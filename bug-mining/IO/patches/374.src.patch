diff --git a/src/main/java/org/apache/commons/io/FilenameUtils.java b/src/main/java/org/apache/commons/io/FilenameUtils.java
index 049c3a710..162b6cd7b 100644
--- a/src/main/java/org/apache/commons/io/FilenameUtils.java
+++ b/src/main/java/org/apache/commons/io/FilenameUtils.java
@@ -28,9 +28,11 @@
 import java.util.stream.Stream;
 
 /**
- * General file name and file path manipulation utilities.
+ * General file name and file path manipulation utilities. The methods in this class
+ * operate on strings that represent relative or absolute paths. Nothing in this class
+ * ever accesses the file system, or depends on whether a path points to a file that exists.
  * <p>
- * When dealing with file names you can hit problems when moving from a Windows
+ * When dealing with file names, you can hit problems when moving from a Windows
  * based development machine to a Unix based production machine.
  * This class aims to help avoid those problems.
  * </p>
@@ -40,18 +42,19 @@
  * {@link java.io.File#File(java.io.File, String) File(File,String)}.
  * </p>
  * <p>
- * Most methods on this class are designed to work the same on both Unix and Windows.
- * Those that don't include 'System', 'Unix' or 'Windows' in their name.
+ * Most methods in this class are designed to work the same on both Unix and Windows.
+ * Those that don't include 'System', 'Unix', or 'Windows' in their name.
  * </p>
  * <p>
- * Most methods recognize both separators (forward and back), and both
+ * Most methods recognize both separators (forward and backslashes), and both
  * sets of prefixes. See the Javadoc of each method for details.
  * </p>
  * <p>
- * This class defines six components within a file name
- * (example C:\dev\project\file.txt):
+ * This class defines six components within a path (sometimes called a file name or a full file name).
+ * Given an absolute Windows path such as C:\dev\project\file.txt they are:
  * </p>
  * <ul>
+ * <li>the full file name, or just file name - C:\dev\project\file.txt</li>
  * <li>the prefix - C:\</li>
  * <li>the path - dev\project\</li>
  * <li>the full path - C:\dev\project\</li>
@@ -60,10 +63,48 @@
  * <li>the extension - txt</li>
  * </ul>
  * <p>
- * Note that this class works best if directory file names end with a separator.
- * If you omit the last separator, it is impossible to determine if the file name
- * corresponds to a file or a directory. As a result, we have chosen to say
- * it corresponds to a file.
+ * Given an absolute Unix path such as /dev/project/file.txt they are:
+ * </p>
+ * <ul>
+ * <li>the full file name, or just file name - /dev/project/file.txt</li>
+ * <li>the prefix - /</li>
+ * <li>the path - dev/project</li>
+ * <li>the full path - /dev/project</li>
+ * <li>the name - file.txt</li>
+ * <li>the base name - file</li>
+ * <li>the extension - txt</li>
+ * </ul>
+ * <p>
+ * Given a relative Windows path such as dev\project\file.txt they are:
+ * </p>
+ * <ul>
+ * <li>the full file name, or just file name - dev\project\file.txt</li>
+ * <li>the prefix - null</li>
+ * <li>the path - dev\project\</li>
+ * <li>the full path - dev\project\</li>
+ * <li>the name - file.txt</li>
+ * <li>the base name - file</li>
+ * <li>the extension - txt</li>
+ * </ul>
+ * <p>
+ * Given an absolute Unix path such as /dev/project/file.txt they are:
+ * </p>
+ * <ul>
+ * <li>the full path, full file name, or just file name - /dev/project/file.txt</li>
+ * <li>the prefix - /</li>
+ * <li>the path - dev/project</li>
+ * <li>the full path - /dev/project</li>
+ * <li>the name - file.txt</li>
+ * <li>the base name - file</li>
+ * <li>the extension - txt</li>
+ * </ul>
+ *
+ *
+ * <p>
+ * This class works best if directory names end with a separator.
+ * If you omit the last separator, it is impossible to determine if the last component
+ * corresponds to a file or a directory. This class treats final components
+ * that do not end with a separator as files, not directories.
  * </p>
  * <p>
  * This class only supports Unix and Windows style names.
@@ -86,12 +127,9 @@
  * ~user               --&gt; "~user/"    --&gt; named user (slash added)
  * </pre>
  * <p>
- * Both prefix styles are matched always, irrespective of the machine that you are
+ * Both prefix styles are matched, irrespective of the machine that you are
  * currently running on.
  * </p>
- * <p>
- * Provenance: Excalibur, Alexandria, Tomcat, Commons-Utils.
- * </p>
  *
  * @since 1.1
  */
@@ -194,7 +232,7 @@ public class FilenameUtils {
      * </p>
      *
      * @param basePath  the base path to attach to, always treated as a path
-     * @param fullFileNameToAdd  the fileName (or path) to attach to the base
+     * @param fullFileNameToAdd  the file name (or path) to attach to the base
      * @return the concatenated path, or null if invalid
      * @throws IllegalArgumentException if the result path contains the null character ({@code U+0000})
      */
@@ -221,7 +259,9 @@ public static String concat(final String basePath, final String fullFileNameToAd
     }
 
     /**
-     * Determines whether the {@code parent} directory contains the {@code child} element (a file or directory).
+     * Determines whether the {@code parent} directory contains the {@code child} (a file or directory).
+     * This does not read from the file system, and there is no guarantee or expectation that
+     * these paths actually exist.
      * <p>
      * The files names are expected to be normalized.
      * </p>
@@ -233,11 +273,9 @@ public static String concat(final String basePath, final String fullFileNameToAd
      * <li>A null child file is not contained in any parent: return false</li>
      * </ul>
      *
-     * @param canonicalParent
-     *            the file to consider as the parent.
-     * @param canonicalChild
-     *            the file to consider as the child.
-     * @return true is the candidate leaf is under by the specified composite. False otherwise.
+     * @param canonicalParent the path string to consider as the parent.
+     * @param canonicalChild the path string to consider as the child.
+     * @return true if the candidate leaf is under the specified composite. False otherwise.
      * @since 2.2
      * @see FileUtils#directoryContains(File, File)
      */
@@ -259,7 +297,7 @@ public static boolean directoryContains(final String canonicalParent, final Stri
     /**
      * Does the work of getting the path.
      *
-     * @param fileName  the fileName
+     * @param fileName  the file name
      * @param includeSeparator  true to include the end separator
      * @return the path
      * @throws IllegalArgumentException if the result path contains the null character ({@code U+0000})
@@ -292,7 +330,7 @@ private static String doGetFullPath(final String fileName, final boolean include
     /**
      * Does the work of getting the path.
      *
-     * @param fileName  the fileName
+     * @param fileName  the file name
      * @param separatorAdd  0 to omit the end separator, 1 to return it
      * @return the path
      * @throws IllegalArgumentException if the result path contains the null character ({@code U+0000})
@@ -316,11 +354,11 @@ private static String doGetPath(final String fileName, final int separatorAdd) {
     /**
      * Internal method to perform the normalization.
      *
-     * @param fileName  the fileName
+     * @param fileName  the file name
      * @param separator The separator character to use
      * @param keepSeparator  true to keep the final separator
      * @return the normalized fileName
-     * @throws IllegalArgumentException if the fileName contains the null character ({@code U+0000})
+     * @throws IllegalArgumentException if the file name contains the null character ({@code U+0000})
      */
     private static String doNormalize(final String fileName, final char separator, final boolean keepSeparator) {
         if (fileName == null) {
@@ -421,15 +459,15 @@ private static String doNormalize(final String fileName, final char separator, f
     }
 
     /**
-     * Checks whether two fileNames are equal exactly.
+     * Checks whether two file names are exactly equal.
      * <p>
-     * No processing is performed on the fileNames other than comparison,
-     * thus this is merely a null-safe case-sensitive equals.
+     * No processing is performed on the file names other than comparison.
+     * This is merely a null-safe case-sensitive string equality.
      * </p>
      *
-     * @param fileName1  the first fileName to query, may be null
-     * @param fileName2  the second fileName to query, may be null
-     * @return true if the fileNames are equal, null equals null
+     * @param fileName1  the first file name, may be null
+     * @param fileName2  the second file name, may be null
+     * @return true if the file names are equal, null equals null
      * @see IOCase#SENSITIVE
      */
     public static boolean equals(final String fileName1, final String fileName2) {
@@ -437,14 +475,14 @@ public static boolean equals(final String fileName1, final String fileName2) {
     }
 
     /**
-     * Checks whether two fileNames are equal, optionally normalizing and providing
+     * Checks whether two file names are equal, optionally normalizing and providing
      * control over the case-sensitivity.
      *
-     * @param fileName1  the first fileName to query, may be null
-     * @param fileName2  the second fileName to query, may be null
-     * @param normalize  whether to normalize the fileNames
+     * @param fileName1  the first file name, may be null
+     * @param fileName2  the second file name, may be null
+     * @param normalize  whether to normalize the file names
      * @param ioCase  what case sensitivity rule to use, null means case-sensitive
-     * @return true if the fileNames are equal, null equals null
+     * @return true if the file names are equal, null equals null
      * @since 1.3
      */
     public static boolean equals(String fileName1, String fileName2, final boolean normalize, final IOCase ioCase) {
@@ -466,15 +504,15 @@ public static boolean equals(String fileName1, String fileName2, final boolean n
     }
 
     /**
-     * Checks whether two fileNames are equal after both have been normalized.
+     * Checks whether two file names are equal after both have been normalized.
      * <p>
-     * Both fileNames are first passed to {@link #normalize(String)}.
+     * Both file names are first passed to {@link #normalize(String)}.
      * The check is then performed in a case-sensitive manner.
      * </p>
      *
-     * @param fileName1  the first fileName to query, may be null
-     * @param fileName2  the second fileName to query, may be null
-     * @return true if the fileNames are equal, null equals null
+     * @param fileName1  the first file name, may be null
+     * @param fileName2  the second file name, may be null
+     * @return true if the file names are equal, null equals null
      * @see IOCase#SENSITIVE
      */
     public static boolean equalsNormalized(final String fileName1, final String fileName2) {
@@ -482,17 +520,17 @@ public static boolean equalsNormalized(final String fileName1, final String file
     }
 
     /**
-     * Checks whether two fileNames are equal after both have been normalized
-     * and using the case rules of the system.
+     * Checks whether two file names are equal using the case rules of the system
+     * after both have been normalized.
      * <p>
-     * Both fileNames are first passed to {@link #normalize(String)}.
-     * The check is then performed case-sensitive on Unix and
-     * case-insensitive on Windows.
+     * Both file names are first passed to {@link #normalize(String)}.
+     * The check is then performed case-sensitively on Unix and
+     * case-insensitively on Windows.
      * </p>
      *
-     * @param fileName1  the first fileName to query, may be null
-     * @param fileName2  the second fileName to query, may be null
-     * @return true if the fileNames are equal, null equals null
+     * @param fileName1  the first file name, may be null
+     * @param fileName2  the second file name, may be null
+     * @return true if the file names are equal, null equals null
      * @see IOCase#SYSTEM
      */
     public static boolean equalsNormalizedOnSystem(final String fileName1, final String fileName2) {
@@ -500,15 +538,15 @@ public static boolean equalsNormalizedOnSystem(final String fileName1, final Str
     }
 
     /**
-     * Checks whether two fileNames are equal using the case rules of the system.
+     * Checks whether two file names are equal using the case rules of the system.
      * <p>
-     * No processing is performed on the fileNames other than comparison.
+     * No processing is performed on the file names other than comparison.
      * The check is case-sensitive on Unix and case-insensitive on Windows.
      * </p>
      *
-     * @param fileName1  the first fileName to query, may be null
-     * @param fileName2  the second fileName to query, may be null
-     * @return true if the fileNames are equal, null equals null
+     * @param fileName1  the first file name, may be null
+     * @param fileName2  the second file name, may be null
+     * @return true if the file names are equal, null equals null
      * @see IOCase#SYSTEM
      */
     public static boolean equalsOnSystem(final String fileName1, final String fileName2) {
@@ -532,7 +570,7 @@ static char flipSeparator(final char ch) {
     }
 
     /**
-     * Special handling for NTFS ADS: Don't accept colon in the fileName.
+     * Special handling for NTFS ADS: Don't accept colon in the file name.
      *
      * @param fileName a file name
      * @return ADS offsets.
@@ -554,13 +592,15 @@ private static int getAdsCriticalOffset(final String fileName) {
     }
 
     /**
-     * Gets the base name, minus the full path and extension, from a full fileName.
+     * Gets the base name, minus the full path and extension, from a full file name.
      * <p>
-     * This method will handle a file in either Unix or Windows format.
+     * This method will handle a path in either Unix or Windows format.
      * The text after the last forward or backslash and before the last dot is returned.
      * </p>
      * <pre>
      * a/b/c.txt --&gt; c
+     * a\b\c.txt --&gt; c
+     * a/b/c.foo.txt --&gt; c.foo
      * a.txt     --&gt; a
      * a/b/c     --&gt; c
      * a/b/c/    --&gt; ""
@@ -569,9 +609,9 @@ private static int getAdsCriticalOffset(final String fileName) {
      * The output will be the same irrespective of the machine that the code is running on.
      * </p>
      *
-     * @param fileName  the fileName to query, null returns null
+     * @param fileName  the file name, null returns null
      * @return the name of the file without the path, or an empty string if none exists
-     * @throws IllegalArgumentException if the fileName contains the null character ({@code U+0000})
+     * @throws IllegalArgumentException if the file name contains the null character ({@code U+0000})
      */
     public static String getBaseName(final String fileName) {
         return removeExtension(getName(fileName));
@@ -580,7 +620,7 @@ public static String getBaseName(final String fileName) {
     /**
      * Gets the extension of a fileName.
      * <p>
-     * This method returns the textual part of the fileName after the last dot.
+     * This method returns the textual part of the file name after the last dot.
      * There must be no directory separator after the dot.
      * </p>
      * <pre>
@@ -597,14 +637,14 @@ public static String getBaseName(final String fileName) {
      * <b>Note:</b> This method used to have a hidden problem for names like "foo.exe:bar.txt".
      * In this case, the name wouldn't be the name of a file, but the identifier of an
      * alternate data stream (bar.txt) on the file foo.exe. The method used to return
-     * ".txt" here, which would be misleading. Commons IO 2.7, and later versions, are throwing
+     * ".txt" here, which would be misleading. Commons IO 2.7 and later throw
      * an {@link IllegalArgumentException} for names like this.
      * </p>
      *
-     * @param fileName the fileName to retrieve the extension of.
+     * @param fileName the file name to retrieve the extension of.
      * @return the extension of the file or an empty string if none exists or {@code null}
-     * if the fileName is {@code null}.
-     * @throws IllegalArgumentException <b>Windows only:</b> The fileName parameter is, in fact,
+     * if the file name is {@code null}.
+     * @throws IllegalArgumentException <b>Windows only:</b> the file name parameter is, in fact,
      * the identifier of an Alternate Data Stream, for example "foo.exe:bar.txt".
      */
     public static String getExtension(final String fileName) throws IllegalArgumentException {
@@ -619,7 +659,7 @@ public static String getExtension(final String fileName) throws IllegalArgumentE
     }
 
     /**
-     * Gets the full path from a full fileName, which is the prefix + path.
+     * Gets the full path (prefix + path) from a full file name.
      * <p>
      * This method will handle a file in either Unix or Windows format.
      * The method is entirely text based, and returns the text before and
@@ -642,7 +682,7 @@ public static String getExtension(final String fileName) throws IllegalArgumentE
      * The output will be the same irrespective of the machine that the code is running on.
      * </p>
      *
-     * @param fileName  the fileName to query, null returns null
+     * @param fileName  the file name, null returns null
      * @return the path of the file, an empty string if none exists, null if invalid
      * @throws IllegalArgumentException if the result path contains the null character ({@code U+0000})
      */
@@ -651,8 +691,8 @@ public static String getFullPath(final String fileName) {
     }
 
     /**
-     * Gets the full path from a full fileName, which is the prefix + path,
-     * and also excluding the final directory separator.
+     * Gets the full path (prefix + path) from a full file name,
+     * excluding the final directory separator.
      * <p>
      * This method will handle a file in either Unix or Windows format.
      * The method is entirely text based, and returns the text before the
@@ -675,7 +715,7 @@ public static String getFullPath(final String fileName) {
      * The output will be the same irrespective of the machine that the code is running on.
      * </p>
      *
-     * @param fileName  the fileName to query, null returns null
+     * @param fileName  the file name, null returns null
      * @return the path of the file, an empty string if none exists, null if invalid
      * @throws IllegalArgumentException if the result path contains the null character ({@code U+0000})
      */
@@ -684,13 +724,14 @@ public static String getFullPathNoEndSeparator(final String fileName) {
     }
 
     /**
-     * Gets the name minus the path from a full fileName.
+     * Gets the name minus the path from a full file name.
      * <p>
      * This method will handle a file in either Unix or Windows format.
      * The text after the last forward or backslash is returned.
      * </p>
      * <pre>
      * a/b/c.txt --&gt; c.txt
+     * a\b\c.txt --&gt; c.txt
      * a.txt     --&gt; a.txt
      * a/b/c     --&gt; c
      * a/b/c/    --&gt; ""
@@ -699,9 +740,9 @@ public static String getFullPathNoEndSeparator(final String fileName) {
      * The output will be the same irrespective of the machine that the code is running on.
      * </p>
      *
-     * @param fileName  the fileName to query, null returns null
+     * @param fileName  the file name, null returns null
      * @return the name of the file without the path, or an empty string if none exists
-     * @throws IllegalArgumentException if the fileName contains the null character ({@code U+0000})
+     * @throws IllegalArgumentException if the file name contains the null character ({@code U+0000})
      */
     public static String getName(final String fileName) {
         if (fileName == null) {
@@ -711,7 +752,7 @@ public static String getName(final String fileName) {
     }
 
     /**
-     * Gets the path from a full fileName, which excludes the prefix.
+     * Gets the path from a full file name, which excludes the prefix and the name.
      * <p>
      * This method will handle a file in either Unix or Windows format.
      * The method is entirely text based, and returns the text before and
@@ -732,7 +773,7 @@ public static String getName(final String fileName) {
      * See {@link #getFullPath(String)} for the method that retains the prefix.
      * </p>
      *
-     * @param fileName  the fileName to query, null returns null
+     * @param fileName  the file name, null returns null
      * @return the path of the file, an empty string if none exists, null if invalid
      * @throws IllegalArgumentException if the result path contains the null character ({@code U+0000})
      */
@@ -741,7 +782,7 @@ public static String getPath(final String fileName) {
     }
 
     /**
-     * Gets the path from a full fileName, which excludes the prefix, and
+     * Gets the path (which excludes the prefix) from a full file name, and
      * also excluding the final directory separator.
      * <p>
      * This method will handle a file in either Unix or Windows format.
@@ -763,7 +804,7 @@ public static String getPath(final String fileName) {
      * See {@link #getFullPathNoEndSeparator(String)} for the method that retains the prefix.
      * </p>
      *
-     * @param fileName  the fileName to query, null returns null
+     * @param fileName  the file name, null returns null
      * @return the path of the file, an empty string if none exists, null if invalid
      * @throws IllegalArgumentException if the result path contains the null character ({@code U+0000})
      */
@@ -772,11 +813,10 @@ public static String getPathNoEndSeparator(final String fileName) {
     }
 
     /**
-     * Gets the prefix from a full fileName, such as {@code C:/}
-     * or {@code ~/}.
+     * Gets the prefix such as {@code C:/} or {@code ~/} from a full file name,
      * <p>
      * This method will handle a file in either Unix or Windows format.
-     * The prefix includes the first slash in the full fileName where applicable.
+     * The prefix includes the first slash in the full file name where applicable.
      * </p>
      * <pre>
      * Windows:
@@ -799,7 +839,7 @@ public static String getPathNoEndSeparator(final String fileName) {
      * ie. both Unix and Windows prefixes are matched regardless.
      * </p>
      *
-     * @param fileName  the fileName to query, null returns null
+     * @param fileName  the file name, null returns null
      * @return the prefix of the file, null if invalid
      * @throws IllegalArgumentException if the result contains the null character ({@code U+0000})
      */
@@ -819,12 +859,12 @@ public static String getPrefix(final String fileName) {
     }
 
     /**
-     * Returns the length of the fileName prefix, such as {@code C:/} or {@code ~/}.
+     * Returns the length of the file name prefix, such as {@code C:/} or {@code ~/}.
      * <p>
      * This method will handle a file in either Unix or Windows format.
      * </p>
      * <p>
-     * The prefix length includes the first slash in the full fileName
+     * The prefix length includes the first slash in the full file name
      * if applicable. Thus, it is possible that the length returned is greater
      * than the length of the input string.
      * </p>
@@ -855,10 +895,10 @@ public static String getPrefix(final String fileName) {
      * <p>
      * Note that a leading // (or \\) is used to indicate a UNC name on Windows.
      * These must be followed by a server name, so double-slashes are not collapsed
-     * to a single slash at the start of the fileName.
+     * to a single slash at the start of the file name.
      * </p>
      *
-     * @param fileName  the fileName to find the prefix in, null returns -1
+     * @param fileName  the file name to find the prefix in, null returns -1
      * @return the length of the prefix, -1 if invalid or null
      */
     public static int getPrefixLength(final String fileName) {
@@ -939,9 +979,9 @@ public static int getPrefixLength(final String fileName) {
      * an {@link IllegalArgumentException} for names like this.
      *
      * @param fileName
-     *            the fileName to find the last extension separator in, null returns -1
+     *            the file name to find the last extension separator in, null returns -1
      * @return the index of the last extension separator character, or -1 if there is no such character
-     * @throws IllegalArgumentException <b>Windows only:</b> The fileName parameter is, in fact,
+     * @throws IllegalArgumentException <b>Windows only:</b> the file name parameter is, in fact,
      * the identifier of an Alternate Data Stream, for example "foo.exe:bar.txt".
      */
     public static int indexOfExtension(final String fileName) throws IllegalArgumentException {
@@ -949,7 +989,7 @@ public static int indexOfExtension(final String fileName) throws IllegalArgument
             return NOT_FOUND;
         }
         if (isSystemWindows()) {
-            // Special handling for NTFS ADS: Don't accept colon in the fileName.
+            // Special handling for NTFS ADS: Don't accept colon in the file name.
             final int offset = fileName.indexOf(':', getAdsCriticalOffset(fileName));
             if (offset != -1) {
                 throw new IllegalArgumentException("NTFS ADS separator (':') in file name is forbidden.");
@@ -968,7 +1008,7 @@ public static int indexOfExtension(final String fileName) throws IllegalArgument
      * <p>
      * The output will be the same irrespective of the machine that the code is running on.
      *
-     * @param fileName  the fileName to find the last path separator in, null returns -1
+     * @param fileName  the file name to find the last path separator in, null returns -1
      * @return the index of the last separator character, or -1 if there
      * is no such character
      */
@@ -986,16 +1026,16 @@ private static boolean isEmpty(final String string) {
     }
 
     /**
-     * Checks whether the extension of the fileName is one of those specified.
+     * Checks whether the extension of the file name is one of those specified.
      * <p>
-     * This method obtains the extension as the textual part of the fileName
+     * This method obtains the extension as the textual part of the file name
      * after the last dot. There must be no directory separator after the dot.
      * The extension check is case-sensitive on all platforms.
      *
-     * @param fileName  the fileName to query, null returns false
+     * @param fileName  the file name, null returns false
      * @param extensions  the extensions to check for, null checks for no extension
-     * @return true if the fileName is one of the extensions
-     * @throws IllegalArgumentException if the fileName contains the null character ({@code U+0000})
+     * @return true if the file name is one of the extensions
+     * @throws IllegalArgumentException if the file name contains the null character ({@code U+0000})
      */
     public static boolean isExtension(final String fileName, final Collection<String> extensions) {
         if (fileName == null) {
@@ -1010,16 +1050,16 @@ public static boolean isExtension(final String fileName, final Collection<String
     }
 
     /**
-     * Checks whether the extension of the fileName is that specified.
+     * Checks whether the extension of the file name is that specified.
      * <p>
-     * This method obtains the extension as the textual part of the fileName
+     * This method obtains the extension as the textual part of the file name
      * after the last dot. There must be no directory separator after the dot.
      * The extension check is case-sensitive on all platforms.
      *
-     * @param fileName  the fileName to query, null returns false
+     * @param fileName  the file name, null returns false
      * @param extension  the extension to check for, null or empty checks for no extension
-     * @return true if the fileName has the specified extension
-     * @throws IllegalArgumentException if the fileName contains the null character ({@code U+0000})
+     * @return true if the file name has the specified extension
+     * @throws IllegalArgumentException if the file name contains the null character ({@code U+0000})
      */
     public static boolean isExtension(final String fileName, final String extension) {
         if (fileName == null) {
@@ -1034,16 +1074,16 @@ public static boolean isExtension(final String fileName, final String extension)
     }
 
     /**
-     * Checks whether the extension of the fileName is one of those specified.
+     * Checks whether the extension of the file name is one of those specified.
      * <p>
-     * This method obtains the extension as the textual part of the fileName
+     * This method obtains the extension as the textual part of the file name
      * after the last dot. There must be no directory separator after the dot.
      * The extension check is case-sensitive on all platforms.
      *
-     * @param fileName  the fileName to query, null returns false
+     * @param fileName  the file name, null returns false
      * @param extensions  the extensions to check for, null checks for no extension
-     * @return true if the fileName is one of the extensions
-     * @throws IllegalArgumentException if the fileName contains the null character ({@code U+0000})
+     * @return true if the file name is one of the extensions
+     * @throws IllegalArgumentException if the file name contains the null character ({@code U+0000})
      */
     public static boolean isExtension(final String fileName, final String... extensions) {
         if (fileName == null) {
@@ -1223,8 +1263,7 @@ private static boolean isValidHostName(final String name) {
      * A double slash will be merged to a single slash (but UNC names are handled).
      * A single dot path segment will be removed.
      * A double dot will cause that path segment and the one before to be removed.
-     * If the double dot has no parent path segment to work with, {@code null}
-     * is returned.
+     * If the double dot has no parent path segment, {@code null} is returned.
      * <p>
      * The output will be the same on both Unix and Windows except
      * for the separator character.
@@ -1247,11 +1286,11 @@ private static boolean isValidHostName(final String name) {
      * ~/foo/../bar/        --&gt;   ~/bar/
      * ~/../bar             --&gt;   null
      * </pre>
-     * (Note the file separator returned will be correct for Windows/Unix)
+     * (Note the file separator will be correct for Windows/Unix.)
      *
-     * @param fileName  the fileName to normalize, null returns null
+     * @param fileName  the file name to normalize, null returns null
      * @return the normalized fileName, or null if invalid
-     * @throws IllegalArgumentException if the fileName contains the null character ({@code U+0000})
+     * @throws IllegalArgumentException if the file name contains the null character ({@code U+0000})
      */
     public static String normalize(final String fileName) {
         return doNormalize(fileName, SYSTEM_NAME_SEPARATOR, true);
@@ -1295,11 +1334,11 @@ public static String normalize(final String fileName) {
      * The output will be the same on both Unix and Windows including
      * the separator character.
      *
-     * @param fileName  the fileName to normalize, null returns null
+     * @param fileName  the file name to normalize, null returns null
      * @param unixSeparator {@code true} if a Unix separator should
      * be used or {@code false} if a Windows separator should be used.
      * @return the normalized fileName, or null if invalid
-     * @throws IllegalArgumentException if the fileName contains the null character ({@code U+0000})
+     * @throws IllegalArgumentException if the file name contains the null character ({@code U+0000})
      * @since 2.0
      */
     public static String normalize(final String fileName, final boolean unixSeparator) {
@@ -1344,9 +1383,9 @@ public static String normalize(final String fileName, final boolean unixSeparato
      * </pre>
      * (Note the file separator returned will be correct for Windows/Unix)
      *
-     * @param fileName  the fileName to normalize, null returns null
+     * @param fileName  the file name to normalize, null returns null
      * @return the normalized fileName, or null if invalid
-     * @throws IllegalArgumentException if the fileName contains the null character ({@code U+0000})
+     * @throws IllegalArgumentException if the file name contains the null character ({@code U+0000})
      */
     public static String normalizeNoEndSeparator(final String fileName) {
         return doNormalize(fileName, SYSTEM_NAME_SEPARATOR, false);
@@ -1389,11 +1428,11 @@ public static String normalizeNoEndSeparator(final String fileName) {
      * ~/../bar             --&gt;   null
      * </pre>
      *
-     * @param fileName  the fileName to normalize, null returns null
+     * @param fileName  the file name to normalize, null returns null
      * @param unixSeparator {@code true} if a Unix separator should
      * be used or {@code false} if a Windows separator should be used.
      * @return the normalized fileName, or null if invalid
-     * @throws IllegalArgumentException if the fileName contains the null character ({@code U+0000})
+     * @throws IllegalArgumentException if the file name contains the null character ({@code U+0000})
      * @since 2.0
      */
     public static String normalizeNoEndSeparator(final String fileName, final boolean unixSeparator) {
@@ -1403,20 +1442,22 @@ public static String normalizeNoEndSeparator(final String fileName, final boolea
     /**
      * Removes the extension from a fileName.
      * <p>
-     * This method returns the textual part of the fileName before the last dot.
+     * This method returns the textual part of the file name before the last dot.
      * There must be no directory separator after the dot.
      * <pre>
      * foo.txt    --&gt; foo
+     * .txt       --&gt; "" (empty string)
      * a\b\c.jpg  --&gt; a\b\c
+     * /a/b/c.jpg --&gt; /a/b/c
      * a\b\c      --&gt; a\b\c
      * a.b\c      --&gt; a.b\c
      * </pre>
      * <p>
      * The output will be the same irrespective of the machine that the code is running on.
      *
-     * @param fileName  the fileName to query, null returns null
-     * @return the fileName minus the extension
-     * @throws IllegalArgumentException if the fileName contains the null character ({@code U+0000})
+     * @param fileName  the file name, null returns null
+     * @return the file name minus the extension
+     * @throws IllegalArgumentException if the file name contains the null character ({@code U+0000})
      */
     public static String removeExtension(final String fileName) {
         if (fileName == null) {
@@ -1434,7 +1475,7 @@ public static String removeExtension(final String fileName) {
     /**
      * Checks the input for null characters ({@code U+0000}), a sign of unsanitized data being passed to file level functions.
      *
-     * This may be used for poison byte attacks.
+     * This may be used to defend against poison byte attacks.
      *
      * @param path the path to check
      * @return The input
@@ -1548,9 +1589,9 @@ private static char toSeparator(final boolean unixSeparator) {
      * </pre>
      * N.B. the sequence "*?" does not work properly at present in match strings.
      *
-     * @param fileName  the fileName to match on
+     * @param fileName  the file name to match on
      * @param wildcardMatcher  the wildcard string to match against
-     * @return true if the fileName matches the wildcard string
+     * @return true if the file name matches the wildcard string
      * @see IOCase#SENSITIVE
      */
     public static boolean wildcardMatch(final String fileName, final String wildcardMatcher) {
@@ -1565,10 +1606,10 @@ public static boolean wildcardMatch(final String fileName, final String wildcard
      * single or multiple (zero or more) wildcard characters.
      * N.B. the sequence "*?" does not work properly at present in match strings.
      *
-     * @param fileName  the fileName to match on
+     * @param fileName  the file name to match on
      * @param wildcardMatcher  the wildcard string to match against
      * @param ioCase  what case sensitivity rule to use, null means case-sensitive
-     * @return true if the fileName matches the wildcard string
+     * @return true if the file name matches the wildcard string
      * @since 1.3
      */
     public static boolean wildcardMatch(final String fileName, final String wildcardMatcher, IOCase ioCase) {
@@ -1666,9 +1707,9 @@ public static boolean wildcardMatch(final String fileName, final String wildcard
      * </pre>
      * N.B. the sequence "*?" does not work properly at present in match strings.
      *
-     * @param fileName  the fileName to match on
+     * @param fileName  the file name to match on
      * @param wildcardMatcher  the wildcard string to match against
-     * @return true if the fileName matches the wildcard string
+     * @return true if the file name matches the wildcard string
      * @see IOCase#SYSTEM
      */
     public static boolean wildcardMatchOnSystem(final String fileName, final String wildcardMatcher) {
