diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index e46186b26..b948a9e05 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -66,6 +66,11 @@ The <action> type attribute can be add,update,fix,remove.
       <action dev="ggregory" type="fix" due-to="Gary Gregory">
         AccumulatorPathVisitor does not track directories properly.
       </action>
+      <action issue="IO-597" dev="ggregory" type="fix" due-to="Gary Gregory, Arvind, Rob Spoor">
+        FileUtils.iterateFiles runs out of memory when executed for a directory with large number of files.
+        Re-implement FileUtils' iterateFiles(), iterateFilesAndDirs(), listFiles(), listFilesAndDirs() to use NIO 
+        file tree walking instead of IO file listings to avoid memory consumption issues on large file trees.
+      </action>
       <!-- ADD -->
       <action dev="ggregory" type="add" due-to="Gary Gregory">
         Add FileSystemProviders class.
diff --git a/src/main/java/org/apache/commons/io/FileUtils.java b/src/main/java/org/apache/commons/io/FileUtils.java
index af677b305..bcfd38930 100644
--- a/src/main/java/org/apache/commons/io/FileUtils.java
+++ b/src/main/java/org/apache/commons/io/FileUtils.java
@@ -45,18 +45,23 @@
 import java.time.chrono.ChronoZonedDateTime;
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.Collections;
 import java.util.Date;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Objects;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
 import java.util.zip.CRC32;
 import java.util.zip.CheckedInputStream;
 import java.util.zip.Checksum;
 
+import org.apache.commons.io.file.AccumulatorPathVisitor;
 import org.apache.commons.io.file.Counters;
+import org.apache.commons.io.file.PathFilter;
 import org.apache.commons.io.file.PathUtils;
-import org.apache.commons.io.filefilter.DirectoryFileFilter;
-import org.apache.commons.io.filefilter.FalseFileFilter;
+import org.apache.commons.io.filefilter.FileEqualsFileFilter;
+import org.apache.commons.io.filefilter.FileFileFilter;
 import org.apache.commons.io.filefilter.IOFileFilter;
 import org.apache.commons.io.filefilter.SuffixFileFilter;
 import org.apache.commons.io.filefilter.TrueFileFilter;
@@ -1583,65 +1588,6 @@ public static String getUserDirectoryPath() {
         return System.getProperty("user.home");
     }
 
-    /**
-     * Finds files within a given directory (and optionally its
-     * subdirectories). All files found are filtered by an IOFileFilter.
-     *
-     * @param files                 the collection of files found.
-     * @param directory             the directory to search in.
-     * @param filter                the filter to apply to files and directories.
-     * @param includeSubDirectories indicates if will include the subdirectories themselves
-     */
-    private static void innerListFiles(final Collection<File> files, final File directory,
-                                       final IOFileFilter filter, final boolean includeSubDirectories) {
-        final File[] found = directory.listFiles((FileFilter) filter);
-
-        if (found != null) {
-            for (final File file : found) {
-                if (file.isDirectory()) {
-                    if (includeSubDirectories) {
-                        files.add(file);
-                    }
-                    innerListFiles(files, file, filter, includeSubDirectories);
-                } else {
-                    files.add(file);
-                }
-            }
-        }
-    }
-
-    /**
-     * Finds files within a given directory (and optionally its
-     * subdirectories). All files found are filtered by an IOFileFilter.
-     *
-     * @param directory             the directory to search in
-     * @param fileFilter            filter to apply when finding files.
-     * @param dirFilter             optional filter to apply when finding subdirectories.
-     *                              If this parameter is {@code null}, subdirectories will not be included in the
-     *                              search. Use TrueFileFilter.INSTANCE to match all directories.
-     * @param includeSubDirectories indicates if will include the subdirectories themselves
-     * @return a collection of java.io.File with the matching files
-     * @see org.apache.commons.io.FileUtils#listFiles
-     * @see org.apache.commons.io.filefilter.FileFilterUtils
-     * @see org.apache.commons.io.filefilter.NameFileFilter
-     */
-    private static Collection<File> innerListFilesOrDirectories(
-            final File directory, final IOFileFilter fileFilter, final IOFileFilter dirFilter,
-            final boolean includeSubDirectories) {
-        validateListFilesParameters(directory, fileFilter);
-
-        final IOFileFilter effFileFilter = setUpEffectiveFileFilter(fileFilter);
-        final IOFileFilter effDirFilter = setUpEffectiveDirFilter(dirFilter);
-
-        //Find files
-        final Collection<File> files = new java.util.LinkedList<>();
-        if (includeSubDirectories) {
-            files.add(directory);
-        }
-        innerListFiles(files, directory, effFileFilter.or(effDirFilter), includeSubDirectories);
-        return files;
-    }
-
     /**
      * Tests if the specified {@code File} is newer than the specified {@code ChronoLocalDate}
      * at the current time.
@@ -2006,12 +1952,14 @@ public static boolean isSymlink(final File file) {
     }
 
     /**
-     * Allows iteration over the files in given directory (and optionally
+     * Iterates over the files in given directory (and optionally
      * its subdirectories).
      * <p>
-     * All files found are filtered by an IOFileFilter. This method is
-     * based on {@link #listFiles(File, IOFileFilter, IOFileFilter)},
-     * which supports Iterable ('foreach' loop).
+     * The resulting iterator MUST be consumed in its entirety in order to close its underlying stream.
+     * </p>
+     * <p>
+     * <p>
+     * All files found are filtered by an IOFileFilter.
      * </p>
      *
      * @param directory  the directory to search in
@@ -2024,16 +1972,18 @@ public static boolean isSymlink(final File file) {
      * @see org.apache.commons.io.filefilter.NameFileFilter
      * @since 1.2
      */
-    public static Iterator<File> iterateFiles(
-            final File directory, final IOFileFilter fileFilter, final IOFileFilter dirFilter) {
+    public static Iterator<File> iterateFiles(final File directory, final IOFileFilter fileFilter,
+        final IOFileFilter dirFilter) {
         return listFiles(directory, fileFilter, dirFilter).iterator();
     }
 
     /**
-     * Allows iteration over the files in a given directory (and optionally
-     * its subdirectories) which match an array of extensions. This method
-     * is based on {@link #listFiles(File, String[], boolean)},
-     * which supports Iterable ('foreach' loop).
+     * Iterates over the files in a given directory (and optionally
+     * its subdirectories) which match an array of extensions.
+     * <p>
+     * The resulting iterator MUST be consumed in its entirety in order to close its underlying stream.
+     * </p>
+     * <p>
      *
      * @param directory  the directory to search in
      * @param extensions an array of extensions, ex. {"java","xml"}. If this
@@ -2042,18 +1992,23 @@ public static Iterator<File> iterateFiles(
      * @return an iterator of java.io.File with the matching files
      * @since 1.2
      */
-    public static Iterator<File> iterateFiles(
-            final File directory, final String[] extensions, final boolean recursive) {
-        return listFiles(directory, extensions, recursive).iterator();
+    public static Iterator<File> iterateFiles(final File directory, final String[] extensions,
+        final boolean recursive) {
+        try {
+            return StreamIterator.iterator(streamFiles(directory, recursive, extensions));
+        } catch (final IOException e) {
+            throw new IllegalStateException(e);
+        }
     }
 
     /**
-     * Allows iteration over the files in given directory (and optionally
+     * Iterates over the files in given directory (and optionally
      * its subdirectories).
      * <p>
-     * All files found are filtered by an IOFileFilter. This method is
-     * based on {@link #listFilesAndDirs(File, IOFileFilter, IOFileFilter)},
-     * which supports Iterable ('foreach' loop).
+     * The resulting iterator MUST be consumed in its entirety in order to close its underlying stream.
+     * </p>
+     * <p>
+     * All files found are filtered by an IOFileFilter.
      * </p>
      * <p>
      * The resulting iterator includes the subdirectories themselves.
@@ -2070,7 +2025,7 @@ public static Iterator<File> iterateFiles(
      * @since 2.2
      */
     public static Iterator<File> iterateFilesAndDirs(final File directory, final IOFileFilter fileFilter,
-                                                     final IOFileFilter dirFilter) {
+        final IOFileFilter dirFilter) {
         return listFilesAndDirs(directory, fileFilter, dirFilter).iterator();
     }
 
@@ -2132,6 +2087,17 @@ public static LineIterator lineIterator(final File file, final String charsetNam
         }
     }
 
+    private static AccumulatorPathVisitor listAccumulate(final File directory, final IOFileFilter fileFilter,
+        final IOFileFilter dirFilter) throws IOException {
+        final boolean isDirFilterSet = dirFilter != null;
+        final FileEqualsFileFilter rootFileFilter = new FileEqualsFileFilter(directory);
+        final PathFilter dirPathFilter = isDirFilterSet ? rootFileFilter.or(dirFilter) : rootFileFilter;
+        final AccumulatorPathVisitor visitor = new AccumulatorPathVisitor(Counters.noopPathCounters(), fileFilter,
+            dirPathFilter);
+        Files.walkFileTree(directory.toPath(), Collections.emptySet(), toMaxDepth(isDirFilterSet), visitor);
+        return visitor;
+    }
+
     /**
      * Finds files within a given directory (and optionally its
      * subdirectories). All files found are filtered by an IOFileFilter.
@@ -2162,8 +2128,13 @@ public static LineIterator lineIterator(final File file, final String charsetNam
      * @see org.apache.commons.io.filefilter.NameFileFilter
      */
     public static Collection<File> listFiles(
-            final File directory, final IOFileFilter fileFilter, final IOFileFilter dirFilter) {
-        return innerListFilesOrDirectories(directory, fileFilter, dirFilter, false);
+        final File directory, final IOFileFilter fileFilter, final IOFileFilter dirFilter) {
+        try {
+            final AccumulatorPathVisitor visitor = listAccumulate(directory, fileFilter, dirFilter);
+            return visitor.getFileList().stream().map(Path::toFile).collect(Collectors.toList());
+        } catch (IOException e) {
+            throw new IllegalArgumentException(e);
+        }
     }
 
     /**
@@ -2176,19 +2147,13 @@ public static Collection<File> listFiles(
      * @param recursive  if true all subdirectories are searched as well
      * @return a collection of java.io.File with the matching files
      */
-    public static Collection<File> listFiles(
-            final File directory, final String[] extensions, final boolean recursive) {
-        IOFileFilter filter;
-        if (extensions == null) {
-            filter = TrueFileFilter.INSTANCE;
-        } else {
-            filter = new SuffixFileFilter(toSuffixes(extensions));
+    public static Collection<File> listFiles(final File directory, final String[] extensions, final boolean recursive) {
+        try {
+            return toList(streamFiles(directory, recursive, extensions));
+        } catch (final IOException e) {
+            throw new IllegalArgumentException(e);
         }
-        return listFiles(directory, filter,
-                recursive ? TrueFileFilter.INSTANCE : FalseFileFilter.INSTANCE);
     }
-
-
     /**
      * Finds files within a given directory (and optionally its
      * subdirectories). All files found are filtered by an IOFileFilter.
@@ -2209,8 +2174,15 @@ public static Collection<File> listFiles(
      * @since 2.2
      */
     public static Collection<File> listFilesAndDirs(
-            final File directory, final IOFileFilter fileFilter, final IOFileFilter dirFilter) {
-        return innerListFilesOrDirectories(directory, fileFilter, dirFilter, true);
+        final File directory, final IOFileFilter fileFilter, final IOFileFilter dirFilter) {
+        try {
+            final AccumulatorPathVisitor visitor = listAccumulate(directory, fileFilter, dirFilter);
+            final List<Path> list = visitor.getFileList();
+            list.addAll(visitor.getDirList());
+            return list.stream().map(Path::toFile).collect(Collectors.toList());
+        } catch (IOException e) {
+            throw new IllegalStateException(e);
+        }
     }
 
     /**
@@ -2407,7 +2379,6 @@ public static FileInputStream openInputStream(final File file) throws IOExceptio
         return new FileInputStream(file);
     }
 
-
     /**
      * Opens a {@link FileOutputStream} for the specified file, checking and
      * creating the parent directory if it does not exist.
@@ -2509,6 +2480,7 @@ public static String readFileToString(final File file) throws IOException {
         return readFileToString(file, Charset.defaultCharset());
     }
 
+
     /**
      * Reads the contents of a file into a String.
      * The file is always closed.
@@ -2599,26 +2571,6 @@ private static void setLastModified(final File sourceFile, final File targetFile
         }
     }
 
-    /**
-     * Returns a filter that accepts directories in addition to the {@link File} objects accepted by the given filter.
-     *
-     * @param dirFilter a base filter to add to
-     * @return a filter that accepts directories
-     */
-    private static IOFileFilter setUpEffectiveDirFilter(final IOFileFilter dirFilter) {
-        return dirFilter == null ? FalseFileFilter.INSTANCE : dirFilter.and(DirectoryFileFilter.INSTANCE);
-    }
-
-    /**
-     * Returns a filter that accepts files in addition to the {@link File} objects accepted by the given filter.
-     *
-     * @param fileFilter a base filter to add to
-     * @return a filter that accepts files
-     */
-    private static IOFileFilter setUpEffectiveFileFilter(final IOFileFilter fileFilter) {
-        return fileFilter.and(DirectoryFileFilter.INSTANCE.negate());
-    }
-
     /**
      * Returns the size of the specified file or directory. If the provided
      * {@link File} is a regular file, then the file's length is returned.
@@ -2781,6 +2733,30 @@ private static BigInteger sizeOfDirectoryBig0(final File directory) {
         return size;
     }
 
+    /**
+     * Streams over the files in a given directory (and optionally
+     * its subdirectories) which match an array of extensions.
+     *
+     * @param directory  the directory to search in
+     * @param recursive  if true all subdirectories are searched as well
+     * @param extensions an array of extensions, ex. {"java","xml"}. If this
+     *                   parameter is {@code null}, all files are returned.
+     * @return an iterator of java.io.File with the matching files
+     * @throws IOException if an I/O error is thrown when accessing the starting file.
+     * @since 2.9.0
+     */
+    public static Stream<File> streamFiles(final File directory, final boolean recursive, final String... extensions)
+        throws IOException {
+        IOFileFilter filter;
+        if (extensions == null) {
+            filter = FileFileFilter.INSTANCE;
+        } else {
+            filter = FileFileFilter.INSTANCE.and(new SuffixFileFilter(toSuffixes(extensions)));
+        }
+        // We use filters that do not need file attributes so pass false.
+        return PathUtils.walk(directory.toPath(), filter, toMaxDepth(recursive), false).map(Path::toFile);
+    }
+
     /**
      * Convert from a <code>URL</code> to a <code>File</code>.
      * <p>
@@ -2844,6 +2820,20 @@ public static File[] toFiles(final URL... urls) {
         return files;
     }
 
+    private static List<File> toList(Stream<File> stream) {
+        return stream.collect(Collectors.toList());
+    }
+
+    /**
+     * Converts whether or not to recurse into a recursion max depth.
+     *
+     * @param recursive whether or not to recurse 
+     * @return the recursion depth
+     */
+    private static int toMaxDepth(final boolean recursive) {
+        return recursive ? Integer.MAX_VALUE : 1;
+    }
+
     /**
      * Converts an array of file extensions to suffixes for use
      * with IOFileFilters.
@@ -2903,23 +2893,6 @@ public static URL[] toURLs(final File... files) throws IOException {
         return urls;
     }
 
-    /**
-     * Validates the given arguments.
-     * <ul>
-     * <li>Throws {@link IllegalArgumentException} if {@code directory} is not a directory</li>
-     * <li>Throws {@link NullPointerException} if {@code fileFilter} is null</li>
-     * </ul>
-     *
-     * @param directory  The File to test
-     * @param fileFilter The IOFileFilter to test
-     */
-    private static void validateListFilesParameters(final File directory, final IOFileFilter fileFilter) {
-        if (!directory.isDirectory()) {
-            throw new IllegalArgumentException("Parameter 'directory' is not a directory: " + directory);
-        }
-        Objects.requireNonNull(fileFilter, "fileFilter");
-    }
-
     /**
      * Validates the given arguments.
      * <ul>
diff --git a/src/main/java/org/apache/commons/io/StreamIterator.java b/src/main/java/org/apache/commons/io/StreamIterator.java
new file mode 100644
index 000000000..5bc98e41e
--- /dev/null
+++ b/src/main/java/org/apache/commons/io/StreamIterator.java
@@ -0,0 +1,88 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.io;
+
+import java.io.Closeable;
+import java.util.Iterator;
+import java.util.Objects;
+import java.util.stream.Stream;
+
+/**
+ * Wraps and presents a stream as a closable iterator resource that automatically closes itself when reaching the end
+ * of stream.
+ *
+ * @param <E> The stream and iterator type.
+ * @since 2.9.0
+ */
+class StreamIterator<E> implements Iterator<E>, Closeable {
+
+    /**
+     * Wraps and presents a stream as a closable resource that automatically closes itself when reaching the end of
+     * stream.
+     * <h2>Warning</h2>
+     * <p>
+     * In order to close the stream, the call site MUST either close the stream it allocated OR call the iterator until
+     * the end.
+     * </p>
+     * 
+     * @param <T> The stream and iterator type.
+     * @param stream The stream iterate.
+     * @return A new iterator.
+     */
+    @SuppressWarnings("resource") // Caller MUST close or iterate to the end.
+    public static <T> Iterator<T> iterator(final Stream<T> stream) {
+        return new StreamIterator<>(stream).iterator;
+    }
+
+    private StreamIterator(final Stream<E> stream) {
+        super();
+        this.stream = Objects.requireNonNull(stream, "stream");
+        this.iterator = stream.iterator();
+    }
+
+    private final Iterator<E> iterator;
+    private final Stream<E> stream;
+
+    @Override
+    public boolean hasNext() {
+        final boolean hasNext = iterator.hasNext();
+        if (!hasNext) {
+            close();
+        }
+        return hasNext;
+    }
+
+    @Override
+    public E next() {
+        final E next = iterator.next();
+        if (next == null) {
+            close();
+        }
+        return next;
+    }
+
+    /**
+     * Closes the underlying stream.
+     */
+    @Override
+    public void close() {
+        stream.close();
+
+    }
+
+}
diff --git a/src/main/java/org/apache/commons/io/file/AccumulatorPathVisitor.java b/src/main/java/org/apache/commons/io/file/AccumulatorPathVisitor.java
index a2596409a..7cbe39462 100644
--- a/src/main/java/org/apache/commons/io/file/AccumulatorPathVisitor.java
+++ b/src/main/java/org/apache/commons/io/file/AccumulatorPathVisitor.java
@@ -35,7 +35,7 @@
  * <h2>Example</h2>
  *
  * <pre>
- * Path dir = Paths.get(".");
+ * Path dir = Paths.get("");
  * // We are interested in files older than one day
  * long cutoff = System.currentTimeMillis() - (24 * 60 * 60 * 1000);
  * AccumulatorPathVisitor visitor = AccumulatorPathVisitor.withLongCounters(new AgeFileFilter(cutoff));
@@ -70,12 +70,14 @@ public static AccumulatorPathVisitor withBigIntegerCounters() {
     /**
      * Creates a new instance configured with a BigInteger {@link PathCounters}.
      *
-     * @param pathFilter Filters files to accumulate and count.
+     * @param fileFilter Filters files to accumulate and count.
+     * @param dirFilter Filters directories to accumulate and count.
      * @return a new instance configured with a long {@link PathCounters}.
      * @since 2.9.0
      */
-    public static AccumulatorPathVisitor withBigIntegerCounters(final PathFilter pathFilter) {
-        return new AccumulatorPathVisitor(Counters.bigIntegerPathCounters(), pathFilter);
+    public static AccumulatorPathVisitor withBigIntegerCounters(final PathFilter fileFilter,
+        final PathFilter dirFilter) {
+        return new AccumulatorPathVisitor(Counters.bigIntegerPathCounters(), fileFilter, dirFilter);
     }
 
     /**
@@ -90,12 +92,13 @@ public static AccumulatorPathVisitor withLongCounters() {
     /**
      * Creates a new instance configured with a long {@link PathCounters}.
      *
-     * @param pathFilter Filters files to accumulate and count.
+     * @param fileFilter Filters files to accumulate and count.
+     * @param dirFilter Filters directories to accumulate and count.
      * @return a new instance configured with a long {@link PathCounters}.
      * @since 2.9.0
      */
-    public static AccumulatorPathVisitor withLongCounters(final PathFilter pathFilter) {
-        return new AccumulatorPathVisitor(Counters.longPathCounters(), pathFilter);
+    public static AccumulatorPathVisitor withLongCounters(final PathFilter fileFilter, final PathFilter dirFilter) {
+        return new AccumulatorPathVisitor(Counters.longPathCounters(), fileFilter, dirFilter);
     }
 
     private final List<Path> dirList = new ArrayList<>();
@@ -124,11 +127,13 @@ public AccumulatorPathVisitor(final PathCounters pathCounter) {
      * Constructs a new instance.
      *
      * @param pathCounter How to count path visits.
-     * @param pathFilter Filters which paths to count.
+     * @param pathFilter Filters which files to count.
+     * @param dirFilter Filters which directories to count.
      * @since 2.9.0
      */
-    public AccumulatorPathVisitor(final PathCounters pathCounter, final PathFilter pathFilter) {
-        super(pathCounter, pathFilter);
+    public AccumulatorPathVisitor(final PathCounters pathCounter, final PathFilter pathFilter,
+        final PathFilter dirFilter) {
+        super(pathCounter, pathFilter, dirFilter);
     }
 
     private void add(final List<Path> list, final Path dir) {
diff --git a/src/main/java/org/apache/commons/io/file/CopyDirectoryVisitor.java b/src/main/java/org/apache/commons/io/file/CopyDirectoryVisitor.java
index 72bca1128..c2fdf8b02 100644
--- a/src/main/java/org/apache/commons/io/file/CopyDirectoryVisitor.java
+++ b/src/main/java/org/apache/commons/io/file/CopyDirectoryVisitor.java
@@ -59,15 +59,16 @@ public CopyDirectoryVisitor(final PathCounters pathCounter, final Path sourceDir
      * Constructs a new visitor that deletes files except for the files and directories explicitly given.
      *
      * @param pathCounter How to count visits.
-     * @param pathFilter How to filter paths.
+     * @param fileFilter How to filter file paths.
+     * @param dirFilter How to filter directory paths.
      * @param sourceDirectory The source directory
      * @param targetDirectory The target directory
      * @param copyOptions Specifies how the copying should be done.
      * @since 2.9.0
      */
-    public CopyDirectoryVisitor(final PathCounters pathCounter, final PathFilter pathFilter, final Path sourceDirectory, final Path targetDirectory,
-        final CopyOption... copyOptions) {
-        super(pathCounter, pathFilter);
+    public CopyDirectoryVisitor(final PathCounters pathCounter, final PathFilter fileFilter, final PathFilter dirFilter,
+        final Path sourceDirectory, final Path targetDirectory, final CopyOption... copyOptions) {
+        super(pathCounter, fileFilter, dirFilter);
         this.sourceDirectory = sourceDirectory;
         this.targetDirectory = targetDirectory;
         this.copyOptions = copyOptions == null ? PathUtils.EMPTY_COPY_OPTIONS : copyOptions.clone();
diff --git a/src/main/java/org/apache/commons/io/file/CountingPathVisitor.java b/src/main/java/org/apache/commons/io/file/CountingPathVisitor.java
index 7d34e5977..53b41c826 100644
--- a/src/main/java/org/apache/commons/io/file/CountingPathVisitor.java
+++ b/src/main/java/org/apache/commons/io/file/CountingPathVisitor.java
@@ -55,7 +55,8 @@ public static CountingPathVisitor withLongCounters() {
     }
 
     private final PathCounters pathCounters;
-    private final PathFilter pathFilter;
+    private final PathFilter fileFilter;
+    private final PathFilter dirFilter;
 
     /**
      * Constructs a new instance.
@@ -63,20 +64,22 @@ public static CountingPathVisitor withLongCounters() {
      * @param pathCounter How to count path visits.
      */
     public CountingPathVisitor(final PathCounters pathCounter) {
-        this(pathCounter, TrueFileFilter.INSTANCE);
+        this(pathCounter, TrueFileFilter.INSTANCE, TrueFileFilter.INSTANCE);
     }
 
     /**
      * Constructs a new instance.
      *
      * @param pathCounter How to count path visits.
-     * @param pathFilter Filters which paths to count.
+     * @param fileFilter Filters which files to count.
+     * @param dirFilter Filters which directories to count.
      * @since 2.9.0
      */
-    public CountingPathVisitor(final PathCounters pathCounter, final PathFilter pathFilter) {
+    public CountingPathVisitor(final PathCounters pathCounter, final PathFilter fileFilter, PathFilter dirFilter) {
         super();
         this.pathCounters = Objects.requireNonNull(pathCounter, "pathCounter");
-        this.pathFilter = Objects.requireNonNull(pathFilter, "pathFilter");
+        this.fileFilter = Objects.requireNonNull(fileFilter, "fileFilter");
+        this.dirFilter = Objects.requireNonNull(dirFilter, "dirFilter");
     }
 
     @Override
@@ -110,6 +113,12 @@ public FileVisitResult postVisitDirectory(final Path dir, final IOException exc)
         updateDirCounter(dir, exc);
         return FileVisitResult.CONTINUE;
     }
+    
+    @Override
+    public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attributes) throws IOException {
+        final FileVisitResult accept = dirFilter.accept(dir, attributes);
+        return accept != FileVisitResult.CONTINUE ? FileVisitResult.SKIP_SUBTREE : FileVisitResult.CONTINUE;
+    }
 
     @Override
     public String toString() {
@@ -140,7 +149,7 @@ protected void updateFileCounters(final Path file, final BasicFileAttributes att
 
     @Override
     public FileVisitResult visitFile(final Path file, final BasicFileAttributes attributes) throws IOException {
-        if (Files.exists(file) && pathFilter.accept(file, attributes) == FileVisitResult.CONTINUE) {
+        if (Files.exists(file) && fileFilter.accept(file, attributes) == FileVisitResult.CONTINUE) {
             updateFileCounters(file, attributes);
         }
         return FileVisitResult.CONTINUE;
diff --git a/src/main/java/org/apache/commons/io/file/PathFilter.java b/src/main/java/org/apache/commons/io/file/PathFilter.java
index 77de9e6cf..837ddc027 100644
--- a/src/main/java/org/apache/commons/io/file/PathFilter.java
+++ b/src/main/java/org/apache/commons/io/file/PathFilter.java
@@ -33,7 +33,7 @@ public interface PathFilter {
      * Tests whether or not to include the specified Path in a result.
      *
      * @param path The Path to test.
-     * @param attributes the file's basic attributes.
+     * @param attributes the file's basic attributes (TODO may be null).
      * @return a FileVisitResult
      */
     FileVisitResult accept(Path path, BasicFileAttributes attributes);
diff --git a/src/main/java/org/apache/commons/io/file/PathUtils.java b/src/main/java/org/apache/commons/io/file/PathUtils.java
index b639beb8f..23f389dd7 100644
--- a/src/main/java/org/apache/commons/io/file/PathUtils.java
+++ b/src/main/java/org/apache/commons/io/file/PathUtils.java
@@ -280,6 +280,17 @@ public static PathCounters countDirectory(final Path directory) throws IOExcepti
         return visitFileTree(new CountingPathVisitor(Counters.longPathCounters()), directory).getPathCounters();
     }
 
+    /**
+     * Gets the current directory.
+     * 
+     * @return the current directory.
+     *
+     * @since 2.9.0
+     */
+    public static Path current() {
+        return Paths.get("");
+    }
+    
     /**
      * Deletes a file or directory. If the path is a directory, delete it and all sub-directories.
      * <p>
@@ -684,7 +695,8 @@ public static boolean isNewer(final Path file, final long timeMillis, final Link
      * @return a new instance.
      * @throws IOException if an I/O error occurs.
      */
-    public static DirectoryStream<Path> newDirectoryStream(final Path dir, final PathFilter pathFilter) throws IOException {
+    public static DirectoryStream<Path> newDirectoryStream(final Path dir, final PathFilter pathFilter)
+        throws IOException {
         return Files.newDirectoryStream(dir, new DirectoryStreamFilter(pathFilter));
     }
 
@@ -874,6 +886,24 @@ public static <T extends FileVisitor<? super Path>> T visitFileTree(final T visi
         return visitFileTree(visitor, Paths.get(uri));
     }
 
+    /**
+     * Returns a stream of filtered paths.
+     *
+     * @param start the start path
+     * @param pathFilter the path filter
+     * @param maxDepth the maximum depth of directories to walk.
+     * @param readAttributes whether to call the filters with file attributes (false passes null).
+     * @param options the options to configure the walk.
+     * @return a filtered stream of paths.
+     * @throws IOException if an I/O error is thrown when accessing the starting file.
+     * @since 2.9.0
+     */
+    public static Stream<Path> walk(final Path start, final PathFilter pathFilter, final int maxDepth,
+        boolean readAttributes, final FileVisitOption... options) throws IOException {
+        return Files.walk(start, maxDepth, options).filter(path -> pathFilter.accept(path,
+            readAttributes ? readBasicFileAttributesQuietly(path) : null) == FileVisitResult.CONTINUE);
+    }
+
     /**
      * Does allow to instantiate.
      */
diff --git a/src/main/java/org/apache/commons/io/filefilter/AbstractFileFilter.java b/src/main/java/org/apache/commons/io/filefilter/AbstractFileFilter.java
index 3632c93e0..6f9190493 100644
--- a/src/main/java/org/apache/commons/io/filefilter/AbstractFileFilter.java
+++ b/src/main/java/org/apache/commons/io/filefilter/AbstractFileFilter.java
@@ -39,7 +39,7 @@
  */
 public abstract class AbstractFileFilter implements IOFileFilter, PathVisitor {
 
-    protected static FileVisitResult toFileVisitResult(final boolean accept) {
+    static FileVisitResult toFileVisitResult(final boolean accept, final Path path) {
         return accept ? FileVisitResult.CONTINUE : FileVisitResult.TERMINATE;
     }
 
diff --git a/src/main/java/org/apache/commons/io/filefilter/AgeFileFilter.java b/src/main/java/org/apache/commons/io/filefilter/AgeFileFilter.java
index eb6975858..71facc5bf 100644
--- a/src/main/java/org/apache/commons/io/filefilter/AgeFileFilter.java
+++ b/src/main/java/org/apache/commons/io/filefilter/AgeFileFilter.java
@@ -34,7 +34,7 @@
  * </p>
  * <h2>Using Classic IO</h2>
  * <pre>
- * Path dir = Paths.get(".");
+ * Path dir = Paths.get("");
  * // We are interested in files older than one day
  * long cutoff = System.currentTimeMillis() - (24 * 60 * 60 * 1000);
  * String[] files = dir.list(new AgeFileFilter(cutoff));
@@ -45,7 +45,7 @@
  *
  * <h2>Using NIO</h2>
  * <pre>
- * Path dir = Paths.get(".");
+ * Path dir = Paths.get("");
  * // We are interested in files older than one day
  * long cutoff = System.currentTimeMillis() - (24 * 60 * 60 * 1000);
  * AccumulatorPathVisitor visitor = AccumulatorPathVisitor.withLongCounters(new AgeFileFilter(cutoff));
@@ -182,7 +182,7 @@ public FileVisitResult accept(final Path file, final BasicFileAttributes attribu
         } catch (final IOException e) {
             return handle(e);
         }
-        return toFileVisitResult(acceptOlder != newer);
+        return toFileVisitResult(acceptOlder != newer, file);
     }
 
     /**
diff --git a/src/main/java/org/apache/commons/io/filefilter/CanExecuteFileFilter.java b/src/main/java/org/apache/commons/io/filefilter/CanExecuteFileFilter.java
index b87e176c5..c50fa9c67 100644
--- a/src/main/java/org/apache/commons/io/filefilter/CanExecuteFileFilter.java
+++ b/src/main/java/org/apache/commons/io/filefilter/CanExecuteFileFilter.java
@@ -90,7 +90,7 @@ public boolean accept(final File file) {
      */
     @Override
     public FileVisitResult accept(final Path file, final BasicFileAttributes attributes) {
-        return toFileVisitResult(Files.isExecutable(file));
+        return toFileVisitResult(Files.isExecutable(file), file);
     }
 
 }
diff --git a/src/main/java/org/apache/commons/io/filefilter/CanReadFileFilter.java b/src/main/java/org/apache/commons/io/filefilter/CanReadFileFilter.java
index 320356d51..4f7bf0332 100644
--- a/src/main/java/org/apache/commons/io/filefilter/CanReadFileFilter.java
+++ b/src/main/java/org/apache/commons/io/filefilter/CanReadFileFilter.java
@@ -100,7 +100,7 @@ public boolean accept(final File file) {
      */
     @Override
     public FileVisitResult accept(final Path file, final BasicFileAttributes attributes) {
-        return toFileVisitResult(Files.isReadable(file));
+        return toFileVisitResult(Files.isReadable(file), file);
     }
 
 }
diff --git a/src/main/java/org/apache/commons/io/filefilter/CanWriteFileFilter.java b/src/main/java/org/apache/commons/io/filefilter/CanWriteFileFilter.java
index a49ec4e04..825100e41 100644
--- a/src/main/java/org/apache/commons/io/filefilter/CanWriteFileFilter.java
+++ b/src/main/java/org/apache/commons/io/filefilter/CanWriteFileFilter.java
@@ -89,7 +89,7 @@ public boolean accept(final File file) {
      */
     @Override
     public FileVisitResult accept(final Path file, final BasicFileAttributes attributes) {
-        return toFileVisitResult(Files.isWritable(file));
+        return toFileVisitResult(Files.isWritable(file), file);
     }
 
 }
diff --git a/src/main/java/org/apache/commons/io/filefilter/DirectoryFileFilter.java b/src/main/java/org/apache/commons/io/filefilter/DirectoryFileFilter.java
index 23183a5d3..c66d4c587 100644
--- a/src/main/java/org/apache/commons/io/filefilter/DirectoryFileFilter.java
+++ b/src/main/java/org/apache/commons/io/filefilter/DirectoryFileFilter.java
@@ -41,7 +41,7 @@
  * <h2>Using NIO</h2>
  *
  * <pre>
- * final Path dir = Paths.get(".");
+ * final Path dir = Paths.get("");
  * final AccumulatorPathVisitor visitor = AccumulatorPathVisitor.withLongCounters(DirectoryFileFilter.INSTANCE);
  * //
  * // Walk one dir
@@ -105,7 +105,7 @@ public boolean accept(final File file) {
      */
     @Override
     public FileVisitResult accept(final Path file, final BasicFileAttributes attributes) {
-        return toFileVisitResult(Files.isDirectory(file));
+        return toFileVisitResult(Files.isDirectory(file), file);
     }
 
 }
diff --git a/src/main/java/org/apache/commons/io/filefilter/EmptyFileFilter.java b/src/main/java/org/apache/commons/io/filefilter/EmptyFileFilter.java
index aa83fc8a6..813c7d48c 100644
--- a/src/main/java/org/apache/commons/io/filefilter/EmptyFileFilter.java
+++ b/src/main/java/org/apache/commons/io/filefilter/EmptyFileFilter.java
@@ -56,7 +56,7 @@
  *
  * <h2>Using NIO</h2>
  * <pre>
- * final Path dir = Paths.get(".");
+ * final Path dir = Paths.get("");
  * final AccumulatorPathVisitor visitor = AccumulatorPathVisitor.withLongCounters(EmptyFileFilter.EMPTY);
  * //
  * // Walk one dir
@@ -118,10 +118,10 @@ public FileVisitResult accept(final Path file, final BasicFileAttributes attribu
         try {
             if (Files.isDirectory(file)) {
                 try (Stream<Path> stream = Files.list(file)) {
-                    return toFileVisitResult(!stream.findFirst().isPresent());
+                    return toFileVisitResult(!stream.findFirst().isPresent(), file);
                 }
             }
-            return toFileVisitResult(Files.size(file) == 0);
+            return toFileVisitResult(Files.size(file) == 0, file);
         } catch (final IOException e) {
             return handle(e);
         }
diff --git a/src/main/java/org/apache/commons/io/filefilter/FileEqualsFileFilter.java b/src/main/java/org/apache/commons/io/filefilter/FileEqualsFileFilter.java
new file mode 100644
index 000000000..0f5f8dc8b
--- /dev/null
+++ b/src/main/java/org/apache/commons/io/filefilter/FileEqualsFileFilter.java
@@ -0,0 +1,58 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.io.filefilter;
+
+import java.io.File;
+import java.nio.file.FileVisitResult;
+import java.nio.file.Path;
+import java.nio.file.attribute.BasicFileAttributes;
+import java.util.Objects;
+
+/**
+ * Accepts only an exact {@link File} object match. You can use this filter to visit the start directory when walking a
+ * file tree with
+ * {@link java.nio.file.Files#walkFileTree(java.nio.file.Path, java.util.Set, int, java.nio.file.FileVisitor)}.
+ *
+ * @since 2.9.0
+ */
+public class FileEqualsFileFilter extends AbstractFileFilter {
+
+    private final File file;
+    private final Path path;
+
+    /**
+     * Constructs a new instance for the given {@link File}.
+     *
+     * @param file The file to match.
+     */
+    public FileEqualsFileFilter(final File file) {
+        super();
+        this.file = file;
+        this.path = file.toPath();
+    }
+
+    @Override
+    public boolean accept(final File file) {
+        return Objects.equals(this.file, file);
+    }
+
+    @Override
+    public FileVisitResult accept(final Path path, final BasicFileAttributes attributes) {
+        return toFileVisitResult(Objects.equals(this.path, path), path);
+    }
+}
diff --git a/src/main/java/org/apache/commons/io/filefilter/FileFileFilter.java b/src/main/java/org/apache/commons/io/filefilter/FileFileFilter.java
index a2980d703..39f6159ab 100644
--- a/src/main/java/org/apache/commons/io/filefilter/FileFileFilter.java
+++ b/src/main/java/org/apache/commons/io/filefilter/FileFileFilter.java
@@ -40,7 +40,7 @@
  *
  * <h2>Using NIO</h2>
  * <pre>
- * final Path dir = Paths.get(".");
+ * final Path dir = Paths.get("");
  * final AccumulatorPathVisitor visitor = AccumulatorPathVisitor.withLongCounters(FileFileFilter.FILE);
  * //
  * // Walk one dir
@@ -62,8 +62,21 @@
  */
 public class FileFileFilter extends AbstractFileFilter implements Serializable {
 
-    /** Singleton instance of file filter */
-    public static final IOFileFilter FILE = new FileFileFilter();
+    /**
+     * Singleton instance of file filter.
+     *
+     * @since 2.9.0
+     */
+    public static final IOFileFilter INSTANCE = new FileFileFilter();
+
+    /**
+     * Singleton instance of file filter.
+     *
+     * @deprecated Use {@link #INSTANCE}.
+     */
+    @Deprecated
+    public static final IOFileFilter FILE = INSTANCE;
+
     private static final long serialVersionUID = 5345244090827540862L;
 
     /**
@@ -92,7 +105,7 @@ public boolean accept(final File file) {
      */
     @Override
     public FileVisitResult accept(final Path file, final BasicFileAttributes attributes) {
-        return toFileVisitResult(Files.isRegularFile(file));
+        return toFileVisitResult(Files.isRegularFile(file), file);
     }
 
 }
diff --git a/src/main/java/org/apache/commons/io/filefilter/FileFilterUtils.java b/src/main/java/org/apache/commons/io/filefilter/FileFilterUtils.java
index 2147bac0a..2a3c66770 100644
--- a/src/main/java/org/apache/commons/io/filefilter/FileFilterUtils.java
+++ b/src/main/java/org/apache/commons/io/filefilter/FileFilterUtils.java
@@ -214,10 +214,10 @@ public static IOFileFilter falseFileFilter() {
      * Returns a filter that checks if the file is a file (and not a directory).
      *
      * @return file filter that accepts only files and not directories
-     * @see FileFileFilter#FILE
+     * @see FileFileFilter#INSTANCE
      */
     public static IOFileFilter fileFileFilter() {
-        return FileFileFilter.FILE;
+        return FileFileFilter.INSTANCE;
     }
 
     /**
@@ -545,14 +545,14 @@ public static IOFileFilter makeDirectoryOnly(final IOFileFilter filter) {
      *
      * @param filter  the filter to decorate, null means an unrestricted filter
      * @return the decorated filter, never null
-     * @see FileFileFilter#FILE
+     * @see FileFileFilter#INSTANCE
      * @since 1.3
      */
     public static IOFileFilter makeFileOnly(final IOFileFilter filter) {
         if (filter == null) {
-            return FileFileFilter.FILE;
+            return FileFileFilter.INSTANCE;
         }
-        return FileFileFilter.FILE.and(filter);
+        return FileFileFilter.INSTANCE.and(filter);
     }
 
     /**
diff --git a/src/main/java/org/apache/commons/io/filefilter/HiddenFileFilter.java b/src/main/java/org/apache/commons/io/filefilter/HiddenFileFilter.java
index ce20698ce..618f7ace5 100644
--- a/src/main/java/org/apache/commons/io/filefilter/HiddenFileFilter.java
+++ b/src/main/java/org/apache/commons/io/filefilter/HiddenFileFilter.java
@@ -54,7 +54,7 @@
  *
  * <h2>Using NIO</h2>
  * <pre>
- * final Path dir = Paths.get(".");
+ * final Path dir = Paths.get("");
  * final AccumulatorPathVisitor visitor = AccumulatorPathVisitor.withLongCounters(HiddenFileFilter.HIDDEN);
  * //
  * // Walk one dir
@@ -112,7 +112,7 @@ public boolean accept(final File file) {
     @Override
     public FileVisitResult accept(final Path file, final BasicFileAttributes attributes) {
         try {
-            return toFileVisitResult(Files.isHidden(file));
+            return toFileVisitResult(Files.isHidden(file), file);
         } catch (final IOException e) {
             return handle(e);
         }
diff --git a/src/main/java/org/apache/commons/io/filefilter/IOFileFilter.java b/src/main/java/org/apache/commons/io/filefilter/IOFileFilter.java
index ddb472238..902b9cf3d 100644
--- a/src/main/java/org/apache/commons/io/filefilter/IOFileFilter.java
+++ b/src/main/java/org/apache/commons/io/filefilter/IOFileFilter.java
@@ -71,7 +71,7 @@ public interface IOFileFilter extends FileFilter, FilenameFilter, PathFilter {
      */
     @Override
     default FileVisitResult accept(final Path path, final BasicFileAttributes attributes) {
-        return AbstractFileFilter.toFileVisitResult(accept(path.toFile()));
+        return AbstractFileFilter.toFileVisitResult(accept(path.toFile()), path);
     }
 
     /**
diff --git a/src/main/java/org/apache/commons/io/filefilter/MagicNumberFileFilter.java b/src/main/java/org/apache/commons/io/filefilter/MagicNumberFileFilter.java
index 701e5e104..c1664427d 100644
--- a/src/main/java/org/apache/commons/io/filefilter/MagicNumberFileFilter.java
+++ b/src/main/java/org/apache/commons/io/filefilter/MagicNumberFileFilter.java
@@ -65,7 +65,7 @@
  * </pre>
  * <h2>Using NIO</h2>
  * <pre>
- * final Path dir = Paths.get(".");
+ * final Path dir = Paths.get("");
  * final AccumulatorPathVisitor visitor = AccumulatorPathVisitor.withLongCounters(MagicNumberFileFilter("ustar", 257));
  * //
  * // Walk one dir
@@ -301,7 +301,7 @@ public FileVisitResult accept(final Path file, final BasicFileAttributes attribu
                     if (read != magicNumbers.length) {
                         return FileVisitResult.TERMINATE;
                     }
-                    return toFileVisitResult(Arrays.equals(this.magicNumbers, byteBuffer.array()));
+                    return toFileVisitResult(Arrays.equals(this.magicNumbers, byteBuffer.array()), file);
                 }
             }
             catch (final IOException ioe) {
diff --git a/src/main/java/org/apache/commons/io/filefilter/NameFileFilter.java b/src/main/java/org/apache/commons/io/filefilter/NameFileFilter.java
index e6df6df44..f9879f698 100644
--- a/src/main/java/org/apache/commons/io/filefilter/NameFileFilter.java
+++ b/src/main/java/org/apache/commons/io/filefilter/NameFileFilter.java
@@ -42,7 +42,7 @@
  *
  * <h2>Using NIO</h2>
  * <pre>
- * final Path dir = Paths.get(".");
+ * final Path dir = Paths.get("");
  * final AccumulatorPathVisitor visitor = AccumulatorPathVisitor.withLongCounters(new NameFileFilter("Test"));
  * //
  * // Walk one dir
@@ -187,7 +187,7 @@ public boolean accept(final File dir, final String name) {
      */
     @Override
     public FileVisitResult accept(final Path file, final BasicFileAttributes attributes) {
-        return toFileVisitResult(acceptBaseName(file.getFileName().toString()));
+        return toFileVisitResult(acceptBaseName(file.getFileName().toString()), file);
     }
 
     private boolean acceptBaseName(final String baseName) {
diff --git a/src/main/java/org/apache/commons/io/filefilter/PathEqualsFileFilter.java b/src/main/java/org/apache/commons/io/filefilter/PathEqualsFileFilter.java
new file mode 100644
index 000000000..f24bf4c88
--- /dev/null
+++ b/src/main/java/org/apache/commons/io/filefilter/PathEqualsFileFilter.java
@@ -0,0 +1,56 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.io.filefilter;
+
+import java.io.File;
+import java.nio.file.FileVisitResult;
+import java.nio.file.Path;
+import java.nio.file.attribute.BasicFileAttributes;
+import java.util.Objects;
+
+/**
+ * Accepts only an exact {@link Path} object match. You can use this filter to visit the start directory when walking a
+ * file tree with
+ * {@link java.nio.file.Files#walkFileTree(java.nio.file.Path, java.util.Set, int, java.nio.file.FileVisitor)}.
+ *
+ * @since 2.9.0
+ */
+public class PathEqualsFileFilter extends AbstractFileFilter {
+
+    private final Path path;
+
+    /**
+     * Constructs a new instance for the given {@link Path}.
+     * 
+     * @param file The file to match.
+     */
+    public PathEqualsFileFilter(final Path file) {
+        super();
+        this.path = file;
+    }
+
+    @Override
+    public boolean accept(File file) {
+        return Objects.equals(this.path, file.toPath());
+    }
+
+    @Override
+    public FileVisitResult accept(Path path, BasicFileAttributes attributes) {
+        return toFileVisitResult(Objects.equals(this.path, path), path);
+    }
+}
diff --git a/src/main/java/org/apache/commons/io/filefilter/PrefixFileFilter.java b/src/main/java/org/apache/commons/io/filefilter/PrefixFileFilter.java
index 97452e032..c71fb2073 100644
--- a/src/main/java/org/apache/commons/io/filefilter/PrefixFileFilter.java
+++ b/src/main/java/org/apache/commons/io/filefilter/PrefixFileFilter.java
@@ -42,7 +42,7 @@
  *
  * <h2>Using NIO</h2>
  * <pre>
- * final Path dir = Paths.get(".");
+ * final Path dir = Paths.get("");
  * final AccumulatorPathVisitor visitor = AccumulatorPathVisitor.withLongCounters(new PrefixFileFilter("Test"));
  * //
  * // Walk one dir
@@ -192,7 +192,7 @@ public boolean accept(final File file, final String name) {
      */
     @Override
     public FileVisitResult accept(final Path file, final BasicFileAttributes attributes) {
-        return toFileVisitResult(accept(file.getFileName().toFile()));
+        return toFileVisitResult(accept(file.getFileName().toFile()), file);
     }
 
     private boolean accept(final String name) {
diff --git a/src/main/java/org/apache/commons/io/filefilter/RegexFileFilter.java b/src/main/java/org/apache/commons/io/filefilter/RegexFileFilter.java
index e10397654..bfa75cffd 100644
--- a/src/main/java/org/apache/commons/io/filefilter/RegexFileFilter.java
+++ b/src/main/java/org/apache/commons/io/filefilter/RegexFileFilter.java
@@ -33,7 +33,7 @@
  * <h2>Using Classic IO</h2>
  * <p>
  * e.g.
- * 
+ *
  * <pre>
  * File dir = new File(".");
  * FileFilter fileFilter = new RegexFileFilter("^.*[tT]est(-\\d+)?\\.java$");
@@ -44,9 +44,9 @@
  * </pre>
  *
  * <h2>Using NIO</h2>
- * 
+ *
  * <pre>
- * final Path dir = Paths.get(".");
+ * final Path dir = Paths.get("");
  * final AccumulatorPathVisitor visitor = AccumulatorPathVisitor.withLongCounters(new RegexFileFilter("^.*[tT]est(-\\d+)?\\.java$"));
  * //
  * // Walk one dir
@@ -145,14 +145,14 @@ public boolean accept(final File dir, final String name) {
 
     /**
      * Checks to see if the file name matches one of the regular expressions.
-     * 
+     *
      * @param path the path
      * @param attributes the path attributes
      * @return true if the file name matches one of the regular expressions
      */
     @Override
     public FileVisitResult accept(final Path path, final BasicFileAttributes attributes) {
-        return toFileVisitResult(pattern.matcher(path.toString()).matches());
+        return toFileVisitResult(pattern.matcher(path.toString()).matches(), path);
     }
 
 }
diff --git a/src/main/java/org/apache/commons/io/filefilter/SizeFileFilter.java b/src/main/java/org/apache/commons/io/filefilter/SizeFileFilter.java
index d6680740e..6b11c5f13 100644
--- a/src/main/java/org/apache/commons/io/filefilter/SizeFileFilter.java
+++ b/src/main/java/org/apache/commons/io/filefilter/SizeFileFilter.java
@@ -42,7 +42,7 @@
  *
  * <h2>Using NIO</h2>
  * <pre>
- * final Path dir = Paths.get(".");
+ * final Path dir = Paths.get("");
  * final AccumulatorPathVisitor visitor = AccumulatorPathVisitor.withLongCounters(new SizeFileFilter(1024 * 1024));
  * //
  * // Walk one dir
@@ -138,7 +138,7 @@ private boolean accept(final long length) {
     @Override
     public FileVisitResult accept(final Path file, final BasicFileAttributes attributes) {
         try {
-            return toFileVisitResult(accept(Files.size(file)));
+            return toFileVisitResult(accept(Files.size(file)), file);
         } catch (final IOException e) {
             return handle(e);
         }
@@ -157,7 +157,7 @@ public String toString() {
 
     @Override
     public FileVisitResult visitFile(final Path file, final BasicFileAttributes attrs) throws IOException {
-        return toFileVisitResult(accept(Files.size(file)));
+        return toFileVisitResult(accept(Files.size(file)), file);
     }
 
 }
diff --git a/src/main/java/org/apache/commons/io/filefilter/SuffixFileFilter.java b/src/main/java/org/apache/commons/io/filefilter/SuffixFileFilter.java
index 6875fcc71..d0c480bbe 100644
--- a/src/main/java/org/apache/commons/io/filefilter/SuffixFileFilter.java
+++ b/src/main/java/org/apache/commons/io/filefilter/SuffixFileFilter.java
@@ -43,7 +43,7 @@
  *
  * <h2>Using NIO</h2>
  * <pre>
- * final Path dir = Paths.get(".");
+ * final Path dir = Paths.get("");
  * final AccumulatorPathVisitor visitor = AccumulatorPathVisitor.withLongCounters(new SuffixFileFilter(".java"));
  * //
  * // Walk one dir
@@ -193,7 +193,7 @@ public boolean accept(final File file, final String name) {
      */
     @Override
     public FileVisitResult accept(final Path file, final BasicFileAttributes attributes) {
-        return toFileVisitResult(accept(file.getFileName().toString()));
+        return toFileVisitResult(accept(file.getFileName().toString()), file);
     }
 
     private boolean accept(final String name) {
diff --git a/src/main/java/org/apache/commons/io/filefilter/WildcardFileFilter.java b/src/main/java/org/apache/commons/io/filefilter/WildcardFileFilter.java
index d1ecf4724..4590062cc 100644
--- a/src/main/java/org/apache/commons/io/filefilter/WildcardFileFilter.java
+++ b/src/main/java/org/apache/commons/io/filefilter/WildcardFileFilter.java
@@ -54,7 +54,7 @@
  *
  * <h2>Using NIO</h2>
  * <pre>
- * final Path dir = Paths.get(".");
+ * final Path dir = Paths.get("");
  * final AccumulatorPathVisitor visitor = AccumulatorPathVisitor.withLongCounters(new WildcardFileFilter("*test*.java~*~"));
  * //
  * // Walk one dir
@@ -195,7 +195,7 @@ public boolean accept(final File dir, final String name) {
      */
     @Override
     public FileVisitResult accept(final Path file, final BasicFileAttributes attributes) {
-        return toFileVisitResult(accept(file.getFileName().toString()));
+        return toFileVisitResult(accept(file.getFileName().toString()), file);
     }
 
     private boolean accept(final String name) {
diff --git a/src/main/java/org/apache/commons/io/filefilter/WildcardFilter.java b/src/main/java/org/apache/commons/io/filefilter/WildcardFilter.java
index c06083cab..07de7950b 100644
--- a/src/main/java/org/apache/commons/io/filefilter/WildcardFilter.java
+++ b/src/main/java/org/apache/commons/io/filefilter/WildcardFilter.java
@@ -54,7 +54,7 @@
  *
  * <h2>Using NIO</h2>
  * <pre>
- * final Path dir = Paths.get(".");
+ * final Path dir = Paths.get("");
  * final AccumulatorPathVisitor visitor = AccumulatorPathVisitor.withLongCounters(new WildcardFilter("*test*.java~*~"));
  * //
  * // Walk one dir
diff --git a/src/main/java/org/apache/commons/io/filefilter/package.html b/src/main/java/org/apache/commons/io/filefilter/package.html
index 9612aee3c..545ee6a10 100644
--- a/src/main/java/org/apache/commons/io/filefilter/package.html
+++ b/src/main/java/org/apache/commons/io/filefilter/package.html
@@ -153,7 +153,7 @@ <h2>Using Classic IO</h2>
 <h2>Using NIO</h2>
 <p>You can combine Java <b>file tree walking</b> by using <code>java.nio.file.Files.walk()</code> APIs with filters:</p>
 <pre>
-   final Path dir = Paths.get(".");
+   final Path dir = Paths.get("");
    // We are interested in files older than one day
    final long cutoff = System.currentTimeMillis() - (24 * 60 * 60 * 1000);
    final AccumulatorPathVisitor visitor = AccumulatorPathVisitor.withLongCounters(new AgeFileFilter(cutoff));
diff --git a/src/test/java/org/apache/commons/io/FileUtilsTestCase.java b/src/test/java/org/apache/commons/io/FileUtilsTestCase.java
index 0679320b2..af318ae8f 100644
--- a/src/test/java/org/apache/commons/io/FileUtilsTestCase.java
+++ b/src/test/java/org/apache/commons/io/FileUtilsTestCase.java
@@ -58,6 +58,7 @@
 import java.util.zip.CRC32;
 import java.util.zip.Checksum;
 
+import org.apache.commons.io.filefilter.IOFileFilter;
 import org.apache.commons.io.filefilter.NameFileFilter;
 import org.apache.commons.io.filefilter.WildcardFileFilter;
 import org.apache.commons.io.test.TestUtils;
@@ -75,17 +76,57 @@
 @SuppressWarnings({"deprecation", "ResultOfMethodCallIgnored"}) // unit tests include tests of many deprecated methods
 public class FileUtilsTestCase {
 
-    private static final long DATE3 = 1000000002000L;
+    /**
+     * DirectoryWalker implementation that recursively lists all files and directories.
+     */
+    static class ListDirectoryWalker extends DirectoryWalker<File> {
 
-    private static final long DATE2 = 1000000001000L;
+        ListDirectoryWalker() {
+            super();
+        }
 
-    private static final long DATE1 = 1000000000000L;
+        @Override
+        protected void handleDirectoryStart(final File directory, final int depth, final Collection<File> results) throws IOException {
+            // Add all directories except the starting directory
+            if (depth > 0) {
+                results.add(directory);
+            }
+        }
 
-    @TempDir
-    public File temporaryFolder;
+        @Override
+        protected void handleFile(final File file, final int depth, final Collection<File> results) throws IOException {
+            results.add(file);
+        }
+
+        List<File> list(final File startDirectory) throws IOException {
+            final ArrayList<File> files = new ArrayList<>();
+            walk(startDirectory, files);
+            return files;
+        }
+    }
+
+    // Test helper class to pretend a file is shorter than it is
+    private static class ShorterFile extends File {
+        private static final long serialVersionUID = 1L;
+
+        public ShorterFile(final String pathname) {
+            super(pathname);
+        }
+
+        @Override
+        public long length() {
+            return super.length() - 1;
+        }
+    }
+
+    private static final long DATE3 = 1000000002000L;
+
+    private static final long DATE2 = 1000000001000L;
 
     // Test data
 
+    private static final long DATE1 = 1000000000000L;
+
     /**
      * Size of test directory.
      */
@@ -105,6 +146,8 @@ public class FileUtilsTestCase {
      * List files recursively
      */
     private static final ListDirectoryWalker LIST_WALKER = new ListDirectoryWalker();
+    @TempDir
+    public File temporaryFolder;
 
     /**
      * Delay in milliseconds to make sure test for "last modified date" are accurate
@@ -115,8 +158,118 @@ public class FileUtilsTestCase {
     private File testFile2;
 
     private long testFile1Size;
+
     private long testFile2Size;
 
+    private void backDateFile10Minutes(final File testFile) throws IOException {
+        final long mins10 = 1000 * 60 * 10;
+        final long lastModified1 = getLastModifiedMillis(testFile);
+        assertTrue(setLastModifiedMillis(testFile, lastModified1 - mins10));
+        // ensure it was changed
+        assertNotEquals(getLastModifiedMillis(testFile), lastModified1, "Should have changed source date");
+    }
+
+    private void consumeRemaining(Iterator<File> iterator) {
+        if (iterator != null) {
+            iterator.forEachRemaining(e -> {});
+        }
+    }
+
+    private void createCircularSymLink(final File file) throws IOException {
+        if (!FilenameUtils.isSystemWindows()) {
+            Runtime.getRuntime()
+                    .exec("ln -s " + file + "/.. " + file + "/cycle");
+        } else {
+            try {
+                Runtime.getRuntime()
+                        .exec("mklink /D " + file + "/cycle" + file + "/.. ");
+            } catch (final IOException ioe) { // So that tests run in FAT filesystems
+                //don't fail
+            }
+        }
+    }
+
+    private void createFilesForTestCopyDirectory(final File grandParentDir, final File parentDir, final File childDir) throws Exception {
+        final File childDir2 = new File(parentDir, "child2");
+        final File grandChildDir = new File(childDir, "grandChild");
+        final File grandChild2Dir = new File(childDir2, "grandChild2");
+        final File file1 = new File(grandParentDir, "file1.txt");
+        final File file2 = new File(parentDir, "file2.txt");
+        final File file3 = new File(childDir, "file3.txt");
+        final File file4 = new File(childDir2, "file4.txt");
+        final File file5 = new File(grandChildDir, "file5.txt");
+        final File file6 = new File(grandChild2Dir, "file6.txt");
+        FileUtils.deleteDirectory(grandParentDir);
+        grandChildDir.mkdirs();
+        grandChild2Dir.mkdirs();
+        FileUtils.writeStringToFile(file1, "File 1 in grandparent", "UTF8");
+        FileUtils.writeStringToFile(file2, "File 2 in parent", "UTF8");
+        FileUtils.writeStringToFile(file3, "File 3 in child", "UTF8");
+        FileUtils.writeStringToFile(file4, "File 4 in child2", "UTF8");
+        FileUtils.writeStringToFile(file5, "File 5 in grandChild", "UTF8");
+        FileUtils.writeStringToFile(file6, "File 6 in grandChild2", "UTF8");
+    }
+
+    private long getLastModifiedMillis(final File file) throws IOException {
+        return file.lastModified();
+        //https://bugs.openjdk.java.net/browse/JDK-8177809
+        //return Files.getLastModifiedTime(file.toPath()).toMillis();
+    }
+
+    private String getName() {
+        return this.getClass().getSimpleName();
+    }
+
+    private void iterateFilesAndDirs(final File dir, final IOFileFilter fileFilter,
+        final IOFileFilter dirFilter, Collection<File> expectedFilesAndDirs) {
+        Iterator<File> iterator;
+        int filesCount = 0;
+        iterator = FileUtils.iterateFilesAndDirs(dir, fileFilter, dirFilter);
+        try {
+            List<File> actualFiles = new ArrayList<>();
+            while (iterator.hasNext()) {
+                filesCount++;
+                final File file = iterator.next();
+                actualFiles.add(file);
+                assertTrue(expectedFilesAndDirs.contains(file),
+                    () -> "Unexpected directory/file " + file + ", expected one of " + expectedFilesAndDirs);
+            }
+            assertEquals(expectedFilesAndDirs.size(), filesCount, () -> actualFiles.toString());
+        } finally {
+            // MUST consume until the end in order to close the underlying stream.
+            consumeRemaining(iterator);
+        }
+    }
+
+    //-----------------------------------------------------------------------
+    void openOutputStream_noParent(final boolean createFile) throws Exception {
+        final File file = new File("test.txt");
+        assertNull(file.getParentFile());
+        try {
+            if (createFile) {
+                TestUtils.createLineBasedFile(file, new String[]{"Hello"});
+            }
+            try (FileOutputStream out = FileUtils.openOutputStream(file)) {
+                out.write(0);
+            }
+            assertTrue(file.exists());
+        } finally {
+            if (!file.delete()) {
+                file.deleteOnExit();
+            }
+        }
+    }
+
+    private boolean setLastModifiedMillis(final File testFile, final long millis) {
+        return testFile.setLastModified(millis);
+//        try {
+//            Files.setLastModifiedTime(testFile.toPath(), FileTime.fromMillis(millis));
+//        } catch (IOException e) {
+//            return false;
+//        }
+//        return true;
+    }
+
     @BeforeEach
     public void setUp() throws Exception {
         testFile1 = new File(temporaryFolder, "file1-test.txt");
@@ -160,74 +313,6 @@ public void setUp() throws Exception {
         }
     }
 
-    private String getName() {
-        return this.getClass().getSimpleName();
-    }
-
-    //-----------------------------------------------------------------------
-    @Test
-    public void testGetFile() {
-        final File expected_A = new File("src");
-        final File expected_B = new File(expected_A, "main");
-        final File expected_C = new File(expected_B, "java");
-        assertEquals(expected_A, FileUtils.getFile("src"), "A");
-        assertEquals(expected_B, FileUtils.getFile("src", "main"), "B");
-        assertEquals(expected_C, FileUtils.getFile("src", "main", "java"), "C");
-        try {
-            FileUtils.getFile((String[]) null);
-            fail("Expected NullPointerException");
-        } catch (final NullPointerException e) {
-            // expected
-        }
-    }
-
-    @Test
-    public void testGetFile_Parent() {
-        final File parent = new File("parent");
-        final File expected_A = new File(parent, "src");
-        final File expected_B = new File(expected_A, "main");
-        final File expected_C = new File(expected_B, "java");
-        assertEquals(expected_A, FileUtils.getFile(parent, "src"), "A");
-        assertEquals(expected_B, FileUtils.getFile(parent, "src", "main"), "B");
-        assertEquals(expected_C, FileUtils.getFile(parent, "src", "main", "java"), "C");
-        try {
-            FileUtils.getFile(parent, (String[]) null);
-            fail("Expected NullPointerException");
-        } catch (final NullPointerException e) {
-            // expected
-        }
-        try {
-            FileUtils.getFile((File) null, "src");
-            fail("Expected NullPointerException");
-        } catch (final NullPointerException e) {
-            // expected
-        }
-    }
-
-    @Test
-    public void testGetTempDirectoryPath() {
-        assertEquals(System.getProperty("java.io.tmpdir"),
-                FileUtils.getTempDirectoryPath());
-    }
-
-    @Test
-    public void testGetTempDirectory() {
-        final File tempDirectory = new File(System.getProperty("java.io.tmpdir"));
-        assertEquals(tempDirectory, FileUtils.getTempDirectory());
-    }
-
-    @Test
-    public void testGetUserDirectoryPath() {
-        assertEquals(System.getProperty("user.home"),
-                FileUtils.getUserDirectoryPath());
-    }
-
-    @Test
-    public void testGetUserDirectory() {
-        final File userDirectory = new File(System.getProperty("user.home"));
-        assertEquals(userDirectory, FileUtils.getUserDirectory());
-    }
-
     //-----------------------------------------------------------------------
     @Test
     public void test_openInputStream_exists() throws Exception {
@@ -259,35 +344,6 @@ public void test_openInputStream_notExists() throws Exception {
         }
     }
 
-    //-----------------------------------------------------------------------
-    void openOutputStream_noParent(final boolean createFile) throws Exception {
-        final File file = new File("test.txt");
-        assertNull(file.getParentFile());
-        try {
-            if (createFile) {
-                TestUtils.createLineBasedFile(file, new String[]{"Hello"});
-            }
-            try (FileOutputStream out = FileUtils.openOutputStream(file)) {
-                out.write(0);
-            }
-            assertTrue(file.exists());
-        } finally {
-            if (!file.delete()) {
-                file.deleteOnExit();
-            }
-        }
-    }
-
-    @Test
-    public void test_openOutputStream_noParentCreateFile() throws Exception {
-        openOutputStream_noParent(true);
-    }
-
-    @Test
-    public void test_openOutputStream_noParentNoFile() throws Exception {
-        openOutputStream_noParent(false);
-    }
-
     @Test
     public void test_openOutputStream_exists() throws Exception {
         final File file = new File(temporaryFolder, "test.txt");
@@ -309,6 +365,16 @@ public void test_openOutputStream_existsButIsDirectory() throws Exception {
         }
     }
 
+    @Test
+    public void test_openOutputStream_noParentCreateFile() throws Exception {
+        openOutputStream_noParent(true);
+    }
+
+    @Test
+    public void test_openOutputStream_noParentNoFile() throws Exception {
+        openOutputStream_noParent(false);
+    }
+
     @Test
     public void test_openOutputStream_notExists() throws Exception {
         final File file = new File(temporaryFolder, "a/test.txt");
@@ -398,188 +464,119 @@ public void testByteCountToDisplaySizeLong() {
         assertEquals("1 GB", FileUtils.byteCountToDisplaySize(Integer.MAX_VALUE));
     }
 
-    //-----------------------------------------------------------------------
     @Test
-    public void testToFile1() throws Exception {
-        final URL url = new URL("file", null, "a/b/c/file.txt");
-        final File file = FileUtils.toFile(url);
-        assertTrue(file.toString().contains("file.txt"));
-    }
-
-    @Test
-    public void testToFile2() throws Exception {
-        final URL url = new URL("file", null, "a/b/c/file%20n%61me%2520.tx%74");
-        final File file = FileUtils.toFile(url);
-        assertTrue(file.toString().contains("file name%20.txt"));
-    }
-
-    @Test
-    public void testToFile3() throws Exception {
-        assertEquals(null, FileUtils.toFile(null));
-        assertEquals(null, FileUtils.toFile(new URL("http://jakarta.apache.org")));
-    }
+    public void testChecksum() throws Exception {
+        // create a test file
+        final String text = "Imagination is more important than knowledge - Einstein";
+        final File file = new File(temporaryFolder, "checksum-test.txt");
+        FileUtils.writeStringToFile(file, text, "US-ASCII");
 
-    @Test
-    public void testToFile4() throws Exception {
-        final URL url = new URL("file", null, "a/b/c/file%%20%me.txt%");
-        final File file = FileUtils.toFile(url);
-        assertTrue(file.toString().contains("file% %me.txt%"));
-    }
+        // compute the expected checksum
+        final Checksum expectedChecksum = new CRC32();
+        expectedChecksum.update(text.getBytes("US-ASCII"), 0, text.length());
+        final long expectedValue = expectedChecksum.getValue();
 
-    /* IO-252 */
-    @Test
-    public void testToFile5() throws Exception {
-        final URL url = new URL("file", null, "both%20are%20100%20%25%20true");
-        final File file = FileUtils.toFile(url);
-        assertEquals("both are 100 % true", file.toString());
-    }
+        // compute the checksum of the file
+        final Checksum testChecksum = new CRC32();
+        final Checksum resultChecksum = FileUtils.checksum(file, testChecksum);
+        final long resultValue = resultChecksum.getValue();
 
-    @Test
-    public void testToFileUtf8() throws Exception {
-        final URL url = new URL("file", null, "/home/%C3%A4%C3%B6%C3%BC%C3%9F");
-        final File file = FileUtils.toFile(url);
-        assertTrue(file.toString().contains("\u00E4\u00F6\u00FC\u00DF"));
+        assertSame(testChecksum, resultChecksum);
+        assertEquals(expectedValue, resultValue);
     }
 
+    //-----------------------------------------------------------------------
     @Test
-    public void testDecodeUrl() {
-        assertEquals("", FileUtils.decodeUrl(""));
-        assertEquals("foo", FileUtils.decodeUrl("foo"));
-        assertEquals("+", FileUtils.decodeUrl("+"));
-        assertEquals("% ", FileUtils.decodeUrl("%25%20"));
-        assertEquals("%20", FileUtils.decodeUrl("%2520"));
-        assertEquals("jar:file:/C:/dir/sub dir/1.0/foo-1.0.jar!/org/Bar.class", FileUtils
-                .decodeUrl("jar:file:/C:/dir/sub%20dir/1.0/foo-1.0.jar!/org/Bar.class"));
-    }
+    public void testChecksumCRC32() throws Exception {
+        // create a test file
+        final String text = "Imagination is more important than knowledge - Einstein";
+        final File file = new File(temporaryFolder, "checksum-test.txt");
+        FileUtils.writeStringToFile(file, text, "US-ASCII");
 
-    @Test
-    public void testDecodeUrlLenient() {
-        assertEquals(" ", FileUtils.decodeUrl(" "));
-        assertEquals("\u00E4\u00F6\u00FC\u00DF", FileUtils.decodeUrl("\u00E4\u00F6\u00FC\u00DF"));
-        assertEquals("%", FileUtils.decodeUrl("%"));
-        assertEquals("% ", FileUtils.decodeUrl("%%20"));
-        assertEquals("%2", FileUtils.decodeUrl("%2"));
-        assertEquals("%2G", FileUtils.decodeUrl("%2G"));
-    }
+        // compute the expected checksum
+        final Checksum expectedChecksum = new CRC32();
+        expectedChecksum.update(text.getBytes("US-ASCII"), 0, text.length());
+        final long expectedValue = expectedChecksum.getValue();
 
-    @Test
-    public void testDecodeUrlNullSafe() {
-        assertNull(FileUtils.decodeUrl(null));
-    }
+        // compute the checksum of the file
+        final long resultValue = FileUtils.checksumCRC32(file);
 
-    @Test
-    public void testDecodeUrlEncodingUtf8() {
-        assertEquals("\u00E4\u00F6\u00FC\u00DF", FileUtils.decodeUrl("%C3%A4%C3%B6%C3%BC%C3%9F"));
+        assertEquals(expectedValue, resultValue);
     }
 
-    // toFiles
-
     @Test
-    public void testToFiles1() throws Exception {
-        final URL[] urls = new URL[]{
-                new URL("file", null, "file1.txt"),
-                new URL("file", null, "file2.txt"),
-        };
-        final File[] files = FileUtils.toFiles(urls);
-
-        assertEquals(urls.length, files.length);
-        assertEquals(true, files[0].toString().contains("file1.txt"), "File: " + files[0]);
-        assertEquals(true, files[1].toString().contains("file2.txt"), "File: " + files[1]);
-    }
+    public void testChecksumDouble() throws Exception {
+        // create a test file
+        final String text1 = "Imagination is more important than knowledge - Einstein";
+        final File file1 = new File(temporaryFolder, "checksum-test.txt");
+        FileUtils.writeStringToFile(file1, text1, "US-ASCII");
 
-    @Test
-    public void testToFiles2() throws Exception {
-        final URL[] urls = new URL[]{
-                new URL("file", null, "file1.txt"),
-                null,
-        };
-        final File[] files = FileUtils.toFiles(urls);
+        // create a second test file
+        final String text2 = "To be or not to be - Shakespeare";
+        final File file2 = new File(temporaryFolder, "checksum-test2.txt");
+        FileUtils.writeStringToFile(file2, text2, "US-ASCII");
 
-        assertEquals(urls.length, files.length);
-        assertEquals(true, files[0].toString().contains("file1.txt"), "File: " + files[0]);
-        assertEquals(null, files[1], "File: " + files[1]);
-    }
+        // compute the expected checksum
+        final Checksum expectedChecksum = new CRC32();
+        expectedChecksum.update(text1.getBytes("US-ASCII"), 0, text1.length());
+        expectedChecksum.update(text2.getBytes("US-ASCII"), 0, text2.length());
+        final long expectedValue = expectedChecksum.getValue();
 
-    @Test
-    public void testToFiles3() throws Exception {
-        final URL[] urls = null;
-        final File[] files = FileUtils.toFiles(urls);
+        // compute the checksum of the file
+        final Checksum testChecksum = new CRC32();
+        FileUtils.checksum(file1, testChecksum);
+        FileUtils.checksum(file2, testChecksum);
+        final long resultValue = testChecksum.getValue();
 
-        assertEquals(0, files.length);
+        assertEquals(expectedValue, resultValue);
     }
 
     @Test
-    public void testToFiles3a() throws Exception {
-        final URL[] urls = new URL[0]; // empty array
-        final File[] files = FileUtils.toFiles(urls);
-
-        assertEquals(0, files.length);
+    public void testChecksumOnDirectory() throws Exception {
+        try {
+            FileUtils.checksum(new File("."), new CRC32());
+            fail();
+        } catch (final IllegalArgumentException ex) {
+            // expected
+        }
     }
 
     @Test
-    public void testToFiles4() throws Exception {
-        final URL[] urls = new URL[]{
-                new URL("file", null, "file1.txt"),
-                new URL("http", "jakarta.apache.org", "file1.txt"),
-        };
+    public void testChecksumOnNullChecksum() throws Exception {
+        // create a test file
+        final String text = "Imagination is more important than knowledge - Einstein";
+        final File file = new File(temporaryFolder, "checksum-test.txt");
+        FileUtils.writeStringToFile(file, text, "US-ASCII");
         try {
-            FileUtils.toFiles(urls);
+            FileUtils.checksum(file, null);
             fail();
-        } catch (final IllegalArgumentException ignore) {
+        } catch (final NullPointerException ex) {
+            // expected
         }
     }
 
-    // toURLs
-
     @Test
-    public void testToURLs1() throws Exception {
-        final File[] files = new File[]{
-                new File(temporaryFolder, "file1.txt"),
-                new File(temporaryFolder, "file2.txt"),
-                new File(temporaryFolder, "test file.txt"),
-        };
-        final URL[] urls = FileUtils.toURLs(files);
-
-        assertEquals(files.length, urls.length);
-        assertTrue(urls[0].toExternalForm().startsWith("file:"));
-        assertTrue(urls[0].toExternalForm().contains("file1.txt"));
-        assertTrue(urls[1].toExternalForm().startsWith("file:"));
-        assertTrue(urls[1].toExternalForm().contains("file2.txt"));
-
-        // Test escaped char
-        assertTrue(urls[2].toExternalForm().startsWith("file:"));
-        assertTrue(urls[2].toExternalForm().contains("test%20file.txt"));
+    public void testChecksumOnNullFile() throws Exception {
+        try {
+            FileUtils.checksum(null, new CRC32());
+            fail();
+        } catch (final NullPointerException ex) {
+            // expected
+        }
     }
 
-//   @Test public void testToURLs2() throws Exception {
-//        File[] files = new File[] {
-//            new File(temporaryFolder, "file1.txt"),
-//            null,
-//        };
-//        URL[] urls = FileUtils.toURLs(files);
-//
-//        assertEquals(files.length, urls.length);
-//        assertTrue(urls[0].toExternalForm().startsWith("file:"));
-//        assertTrue(urls[0].toExternalForm().indexOf("file1.txt") > 0);
-//        assertEquals(null, urls[1]);
-//    }
-//
-//   @Test public void testToURLs3() throws Exception {
-//        File[] files = null;
-//        URL[] urls = FileUtils.toURLs(files);
-//
-//        assertEquals(0, urls.length);
-//    }
-
+    // Compare sizes of a directory tree using long and BigInteger methods
     @Test
-    public void testToURLs3a() throws Exception {
-        final File[] files = new File[0]; // empty array
-        final URL[] urls = FileUtils.toURLs(files);
-
-        assertEquals(0, urls.length);
+    public void testCompareSizeOf() {
+        final File start = new File("src/test/java");
+        final long sizeLong1 = FileUtils.sizeOf(start);
+        final BigInteger sizeBig = FileUtils.sizeOfAsBigInteger(start);
+        final long sizeLong2 = FileUtils.sizeOf(start);
+        assertEquals(sizeLong1, sizeLong2, "Size should not change");
+        assertEquals(sizeLong1, sizeBig.longValue(), "longSize should equal BigSize");
     }
 
-    // contentEquals
+    // toFiles
 
     @Test
     public void testContentEquals() throws Exception {
@@ -722,499 +719,398 @@ public void testContentEqualsIgnoreEOL() throws Exception {
         assertTrue(FileUtils.contentEqualsIgnoreEOL(file1, file2, null));
     }
 
-    // copyURLToFile
-
     @Test
-    public void testCopyURLToFile() throws Exception {
-        // Creates file
-        final File file = new File(temporaryFolder, getName());
-        file.deleteOnExit();
-
-        // Loads resource
-        final String resourceName = "/java/lang/Object.class";
-        FileUtils.copyURLToFile(getClass().getResource(resourceName), file);
-
-        // Tests that resuorce was copied correctly
-        try (FileInputStream fis = new FileInputStream(file)) {
-            assertTrue(IOUtils.contentEquals(getClass().getResourceAsStream(resourceName), fis),
-                    "Content is not equal.");
+    public void testCopyDirectoryErrors() throws Exception {
+        try {
+            FileUtils.copyDirectory(null, null);
+            fail();
+        } catch (final NullPointerException ignore) {
         }
-        //TODO Maybe test copy to itself like for copyFile()
-    }
-
-    @Test
-    public void testCopyURLToFileWithTimeout() throws Exception {
-        // Creates file
-        final File file = new File(temporaryFolder, "testCopyURLToFileWithTimeout");
-        file.deleteOnExit();
-
-        // Loads resource
-        final String resourceName = "/java/lang/Object.class";
-        FileUtils.copyURLToFile(getClass().getResource(resourceName), file, 500, 500);
-
-        // Tests that resuorce was copied correctly
-        try (FileInputStream fis = new FileInputStream(file)) {
-            assertTrue(IOUtils.contentEquals(getClass().getResourceAsStream(resourceName), fis),
-                    "Content is not equal.");
+        try {
+            FileUtils.copyDirectory(new File("a"), null);
+            fail();
+        } catch (final NullPointerException ignore) {
         }
-        //TODO Maybe test copy to itself like for copyFile()
-    }
-
-    // forceMkdir
-
-    @Test
-    public void testForceMkdir() throws Exception {
-        // Tests with existing directory
-        FileUtils.forceMkdir(temporaryFolder);
-
-        // Creates test file
-        final File testFile = new File(temporaryFolder, getName());
-        testFile.deleteOnExit();
-        testFile.createNewFile();
-        assertTrue(testFile.exists(), "Test file does not exist.");
-
-        // Tests with existing file
         try {
-            FileUtils.forceMkdir(testFile);
-            fail("Exception expected.");
+            FileUtils.copyDirectory(null, new File("a"));
+            fail();
+        } catch (final NullPointerException ignore) {
+        }
+        try {
+            FileUtils.copyDirectory(new File("doesnt-exist"), new File("a"));
+            fail();
+        } catch (final IOException ignore) {
+        }
+        try {
+            FileUtils.copyDirectory(testFile1, new File("a"));
+            fail();
+        } catch (final IOException ignore) {
+        }
+        try {
+            FileUtils.copyDirectory(temporaryFolder, testFile1);
+            fail();
+        } catch (final IOException ignore) {
+        }
+        try {
+            FileUtils.copyDirectory(temporaryFolder, temporaryFolder);
+            fail();
         } catch (final IOException ignore) {
         }
-
-        testFile.delete();
-
-        // Tests with non-existent directory
-        FileUtils.forceMkdir(testFile);
-        assertTrue(testFile.exists(), "Directory was not created.");
     }
 
     @Test
-    public void testForceMkdirParent() throws Exception {
-        // Tests with existing directory
-        assertTrue(temporaryFolder.exists());
-        final File testParentDir = new File(temporaryFolder, "testForceMkdirParent");
-        testParentDir.delete();
-        assertFalse(testParentDir.exists());
-        final File testFile = new File(testParentDir, "test.txt");
-        assertFalse(testParentDir.exists());
-        assertFalse(testFile.exists());
-        // Create
-        FileUtils.forceMkdirParent(testFile);
-        assertTrue(testParentDir.exists());
-        assertFalse(testFile.exists());
-        // Again
-        FileUtils.forceMkdirParent(testFile);
-        assertTrue(testParentDir.exists());
-        assertFalse(testFile.exists());
-    }
+    public void testCopyDirectoryFiltered() throws Exception {
+        final File grandParentDir = new File(temporaryFolder, "grandparent");
+        final File parentDir = new File(grandParentDir, "parent");
+        final File childDir = new File(parentDir, "child");
+        createFilesForTestCopyDirectory(grandParentDir, parentDir, childDir);
 
-    // sizeOfDirectory
+        final NameFileFilter filter = new NameFileFilter(new String[]{"parent", "child", "file3.txt"});
+        final File destDir = new File(temporaryFolder, "copydest");
+
+        FileUtils.copyDirectory(grandParentDir, destDir, filter);
+        final List<File> files = LIST_WALKER.list(destDir);
+        assertEquals(3, files.size());
+        assertEquals("parent", files.get(0).getName());
+        assertEquals("child", files.get(1).getName());
+        assertEquals("file3.txt", files.get(2).getName());
+    }
 
     @Test
-    public void testSizeOfDirectory() throws Exception {
-        final File file = new File(temporaryFolder, getName());
+    public void testCopyDirectoryPreserveDates() throws Exception {
+        final File source = new File(temporaryFolder, "source");
+        final File sourceDirectory = new File(source, "directory");
+        final File sourceFile = new File(sourceDirectory, "hello.txt");
 
-        // Non-existent file
-        try {
-            FileUtils.sizeOfDirectory(file);
-            fail("Exception expected.");
-        } catch (final IllegalArgumentException ignore) {
-        }
+        // Prepare source data
+        source.mkdirs();
+        sourceDirectory.mkdir();
+        FileUtils.writeStringToFile(sourceFile, "HELLO WORLD", "UTF8");
+        // Set dates in reverse order to avoid overwriting previous values
+        // Also, use full seconds (arguments are in ms) close to today
+        // but still highly unlikely to occur in the real world
+        assertTrue(setLastModifiedMillis(sourceFile, DATE3));
+        assertTrue(setLastModifiedMillis(sourceDirectory, DATE2));
+        assertTrue(setLastModifiedMillis(source, DATE1));
 
-        // Creates file
-        file.createNewFile();
+        final File target = new File(temporaryFolder, "target");
+        final File targetDirectory = new File(target, "directory");
+        final File targetFile = new File(targetDirectory, "hello.txt");
 
-        // Existing file
-        try {
-            FileUtils.sizeOfDirectory(file);
-            fail("Exception expected.");
-        } catch (final IllegalArgumentException ignore) {
+        // Test with preserveFileDate disabled
+        // On Windows, the last modified time is copied by default.
+        FileUtils.copyDirectory(source, target, false);
+        assertNotEquals(DATE1, getLastModifiedMillis(target));
+        assertNotEquals(DATE2, getLastModifiedMillis(targetDirectory));
+        if (!SystemUtils.IS_OS_WINDOWS) {
+            assertNotEquals(DATE3, getLastModifiedMillis(targetFile));
         }
+        FileUtils.deleteDirectory(target);
 
-        // Existing directory
-        file.delete();
-        file.mkdir();
+        // Test with preserveFileDate enabled
+        FileUtils.copyDirectory(source, target, true);
+        assertEquals(DATE1, getLastModifiedMillis(target));
+        assertEquals(DATE2, getLastModifiedMillis(targetDirectory));
+        assertEquals(DATE3, getLastModifiedMillis(targetFile));
+        FileUtils.deleteDirectory(target);
 
-        // Create a cyclic symlink
-        this.createCircularSymLink(file);
+        // also if the target directory already exists (IO-190)
+        target.mkdirs();
+        FileUtils.copyDirectory(source, target, true);
+        assertEquals(DATE1, getLastModifiedMillis(target));
+        assertEquals(DATE2, getLastModifiedMillis(targetDirectory));
+        assertEquals(DATE3, getLastModifiedMillis(targetFile));
+        FileUtils.deleteDirectory(target);
 
-        assertEquals(TEST_DIRECTORY_SIZE, FileUtils.sizeOfDirectory(file), "Unexpected directory size");
+        // also if the target subdirectory already exists (IO-190)
+        targetDirectory.mkdirs();
+        FileUtils.copyDirectory(source, target, true);
+        assertEquals(DATE1, getLastModifiedMillis(target));
+        assertEquals(DATE2, getLastModifiedMillis(targetDirectory));
+        assertEquals(DATE3, getLastModifiedMillis(targetFile));
+        FileUtils.deleteDirectory(target);
     }
 
-    private void createCircularSymLink(final File file) throws IOException {
-        if (!FilenameUtils.isSystemWindows()) {
-            Runtime.getRuntime()
-                    .exec("ln -s " + file + "/.. " + file + "/cycle");
-        } else {
-            try {
-                Runtime.getRuntime()
-                        .exec("mklink /D " + file + "/cycle" + file + "/.. ");
-            } catch (final IOException ioe) { // So that tests run in FAT filesystems
-                //don't fail
-            }
-        }
-    }
+    // toURLs
 
+    /* Test for IO-141 */
     @Test
-    public void testSizeOfDirectoryAsBigInteger() throws Exception {
-        final File file = new File(temporaryFolder, getName());
+    public void testCopyDirectoryToChild() throws Exception {
+        final File grandParentDir = new File(temporaryFolder, "grandparent");
+        final File parentDir = new File(grandParentDir, "parent");
+        final File childDir = new File(parentDir, "child");
+        createFilesForTestCopyDirectory(grandParentDir, parentDir, childDir);
 
-        // Non-existent file
-        try {
-            FileUtils.sizeOfDirectoryAsBigInteger(file);
-            fail("Exception expected.");
-        } catch (final IllegalArgumentException ignore) {
-        }
+        final long expectedCount = LIST_WALKER.list(grandParentDir).size() +
+                LIST_WALKER.list(parentDir).size();
+        final long expectedSize = FileUtils.sizeOfDirectory(grandParentDir) +
+                FileUtils.sizeOfDirectory(parentDir);
+        FileUtils.copyDirectory(parentDir, childDir);
+        assertEquals(expectedCount, LIST_WALKER.list(grandParentDir).size());
+        assertEquals(expectedSize, FileUtils.sizeOfDirectory(grandParentDir));
+        assertTrue(expectedCount > 0, "Count > 0");
+        assertTrue(expectedSize > 0, "Size > 0");
+    }
 
-        // Creates file
-        file.createNewFile();
-        file.deleteOnExit();
+//   @Test public void testToURLs2() throws Exception {
+//        File[] files = new File[] {
+//            new File(temporaryFolder, "file1.txt"),
+//            null,
+//        };
+//        URL[] urls = FileUtils.toURLs(files);
+//
+//        assertEquals(files.length, urls.length);
+//        assertTrue(urls[0].toExternalForm().startsWith("file:"));
+//        assertTrue(urls[0].toExternalForm().indexOf("file1.txt") > 0);
+//        assertEquals(null, urls[1]);
+//    }
+//
+//   @Test public void testToURLs3() throws Exception {
+//        File[] files = null;
+//        URL[] urls = FileUtils.toURLs(files);
+//
+//        assertEquals(0, urls.length);
+//    }
 
-        // Existing file
+    @Test
+    public void testCopyDirectoryToDirectory_NonExistingDest() throws Exception {
+        if (!testFile1.getParentFile().exists()) {
+            throw new IOException("Cannot create file " + testFile1
+                    + " as the parent directory does not exist");
+        }
+        final BufferedOutputStream output1 =
+                new BufferedOutputStream(new FileOutputStream(testFile1));
         try {
-            FileUtils.sizeOfDirectoryAsBigInteger(file);
-            fail("Exception expected.");
-        } catch (final IllegalArgumentException ignore) {
+            TestUtils.generateTestData(output1, 1234);
+        } finally {
+            IOUtils.closeQuietly(output1);
         }
-
-        // Existing directory
-        file.delete();
-        file.mkdir();
-
-        this.createCircularSymLink(file);
-
-        assertEquals(TEST_DIRECTORY_SIZE_BI, FileUtils.sizeOfDirectoryAsBigInteger(file), "Unexpected directory size");
-
-        // Existing directory which size is greater than zero
-        file.delete();
-        file.mkdir();
-
-        final File nonEmptyFile = new File(file, "nonEmptyFile" + System.nanoTime());
-        if (!nonEmptyFile.getParentFile().exists()) {
-            throw new IOException("Cannot create file " + nonEmptyFile
+        if (!testFile2.getParentFile().exists()) {
+            throw new IOException("Cannot create file " + testFile2
                     + " as the parent directory does not exist");
         }
         final BufferedOutputStream output =
-                new BufferedOutputStream(new FileOutputStream(nonEmptyFile));
+                new BufferedOutputStream(new FileOutputStream(testFile2));
         try {
-            TestUtils.generateTestData(output, TEST_DIRECTORY_SIZE_GT_ZERO_BI.longValue());
+            TestUtils.generateTestData(output, 4321);
         } finally {
             IOUtils.closeQuietly(output);
         }
-        nonEmptyFile.deleteOnExit();
-
-        assertEquals(TEST_DIRECTORY_SIZE_GT_ZERO_BI, FileUtils.sizeOfDirectoryAsBigInteger(file),
-                "Unexpected directory size");
-
-        nonEmptyFile.delete();
-        file.delete();
-    }
+        final File srcDir = temporaryFolder;
+        final File subDir = new File(srcDir, "sub");
+        subDir.mkdir();
+        final File subFile = new File(subDir, "A.txt");
+        FileUtils.writeStringToFile(subFile, "HELLO WORLD", "UTF8");
+        final File destDir = new File(System.getProperty("java.io.tmpdir"), "tmp-FileUtilsTestCase");
+        FileUtils.deleteDirectory(destDir);
+        final File actualDestDir = new File(destDir, srcDir.getName());
 
-    // Compare sizes of a directory tree using long and BigInteger methods
-    @Test
-    public void testCompareSizeOf() {
-        final File start = new File("src/test/java");
-        final long sizeLong1 = FileUtils.sizeOf(start);
-        final BigInteger sizeBig = FileUtils.sizeOfAsBigInteger(start);
-        final long sizeLong2 = FileUtils.sizeOf(start);
-        assertEquals(sizeLong1, sizeLong2, "Size should not change");
-        assertEquals(sizeLong1, sizeBig.longValue(), "longSize should equal BigSize");
+        FileUtils.copyDirectoryToDirectory(srcDir, destDir);
+
+        assertTrue(destDir.exists(), "Check exists");
+        assertTrue(actualDestDir.exists(), "Check exists");
+        final long srcSize = FileUtils.sizeOfDirectory(srcDir);
+        assertTrue(srcSize > 0, "Size > 0");
+        assertEquals(srcSize, FileUtils.sizeOfDirectory(actualDestDir), "Check size");
+        assertTrue(new File(actualDestDir, "sub/A.txt").exists());
+        FileUtils.deleteDirectory(destDir);
     }
 
-    @Test
-    public void testSizeOf() throws Exception {
-        final File file = new File(temporaryFolder, getName());
+    // contentEquals
 
-        // Null argument
+    @Test
+    public void testCopyDirectoryToExistingDest() throws Exception {
+        if (!testFile1.getParentFile().exists()) {
+            throw new IOException("Cannot create file " + testFile1
+                    + " as the parent directory does not exist");
+        }
+        final BufferedOutputStream output1 =
+                new BufferedOutputStream(new FileOutputStream(testFile1));
         try {
-            FileUtils.sizeOf(null);
-            fail("Exception expected.");
-        } catch (final NullPointerException ignore) {
+            TestUtils.generateTestData(output1, 1234);
+        } finally {
+            IOUtils.closeQuietly(output1);
         }
-
-        // Non-existent file
+        if (!testFile2.getParentFile().exists()) {
+            throw new IOException("Cannot create file " + testFile2
+                    + " as the parent directory does not exist");
+        }
+        final BufferedOutputStream output =
+                new BufferedOutputStream(new FileOutputStream(testFile2));
         try {
-            FileUtils.sizeOf(file);
-            fail("Exception expected.");
-        } catch (final IllegalArgumentException ignore) {
+            TestUtils.generateTestData(output, 4321);
+        } finally {
+            IOUtils.closeQuietly(output);
         }
+        final File srcDir = temporaryFolder;
+        final File subDir = new File(srcDir, "sub");
+        subDir.mkdir();
+        final File subFile = new File(subDir, "A.txt");
+        FileUtils.writeStringToFile(subFile, "HELLO WORLD", "UTF8");
+        final File destDir = new File(System.getProperty("java.io.tmpdir"), "tmp-FileUtilsTestCase");
+        FileUtils.deleteDirectory(destDir);
+        destDir.mkdirs();
 
-        // Creates file
-        file.createNewFile();
-        file.deleteOnExit();
+        FileUtils.copyDirectory(srcDir, destDir);
 
-        // New file
-        assertEquals(0, FileUtils.sizeOf(file));
-        file.delete();
+        final long srcSize = FileUtils.sizeOfDirectory(srcDir);
+        assertTrue(srcSize > 0, "Size > 0");
+        assertEquals(srcSize, FileUtils.sizeOfDirectory(destDir));
+        assertTrue(new File(destDir, "sub/A.txt").exists());
+    }
 
-        // Existing file
-        assertEquals(testFile1Size, FileUtils.sizeOf(testFile1), "Unexpected files size");
+    /* Test for IO-141 */
+    @Test
+    public void testCopyDirectoryToGrandChild() throws Exception {
+        final File grandParentDir = new File(temporaryFolder, "grandparent");
+        final File parentDir = new File(grandParentDir, "parent");
+        final File childDir = new File(parentDir, "child");
+        createFilesForTestCopyDirectory(grandParentDir, parentDir, childDir);
 
-        // Existing directory
-        assertEquals(TEST_DIRECTORY_SIZE, FileUtils.sizeOf(temporaryFolder), "Unexpected directory size");
+        final long expectedCount = LIST_WALKER.list(grandParentDir).size() * 2;
+        final long expectedSize = FileUtils.sizeOfDirectory(grandParentDir) * 2;
+        FileUtils.copyDirectory(grandParentDir, childDir);
+        assertEquals(expectedCount, LIST_WALKER.list(grandParentDir).size());
+        assertEquals(expectedSize, FileUtils.sizeOfDirectory(grandParentDir));
+        assertTrue(expectedSize > 0, "Size > 0");
     }
 
+    // copyURLToFile
+
+    /* Test for IO-217 FileUtils.copyDirectoryToDirectory makes infinite loops */
     @Test
-    public void testSizeOfAsBigInteger() throws Exception {
-        final File file = new File(temporaryFolder, getName());
+    public void testCopyDirectoryToItself() throws Exception {
+        final File dir = new File(temporaryFolder, "itself");
+        dir.mkdirs();
+        FileUtils.copyDirectoryToDirectory(dir, dir);
+        assertEquals(1, LIST_WALKER.list(dir).size());
+    }
 
-        // Null argument
+    @Test
+    public void testCopyDirectoryToNonExistingDest() throws Exception {
+        if (!testFile1.getParentFile().exists()) {
+            throw new IOException("Cannot create file " + testFile1
+                    + " as the parent directory does not exist");
+        }
+        final BufferedOutputStream output1 =
+                new BufferedOutputStream(new FileOutputStream(testFile1));
         try {
-            FileUtils.sizeOfAsBigInteger(null);
-            fail("Exception expected.");
-        } catch (final NullPointerException ignore) {
+            TestUtils.generateTestData(output1, 1234);
+        } finally {
+            IOUtils.closeQuietly(output1);
         }
-
-        // Non-existent file
+        if (!testFile2.getParentFile().exists()) {
+            throw new IOException("Cannot create file " + testFile2
+                    + " as the parent directory does not exist");
+        }
+        final BufferedOutputStream output =
+                new BufferedOutputStream(new FileOutputStream(testFile2));
         try {
-            FileUtils.sizeOfAsBigInteger(file);
-            fail("Exception expected.");
-        } catch (final IllegalArgumentException ignore) {
+            TestUtils.generateTestData(output, 4321);
+        } finally {
+            IOUtils.closeQuietly(output);
         }
+        final File srcDir = temporaryFolder;
+        final File subDir = new File(srcDir, "sub");
+        subDir.mkdir();
+        final File subFile = new File(subDir, "A.txt");
+        FileUtils.writeStringToFile(subFile, "HELLO WORLD", "UTF8");
+        final File destDir = new File(System.getProperty("java.io.tmpdir"), "tmp-FileUtilsTestCase");
+        FileUtils.deleteDirectory(destDir);
 
-        // Creates file
-        file.createNewFile();
-        file.deleteOnExit();
+        FileUtils.copyDirectory(srcDir, destDir);
 
-        // New file
-        assertEquals(BigInteger.ZERO, FileUtils.sizeOfAsBigInteger(file));
-        file.delete();
+        assertTrue(destDir.exists(), "Check exists");
+        final long sizeOfSrcDirectory = FileUtils.sizeOfDirectory(srcDir);
+        assertTrue(sizeOfSrcDirectory > 0, "Size > 0");
+        assertEquals(sizeOfSrcDirectory, FileUtils.sizeOfDirectory(destDir), "Check size");
+        assertTrue(new File(destDir, "sub/A.txt").exists());
+        FileUtils.deleteDirectory(destDir);
+    }
 
-        // Existing file
-        assertEquals(BigInteger.valueOf(testFile1Size), FileUtils.sizeOfAsBigInteger(testFile1),
-                "Unexpected files size");
+    // forceMkdir
 
-        // Existing directory
-        assertEquals(TEST_DIRECTORY_SIZE_BI, FileUtils.sizeOfAsBigInteger(temporaryFolder),
-                "Unexpected directory size");
+    @Test
+    public void testCopyFile1() throws Exception {
+        final File destination = new File(temporaryFolder, "copy1.txt");
+
+        backDateFile10Minutes(testFile1); // set test file back 10 minutes
+
+        FileUtils.copyFile(testFile1, destination);
+        assertTrue(destination.exists(), "Check Exist");
+        assertEquals(testFile1Size, destination.length(), "Check Full copy");
+        assertEquals(getLastModifiedMillis(testFile1), getLastModifiedMillis(destination), "Check last modified date preserved");
     }
 
-    // isFileNewer / isFileOlder
     @Test
-    public void testIsFileNewerOlder() throws Exception {
-        final File reference = new File(temporaryFolder, "FileUtils-reference.txt");
-        final File oldFile = new File(temporaryFolder, "FileUtils-old.txt");
-        final File newFile = new File(temporaryFolder, "FileUtils-new.txt");
-        final File invalidFile = new File(temporaryFolder, "FileUtils-invalid-file.txt");
-
-        // Create Files
-        if (!oldFile.getParentFile().exists()) {
-            throw new IOException("Cannot create file " + oldFile
-                    + " as the parent directory does not exist");
-        }
-        final BufferedOutputStream output1 =
-                new BufferedOutputStream(new FileOutputStream(oldFile));
-        try {
-            TestUtils.generateTestData(output1, 0);
-        } finally {
-            IOUtils.closeQuietly(output1);
+    public void testCopyFile1ToDir() throws Exception {
+        final File directory = new File(temporaryFolder, "subdir");
+        if (!directory.exists()) {
+            directory.mkdirs();
         }
+        final File destination = new File(directory, testFile1.getName());
 
-        do {
-            try {
-                TestUtils.sleep(1000);
-            } catch (final InterruptedException ie) {
-                // ignore
-            }
-            if (!reference.getParentFile().exists()) {
-                throw new IOException("Cannot create file " + reference
-                        + " as the parent directory does not exist");
-            }
-            final BufferedOutputStream output =
-                    new BufferedOutputStream(new FileOutputStream(reference));
-            try {
-                TestUtils.generateTestData(output, 0);
-            } finally {
-                IOUtils.closeQuietly(output);
-            }
-        } while (getLastModifiedMillis(oldFile) == getLastModifiedMillis(reference));
+        backDateFile10Minutes(testFile1);
 
-        final Date date = new Date();
-        final long now = date.getTime();
-        final Instant instant = date.toInstant();
-        final ZonedDateTime zonedDateTime = ZonedDateTime.ofInstant(instant, ZoneId.systemDefault());
-        final LocalDateTime localDateTime = zonedDateTime.toLocalDateTime();
-        final LocalDate localDate = zonedDateTime.toLocalDate();
-        final LocalDate localDatePlusDay = localDate.plusDays(1);
-        final LocalTime localTime = LocalTime.ofSecondOfDay(0);
+        FileUtils.copyFileToDirectory(testFile1, directory);
+        assertTrue(destination.exists(), "Check Exist");
+        assertEquals(testFile1Size, destination.length(), "Check Full copy");
+        assertEquals(testFile1.lastModified(), destination.lastModified(), "Check last modified date preserved");
 
-        do {
-            try {
-                TestUtils.sleep(1000);
-            } catch (final InterruptedException ie) {
-                // ignore
-            }
-            if (!newFile.getParentFile().exists()) {
-                throw new IOException("Cannot create file " + newFile
-                        + " as the parent directory does not exist");
-            }
-            final BufferedOutputStream output =
-                    new BufferedOutputStream(new FileOutputStream(newFile));
-            try {
-                TestUtils.generateTestData(output, 0);
-            } finally {
-                IOUtils.closeQuietly(output);
-            }
-        } while (getLastModifiedMillis(reference) == getLastModifiedMillis(newFile));
+        assertThrows(IOException.class,
+            () -> FileUtils.copyFileToDirectory(destination, directory),
+            "Should not be able to copy a file into the same directory as itself");
+    }
 
-        // Test isFileNewer()
-        assertFalse(FileUtils.isFileNewer(oldFile, reference), "Old File - Newer - File");
-        assertFalse(FileUtils.isFileNewer(oldFile, date), "Old File - Newer - Date");
-        assertFalse(FileUtils.isFileNewer(oldFile, now), "Old File - Newer - Mili");
-        assertFalse(FileUtils.isFileNewer(oldFile, instant), "Old File - Newer - Instant");
-        assertFalse(FileUtils.isFileNewer(oldFile, zonedDateTime), "Old File - Newer - ZonedDateTime");
-        assertFalse(FileUtils.isFileNewer(oldFile, localDateTime), "Old File - Newer - LocalDateTime");
-        assertFalse(FileUtils.isFileNewer(oldFile, localDateTime, ZoneId.systemDefault()), "Old File - Newer - LocalDateTime,ZoneId");
-        assertFalse(FileUtils.isFileNewer(oldFile, localDate), "Old File - Newer - LocalDate");
-        assertTrue(FileUtils.isFileNewer(oldFile, localDate, localTime), "Old File - Newer - LocalDate,ZoneId");
-        assertFalse(FileUtils.isFileNewer(oldFile, localDatePlusDay), "Old File - Newer - LocalDate plus one day");
-        assertFalse(FileUtils.isFileNewer(oldFile, localDatePlusDay, localTime), "Old File - Newer - LocalDate plus one day,ZoneId");
-
-        assertTrue(FileUtils.isFileNewer(newFile, reference), "New File - Newer - File");
-        assertTrue(FileUtils.isFileNewer(newFile, date), "New File - Newer - Date");
-        assertTrue(FileUtils.isFileNewer(newFile, now), "New File - Newer - Mili");
-        assertTrue(FileUtils.isFileNewer(newFile, instant), "New File - Newer - Instant");
-        assertTrue(FileUtils.isFileNewer(newFile, zonedDateTime), "New File - Newer - ZonedDateTime");
-        assertTrue(FileUtils.isFileNewer(newFile, localDateTime), "New File - Newer - LocalDateTime");
-        assertTrue(FileUtils.isFileNewer(newFile, localDateTime, ZoneId.systemDefault()), "New File - Newer - LocalDateTime,ZoneId");
-        assertFalse(FileUtils.isFileNewer(newFile, localDate), "New File - Newer - LocalDate");
-        assertTrue(FileUtils.isFileNewer(newFile, localDate, localTime), "New File - Newer - LocalDate,ZoneId");
-        assertFalse(FileUtils.isFileNewer(newFile, localDatePlusDay), "New File - Newer - LocalDate plus one day");
-        assertFalse(FileUtils.isFileNewer(newFile, localDatePlusDay, localTime), "New File - Newer - LocalDate plus one day,ZoneId");
-        assertFalse(FileUtils.isFileNewer(invalidFile, reference), "Invalid - Newer - File");
-        final String invalidFileName = invalidFile.getName();
-        try {
-            FileUtils.isFileNewer(newFile, invalidFile);
-            fail("Should have cause IllegalArgumentException");
-        } catch (final IllegalArgumentException iae) {
-            final String message = iae.getMessage();
-            assertTrue(message.contains(invalidFileName), "Message should contain: " + invalidFileName + " but was: " + message);
-        }
-
-        // Test isFileOlder()
-        assertTrue(FileUtils.isFileOlder(oldFile, reference), "Old File - Older - File");
-        assertTrue(FileUtils.isFileOlder(oldFile, date), "Old File - Older - Date");
-        assertTrue(FileUtils.isFileOlder(oldFile, now), "Old File - Older - Mili");
-        assertTrue(FileUtils.isFileOlder(oldFile, instant), "Old File - Older - Instant");
-        assertTrue(FileUtils.isFileOlder(oldFile, zonedDateTime), "Old File - Older - ZonedDateTime");
-        assertTrue(FileUtils.isFileOlder(oldFile, localDateTime), "Old File - Older - LocalDateTime");
-        assertTrue(FileUtils.isFileOlder(oldFile, localDateTime, ZoneId.systemDefault()), "Old File - Older - LocalDateTime,LocalTime");
-        assertTrue(FileUtils.isFileOlder(oldFile, localDate), "Old File - Older - LocalDate");
-        assertFalse(FileUtils.isFileOlder(oldFile, localDate, localTime), "Old File - Older - LocalDate,ZoneId");
-        assertTrue(FileUtils.isFileOlder(oldFile, localDatePlusDay), "Old File - Older - LocalDate plus one day");
-        assertTrue(FileUtils.isFileOlder(oldFile, localDatePlusDay, localTime), "Old File - Older - LocalDate plus one day,LocalTime");
-
-        assertFalse(FileUtils.isFileOlder(newFile, reference), "New File - Older - File");
-        assertFalse(FileUtils.isFileOlder(newFile, date), "New File - Older - Date");
-        assertFalse(FileUtils.isFileOlder(newFile, now), "New File - Older - Mili");
-        assertFalse(FileUtils.isFileOlder(newFile, instant), "New File - Older - Instant");
-        assertFalse(FileUtils.isFileOlder(newFile, zonedDateTime), "New File - Older - ZonedDateTime");
-        assertFalse(FileUtils.isFileOlder(newFile, localDateTime), "New File - Older - LocalDateTime");
-        assertFalse(FileUtils.isFileOlder(newFile, localDateTime, ZoneId.systemDefault()), "New File - Older - LocalDateTime,ZoneId");
-        assertTrue(FileUtils.isFileOlder(newFile, localDate), "New File - Older - LocalDate");
-        assertFalse(FileUtils.isFileOlder(newFile, localDate, localTime), "New File - Older - LocalDate,LocalTime");
-        assertTrue(FileUtils.isFileOlder(newFile, localDatePlusDay), "New File - Older - LocalDate plus one day");
-        assertTrue(FileUtils.isFileOlder(newFile, localDatePlusDay, localTime), "New File - Older - LocalDate plus one day,LocalTime");
-
-        assertFalse(FileUtils.isFileOlder(invalidFile, reference), "Invalid - Older - File");
-        try {
-            FileUtils.isFileOlder(newFile, invalidFile);
-            fail("Should have cause IllegalArgumentException");
-        } catch (final IllegalArgumentException iae) {
-            final String message = iae.getMessage();
-            assertTrue(message.contains(invalidFileName), "Message should contain: " + invalidFileName + " but was: " + message);
-        }
-
-
-        // ----- Test isFileNewer() exceptions -----
-        // Null File
-        try {
-            FileUtils.isFileNewer(null, now);
-            fail("Newer Null, expected NullPointerException");
-        } catch (final NullPointerException expected) {
-            // expected result
-        }
-
-        // Null reference File
-        try {
-            FileUtils.isFileNewer(oldFile, (File) null);
-            fail("Newer Null reference, expected NullPointerException");
-        } catch (final NullPointerException ignore) {
-            // expected result
-        }
-
-        // Invalid reference File
-        try {
-            FileUtils.isFileNewer(oldFile, invalidFile);
-            fail("Newer invalid reference, expected IllegalArgumentException");
-        } catch (final IllegalArgumentException ignore) {
-            // expected result
-        }
-
-        // Null reference Date
-        try {
-            FileUtils.isFileNewer(oldFile, (Date) null);
-            fail("Newer Null date, expected NullPointerException");
-        } catch (final NullPointerException ignore) {
-            // expected result
-        }
+    // sizeOfDirectory
 
+    @Test
+    public void testCopyFile2() throws Exception {
+        final File destination = new File(temporaryFolder, "copy2.txt");
 
-        // ----- Test isFileOlder() exceptions -----
-        // Null File
-        try {
-            FileUtils.isFileOlder(null, now);
-            fail("Older Null, expected NullPointerException");
-        } catch (final NullPointerException ignore) {
-            // expected result
-        }
+        backDateFile10Minutes(testFile1); // set test file back 10 minutes
 
-        // Null reference File
-        try {
-            FileUtils.isFileOlder(oldFile, (File) null);
-            fail("Older Null reference, expected NullPointerException");
-        } catch (final NullPointerException ignore) {
-            // expected result
-        }
+        FileUtils.copyFile(testFile1, destination);
+        assertTrue(destination.exists(), "Check Exist");
+        assertEquals(testFile2Size, destination.length(), "Check Full copy");
+        assertEquals(getLastModifiedMillis(testFile1) , getLastModifiedMillis(destination), "Check last modified date preserved");
+    }
 
-        // Invalid reference File
-        try {
-            FileUtils.isFileOlder(oldFile, invalidFile);
-            fail("Older invalid reference, expected IllegalArgumentException");
-        } catch (final IllegalArgumentException ignore) {
-            // expected result
+    @Test
+    public void testCopyFile2ToDir() throws Exception {
+        final File directory = new File(temporaryFolder, "subdir");
+        if (!directory.exists()) {
+            directory.mkdirs();
         }
+        final File destination = new File(directory, testFile1.getName());
 
-        // Null reference Date
-        try {
-            FileUtils.isFileOlder(oldFile, (Date) null);
-            fail("Older Null date, expected NullPointerException");
-        } catch (final NullPointerException ignore) {
-            // expected result
-        }
+        backDateFile10Minutes(testFile1);
 
+        FileUtils.copyFileToDirectory(testFile1, directory);
+        assertTrue(destination.exists(), "Check Exist");
+        assertEquals(testFile2Size, destination.length(), "Check Full copy");
+        assertEquals(testFile1.lastModified(), destination.lastModified(), "Check last modified date preserved");
     }
 
-    // copyFile
-
     @Test
-    public void testCopyFile1() throws Exception {
-        final File destination = new File(temporaryFolder, "copy1.txt");
+    public void testCopyFile2WithoutFileDatePreservation() throws Exception {
+        final File destFile = new File(temporaryFolder, "copy2.txt");
 
         backDateFile10Minutes(testFile1); // set test file back 10 minutes
 
-        FileUtils.copyFile(testFile1, destination);
-        assertTrue(destination.exists(), "Check Exist");
-        assertEquals(testFile1Size, destination.length(), "Check Full copy");
-        assertEquals(getLastModifiedMillis(testFile1), getLastModifiedMillis(destination), "Check last modified date preserved");
-    }
-
-    @Test
-    public void testCopyFileToOutputStream() throws Exception {
-        final ByteArrayOutputStream destination = new ByteArrayOutputStream();
-        FileUtils.copyFile(testFile1, destination);
-        assertEquals(testFile1Size, destination.size(), "Check Full copy size");
-        final byte[] expected = FileUtils.readFileToByteArray(testFile1);
-        assertArrayEquals(expected, destination.toByteArray(), "Check Full copy");
+        // destination file time should not be less than this (allowing for granularity)
+        final long now = System.currentTimeMillis() - 1000L;
+        // On Windows, the last modified time is copied by default.
+        FileUtils.copyFile(testFile1, destFile, false);
+        assertTrue(destFile.exists(), "Check Exist");
+        assertEquals(testFile1Size, destFile.length(), "Check Full copy");
+        final long destLastMod = getLastModifiedMillis(destFile);
+        final long unexpected = getLastModifiedMillis(testFile1);
+        if (!SystemUtils.IS_OS_WINDOWS) {
+            final long delta = destLastMod - unexpected;
+            assertNotEquals(unexpected, destLastMod, "Check last modified date not same as input, delta " + delta);
+            assertTrue(destLastMod > now, destLastMod + " > " + now + " (delta " + delta + ")");
+        }
     }
 
     @Test
@@ -1245,789 +1141,1343 @@ public void testCopyFileLarge() throws Exception {
     }
 
     @Test
-    public void testCopyFile2() throws Exception {
-        final File destination = new File(temporaryFolder, "copy2.txt");
-
-        backDateFile10Minutes(testFile1); // set test file back 10 minutes
-
+    public void testCopyFileToOutputStream() throws Exception {
+        final ByteArrayOutputStream destination = new ByteArrayOutputStream();
         FileUtils.copyFile(testFile1, destination);
-        assertTrue(destination.exists(), "Check Exist");
-        assertEquals(testFile2Size, destination.length(), "Check Full copy");
-        assertEquals(getLastModifiedMillis(testFile1) , getLastModifiedMillis(destination), "Check last modified date preserved");
+        assertEquals(testFile1Size, destination.size(), "Check Full copy size");
+        final byte[] expected = FileUtils.readFileToByteArray(testFile1);
+        assertArrayEquals(expected, destination.toByteArray(), "Check Full copy");
     }
 
     @Test
-    public void testCopyToSelf() throws Exception {
-        final File destination = new File(temporaryFolder, "copy3.txt");
-        //Prepare a test file
-        FileUtils.copyFile(testFile1, destination);
+    public void testCopyToDirectoryWithDirectory() throws IOException {
+        final File destDirectory = new File(temporaryFolder, "destination");
+        if (!destDirectory.exists()) {
+            destDirectory.mkdirs();
+        }
 
-        try {
-            FileUtils.copyFile(destination, destination);
-            fail("file copy to self should not be possible");
-        } catch (final IOException ioe) {
-            //we want the exception, copy to self should be illegal
+        // Create a test directory
+        final File inputDirectory = new File(temporaryFolder, "input");
+        if (!inputDirectory.exists()) {
+            inputDirectory.mkdirs();
         }
-    }
+        final File outputDirDestination = new File(destDirectory, inputDirectory.getName());
+        FileUtils.copyToDirectory(testFile1, inputDirectory);
+        final File destFile1 = new File(outputDirDestination, testFile1.getName());
+        FileUtils.copyToDirectory(testFile2, inputDirectory);
+        final File destFile2 = new File(outputDirDestination, testFile2.getName());
 
-    @Test
-    public void testCopyFile2WithoutFileDatePreservation() throws Exception {
-        final File destFile = new File(temporaryFolder, "copy2.txt");
+        FileUtils.copyToDirectory(inputDirectory, destDirectory);
 
-        backDateFile10Minutes(testFile1); // set test file back 10 minutes
+        // Check the directory was created
+        assertTrue(outputDirDestination.exists(), "Check Exists");
+        assertTrue(outputDirDestination.isDirectory(), "Check Directory");
 
-        // destination file time should not be less than this (allowing for granularity)
-        final long now = System.currentTimeMillis() - 1000L;
-        // On Windows, the last modified time is copied by default.
-        FileUtils.copyFile(testFile1, destFile, false);
-        assertTrue(destFile.exists(), "Check Exist");
-        assertEquals(testFile1Size, destFile.length(), "Check Full copy");
-        final long destLastMod = getLastModifiedMillis(destFile);
-        final long unexpected = getLastModifiedMillis(testFile1);
-        if (!SystemUtils.IS_OS_WINDOWS) {
-            final long delta = destLastMod - unexpected;
-            assertNotEquals(unexpected, destLastMod, "Check last modified date not same as input, delta " + delta);
-            assertTrue(destLastMod > now, destLastMod + " > " + now + " (delta " + delta + ")");
-        }
+        // Check each file
+        assertTrue(destFile1.exists(), "Check Exists");
+        assertEquals(testFile1Size, destFile1.length(), "Check Full Copy");
+        assertTrue(destFile2.exists(), "Check Exists");
+        assertEquals(testFile2Size, destFile2.length(), "Check Full Copy");
     }
 
     @Test
-    public void testCopyDirectoryToDirectory_NonExistingDest() throws Exception {
-        if (!testFile1.getParentFile().exists()) {
-            throw new IOException("Cannot create file " + testFile1
-                    + " as the parent directory does not exist");
+    public void testCopyToDirectoryWithFile() throws IOException {
+        final File directory = new File(temporaryFolder, "subdir");
+        if (!directory.exists()) {
+            directory.mkdirs();
         }
-        final BufferedOutputStream output1 =
-                new BufferedOutputStream(new FileOutputStream(testFile1));
-        try {
-            TestUtils.generateTestData(output1, 1234);
-        } finally {
-            IOUtils.closeQuietly(output1);
-        }
-        if (!testFile2.getParentFile().exists()) {
-            throw new IOException("Cannot create file " + testFile2
-                    + " as the parent directory does not exist");
+        final File destination = new File(directory, testFile1.getName());
+
+        FileUtils.copyToDirectory(testFile1, directory);
+        assertTrue(destination.exists(), "Check Exists");
+        assertEquals(testFile1Size, destination.length(), "Check Full Copy");
+    }
+
+    // copyFile
+
+    @Test
+    public void testCopyToDirectoryWithFileSourceDoesNotExist() {
+        assertThrows(IOException.class,
+                () -> FileUtils.copyToDirectory(new File(temporaryFolder, "doesNotExists"), temporaryFolder));
+    }
+
+    @Test
+    public void testCopyToDirectoryWithFileSourceIsNull() {
+        assertThrows(NullPointerException.class, () -> FileUtils.copyToDirectory((File) null, temporaryFolder));
+    }
+
+    @Test
+    public void testCopyToDirectoryWithIterable() throws IOException {
+        final File directory = new File(temporaryFolder, "subdir");
+        if (!directory.exists()) {
+            directory.mkdirs();
         }
-        final BufferedOutputStream output =
-                new BufferedOutputStream(new FileOutputStream(testFile2));
+
+        final List<File> input = new ArrayList<>();
+        input.add(testFile1);
+        input.add(testFile2);
+
+        final File destFile1 = new File(directory, testFile1.getName());
+        final File destFile2 = new File(directory, testFile2.getName());
+
+        FileUtils.copyToDirectory(input, directory);
+        // Check each file
+        assertTrue(destFile1.exists(), "Check Exists");
+        assertEquals(testFile1Size, destFile1.length(), "Check Full Copy");
+        assertTrue(destFile2.exists(), "Check Exists");
+        assertEquals(testFile2Size, destFile2.length(), "Check Full Copy");
+    }
+
+    @Test
+    public void testCopyToDirectoryWithIterableSourceDoesNotExist() {
+        assertThrows(IOException.class,
+                () -> FileUtils.copyToDirectory(Collections.singleton(new File(temporaryFolder, "doesNotExists")),
+                        temporaryFolder));
+    }
+
+    @Test
+    public void testCopyToDirectoryWithIterableSourceIsNull() {
+        assertThrows(NullPointerException.class, () -> FileUtils.copyToDirectory((List<File>) null, temporaryFolder));
+    }
+
+    @Test
+    public void testCopyToSelf() throws Exception {
+        final File destination = new File(temporaryFolder, "copy3.txt");
+        //Prepare a test file
+        FileUtils.copyFile(testFile1, destination);
+
         try {
-            TestUtils.generateTestData(output, 4321);
-        } finally {
-            IOUtils.closeQuietly(output);
+            FileUtils.copyFile(destination, destination);
+            fail("file copy to self should not be possible");
+        } catch (final IOException ioe) {
+            //we want the exception, copy to self should be illegal
         }
-        final File srcDir = temporaryFolder;
-        final File subDir = new File(srcDir, "sub");
-        subDir.mkdir();
-        final File subFile = new File(subDir, "A.txt");
-        FileUtils.writeStringToFile(subFile, "HELLO WORLD", "UTF8");
-        final File destDir = new File(System.getProperty("java.io.tmpdir"), "tmp-FileUtilsTestCase");
-        FileUtils.deleteDirectory(destDir);
-        final File actualDestDir = new File(destDir, srcDir.getName());
+    }
 
-        FileUtils.copyDirectoryToDirectory(srcDir, destDir);
+    @Test
+    public void testCopyURLToFile() throws Exception {
+        // Creates file
+        final File file = new File(temporaryFolder, getName());
+        file.deleteOnExit();
 
-        assertTrue(destDir.exists(), "Check exists");
-        assertTrue(actualDestDir.exists(), "Check exists");
-        final long srcSize = FileUtils.sizeOfDirectory(srcDir);
-        assertTrue(srcSize > 0, "Size > 0");
-        assertEquals(srcSize, FileUtils.sizeOfDirectory(actualDestDir), "Check size");
-        assertTrue(new File(actualDestDir, "sub/A.txt").exists());
-        FileUtils.deleteDirectory(destDir);
+        // Loads resource
+        final String resourceName = "/java/lang/Object.class";
+        FileUtils.copyURLToFile(getClass().getResource(resourceName), file);
+
+        // Tests that resuorce was copied correctly
+        try (FileInputStream fis = new FileInputStream(file)) {
+            assertTrue(IOUtils.contentEquals(getClass().getResourceAsStream(resourceName), fis),
+                    "Content is not equal.");
+        }
+        //TODO Maybe test copy to itself like for copyFile()
     }
 
     @Test
-    public void testCopyDirectoryToNonExistingDest() throws Exception {
-        if (!testFile1.getParentFile().exists()) {
-            throw new IOException("Cannot create file " + testFile1
-                    + " as the parent directory does not exist");
+    public void testCopyURLToFileWithTimeout() throws Exception {
+        // Creates file
+        final File file = new File(temporaryFolder, "testCopyURLToFileWithTimeout");
+        file.deleteOnExit();
+
+        // Loads resource
+        final String resourceName = "/java/lang/Object.class";
+        FileUtils.copyURLToFile(getClass().getResource(resourceName), file, 500, 500);
+
+        // Tests that resuorce was copied correctly
+        try (FileInputStream fis = new FileInputStream(file)) {
+            assertTrue(IOUtils.contentEquals(getClass().getResourceAsStream(resourceName), fis),
+                    "Content is not equal.");
         }
-        final BufferedOutputStream output1 =
-                new BufferedOutputStream(new FileOutputStream(testFile1));
+        //TODO Maybe test copy to itself like for copyFile()
+    }
+
+    @Test
+    public void testDecodeUrl() {
+        assertEquals("", FileUtils.decodeUrl(""));
+        assertEquals("foo", FileUtils.decodeUrl("foo"));
+        assertEquals("+", FileUtils.decodeUrl("+"));
+        assertEquals("% ", FileUtils.decodeUrl("%25%20"));
+        assertEquals("%20", FileUtils.decodeUrl("%2520"));
+        assertEquals("jar:file:/C:/dir/sub dir/1.0/foo-1.0.jar!/org/Bar.class", FileUtils
+                .decodeUrl("jar:file:/C:/dir/sub%20dir/1.0/foo-1.0.jar!/org/Bar.class"));
+    }
+
+    @Test
+    public void testDecodeUrlEncodingUtf8() {
+        assertEquals("\u00E4\u00F6\u00FC\u00DF", FileUtils.decodeUrl("%C3%A4%C3%B6%C3%BC%C3%9F"));
+    }
+
+    @Test
+    public void testDecodeUrlLenient() {
+        assertEquals(" ", FileUtils.decodeUrl(" "));
+        assertEquals("\u00E4\u00F6\u00FC\u00DF", FileUtils.decodeUrl("\u00E4\u00F6\u00FC\u00DF"));
+        assertEquals("%", FileUtils.decodeUrl("%"));
+        assertEquals("% ", FileUtils.decodeUrl("%%20"));
+        assertEquals("%2", FileUtils.decodeUrl("%2"));
+        assertEquals("%2G", FileUtils.decodeUrl("%2G"));
+    }
+
+    @Test
+    public void testDecodeUrlNullSafe() {
+        assertNull(FileUtils.decodeUrl(null));
+    }
+
+    @Test
+    public void testDeleteDirectoryWithNonDirectory() throws Exception {
         try {
-            TestUtils.generateTestData(output1, 1234);
-        } finally {
-            IOUtils.closeQuietly(output1);
+            FileUtils.deleteDirectory(testFile1);
+            fail();
+        } catch (final IllegalArgumentException ex) {
+            // expected
         }
-        if (!testFile2.getParentFile().exists()) {
-            throw new IOException("Cannot create file " + testFile2
+    }
+
+    @Test
+    public void testDeleteQuietlyDir() throws IOException {
+        final File testDirectory = new File(temporaryFolder, "testDeleteQuietlyDir");
+        final File testFile = new File(testDirectory, "testDeleteQuietlyFile");
+        testDirectory.mkdirs();
+        if (!testFile.getParentFile().exists()) {
+            throw new IOException("Cannot create file " + testFile
                     + " as the parent directory does not exist");
         }
         final BufferedOutputStream output =
-                new BufferedOutputStream(new FileOutputStream(testFile2));
+                new BufferedOutputStream(new FileOutputStream(testFile));
         try {
-            TestUtils.generateTestData(output, 4321);
+            TestUtils.generateTestData(output, 0);
         } finally {
             IOUtils.closeQuietly(output);
         }
-        final File srcDir = temporaryFolder;
-        final File subDir = new File(srcDir, "sub");
-        subDir.mkdir();
-        final File subFile = new File(subDir, "A.txt");
-        FileUtils.writeStringToFile(subFile, "HELLO WORLD", "UTF8");
-        final File destDir = new File(System.getProperty("java.io.tmpdir"), "tmp-FileUtilsTestCase");
-        FileUtils.deleteDirectory(destDir);
 
-        FileUtils.copyDirectory(srcDir, destDir);
-
-        assertTrue(destDir.exists(), "Check exists");
-        final long sizeOfSrcDirectory = FileUtils.sizeOfDirectory(srcDir);
-        assertTrue(sizeOfSrcDirectory > 0, "Size > 0");
-        assertEquals(sizeOfSrcDirectory, FileUtils.sizeOfDirectory(destDir), "Check size");
-        assertTrue(new File(destDir, "sub/A.txt").exists());
-        FileUtils.deleteDirectory(destDir);
+        assertTrue(testDirectory.exists());
+        assertTrue(testFile.exists());
+        FileUtils.deleteQuietly(testDirectory);
+        assertFalse(testDirectory.exists(), "Check No Exist");
+        assertFalse(testFile.exists(), "Check No Exist");
     }
 
     @Test
-    public void testCopyDirectoryToExistingDest() throws Exception {
-        if (!testFile1.getParentFile().exists()) {
-            throw new IOException("Cannot create file " + testFile1
-                    + " as the parent directory does not exist");
-        }
-        final BufferedOutputStream output1 =
-                new BufferedOutputStream(new FileOutputStream(testFile1));
-        try {
-            TestUtils.generateTestData(output1, 1234);
-        } finally {
-            IOUtils.closeQuietly(output1);
-        }
-        if (!testFile2.getParentFile().exists()) {
-            throw new IOException("Cannot create file " + testFile2
+    public void testDeleteQuietlyFile() throws IOException {
+        final File testFile = new File(temporaryFolder, "testDeleteQuietlyFile");
+        if (!testFile.getParentFile().exists()) {
+            throw new IOException("Cannot create file " + testFile
                     + " as the parent directory does not exist");
         }
         final BufferedOutputStream output =
-                new BufferedOutputStream(new FileOutputStream(testFile2));
+                new BufferedOutputStream(new FileOutputStream(testFile));
         try {
-            TestUtils.generateTestData(output, 4321);
+            TestUtils.generateTestData(output, 0);
         } finally {
             IOUtils.closeQuietly(output);
         }
-        final File srcDir = temporaryFolder;
-        final File subDir = new File(srcDir, "sub");
-        subDir.mkdir();
-        final File subFile = new File(subDir, "A.txt");
-        FileUtils.writeStringToFile(subFile, "HELLO WORLD", "UTF8");
-        final File destDir = new File(System.getProperty("java.io.tmpdir"), "tmp-FileUtilsTestCase");
-        FileUtils.deleteDirectory(destDir);
-        destDir.mkdirs();
 
-        FileUtils.copyDirectory(srcDir, destDir);
+        assertTrue(testFile.exists());
+        FileUtils.deleteQuietly(testFile);
+        assertFalse(testFile.exists(), "Check No Exist");
+    }
 
-        final long srcSize = FileUtils.sizeOfDirectory(srcDir);
-        assertTrue(srcSize > 0, "Size > 0");
-        assertEquals(srcSize, FileUtils.sizeOfDirectory(destDir));
-        assertTrue(new File(destDir, "sub/A.txt").exists());
+    @Test
+    public void testDeleteQuietlyForNull() {
+        try {
+            FileUtils.deleteQuietly(null);
+        } catch (final Exception ex) {
+            fail(ex.getMessage());
+        }
     }
 
     @Test
-    public void testCopyDirectoryFiltered() throws Exception {
-        final File grandParentDir = new File(temporaryFolder, "grandparent");
-        final File parentDir = new File(grandParentDir, "parent");
-        final File childDir = new File(parentDir, "child");
-        createFilesForTestCopyDirectory(grandParentDir, parentDir, childDir);
+    public void testDeleteQuietlyNonExistent() {
+        final File testFile = new File("testDeleteQuietlyNonExistent");
+        assertFalse(testFile.exists());
 
-        final NameFileFilter filter = new NameFileFilter(new String[]{"parent", "child", "file3.txt"});
-        final File destDir = new File(temporaryFolder, "copydest");
-
-        FileUtils.copyDirectory(grandParentDir, destDir, filter);
-        final List<File> files = LIST_WALKER.list(destDir);
-        assertEquals(3, files.size());
-        assertEquals("parent", files.get(0).getName());
-        assertEquals("child", files.get(1).getName());
-        assertEquals("file3.txt", files.get(2).getName());
+        try {
+            FileUtils.deleteQuietly(testFile);
+        } catch (final Exception ex) {
+            fail(ex.getMessage());
+        }
     }
 
+    // copyToDirectory
+
+    /*
+     *  Test the FileUtils implementation.
+     */
     @Test
-    public void testCopyDirectoryPreserveDates() throws Exception {
-        final File source = new File(temporaryFolder, "source");
-        final File sourceDirectory = new File(source, "directory");
-        final File sourceFile = new File(sourceDirectory, "hello.txt");
+    public void testFileUtils() throws Exception {
+        // Loads file from classpath
+        final File file1 = new File(temporaryFolder, "test.txt");
+        final String filename = file1.getAbsolutePath();
 
-        // Prepare source data
-        source.mkdirs();
-        sourceDirectory.mkdir();
-        FileUtils.writeStringToFile(sourceFile, "HELLO WORLD", "UTF8");
-        // Set dates in reverse order to avoid overwriting previous values
-        // Also, use full seconds (arguments are in ms) close to today
-        // but still highly unlikely to occur in the real world
-        assertTrue(setLastModifiedMillis(sourceFile, DATE3));
-        assertTrue(setLastModifiedMillis(sourceDirectory, DATE2));
-        assertTrue(setLastModifiedMillis(source, DATE1));
+        //Create test file on-the-fly (used to be in CVS)
+        try (OutputStream out = new FileOutputStream(file1)) {
+            out.write("This is a test".getBytes("UTF-8"));
+        }
 
-        final File target = new File(temporaryFolder, "target");
-        final File targetDirectory = new File(target, "directory");
-        final File targetFile = new File(targetDirectory, "hello.txt");
+        final File file2 = new File(temporaryFolder, "test2.txt");
 
-        // Test with preserveFileDate disabled
-        // On Windows, the last modified time is copied by default.
-        FileUtils.copyDirectory(source, target, false);
-        assertNotEquals(DATE1, getLastModifiedMillis(target));
-        assertNotEquals(DATE2, getLastModifiedMillis(targetDirectory));
-        if (!SystemUtils.IS_OS_WINDOWS) {
-            assertNotEquals(DATE3, getLastModifiedMillis(targetFile));
-        }
-        FileUtils.deleteDirectory(target);
+        FileUtils.writeStringToFile(file2, filename, "UTF-8");
+        assertTrue(file2.exists());
+        assertTrue(file2.length() > 0);
 
-        // Test with preserveFileDate enabled
-        FileUtils.copyDirectory(source, target, true);
-        assertEquals(DATE1, getLastModifiedMillis(target));
-        assertEquals(DATE2, getLastModifiedMillis(targetDirectory));
-        assertEquals(DATE3, getLastModifiedMillis(targetFile));
-        FileUtils.deleteDirectory(target);
+        final String file2contents = FileUtils.readFileToString(file2, "UTF-8");
+        assertEquals(filename, file2contents, "Second file's contents correct");
 
-        // also if the target directory already exists (IO-190)
-        target.mkdirs();
-        FileUtils.copyDirectory(source, target, true);
-        assertEquals(DATE1, getLastModifiedMillis(target));
-        assertEquals(DATE2, getLastModifiedMillis(targetDirectory));
-        assertEquals(DATE3, getLastModifiedMillis(targetFile));
-        FileUtils.deleteDirectory(target);
+        assertTrue(file2.delete());
 
-        // also if the target subdirectory already exists (IO-190)
-        targetDirectory.mkdirs();
-        FileUtils.copyDirectory(source, target, true);
-        assertEquals(DATE1, getLastModifiedMillis(target));
-        assertEquals(DATE2, getLastModifiedMillis(targetDirectory));
-        assertEquals(DATE3, getLastModifiedMillis(targetFile));
-        FileUtils.deleteDirectory(target);
-    }
+        final String contents = FileUtils.readFileToString(new File(filename), "UTF-8");
+        assertEquals("This is a test", contents, "FileUtils.fileRead()");
 
-    private long getLastModifiedMillis(final File file) throws IOException {
-        return file.lastModified();
-        //https://bugs.openjdk.java.net/browse/JDK-8177809
-        //return Files.getLastModifiedTime(file.toPath()).toMillis();
     }
 
-    /* Test for IO-141 */
     @Test
-    public void testCopyDirectoryToChild() throws Exception {
-        final File grandParentDir = new File(temporaryFolder, "grandparent");
-        final File parentDir = new File(grandParentDir, "parent");
-        final File childDir = new File(parentDir, "child");
-        createFilesForTestCopyDirectory(grandParentDir, parentDir, childDir);
-
-        final long expectedCount = LIST_WALKER.list(grandParentDir).size() +
-                LIST_WALKER.list(parentDir).size();
-        final long expectedSize = FileUtils.sizeOfDirectory(grandParentDir) +
-                FileUtils.sizeOfDirectory(parentDir);
-        FileUtils.copyDirectory(parentDir, childDir);
-        assertEquals(expectedCount, LIST_WALKER.list(grandParentDir).size());
-        assertEquals(expectedSize, FileUtils.sizeOfDirectory(grandParentDir));
-        assertTrue(expectedCount > 0, "Count > 0");
-        assertTrue(expectedSize > 0, "Size > 0");
+    public void testForceDeleteAFile1() throws Exception {
+        final File destination = new File(temporaryFolder, "copy1.txt");
+        destination.createNewFile();
+        assertTrue(destination.exists(), "Copy1.txt doesn't exist to delete");
+        FileUtils.forceDelete(destination);
+        assertTrue(!destination.exists(), "Check No Exist");
     }
 
-    /* Test for IO-141 */
     @Test
-    public void testCopyDirectoryToGrandChild() throws Exception {
-        final File grandParentDir = new File(temporaryFolder, "grandparent");
-        final File parentDir = new File(grandParentDir, "parent");
-        final File childDir = new File(parentDir, "child");
-        createFilesForTestCopyDirectory(grandParentDir, parentDir, childDir);
-
-        final long expectedCount = LIST_WALKER.list(grandParentDir).size() * 2;
-        final long expectedSize = FileUtils.sizeOfDirectory(grandParentDir) * 2;
-        FileUtils.copyDirectory(grandParentDir, childDir);
-        assertEquals(expectedCount, LIST_WALKER.list(grandParentDir).size());
-        assertEquals(expectedSize, FileUtils.sizeOfDirectory(grandParentDir));
-        assertTrue(expectedSize > 0, "Size > 0");
+    public void testForceDeleteAFile2() throws Exception {
+        final File destination = new File(temporaryFolder, "copy2.txt");
+        destination.createNewFile();
+        assertTrue(destination.exists(), "Copy2.txt doesn't exist to delete");
+        FileUtils.forceDelete(destination);
+        assertTrue(!destination.exists(), "Check No Exist");
     }
 
-    /* Test for IO-217 FileUtils.copyDirectoryToDirectory makes infinite loops */
     @Test
-    public void testCopyDirectoryToItself() throws Exception {
-        final File dir = new File(temporaryFolder, "itself");
-        dir.mkdirs();
-        FileUtils.copyDirectoryToDirectory(dir, dir);
-        assertEquals(1, LIST_WALKER.list(dir).size());
+    public void testForceDeleteAFile3() throws Exception {
+        final File destination = new File(temporaryFolder, "no_such_file");
+        assertTrue(!destination.exists(), "Check No Exist");
+        try {
+            FileUtils.forceDelete(destination);
+            fail("Should generate FileNotFoundException");
+        } catch (final FileNotFoundException ignored) {
+        }
     }
 
-    private void createFilesForTestCopyDirectory(final File grandParentDir, final File parentDir, final File childDir) throws Exception {
-        final File childDir2 = new File(parentDir, "child2");
-        final File grandChildDir = new File(childDir, "grandChild");
-        final File grandChild2Dir = new File(childDir2, "grandChild2");
-        final File file1 = new File(grandParentDir, "file1.txt");
-        final File file2 = new File(parentDir, "file2.txt");
-        final File file3 = new File(childDir, "file3.txt");
-        final File file4 = new File(childDir2, "file4.txt");
-        final File file5 = new File(grandChildDir, "file5.txt");
-        final File file6 = new File(grandChild2Dir, "file6.txt");
-        FileUtils.deleteDirectory(grandParentDir);
-        grandChildDir.mkdirs();
-        grandChild2Dir.mkdirs();
-        FileUtils.writeStringToFile(file1, "File 1 in grandparent", "UTF8");
-        FileUtils.writeStringToFile(file2, "File 2 in parent", "UTF8");
-        FileUtils.writeStringToFile(file3, "File 3 in child", "UTF8");
-        FileUtils.writeStringToFile(file4, "File 4 in child2", "UTF8");
-        FileUtils.writeStringToFile(file5, "File 5 in grandChild", "UTF8");
-        FileUtils.writeStringToFile(file6, "File 6 in grandChild2", "UTF8");
+    @Test
+    public void testForceDeleteDir() throws Exception {
+        final File testDirectory = temporaryFolder;
+        assertTrue(testDirectory.exists(), "TestDirectory must exist");
+        FileUtils.forceDelete(testDirectory);
+        assertFalse(testDirectory.exists(), "TestDirectory must not exist");
     }
 
     @Test
-    public void testCopyDirectoryErrors() throws Exception {
-        try {
-            FileUtils.copyDirectory(null, null);
-            fail();
-        } catch (final NullPointerException ignore) {
-        }
-        try {
-            FileUtils.copyDirectory(new File("a"), null);
-            fail();
-        } catch (final NullPointerException ignore) {
-        }
-        try {
-            FileUtils.copyDirectory(null, new File("a"));
-            fail();
-        } catch (final NullPointerException ignore) {
-        }
-        try {
-            FileUtils.copyDirectory(new File("doesnt-exist"), new File("a"));
-            fail();
-        } catch (final IOException ignore) {
-        }
-        try {
-            FileUtils.copyDirectory(testFile1, new File("a"));
-            fail();
-        } catch (final IOException ignore) {
-        }
-        try {
-            FileUtils.copyDirectory(temporaryFolder, testFile1);
-            fail();
-        } catch (final IOException ignore) {
-        }
+    public void testForceMkdir() throws Exception {
+        // Tests with existing directory
+        FileUtils.forceMkdir(temporaryFolder);
+
+        // Creates test file
+        final File testFile = new File(temporaryFolder, getName());
+        testFile.deleteOnExit();
+        testFile.createNewFile();
+        assertTrue(testFile.exists(), "Test file does not exist.");
+
+        // Tests with existing file
         try {
-            FileUtils.copyDirectory(temporaryFolder, temporaryFolder);
-            fail();
+            FileUtils.forceMkdir(testFile);
+            fail("Exception expected.");
         } catch (final IOException ignore) {
         }
-    }
-
-    // copyToDirectory
 
-    @Test
-    public void testCopyToDirectoryWithFile() throws IOException {
-        final File directory = new File(temporaryFolder, "subdir");
-        if (!directory.exists()) {
-            directory.mkdirs();
-        }
-        final File destination = new File(directory, testFile1.getName());
+        testFile.delete();
 
-        FileUtils.copyToDirectory(testFile1, directory);
-        assertTrue(destination.exists(), "Check Exists");
-        assertEquals(testFile1Size, destination.length(), "Check Full Copy");
+        // Tests with non-existent directory
+        FileUtils.forceMkdir(testFile);
+        assertTrue(testFile.exists(), "Directory was not created.");
     }
 
     @Test
-    public void testCopyToDirectoryWithFileSourceIsNull() {
-        assertThrows(NullPointerException.class, () -> FileUtils.copyToDirectory((File) null, temporaryFolder));
+    public void testForceMkdirParent() throws Exception {
+        // Tests with existing directory
+        assertTrue(temporaryFolder.exists());
+        final File testParentDir = new File(temporaryFolder, "testForceMkdirParent");
+        testParentDir.delete();
+        assertFalse(testParentDir.exists());
+        final File testFile = new File(testParentDir, "test.txt");
+        assertFalse(testParentDir.exists());
+        assertFalse(testFile.exists());
+        // Create
+        FileUtils.forceMkdirParent(testFile);
+        assertTrue(testParentDir.exists());
+        assertFalse(testFile.exists());
+        // Again
+        FileUtils.forceMkdirParent(testFile);
+        assertTrue(testParentDir.exists());
+        assertFalse(testFile.exists());
     }
 
-    @Test
-    public void testCopyToDirectoryWithFileSourceDoesNotExist() {
-        assertThrows(IOException.class,
-                () -> FileUtils.copyToDirectory(new File(temporaryFolder, "doesNotExists"), temporaryFolder));
-    }
+    // forceDelete
 
+    //-----------------------------------------------------------------------
     @Test
-    public void testCopyToDirectoryWithDirectory() throws IOException {
-        final File destDirectory = new File(temporaryFolder, "destination");
-        if (!destDirectory.exists()) {
-            destDirectory.mkdirs();
-        }
-
-        // Create a test directory
-        final File inputDirectory = new File(temporaryFolder, "input");
-        if (!inputDirectory.exists()) {
-            inputDirectory.mkdirs();
+    public void testGetFile() {
+        final File expected_A = new File("src");
+        final File expected_B = new File(expected_A, "main");
+        final File expected_C = new File(expected_B, "java");
+        assertEquals(expected_A, FileUtils.getFile("src"), "A");
+        assertEquals(expected_B, FileUtils.getFile("src", "main"), "B");
+        assertEquals(expected_C, FileUtils.getFile("src", "main", "java"), "C");
+        try {
+            FileUtils.getFile((String[]) null);
+            fail("Expected NullPointerException");
+        } catch (final NullPointerException e) {
+            // expected
         }
-        final File outputDirDestination = new File(destDirectory, inputDirectory.getName());
-        FileUtils.copyToDirectory(testFile1, inputDirectory);
-        final File destFile1 = new File(outputDirDestination, testFile1.getName());
-        FileUtils.copyToDirectory(testFile2, inputDirectory);
-        final File destFile2 = new File(outputDirDestination, testFile2.getName());
-
-        FileUtils.copyToDirectory(inputDirectory, destDirectory);
-
-        // Check the directory was created
-        assertTrue(outputDirDestination.exists(), "Check Exists");
-        assertTrue(outputDirDestination.isDirectory(), "Check Directory");
-
-        // Check each file
-        assertTrue(destFile1.exists(), "Check Exists");
-        assertEquals(testFile1Size, destFile1.length(), "Check Full Copy");
-        assertTrue(destFile2.exists(), "Check Exists");
-        assertEquals(testFile2Size, destFile2.length(), "Check Full Copy");
     }
 
     @Test
-    public void testCopyToDirectoryWithIterable() throws IOException {
-        final File directory = new File(temporaryFolder, "subdir");
-        if (!directory.exists()) {
-            directory.mkdirs();
+    public void testGetFile_Parent() {
+        final File parent = new File("parent");
+        final File expected_A = new File(parent, "src");
+        final File expected_B = new File(expected_A, "main");
+        final File expected_C = new File(expected_B, "java");
+        assertEquals(expected_A, FileUtils.getFile(parent, "src"), "A");
+        assertEquals(expected_B, FileUtils.getFile(parent, "src", "main"), "B");
+        assertEquals(expected_C, FileUtils.getFile(parent, "src", "main", "java"), "C");
+        try {
+            FileUtils.getFile(parent, (String[]) null);
+            fail("Expected NullPointerException");
+        } catch (final NullPointerException e) {
+            // expected
+        }
+        try {
+            FileUtils.getFile((File) null, "src");
+            fail("Expected NullPointerException");
+        } catch (final NullPointerException e) {
+            // expected
         }
-
-        final List<File> input = new ArrayList<>();
-        input.add(testFile1);
-        input.add(testFile2);
-
-        final File destFile1 = new File(directory, testFile1.getName());
-        final File destFile2 = new File(directory, testFile2.getName());
-
-        FileUtils.copyToDirectory(input, directory);
-        // Check each file
-        assertTrue(destFile1.exists(), "Check Exists");
-        assertEquals(testFile1Size, destFile1.length(), "Check Full Copy");
-        assertTrue(destFile2.exists(), "Check Exists");
-        assertEquals(testFile2Size, destFile2.length(), "Check Full Copy");
-    }
-
-    @Test
-    public void testCopyToDirectoryWithIterableSourceIsNull() {
-        assertThrows(NullPointerException.class, () -> FileUtils.copyToDirectory((List<File>) null, temporaryFolder));
     }
 
     @Test
-    public void testCopyToDirectoryWithIterableSourceDoesNotExist() {
-        assertThrows(IOException.class,
-                () -> FileUtils.copyToDirectory(Collections.singleton(new File(temporaryFolder, "doesNotExists")),
-                        temporaryFolder));
+    public void testGetTempDirectory() {
+        final File tempDirectory = new File(System.getProperty("java.io.tmpdir"));
+        assertEquals(tempDirectory, FileUtils.getTempDirectory());
     }
 
-    // forceDelete
+    // copyFileToDirectory
 
     @Test
-    public void testForceDeleteAFile1() throws Exception {
-        final File destination = new File(temporaryFolder, "copy1.txt");
-        destination.createNewFile();
-        assertTrue(destination.exists(), "Copy1.txt doesn't exist to delete");
-        FileUtils.forceDelete(destination);
-        assertTrue(!destination.exists(), "Check No Exist");
+    public void testGetTempDirectoryPath() {
+        assertEquals(System.getProperty("java.io.tmpdir"),
+                FileUtils.getTempDirectoryPath());
     }
 
     @Test
-    public void testForceDeleteAFile2() throws Exception {
-        final File destination = new File(temporaryFolder, "copy2.txt");
-        destination.createNewFile();
-        assertTrue(destination.exists(), "Copy2.txt doesn't exist to delete");
-        FileUtils.forceDelete(destination);
-        assertTrue(!destination.exists(), "Check No Exist");
+    public void testGetUserDirectory() {
+        final File userDirectory = new File(System.getProperty("user.home"));
+        assertEquals(userDirectory, FileUtils.getUserDirectory());
     }
 
+    // forceDelete
+
     @Test
-    public void testForceDeleteAFile3() throws Exception {
-        final File destination = new File(temporaryFolder, "no_such_file");
-        assertTrue(!destination.exists(), "Check No Exist");
-        try {
-            FileUtils.forceDelete(destination);
-            fail("Should generate FileNotFoundException");
-        } catch (final FileNotFoundException ignored) {
-        }
+    public void testGetUserDirectoryPath() {
+        assertEquals(System.getProperty("user.home"),
+                FileUtils.getUserDirectoryPath());
     }
 
-    // copyFileToDirectory
-
+    // This test relies on FileUtils.copyFile using File.length to check the output size
     @Test
-    public void testCopyFile1ToDir() throws Exception {
-        final File directory = new File(temporaryFolder, "subdir");
-        if (!directory.exists()) {
-            directory.mkdirs();
+    public void testIncorrectOutputSize() throws Exception {
+        final File inFile = new File("pom.xml");
+        final File outFile = new ShorterFile("target/pom.tmp"); // it will report a shorter file
+        try {
+            FileUtils.copyFile(inFile, outFile);
+            fail("Expected IOException");
+        } catch (final Exception e) {
+            final String msg = e.toString();
+            assertTrue(msg.contains("Failed to copy full contents"), msg);
+        } finally {
+            outFile.delete(); // tidy up
         }
-        final File destination = new File(directory, testFile1.getName());
-
-        backDateFile10Minutes(testFile1);
-
-        FileUtils.copyFileToDirectory(testFile1, directory);
-        assertTrue(destination.exists(), "Check Exist");
-        assertEquals(testFile1Size, destination.length(), "Check Full copy");
-        assertEquals(testFile1.lastModified(), destination.lastModified(), "Check last modified date preserved");
-
-        assertThrows(IOException.class,
-            () -> FileUtils.copyFileToDirectory(destination, directory),
-            "Should not be able to copy a file into the same directory as itself");
     }
 
     @Test
-    public void testCopyFile2ToDir() throws Exception {
-        final File directory = new File(temporaryFolder, "subdir");
-        if (!directory.exists()) {
-            directory.mkdirs();
-        }
-        final File destination = new File(directory, testFile1.getName());
-
-        backDateFile10Minutes(testFile1);
-
-        FileUtils.copyFileToDirectory(testFile1, directory);
-        assertTrue(destination.exists(), "Check Exist");
-        assertEquals(testFile2Size, destination.length(), "Check Full copy");
-        assertEquals(testFile1.lastModified(), destination.lastModified(), "Check last modified date preserved");
+    public void testIO276() throws Exception {
+        final File dir = new File("target", "IO276");
+        assertTrue(dir.mkdirs(), dir + " should not be present");
+        final File file = new File(dir, "IO276.txt");
+        assertTrue(file.createNewFile(), file + " should not be present");
+        FileUtils.forceDeleteOnExit(dir);
+        // If this does not work, test will fail next time (assuming target is not cleaned)
     }
 
-    // forceDelete
-
     @Test
-    public void testForceDeleteDir() throws Exception {
+    public void testIO300() throws Exception {
         final File testDirectory = temporaryFolder;
-        assertTrue(testDirectory.exists(), "TestDirectory must exist");
-        FileUtils.forceDelete(testDirectory);
-        assertFalse(testDirectory.exists(), "TestDirectory must not exist");
+        final File src = new File(testDirectory, "dir1");
+        final File dest = new File(src, "dir2");
+        assertTrue(dest.mkdirs());
+        assertTrue(src.exists());
+        try {
+            FileUtils.moveDirectoryToDirectory(src, dest, false);
+            fail("expected IOException");
+        } catch (final IOException ioe) {
+            // expected
+        }
+        assertTrue(src.exists());
     }
 
-    /*
-     *  Test the FileUtils implementation.
-     */
+    // isFileNewer / isFileOlder
     @Test
-    public void testFileUtils() throws Exception {
-        // Loads file from classpath
-        final File file1 = new File(temporaryFolder, "test.txt");
-        final String filename = file1.getAbsolutePath();
+    public void testIsFileNewerOlder() throws Exception {
+        final File reference = new File(temporaryFolder, "FileUtils-reference.txt");
+        final File oldFile = new File(temporaryFolder, "FileUtils-old.txt");
+        final File newFile = new File(temporaryFolder, "FileUtils-new.txt");
+        final File invalidFile = new File(temporaryFolder, "FileUtils-invalid-file.txt");
 
-        //Create test file on-the-fly (used to be in CVS)
-        try (OutputStream out = new FileOutputStream(file1)) {
-            out.write("This is a test".getBytes("UTF-8"));
+        // Create Files
+        if (!oldFile.getParentFile().exists()) {
+            throw new IOException("Cannot create file " + oldFile
+                    + " as the parent directory does not exist");
+        }
+        final BufferedOutputStream output1 =
+                new BufferedOutputStream(new FileOutputStream(oldFile));
+        try {
+            TestUtils.generateTestData(output1, 0);
+        } finally {
+            IOUtils.closeQuietly(output1);
         }
 
-        final File file2 = new File(temporaryFolder, "test2.txt");
-
-        FileUtils.writeStringToFile(file2, filename, "UTF-8");
-        assertTrue(file2.exists());
-        assertTrue(file2.length() > 0);
-
-        final String file2contents = FileUtils.readFileToString(file2, "UTF-8");
-        assertEquals(filename, file2contents, "Second file's contents correct");
-
-        assertTrue(file2.delete());
-
-        final String contents = FileUtils.readFileToString(new File(filename), "UTF-8");
-        assertEquals("This is a test", contents, "FileUtils.fileRead()");
+        do {
+            try {
+                TestUtils.sleep(1000);
+            } catch (final InterruptedException ie) {
+                // ignore
+            }
+            if (!reference.getParentFile().exists()) {
+                throw new IOException("Cannot create file " + reference
+                        + " as the parent directory does not exist");
+            }
+            final BufferedOutputStream output =
+                    new BufferedOutputStream(new FileOutputStream(reference));
+            try {
+                TestUtils.generateTestData(output, 0);
+            } finally {
+                IOUtils.closeQuietly(output);
+            }
+        } while (getLastModifiedMillis(oldFile) == getLastModifiedMillis(reference));
 
-    }
+        final Date date = new Date();
+        final long now = date.getTime();
+        final Instant instant = date.toInstant();
+        final ZonedDateTime zonedDateTime = ZonedDateTime.ofInstant(instant, ZoneId.systemDefault());
+        final LocalDateTime localDateTime = zonedDateTime.toLocalDateTime();
+        final LocalDate localDate = zonedDateTime.toLocalDate();
+        final LocalDate localDatePlusDay = localDate.plusDays(1);
+        final LocalTime localTime = LocalTime.ofSecondOfDay(0);
 
-    @Test
-    public void testTouch() throws IOException {
-        final File file = new File(temporaryFolder, "touch.txt");
-        if (file.exists()) {
-            file.delete();
-        }
-        assertTrue(!file.exists(), "Bad test: test file still exists");
-        FileUtils.touch(file);
-        assertTrue(file.exists(), "FileUtils.touch() created file");
-        final FileOutputStream out = new FileOutputStream(file);
-        assertEquals(0, file.length(), "Created empty file.");
-        out.write(0);
-        out.close();
-        assertEquals(1, file.length(), "Wrote one byte to file");
-        final long y2k = new GregorianCalendar(2000, 0, 1).getTime().getTime();
-        final boolean res = setLastModifiedMillis(file, y2k);  // 0L fails on Win98
-        assertEquals(true, res, "Bad test: set lastModified failed");
-        assertEquals(y2k, getLastModifiedMillis(file), "Bad test: set lastModified set incorrect value");
-        final long now = System.currentTimeMillis();
-        FileUtils.touch(file);
-        assertEquals(1, file.length(), "FileUtils.touch() didn't empty the file.");
-        assertEquals(false, y2k == getLastModifiedMillis(file), "FileUtils.touch() changed lastModified");
-        assertEquals(true, getLastModifiedMillis(file) >= now - 3000, "FileUtils.touch() changed lastModified to more than now-3s");
-        assertEquals(true, getLastModifiedMillis(file) <= now + 3000, "FileUtils.touch() changed lastModified to less than now+3s");
-    }
-
-    @Test
-    public void testListFiles() throws Exception {
-        final File srcDir = temporaryFolder;
-        final File subDir = new File(srcDir, "list_test");
-        subDir.mkdir();
-
-        final File subDir2 = new File(subDir, "subdir");
-        subDir2.mkdir();
-
-        final String[] fileNames = {"a.txt", "b.txt", "c.txt", "d.txt", "e.txt", "f.txt"};
-        final int[] fileSizes = {123, 234, 345, 456, 678, 789};
-
-        for (int i = 0; i < fileNames.length; ++i) {
-            final File theFile = new File(subDir, fileNames[i]);
-            if (!theFile.getParentFile().exists()) {
-                throw new IOException("Cannot create file " + theFile
+        do {
+            try {
+                TestUtils.sleep(1000);
+            } catch (final InterruptedException ie) {
+                // ignore
+            }
+            if (!newFile.getParentFile().exists()) {
+                throw new IOException("Cannot create file " + newFile
                         + " as the parent directory does not exist");
             }
             final BufferedOutputStream output =
-                    new BufferedOutputStream(new FileOutputStream(theFile));
+                    new BufferedOutputStream(new FileOutputStream(newFile));
             try {
-                TestUtils.generateTestData(output, fileSizes[i]);
+                TestUtils.generateTestData(output, 0);
             } finally {
                 IOUtils.closeQuietly(output);
             }
+        } while (getLastModifiedMillis(reference) == getLastModifiedMillis(newFile));
+
+        // Test isFileNewer()
+        assertFalse(FileUtils.isFileNewer(oldFile, reference), "Old File - Newer - File");
+        assertFalse(FileUtils.isFileNewer(oldFile, date), "Old File - Newer - Date");
+        assertFalse(FileUtils.isFileNewer(oldFile, now), "Old File - Newer - Mili");
+        assertFalse(FileUtils.isFileNewer(oldFile, instant), "Old File - Newer - Instant");
+        assertFalse(FileUtils.isFileNewer(oldFile, zonedDateTime), "Old File - Newer - ZonedDateTime");
+        assertFalse(FileUtils.isFileNewer(oldFile, localDateTime), "Old File - Newer - LocalDateTime");
+        assertFalse(FileUtils.isFileNewer(oldFile, localDateTime, ZoneId.systemDefault()), "Old File - Newer - LocalDateTime,ZoneId");
+        assertFalse(FileUtils.isFileNewer(oldFile, localDate), "Old File - Newer - LocalDate");
+        assertTrue(FileUtils.isFileNewer(oldFile, localDate, localTime), "Old File - Newer - LocalDate,ZoneId");
+        assertFalse(FileUtils.isFileNewer(oldFile, localDatePlusDay), "Old File - Newer - LocalDate plus one day");
+        assertFalse(FileUtils.isFileNewer(oldFile, localDatePlusDay, localTime), "Old File - Newer - LocalDate plus one day,ZoneId");
+
+        assertTrue(FileUtils.isFileNewer(newFile, reference), "New File - Newer - File");
+        assertTrue(FileUtils.isFileNewer(newFile, date), "New File - Newer - Date");
+        assertTrue(FileUtils.isFileNewer(newFile, now), "New File - Newer - Mili");
+        assertTrue(FileUtils.isFileNewer(newFile, instant), "New File - Newer - Instant");
+        assertTrue(FileUtils.isFileNewer(newFile, zonedDateTime), "New File - Newer - ZonedDateTime");
+        assertTrue(FileUtils.isFileNewer(newFile, localDateTime), "New File - Newer - LocalDateTime");
+        assertTrue(FileUtils.isFileNewer(newFile, localDateTime, ZoneId.systemDefault()), "New File - Newer - LocalDateTime,ZoneId");
+        assertFalse(FileUtils.isFileNewer(newFile, localDate), "New File - Newer - LocalDate");
+        assertTrue(FileUtils.isFileNewer(newFile, localDate, localTime), "New File - Newer - LocalDate,ZoneId");
+        assertFalse(FileUtils.isFileNewer(newFile, localDatePlusDay), "New File - Newer - LocalDate plus one day");
+        assertFalse(FileUtils.isFileNewer(newFile, localDatePlusDay, localTime), "New File - Newer - LocalDate plus one day,ZoneId");
+        assertFalse(FileUtils.isFileNewer(invalidFile, reference), "Invalid - Newer - File");
+        final String invalidFileName = invalidFile.getName();
+        try {
+            FileUtils.isFileNewer(newFile, invalidFile);
+            fail("Should have cause IllegalArgumentException");
+        } catch (final IllegalArgumentException iae) {
+            final String message = iae.getMessage();
+            assertTrue(message.contains(invalidFileName), "Message should contain: " + invalidFileName + " but was: " + message);
         }
 
-        final Collection<File> files = FileUtils.listFiles(subDir,
-                new WildcardFileFilter("*.*"),
-                new WildcardFileFilter("*"));
+        // Test isFileOlder()
+        assertTrue(FileUtils.isFileOlder(oldFile, reference), "Old File - Older - File");
+        assertTrue(FileUtils.isFileOlder(oldFile, date), "Old File - Older - Date");
+        assertTrue(FileUtils.isFileOlder(oldFile, now), "Old File - Older - Mili");
+        assertTrue(FileUtils.isFileOlder(oldFile, instant), "Old File - Older - Instant");
+        assertTrue(FileUtils.isFileOlder(oldFile, zonedDateTime), "Old File - Older - ZonedDateTime");
+        assertTrue(FileUtils.isFileOlder(oldFile, localDateTime), "Old File - Older - LocalDateTime");
+        assertTrue(FileUtils.isFileOlder(oldFile, localDateTime, ZoneId.systemDefault()), "Old File - Older - LocalDateTime,LocalTime");
+        assertTrue(FileUtils.isFileOlder(oldFile, localDate), "Old File - Older - LocalDate");
+        assertFalse(FileUtils.isFileOlder(oldFile, localDate, localTime), "Old File - Older - LocalDate,ZoneId");
+        assertTrue(FileUtils.isFileOlder(oldFile, localDatePlusDay), "Old File - Older - LocalDate plus one day");
+        assertTrue(FileUtils.isFileOlder(oldFile, localDatePlusDay, localTime), "Old File - Older - LocalDate plus one day,LocalTime");
 
-        final int count = files.size();
-        final Object[] fileObjs = files.toArray();
+        assertFalse(FileUtils.isFileOlder(newFile, reference), "New File - Older - File");
+        assertFalse(FileUtils.isFileOlder(newFile, date), "New File - Older - Date");
+        assertFalse(FileUtils.isFileOlder(newFile, now), "New File - Older - Mili");
+        assertFalse(FileUtils.isFileOlder(newFile, instant), "New File - Older - Instant");
+        assertFalse(FileUtils.isFileOlder(newFile, zonedDateTime), "New File - Older - ZonedDateTime");
+        assertFalse(FileUtils.isFileOlder(newFile, localDateTime), "New File - Older - LocalDateTime");
+        assertFalse(FileUtils.isFileOlder(newFile, localDateTime, ZoneId.systemDefault()), "New File - Older - LocalDateTime,ZoneId");
+        assertTrue(FileUtils.isFileOlder(newFile, localDate), "New File - Older - LocalDate");
+        assertFalse(FileUtils.isFileOlder(newFile, localDate, localTime), "New File - Older - LocalDate,LocalTime");
+        assertTrue(FileUtils.isFileOlder(newFile, localDatePlusDay), "New File - Older - LocalDate plus one day");
+        assertTrue(FileUtils.isFileOlder(newFile, localDatePlusDay, localTime), "New File - Older - LocalDate plus one day,LocalTime");
 
-        assertEquals(fileNames.length, files.size());
+        assertFalse(FileUtils.isFileOlder(invalidFile, reference), "Invalid - Older - File");
+        try {
+            FileUtils.isFileOlder(newFile, invalidFile);
+            fail("Should have cause IllegalArgumentException");
+        } catch (final IllegalArgumentException iae) {
+            final String message = iae.getMessage();
+            assertTrue(message.contains(invalidFileName), "Message should contain: " + invalidFileName + " but was: " + message);
+        }
 
-        final Map<String, String> foundFileNames = new HashMap<>();
 
-        for (int i = 0; i < count; ++i) {
-            boolean found = false;
-            for (int j = 0; !found && j < fileNames.length; ++j) {
-                if (fileNames[j].equals(((File) fileObjs[i]).getName())) {
-                    foundFileNames.put(fileNames[j], fileNames[j]);
-                    found = true;
-                }
-            }
+        // ----- Test isFileNewer() exceptions -----
+        // Null File
+        try {
+            FileUtils.isFileNewer(null, now);
+            fail("Newer Null, expected NullPointerException");
+        } catch (final NullPointerException expected) {
+            // expected result
         }
 
-        assertEquals(foundFileNames.size(), fileNames.length);
+        // Null reference File
+        try {
+            FileUtils.isFileNewer(oldFile, (File) null);
+            fail("Newer Null reference, expected NullPointerException");
+        } catch (final NullPointerException ignore) {
+            // expected result
+        }
 
-        subDir.delete();
-    }
+        // Invalid reference File
+        try {
+            FileUtils.isFileNewer(oldFile, invalidFile);
+            fail("Newer invalid reference, expected IllegalArgumentException");
+        } catch (final IllegalArgumentException ignore) {
+            // expected result
+        }
 
-    @Test
-    public void testListFilesWithDirs() throws IOException {
-        final File srcDir = temporaryFolder;
+        // Null reference Date
+        try {
+            FileUtils.isFileNewer(oldFile, (Date) null);
+            fail("Newer Null date, expected NullPointerException");
+        } catch (final NullPointerException ignore) {
+            // expected result
+        }
 
-        final File subDir1 = new File(srcDir, "subdir");
-        subDir1.mkdir();
 
-        final File subDir2 = new File(subDir1, "subdir2");
-        subDir2.mkdir();
+        // ----- Test isFileOlder() exceptions -----
+        // Null File
+        try {
+            FileUtils.isFileOlder(null, now);
+            fail("Older Null, expected NullPointerException");
+        } catch (final NullPointerException ignore) {
+            // expected result
+        }
 
-        final File someFile = new File(subDir2, "a.txt");
-        if (!someFile.getParentFile().exists()) {
-            throw new IOException("Cannot create file " + someFile
-                    + " as the parent directory does not exist");
+        // Null reference File
+        try {
+            FileUtils.isFileOlder(oldFile, (File) null);
+            fail("Older Null reference, expected NullPointerException");
+        } catch (final NullPointerException ignore) {
+            // expected result
         }
-        final BufferedOutputStream output =
-                new BufferedOutputStream(new FileOutputStream(someFile));
+
+        // Invalid reference File
         try {
-            TestUtils.generateTestData(output, 100);
-        } finally {
-            IOUtils.closeQuietly(output);
+            FileUtils.isFileOlder(oldFile, invalidFile);
+            fail("Older invalid reference, expected IllegalArgumentException");
+        } catch (final IllegalArgumentException ignore) {
+            // expected result
         }
 
-        final File subDir3 = new File(subDir2, "subdir3");
-        subDir3.mkdir();
+        // Null reference Date
+        try {
+            FileUtils.isFileOlder(oldFile, (Date) null);
+            fail("Older Null date, expected NullPointerException");
+        } catch (final NullPointerException ignore) {
+            // expected result
+        }
 
-        final Collection<File> files = FileUtils.listFilesAndDirs(subDir1,
-                new WildcardFileFilter("*.*"), new WildcardFileFilter("*"));
+    }
 
-        assertEquals(4, files.size());
-        assertTrue(files.contains(subDir1), "Should contain the directory.");
-        assertTrue(files.contains(subDir2), "Should contain the directory.");
-        assertTrue(files.contains(someFile), "Should contain the file.");
-        assertTrue(files.contains(subDir3), "Should contain the directory.");
+    @Test
+    public void testIterateFiles() throws Exception {
+        final File srcDir = temporaryFolder;
+        final File subDir = new File(srcDir, "list_test");
+        final File subSubDir = new File(subDir, "subSubDir");
+        final File notSubSubDir = new File(subDir, "notSubSubDir");
+        assertTrue(subDir.mkdir());
+        assertTrue(subSubDir.mkdir());
+        assertTrue(notSubSubDir.mkdir());
+        Iterator<File> iterator = null;
+        try {
+            // Need list to be appendable
+            final List<String> expectedFileNames = new ArrayList(
+                Arrays.asList("a.txt", "b.txt", "c.txt", "d.txt", "e.txt", "f.txt"));
+            final int[] fileSizes = {123, 234, 345, 456, 678, 789};
+            assertEquals(expectedFileNames.size(), fileSizes.length);
+            Collections.sort(expectedFileNames);
+            Arrays.sort(fileSizes);
+            for (int i = 0; i < fileSizes.length; ++i) {
+                TestUtils.generateTestData(new File(subDir, expectedFileNames.get(i)), fileSizes[i]);
+            }
+            //
+            final String subSubFileName = "z.txt";
+            TestUtils.generateTestData(new File(subSubDir, subSubFileName), 1);
+            expectedFileNames.add(subSubFileName);
+            //
+            final String notSubSubFileName = "not.txt";
+            TestUtils.generateTestData(new File(notSubSubDir, notSubSubFileName), 1);
+
+            final WildcardFileFilter allFilesFileFilter = new WildcardFileFilter("*.*");
+            final NameFileFilter dirFilter = new NameFileFilter("subSubDir");
+            iterator = FileUtils.iterateFiles(subDir, allFilesFileFilter, dirFilter);
+
+            final Map<String, String> matchedFileNames = new HashMap<>();
+            final List<String> actualFileNames = new ArrayList<>();
+
+            while (iterator.hasNext()) {
+                boolean found = false;
+                final String fileName = iterator.next().getName();
+                actualFileNames.add(fileName);
+
+                for (int j = 0; !found && j < expectedFileNames.size(); ++j) {
+                    final String expectedFileName = expectedFileNames.get(j);
+                    if (expectedFileName.equals(fileName)) {
+                        matchedFileNames.put(expectedFileName, expectedFileName);
+                        found = true;
+                    }
+                }
+            }
+            assertEquals(expectedFileNames.size(), matchedFileNames.size());
+            Collections.sort(actualFileNames);
+            assertEquals(expectedFileNames, actualFileNames);
+        } finally {
+            consumeRemaining(iterator);
+            notSubSubDir.delete();
+            subSubDir.delete();
+            subDir.delete();
+        }
+    }
 
-        subDir1.delete();
+    @Test
+    public void testIterateFilesAndDirs() throws IOException {
+        final File srcDir = temporaryFolder;
+        // temporaryFolder/srcDir
+        // - subdir1
+        // -- subdir2
+        // --- a.txt
+        // --- subdir3
+        // --- subdir4
+        final File subDir1 = new File(srcDir, "subdir1");
+        final File subDir2 = new File(subDir1, "subdir2");
+        final File subDir3 = new File(subDir2, "subdir3");
+        final File subDir4 = new File(subDir2, "subdir4");
+        assertTrue(subDir1.mkdir());
+        assertTrue(subDir2.mkdir());
+        assertTrue(subDir3.mkdir());
+        assertTrue(subDir4.mkdir());
+        final File someFile = new File(subDir2, "a.txt");
+        final WildcardFileFilter fileFilterAllFiles = new WildcardFileFilter("*.*");
+        final WildcardFileFilter fileFilterAllDirs = new WildcardFileFilter("*");
+        final WildcardFileFilter fileFilterExtTxt = new WildcardFileFilter("*.txt");
+        try {
+            try (final BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(someFile))) {
+                TestUtils.generateTestData(output, 100);
+            }
+            //
+            // "*.*" and "*"
+            Collection<File> expectedFilesAndDirs = Arrays.asList(subDir1, subDir2, someFile, subDir3, subDir4);
+            iterateFilesAndDirs(subDir1, fileFilterAllFiles, fileFilterAllDirs, expectedFilesAndDirs);
+            //
+            // "*.txt" and "*"
+            int filesCount;
+            expectedFilesAndDirs = Arrays.asList(subDir1, subDir2, someFile, subDir3, subDir4);
+            iterateFilesAndDirs(subDir1, fileFilterExtTxt, fileFilterAllDirs, expectedFilesAndDirs);
+            //
+            // "*.*" and "subdir2"
+            expectedFilesAndDirs = Arrays.asList(subDir1, subDir2, someFile);
+            iterateFilesAndDirs(subDir1, fileFilterAllFiles, new NameFileFilter("subdir2"), expectedFilesAndDirs);
+            //
+            // "*.txt" and "subdir2"
+            expectedFilesAndDirs = Arrays.asList(subDir1, subDir2, someFile);
+            iterateFilesAndDirs(subDir1, fileFilterExtTxt, new NameFileFilter("subdir2"), expectedFilesAndDirs);
+        } finally {
+            someFile.delete();
+            subDir4.delete();
+            subDir3.delete();
+            subDir2.delete();
+            subDir1.delete();
+        }
     }
 
     @Test
-    public void testIterateFiles() throws Exception {
+    public void testListFiles() throws Exception {
         final File srcDir = temporaryFolder;
         final File subDir = new File(srcDir, "list_test");
+        final File subDir2 = new File(subDir, "subdir");
         subDir.mkdir();
+        subDir2.mkdir();
+        try {
 
-        final String[] fileNames = {"a.txt", "b.txt", "c.txt", "d.txt", "e.txt", "f.txt"};
-        final int[] fileSizes = {123, 234, 345, 456, 678, 789};
+            final String[] expectedFileNames = {"a.txt", "b.txt", "c.txt", "d.txt", "e.txt", "f.txt"};
+            final int[] fileSizes = {123, 234, 345, 456, 678, 789};
 
-        for (int i = 0; i < fileNames.length; ++i) {
-            final File theFile = new File(subDir, fileNames[i]);
-            if (!theFile.getParentFile().exists()) {
-                throw new IOException("Cannot create file " + theFile
-                        + " as the parent directory does not exist");
-            }
-            final BufferedOutputStream output =
-                    new BufferedOutputStream(new FileOutputStream(theFile));
-            try {
-                TestUtils.generateTestData(output, fileSizes[i]);
-            } finally {
-                IOUtils.closeQuietly(output);
+            for (int i = 0; i < expectedFileNames.length; ++i) {
+                final File theFile = new File(subDir, expectedFileNames[i]);
+                if (!theFile.getParentFile().exists()) {
+                    throw new IOException("Cannot create file " + theFile + " as the parent directory does not exist");
+                }
+                final BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(theFile));
+                try {
+                    TestUtils.generateTestData(output, fileSizes[i]);
+                } finally {
+                    IOUtils.closeQuietly(output);
+                }
             }
-        }
 
-        final Iterator<File> files = FileUtils.iterateFiles(subDir,
-                new WildcardFileFilter("*.*"),
+            final Collection<File> actualFiles = FileUtils.listFiles(subDir, new WildcardFileFilter("*.*"),
                 new WildcardFileFilter("*"));
 
-        final Map<String, String> foundFileNames = new HashMap<>();
+            final int count = actualFiles.size();
+            final Object[] fileObjs = actualFiles.toArray();
+
+            assertEquals(expectedFileNames.length, actualFiles.size(), () -> actualFiles.toString());
 
-        while (files.hasNext()) {
-            boolean found = false;
-            final String fileName = files.next().getName();
+            final Map<String, String> foundFileNames = new HashMap<>();
 
-            for (int j = 0; !found && j < fileNames.length; ++j) {
-                if (fileNames[j].equals(fileName)) {
-                    foundFileNames.put(fileNames[j], fileNames[j]);
-                    found = true;
+            for (int i = 0; i < count; ++i) {
+                boolean found = false;
+                for (int j = 0; !found && j < expectedFileNames.length; ++j) {
+                    if (expectedFileNames[j].equals(((File) fileObjs[i]).getName())) {
+                        foundFileNames.put(expectedFileNames[j], expectedFileNames[j]);
+                        found = true;
+                    }
                 }
             }
-        }
-
-        assertEquals(foundFileNames.size(), fileNames.length);
 
-        subDir.delete();
+            assertEquals(foundFileNames.size(), expectedFileNames.length, () -> foundFileNames.toString());
+        } finally {
+            subDir.delete();
+        }
     }
 
     @Test
-    public void testIterateFilesAndDirs() throws IOException {
+    public void testListFilesWithDirs() throws IOException {
         final File srcDir = temporaryFolder;
 
         final File subDir1 = new File(srcDir, "subdir");
-        subDir1.mkdir();
-
         final File subDir2 = new File(subDir1, "subdir2");
+        subDir1.mkdir();
         subDir2.mkdir();
-
-        final File someFile = new File(subDir2, "a.txt");
-        if (!someFile.getParentFile().exists()) {
-            throw new IOException("Cannot create file " + someFile
-                    + " as the parent directory does not exist");
-        }
-        final BufferedOutputStream output =
-                new BufferedOutputStream(new FileOutputStream(someFile));
         try {
-            TestUtils.generateTestData(output, 100);
-        } finally {
-            IOUtils.closeQuietly(output);
-        }
-
-        final File subDir3 = new File(subDir2, "subdir3");
-        subDir3.mkdir();
+            final File someFile = new File(subDir2, "a.txt");
+            if (!someFile.getParentFile().exists()) {
+                throw new IOException("Cannot create file " + someFile + " as the parent directory does not exist");
+            }
+            final BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(someFile));
+            try {
+                TestUtils.generateTestData(output, 100);
+            } finally {
+                IOUtils.closeQuietly(output);
+            }
 
-        final Collection<File> filesAndDirs = Arrays.asList(subDir1, subDir2, someFile, subDir3);
+            final File subDir3 = new File(subDir2, "subdir3");
+            subDir3.mkdir();
 
-        int filesCount = 0;
-        final Iterator<File> files = FileUtils.iterateFilesAndDirs(subDir1,
-                new WildcardFileFilter("*.*"),
+            final Collection<File> files = FileUtils.listFilesAndDirs(subDir1, new WildcardFileFilter("*.*"),
                 new WildcardFileFilter("*"));
-        while (files.hasNext()) {
-            filesCount++;
-            final File file = files.next();
-            assertTrue(filesAndDirs.contains(file), "Should contain the directory/file");
-        }
 
-        assertEquals(filesCount, filesAndDirs.size());
+            assertEquals(4, files.size());
+            assertTrue(files.contains(subDir1), "Should contain the directory.");
+            assertTrue(files.contains(subDir2), "Should contain the directory.");
+            assertTrue(files.contains(someFile), "Should contain the file.");
+            assertTrue(files.contains(subDir3), "Should contain the directory.");
+        } finally {
+            subDir1.delete();
+        }
     }
 
     @Test
-    public void testReadFileToStringWithDefaultEncoding() throws Exception {
-        final File file = new File(temporaryFolder, "read.obj");
-        final FileOutputStream out = new FileOutputStream(file);
-        final byte[] text = "Hello /u1234".getBytes();
-        out.write(text);
-        out.close();
+    public void testMoveDirectory_CopyDelete() throws Exception {
 
-        final String data = FileUtils.readFileToString(file);
-        assertEquals("Hello /u1234", data);
-    }
+        final File dir = temporaryFolder;
+        final File src = new File(dir, "testMoveDirectory2Source") {
+            private static final long serialVersionUID = 1L;
+
+            // Force renameTo to fail
+            @Override
+            public boolean renameTo(final File dest) {
+                return false;
+            }
+        };
+        final File testDir = new File(src, "foo");
+        final File testFile = new File(testDir, "bar");
+        testDir.mkdirs();
+        if (!testFile.getParentFile().exists()) {
+            throw new IOException("Cannot create file " + testFile
+                    + " as the parent directory does not exist");
+        }
+        final BufferedOutputStream output =
+                new BufferedOutputStream(new FileOutputStream(testFile));
+        try {
+            TestUtils.generateTestData(output, 0);
+        } finally {
+            IOUtils.closeQuietly(output);
+        }
+        final File destination = new File(dir, "testMoveDirectory1Dest");
+        FileUtils.deleteDirectory(destination);
+
+        // Move the directory
+        FileUtils.moveDirectory(src, destination);
+
+        // Check results
+        assertTrue(destination.exists(), "Check Exist");
+        assertTrue(!src.exists(), "Original deleted");
+        final File movedDir = new File(destination, testDir.getName());
+        final File movedFile = new File(movedDir, testFile.getName());
+        assertTrue(movedDir.exists(), "Check dir moved");
+        assertTrue(movedFile.exists(), "Check file moved");
+    }
+
+    @Test
+    public void testMoveDirectory_Errors() throws Exception {
+        try {
+            FileUtils.moveDirectory(null, new File("foo"));
+            fail("Expected NullPointerException when source is null");
+        } catch (final NullPointerException e) {
+            // expected
+        }
+        try {
+            FileUtils.moveDirectory(new File("foo"), null);
+            fail("Expected NullPointerException when destination is null");
+        } catch (final NullPointerException e) {
+            // expected
+        }
+        try {
+            FileUtils.moveDirectory(new File("nonexistant"), new File("foo"));
+            fail("Expected FileNotFoundException for source");
+        } catch (final FileNotFoundException e) {
+            // expected
+        }
+        final File testFile = new File(temporaryFolder, "testMoveDirectoryFile");
+        if (!testFile.getParentFile().exists()) {
+            throw new IOException("Cannot create file " + testFile
+                    + " as the parent directory does not exist");
+        }
+        final BufferedOutputStream output =
+                new BufferedOutputStream(new FileOutputStream(testFile));
+        try {
+            TestUtils.generateTestData(output, 0);
+        } finally {
+            IOUtils.closeQuietly(output);
+        }
+        try {
+            FileUtils.moveDirectory(testFile, new File("foo"));
+            fail("Expected IOException when source is not a directory");
+        } catch (final IOException e) {
+            // expected
+        }
+        final File testSrcFile = new File(temporaryFolder, "testMoveDirectorySource");
+        final File testDestFile = new File(temporaryFolder, "testMoveDirectoryDest");
+        testSrcFile.mkdir();
+        testDestFile.mkdir();
+        try {
+            FileUtils.moveDirectory(testSrcFile, testDestFile);
+            fail("Expected FileExistsException when dest already exists");
+        } catch (final FileExistsException e) {
+            // expected
+        }
+    }
+
+    @Test
+    public void testMoveDirectory_Rename() throws Exception {
+        final File dir = temporaryFolder;
+        final File src = new File(dir, "testMoveDirectory1Source");
+        final File testDir = new File(src, "foo");
+        final File testFile = new File(testDir, "bar");
+        testDir.mkdirs();
+        if (!testFile.getParentFile().exists()) {
+            throw new IOException("Cannot create file " + testFile
+                    + " as the parent directory does not exist");
+        }
+        final BufferedOutputStream output =
+                new BufferedOutputStream(new FileOutputStream(testFile));
+        try {
+            TestUtils.generateTestData(output, 0);
+        } finally {
+            IOUtils.closeQuietly(output);
+        }
+        final File destination = new File(dir, "testMoveDirectory1Dest");
+        FileUtils.deleteDirectory(destination);
+
+        // Move the directory
+        FileUtils.moveDirectory(src, destination);
+
+        // Check results
+        assertTrue(destination.exists(), "Check Exist");
+        assertTrue(!src.exists(), "Original deleted");
+        final File movedDir = new File(destination, testDir.getName());
+        final File movedFile = new File(movedDir, testFile.getName());
+        assertTrue(movedDir.exists(), "Check dir moved");
+        assertTrue(movedFile.exists(), "Check file moved");
+    }
+
+    @Test
+    public void testMoveDirectoryToDirectory() throws Exception {
+        final File dir = temporaryFolder;
+        final File src = new File(dir, "testMoveDirectory1Source");
+        final File testChildDir = new File(src, "foo");
+        final File testFile = new File(testChildDir, "bar");
+        testChildDir.mkdirs();
+        if (!testFile.getParentFile().exists()) {
+            throw new IOException("Cannot create file " + testFile
+                    + " as the parent directory does not exist");
+        }
+        final BufferedOutputStream output =
+                new BufferedOutputStream(new FileOutputStream(testFile));
+        try {
+            TestUtils.generateTestData(output, 0);
+        } finally {
+            IOUtils.closeQuietly(output);
+        }
+        final File destDir = new File(dir, "testMoveDirectory1Dest");
+        FileUtils.deleteDirectory(destDir);
+        assertFalse(destDir.exists(), "Check Exist before");
+
+        // Move the directory
+        FileUtils.moveDirectoryToDirectory(src, destDir, true);
+
+        // Check results
+        assertTrue(destDir.exists(), "Check Exist after");
+        assertTrue(!src.exists(), "Original deleted");
+        final File movedDir = new File(destDir, src.getName());
+        final File movedChildDir = new File(movedDir, testChildDir.getName());
+        final File movedFile = new File(movedChildDir, testFile.getName());
+        assertTrue(movedDir.exists(), "Check dir moved");
+        assertTrue(movedChildDir.exists(), "Check child dir moved");
+        assertTrue(movedFile.exists(), "Check file moved");
+    }
+
+    @Test
+    public void testMoveDirectoryToDirectory_Errors() throws Exception {
+        try {
+            FileUtils.moveDirectoryToDirectory(null, new File("foo"), true);
+            fail("Expected NullPointerException when source is null");
+        } catch (final NullPointerException e) {
+            // expected
+        }
+        try {
+            FileUtils.moveDirectoryToDirectory(new File("foo"), null, true);
+            fail("Expected NullPointerException when destination is null");
+        } catch (final NullPointerException e) {
+            // expected
+        }
+        final File testFile1 = new File(temporaryFolder, "testMoveFileFile1");
+        final File testFile2 = new File(temporaryFolder, "testMoveFileFile2");
+        if (!testFile1.getParentFile().exists()) {
+            throw new IOException("Cannot create file " + testFile1
+                    + " as the parent directory does not exist");
+        }
+        final BufferedOutputStream output1 =
+                new BufferedOutputStream(new FileOutputStream(testFile1));
+        try {
+            TestUtils.generateTestData(output1, 0);
+        } finally {
+            IOUtils.closeQuietly(output1);
+        }
+        if (!testFile2.getParentFile().exists()) {
+            throw new IOException("Cannot create file " + testFile2
+                    + " as the parent directory does not exist");
+        }
+        final BufferedOutputStream output =
+                new BufferedOutputStream(new FileOutputStream(testFile2));
+        try {
+            TestUtils.generateTestData(output, 0);
+        } finally {
+            IOUtils.closeQuietly(output);
+        }
+        try {
+            FileUtils.moveDirectoryToDirectory(testFile1, testFile2, true);
+            fail("Expected IOException when dest not a directory");
+        } catch (final IOException e) {
+            // expected
+        }
+
+        final File nonexistant = new File(temporaryFolder, "testMoveFileNonExistant");
+        try {
+            FileUtils.moveDirectoryToDirectory(testFile1, nonexistant, false);
+            fail("Expected IOException when dest does not exist and create=false");
+        } catch (final IOException e) {
+            // expected
+        }
+    }
+
+    @Test
+    public void testMoveFile_CopyDelete() throws Exception {
+        final File destination = new File(temporaryFolder, "move2.txt");
+        final File src = new File(testFile1.getAbsolutePath()) {
+            private static final long serialVersionUID = 1L;
+
+            // Force renameTo to fail, as if destination is on another
+            // filesystem
+            @Override
+            public boolean renameTo(final File f) {
+                return false;
+            }
+        };
+        FileUtils.moveFile(src, destination);
+        assertTrue(destination.exists(), "Check Exist");
+        assertTrue(!src.exists(), "Original deleted");
+    }
+
+    @Test
+    public void testMoveFile_CopyDelete_Failed() throws Exception {
+        final File destination = new File(temporaryFolder, "move3.txt");
+        final File src = new File(testFile1.getAbsolutePath()) {
+            private static final long serialVersionUID = 1L;
+
+            // Force delete failure
+            @Override
+            public boolean delete() {
+                return false;
+            }
+
+            // Force renameTo to fail, as if destination is on another
+            // filesystem
+            @Override
+            public boolean renameTo(final File f) {
+                return false;
+            }
+
+        };
+        try {
+            FileUtils.moveFile(src, destination);
+            fail("move should have failed as src has not been deleted");
+        } catch (final IOException e) {
+            // exepected
+            assertTrue(!destination.exists(), "Check Rollback");
+            assertTrue(src.exists(), "Original exists");
+        }
+    }
+
+    @Test
+    public void testMoveFile_Errors() throws Exception {
+        try {
+            FileUtils.moveFile(null, new File("foo"));
+            fail("Expected NullPointerException when source is null");
+        } catch (final NullPointerException e) {
+            // expected
+        }
+        try {
+            FileUtils.moveFile(new File("foo"), null);
+            fail("Expected NullPointerException when destination is null");
+        } catch (final NullPointerException e) {
+            // expected
+        }
+        try {
+            FileUtils.moveFile(new File("nonexistant"), new File("foo"));
+            fail("Expected FileNotFoundException for source");
+        } catch (final FileNotFoundException e) {
+            // expected
+        }
+        try {
+            FileUtils.moveFile(temporaryFolder, new File("foo"));
+            fail("Expected IOException when source is a directory");
+        } catch (final IOException e) {
+            // expected
+        }
+        final File testSourceFile = new File(temporaryFolder, "testMoveFileSource");
+        final File testDestFile = new File(temporaryFolder, "testMoveFileSource");
+        if (!testSourceFile.getParentFile().exists()) {
+            throw new IOException("Cannot create file " + testSourceFile
+                    + " as the parent directory does not exist");
+        }
+        final BufferedOutputStream output1 =
+                new BufferedOutputStream(new FileOutputStream(testSourceFile));
+        try {
+            TestUtils.generateTestData(output1, 0);
+        } finally {
+            IOUtils.closeQuietly(output1);
+        }
+        if (!testDestFile.getParentFile().exists()) {
+            throw new IOException("Cannot create file " + testDestFile
+                    + " as the parent directory does not exist");
+        }
+        final BufferedOutputStream output =
+                new BufferedOutputStream(new FileOutputStream(testDestFile));
+        try {
+            TestUtils.generateTestData(output, 0);
+        } finally {
+            IOUtils.closeQuietly(output);
+        }
+        try {
+            FileUtils.moveFile(testSourceFile, testDestFile);
+            fail("Expected FileExistsException when dest already exists");
+        } catch (final FileExistsException e) {
+            // expected
+        }
+    }
+
+    @Test
+    public void testMoveFile_Rename() throws Exception {
+        final File destination = new File(temporaryFolder, "move1.txt");
+
+        FileUtils.moveFile(testFile1, destination);
+        assertTrue(destination.exists(), "Check Exist");
+        assertTrue(!testFile1.exists(), "Original deleted");
+    }
+
+    @Test
+    public void testMoveFileToDirectory() throws Exception {
+        final File destDir = new File(temporaryFolder, "moveFileDestDir");
+        final File movedFile = new File(destDir, testFile1.getName());
+        assertFalse(destDir.exists(), "Check Exist before");
+        assertFalse(movedFile.exists(), "Check Exist before");
+
+        FileUtils.moveFileToDirectory(testFile1, destDir, true);
+        assertTrue(movedFile.exists(), "Check Exist after");
+        assertTrue(!testFile1.exists(), "Original deleted");
+    }
 
     @Test
-    public void testReadFileToStringWithEncoding() throws Exception {
-        final File file = new File(temporaryFolder, "read.obj");
-        final FileOutputStream out = new FileOutputStream(file);
-        final byte[] text = "Hello /u1234".getBytes("UTF8");
-        out.write(text);
-        out.close();
+    public void testMoveFileToDirectory_Errors() throws Exception {
+        try {
+            FileUtils.moveFileToDirectory(null, new File("foo"), true);
+            fail("Expected NullPointerException when source is null");
+        } catch (final NullPointerException e) {
+            // expected
+        }
+        try {
+            FileUtils.moveFileToDirectory(new File("foo"), null, true);
+            fail("Expected NullPointerException when destination is null");
+        } catch (final NullPointerException e) {
+            // expected
+        }
+        final File testFile1 = new File(temporaryFolder, "testMoveFileFile1");
+        final File testFile2 = new File(temporaryFolder, "testMoveFileFile2");
+        if (!testFile1.getParentFile().exists()) {
+            throw new IOException("Cannot create file " + testFile1
+                    + " as the parent directory does not exist");
+        }
+        final BufferedOutputStream output1 =
+                new BufferedOutputStream(new FileOutputStream(testFile1));
+        try {
+            TestUtils.generateTestData(output1, 0);
+        } finally {
+            IOUtils.closeQuietly(output1);
+        }
+        if (!testFile2.getParentFile().exists()) {
+            throw new IOException("Cannot create file " + testFile2
+                    + " as the parent directory does not exist");
+        }
+        final BufferedOutputStream output =
+                new BufferedOutputStream(new FileOutputStream(testFile2));
+        try {
+            TestUtils.generateTestData(output, 0);
+        } finally {
+            IOUtils.closeQuietly(output);
+        }
+        try {
+            FileUtils.moveFileToDirectory(testFile1, testFile2, true);
+            fail("Expected IOException when dest not a directory");
+        } catch (final IOException e) {
+            // expected
+        }
 
-        final String data = FileUtils.readFileToString(file, "UTF8");
-        assertEquals("Hello /u1234", data);
+        final File nonexistant = new File(temporaryFolder, "testMoveFileNonExistant");
+        try {
+            FileUtils.moveFileToDirectory(testFile1, nonexistant, false);
+            fail("Expected IOException when dest does not exist and create=false");
+        } catch (final IOException e) {
+            // expected
+        }
+    }
+
+    @Test
+    public void testMoveToDirectory() throws Exception {
+        final File destDir = new File(temporaryFolder, "testMoveToDirectoryDestDir");
+        final File testDir = new File(temporaryFolder, "testMoveToDirectoryTestDir");
+        final File testFile = new File(temporaryFolder, "testMoveToDirectoryTestFile");
+        testDir.mkdirs();
+        if (!testFile.getParentFile().exists()) {
+            throw new IOException("Cannot create file " + testFile
+                    + " as the parent directory does not exist");
+        }
+        final BufferedOutputStream output =
+                new BufferedOutputStream(new FileOutputStream(testFile));
+        try {
+            TestUtils.generateTestData(output, 0);
+        } finally {
+            IOUtils.closeQuietly(output);
+        }
+        final File movedFile = new File(destDir, testFile.getName());
+        final File movedDir = new File(destDir, testFile.getName());
+
+        assertFalse(movedFile.exists(), "Check File Doesnt exist");
+        assertFalse(movedDir.exists(), "Check Dir Doesnt exist");
+
+        // Test moving a file
+        FileUtils.moveToDirectory(testFile, destDir, true);
+        assertTrue(movedFile.exists(), "Check File exists");
+        assertFalse(testFile.exists(), "Check Original File doesn't exist");
+
+        // Test moving a directory
+        FileUtils.moveToDirectory(testDir, destDir, true);
+        assertTrue(movedDir.exists(), "Check Dir exists");
+        assertFalse(testDir.exists(), "Check Original Dir doesn't exist");
+    }
+
+    @Test
+    public void testMoveToDirectory_Errors() throws Exception {
+        try {
+            FileUtils.moveDirectoryToDirectory(null, new File("foo"), true);
+            fail("Expected NullPointerException when source is null");
+        } catch (final NullPointerException e) {
+            // expected
+        }
+        try {
+            FileUtils.moveDirectoryToDirectory(new File("foo"), null, true);
+            fail("Expected NullPointerException when destination is null");
+        } catch (final NullPointerException e) {
+            // expected
+        }
+        final File nonexistant = new File(temporaryFolder, "nonexistant");
+        final File destDir = new File(temporaryFolder, "MoveToDirectoryDestDir");
+        try {
+            FileUtils.moveToDirectory(nonexistant, destDir, true);
+            fail("Expected IOException when source does not exist");
+        } catch (final IOException e) {
+            // expected
+        }
     }
 
     @Test
@@ -2046,6 +2496,30 @@ public void testReadFileToByteArray() throws Exception {
         assertEquals(31, data[2]);
     }
 
+    @Test
+    public void testReadFileToStringWithDefaultEncoding() throws Exception {
+        final File file = new File(temporaryFolder, "read.obj");
+        final FileOutputStream out = new FileOutputStream(file);
+        final byte[] text = "Hello /u1234".getBytes();
+        out.write(text);
+        out.close();
+
+        final String data = FileUtils.readFileToString(file);
+        assertEquals("Hello /u1234", data);
+    }
+
+    @Test
+    public void testReadFileToStringWithEncoding() throws Exception {
+        final File file = new File(temporaryFolder, "read.obj");
+        final FileOutputStream out = new FileOutputStream(file);
+        final byte[] text = "Hello /u1234".getBytes("UTF8");
+        out.write(text);
+        out.close();
+
+        final String data = FileUtils.readFileToString(file, "UTF8");
+        assertEquals("Hello /u1234", data);
+    }
+
     @Test
     public void testReadLines() throws Exception {
         final File file = TestUtils.newFile(temporaryFolder, "lines.txt");
@@ -2061,328 +2535,310 @@ public void testReadLines() throws Exception {
     }
 
     @Test
-    public void testWriteStringToFile1() throws Exception {
-        final File file = new File(temporaryFolder, "write.txt");
-        FileUtils.writeStringToFile(file, "Hello /u1234", "UTF8");
-        final byte[] text = "Hello /u1234".getBytes("UTF8");
-        TestUtils.assertEqualContent(text, file);
-    }
+    public void testSizeOf() throws Exception {
+        final File file = new File(temporaryFolder, getName());
 
-    @Test
-    public void testWriteStringToFile2() throws Exception {
-        final File file = new File(temporaryFolder, "write.txt");
-        FileUtils.writeStringToFile(file, "Hello /u1234", (String) null);
-        final byte[] text = "Hello /u1234".getBytes();
-        TestUtils.assertEqualContent(text, file);
-    }
+        // Null argument
+        try {
+            FileUtils.sizeOf(null);
+            fail("Exception expected.");
+        } catch (final NullPointerException ignore) {
+        }
 
-    @Test
-    public void testWriteStringToFile3() throws Exception {
-        final File file = new File(temporaryFolder, "write.txt");
-        FileUtils.writeStringToFile(file, "Hello /u1234", (Charset) null);
-        final byte[] text = "Hello /u1234".getBytes();
-        TestUtils.assertEqualContent(text, file);
-    }
+        // Non-existent file
+        try {
+            FileUtils.sizeOf(file);
+            fail("Exception expected.");
+        } catch (final IllegalArgumentException ignore) {
+        }
 
-    @Test
-    public void testWriteCharSequence1() throws Exception {
-        final File file = new File(temporaryFolder, "write.txt");
-        FileUtils.write(file, "Hello /u1234", "UTF8");
-        final byte[] text = "Hello /u1234".getBytes("UTF8");
-        TestUtils.assertEqualContent(text, file);
-    }
+        // Creates file
+        file.createNewFile();
+        file.deleteOnExit();
 
-    @Test
-    public void testWriteCharSequence2() throws Exception {
-        final File file = new File(temporaryFolder, "write.txt");
-        FileUtils.write(file, "Hello /u1234", (String) null);
-        final byte[] text = "Hello /u1234".getBytes();
-        TestUtils.assertEqualContent(text, file);
-    }
+        // New file
+        assertEquals(0, FileUtils.sizeOf(file));
+        file.delete();
 
-    @Test
-    public void testWriteByteArrayToFile() throws Exception {
-        final File file = new File(temporaryFolder, "write.obj");
-        final byte[] data = new byte[]{11, 21, 31};
-        FileUtils.writeByteArrayToFile(file, data);
-        TestUtils.assertEqualContent(data, file);
-    }
+        // Existing file
+        assertEquals(testFile1Size, FileUtils.sizeOf(testFile1), "Unexpected files size");
 
-    @Test
-    public void testWriteByteArrayToFile_WithOffsetAndLength() throws Exception {
-        final File file = new File(temporaryFolder, "write.obj");
-        final byte[] data = new byte[]{11, 21, 32, 41, 51};
-        final byte[] writtenData = new byte[3];
-        System.arraycopy(data, 1, writtenData, 0, 3);
-        FileUtils.writeByteArrayToFile(file, data, 1, 3);
-        TestUtils.assertEqualContent(writtenData, file);
+        // Existing directory
+        assertEquals(TEST_DIRECTORY_SIZE, FileUtils.sizeOf(temporaryFolder), "Unexpected directory size");
     }
 
     @Test
-    public void testWriteLines_4arg() throws Exception {
-        final Object[] data = new Object[]{
-                "hello", new StringBuffer("world"), "", "this is", null, "some text"};
-        final List<Object> list = Arrays.asList(data);
+    public void testSizeOfAsBigInteger() throws Exception {
+        final File file = new File(temporaryFolder, getName());
 
-        final File file = TestUtils.newFile(temporaryFolder, "lines.txt");
-        FileUtils.writeLines(file, "US-ASCII", list, "*");
+        // Null argument
+        try {
+            FileUtils.sizeOfAsBigInteger(null);
+            fail("Exception expected.");
+        } catch (final NullPointerException ignore) {
+        }
 
-        final String expected = "hello*world**this is**some text*";
-        final String actual = FileUtils.readFileToString(file, "US-ASCII");
-        assertEquals(expected, actual);
-    }
+        // Non-existent file
+        try {
+            FileUtils.sizeOfAsBigInteger(file);
+            fail("Exception expected.");
+        } catch (final IllegalArgumentException ignore) {
+        }
+
+        // Creates file
+        file.createNewFile();
+        file.deleteOnExit();
+
+        // New file
+        assertEquals(BigInteger.ZERO, FileUtils.sizeOfAsBigInteger(file));
+        file.delete();
 
-    @Test
-    public void testWriteLines_4arg_Writer_nullData() throws Exception {
-        final File file = TestUtils.newFile(temporaryFolder, "lines.txt");
-        FileUtils.writeLines(file, "US-ASCII", null, "*");
+        // Existing file
+        assertEquals(BigInteger.valueOf(testFile1Size), FileUtils.sizeOfAsBigInteger(testFile1),
+                "Unexpected files size");
 
-        assertEquals(0, file.length(), "Sizes differ");
+        // Existing directory
+        assertEquals(TEST_DIRECTORY_SIZE_BI, FileUtils.sizeOfAsBigInteger(temporaryFolder),
+                "Unexpected directory size");
     }
 
+
     @Test
-    public void testWriteLines_4arg_nullSeparator() throws Exception {
-        final Object[] data = new Object[]{
-                "hello", new StringBuffer("world"), "", "this is", null, "some text"};
-        final List<Object> list = Arrays.asList(data);
+    public void testSizeOfDirectory() throws Exception {
+        final File file = new File(temporaryFolder, getName());
 
-        final File file = TestUtils.newFile(temporaryFolder, "lines.txt");
-        FileUtils.writeLines(file, "US-ASCII", list, null);
+        // Non-existent file
+        try {
+            FileUtils.sizeOfDirectory(file);
+            fail("Exception expected.");
+        } catch (final IllegalArgumentException ignore) {
+        }
 
-        final String expected = "hello" + System.lineSeparator() + "world" + System.lineSeparator() +
-                System.lineSeparator() + "this is" + System.lineSeparator() +
-                System.lineSeparator() + "some text" + System.lineSeparator();
-        final String actual = FileUtils.readFileToString(file, "US-ASCII");
-        assertEquals(expected, actual);
-    }
+        // Creates file
+        file.createNewFile();
 
-    @Test
-    public void testWriteLines_3arg_nullSeparator() throws Exception {
-        final Object[] data = new Object[]{
-                "hello", new StringBuffer("world"), "", "this is", null, "some text"};
-        final List<Object> list = Arrays.asList(data);
+        // Existing file
+        try {
+            FileUtils.sizeOfDirectory(file);
+            fail("Exception expected.");
+        } catch (final IllegalArgumentException ignore) {
+        }
 
-        final File file = TestUtils.newFile(temporaryFolder, "lines.txt");
-        FileUtils.writeLines(file, "US-ASCII", list);
+        // Existing directory
+        file.delete();
+        file.mkdir();
 
-        final String expected = "hello" + System.lineSeparator() + "world" + System.lineSeparator() +
-                System.lineSeparator() + "this is" + System.lineSeparator() +
-                System.lineSeparator() + "some text" + System.lineSeparator();
-        final String actual = FileUtils.readFileToString(file, "US-ASCII");
-        assertEquals(expected, actual);
+        // Create a cyclic symlink
+        this.createCircularSymLink(file);
+
+        assertEquals(TEST_DIRECTORY_SIZE, FileUtils.sizeOfDirectory(file), "Unexpected directory size");
     }
 
     @Test
-    public void testWriteLines_5argsWithAppendOptionTrue_ShouldNotDeletePreviousFileLines() throws Exception {
-        final File file = TestUtils.newFile(temporaryFolder, "lines.txt");
-        FileUtils.writeStringToFile(file, "This line was there before you...");
-
-        final List<String> linesToAppend = Arrays.asList("my first line", "The second Line");
-        FileUtils.writeLines(file, null, linesToAppend, null, true);
+    public void testSizeOfDirectoryAsBigInteger() throws Exception {
+        final File file = new File(temporaryFolder, getName());
 
-        final String expected = "This line was there before you..."
-                + "my first line"
-                + System.lineSeparator() + "The second Line"
-                + System.lineSeparator();
-        final String actual = FileUtils.readFileToString(file);
-        assertEquals(expected, actual);
-    }
+        // Non-existent file
+        try {
+            FileUtils.sizeOfDirectoryAsBigInteger(file);
+            fail("Exception expected.");
+        } catch (final IllegalArgumentException ignore) {
+        }
 
-    @Test
-    public void testWriteLines_5argsWithAppendOptionFalse_ShouldDeletePreviousFileLines() throws Exception {
-        final File file = TestUtils.newFile(temporaryFolder, "lines.txt");
-        FileUtils.writeStringToFile(file, "This line was there before you...");
+        // Creates file
+        file.createNewFile();
+        file.deleteOnExit();
 
-        final List<String> linesToAppend = Arrays.asList("my first line", "The second Line");
-        FileUtils.writeLines(file, null, linesToAppend, null, false);
+        // Existing file
+        try {
+            FileUtils.sizeOfDirectoryAsBigInteger(file);
+            fail("Exception expected.");
+        } catch (final IllegalArgumentException ignore) {
+        }
 
-        final String expected = "my first line"
-                + System.lineSeparator() + "The second Line"
-                + System.lineSeparator();
-        final String actual = FileUtils.readFileToString(file);
-        assertEquals(expected, actual);
-    }
+        // Existing directory
+        file.delete();
+        file.mkdir();
 
-    @Test
-    public void testWriteLines_4argsWithAppendOptionTrue_ShouldNotDeletePreviousFileLines() throws Exception {
-        final File file = TestUtils.newFile(temporaryFolder, "lines.txt");
-        FileUtils.writeStringToFile(file, "This line was there before you...");
+        this.createCircularSymLink(file);
 
-        final List<String> linesToAppend = Arrays.asList("my first line", "The second Line");
-        FileUtils.writeLines(file, linesToAppend, null, true);
+        assertEquals(TEST_DIRECTORY_SIZE_BI, FileUtils.sizeOfDirectoryAsBigInteger(file), "Unexpected directory size");
 
-        final String expected = "This line was there before you..."
-                + "my first line"
-                + System.lineSeparator() + "The second Line"
-                + System.lineSeparator();
-        final String actual = FileUtils.readFileToString(file);
-        assertEquals(expected, actual);
-    }
+        // Existing directory which size is greater than zero
+        file.delete();
+        file.mkdir();
 
-    @Test
-    public void testWriteLines_4argsWithAppendOptionFalse_ShouldDeletePreviousFileLines() throws Exception {
-        final File file = TestUtils.newFile(temporaryFolder, "lines.txt");
-        FileUtils.writeStringToFile(file, "This line was there before you...");
+        final File nonEmptyFile = new File(file, "nonEmptyFile" + System.nanoTime());
+        if (!nonEmptyFile.getParentFile().exists()) {
+            throw new IOException("Cannot create file " + nonEmptyFile
+                    + " as the parent directory does not exist");
+        }
+        final BufferedOutputStream output =
+                new BufferedOutputStream(new FileOutputStream(nonEmptyFile));
+        try {
+            TestUtils.generateTestData(output, TEST_DIRECTORY_SIZE_GT_ZERO_BI.longValue());
+        } finally {
+            IOUtils.closeQuietly(output);
+        }
+        nonEmptyFile.deleteOnExit();
 
-        final List<String> linesToAppend = Arrays.asList("my first line", "The second Line");
-        FileUtils.writeLines(file, linesToAppend, null, false);
+        assertEquals(TEST_DIRECTORY_SIZE_GT_ZERO_BI, FileUtils.sizeOfDirectoryAsBigInteger(file),
+                "Unexpected directory size");
 
-        final String expected = "my first line"
-                + System.lineSeparator() + "The second Line"
-                + System.lineSeparator();
-        final String actual = FileUtils.readFileToString(file);
-        assertEquals(expected, actual);
+        nonEmptyFile.delete();
+        file.delete();
     }
 
-
+    //-----------------------------------------------------------------------
     @Test
-    public void testWriteLinesEncoding_WithAppendOptionTrue_ShouldNotDeletePreviousFileLines() throws Exception {
-        final File file = TestUtils.newFile(temporaryFolder, "lines.txt");
-        FileUtils.writeStringToFile(file, "This line was there before you...");
-
-        final List<String> linesToAppend = Arrays.asList("my first line", "The second Line");
-        FileUtils.writeLines(file, null, linesToAppend, true);
-
-        final String expected = "This line was there before you..."
-                + "my first line"
-                + System.lineSeparator() + "The second Line"
-                + System.lineSeparator();
-        final String actual = FileUtils.readFileToString(file);
-        assertEquals(expected, actual);
+    public void testToFile1() throws Exception {
+        final URL url = new URL("file", null, "a/b/c/file.txt");
+        final File file = FileUtils.toFile(url);
+        assertTrue(file.toString().contains("file.txt"));
     }
 
     @Test
-    public void testWriteLinesEncoding_WithAppendOptionFalse_ShouldDeletePreviousFileLines() throws Exception {
-        final File file = TestUtils.newFile(temporaryFolder, "lines.txt");
-        FileUtils.writeStringToFile(file, "This line was there before you...");
-
-        final List<String> linesToAppend = Arrays.asList("my first line", "The second Line");
-        FileUtils.writeLines(file, null, linesToAppend, false);
-
-        final String expected = "my first line"
-                + System.lineSeparator() + "The second Line"
-                + System.lineSeparator();
-        final String actual = FileUtils.readFileToString(file);
-        assertEquals(expected, actual);
+    public void testToFile2() throws Exception {
+        final URL url = new URL("file", null, "a/b/c/file%20n%61me%2520.tx%74");
+        final File file = FileUtils.toFile(url);
+        assertTrue(file.toString().contains("file name%20.txt"));
     }
 
     @Test
-    public void testWriteLines_3argsWithAppendOptionTrue_ShouldNotDeletePreviousFileLines() throws Exception {
-        final File file = TestUtils.newFile(temporaryFolder, "lines.txt");
-        FileUtils.writeStringToFile(file, "This line was there before you...");
-
-        final List<String> linesToAppend = Arrays.asList("my first line", "The second Line");
-        FileUtils.writeLines(file, linesToAppend, true);
-
-        final String expected = "This line was there before you..."
-                + "my first line"
-                + System.lineSeparator() + "The second Line"
-                + System.lineSeparator();
-        final String actual = FileUtils.readFileToString(file);
-        assertEquals(expected, actual);
+    public void testToFile3() throws Exception {
+        assertEquals(null, FileUtils.toFile(null));
+        assertEquals(null, FileUtils.toFile(new URL("http://jakarta.apache.org")));
     }
 
     @Test
-    public void testWriteLines_3argsWithAppendOptionFalse_ShouldDeletePreviousFileLines() throws Exception {
-        final File file = TestUtils.newFile(temporaryFolder, "lines.txt");
-        FileUtils.writeStringToFile(file, "This line was there before you...");
-
-        final List<String> linesToAppend = Arrays.asList("my first line", "The second Line");
-        FileUtils.writeLines(file, linesToAppend, false);
-
-        final String expected = "my first line"
-                + System.lineSeparator() + "The second Line"
-                + System.lineSeparator();
-        final String actual = FileUtils.readFileToString(file);
-        assertEquals(expected, actual);
+    public void testToFile4() throws Exception {
+        final URL url = new URL("file", null, "a/b/c/file%%20%me.txt%");
+        final File file = FileUtils.toFile(url);
+        assertTrue(file.toString().contains("file% %me.txt%"));
     }
 
+    /* IO-252 */
     @Test
-    public void testWriteStringToFileWithEncoding_WithAppendOptionTrue_ShouldNotDeletePreviousFileLines() throws Exception {
-        final File file = TestUtils.newFile(temporaryFolder, "lines.txt");
-        FileUtils.writeStringToFile(file, "This line was there before you...");
-
-        FileUtils.writeStringToFile(file, "this is brand new data", (String) null, true);
-
-        final String expected = "This line was there before you..."
-                + "this is brand new data";
-        final String actual = FileUtils.readFileToString(file);
-        assertEquals(expected, actual);
+    public void testToFile5() throws Exception {
+        final URL url = new URL("file", null, "both%20are%20100%20%25%20true");
+        final File file = FileUtils.toFile(url);
+        assertEquals("both are 100 % true", file.toString());
     }
 
     @Test
-    public void testWriteStringToFileWithEncoding_WithAppendOptionFalse_ShouldDeletePreviousFileLines() throws Exception {
-        final File file = TestUtils.newFile(temporaryFolder, "lines.txt");
-        FileUtils.writeStringToFile(file, "This line was there before you...");
+    public void testToFiles1() throws Exception {
+        final URL[] urls = new URL[]{
+                new URL("file", null, "file1.txt"),
+                new URL("file", null, "file2.txt"),
+        };
+        final File[] files = FileUtils.toFiles(urls);
 
-        FileUtils.writeStringToFile(file, "this is brand new data", (String) null, false);
+        assertEquals(urls.length, files.length);
+        assertEquals(true, files[0].toString().contains("file1.txt"), "File: " + files[0]);
+        assertEquals(true, files[1].toString().contains("file2.txt"), "File: " + files[1]);
+    }
 
-        final String expected = "this is brand new data";
-        final String actual = FileUtils.readFileToString(file);
-        assertEquals(expected, actual);
+    @Test
+    public void testToFiles2() throws Exception {
+        final URL[] urls = new URL[]{
+                new URL("file", null, "file1.txt"),
+                null,
+        };
+        final File[] files = FileUtils.toFiles(urls);
+
+        assertEquals(urls.length, files.length);
+        assertEquals(true, files[0].toString().contains("file1.txt"), "File: " + files[0]);
+        assertEquals(null, files[1], "File: " + files[1]);
     }
 
     @Test
-    public void testWriteStringToFile_WithAppendOptionTrue_ShouldNotDeletePreviousFileLines() throws Exception {
-        final File file = TestUtils.newFile(temporaryFolder, "lines.txt");
-        FileUtils.writeStringToFile(file, "This line was there before you...");
-
-        FileUtils.writeStringToFile(file, "this is brand new data", true);
+    public void testToFiles3() throws Exception {
+        final URL[] urls = null;
+        final File[] files = FileUtils.toFiles(urls);
 
-        final String expected = "This line was there before you..."
-                + "this is brand new data";
-        final String actual = FileUtils.readFileToString(file);
-        assertEquals(expected, actual);
+        assertEquals(0, files.length);
     }
 
     @Test
-    public void testWriteStringToFile_WithAppendOptionFalse_ShouldDeletePreviousFileLines() throws Exception {
-        final File file = TestUtils.newFile(temporaryFolder, "lines.txt");
-        FileUtils.writeStringToFile(file, "This line was there before you...");
-
-        FileUtils.writeStringToFile(file, "this is brand new data", false);
+    public void testToFiles3a() throws Exception {
+        final URL[] urls = new URL[0]; // empty array
+        final File[] files = FileUtils.toFiles(urls);
 
-        final String expected = "this is brand new data";
-        final String actual = FileUtils.readFileToString(file);
-        assertEquals(expected, actual);
+        assertEquals(0, files.length);
     }
 
     @Test
-    public void testWriteWithEncoding_WithAppendOptionTrue_ShouldNotDeletePreviousFileLines() throws Exception {
-        final File file = TestUtils.newFile(temporaryFolder, "lines.txt");
-        FileUtils.writeStringToFile(file, "This line was there before you...");
+    public void testToFiles4() throws Exception {
+        final URL[] urls = new URL[]{
+                new URL("file", null, "file1.txt"),
+                new URL("http", "jakarta.apache.org", "file1.txt"),
+        };
+        try {
+            FileUtils.toFiles(urls);
+            fail();
+        } catch (final IllegalArgumentException ignore) {
+        }
+    }
 
-        FileUtils.write(file, "this is brand new data", (String) null, true);
+    @Test
+    public void testToFileUtf8() throws Exception {
+        final URL url = new URL("file", null, "/home/%C3%A4%C3%B6%C3%BC%C3%9F");
+        final File file = FileUtils.toFile(url);
+        assertTrue(file.toString().contains("\u00E4\u00F6\u00FC\u00DF"));
+    }
 
-        final String expected = "This line was there before you..."
-                + "this is brand new data";
-        final String actual = FileUtils.readFileToString(file);
-        assertEquals(expected, actual);
+    @Test
+    public void testTouch() throws IOException {
+        final File file = new File(temporaryFolder, "touch.txt");
+        if (file.exists()) {
+            file.delete();
+        }
+        assertTrue(!file.exists(), "Bad test: test file still exists");
+        FileUtils.touch(file);
+        assertTrue(file.exists(), "FileUtils.touch() created file");
+        final FileOutputStream out = new FileOutputStream(file);
+        assertEquals(0, file.length(), "Created empty file.");
+        out.write(0);
+        out.close();
+        assertEquals(1, file.length(), "Wrote one byte to file");
+        final long y2k = new GregorianCalendar(2000, 0, 1).getTime().getTime();
+        final boolean res = setLastModifiedMillis(file, y2k);  // 0L fails on Win98
+        assertEquals(true, res, "Bad test: set lastModified failed");
+        assertEquals(y2k, getLastModifiedMillis(file), "Bad test: set lastModified set incorrect value");
+        final long now = System.currentTimeMillis();
+        FileUtils.touch(file);
+        assertEquals(1, file.length(), "FileUtils.touch() didn't empty the file.");
+        assertEquals(false, y2k == getLastModifiedMillis(file), "FileUtils.touch() changed lastModified");
+        assertEquals(true, getLastModifiedMillis(file) >= now - 3000, "FileUtils.touch() changed lastModified to more than now-3s");
+        assertEquals(true, getLastModifiedMillis(file) <= now + 3000, "FileUtils.touch() changed lastModified to less than now+3s");
     }
 
     @Test
-    public void testWriteWithEncoding_WithAppendOptionFalse_ShouldDeletePreviousFileLines() throws Exception {
-        final File file = TestUtils.newFile(temporaryFolder, "lines.txt");
-        FileUtils.writeStringToFile(file, "This line was there before you...");
+    public void testToURLs1() throws Exception {
+        final File[] files = new File[]{
+                new File(temporaryFolder, "file1.txt"),
+                new File(temporaryFolder, "file2.txt"),
+                new File(temporaryFolder, "test file.txt"),
+        };
+        final URL[] urls = FileUtils.toURLs(files);
 
-        FileUtils.write(file, "this is brand new data", (String) null, false);
+        assertEquals(files.length, urls.length);
+        assertTrue(urls[0].toExternalForm().startsWith("file:"));
+        assertTrue(urls[0].toExternalForm().contains("file1.txt"));
+        assertTrue(urls[1].toExternalForm().startsWith("file:"));
+        assertTrue(urls[1].toExternalForm().contains("file2.txt"));
 
-        final String expected = "this is brand new data";
-        final String actual = FileUtils.readFileToString(file);
-        assertEquals(expected, actual);
+        // Test escaped char
+        assertTrue(urls[2].toExternalForm().startsWith("file:"));
+        assertTrue(urls[2].toExternalForm().contains("test%20file.txt"));
     }
 
     @Test
-    public void testWrite_WithAppendOptionTrue_ShouldNotDeletePreviousFileLines() throws Exception {
-        final File file = TestUtils.newFile(temporaryFolder, "lines.txt");
-        FileUtils.writeStringToFile(file, "This line was there before you...");
-
-        FileUtils.write(file, "this is brand new data", true);
+    public void testToURLs3a() throws Exception {
+        final File[] files = new File[0]; // empty array
+        final URL[] urls = FileUtils.toURLs(files);
 
-        final String expected = "This line was there before you..."
-                + "this is brand new data";
-        final String actual = FileUtils.readFileToString(file);
-        assertEquals(expected, actual);
+        assertEquals(0, urls.length);
     }
 
     @Test
@@ -2398,11 +2854,11 @@ public void testWrite_WithAppendOptionFalse_ShouldDeletePreviousFileLines() thro
     }
 
     @Test
-    public void testWriteByteArrayToFile_WithAppendOptionTrue_ShouldNotDeletePreviousFileLines() throws Exception {
+    public void testWrite_WithAppendOptionTrue_ShouldNotDeletePreviousFileLines() throws Exception {
         final File file = TestUtils.newFile(temporaryFolder, "lines.txt");
         FileUtils.writeStringToFile(file, "This line was there before you...");
 
-        FileUtils.writeByteArrayToFile(file, "this is brand new data".getBytes(), true);
+        FileUtils.write(file, "this is brand new data", true);
 
         final String expected = "This line was there before you..."
                 + "this is brand new data";
@@ -2410,6 +2866,14 @@ public void testWriteByteArrayToFile_WithAppendOptionTrue_ShouldNotDeletePreviou
         assertEquals(expected, actual);
     }
 
+    @Test
+    public void testWriteByteArrayToFile() throws Exception {
+        final File file = new File(temporaryFolder, "write.obj");
+        final byte[] data = new byte[]{11, 21, 31};
+        FileUtils.writeByteArrayToFile(file, data);
+        TestUtils.assertEqualContent(data, file);
+    }
+
     @Test
     public void testWriteByteArrayToFile_WithAppendOptionFalse_ShouldDeletePreviousFileLines() throws Exception {
         final File file = TestUtils.newFile(temporaryFolder, "lines.txt");
@@ -2423,763 +2887,346 @@ public void testWriteByteArrayToFile_WithAppendOptionFalse_ShouldDeletePreviousF
     }
 
     @Test
-    public void testWriteByteArrayToFile_WithOffsetAndLength_WithAppendOptionTrue_ShouldNotDeletePreviousFileLines() throws Exception {
-        final File file = TestUtils.newFile(temporaryFolder, "lines.txt");
-        FileUtils.writeStringToFile(file, "This line was there before you...");
-
-        final byte[] data = "SKIP_THIS_this is brand new data_AND_SKIP_THIS".getBytes(StandardCharsets.UTF_8);
-        FileUtils.writeByteArrayToFile(file, data, 10, 22, true);
-
-        final String expected = "This line was there before you..." + "this is brand new data";
-        final String actual = FileUtils.readFileToString(file, StandardCharsets.UTF_8);
-        assertEquals(expected, actual);
-    }
-
-    @Test
-    public void testWriteByteArrayToFile_WithOffsetAndLength_WithAppendOptionTrue_ShouldDeletePreviousFileLines() throws Exception {
+    public void testWriteByteArrayToFile_WithAppendOptionTrue_ShouldNotDeletePreviousFileLines() throws Exception {
         final File file = TestUtils.newFile(temporaryFolder, "lines.txt");
         FileUtils.writeStringToFile(file, "This line was there before you...");
 
-        final byte[] data = "SKIP_THIS_this is brand new data_AND_SKIP_THIS".getBytes(StandardCharsets.UTF_8);
-        FileUtils.writeByteArrayToFile(file, data, 10, 22, false);
+        FileUtils.writeByteArrayToFile(file, "this is brand new data".getBytes(), true);
 
-        final String expected = "this is brand new data";
-        final String actual = FileUtils.readFileToString(file, StandardCharsets.UTF_8);
+        final String expected = "This line was there before you..."
+                + "this is brand new data";
+        final String actual = FileUtils.readFileToString(file);
         assertEquals(expected, actual);
     }
 
-    //-----------------------------------------------------------------------
-    @Test
-    public void testChecksumCRC32() throws Exception {
-        // create a test file
-        final String text = "Imagination is more important than knowledge - Einstein";
-        final File file = new File(temporaryFolder, "checksum-test.txt");
-        FileUtils.writeStringToFile(file, text, "US-ASCII");
-
-        // compute the expected checksum
-        final Checksum expectedChecksum = new CRC32();
-        expectedChecksum.update(text.getBytes("US-ASCII"), 0, text.length());
-        final long expectedValue = expectedChecksum.getValue();
-
-        // compute the checksum of the file
-        final long resultValue = FileUtils.checksumCRC32(file);
-
-        assertEquals(expectedValue, resultValue);
-    }
-
-    @Test
-    public void testChecksum() throws Exception {
-        // create a test file
-        final String text = "Imagination is more important than knowledge - Einstein";
-        final File file = new File(temporaryFolder, "checksum-test.txt");
-        FileUtils.writeStringToFile(file, text, "US-ASCII");
-
-        // compute the expected checksum
-        final Checksum expectedChecksum = new CRC32();
-        expectedChecksum.update(text.getBytes("US-ASCII"), 0, text.length());
-        final long expectedValue = expectedChecksum.getValue();
-
-        // compute the checksum of the file
-        final Checksum testChecksum = new CRC32();
-        final Checksum resultChecksum = FileUtils.checksum(file, testChecksum);
-        final long resultValue = resultChecksum.getValue();
-
-        assertSame(testChecksum, resultChecksum);
-        assertEquals(expectedValue, resultValue);
-    }
-
-    @Test
-    public void testChecksumOnNullFile() throws Exception {
-        try {
-            FileUtils.checksum(null, new CRC32());
-            fail();
-        } catch (final NullPointerException ex) {
-            // expected
-        }
-    }
-
-    @Test
-    public void testChecksumOnNullChecksum() throws Exception {
-        // create a test file
-        final String text = "Imagination is more important than knowledge - Einstein";
-        final File file = new File(temporaryFolder, "checksum-test.txt");
-        FileUtils.writeStringToFile(file, text, "US-ASCII");
-        try {
-            FileUtils.checksum(file, null);
-            fail();
-        } catch (final NullPointerException ex) {
-            // expected
-        }
-    }
-
-    @Test
-    public void testChecksumOnDirectory() throws Exception {
-        try {
-            FileUtils.checksum(new File("."), new CRC32());
-            fail();
-        } catch (final IllegalArgumentException ex) {
-            // expected
-        }
-    }
-
-    @Test
-    public void testChecksumDouble() throws Exception {
-        // create a test file
-        final String text1 = "Imagination is more important than knowledge - Einstein";
-        final File file1 = new File(temporaryFolder, "checksum-test.txt");
-        FileUtils.writeStringToFile(file1, text1, "US-ASCII");
-
-        // create a second test file
-        final String text2 = "To be or not to be - Shakespeare";
-        final File file2 = new File(temporaryFolder, "checksum-test2.txt");
-        FileUtils.writeStringToFile(file2, text2, "US-ASCII");
-
-        // compute the expected checksum
-        final Checksum expectedChecksum = new CRC32();
-        expectedChecksum.update(text1.getBytes("US-ASCII"), 0, text1.length());
-        expectedChecksum.update(text2.getBytes("US-ASCII"), 0, text2.length());
-        final long expectedValue = expectedChecksum.getValue();
-
-        // compute the checksum of the file
-        final Checksum testChecksum = new CRC32();
-        FileUtils.checksum(file1, testChecksum);
-        FileUtils.checksum(file2, testChecksum);
-        final long resultValue = testChecksum.getValue();
-
-        assertEquals(expectedValue, resultValue);
-    }
-
     @Test
-    public void testDeleteDirectoryWithNonDirectory() throws Exception {
-        try {
-            FileUtils.deleteDirectory(testFile1);
-            fail();
-        } catch (final IllegalArgumentException ex) {
-            // expected
-        }
+    public void testWriteByteArrayToFile_WithOffsetAndLength() throws Exception {
+        final File file = new File(temporaryFolder, "write.obj");
+        final byte[] data = new byte[]{11, 21, 32, 41, 51};
+        final byte[] writtenData = new byte[3];
+        System.arraycopy(data, 1, writtenData, 0, 3);
+        FileUtils.writeByteArrayToFile(file, data, 1, 3);
+        TestUtils.assertEqualContent(writtenData, file);
     }
 
     @Test
-    public void testDeleteQuietlyForNull() {
-        try {
-            FileUtils.deleteQuietly(null);
-        } catch (final Exception ex) {
-            fail(ex.getMessage());
-        }
+    public void testWriteByteArrayToFile_WithOffsetAndLength_WithAppendOptionTrue_ShouldDeletePreviousFileLines() throws Exception {
+        final File file = TestUtils.newFile(temporaryFolder, "lines.txt");
+        FileUtils.writeStringToFile(file, "This line was there before you...");
+
+        final byte[] data = "SKIP_THIS_this is brand new data_AND_SKIP_THIS".getBytes(StandardCharsets.UTF_8);
+        FileUtils.writeByteArrayToFile(file, data, 10, 22, false);
+
+        final String expected = "this is brand new data";
+        final String actual = FileUtils.readFileToString(file, StandardCharsets.UTF_8);
+        assertEquals(expected, actual);
     }
 
     @Test
-    public void testDeleteQuietlyDir() throws IOException {
-        final File testDirectory = new File(temporaryFolder, "testDeleteQuietlyDir");
-        final File testFile = new File(testDirectory, "testDeleteQuietlyFile");
-        testDirectory.mkdirs();
-        if (!testFile.getParentFile().exists()) {
-            throw new IOException("Cannot create file " + testFile
-                    + " as the parent directory does not exist");
-        }
-        final BufferedOutputStream output =
-                new BufferedOutputStream(new FileOutputStream(testFile));
-        try {
-            TestUtils.generateTestData(output, 0);
-        } finally {
-            IOUtils.closeQuietly(output);
-        }
+    public void testWriteByteArrayToFile_WithOffsetAndLength_WithAppendOptionTrue_ShouldNotDeletePreviousFileLines() throws Exception {
+        final File file = TestUtils.newFile(temporaryFolder, "lines.txt");
+        FileUtils.writeStringToFile(file, "This line was there before you...");
 
-        assertTrue(testDirectory.exists());
-        assertTrue(testFile.exists());
-        FileUtils.deleteQuietly(testDirectory);
-        assertFalse(testDirectory.exists(), "Check No Exist");
-        assertFalse(testFile.exists(), "Check No Exist");
+        final byte[] data = "SKIP_THIS_this is brand new data_AND_SKIP_THIS".getBytes(StandardCharsets.UTF_8);
+        FileUtils.writeByteArrayToFile(file, data, 10, 22, true);
+
+        final String expected = "This line was there before you..." + "this is brand new data";
+        final String actual = FileUtils.readFileToString(file, StandardCharsets.UTF_8);
+        assertEquals(expected, actual);
     }
 
     @Test
-    public void testDeleteQuietlyFile() throws IOException {
-        final File testFile = new File(temporaryFolder, "testDeleteQuietlyFile");
-        if (!testFile.getParentFile().exists()) {
-            throw new IOException("Cannot create file " + testFile
-                    + " as the parent directory does not exist");
-        }
-        final BufferedOutputStream output =
-                new BufferedOutputStream(new FileOutputStream(testFile));
-        try {
-            TestUtils.generateTestData(output, 0);
-        } finally {
-            IOUtils.closeQuietly(output);
-        }
+    public void testWriteCharSequence1() throws Exception {
+        final File file = new File(temporaryFolder, "write.txt");
+        FileUtils.write(file, "Hello /u1234", "UTF8");
+        final byte[] text = "Hello /u1234".getBytes("UTF8");
+        TestUtils.assertEqualContent(text, file);
+    }
 
-        assertTrue(testFile.exists());
-        FileUtils.deleteQuietly(testFile);
-        assertFalse(testFile.exists(), "Check No Exist");
+    @Test
+    public void testWriteCharSequence2() throws Exception {
+        final File file = new File(temporaryFolder, "write.txt");
+        FileUtils.write(file, "Hello /u1234", (String) null);
+        final byte[] text = "Hello /u1234".getBytes();
+        TestUtils.assertEqualContent(text, file);
     }
 
     @Test
-    public void testDeleteQuietlyNonExistent() {
-        final File testFile = new File("testDeleteQuietlyNonExistent");
-        assertFalse(testFile.exists());
+    public void testWriteLines_3arg_nullSeparator() throws Exception {
+        final Object[] data = new Object[]{
+                "hello", new StringBuffer("world"), "", "this is", null, "some text"};
+        final List<Object> list = Arrays.asList(data);
 
-        try {
-            FileUtils.deleteQuietly(testFile);
-        } catch (final Exception ex) {
-            fail(ex.getMessage());
-        }
+        final File file = TestUtils.newFile(temporaryFolder, "lines.txt");
+        FileUtils.writeLines(file, "US-ASCII", list);
+
+        final String expected = "hello" + System.lineSeparator() + "world" + System.lineSeparator() +
+                System.lineSeparator() + "this is" + System.lineSeparator() +
+                System.lineSeparator() + "some text" + System.lineSeparator();
+        final String actual = FileUtils.readFileToString(file, "US-ASCII");
+        assertEquals(expected, actual);
     }
 
     @Test
-    public void testMoveFile_Rename() throws Exception {
-        final File destination = new File(temporaryFolder, "move1.txt");
+    public void testWriteLines_3argsWithAppendOptionFalse_ShouldDeletePreviousFileLines() throws Exception {
+        final File file = TestUtils.newFile(temporaryFolder, "lines.txt");
+        FileUtils.writeStringToFile(file, "This line was there before you...");
 
-        FileUtils.moveFile(testFile1, destination);
-        assertTrue(destination.exists(), "Check Exist");
-        assertTrue(!testFile1.exists(), "Original deleted");
+        final List<String> linesToAppend = Arrays.asList("my first line", "The second Line");
+        FileUtils.writeLines(file, linesToAppend, false);
+
+        final String expected = "my first line"
+                + System.lineSeparator() + "The second Line"
+                + System.lineSeparator();
+        final String actual = FileUtils.readFileToString(file);
+        assertEquals(expected, actual);
     }
 
     @Test
-    public void testMoveFile_CopyDelete() throws Exception {
-        final File destination = new File(temporaryFolder, "move2.txt");
-        final File src = new File(testFile1.getAbsolutePath()) {
-            private static final long serialVersionUID = 1L;
+    public void testWriteLines_3argsWithAppendOptionTrue_ShouldNotDeletePreviousFileLines() throws Exception {
+        final File file = TestUtils.newFile(temporaryFolder, "lines.txt");
+        FileUtils.writeStringToFile(file, "This line was there before you...");
 
-            // Force renameTo to fail, as if destination is on another
-            // filesystem
-            @Override
-            public boolean renameTo(final File f) {
-                return false;
-            }
-        };
-        FileUtils.moveFile(src, destination);
-        assertTrue(destination.exists(), "Check Exist");
-        assertTrue(!src.exists(), "Original deleted");
+        final List<String> linesToAppend = Arrays.asList("my first line", "The second Line");
+        FileUtils.writeLines(file, linesToAppend, true);
+
+        final String expected = "This line was there before you..."
+                + "my first line"
+                + System.lineSeparator() + "The second Line"
+                + System.lineSeparator();
+        final String actual = FileUtils.readFileToString(file);
+        assertEquals(expected, actual);
     }
 
     @Test
-    public void testMoveFile_CopyDelete_Failed() throws Exception {
-        final File destination = new File(temporaryFolder, "move3.txt");
-        final File src = new File(testFile1.getAbsolutePath()) {
-            private static final long serialVersionUID = 1L;
-
-            // Force renameTo to fail, as if destination is on another
-            // filesystem
-            @Override
-            public boolean renameTo(final File f) {
-                return false;
-            }
+    public void testWriteLines_4arg() throws Exception {
+        final Object[] data = new Object[]{
+                "hello", new StringBuffer("world"), "", "this is", null, "some text"};
+        final List<Object> list = Arrays.asList(data);
 
-            // Force delete failure
-            @Override
-            public boolean delete() {
-                return false;
-            }
+        final File file = TestUtils.newFile(temporaryFolder, "lines.txt");
+        FileUtils.writeLines(file, "US-ASCII", list, "*");
 
-        };
-        try {
-            FileUtils.moveFile(src, destination);
-            fail("move should have failed as src has not been deleted");
-        } catch (final IOException e) {
-            // exepected
-            assertTrue(!destination.exists(), "Check Rollback");
-            assertTrue(src.exists(), "Original exists");
-        }
+        final String expected = "hello*world**this is**some text*";
+        final String actual = FileUtils.readFileToString(file, "US-ASCII");
+        assertEquals(expected, actual);
     }
 
     @Test
-    public void testMoveFile_Errors() throws Exception {
-        try {
-            FileUtils.moveFile(null, new File("foo"));
-            fail("Expected NullPointerException when source is null");
-        } catch (final NullPointerException e) {
-            // expected
-        }
-        try {
-            FileUtils.moveFile(new File("foo"), null);
-            fail("Expected NullPointerException when destination is null");
-        } catch (final NullPointerException e) {
-            // expected
-        }
-        try {
-            FileUtils.moveFile(new File("nonexistant"), new File("foo"));
-            fail("Expected FileNotFoundException for source");
-        } catch (final FileNotFoundException e) {
-            // expected
-        }
-        try {
-            FileUtils.moveFile(temporaryFolder, new File("foo"));
-            fail("Expected IOException when source is a directory");
-        } catch (final IOException e) {
-            // expected
-        }
-        final File testSourceFile = new File(temporaryFolder, "testMoveFileSource");
-        final File testDestFile = new File(temporaryFolder, "testMoveFileSource");
-        if (!testSourceFile.getParentFile().exists()) {
-            throw new IOException("Cannot create file " + testSourceFile
-                    + " as the parent directory does not exist");
-        }
-        final BufferedOutputStream output1 =
-                new BufferedOutputStream(new FileOutputStream(testSourceFile));
-        try {
-            TestUtils.generateTestData(output1, 0);
-        } finally {
-            IOUtils.closeQuietly(output1);
-        }
-        if (!testDestFile.getParentFile().exists()) {
-            throw new IOException("Cannot create file " + testDestFile
-                    + " as the parent directory does not exist");
-        }
-        final BufferedOutputStream output =
-                new BufferedOutputStream(new FileOutputStream(testDestFile));
-        try {
-            TestUtils.generateTestData(output, 0);
-        } finally {
-            IOUtils.closeQuietly(output);
-        }
-        try {
-            FileUtils.moveFile(testSourceFile, testDestFile);
-            fail("Expected FileExistsException when dest already exists");
-        } catch (final FileExistsException e) {
-            // expected
-        }
+    public void testWriteLines_4arg_nullSeparator() throws Exception {
+        final Object[] data = new Object[]{
+                "hello", new StringBuffer("world"), "", "this is", null, "some text"};
+        final List<Object> list = Arrays.asList(data);
+
+        final File file = TestUtils.newFile(temporaryFolder, "lines.txt");
+        FileUtils.writeLines(file, "US-ASCII", list, null);
+
+        final String expected = "hello" + System.lineSeparator() + "world" + System.lineSeparator() +
+                System.lineSeparator() + "this is" + System.lineSeparator() +
+                System.lineSeparator() + "some text" + System.lineSeparator();
+        final String actual = FileUtils.readFileToString(file, "US-ASCII");
+        assertEquals(expected, actual);
     }
 
     @Test
-    public void testMoveFileToDirectory() throws Exception {
-        final File destDir = new File(temporaryFolder, "moveFileDestDir");
-        final File movedFile = new File(destDir, testFile1.getName());
-        assertFalse(destDir.exists(), "Check Exist before");
-        assertFalse(movedFile.exists(), "Check Exist before");
-
-        FileUtils.moveFileToDirectory(testFile1, destDir, true);
-        assertTrue(movedFile.exists(), "Check Exist after");
-        assertTrue(!testFile1.exists(), "Original deleted");
+    public void testWriteLines_4arg_Writer_nullData() throws Exception {
+        final File file = TestUtils.newFile(temporaryFolder, "lines.txt");
+        FileUtils.writeLines(file, "US-ASCII", null, "*");
+
+        assertEquals(0, file.length(), "Sizes differ");
     }
 
     @Test
-    public void testMoveFileToDirectory_Errors() throws Exception {
-        try {
-            FileUtils.moveFileToDirectory(null, new File("foo"), true);
-            fail("Expected NullPointerException when source is null");
-        } catch (final NullPointerException e) {
-            // expected
-        }
-        try {
-            FileUtils.moveFileToDirectory(new File("foo"), null, true);
-            fail("Expected NullPointerException when destination is null");
-        } catch (final NullPointerException e) {
-            // expected
-        }
-        final File testFile1 = new File(temporaryFolder, "testMoveFileFile1");
-        final File testFile2 = new File(temporaryFolder, "testMoveFileFile2");
-        if (!testFile1.getParentFile().exists()) {
-            throw new IOException("Cannot create file " + testFile1
-                    + " as the parent directory does not exist");
-        }
-        final BufferedOutputStream output1 =
-                new BufferedOutputStream(new FileOutputStream(testFile1));
-        try {
-            TestUtils.generateTestData(output1, 0);
-        } finally {
-            IOUtils.closeQuietly(output1);
-        }
-        if (!testFile2.getParentFile().exists()) {
-            throw new IOException("Cannot create file " + testFile2
-                    + " as the parent directory does not exist");
-        }
-        final BufferedOutputStream output =
-                new BufferedOutputStream(new FileOutputStream(testFile2));
-        try {
-            TestUtils.generateTestData(output, 0);
-        } finally {
-            IOUtils.closeQuietly(output);
-        }
-        try {
-            FileUtils.moveFileToDirectory(testFile1, testFile2, true);
-            fail("Expected IOException when dest not a directory");
-        } catch (final IOException e) {
-            // expected
-        }
+    public void testWriteLines_4argsWithAppendOptionFalse_ShouldDeletePreviousFileLines() throws Exception {
+        final File file = TestUtils.newFile(temporaryFolder, "lines.txt");
+        FileUtils.writeStringToFile(file, "This line was there before you...");
 
-        final File nonexistant = new File(temporaryFolder, "testMoveFileNonExistant");
-        try {
-            FileUtils.moveFileToDirectory(testFile1, nonexistant, false);
-            fail("Expected IOException when dest does not exist and create=false");
-        } catch (final IOException e) {
-            // expected
-        }
+        final List<String> linesToAppend = Arrays.asList("my first line", "The second Line");
+        FileUtils.writeLines(file, linesToAppend, null, false);
+
+        final String expected = "my first line"
+                + System.lineSeparator() + "The second Line"
+                + System.lineSeparator();
+        final String actual = FileUtils.readFileToString(file);
+        assertEquals(expected, actual);
     }
 
 
     @Test
-    public void testMoveDirectory_Rename() throws Exception {
-        final File dir = temporaryFolder;
-        final File src = new File(dir, "testMoveDirectory1Source");
-        final File testDir = new File(src, "foo");
-        final File testFile = new File(testDir, "bar");
-        testDir.mkdirs();
-        if (!testFile.getParentFile().exists()) {
-            throw new IOException("Cannot create file " + testFile
-                    + " as the parent directory does not exist");
-        }
-        final BufferedOutputStream output =
-                new BufferedOutputStream(new FileOutputStream(testFile));
-        try {
-            TestUtils.generateTestData(output, 0);
-        } finally {
-            IOUtils.closeQuietly(output);
-        }
-        final File destination = new File(dir, "testMoveDirectory1Dest");
-        FileUtils.deleteDirectory(destination);
+    public void testWriteLines_4argsWithAppendOptionTrue_ShouldNotDeletePreviousFileLines() throws Exception {
+        final File file = TestUtils.newFile(temporaryFolder, "lines.txt");
+        FileUtils.writeStringToFile(file, "This line was there before you...");
 
-        // Move the directory
-        FileUtils.moveDirectory(src, destination);
+        final List<String> linesToAppend = Arrays.asList("my first line", "The second Line");
+        FileUtils.writeLines(file, linesToAppend, null, true);
 
-        // Check results
-        assertTrue(destination.exists(), "Check Exist");
-        assertTrue(!src.exists(), "Original deleted");
-        final File movedDir = new File(destination, testDir.getName());
-        final File movedFile = new File(movedDir, testFile.getName());
-        assertTrue(movedDir.exists(), "Check dir moved");
-        assertTrue(movedFile.exists(), "Check file moved");
+        final String expected = "This line was there before you..."
+                + "my first line"
+                + System.lineSeparator() + "The second Line"
+                + System.lineSeparator();
+        final String actual = FileUtils.readFileToString(file);
+        assertEquals(expected, actual);
     }
 
     @Test
-    public void testMoveDirectory_CopyDelete() throws Exception {
+    public void testWriteLines_5argsWithAppendOptionFalse_ShouldDeletePreviousFileLines() throws Exception {
+        final File file = TestUtils.newFile(temporaryFolder, "lines.txt");
+        FileUtils.writeStringToFile(file, "This line was there before you...");
 
-        final File dir = temporaryFolder;
-        final File src = new File(dir, "testMoveDirectory2Source") {
-            private static final long serialVersionUID = 1L;
+        final List<String> linesToAppend = Arrays.asList("my first line", "The second Line");
+        FileUtils.writeLines(file, null, linesToAppend, null, false);
 
-            // Force renameTo to fail
-            @Override
-            public boolean renameTo(final File dest) {
-                return false;
-            }
-        };
-        final File testDir = new File(src, "foo");
-        final File testFile = new File(testDir, "bar");
-        testDir.mkdirs();
-        if (!testFile.getParentFile().exists()) {
-            throw new IOException("Cannot create file " + testFile
-                    + " as the parent directory does not exist");
-        }
-        final BufferedOutputStream output =
-                new BufferedOutputStream(new FileOutputStream(testFile));
-        try {
-            TestUtils.generateTestData(output, 0);
-        } finally {
-            IOUtils.closeQuietly(output);
-        }
-        final File destination = new File(dir, "testMoveDirectory1Dest");
-        FileUtils.deleteDirectory(destination);
+        final String expected = "my first line"
+                + System.lineSeparator() + "The second Line"
+                + System.lineSeparator();
+        final String actual = FileUtils.readFileToString(file);
+        assertEquals(expected, actual);
+    }
 
-        // Move the directory
-        FileUtils.moveDirectory(src, destination);
+    @Test
+    public void testWriteLines_5argsWithAppendOptionTrue_ShouldNotDeletePreviousFileLines() throws Exception {
+        final File file = TestUtils.newFile(temporaryFolder, "lines.txt");
+        FileUtils.writeStringToFile(file, "This line was there before you...");
 
-        // Check results
-        assertTrue(destination.exists(), "Check Exist");
-        assertTrue(!src.exists(), "Original deleted");
-        final File movedDir = new File(destination, testDir.getName());
-        final File movedFile = new File(movedDir, testFile.getName());
-        assertTrue(movedDir.exists(), "Check dir moved");
-        assertTrue(movedFile.exists(), "Check file moved");
+        final List<String> linesToAppend = Arrays.asList("my first line", "The second Line");
+        FileUtils.writeLines(file, null, linesToAppend, null, true);
+
+        final String expected = "This line was there before you..."
+                + "my first line"
+                + System.lineSeparator() + "The second Line"
+                + System.lineSeparator();
+        final String actual = FileUtils.readFileToString(file);
+        assertEquals(expected, actual);
     }
 
     @Test
-    public void testMoveDirectory_Errors() throws Exception {
-        try {
-            FileUtils.moveDirectory(null, new File("foo"));
-            fail("Expected NullPointerException when source is null");
-        } catch (final NullPointerException e) {
-            // expected
-        }
-        try {
-            FileUtils.moveDirectory(new File("foo"), null);
-            fail("Expected NullPointerException when destination is null");
-        } catch (final NullPointerException e) {
-            // expected
-        }
-        try {
-            FileUtils.moveDirectory(new File("nonexistant"), new File("foo"));
-            fail("Expected FileNotFoundException for source");
-        } catch (final FileNotFoundException e) {
-            // expected
-        }
-        final File testFile = new File(temporaryFolder, "testMoveDirectoryFile");
-        if (!testFile.getParentFile().exists()) {
-            throw new IOException("Cannot create file " + testFile
-                    + " as the parent directory does not exist");
-        }
-        final BufferedOutputStream output =
-                new BufferedOutputStream(new FileOutputStream(testFile));
-        try {
-            TestUtils.generateTestData(output, 0);
-        } finally {
-            IOUtils.closeQuietly(output);
-        }
-        try {
-            FileUtils.moveDirectory(testFile, new File("foo"));
-            fail("Expected IOException when source is not a directory");
-        } catch (final IOException e) {
-            // expected
-        }
-        final File testSrcFile = new File(temporaryFolder, "testMoveDirectorySource");
-        final File testDestFile = new File(temporaryFolder, "testMoveDirectoryDest");
-        testSrcFile.mkdir();
-        testDestFile.mkdir();
-        try {
-            FileUtils.moveDirectory(testSrcFile, testDestFile);
-            fail("Expected FileExistsException when dest already exists");
-        } catch (final FileExistsException e) {
-            // expected
-        }
+    public void testWriteLinesEncoding_WithAppendOptionFalse_ShouldDeletePreviousFileLines() throws Exception {
+        final File file = TestUtils.newFile(temporaryFolder, "lines.txt");
+        FileUtils.writeStringToFile(file, "This line was there before you...");
+
+        final List<String> linesToAppend = Arrays.asList("my first line", "The second Line");
+        FileUtils.writeLines(file, null, linesToAppend, false);
+
+        final String expected = "my first line"
+                + System.lineSeparator() + "The second Line"
+                + System.lineSeparator();
+        final String actual = FileUtils.readFileToString(file);
+        assertEquals(expected, actual);
     }
 
     @Test
-    public void testMoveDirectoryToDirectory() throws Exception {
-        final File dir = temporaryFolder;
-        final File src = new File(dir, "testMoveDirectory1Source");
-        final File testChildDir = new File(src, "foo");
-        final File testFile = new File(testChildDir, "bar");
-        testChildDir.mkdirs();
-        if (!testFile.getParentFile().exists()) {
-            throw new IOException("Cannot create file " + testFile
-                    + " as the parent directory does not exist");
-        }
-        final BufferedOutputStream output =
-                new BufferedOutputStream(new FileOutputStream(testFile));
-        try {
-            TestUtils.generateTestData(output, 0);
-        } finally {
-            IOUtils.closeQuietly(output);
-        }
-        final File destDir = new File(dir, "testMoveDirectory1Dest");
-        FileUtils.deleteDirectory(destDir);
-        assertFalse(destDir.exists(), "Check Exist before");
-
-        // Move the directory
-        FileUtils.moveDirectoryToDirectory(src, destDir, true);
+    public void testWriteLinesEncoding_WithAppendOptionTrue_ShouldNotDeletePreviousFileLines() throws Exception {
+        final File file = TestUtils.newFile(temporaryFolder, "lines.txt");
+        FileUtils.writeStringToFile(file, "This line was there before you...");
 
-        // Check results
-        assertTrue(destDir.exists(), "Check Exist after");
-        assertTrue(!src.exists(), "Original deleted");
-        final File movedDir = new File(destDir, src.getName());
-        final File movedChildDir = new File(movedDir, testChildDir.getName());
-        final File movedFile = new File(movedChildDir, testFile.getName());
-        assertTrue(movedDir.exists(), "Check dir moved");
-        assertTrue(movedChildDir.exists(), "Check child dir moved");
-        assertTrue(movedFile.exists(), "Check file moved");
+        final List<String> linesToAppend = Arrays.asList("my first line", "The second Line");
+        FileUtils.writeLines(file, null, linesToAppend, true);
+
+        final String expected = "This line was there before you..."
+                + "my first line"
+                + System.lineSeparator() + "The second Line"
+                + System.lineSeparator();
+        final String actual = FileUtils.readFileToString(file);
+        assertEquals(expected, actual);
     }
 
     @Test
-    public void testMoveDirectoryToDirectory_Errors() throws Exception {
-        try {
-            FileUtils.moveDirectoryToDirectory(null, new File("foo"), true);
-            fail("Expected NullPointerException when source is null");
-        } catch (final NullPointerException e) {
-            // expected
-        }
-        try {
-            FileUtils.moveDirectoryToDirectory(new File("foo"), null, true);
-            fail("Expected NullPointerException when destination is null");
-        } catch (final NullPointerException e) {
-            // expected
-        }
-        final File testFile1 = new File(temporaryFolder, "testMoveFileFile1");
-        final File testFile2 = new File(temporaryFolder, "testMoveFileFile2");
-        if (!testFile1.getParentFile().exists()) {
-            throw new IOException("Cannot create file " + testFile1
-                    + " as the parent directory does not exist");
-        }
-        final BufferedOutputStream output1 =
-                new BufferedOutputStream(new FileOutputStream(testFile1));
-        try {
-            TestUtils.generateTestData(output1, 0);
-        } finally {
-            IOUtils.closeQuietly(output1);
-        }
-        if (!testFile2.getParentFile().exists()) {
-            throw new IOException("Cannot create file " + testFile2
-                    + " as the parent directory does not exist");
-        }
-        final BufferedOutputStream output =
-                new BufferedOutputStream(new FileOutputStream(testFile2));
-        try {
-            TestUtils.generateTestData(output, 0);
-        } finally {
-            IOUtils.closeQuietly(output);
-        }
-        try {
-            FileUtils.moveDirectoryToDirectory(testFile1, testFile2, true);
-            fail("Expected IOException when dest not a directory");
-        } catch (final IOException e) {
-            // expected
-        }
+    public void testWriteStringToFile_WithAppendOptionFalse_ShouldDeletePreviousFileLines() throws Exception {
+        final File file = TestUtils.newFile(temporaryFolder, "lines.txt");
+        FileUtils.writeStringToFile(file, "This line was there before you...");
 
-        final File nonexistant = new File(temporaryFolder, "testMoveFileNonExistant");
-        try {
-            FileUtils.moveDirectoryToDirectory(testFile1, nonexistant, false);
-            fail("Expected IOException when dest does not exist and create=false");
-        } catch (final IOException e) {
-            // expected
-        }
+        FileUtils.writeStringToFile(file, "this is brand new data", false);
+
+        final String expected = "this is brand new data";
+        final String actual = FileUtils.readFileToString(file);
+        assertEquals(expected, actual);
     }
 
     @Test
-    public void testMoveToDirectory() throws Exception {
-        final File destDir = new File(temporaryFolder, "testMoveToDirectoryDestDir");
-        final File testDir = new File(temporaryFolder, "testMoveToDirectoryTestDir");
-        final File testFile = new File(temporaryFolder, "testMoveToDirectoryTestFile");
-        testDir.mkdirs();
-        if (!testFile.getParentFile().exists()) {
-            throw new IOException("Cannot create file " + testFile
-                    + " as the parent directory does not exist");
-        }
-        final BufferedOutputStream output =
-                new BufferedOutputStream(new FileOutputStream(testFile));
-        try {
-            TestUtils.generateTestData(output, 0);
-        } finally {
-            IOUtils.closeQuietly(output);
-        }
-        final File movedFile = new File(destDir, testFile.getName());
-        final File movedDir = new File(destDir, testFile.getName());
-
-        assertFalse(movedFile.exists(), "Check File Doesnt exist");
-        assertFalse(movedDir.exists(), "Check Dir Doesnt exist");
+    public void testWriteStringToFile_WithAppendOptionTrue_ShouldNotDeletePreviousFileLines() throws Exception {
+        final File file = TestUtils.newFile(temporaryFolder, "lines.txt");
+        FileUtils.writeStringToFile(file, "This line was there before you...");
 
-        // Test moving a file
-        FileUtils.moveToDirectory(testFile, destDir, true);
-        assertTrue(movedFile.exists(), "Check File exists");
-        assertFalse(testFile.exists(), "Check Original File doesn't exist");
+        FileUtils.writeStringToFile(file, "this is brand new data", true);
 
-        // Test moving a directory
-        FileUtils.moveToDirectory(testDir, destDir, true);
-        assertTrue(movedDir.exists(), "Check Dir exists");
-        assertFalse(testDir.exists(), "Check Original Dir doesn't exist");
+        final String expected = "This line was there before you..."
+                + "this is brand new data";
+        final String actual = FileUtils.readFileToString(file);
+        assertEquals(expected, actual);
     }
 
     @Test
-    public void testMoveToDirectory_Errors() throws Exception {
-        try {
-            FileUtils.moveDirectoryToDirectory(null, new File("foo"), true);
-            fail("Expected NullPointerException when source is null");
-        } catch (final NullPointerException e) {
-            // expected
-        }
-        try {
-            FileUtils.moveDirectoryToDirectory(new File("foo"), null, true);
-            fail("Expected NullPointerException when destination is null");
-        } catch (final NullPointerException e) {
-            // expected
-        }
-        final File nonexistant = new File(temporaryFolder, "nonexistant");
-        final File destDir = new File(temporaryFolder, "MoveToDirectoryDestDir");
-        try {
-            FileUtils.moveToDirectory(nonexistant, destDir, true);
-            fail("Expected IOException when source does not exist");
-        } catch (final IOException e) {
-            // expected
-        }
+    public void testWriteStringToFile1() throws Exception {
+        final File file = new File(temporaryFolder, "write.txt");
+        FileUtils.writeStringToFile(file, "Hello /u1234", "UTF8");
+        final byte[] text = "Hello /u1234".getBytes("UTF8");
+        TestUtils.assertEqualContent(text, file);
     }
 
     @Test
-    public void testIO300() throws Exception {
-        final File testDirectory = temporaryFolder;
-        final File src = new File(testDirectory, "dir1");
-        final File dest = new File(src, "dir2");
-        assertTrue(dest.mkdirs());
-        assertTrue(src.exists());
-        try {
-            FileUtils.moveDirectoryToDirectory(src, dest, false);
-            fail("expected IOException");
-        } catch (final IOException ioe) {
-            // expected
-        }
-        assertTrue(src.exists());
+    public void testWriteStringToFile2() throws Exception {
+        final File file = new File(temporaryFolder, "write.txt");
+        FileUtils.writeStringToFile(file, "Hello /u1234", (String) null);
+        final byte[] text = "Hello /u1234".getBytes();
+        TestUtils.assertEqualContent(text, file);
     }
 
     @Test
-    public void testIO276() throws Exception {
-        final File dir = new File("target", "IO276");
-        assertTrue(dir.mkdirs(), dir + " should not be present");
-        final File file = new File(dir, "IO276.txt");
-        assertTrue(file.createNewFile(), file + " should not be present");
-        FileUtils.forceDeleteOnExit(dir);
-        // If this does not work, test will fail next time (assuming target is not cleaned)
+    public void testWriteStringToFile3() throws Exception {
+        final File file = new File(temporaryFolder, "write.txt");
+        FileUtils.writeStringToFile(file, "Hello /u1234", (Charset) null);
+        final byte[] text = "Hello /u1234".getBytes();
+        TestUtils.assertEqualContent(text, file);
     }
 
-    // Test helper class to pretend a file is shorter than it is
-    private static class ShorterFile extends File {
-        private static final long serialVersionUID = 1L;
+    @Test
+    public void testWriteStringToFileWithEncoding_WithAppendOptionFalse_ShouldDeletePreviousFileLines() throws Exception {
+        final File file = TestUtils.newFile(temporaryFolder, "lines.txt");
+        FileUtils.writeStringToFile(file, "This line was there before you...");
 
-        public ShorterFile(final String pathname) {
-            super(pathname);
-        }
+        FileUtils.writeStringToFile(file, "this is brand new data", (String) null, false);
 
-        @Override
-        public long length() {
-            return super.length() - 1;
-        }
+        final String expected = "this is brand new data";
+        final String actual = FileUtils.readFileToString(file);
+        assertEquals(expected, actual);
     }
 
-    // This test relies on FileUtils.copyFile using File.length to check the output size
     @Test
-    public void testIncorrectOutputSize() throws Exception {
-        final File inFile = new File("pom.xml");
-        final File outFile = new ShorterFile("target/pom.tmp"); // it will report a shorter file
-        try {
-            FileUtils.copyFile(inFile, outFile);
-            fail("Expected IOException");
-        } catch (final Exception e) {
-            final String msg = e.toString();
-            assertTrue(msg.contains("Failed to copy full contents"), msg);
-        } finally {
-            outFile.delete(); // tidy up
-        }
-    }
+    public void testWriteStringToFileWithEncoding_WithAppendOptionTrue_ShouldNotDeletePreviousFileLines() throws Exception {
+        final File file = TestUtils.newFile(temporaryFolder, "lines.txt");
+        FileUtils.writeStringToFile(file, "This line was there before you...");
 
-    private void backDateFile10Minutes(final File testFile) throws IOException {
-        final long mins10 = 1000 * 60 * 10;
-        final long lastModified1 = getLastModifiedMillis(testFile);
-        assertTrue(setLastModifiedMillis(testFile, lastModified1 - mins10));
-        // ensure it was changed
-        assertNotEquals(getLastModifiedMillis(testFile), lastModified1, "Should have changed source date");
-    }
+        FileUtils.writeStringToFile(file, "this is brand new data", (String) null, true);
 
-    private boolean setLastModifiedMillis(final File testFile, final long millis) {
-        return testFile.setLastModified(millis);
-//        try {
-//            Files.setLastModifiedTime(testFile.toPath(), FileTime.fromMillis(millis));
-//        } catch (IOException e) {
-//            return false;
-//        }
-//        return true;
+        final String expected = "This line was there before you..."
+                + "this is brand new data";
+        final String actual = FileUtils.readFileToString(file);
+        assertEquals(expected, actual);
     }
 
-    /**
-     * DirectoryWalker implementation that recursively lists all files and directories.
-     */
-    static class ListDirectoryWalker extends DirectoryWalker<File> {
+    @Test
+    public void testWriteWithEncoding_WithAppendOptionFalse_ShouldDeletePreviousFileLines() throws Exception {
+        final File file = TestUtils.newFile(temporaryFolder, "lines.txt");
+        FileUtils.writeStringToFile(file, "This line was there before you...");
 
-        ListDirectoryWalker() {
-            super();
-        }
+        FileUtils.write(file, "this is brand new data", (String) null, false);
 
-        List<File> list(final File startDirectory) throws IOException {
-            final ArrayList<File> files = new ArrayList<>();
-            walk(startDirectory, files);
-            return files;
-        }
+        final String expected = "this is brand new data";
+        final String actual = FileUtils.readFileToString(file);
+        assertEquals(expected, actual);
+    }
 
-        @Override
-        protected void handleDirectoryStart(final File directory, final int depth, final Collection<File> results) throws IOException {
-            // Add all directories except the starting directory
-            if (depth > 0) {
-                results.add(directory);
-            }
-        }
+    @Test
+    public void testWriteWithEncoding_WithAppendOptionTrue_ShouldNotDeletePreviousFileLines() throws Exception {
+        final File file = TestUtils.newFile(temporaryFolder, "lines.txt");
+        FileUtils.writeStringToFile(file, "This line was there before you...");
 
-        @Override
-        protected void handleFile(final File file, final int depth, final Collection<File> results) throws IOException {
-            results.add(file);
-        }
+        FileUtils.write(file, "this is brand new data", (String) null, true);
+
+        final String expected = "This line was there before you..."
+                + "this is brand new data";
+        final String actual = FileUtils.readFileToString(file);
+        assertEquals(expected, actual);
     }
 
 }
diff --git a/src/test/java/org/apache/commons/io/file/DirectoryStreamFilterTest.java b/src/test/java/org/apache/commons/io/file/DirectoryStreamFilterTest.java
index 295273627..1146acca7 100644
--- a/src/test/java/org/apache/commons/io/file/DirectoryStreamFilterTest.java
+++ b/src/test/java/org/apache/commons/io/file/DirectoryStreamFilterTest.java
@@ -45,7 +45,7 @@ public void testFilterByName() throws Exception {
         final PathFilter pathFilter = new NameFileFilter(PATH_FIXTURE);
         final DirectoryStreamFilter streamFilter = new DirectoryStreamFilter(pathFilter);
         assertEquals(pathFilter, streamFilter.getPathFilter());
-        try (final DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get("."), streamFilter)) {
+        try (final DirectoryStream<Path> stream = Files.newDirectoryStream(PathUtils.current(), streamFilter)) {
             final Iterator<Path> iterator = stream.iterator();
             final Path path = iterator.next();
             assertEquals(PATH_FIXTURE, path.getFileName().toString());
@@ -58,7 +58,7 @@ public void testFilterByNameNot() throws Exception {
         final PathFilter pathFilter = new NameFileFilter(PATH_FIXTURE).negate();
         final DirectoryStreamFilter streamFilter = new DirectoryStreamFilter(pathFilter);
         assertEquals(pathFilter, streamFilter.getPathFilter());
-        try (final DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get("."), streamFilter)) {
+        try (final DirectoryStream<Path> stream = Files.newDirectoryStream(PathUtils.current(), streamFilter)) {
             for (final Path path : stream) {
                 assertNotEquals(PATH_FIXTURE, path.getFileName().toString());
             }
diff --git a/src/test/java/org/apache/commons/io/file/PathUtilsTest.java b/src/test/java/org/apache/commons/io/file/PathUtilsTest.java
index c76c5d221..4103aecfe 100644
--- a/src/test/java/org/apache/commons/io/file/PathUtilsTest.java
+++ b/src/test/java/org/apache/commons/io/file/PathUtilsTest.java
@@ -52,7 +52,7 @@ public void testCopyFile() throws IOException {
     @Test
     public void testNewDirectoryStream() throws Exception {
         final PathFilter pathFilter = new NameFileFilter(PATH_FIXTURE);
-        try (final DirectoryStream<Path> stream = PathUtils.newDirectoryStream(Paths.get("."), pathFilter)) {
+        try (final DirectoryStream<Path> stream = PathUtils.newDirectoryStream(PathUtils.current(), pathFilter)) {
             final Iterator<Path> iterator = stream.iterator();
             final Path path = iterator.next();
             assertEquals(PATH_FIXTURE, path.getFileName().toString());
diff --git a/src/test/java/org/apache/commons/io/filefilter/AgeFileFilterTest.java b/src/test/java/org/apache/commons/io/filefilter/AgeFileFilterTest.java
index 42c90a049..3f941fe97 100644
--- a/src/test/java/org/apache/commons/io/filefilter/AgeFileFilterTest.java
+++ b/src/test/java/org/apache/commons/io/filefilter/AgeFileFilterTest.java
@@ -62,10 +62,10 @@ public void testJavadocExampleUsingIo() {
      */
     @Test
     public void testJavadocExampleUsingNio() throws IOException {
-        final Path dir = Paths.get(".");
+        final Path dir = Paths.get("");
         // We are interested in files older than one day
         final long cutoff = System.currentTimeMillis();
-        final AccumulatorPathVisitor visitor = AccumulatorPathVisitor.withLongCounters(new AgeFileFilter(cutoff));
+        final AccumulatorPathVisitor visitor = AccumulatorPathVisitor.withLongCounters(new AgeFileFilter(cutoff), TrueFileFilter.INSTANCE);
         //
         // Walk one dir
         Files.walkFileTree(dir, Collections.emptySet(), 1, visitor);
@@ -95,10 +95,10 @@ public void testJavadocExampleUsingNio() throws IOException {
 
     @Test
     public void testNoCounting() throws IOException {
-        final Path dir = Paths.get(".");
+        final Path dir = Paths.get("");
         final long cutoff = System.currentTimeMillis();
         final AccumulatorPathVisitor visitor = new AccumulatorPathVisitor(Counters.noopPathCounters(),
-            new AgeFileFilter(cutoff));
+            new AgeFileFilter(cutoff), TrueFileFilter.INSTANCE);
         Files.walkFileTree(dir, Collections.emptySet(), 1, visitor);
         //
         CounterAssertions.assertZeroCounters(visitor.getPathCounters());
diff --git a/src/test/java/org/apache/commons/io/filefilter/DirectoryFileFilterTest.java b/src/test/java/org/apache/commons/io/filefilter/DirectoryFileFilterTest.java
index f7512378c..da0c5a894 100644
--- a/src/test/java/org/apache/commons/io/filefilter/DirectoryFileFilterTest.java
+++ b/src/test/java/org/apache/commons/io/filefilter/DirectoryFileFilterTest.java
@@ -61,8 +61,9 @@ public void testJavadocExampleUsingIo() {
      */
     @Test
     public void testJavadocExampleUsingNio() throws IOException {
-        final Path dir = Paths.get(".");
-        final AccumulatorPathVisitor visitor = AccumulatorPathVisitor.withLongCounters(DirectoryFileFilter.INSTANCE);
+        final Path dir = Paths.get("");
+        final AccumulatorPathVisitor visitor = AccumulatorPathVisitor.withLongCounters(DirectoryFileFilter.INSTANCE,
+            TrueFileFilter.INSTANCE);
         //
         // Walk one dir
         Files.walkFileTree(dir, Collections.emptySet(), 1, visitor);
diff --git a/src/test/java/org/apache/commons/io/filefilter/FileFilterTestCase.java b/src/test/java/org/apache/commons/io/filefilter/FileFilterTestCase.java
index 8cabc14a7..ca525b8fd 100644
--- a/src/test/java/org/apache/commons/io/filefilter/FileFilterTestCase.java
+++ b/src/test/java/org/apache/commons/io/filefilter/FileFilterTestCase.java
@@ -30,7 +30,6 @@
 import java.io.FileFilter;
 import java.io.FileOutputStream;
 import java.io.FilenameFilter;
-import java.io.IOException;
 import java.io.OutputStream;
 import java.nio.charset.StandardCharsets;
 import java.nio.file.FileVisitResult;
@@ -69,7 +68,7 @@ public class FileFilterTestCase {
     @TempDir
     public File temporaryFolder;
 
-    public void assertFiltering(final IOFileFilter filter, final File file, final boolean expected) throws Exception {
+    void assertFiltering(final IOFileFilter filter, final File file, final boolean expected) {
         // Note. This only tests the (File, String) version if the parent of
         // the File passed in is not null
         assertEquals(expected, filter.accept(file),
@@ -85,10 +84,10 @@ public void assertFiltering(final IOFileFilter filter, final File file, final bo
         assertNotNull(filter.toString());
     }
 
-    public void assertFiltering(final IOFileFilter filter, final Path path, final boolean expected) throws Exception {
+    void assertFiltering(final IOFileFilter filter, final Path path, final boolean expected) {
         // Note. This only tests the (Path, Path) version if the parent of
         // the File passed in is not null
-        final FileVisitResult expectedFileVisitResult = AbstractFileFilter.toFileVisitResult(expected);
+        final FileVisitResult expectedFileVisitResult = AbstractFileFilter.toFileVisitResult(expected, path);
         assertEquals(expectedFileVisitResult, filter.accept(path, null),
             "Filter(Path) " + filter.getClass().getName() + " not " + expectedFileVisitResult + " for " + path);
 
@@ -112,7 +111,7 @@ public void testAgeFilter() throws Exception {
         final Path newPath = newFile.toPath();
 
         if (!oldFile.getParentFile().exists()) {
-            throw new IOException("Cannot create file " + oldFile + " as the parent directory does not exist");
+            fail("Cannot create file " + oldFile + " as the parent directory does not exist");
         }
         try (final BufferedOutputStream output1 = new BufferedOutputStream(new FileOutputStream(oldFile))) {
             TestUtils.generateTestData(output1, 0);
@@ -125,7 +124,7 @@ public void testAgeFilter() throws Exception {
                 // ignore
             }
             if (!reference.getParentFile().exists()) {
-                throw new IOException("Cannot create file " + reference + " as the parent directory does not exist");
+                fail("Cannot create file " + reference + " as the parent directory does not exist");
             }
             try (final BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(reference))) {
                 TestUtils.generateTestData(output, 0);
@@ -142,7 +141,7 @@ public void testAgeFilter() throws Exception {
                 // ignore
             }
             if (!newFile.getParentFile().exists()) {
-                throw new IOException("Cannot create file " + newFile + " as the parent directory does not exist");
+                fail("Cannot create file " + newFile + " as the parent directory does not exist");
             }
             try (final BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(newFile))) {
                 TestUtils.generateTestData(output, 0);
@@ -199,7 +198,7 @@ public void testAgeFilter() throws Exception {
     }
 
     @Test
-    public void testAnd() throws Exception {
+    public void testAnd() {
         final IOFileFilter trueFilter = TrueFileFilter.INSTANCE;
         final IOFileFilter falseFilter = FalseFileFilter.INSTANCE;
         assertFiltering(trueFilter.and(trueFilter), new File("foo.test"), true);
@@ -211,7 +210,7 @@ public void testAnd() throws Exception {
     }
 
     @Test
-    public void testAnd2() throws Exception {
+    public void testAnd2() {
         final IOFileFilter trueFilter = TrueFileFilter.INSTANCE;
         final IOFileFilter falseFilter = FalseFileFilter.INSTANCE;
         assertFiltering(new AndFileFilter(trueFilter, trueFilter), new File("foo.test"), true);
@@ -226,14 +225,14 @@ public void testAnd2() throws Exception {
         assertThrows(IllegalArgumentException.class, () -> new AndFileFilter(falseFilter, (IOFileFilter) null));
         assertThrows(IllegalArgumentException.class, () -> new AndFileFilter(null, falseFilter));
 
-        final AndFileFilter f = new AndFileFilter((List) null);
+        final AndFileFilter f = new AndFileFilter((List<IOFileFilter>) null);
         assertTrue(f.getFileFilters().isEmpty());
 
         assertNotNull(f.toString()); // TODO better tests
     }
 
     @Test
-    public void testAndArray() throws Exception {
+    public void testAndArray() {
         final IOFileFilter trueFilter = TrueFileFilter.INSTANCE;
         final IOFileFilter falseFilter = FalseFileFilter.INSTANCE;
         assertFiltering(new AndFileFilter(trueFilter, trueFilter, trueFilter), new File("foo.test"), true);
@@ -271,7 +270,7 @@ public void testCanRead() throws Exception {
         final File readOnlyFile = new File(temporaryFolder, "read-only-file1.txt");
         final Path readOnlyPath = readOnlyFile.toPath();
         if (!readOnlyFile.getParentFile().exists()) {
-            throw new IOException("Cannot create file " + readOnlyFile + " as the parent directory does not exist");
+            fail("Cannot create file " + readOnlyFile + " as the parent directory does not exist");
         }
         try (final BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(readOnlyFile))) {
             TestUtils.generateTestData(output, 32);
@@ -291,7 +290,7 @@ public void testCanWrite() throws Exception {
         final File readOnlyFile = new File(temporaryFolder, "read-only-file2.txt");
         final Path readOnlyPath = readOnlyFile.toPath();
         if (!readOnlyFile.getParentFile().exists()) {
-            throw new IOException("Cannot create file " + readOnlyFile + " as the parent directory does not exist");
+            fail("Cannot create file " + readOnlyFile + " as the parent directory does not exist");
         }
         try (final BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(readOnlyFile))) {
             TestUtils.generateTestData(output, 32);
@@ -307,7 +306,7 @@ public void testCanWrite() throws Exception {
     }
 
     @Test
-    public void testDelegateFileFilter() throws Exception {
+    public void testDelegateFileFilter() {
         final OrFileFilter orFilter = new OrFileFilter();
         final File testFile = new File("test.txt");
 
@@ -341,7 +340,7 @@ public void testDelegation() { // TODO improve these tests
 
     @SuppressWarnings("deprecation")
     @Test
-    public void testDeprecatedWildcard() throws Exception {
+    public void testDeprecatedWildcard() {
         IOFileFilter filter = new WildcardFilter("*.txt");
         final List<String> patternList = Arrays.asList("*.txt", "*.xml", "*.gif");
         final IOFileFilter listFilter = new WildcardFilter(patternList);
@@ -432,7 +431,7 @@ public void testDeprecatedWildcard() throws Exception {
     }
 
     @Test
-    public void testDirectory() throws Exception {
+    public void testDirectory() {
         // XXX: This test presumes the current working dir is the base dir of the source checkout.
         final IOFileFilter filter = new DirectoryFileFilter();
 
@@ -471,7 +470,7 @@ public void testEmpty() throws Exception {
         final File emptyFile = new File(emptyDirFile, "empty-file.txt");
         final Path emptyPath = emptyFile.toPath();
         if (!emptyFile.getParentFile().exists()) {
-            throw new IOException("Cannot create file " + emptyFile + " as the parent directory does not exist");
+            fail("Cannot create file " + emptyFile + " as the parent directory does not exist");
         }
         try (final BufferedOutputStream output1 = new BufferedOutputStream(new FileOutputStream(emptyFile))) {
             TestUtils.generateTestData(output1, 0);
@@ -491,7 +490,7 @@ public void testEmpty() throws Exception {
         final File notEmptyFile = new File(emptyDirFile, "not-empty-file.txt");
         final Path notEmptyPath = notEmptyFile.toPath();
         if (!notEmptyFile.getParentFile().exists()) {
-            throw new IOException("Cannot create file " + notEmptyFile + " as the parent directory does not exist");
+            fail("Cannot create file " + notEmptyFile + " as the parent directory does not exist");
         }
         try (final BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(notEmptyFile))) {
             TestUtils.generateTestData(output, 32);
@@ -509,7 +508,7 @@ public void testEnsureTestCoverage() {
     }
 
     @Test
-    public void testFalse() throws Exception {
+    public void testFalse() {
         final IOFileFilter filter = FileFilterUtils.falseFileFilter();
         assertFiltering(filter, new File("foo.test"), false);
         assertFiltering(filter, new File("foo.test").toPath(), false);
@@ -523,7 +522,7 @@ public void testFalse() throws Exception {
     }
 
     @Test
-    public void testFileFilterUtils_and() throws Exception {
+    public void testFileFilterUtils_and() {
         final IOFileFilter trueFilter = TrueFileFilter.INSTANCE;
         final IOFileFilter falseFilter = FalseFileFilter.INSTANCE;
         assertFiltering(FileFilterUtils.and(trueFilter, trueFilter, trueFilter), new File("foo.test"), true);
@@ -533,7 +532,7 @@ public void testFileFilterUtils_and() throws Exception {
     }
 
     @Test
-    public void testFileFilterUtils_or() throws Exception {
+    public void testFileFilterUtils_or() {
         final IOFileFilter trueFilter = TrueFileFilter.INSTANCE;
         final IOFileFilter falseFilter = FalseFileFilter.INSTANCE;
         final File testFile = new File("foo.test");
@@ -544,9 +543,9 @@ public void testFileFilterUtils_or() throws Exception {
     }
 
     @Test
-    public void testFiles() throws Exception {
+    public void testFiles() {
         // XXX: This test presumes the current working dir is the base dir of the source checkout.
-        final IOFileFilter filter = FileFileFilter.FILE;
+        final IOFileFilter filter = FileFileFilter.INSTANCE;
 
         assertFiltering(filter, new File("src/"), false);
         assertFiltering(filter, new File("src/").toPath(), false);
@@ -796,7 +795,7 @@ public void testFilterSetNullParameters() {
     }
 
     @Test
-    public void testHidden() throws Exception {
+    public void testHidden() {
         final File hiddenDirFile = new File(SVN_DIR_NAME);
         final Path hiddenDirPath = hiddenDirFile.toPath();
         if (hiddenDirFile.exists()) {
@@ -874,7 +873,7 @@ public void testMagicNumberFileFilterBytesOffset() throws Exception {
         }
 
         if (!randomFileB.getParentFile().exists()) {
-            throw new IOException("Cannot create file " + randomFileB + " as the parent directory does not exist");
+            fail("Cannot create file " + randomFileB + " as the parent directory does not exist");
         }
         try (final BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(randomFileB))) {
             TestUtils.generateTestData(output, 2 * tarMagicNumberOffset);
@@ -940,7 +939,7 @@ public void testMagicNumberFileFilterStringOffset() throws Exception {
         }
 
         if (!randomFileB.getParentFile().exists()) {
-            throw new IOException("Cannot create file " + randomFileB + " as the parent directory does not exist");
+            fail("Cannot create file " + randomFileB + " as the parent directory does not exist");
         }
         try (final BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(randomFileB))) {
             TestUtils.generateTestData(output, 2 * tarMagicNumberOffset);
@@ -1014,7 +1013,7 @@ public void testMakeCVSAware() throws Exception {
 
         file = new File(temporaryFolder, "test-file1.txt");
         if (!file.getParentFile().exists()) {
-            throw new IOException("Cannot create file " + file + " as the parent directory does not exist");
+            fail("Cannot create file " + file + " as the parent directory does not exist");
         }
         try (final BufferedOutputStream output2 = new BufferedOutputStream(new FileOutputStream(file))) {
             TestUtils.generateTestData(output2, 0);
@@ -1024,7 +1023,7 @@ public void testMakeCVSAware() throws Exception {
 
         file = new File(temporaryFolder, "test-file2.log");
         if (!file.getParentFile().exists()) {
-            throw new IOException("Cannot create file " + file + " as the parent directory does not exist");
+            fail("Cannot create file " + file + " as the parent directory does not exist");
         }
         try (final BufferedOutputStream output1 = new BufferedOutputStream(new FileOutputStream(file))) {
             TestUtils.generateTestData(output1, 0);
@@ -1034,7 +1033,7 @@ public void testMakeCVSAware() throws Exception {
 
         file = new File(temporaryFolder, "CVS");
         if (!file.getParentFile().exists()) {
-            throw new IOException("Cannot create file " + file + " as the parent directory does not exist");
+            fail("Cannot create file " + file + " as the parent directory does not exist");
         }
         try (final BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(file))) {
             TestUtils.generateTestData(output, 0);
@@ -1063,13 +1062,13 @@ public void testMakeDirectoryOnly() throws Exception {
         FileUtils.deleteDirectory(fileB);
 
         if (!fileA.getParentFile().exists()) {
-            throw new IOException("Cannot create file " + fileA + " as the parent directory does not exist");
+            fail("Cannot create file " + fileA + " as the parent directory does not exist");
         }
         try (final BufferedOutputStream output1 = new BufferedOutputStream(new FileOutputStream(fileA))) {
             TestUtils.generateTestData(output1, 32);
         }
         if (!fileB.getParentFile().exists()) {
-            throw new IOException("Cannot create file " + fileB + " as the parent directory does not exist");
+            fail("Cannot create file " + fileB + " as the parent directory does not exist");
         }
         try (final BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(fileB))) {
             TestUtils.generateTestData(output, 32);
@@ -1085,7 +1084,7 @@ public void testMakeDirectoryOnly() throws Exception {
     // -----------------------------------------------------------------------
     @Test
     public void testMakeFileOnly() throws Exception {
-        assertSame(FileFileFilter.FILE, FileFilterUtils.makeFileOnly(null));
+        assertSame(FileFileFilter.INSTANCE, FileFilterUtils.makeFileOnly(null));
 
         final IOFileFilter filter = FileFilterUtils.makeFileOnly(FileFilterUtils.nameFileFilter("B"));
 
@@ -1102,13 +1101,13 @@ public void testMakeFileOnly() throws Exception {
         FileUtils.deleteDirectory(fileB);
 
         if (!fileA.getParentFile().exists()) {
-            throw new IOException("Cannot create file " + fileA + " as the parent directory does not exist");
+            fail("Cannot create file " + fileA + " as the parent directory does not exist");
         }
         try (final BufferedOutputStream output1 = new BufferedOutputStream(new FileOutputStream(fileA))) {
             TestUtils.generateTestData(output1, 32);
         }
         if (!fileB.getParentFile().exists()) {
-            throw new IOException("Cannot create file " + fileB + " as the parent directory does not exist");
+            fail("Cannot create file " + fileB + " as the parent directory does not exist");
         }
         try (final BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(fileB))) {
             TestUtils.generateTestData(output, 32);
@@ -1134,7 +1133,7 @@ public void testMakeSVNAware() throws Exception {
 
         file = new File(temporaryFolder, "test-file1.txt");
         if (!file.getParentFile().exists()) {
-            throw new IOException("Cannot create file " + file + " as the parent directory does not exist");
+            fail("Cannot create file " + file + " as the parent directory does not exist");
         }
         try (final BufferedOutputStream output2 = new BufferedOutputStream(new FileOutputStream(file))) {
             TestUtils.generateTestData(output2, 0);
@@ -1144,7 +1143,7 @@ public void testMakeSVNAware() throws Exception {
 
         file = new File(temporaryFolder, "test-file2.log");
         if (!file.getParentFile().exists()) {
-            throw new IOException("Cannot create file " + file + " as the parent directory does not exist");
+            fail("Cannot create file " + file + " as the parent directory does not exist");
         }
         try (final BufferedOutputStream output1 = new BufferedOutputStream(new FileOutputStream(file))) {
             TestUtils.generateTestData(output1, 0);
@@ -1154,7 +1153,7 @@ public void testMakeSVNAware() throws Exception {
 
         file = new File(temporaryFolder, SVN_DIR_NAME);
         if (!file.getParentFile().exists()) {
-            throw new IOException("Cannot create file " + file + " as the parent directory does not exist");
+            fail("Cannot create file " + file + " as the parent directory does not exist");
         }
         try (final BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(file))) {
             TestUtils.generateTestData(output, 0);
@@ -1164,8 +1163,23 @@ public void testMakeSVNAware() throws Exception {
     }
 
     @Test
-    public void testNameFilter() throws Exception {
-        IOFileFilter filter = new NameFileFilter(new String[] {"foo", "bar"});
+    public void testNameFilter() {
+        assertFooBarFileFiltering(new NameFileFilter(new String[] {"foo", "bar"}));
+    }
+
+    @Test
+    public void testFileEqualsFilter() {
+        assertFooBarFileFiltering(
+            new FileEqualsFileFilter(new File("foo")).or(new FileEqualsFileFilter(new File("bar"))));
+    }
+
+    @Test
+    public void testPathEqualsFilter() {
+        assertFooBarFileFiltering(
+            new PathEqualsFileFilter(Paths.get("foo")).or(new PathEqualsFileFilter(Paths.get("bar"))));
+    }
+
+    private void assertFooBarFileFiltering(IOFileFilter filter) {
         assertFiltering(filter, new File("foo"), true);
         assertFiltering(filter, new File("foo"), true);
         assertFiltering(filter, new File("bar"), true);
@@ -1254,7 +1268,7 @@ public void testNameFilter() throws Exception {
     }
 
     @Test
-    public void testNameFilterNullArgument() throws Exception {
+    public void testNameFilterNullArgument() {
         final String test = null;
         try {
             new NameFileFilter(test);
@@ -1281,7 +1295,7 @@ public void testNameFilterNullListArgument() {
     }
 
     @Test
-    public void testNegate() throws Exception {
+    public void testNegate() {
         final IOFileFilter filter = FileFilterUtils.notFileFilter(FileFilterUtils.trueFileFilter());
         assertFiltering(filter, new File("foo.test"), false);
         assertFiltering(filter, new File("foo"), false);
@@ -1307,7 +1321,7 @@ public void testNullFilters() {
     }
 
     @Test
-    public void testOr() throws Exception {
+    public void testOr() {
         final IOFileFilter trueFilter = TrueFileFilter.INSTANCE;
         final IOFileFilter falseFilter = FalseFileFilter.INSTANCE;
         final File testFile = new File("foo.test");
@@ -1361,7 +1375,7 @@ public void testOr() throws Exception {
     }
 
     @Test
-    public void testPrefix() throws Exception {
+    public void testPrefix() {
         IOFileFilter filter = new PrefixFileFilter(new String[] {"foo", "bar"});
         final File testFile = new File("test");
         final Path testPath = testFile.toPath();
@@ -1433,7 +1447,7 @@ public void testPrefix() throws Exception {
     }
 
     @Test
-    public void testPrefixCaseInsensitive() throws Exception {
+    public void testPrefixCaseInsensitive() {
 
         IOFileFilter filter = new PrefixFileFilter(new String[] {"foo", "bar"}, IOCase.INSENSITIVE);
         assertFiltering(filter, new File("foo.test1"), true);
@@ -1490,14 +1504,14 @@ public void testPrefixCaseInsensitive() throws Exception {
     public void testSizeFilterOnFiles() throws Exception {
         final File smallFile = new File(temporaryFolder, "small.txt");
         if (!smallFile.getParentFile().exists()) {
-            throw new IOException("Cannot create file " + smallFile + " as the parent directory does not exist");
+            fail("Cannot create file " + smallFile + " as the parent directory does not exist");
         }
         try (final BufferedOutputStream output1 = new BufferedOutputStream(new FileOutputStream(smallFile))) {
             TestUtils.generateTestData(output1, 32);
         }
         final File largeFile = new File(temporaryFolder, "large.txt");
         if (!largeFile.getParentFile().exists()) {
-            throw new IOException("Cannot create file " + largeFile + " as the parent directory does not exist");
+            fail("Cannot create file " + largeFile + " as the parent directory does not exist");
         }
         try (final BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(largeFile))) {
             TestUtils.generateTestData(output, 128);
@@ -1542,14 +1556,14 @@ public void testSizeFilterOnFiles() throws Exception {
     public void testSizeFilterOnPaths() throws Exception {
         final Path smallFile = Paths.get(temporaryFolder.toString(), "small.txt");
         if (!Files.exists(smallFile.getParent())) {
-            throw new IOException("Cannot create file " + smallFile + " as the parent directory does not exist");
+            fail("Cannot create file " + smallFile + " as the parent directory does not exist");
         }
         try (OutputStream output = Files.newOutputStream(smallFile)) {
             TestUtils.generateTestData(output, 32);
         }
         final Path largeFile = Paths.get(temporaryFolder.toString(), "large.txt");
         if (!Files.exists(largeFile.getParent())) {
-            throw new IOException("Cannot create file " + largeFile + " as the parent directory does not exist");
+            fail("Cannot create file " + largeFile + " as the parent directory does not exist");
         }
         try (OutputStream output = Files.newOutputStream(largeFile)) {
             TestUtils.generateTestData(output, 128);
@@ -1591,7 +1605,7 @@ public void testSizeFilterOnPaths() throws Exception {
     }
 
     @Test
-    public void testSuffix() throws Exception {
+    public void testSuffix() {
         IOFileFilter filter = new SuffixFileFilter(new String[] {"tes", "est"});
         final File testFile = new File("test");
         final Path testPath = testFile.toPath();
@@ -1659,7 +1673,7 @@ public void testSuffix() throws Exception {
     }
 
     @Test
-    public void testSuffixCaseInsensitive() throws Exception {
+    public void testSuffixCaseInsensitive() {
 
         IOFileFilter filter = new SuffixFileFilter(new String[] {"tes", "est"}, IOCase.INSENSITIVE);
         assertFiltering(filter, new File("foo.tes"), true);
@@ -1711,7 +1725,7 @@ public void testSuffixCaseInsensitive() throws Exception {
     }
 
     @Test
-    public void testTrue() throws Exception {
+    public void testTrue() {
         final IOFileFilter filter = FileFilterUtils.trueFileFilter();
         assertFiltering(filter, new File("foo.test"), true);
         assertFiltering(filter, new File("foo"), true);
@@ -1727,7 +1741,7 @@ public void testTrue() throws Exception {
     }
 
     @Test
-    public void testWildcard() throws Exception {
+    public void testWildcard() {
         IOFileFilter filter = new WildcardFileFilter("*.txt");
         assertFiltering(filter, new File("log.txt"), true);
         assertFiltering(filter, new File("log.TXT"), false);
diff --git a/src/test/java/org/apache/commons/io/filefilter/NameFileFilterTest.java b/src/test/java/org/apache/commons/io/filefilter/NameFileFilterTest.java
index 81402b04f..11c6119c6 100644
--- a/src/test/java/org/apache/commons/io/filefilter/NameFileFilterTest.java
+++ b/src/test/java/org/apache/commons/io/filefilter/NameFileFilterTest.java
@@ -61,10 +61,10 @@ public void testJavadocExampleUsingIo() {
      */
     @Test
     public void testJavadocExampleUsingNio() throws IOException {
-        final Path dir = Paths.get(".");
+        final Path dir = Paths.get("");
         // We are interested in files older than one day
-        final AccumulatorPathVisitor visitor = AccumulatorPathVisitor
-            .withLongCounters(new NameFileFilter("NOTICE.txt"));
+        final AccumulatorPathVisitor visitor = AccumulatorPathVisitor.withLongCounters(new NameFileFilter("NOTICE.txt"),
+            TrueFileFilter.INSTANCE);
         //
         // Walk one dir
         Files.walkFileTree(dir, Collections.emptySet(), 1, visitor);
@@ -101,9 +101,9 @@ public void testJavadocExampleUsingNio() throws IOException {
 
     @Test
     public void testNoCounting() throws IOException {
-        final Path dir = Paths.get(".");
+        final Path dir = Paths.get("");
         final AccumulatorPathVisitor visitor = new AccumulatorPathVisitor(Counters.noopPathCounters(),
-            new NameFileFilter("NOTICE.txt"));
+            new NameFileFilter("NOTICE.txt"), TrueFileFilter.INSTANCE);
         Files.walkFileTree(dir, Collections.emptySet(), 1, visitor);
         //
         CounterAssertions.assertZeroCounters(visitor.getPathCounters());
diff --git a/src/test/java/org/apache/commons/io/filefilter/RegexFileFilterTestCase.java b/src/test/java/org/apache/commons/io/filefilter/RegexFileFilterTestCase.java
index 6c2822b03..b508c7aec 100644
--- a/src/test/java/org/apache/commons/io/filefilter/RegexFileFilterTestCase.java
+++ b/src/test/java/org/apache/commons/io/filefilter/RegexFileFilterTestCase.java
@@ -50,7 +50,7 @@ public void assertFiltering(final IOFileFilter filter, final File file, final bo
     public void assertFiltering(final IOFileFilter filter, final Path path, final boolean expected) throws Exception {
         // Note. This only tests the (Path, Path) version if the parent of
         // the Path passed in is not null
-        final FileVisitResult expectedFileVisitResult = AbstractFileFilter.toFileVisitResult(expected);
+        final FileVisitResult expectedFileVisitResult = AbstractFileFilter.toFileVisitResult(expected, path);
         assertEquals(expectedFileVisitResult, filter.accept(path, null),
             "Filter(Path) " + filter.getClass().getName() + " not " + expectedFileVisitResult + " for " + path);
 
diff --git a/src/test/java/org/apache/commons/io/test/TestUtils.java b/src/test/java/org/apache/commons/io/test/TestUtils.java
index 01f3ff665..ad9ef1d28 100644
--- a/src/test/java/org/apache/commons/io/test/TestUtils.java
+++ b/src/test/java/org/apache/commons/io/test/TestUtils.java
@@ -23,6 +23,7 @@
 import java.io.BufferedOutputStream;
 import java.io.File;
 import java.io.FileInputStream;
+import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.FileReader;
 import java.io.IOException;
@@ -169,6 +170,12 @@ public static void deleteFile(final File file) {
         }
     }
 
+    public static void generateTestData(final File file, final long size) throws IOException, FileNotFoundException {
+        try (final BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(file))) {
+            generateTestData(output, size);
+        }
+    }
+
     public static byte[] generateTestData(final long size) {
         try {
             try (final ByteArrayOutputStream baout = new ByteArrayOutputStream()) {
@@ -176,15 +183,14 @@ public static byte[] generateTestData(final long size) {
                 return baout.toByteArray();
             }
         } catch (final IOException ioe) {
-            throw new RuntimeException("This should never happen: " + ioe.getMessage());
+            throw new IllegalStateException("This should never happen: " + ioe.getMessage(), ioe);
         }
     }
 
     public static void generateTestData(final OutputStream out, final long size)
             throws IOException {
         for (int i = 0; i < size; i++) {
-            //output.write((byte)'X');
-
+            // output.write((byte)'X');
             // nice varied byte pattern compatible with Readers and Writers
             out.write((byte) ((i % 127) + 1));
         }
