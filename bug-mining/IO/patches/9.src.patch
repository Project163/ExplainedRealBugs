diff --git a/RELEASE-NOTES.txt b/RELEASE-NOTES.txt
index 158c433b8..f3d908e46 100644
--- a/RELEASE-NOTES.txt
+++ b/RELEASE-NOTES.txt
@@ -60,8 +60,12 @@ Bug fixes from 1.2
   - This now handles the situation where an error occurs when deleting the file
 
 - IOUtils.copy [IO-84]
-  - Comment about result byte/char count being limited to an int, thus
-    being inacurate for large streams
+  - The copy(InputStream, OutputStream) method now throws an exception if
+    the count is greater than an int
+  - The copy(Reader, Writer) method now throws an exception if
+    the count is greater than an int
+  - Added a new copyLarge(InputStream, OutputStream) method that returns a long
+  - Added a new copyLarge(Reader, Writer) method that returns a long
 
 - CountingInputStream/CountingOutputStream [IO-84]
   - methods were declared as int thus the count was innacurate for large streams
diff --git a/src/java/org/apache/commons/io/IOUtils.java b/src/java/org/apache/commons/io/IOUtils.java
index bb544c245..4d85b7afa 100644
--- a/src/java/org/apache/commons/io/IOUtils.java
+++ b/src/java/org/apache/commons/io/IOUtils.java
@@ -982,20 +982,46 @@ public static void writeLines(Collection lines, String lineEnding,
      * This method buffers the input internally, so there is no need to use a
      * <code>BufferedInputStream</code>.
      * <p>
-     * Large streams (over 2GB) will return an inaccurate result count as the
-     * type is an int. The copy will complete correctly however.
+     * Large streams (over 2GB) will throw an {@link ArithmeticException}
+     * after the copy has completed since the correct number of bytes
+     * cannot be returned as an int. For large streams use the
+     * <code>copyLarge(InputStream, OutputStream)</code> method.
      * 
      * @param input  the <code>InputStream</code> to read from
      * @param output  the <code>OutputStream</code> to write to
      * @return the number of bytes copied
      * @throws NullPointerException if the input or output is null
      * @throws IOException if an I/O error occurs
+     * @throws ArithmeticException if the byte count is too large
      * @since Commons IO 1.1
      */
     public static int copy(InputStream input, OutputStream output)
             throws IOException {
+        long count = copyLarge(input, output);
+        if (count > Integer.MAX_VALUE) {
+            throw new ArithmeticException("The byte count " + count + " is too large to be converted to an int");
+        }
+        return (int)count;
+    }
+
+    /**
+     * Copy bytes from a large (over 2GB) <code>InputStream</code> to an
+     * <code>OutputStream</code>.
+     * <p>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedInputStream</code>.
+     * 
+     * @param input  the <code>InputStream</code> to read from
+     * @param output  the <code>OutputStream</code> to write to
+     * @return the number of bytes copied
+     * @throws NullPointerException if the input or output is null
+     * @throws IOException if an I/O error occurs
+     * @since Commons IO 1.3
+     */
+    public static long copyLarge(InputStream input, OutputStream output)
+            throws IOException {
         byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];
-        int count = 0;
+        long count = 0;
         int n = 0;
         while (-1 != (n = input.read(buffer))) {
             output.write(buffer, 0, n);
@@ -1062,19 +1088,43 @@ public static void copy(InputStream input, Writer output, String encoding)
      * This method buffers the input internally, so there is no need to use a
      * <code>BufferedReader</code>.
      * <p>
-     * Large streams (over 2GB) will return an inaccurate result count as the
-     * type is an int. The copy will complete correctly however.
+     * Large streams (over 2GB) will throw an {@link ArithmeticException}
+     * after the copy has completed since the correct number of characters
+     * cannot be returned as an int. For large streams use the
+     * <code>copyLarge(Reader, Writer)</code> method.
      *
      * @param input  the <code>Reader</code> to read from
      * @param output  the <code>Writer</code> to write to
      * @return the number of characters copied
      * @throws NullPointerException if the input or output is null
      * @throws IOException if an I/O error occurs
+     * @throws ArithmeticException if the character count is too large
      * @since Commons IO 1.1
      */
     public static int copy(Reader input, Writer output) throws IOException {
+        long count = copyLarge(input, output);
+        if (count > Integer.MAX_VALUE) {
+            throw new ArithmeticException("The character count " + count + " is too large to be converted to an int");
+        }
+        return (int)count;
+    }
+
+    /**
+     * Copy chars from a large (over 2GB) <code>Reader</code> to a <code>Writer</code>.
+     * <p>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedReader</code>.
+     *
+     * @param input  the <code>Reader</code> to read from
+     * @param output  the <code>Writer</code> to write to
+     * @return the number of characters copied
+     * @throws NullPointerException if the input or output is null
+     * @throws IOException if an I/O error occurs
+     * @since Commons IO 1.3
+     */
+    public static long copyLarge(Reader input, Writer output) throws IOException {
         char[] buffer = new char[DEFAULT_BUFFER_SIZE];
-        int count = 0;
+        long count = 0;
         int n = 0;
         while (-1 != (n = input.read(buffer))) {
             output.write(buffer, 0, n);
