diff --git a/pom.xml b/pom.xml
index 787d44d35..13acd746c 100644
--- a/pom.xml
+++ b/pom.xml
@@ -242,6 +242,9 @@ file comparators, endian transformation classes, and much more.
     <contributor>
       <name>Arturo Bernal</name>
     </contributor>
+    <contributor>
+      <name>Miguel Mu√±oz</name>
+    </contributor>
   </contributors>
 
   <dependencies>
diff --git a/src/main/java/org/apache/commons/io/input/CharSequenceInputStream.java b/src/main/java/org/apache/commons/io/input/CharSequenceInputStream.java
index 303e03578..9860ada2b 100644
--- a/src/main/java/org/apache/commons/io/input/CharSequenceInputStream.java
+++ b/src/main/java/org/apache/commons/io/input/CharSequenceInputStream.java
@@ -37,7 +37,8 @@
 import org.apache.commons.io.function.Uncheck;
 
 /**
- * Implements an {@link InputStream} to read from String, StringBuffer, StringBuilder or CharBuffer.
+ * Implements an {@link InputStream} to read bytes from String, StringBuffer, StringBuilder or CharBuffer,
+ * encoded using the specified Charset. The Charset defaults to Charset.defaultCharset().
  * <p>
  * <strong>Note:</strong> Supports {@link #mark(int)} and {@link #reset()}.
  * </p>
@@ -353,6 +354,7 @@ public synchronized void reset() throws IOException {
             this.cBufMark = NO_MARK;
             this.bBufMark = NO_MARK;
         }
+        mark(0);
     }
 
     @Override
diff --git a/src/test/java/org/apache/commons/io/input/CharSequenceInputStreamTest.java b/src/test/java/org/apache/commons/io/input/CharSequenceInputStreamTest.java
index 6f6f1c361..24bdce350 100644
--- a/src/test/java/org/apache/commons/io/input/CharSequenceInputStreamTest.java
+++ b/src/test/java/org/apache/commons/io/input/CharSequenceInputStreamTest.java
@@ -26,13 +26,16 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.StringReader;
+import java.nio.ByteBuffer;
+import java.nio.CharBuffer;
 import java.nio.charset.Charset;
+import java.nio.charset.CharsetEncoder;
+import java.nio.charset.CoderResult;
 import java.nio.charset.StandardCharsets;
 import java.util.Random;
 
 import org.apache.commons.io.CharsetsTest;
 import org.apache.commons.io.IOUtils;
-import org.junit.jupiter.api.Disabled;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.params.ParameterizedTest;
 import org.junit.jupiter.params.provider.MethodSource;
@@ -297,7 +300,49 @@ public void testLargeSingleByteRead_UTF8() throws IOException {
         testSingleByteRead(LARGE_TEST_STRING, UTF_8);
     }
 
-    // This test is broken for charsets that don't create a single byte for each char
+    private void testMarkResetMultiByteChars(final String csName) throws IOException {
+        // This test quietly skips Charsets that can't handle multibyte characters like ASCII.
+        final String sequenceEnglish = "Test Sequence";
+        final String sequenceCJK = "\u4e01\u4f23\u5045\u5167\u5289\u53ab"; // Kanji text
+        final String[] sequences = {sequenceEnglish, sequenceCJK};
+        for (String testSequence : sequences) {
+            final CharsetEncoder charsetEncoder = Charset.forName(csName).newEncoder();
+            final ByteBuffer byteBuffer = ByteBuffer.allocate(testSequence.length() * 3);
+            final CharBuffer charBuffer = CharBuffer.wrap(testSequence);
+            final CoderResult result = charsetEncoder.encode(charBuffer, byteBuffer, true);
+            if (result.isUnmappable()) {
+                continue; // Skip character sets that can't handle multibyte characters.
+            }
+            final byte[] expectedBytes = byteBuffer.array();
+
+            final int bLength = byteBuffer.position();
+            final int skip = bLength - 4;
+            try (InputStream r = new CharSequenceInputStream(testSequence, csName)) {
+                assertEquals(skip, r.skip(skip));
+                r.mark(0);
+                assertEquals(expectedBytes[bLength - 4], (byte) r.read(), csName);
+                assertEquals(expectedBytes[bLength - 3], (byte) r.read(), csName);
+                assertEquals(expectedBytes[bLength - 2], (byte) r.read(), csName);
+                assertEquals(expectedBytes[bLength - 1], (byte) r.read(), csName);
+                assertEquals(-1, (byte) r.read(), csName);
+                r.reset();
+                assertEquals(expectedBytes[bLength - 4], (byte) r.read(), csName);
+                assertEquals(expectedBytes[bLength - 3], (byte) r.read(), csName);
+                assertEquals(expectedBytes[bLength - 2], (byte) r.read(), csName);
+                assertEquals(expectedBytes[bLength - 1], (byte) r.read(), csName);
+                assertEquals(-1, (byte) r.read(), csName);
+                r.reset();
+                assertEquals(expectedBytes[bLength - 4], (byte) r.read(), csName);
+                assertEquals(expectedBytes[bLength - 3], (byte) r.read(), csName);
+                assertEquals(expectedBytes[bLength - 2], (byte) r.read(), csName);
+                assertEquals(expectedBytes[bLength - 1], (byte) r.read(), csName);
+                assertEquals(-1, (byte) r.read(), csName);
+            }
+        }
+    }
+
+    // This test doesn't work for charsets that don't create a single byte for each char.
+    // Use testMarkResetMultiByteChars() instead for those cases.
     private void testMarkReset(final String csName) throws Exception {
         try (InputStream r = new CharSequenceInputStream("test", csName)) {
             assertEquals(2, r.skip(2));
@@ -316,9 +361,8 @@ private void testMarkReset(final String csName) throws Exception {
 
     @ParameterizedTest
     @MethodSource(CharsetsTest.REQUIRED_CHARSETS)
-    @Disabled // Test broken for charsets that create multiple bytes for a single char
     public void testMarkReset_RequiredCharsets(final String csName) throws Exception {
-        testMarkReset(csName);
+        testMarkResetMultiByteChars(csName);
     }
 
     @Test
@@ -407,7 +451,6 @@ private void testResetBeforeEnd(final CharSequenceInputStream inputStream) throw
     }
 
     @Test
-    @Disabled("[IO-795] CharSequenceInputStream.reset() only works once")
     public void testResetBeforeEndSetCharSequence() throws IOException {
         try (final CharSequenceInputStream inputStream = CharSequenceInputStream.builder().setCharSequence("1234").get()) {
             testResetBeforeEnd(inputStream);
