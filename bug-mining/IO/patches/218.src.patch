diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index 8c1fa19a5..a024d10e1 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -86,6 +86,9 @@ The <action> type attribute can be add,update,fix,remove.
       <action issue="IO-554" dev="ggregory" type="fix" due-to="Michele Mariotti">
         FileUtils.copyToFile(InputStream source, File destination) should not close input stream.
       </action>
+      <action issue="IO-594" dev="ggregory" type="add" due-to="Gary Gregory">
+        Add IOUtils copy methods with java.lang.Appendable as the target.
+      </action>
     </release>
 
     <release version="2.6" date="2017-10-15" description="Java 7 required, Java 9 supported.">
diff --git a/src/main/java/org/apache/commons/io/IOUtils.java b/src/main/java/org/apache/commons/io/IOUtils.java
index fd1c2b972..f53aa4b8c 100644
--- a/src/main/java/org/apache/commons/io/IOUtils.java
+++ b/src/main/java/org/apache/commons/io/IOUtils.java
@@ -40,6 +40,7 @@
 import java.net.URL;
 import java.net.URLConnection;
 import java.nio.ByteBuffer;
+import java.nio.CharBuffer;
 import java.nio.channels.ReadableByteChannel;
 import java.nio.channels.Selector;
 import java.nio.charset.Charset;
@@ -972,6 +973,28 @@ public static void copy(final Reader input, final OutputStream output, final Str
         copy(input, output, Charsets.toCharset(outputEncoding));
     }
 
+    /**
+     * Copies chars from a <code>Reader</code> to a <code>Appendable</code>.
+     * <p>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedReader</code>.
+     * <p>
+     * Large streams (over 2GB) will return a chars copied value of
+     * <code>-1</code> after the copy has completed since the correct
+     * number of chars cannot be returned as an int. For large streams
+     * use the <code>copyLarge(Reader, Writer)</code> method.
+     *
+     * @param input the <code>Reader</code> to read from
+     * @param output the <code>Appendable</code> to write to
+     * @return the number of characters copied, or -1 if &gt; Integer.MAX_VALUE
+     * @throws NullPointerException if the input or output is null
+     * @throws IOException          if an I/O error occurs
+     * @since 2.7
+     */
+    public static long copy(final Reader input, final Appendable output) throws IOException {
+        return copy(input, output, CharBuffer.allocate(DEFAULT_BUFFER_SIZE));
+    }
+
     /**
      * Copies chars from a <code>Reader</code> to a <code>Writer</code>.
      * <p>
@@ -1128,6 +1151,51 @@ public static long copyLarge(final InputStream input, final OutputStream output,
         return totalRead;
     }
 
+    /**
+     * Copies chars from a large (over 2GB) <code>Reader</code> to an <code>Appendable</code>.
+     * <p>
+     * This method buffers the input internally, so there is no need to use a
+     * <code>BufferedReader</code>.
+     * </p>
+     * The buffer size is given by {@link #DEFAULT_BUFFER_SIZE}.
+     *
+     * @param input the <code>Reader</code> to read from
+     * @param output the <code>Appendable</code> to append to
+     * @return the number of characters copied
+     * @throws NullPointerException if the input or output is null
+     * @throws IOException          if an I/O error occurs
+     * @since 2.7
+     */
+    public static long copyLarge(final Reader input, final Appendable output) throws IOException {
+        return copy(input, output, CharBuffer.allocate(DEFAULT_BUFFER_SIZE));
+    }
+
+    /**
+     * Copies chars from a <code>Reader</code> to an <code>Appendable</code>.
+     * <p>
+     * This method uses the provided buffer, so there is no need to use a
+     * <code>BufferedReader</code>.
+     * </p>
+     *
+     * @param input the <code>Reader</code> to read from
+     * @param output the <code>Appendable</code> to write to
+     * @param buffer the buffer to be used for the copy
+     * @return the number of characters copied
+     * @throws NullPointerException if the input or output is null
+     * @throws IOException          if an I/O error occurs
+     * @since 2.7
+     */
+    public static long copy(final Reader input, final Appendable output, final CharBuffer buffer) throws IOException {
+        long count = 0;
+        int n;
+        while (EOF != (n = input.read(buffer))) {
+            buffer.flip();
+            output.append(buffer, 0, n);
+            count += n;
+        }
+        return count;
+    }
+
     /**
      * Copies chars from a large (over 2GB) <code>Reader</code> to a <code>Writer</code>.
      * <p>
@@ -1147,6 +1215,9 @@ public static long copyLarge(final Reader input, final Writer output) throws IOE
         return copyLarge(input, output, new char[DEFAULT_BUFFER_SIZE]);
     }
 
+    // read toString
+    //-----------------------------------------------------------------------
+
     /**
      * Copies chars from a large (over 2GB) <code>Reader</code> to a <code>Writer</code>.
      * <p>
@@ -1196,9 +1267,6 @@ public static long copyLarge(final Reader input, final Writer output, final long
         return copyLarge(input, output, inputOffset, length, new char[DEFAULT_BUFFER_SIZE]);
     }
 
-    // read toString
-    //-----------------------------------------------------------------------
-
     /**
      * Copies some or all chars from a large (over 2GB) <code>InputStream</code> to an
      * <code>OutputStream</code>, optionally skipping input chars.
diff --git a/src/test/java/org/apache/commons/io/IOUtilsCopyTestCase.java b/src/test/java/org/apache/commons/io/IOUtilsCopyTestCase.java
index 1569c30cb..eefaac9b7 100644
--- a/src/test/java/org/apache/commons/io/IOUtilsCopyTestCase.java
+++ b/src/test/java/org/apache/commons/io/IOUtilsCopyTestCase.java
@@ -75,6 +75,37 @@ public void testCopy_inputStreamToOutputStream() throws Exception {
         assertEquals(inData.length,count);
     }
 
+    /*
+     * Test Copying file > 2GB  - see issue# IO-84
+     */
+    @Test
+    public void testCopy_inputStreamToOutputStream_IO84() throws Exception {
+        final long size = (long)Integer.MAX_VALUE + (long)1;
+        final InputStream  in  = new NullInputStream(size);
+        final OutputStream out = new NullOutputStream();
+
+        // Test copy() method
+        assertEquals(-1, IOUtils.copy(in, out));
+
+        // reset the input
+        in.close();
+
+        // Test copyLarge() method
+        assertEquals("copyLarge()", size, IOUtils.copyLarge(in, out));
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void testCopy_inputStreamToOutputStream_nullIn() throws Exception {
+        final OutputStream out = new ByteArrayOutputStream();
+        IOUtils.copy((InputStream) null, out);
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void testCopy_inputStreamToOutputStream_nullOut() throws Exception {
+        final InputStream in = new ByteArrayInputStream(inData);
+        IOUtils.copy(in, (OutputStream) null);
+    }
+
     @Test
     public void testCopy_inputStreamToOutputStreamWithBufferSize() throws Exception {
         testCopy_inputStreamToOutputStreamWithBufferSize(1);
@@ -110,37 +141,6 @@ private void testCopy_inputStreamToOutputStreamWithBufferSize(final int bufferSi
         assertEquals(inData.length,count);
     }
 
-    @Test(expected = NullPointerException.class)
-    public void testCopy_inputStreamToOutputStream_nullIn() throws Exception {
-        final OutputStream out = new ByteArrayOutputStream();
-        IOUtils.copy((InputStream) null, out);
-    }
-
-    @Test(expected = NullPointerException.class)
-    public void testCopy_inputStreamToOutputStream_nullOut() throws Exception {
-        final InputStream in = new ByteArrayInputStream(inData);
-        IOUtils.copy(in, (OutputStream) null);
-    }
-
-    /*
-     * Test Copying file > 2GB  - see issue# IO-84
-     */
-    @Test
-    public void testCopy_inputStreamToOutputStream_IO84() throws Exception {
-        final long size = (long)Integer.MAX_VALUE + (long)1;
-        final InputStream  in  = new NullInputStream(size);
-        final OutputStream out = new NullOutputStream();
-
-        // Test copy() method
-        assertEquals(-1, IOUtils.copy(in, out));
-
-        // reset the input
-        in.close();
-
-        // Test copyLarge() method
-        assertEquals("copyLarge()", size, IOUtils.copyLarge(in, out));
-    }
-
     //-----------------------------------------------------------------------
     @SuppressWarnings({ "resource", "deprecation" }) // 'in' is deliberately not closed
     @Test
@@ -161,22 +161,6 @@ public void testCopy_inputStreamToWriter() throws Exception {
         assertTrue("Content differs", Arrays.equals(inData, baout.toByteArray()));
     }
 
-    @SuppressWarnings("deprecation") // deliberately testing deprecated method
-    @Test(expected = NullPointerException.class)
-    public void testCopy_inputStreamToWriter_nullIn() throws Exception {
-        final ByteArrayOutputStream baout = new ByteArrayOutputStream();
-        final OutputStream out = new YellOnFlushAndCloseOutputStream(baout, true, true);
-        final Writer writer = new OutputStreamWriter(out, "US-ASCII");
-        IOUtils.copy((InputStream) null, writer);
-    }
-
-    @SuppressWarnings("deprecation") // deliberately testing deprecated method
-    @Test(expected = NullPointerException.class)
-    public void testCopy_inputStreamToWriter_nullOut() throws Exception {
-        final InputStream in = new ByteArrayInputStream(inData);
-        IOUtils.copy(in, (Writer) null); // deliberately testing deprecated method
-    }
-
     //-----------------------------------------------------------------------
     @SuppressWarnings("resource") // 'in' is deliberately not closed
     @Test
@@ -198,6 +182,25 @@ public void testCopy_inputStreamToWriter_Encoding() throws Exception {
         assertTrue("Content differs", Arrays.equals(inData, bytes));
     }
 
+    @SuppressWarnings("resource") // 'in' is deliberately not closed
+    @Test
+    public void testCopy_inputStreamToWriter_Encoding_nullEncoding() throws Exception {
+        InputStream in = new ByteArrayInputStream(inData);
+        in = new YellOnCloseInputStream(in);
+
+        final ByteArrayOutputStream baout = new ByteArrayOutputStream();
+        final YellOnFlushAndCloseOutputStream out = new YellOnFlushAndCloseOutputStream(baout, true, true);
+        final Writer writer = new OutputStreamWriter(baout, "US-ASCII");
+
+        IOUtils.copy(in, writer, (String) null);
+        out.off();
+        writer.flush();
+
+        assertEquals("Not all bytes were read", 0, in.available());
+        assertEquals("Sizes differ", inData.length, baout.size());
+        assertTrue("Content differs", Arrays.equals(inData, baout.toByteArray()));
+    }
+
     @Test(expected = NullPointerException.class)
     public void testCopy_inputStreamToWriter_Encoding_nullIn() throws Exception {
         final ByteArrayOutputStream baout = new ByteArrayOutputStream();
@@ -212,25 +215,75 @@ public void testCopy_inputStreamToWriter_Encoding_nullOut() throws Exception {
         IOUtils.copy(in, null, "UTF8");
     }
 
+    @SuppressWarnings("deprecation") // deliberately testing deprecated method
+    @Test(expected = NullPointerException.class)
+    public void testCopy_inputStreamToWriter_nullIn() throws Exception {
+        final ByteArrayOutputStream baout = new ByteArrayOutputStream();
+        final OutputStream out = new YellOnFlushAndCloseOutputStream(baout, true, true);
+        final Writer writer = new OutputStreamWriter(out, "US-ASCII");
+        IOUtils.copy((InputStream) null, writer);
+    }
+
+    @SuppressWarnings("deprecation") // deliberately testing deprecated method
+    @Test(expected = NullPointerException.class)
+    public void testCopy_inputStreamToWriter_nullOut() throws Exception {
+        final InputStream in = new ByteArrayInputStream(inData);
+        IOUtils.copy(in, (Writer) null); // deliberately testing deprecated method
+    }
+
     @SuppressWarnings("resource") // 'in' is deliberately not closed
     @Test
-    public void testCopy_inputStreamToWriter_Encoding_nullEncoding() throws Exception {
+    public void testCopy_readerToAppendable() throws Exception {
         InputStream in = new ByteArrayInputStream(inData);
         in = new YellOnCloseInputStream(in);
+        final Reader reader = new InputStreamReader(in, "US-ASCII");
 
         final ByteArrayOutputStream baout = new ByteArrayOutputStream();
         final YellOnFlushAndCloseOutputStream out = new YellOnFlushAndCloseOutputStream(baout, true, true);
         final Writer writer = new OutputStreamWriter(baout, "US-ASCII");
 
-        IOUtils.copy(in, writer, (String) null);
+        final long count = IOUtils.copy(reader, (Appendable) writer);
         out.off();
         writer.flush();
-
-        assertEquals("Not all bytes were read", 0, in.available());
+        assertEquals("The number of characters returned by copy is wrong", inData.length, count);
         assertEquals("Sizes differ", inData.length, baout.size());
         assertTrue("Content differs", Arrays.equals(inData, baout.toByteArray()));
     }
 
+    @Test
+    public void testCopy_readerToAppendable_IO84() throws Exception {
+        final long size = (long) Integer.MAX_VALUE + (long) 1;
+        final Reader reader = new NullReader(size);
+        final Appendable writer = new NullWriter();
+
+        // Test copy() method
+        assertEquals(size, IOUtils.copy(reader, writer));
+
+        // reset the input
+        reader.close();
+
+        // Test copyLarge() method
+        assertEquals("copy()", size, IOUtils.copyLarge(reader, writer));
+
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void testCopy_readerToAppendable_nullIn() throws Exception {
+        final ByteArrayOutputStream baout = new ByteArrayOutputStream();
+        final OutputStream out = new YellOnFlushAndCloseOutputStream(baout, true, true);
+        final Appendable writer = new OutputStreamWriter(out, "US-ASCII");
+        IOUtils.copy((Reader) null, writer);
+    }
+
+    @SuppressWarnings("resource") // 'in' is deliberately not closed
+    @Test(expected = NullPointerException.class)
+    public void testCopy_readerToAppendable_nullOut() throws Exception {
+        InputStream in = new ByteArrayInputStream(inData);
+        in = new YellOnCloseInputStream(in);
+        final Reader reader = new InputStreamReader(in, "US-ASCII");
+        IOUtils.copy(reader, (Appendable) null);
+    }
+
     //-----------------------------------------------------------------------
     @SuppressWarnings({ "resource", "deprecation" }) // 'in' is deliberately not closed
     @Test
@@ -254,23 +307,6 @@ public void testCopy_readerToOutputStream() throws Exception {
         assertTrue("Content differs", Arrays.equals(inData, baout.toByteArray()));
     }
 
-    @SuppressWarnings("deprecation")
-    @Test(expected = NullPointerException.class)
-    public void testCopy_readerToOutputStream_nullIn() throws Exception { // deliberately testing deprecated method
-        final ByteArrayOutputStream baout = new ByteArrayOutputStream();
-        final OutputStream out = new YellOnFlushAndCloseOutputStream(baout, true, true);
-        IOUtils.copy((Reader) null, out);
-    }
-
-    @SuppressWarnings({ "resource", "deprecation" }) // 'in' is deliberately not closed
-    @Test(expected = NullPointerException.class)
-    public void testCopy_readerToOutputStream_nullOut() throws Exception {
-        InputStream in = new ByteArrayInputStream(inData);
-        in = new YellOnCloseInputStream(in);
-        final Reader reader = new InputStreamReader(in, "US-ASCII");
-        IOUtils.copy(reader, (OutputStream) null); // deliberately testing deprecated method
-    }
-
     //-----------------------------------------------------------------------
     @SuppressWarnings("resource") // 'in' is deliberately not closed
     @Test
@@ -291,6 +327,24 @@ public void testCopy_readerToOutputStream_Encoding() throws Exception {
         assertTrue("Content differs", Arrays.equals(inData, bytes));
     }
 
+    @SuppressWarnings("resource") // 'in' is deliberately not closed
+    @Test
+    public void testCopy_readerToOutputStream_Encoding_nullEncoding() throws Exception {
+        InputStream in = new ByteArrayInputStream(inData);
+        in = new YellOnCloseInputStream(in);
+        final Reader reader = new InputStreamReader(in, "US-ASCII");
+
+        final ByteArrayOutputStream baout = new ByteArrayOutputStream();
+        final OutputStream out = new YellOnFlushAndCloseOutputStream(baout, false, true);
+
+        IOUtils.copy(reader, out, (String) null);
+        // note: this method *does* flush.
+        // note: we don't flush here; this IOUtils method does it for us
+
+        assertEquals("Sizes differ", inData.length, baout.size());
+        assertTrue("Content differs", Arrays.equals(inData, baout.toByteArray()));
+    }
+
     @Test(expected = NullPointerException.class)
     public void testCopy_readerToOutputStream_Encoding_nullIn() throws Exception {
         final ByteArrayOutputStream baout = new ByteArrayOutputStream();
@@ -307,22 +361,21 @@ public void testCopy_readerToOutputStream_Encoding_nullOut() throws Exception {
         IOUtils.copy(reader, null, "UTF16");
     }
 
-    @SuppressWarnings("resource") // 'in' is deliberately not closed
-    @Test
-    public void testCopy_readerToOutputStream_Encoding_nullEncoding() throws Exception {
+    @SuppressWarnings("deprecation")
+    @Test(expected = NullPointerException.class)
+    public void testCopy_readerToOutputStream_nullIn() throws Exception { // deliberately testing deprecated method
+        final ByteArrayOutputStream baout = new ByteArrayOutputStream();
+        final OutputStream out = new YellOnFlushAndCloseOutputStream(baout, true, true);
+        IOUtils.copy((Reader) null, out);
+    }
+
+    @SuppressWarnings({ "resource", "deprecation" }) // 'in' is deliberately not closed
+    @Test(expected = NullPointerException.class)
+    public void testCopy_readerToOutputStream_nullOut() throws Exception {
         InputStream in = new ByteArrayInputStream(inData);
         in = new YellOnCloseInputStream(in);
         final Reader reader = new InputStreamReader(in, "US-ASCII");
-
-        final ByteArrayOutputStream baout = new ByteArrayOutputStream();
-        final OutputStream out = new YellOnFlushAndCloseOutputStream(baout, false, true);
-
-        IOUtils.copy(reader, out, (String) null);
-        // note: this method *does* flush.
-        // note: we don't flush here; this IOUtils method does it for us
-
-        assertEquals("Sizes differ", inData.length, baout.size());
-        assertTrue("Content differs", Arrays.equals(inData, baout.toByteArray()));
+        IOUtils.copy(reader, (OutputStream) null); // deliberately testing deprecated method
     }
 
     //-----------------------------------------------------------------------
@@ -345,23 +398,6 @@ public void testCopy_readerToWriter() throws Exception {
         assertTrue("Content differs", Arrays.equals(inData, baout.toByteArray()));
     }
 
-    @Test(expected = NullPointerException.class)
-    public void testCopy_readerToWriter_nullIn() throws Exception {
-        final ByteArrayOutputStream baout = new ByteArrayOutputStream();
-        final OutputStream out = new YellOnFlushAndCloseOutputStream(baout, true, true);
-        final Writer writer = new OutputStreamWriter(out, "US-ASCII");
-        IOUtils.copy((Reader) null, writer);
-    }
-
-    @SuppressWarnings("resource") // 'in' is deliberately not closed
-    @Test(expected = NullPointerException.class)
-    public void testCopy_readerToWriter_nullOut() throws Exception {
-        InputStream in = new ByteArrayInputStream(inData);
-        in = new YellOnCloseInputStream(in);
-        final Reader reader = new InputStreamReader(in, "US-ASCII");
-        IOUtils.copy(reader, (Writer) null);
-    }
-
     /*
      * Test Copying file > 2GB  - see issue# IO-84
      */
@@ -382,4 +418,21 @@ public void testCopy_readerToWriter_IO84() throws Exception {
 
     }
 
+    @Test(expected = NullPointerException.class)
+    public void testCopy_readerToWriter_nullIn() throws Exception {
+        final ByteArrayOutputStream baout = new ByteArrayOutputStream();
+        final OutputStream out = new YellOnFlushAndCloseOutputStream(baout, true, true);
+        final Writer writer = new OutputStreamWriter(out, "US-ASCII");
+        IOUtils.copy((Reader) null, writer);
+    }
+
+    @SuppressWarnings("resource") // 'in' is deliberately not closed
+    @Test(expected = NullPointerException.class)
+    public void testCopy_readerToWriter_nullOut() throws Exception {
+        InputStream in = new ByteArrayInputStream(inData);
+        in = new YellOnCloseInputStream(in);
+        final Reader reader = new InputStreamReader(in, "US-ASCII");
+        IOUtils.copy(reader, (Writer) null);
+    }
+
 }
