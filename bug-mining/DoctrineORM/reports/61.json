{"url":"https://api.github.com/repos/doctrine/orm/issues/11108","repository_url":"https://api.github.com/repos/doctrine/orm","labels_url":"https://api.github.com/repos/doctrine/orm/issues/11108/labels{/name}","comments_url":"https://api.github.com/repos/doctrine/orm/issues/11108/comments","events_url":"https://api.github.com/repos/doctrine/orm/issues/11108/events","html_url":"https://github.com/doctrine/orm/issues/11108","id":2029256629,"node_id":"I_kwDOAAkff8548_-1","number":11108,"title":"Loading inverse side of a one-to-one fails if target entity has an association id","user":{"login":"mcurland","id":8583438,"node_id":"MDQ6VXNlcjg1ODM0Mzg=","avatar_url":"https://avatars.githubusercontent.com/u/8583438?v=4","gravatar_id":"","url":"https://api.github.com/users/mcurland","html_url":"https://github.com/mcurland","followers_url":"https://api.github.com/users/mcurland/followers","following_url":"https://api.github.com/users/mcurland/following{/other_user}","gists_url":"https://api.github.com/users/mcurland/gists{/gist_id}","starred_url":"https://api.github.com/users/mcurland/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mcurland/subscriptions","organizations_url":"https://api.github.com/users/mcurland/orgs","repos_url":"https://api.github.com/users/mcurland/repos","events_url":"https://api.github.com/users/mcurland/events{/privacy}","received_events_url":"https://api.github.com/users/mcurland/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":2,"created_at":"2023-12-06T19:37:10Z","updated_at":"2024-08-23T10:03:53Z","closed_at":"2024-08-23T10:03:53Z","author_association":"CONTRIBUTOR","type":null,"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"### Bug Report\r\n\r\nAn inverse one-to-one is resolved with a separate query in EntityPersister->loadOneToOneEntity, which is called by UnitOfWork immediately after entity construction. If this is not the owning side of the association, a freshly constructed entity is provided as the source with the assumption that sufficient data is available in the entity to resolve the association.\r\n\r\nThe problem is that this is simply not true for an entity that uses an association as its identifier. In this case, the identifying association has not been initialized, so the entity has exactly zero useful information in it. This throws in loadOneToOneEntity indicating that the join column is not mapped.\r\n\r\nThe result is that the owning side of the relationship needs to be pulled into the UoW before the inverse side. Obviously, I should be able to query either object without failure\r\n\r\n|    Q        |   A\r\n|------------ | ------\r\n| BC Break    | no (assuming BC means _Backwards Compatibility_, which is NO (_Not Obvious_))\r\n| Version     | 2.17.1 (ongoing)\r\n\r\n#### Summary\r\n\r\nEntity identified with an association cannot be loaded if it is the inverse side of a non-identifying one-to-one relationship.\r\n\r\n#### Current behavior\r\n\r\nException is thrown indicating that the join column cannot be identified.\r\n\r\n#### How to reproduce\r\n\r\nSnippets pulled from associated pull request (which does not fail because it includes a fix). Any attempt to directly retrieve an InverseSide (findOneBy, getResult, etc.) that is not already cached will throw.\r\n```php\r\n/**\r\n * @Entity()\r\n * @Table(name=\"one_to_one_inverse_side_assoc_id_load_inverse\")\r\n */\r\nclass InverseSide\r\n{\r\n    /**\r\n     * Associative id (owning identifier)\r\n     *\r\n     * @var InverseSideIdTarget\r\n     * @Id()\r\n     * @OneToOne(targetEntity=InverseSideIdTarget::class, inversedBy=\"inverseSide\")\r\n     * @JoinColumn(nullable=false, name=\"associativeId\")\r\n     */\r\n    public $associativeId;\r\n\r\n    /**\r\n     * @var OwningSide\r\n     * @OneToOne(targetEntity=OwningSide::class, mappedBy=\"inverse\")\r\n     */\r\n    public $owning;\r\n}\r\n\r\n/**\r\n * @Entity()\r\n * @Table(name=\"one_to_one_inverse_side_assoc_id_load_owning\")\r\n */\r\nclass OwningSide\r\n{\r\n    /**\r\n     * @var string\r\n     * @Id()\r\n     * @Column(type=\"string\", length=255)\r\n     * @GeneratedValue(strategy=\"NONE\")\r\n     */\r\n    public $id;\r\n\r\n    /**\r\n     * Owning side\r\n     *\r\n     * @var InverseSide\r\n     * @OneToOne(targetEntity=InverseSide::class, inversedBy=\"owning\")\r\n     * @JoinColumn(name=\"inverse\", referencedColumnName=\"associativeId\")\r\n     */\r\n    public $inverse;\r\n}\r\n\r\n/**\r\n * @Entity()\r\n * @Table(name=\"one_to_one_inverse_side_assoc_id_load_inverse_id_target\")\r\n */\r\nclass InverseSideIdTarget\r\n{\r\n    /**\r\n     * @var string\r\n     * @Id()\r\n     * @Column(type=\"string\", length=255)\r\n     * @GeneratedValue(strategy=\"NONE\")\r\n     */\r\n    public $id;\r\n\r\n    /**\r\n     * @var InverseSide\r\n     * @OneToOne(targetEntity=InverseSide::class, mappedBy=\"associativeId\")\r\n     */\r\n    public $inverseSide;\r\n}\r\n```\r\n#### Expected behavior\r\n\r\nThe expected behavior is that I can directly retrieve OwningSide and InverseSide in a symmetric fashion.\r\n\r\n#### Approach to fix\r\nThe exception indicates that there is no field/column mapping for the associativeId field because it is used in association join column, so the first attempt to this added code to resolve the column. This was ultimately fruitless because even though the field was resolved, its contents are null because the owning relationship for the identifier has not been processed at this point.\r\n\r\nThe sourceEntity instance passed to loadOneToOneEntity is created immediately before this call, which moves data from the provided column-keyed array to the entity columns, with associations populated afterward. This means that we still have the original entity data array. I simply added a sourceEntityData argument to loadOneToOneEntity and provided this initial data. If the non-owning side cannot find data in the entity then it uses the original data array (which contains a superset of the entity data at this point) to form the query. This is a straightforward fix that solves the problem.","closed_by":{"login":"greg0ire","id":657779,"node_id":"MDQ6VXNlcjY1Nzc3OQ==","avatar_url":"https://avatars.githubusercontent.com/u/657779?v=4","gravatar_id":"","url":"https://api.github.com/users/greg0ire","html_url":"https://github.com/greg0ire","followers_url":"https://api.github.com/users/greg0ire/followers","following_url":"https://api.github.com/users/greg0ire/following{/other_user}","gists_url":"https://api.github.com/users/greg0ire/gists{/gist_id}","starred_url":"https://api.github.com/users/greg0ire/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/greg0ire/subscriptions","organizations_url":"https://api.github.com/users/greg0ire/orgs","repos_url":"https://api.github.com/users/greg0ire/repos","events_url":"https://api.github.com/users/greg0ire/events{/privacy}","received_events_url":"https://api.github.com/users/greg0ire/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/doctrine/orm/issues/11108/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/doctrine/orm/issues/11108/timeline","performed_via_github_app":null,"state_reason":"completed"}