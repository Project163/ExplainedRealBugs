{"url":"https://api.github.com/repos/tauri-apps/tauri/issues/2959","repository_url":"https://api.github.com/repos/tauri-apps/tauri","labels_url":"https://api.github.com/repos/tauri-apps/tauri/issues/2959/labels{/name}","comments_url":"https://api.github.com/repos/tauri-apps/tauri/issues/2959/comments","events_url":"https://api.github.com/repos/tauri-apps/tauri/issues/2959/events","html_url":"https://github.com/tauri-apps/tauri/issues/2959","id":1063482388,"node_id":"I_kwDOC7lts84_Y3QU","number":2959,"title":"[Proposal]: Plugin Builder","user":{"login":"JonasKruckenberg","id":25329995,"node_id":"MDQ6VXNlcjI1MzI5OTk1","avatar_url":"https://avatars.githubusercontent.com/u/25329995?v=4","gravatar_id":"","url":"https://api.github.com/users/JonasKruckenberg","html_url":"https://github.com/JonasKruckenberg","followers_url":"https://api.github.com/users/JonasKruckenberg/followers","following_url":"https://api.github.com/users/JonasKruckenberg/following{/other_user}","gists_url":"https://api.github.com/users/JonasKruckenberg/gists{/gist_id}","starred_url":"https://api.github.com/users/JonasKruckenberg/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/JonasKruckenberg/subscriptions","organizations_url":"https://api.github.com/users/JonasKruckenberg/orgs","repos_url":"https://api.github.com/users/JonasKruckenberg/repos","events_url":"https://api.github.com/users/JonasKruckenberg/events{/privacy}","received_events_url":"https://api.github.com/users/JonasKruckenberg/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[{"id":3307089819,"node_id":"MDU6TGFiZWwzMzA3MDg5ODE5","url":"https://api.github.com/repos/tauri-apps/tauri/labels/type:%20feature%20request","name":"type: feature request","color":"446DBA","default":false,"description":""},{"id":3307098206,"node_id":"MDU6TGFiZWwzMzA3MDk4MjA2","url":"https://api.github.com/repos/tauri-apps/tauri/labels/priority:%202%20medium","name":"priority: 2 medium","color":"E844A1","default":false,"description":""}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":11,"created_at":"2021-11-25T11:38:36Z","updated_at":"2022-07-01T22:51:12Z","closed_at":"2021-12-02T10:13:56Z","author_association":"MEMBER","type":null,"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"> This proposal is not finished yet! Please participate by reviewing the proposed API.\r\n\r\n**Is your feature request related to a problem? Please describe.**\r\n\r\nThere are several observations I made about the current `Plugin` trait that I would like to address:\r\n1. Defining a custom struct for a plugin has little realworld use as plugin state is better stored using the `app.manage` and `app.state` methods. (This state is also accessible in commands while plugin struct fields are not)\r\n2. the `Plugin` method names are not super self explanatory and naming is somewhat inconsistent (`created` is an event callback but is not named `on_created` while `on_event` and `on_page_load` are)\r\n3. The practice of having an `invoke_handler` field and a `extend_api` to register commands is not obvious\r\n4. In \"real-world\" usage (the official plugins) the `config` property taken from the `tauri.conf.json` file had little use and makes plugins more confusing rather than easier to use. It has shown that exporting a builder and having configuration \"in-code\" is better.\r\n\r\nIn general I think the current Plugin api leads to unnecessarily verbose and complex plugins, so I would like to propose an improved builder based API:\r\n\r\n**Describe the solution you'd like**\r\nIntroduce a `PluginBuilder` struct to streamline the plugin creation:\r\n```rs\r\n/// Mock command\r\n#[command]\r\nasync fn execute<R: Runtime>(_app: AppHandle<R>) -> Result<String> {\r\n  Ok(\"success\".to_string())\r\n}\r\n\r\npub fn init() -> Plugin { // not the Plugin trait\r\n   PluginBuilder::new(\"example\")\r\n      .commands(vec![execute])\r\n      .setup(|app| {\r\n         app.manage(MyState::default());\r\n         Ok(())\r\n      })\r\n}\r\n```\r\n\r\nInstead of the current api:\r\n```rs\r\n/// Mock command\r\n#[command]\r\nasync fn execute<R: Runtime>(_app: AppHandle<R>) -> Result<String> {\r\n  Ok(\"success\".to_string())\r\n}\r\n\r\npub struct ExamplePlugin<R: Runtime> {\r\n  invoke_handler: Box<dyn Fn(Invoke<R>) + Send + Sync>,\r\n}\r\n\r\nimpl<R: Runtime> Default for ExamplePlugin<R> {\r\n  fn default() -> Self {\r\n    Self {\r\n      invoke_handler: Box::new(tauri::generate_handler![execute]),\r\n    }\r\n  }\r\n}\r\n\r\nimpl<R: Runtime> Plugin<R> for ExamplePlugin<R> {\r\n  fn name(&self) -> &'static str {\r\n    \"example\"\r\n  }\r\n\r\n  fn initialize(&mut self, app: &AppHandle<R>, _config: JsonValue) -> tauri::plugin::Result<()> {\r\n    app.manage(MyState::default());\r\n    Ok(())\r\n  }\r\n\r\n  fn extend_api(&mut self, message: Invoke<R>) {\r\n    (self.invoke_handler)(message)\r\n  }\r\n}\r\n```\r\n\r\nThe proposed builder methods closely resemble the traits methods, with a few differences:\r\n- rename methods to better communicate their purpose \r\n   `js` instead of `initiailization_script`, `commands` instead of `extend_api` and `setup` instead of `initialize`.\r\n- name event callbacks consistently\r\n  with the prefix `on_`\r\n\r\n```rs\r\ntrait PluginBuilder {\r\n   // creates the builder using the plugin `name`\r\n   fn new(name: &'static str) -> Self;\r\n   // Renamed `initialization_script` fn to better communicate it takes a JavaScript string\r\n   fn js(&mut self, js_code: String) -> &mut self;\r\n   // Register an array of tauri commands. This hides all the ugly Boxing and macro usage\r\n   fn commands(&mut self, commands: Vec<?>) -> &mut self;\r\n   // Renamed `initialize` fn to highlight the similarity to the `AppBuilder`s setup fn\r\n   fn setup(setup: Fn(&AppHandle<R>) -> Result<(), Box<dyn Error + Send>> + Send + 'static);\r\n   // set the `on_event ` method\r\n   fn on_event(cb: Fn(&AppHandle<R>, &Event)) -> &mut self;\r\n   // set the `on_page_load` method\r\n   fn on_page_load(cb: Fn(Window<R>, payload: PageLoadPayload)) -> &mut self;\r\n   // set the `created` method\r\n   fn on_webview_ready(cb: Fn(Window<R>)) -> &mut self;\r\n   // builds the plugin\r\n   fn build(self) -> Plugin; // not the Plugin trait\r\n}\r\n```\r\n\r\nThe `PluginBuilder` struct could just be wrapper returning `Plugin` trait implementations, so this proposal would have a clear implementation path.\r\n\r\n### Notes\r\n\r\n1. Having a builder struct allows us to improve and extend the plugin API in the future with less hassle\r\n2. I propose plugins exporting a creation function called `init` (as shown in the example above). This function is free to receive any arguments, so plugin authors may use this to provide configuration options for end users.\r\n3. I'm considering to remove the `js`/`initialization_script` methods all together. Plugins should expose corresponding js packages and not rely on extending the global object. The overwhelming majority of tauri projects also uses bundlers which make providing api packages is a no-brainer. For the few projects that don't, plugin can provide prebuilt *browser bundles*. See [tauri-plugin-store](https://github.com/tauri-apps/tauri-plugin-store/blob/dev/webview-src/rollup.config.js) for an example of this.\r\n\r\n**Describe alternatives you've considered**\r\nLeave the trait as is.\r\n\r\n**Additional context**\r\nThe builder pattern is inspired by [`deno_core`s `ExtensionBuilder`](https://github.com/denoland/deno/blob/main/core/extensions.rs#L61-L108).\r\nThe `init`function is inspired by [denos extensions](https://github.com/denoland/deno/tree/main/ext) and the convention among [rollup](https://rollupjs.org) plugins to export a [single creation function](https://rollupjs.org/guide/en/#a-simple-example).\r\n","closed_by":{"login":"JonasKruckenberg","id":25329995,"node_id":"MDQ6VXNlcjI1MzI5OTk1","avatar_url":"https://avatars.githubusercontent.com/u/25329995?v=4","gravatar_id":"","url":"https://api.github.com/users/JonasKruckenberg","html_url":"https://github.com/JonasKruckenberg","followers_url":"https://api.github.com/users/JonasKruckenberg/followers","following_url":"https://api.github.com/users/JonasKruckenberg/following{/other_user}","gists_url":"https://api.github.com/users/JonasKruckenberg/gists{/gist_id}","starred_url":"https://api.github.com/users/JonasKruckenberg/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/JonasKruckenberg/subscriptions","organizations_url":"https://api.github.com/users/JonasKruckenberg/orgs","repos_url":"https://api.github.com/users/JonasKruckenberg/repos","events_url":"https://api.github.com/users/JonasKruckenberg/events{/privacy}","received_events_url":"https://api.github.com/users/JonasKruckenberg/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/tauri-apps/tauri/issues/2959/reactions","total_count":1,"+1":1,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/tauri-apps/tauri/issues/2959/timeline","performed_via_github_app":null,"state_reason":"completed"}