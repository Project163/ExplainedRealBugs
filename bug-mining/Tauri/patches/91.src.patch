diff --git a/.changes/fix-cli-signer-sign-cmd.md b/.changes/fix-cli-signer-sign-cmd.md
new file mode 100644
index 000000000..1f49618c1
--- /dev/null
+++ b/.changes/fix-cli-signer-sign-cmd.md
@@ -0,0 +1,6 @@
+---
+"cli.rs": patch
+"cli.js": patch
+---
+
+Fixes the signature of the `signer sign` command to not have duplicated short flags.
diff --git a/examples/api/src-tauri/Cargo.lock b/examples/api/src-tauri/Cargo.lock
index 6c494f1bf..55e6b829e 100644
--- a/examples/api/src-tauri/Cargo.lock
+++ b/examples/api/src-tauri/Cargo.lock
@@ -490,9 +490,9 @@ dependencies = [
 
 [[package]]
 name = "clap"
-version = "3.0.14"
+version = "3.1.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b63edc3f163b3c71ec8aa23f9bd6070f77edbf3d1d198b164afa90ff00e4ec62"
+checksum = "e5f1fea81f183005ced9e59cdb01737ef2423956dac5a6d731b06b2ecfaa3467"
 dependencies = [
  "atty",
  "bitflags",
@@ -3304,8 +3304,9 @@ dependencies = [
 
 [[package]]
 name = "tauri"
-version = "1.0.0-rc.1"
+version = "1.0.0-rc.2"
 dependencies = [
+ "anyhow",
  "attohttpc",
  "base64",
  "bincode",
@@ -3355,7 +3356,7 @@ dependencies = [
 
 [[package]]
 name = "tauri-build"
-version = "1.0.0-rc.1"
+version = "1.0.0-rc.2"
 dependencies = [
  "anyhow",
  "cargo_toml",
diff --git a/tooling/cli/src/helpers/updater_signature.rs b/tooling/cli/src/helpers/updater_signature.rs
index 778f38395..158adbf07 100644
--- a/tooling/cli/src/helpers/updater_signature.rs
+++ b/tooling/cli/src/helpers/updater_signature.rs
@@ -102,7 +102,7 @@ where
 /// Sign files
 pub fn sign_file<P>(
   private_key: String,
-  password: String,
+  password: Option<String>,
   bin_path: P,
 ) -> crate::Result<(PathBuf, String)>
 where
@@ -110,7 +110,7 @@ where
 {
   let decoded_secret = decode_key(private_key)?;
   let sk_box = SecretKeyBox::from_string(&decoded_secret).unwrap();
-  let sk = sk_box.into_secret_key(Some(password)).unwrap();
+  let sk = sk_box.into_secret_key(password).unwrap();
 
   // We need to append .sig at the end it's where the signature will be stored
   let signature_path_string = format!("{}.sig", bin_path.as_ref().display());
@@ -146,10 +146,8 @@ where
   P: AsRef<Path>,
 {
   // if no password provided we set empty string
-  let password_string = match var_os("TAURI_KEY_PASSWORD") {
-    Some(value) => String::from(value.to_str().unwrap()),
-    None => "".into(),
-  };
+  let password_string =
+    var_os("TAURI_KEY_PASSWORD").map(|value| value.to_str().unwrap().to_string());
   // get the private key
   if let Some(private_key) = var_os("TAURI_PRIVATE_KEY") {
     // check if this file exist..
diff --git a/tooling/cli/src/signer/sign.rs b/tooling/cli/src/signer/sign.rs
index 99c21b7b3..0c54d328c 100644
--- a/tooling/cli/src/signer/sign.rs
+++ b/tooling/cli/src/signer/sign.rs
@@ -24,8 +24,7 @@ pub struct Options {
   #[clap(short, long)]
   password: Option<String>,
   /// Sign the specified file
-  #[clap(short, long)]
-  file: Option<PathBuf>,
+  file: PathBuf,
 }
 
 pub fn command(mut options: Options) -> Result<()> {
@@ -34,22 +33,20 @@ pub fn command(mut options: Options) -> Result<()> {
   } else {
     options.private_key
   };
-  if options.private_key.is_none() {
+  let private_key = if let Some(pk) = options.private_key {
+    pk
+  } else {
     return Err(anyhow::anyhow!(
       "Key generation aborted: Unable to find the private key".to_string(),
     ));
-  }
+  };
 
   if options.password.is_none() {
     println!("Signing without password.");
   }
 
-  let (manifest_dir, signature) = sign_file(
-    options.private_key.unwrap(),
-    options.password.unwrap(),
-    options.file.unwrap(),
-  )
-  .with_context(|| "failed to sign file")?;
+  let (manifest_dir, signature) = sign_file(private_key, options.password, options.file)
+    .with_context(|| "failed to sign file")?;
 
   println!(
            "\nYour file was signed successfully, You can find the signature here:\n{}\n\nPublic signature:\n{}\n\nMake sure to include this into the signature field of your update server.",
