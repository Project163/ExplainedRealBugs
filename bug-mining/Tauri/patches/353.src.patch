diff --git a/.changes/cli-autoreload-mime-type.md b/.changes/cli-autoreload-mime-type.md
new file mode 100644
index 000000000..ced6924f0
--- /dev/null
+++ b/.changes/cli-autoreload-mime-type.md
@@ -0,0 +1,6 @@
+---
+'tauri-cli': 'patch'
+'@tauri-apps/cli': 'patch'
+---
+
+Fix built-in devserver adding hot-reload code to non-html files.
diff --git a/.changes/mime-type.md b/.changes/mime-type.md
new file mode 100644
index 000000000..0b43e79e4
--- /dev/null
+++ b/.changes/mime-type.md
@@ -0,0 +1,5 @@
+---
+'tauri-utils': 'patch'
+---
+
+Add `MimeType::parse_with_fallback` and `MimeType::parse_from_uri_with_fallback`
diff --git a/core/tauri-utils/src/mime_type.rs b/core/tauri-utils/src/mime_type.rs
index d3ae5f6d9..ba8a2571b 100644
--- a/core/tauri-utils/src/mime_type.rs
+++ b/core/tauri-utils/src/mime_type.rs
@@ -46,6 +46,11 @@ impl std::fmt::Display for MimeType {
 impl MimeType {
   /// parse a URI suffix to convert text/plain mimeType to their actual web compatible mimeType.
   pub fn parse_from_uri(uri: &str) -> MimeType {
+    Self::parse_from_uri_with_fallback(uri, Self::Html)
+  }
+
+  /// parse a URI suffix to convert text/plain mimeType to their actual web compatible mimeType with specified fallback for unknown file extensions.
+  pub fn parse_from_uri_with_fallback(uri: &str, fallback: MimeType) -> MimeType {
     let suffix = uri.split('.').last();
     match suffix {
       Some("bin") => Self::OctetStream,
@@ -61,15 +66,19 @@ impl MimeType {
       Some("svg") => Self::Svg,
       Some("mp4") => Self::Mp4,
       // Assume HTML when a TLD is found for eg. `wry:://tauri.app` | `wry://hello.com`
-      Some(_) => Self::Html,
-      // https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types
+      Some(_) => fallback,
       // using octet stream according to this:
+      // https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types
       None => Self::OctetStream,
     }
   }
 
   /// infer mimetype from content (or) URI if needed.
   pub fn parse(content: &[u8], uri: &str) -> String {
+    Self::parse_with_fallback(content, uri, Self::Html)
+  }
+  /// infer mimetype from content (or) URI if needed with specified fallback for unknown file extensions.
+  pub fn parse_with_fallback(content: &[u8], uri: &str, fallback: MimeType) -> String {
     let mime = if uri.ends_with(".svg") {
       // when reading svg, we can't use `infer`
       None
@@ -78,8 +87,10 @@ impl MimeType {
     };
 
     match mime {
-      Some(mime) if mime == MIMETYPE_PLAIN => Self::parse_from_uri(uri).to_string(),
-      None => Self::parse_from_uri(uri).to_string(),
+      Some(mime) if mime == MIMETYPE_PLAIN => {
+        Self::parse_from_uri_with_fallback(uri, fallback).to_string()
+      }
+      None => Self::parse_from_uri_with_fallback(uri, fallback).to_string(),
       Some(mime) => mime.to_string(),
     }
   }
diff --git a/tooling/cli/src/helpers/web_dev_server.rs b/tooling/cli/src/helpers/web_dev_server.rs
index e095f0b3c..d39f1579e 100644
--- a/tooling/cli/src/helpers/web_dev_server.rs
+++ b/tooling/cli/src/helpers/web_dev_server.rs
@@ -145,7 +145,7 @@ async fn handler<T>(req: Request<T>, state: Arc<State>) -> impl IntoResponse {
 
   file
     .map(|mut f| {
-      let mime_type = MimeType::parse(&f, uri);
+      let mime_type = MimeType::parse_with_fallback(&f, uri, MimeType::OctetStream);
       if mime_type == MimeType::Html.to_string() {
         let mut document = kuchiki::parse_html().one(String::from_utf8_lossy(&f).into_owned());
         fn with_html_head<F: FnOnce(&NodeRef)>(document: &mut NodeRef, f: F) {
