diff --git a/.changes/allow-conf-gitignore.md b/.changes/allow-conf-gitignore.md
new file mode 100644
index 000000000..cf63422e6
--- /dev/null
+++ b/.changes/allow-conf-gitignore.md
@@ -0,0 +1,6 @@
+---
+"cli.rs": patch
+"cli.js": patch
+---
+
+Allows the `tauri.conf.json` file to be git ignored on the path lookup function.
diff --git a/tooling/cli/src/helpers/app_paths.rs b/tooling/cli/src/helpers/app_paths.rs
index 6ee7b78a4..8a708c15d 100644
--- a/tooling/cli/src/helpers/app_paths.rs
+++ b/tooling/cli/src/helpers/app_paths.rs
@@ -6,6 +6,7 @@ use std::{
   cmp::Ordering,
   env::current_dir,
   ffi::OsStr,
+  fs::FileType,
   path::{Path, PathBuf},
 };
 
@@ -14,7 +15,7 @@ use once_cell::sync::Lazy;
 
 const TAURI_GITIGNORE: &[u8] = include_bytes!("../../tauri.gitignore");
 
-fn lookup<F: Fn(&PathBuf) -> bool>(dir: &Path, checker: F) -> Option<PathBuf> {
+fn lookup<F: Fn(&PathBuf, FileType) -> bool>(dir: &Path, checker: F) -> Option<PathBuf> {
   let mut default_gitignore = std::env::temp_dir();
   default_gitignore.push(".gitignore");
   if !default_gitignore.exists() {
@@ -47,7 +48,7 @@ fn lookup<F: Fn(&PathBuf) -> bool>(dir: &Path, checker: F) -> Option<PathBuf> {
 
   for entry in builder.build().flatten() {
     let path = dir.join(entry.path());
-    if checker(&path) {
+    if checker(&path, entry.file_type().unwrap()) {
       return Some(path);
     }
   }
@@ -55,17 +56,19 @@ fn lookup<F: Fn(&PathBuf) -> bool>(dir: &Path, checker: F) -> Option<PathBuf> {
 }
 
 fn get_tauri_dir() -> PathBuf {
-  lookup(&current_dir().expect("failed to read cwd"), |path| if let Some(file_name) = path.file_name() {
+  lookup(&current_dir().expect("failed to read cwd"), |path, file_type| if file_type.is_dir() {
+    path.join("tauri.conf.json").exists() || path.join("tauri.conf.json5").exists()
+  } else if let Some(file_name) = path.file_name() {
     file_name == OsStr::new("tauri.conf.json") || file_name == OsStr::new("tauri.conf.json5")
   } else {
     false
   })
-  .map(|p| p.parent().unwrap().to_path_buf())
+  .map(|p| if p.is_dir() { p } else {  p.parent().unwrap().to_path_buf() })
   .expect("Couldn't recognize the current folder as a Tauri project. It must contain a `tauri.conf.json` or `tauri.conf.json5` file in any subfolder.")
 }
 
 fn get_app_dir() -> Option<PathBuf> {
-  lookup(&current_dir().expect("failed to read cwd"), |path| {
+  lookup(&current_dir().expect("failed to read cwd"), |path, _| {
     if let Some(file_name) = path.file_name() {
       file_name == OsStr::new("package.json")
     } else {
