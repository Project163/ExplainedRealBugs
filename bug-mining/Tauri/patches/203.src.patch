diff --git a/.changes/cargo-not-found.md b/.changes/cargo-not-found.md
new file mode 100644
index 000000000..6141ed9ef
--- /dev/null
+++ b/.changes/cargo-not-found.md
@@ -0,0 +1,6 @@
+---
+"cli.rs": patch
+"cli.js": patch
+---
+
+Improve error message when `cargo` is not installed.
diff --git a/tooling/cli/src/dev.rs b/tooling/cli/src/dev.rs
index ecb2f233a..b0fb4f08f 100644
--- a/tooling/cli/src/dev.rs
+++ b/tooling/cli/src/dev.rs
@@ -23,7 +23,7 @@ use std::{
   env::set_current_dir,
   ffi::OsStr,
   fs::FileType,
-  io::{BufReader, Write},
+  io::{BufReader, ErrorKind, Write},
   path::{Path, PathBuf},
   process::{exit, Command, Stdio},
   sync::{
@@ -495,8 +495,24 @@ fn start_app(
   command.stdout(os_pipe::dup_stdout().unwrap());
   command.stderr(Stdio::piped());
 
-  let child =
-    SharedChild::spawn(&mut command).with_context(|| format!("failed to run {}", runner))?;
+  let child = match SharedChild::spawn(&mut command) {
+    Ok(c) => c,
+    Err(e) => {
+      if e.kind() == ErrorKind::NotFound {
+        return Err(anyhow::anyhow!(
+          "`{}` command not found.{}",
+          runner,
+          if runner == "cargo" {
+            " Please follow the Tauri setup guide: https://tauri.app/v1/guides/getting-started/prerequisites"
+          } else {
+            ""
+          }
+        ));
+      } else {
+        return Err(e.into());
+      }
+    }
+  };
   let child_arc = Arc::new(child);
   let child_stderr = child_arc.take_stderr().unwrap();
   let mut stderr = BufReader::new(child_stderr);
diff --git a/tooling/cli/src/interface/rust.rs b/tooling/cli/src/interface/rust.rs
index e873b0296..68f6f3831 100644
--- a/tooling/cli/src/interface/rust.rs
+++ b/tooling/cli/src/interface/rust.rs
@@ -4,7 +4,7 @@
 
 use std::{
   fs::File,
-  io::Read,
+  io::{ErrorKind, Read},
   path::{Path, PathBuf},
   process::Command,
   str::FromStr,
@@ -101,18 +101,37 @@ struct CargoConfig {
 }
 
 pub fn build_project(runner: String, args: Vec<String>) -> crate::Result<()> {
-  let status = Command::new(&runner)
+  match Command::new(&runner)
     .args(&["build", "--features=custom-protocol"])
     .args(args)
     .env("STATIC_VCRUNTIME", "true")
-    .piped()?;
-  if status.success() {
-    Ok(())
-  } else {
-    Err(anyhow::anyhow!(
-      "Result of `{} build` operation was unsuccessful",
-      runner
-    ))
+    .piped()
+  {
+    Ok(status) => {
+      if status.success() {
+        Ok(())
+      } else {
+        Err(anyhow::anyhow!(
+          "Result of `{} build` operation was unsuccessful",
+          runner
+        ))
+      }
+    }
+    Err(e) => {
+      if e.kind() == ErrorKind::NotFound {
+        Err(anyhow::anyhow!(
+          "`{}` command not found.{}",
+          runner,
+          if runner == "cargo" {
+            " Please follow the Tauri setup guide: https://tauri.app/v1/guides/getting-started/prerequisites"
+          } else {
+            ""
+          }
+        ))
+      } else {
+        Err(e.into())
+      }
+    }
   }
 }
 
diff --git a/tooling/cli/src/lib.rs b/tooling/cli/src/lib.rs
index adb980ad5..b7cbaa5e6 100644
--- a/tooling/cli/src/lib.rs
+++ b/tooling/cli/src/lib.rs
@@ -176,12 +176,12 @@ fn prettyprint_level(lvl: Level) -> &'static str {
 pub trait CommandExt {
   // The `pipe` function sets the stdout and stderr to properly
   // show the command output in the Node.js wrapper.
-  fn piped(&mut self) -> Result<ExitStatus>;
+  fn piped(&mut self) -> std::io::Result<ExitStatus>;
   fn output_ok(&mut self) -> crate::Result<()>;
 }
 
 impl CommandExt for Command {
-  fn piped(&mut self) -> crate::Result<ExitStatus> {
+  fn piped(&mut self) -> std::io::Result<ExitStatus> {
     self.stdout(os_pipe::dup_stdout()?);
     self.stderr(os_pipe::dup_stderr()?);
     let program = self.get_program().to_string_lossy().into_owned();
