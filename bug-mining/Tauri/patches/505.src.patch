diff --git a/.changes/cli-perserve-cargo-bin-name.md b/.changes/cli-perserve-cargo-bin-name.md
new file mode 100644
index 000000000..a991e3eea
--- /dev/null
+++ b/.changes/cli-perserve-cargo-bin-name.md
@@ -0,0 +1,7 @@
+---
+"tauri-cli": "patch:breaking"
+"@tauri-apps/cli": "patch:breaking"
+---
+
+Avoid renaming main binary to product name and perserve the name generated by cargo.
+
diff --git a/.changes/tauri-utils-package-name-removed.md b/.changes/tauri-utils-package-name-removed.md
new file mode 100644
index 000000000..bbb4ae146
--- /dev/null
+++ b/.changes/tauri-utils-package-name-removed.md
@@ -0,0 +1,6 @@
+---
+"tauri-utils": "patch:breaking"
+---
+
+Removed `Config::binary_name` and `PackageInfo::package_name`
+
diff --git a/Cargo.lock b/Cargo.lock
index ab4bf0f2e..f6cf67e88 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -3720,7 +3720,6 @@ dependencies = [
  "dunce",
  "getrandom 0.2.12",
  "glob",
- "heck 0.5.0",
  "html5ever",
  "infer",
  "json-patch",
diff --git a/core/tauri-utils/Cargo.toml b/core/tauri-utils/Cargo.toml
index 6a5c7e156..a86e2ad76 100644
--- a/core/tauri-utils/Cargo.toml
+++ b/core/tauri-utils/Cargo.toml
@@ -43,9 +43,6 @@ dunce = "1"
 log = "0.4.21"
 cargo_metadata = { version = "0.18", optional = true }
 
-[target."cfg(target_os = \"linux\")".dependencies]
-heck = "0.5"
-
 [target."cfg(target_os = \"macos\")".dependencies]
 swift-rs = { version = "1.0.6", optional = true, features = [ "build" ] }
 
diff --git a/core/tauri-utils/src/config.rs b/core/tauri-utils/src/config.rs
index e6bdb630e..d0ddca3d6 100644
--- a/core/tauri-utils/src/config.rs
+++ b/core/tauri-utils/src/config.rs
@@ -10,8 +10,6 @@
 //! This is a core functionality that is not considered part of the stable API.
 //! If you use it, note that it may include breaking changes in the future.
 
-#[cfg(target_os = "linux")]
-use heck::ToKebabCase;
 #[cfg(feature = "schema")]
 use schemars::JsonSchema;
 use semver::Version;
@@ -2115,21 +2113,6 @@ pub struct Config {
   pub plugins: PluginConfig,
 }
 
-impl Config {
-  /// The binary name. Returns the product name as kebab-case on Linux,
-  /// and returns it as is on all other platforms.
-  pub fn binary_name(&self) -> Option<String> {
-    #[cfg(target_os = "linux")]
-    {
-      self.product_name.as_ref().map(|n| n.to_kebab_case())
-    }
-    #[cfg(not(target_os = "linux"))]
-    {
-      self.product_name.clone()
-    }
-  }
-}
-
 /// The plugin configs holds a HashMap mapping a plugin name to its configuration object.
 ///
 /// See more: <https://tauri.app/v1/api/config#pluginconfig>
diff --git a/core/tauri-utils/src/lib.rs b/core/tauri-utils/src/lib.rs
index c9bea8f60..c8e363391 100644
--- a/core/tauri-utils/src/lib.rs
+++ b/core/tauri-utils/src/lib.rs
@@ -57,20 +57,6 @@ pub struct PackageInfo {
   pub crate_name: &'static str,
 }
 
-impl PackageInfo {
-  /// Returns the application package name.
-  /// On macOS and Windows it's the `name` field, and on Linux it's the `name` in `kebab-case`.
-  pub fn package_name(&self) -> String {
-    #[cfg(target_os = "linux")]
-    {
-      use heck::ToKebabCase;
-      self.name.clone().to_kebab_case()
-    }
-    #[cfg(not(target_os = "linux"))]
-    self.name.clone()
-  }
-}
-
 #[allow(deprecated)]
 mod window_effects {
   use super::*;
diff --git a/core/tauri-utils/src/platform.rs b/core/tauri-utils/src/platform.rs
index 5c3bc8e02..29bfcc222 100644
--- a/core/tauri-utils/src/platform.rs
+++ b/core/tauri-utils/src/platform.rs
@@ -292,7 +292,7 @@ fn resource_dir_from<P: AsRef<Path>>(
     res = if curr_dir.ends_with("/data/usr/bin") {
       // running from the deb bundle dir
       exe_dir
-        .join(format!("../lib/{}", package_info.package_name()))
+        .join(format!("../lib/{}", package_info.crate_name))
         .canonicalize()
         .map_err(Into::into)
     } else if let Some(appdir) = &env.appdir {
@@ -300,13 +300,13 @@ fn resource_dir_from<P: AsRef<Path>>(
       Ok(PathBuf::from(format!(
         "{}/usr/lib/{}",
         appdir.display(),
-        package_info.package_name()
+        package_info.crate_name
       )))
     } else {
       // running bundle
       Ok(PathBuf::from(format!(
         "/usr/lib/{}",
-        package_info.package_name()
+        package_info.crate_name
       )))
     };
   }
@@ -357,7 +357,7 @@ mod tests {
       version: "1.0.0".parse().unwrap(),
       authors: "",
       description: "",
-      crate_name: "",
+      crate_name: "my-app",
     };
     let env = Env::default();
 
diff --git a/core/tauri/src/window/mod.rs b/core/tauri/src/window/mod.rs
index c0445fa18..c4db893bd 100644
--- a/core/tauri/src/window/mod.rs
+++ b/core/tauri/src/window/mod.rs
@@ -1991,16 +1991,7 @@ tauri::Builder::default()
       .set_progress_bar(crate::runtime::ProgressBarState {
         status: progress_state.status,
         progress: progress_state.progress,
-        desktop_filename: Some(format!(
-          "{}.desktop",
-          heck::AsKebabCase(
-            self
-              .config()
-              .product_name
-              .as_deref()
-              .unwrap_or_else(|| self.package_info().crate_name)
-          )
-        )),
+        desktop_filename: Some(format!("{}.desktop", self.package_info().crate_name)),
       })
       .map_err(Into::into)
   }
diff --git a/examples/api/src-tauri/Cargo.lock b/examples/api/src-tauri/Cargo.lock
index cc680c3ba..3f60f26ab 100644
--- a/examples/api/src-tauri/Cargo.lock
+++ b/examples/api/src-tauri/Cargo.lock
@@ -3189,7 +3189,6 @@ dependencies = [
  "dunce",
  "getrandom 0.2.15",
  "glob",
- "heck 0.5.0",
  "html5ever",
  "infer",
  "json-patch",
diff --git a/tooling/bundler/src/bundle.rs b/tooling/bundler/src/bundle.rs
index b4a937550..c77e1b8ac 100644
--- a/tooling/bundler/src/bundle.rs
+++ b/tooling/bundler/src/bundle.rs
@@ -63,35 +63,38 @@ pub fn bundle_project(settings: Settings) -> crate::Result<Vec<Bundle>> {
     log::warn!("Cross-platform compilation is experimental and does not support all features. Please use a matching host system for full compatibility.");
   }
 
-  if settings.can_sign() {
-    // Sign windows binaries before the bundling step in case neither wix and nsis bundles are enabled
-    for bin in settings.binaries() {
-      let bin_path = settings.binary_path(bin);
-      windows::sign::try_sign(&bin_path, &settings)?;
-    }
-
-    // Sign the sidecar binaries
-    for bin in settings.external_binaries() {
-      let path = bin?;
-      let skip = std::env::var("TAURI_SKIP_SIDECAR_SIGNATURE_CHECK").map_or(false, |v| v == "true");
-      if skip {
-        continue;
+  // Sign windows binaries before the bundling step in case neither wix and nsis bundles are enabled
+  if target_os == "windows" {
+    if settings.can_sign() {
+      for bin in settings.binaries() {
+        let bin_path = settings.binary_path(bin);
+        windows::sign::try_sign(&bin_path, &settings)?;
       }
 
-      #[cfg(windows)]
-      if windows::sign::verify(&path)? {
-        log::info!(
-          "sidecar at \"{}\" already signed. Skipping...",
-          path.display()
-        );
-        continue;
-      }
+      // Sign the sidecar binaries
+      for bin in settings.external_binaries() {
+        let path = bin?;
+        let skip =
+          std::env::var("TAURI_SKIP_SIDECAR_SIGNATURE_CHECK").map_or(false, |v| v == "true");
+        if skip {
+          continue;
+        }
 
-      windows::sign::try_sign(&path, &settings)?;
+        #[cfg(windows)]
+        if windows::sign::verify(&path)? {
+          log::info!(
+            "sidecar at \"{}\" already signed. Skipping...",
+            path.display()
+          );
+          continue;
+        }
+
+        windows::sign::try_sign(&path, &settings)?;
+      }
+    } else {
+      #[cfg(not(target_os = "windows"))]
+      log::warn!("Signing, by default, is only supported on Windows hosts, but you can specify a custom signing command in `bundler > windows > sign_command`, for now, skipping signing the installer...");
     }
-  } else {
-    #[cfg(not(target_os = "windows"))]
-    log::warn!("Signing, by default, is only supported on Windows hosts, but you can specify a custom signing command in `bundler > windows > sign_command`, for now, skipping signing the installer...");
   }
 
   for package_type in &package_types {
diff --git a/tooling/bundler/src/bundle/linux/appimage.rs b/tooling/bundler/src/bundle/linux/appimage.rs
index e28e795c4..7c9b26a1f 100644
--- a/tooling/bundler/src/bundle/linux/appimage.rs
+++ b/tooling/bundler/src/bundle/linux/appimage.rs
@@ -42,22 +42,22 @@ pub fn bundle_project(settings: &Settings) -> crate::Result<Vec<PathBuf>> {
     remove_dir_all(&output_path)?;
   }
   std::fs::create_dir_all(output_path.clone())?;
-  let app_dir_path = output_path.join(format!("{}.AppDir", settings.main_binary_name()));
+  let app_dir_path = output_path.join(format!("{}.AppDir", settings.product_name()));
   let appimage_filename = format!(
     "{}_{}_{}.AppImage",
-    settings.main_binary_name(),
+    settings.product_name(),
     settings.version_string(),
     arch
   );
   let appimage_path = output_path.join(&appimage_filename);
   path_utils::create(app_dir_path, true)?;
 
-  let upcase_app_name = settings.main_binary_name().to_uppercase();
+  let upcase_app_name = settings.product_name().to_uppercase();
 
   // setup data to insert into shell script
   let mut sh_map = BTreeMap::new();
   sh_map.insert("arch", settings.target().split('-').next().unwrap());
-  sh_map.insert("app_name", settings.main_binary_name());
+  sh_map.insert("app_name", settings.product_name());
   sh_map.insert("app_name_uppercase", &upcase_app_name);
   sh_map.insert("appimage_filename", &appimage_filename);
   let tauri_tools_path = dirs_next::cache_dir().map_or_else(
diff --git a/tooling/bundler/src/bundle/linux/debian.rs b/tooling/bundler/src/bundle/linux/debian.rs
index 1de9278db..250ad3b23 100644
--- a/tooling/bundler/src/bundle/linux/debian.rs
+++ b/tooling/bundler/src/bundle/linux/debian.rs
@@ -27,7 +27,6 @@ use super::{super::common, freedesktop};
 use crate::Settings;
 use anyhow::Context;
 use flate2::{write::GzEncoder, Compression};
-use heck::AsKebabCase;
 use tar::HeaderMode;
 use walkdir::WalkDir;
 
@@ -51,7 +50,7 @@ pub fn bundle_project(settings: &Settings) -> crate::Result<Vec<PathBuf>> {
   };
   let package_base_name = format!(
     "{}_{}_{}",
-    settings.main_binary_name(),
+    settings.product_name(),
     settings.version_string(),
     arch
   );
@@ -158,7 +157,8 @@ fn generate_control_file(
   // https://www.debian.org/doc/debian-policy/ch-controlfields.html
   let dest_path = control_dir.join("control");
   let mut file = common::create_file(&dest_path)?;
-  writeln!(file, "Package: {}", AsKebabCase(settings.product_name()))?;
+  let package = heck::AsKebabCase(settings.product_name());
+  writeln!(file, "Package: {}", package)?;
   writeln!(file, "Version: {}", settings.version_string())?;
   writeln!(file, "Architecture: {arch}")?;
   // Installed-Size must be divided by 1024, see https://www.debian.org/doc/debian-policy/ch-controlfields.html#installed-size
diff --git a/tooling/bundler/src/bundle/linux/freedesktop.rs b/tooling/bundler/src/bundle/linux/freedesktop.rs
index af07e97c8..9fc015692 100644
--- a/tooling/bundler/src/bundle/linux/freedesktop.rs
+++ b/tooling/bundler/src/bundle/linux/freedesktop.rs
@@ -80,7 +80,7 @@ pub fn list_icon_files(
 
 /// Generate the icon files and store them under the `data_dir`.
 pub fn copy_icon_files(settings: &Settings, data_dir: &Path) -> crate::Result<Vec<Icon>> {
-  let icons = self::list_icon_files(settings, data_dir)?;
+  let icons = list_icon_files(settings, data_dir)?;
   for (icon, src) in &icons {
     common::copy_file(src, &icon.path)?;
   }
diff --git a/tooling/bundler/src/bundle/macos/dmg.rs b/tooling/bundler/src/bundle/macos/dmg.rs
index 7356e755b..338866fe7 100644
--- a/tooling/bundler/src/bundle/macos/dmg.rs
+++ b/tooling/bundler/src/bundle/macos/dmg.rs
@@ -40,7 +40,7 @@ pub fn bundle_project(settings: &Settings, bundles: &[Bundle]) -> crate::Result<
   let output_path = settings.project_out_directory().join("bundle/dmg");
   let package_base_name = format!(
     "{}_{}_{}",
-    settings.main_binary_name(),
+    settings.product_name(),
     settings.version_string(),
     match settings.binary_arch() {
       "x86_64" => "x64",
@@ -50,7 +50,7 @@ pub fn bundle_project(settings: &Settings, bundles: &[Bundle]) -> crate::Result<
   let dmg_name = format!("{}.dmg", &package_base_name);
   let dmg_path = output_path.join(&dmg_name);
 
-  let product_name = settings.main_binary_name();
+  let product_name = settings.product_name();
   let bundle_file_name = format!("{}.app", product_name);
   let bundle_dir = settings.project_out_directory().join("bundle/macos");
 
diff --git a/tooling/bundler/src/bundle/settings.rs b/tooling/bundler/src/bundle/settings.rs
index 445e50cfe..27af3e538 100644
--- a/tooling/bundler/src/bundle/settings.rs
+++ b/tooling/bundler/src/bundle/settings.rs
@@ -606,6 +606,15 @@ impl BundleBinary {
     }
   }
 
+  /// Creates a new bundle binary with path.
+  pub fn with_path(name: String, main: bool, src_path: Option<String>) -> Self {
+    Self {
+      name,
+      src_path,
+      main,
+    }
+  }
+
   /// Sets the src path of the binary.
   #[must_use]
   pub fn set_src_path(mut self, src_path: Option<String>) -> Self {
diff --git a/tooling/bundler/src/bundle/windows/msi/wix.rs b/tooling/bundler/src/bundle/windows/msi/wix.rs
index 9f66967b8..613707782 100644
--- a/tooling/bundler/src/bundle/windows/msi/wix.rs
+++ b/tooling/bundler/src/bundle/windows/msi/wix.rs
@@ -21,7 +21,7 @@ use regex::Regex;
 use serde::{Deserialize, Serialize};
 use std::{
   collections::{BTreeMap, HashMap, HashSet},
-  fs::{create_dir_all, read_to_string, remove_dir_all, rename, write, File},
+  fs::{self, File},
   io::Write,
   path::{Path, PathBuf},
   process::Command,
@@ -155,7 +155,7 @@ fn copy_icon(settings: &Settings, filename: &str, path: &Path) -> crate::Result<
   let base_dir = settings.project_out_directory();
 
   let resource_dir = base_dir.join("resources");
-  create_dir_all(&resource_dir)?;
+  fs::create_dir_all(&resource_dir)?;
   let icon_target_path = resource_dir.join(filename);
 
   let icon_path = std::env::current_dir()?.join(path);
@@ -192,7 +192,7 @@ fn app_installer_output_path(
 
   let package_base_name = format!(
     "{}_{}_{}_{}",
-    settings.main_binary_name().replace(".exe", ""),
+    settings.product_name(),
     version,
     arch,
     language,
@@ -411,9 +411,9 @@ pub fn build_wix_app_installer(
   let output_path = settings.project_out_directory().join("wix").join(arch);
 
   if output_path.exists() {
-    remove_dir_all(&output_path)?;
+    fs::remove_dir_all(&output_path)?;
   }
-  create_dir_all(&output_path)?;
+  fs::create_dir_all(&output_path)?;
 
   let mut data = BTreeMap::new();
 
@@ -484,7 +484,7 @@ pub fn build_wix_app_installer(
     if license.ends_with(".rtf") {
       data.insert("license", to_json(license));
     } else {
-      let license_contents = read_to_string(license)?;
+      let license_contents = fs::read_to_string(license)?;
       let license_rtf = format!(
         r#"{{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1033{{\fonttbl{{\f0\fnil\fcharset0 Calibri;}}}}
 {{\*\generator Riched20 10.0.18362}}\viewkind4\uc1
@@ -629,7 +629,7 @@ pub fn build_wix_app_installer(
 
   if let Some(path) = custom_template_path {
     handlebars
-      .register_template_string("main.wxs", read_to_string(path)?)
+      .register_template_string("main.wxs", fs::read_to_string(path)?)
       .map_err(|e| e.to_string())
       .expect("Failed to setup custom handlebar template");
   } else {
@@ -660,7 +660,7 @@ pub fn build_wix_app_installer(
       .expect("Failed to setup Update Task handlebars");
     let temp_xml_path = output_path.join("update.xml");
     let update_content = skip_uac_task.render("update.xml", &data)?;
-    write(temp_xml_path, update_content)?;
+    fs::write(temp_xml_path, update_content)?;
 
     // Create the Powershell script to install the task
     let mut skip_uac_task_installer = Handlebars::new();
@@ -672,7 +672,7 @@ pub fn build_wix_app_installer(
       .expect("Failed to setup Update Task Installer handlebars");
     let temp_ps1_path = output_path.join("install-task.ps1");
     let install_script_content = skip_uac_task_installer.render("install-task.ps1", &data)?;
-    write(temp_ps1_path, install_script_content)?;
+    fs::write(temp_ps1_path, install_script_content)?;
 
     // Create the Powershell script to uninstall the task
     let mut skip_uac_task_uninstaller = Handlebars::new();
@@ -684,13 +684,13 @@ pub fn build_wix_app_installer(
       .expect("Failed to setup Update Task Uninstaller handlebars");
     let temp_ps1_path = output_path.join("uninstall-task.ps1");
     let install_script_content = skip_uac_task_uninstaller.render("uninstall-task.ps1", &data)?;
-    write(temp_ps1_path, install_script_content)?;
+    fs::write(temp_ps1_path, install_script_content)?;
 
     data.insert("enable_elevated_update_task", to_json(true));
   }
 
   let main_wxs_path = output_path.join("main.wxs");
-  write(main_wxs_path, handlebars.render("main.wxs", &data)?)?;
+  fs::write(main_wxs_path, handlebars.render("main.wxs", &data)?)?;
 
   let mut candle_inputs = vec![("main.wxs".into(), Vec::new())];
 
@@ -698,7 +698,7 @@ pub fn build_wix_app_installer(
   let extension_regex = Regex::new("\"http://schemas.microsoft.com/wix/(\\w+)\"")?;
   for fragment_path in fragment_paths {
     let fragment_path = current_dir.join(fragment_path);
-    let fragment = read_to_string(&fragment_path)?;
+    let fragment = fs::read_to_string(&fragment_path)?;
     let mut extensions = Vec::new();
     for cap in extension_regex.captures_iter(&fragment) {
       extensions.push(wix_toolset_path.join(format!("Wix{}.dll", &cap[1])));
@@ -734,7 +734,7 @@ pub fn build_wix_app_installer(
     });
 
     let locale_contents = match language_config.locale_path {
-      Some(p) => read_to_string(p)?,
+      Some(p) => fs::read_to_string(p)?,
       None => format!(
         r#"<WixLocalization Culture="{}" xmlns="http://schemas.microsoft.com/wix/2006/localization"></WixLocalization>"#,
         language.to_lowercase(),
@@ -786,7 +786,7 @@ pub fn build_wix_app_installer(
     let msi_output_path = output_path.join("output.msi");
     let msi_path =
       app_installer_output_path(settings, &language, settings.version_string(), updater)?;
-    create_dir_all(msi_path.parent().unwrap())?;
+    fs::create_dir_all(msi_path.parent().unwrap())?;
 
     log::info!(action = "Running"; "light to produce {}", display_path(&msi_path));
 
@@ -797,7 +797,7 @@ pub fn build_wix_app_installer(
       &(fragment_extensions.clone().into_iter().collect()),
       &msi_output_path,
     )?;
-    rename(&msi_output_path, &msi_path)?;
+    fs::rename(&msi_output_path, &msi_path)?;
 
     if settings.can_sign() {
       try_sign(&msi_path, settings)?;
diff --git a/tooling/bundler/src/bundle/windows/nsis.rs b/tooling/bundler/src/bundle/windows/nsis.rs
index 418d0de0f..c8a21acfa 100644
--- a/tooling/bundler/src/bundle/windows/nsis.rs
+++ b/tooling/bundler/src/bundle/windows/nsis.rs
@@ -22,7 +22,7 @@ use tauri_utils::config::{NSISInstallerMode, NsisCompression, WebviewInstallMode
 
 use std::{
   collections::{BTreeMap, HashMap},
-  fs::{create_dir_all, remove_dir_all, rename, write},
+  fs,
   path::{Path, PathBuf},
   process::Command,
 };
@@ -67,7 +67,7 @@ pub fn bundle_project(settings: &Settings, updater: bool) -> crate::Result<Vec<P
   let nsis_toolset_path = tauri_tools_path.join("NSIS");
 
   if !nsis_toolset_path.exists() {
-    create_dir_all(&nsis_toolset_path)?;
+    fs::create_dir_all(&nsis_toolset_path)?;
     get_and_extract_nsis(&nsis_toolset_path, &tauri_tools_path)?;
   } else if NSIS_REQUIRED_FILES
     .iter()
@@ -88,7 +88,7 @@ pub fn bundle_project(settings: &Settings, updater: bool) -> crate::Result<Vec<P
       log::warn!("NSIS directory contains mis-hashed files. Redownloading them.");
       for (path, url, hash, hash_algorithim) in mismatched {
         let data = download_and_verify(url, hash, *hash_algorithim)?;
-        write(nsis_toolset_path.join(path), data)?;
+        fs::write(nsis_toolset_path.join(path), data)?;
       }
     }
   }
@@ -105,7 +105,7 @@ fn get_and_extract_nsis(nsis_toolset_path: &Path, _tauri_tools_path: &Path) -> c
     let data = download_and_verify(NSIS_URL, NSIS_SHA1, HashAlgorithm::Sha1)?;
     log::info!("extracting NSIS");
     crate::bundle::windows::util::extract_zip(&data, _tauri_tools_path)?;
-    rename(_tauri_tools_path.join("nsis-3.08"), nsis_toolset_path)?;
+    fs::rename(_tauri_tools_path.join("nsis-3.08"), nsis_toolset_path)?;
   }
 
   let nsis_plugins = nsis_toolset_path.join("Plugins");
@@ -117,8 +117,8 @@ fn get_and_extract_nsis(nsis_toolset_path: &Path, _tauri_tools_path: &Path) -> c
   )?;
 
   let target_folder = nsis_plugins.join("x86-unicode");
-  create_dir_all(&target_folder)?;
-  write(target_folder.join("nsis_tauri_utils.dll"), data)?;
+  fs::create_dir_all(&target_folder)?;
+  fs::write(target_folder.join("nsis_tauri_utils.dll"), data)?;
 
   Ok(())
 }
@@ -164,9 +164,9 @@ fn build_nsis_app_installer(
 
   let output_path = settings.project_out_directory().join("nsis").join(arch);
   if output_path.exists() {
-    remove_dir_all(&output_path)?;
+    fs::remove_dir_all(&output_path)?;
   }
-  create_dir_all(&output_path)?;
+  fs::create_dir_all(&output_path)?;
 
   let mut data = BTreeMap::new();
 
@@ -475,7 +475,7 @@ fn build_nsis_app_installer(
 
   let package_base_name = format!(
     "{}_{}_{}-setup",
-    main_binary.name().replace(".exe", ""),
+    settings.product_name(),
     settings.version_string(),
     arch,
   );
@@ -490,7 +490,7 @@ fn build_nsis_app_installer(
     },
     package_base_name
   ));
-  create_dir_all(nsis_installer_path.parent().unwrap())?;
+  fs::create_dir_all(nsis_installer_path.parent().unwrap())?;
 
   log::info!(action = "Running"; "makensis.exe to produce {}", display_path(&nsis_installer_path));
 
@@ -513,7 +513,7 @@ fn build_nsis_app_installer(
     .piped()
     .context("error running makensis.exe")?;
 
-  rename(nsis_output_path, &nsis_installer_path)?;
+  fs::rename(nsis_output_path, &nsis_installer_path)?;
 
   if settings.can_sign() {
     try_sign(&nsis_installer_path, settings)?;
diff --git a/tooling/cli/Cargo.lock b/tooling/cli/Cargo.lock
index 9e379bcc4..4356c11eb 100644
--- a/tooling/cli/Cargo.lock
+++ b/tooling/cli/Cargo.lock
@@ -5002,7 +5002,6 @@ dependencies = [
  "dunce",
  "getrandom 0.2.12",
  "glob",
- "heck 0.5.0",
  "html5ever",
  "infer 0.15.0",
  "json-patch",
diff --git a/tooling/cli/Cargo.toml b/tooling/cli/Cargo.toml
index 124386836..a4418811d 100644
--- a/tooling/cli/Cargo.toml
+++ b/tooling/cli/Cargo.toml
@@ -117,6 +117,10 @@ native-tls = [
 native-tls-vendored = [ "native-tls", "tauri-bundler/native-tls-vendored" ]
 rustls = [ "tauri-bundler/rustls", "cargo-mobile2/rustls", "ureq/tls" ]
 
+# optimize flate2 on debug
+[profile.dev.package.miniz_oxide]
+opt-level = 3
+
 [profile.release-size-optimized]
 inherits = "release"
 codegen-units = 1
diff --git a/tooling/cli/src/interface/mod.rs b/tooling/cli/src/interface/mod.rs
index 29f5b9ae7..8979675cb 100644
--- a/tooling/cli/src/interface/mod.rs
+++ b/tooling/cli/src/interface/mod.rs
@@ -31,11 +31,7 @@ pub trait AppSettings {
     features: &[String],
   ) -> crate::Result<tauri_bundler::BundleSettings>;
   fn app_binary_path(&self, options: &Options) -> crate::Result<PathBuf>;
-  fn get_binaries(
-    &self,
-    config: &Config,
-    target: &str,
-  ) -> crate::Result<Vec<tauri_bundler::BundleBinary>>;
+  fn get_binaries(&self, target: &str) -> crate::Result<Vec<tauri_bundler::BundleBinary>>;
   fn app_name(&self) -> Option<String>;
   fn lib_name(&self) -> Option<String>;
 
@@ -61,7 +57,7 @@ pub trait AppSettings {
     SettingsBuilder::new()
       .package_settings(self.get_package_settings())
       .bundle_settings(self.get_bundle_settings(config, &enabled_features)?)
-      .binaries(self.get_binaries(config, &target)?)
+      .binaries(self.get_binaries(&target)?)
       .project_out_directory(out_dir)
       .target(target)
       .package_types(package_types)
diff --git a/tooling/cli/src/interface/rust.rs b/tooling/cli/src/interface/rust.rs
index b610e73d7..4668dcaec 100644
--- a/tooling/cli/src/interface/rust.rs
+++ b/tooling/cli/src/interface/rust.rs
@@ -16,7 +16,6 @@ use std::{
 
 use anyhow::Context;
 use glob::glob;
-use heck::ToKebabCase;
 use ignore::gitignore::{Gitignore, GitignoreBuilder};
 use notify::RecursiveMode;
 use notify_debouncer_mini::new_debouncer;
@@ -114,7 +113,6 @@ pub struct RustupTarget {
 pub struct Rust {
   app_settings: Arc<RustAppSettings>,
   config_features: Vec<String>,
-  product_name: Option<String>,
   available_targets: Option<Vec<RustupTarget>>,
 }
 
@@ -156,7 +154,6 @@ impl Interface for Rust {
     Ok(Self {
       app_settings: Arc::new(app_settings),
       config_features: config.build.features.clone().unwrap_or_default(),
-      product_name: config.product_name.clone(),
       available_targets: None,
     })
   }
@@ -169,7 +166,6 @@ impl Interface for Rust {
     desktop::build(
       options,
       &self.app_settings,
-      self.product_name.clone(),
       &mut self.available_targets,
       self.config_features.clone(),
     )?;
@@ -496,7 +492,6 @@ impl Rust {
       &mut self.available_targets,
       self.config_features.clone(),
       &self.app_settings,
-      self.product_name.clone(),
       on_exit,
     )
     .map(|c| Box::new(c) as Box<dyn DevProcess + Send>)
@@ -672,7 +667,7 @@ struct BinarySettings {
 #[serde(rename_all = "kebab-case")]
 pub struct CargoPackageSettings {
   /// the package's name.
-  pub name: Option<String>,
+  pub name: String,
   /// the package's version.
   pub version: Option<MaybeWorkspace<String>>,
   /// the package's description.
@@ -848,11 +843,7 @@ impl AppSettings for RustAppSettings {
   }
 
   fn app_binary_path(&self, options: &Options) -> crate::Result<PathBuf> {
-    let bin_name = self
-      .cargo_package_settings()
-      .name
-      .clone()
-      .expect("Cargo manifest must have the `package.name` field");
+    let bin_name = self.cargo_package_settings().name.clone();
 
     let out_dir = self
       .out_dir(options.target.clone(), get_profile_dir(options).to_string())
@@ -868,7 +859,7 @@ impl AppSettings for RustAppSettings {
     Ok(out_dir.join(bin_name).with_extension(binary_extension))
   }
 
-  fn get_binaries(&self, config: &Config, target: &str) -> crate::Result<Vec<BundleBinary>> {
+  fn get_binaries(&self, target: &str) -> crate::Result<Vec<BundleBinary>> {
     let mut binaries: Vec<BundleBinary> = vec![];
 
     let binary_extension: String = if target.contains("windows") {
@@ -878,35 +869,17 @@ impl AppSettings for RustAppSettings {
     }
     .into();
 
-    let target_os = target.split('-').nth(2).unwrap_or(std::env::consts::OS);
-
-    if let Some(bin) = &self.cargo_settings.bin {
+    if let Some(bins) = &self.cargo_settings.bin {
       let default_run = self
         .package_settings
         .default_run
         .clone()
         .unwrap_or_default();
-      for binary in bin {
-        binaries.push(
-          if Some(&binary.name) == self.cargo_package_settings.name.as_ref()
-            || binary.name.as_str() == default_run
-          {
-            BundleBinary::new(
-              format!(
-                "{}{}",
-                config.binary_name().unwrap_or_else(|| binary.name.clone()),
-                &binary_extension
-              ),
-              true,
-            )
-          } else {
-            BundleBinary::new(
-              format!("{}{}", binary.name.clone(), &binary_extension),
-              false,
-            )
-          }
-          .set_src_path(binary.path.clone()),
-        )
+      for bin in bins {
+        let name = format!("{}{}", bin.name, binary_extension);
+        let is_main =
+          bin.name == self.cargo_package_settings.name || bin.name.as_str() == default_run;
+        binaries.push(BundleBinary::with_path(name, is_main, bin.path.clone()))
       }
     }
 
@@ -930,38 +903,17 @@ impl AppSettings for RustAppSettings {
     }
 
     if let Some(default_run) = self.package_settings.default_run.as_ref() {
-      match binaries.iter_mut().find(|bin| bin.name() == default_run) {
-        Some(bin) => {
-          if let Some(bin_name) = config.binary_name() {
-            bin.set_name(bin_name);
-          }
-        }
-        None => {
-          binaries.push(BundleBinary::new(
-            format!(
-              "{}{}",
-              config
-                .binary_name()
-                .unwrap_or_else(|| default_run.to_string()),
-              &binary_extension
-            ),
-            true,
-          ));
-        }
+      if !binaries.iter_mut().any(|bin| bin.name() == default_run) {
+        binaries.push(BundleBinary::new(
+          format!("{}{}", default_run, binary_extension),
+          true,
+        ));
       }
     }
 
     match binaries.len() {
       0 => binaries.push(BundleBinary::new(
-        if target_os == "linux" {
-          self.package_settings.product_name.to_kebab_case()
-        } else {
-          format!(
-            "{}{}",
-            self.package_settings.product_name.clone(),
-            &binary_extension
-          )
-        },
+        format!("{}{}", self.cargo_package_settings.name, &binary_extension),
         true,
       )),
       1 => binaries.get_mut(0).unwrap().set_main(true),
@@ -1019,12 +971,10 @@ impl RustAppSettings {
       .and_then(|v| v.package);
 
     let package_settings = PackageSettings {
-      product_name: config.product_name.clone().unwrap_or_else(|| {
-        cargo_package_settings
-          .name
-          .clone()
-          .expect("Cargo manifest must have the `package.name` field")
-      }),
+      product_name: config
+        .product_name
+        .clone()
+        .unwrap_or_else(|| cargo_package_settings.name.clone()),
       version: config.version.clone().unwrap_or_else(|| {
         cargo_package_settings
           .version
diff --git a/tooling/cli/src/interface/rust/desktop.rs b/tooling/cli/src/interface/rust/desktop.rs
index 43dfaf4b2..f9a8440d1 100644
--- a/tooling/cli/src/interface/rust/desktop.rs
+++ b/tooling/cli/src/interface/rust/desktop.rs
@@ -6,15 +6,11 @@ use super::{
   get_profile_dir, AppSettings, DevProcess, ExitReason, Options, RustAppSettings, RustupTarget,
 };
 use crate::CommandExt;
-use tauri_utils::display_path;
 
 use anyhow::Context;
-use heck::ToKebabCase;
 use shared_child::SharedChild;
 use std::{
-  fs::rename,
   io::{BufReader, ErrorKind, Write},
-  path::{Path, PathBuf},
   process::{Command, ExitStatus, Stdio},
   sync::{
     atomic::{AtomicBool, Ordering},
@@ -70,16 +66,9 @@ pub fn run_dev<F: Fn(Option<i32>, ExitReason) + Send + Sync + 'static>(
   available_targets: &mut Option<Vec<RustupTarget>>,
   config_features: Vec<String>,
   app_settings: &RustAppSettings,
-  product_name: Option<String>,
   on_exit: F,
 ) -> crate::Result<impl DevProcess> {
   let bin_path = app_settings.app_binary_path(&options)?;
-  let target_os = options
-    .target
-    .as_ref()
-    .and_then(|t| t.split('-').nth(2))
-    .unwrap_or(std::env::consts::OS)
-    .replace("darwin", "macos");
 
   let manually_killed_app = Arc::new(AtomicBool::default());
   let manually_killed_app_ = manually_killed_app.clone();
@@ -92,8 +81,6 @@ pub fn run_dev<F: Fn(Option<i32>, ExitReason) + Send + Sync + 'static>(
     config_features,
     move |status, reason| {
       if status == Some(0) {
-        let bin_path =
-          rename_app(target_os, &bin_path, product_name.as_deref()).expect("failed to rename app");
         let mut app = Command::new(bin_path);
         app.stdout(os_pipe::dup_stdout().unwrap());
         app.stderr(os_pipe::dup_stderr().unwrap());
@@ -132,7 +119,6 @@ pub fn run_dev<F: Fn(Option<i32>, ExitReason) + Send + Sync + 'static>(
 pub fn build(
   options: Options,
   app_settings: &RustAppSettings,
-  product_name: Option<String>,
   available_targets: &mut Option<Vec<RustupTarget>>,
   config_features: Vec<String>,
 ) -> crate::Result<()> {
@@ -145,13 +131,6 @@ pub fn build(
     std::env::set_var("STATIC_VCRUNTIME", "true");
   }
 
-  let target_os = options
-    .target
-    .as_ref()
-    .and_then(|t| t.split('-').nth(2))
-    .unwrap_or(std::env::consts::OS)
-    .replace("darwin", "macos");
-
   if options.target == Some("universal-apple-darwin".into()) {
     std::fs::create_dir_all(out_dir).with_context(|| "failed to create project out directory")?;
 
@@ -185,8 +164,6 @@ pub fn build(
       .with_context(|| "failed to build app")?;
   }
 
-  rename_app(target_os, &bin_path, product_name.as_deref())?;
-
   Ok(())
 }
 
@@ -388,37 +365,6 @@ fn validate_target(
   Ok(())
 }
 
-fn rename_app(
-  target_os: String,
-  bin_path: &Path,
-  product_name: Option<&str>,
-) -> crate::Result<PathBuf> {
-  if let Some(product_name) = product_name {
-    let product_name = if target_os == "linux" {
-      product_name.to_kebab_case()
-    } else {
-      product_name.into()
-    };
-
-    let product_path = bin_path
-      .parent()
-      .unwrap()
-      .join(product_name)
-      .with_extension(bin_path.extension().unwrap_or_default());
-
-    rename(bin_path, &product_path).with_context(|| {
-      format!(
-        "failed to rename `{}` to `{}`",
-        display_path(bin_path),
-        display_path(&product_path),
-      )
-    })?;
-    Ok(product_path)
-  } else {
-    Ok(bin_path.to_path_buf())
-  }
-}
-
 // taken from https://github.com/rust-lang/cargo/blob/78b10d4e611ab0721fc3aeaf0edd5dd8f4fdc372/src/cargo/core/shell.rs#L514
 #[cfg(unix)]
 mod terminal {
