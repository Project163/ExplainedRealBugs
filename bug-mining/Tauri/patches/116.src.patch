diff --git a/.changes/runtime-create-proxy.md b/.changes/runtime-create-proxy.md
new file mode 100644
index 000000000..ebc725684
--- /dev/null
+++ b/.changes/runtime-create-proxy.md
@@ -0,0 +1,6 @@
+---
+"tauri-runtime": minor
+"tauri-runtime-wry": minor
+---
+
+Added `create_proxy` to the `Runtime` and `RuntimeHandle` traits.
diff --git a/.changes/runtime-user-event.md b/.changes/runtime-user-event.md
new file mode 100644
index 000000000..b88273faf
--- /dev/null
+++ b/.changes/runtime-user-event.md
@@ -0,0 +1,6 @@
+---
+"tauri-runtime": minor
+"tauri-runtime-wry": minor
+---
+
+Allow specifying a user event type for the event loop message.
diff --git a/.changes/rust-tauri-events.md b/.changes/rust-tauri-events.md
new file mode 100644
index 000000000..62ba67563
--- /dev/null
+++ b/.changes/rust-tauri-events.md
@@ -0,0 +1,5 @@
+---
+"tauri": minor
+---
+
+**Breaking change:** The `tauri://` events are no longer emitted to listeners using `Window::listen`. Use the `App::run` closure, `Window::on_window_event` and `Window::on_menu_event` instead.
diff --git a/.changes/updater-events.md b/.changes/updater-events.md
new file mode 100644
index 000000000..73e98f62b
--- /dev/null
+++ b/.changes/updater-events.md
@@ -0,0 +1,5 @@
+---
+"tauri": minor
+---
+
+Send updater events to the `App::run` closure.
diff --git a/core/tauri-runtime-wry/src/lib.rs b/core/tauri-runtime-wry/src/lib.rs
index 684ae1d99..add60d7fc 100644
--- a/core/tauri-runtime-wry/src/lib.rs
+++ b/core/tauri-runtime-wry/src/lib.rs
@@ -16,8 +16,9 @@ use tauri_runtime::{
     dpi::{LogicalPosition, LogicalSize, PhysicalPosition, PhysicalSize, Position, Size},
     DetachedWindow, FileDropEvent, JsEventListenerKey, PendingWindow, WindowEvent,
   },
-  ClipboardManager, Dispatch, Error, ExitRequestedEventAction, GlobalShortcutManager, Result,
-  RunEvent, RunIteration, Runtime, RuntimeHandle, UserAttentionType, WindowIcon,
+  ClipboardManager, Dispatch, Error, EventLoopProxy, ExitRequestedEventAction,
+  GlobalShortcutManager, Result, RunEvent, RunIteration, Runtime, RuntimeHandle, UserAttentionType,
+  UserEvent, WindowIcon,
 };
 
 use tauri_runtime::window::MenuEvent;
@@ -49,7 +50,9 @@ use wry::{
       Position as WryPosition, Size as WrySize,
     },
     event::{Event, StartCause, WindowEvent as WryWindowEvent},
-    event_loop::{ControlFlow, EventLoop, EventLoopProxy, EventLoopWindowTarget},
+    event_loop::{
+      ControlFlow, EventLoop, EventLoopProxy as WryEventLoopProxy, EventLoopWindowTarget,
+    },
     global_shortcut::{GlobalShortcut, ShortcutManager as WryShortcutManager},
     menu::{
       CustomMenuItem as WryCustomMenuItem, MenuBar, MenuId as WryMenuId, MenuItem as WryMenuItem,
@@ -124,7 +127,7 @@ macro_rules! window_getter {
   }};
 }
 
-fn send_user_message(context: &Context, message: Message) -> Result<()> {
+fn send_user_message<T: UserEvent>(context: &Context<T>, message: Message<T>) -> Result<()> {
   if current_thread().id() == context.main_thread_id {
     handle_user_message(
       &context.main_thread.window_target,
@@ -150,17 +153,17 @@ fn send_user_message(context: &Context, message: Message) -> Result<()> {
 }
 
 #[derive(Clone)]
-struct Context {
+struct Context<T: UserEvent> {
   main_thread_id: ThreadId,
-  proxy: EventLoopProxy<Message>,
+  proxy: WryEventLoopProxy<Message<T>>,
   window_event_listeners: WindowEventListeners,
   menu_event_listeners: MenuEventListeners,
-  main_thread: DispatcherMainThreadContext,
+  main_thread: DispatcherMainThreadContext<T>,
 }
 
 #[derive(Debug, Clone)]
-struct DispatcherMainThreadContext {
-  window_target: EventLoopWindowTarget<Message>,
+struct DispatcherMainThreadContext<T: UserEvent> {
+  window_target: EventLoopWindowTarget<Message<T>>,
   web_context: WebContextStore,
   global_shortcut_manager: Arc<Mutex<WryShortcutManager>>,
   clipboard_manager: Arc<Mutex<Clipboard>>,
@@ -171,9 +174,9 @@ struct DispatcherMainThreadContext {
 
 // SAFETY: we ensure this type is only used on the main thread.
 #[allow(clippy::non_send_fields_in_send_ty)]
-unsafe impl Send for DispatcherMainThreadContext {}
+unsafe impl<T: UserEvent> Send for DispatcherMainThreadContext<T> {}
 
-impl fmt::Debug for Context {
+impl<T: UserEvent> fmt::Debug for Context<T> {
   fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
     f.debug_struct("Context")
       .field("main_thread_id", &self.main_thread_id)
@@ -377,17 +380,17 @@ unsafe impl Send for GlobalShortcutWrapper {}
 
 /// Wrapper around [`WryShortcutManager`].
 #[derive(Clone)]
-pub struct GlobalShortcutManagerHandle {
-  context: Context,
+pub struct GlobalShortcutManagerHandle<T: UserEvent> {
+  context: Context<T>,
   shortcuts: Arc<Mutex<HashMap<String, (AcceleratorId, GlobalShortcutWrapper)>>>,
   listeners: GlobalShortcutListeners,
 }
 
 // SAFETY: this is safe since the `Context` usage is guarded on `send_user_message`.
 #[allow(clippy::non_send_fields_in_send_ty)]
-unsafe impl Sync for GlobalShortcutManagerHandle {}
+unsafe impl<T: UserEvent> Sync for GlobalShortcutManagerHandle<T> {}
 
-impl fmt::Debug for GlobalShortcutManagerHandle {
+impl<T: UserEvent> fmt::Debug for GlobalShortcutManagerHandle<T> {
   fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
     f.debug_struct("GlobalShortcutManagerHandle")
       .field("context", &self.context)
@@ -396,7 +399,7 @@ impl fmt::Debug for GlobalShortcutManagerHandle {
   }
 }
 
-impl GlobalShortcutManager for GlobalShortcutManagerHandle {
+impl<T: UserEvent> GlobalShortcutManager for GlobalShortcutManagerHandle<T> {
   fn is_registered(&self, accelerator: &str) -> Result<bool> {
     let (tx, rx) = channel();
     getter!(
@@ -456,21 +459,21 @@ impl GlobalShortcutManager for GlobalShortcutManagerHandle {
 }
 
 #[derive(Debug, Clone)]
-pub struct ClipboardManagerWrapper {
-  context: Context,
+pub struct ClipboardManagerWrapper<T: UserEvent> {
+  context: Context<T>,
 }
 
 // SAFETY: this is safe since the `Context` usage is guarded on `send_user_message`.
 #[allow(clippy::non_send_fields_in_send_ty)]
-unsafe impl Sync for ClipboardManagerWrapper {}
+unsafe impl<T: UserEvent> Sync for ClipboardManagerWrapper<T> {}
 
-impl ClipboardManager for ClipboardManagerWrapper {
+impl<T: UserEvent> ClipboardManager for ClipboardManagerWrapper<T> {
   fn read_text(&self) -> Result<Option<String>> {
     let (tx, rx) = channel();
     getter!(self, rx, Message::Clipboard(ClipboardMessage::ReadText(tx)))
   }
 
-  fn write_text<T: Into<String>>(&mut self, text: T) -> Result<()> {
+  fn write_text<V: Into<String>>(&mut self, text: V) -> Result<()> {
     let (tx, rx) = channel();
     getter!(
       self,
@@ -987,27 +990,27 @@ pub enum ClipboardMessage {
   ReadText(Sender<Option<String>>),
 }
 
-pub enum Message {
+pub type CreateWebviewClosure<T> = Box<
+  dyn FnOnce(&EventLoopWindowTarget<Message<T>>, &WebContextStore) -> Result<WindowWrapper> + Send,
+>;
+
+pub enum Message<T: 'static> {
   Task(Box<dyn FnOnce() + Send>),
   Window(WindowId, WindowMessage),
   Webview(WindowId, WebviewMessage),
   #[cfg(feature = "system-tray")]
   Tray(TrayMessage),
-  CreateWebview(
-    Box<
-      dyn FnOnce(&EventLoopWindowTarget<Message>, &WebContextStore) -> Result<WindowWrapper> + Send,
-    >,
-    Sender<WindowId>,
-  ),
+  CreateWebview(CreateWebviewClosure<T>, Sender<WindowId>),
   CreateWindow(
     Box<dyn FnOnce() -> (String, WryWindowBuilder) + Send>,
     Sender<Result<Weak<Window>>>,
   ),
   GlobalShortcut(GlobalShortcutMessage),
   Clipboard(ClipboardMessage),
+  UserEvent(T),
 }
 
-impl Clone for Message {
+impl<T: UserEvent> Clone for Message<T> {
   fn clone(&self) -> Self {
     match self {
       Self::Window(i, m) => Self::Window(*i, m.clone()),
@@ -1016,6 +1019,7 @@ impl Clone for Message {
       Self::Tray(m) => Self::Tray(m.clone()),
       Self::GlobalShortcut(m) => Self::GlobalShortcut(m.clone()),
       Self::Clipboard(m) => Self::Clipboard(m.clone()),
+      Self::UserEvent(t) => Self::UserEvent(t.clone()),
       _ => unimplemented!(),
     }
   }
@@ -1023,17 +1027,17 @@ impl Clone for Message {
 
 /// The Tauri [`Dispatch`] for [`Wry`].
 #[derive(Debug, Clone)]
-pub struct WryDispatcher {
+pub struct WryDispatcher<T: UserEvent> {
   window_id: WindowId,
-  context: Context,
+  context: Context<T>,
 }
 
 // SAFETY: this is safe since the `Context` usage is guarded on `send_user_message`.
 #[allow(clippy::non_send_fields_in_send_ty)]
-unsafe impl Sync for WryDispatcher {}
+unsafe impl<T: UserEvent> Sync for WryDispatcher<T> {}
 
-impl Dispatch for WryDispatcher {
-  type Runtime = Wry;
+impl<T: UserEvent> Dispatch<T> for WryDispatcher<T> {
+  type Runtime = Wry<T>;
   type WindowBuilder = WindowBuilderWrapper;
 
   fn run_on_main_thread<F: FnOnce() + Send + 'static>(&self, f: F) -> Result<()> {
@@ -1192,8 +1196,8 @@ impl Dispatch for WryDispatcher {
   // Note that this must be called from a separate thread, otherwise the channel will introduce a deadlock.
   fn create_window(
     &mut self,
-    pending: PendingWindow<Self::Runtime>,
-  ) -> Result<DetachedWindow<Self::Runtime>> {
+    pending: PendingWindow<T, Self::Runtime>,
+  ) -> Result<DetachedWindow<T, Self::Runtime>> {
     let (tx, rx) = channel();
     let label = pending.label.clone();
     let menu_ids = pending.menu_ids.clone();
@@ -1451,14 +1455,26 @@ pub struct WindowWrapper {
   menu_items: Option<HashMap<u16, WryCustomMenuItem>>,
 }
 
+#[derive(Debug, Clone)]
+pub struct EventProxy<T: UserEvent>(WryEventLoopProxy<Message<T>>);
+
+impl<T: UserEvent> EventLoopProxy<T> for EventProxy<T> {
+  fn send_event(&self, event: T) -> Result<()> {
+    self
+      .0
+      .send_event(Message::UserEvent(event))
+      .map_err(|_| Error::EventLoopClosed)
+  }
+}
+
 /// A Tauri [`Runtime`] wrapper around wry.
-pub struct Wry {
+pub struct Wry<T: UserEvent> {
   main_thread_id: ThreadId,
   global_shortcut_manager: Arc<Mutex<WryShortcutManager>>,
-  global_shortcut_manager_handle: GlobalShortcutManagerHandle,
+  global_shortcut_manager_handle: GlobalShortcutManagerHandle<T>,
   clipboard_manager: Arc<Mutex<Clipboard>>,
-  clipboard_manager_handle: ClipboardManagerWrapper,
-  event_loop: EventLoop<Message>,
+  clipboard_manager_handle: ClipboardManagerWrapper<T>,
+  event_loop: EventLoop<Message<T>>,
   windows: Arc<Mutex<HashMap<WindowId, WindowWrapper>>>,
   web_context: WebContextStore,
   window_event_listeners: WindowEventListeners,
@@ -1467,7 +1483,7 @@ pub struct Wry {
   tray_context: TrayContext,
 }
 
-impl fmt::Debug for Wry {
+impl<T: UserEvent> fmt::Debug for Wry<T> {
   fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
     let mut d = f.debug_struct("Wry");
     d.field("main_thread_id", &self.main_thread_id)
@@ -1489,15 +1505,15 @@ impl fmt::Debug for Wry {
 
 /// A handle to the Wry runtime.
 #[derive(Debug, Clone)]
-pub struct WryHandle {
-  context: Context,
+pub struct WryHandle<T: UserEvent> {
+  context: Context<T>,
 }
 
 // SAFETY: this is safe since the `Context` usage is guarded on `send_user_message`.
 #[allow(clippy::non_send_fields_in_send_ty)]
-unsafe impl Sync for WryHandle {}
+unsafe impl<T: UserEvent> Sync for WryHandle<T> {}
 
-impl WryHandle {
+impl<T: UserEvent> WryHandle<T> {
   /// Creates a new tao window using a callback, and returns its window id.
   pub fn create_tao_window<F: FnOnce() -> (String, WryWindowBuilder) + Send + 'static>(
     &self,
@@ -1509,7 +1525,7 @@ impl WryHandle {
   }
 
   /// Send a message to the event loop.
-  pub fn send_event(&self, message: Message) -> Result<()> {
+  pub fn send_event(&self, message: Message<T>) -> Result<()> {
     self
       .context
       .proxy
@@ -1519,15 +1535,19 @@ impl WryHandle {
   }
 }
 
-impl RuntimeHandle for WryHandle {
-  type Runtime = Wry;
+impl<T: UserEvent> RuntimeHandle<T> for WryHandle<T> {
+  type Runtime = Wry<T>;
+
+  fn create_proxy(&self) -> EventProxy<T> {
+    EventProxy(self.context.proxy.clone())
+  }
 
   // Creates a window by dispatching a message to the event loop.
   // Note that this must be called from a separate thread, otherwise the channel will introduce a deadlock.
   fn create_window(
     &self,
-    pending: PendingWindow<Self::Runtime>,
-  ) -> Result<DetachedWindow<Self::Runtime>> {
+    pending: PendingWindow<T, Self::Runtime>,
+  ) -> Result<DetachedWindow<T, Self::Runtime>> {
     let (tx, rx) = channel();
     let label = pending.label.clone();
     let menu_ids = pending.menu_ids.clone();
@@ -1567,8 +1587,8 @@ impl RuntimeHandle for WryHandle {
   }
 }
 
-impl Wry {
-  fn init(event_loop: EventLoop<Message>) -> Result<Self> {
+impl<T: UserEvent> Wry<T> {
+  fn init(event_loop: EventLoop<Message<T>>) -> Result<Self> {
     let proxy = event_loop.create_proxy();
     let main_thread_id = current_thread().id();
     let web_context = WebContextStore::default();
@@ -1623,16 +1643,17 @@ impl Wry {
   }
 }
 
-impl Runtime for Wry {
-  type Dispatcher = WryDispatcher;
-  type Handle = WryHandle;
-  type GlobalShortcutManager = GlobalShortcutManagerHandle;
-  type ClipboardManager = ClipboardManagerWrapper;
+impl<T: UserEvent> Runtime<T> for Wry<T> {
+  type Dispatcher = WryDispatcher<T>;
+  type Handle = WryHandle<T>;
+  type GlobalShortcutManager = GlobalShortcutManagerHandle<T>;
+  type ClipboardManager = ClipboardManagerWrapper<T>;
   #[cfg(feature = "system-tray")]
-  type TrayHandler = SystemTrayHandle;
+  type TrayHandler = SystemTrayHandle<T>;
+  type EventLoopProxy = EventProxy<T>;
 
   fn new() -> Result<Self> {
-    let event_loop = EventLoop::<Message>::with_user_event();
+    let event_loop = EventLoop::<Message<T>>::with_user_event();
     Self::init(event_loop)
   }
 
@@ -1642,10 +1663,14 @@ impl Runtime for Wry {
     use wry::application::platform::unix::EventLoopExtUnix;
     #[cfg(windows)]
     use wry::application::platform::windows::EventLoopExtWindows;
-    let event_loop = EventLoop::<Message>::new_any_thread();
+    let event_loop = EventLoop::<Message<T>>::new_any_thread();
     Self::init(event_loop)
   }
 
+  fn create_proxy(&self) -> EventProxy<T> {
+    EventProxy(self.event_loop.create_proxy())
+  }
+
   fn handle(&self) -> Self::Handle {
     WryHandle {
       context: Context {
@@ -1674,7 +1699,7 @@ impl Runtime for Wry {
     self.clipboard_manager_handle.clone()
   }
 
-  fn create_window(&self, pending: PendingWindow<Self>) -> Result<DetachedWindow<Self>> {
+  fn create_window(&self, pending: PendingWindow<T, Self>) -> Result<DetachedWindow<T, Self>> {
     let label = pending.label.clone();
     let menu_ids = pending.menu_ids.clone();
     let js_event_listeners = pending.js_event_listeners.clone();
@@ -1833,7 +1858,7 @@ impl Runtime for Wry {
       });
   }
 
-  fn run_iteration<F: FnMut(RunEvent) + 'static>(&mut self, mut callback: F) -> RunIteration {
+  fn run_iteration<F: FnMut(RunEvent<T>) + 'static>(&mut self, mut callback: F) -> RunIteration {
     use wry::application::platform::run_return::EventLoopExtRunReturn;
     let windows = self.windows.clone();
     let web_context = &self.web_context;
@@ -1876,7 +1901,7 @@ impl Runtime for Wry {
     iteration
   }
 
-  fn run<F: FnMut(RunEvent) + 'static>(self, mut callback: F) {
+  fn run<F: FnMut(RunEvent<T>) + 'static>(self, mut callback: F) {
     let windows = self.windows.clone();
     let web_context = self.web_context;
     let window_event_listeners = self.window_event_listeners.clone();
@@ -1909,12 +1934,12 @@ impl Runtime for Wry {
   }
 }
 
-pub struct EventLoopIterationContext<'a> {
-  callback: &'a mut (dyn FnMut(RunEvent) + 'static),
+pub struct EventLoopIterationContext<'a, T: UserEvent> {
+  callback: &'a mut (dyn FnMut(RunEvent<T>) + 'static),
   windows: Arc<Mutex<HashMap<WindowId, WindowWrapper>>>,
   window_event_listeners: &'a WindowEventListeners,
   global_shortcut_manager: Arc<Mutex<WryShortcutManager>>,
-  global_shortcut_manager_handle: &'a GlobalShortcutManagerHandle,
+  global_shortcut_manager_handle: &'a GlobalShortcutManagerHandle<T>,
   clipboard_manager: Arc<Mutex<Clipboard>>,
   menu_event_listeners: &'a MenuEventListeners,
   #[cfg(feature = "system-tray")]
@@ -1931,9 +1956,9 @@ struct UserMessageContext<'a> {
   tray_context: &'a TrayContext,
 }
 
-fn handle_user_message(
-  event_loop: &EventLoopWindowTarget<Message>,
-  message: Message,
+fn handle_user_message<T: UserEvent>(
+  event_loop: &EventLoopWindowTarget<Message<T>>,
+  message: Message<T>,
   context: UserMessageContext<'_>,
   web_context: &WebContextStore,
 ) -> RunIteration {
@@ -2256,6 +2281,7 @@ fn handle_user_message(
         .send(clipboard_manager.lock().unwrap().read_text())
         .unwrap(),
     },
+    Message::UserEvent(_) => (),
   }
 
   let it = RunIteration {
@@ -2264,11 +2290,11 @@ fn handle_user_message(
   it
 }
 
-fn handle_event_loop(
-  event: Event<'_, Message>,
-  event_loop: &EventLoopWindowTarget<Message>,
+fn handle_event_loop<T: UserEvent>(
+  event: Event<'_, Message<T>>,
+  event_loop: &EventLoopWindowTarget<Message<T>>,
   control_flow: &mut ControlFlow,
-  context: EventLoopIterationContext<'_>,
+  context: EventLoopIterationContext<'_, T>,
   web_context: &WebContextStore,
 ) -> RunIteration {
   let EventLoopIterationContext {
@@ -2429,8 +2455,8 @@ fn handle_event_loop(
         _ => {}
       }
     }
-    Event::UserEvent(message) => {
-      if let Message::Window(id, WindowMessage::Close) = message {
+    Event::UserEvent(message) => match message {
+      Message::Window(id, WindowMessage::Close) => {
         on_window_close(
           callback,
           id,
@@ -2440,7 +2466,9 @@ fn handle_event_loop(
           window_event_listeners,
           menu_event_listeners.clone(),
         );
-      } else {
+      }
+      Message::UserEvent(t) => callback(RunEvent::UserEvent(t)),
+      message => {
         return handle_user_message(
           event_loop,
           message,
@@ -2456,7 +2484,7 @@ fn handle_event_loop(
           web_context,
         );
       }
-    }
+    },
     _ => (),
   }
 
@@ -2466,8 +2494,8 @@ fn handle_event_loop(
   it
 }
 
-fn on_close_requested<'a>(
-  callback: &'a mut (dyn FnMut(RunEvent) + 'static),
+fn on_close_requested<'a, T: UserEvent>(
+  callback: &'a mut (dyn FnMut(RunEvent<T>) + 'static),
   window_id: WindowId,
   windows: Arc<Mutex<HashMap<WindowId, WindowWrapper>>>,
   control_flow: &mut ControlFlow,
@@ -2515,8 +2543,8 @@ fn on_close_requested<'a>(
   }
 }
 
-fn on_window_close<'a>(
-  callback: &'a mut (dyn FnMut(RunEvent) + 'static),
+fn on_window_close<'a, T: UserEvent>(
+  callback: &'a mut (dyn FnMut(RunEvent<T>) + 'static),
   window_id: WindowId,
   mut windows: MutexGuard<'a, HashMap<WindowId, WindowWrapper>>,
   control_flow: &mut ControlFlow,
@@ -2612,11 +2640,11 @@ fn to_wry_menu(
   wry_menu
 }
 
-fn create_webview(
-  event_loop: &EventLoopWindowTarget<Message>,
+fn create_webview<T: UserEvent>(
+  event_loop: &EventLoopWindowTarget<Message<T>>,
   web_context: &WebContextStore,
-  context: Context,
-  pending: PendingWindow<Wry>,
+  context: Context<T>,
+  pending: PendingWindow<T, Wry<T>>,
 ) -> Result<WindowWrapper> {
   #[allow(unused_mut)]
   let PendingWindow {
@@ -2733,12 +2761,12 @@ fn create_webview(
 }
 
 /// Create a wry ipc handler from a tauri ipc handler.
-fn create_ipc_handler(
-  context: Context,
+fn create_ipc_handler<T: UserEvent>(
+  context: Context<T>,
   label: String,
   menu_ids: Arc<Mutex<HashMap<MenuHash, MenuId>>>,
   js_event_listeners: Arc<Mutex<HashMap<JsEventListenerKey, HashSet<u64>>>>,
-  handler: WebviewIpcHandler<Wry>,
+  handler: WebviewIpcHandler<T, Wry<T>>,
 ) -> Box<dyn Fn(&Window, String) + 'static> {
   Box::new(move |window, request| {
     handler(
@@ -2757,8 +2785,8 @@ fn create_ipc_handler(
 }
 
 /// Create a wry file drop handler.
-fn create_file_drop_handler(
-  context: &Context,
+fn create_file_drop_handler<T: UserEvent>(
+  context: &Context<T>,
 ) -> Box<dyn Fn(&Window, WryFileDropEvent) -> bool + 'static> {
   let window_event_listeners = context.window_event_listeners.clone();
   Box::new(move |window, event| {
diff --git a/core/tauri-runtime-wry/src/system_tray.rs b/core/tauri-runtime-wry/src/system_tray.rs
index e38268d42..568c08433 100644
--- a/core/tauri-runtime-wry/src/system_tray.rs
+++ b/core/tauri-runtime-wry/src/system_tray.rs
@@ -22,7 +22,7 @@ pub use wry::application::platform::macos::CustomMenuItemExtMacOS;
 
 use crate::{Error, Message, Result, TrayMessage};
 
-use tauri_runtime::menu::MenuHash;
+use tauri_runtime::{menu::MenuHash, UserEvent};
 
 use uuid::Uuid;
 
@@ -36,11 +36,11 @@ pub type SystemTrayEventListeners = Arc<Mutex<HashMap<Uuid, SystemTrayEventHandl
 pub type SystemTrayItems = Arc<Mutex<HashMap<u16, WryCustomMenuItem>>>;
 
 #[derive(Debug, Clone)]
-pub struct SystemTrayHandle {
-  pub(crate) proxy: EventLoopProxy<super::Message>,
+pub struct SystemTrayHandle<T: UserEvent> {
+  pub(crate) proxy: EventLoopProxy<super::Message<T>>,
 }
 
-impl TrayHandle for SystemTrayHandle {
+impl<T: UserEvent> TrayHandle for SystemTrayHandle<T> {
   fn set_icon(&self, icon: TrayIcon) -> Result<()> {
     self
       .proxy
diff --git a/core/tauri-runtime/src/lib.rs b/core/tauri-runtime/src/lib.rs
index 954155b70..ba91331e5 100644
--- a/core/tauri-runtime/src/lib.rs
+++ b/core/tauri-runtime/src/lib.rs
@@ -140,6 +140,8 @@ pub enum Error {
   InvalidMethod(#[from] InvalidMethod),
   #[error("Infallible error, something went really wrong: {0}")]
   Infallible(#[from] std::convert::Infallible),
+  #[error("the event loop has been closed")]
+  EventLoopClosed,
 }
 
 /// Result type.
@@ -192,9 +194,14 @@ impl TrayIcon {
   }
 }
 
+/// A type that can be used as an user event.
+pub trait UserEvent: Debug + Clone + Send + 'static {}
+
+impl<T: Debug + Clone + Send + 'static> UserEvent for T {}
+
 /// Event triggered on the event loop run.
 #[non_exhaustive]
-pub enum RunEvent {
+pub enum RunEvent<T: UserEvent> {
   /// Event loop is exiting.
   Exit,
   /// Event loop is about to exit
@@ -220,6 +227,8 @@ pub enum RunEvent {
   ///
   /// This event is useful as a place to put your code that should be run after all state-changing events have been handled and you want to do stuff (updating state, performing calculations, etc) that happens as the “main body” of your event loop.
   MainEventsCleared,
+  /// A custom event defined by the user.
+  UserEvent(T),
 }
 
 /// Action to take when the event loop is about to exit
@@ -267,13 +276,17 @@ pub enum ActivationPolicy {
 }
 
 /// A [`Send`] handle to the runtime.
-pub trait RuntimeHandle: Debug + Clone + Send + Sync + Sized + 'static {
-  type Runtime: Runtime<Handle = Self>;
+pub trait RuntimeHandle<T: UserEvent>: Debug + Clone + Send + Sync + Sized + 'static {
+  type Runtime: Runtime<T, Handle = Self>;
+
+  /// Creates an `EventLoopProxy` that can be used to dispatch user events to the main event loop.
+  fn create_proxy(&self) -> <Self::Runtime as Runtime<T>>::EventLoopProxy;
+
   /// Create a new webview window.
   fn create_window(
     &self,
-    pending: PendingWindow<Self::Runtime>,
-  ) -> crate::Result<DetachedWindow<Self::Runtime>>;
+    pending: PendingWindow<T, Self::Runtime>,
+  ) -> crate::Result<DetachedWindow<T, Self::Runtime>>;
 
   /// Run a task on the main thread.
   fn run_on_main_thread<F: FnOnce() + Send + 'static>(&self, f: F) -> crate::Result<()>;
@@ -310,12 +323,16 @@ pub trait ClipboardManager: Debug + Clone + Send + Sync {
   fn read_text(&self) -> Result<Option<String>>;
 }
 
+pub trait EventLoopProxy<T: UserEvent>: Debug + Clone + Send + Sync {
+  fn send_event(&self, event: T) -> Result<()>;
+}
+
 /// The webview runtime interface.
-pub trait Runtime: Debug + Sized + 'static {
+pub trait Runtime<T: UserEvent>: Debug + Sized + 'static {
   /// The message dispatcher.
-  type Dispatcher: Dispatch<Runtime = Self>;
+  type Dispatcher: Dispatch<T, Runtime = Self>;
   /// The runtime handle type.
-  type Handle: RuntimeHandle<Runtime = Self>;
+  type Handle: RuntimeHandle<T, Runtime = Self>;
   /// The global shortcut manager type.
   type GlobalShortcutManager: GlobalShortcutManager;
   /// The clipboard manager type.
@@ -323,6 +340,8 @@ pub trait Runtime: Debug + Sized + 'static {
   /// The tray handler type.
   #[cfg(feature = "system-tray")]
   type TrayHandler: menu::TrayHandle;
+  /// The proxy type.
+  type EventLoopProxy: EventLoopProxy<T>;
 
   /// Creates a new webview runtime. Must be used on the main thread.
   fn new() -> crate::Result<Self>;
@@ -332,6 +351,9 @@ pub trait Runtime: Debug + Sized + 'static {
   #[cfg_attr(doc_cfg, doc(cfg(any(windows, target_os = "linux"))))]
   fn new_any_thread() -> crate::Result<Self>;
 
+  /// Creates an `EventLoopProxy` that can be used to dispatch user events to the main event loop.
+  fn create_proxy(&self) -> Self::EventLoopProxy;
+
   /// Gets a runtime handle.
   fn handle(&self) -> Self::Handle;
 
@@ -342,7 +364,10 @@ pub trait Runtime: Debug + Sized + 'static {
   fn clipboard_manager(&self) -> Self::ClipboardManager;
 
   /// Create a new webview window.
-  fn create_window(&self, pending: PendingWindow<Self>) -> crate::Result<DetachedWindow<Self>>;
+  fn create_window(
+    &self,
+    pending: PendingWindow<T, Self>,
+  ) -> crate::Result<DetachedWindow<T, Self>>;
 
   /// Adds the icon to the system tray with the specified menu items.
   #[cfg(feature = "system-tray")]
@@ -360,16 +385,16 @@ pub trait Runtime: Debug + Sized + 'static {
   fn set_activation_policy(&mut self, activation_policy: ActivationPolicy);
 
   /// Runs the one step of the webview runtime event loop and returns control flow to the caller.
-  fn run_iteration<F: Fn(RunEvent) + 'static>(&mut self, callback: F) -> RunIteration;
+  fn run_iteration<F: Fn(RunEvent<T>) + 'static>(&mut self, callback: F) -> RunIteration;
 
   /// Run the webview runtime.
-  fn run<F: FnMut(RunEvent) + 'static>(self, callback: F);
+  fn run<F: FnMut(RunEvent<T>) + 'static>(self, callback: F);
 }
 
 /// Webview dispatcher. A thread-safe handle to the webview API.
-pub trait Dispatch: Debug + Clone + Send + Sync + Sized + 'static {
+pub trait Dispatch<T: UserEvent>: Debug + Clone + Send + Sync + Sized + 'static {
   /// The runtime this [`Dispatch`] runs under.
-  type Runtime: Runtime;
+  type Runtime: Runtime<T>;
 
   /// The winoow builder type.
   type WindowBuilder: WindowBuilder;
@@ -472,8 +497,8 @@ pub trait Dispatch: Debug + Clone + Send + Sync + Sized + 'static {
   /// Create a new webview window.
   fn create_window(
     &mut self,
-    pending: PendingWindow<Self::Runtime>,
-  ) -> crate::Result<DetachedWindow<Self::Runtime>>;
+    pending: PendingWindow<T, Self::Runtime>,
+  ) -> crate::Result<DetachedWindow<T, Self::Runtime>>;
 
   /// Updates the window resizable flag.
   fn set_resizable(&self, resizable: bool) -> crate::Result<()>;
diff --git a/core/tauri-runtime/src/webview.rs b/core/tauri-runtime/src/webview.rs
index 5ee462f42..6409b4b58 100644
--- a/core/tauri-runtime/src/webview.rs
+++ b/core/tauri-runtime/src/webview.rs
@@ -185,4 +185,4 @@ pub trait WindowBuilder: WindowBuilderBase {
 }
 
 /// IPC handler.
-pub type WebviewIpcHandler<R> = Box<dyn Fn(DetachedWindow<R>, String) + Send>;
+pub type WebviewIpcHandler<T, R> = Box<dyn Fn(DetachedWindow<T, R>, String) + Send>;
diff --git a/core/tauri-runtime/src/window.rs b/core/tauri-runtime/src/window.rs
index 4e58404d2..dbcf5576a 100644
--- a/core/tauri-runtime/src/window.rs
+++ b/core/tauri-runtime/src/window.rs
@@ -8,7 +8,7 @@ use crate::{
   http::{Request as HttpRequest, Response as HttpResponse},
   menu::{Menu, MenuEntry, MenuHash, MenuId},
   webview::{WebviewAttributes, WebviewIpcHandler},
-  Dispatch, Runtime, WindowBuilder,
+  Dispatch, Runtime, UserEvent, WindowBuilder,
 };
 use serde::Serialize;
 use tauri_utils::config::WindowConfig;
@@ -96,12 +96,12 @@ fn get_menu_ids(map: &mut HashMap<MenuHash, MenuId>, menu: &Menu) {
 }
 
 /// A webview window that has yet to be built.
-pub struct PendingWindow<R: Runtime> {
+pub struct PendingWindow<T: UserEvent, R: Runtime<T>> {
   /// The label that the window will be named.
   pub label: String,
 
   /// The [`WindowBuilder`] that the window will be created with.
-  pub window_builder: <R::Dispatcher as Dispatch>::WindowBuilder,
+  pub window_builder: <R::Dispatcher as Dispatch<T>>::WindowBuilder,
 
   /// The [`WebviewAttributes`] that the webview will be created with.
   pub webview_attributes: WebviewAttributes,
@@ -109,7 +109,7 @@ pub struct PendingWindow<R: Runtime> {
   pub uri_scheme_protocols: HashMap<String, Box<UriSchemeProtocol>>,
 
   /// How to handle IPC calls on the webview window.
-  pub ipc_handler: Option<WebviewIpcHandler<R>>,
+  pub ipc_handler: Option<WebviewIpcHandler<T, R>>,
 
   /// The resolved URL to load on the webview.
   pub url: String,
@@ -134,10 +134,10 @@ pub fn assert_label_is_valid(label: &str) {
   );
 }
 
-impl<R: Runtime> PendingWindow<R> {
+impl<T: UserEvent, R: Runtime<T>> PendingWindow<T, R> {
   /// Create a new [`PendingWindow`] with a label and starting url.
   pub fn new(
-    window_builder: <R::Dispatcher as Dispatch>::WindowBuilder,
+    window_builder: <R::Dispatcher as Dispatch<T>>::WindowBuilder,
     webview_attributes: WebviewAttributes,
     label: impl Into<String>,
   ) -> crate::Result<Self> {
@@ -168,7 +168,8 @@ impl<R: Runtime> PendingWindow<R> {
     webview_attributes: WebviewAttributes,
     label: impl Into<String>,
   ) -> crate::Result<Self> {
-    let window_builder = <<R::Dispatcher as Dispatch>::WindowBuilder>::with_config(window_config);
+    let window_builder =
+      <<R::Dispatcher as Dispatch<T>>::WindowBuilder>::with_config(window_config);
     let mut menu_ids = HashMap::new();
     if let Some(menu) = window_builder.get_menu() {
       get_menu_ids(&mut menu_ids, menu);
@@ -225,7 +226,7 @@ pub struct JsEventListenerKey {
 
 /// A webview window that is not yet managed by Tauri.
 #[derive(Debug)]
-pub struct DetachedWindow<R: Runtime> {
+pub struct DetachedWindow<T: UserEvent, R: Runtime<T>> {
   /// Name of the window
   pub label: String,
 
@@ -239,7 +240,7 @@ pub struct DetachedWindow<R: Runtime> {
   pub js_event_listeners: Arc<Mutex<HashMap<JsEventListenerKey, HashSet<u64>>>>,
 }
 
-impl<R: Runtime> Clone for DetachedWindow<R> {
+impl<T: UserEvent, R: Runtime<T>> Clone for DetachedWindow<T, R> {
   fn clone(&self) -> Self {
     Self {
       label: self.label.clone(),
@@ -250,15 +251,15 @@ impl<R: Runtime> Clone for DetachedWindow<R> {
   }
 }
 
-impl<R: Runtime> Hash for DetachedWindow<R> {
+impl<T: UserEvent, R: Runtime<T>> Hash for DetachedWindow<T, R> {
   /// Only use the [`DetachedWindow`]'s label to represent its hash.
   fn hash<H: Hasher>(&self, state: &mut H) {
     self.label.hash(state)
   }
 }
 
-impl<R: Runtime> Eq for DetachedWindow<R> {}
-impl<R: Runtime> PartialEq for DetachedWindow<R> {
+impl<T: UserEvent, R: Runtime<T>> Eq for DetachedWindow<T, R> {}
+impl<T: UserEvent, R: Runtime<T>> PartialEq for DetachedWindow<T, R> {
   /// Only use the [`DetachedWindow`]'s label to compare equality.
   fn eq(&self, other: &Self) -> bool {
     self.label.eq(&other.label)
diff --git a/core/tauri/src/app.rs b/core/tauri/src/app.rs
index 096b9bfcc..f324bfc6e 100644
--- a/core/tauri/src/app.rs
+++ b/core/tauri/src/app.rs
@@ -17,14 +17,15 @@ use crate::{
     http::{Request as HttpRequest, Response as HttpResponse},
     webview::{WebviewAttributes, WindowBuilder as _},
     window::{PendingWindow, WindowEvent},
-    Dispatch, ExitRequestedEventAction, RunEvent as RuntimeRunEvent, Runtime,
+    Dispatch, ExitRequestedEventAction, RunEvent as RuntimeRunEvent,
   },
   scope::FsScope,
   sealed::{ManagerBase, RuntimeOrDispatch},
   utils::config::{Config, WindowUrl},
   utils::{assets::Assets, Env},
   window::WindowBuilder,
-  Context, Invoke, InvokeError, InvokeResponse, Manager, Scopes, StateManager, Window,
+  Context, EventLoopMessage, Invoke, InvokeError, InvokeResponse, Manager, Runtime, Scopes,
+  StateManager, Window,
 };
 
 #[cfg(shell_scope)]
@@ -111,6 +112,19 @@ pub enum RunEvent {
   ///
   /// This event is useful as a place to put your code that should be run after all state-changing events have been handled and you want to do stuff (updating state, performing calculations, etc) that happens as the “main body” of your event loop.
   MainEventsCleared,
+  /// Updater event.
+  #[cfg(feature = "updater")]
+  #[cfg_attr(doc_cfg, doc(cfg(feature = "updater")))]
+  Updater(crate::UpdaterEvent),
+}
+
+impl From<EventLoopMessage> for RunEvent {
+  fn from(event: EventLoopMessage) -> Self {
+    match event {
+      #[cfg(feature = "updater")]
+      EventLoopMessage::Updater(event) => RunEvent::Updater(event),
+    }
+  }
 }
 
 /// A menu event that was triggered on a window.
@@ -205,6 +219,14 @@ pub struct AppHandle<R: Runtime> {
   tray_handle: Option<tray::SystemTrayHandle<R>>,
 }
 
+impl<R: Runtime> AppHandle<R> {
+  // currently only used on the updater
+  #[allow(dead_code)]
+  pub(crate) fn create_proxy(&self) -> R::EventLoopProxy {
+    self.runtime_handle.create_proxy()
+  }
+}
+
 #[cfg(feature = "wry")]
 impl AppHandle<crate::Wry> {
   /// Create a new tao window using a callback. The event loop must be running at this point.
@@ -380,10 +402,10 @@ macro_rules! shared_app_impl {
       ) -> crate::Result<Window<R>>
       where
         F: FnOnce(
-          <R::Dispatcher as Dispatch>::WindowBuilder,
+          <R::Dispatcher as Dispatch<EventLoopMessage>>::WindowBuilder,
           WebviewAttributes,
         ) -> (
-          <R::Dispatcher as Dispatch>::WindowBuilder,
+          <R::Dispatcher as Dispatch<EventLoopMessage>>::WindowBuilder,
           WebviewAttributes,
         ),
       {
@@ -629,7 +651,7 @@ pub struct Builder<R: Runtime> {
   on_page_load: Box<OnPageLoad<R>>,
 
   /// windows to create when starting up.
-  pending_windows: Vec<PendingWindow<R>>,
+  pending_windows: Vec<PendingWindow<EventLoopMessage, R>>,
 
   /// All passed plugins
   plugins: PluginStore<R>,
@@ -891,15 +913,15 @@ impl<R: Runtime> Builder<R> {
   ) -> crate::Result<Self>
   where
     F: FnOnce(
-      <R::Dispatcher as Dispatch>::WindowBuilder,
+      <R::Dispatcher as Dispatch<EventLoopMessage>>::WindowBuilder,
       WebviewAttributes,
     ) -> (
-      <R::Dispatcher as Dispatch>::WindowBuilder,
+      <R::Dispatcher as Dispatch<EventLoopMessage>>::WindowBuilder,
       WebviewAttributes,
     ),
   {
     let (window_builder, webview_attributes) = setup(
-      <R::Dispatcher as Dispatch>::WindowBuilder::new(),
+      <R::Dispatcher as Dispatch<EventLoopMessage>>::WindowBuilder::new(),
       WebviewAttributes::new(url),
     );
     self.pending_windows.push(PendingWindow::new(
@@ -1341,7 +1363,7 @@ impl<R: Runtime> Builder<R> {
 
 fn on_event_loop_event<R: Runtime, F: FnMut(&AppHandle<R>, RunEvent) + 'static>(
   app_handle: &AppHandle<R>,
-  event: RuntimeRunEvent,
+  event: RuntimeRunEvent<EventLoopMessage>,
   manager: &WindowManager<R>,
   callback: Option<&mut F>,
 ) {
@@ -1363,6 +1385,7 @@ fn on_event_loop_event<R: Runtime, F: FnMut(&AppHandle<R>, RunEvent) + 'static>(
     RuntimeRunEvent::Ready => RunEvent::Ready,
     RuntimeRunEvent::Resumed => RunEvent::Resumed,
     RuntimeRunEvent::MainEventsCleared => RunEvent::MainEventsCleared,
+    RuntimeRunEvent::UserEvent(t) => t.into(),
     _ => unimplemented!(),
   };
 
diff --git a/core/tauri/src/app/tray.rs b/core/tauri/src/app/tray.rs
index 21b0de704..c9755de5e 100644
--- a/core/tauri/src/app/tray.rs
+++ b/core/tauri/src/app/tray.rs
@@ -2,12 +2,15 @@
 // SPDX-License-Identifier: Apache-2.0
 // SPDX-License-Identifier: MIT
 
-pub use crate::runtime::{
-  menu::{
-    MenuHash, MenuId, MenuIdRef, MenuUpdate, SystemTrayMenu, SystemTrayMenuEntry, TrayHandle,
+pub use crate::{
+  runtime::{
+    menu::{
+      MenuHash, MenuId, MenuIdRef, MenuUpdate, SystemTrayMenu, SystemTrayMenuEntry, TrayHandle,
+    },
+    window::dpi::{PhysicalPosition, PhysicalSize},
+    SystemTray, TrayIcon,
   },
-  window::dpi::{PhysicalPosition, PhysicalSize},
-  Runtime, SystemTray, TrayIcon,
+  Runtime,
 };
 
 use tauri_macros::default_runtime;
diff --git a/core/tauri/src/command.rs b/core/tauri/src/command.rs
index 3169b29b3..f4b747e49 100644
--- a/core/tauri/src/command.rs
+++ b/core/tauri/src/command.rs
@@ -8,8 +8,8 @@
 //! attribute macro along the way and used by [`crate::generate_handler`] macro.
 
 use crate::hooks::InvokeError;
-use crate::runtime::Runtime;
 use crate::InvokeMessage;
+use crate::Runtime;
 use serde::de::Visitor;
 use serde::{Deserialize, Deserializer};
 
@@ -155,7 +155,7 @@ impl<'de, R: Runtime> Deserializer<'de> for CommandItem<'de, R> {
 /// Nothing in this module is considered stable.
 #[doc(hidden)]
 pub mod private {
-  use crate::{runtime::Runtime, InvokeError, InvokeResolver};
+  use crate::{InvokeError, InvokeResolver, Runtime};
   use futures::{FutureExt, TryFutureExt};
   use serde::Serialize;
   use serde_json::Value;
diff --git a/core/tauri/src/endpoints.rs b/core/tauri/src/endpoints.rs
index 8a48d14be..001c06475 100644
--- a/core/tauri/src/endpoints.rs
+++ b/core/tauri/src/endpoints.rs
@@ -4,8 +4,7 @@
 
 use crate::{
   hooks::{InvokeError, InvokeMessage, InvokeResolver},
-  runtime::Runtime,
-  Config, Invoke, PackageInfo, Window,
+  Config, Invoke, PackageInfo, Runtime, Window,
 };
 pub use anyhow::Result;
 use serde::{Deserialize, Serialize};
diff --git a/core/tauri/src/endpoints/window.rs b/core/tauri/src/endpoints/window.rs
index 7e4106385..00a7cd6c5 100644
--- a/core/tauri/src/endpoints/window.rs
+++ b/core/tauri/src/endpoints/window.rs
@@ -8,10 +8,10 @@ use crate::runtime::{webview::WindowBuilder, Dispatch};
 use crate::{
   runtime::{
     window::dpi::{Position, Size},
-    Runtime, UserAttentionType,
+    UserAttentionType,
   },
   utils::config::WindowConfig,
-  Icon, Manager,
+  Icon, Manager, Runtime,
 };
 use serde::Deserialize;
 use tauri_macros::{module_command_handler, CommandModule};
@@ -171,7 +171,8 @@ impl Cmd {
     let url = options.url.clone();
 
     let mut builder = crate::window::Window::builder(&context.window, label, url);
-    builder.window_builder = <<R::Dispatcher as Dispatch>::WindowBuilder>::with_config(*options);
+    builder.window_builder =
+      <<R::Dispatcher as Dispatch<crate::EventLoopMessage>>::WindowBuilder>::with_config(*options);
     builder.build().map_err(crate::error::into_anyhow)?;
 
     Ok(())
diff --git a/core/tauri/src/hooks.rs b/core/tauri/src/hooks.rs
index 73bfd8a88..413d8926d 100644
--- a/core/tauri/src/hooks.rs
+++ b/core/tauri/src/hooks.rs
@@ -5,8 +5,7 @@
 use crate::{
   api::ipc::{format_callback, format_callback_result, CallbackFn},
   app::App,
-  runtime::Runtime,
-  StateManager, Window,
+  Runtime, StateManager, Window,
 };
 use serde::{Deserialize, Serialize};
 use serde_json::Value as JsonValue;
diff --git a/core/tauri/src/lib.rs b/core/tauri/src/lib.rs
index 2f2ce2551..370fe5856 100644
--- a/core/tauri/src/lib.rs
+++ b/core/tauri/src/lib.rs
@@ -164,9 +164,10 @@ pub mod updater;
 
 pub use tauri_utils as utils;
 
+/// A Tauri [`Runtime`] wrapper around wry.
 #[cfg(feature = "wry")]
 #[cfg_attr(doc_cfg, doc(cfg(feature = "wry")))]
-pub use tauri_runtime_wry::Wry;
+pub type Wry = tauri_runtime_wry::Wry<EventLoopMessage>;
 
 /// `Result<T, ::tauri::Error>`
 pub type Result<T> = std::result::Result<T, Error>;
@@ -215,7 +216,7 @@ pub use {
       dpi::{LogicalPosition, LogicalSize, PhysicalPosition, PhysicalSize, Pixel, Position, Size},
       FileDropEvent, WindowEvent,
     },
-    ClipboardManager, GlobalShortcutManager, RunIteration, Runtime, TrayIcon, UserAttentionType,
+    ClipboardManager, GlobalShortcutManager, RunIteration, TrayIcon, UserAttentionType,
   },
   self::state::{State, StateManager},
   self::utils::{
@@ -227,6 +228,50 @@ pub use {
   scope::*,
 };
 
+/// Updater events.
+#[cfg(feature = "updater")]
+#[cfg_attr(doc_cfg, doc(cfg(feature = "updater")))]
+#[derive(Debug, Clone)]
+pub enum UpdaterEvent {
+  /// An update is available.
+  UpdateAvailable,
+  /// The update is pending.
+  Pending,
+  /// The update has been applied and the app is now up to date.
+  Updated,
+  /// The app is already up to date.
+  AlreadyUpToDate,
+  /// An error occurred while updating.
+  Error(String),
+}
+
+#[cfg(feature = "updater")]
+impl UpdaterEvent {
+  pub(crate) fn status_message(self) -> &'static str {
+    match self {
+      Self::Pending => updater::EVENT_STATUS_PENDING,
+      Self::Updated => updater::EVENT_STATUS_SUCCESS,
+      Self::AlreadyUpToDate => updater::EVENT_STATUS_UPTODATE,
+      Self::Error(_) => updater::EVENT_STATUS_ERROR,
+      _ => unreachable!(),
+    }
+  }
+}
+
+/// The user event type.
+#[derive(Debug, Clone)]
+pub enum EventLoopMessage {
+  /// Updater event.
+  #[cfg(feature = "updater")]
+  #[cfg_attr(doc_cfg, doc(cfg(feature = "updater")))]
+  Updater(UpdaterEvent),
+}
+
+/// The webview runtime interface. A wrapper around [`runtime::Runtime`] with the proper user event type associated.
+pub trait Runtime: runtime::Runtime<EventLoopMessage> {}
+
+impl<W: runtime::Runtime<EventLoopMessage>> Runtime for W {}
+
 /// Reads the config file at compile time and generates a [`Context`] based on its content.
 ///
 /// The default config file path is a `tauri.conf.json` file inside the Cargo manifest directory of
@@ -692,8 +737,8 @@ pub trait Manager<R: Runtime>: sealed::ManagerBase<R> {
 
 /// Prevent implementation details from leaking out of the [`Manager`] trait.
 pub(crate) mod sealed {
+  use super::Runtime;
   use crate::{app::AppHandle, manager::WindowManager};
-  use tauri_runtime::Runtime;
 
   /// A running [`Runtime`] or a dispatcher to it.
   pub enum RuntimeOrDispatch<'r, R: Runtime> {
diff --git a/core/tauri/src/manager.rs b/core/tauri/src/manager.rs
index 20a1a081b..14713bf8c 100644
--- a/core/tauri/src/manager.rs
+++ b/core/tauri/src/manager.rs
@@ -41,14 +41,13 @@ use crate::{
     },
     webview::{WebviewIpcHandler, WindowBuilder},
     window::{dpi::PhysicalSize, DetachedWindow, FileDropEvent, PendingWindow, WindowEvent},
-    Runtime,
   },
   utils::{
     assets::Assets,
     config::{AppUrl, Config, WindowUrl},
     PackageInfo,
   },
-  Context, Icon, Invoke, Manager, Pattern, Scopes, StateManager, Window,
+  Context, EventLoopMessage, Icon, Invoke, Manager, Pattern, Runtime, Scopes, StateManager, Window,
 };
 
 #[cfg(any(target_os = "linux", target_os = "windows"))]
@@ -379,14 +378,14 @@ impl<R: Runtime> WindowManager<R> {
 
   fn prepare_pending_window(
     &self,
-    mut pending: PendingWindow<R>,
+    mut pending: PendingWindow<EventLoopMessage, R>,
     label: &str,
     window_labels: &[String],
     app_handle: AppHandle<R>,
     web_resource_request_handler: Option<
       Box<dyn Fn(&HttpRequest, &mut HttpResponse) + Send + Sync>,
     >,
-  ) -> crate::Result<PendingWindow<R>> {
+  ) -> crate::Result<PendingWindow<EventLoopMessage, R>> {
     let is_init_global = self.inner.config.build.with_global_tauri;
     let plugin_init = self
       .inner
@@ -681,7 +680,10 @@ impl<R: Runtime> WindowManager<R> {
     Ok(pending)
   }
 
-  fn prepare_ipc_handler(&self, app_handle: AppHandle<R>) -> WebviewIpcHandler<R> {
+  fn prepare_ipc_handler(
+    &self,
+    app_handle: AppHandle<R>,
+  ) -> WebviewIpcHandler<EventLoopMessage, R> {
     let manager = self.clone();
     Box::new(move |window, #[allow(unused_mut)] mut request| {
       let window = Window::new(manager.clone(), window, app_handle.clone());
@@ -993,12 +995,12 @@ impl<R: Runtime> WindowManager<R> {
   pub fn prepare_window(
     &self,
     app_handle: AppHandle<R>,
-    mut pending: PendingWindow<R>,
+    mut pending: PendingWindow<EventLoopMessage, R>,
     window_labels: &[String],
     web_resource_request_handler: Option<
       Box<dyn Fn(&HttpRequest, &mut HttpResponse) + Send + Sync>,
     >,
-  ) -> crate::Result<PendingWindow<R>> {
+  ) -> crate::Result<PendingWindow<EventLoopMessage, R>> {
     if self.windows_lock().contains_key(&pending.label) {
       return Err(crate::Error::WindowLabelAlreadyExists(pending.label));
     }
@@ -1087,7 +1089,11 @@ impl<R: Runtime> WindowManager<R> {
     Ok(pending)
   }
 
-  pub fn attach_window(&self, app_handle: AppHandle<R>, window: DetachedWindow<R>) -> Window<R> {
+  pub fn attach_window(
+    &self,
+    app_handle: AppHandle<R>,
+    window: DetachedWindow<EventLoopMessage, R>,
+  ) -> Window<R> {
     let window = Window::new(self.clone(), window, app_handle);
 
     let window_ = window.clone();
@@ -1223,8 +1229,8 @@ fn on_window_event<R: Runtime>(
   event: &WindowEvent,
 ) -> crate::Result<()> {
   match event {
-    WindowEvent::Resized(size) => window.emit_and_trigger(WINDOW_RESIZED_EVENT, size)?,
-    WindowEvent::Moved(position) => window.emit_and_trigger(WINDOW_MOVED_EVENT, position)?,
+    WindowEvent::Resized(size) => window.emit(WINDOW_RESIZED_EVENT, size)?,
+    WindowEvent::Moved(position) => window.emit(WINDOW_MOVED_EVENT, position)?,
     WindowEvent::CloseRequested {
       label: _,
       signal_tx,
@@ -1232,10 +1238,10 @@ fn on_window_event<R: Runtime>(
       if window.has_js_listener(Some(window.label().into()), WINDOW_CLOSE_REQUESTED_EVENT) {
         signal_tx.send(true).unwrap();
       }
-      window.emit_and_trigger(WINDOW_CLOSE_REQUESTED_EVENT, ())?;
+      window.emit(WINDOW_CLOSE_REQUESTED_EVENT, ())?;
     }
     WindowEvent::Destroyed => {
-      window.emit_and_trigger(WINDOW_DESTROYED_EVENT, ())?;
+      window.emit(WINDOW_DESTROYED_EVENT, ())?;
       let label = window.label();
       for window in manager.inner.windows.lock().unwrap().values() {
         window.eval(&format!(
@@ -1244,7 +1250,7 @@ fn on_window_event<R: Runtime>(
         ))?;
       }
     }
-    WindowEvent::Focused(focused) => window.emit_and_trigger(
+    WindowEvent::Focused(focused) => window.emit(
       if *focused {
         WINDOW_FOCUS_EVENT
       } else {
@@ -1256,7 +1262,7 @@ fn on_window_event<R: Runtime>(
       scale_factor,
       new_inner_size,
       ..
-    } => window.emit_and_trigger(
+    } => window.emit(
       WINDOW_SCALE_FACTOR_CHANGED_EVENT,
       ScaleFactorChanged {
         scale_factor: *scale_factor,
@@ -1264,7 +1270,7 @@ fn on_window_event<R: Runtime>(
       },
     )?,
     WindowEvent::FileDrop(event) => match event {
-      FileDropEvent::Hovered(paths) => window.emit_and_trigger("tauri://file-drop-hover", paths)?,
+      FileDropEvent::Hovered(paths) => window.emit("tauri://file-drop-hover", paths)?,
       FileDropEvent::Dropped(paths) => {
         let scopes = window.state::<Scopes>();
         for path in paths {
@@ -1274,9 +1280,9 @@ fn on_window_event<R: Runtime>(
             let _ = scopes.allow_directory(path, false);
           }
         }
-        window.emit_and_trigger("tauri://file-drop", paths)?
+        window.emit("tauri://file-drop", paths)?
       }
-      FileDropEvent::Cancelled => window.emit_and_trigger("tauri://file-drop-cancelled", ())?,
+      FileDropEvent::Cancelled => window.emit("tauri://file-drop-cancelled", ())?,
       _ => unimplemented!(),
     },
     _ => unimplemented!(),
@@ -1292,7 +1298,7 @@ struct ScaleFactorChanged {
 }
 
 fn on_menu_event<R: Runtime>(window: &Window<R>, event: &MenuEvent) -> crate::Result<()> {
-  window.emit_and_trigger(MENU_EVENT, event.menu_item_id.clone())
+  window.emit(MENU_EVENT, event.menu_item_id.clone())
 }
 
 #[cfg(feature = "isolation")]
diff --git a/core/tauri/src/plugin.rs b/core/tauri/src/plugin.rs
index f6e39a42c..a69ee6764 100644
--- a/core/tauri/src/plugin.rs
+++ b/core/tauri/src/plugin.rs
@@ -5,8 +5,8 @@
 //! The Tauri plugin extension to expand Tauri functionality.
 
 use crate::{
-  runtime::Runtime, utils::config::PluginConfig, AppHandle, Invoke, InvokeHandler, PageLoadPayload,
-  RunEvent, Window,
+  utils::config::PluginConfig, AppHandle, Invoke, InvokeHandler, PageLoadPayload, RunEvent,
+  Runtime, Window,
 };
 use serde::de::DeserializeOwned;
 use serde_json::Value as JsonValue;
@@ -71,7 +71,7 @@ type OnPageLoad<R> = dyn FnMut(Window<R>, PageLoadPayload) + Send;
 /// sticking to the `init` function convention helps users to quickly identify the correct function to call.
 ///
 /// ```rust
-/// use tauri::{plugin::{Builder, TauriPlugin}, runtime::Runtime};
+/// use tauri::{plugin::{Builder, TauriPlugin}, Runtime};
 ///
 /// pub fn init<R: Runtime>() -> TauriPlugin<R> {
 ///   Builder::new("example")
@@ -82,7 +82,7 @@ type OnPageLoad<R> = dyn FnMut(Window<R>, PageLoadPayload) + Send;
 /// When plugins expose more complex configuration options, it can be helpful to provide a Builder instead:
 ///
 /// ```rust
-/// use tauri::{plugin::{Builder as PluginBuilder, TauriPlugin}, runtime::Runtime};
+/// use tauri::{plugin::{Builder as PluginBuilder, TauriPlugin}, Runtime};
 ///
 /// pub struct Builder {
 ///   option_a: String,
@@ -164,7 +164,7 @@ impl<R: Runtime, C: DeserializeOwned> Builder<R, C> {
   /// # Examples
   ///
   /// ```rust
-  /// use tauri::{plugin::{Builder, TauriPlugin}, runtime::Runtime};
+  /// use tauri::{plugin::{Builder, TauriPlugin}, Runtime};
   ///
   /// #[tauri::command]
   /// async fn foobar<R: Runtime>(app: tauri::AppHandle<R>, window: tauri::Window<R>) -> Result<(), String> {
@@ -199,7 +199,7 @@ impl<R: Runtime, C: DeserializeOwned> Builder<R, C> {
   /// # Examples
   ///
   /// ```rust
-  /// use tauri::{plugin::{Builder, TauriPlugin}, runtime::Runtime};
+  /// use tauri::{plugin::{Builder, TauriPlugin}, Runtime};
   ///
   /// const INIT_SCRIPT: &str = r#"
   ///    console.log("hello world from js init script");
@@ -228,7 +228,7 @@ impl<R: Runtime, C: DeserializeOwned> Builder<R, C> {
   /// # Examples
   ///
   /// ```rust
-  /// use tauri::{plugin::{Builder, TauriPlugin}, runtime::Runtime, Manager};
+  /// use tauri::{plugin::{Builder, TauriPlugin}, Runtime, Manager};
   /// use std::path::PathBuf;
   ///
   /// #[derive(Debug, Default)]
@@ -298,7 +298,7 @@ impl<R: Runtime, C: DeserializeOwned> Builder<R, C> {
   /// # Examples
   ///
   /// ```rust
-  /// use tauri::{plugin::{Builder, TauriPlugin}, runtime::Runtime};
+  /// use tauri::{plugin::{Builder, TauriPlugin}, Runtime};
   ///
   /// fn init<R: Runtime>() -> TauriPlugin<R> {
   ///   Builder::new("example")
@@ -322,7 +322,7 @@ impl<R: Runtime, C: DeserializeOwned> Builder<R, C> {
   /// # Examples
   ///
   /// ```rust
-  /// use tauri::{plugin::{Builder, TauriPlugin}, runtime::Runtime};
+  /// use tauri::{plugin::{Builder, TauriPlugin}, Runtime};
   ///
   /// fn init<R: Runtime>() -> TauriPlugin<R> {
   ///   Builder::new("example")
@@ -346,7 +346,7 @@ impl<R: Runtime, C: DeserializeOwned> Builder<R, C> {
   /// # Examples
   ///
   /// ```rust
-  /// use tauri::{plugin::{Builder, TauriPlugin}, RunEvent, runtime::Runtime};
+  /// use tauri::{plugin::{Builder, TauriPlugin}, RunEvent, Runtime};
   ///
   /// fn init<R: Runtime>() -> TauriPlugin<R> {
   ///   Builder::new("example")
diff --git a/core/tauri/src/state.rs b/core/tauri/src/state.rs
index d42c47e75..c617bd5df 100644
--- a/core/tauri/src/state.rs
+++ b/core/tauri/src/state.rs
@@ -4,8 +4,7 @@
 
 use crate::{
   command::{CommandArg, CommandItem},
-  runtime::Runtime,
-  InvokeError,
+  InvokeError, Runtime,
 };
 use state::Container;
 
diff --git a/core/tauri/src/test/mock_runtime.rs b/core/tauri/src/test/mock_runtime.rs
index f3fb6146c..d0be3cc88 100644
--- a/core/tauri/src/test/mock_runtime.rs
+++ b/core/tauri/src/test/mock_runtime.rs
@@ -12,8 +12,8 @@ use tauri_runtime::{
     dpi::{PhysicalPosition, PhysicalSize, Position, Size},
     DetachedWindow, MenuEvent, PendingWindow, WindowEvent,
   },
-  ClipboardManager, Dispatch, GlobalShortcutManager, Result, RunEvent, Runtime, RuntimeHandle,
-  UserAttentionType, WindowIcon,
+  ClipboardManager, Dispatch, EventLoopProxy, GlobalShortcutManager, Result, RunEvent, Runtime,
+  RuntimeHandle, UserAttentionType, UserEvent, WindowIcon,
 };
 #[cfg(feature = "system-tray")]
 use tauri_runtime::{
@@ -53,13 +53,18 @@ pub struct MockRuntimeHandle {
   context: RuntimeContext,
 }
 
-impl RuntimeHandle for MockRuntimeHandle {
+impl<T: UserEvent> RuntimeHandle<T> for MockRuntimeHandle {
   type Runtime = MockRuntime;
+
+  fn create_proxy(&self) -> EventProxy {
+    unimplemented!()
+  }
+
   /// Create a new webview window.
   fn create_window(
     &self,
-    pending: PendingWindow<Self::Runtime>,
-  ) -> Result<DetachedWindow<Self::Runtime>> {
+    pending: PendingWindow<T, Self::Runtime>,
+  ) -> Result<DetachedWindow<T, Self::Runtime>> {
     Ok(DetachedWindow {
       label: pending.label,
       dispatcher: MockDispatcher {
@@ -247,7 +252,7 @@ impl WindowBuilder for MockWindowBuilder {
   }
 }
 
-impl Dispatch for MockDispatcher {
+impl<T: UserEvent> Dispatch<T> for MockDispatcher {
   type Runtime = MockRuntime;
 
   type WindowBuilder = MockWindowBuilder;
@@ -364,8 +369,8 @@ impl Dispatch for MockDispatcher {
 
   fn create_window(
     &mut self,
-    pending: PendingWindow<Self::Runtime>,
-  ) -> Result<DetachedWindow<Self::Runtime>> {
+    pending: PendingWindow<T, Self::Runtime>,
+  ) -> Result<DetachedWindow<T, Self::Runtime>> {
     unimplemented!()
   }
 
@@ -489,6 +494,15 @@ impl TrayHandle for MockTrayHandler {
   }
 }
 
+#[derive(Debug, Clone)]
+pub struct EventProxy {}
+
+impl<T: UserEvent> EventLoopProxy<T> for EventProxy {
+  fn send_event(&self, event: T) -> Result<()> {
+    Ok(())
+  }
+}
+
 #[derive(Debug)]
 pub struct MockRuntime {
   pub context: RuntimeContext,
@@ -520,13 +534,14 @@ impl MockRuntime {
   }
 }
 
-impl Runtime for MockRuntime {
+impl<T: UserEvent> Runtime<T> for MockRuntime {
   type Dispatcher = MockDispatcher;
   type Handle = MockRuntimeHandle;
   type GlobalShortcutManager = MockGlobalShortcutManager;
   type ClipboardManager = MockClipboardManager;
   #[cfg(feature = "system-tray")]
   type TrayHandler = MockTrayHandler;
+  type EventLoopProxy = EventProxy;
 
   fn new() -> Result<Self> {
     Ok(Self::init())
@@ -537,6 +552,10 @@ impl Runtime for MockRuntime {
     Ok(Self::init())
   }
 
+  fn create_proxy(&self) -> EventProxy {
+    unimplemented!()
+  }
+
   fn handle(&self) -> Self::Handle {
     MockRuntimeHandle {
       context: self.context.clone(),
@@ -551,7 +570,7 @@ impl Runtime for MockRuntime {
     self.clipboard_manager.clone()
   }
 
-  fn create_window(&self, pending: PendingWindow<Self>) -> Result<DetachedWindow<Self>> {
+  fn create_window(&self, pending: PendingWindow<T, Self>) -> Result<DetachedWindow<T, Self>> {
     Ok(DetachedWindow {
       label: pending.label,
       dispatcher: MockDispatcher {
@@ -578,14 +597,14 @@ impl Runtime for MockRuntime {
   #[cfg_attr(doc_cfg, doc(cfg(target_os = "macos")))]
   fn set_activation_policy(&mut self, activation_policy: tauri_runtime::ActivationPolicy) {}
 
-  fn run_iteration<F: Fn(RunEvent) + 'static>(
+  fn run_iteration<F: Fn(RunEvent<T>) + 'static>(
     &mut self,
     callback: F,
   ) -> tauri_runtime::RunIteration {
     Default::default()
   }
 
-  fn run<F: FnMut(RunEvent) + 'static>(self, callback: F) {
+  fn run<F: FnMut(RunEvent<T>) + 'static>(self, callback: F) {
     loop {
       std::thread::sleep(std::time::Duration::from_secs(1));
     }
diff --git a/core/tauri/src/updater/mod.rs b/core/tauri/src/updater/mod.rs
index 7254d551f..55d1e79ad 100644
--- a/core/tauri/src/updater/mod.rs
+++ b/core/tauri/src/updater/mod.rs
@@ -333,7 +333,8 @@ mod error;
 pub use self::error::Error;
 
 use crate::{
-  api::dialog::blocking::ask, runtime::Runtime, utils::config::UpdaterConfig, Env, Manager, Window,
+  api::dialog::blocking::ask, runtime::EventLoopProxy, utils::config::UpdaterConfig, Env,
+  EventLoopMessage, Manager, Runtime, UpdaterEvent, Window,
 };
 
 /// Check for new updates
@@ -404,17 +405,13 @@ pub(crate) async fn check_update_with_dialog<R: Runtime>(
           )
           .await;
 
-          if dialog.is_err() {
-            send_status_update(
-              window.clone(),
-              EVENT_STATUS_ERROR,
-              Some(dialog.err().unwrap().to_string()),
-            );
+          if let Err(e) = dialog {
+            send_status_update(window.clone(), UpdaterEvent::Error(e.to_string()));
           }
         }
       }
       Err(e) => {
-        send_status_update(window.clone(), EVENT_STATUS_ERROR, Some(e.to_string()));
+        send_status_update(window.clone(), UpdaterEvent::Error(e.to_string()));
       }
     }
   }
@@ -464,7 +461,7 @@ pub(crate) fn listener<R: Runtime>(
             let body = updater.body.clone().unwrap_or_else(|| String::from(""));
 
             // Emit `tauri://update-available`
-            let _ = window.emit_and_trigger(
+            let _ = window.emit(
               EVENT_UPDATE_AVAILABLE,
               UpdateManifest {
                 body,
@@ -472,6 +469,10 @@ pub(crate) fn listener<R: Runtime>(
                 version: updater.version.clone(),
               },
             );
+            let _ = window
+              .app_handle
+              .create_proxy()
+              .send_event(EventLoopMessage::Updater(UpdaterEvent::UpdateAvailable));
 
             // Listen for `tauri://update-install`
             window.once(EVENT_INSTALL_UPDATE, move |_msg| {
@@ -481,7 +482,7 @@ pub(crate) fn listener<R: Runtime>(
               // Start installation
               crate::async_runtime::spawn(async move {
                 // emit {"status": "PENDING"}
-                send_status_update(window.clone(), EVENT_STATUS_PENDING, None);
+                send_status_update(window.clone(), UpdaterEvent::Pending);
 
                 // Launch updater download process
                 // macOS we display the `Ready to restart dialog` asking to restart
@@ -491,19 +492,19 @@ pub(crate) fn listener<R: Runtime>(
 
                 if let Err(err) = update_result {
                   // emit {"status": "ERROR", "error": "The error message"}
-                  send_status_update(window.clone(), EVENT_STATUS_ERROR, Some(err.to_string()));
+                  send_status_update(window.clone(), UpdaterEvent::Error(err.to_string()));
                 } else {
                   // emit {"status": "DONE"}
-                  send_status_update(window.clone(), EVENT_STATUS_SUCCESS, None);
+                  send_status_update(window.clone(), UpdaterEvent::Updated);
                 }
               });
             });
           } else {
-            send_status_update(window.clone(), EVENT_STATUS_UPTODATE, None);
+            send_status_update(window.clone(), UpdaterEvent::AlreadyUpToDate);
           }
         }
         Err(e) => {
-          send_status_update(window.clone(), EVENT_STATUS_ERROR, Some(e.to_string()));
+          send_status_update(window.clone(), UpdaterEvent::Error(e.to_string()));
         }
       }
     });
@@ -511,14 +512,25 @@ pub(crate) fn listener<R: Runtime>(
 }
 
 // Send a status update via `tauri://update-status` event.
-fn send_status_update<R: Runtime>(window: Window<R>, status: &str, error: Option<String>) {
-  let _ = window.emit_and_trigger(
+fn send_status_update<R: Runtime>(window: Window<R>, message: UpdaterEvent) {
+  let _ = window.emit(
     EVENT_STATUS_UPDATE,
-    StatusEvent {
-      error,
-      status: String::from(status),
+    if let UpdaterEvent::Error(error) = &message {
+      StatusEvent {
+        error: Some(error.clone()),
+        status: message.clone().status_message().into(),
+      }
+    } else {
+      StatusEvent {
+        error: None,
+        status: message.clone().status_message().into(),
+      }
     },
   );
+  let _ = window
+    .app_handle
+    .create_proxy()
+    .send_event(EventLoopMessage::Updater(message));
 }
 
 // Prompt a dialog asking if the user want to install the new version
diff --git a/core/tauri/src/window.rs b/core/tauri/src/window.rs
index ec0ca3d30..a3ab4ebb9 100644
--- a/core/tauri/src/window.rs
+++ b/core/tauri/src/window.rs
@@ -23,12 +23,13 @@ use crate::{
       dpi::{PhysicalPosition, PhysicalSize, Position, Size},
       DetachedWindow, JsEventListenerKey, PendingWindow, WindowEvent,
     },
-    Dispatch, Runtime, RuntimeHandle, UserAttentionType,
+    Dispatch, RuntimeHandle, UserAttentionType,
   },
   sealed::ManagerBase,
   sealed::RuntimeOrDispatch,
   utils::config::WindowUrl,
-  Icon, Invoke, InvokeError, InvokeMessage, InvokeResolver, Manager, PageLoadPayload,
+  EventLoopMessage, Icon, Invoke, InvokeError, InvokeMessage, InvokeResolver, Manager,
+  PageLoadPayload, Runtime,
 };
 
 use serde::Serialize;
@@ -110,7 +111,7 @@ pub struct WindowBuilder<R: Runtime> {
   runtime: RuntimeHandleOrDispatch<R>,
   app_handle: AppHandle<R>,
   label: String,
-  pub(crate) window_builder: <R::Dispatcher as Dispatch>::WindowBuilder,
+  pub(crate) window_builder: <R::Dispatcher as Dispatch<EventLoopMessage>>::WindowBuilder,
   pub(crate) webview_attributes: WebviewAttributes,
   web_resource_request_handler: Option<Box<dyn Fn(&HttpRequest, &mut HttpResponse) + Send + Sync>>,
 }
@@ -159,7 +160,7 @@ impl<R: Runtime> WindowBuilder<R> {
       runtime,
       app_handle,
       label: label.into(),
-      window_builder: <R::Dispatcher as Dispatch>::WindowBuilder::new(),
+      window_builder: <R::Dispatcher as Dispatch<EventLoopMessage>>::WindowBuilder::new(),
       webview_attributes: WebviewAttributes::new(url),
       web_resource_request_handler: None,
     }
@@ -451,7 +452,7 @@ impl<R: Runtime> WindowBuilder<R> {
 #[derive(Debug)]
 pub struct Window<R: Runtime> {
   /// The webview window created by the runtime.
-  window: DetachedWindow<R>,
+  window: DetachedWindow<EventLoopMessage, R>,
   /// The manager to associate this webview window with.
   manager: WindowManager<R>,
   pub(crate) app_handle: AppHandle<R>,
@@ -528,7 +529,7 @@ impl<R: Runtime> Window<R> {
   /// Create a new window that is attached to the manager.
   pub(crate) fn new(
     manager: WindowManager<R>,
-    window: DetachedWindow<R>,
+    window: DetachedWindow<EventLoopMessage, R>,
     app_handle: AppHandle<R>,
   ) -> Self {
     Self {
@@ -566,10 +567,10 @@ impl<R: Runtime> Window<R> {
   ) -> crate::Result<Window<R>>
   where
     F: FnOnce(
-      <R::Dispatcher as Dispatch>::WindowBuilder,
+      <R::Dispatcher as Dispatch<EventLoopMessage>>::WindowBuilder,
       WebviewAttributes,
     ) -> (
-      <R::Dispatcher as Dispatch>::WindowBuilder,
+      <R::Dispatcher as Dispatch<EventLoopMessage>>::WindowBuilder,
       WebviewAttributes,
     ),
   {
diff --git a/core/tauri/src/window/menu.rs b/core/tauri/src/window/menu.rs
index b9b346aaa..a6cac7aca 100644
--- a/core/tauri/src/window/menu.rs
+++ b/core/tauri/src/window/menu.rs
@@ -2,9 +2,12 @@
 // SPDX-License-Identifier: Apache-2.0
 // SPDX-License-Identifier: MIT
 
-use crate::runtime::{
-  menu::{MenuHash, MenuId, MenuIdRef, MenuUpdate},
-  Dispatch, Runtime,
+use crate::{
+  runtime::{
+    menu::{MenuHash, MenuId, MenuIdRef, MenuUpdate},
+    Dispatch,
+  },
+  Runtime,
 };
 
 use tauri_macros::default_runtime;
diff --git a/tooling/cli/templates/plugin/backend/src/lib.rs b/tooling/cli/templates/plugin/backend/src/lib.rs
index 99fbfbaa6..f9c48bca9 100755
--- a/tooling/cli/templates/plugin/backend/src/lib.rs
+++ b/tooling/cli/templates/plugin/backend/src/lib.rs
@@ -1,7 +1,7 @@
 {{#if license_header}}
 {{ license_header }}
 {{/if}}
-use tauri::{plugin::{Builder, TauriPlugin}, runtime::Runtime};
+use tauri::{plugin::{Builder, TauriPlugin}, Runtime};
 
 /// Initializes the plugin.
 pub fn init<R: Runtime>() -> TauriPlugin<R> {
