diff --git a/.changes/updater-dialog-unsupported-platform.md b/.changes/updater-dialog-unsupported-platform.md
new file mode 100644
index 000000000..eaebc630e
--- /dev/null
+++ b/.changes/updater-dialog-unsupported-platform.md
@@ -0,0 +1,5 @@
+---
+"tauri": patch
+---
+
+Only run the updater default dialog mode in supported platforms or development mode.
diff --git a/core/tauri/src/app.rs b/core/tauri/src/app.rs
index 43f0b9871..1f02fd9e6 100644
--- a/core/tauri/src/app.rs
+++ b/core/tauri/src/app.rs
@@ -794,21 +794,27 @@ impl<R: Runtime> App<R> {
     // check if updater is active or not
     if updater_config.active {
       if updater_config.dialog {
-        // if updater dialog is enabled spawn a new task
-        self.run_updater_dialog();
-        // When dialog is enabled, if user want to recheck
-        // if an update is available after first start
-        // invoke the Event `tauri://update` from JS or rust side.
-        handle.listen_global(updater::EVENT_CHECK_UPDATE, move |_msg| {
-          let handle = handle_.clone();
-          // re-spawn task inside tokyo to launch the download
-          // we don't need to emit anything as everything is handled
-          // by the process (user is asked to restart at the end)
-          // and it's handled by the updater
-          crate::async_runtime::spawn(
-            async move { updater::check_update_with_dialog(handle).await },
-          );
-        });
+        #[cfg(not(target_os = "linux"))]
+        let updater_enabled = true;
+        #[cfg(target_os = "linux")]
+        let updater_enabled = cfg!(dev) || self.state::<Env>().appimage.is_some();
+        if updater_enabled {
+          // if updater dialog is enabled spawn a new task
+          self.run_updater_dialog();
+          // When dialog is enabled, if user want to recheck
+          // if an update is available after first start
+          // invoke the Event `tauri://update` from JS or rust side.
+          handle.listen_global(updater::EVENT_CHECK_UPDATE, move |_msg| {
+            let handle = handle_.clone();
+            // re-spawn task inside tokyo to launch the download
+            // we don't need to emit anything as everything is handled
+            // by the process (user is asked to restart at the end)
+            // and it's handled by the updater
+            crate::async_runtime::spawn(
+              async move { updater::check_update_with_dialog(handle).await },
+            );
+          });
+        }
       } else {
         // we only listen for `tauri://update`
         // once we receive the call, we check if an update is available or not
diff --git a/examples/updater/src-tauri/Cargo.lock b/examples/updater/src-tauri/Cargo.lock
index d0ef5225e..9d9d46273 100644
--- a/examples/updater/src-tauri/Cargo.lock
+++ b/examples/updater/src-tauri/Cargo.lock
@@ -2622,7 +2622,7 @@ dependencies = [
 
 [[package]]
 name = "tauri"
-version = "1.0.0"
+version = "1.0.2"
 dependencies = [
  "anyhow",
  "attohttpc",
@@ -2671,7 +2671,7 @@ dependencies = [
 
 [[package]]
 name = "tauri-build"
-version = "1.0.0"
+version = "1.0.2"
 dependencies = [
  "anyhow",
  "cargo_toml",
@@ -2686,7 +2686,7 @@ dependencies = [
 
 [[package]]
 name = "tauri-codegen"
-version = "1.0.0"
+version = "1.0.2"
 dependencies = [
  "base64",
  "brotli",
@@ -2708,7 +2708,7 @@ dependencies = [
 
 [[package]]
 name = "tauri-macros"
-version = "1.0.0"
+version = "1.0.2"
 dependencies = [
  "heck 0.4.0",
  "proc-macro2",
@@ -2720,7 +2720,7 @@ dependencies = [
 
 [[package]]
 name = "tauri-runtime"
-version = "0.9.0"
+version = "0.10.1"
 dependencies = [
  "gtk",
  "http",
@@ -2738,7 +2738,7 @@ dependencies = [
 
 [[package]]
 name = "tauri-runtime-wry"
-version = "0.9.0"
+version = "0.10.1"
 dependencies = [
  "cocoa",
  "gtk",
@@ -2756,7 +2756,7 @@ dependencies = [
 
 [[package]]
 name = "tauri-utils"
-version = "1.0.0"
+version = "1.0.2"
 dependencies = [
  "brotli",
  "ctor",
