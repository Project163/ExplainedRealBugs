diff --git a/pom.xml b/pom.xml
index 9f8afae..a0f2308 100644
--- a/pom.xml
+++ b/pom.xml
@@ -198,9 +198,9 @@
             <scope>provided</scope>
         </dependency>
         <dependency>
-            <groupId>org.apache.commons</groupId>
-            <artifactId>commons-collections4</artifactId>
-            <version>4.1</version>
+            <groupId>org.apache.jackrabbit</groupId>
+            <artifactId>jackrabbit-jcr-commons</artifactId>
+            <version>2.14.0</version>
             <scope>provided</scope>
         </dependency>
         <dependency>
@@ -285,5 +285,11 @@
             <version>1.0.0</version>
             <scope>test</scope>
         </dependency>
+        <dependency>
+            <groupId>org.apache.commons</groupId>
+            <artifactId>commons-collections4</artifactId>
+            <version>4.1</version>
+            <scope>test</scope>
+        </dependency>
     </dependencies>
 </project>
diff --git a/src/main/java/org/apache/sling/validation/impl/ValidationModelRetrieverImpl.java b/src/main/java/org/apache/sling/validation/impl/ValidationModelRetrieverImpl.java
index 2e29033..e1277ec 100644
--- a/src/main/java/org/apache/sling/validation/impl/ValidationModelRetrieverImpl.java
+++ b/src/main/java/org/apache/sling/validation/impl/ValidationModelRetrieverImpl.java
@@ -20,11 +20,12 @@ package org.apache.sling.validation.impl;
 
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.HashMap;
 import java.util.List;
-import java.util.SortedMap;
+import java.util.Map;
 
-import org.apache.commons.collections4.trie.PatriciaTrie;
 import org.apache.commons.lang3.StringUtils;
+import org.apache.jackrabbit.util.Text;
 import org.apache.sling.api.resource.LoginException;
 import org.apache.sling.api.resource.ResourceResolver;
 import org.apache.sling.api.resource.ResourceResolverFactory;
@@ -105,16 +106,27 @@ public class ValidationModelRetrieverImpl implements ValidationModelRetriever {
     }
 
     private @Nullable ValidationModel getModel(@NotNull String resourceType, String resourcePath) {
-        PatriciaTrie<ValidationModel> modelsForResourceType = fillTrieForResourceType(resourceType);
+        Map<String, ValidationModel> modelsForResourceType = fillMapForResourceType(resourceType);
         ValidationModel model = null;
         // for empty/null resource paths, always return the entry stored for ""
         if (StringUtils.isEmpty(resourcePath)) {
             model = modelsForResourceType.get("");
         } else {
             // get longest prefix entry, which still matches
-            SortedMap<String, ValidationModel> modelMap = modelsForResourceType.subMap("", resourcePath + "/");
-            if (!modelMap.isEmpty()) {
-                model =  modelMap.get(modelMap.lastKey());
+            // go to parent
+            String parentResourcePath = resourcePath;
+            while (!parentResourcePath.equals("/")) {
+                model = modelsForResourceType.get(parentResourcePath);
+                if (model != null) {
+                    return model;
+                }
+                // this returns the root entry "/" for root path "/"
+                parentResourcePath = Text.getRelativeParent(parentResourcePath, 1);
+            }
+            // now check for both the root path "/" and the empty path!
+            model = modelsForResourceType.get(parentResourcePath);
+            if (model == null) {
+                model = modelsForResourceType.get("");
             }
         }
         if (model == null && !modelsForResourceType.isEmpty()) {
@@ -124,9 +136,9 @@ public class ValidationModelRetrieverImpl implements ValidationModelRetriever {
         return model;
     }
 
-    private @NotNull PatriciaTrie<ValidationModel> fillTrieForResourceType(@NotNull String resourceType) {
-        // create a new (empty) trie
-        PatriciaTrie<ValidationModel> modelsForResourceType = new PatriciaTrie<ValidationModel>();
+    private @NotNull Map<String, ValidationModel> fillMapForResourceType(@NotNull String resourceType) {
+        // create a new map
+        Map<String, ValidationModel> modelsForResourceType = new HashMap<>();
 
         // fill trie with data from model providers (all models for the given resource type, independent of resource path)
         // lowest ranked model provider inserts first (i.e. higher ranked should overwrite)
diff --git a/src/test/java/org/apache/sling/validation/impl/ValidationModelRetrieverImplTest.java b/src/test/java/org/apache/sling/validation/impl/ValidationModelRetrieverImplTest.java
index 7b6697f..6b00f2f 100644
--- a/src/test/java/org/apache/sling/validation/impl/ValidationModelRetrieverImplTest.java
+++ b/src/test/java/org/apache/sling/validation/impl/ValidationModelRetrieverImplTest.java
@@ -139,6 +139,41 @@ public class ValidationModelRetrieverImplTest {
         Assert.assertThat(model.getApplicablePaths(), Matchers.contains(""));
     }
 
+    @Test
+    public void testGetModelWithApplicablePathOnRootMatching() {
+        applicablePathPerResourceType.put("test/type", "/content/site1");
+        applicablePathPerResourceType.put("test/type", "");
+        applicablePathPerResourceType.put("test/type", "/content/site1/subnode");
+
+        ValidationModel model = validationModelRetriever.getValidationModel("test/type", "/content/site2", false);
+        Assert.assertNotNull(model);
+        Assert.assertThat(model.getApplicablePaths(), Matchers.contains(""));
+    }
+
+    @Test
+    public void testGetModelWithApplicablePathOnRootMatching2() {
+        applicablePathPerResourceType.put("test/type", "/content/site1");
+        applicablePathPerResourceType.put("test/type", "/");
+        applicablePathPerResourceType.put("test/type", "/content/site1/subnode");
+
+        ValidationModel model = validationModelRetriever.getValidationModel("test/type", "/content/site2", false);
+        Assert.assertNotNull(model);
+        Assert.assertThat(model.getApplicablePaths(), Matchers.contains("/"));
+    }
+    
+    @Test
+    public void testGetModelWithInexactApplicablePathPath() {
+        applicablePathPerResourceType.put("test/type", "/content/site1");
+        applicablePathPerResourceType.put("test/type", "");
+        applicablePathPerResourceType.put("test/type", "/content/site1/a");
+
+        ValidationModel model = validationModelRetriever.getValidationModel("test/type", "/content/site1/b", false);
+        // SLING-7924
+        Assert.assertNotNull(model);
+        // make sure that the parent applicable path is returned
+        Assert.assertThat(model.getApplicablePaths(), Matchers.contains("/content/site1"));
+    }
+    
     @Test
     public void testGetModelWithResourceInheritance() {
         // in case no super type is known, just return model
