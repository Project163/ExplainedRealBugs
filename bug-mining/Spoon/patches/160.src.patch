diff --git a/src/main/java/spoon/reflect/code/CtConstructorCall.java b/src/main/java/spoon/reflect/code/CtConstructorCall.java
index 18ebb72d7..e180174c0 100644
--- a/src/main/java/spoon/reflect/code/CtConstructorCall.java
+++ b/src/main/java/spoon/reflect/code/CtConstructorCall.java
@@ -17,6 +17,10 @@
 package spoon.reflect.code;
 
 import spoon.reflect.reference.CtActualTypeContainer;
+import spoon.reflect.reference.CtExecutableReference;
+import spoon.reflect.reference.CtTypeReference;
+
+import java.util.List;
 
 /**
  * This code element represents a constructor call.
@@ -25,6 +29,30 @@ import spoon.reflect.reference.CtActualTypeContainer;
  * 		created type
  */
 public interface CtConstructorCall<T> extends CtTargetedExpression<T, CtExpression<?>>, CtAbstractInvocation<T>, CtStatement, CtActualTypeContainer {
+	/**
+	 * Delegate to the executable reference of the constructor call.
+	 *
+	 * @see CtExecutableReference#getActualTypeArguments()
+	 */
+	@Override
+	List<CtTypeReference<?>> getActualTypeArguments();
+
+	/**
+	 * Delegate to the executable reference of the constructor call.
+	 *
+	 * @see CtExecutableReference#getActualTypeArguments()
+	 */
+	@Override
+	<T extends CtActualTypeContainer> T setActualTypeArguments(List<CtTypeReference<?>> actualTypeArguments);
+
+	/**
+	 * Delegate to the executable reference of the constructor call.
+	 *
+	 * @see CtExecutableReference#getActualTypeArguments()
+	 */
+	@Override
+	<T extends CtActualTypeContainer> T addActualTypeArgument(CtTypeReference<?> actualTypeArgument);
+
 	@Override
 	CtConstructorCall<T> clone();
 }
diff --git a/src/main/java/spoon/reflect/code/CtInvocation.java b/src/main/java/spoon/reflect/code/CtInvocation.java
index b32ea03e9..ee6449dba 100644
--- a/src/main/java/spoon/reflect/code/CtInvocation.java
+++ b/src/main/java/spoon/reflect/code/CtInvocation.java
@@ -17,8 +17,11 @@
 package spoon.reflect.code;
 
 import spoon.reflect.reference.CtActualTypeContainer;
+import spoon.reflect.reference.CtExecutableReference;
 import spoon.reflect.reference.CtTypeReference;
 
+import java.util.List;
+
 /**
  * This code element defines a concrete invocation.
  *
@@ -26,6 +29,30 @@ import spoon.reflect.reference.CtTypeReference;
  * 		Return type of this invocation
  */
 public interface CtInvocation<T> extends CtAbstractInvocation<T>, CtStatement, CtTargetedExpression<T, CtExpression<?>>, CtActualTypeContainer {
+	/**
+	 * Delegate to the executable reference of the invocation.
+	 *
+	 * @see CtExecutableReference#getActualTypeArguments()
+	 */
+	@Override
+	List<CtTypeReference<?>> getActualTypeArguments();
+
+	/**
+	 * Delegate to the executable reference of the invocation.
+	 *
+	 * @see CtExecutableReference#getActualTypeArguments()
+	 */
+	@Override
+	<T extends CtActualTypeContainer> T setActualTypeArguments(List<CtTypeReference<?>> actualTypeArguments);
+
+	/**
+	 * Delegate to the executable reference of the invocation.
+	 *
+	 * @see CtExecutableReference#getActualTypeArguments()
+	 */
+	@Override
+	<T extends CtActualTypeContainer> T addActualTypeArgument(CtTypeReference<?> actualTypeArgument);
+
 	/**
 	 * Return the type returned by the invocation. If the invocation is to a
 	 * method where the returned type is a generic type, this method returns
diff --git a/src/main/java/spoon/reflect/code/CtNewClass.java b/src/main/java/spoon/reflect/code/CtNewClass.java
index f7cdd4d7c..f38738506 100644
--- a/src/main/java/spoon/reflect/code/CtNewClass.java
+++ b/src/main/java/spoon/reflect/code/CtNewClass.java
@@ -17,6 +17,11 @@
 package spoon.reflect.code;
 
 import spoon.reflect.declaration.CtClass;
+import spoon.reflect.reference.CtActualTypeContainer;
+import spoon.reflect.reference.CtExecutableReference;
+import spoon.reflect.reference.CtTypeReference;
+
+import java.util.List;
 
 /**
  * This code element represents the creation of a anonymous class.
@@ -25,6 +30,29 @@ import spoon.reflect.declaration.CtClass;
  * 		created type
  */
 public interface CtNewClass<T> extends CtConstructorCall<T> {
+	/**
+	 * Delegate to the executable reference of the new class.
+	 *
+	 * @see CtExecutableReference#getActualTypeArguments()
+	 */
+	@Override
+	List<CtTypeReference<?>> getActualTypeArguments();
+
+	/**
+	 * Delegate to the executable reference of the new class.
+	 *
+	 * @see CtExecutableReference#getActualTypeArguments()
+	 */
+	@Override
+	<T extends CtActualTypeContainer> T setActualTypeArguments(List<CtTypeReference<?>> actualTypeArguments);
+
+	/**
+	 * Delegate to the executable reference of the new class.
+	 *
+	 * @see CtExecutableReference#getActualTypeArguments()
+	 */
+	@Override
+	<T extends CtActualTypeContainer> T addActualTypeArgument(CtTypeReference<?> actualTypeArgument);
 
 	/**
 	 * Gets the created class.
