diff --git a/src/main/java/spoon/reflect/visitor/CtScanner.java b/src/main/java/spoon/reflect/visitor/CtScanner.java
index a5462d27b..d8221640f 100644
--- a/src/main/java/spoon/reflect/visitor/CtScanner.java
+++ b/src/main/java/spoon/reflect/visitor/CtScanner.java
@@ -97,7 +97,12 @@ import java.lang.annotation.Annotation;
 import java.util.Collection;
 
 /**
- * This visitor implements a deep-search scan on the metamodel.
+ * This visitor implements a deep-search scan on the model.
+ *
+ * Ensures that all children nodes are visited once, a visit means three method
+ * calls, one call to "enter", one call to "exit" and one call to scan.
+ *
+ * Is used by the processing and filtering engine.
  */
 public abstract class CtScanner implements CtVisitor {
 	/**
@@ -667,6 +672,8 @@ public abstract class CtScanner implements CtVisitor {
 
 	@Override
 	public void visitCtCircularTypeReference(CtCircularTypeReference reference) {
+		enter(reference);
+		exit(reference);
 	}
 
 	@Override
@@ -730,16 +737,19 @@ public abstract class CtScanner implements CtVisitor {
 		exit(whileLoop);
 	}
 
-	public <T> void visitCtCodeSnippetExpression(
-			CtCodeSnippetExpression<T> expression) {
+	public <T> void visitCtCodeSnippetExpression(CtCodeSnippetExpression<T> expression) {
+		enter(expression);
+		exit(expression);
 	}
 
 	public void visitCtCodeSnippetStatement(CtCodeSnippetStatement statement) {
+		enter(statement);
+		exit(statement);
 	}
 
-	public <T> void visitCtUnboundVariableReference(
-			CtUnboundVariableReference<T> reference) {
-
+	public <T> void visitCtUnboundVariableReference(CtUnboundVariableReference<T> reference) {
+		enter(reference);
+		exit(reference);
 	}
 
 	@Override
diff --git a/src/test/java/spoon/reflect/visitor/CtScannerTest.java b/src/test/java/spoon/reflect/visitor/CtScannerTest.java
new file mode 100644
index 000000000..8ee2434c7
--- /dev/null
+++ b/src/test/java/spoon/reflect/visitor/CtScannerTest.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2006-2015 INRIA and contributors
+ * Spoon - http://spoon.gforge.inria.fr/
+ *
+ * This software is governed by the CeCILL-C License under French law and
+ * abiding by the rules of distribution of free software. You can use, modify
+ * and/or redistribute the software under the terms of the CeCILL-C license as
+ * circulated by CEA, CNRS and INRIA at http://www.cecill.info.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the CeCILL-C License for more details.
+ *
+ * The fact that you are presently reading this means that you have had
+ * knowledge of the CeCILL-C license and that you accept its terms.
+ */
+
+package spoon.reflect.visitor;
+
+import org.junit.Test;
+import spoon.Launcher;
+import spoon.reflect.visitor.processors.CheckScannerProcessor;
+
+public class CtScannerTest {
+	@Test
+	public void testScannerContract() throws Exception {
+		// contract: CtScanner must call enter and exit methods in each visit methods.
+		final Launcher launcher = new Launcher();
+		launcher.getEnvironment().setNoClasspath(true);
+		launcher.addProcessor(new CheckScannerProcessor());
+		launcher.setSourceOutputDirectory("./target/trash");
+		// interfaces.
+		launcher.addInputResource("./src/main/java/spoon/reflect/code");
+		launcher.addInputResource("./src/main/java/spoon/reflect/declaration");
+		launcher.addInputResource("./src/main/java/spoon/reflect/reference");
+		// implementations.
+		launcher.addInputResource("./src/main/java/spoon/support/reflect/code");
+		launcher.addInputResource("./src/main/java/spoon/support/reflect/declaration");
+		launcher.addInputResource("./src/main/java/spoon/support/reflect/reference");
+		launcher.addInputResource("./src/main/java/spoon/reflect/visitor/CtScanner.java");
+		launcher.run();
+
+		// All assertions are in the processor.
+	}
+}
diff --git a/src/test/java/spoon/reflect/visitor/processors/CheckScannerProcessor.java b/src/test/java/spoon/reflect/visitor/processors/CheckScannerProcessor.java
new file mode 100644
index 000000000..b954246e4
--- /dev/null
+++ b/src/test/java/spoon/reflect/visitor/processors/CheckScannerProcessor.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2006-2015 INRIA and contributors
+ * Spoon - http://spoon.gforge.inria.fr/
+ *
+ * This software is governed by the CeCILL-C License under French law and
+ * abiding by the rules of distribution of free software. You can use, modify
+ * and/or redistribute the software under the terms of the CeCILL-C license as
+ * circulated by CEA, CNRS and INRIA at http://www.cecill.info.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the CeCILL-C License for more details.
+ *
+ * The fact that you are presently reading this means that you have had
+ * knowledge of the CeCILL-C license and that you accept its terms.
+ */
+
+package spoon.reflect.visitor.processors;
+
+import spoon.processing.AbstractProcessor;
+import spoon.reflect.code.CtInvocation;
+import spoon.reflect.code.CtStatement;
+import spoon.reflect.declaration.CtClass;
+import spoon.reflect.declaration.CtMethod;
+import spoon.reflect.declaration.CtType;
+import spoon.reflect.declaration.ModifierKind;
+import spoon.reflect.visitor.CtScanner;
+import spoon.reflect.visitor.CtVisitor;
+
+import java.util.Arrays;
+import java.util.List;
+
+public class CheckScannerProcessor extends AbstractProcessor<CtClass<?>> {
+	private final List<String> excludingClasses = Arrays.asList("CompilationUnitVirtualImpl");
+
+	@Override
+	public boolean isToBeProcessed(CtClass<?> candidate) {
+		return super.isToBeProcessed(candidate) //
+				&& !excludingClasses.contains(candidate.getSimpleName()) //
+				&& !candidate.hasModifier(ModifierKind.ABSTRACT)
+				&& candidate.getSimpleName().endsWith("Impl") //
+				&& candidate.getPackage().getQualifiedName().startsWith("spoon.support.reflect") //
+				&& candidate.isTopLevel();
+	}
+
+	@Override
+	public void process(CtClass<?> element) {
+		final CtType<CtVisitor> scanner = getFactory().Type().get(CtScanner.class);
+		final String qualifiedName = element.getQualifiedName().replace(".support.", ".");
+		final String interfaceName = qualifiedName.substring(0, qualifiedName.lastIndexOf("Impl"));
+		final CtType<Object> theInterface = getFactory().Type().get(interfaceName);
+
+		final List<CtMethod<?>> visits = scanner.getMethodsByName("visit" + theInterface.getSimpleName());
+		if (visits.size() != 1) {
+			throw new AssertionError("You must have only one visitor methods in CtScanner for visit" + theInterface.getSimpleName());
+		}
+
+		final CtMethod<?> visit = visits.get(0);
+		if (visit.getBody().getStatements().size() < 2) {
+			throw new AssertionError("You must have minimum 2 statements in the visit method to call enter and exit in visit" + theInterface.getSimpleName());
+		}
+
+		checkInvocation("enter", visit.getBody().getStatement(0));
+		checkInvocation("exit", visit.getBody().getLastStatement());
+	}
+
+	private void checkInvocation(String expected, CtStatement statement) {
+		if (!(statement instanceof CtInvocation)) {
+			throw new AssertionError("The statement must be a call to " + expected + " method.");
+		}
+
+		if (!expected.equals(((CtInvocation) statement).getExecutable().getSimpleName())) {
+			throw new AssertionError("The statement must be a call to " + expected + " method.");
+		}
+	}
+}
diff --git a/src/test/java/spoon/test/main/MainTest.java b/src/test/java/spoon/test/main/MainTest.java
index 4d2ef4927..215ad9f7f 100644
--- a/src/test/java/spoon/test/main/MainTest.java
+++ b/src/test/java/spoon/test/main/MainTest.java
@@ -12,6 +12,7 @@ import spoon.reflect.code.CtFieldWrite;
 import spoon.reflect.code.CtVariableWrite;
 import spoon.reflect.declaration.CtElement;
 import spoon.reflect.declaration.CtPackage;
+import spoon.reflect.visitor.CtScanner;
 import spoon.reflect.visitor.filter.TypeFilter;
 import spoon.test.parent.ParentTest;
 
@@ -60,6 +61,45 @@ public class MainTest {
 
 		// assignments
 		checkAssignmentContracts(pack);
+
+		// scanners
+		checkContractCtScanner(pack);
+	}
+
+	private void checkContractCtScanner(CtPackage pack) {
+		class Counter {
+			int scan, enter, exit = 0;
+		}
+
+		final Counter counter = new Counter();
+
+		new CtScanner() {
+
+			@Override
+			public void scan(CtElement element) {
+				if (element != null) {
+					counter.scan++;
+				}
+				super.scan(element);
+			}
+
+			@Override
+			public void enter(CtElement element) {
+				counter.enter++;
+				super.enter(element);
+			}
+
+			@Override
+			public void exit(CtElement element) {
+				counter.exit++;
+				super.exit(element);
+			}
+
+		}.visitCtPackage(pack);
+
+		assertTrue(counter.enter == counter.exit);
+		// there is one scan less, because we start with visit
+		assertTrue(counter.enter == counter.scan + 1);
 	}
 
 	public static void checkAssignmentContracts(CtElement pack) {
