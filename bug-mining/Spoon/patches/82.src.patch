diff --git a/src/main/java/spoon/reflect/visitor/filter/OverridingMethodFilter.java b/src/main/java/spoon/reflect/visitor/filter/OverridingMethodFilter.java
new file mode 100644
index 000000000..cbdcac1cc
--- /dev/null
+++ b/src/main/java/spoon/reflect/visitor/filter/OverridingMethodFilter.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2006-2015 INRIA and contributors
+ * Spoon - http://spoon.gforge.inria.fr/
+ *
+ * This software is governed by the CeCILL-C License under French law and
+ * abiding by the rules of distribution of free software. You can use, modify
+ * and/or redistribute the software under the terms of the CeCILL-C license as
+ * circulated by CEA, CNRS and INRIA at http://www.cecill.info.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the CeCILL-C License for more details.
+ *
+ * The fact that you are presently reading this means that you have had
+ * knowledge of the CeCILL-C license and that you accept its terms.
+ */
+package spoon.reflect.visitor.filter;
+
+import spoon.reflect.declaration.CtExecutable;
+import spoon.reflect.declaration.CtMethod;
+import spoon.reflect.declaration.CtType;
+import spoon.reflect.reference.CtExecutableReference;
+import spoon.reflect.visitor.Filter;
+
+public class OverridingMethodFilter implements Filter<CtMethod<?>> {
+	private final CtExecutableReference<?> executableReference;
+
+	public OverridingMethodFilter(CtExecutableReference<?> executableReference) {
+		this.executableReference = executableReference;
+	}
+
+	@Override
+	public boolean matches(CtMethod<?> element) {
+		final CtExecutable<?> declaration = executableReference.getDeclaration();
+		if (declaration == null) {
+			return false;
+		}
+		final CtType expectedParent = declaration.getParent(CtType.class);
+		final CtType<?> currentParent = element.getParent(CtType.class);
+		return currentParent.isAssignableFrom(expectedParent.getReference()) //
+				&& !currentParent.equals(expectedParent) //
+				&& element.getReference().isOverriding(executableReference);
+	}
+}
diff --git a/src/main/java/spoon/support/reflect/reference/CtExecutableReferenceImpl.java b/src/main/java/spoon/support/reflect/reference/CtExecutableReferenceImpl.java
index 1aa0970b5..5f144b09b 100644
--- a/src/main/java/spoon/support/reflect/reference/CtExecutableReferenceImpl.java
+++ b/src/main/java/spoon/support/reflect/reference/CtExecutableReferenceImpl.java
@@ -215,10 +215,16 @@ public class CtExecutableReferenceImpl<T> extends CtReferenceImpl
 
 	@Override
 	public boolean isOverriding(CtExecutableReference<?> executable) {
-		if (!this.getDeclaringType().isSubtypeOf(executable.getDeclaringType())) {
+		if (getDeclaringType().isAnonymous()) {
+			if (!getDeclaringType().getDeclaringType().isSubtypeOf(executable.getDeclaringType())) {
+				return false;
+			}
+		} else if (!getDeclaringType().isSubtypeOf(executable.getDeclaringType())) {
 			return false;
 		}
-		return getSimpleName().equals(executable.getSimpleName());
+		return getSimpleName().equals(executable.getSimpleName())
+				&& getParameters().equals(executable.getParameters())
+				&& getActualTypeArguments().equals(executable.getActualTypeArguments());
 	}
 
 	@Override
diff --git a/src/test/java/spoon/test/filters/FilterTest.java b/src/test/java/spoon/test/filters/FilterTest.java
index 0ffebeda5..b4fd4c7a6 100644
--- a/src/test/java/spoon/test/filters/FilterTest.java
+++ b/src/test/java/spoon/test/filters/FilterTest.java
@@ -1,14 +1,7 @@
 package spoon.test.filters;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-
-import java.util.ArrayList;
-import java.util.List;
-
 import org.junit.Before;
 import org.junit.Test;
-
 import spoon.Launcher;
 import spoon.compiler.SpoonResourceHelper;
 import spoon.reflect.code.CtCFlowBreak;
@@ -17,6 +10,7 @@ import spoon.reflect.code.CtFieldAccess;
 import spoon.reflect.code.CtNewClass;
 import spoon.reflect.declaration.CtClass;
 import spoon.reflect.declaration.CtElement;
+import spoon.reflect.declaration.CtInterface;
 import spoon.reflect.declaration.CtMethod;
 import spoon.reflect.declaration.CtNamedElement;
 import spoon.reflect.declaration.CtVariable;
@@ -28,11 +22,24 @@ import spoon.reflect.visitor.filter.CompositeFilter;
 import spoon.reflect.visitor.filter.FieldAccessFilter;
 import spoon.reflect.visitor.filter.FilteringOperator;
 import spoon.reflect.visitor.filter.NameFilter;
+import spoon.reflect.visitor.filter.OverridingMethodFilter;
 import spoon.reflect.visitor.filter.RegexFilter;
 import spoon.reflect.visitor.filter.ReturnOrThrowFilter;
 import spoon.reflect.visitor.filter.TypeFilter;
 import spoon.support.reflect.declaration.CtMethodImpl;
 import spoon.test.TestUtils;
+import spoon.test.filters.testclasses.AbstractTostada;
+import spoon.test.filters.testclasses.Antojito;
+import spoon.test.filters.testclasses.ITostada;
+import spoon.test.filters.testclasses.SubTostada;
+import spoon.test.filters.testclasses.Tacos;
+import spoon.test.filters.testclasses.Tostada;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
 
 public class FilterTest {
 
@@ -70,7 +77,7 @@ public class FilterTest {
 
 		List<CtNamedElement> elements = foo.getElements(new NameFilter<>("i"));
 		assertEquals(1, elements.size());
-		
+
 		CtFieldReference<?> ref = (CtFieldReference<?>)(elements.get(0)).getReference();
 		List<CtFieldAccess<?>> expressions = foo.getElements(new FieldAccessFilter(ref));
 		assertEquals(2, expressions.size());
@@ -98,7 +105,7 @@ public class FilterTest {
 			assertTrue(filterClass.isInstance(element));
 		}
 	}
-	
+
 	@SuppressWarnings({"rawtypes", "unchecked"})
 	@Test
 	public void intersectionOfTwoFilters() throws Exception {
@@ -106,19 +113,19 @@ public class FilterTest {
 		TypeFilter<CtMethod> statementFilter = new TypeFilter<CtMethod>(CtMethod.class);
 		TypeFilter<CtMethodImpl> statementImplFilter = new TypeFilter<CtMethodImpl>(CtMethodImpl.class);
 		CompositeFilter compositeFilter = new CompositeFilter(FilteringOperator.INTERSECTION, statementFilter, statementImplFilter);
-		
+
 		List<CtMethod> methodsWithInterfaceSuperclass = Query.getElements(factory, statementFilter);
 		List<CtMethodImpl> methodWithConcreteClass = Query.getElements(factory, statementImplFilter);
-		
+
 		assertEquals(methodsWithInterfaceSuperclass.size(), methodWithConcreteClass.size());
 		assertEquals(methodsWithInterfaceSuperclass, methodWithConcreteClass);
-		
+
 		List intersection = Query.getElements(factory, compositeFilter);
-		
+
 		assertEquals(methodsWithInterfaceSuperclass.size(), intersection.size());
 		assertEquals(methodsWithInterfaceSuperclass, intersection);
 	}
-	
+
 	@SuppressWarnings({"rawtypes", "unchecked"})
 	@Test
 	public void unionOfTwoFilters() throws Exception {
@@ -126,20 +133,20 @@ public class FilterTest {
 		TypeFilter<CtNewClass> newClassFilter = new TypeFilter<CtNewClass>(CtNewClass.class);
 		TypeFilter<CtMethod> methodFilter = new TypeFilter<CtMethod>(CtMethod.class);
 		CompositeFilter compositeFilter = new CompositeFilter(FilteringOperator.UNION, methodFilter, newClassFilter);
-		
+
 		List filteredWithCompositeFilter = Query.getElements(factory, compositeFilter);
 		List<CtMethod> methods = Query.getElements(factory, methodFilter);
 		List<CtNewClass> newClasses = Query.getElements(factory, newClassFilter);
-		
+
 		List<CtElement> union = new ArrayList<CtElement>();
 		union.addAll(methods);
 		union.addAll(newClasses);
-		
+
 		assertEquals(methods.size() + newClasses.size(), union.size());
 		assertEquals(union.size(), filteredWithCompositeFilter.size());
 		assertTrue(filteredWithCompositeFilter.containsAll(union));
 	}
-	
+
 	@SuppressWarnings({"rawtypes", "unchecked"})
 	@Test
 	public void classCastExceptionIsNotThrown() throws Exception {
@@ -151,4 +158,82 @@ public class FilterTest {
 		assertTrue(filteredWithCompositeFilter.isEmpty());
 	}
 
+	@Test
+	public void testOverridingMethodFromAbstractClass() throws Exception {
+		// contract: When we declare an abstract method on an abstract class, we must return all overriding
+		// methods in sub classes and anonymous classes.
+		final Launcher launcher = new Launcher();
+		launcher.addInputResource("./src/test/java/spoon/test/filters/testclasses");
+		launcher.setSourceOutputDirectory("./target/trash");
+		launcher.run();
+
+		final CtClass<AbstractTostada> aClass = launcher.getFactory().Class().get(AbstractTostada.class);
+
+		final List<CtMethod<?>> overridingMethods = Query.getElements(launcher.getFactory(), new OverridingMethodFilter(aClass.getMethodsByName("prepare").get(0).getReference()));
+		assertEquals(5, overridingMethods.size());
+		assertEquals("spoon.test.filters.testclasses.AbstractTostada$1", overridingMethods.get(0).getParent(CtClass.class).getQualifiedName());
+		assertEquals(Antojito.class, overridingMethods.get(1).getParent(CtClass.class).getActualClass());
+		assertEquals(SubTostada.class, overridingMethods.get(2).getParent(CtClass.class).getActualClass());
+		assertEquals("spoon.test.filters.testclasses.Tostada$1", overridingMethods.get(3).getParent(CtClass.class).getQualifiedName());
+		assertEquals(Tostada.class, overridingMethods.get(4).getParent(CtClass.class).getActualClass());
+	}
+
+	@Test
+	public void testOverridingMethodFromSubClassOfAbstractClass() throws Exception {
+		// contract: When we ask all overriding methods from an overriding method, we must returns all methods
+		// below and not above (including the declaration).
+		final Launcher launcher = new Launcher();
+		launcher.addInputResource("./src/test/java/spoon/test/filters/testclasses");
+		launcher.setSourceOutputDirectory("./target/trash");
+		launcher.run();
+
+		final CtClass<Tostada> aTostada = launcher.getFactory().Class().get(Tostada.class);
+
+		final List<CtMethod<?>> overridingMethods = Query.getElements(launcher.getFactory(), new OverridingMethodFilter(aTostada.getMethodsByName("prepare").get(0).getReference()));
+		assertEquals(2, overridingMethods.size());
+		assertEquals(SubTostada.class, overridingMethods.get(0).getParent(CtClass.class).getActualClass());
+		assertEquals("spoon.test.filters.testclasses.Tostada$1", overridingMethods.get(1).getParent(CtClass.class).getQualifiedName());
+
+		final CtClass<SubTostada> aSubTostada = launcher.getFactory().Class().get(SubTostada.class);
+		assertEquals(0, Query.getElements(launcher.getFactory(), new OverridingMethodFilter(aSubTostada.getMethodsByName("prepare").get(0).getReference())).size());
+	}
+
+	@Test
+	public void testOverridingMethodFromInterface() throws Exception {
+		// contract: When we declare a method in an interface, we must return all overriding
+		// methods in sub classes and anonymous classes.
+		final Launcher launcher = new Launcher();
+		launcher.addInputResource("./src/test/java/spoon/test/filters/testclasses");
+		launcher.setSourceOutputDirectory("./target/trash");
+		launcher.run();
+
+		final CtInterface<ITostada> aITostada = launcher.getFactory().Interface().get(ITostada.class);
+
+		final List<CtMethod<?>> overridingMethods = Query.getElements(launcher.getFactory(), new OverridingMethodFilter(aITostada.getMethodsByName("make").get(0).getReference()));
+		assertEquals(4, overridingMethods.size());
+		assertEquals(AbstractTostada.class, overridingMethods.get(0).getParent(CtClass.class).getActualClass());
+		assertEquals("spoon.test.filters.testclasses.AbstractTostada$1", overridingMethods.get(1).getParent(CtClass.class).getQualifiedName());
+		assertEquals(Tacos.class, overridingMethods.get(2).getParent(CtClass.class).getActualClass());
+		assertEquals(Tostada.class, overridingMethods.get(3).getParent(CtClass.class).getActualClass());
+	}
+
+	@Test
+	public void testOverridingMethodFromSubClassOfInterface() throws Exception {
+		// contract: When we ask all overriding methods from an overriding method, we must returns all methods
+		// below and not above (including the declaration).
+		final Launcher launcher = new Launcher();
+		launcher.addInputResource("./src/test/java/spoon/test/filters/testclasses");
+		launcher.setSourceOutputDirectory("./target/trash");
+		launcher.run();
+
+		final CtClass<AbstractTostada> anAbstractTostada = launcher.getFactory().Class().get(AbstractTostada.class);
+
+		final List<CtMethod<?>> overridingMethods = Query.getElements(launcher.getFactory(), new OverridingMethodFilter(anAbstractTostada.getMethodsByName("make").get(0).getReference()));
+		assertEquals(2, overridingMethods.size());
+		assertEquals("spoon.test.filters.testclasses.AbstractTostada$1", overridingMethods.get(0).getParent(CtClass.class).getQualifiedName());
+		assertEquals(Tostada.class, overridingMethods.get(1).getParent(CtClass.class).getActualClass());
+
+		final CtClass<Tostada> aTostada = launcher.getFactory().Class().get(Tostada.class);
+		assertEquals(0, Query.getElements(launcher.getFactory(), new OverridingMethodFilter(aTostada.getMethodsByName("make").get(0).getReference())).size());
+	}
 }
diff --git a/src/test/java/spoon/test/filters/testclasses/AbstractTostada.java b/src/test/java/spoon/test/filters/testclasses/AbstractTostada.java
new file mode 100644
index 000000000..b1745ce60
--- /dev/null
+++ b/src/test/java/spoon/test/filters/testclasses/AbstractTostada.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2006-2015 INRIA and contributors
+ * Spoon - http://spoon.gforge.inria.fr/
+ *
+ * This software is governed by the CeCILL-C License under French law and
+ * abiding by the rules of distribution of free software. You can use, modify
+ * and/or redistribute the software under the terms of the CeCILL-C license as
+ * circulated by CEA, CNRS and INRIA at http://www.cecill.info.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the CeCILL-C License for more details.
+ *
+ * The fact that you are presently reading this means that you have had
+ * knowledge of the CeCILL-C license and that you accept its terms.
+ */
+package spoon.test.filters.testclasses;
+
+public abstract class AbstractTostada implements ITostada {
+	@Override
+	public ITostada make() {
+		return new Tostada() {
+			@Override
+			public void prepare() {
+				super.prepare();
+			}
+
+			@Override
+			public ITostada make() {
+				return super.make();
+			}
+		};
+	}
+
+	public abstract void prepare();
+}
diff --git a/src/test/java/spoon/test/filters/testclasses/Antojito.java b/src/test/java/spoon/test/filters/testclasses/Antojito.java
new file mode 100644
index 000000000..da493a4eb
--- /dev/null
+++ b/src/test/java/spoon/test/filters/testclasses/Antojito.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2006-2015 INRIA and contributors
+ * Spoon - http://spoon.gforge.inria.fr/
+ *
+ * This software is governed by the CeCILL-C License under French law and
+ * abiding by the rules of distribution of free software. You can use, modify
+ * and/or redistribute the software under the terms of the CeCILL-C license as
+ * circulated by CEA, CNRS and INRIA at http://www.cecill.info.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the CeCILL-C License for more details.
+ *
+ * The fact that you are presently reading this means that you have had
+ * knowledge of the CeCILL-C license and that you accept its terms.
+ */
+
+package spoon.test.filters.testclasses;
+
+public class Antojito extends AbstractTostada {
+	@Override
+	public void prepare() {
+	}
+
+	public void prepare(String ingredient) {
+	}
+}
diff --git a/src/test/java/spoon/test/filters/testclasses/ITostada.java b/src/test/java/spoon/test/filters/testclasses/ITostada.java
new file mode 100644
index 000000000..d5ea1eedb
--- /dev/null
+++ b/src/test/java/spoon/test/filters/testclasses/ITostada.java
@@ -0,0 +1,21 @@
+/*
+ * Copyright (C) 2006-2015 INRIA and contributors
+ * Spoon - http://spoon.gforge.inria.fr/
+ *
+ * This software is governed by the CeCILL-C License under French law and
+ * abiding by the rules of distribution of free software. You can use, modify
+ * and/or redistribute the software under the terms of the CeCILL-C license as
+ * circulated by CEA, CNRS and INRIA at http://www.cecill.info.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the CeCILL-C License for more details.
+ *
+ * The fact that you are presently reading this means that you have had
+ * knowledge of the CeCILL-C license and that you accept its terms.
+ */
+package spoon.test.filters.testclasses;
+
+public interface ITostada {
+	ITostada make();
+}
diff --git a/src/test/java/spoon/test/filters/testclasses/SubTostada.java b/src/test/java/spoon/test/filters/testclasses/SubTostada.java
new file mode 100644
index 000000000..0abfaefce
--- /dev/null
+++ b/src/test/java/spoon/test/filters/testclasses/SubTostada.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2006-2015 INRIA and contributors
+ * Spoon - http://spoon.gforge.inria.fr/
+ *
+ * This software is governed by the CeCILL-C License under French law and
+ * abiding by the rules of distribution of free software. You can use, modify
+ * and/or redistribute the software under the terms of the CeCILL-C license as
+ * circulated by CEA, CNRS and INRIA at http://www.cecill.info.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the CeCILL-C License for more details.
+ *
+ * The fact that you are presently reading this means that you have had
+ * knowledge of the CeCILL-C license and that you accept its terms.
+ */
+
+package spoon.test.filters.testclasses;
+
+public class SubTostada extends Tostada {
+	@Override
+	public void prepare() {
+		super.prepare();
+	}
+}
diff --git a/src/test/java/spoon/test/filters/testclasses/Tacos.java b/src/test/java/spoon/test/filters/testclasses/Tacos.java
new file mode 100644
index 000000000..df91011de
--- /dev/null
+++ b/src/test/java/spoon/test/filters/testclasses/Tacos.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2006-2015 INRIA and contributors
+ * Spoon - http://spoon.gforge.inria.fr/
+ *
+ * This software is governed by the CeCILL-C License under French law and
+ * abiding by the rules of distribution of free software. You can use, modify
+ * and/or redistribute the software under the terms of the CeCILL-C license as
+ * circulated by CEA, CNRS and INRIA at http://www.cecill.info.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the CeCILL-C License for more details.
+ *
+ * The fact that you are presently reading this means that you have had
+ * knowledge of the CeCILL-C license and that you accept its terms.
+ */
+
+package spoon.test.filters.testclasses;
+
+public class Tacos implements ITostada {
+	@Override
+	public ITostada make() {
+		return null;
+	}
+
+	public void prepare() {
+	}
+}
diff --git a/src/test/java/spoon/test/filters/testclasses/Tostada.java b/src/test/java/spoon/test/filters/testclasses/Tostada.java
new file mode 100644
index 000000000..b08fdaba1
--- /dev/null
+++ b/src/test/java/spoon/test/filters/testclasses/Tostada.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2006-2015 INRIA and contributors
+ * Spoon - http://spoon.gforge.inria.fr/
+ *
+ * This software is governed by the CeCILL-C License under French law and
+ * abiding by the rules of distribution of free software. You can use, modify
+ * and/or redistribute the software under the terms of the CeCILL-C license as
+ * circulated by CEA, CNRS and INRIA at http://www.cecill.info.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the CeCILL-C License for more details.
+ *
+ * The fact that you are presently reading this means that you have had
+ * knowledge of the CeCILL-C license and that you accept its terms.
+ */
+
+package spoon.test.filters.testclasses;
+
+public class Tostada extends AbstractTostada {
+	@Override
+	public ITostada make() {
+		return new Tostada() {
+			@Override
+			public void prepare() {
+				super.prepare();
+			}
+		};
+	}
+
+	@Override
+	public void prepare() {
+	}
+}
