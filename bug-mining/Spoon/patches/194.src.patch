diff --git a/src/main/java/spoon/reflect/code/CtLambda.java b/src/main/java/spoon/reflect/code/CtLambda.java
index 276059595..5846595c6 100644
--- a/src/main/java/spoon/reflect/code/CtLambda.java
+++ b/src/main/java/spoon/reflect/code/CtLambda.java
@@ -17,7 +17,9 @@
 package spoon.reflect.code;
 
 import spoon.reflect.declaration.CtExecutable;
+import spoon.reflect.declaration.CtMethod;
 import spoon.reflect.reference.CtTypeReference;
+import spoon.support.DerivedProperty;
 import spoon.support.UnsettableProperty;
 
 import java.util.Set;
@@ -59,6 +61,13 @@ public interface CtLambda<T> extends CtExpression<T>, CtExecutable<T> {
 	 */
 	CtExpression<T> getExpression();
 
+	/**
+	 * @return the method that this lambda expression implements.
+	 * Must be defined as a non-default method in an interface, e.g. Consumer.accept().
+	 */
+	@DerivedProperty
+	<R> CtMethod<R> getOverriddenMethod();
+
 	/**
 	 * Sets the expression in the body of the lambda. Nothing will change
 	 * if the lambda already has a value in the body attribute.
diff --git a/src/main/java/spoon/reflect/factory/ExecutableFactory.java b/src/main/java/spoon/reflect/factory/ExecutableFactory.java
index a4310c992..0a8881490 100644
--- a/src/main/java/spoon/reflect/factory/ExecutableFactory.java
+++ b/src/main/java/spoon/reflect/factory/ExecutableFactory.java
@@ -111,7 +111,8 @@ public class ExecutableFactory extends SubFactory {
 			boolean isStatic = ((CtMethod) e).hasModifier(ModifierKind.STATIC);
 			return createReference(((CtMethod<T>) e).getDeclaringType().getReference(), isStatic, ((CtMethod<T>) e).getType().clone(), executableName, refs);
 		} else if (e instanceof CtLambda) {
-			return createReference(e.getParent(CtType.class).getReference(), e.getType(), executableName, refs);
+			CtMethod<T> lambdaMethod = ((CtLambda) e).getOverriddenMethod();
+			return createReference(e.getParent(CtType.class).getReference(), lambdaMethod == null ? null : lambdaMethod.getType(), executableName, refs);
 		} else if (e instanceof CtAnonymousExecutable) {
 			return createReference(((CtAnonymousExecutable) e).getDeclaringType().getReference(), e.getType().clone(), executableName);
 		}
diff --git a/src/main/java/spoon/support/reflect/code/CtLambdaImpl.java b/src/main/java/spoon/support/reflect/code/CtLambdaImpl.java
index 90da466f5..cc74f8c79 100644
--- a/src/main/java/spoon/support/reflect/code/CtLambdaImpl.java
+++ b/src/main/java/spoon/support/reflect/code/CtLambdaImpl.java
@@ -23,8 +23,11 @@ import spoon.reflect.code.CtExpression;
 import spoon.reflect.code.CtLambda;
 import spoon.reflect.code.CtStatement;
 import spoon.reflect.declaration.CtExecutable;
+import spoon.reflect.declaration.CtMethod;
 import spoon.reflect.declaration.CtNamedElement;
 import spoon.reflect.declaration.CtParameter;
+import spoon.reflect.declaration.CtType;
+import spoon.reflect.declaration.ModifierKind;
 import spoon.reflect.reference.CtExecutableReference;
 import spoon.reflect.reference.CtTypeReference;
 import spoon.reflect.visitor.CtVisitor;
@@ -86,6 +89,41 @@ public class CtLambdaImpl<T> extends CtExpressionImpl<T> implements CtLambda<T>
 		return (C) this;
 	}
 
+	@SuppressWarnings("unchecked")
+	@Override
+	public <R> CtMethod<R> getOverriddenMethod() {
+		//The type of this lambda expression. For example: `Consumer<Integer>`
+		CtTypeReference<T> lambdaTypeRef = getType();
+		if (lambdaTypeRef == null) {
+			//it can be null in noclasspath mode, so we do not know which method is called, by lambda
+			return null;
+		}
+		CtType<T> lambdaType = lambdaTypeRef.getTypeDeclaration();
+		if (lambdaType.isInterface() == false) {
+			throw new SpoonException("The lambda can be based on interface only. But type " + lambdaTypeRef.getQualifiedName() + " is not an interface");
+		}
+		Set<CtMethod<?>> lambdaTypeMethods = lambdaType.getAllMethods();
+		CtMethod<?> lambdaExecutableMethod = null;
+		if (lambdaTypeMethods.size() == 1) {
+			//even the default method can be used, if it is the only one
+			lambdaExecutableMethod = lambdaTypeMethods.iterator().next();
+		} else {
+			for (CtMethod<?> method : lambdaTypeMethods) {
+				if (method.isDefaultMethod() || method.hasModifier(ModifierKind.PRIVATE)) {
+					continue;
+				}
+				if (lambdaExecutableMethod != null) {
+					throw new SpoonException("The lambda can be based on interface, which has only one method. But " + lambdaTypeRef.getQualifiedName() + " has at least two: " + lambdaExecutableMethod.getSignature() + " and " + method.getSignature());
+				}
+				lambdaExecutableMethod = method;
+			}
+		}
+		if (lambdaExecutableMethod == null) {
+			throw new SpoonException("The lambda can be based on interface, which has one method. But " + lambdaTypeRef.getQualifiedName() + " has no one");
+		}
+		return (CtMethod<R>) lambdaExecutableMethod;
+	}
+
 	@Override
 	public List<CtParameter<?>> getParameters() {
 		return unmodifiableList(parameters);
diff --git a/src/test/java/spoon/test/lambda/LambdaTest.java b/src/test/java/spoon/test/lambda/LambdaTest.java
index cb6af294c..08c6ccd2f 100644
--- a/src/test/java/spoon/test/lambda/LambdaTest.java
+++ b/src/test/java/spoon/test/lambda/LambdaTest.java
@@ -29,6 +29,7 @@ import spoon.testing.utils.ModelUtils;
 
 import java.io.File;
 import java.util.List;
+import java.util.function.Consumer;
 import java.util.function.Predicate;
 import java.util.stream.Collectors;
 
@@ -341,6 +342,32 @@ public class LambdaTest {
 		assertNotNull(collect);
 		assertEquals(1, collect.size());
 	}
+	
+	@Test
+	public void testEqualsLambdaParameterRef() throws Exception {
+		CtLambda<?> lambda = getLambdaInFooByNumber(8);
+		CtParameter<?> param = (CtParameter<?>)lambda.getParameters().get(0);
+		CtParameterReference paramRef1 = param.getReference();
+		CtParameterReference paramRef2 = lambda.filterChildren(new TypeFilter<>(CtParameterReference.class)).first();
+		assertTrue(paramRef1.getDeclaringExecutable().getType().equals(paramRef2.getDeclaringExecutable().getType())); 
+		assertTrue(paramRef1.equals(paramRef2));
+	}
+
+	@Test
+	public void testLambdaMethod() throws Exception {
+		CtLambda<?> lambda = getLambdaInFooByNumber(8);
+		CtMethod<?> method = lambda.getOverriddenMethod();
+		CtTypeReference<?> iface = lambda.getType();
+		assertEquals(Consumer.class.getName(), iface.getQualifiedName());
+		assertEquals(iface.getTypeDeclaration().getMethodsByName("accept").get(0), method);
+/* This assertion fails now		
+		CtExecutableReference<?> lambdaRef = lambda.getReference();
+		CtExecutableReference<?> methodRef = lambdaRef.getOverridingExecutable();
+// because methodRef is null
+		CtExecutable<?> method2 = methodRef.getDeclaration();
+		assertEquals("The lambda.getMethod() != lambda.getReference().getOverridingExecutable().getDeclaration()", method, method2);
+*/
+	}
 
 	private void assertTypedBy(Class<?> expectedType, CtTypeReference<?> type) {
 		assertEquals("Lambda must be typed", expectedType, type.getActualClass());
diff --git a/src/test/java/spoon/test/lambda/testclasses/Foo.java b/src/test/java/spoon/test/lambda/testclasses/Foo.java
index 28baffa62..10d7e3578 100644
--- a/src/test/java/spoon/test/lambda/testclasses/Foo.java
+++ b/src/test/java/spoon/test/lambda/testclasses/Foo.java
@@ -2,6 +2,7 @@ package spoon.test.lambda.testclasses;
 
 import java.util.ArrayList;
 import java.util.List;
+import java.util.function.Consumer;
 import java.util.function.Predicate;
 
 public class Foo {
@@ -48,6 +49,12 @@ public class Foo {
 		}
 	}
 
+	public void m9() {
+		Consumer<Integer> c = (field)->{
+			field=1;
+		};
+	}
+
 	public static void printPersonsWithPredicate(List<Person> roster, Predicate<Person> tester) {
 		for (Person p : roster) {
 			if (tester.test(p)) {
