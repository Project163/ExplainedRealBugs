diff --git a/src/main/java/spoon/reflect/reference/CtTypeReference.java b/src/main/java/spoon/reflect/reference/CtTypeReference.java
index 43c05efe3..13fdfeff2 100644
--- a/src/main/java/spoon/reflect/reference/CtTypeReference.java
+++ b/src/main/java/spoon/reflect/reference/CtTypeReference.java
@@ -21,6 +21,7 @@ import java.util.Collection;
 import java.util.Set;
 
 import spoon.reflect.declaration.CtSimpleType;
+import spoon.reflect.declaration.ModifierKind;
 
 /**
  * This interface defines a reference to a
@@ -144,6 +145,11 @@ public interface CtTypeReference<T> extends CtReference,
 	 */
 	Set<CtTypeReference<?>> getSuperInterfaces();
 
+	/**
+	 * Gets modifiers of this type.
+	 */
+	Set<ModifierKind> getModifiers();
+
 	/**
 	 * Returns true if the reference refers to the super implementation
 	 */
diff --git a/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java b/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java
index cbd3a4a6a..83e79d773 100644
--- a/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java
+++ b/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java
@@ -1791,7 +1791,8 @@ public class DefaultJavaPrettyPrinter implements CtVisitor, PrettyPrinter {
 			write(ref.getSimpleName());
 		} else {
 			if (ref.getDeclaringType() != null) {
-				if (!context.currentThis.contains(ref.getDeclaringType())) {
+				if (!context.currentThis.contains(ref.getDeclaringType())
+						|| ref.getModifiers().contains(ModifierKind.STATIC)) {
 					if (!context.ignoreEnclosingClass) {
 //						boolean ign = context.ignoreGenerics;
 //						context.ignoreGenerics = false;
diff --git a/src/test/java/spoon/test/imports/ImportTest.java b/src/test/java/spoon/test/imports/ImportTest.java
index e44cff2a1..17c6f9e87 100644
--- a/src/test/java/spoon/test/imports/ImportTest.java
+++ b/src/test/java/spoon/test/imports/ImportTest.java
@@ -5,12 +5,16 @@ import org.junit.Test;
 import spoon.Launcher;
 import spoon.compiler.SpoonCompiler;
 import spoon.compiler.SpoonResourceHelper;
+import spoon.reflect.code.CtConstructorCall;
+import spoon.reflect.code.CtNewClass;
 import spoon.reflect.declaration.CtClass;
 import spoon.reflect.declaration.CtMethod;
 import spoon.reflect.declaration.CtSimpleType;
 import spoon.reflect.factory.Factory;
 import spoon.reflect.visitor.Query;
+import spoon.reflect.visitor.filter.AbstractFilter;
 import spoon.reflect.visitor.filter.NameFilter;
+import spoon.test.imports.testclasses.SubClass;
 
 import java.util.List;
 
@@ -63,4 +67,39 @@ public class ImportTest {
 		final CtSimpleType<Object> innerClass = factory.Type().get("spoon.test.imports.testclasses.DefaultClientClass$InnerClass");
 		assertEquals("Type of the method must to be InnerClass accessed via DefaultClientClass.", innerClass, methodVisit.getType().getDeclaration());
 	}
+
+	@Test
+	public void testNewInnerClassDefinesInItsClassAndSuperClass() throws Exception {
+		Launcher spoon = new Launcher();
+		Factory factory = spoon.createFactory();
+
+		SpoonCompiler compiler = spoon.createCompiler(
+				factory,
+				SpoonResourceHelper.resources(
+						"./src/test/java/spoon/test/imports/testclasses/SuperClass.java",
+						"./src/test/java/spoon/test/imports/testclasses/SubClass.java"));
+
+		compiler.build();
+		final CtClass<?> subClass = (CtClass<?>) factory.Type().get(SubClass.class);
+		final CtConstructorCall<?> ctNewClass = subClass.getElements(new AbstractFilter<CtConstructorCall<?>>(CtConstructorCall.class) {
+			@Override
+			public boolean matches(CtConstructorCall<?> element) {
+				return true;
+			}
+		}).get(0);
+
+		assertEquals("new spoon.test.imports.testclasses.SubClass.Item(\"\")", ctNewClass.toString());
+		final String expected = "public class SubClass extends spoon.test.imports.testclasses.SuperClass {\n"
+				+ "    public void aMethod() {\n"
+				+ "        new spoon.test.imports.testclasses.SubClass.Item(\"\");\n"
+				+ "    }\n"
+				+ "\n"
+				+ "    public static class Item extends spoon.test.imports.testclasses.SuperClass.Item {\n"
+				+ "        public Item(java.lang.String s) {\n"
+				+ "            super(1, s);\n"
+				+ "        }\n"
+				+ "    }\n"
+				+ "}";
+		assertEquals(expected, subClass.toString());
+	}
 }
diff --git a/src/test/java/spoon/test/imports/testclasses/SubClass.java b/src/test/java/spoon/test/imports/testclasses/SubClass.java
new file mode 100644
index 000000000..7d71155b2
--- /dev/null
+++ b/src/test/java/spoon/test/imports/testclasses/SubClass.java
@@ -0,0 +1,13 @@
+package spoon.test.imports.testclasses;
+
+public class SubClass extends SuperClass {
+	public void aMethod() {
+		new SubClass.Item("");
+	}
+
+	public static class Item extends SuperClass.Item {
+		public Item(String s) {
+			super(1, s);
+		}
+	}
+}
diff --git a/src/test/java/spoon/test/imports/testclasses/SuperClass.java b/src/test/java/spoon/test/imports/testclasses/SuperClass.java
new file mode 100644
index 000000000..38bddb965
--- /dev/null
+++ b/src/test/java/spoon/test/imports/testclasses/SuperClass.java
@@ -0,0 +1,8 @@
+package spoon.test.imports.testclasses;
+
+public class SuperClass {
+	public static class Item {
+		public Item(int i, String s) {
+		}
+	}
+}
