diff --git a/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilderHelper.java b/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilderHelper.java
index 6615edef0..e9446c943 100644
--- a/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilderHelper.java
+++ b/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilderHelper.java
@@ -659,7 +659,11 @@ public class JDTTreeBuilderHelper {
 		} else if (ref.isStatic()) {
 			target = createTypeAccess(qualifiedNameReference, ref);
 		} else if (!ref.isStatic() && !ref.getDeclaringType().isAnonymous()) {
-			target = jdtTreeBuilder.getFactory().Code().createThisAccess(jdtTreeBuilder.getReferencesBuilder().<Object>getTypeReference(qualifiedNameReference.actualReceiverType), true);
+			if (ref.getDeclaringType().getDeclaredField(ref.getSimpleName()) == null) {
+				target = createTypeAccessNoClasspath(qualifiedNameReference);
+			} else {
+				target = jdtTreeBuilder.getFactory().Code().createThisAccess(jdtTreeBuilder.getReferencesBuilder().<Object>getTypeReference(qualifiedNameReference.actualReceiverType), true);
+			}
 		}
 		return target;
 	}
diff --git a/src/test/java/spoon/test/targeted/TargetedExpressionTest.java b/src/test/java/spoon/test/targeted/TargetedExpressionTest.java
index 4333b59d6..b1456cd59 100644
--- a/src/test/java/spoon/test/targeted/TargetedExpressionTest.java
+++ b/src/test/java/spoon/test/targeted/TargetedExpressionTest.java
@@ -29,6 +29,7 @@ import java.util.List;
 import org.junit.Test;
 
 import spoon.Launcher;
+import spoon.reflect.CtModel;
 import spoon.reflect.code.CtExpression;
 import spoon.reflect.code.CtFieldAccess;
 import spoon.reflect.code.CtFieldRead;
@@ -282,6 +283,24 @@ public class TargetedExpressionTest {
 		assertEqualsFieldAccess(new ExpectedTargetedExpression().declaringType(expectedFiiFuu).target(launcher.getFactory().Code().createTypeAccess(expectedFiiFuu)).result("Fii.Fuu.i"), elements.get(9));
 	}
 
+	@Test
+	public void testOnlyStaticTargetFieldReadNoClasspath() {
+		// bug case kindly provided by @slarse
+		// in https://github.com/INRIA/spoon/issues/3329
+		final Launcher launcher = new Launcher();
+		launcher.getEnvironment().setNoClasspath(true);
+		launcher.addInputResource("./src/test/resources/spoon/test/noclasspath/targeted/StaticFieldReadOnly.java");
+		CtModel model = launcher.buildModel();
+
+		List<CtInvocation<?>> invocations = model.getElements(e -> e.getExecutable().getSimpleName().equals("error"));
+		CtInvocation<?> inv = invocations.get(0);
+		CtFieldRead<?> fieldRead = (CtFieldRead<?>) inv.getTarget();
+		CtExpression<?> target = fieldRead.getTarget();
+
+		assertTrue(target instanceof CtTypeAccess);
+		assertEquals("Launcher", ((CtTypeAccess<?>) target).getAccessedType().getSimpleName());
+	}
+
 	@Test
 	public void testTargetsOfInv() throws Exception {
 		// contract: Specify declaring type of the executable of an invocation, the target of the invocation and its result.
diff --git a/src/test/resources/spoon/test/noclasspath/targeted/StaticFieldReadOnly.java b/src/test/resources/spoon/test/noclasspath/targeted/StaticFieldReadOnly.java
new file mode 100644
index 000000000..7e6dac78a
--- /dev/null
+++ b/src/test/resources/spoon/test/noclasspath/targeted/StaticFieldReadOnly.java
@@ -0,0 +1,7 @@
+import spoon.Launcher;
+
+public class StaticFieldReadOnly {
+	public static void main(String[] args) {
+		Launcher.logger.error("Hello :)");
+	}
+}
