diff --git a/src/test/java/spoon/reflect/visitor/DefaultJavaPrettyPrinterTest.java b/src/test/java/spoon/reflect/visitor/DefaultJavaPrettyPrinterTest.java
index 5e74f2ddc..d6c7d39eb 100644
--- a/src/test/java/spoon/reflect/visitor/DefaultJavaPrettyPrinterTest.java
+++ b/src/test/java/spoon/reflect/visitor/DefaultJavaPrettyPrinterTest.java
@@ -130,6 +130,38 @@ public class DefaultJavaPrettyPrinterTest {
         return launcher;
     }
 
+    @Nested
+    class LongStringAssignmentInUnchangedFile {
+        // This is the string LITERAL that we hope is the pretty-printed value for the "sql" variable.
+        // This was obtained from the output produced by the pretty printer at the time, but notice importantly
+        // that the parenthesis presented in the original issue (https://github.com/INRIA/spoon/issues/5001) around "from..."
+        // and before "binaryIpStart" are not present, which is essentially what the original issue seems to be about.
+        private String expectedStringLiteral = "\"Select distinct t.NETWORK_IP, t.NETWORK_IP1, t.NETWORK_IP2, " +
+                "t.NETWORK_IP3, t.NETWORK_IP4 \" + \"from (SELECT DISTINCT t1.ipv4digit1 || '.' || t1.ipv4digit2 " +
+                "|| '.' || t1.ipv4digit3 \" + \" || '.0' network_ip, \" + \" TO_NUMBER (t1.ipv4digit1) network_ip1, \" + \" TO_NUMBER " +
+                "(t1.ipv4digit2) network_ip2, \" + \" TO_NUMBER (t1.ipv4digit3) network_ip3, \" + \" TO_NUMBER ('0') " +
+                "network_ip4, t1.t2_team_id, \" + \" t1.system_owner_id, t1.system_owner_team_id \" + \" FROM ip_info t1 \" + \" where " +
+                "t1.binary_ip >= '\" + binaryIpStart + \"' \" + \" and t1.binary_ip <= '\" + binaryIpEnd + \"' \" + \" " +
+                "ORDER BY network_ip1, network_ip2, network_ip3  \" + \" ) t order by t.NETWORK_IP1,t.NETWORK_IP2,t.NETWORK_IP3,t.NETWORK_IP4 \"";
+
+        @Test
+        @GitHubIssue(issueNumber = 5001, fixed = true)
+        void testSameOutputWithOptimizedParenthesis() {
+            Launcher launcher = createLauncherWithOptimizeParenthesesPrinter();
+            launcher.addInputResource("src/test/java/spoon/test/prettyprinter/testclasses/SampleClassIssue5001.java");
+            launcher.buildModel();
+
+            // Since there is only one class, there is only one entity returned by "getAll"
+            CtCompilationUnit cu = launcher.getFactory().Type().getAll().get(0)
+                    .getPosition().getCompilationUnit();
+
+            PrettyPrinter prettyPrinter = launcher.createPrettyPrinter();
+            String output = prettyPrinter.prettyprint(cu);
+
+            assertThat(output, containsString(expectedStringLiteral));
+        }
+    }
+
 
     @Test
     void testAutoImportPrinterDoesNotImportFunctionalInterfaceTargetedInLambda() {
diff --git a/src/test/java/spoon/test/eval/EvalTest.java b/src/test/java/spoon/test/eval/EvalTest.java
index e29b424b8..e230e3a74 100644
--- a/src/test/java/spoon/test/eval/EvalTest.java
+++ b/src/test/java/spoon/test/eval/EvalTest.java
@@ -18,6 +18,9 @@ package spoon.test.eval;
 
 
 import java.io.File;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.List;
@@ -55,6 +58,7 @@ import spoon.reflect.eval.PartialEvaluator;
 import spoon.reflect.factory.Factory;
 import spoon.reflect.reference.CtTypeReference;
 import spoon.reflect.visitor.AccessibleVariablesFinder;
+import spoon.reflect.visitor.CtScanner;
 import spoon.reflect.visitor.OperatorHelper;
 import spoon.reflect.visitor.filter.TypeFilter;
 import spoon.support.compiler.VirtualFile;
@@ -62,6 +66,7 @@ import spoon.support.reflect.eval.EvalHelper;
 import spoon.support.reflect.eval.InlinePartialEvaluator;
 import spoon.support.reflect.eval.VisitorPartialEvaluator;
 import spoon.test.eval.testclasses.Foo;
+import spoon.testing.utils.GitHubIssue;
 
 import static org.junit.jupiter.api.Assertions.*;
 import static spoon.testing.utils.ModelUtils.build;
@@ -609,4 +614,28 @@ public class EvalTest {
 			ctLiteral
 		);
 	}
+
+	@Test
+	@GitHubIssue(issueNumber = 5001, fixed = true)
+	public void testVisitCtLiteralWithLongStringValue() throws Exception {
+		CtClass<?> ctClass = Launcher.parseClass(Files.readString(Paths.get("src/test/java/spoon/test/prettyprinter/testclasses/SampleClassIssue5001.java")));
+		CtExpression<?> sql = ctClass.getField("sql").getAssignment();
+		StringBuilder result = new StringBuilder();
+		sql.accept(new CtScanner() {
+			@Override
+			public <T> void visitCtLiteral(CtLiteral<T> literal) {
+				result.append(literal.getValue());
+			}
+		});
+
+		String expectedValue = "Select distinct t.NETWORK_IP, t.NETWORK_IP1, t.NETWORK_IP2, " +
+				"t.NETWORK_IP3, t.NETWORK_IP4 from (SELECT DISTINCT t1.ipv4digit1 || '.' || t1.ipv4digit2 || '.' || " +
+				"t1.ipv4digit3 || '.0' network_ip, TO_NUMBER (t1.ipv4digit1) network_ip1, TO_NUMBER (t1.ipv4digit2) " +
+				"network_ip2, TO_NUMBER (t1.ipv4digit3) network_ip3, TO_NUMBER ('0') network_ip4, t1.t2_team_id, " +
+				"t1.system_owner_id, t1.system_owner_team_id FROM ip_info t1 where t1.binary_ip >= '' and t1.binary_ip " +
+				"<= '' ORDER BY network_ip1, network_ip2, network_ip3 ) t order by t.NETWORK_IP1,t.NETWORK_IP2,t.NETWORK_IP3,t.NETWORK_IP4";
+
+		String actualValue = result.toString().strip().replaceAll("\\s{2,}", " ");
+		assertEquals(expectedValue, actualValue);
+	}
 }
diff --git a/src/test/java/spoon/test/prettyprinter/TestSniperPrinter.java b/src/test/java/spoon/test/prettyprinter/TestSniperPrinter.java
index 0bd4392ae..b559bcb81 100644
--- a/src/test/java/spoon/test/prettyprinter/TestSniperPrinter.java
+++ b/src/test/java/spoon/test/prettyprinter/TestSniperPrinter.java
@@ -1175,6 +1175,15 @@ public class TestSniperPrinter {
 			refactor.refactor();
 		}, (type, result) -> assertThat(result, containsString("((Double) b).toString();")));
 	}
+
+	@Test
+	@GitHubIssue(issueNumber = 5001, fixed = true)
+	public void testCorrectPrintingOfUnchangedStringAssignment() throws IOException {
+		// We want to make sure that if there are no changes made to the source code, then the output is the same
+		// as the input.
+		testNoChangeDiffFailing(
+				Paths.get("src/test/java/spoon/test/prettyprinter/testclasses/SampleClassIssue5001").toFile());
+	}
 	/**
 	 * Test various syntax by doing an change to every element that should not
 	 * result in any change in source. This forces the sniper printer to recreate
diff --git a/src/test/java/spoon/test/prettyprinter/testclasses/SampleClassIssue5001.java b/src/test/java/spoon/test/prettyprinter/testclasses/SampleClassIssue5001.java
new file mode 100644
index 000000000..88f817a49
--- /dev/null
+++ b/src/test/java/spoon/test/prettyprinter/testclasses/SampleClassIssue5001.java
@@ -0,0 +1,19 @@
+package spoon.test.prettyprinter.testclasses;
+
+public class SampleClassIssue5001 {
+    String binaryIpStart = "start";
+    String binaryIpEnd = "end";
+    String sql = "Select distinct t.NETWORK_IP, t.NETWORK_IP1, t.NETWORK_IP2, t.NETWORK_IP3, t.NETWORK_IP4 " +
+            "from (SELECT DISTINCT t1.ipv4digit1 || '.' || t1.ipv4digit2 || '.' || t1.ipv4digit3 " +
+            " || '.0' network_ip, " +
+            " TO_NUMBER (t1.ipv4digit1) network_ip1, " +
+            " TO_NUMBER (t1.ipv4digit2) network_ip2, " +
+            " TO_NUMBER (t1.ipv4digit3) network_ip3, " +
+            " TO_NUMBER ('0') network_ip4, t1.t2_team_id, " +
+            " t1.system_owner_id, t1.system_owner_team_id " +
+            " FROM ip_info t1 " +
+            " where t1.binary_ip >= '" + binaryIpStart + "' " +
+            " and t1.binary_ip <= '" + binaryIpEnd + "' " +
+            " ORDER BY network_ip1, network_ip2, network_ip3  " +
+            " ) t order by t.NETWORK_IP1,t.NETWORK_IP2,t.NETWORK_IP3,t.NETWORK_IP4 ";
+}
\ No newline at end of file
