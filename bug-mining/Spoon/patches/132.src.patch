diff --git a/doc/command_line.md b/doc/command_line.md
index 245507bad..bae2eb8b5 100644
--- a/doc/command_line.md
+++ b/doc/command_line.md
@@ -129,4 +129,8 @@ Options :
   [(-f|--generate-files) <generate-files>]
         Only generate the given fully qualified java classes (separated by ':'
         if multiple are given).
+
+  [-a|--disable-model-self-checks]
+        Disables checks made on the AST (hashcode violation, method's signature
+        violation and parent violation). Default: false.
 ```
\ No newline at end of file
diff --git a/src/main/java/spoon/Launcher.java b/src/main/java/spoon/Launcher.java
index 1772473bc..93bc22b7a 100644
--- a/src/main/java/spoon/Launcher.java
+++ b/src/main/java/spoon/Launcher.java
@@ -396,6 +396,14 @@ public class Launcher implements SpoonAPI {
 			opt2.setRequired(false);
 			jsap.registerParameter(opt2);
 
+			// Disable checks.
+			sw1 = new Switch("disable-model-self-checks");
+			sw1.setShortFlag('a');
+			sw1.setLongFlag("disable-model-self-checks");
+			sw1.setHelp("Disables checks made on the AST (hashcode violation, method's signature violation and parent violation). Default: false.");
+			sw1.setDefault("false");
+			jsap.registerParameter(sw1);
+
 			return jsap;
 		} catch (JSAPException e) {
 			throw new SpoonException(e.getMessage(), e);
@@ -430,6 +438,7 @@ public class Launcher implements SpoonAPI {
 		environment.setCommentEnabled(jsapActualArgs.getBoolean("enable-comments"));
 
 		environment.setShouldCompile(jsapActualArgs.getBoolean("compile"));
+		environment.setSelfChecks(jsapActualArgs.getBoolean("disable-model-self-checks"));
 
 		if (getArguments().getString("generate-files") != null) {
 			setOutputFilter(getArguments().getString("generate-files").split(":"));
diff --git a/src/main/java/spoon/compiler/Environment.java b/src/main/java/spoon/compiler/Environment.java
index ec1acaa5f..1cd77296d 100644
--- a/src/main/java/spoon/compiler/Environment.java
+++ b/src/main/java/spoon/compiler/Environment.java
@@ -23,6 +23,7 @@ import spoon.processing.ProcessingManager;
 import spoon.processing.Processor;
 import spoon.processing.ProcessorProperties;
 import spoon.reflect.declaration.CtElement;
+import spoon.reflect.declaration.CtMethod;
 import spoon.reflect.factory.Factory;
 
 import java.io.File;
@@ -334,4 +335,18 @@ public interface Environment {
 	 * Sets the compile argument.
 	 */
 	void setShouldCompile(boolean shouldCompile);
+
+	/**
+	 * Checks if {@link spoon.reflect.visitor.AstParentConsistencyChecker},
+	 * hashcode violation declared in CtElement#equals(CtElement) and
+	 * method violation declared in {@link spoon.reflect.declaration.CtType#addMethod(CtMethod)}
+	 * are active or not.
+	 */
+	boolean checksAreSkipped();
+
+	/**
+	 * Enable or not checks on the AST. See {@link #checksAreSkipped()} to know all checks enabled.
+	 * true means that no self checks are made.
+	 */
+	void setSelfChecks(boolean skip);
 }
diff --git a/src/main/java/spoon/support/StandardEnvironment.java b/src/main/java/spoon/support/StandardEnvironment.java
index 478374113..547eac5c6 100644
--- a/src/main/java/spoon/support/StandardEnvironment.java
+++ b/src/main/java/spoon/support/StandardEnvironment.java
@@ -99,6 +99,8 @@ public class StandardEnvironment implements Serializable, Environment {
 
 	private boolean shouldCompile;
 
+	private boolean skipSelfChecks;
+
 	/**
 	 * Creates a new environment with a <code>null</code> default file
 	 * generator.
@@ -152,6 +154,16 @@ public class StandardEnvironment implements Serializable, Environment {
 		this.shouldCompile = shouldCompile;
 	}
 
+	@Override
+	public boolean checksAreSkipped() {
+		return skipSelfChecks;
+	}
+
+	@Override
+	public void setSelfChecks(boolean skip) {
+		skipSelfChecks = skip;
+	}
+
 	private Level toLevel(String level) {
 		if (level == null || level.isEmpty()) {
 			throw new SpoonException("Wrong level given at Spoon.");
diff --git a/src/main/java/spoon/support/compiler/jdt/JDTBasedSpoonCompiler.java b/src/main/java/spoon/support/compiler/jdt/JDTBasedSpoonCompiler.java
index 3c5f29428..44316087e 100644
--- a/src/main/java/spoon/support/compiler/jdt/JDTBasedSpoonCompiler.java
+++ b/src/main/java/spoon/support/compiler/jdt/JDTBasedSpoonCompiler.java
@@ -136,7 +136,9 @@ public class JDTBasedSpoonCompiler implements SpoonCompiler {
 	}
 
 	private void checkModel() {
-		factory.getModel().getRootPackage().accept(new AstParentConsistencyChecker());
+		if (!factory.getEnvironment().checksAreSkipped()) {
+			factory.getModel().getRootPackage().accept(new AstParentConsistencyChecker());
+		}
 	}
 
 	@Override
diff --git a/src/main/java/spoon/support/reflect/declaration/CtElementImpl.java b/src/main/java/spoon/support/reflect/declaration/CtElementImpl.java
index 82811fc61..587db418a 100644
--- a/src/main/java/spoon/support/reflect/declaration/CtElementImpl.java
+++ b/src/main/java/spoon/support/reflect/declaration/CtElementImpl.java
@@ -145,7 +145,7 @@ public abstract class CtElementImpl implements CtElement, Serializable, Comparab
 		}
 		boolean ret = EqualsVisitor.equals(this, (CtElement) o);
 		// neat online testing of core Java contract
-		if (ret && this.hashCode() != o.hashCode()) {
+		if (ret && !factory.getEnvironment().checksAreSkipped() && this.hashCode() != o.hashCode()) {
 			throw new IllegalStateException("violation of equal/hashcode contract between \n" + getDeepRepresentation(this) + "\nand\n" + getDeepRepresentation((CtElement) o) + "\n");
 		}
 		return ret;
diff --git a/src/main/java/spoon/support/reflect/declaration/CtTypeImpl.java b/src/main/java/spoon/support/reflect/declaration/CtTypeImpl.java
index 65357f9e5..ca385e247 100644
--- a/src/main/java/spoon/support/reflect/declaration/CtTypeImpl.java
+++ b/src/main/java/spoon/support/reflect/declaration/CtTypeImpl.java
@@ -450,7 +450,7 @@ public abstract class CtTypeImpl<T> extends CtNamedElementImpl implements CtType
 				methods.remove(m);
 			} else {
 				// checking contract signature implies equal
-				if (m.equals(method)) {
+				if (!factory.getEnvironment().checksAreSkipped() && m.equals(method)) {
 					throw new AssertionError("violation of core contract! different signature but same equal");
 				}
 			}
