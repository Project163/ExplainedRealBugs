diff --git a/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java b/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
index 473598785..910bb7373 100644
--- a/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
+++ b/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
@@ -3082,7 +3082,8 @@ public class JDTTreeBuilder extends ASTVisitor {
 			CtTypeAccess<Object> ta = factory.Code().createTypeAccess(references.getTypeReference((TypeBinding) singleNameReference.binding));
 			context.enter(ta, singleNameReference);
 		} else if (singleNameReference.binding instanceof ProblemBinding) {
-			if (context.stack.peek().element instanceof CtInvocation) {
+			if (context.stack.peek().element instanceof CtInvocation
+					&& CharOperation.charToString(singleNameReference.token).equals(((CtInvocation) context.stack.peek().element).getExecutable().getDeclaringType().getSimpleName())) {
 				CtTypeReference<Object> typeReference = factory.Core().createTypeReference();
 				typeReference.setSimpleName(new String(singleNameReference.binding.readableName()));
 				final CtReference declaring = references.getDeclaringReferenceFromImports(singleNameReference.token);
diff --git a/src/test/java/spoon/test/reference/TypeReferenceTest.java b/src/test/java/spoon/test/reference/TypeReferenceTest.java
index 41ec65733..18a5fcf53 100644
--- a/src/test/java/spoon/test/reference/TypeReferenceTest.java
+++ b/src/test/java/spoon/test/reference/TypeReferenceTest.java
@@ -5,6 +5,7 @@ import spoon.Launcher;
 import spoon.compiler.SpoonCompiler;
 import spoon.compiler.SpoonResource;
 import spoon.compiler.SpoonResourceHelper;
+import spoon.reflect.code.CtFieldRead;
 import spoon.reflect.code.CtInvocation;
 import spoon.reflect.declaration.CtClass;
 import spoon.reflect.declaration.CtField;
@@ -347,6 +348,25 @@ public class TypeReferenceTest {
 		assertEquals("example.FooBar<?, ? extends Tacos<?>>.Bar<?, ? extends Tacos<?>>", superInterface.toString());
 	}
 
+	@Test
+	public void testArgumentOfAInvocationIsNotATypeAccess() throws Exception {
+		// contract: In no classpath, an unknown field specified as argument isn't a CtTypeAccess.
+		final Launcher launcher = new Launcher();
+		launcher.addInputResource("./src/test/resources/noclasspath/Demo3.java");
+		launcher.setSourceOutputDirectory("./target/class-declaration");
+		launcher.getEnvironment().setNoClasspath(true);
+		launcher.run();
+
+		final CtClass<Object> demo3 = launcher.getFactory().Class().get("Demo3");
+		final List<CtFieldRead> fields = demo3.getElements(new TypeFilter<CtFieldRead>(CtFieldRead.class) {
+			@Override
+			public boolean matches(CtFieldRead element) {
+				return "bar".equals(element.getVariable().getSimpleName()) && super.matches(element);
+			}
+		});
+		assertEquals(1, fields.size());
+	}
+
 	class A {
 		class Tacos<K> {
 		}
diff --git a/src/test/resources/noclasspath/Demo3.java b/src/test/resources/noclasspath/Demo3.java
new file mode 100644
index 000000000..7902fa394
--- /dev/null
+++ b/src/test/resources/noclasspath/Demo3.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2006-2015 INRIA and contributors
+ * Spoon - http://spoon.gforge.inria.fr/
+ *
+ * This software is governed by the CeCILL-C License under French law and
+ * abiding by the rules of distribution of free software. You can use, modify
+ * and/or redistribute the software under the terms of the CeCILL-C license as
+ * circulated by CEA, CNRS and INRIA at http://www.cecill.info.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the CeCILL-C License for more details.
+ *
+ * The fact that you are presently reading this means that you have had
+ * knowledge of the CeCILL-C license and that you accept its terms.
+ */
+
+public class Demo3 extends Foo {
+
+	void doSomething() {
+		System.out.println(bar);
+	}
+
+}
\ No newline at end of file
