diff --git a/src/main/java/spoon/reflect/factory/InternalFactory.java b/src/main/java/spoon/reflect/factory/InternalFactory.java
index 2537ce77f..796cef52f 100644
--- a/src/main/java/spoon/reflect/factory/InternalFactory.java
+++ b/src/main/java/spoon/reflect/factory/InternalFactory.java
@@ -1,6 +1,7 @@
 package spoon.reflect.factory;
 
 import spoon.reflect.internal.CtCircularTypeReference;
+import spoon.reflect.internal.CtImplicitArrayTypeReference;
 import spoon.reflect.internal.CtImplicitTypeReference;
 
 /**
@@ -18,4 +19,9 @@ public interface InternalFactory {
 	 * Creates a inference type reference.
 	 */
 	<T> CtImplicitTypeReference<T> createImplicitTypeReference();
+
+	/**
+	 * Creates an implicit array type reference.
+	 */
+	<T> CtImplicitArrayTypeReference<T> createImplicitArrayTypeReference();
 }
diff --git a/src/main/java/spoon/reflect/internal/CtImplicitArrayTypeReference.java b/src/main/java/spoon/reflect/internal/CtImplicitArrayTypeReference.java
new file mode 100644
index 000000000..5b5fbf76f
--- /dev/null
+++ b/src/main/java/spoon/reflect/internal/CtImplicitArrayTypeReference.java
@@ -0,0 +1,17 @@
+package spoon.reflect.internal;
+
+import spoon.reflect.reference.CtArrayTypeReference;
+
+/**
+ * This interface defines a reference to an array but when this array is implicit
+ * like given in the diamond operator or parameter of a lambda.
+ *
+ * {@code
+ * final AtomicReference<AtomicLong[]> atomicReference = new AtomicReference<>(EMPTY);
+ * }
+ *
+ * @param <T>
+ * 		Implicit type.
+ */
+public interface CtImplicitArrayTypeReference<T> extends CtArrayTypeReference<T> {
+}
diff --git a/src/main/java/spoon/reflect/visitor/CtAbstractVisitor.java b/src/main/java/spoon/reflect/visitor/CtAbstractVisitor.java
index 38e83793d..157797b81 100644
--- a/src/main/java/spoon/reflect/visitor/CtAbstractVisitor.java
+++ b/src/main/java/spoon/reflect/visitor/CtAbstractVisitor.java
@@ -61,6 +61,7 @@ import spoon.reflect.declaration.CtMethod;
 import spoon.reflect.declaration.CtPackage;
 import spoon.reflect.declaration.CtParameter;
 import spoon.reflect.declaration.CtTypeParameter;
+import spoon.reflect.internal.CtImplicitArrayTypeReference;
 import spoon.reflect.reference.CtArrayTypeReference;
 import spoon.reflect.reference.CtCatchVariableReference;
 import spoon.reflect.internal.CtCircularTypeReference;
@@ -156,6 +157,11 @@ public abstract class CtAbstractVisitor implements CtVisitor {
 
 	}
 
+	@Override
+	public <T> void visitCtImplicitArrayTypeReference(CtImplicitArrayTypeReference<T> reference) {
+
+	}
+
 	@Override
 	public <T> void visitCtAssert(CtAssert<T> asserted) {
 
diff --git a/src/main/java/spoon/reflect/visitor/CtInheritanceScanner.java b/src/main/java/spoon/reflect/visitor/CtInheritanceScanner.java
index a20016ab4..8d4969d7f 100644
--- a/src/main/java/spoon/reflect/visitor/CtInheritanceScanner.java
+++ b/src/main/java/spoon/reflect/visitor/CtInheritanceScanner.java
@@ -95,6 +95,7 @@ import spoon.reflect.declaration.CtTypeMember;
 import spoon.reflect.declaration.CtTypeParameter;
 import spoon.reflect.declaration.CtTypedElement;
 import spoon.reflect.declaration.CtVariable;
+import spoon.reflect.internal.CtImplicitArrayTypeReference;
 import spoon.reflect.reference.CtArrayTypeReference;
 import spoon.reflect.reference.CtCatchVariableReference;
 import spoon.reflect.internal.CtCircularTypeReference;
@@ -390,6 +391,11 @@ public abstract class CtInheritanceScanner implements CtVisitor {
 		visitCtTypeReference(e);
 	}
 
+	@Override
+	public <T> void visitCtImplicitArrayTypeReference(CtImplicitArrayTypeReference<T> reference) {
+		visitCtArrayTypeReference(reference);
+	}
+
 	public <T> void visitCtAssert(CtAssert<T> e) {
 		scanCtStatement(e);
 		scanCtCodeElement(e);
diff --git a/src/main/java/spoon/reflect/visitor/CtScanner.java b/src/main/java/spoon/reflect/visitor/CtScanner.java
index dfb720fdc..678a3330c 100644
--- a/src/main/java/spoon/reflect/visitor/CtScanner.java
+++ b/src/main/java/spoon/reflect/visitor/CtScanner.java
@@ -79,6 +79,7 @@ import spoon.reflect.declaration.CtMethod;
 import spoon.reflect.declaration.CtPackage;
 import spoon.reflect.declaration.CtParameter;
 import spoon.reflect.declaration.CtTypeParameter;
+import spoon.reflect.internal.CtImplicitArrayTypeReference;
 import spoon.reflect.reference.CtArrayTypeReference;
 import spoon.reflect.reference.CtCatchVariableReference;
 import spoon.reflect.internal.CtCircularTypeReference;
@@ -253,6 +254,11 @@ public abstract class CtScanner implements CtVisitor {
 		exitReference(reference);
 	}
 
+	@Override
+	public <T> void visitCtImplicitArrayTypeReference(CtImplicitArrayTypeReference<T> reference) {
+		visitCtArrayTypeReference(reference);
+	}
+
 	public <T> void visitCtAssert(CtAssert<T> asserted) {
 		enter(asserted);
 		scan(asserted.getAnnotations());
diff --git a/src/main/java/spoon/reflect/visitor/CtVisitor.java b/src/main/java/spoon/reflect/visitor/CtVisitor.java
index 02c4a03ab..cdb576562 100644
--- a/src/main/java/spoon/reflect/visitor/CtVisitor.java
+++ b/src/main/java/spoon/reflect/visitor/CtVisitor.java
@@ -77,12 +77,13 @@ import spoon.reflect.declaration.CtMethod;
 import spoon.reflect.declaration.CtPackage;
 import spoon.reflect.declaration.CtParameter;
 import spoon.reflect.declaration.CtTypeParameter;
+import spoon.reflect.internal.CtCircularTypeReference;
+import spoon.reflect.internal.CtImplicitArrayTypeReference;
+import spoon.reflect.internal.CtImplicitTypeReference;
 import spoon.reflect.reference.CtArrayTypeReference;
 import spoon.reflect.reference.CtCatchVariableReference;
-import spoon.reflect.internal.CtCircularTypeReference;
 import spoon.reflect.reference.CtExecutableReference;
 import spoon.reflect.reference.CtFieldReference;
-import spoon.reflect.internal.CtImplicitTypeReference;
 import spoon.reflect.reference.CtLocalVariableReference;
 import spoon.reflect.reference.CtPackageReference;
 import spoon.reflect.reference.CtParameterReference;
@@ -143,6 +144,11 @@ public interface CtVisitor {
 	 */
 	<T> void visitCtArrayTypeReference(CtArrayTypeReference<T> reference);
 
+	/**
+	 * Visits a reference to an implicit array type.
+	 */
+	<T> void visitCtImplicitArrayTypeReference(CtImplicitArrayTypeReference<T> reference);
+
 	/**
 	 * Visits an assert.
 	 */
diff --git a/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java b/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java
index eef92e18d..d122b51bc 100644
--- a/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java
+++ b/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java
@@ -93,6 +93,7 @@ import spoon.reflect.declaration.CtTypeParameter;
 import spoon.reflect.declaration.ModifierKind;
 import spoon.reflect.declaration.ParentNotInitializedException;
 import spoon.reflect.factory.Factory;
+import spoon.reflect.internal.CtImplicitArrayTypeReference;
 import spoon.reflect.reference.CtArrayTypeReference;
 import spoon.reflect.reference.CtCatchVariableReference;
 import spoon.reflect.internal.CtCircularTypeReference;
@@ -641,6 +642,11 @@ public class DefaultJavaPrettyPrinter implements CtVisitor, PrettyPrinter {
 		}
 	}
 
+	@Override
+	public <T> void visitCtImplicitArrayTypeReference(CtImplicitArrayTypeReference<T> reference) {
+		// The array type is implicit, we don't print it!
+	}
+
 	public <T> void visitCtAssert(CtAssert<T> asserted) {
 		enterCtStatement(asserted);
 		write("assert ");
diff --git a/src/main/java/spoon/support/DefaultInternalFactory.java b/src/main/java/spoon/support/DefaultInternalFactory.java
index 3b74af4dc..2d2307e51 100644
--- a/src/main/java/spoon/support/DefaultInternalFactory.java
+++ b/src/main/java/spoon/support/DefaultInternalFactory.java
@@ -3,8 +3,10 @@ package spoon.support;
 import spoon.reflect.factory.Factory;
 import spoon.reflect.factory.InternalFactory;
 import spoon.reflect.internal.CtCircularTypeReference;
+import spoon.reflect.internal.CtImplicitArrayTypeReference;
 import spoon.reflect.internal.CtImplicitTypeReference;
 import spoon.support.reflect.internal.CtCircularTypeReferenceImpl;
+import spoon.support.reflect.internal.CtImplicitArrayTypeReferenceImpl;
 import spoon.support.reflect.internal.CtImplicitTypeReferenceImpl;
 
 public class DefaultInternalFactory implements InternalFactory {
@@ -27,4 +29,11 @@ public class DefaultInternalFactory implements InternalFactory {
 		e.setFactory(mainFactory);
 		return e;
 	}
+
+	@Override
+	public <T> CtImplicitArrayTypeReference<T> createImplicitArrayTypeReference() {
+		final CtImplicitArrayTypeReference<T> e = new CtImplicitArrayTypeReferenceImpl<T>();
+		e.setFactory(mainFactory);
+		return e;
+	}
 }
diff --git a/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java b/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
index d744e0b5f..783247dc9 100644
--- a/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
+++ b/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
@@ -633,7 +633,12 @@ public class JDTTreeBuilder extends ASTVisitor {
 					// }
 				}
 			} else if (binding instanceof ArrayBinding) {
-				CtArrayTypeReference<Object> arrayref = factory.Core().createArrayTypeReference();
+				CtArrayTypeReference<Object> arrayref;
+				if (isImplicit) {
+					arrayref = factory.Internal().createImplicitArrayTypeReference();
+				} else {
+					arrayref = factory.Core().createArrayTypeReference();
+				}
 				ref = arrayref;
 				for (int i = 1; i < binding.dimensions(); i++) {
 					CtArrayTypeReference<Object> tmp = factory.Core().createArrayTypeReference();
diff --git a/src/main/java/spoon/support/reflect/eval/VisitorPartialEvaluator.java b/src/main/java/spoon/support/reflect/eval/VisitorPartialEvaluator.java
index fa64baca3..395ba44c4 100644
--- a/src/main/java/spoon/support/reflect/eval/VisitorPartialEvaluator.java
+++ b/src/main/java/spoon/support/reflect/eval/VisitorPartialEvaluator.java
@@ -88,6 +88,7 @@ import spoon.reflect.declaration.CtTypedElement;
 import spoon.reflect.declaration.CtVariable;
 import spoon.reflect.declaration.ModifierKind;
 import spoon.reflect.eval.PartialEvaluator;
+import spoon.reflect.internal.CtImplicitArrayTypeReference;
 import spoon.reflect.reference.CtArrayTypeReference;
 import spoon.reflect.reference.CtCatchVariableReference;
 import spoon.reflect.internal.CtCircularTypeReference;
@@ -190,6 +191,11 @@ public class VisitorPartialEvaluator implements CtVisitor, PartialEvaluator {
 		throw new RuntimeException("Unknow Element");
 	}
 
+	@Override
+	public <T> void visitCtImplicitArrayTypeReference(CtImplicitArrayTypeReference<T> reference) {
+		throw new RuntimeException("Unknow Element");
+	}
+
 	public <T> void visitCtAssert(CtAssert<T> asserted) {
 		throw new RuntimeException("Unknow Element");
 	}
diff --git a/src/main/java/spoon/support/reflect/internal/CtImplicitArrayTypeReferenceImpl.java b/src/main/java/spoon/support/reflect/internal/CtImplicitArrayTypeReferenceImpl.java
new file mode 100644
index 000000000..5cdd93781
--- /dev/null
+++ b/src/main/java/spoon/support/reflect/internal/CtImplicitArrayTypeReferenceImpl.java
@@ -0,0 +1,12 @@
+package spoon.support.reflect.internal;
+
+import spoon.reflect.internal.CtImplicitArrayTypeReference;
+import spoon.reflect.visitor.CtVisitor;
+import spoon.support.reflect.reference.CtArrayTypeReferenceImpl;
+
+public class CtImplicitArrayTypeReferenceImpl<T> extends CtArrayTypeReferenceImpl<T> implements CtImplicitArrayTypeReference<T> {
+	@Override
+	public void accept(CtVisitor visitor) {
+		visitor.visitCtImplicitArrayTypeReference(this);
+	}
+}
diff --git a/src/main/java/spoon/support/visitor/SignaturePrinter.java b/src/main/java/spoon/support/visitor/SignaturePrinter.java
index 358d0da92..fd8a290cd 100644
--- a/src/main/java/spoon/support/visitor/SignaturePrinter.java
+++ b/src/main/java/spoon/support/visitor/SignaturePrinter.java
@@ -80,6 +80,7 @@ import spoon.reflect.declaration.CtMethod;
 import spoon.reflect.declaration.CtPackage;
 import spoon.reflect.declaration.CtParameter;
 import spoon.reflect.declaration.CtTypeParameter;
+import spoon.reflect.internal.CtImplicitArrayTypeReference;
 import spoon.reflect.reference.CtArrayTypeReference;
 import spoon.reflect.reference.CtCatchVariableReference;
 import spoon.reflect.internal.CtCircularTypeReference;
@@ -178,6 +179,11 @@ public class SignaturePrinter implements CtVisitor {
 		write("[]");
 	}
 
+	@Override
+	public <T> void visitCtImplicitArrayTypeReference(CtImplicitArrayTypeReference<T> reference) {
+		visitCtArrayTypeReference(reference);
+	}
+
 	public <T> void visitCtAssert(CtAssert<T> asserted) {
 		signature.append("assert ");
 		scan(asserted.getAssertExpression());
diff --git a/src/test/java/spoon/test/constructorcallnewclass/ConstructorCallTest.java b/src/test/java/spoon/test/constructorcallnewclass/ConstructorCallTest.java
index 01e1d3406..cc53f2bae 100644
--- a/src/test/java/spoon/test/constructorcallnewclass/ConstructorCallTest.java
+++ b/src/test/java/spoon/test/constructorcallnewclass/ConstructorCallTest.java
@@ -2,12 +2,18 @@ package spoon.test.constructorcallnewclass;
 
 import org.junit.Before;
 import org.junit.Test;
+import spoon.Launcher;
 import spoon.reflect.code.CtConstructorCall;
 import spoon.reflect.declaration.CtClass;
+import spoon.reflect.declaration.CtType;
 import spoon.reflect.factory.Factory;
+import spoon.reflect.internal.CtImplicitArrayTypeReference;
+import spoon.reflect.internal.CtImplicitTypeReference;
+import spoon.reflect.reference.CtTypeReference;
 import spoon.reflect.visitor.filter.AbstractFilter;
-import spoon.test.TestUtils;
+import spoon.reflect.visitor.filter.TypeFilter;
 import spoon.test.constructorcallnewclass.testclasses.Foo;
+import spoon.test.constructorcallnewclass.testclasses.Panini;
 
 import java.util.List;
 
@@ -16,10 +22,16 @@ import static org.junit.Assert.assertTrue;
 
 public class ConstructorCallTest {
 	private List<CtConstructorCall<?>> constructorCalls;
+	private List<CtConstructorCall<?>> constructorCallsPanini;
 
 	@Before
 	public void setUp() throws Exception {
-		final Factory factory = TestUtils.build(Foo.class);
+		final Launcher launcher = new Launcher();
+		launcher.addInputResource("./src/test/java/" + Foo.class.getCanonicalName().replace(".", "/") + ".java");
+		launcher.addInputResource("./src/test/java/" + Panini.class.getCanonicalName().replace(".", "/") + ".java");
+		launcher.setSourceOutputDirectory("./target/spooned");
+		launcher.run();
+		final Factory factory = launcher.getFactory();
 		final CtClass<?> foo = (CtClass<?>) factory.Type().get(Foo.class);
 		constructorCalls = foo.getElements(new AbstractFilter<CtConstructorCall<?>>(CtConstructorCall.class) {
 			@Override
@@ -27,6 +39,8 @@ public class ConstructorCallTest {
 				return true;
 			}
 		});
+		final CtType<Panini> panini = factory.Type().get(Panini.class);
+		constructorCallsPanini = panini.getElements(new TypeFilter<CtConstructorCall<?>>(CtConstructorCall.class));
 	}
 
 	@Test
@@ -61,6 +75,21 @@ public class ConstructorCallTest {
 		assertHasParameters(1, constructorCall);
 	}
 
+	@Test
+	public void testConstructorCallWithGenericArray() throws Exception {
+		final CtConstructorCall<?> ctConstructorCall = constructorCallsPanini.get(0);
+
+		assertEquals(1, ctConstructorCall.getType().getActualTypeArguments().size());
+		final CtTypeReference<?> implicitArray = ctConstructorCall.getType().getActualTypeArguments().get(0);
+		assertTrue(implicitArray instanceof CtImplicitArrayTypeReference);
+		final CtImplicitArrayTypeReference implicitArrayTyped = (CtImplicitArrayTypeReference) implicitArray;
+		assertEquals("", implicitArrayTyped.toString());
+		assertEquals("Array", implicitArrayTyped.getSimpleName());
+		assertTrue(implicitArrayTyped.getComponentType() instanceof CtImplicitTypeReference);
+		assertEquals("", implicitArrayTyped.getComponentType().toString());
+		assertEquals("AtomicLong", implicitArrayTyped.getComponentType().getSimpleName());
+	}
+
 	private void assertHasParameters(int sizeExpected, CtConstructorCall<?> constructorCall) {
 		if (sizeExpected == 0) {
 			assertEquals("Constructor call without parameter", sizeExpected, constructorCall.getArguments().size());
diff --git a/src/test/java/spoon/test/constructorcallnewclass/testclasses/Panini.java b/src/test/java/spoon/test/constructorcallnewclass/testclasses/Panini.java
new file mode 100644
index 000000000..e54bb4a9b
--- /dev/null
+++ b/src/test/java/spoon/test/constructorcallnewclass/testclasses/Panini.java
@@ -0,0 +1,12 @@
+package spoon.test.constructorcallnewclass.testclasses;
+
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.atomic.AtomicReference;
+
+public class Panini {
+	static final AtomicLong[] EMPTY = new AtomicLong[0];
+
+	public void m() {
+		final AtomicReference<AtomicLong[]> atomicReference = new AtomicReference<>(EMPTY);
+	}
+}
