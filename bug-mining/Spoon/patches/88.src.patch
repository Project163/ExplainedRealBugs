diff --git a/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java b/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
index 30b1e42e7..1398cdb9f 100644
--- a/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
+++ b/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
@@ -2391,10 +2391,36 @@ public class JDTTreeBuilder extends ASTVisitor {
 				ref.setType(references.getTypeReference(messageSend.expectedType()));
 				if (messageSend.receiver.resolvedType == null) {
 					// It is crisis dude! static context, we don't have much more information.
-					if (messageSend.receiver instanceof SingleNameReference || messageSend.receiver instanceof QualifiedNameReference) {
+					if (messageSend.receiver instanceof SingleNameReference) {
 						final CtTypeReference<Object> typeReference = factory.Core().createTypeReference();
 						typeReference.setSimpleName(messageSend.receiver.toString());
+						if (context.compilationunitdeclaration != null && context.compilationunitdeclaration.imports != null) {
+							for (ImportReference anImport : context.compilationunitdeclaration.imports) {
+								if (CharOperation.equals(anImport.getImportName()[anImport.getImportName().length - 1], ((SingleNameReference) messageSend.receiver).token)) {
+									char[][] packageName = CharOperation.subarray(anImport.getImportName(), 0, anImport.getImportName().length - 1);
+									CtPackageReference packageRef = factory.Core().createPackageReference();
+									packageRef.setSimpleName(CharOperation.toString(packageName));
+									typeReference.setPackage(packageRef);
+									break;
+								}
+							}
+						}
 						ref.setDeclaringType(typeReference);
+					} else if (messageSend.receiver instanceof QualifiedNameReference) {
+						QualifiedNameReference qualifiedNameReference = (QualifiedNameReference) messageSend.receiver;
+
+						char[][] packageName = CharOperation.subarray(qualifiedNameReference.tokens, 0, qualifiedNameReference.tokens.length - 2);
+						char[][] className = CharOperation.subarray(qualifiedNameReference.tokens, qualifiedNameReference.tokens.length - 2, qualifiedNameReference.tokens.length - 1);
+						if (packageName.length > 0) {
+							final PackageBinding aPackage = context.compilationunitdeclaration.scope.environment.createPackage(packageName);
+							final MissingTypeBinding declaringType = context.compilationunitdeclaration.scope.environment.createMissingType(aPackage, className);
+
+							ref.setDeclaringType(references.getTypeReference(declaringType));
+						} else {
+							final CtTypeReference<Object> typeReference = factory.Core().createTypeReference();
+							typeReference.setSimpleName(messageSend.receiver.toString());
+							ref.setDeclaringType(typeReference);
+						}
 					}
 				} else {
 					ref.setDeclaringType(references.getTypeReference(messageSend.receiver.resolvedType));
@@ -2827,6 +2853,17 @@ public class JDTTreeBuilder extends ASTVisitor {
 				final CtTypeAccess<Object> ta = factory.Core().createTypeAccess();
 				final CtTypeReference<Object> typeReference = factory.Core().createTypeReference();
 				typeReference.setSimpleName(new String(singleNameReference.binding.readableName()));
+				if (context.compilationunitdeclaration != null && context.compilationunitdeclaration.imports != null) {
+					for (ImportReference anImport : context.compilationunitdeclaration.imports) {
+						if (CharOperation.equals(anImport.getImportName()[anImport.getImportName().length - 1], singleNameReference.token)) {
+							char[][] packageName = CharOperation.subarray(anImport.getImportName(), 0, anImport.getImportName().length - 1);
+							CtPackageReference packageRef = factory.Core().createPackageReference();
+							packageRef.setSimpleName(CharOperation.toString(packageName));
+							typeReference.setPackage(packageRef);
+							break;
+						}
+					}
+				}
 				ta.setType(typeReference);
 				context.enter(ta, singleNameReference);
 				return true;
diff --git a/src/test/java/spoon/test/imports/ImportTest.java b/src/test/java/spoon/test/imports/ImportTest.java
index 73c4bd304..60ef9029f 100644
--- a/src/test/java/spoon/test/imports/ImportTest.java
+++ b/src/test/java/spoon/test/imports/ImportTest.java
@@ -199,13 +199,13 @@ public class ImportTest {
 		assertCorrectInvocation(new Expected().name("staticD").target("pack2.C.D").declaringType("D").typeIsNull(false), elements.get(11));
 
 		// Invocation for a static method with the declaring class specified and an import *.
-		assertCorrectInvocation(new Expected().name("staticE").target("E").declaringType("E").typeIsNull(true), elements.get(12));
+		assertCorrectInvocation(new Expected().name("staticE").target("pack3.E").declaringType("E").typeIsNull(true), elements.get(12));
 
 		// Invocation for a static method without the declaring class specified and an import *.
 		assertCorrectInvocationWithLimit(new Expected().name("staticE").typeIsNull(true), elements.get(13));
 
 		// Invocation for a static method with the declaring class specified, a return type and an import *.
-		assertCorrectInvocation(new Expected().name("staticE").target("E").declaringType("E").typeIsNull(false), elements.get(14));
+		assertCorrectInvocation(new Expected().name("staticE").target("pack3.E").declaringType("E").typeIsNull(false), elements.get(14));
 
 		// Invocation for a static method without the declaring class specified, a return type and an import *.
 		assertCorrectInvocationWithLimit(new Expected().name("staticE").typeIsNull(false), elements.get(15));
diff --git a/src/test/java/spoon/test/reference/TypeReferenceTest.java b/src/test/java/spoon/test/reference/TypeReferenceTest.java
index 7958451bf..6d66ed290 100644
--- a/src/test/java/spoon/test/reference/TypeReferenceTest.java
+++ b/src/test/java/spoon/test/reference/TypeReferenceTest.java
@@ -23,7 +23,9 @@ import spoon.reflect.visitor.filter.TypeFilter;
 import spoon.test.reference.testclasses.EnumValue;
 
 import java.util.Collection;
+import java.util.Iterator;
 import java.util.List;
+import java.util.Set;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -256,6 +258,40 @@ public class TypeReferenceTest {
 		assertTrue(circularRef instanceof CtCircularTypeReference);
 	}
 
+	@Test
+	public void testPackageInNoClasspath () {
+		final Launcher launcher = new Launcher();
+		launcher.addInputResource("./src/test/resources/noclasspath/Demo.java");
+		launcher.setSourceOutputDirectory("./target/class");
+		launcher.getEnvironment().setNoClasspath(true);
+		launcher.run();
+
+		final CtClass<Object> aClass = launcher.getFactory().Class().get("Demo");
+		final Set<CtTypeReference<?>> referencedTypes = aClass.getReferencedTypes();
+
+		boolean containsDemoReference = false;
+		boolean containsVoidReference = false;
+		boolean containsStringReference = false;
+		boolean containsJoinerReference = false;
+
+		for (Iterator<CtTypeReference<?>> iterator = referencedTypes.iterator(); iterator.hasNext(); ) {
+			CtTypeReference<?> reference = iterator.next();
+			if (reference.toString().equals("Demo")) {
+				containsDemoReference = true;
+			} else if (reference.toString().equals("void")) {
+				containsVoidReference = true;
+			} else if (reference.toString().equals("java.lang.String")) {
+				containsStringReference = true;
+			} else if (reference.toString().equals("com.google.common.base.Joiner")) {
+				containsJoinerReference = true;
+			}
+		}
+		assertTrue("Reference to Demo is missing", containsDemoReference);
+		assertTrue("Reference to void is missing", containsVoidReference);
+		assertTrue("Reference to String is missing", containsStringReference);
+		assertTrue("Reference to Joiner is missing", containsJoinerReference);
+	}
+
 	class A {
 		class Tacos<K> {
 		}
diff --git a/src/test/java/spoon/test/variable/AccessTest.java b/src/test/java/spoon/test/variable/AccessTest.java
index acb9add6d..e7f2c7fd5 100644
--- a/src/test/java/spoon/test/variable/AccessTest.java
+++ b/src/test/java/spoon/test/variable/AccessTest.java
@@ -193,6 +193,6 @@ public class AccessTest {
 		}
 
 		assertEquals("java.lang.Class mclass = ((java.lang.Class)(ModelFacade.USE_CASE))", elements.get(0).getParent().toString());
-		assertEquals("new PropPanelButton(this , buttonPanel , _navUpIcon , Translator.localize(\"UMLMenu\", \"button.go-up\") , \"navigateNamespace\" , null)", elements.get(2).getParent().toString());
+		assertEquals("new PropPanelButton(this , buttonPanel , _navUpIcon , org.argouml.i18n.Translator.localize(\"UMLMenu\", \"button.go-up\") , \"navigateNamespace\" , null)", elements.get(2).getParent().toString());
 	}
 }
diff --git a/src/test/resources/noclasspath/Demo.java b/src/test/resources/noclasspath/Demo.java
new file mode 100644
index 000000000..8834c70b8
--- /dev/null
+++ b/src/test/resources/noclasspath/Demo.java
@@ -0,0 +1,8 @@
+import com.google.common.base.Joiner;
+
+public class Demo {
+
+    public static void main(String[] args) {
+        Joiner.on();
+    }
+}
\ No newline at end of file
