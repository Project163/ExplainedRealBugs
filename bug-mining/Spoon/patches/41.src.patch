diff --git a/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java b/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java
index 11975d0b1..00917598c 100644
--- a/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java
+++ b/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java
@@ -1217,7 +1217,7 @@ public class DefaultJavaPrettyPrinter implements CtVisitor, PrettyPrinter {
 			}
 		} else {
 			// It's a method invocation
-			if (invocation.getExecutable().isStatic()) {
+			if (invocation.getExecutable().isStatic() && invocation.getExecutable().getDeclaringType() != null) {
 				CtTypeReference<?> type = invocation.getExecutable().getDeclaringType();
 				context.ignoreGenerics = true;
 				scan(type);
diff --git a/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java b/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
index 02554901b..201c78bf3 100644
--- a/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
+++ b/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
@@ -142,6 +142,7 @@ import org.eclipse.jdt.internal.compiler.lookup.MissingTypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.PackageBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ProblemBinding;
+import org.eclipse.jdt.internal.compiler.lookup.ProblemMethodBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ProblemReferenceBinding;
 import org.eclipse.jdt.internal.compiler.lookup.RawTypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;
@@ -381,11 +382,33 @@ public class JDTTreeBuilder extends ASTVisitor {
 				return null;
 			}
 
-			CtExecutableReference<T> ref = factory.Core().createExecutableReference();
-			ref.setDeclaringType(getTypeReference(exec.declaringClass));
-			ref.setType((CtTypeReference<T>) getTypeReference(exec.returnType));
+			final CtExecutableReference<T> ref = factory.Core().createExecutableReference();
 			ref.setSimpleName(new String(exec.selector));
-			ref.setStatic(exec.isStatic());
+			ref.setType((CtTypeReference<T>) getTypeReference(exec.returnType));
+
+			if (exec instanceof ProblemMethodBinding) {
+				// We try to check in imports if there is the correct package of the type.
+				if (context.compilationunitdeclaration != null && context.compilationunitdeclaration.imports != null) {
+					for (ImportReference anImport : context.compilationunitdeclaration.imports) {
+						if (CharOperation.equals(anImport.getImportName()[anImport.getImportName().length - 1], exec.constantPoolName())) {
+							char[][] packageName = CharOperation.subarray(anImport.getImportName(), 0, anImport.getImportName().length - 2);
+							char[][] className = CharOperation.subarray(anImport.getImportName(), anImport.getImportName().length - 2, anImport.getImportName().length - 1);
+							final PackageBinding aPackage = context.compilationunitdeclaration.scope.environment.createPackage(packageName);
+							final MissingTypeBinding declaringType = context.compilationunitdeclaration.scope.environment.createMissingType(aPackage, className);
+							ref.setDeclaringType(getTypeReference(declaringType));
+							break;
+						}
+					}
+				}
+				if (exec.isConstructor()) {
+					// super() invocation have a good declaring class.
+					ref.setDeclaringType(getTypeReference(exec.declaringClass));
+				}
+				ref.setStatic(true);
+			} else {
+				ref.setDeclaringType(getTypeReference(exec.declaringClass));
+				ref.setStatic(exec.isStatic());
+			}
 
 			// original() method returns a result not null when the current method is generic.
 			if (exec.original() != null) {
@@ -2245,15 +2268,28 @@ public class JDTTreeBuilder extends ASTVisitor {
 			CtInvocation<Object> inv = factory.Core().createInvocation();
 			if (messageSend.binding != null) {
 				inv.setExecutable(references.getExecutableReference(messageSend.binding));
+				if (messageSend.binding instanceof ProblemMethodBinding) {
+					// We are in a static complex in noclasspath mode.
+					if (inv.getExecutable() != null && inv.getExecutable().getDeclaringType() != null) {
+						final CtTypeAccess ta = factory.Core().createTypeAccess();
+						ta.setType(inv.getExecutable().getDeclaringType());
+						inv.setTarget(ta);
+					}
+					if (messageSend.expectedType() != null) {
+						inv.getExecutable().setType(references.getTypeReference(messageSend.expectedType()));
+					}
+				}
 			} else {
 				CtExecutableReference<Object> ref = factory.Core().createExecutableReference();
 				ref.setSimpleName(new String(messageSend.selector));
 				ref.setType(references.getTypeReference(messageSend.expectedType()));
-				if (messageSend.receiver.resolvedType == null && messageSend.receiver instanceof SingleNameReference) {
+				if (messageSend.receiver.resolvedType == null) {
 					// It is crisis dude! static context, we don't have much more information.
-					final CtTypeReference<Object> typeReference = factory.Core().createTypeReference();
-					typeReference.setSimpleName(new String(((SingleNameReference) messageSend.receiver).binding.readableName()));
-					ref.setDeclaringType(typeReference);
+					if (messageSend.receiver instanceof SingleNameReference || messageSend.receiver instanceof QualifiedNameReference) {
+						final CtTypeReference<Object> typeReference = factory.Core().createTypeReference();
+						typeReference.setSimpleName(messageSend.receiver.toString());
+						ref.setDeclaringType(typeReference);
+					}
 				} else {
 					ref.setDeclaringType(references.getTypeReference(messageSend.receiver.resolvedType));
 				}
@@ -2592,6 +2628,15 @@ public class JDTTreeBuilder extends ASTVisitor {
 			ta.setType(references.getTypeReference((TypeBinding) qualifiedNameReference.binding));
 			context.enter(ta, qualifiedNameReference);
 			return false;
+		} else if (qualifiedNameReference.binding instanceof ProblemBinding) {
+			if (context.stack.peek().element instanceof CtInvocation) {
+				final CtTypeAccess<Object> ta = factory.Core().createTypeAccess();
+				final CtTypeReference<Object> typeReference = factory.Core().createTypeReference();
+				typeReference.setSimpleName(qualifiedNameReference.toString());
+				ta.setType(typeReference);
+				context.enter(ta, qualifiedNameReference);
+			}
+			return false;
 		} else {
 			CtVariableAccess<Object> va = null;
 			if (context.stack.peek().element instanceof CtAssignment && context.assigned) {
diff --git a/src/test/java/spoon/test/imports/ImportTest.java b/src/test/java/spoon/test/imports/ImportTest.java
index ca262b4b3..5f4c079e6 100644
--- a/src/test/java/spoon/test/imports/ImportTest.java
+++ b/src/test/java/spoon/test/imports/ImportTest.java
@@ -6,6 +6,8 @@ import spoon.compiler.SpoonCompiler;
 import spoon.compiler.SpoonResource;
 import spoon.compiler.SpoonResourceHelper;
 import spoon.reflect.code.CtConstructorCall;
+import spoon.reflect.code.CtInvocation;
+import spoon.reflect.code.CtTypeAccess;
 import spoon.reflect.declaration.CtClass;
 import spoon.reflect.declaration.CtMethod;
 import spoon.reflect.declaration.CtType;
@@ -25,6 +27,9 @@ import java.util.Collection;
 import java.util.List;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
 
 public class ImportTest {
 
@@ -33,12 +38,9 @@ public class ImportTest {
 		Launcher spoon = new Launcher();
 		Factory factory = spoon.createFactory();
 
-		SpoonCompiler compiler = spoon.createCompiler(
-				factory,
-				SpoonResourceHelper.resources(
-						"./src/test/java/spoon/test/imports/testclasses/internal/SuperClass.java",
-						"./src/test/java/spoon/test/imports/testclasses/internal/ChildClass.java",
-						"./src/test/java/spoon/test/imports/testclasses/ClientClass.java"));
+		SpoonCompiler compiler = spoon.createCompiler(factory, SpoonResourceHelper
+						.resources("./src/test/java/spoon/test/imports/testclasses/internal/SuperClass.java", "./src/test/java/spoon/test/imports/testclasses/internal/ChildClass.java",
+								"./src/test/java/spoon/test/imports/testclasses/ClientClass.java"));
 
 		compiler.build();
 
@@ -78,11 +80,8 @@ public class ImportTest {
 		Launcher spoon = new Launcher();
 		Factory factory = spoon.createFactory();
 
-		SpoonCompiler compiler = spoon.createCompiler(
-				factory,
-				SpoonResourceHelper.resources(
-						"./src/test/java/spoon/test/imports/testclasses/internal/PublicSuperClass.java",
-						"./src/test/java/spoon/test/imports/testclasses/DefaultClientClass.java"));
+		SpoonCompiler compiler = spoon.createCompiler(factory, SpoonResourceHelper
+				.resources("./src/test/java/spoon/test/imports/testclasses/internal/PublicSuperClass.java", "./src/test/java/spoon/test/imports/testclasses/DefaultClientClass.java"));
 
 		compiler.build();
 
@@ -98,30 +97,18 @@ public class ImportTest {
 		Launcher spoon = new Launcher();
 		Factory factory = spoon.createFactory();
 
-		SpoonCompiler compiler = spoon.createCompiler(
-				factory,
-				SpoonResourceHelper.resources(
-						"./src/test/java/spoon/test/imports/testclasses/SuperClass.java",
-						"./src/test/java/spoon/test/imports/testclasses/SubClass.java"));
+		SpoonCompiler compiler = spoon.createCompiler(factory,
+				SpoonResourceHelper.resources("./src/test/java/spoon/test/imports/testclasses/SuperClass.java", "./src/test/java/spoon/test/imports/testclasses/SubClass.java"));
 
 		compiler.build();
 		final CtClass<?> subClass = (CtClass<?>) factory.Type().get(SubClass.class);
-		final CtConstructorCall<?> ctConstructorCall = subClass.getElements(new TypeFilter<CtConstructorCall<?>>(CtConstructorCall.class)).get(
-				0);
-
-		assertEquals("new spoon.test.imports.testclasses.SubClass.Item(\"\")",
-					 ctConstructorCall.toString());
-		final String expected = "public class SubClass extends spoon.test.imports.testclasses.SuperClass {" + System.lineSeparator()
-				+ "    public void aMethod() {" + System.lineSeparator()
-				+ "        new spoon.test.imports.testclasses.SubClass.Item(\"\");" + System.lineSeparator()
-				+ "    }" + System.lineSeparator()
-				+ System.lineSeparator()
-				+ "    public static class Item extends spoon.test.imports.testclasses.SuperClass.Item {" + System.lineSeparator()
-				+ "        public Item(java.lang.String s) {" + System.lineSeparator()
-				+ "            super(1, s);" + System.lineSeparator()
-				+ "        }" + System.lineSeparator()
-				+ "    }" + System.lineSeparator()
-				+ "}";
+		final CtConstructorCall<?> ctConstructorCall = subClass.getElements(new TypeFilter<CtConstructorCall<?>>(CtConstructorCall.class)).get(0);
+
+		assertEquals("new spoon.test.imports.testclasses.SubClass.Item(\"\")", ctConstructorCall.toString());
+		final String expected = "public class SubClass extends spoon.test.imports.testclasses.SuperClass {" + System.lineSeparator() + "    public void aMethod() {" + System.lineSeparator()
+				+ "        new spoon.test.imports.testclasses.SubClass.Item(\"\");" + System.lineSeparator() + "    }" + System.lineSeparator() + System.lineSeparator()
+				+ "    public static class Item extends spoon.test.imports.testclasses.SuperClass.Item {" + System.lineSeparator() + "        public Item(java.lang.String s) {" + System
+				.lineSeparator() + "            super(1, s);" + System.lineSeparator() + "        }" + System.lineSeparator() + "    }" + System.lineSeparator() + "}";
 		assertEquals(expected, subClass.toString());
 	}
 
@@ -132,9 +119,7 @@ public class ImportTest {
 		factory.getEnvironment().setNoClasspath(true);
 		factory.getEnvironment().setLevel("OFF");
 
-		SpoonCompiler compiler = spoon.createCompiler(
-				factory,
-				SpoonResourceHelper.resources("./src/test/resources/import-resources/fr/inria/MissingImport.java"));
+		SpoonCompiler compiler = spoon.createCompiler(factory, SpoonResourceHelper.resources("./src/test/resources/import-resources/fr/inria/MissingImport.java"));
 
 		compiler.build();
 		CtTypeReference<?> type = factory.Class().getAll().get(0).getFields().get(0).getType();
@@ -146,9 +131,7 @@ public class ImportTest {
 	public void testSpoonWithImports() throws Exception {
 		final Launcher launcher = new Launcher();
 		launcher.run(new String[] {
-				"-i", "./src/test/java/spoon/test/imports/testclasses",
-				"-o", "./target/spooned",
-				"--with-imports"
+				"-i", "./src/test/java/spoon/test/imports/testclasses", "-o", "./target/spooned", "--with-imports"
 		});
 		final CtClass<ImportTest> aClass = launcher.getFactory().Class().get(ChildClass.class);
 		final CtClass<ImportTest> anotherClass = launcher.getFactory().Class().get(ClientClass.class);
@@ -162,4 +145,117 @@ public class ImportTest {
 		final Collection<CtTypeReference<?>> imports2 = importScanner.computeImports(classWithInvocation);
 		assertEquals("Spoon ignores the arguments of CtInvocations", 1, imports2.size());
 	}
+
+	@Test
+	public void testStaticImportForInvocationInNoClasspath() throws Exception {
+		final Launcher launcher = new Launcher();
+		launcher.run(new String[] {
+				"-i", "./src/test/resources/import-static", "-o", "./target/spoon", "--noclasspath"
+		});
+
+		final List<CtInvocation<?>> elements = Query.getElements(launcher.getFactory(), new TypeFilter<CtInvocation<?>>(CtInvocation.class) {
+			@Override
+			public boolean matches(CtInvocation<?> element) {
+				return !element.getExecutable().isConstructor() && super.matches(element);
+			}
+		});
+
+		// Invocation for a static method with the declaring class specified.
+		assertCorrectInvocation(new Expected().name("staticMethod").target("A").declaringType("A").typeIsNull(true), elements.get(0));
+
+		// Invocation for a static method without the declaring class specified.
+		assertCorrectInvocation(new Expected().name("staticMethod").target("pack1.A").declaringType("A").typeIsNull(true), elements.get(1));
+
+		// Invocation for a static method with the declaring class specified and a return type.
+		assertCorrectInvocation(new Expected().name("staticMethod").target("A").declaringType("A").typeIsNull(false), elements.get(2));
+
+		// Invocation for a static method without the declaring class specified and a return type.
+		assertCorrectInvocation(new Expected().name("staticMethod").target("pack1.A").declaringType("A").typeIsNull(false), elements.get(3));
+
+		// Invocation for a static method in an inner class with the declaring class specified.
+		assertCorrectInvocation(new Expected().name("makeBurritos").target("Tacos.Burritos").declaringType("Burritos").typeIsNull(false), elements.get(4));
+
+		// Invocation for a static method in an inner class without the declaring class specified.
+		assertCorrectInvocation(new Expected().name("makeBurritos").target("Tacos.Burritos").declaringType("Burritos").typeIsNull(true), elements.get(5));
+
+		// Invocation for a static method in an inner class with the declaring class specified and a return type.
+		assertCorrectInvocation(new Expected().name("makeBurritos").target("Tacos.Burritos").declaringType("Burritos").typeIsNull(false), elements.get(6));
+
+		// Invocation for a static method in an innser class without the declaring class specified and a return type.
+		assertCorrectInvocation(new Expected().name("makeBurritos").target("Tacos.Burritos").declaringType("Burritos").typeIsNull(false), elements.get(7));
+
+		// Invocation for a static method in an inner class with the declaring class specified.
+		assertCorrectInvocation(new Expected().name("staticD").target("C.D").declaringType("C.D").typeIsNull(true), elements.get(8));
+
+		// Invocation for a static method in an inner class without the declaring class specified.
+		assertCorrectInvocation(new Expected().name("staticD").target("pack2.C.D").declaringType("D").typeIsNull(true), elements.get(9));
+
+		// Invocation for a static method in an inner class with the declaring class specified and a return type.
+		assertCorrectInvocation(new Expected().name("staticD").target("C.D").declaringType("C.D").typeIsNull(false), elements.get(10));
+
+		// Invocation for a static method in an inner class without the declaring class specified and a return type.
+		assertCorrectInvocation(new Expected().name("staticD").target("pack2.C.D").declaringType("D").typeIsNull(false), elements.get(11));
+
+		// Invocation for a static method with the declaring class specified and an import *.
+		assertCorrectInvocation(new Expected().name("staticE").target("E").declaringType("E").typeIsNull(true), elements.get(12));
+
+		// Invocation for a static method without the declaring class specified and an import *.
+		assertCorrectInvocationWithLimit(new Expected().name("staticE").typeIsNull(true), elements.get(13));
+
+		// Invocation for a static method with the declaring class specified, a return type and an import *.
+		assertCorrectInvocation(new Expected().name("staticE").target("E").declaringType("E").typeIsNull(false), elements.get(14));
+
+		// Invocation for a static method without the declaring class specified, a return type and an import *.
+		assertCorrectInvocationWithLimit(new Expected().name("staticE").typeIsNull(false), elements.get(15));
+	}
+
+	private void assertCorrectInvocation(Expected expected, CtInvocation<?> ctInvocation) {
+		assertEquals(1, ctInvocation.getArguments().size());
+		assertNotNull(ctInvocation.getTarget());
+		assertTrue(ctInvocation.getTarget() instanceof CtTypeAccess);
+		assertEquals(expected.target, ctInvocation.getTarget().toString());
+		assertNotNull(ctInvocation.getExecutable());
+		assertEquals(expected.name, ctInvocation.getExecutable().getSimpleName());
+		assertNotNull(ctInvocation.getExecutable().getDeclaringType());
+		assertEquals(expected.declaringType, ctInvocation.getExecutable().getDeclaringType().getSimpleName());
+		assertEquals(expected.isNull, ctInvocation.getExecutable().getType() == null);
+		assertEquals(1, ctInvocation.getExecutable().getParameters().size());
+	}
+
+	private void assertCorrectInvocationWithLimit(Expected expected, CtInvocation<?> ctInvocation) {
+		assertEquals(1, ctInvocation.getArguments().size());
+		assertNull(ctInvocation.getTarget());
+		assertNotNull(ctInvocation.getExecutable());
+		assertEquals(expected.name, ctInvocation.getExecutable().getSimpleName());
+		assertNull(ctInvocation.getExecutable().getDeclaringType());
+		assertEquals(expected.isNull, ctInvocation.getExecutable().getType() == null);
+		assertEquals(1, ctInvocation.getExecutable().getParameters().size());
+	}
+
+	private class Expected {
+		String name;
+		String target;
+		String declaringType;
+		boolean isNull;
+
+		public Expected name(String name) {
+			this.name = name;
+			return this;
+		}
+
+		public Expected target(String target) {
+			this.target = target;
+			return this;
+		}
+
+		public Expected declaringType(String declaringType) {
+			this.declaringType = declaringType;
+			return this;
+		}
+
+		public Expected typeIsNull(boolean isNull) {
+			this.isNull = isNull;
+			return this;
+		}
+	}
 }
diff --git a/src/test/resources/import-static/Tacos.java b/src/test/resources/import-static/Tacos.java
new file mode 100644
index 000000000..c1248c907
--- /dev/null
+++ b/src/test/resources/import-static/Tacos.java
@@ -0,0 +1,40 @@
+
+import static pack1.A.staticMethod;
+import static Tacos.Burritos.makeBurritos;
+import static pack2.C.D.staticD;
+import static pack3.E.*;
+
+public class Tacos {
+	public void m() {
+		A.staticMethod("");
+		staticMethod("");
+		String s = A.staticMethod("");
+		String s1 = staticMethod(1);
+	}
+
+	public void m2() {
+		Burritos.makeBurritos(1);
+		makeBurritos(2);
+		String s = Burritos.makeBurritos(3);
+		String s = makeBurritos(4);
+	}
+
+	public void m3() {
+		C.D.staticD(1);
+		staticD(2);
+		String s = C.D.staticD(3);
+		String s = staticD(4);
+	}
+
+	public void m4() {
+		E.staticE(1);
+		staticE(2);
+		String s = E.staticE(3);
+		String s = staticE(4);
+	}
+
+	public static class Burritos {
+		public static String makeBurritos(int o) {
+		}
+	}
+}
\ No newline at end of file
diff --git a/src/test/resources/spoon/test/noclasspath/Foo.java b/src/test/resources/spoon/test/noclasspath/Foo.java
index 825b5dae5..30b778744 100644
--- a/src/test/resources/spoon/test/noclasspath/Foo.java
+++ b/src/test/resources/spoon/test/noclasspath/Foo.java
@@ -5,7 +5,7 @@ public class Foo extends Unknown {
 		Unknown x = null;
 		x.method();
 	}
-	
+
 	void m1() throws UnknownException {
 		// x is not known
 		// as the other ones as well
@@ -16,7 +16,7 @@ public class Foo extends Unknown {
 		Unknown x = null;
 		x.first().second().third();
 	}
-	
+
 	void m3(){
 		int x = first().field; // field after call
 	}
