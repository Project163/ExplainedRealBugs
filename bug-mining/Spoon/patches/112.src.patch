diff --git a/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java b/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
index bbf6cf28b..83c06cd0d 100644
--- a/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
+++ b/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
@@ -2558,7 +2558,7 @@ public class JDTTreeBuilder extends ASTVisitor {
 
 	private <A extends java.lang.annotation.Annotation> boolean visitMarkerAnnoation(MarkerAnnotation annotation, BlockScope scope) {
 		CtAnnotation<A> a = factory.Core().createAnnotation();
-		CtTypeReference<A> t = references.getTypeReference(annotation.resolvedType);
+		CtTypeReference<A> t = references.getTypeReference(annotation.resolvedType, annotation.type);
 		a.setAnnotationType(t);
 		context.enter(a, annotation);
 		skipTypeInAnnotation = true;
@@ -2738,7 +2738,7 @@ public class JDTTreeBuilder extends ASTVisitor {
 	}
 
 	private boolean isContainsInTypeAnnotation(TypeBinding binding, Annotation a) {
-		return !binding.hasTypeAnnotations() || !containsInTypeAnnotation(a, binding.getTypeAnnotations());
+		return binding == null || !binding.hasTypeAnnotations() || !containsInTypeAnnotation(a, binding.getTypeAnnotations());
 	}
 
 	private boolean containsInTypeAnnotation(Annotation a, AnnotationBinding[] typeAnnotations) {
diff --git a/src/test/java/spoon/test/reference/TypeReferenceTest.java b/src/test/java/spoon/test/reference/TypeReferenceTest.java
index cd7ee172b..2dbfa094c 100644
--- a/src/test/java/spoon/test/reference/TypeReferenceTest.java
+++ b/src/test/java/spoon/test/reference/TypeReferenceTest.java
@@ -7,6 +7,7 @@ import spoon.compiler.SpoonResource;
 import spoon.compiler.SpoonResourceHelper;
 import spoon.reflect.code.CtFieldRead;
 import spoon.reflect.code.CtInvocation;
+import spoon.reflect.code.CtNewClass;
 import spoon.reflect.declaration.CtClass;
 import spoon.reflect.declaration.CtField;
 import spoon.reflect.declaration.CtInterface;
@@ -392,6 +393,25 @@ public class TypeReferenceTest {
 		TestUtils.canBeBuilt("./src/test/resources/noclasspath/TestBot.java", 8, true);
 	}
 
+	@Test
+	public void testAnnotationOnMethodWithPrimitiveReturnTypeInNoClasspath() throws Exception {
+		// contract: In no classpath mode, if we have an annotation declared on a method and overridden
+		// from a super class in an anonymous class, we should rewrite correctly the annotation and don't
+		// throw a NPE.
+		final Launcher launcher = new Launcher();
+		launcher.addInputResource("./src/test/resources/noclasspath/A.java");
+		launcher.setSourceOutputDirectory("./target/class-declaration");
+		launcher.getEnvironment().setNoClasspath(true);
+		launcher.run();
+
+		final CtClass<Object> aClass = launcher.getFactory().Class().get("A");
+		final CtClass anonymousClass = aClass.getElements(new TypeFilter<>(CtNewClass.class)).get(0).getAnonymousClass();
+		final CtMethod run = anonymousClass.getMethod("run");
+		assertNotNull(run);
+		assertEquals(1, run.getAnnotations().size());
+		assertEquals("@Override" + System.lineSeparator(), run.getAnnotations().get(0).toString());
+	}
+
 	class A {
 		class Tacos<K> {
 		}
diff --git a/src/test/resources/noclasspath/A.java b/src/test/resources/noclasspath/A.java
new file mode 100644
index 000000000..1e8cbddb6
--- /dev/null
+++ b/src/test/resources/noclasspath/A.java
@@ -0,0 +1,18 @@
+import example.B;
+
+class A extends B {
+
+    private Runnable runnable;
+
+    public void foo() {
+        synchronized (lock) {
+           runnable = new Runnable() {
+
+                @Override
+                public void run() {
+
+                }
+            };
+        }
+    }
+}
\ No newline at end of file
