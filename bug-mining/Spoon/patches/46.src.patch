diff --git a/doc/_jekyll/_data/sidebar_doc.yml b/doc/_jekyll/_data/sidebar_doc.yml
index f79bc1bfa..a45eaa146 100755
--- a/doc/_jekyll/_data/sidebar_doc.yml
+++ b/doc/_jekyll/_data/sidebar_doc.yml
@@ -115,3 +115,24 @@ entries:
           platform: all
           product: all
           version: all
+
+    - title: Processing source code elements
+      audience: writers, designers
+      platform: all
+      product: all
+      version: all
+
+      items:
+          - title: Processor for elements
+            url: /processor.html
+            audience: writers, designers
+            platform: all
+            product: all
+            version: all
+
+          - title: Processor for annotations
+            url: /processor_annotations.html
+            audience: writers, designers
+            platform: all
+            product: all
+            version: all
diff --git a/doc/_jekyll/_data/tags_doc.yml b/doc/_jekyll/_data/tags_doc.yml
index fb98c2d56..09e02f0ce 100755
--- a/doc/_jekyll/_data/tags_doc.yml
+++ b/doc/_jekyll/_data/tags_doc.yml
@@ -3,3 +3,4 @@ allowed-tags:
   - usage
   - meta-model
   - quering
+  - processor
diff --git a/doc/faq.md b/doc/faq.md
index 5e20c1aa2..ab05920a0 100644
--- a/doc/faq.md
+++ b/doc/faq.md
@@ -37,58 +37,6 @@ for(CtSimpleType s : factory.Class().getAll()) {
 }
 {% endhighlight %}
 
-### How to write your own processor(s)?
-
-You need to get the standalone version Spoon jar ([here](http://spoon.gforge.inria.fr/Spoon/HomePage)) and add it to the build path of your Java project. Then you have to subclass the class [spoon.processing.AbstractProcessor](http://spoon.gforge.inria.fr/javadoc/spoon/spoon/processing/AbstractProcessor.html) and implement the process method. This class is parameterized by the type of program element you want to process. These types are those of the Spoon's Java metamodel defined in the [spoon.reflect.declaration package](http://spoon.gforge.inria.fr/javadoc/spoon/spoon/reflect/declaration/package-summary.html) and [spoon.reflect.code package](http://spoon.gforge.inria.fr/javadoc/spoon/spoon/reflect/code/package-summary.html). For example, to process all the Java program elements, you can write the following processor:
-
-{% highlight java %}
-import spoon.processing.AbstractProcessor;
-import spoon.reflect.declaration.CtElement;
-
-public class MyProcessor extends AbstractProcessor<CtElement> {
-  public void process(CtElement element) {
-    // do your processing here
-  }
-}
-{% endhighlight %}
-
-In the process method, you can access the currenly processed element passed as a parameter. Spoon automatically scan all the elements of the target program so that you do not have to implement the scanning yourself. On contrary to APT or JSR 269, you can also modify the program while scanning it. As an example, the following processor reports warnings when it meet undocumented public methods:
-
-{% highlight java %}
-import spoon.processing.AbstractProcessor;
-import spoon.processing.Severity;
-import spoon.reflect.declaration.CtMethod;
-import spoon.reflect.declaration.ModifierKind;
-
-public class MyProcessor extends AbstractProcessor<CtMethod> {
-  public void process(CtMethod method) {
-    if (method.getModifiers().contains(ModifierKind.PUBLIC)
-        && method.getDocComment() == null) {
-      getFactory().getEnvironment().report(
-           Severity.WARNING, method,"undocumented public method");
-    }
-  }
-}
-{% endhighlight %}
-
-Once compiled, you can apply your processor direclty with the Java launcher or Ant (here)
-
-### How to process annotations like with APT or JSR 269?
-
-Spoon is fully compatible with annotations and you can process any program element, including annotations. Even simpler, you can declare that you want to process a certain annotation type by subclassing the special kind of processor [spoon.processing.AbstractAnnotationProcessor](http://spoon.gforge.inria.fr/javadoc/spoon/spoon/processing/AbstractAnnotationProcessor.html). For instance, to process the methods annotated with `@SuppressWarnings`:
-
-{% highlight java %}
-import spoon.processing.AbstractAnnotationProcessor;
-import spoon.reflect.declaration.CtMethod;
-
-public class MyAnnotationProcessor extends 
-    AbstractAnnotationProcessor<SuppressWarnings,CtMethod> {
-  public void process(SuppressWarnings a,CtMethod method) {
-    // do the processing
-  }
-}
-{% endhighlight %}
-
 ## Advanced
 ### How to implement program transformations with well-typed templates?
 
diff --git a/doc/processor.md b/doc/processor.md
new file mode 100644
index 000000000..c33b53cda
--- /dev/null
+++ b/doc/processor.md
@@ -0,0 +1,54 @@
+---
+title: Processor for elements
+tags: [processor]
+keywords: processor, processing, elements
+last_updated: October 6, 2015
+---
+
+A program analysis is a combination of query and analysis code.
+In Spoon, this conceptual pair is reified in a `processor`.
+A Spoon processor is a class that focuses on the analysis of one 
+kind of program elements. For instance, the processor at the end of 
+this page presents a processor that analyzes a program to find 
+empty catch blocks.
+
+The elements to be analyzed (here catch blocks), are given by generic typing: 
+the programmer declares the AST node type under analysis as class generics. 
+The processed element type is automatically inferred through runtime introspection 
+of the processor class. There is also an optional overridable method for querying 
+elements at a finer grain.
+
+The process method takes the requested element as input and does the analysis 
+(here detecting empty catch blocks).
+
+Since a real world analysis combines multiple queries, multiple processors can 
+be used at the same time. The launcher applies them in the order they have been declared. 
+
+Processors are implemented with a visitor design pattern applied to the Spoon 
+Java model. Each node of the metamodel implements an `accept` method so that it 
+can be visited by a visitor object, which can perform any kind of action, 
+including modification. 
+
+{{site.data.alerts.tip}}
+ Spoon provides developers with an intuitive Java metamodel and concise abstractions 
+ to query and process AST elements.
+{{site.data.alerts.end}}
+
+```java
+package fr.inria.gforge.spoon.processors;
+
+import org.apache.log4j.Level;
+import spoon.processing.AbstractProcessor;
+import spoon.reflect.code.CtCatch;
+
+/**
+ * Reports warnings when empty catch blocks are found.
+ */
+public class CatchProcessor extends AbstractProcessor<CtCatch> {
+	public void process(CtCatch element) {
+		if (element.getBody().getStatements().size() == 0) {
+			getFactory().getEnvironment().report(this, Level.WARN, element, "empty catch clause");
+		}
+	}
+}
+```
diff --git a/doc/processor_annotations.md b/doc/processor_annotations.md
new file mode 100644
index 000000000..7856a8424
--- /dev/null
+++ b/doc/processor_annotations.md
@@ -0,0 +1,131 @@
+---
+title: Processor for annotations
+tags: [processor]
+keywords: processor, processing, annotations
+last_updated: October 6, 2015
+---
+
+We now discuss how Spoon deals with the processing of annotations. 
+Java annotations enable developers to embed metadata in their programs. 
+Although by themselves annotations have no explicit semantics, they can 
+be used by frameworks as markers for altering the behavior of the programs 
+that they annotate. This interpretation of annotations can result, for 
+example, on the configuration of services provided by a middleware 
+platform or on the alteration of the program source code. 
+
+Annotation processing is the process by which a pre-processor modifies an 
+annotated program as directed by its annotations during a pre-compilation phase.
+The Java compiler offers the possibility of compile-time processing of annotations 
+via the API provided under the `javax.annotation.processing` package. Classes 
+implementing the `javax.annotation.processing.Process` interface are used by the 
+Java compiler to process annotations present in a client program. 
+The client code is modeled by the classes of the `javax.lang.model` package 
+(although Java 8 has introduced finer-grained annotations, but not on any 
+arbitrary code elements). It is partially modeled: only types, methods, fields and 
+parameter declarations can carry annotations. Furthermore, the model does not allow 
+the developer to modify the client code, it only allows adding new classes.
+
+The Spoon annotation processor overcomes those two limitations: it can handle 
+annotations on any arbitrary code elements (including within method bodies), and it 
+supports the modification of the existing code.
+
+
+## Annotation Processing with Spoon
+
+Spoon provides developers with a way to specify the analyses and transformations 
+associated with annotations. Annotations are metadata on code that start with `@` in Java.
+For example, let us consider the example of a design-by-contract  annotation. 
+The annotation `@NotNull`, when placed on arguments of a method, will ensure that the argument 
+is not null when the method is executed. The code below shows both the definition of the 
+`NotNull` annotation type, and an example of its use.
+
+```java
+@Target({ElementType.PARAMETER})
+@Retention(RetentionPolicy.SOURCE)
+public @interface NotNull{}
+
+class Person{
+	public void marry(@NotNull Person so){
+		if(!so.isMarried())
+			// Marrying logic...
+	}
+}
+```
+
+The `NotNull` annotation type definition carries two meta-annotations (annotations on annotation 
+definitions) stating which source code elements can be annotated (line 1), and that the annotation 
+is intended for compile-time processing (line 2). The `NotNull` annotation is used on the argument 
+of the `marry` method of the class `Person`. Without annotation processing, if the method `marry` 
+is invoked with a `null` reference, a `NullPointerException` would be thrown by the Java virtual 
+machine when invoking the method `isMarried` in line 7.
+
+The implementation of such an annotation would not be straightforward using Java's processing API 
+since it would not allow us to just insert the NULL check in the body of the annotated method. 
+
+
+## The Annotation Processor Interface
+
+In Spoon, the full code model can be used  for compile-time annotation processing. To this end, 
+Spoon provides a special kind of processor called `AnnotationProcessor` whose interface is:
+
+```java
+public interface AnnotationProcessor<A extends Annotation, E extends CtElement> extends Processor<E> {
+	void process(A annotation, E element);
+	boolean inferConsumedAnnotationType();
+	Set<Class<? extends A>> getProcessedAnnotationTypes();
+	Set<Class<? extends A>> getConsumedAnnotationTypes();
+	boolean shoudBeConsumed(CtAnnotation<? extends Annotation> annotation);
+}
+```
+
+Annotation processors extend normal processors by stating the annotation type those elements must 
+carry (type parameter `A`), in addition of stating the kind of source code element they process 
+(type parameter `E`). The `process` method (line 4) receives as arguments both the CtElement and the 
+annotation it carries. The remaining four methods (`getProcessedAnnotationTypes`, `getConsumedAnnotationTypes`, 
+`inferConsumedAnnotationTypes` and `shoudBeConsumed`) configure the visiting of the AST during annotation 
+processing. The Spoon annotation processing runtime is able to infer the type of annotation a processor 
+handles from its type parameter `A`. This restricts each processor to handle a single annotation. To avoid this 
+restriction, a developer can override the `inferConsumedAnnotationType()` method to return `false`. When doing 
+this, Spoon queries the `getProcessedAnnotationTypes()` method to find out which annotations are handled by the 
+processor. Finally, the `getConsumedAnnotationTypes()` returns the set of processed annotations that are to be 
+consumed by the annotation processor. Consumed annotations are not available in later processing rounds. 
+Similar to standard processors, Spoon provides a default abstract implementation for annotation processors: 
+`AbstractAnnotationProcessor`. It provides facilities for maintaining the list of consumed and processed annotation 
+types, allowing the developer to concentrate on the implementation of the annotation processing logic. 
+
+Going back to our `@NotNull` example, we implement a Spoon annotation processor that processes and consumes 
+`NotNull` annotated method parameters, and modifies the source code of the method by inserting an `assert` statement 
+that checks that the argument is not null. 
+
+```java
+class NotNullProcessor extends AbstractAnnotationProcessor<NotNull, CtParameter> {
+	@Override
+	public void process(NotNull anno, CtParameter param){
+		CtMethod<?> method = param.getParent(CtMethod.class);
+		CtBlock<?> body = method.getBlock();
+		CtAssert<?> assertion = constructAssertion(param.getSimpleName());
+		body.insertBegin(assertion);
+	}
+}
+```
+
+The `NotNullProcessor` leverages the default implementation provided by the `AbstractAnnotationProcessor` and binds the 
+type variables representing the annotation to be processed and the annotated code elements to `NotNull` and `CtParameter` 
+respectively. The actual processing of the annotation is implemented in the `process(NotNull,CtParameter)` method 
+(lines 10-13). Annotated code is transformed by navigating the AST up from the annotated parameter to the owner method, 
+and then down to the method's body code block (lines 10 and 12). The construction of the `assert` statement is delegated 
+to a helper method `constructAssertion(String)`, taking as argument the name of the parameter to check. This helper method 
+constructs an instance of `CtAssert` (by either programmatically constructing the desired boolean expression. Having obtained 
+the desired assert statement, it is injected at the beginning of the body of the method. 
+
+More complex annotation processing scenarios can be tackled with Spoon. For example, when using the `NotNull` annotation, 
+the developer is still responsible for manually inspecting which method parameters to place the annotation on. 
+A common processing pattern is then to use regular Spoon processors to `auto-annotate` the application's source code. 
+Such a processor, in our running example, can traverse the body of a method, looking for expressions that send messages 
+to a parameter. Each of these expressions  has as hypothesis that the parameter's value is not null, and thus should result 
+in the parameter being annotated with `NotNull`.
+
+With this processing pattern, the programmer can use an annotation processor in two ways: either by explicitly and manually 
+annotating the base program, or by using a processor that analyzes and annotates the program for triggering annotation processors 
+in an automatic and implicit way. This design decouples the program analysis from the program transformation logics, and leaves 
+room for manual configuration.
