diff --git a/src/main/java/spoon/support/compiler/jdt/ContextBuilder.java b/src/main/java/spoon/support/compiler/jdt/ContextBuilder.java
index 415d328a1..492854c46 100644
--- a/src/main/java/spoon/support/compiler/jdt/ContextBuilder.java
+++ b/src/main/java/spoon/support/compiler/jdt/ContextBuilder.java
@@ -19,6 +19,11 @@ package spoon.support.compiler.jdt;
 import org.eclipse.jdt.internal.compiler.ast.ASTNode;
 import org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.Expression;
+import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
+import org.eclipse.jdt.internal.compiler.ast.TypeReference;
+import org.eclipse.jdt.internal.compiler.lookup.FieldBinding;
+import org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;
+import spoon.compiler.Environment;
 import spoon.reflect.code.CtCatchVariable;
 import spoon.reflect.code.CtConstructorCall;
 import spoon.reflect.code.CtExpression;
@@ -26,11 +31,22 @@ import spoon.reflect.code.CtLocalVariable;
 import spoon.reflect.code.CtStatement;
 import spoon.reflect.cu.CompilationUnit;
 import spoon.reflect.declaration.CtElement;
+import spoon.reflect.declaration.CtExecutable;
+import spoon.reflect.declaration.CtField;
 import spoon.reflect.declaration.CtPackage;
+import spoon.reflect.declaration.CtType;
 import spoon.reflect.declaration.CtTypedElement;
+import spoon.reflect.declaration.CtVariable;
+import spoon.reflect.factory.ClassFactory;
+import spoon.reflect.factory.CoreFactory;
+import spoon.reflect.factory.FieldFactory;
+import spoon.reflect.factory.InterfaceFactory;
+import spoon.reflect.factory.TypeFactory;
+import spoon.reflect.reference.CtReference;
 import spoon.reflect.reference.CtTypeReference;
 import spoon.reflect.visitor.DefaultJavaPrettyPrinter;
 import spoon.reflect.visitor.EarlyTerminatingScanner;
+import spoon.support.reflect.reference.SpoonClassNotFoundException;
 
 import java.util.ArrayDeque;
 import java.util.ArrayList;
@@ -38,6 +54,7 @@ import java.util.Deque;
 import java.util.List;
 
 import static spoon.reflect.ModelElementContainerDefaultCapacities.CASTS_CONTAINER_DEFAULT_CAPACITY;
+import static java.lang.String.format;
 
 public class ContextBuilder {
 
@@ -112,56 +129,240 @@ public class ContextBuilder {
 		}
 	}
 
+	@SuppressWarnings("unchecked")
 	<T> CtLocalVariable<T> getLocalVariableDeclaration(final String name) {
-		for (ASTPair astPair : this.stack) {
-			// TODO check if the variable is visible from here
-
-			EarlyTerminatingScanner<CtLocalVariable<?>> scanner = new EarlyTerminatingScanner<CtLocalVariable<?>>() {
-				@Override
-				public <T> void visitCtLocalVariable(CtLocalVariable<T> localVariable) {
-					if (name.equals(localVariable.getSimpleName())) {
-						setResult(localVariable);
-						terminate();
-						return;
+		final Class<CtLocalVariable<T>> clazz = (Class<CtLocalVariable<T>>)
+				jdtTreeBuilder.getFactory().Core().createLocalVariable().getClass();
+		final CtLocalVariable<T> localVariable =
+				this.<T, CtLocalVariable<T>>getVariableDeclaration(name, clazz);
+		if (localVariable == null) {
+			// note: this happens when using the new try(vardelc) structure
+			this.jdtTreeBuilder.getLogger().error(
+					format("Could not find declaration for local variable %s at %s",
+							name, stack.peek().element.getPosition()));
+		}
+		return localVariable;
+	}
+
+	@SuppressWarnings("unchecked")
+	<T> CtCatchVariable<T> getCatchVariableDeclaration(final String name) {
+		final Class<CtCatchVariable<T>> clazz = (Class<CtCatchVariable<T>>)
+				jdtTreeBuilder.getFactory().Core().createCatchVariable().getClass();
+		final CtCatchVariable<T> catchVariable =
+				this.<T, CtCatchVariable<T>>getVariableDeclaration(name, clazz);
+		if (catchVariable == null) {
+			// note: this happens when using the new try(vardelc) structure
+			this.jdtTreeBuilder.getLogger().error(
+					format("Could not find declaration for catch variable %s at %s",
+							name, stack.peek().element.getPosition()));
+		}
+		return catchVariable;
+	}
+
+	<T> CtVariable<T> getVariableDeclaration(final String name) {
+		final CtVariable<T> variable = this.<T, CtVariable<T>>getVariableDeclaration(name, null);
+		if (variable == null) {
+			// note: this happens when using the new try(vardelc) structure
+			this.jdtTreeBuilder.getLogger().error(
+					format("Could not find declaration for variable %s at %s",
+							name, stack.peek().element.getPosition()));
+		}
+		return variable;
+	}
+
+	@SuppressWarnings("unchecked")
+	private <T, U extends CtVariable<T>> U getVariableDeclaration(
+			final String name, final Class<U> clazz) {
+		final CoreFactory coreFactory = jdtTreeBuilder.getFactory().Core();
+		final TypeFactory typeFactory = jdtTreeBuilder.getFactory().Type();
+		final ClassFactory classFactory = jdtTreeBuilder.getFactory().Class();
+		final InterfaceFactory interfaceFactory = jdtTreeBuilder.getFactory().Interface();
+		final FieldFactory fieldFactory = jdtTreeBuilder.getFactory().Field();
+		final ReferenceBuilder referenceBuilder = jdtTreeBuilder.getReferencesBuilder();
+		final Environment environment = jdtTreeBuilder.getFactory().getEnvironment();
+		// there is some extra work to do if we are looking for CtFields (and subclasses)
+		final boolean lookingForFields = clazz == null
+				|| coreFactory.createField().getClass().isAssignableFrom(clazz);
+
+		// try to find the variable on stack beginning with the most recent element
+		for (final ASTPair astPair : stack) {
+			// the variable may have been declared directly by one of these elements
+			final ScopeRespectingVariableScanner<U> scanner =
+					new ScopeRespectingVariableScanner(name, clazz);
+			astPair.element.accept(scanner);
+			if (scanner.getResult() != null) {
+				return scanner.getResult();
+			}
+
+			// the variable may have been declared in a super class/interface
+			if (lookingForFields && astPair.node instanceof TypeDeclaration) {
+				final TypeDeclaration nodeDeclaration = (TypeDeclaration) astPair.node;
+				final Deque<ReferenceBinding> referenceBindings = new ArrayDeque<>();
+				// add super class if any
+				if (nodeDeclaration.superclass != null
+						&& nodeDeclaration.superclass.resolvedType instanceof ReferenceBinding) {
+					referenceBindings.push((ReferenceBinding) nodeDeclaration.superclass.resolvedType);
+				}
+				// add interfaces if any
+				if (nodeDeclaration.superInterfaces != null) {
+					for (final TypeReference tr : nodeDeclaration.superInterfaces) {
+						if (tr.resolvedType instanceof ReferenceBinding) {
+							referenceBindings.push((ReferenceBinding) tr.resolvedType);
+						}
+					}
+				}
+
+				while (!referenceBindings.isEmpty()) {
+					final ReferenceBinding referenceBinding = referenceBindings.pop();
+					for (final FieldBinding fieldBinding : referenceBinding.fields()) {
+						if (name.equals(new String(fieldBinding.readableName()))) {
+							final String qualifiedNameOfParent =
+									new String(referenceBinding.readableName());
+							final CtType parentOfField = referenceBinding.isClass()
+									? classFactory.create(qualifiedNameOfParent)
+									: interfaceFactory.create(qualifiedNameOfParent);
+							return (U) fieldFactory.create(parentOfField,
+									JDTTreeBuilderQuery.getModifiers(fieldBinding.modifiers),
+									referenceBuilder.getTypeReference(fieldBinding.type),
+									name);
+						}
+					}
+					// add super class if any
+					final ReferenceBinding superclass = referenceBinding.superclass();
+					if (superclass != null) {
+						referenceBindings.push(superclass);
+					}
+					// add interfaces if any
+					final ReferenceBinding[] interfaces = referenceBinding.superInterfaces();
+					if (interfaces != null) {
+						for (ReferenceBinding rb : interfaces) {
+							referenceBindings.push(rb);
+						}
+					}
+				}
+			}
+		}
+
+		// the variable may have been imported statically from another class/interface
+		if (lookingForFields) {
+			final CtReference potentialReferenceToField =
+					referenceBuilder.getDeclaringReferenceFromImports(name.toCharArray());
+			if (potentialReferenceToField != null
+					&& potentialReferenceToField instanceof CtTypeReference) {
+				final CtTypeReference typeReference = (CtTypeReference) potentialReferenceToField;
+				try {
+					final Class classOfType = typeReference.getActualClass();
+					if (classOfType != null) {
+						final CtType declaringTypeOfField = typeReference.isInterface()
+								? interfaceFactory.get(classOfType) : classFactory.get(classOfType);
+						final CtField field = declaringTypeOfField.getField(name);
+						if (field != null) {
+							return (U) field;
+						}
+					}
+				} catch (final SpoonClassNotFoundException scnfe) {
+					// in noclasspath mode we do some heuristics to determine if `name` could be a
+					// field that has been imported statically from another class (or interface).
+					if (environment.getNoClasspath()) {
+						// if `potentialReferenceToField` is a `CtTypeReference` then `name` must
+						// have been imported statically. Otherwise, `potentialReferenceToField`
+						// would be a CtPackageReference!
+
+						// if `name` consists only of upper case characters separated by '_', we
+						// assume a constant value according to JLS.
+						if (name.toUpperCase().equals(name)) {
+							final CtType parentOfField =
+									classFactory.create(typeReference.getQualifiedName());
+							// it is the best thing we can do
+							final CtField field = coreFactory.createField();
+							field.setParent(parentOfField);
+							field.setSimpleName(name);
+							// it is the best thing we can do
+							field.setType(typeFactory.nullType());
+							return (U) field;
+						}
 					}
-					super.visitCtLocalVariable(localVariable);
 				}
-			};
-			astPair.element.accept(scanner);
-			CtLocalVariable<T> var = (CtLocalVariable<T>) scanner.getResult();
-			if (var != null) {
-				return var;
 			}
 		}
-		// note: this happens when using the new try(vardelc) structure
-		this.jdtTreeBuilder.getLogger().error("could not find declaration for local variable " + name + " at " + this.stack.peek().element.getPosition());
 
 		return null;
 	}
 
-	<T> CtCatchVariable<T> getCatchVariableDeclaration(final String name) {
-		for (ASTPair astPair : this.stack) {
-			EarlyTerminatingScanner<CtCatchVariable<?>> scanner = new EarlyTerminatingScanner<CtCatchVariable<?>>() {
-				@Override
-				public <T> void visitCtCatchVariable(CtCatchVariable<T> catchVariable) {
-					if (name.equals(catchVariable.getSimpleName())) {
-						setResult(catchVariable);
-						terminate();
-						return;
+	/**
+	 * An {@link EarlyTerminatingScanner} that is supposed to find a {@link CtVariable} with
+	 * specific name respecting the current scope given by {@link ContextBuilder#stack}.
+
+	 * @param <T> The actual type of the {@link CtVariable} we are looking for. Examples include
+	 *            {@link CtLocalVariable}, {@link CtField}, and so on.
+	 */
+	private class ScopeRespectingVariableScanner<T extends CtVariable>
+			extends EarlyTerminatingScanner<T> {
+
+		/**
+		 * The class object of {@link T} that is required to filter particular elements in
+		 * {@link #scan(CtElement)}.
+		 */
+		private final Class<T> clazz;
+
+		/**
+		 * The name of the variable we are looking for ({@link CtVariable#getSimpleName()}).
+		 */
+		final String name;
+
+		/**
+		 * Creates a new {@link EarlyTerminatingScanner} that tries to find a {@link CtVariable}
+		 * with name {@code pName} (using {@link CtVariable#getSimpleName()}) and upper type bound
+		 * {@code pType}.
+		 *
+		 * @param pName	The name of the variable we are looking for.
+		 * @param pType	{@link T}'s class object ({@link Object#getClass()}). {@link null} values
+		 *              are permitted and indicate that we are looking for any subclass of
+		 *              {@link CtVariable} (including {@link CtVariable} itself).
+		 */
+		ScopeRespectingVariableScanner(final String pName, final Class<T> pType) {
+			clazz =  (Class<T>) (pType == null ? CtVariable.class : pType);
+			name = pName;
+		}
+
+		@Override
+		public void scan(final CtElement element) {
+			if (element != null && clazz.isAssignableFrom(element.getClass())) {
+				final T potentialVariable = (T) element;
+				if (name.equals(potentialVariable.getSimpleName())) {
+					// Since the AST is not completely available yet, we can not check if element's
+					// parent (ep) contains the innermost element of `stack` (ie). Therefore, we
+					// have to check if one of the following condition holds:
+					//
+					//    1) Does `stack` contain `ep`?
+					//    2) Is `ep` the body of one of `stack`'s CtExecutable elements?
+					//
+					// The first condition is easy to see. If `stack` contains `ep` then `ep` and
+					// all it's declared variables are in scope of `ie`. Unfortunately, there is a
+					// special case in which a variable (a CtLocalVariable) has been declared in a
+					// block (CtBlock) of, for instance, a method. Such a block is not contained in
+					// `stack`. This peculiarity calls for the second condition.
+					final CtElement parentOfPotentialVariable = potentialVariable.getParent();
+					for (final ASTPair astPair : stack) {
+						if (astPair.element == parentOfPotentialVariable) {
+							finish(potentialVariable);
+							return;
+						} else if (astPair.element instanceof CtExecutable) {
+							final CtExecutable executable = (CtExecutable) astPair.element;
+							if (executable.getBody() == parentOfPotentialVariable) {
+								finish(potentialVariable);
+								return;
+							}
+						}
 					}
-					super.visitCtCatchVariable(catchVariable);
 				}
-			};
-			astPair.element.accept(scanner);
-
-			CtCatchVariable<T> var = (CtCatchVariable<T>) scanner.getResult();
-			if (var != null) {
-				return null;
 			}
+			super.scan(element);
 		}
-		// note: this happens when using the new try(vardelc) structure
-		this.jdtTreeBuilder.getLogger().error("could not find declaration for catch variable " + name + " at " + this.stack.peek().element.getPosition());
 
-		return null;
+		private void finish(final  T element) {
+			setResult(element);
+			terminate();
+		}
 	}
 }
diff --git a/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java b/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
index 847383f0f..d8a94c001 100644
--- a/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
+++ b/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
@@ -122,6 +122,7 @@ import spoon.reflect.code.CtBreak;
 import spoon.reflect.code.CtCatch;
 import spoon.reflect.code.CtConstructorCall;
 import spoon.reflect.code.CtContinue;
+import spoon.reflect.code.CtExpression;
 import spoon.reflect.code.CtInvocation;
 import spoon.reflect.code.CtLambda;
 import spoon.reflect.code.CtLiteral;
@@ -1333,7 +1334,11 @@ public class JDTTreeBuilder extends ASTVisitor {
 				context.enter(helper.createFieldAccessNoClasspath(singleNameReference), singleNameReference);
 			}
 		} else if (singleNameReference.binding == null) {
-			context.enter(helper.createVariableAccessNoClasspath(singleNameReference), singleNameReference);
+			CtExpression access = helper.createVariableAccessNoClasspath(singleNameReference);
+			if (access == null) {
+				access = helper.createTypeAccessNoClasspath(singleNameReference);
+			}
+			context.enter(access, singleNameReference);
 		}
 		return true;
 	}
diff --git a/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilderHelper.java b/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilderHelper.java
index f830f8da6..399f9a62d 100644
--- a/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilderHelper.java
+++ b/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilderHelper.java
@@ -19,6 +19,7 @@ package spoon.support.compiler.jdt;
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.ast.Argument;
 import org.eclipse.jdt.internal.compiler.ast.FieldReference;
+import org.eclipse.jdt.internal.compiler.ast.MethodDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference;
 import org.eclipse.jdt.internal.compiler.ast.ReferenceExpression;
 import org.eclipse.jdt.internal.compiler.ast.SingleNameReference;
@@ -39,22 +40,28 @@ import spoon.reflect.code.CtCatchVariable;
 import spoon.reflect.code.CtExecutableReferenceExpression;
 import spoon.reflect.code.CtExpression;
 import spoon.reflect.code.CtFieldAccess;
+import spoon.reflect.code.CtLambda;
 import spoon.reflect.code.CtTypeAccess;
 import spoon.reflect.code.CtVariableAccess;
 import spoon.reflect.cu.CompilationUnit;
 import spoon.reflect.declaration.CtClass;
+import spoon.reflect.declaration.CtField;
+import spoon.reflect.declaration.CtMethod;
 import spoon.reflect.declaration.CtParameter;
 import spoon.reflect.declaration.CtType;
+import spoon.reflect.declaration.CtVariable;
 import spoon.reflect.declaration.ModifierKind;
+import spoon.reflect.factory.CoreFactory;
+import spoon.reflect.factory.ExecutableFactory;
 import spoon.reflect.reference.CtArrayTypeReference;
 import spoon.reflect.reference.CtExecutableReference;
 import spoon.reflect.reference.CtFieldReference;
-import spoon.reflect.reference.CtLocalVariableReference;
 import spoon.reflect.reference.CtParameterReference;
 import spoon.reflect.reference.CtReference;
 import spoon.reflect.reference.CtTypeReference;
 import spoon.reflect.reference.CtVariableReference;
 
+import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
@@ -147,32 +154,105 @@ class JDTTreeBuilderHelper {
 	}
 
 	/**
-	 * In this case, we are in no classpath so we don't know if the access is a variable, a field or a type.
-	 * By default, we assume that when we don't have any information, we create a variable access.
+	 * Analyzes if {@code singleNameReference} points to a {@link CtVariable} visible in current
+	 * scope and, if existent, returns its corresponding {@link CtVariableAccess}. Returns
+	 * {@code null} if {@code singleNameReference} could not be resolved as variable access. Since
+	 * we are in noclasspath mode this function may also returns {@code null} if
+	 * {@code singleNameReference} points to a variable declared by an unknown class.
 	 *
 	 * @param singleNameReference
-	 * 		Used to set the name of the variable reference contained in the variable access.
-	 * @return a variable access.
+	 * 		The potential variable access.
+	 * @return A {@link CtVariableAccess} if {@code singleNameReference} points to a variable
+	 * 		   visible in current scope, {@code null} otherwise.
 	 */
 	<T> CtVariableAccess<T> createVariableAccessNoClasspath(SingleNameReference singleNameReference) {
-		CtVariableAccess<T> va;
-		if (isLhsAssignment(jdtTreeBuilder.getContextBuilder(), singleNameReference)) {
-			va = jdtTreeBuilder.getFactory().Core().createVariableWrite();
-		} else {
-			va = jdtTreeBuilder.getFactory().Core().createVariableRead();
-		}
+		final CoreFactory coreFactory = jdtTreeBuilder.getFactory().Core();
+		final ExecutableFactory executableFactory = jdtTreeBuilder.getFactory().Executable();
+		final ContextBuilder contextBuilder = jdtTreeBuilder.getContextBuilder();
+		final ReferenceBuilder referenceBuilder = jdtTreeBuilder.getReferencesBuilder();
+		final PositionBuilder positionBuilder = jdtTreeBuilder.getPositionBuilder();
+
 		final String name = CharOperation.charToString(singleNameReference.token);
-		CtVariableReference<T> ref;
-		if (jdtTreeBuilder.getContextBuilder().isBuildLambda) {
-			ref = jdtTreeBuilder.getFactory().Core().createParameterReference();
-			((CtParameterReference) ref).setDeclaringExecutable(jdtTreeBuilder.getReferencesBuilder().getLambdaExecutableReference(singleNameReference));
-		} else {
-			ref = jdtTreeBuilder.getFactory().Core().createLocalVariableReference();
-			((CtLocalVariableReference<T>) ref).setDeclaration(jdtTreeBuilder.getContextBuilder().<T>getLocalVariableDeclaration(name));
+		final CtVariable<T> variable = contextBuilder.getVariableDeclaration(name);
+		if (variable == null) {
+			return null;
 		}
-		ref.setSimpleName(name);
-		va.setVariable(ref);
-		return va;
+
+		final CtVariableReference<T> variableReference;
+		final CtVariableAccess<T> variableAccess;
+		if (variable instanceof CtParameter) {
+			// create variable of concrete type to avoid type casting while calling methods
+			final CtParameterReference<T> parameterReference = coreFactory.createParameterReference();
+			if (variable.getParent() instanceof CtLambda) {
+				parameterReference.setDeclaringExecutable(
+						referenceBuilder.getLambdaExecutableReference(singleNameReference));
+			} else {
+				// Unfortunately, we can not use `variable.getReference()` here as some parent
+				// references (in terms of Java objects) have not been set up yet. Thus, we need to
+				// create the required parameter reference by our own.
+
+				// since the given parameter has not been declared in a lambda expression it must
+				// have been declared by a method!
+				final CtMethod method = (CtMethod) variable.getParent();
+
+				// create list of method's parameter types
+				final List<CtTypeReference<?>> parameterTypesOfMethod = new ArrayList<>();
+				final List<CtParameter<?>> parametersOfMethod = method.getParameters();
+				for (CtParameter<?> parameter : parametersOfMethod) {
+					if (parameter.getType() != null) {
+						parameterTypesOfMethod.add(parameter.getType().clone());
+					}
+				}
+
+				// find method's corresponding jdt element
+				MethodDeclaration methodJDT = null;
+				for (final ASTPair astPair : contextBuilder.stack) {
+					if (astPair.element == method) {
+						methodJDT = (MethodDeclaration) astPair.node;
+						break;
+					}
+				}
+				assert methodJDT != null;
+
+				// create a reference to method's declaring class
+				final CtTypeReference declaringReferenceOfMethod =
+						// `binding` may be null for anonymous classes which means we have to
+						// create an 'empty' type reference since we have no further information
+						methodJDT.binding == null ? coreFactory.createTypeReference()
+								: referenceBuilder.getTypeReference(methodJDT.binding.declaringClass);
+
+				// create a reference to the method of the currently processed parameter reference
+				final CtExecutableReference methodReference =
+						executableFactory.createReference(declaringReferenceOfMethod,
+								// we need to clone method's return type (rt) before passing to
+								// `createReference` since this method (indirectly) sets the parent
+								// of the rt and, therefore, may break the AST
+								method.getType().clone(),
+								// no need to clone/copy as Strings are immutable
+								method.getSimpleName(),
+								// no need to clone/copy as we just created this object
+								parameterTypesOfMethod);
+
+				// finally, we can set the method reference...
+				parameterReference.setDeclaringExecutable(methodReference);
+			}
+			variableReference = parameterReference;
+			variableAccess = isLhsAssignment(contextBuilder, singleNameReference)
+					? coreFactory.<T>createVariableWrite() : coreFactory.<T>createVariableRead();
+		} else if (variable instanceof CtField) {
+			variableReference = variable.getReference();
+			variableAccess = isLhsAssignment(contextBuilder, singleNameReference)
+					? coreFactory.<T>createFieldWrite() : coreFactory.<T>createFieldRead();
+		} else { // CtLocalVariable, CtCatchVariable, ...
+			variableReference = variable.getReference();
+			variableAccess = isLhsAssignment(contextBuilder, singleNameReference)
+					? coreFactory.<T>createVariableWrite() : coreFactory.<T>createVariableRead();
+		}
+		variableReference.setSimpleName(name);
+		variableReference.setPosition(positionBuilder.buildPosition(
+				singleNameReference.sourceStart(), singleNameReference.sourceEnd()));
+		variableAccess.setVariable(variableReference);
+		return variableAccess;
 	}
 
 	/**
@@ -421,9 +501,8 @@ class JDTTreeBuilderHelper {
 		}
 		final CtTypeAccess<T> typeAccess = jdtTreeBuilder.getFactory().Code().createTypeAccess(typeReference);
 
-		long[] positions = qualifiedNameReference.sourcePositions;
 		int sourceStart = qualifiedNameReference.sourceStart();
-		int sourceEnd = (int) (positions[qualifiedNameReference.indexOfFirstFieldBinding - 1] >>> 32) - 2;
+		int sourceEnd = qualifiedNameReference.sourceEnd();
 		typeAccess.setPosition(jdtTreeBuilder.getPositionBuilder().buildPosition(sourceStart, sourceEnd));
 
 		return typeAccess;
diff --git a/src/test/java/spoon/test/lambda/LambdaTest.java b/src/test/java/spoon/test/lambda/LambdaTest.java
index 89a5a7042..60835e7b4 100644
--- a/src/test/java/spoon/test/lambda/LambdaTest.java
+++ b/src/test/java/spoon/test/lambda/LambdaTest.java
@@ -5,8 +5,10 @@ import org.junit.Test;
 import spoon.Launcher;
 import spoon.OutputType;
 import spoon.compiler.SpoonCompiler;
+import spoon.reflect.code.CtFieldAccess;
 import spoon.reflect.code.CtIf;
 import spoon.reflect.code.CtLambda;
+import spoon.reflect.code.CtTypeAccess;
 import spoon.reflect.declaration.CtMethod;
 import spoon.reflect.declaration.CtParameter;
 import spoon.reflect.declaration.CtType;
@@ -14,6 +16,7 @@ import spoon.reflect.factory.Factory;
 import spoon.reflect.reference.CtArrayTypeReference;
 import spoon.reflect.reference.CtParameterReference;
 import spoon.reflect.reference.CtTypeReference;
+import spoon.reflect.visitor.Filter;
 import spoon.reflect.visitor.filter.AbstractFilter;
 import spoon.reflect.visitor.filter.NameFilter;
 import spoon.reflect.visitor.filter.TypeFilter;
@@ -76,6 +79,63 @@ public class LambdaTest {
 		assertIsWellPrinted("((spoon.test.lambda.testclasses.Foo.Check) (() -> false))", lambda);
 	}
 
+	@Test
+	public void testTypeAccessInLambdaNoClassPath() {
+		final Launcher runLaunch = new Launcher();
+		runLaunch.getEnvironment().setNoClasspath(true);
+		runLaunch.addInputResource("./src/test/resources/noclasspath/lambdas/TypeAccessInLambda.java");
+		runLaunch.buildModel();
+
+		assertEquals("The token 'Strings' has not been parsed as CtTypeAccess", 1,
+				runLaunch.getModel().getElements(new Filter<CtTypeAccess>() {
+			@Override
+			public boolean matches(final CtTypeAccess element) {
+				return element.getAccessedType().getSimpleName().equals("Strings");
+			}
+		}).size());
+	}
+
+	@Test
+	public void testFieldAccessInLambdaNoClassPath() {
+		final Launcher runLaunch = new Launcher();
+		runLaunch.getEnvironment().setNoClasspath(true);
+		runLaunch.addInputResource("./src/test/resources/noclasspath/lambdas/FieldAccessInLambda.java");
+		runLaunch.addInputResource("./src/test/resources/noclasspath/lambdas/imported/SeparateInterfaceWithField.java");
+		runLaunch.buildModel();
+
+		final List<CtFieldAccess> fieldAccesses =
+				runLaunch.getModel().getElements(new Filter<CtFieldAccess>() {
+			@Override
+			public boolean matches(final CtFieldAccess element) {
+				final String name = element.getVariable().getSimpleName();
+				return name.equals("localField")
+						|| name.equals("pathSeparator")
+						|| name.equals("fieldInSeparateInterface")
+						|| name.equals("fieldInClassBase")
+						|| name.equals("fieldInClass")
+						|| name.equals("fieldInInterfaceBase")
+						|| name.equals("fieldInInterface")
+						|| name.equals("iAmToLazyForAnotherFieldName");
+			}
+		});
+		assertEquals(8, fieldAccesses.size());
+	}
+
+	@Test
+	public void testFieldAccessInLambdaNoClassPathExternal1Example() {
+		final Launcher runLaunch = new Launcher();
+		runLaunch.getEnvironment().setNoClasspath(true);
+		runLaunch.addInputResource("./src/test/resources/noclasspath/lambdas/external1");
+		runLaunch.buildModel();
+
+		assertEquals(3, runLaunch.getModel().getElements(new Filter<CtFieldAccess>() {
+			@Override
+			public boolean matches(final CtFieldAccess element) {
+				return element.getVariable().getSimpleName().equals("DEFAULT_RATING");
+			}
+		}).size());
+	}
+
 	@Test
 	public void testLambdaExpressionWithExpressionBodyAndWithoutTypeForParameter() throws Exception {
 		final CtLambda<?> lambda = getLambdaByName("lambda$1");
diff --git a/src/test/resources/noclasspath/lambdas/FieldAccessInLambda.java b/src/test/resources/noclasspath/lambdas/FieldAccessInLambda.java
new file mode 100644
index 000000000..05bd2d781
--- /dev/null
+++ b/src/test/resources/noclasspath/lambdas/FieldAccessInLambda.java
@@ -0,0 +1,65 @@
+import java.util.List;
+
+import static java.io.File.pathSeparator;
+import static imported.SeparateInterfaceWithField.fieldInSeparateInterface;
+import static test.unknown.UnknownClass.unknownField;
+
+interface InterfaceImplementedByExtendedClass {
+    String iAmToLazyForAnotherFieldName = "spoon";
+}
+
+class ClassWithFieldBase implements InterfaceImplementedByExtendedClass {
+    public String fieldInClassBase;
+}
+
+class ClassWithField extends ClassWithFieldBase {
+    public String fieldInClass;
+}
+
+interface InterfaceWithFieldBase {
+    String fieldInInterfaceBase = "spoon";
+}
+
+interface InterfaceWithField extends InterfaceWithFieldBase {
+    String fieldInInterface = "spoon";
+}
+
+public class FieldAccessInLambda extends ClassWithField implements InterfaceWithField {
+    private final String localField = "spoon";
+
+    public void lambdaLocalField(final List<String> strings) {
+        strings.forEach(s -> System.out.println(s + localField));
+    }
+
+    public void lambdaStaticallyImportedField(final List<String> strings) {
+        strings.forEach(s -> System.out.println(s + pathSeparator));
+    }
+
+    public void lambdaStaticallyImportedFieldInterface(final List<String> strings) {
+        strings.forEach(s -> System.out.println(s + fieldInSeparateInterface));
+    }
+
+    public void lambdaFieldInClassBase(final List<String> strings) {
+        strings.forEach(s -> System.out.println(s + fieldInClassBase));
+    }
+
+    public void lambdaFieldInClass(final List<String> strings) {
+        strings.forEach(s -> System.out.println(s + fieldInClass));
+    }
+
+    public void lambdaFieldInInterfaceBase(final List<String> strings) {
+        strings.forEach(s -> System.out.println(s + fieldInInterfaceBase));
+    }
+
+    public void lambdaFieldInInterface(final List<String> strings) {
+        strings.forEach(s -> System.out.println(s + fieldInInterface));
+    }
+
+    public void lambdaFieldInterfaceImplementedByExtendedClass(final List<String> strings) {
+        strings.forEach(s -> System.out.println(s + iAmToLazyForAnotherFieldName));
+    }
+
+    public void lambdaFieldInUnknownClass(final List<String> strings) {
+        strings.forEach(s -> System.out.println(s + unknownField));
+    }
+}
diff --git a/src/test/resources/noclasspath/lambdas/TypeAccessInLambda.java b/src/test/resources/noclasspath/lambdas/TypeAccessInLambda.java
new file mode 100644
index 000000000..8b5b84913
--- /dev/null
+++ b/src/test/resources/noclasspath/lambdas/TypeAccessInLambda.java
@@ -0,0 +1,8 @@
+import test.utils.Strings;
+
+public class TypeAccessInLambda {
+
+    public void testMethod(final List<String> strings) {
+        strings.forEach(s -> Strings.ToUpperCase(s));
+    }
+}
diff --git a/src/test/resources/noclasspath/lambdas/external1/IRatingLookUp.java b/src/test/resources/noclasspath/lambdas/external1/IRatingLookUp.java
new file mode 100644
index 000000000..4371776e7
--- /dev/null
+++ b/src/test/resources/noclasspath/lambdas/external1/IRatingLookUp.java
@@ -0,0 +1,33 @@
+package de.uni_bremen.st.quide.persistence.ratings;
+
+import java.util.Map;
+
+import de.uni_bremen.st.quide.datamodel.transferred_data.IViolation;
+
+public interface IRatingLookUp {
+
+	int DEFAULT_RATING = 5;
+
+	/**
+	 * Sets the rating for the given violation with the contents of the database.
+	 * <p>
+	 * Ratings can be saved for different granularities, one of which is rated filesystems.<br>
+	 * So in the case that the rating for a violation referencing many files has to be calculated and
+	 * no rating of higher granularity can be found the value to be set will be the maximum of the
+	 * ratings of all the files.
+	 *
+	 * @param userId the user who sent this request
+	 * @param violation the violation for which the rating will be set
+	 *
+	 */
+	void setRating(String userId, IViolation violation);
+
+	/**
+	 * Returns ratings for ViolationTypes in a map of name of ViolationType -> rating
+	 * 
+	 * @param userId the user to get the rating for
+	 * @return the map
+	 */
+	Map<String, Integer> getViolationTypeRatings(String userId);
+
+}
diff --git a/src/test/resources/noclasspath/lambdas/external1/impl/RatingLookUp.java b/src/test/resources/noclasspath/lambdas/external1/impl/RatingLookUp.java
new file mode 100644
index 000000000..60d373767
--- /dev/null
+++ b/src/test/resources/noclasspath/lambdas/external1/impl/RatingLookUp.java
@@ -0,0 +1,102 @@
+package de.uni_bremen.st.quide.persistence.ratings.impl;
+
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import javax.persistence.EntityManager;
+import javax.persistence.PersistenceContext;
+
+import org.springframework.stereotype.Service;
+import org.springframework.transaction.annotation.Transactional;
+
+import de.uni_bremen.st.quide.datamodel.transferred_data.IViolation;
+import de.uni_bremen.st.quide.datamodel.transferred_data.ViolationType;
+import de.uni_bremen.st.quide.datamodel.transferred_data.impl.TOFilename;
+import de.uni_bremen.st.quide.datamodel.transferred_data.impl.TOFragment;
+import de.uni_bremen.st.quide.persistence.data.RatingEntry;
+import de.uni_bremen.st.quide.persistence.ratings.IRatingLookUp;
+
+@Service
+public class RatingLookUp implements IRatingLookUp {
+
+	private static final int ERROR_VALUE = -1;
+
+	private static final String byId = "SELECT rating FROM RatingEntry WHERE :type LIKE violationType AND :id = violationId AND userId = :userId";
+	private static final String byFiles = "SELECT rating FROM RatingEntry "
+			+ "WHERE ("
+			+ ":file LIKE (path || '%') OR path IS NULL"
+			+ ") AND ("
+			+ ":type LIKE violationType OR violationType IS NULL"
+			+ ") AND userId = :userId AND violationId IS NULL "
+			+ "ORDER BY path DESC, violationType DESC";
+
+	private static final String forTypes =
+			"FROM RatingEntry WHERE violationType IS NOT NULL AND violationId IS NULL AND path IS NULL AND userId = :userId";
+
+	@PersistenceContext
+	private EntityManager entityManager;
+
+	@Override
+	@Transactional(readOnly = true)
+	public void setRating(String userId, final IViolation violation) {
+		ViolationType type = violation.getViolationType();
+		Long id = violation.getId();
+
+		int rating = byId(userId, type, id);
+		if (rating == ERROR_VALUE) {
+			rating = byFiles(userId, type, violation.getLocations());
+		}
+		violation.setRating(rating);
+	}
+
+	@Override
+	@Transactional
+	public Map<String, Integer> getViolationTypeRatings(String userId) {
+		Map<String, Integer> map = new HashMap<>();
+
+		entityManager.createQuery(forTypes, RatingEntry.class)
+				.setParameter("userId", userId)
+				.getResultList()
+				.forEach(entry -> map.put(entry.getViolationType(), entry.getRating()));
+
+		Arrays.stream(ViolationType.values())
+				.map(type -> type.toString())
+				.filter(type -> !map.containsKey(type))
+				.forEach(type -> map.put(type, DEFAULT_RATING));
+
+		return map;
+	}
+
+	private int byId(String userId, ViolationType type, Long id) {
+		List<Integer> result = entityManager.createQuery(byId, Integer.class)
+				.setParameter("userId", userId)
+				.setParameter("type", type.toString())
+				.setParameter("id", id)
+				.setMaxResults(1)
+				.getResultList();
+		return result.isEmpty() ? ERROR_VALUE : result.get(0);
+	}
+
+	private int byFiles(String userId, ViolationType type, TOFragment... locations) {
+		return Arrays.stream(locations)
+				.map(TOFragment::getFile)
+				.map(TOFilename::getName)
+				.distinct()
+				.mapToInt(file -> byFile(userId, type, file))
+				.max()
+				.orElse(DEFAULT_RATING);
+	}
+
+	private int byFile(String userId, ViolationType type, String file) {
+		List<Integer> list = entityManager.createQuery(byFiles, Integer.class)
+				.setParameter("userId", userId)
+				.setParameter("type", type.toString())
+				.setParameter("file", file)
+				.setMaxResults(1)
+				.getResultList();
+		return list.isEmpty() ? DEFAULT_RATING : list.get(0);
+	}
+
+}
diff --git a/src/test/resources/noclasspath/lambdas/imported/SeparateInterfaceWithField.java b/src/test/resources/noclasspath/lambdas/imported/SeparateInterfaceWithField.java
new file mode 100644
index 000000000..999c3701e
--- /dev/null
+++ b/src/test/resources/noclasspath/lambdas/imported/SeparateInterfaceWithField.java
@@ -0,0 +1,5 @@
+package imported;
+
+public interface SeparateInterfaceWithField {
+    String fieldInSeparateInterface = "spoon";
+}
