diff --git a/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java b/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
index bd889f8ee..3a1cfccca 100644
--- a/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
+++ b/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
@@ -1538,7 +1538,13 @@ public class JDTTreeBuilder extends ASTVisitor {
 
 	private <T, E extends CtExpression<?>> CtExecutableReferenceExpression<T, E> createExecutableReferenceExpression(ReferenceExpression referenceExpression) {
 		CtExecutableReferenceExpression<T, E> executableRef = factory.Core().createExecutableReferenceExpression();
-		final CtExecutableReference<T> executableReference = references.getExecutableReference(referenceExpression.binding);
+		CtExecutableReference<T> executableReference = references.getExecutableReference(referenceExpression.binding);
+		if (executableReference == null) {
+			// No classpath mode.
+			executableReference = factory.Core().createExecutableReference();
+			executableReference.setSimpleName(new String(referenceExpression.selector));
+			executableReference.setDeclaringType(references.getTypeReference(referenceExpression.lhs.resolvedType));
+		}
 		executableReference.setType((CtTypeReference<T>) executableReference.getDeclaringType());
 		executableRef.setExecutable(executableReference);
 		return executableRef;
diff --git a/src/test/java/spoon/test/methodreference/MethodReferenceTest.java b/src/test/java/spoon/test/methodreference/MethodReferenceTest.java
index c93120c8e..2c7d15d1f 100644
--- a/src/test/java/spoon/test/methodreference/MethodReferenceTest.java
+++ b/src/test/java/spoon/test/methodreference/MethodReferenceTest.java
@@ -11,15 +11,19 @@ import spoon.reflect.code.CtLiteral;
 import spoon.reflect.code.CtTypeAccess;
 import spoon.reflect.code.CtVariableRead;
 import spoon.reflect.declaration.CtClass;
+import spoon.reflect.declaration.CtElement;
 import spoon.reflect.factory.Factory;
 import spoon.reflect.reference.CtExecutableReference;
 import spoon.reflect.reference.CtTypeReference;
+import spoon.reflect.visitor.Query;
 import spoon.reflect.visitor.filter.AbstractFilter;
+import spoon.reflect.visitor.filter.TypeFilter;
 import spoon.test.TestUtils;
 import spoon.test.methodreference.testclasses.Foo;
 
 import java.io.File;
 import java.util.Comparator;
+import java.util.List;
 import java.util.function.Supplier;
 
 import static org.junit.Assert.assertEquals;
@@ -143,6 +147,21 @@ public class MethodReferenceTest {
 		TestUtils.canBeBuild(new File("./target/spooned/spoon/test/methodreference/testclasses/"), 8);
 	}
 
+	@Test
+	public void testNoClasspathExecutableReferenceExpression() throws Exception {
+		final Launcher launcher = new Launcher();
+		launcher.run(new String[] {
+				"-i", "./src/test/resources/executable-reference-expression/Bar.java", "-o", "./target/spooned", "--noclasspath"
+		});
+		final CtExecutableReferenceExpression<?, ?> element = Query
+				.getElements(launcher.getFactory(), new TypeFilter<CtExecutableReferenceExpression<?, ?>>(CtExecutableReferenceExpression.class)).get(0);
+
+		assertEquals("isInstance", element.getExecutable().getSimpleName());
+		assertNotNull(element.getExecutable().getDeclaringType());
+		assertEquals("Tacos", element.getExecutable().getDeclaringType().getSimpleName());
+		assertEquals("elemType::isInstance", element.toString());
+	}
+
 	private void assertTypedBy(Class<?> expected, CtTypeReference<?> type) {
 		assertEquals("Method reference must be typed.", expected, type.getActualClass());
 	}
diff --git a/src/test/java/spoon/test/parent/ParentTest.java b/src/test/java/spoon/test/parent/ParentTest.java
index 84d43cd6e..35437fb28 100644
--- a/src/test/java/spoon/test/parent/ParentTest.java
+++ b/src/test/java/spoon/test/parent/ParentTest.java
@@ -27,7 +27,7 @@ import spoon.reflect.visitor.filter.NameFilter;
 import spoon.reflect.visitor.filter.TypeFilter;
 
 public class ParentTest {
-    
+
 	Factory factory;
 
 	@Before
@@ -56,14 +56,13 @@ public class ParentTest {
 			Assert.fail();
 		}
 	}
- 
+
 	@Test
 	public void testParentSet() throws Exception {
 		CtClass<?> foo = factory.Package().get("spoon.test.parent")
 				.getType("Foo");
-		
-		CtMethod<?> fooMethod = foo.getElements(
-				new NameFilter<CtMethod<?>>("foo")).get(0);
+
+		CtMethod<?> fooMethod = foo.getMethodsByName("foo").get(0);
 		assertEquals("foo", fooMethod.getSimpleName());
 
 		CtLocalVariable<?> localVar = (CtLocalVariable<?>) fooMethod.getBody()
@@ -76,13 +75,13 @@ public class ParentTest {
 		CtLiteral<?> newLit = factory.Code().createLiteral(0);
 		localVar.setDefaultExpression((CtExpression) newLit);
 		assertEquals(localVar, newLit.getParent());
-		
+
 		CtLiteral<?> newLit2 = factory.Code().createLiteral(1);
 		assignment.setAssignment((CtExpression) newLit2);
 		assertEquals(assignment, newLit2.getParent());
-				
+
 	}
-	
+
 	@Test
 	public void testParentPackage() throws Exception {
 		// addType should set Parent
@@ -100,7 +99,7 @@ public class ParentTest {
 			// there is always one parent
 			Assert.assertNotNull("no parent for "+elem.getClass()+"-"+elem.getPosition(), elem.getParent());
 		}
-		
+
 		// the scanner and the parent are in correspondence
 		new CtScanner() {
 			Stack<CtElement> elementStack = new Stack<CtElement>();
diff --git a/src/test/java/spoon/test/replace/ReplaceTest.java b/src/test/java/spoon/test/replace/ReplaceTest.java
index 9e1a2a4f2..f725a941f 100644
--- a/src/test/java/spoon/test/replace/ReplaceTest.java
+++ b/src/test/java/spoon/test/replace/ReplaceTest.java
@@ -206,7 +206,7 @@ public class ReplaceTest {
 	@Test
 	public void testReplaceStatement() {
 		CtMethod<?> sample = factory.Package().get("spoon.test.replace")
-				.getType("Foo").getMethod("foo"); 
+				.getType("Foo").getMethod("foo");
 
 		Assert.assertTrue(sample.getBody().getStatement(0) instanceof CtVariable);
 
diff --git a/src/test/resources/executable-reference-expression/Bar.java b/src/test/resources/executable-reference-expression/Bar.java
new file mode 100644
index 000000000..73b733b1b
--- /dev/null
+++ b/src/test/resources/executable-reference-expression/Bar.java
@@ -0,0 +1,12 @@
+import spoon.reflect.declaration.CtClass;
+import spoon.reflect.declaration.CtElement;
+import spoon.reflect.declaration.CtMethod;
+import spoon.test.parent.Foo;
+
+public class Bar {
+	private <T extends CtElement> T get(Tacos<T> elemType) {
+		CtClass<Object> fooClass = factory.Class().get(Foo.class);
+		CtMethod nullParent = fooClass.getMethodsByName("nullParent").get(0);
+		return (T) nullParent.getBody().getElements(elemType::isInstance).get(0);
+	}
+}
\ No newline at end of file
