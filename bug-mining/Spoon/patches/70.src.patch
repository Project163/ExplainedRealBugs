diff --git a/doc/_jekyll/images/structural-elements.png b/doc/_jekyll/images/structural-elements.png
index a279d5f44..f0015a860 100644
Binary files a/doc/_jekyll/images/structural-elements.png and b/doc/_jekyll/images/structural-elements.png differ
diff --git a/doc/_release/spoon-models.graffle b/doc/_release/spoon-models.graffle
index 582fc7e22..6c10183bc 100644
Binary files a/doc/_release/spoon-models.graffle and b/doc/_release/spoon-models.graffle differ
diff --git a/src/main/java/spoon/reflect/declaration/CtAnonymousExecutable.java b/src/main/java/spoon/reflect/declaration/CtAnonymousExecutable.java
index e5163aed7..86c59ca67 100644
--- a/src/main/java/spoon/reflect/declaration/CtAnonymousExecutable.java
+++ b/src/main/java/spoon/reflect/declaration/CtAnonymousExecutable.java
@@ -17,27 +17,10 @@
 
 package spoon.reflect.declaration;
 
-import spoon.reflect.code.CtBlock;
-
 /**
  * This element defines an anonymous executable block declaration in a class.
  *
  * @see spoon.reflect.declaration.CtClass
  */
-public interface CtAnonymousExecutable extends CtTypeMember {
-
-	/**
-	 * Gets the executable block.
-	 *
-	 * @return the representation of this executable
-	 */
-	CtBlock<?> getBody();
-
-	/**
-	 * Sets the executable block.
-	 *
-	 * @param block
-	 * 		the representation of this executable
-	 */
-	<T extends CtAnonymousExecutable> T setBody(CtBlock<?> block);
+public interface CtAnonymousExecutable extends CtExecutable<Void>, CtTypeMember {
 }
diff --git a/src/main/java/spoon/reflect/factory/ExecutableFactory.java b/src/main/java/spoon/reflect/factory/ExecutableFactory.java
index 78e85f93a..60547a9bf 100644
--- a/src/main/java/spoon/reflect/factory/ExecutableFactory.java
+++ b/src/main/java/spoon/reflect/factory/ExecutableFactory.java
@@ -17,10 +17,6 @@
 
 package spoon.reflect.factory;
 
-import java.util.ArrayList;
-import java.util.List;
-import java.util.StringTokenizer;
-
 import spoon.reflect.code.CtBlock;
 import spoon.reflect.declaration.CtAnonymousExecutable;
 import spoon.reflect.declaration.CtClass;
@@ -32,6 +28,10 @@ import spoon.reflect.reference.CtExecutableReference;
 import spoon.reflect.reference.CtParameterReference;
 import spoon.reflect.reference.CtTypeReference;
 
+import java.util.ArrayList;
+import java.util.List;
+import java.util.StringTokenizer;
+
 import static java.util.Arrays.asList;
 import static spoon.reflect.ModelElementContainerDefaultCapacities.PARAMETERS_CONTAINER_DEFAULT_CAPACITY;
 
@@ -53,7 +53,7 @@ public class ExecutableFactory extends SubFactory {
 	/**
 	 * Creates an anonymous executable (initializer block) in a target class).
 	 */
-	public CtAnonymousExecutable createAnonymous(CtClass<?> target, CtBlock<?> body) {
+	public CtAnonymousExecutable createAnonymous(CtClass<?> target, CtBlock<Void> body) {
 		CtAnonymousExecutable a = factory.Core().createAnonymousExecutable();
 		target.addAnonymousExecutable(a);
 		a.setBody(body);
diff --git a/src/main/java/spoon/reflect/visitor/CtInheritanceScanner.java b/src/main/java/spoon/reflect/visitor/CtInheritanceScanner.java
index 95a863b9c..862b004d7 100644
--- a/src/main/java/spoon/reflect/visitor/CtInheritanceScanner.java
+++ b/src/main/java/spoon/reflect/visitor/CtInheritanceScanner.java
@@ -359,11 +359,13 @@ public abstract class CtInheritanceScanner implements CtVisitor {
 	}
 
 	public void visitCtAnonymousExecutable(CtAnonymousExecutable e) {
-		scanCtElement(e);
-		scanCtModifiable(e);
+		scanCtExecutable(e);
+		scanCtNamedElement(e);
+		scanCtTypedElement(e);
 		scanCtTypeMember(e);
+		scanCtModifiable(e);
+		scanCtElement(e);
 		scanCtVisitable(e);
-
 	}
 
 	public <T, E extends CtExpression<?>> void visitCtArrayAccess(
diff --git a/src/main/java/spoon/reflect/visitor/filter/NameFilter.java b/src/main/java/spoon/reflect/visitor/filter/NameFilter.java
index 1cb8e3ff7..61d3fdd60 100644
--- a/src/main/java/spoon/reflect/visitor/filter/NameFilter.java
+++ b/src/main/java/spoon/reflect/visitor/filter/NameFilter.java
@@ -22,7 +22,11 @@ public class NameFilter<T extends CtNamedElement> implements Filter<T> {
 	}
 
 	public boolean matches(T element) {
-		return name.equals(element.getSimpleName());
+		try {
+			return name.equals(element.getSimpleName());
+		} catch (UnsupportedOperationException e) {
+			return false;
+		}
 	}
 
 	@SuppressWarnings("unchecked")
diff --git a/src/main/java/spoon/support/compiler/jdt/ParentExiter.java b/src/main/java/spoon/support/compiler/jdt/ParentExiter.java
index 6065d07be..d86399c37 100644
--- a/src/main/java/spoon/support/compiler/jdt/ParentExiter.java
+++ b/src/main/java/spoon/support/compiler/jdt/ParentExiter.java
@@ -172,7 +172,7 @@ public class ParentExiter extends CtInheritanceScanner {
 	@Override
 	public void visitCtAnonymousExecutable(CtAnonymousExecutable e) {
 		if (child instanceof CtBlock) {
-			e.setBody((CtBlock<?>) child);
+			e.setBody((CtBlock) child);
 			return;
 		}
 		super.visitCtAnonymousExecutable(e);
diff --git a/src/main/java/spoon/support/reflect/declaration/CtAnonymousExecutableImpl.java b/src/main/java/spoon/support/reflect/declaration/CtAnonymousExecutableImpl.java
index 568784724..b87e0d338 100644
--- a/src/main/java/spoon/support/reflect/declaration/CtAnonymousExecutableImpl.java
+++ b/src/main/java/spoon/support/reflect/declaration/CtAnonymousExecutableImpl.java
@@ -17,21 +17,24 @@
 
 package spoon.support.reflect.declaration;
 
-import spoon.reflect.code.CtBlock;
 import spoon.reflect.declaration.CtAnonymousExecutable;
 import spoon.reflect.declaration.CtClass;
+import spoon.reflect.declaration.CtExecutable;
 import spoon.reflect.declaration.CtModifiable;
+import spoon.reflect.declaration.CtNamedElement;
+import spoon.reflect.declaration.CtParameter;
+import spoon.reflect.declaration.CtTypedElement;
 import spoon.reflect.declaration.ModifierKind;
+import spoon.reflect.reference.CtTypeReference;
 import spoon.reflect.visitor.CtVisitor;
 
 import java.util.EnumSet;
+import java.util.List;
 import java.util.Set;
 
-public class CtAnonymousExecutableImpl extends CtElementImpl implements CtAnonymousExecutable {
+public class CtAnonymousExecutableImpl extends CtExecutableImpl<Void> implements CtAnonymousExecutable {
 	private static final long serialVersionUID = 1L;
 
-	CtBlock<?> body;
-
 	Set<ModifierKind> modifiers = emptySet();
 
 	@Override
@@ -53,11 +56,6 @@ public class CtAnonymousExecutableImpl extends CtElementImpl implements CtAnonym
 		return !modifiers.isEmpty() && modifiers.remove(modifier);
 	}
 
-	@Override
-	public CtBlock<?> getBody() {
-		return body;
-	}
-
 	@Override
 	public Set<ModifierKind> getModifiers() {
 		return modifiers;
@@ -87,13 +85,6 @@ public class CtAnonymousExecutableImpl extends CtElementImpl implements CtAnonym
 		return modifiers.contains(modifier);
 	}
 
-	@Override
-	public <T extends CtAnonymousExecutable> T setBody(CtBlock<?> block) {
-		block.setParent(this);
-		body = block;
-		return (T) this;
-	}
-
 	@Override
 	public <T extends CtModifiable> T setModifiers(Set<ModifierKind> modifiers) {
 		this.modifiers = modifiers;
@@ -112,4 +103,63 @@ public class CtAnonymousExecutableImpl extends CtElementImpl implements CtAnonym
 		return (T) this;
 	}
 
+	@Override
+	public List<CtParameter<?>> getParameters() {
+		throw new UnsupportedOperationException("You can't have parameters in a anonymous executable");
+	}
+
+	@Override
+	public CtExecutable setParameters(List list) {
+		throw new UnsupportedOperationException("You can't have parameters in a anonymous executable");
+	}
+
+	@Override
+	public CtExecutable addParameter(CtParameter parameter) {
+		throw new UnsupportedOperationException("You can't have parameters in a anonymous executable");
+	}
+
+	@Override
+	public boolean removeParameter(CtParameter parameter) {
+		throw new UnsupportedOperationException("You can't have parameters in a anonymous executable");
+	}
+
+	@Override
+	public Set<CtTypeReference<? extends Throwable>> getThrownTypes() {
+		throw new UnsupportedOperationException("You can't have throw types in a anonymous executable");
+	}
+
+	@Override
+	public CtExecutable setThrownTypes(Set thrownTypes) {
+		throw new UnsupportedOperationException("You can't have throw types in a anonymous executable");
+	}
+
+	@Override
+	public CtExecutable addThrownType(CtTypeReference throwType) {
+		throw new UnsupportedOperationException("You can't have throw types in a anonymous executable");
+	}
+
+	@Override
+	public boolean removeThrownType(CtTypeReference throwType) {
+		throw new UnsupportedOperationException("You can't have throw types in a anonymous executable");
+	}
+
+	@Override
+	public String getSimpleName() {
+		throw new UnsupportedOperationException("You can't have a name in a anonymous executable");
+	}
+
+	@Override
+	public <T extends CtNamedElement> T setSimpleName(String simpleName) {
+		throw new UnsupportedOperationException("You can't have a name in a anonymous executable");
+	}
+
+	@Override
+	public CtTypeReference<Void> getType() {
+		throw new UnsupportedOperationException("An anonymous executable isn't typed");
+	}
+
+	@Override
+	public <C extends CtTypedElement> C setType(CtTypeReference<Void> type) {
+		throw new UnsupportedOperationException("An anonymous executable isn't typed");
+	}
 }
diff --git a/src/test/java/spoon/test/parent/ParentContractTest.java b/src/test/java/spoon/test/parent/ParentContractTest.java
index 179294b10..b4e327efb 100644
--- a/src/test/java/spoon/test/parent/ParentContractTest.java
+++ b/src/test/java/spoon/test/parent/ParentContractTest.java
@@ -10,6 +10,7 @@ import spoon.reflect.code.CtConstructorCall;
 import spoon.reflect.code.CtInvocation;
 import spoon.reflect.code.CtNewClass;
 import spoon.reflect.declaration.CtAnnotationType;
+import spoon.reflect.declaration.CtAnonymousExecutable;
 import spoon.reflect.declaration.CtConstructor;
 import spoon.reflect.declaration.CtElement;
 import spoon.reflect.declaration.CtParameter;
@@ -113,6 +114,9 @@ public class ParentContractTest<T extends CtVisitable> {
 			if (o instanceof CtInvocation && "setType".equals(setter.getName())) continue;
 			if (o instanceof CtConstructorCall && "setType".equals(setter.getName())) continue;
 			if (o instanceof CtNewClass && "setType".equals(setter.getName())) continue;
+			if (o instanceof CtAnonymousExecutable && ("addParameter".equals(setter.getName()) || "setParameters".equals(setter.getName()))) continue;
+			if (o instanceof CtAnonymousExecutable && ("addThrownType".equals(setter.getName()) || "setThrownTypes".equals(setter.getName()))) continue;
+			if (o instanceof CtAnonymousExecutable && "setType".equals(setter.getName())) continue;
 
 			CtElement mockedArgument = (CtElement) mock(setter.getParameters()[0].getType(),  Mockito.withSettings().extraInterfaces(Comparable.class));
 			try {
