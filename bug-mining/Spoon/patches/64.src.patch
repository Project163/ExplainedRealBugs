diff --git a/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java b/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
index c9d536023..8f662e0c8 100644
--- a/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
+++ b/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
@@ -488,7 +488,11 @@ public class JDTTreeBuilder extends ASTVisitor {
 						if (!JDTTreeBuilder.this.context.isGenericTypeExplicit) {
 							isImplicit = true;
 						}
-						ref.addActualTypeArgument(getTypeReference(b));
+						if (bindingCache.containsKey(b)) {
+							ref.addActualTypeArgument(getCtCircularTypeReference(b));
+						} else {
+							ref.addActualTypeArgument(getTypeReference(b));
+						}
 						isImplicit = false;
 					}
 				}
@@ -545,6 +549,7 @@ public class JDTTreeBuilder extends ASTVisitor {
 						return getTypeReference(((CaptureBinding) b).wildcard);
 					} else if (b.superclass != null && b.firstBound == b.superclass) {
 						bounds = false;
+						bindingCache.put(binding, ref);
 						((CtTypeParameterReference) ref).addBound(getTypeReference(b.superclass));
 						bounds = oldBounds;
 					}
@@ -586,13 +591,7 @@ public class JDTTreeBuilder extends ASTVisitor {
 
 				if (((WildcardBinding) binding).bound != null && ref instanceof CtTypeParameterReference) {
 					if (bindingCache.containsKey(((WildcardBinding) binding).bound)) {
-						final CtCircularTypeReference circularRef = factory.Internal().createCircularTypeReference();
-						final CtTypeReference originalRef = bindingCache.get(((WildcardBinding) binding).bound);
-						circularRef.setPackage(originalRef.getPackage());
-						circularRef.setSimpleName(originalRef.getSimpleName());
-						circularRef.setDeclaringType(originalRef.getDeclaringType());
-						circularRef.setActualTypeArguments(originalRef.getActualTypeArguments());
-						circularRef.setTypeAnnotations(originalRef.getTypeAnnotations());
+						final CtCircularTypeReference circularRef = getCtCircularTypeReference(((WildcardBinding) binding).bound);
 						((CtTypeParameterReference) ref).addBound(circularRef);
 					} else {
 						((CtTypeParameterReference) ref).addBound(getTypeReference(((WildcardBinding) binding).bound));
@@ -671,6 +670,17 @@ public class JDTTreeBuilder extends ASTVisitor {
 			return (CtTypeReference<T>) ref;
 		}
 
+		private CtCircularTypeReference getCtCircularTypeReference(TypeBinding b) {
+			final CtCircularTypeReference circularRef = factory.Internal().createCircularTypeReference();
+			final CtTypeReference originalRef = bindingCache.get(b);
+			circularRef.setPackage(originalRef.getPackage());
+			circularRef.setSimpleName(originalRef.getSimpleName());
+			circularRef.setDeclaringType(originalRef.getDeclaringType());
+			circularRef.setActualTypeArguments(originalRef.getActualTypeArguments());
+			circularRef.setTypeAnnotations(originalRef.getTypeAnnotations());
+			return circularRef;
+		}
+
 		private void addTypeAnnotationFromBindingToReference(TypeBinding resolvedType, CtTypeReference<?> reference) {
 			if (resolvedType.hasTypeAnnotations()) {
 				final AnnotationBinding[] typeAnnotations = resolvedType.getTypeAnnotations();
diff --git a/src/test/java/spoon/test/reference/TypeReferenceTest.java b/src/test/java/spoon/test/reference/TypeReferenceTest.java
index 96e4e10e1..7958451bf 100644
--- a/src/test/java/spoon/test/reference/TypeReferenceTest.java
+++ b/src/test/java/spoon/test/reference/TypeReferenceTest.java
@@ -6,8 +6,10 @@ import spoon.compiler.SpoonCompiler;
 import spoon.compiler.SpoonResource;
 import spoon.compiler.SpoonResourceHelper;
 import spoon.reflect.code.CtInvocation;
+import spoon.reflect.declaration.CtClass;
 import spoon.reflect.declaration.CtField;
 import spoon.reflect.declaration.CtInterface;
+import spoon.reflect.declaration.CtMethod;
 import spoon.reflect.declaration.CtType;
 import spoon.reflect.factory.Factory;
 import spoon.reflect.internal.CtCircularTypeReference;
@@ -18,6 +20,7 @@ import spoon.reflect.reference.CtTypeReference;
 import spoon.reflect.visitor.Query;
 import spoon.reflect.visitor.filter.ReferenceTypeFilter;
 import spoon.reflect.visitor.filter.TypeFilter;
+import spoon.test.reference.testclasses.EnumValue;
 
 import java.util.Collection;
 import java.util.List;
@@ -230,6 +233,29 @@ public class TypeReferenceTest {
 		assertTrue(circularRef instanceof CtCircularTypeReference);
 	}
 
+	@Test
+	public void testRecursiveTypeReferenceInGenericType() throws Exception {
+		final Launcher launcher = new Launcher();
+		launcher.addInputResource("./src/test/java/spoon/test/reference/testclasses/EnumValue.java");
+		launcher.setSourceOutputDirectory("./target/spoon-test");
+		launcher.run();
+
+		final CtClass<EnumValue> aClass = launcher.getFactory().Class().get(EnumValue.class);
+		final CtMethod<?> asEnum = aClass.getMethodsByName("asEnum").get(0);
+
+		final CtTypeParameterReference genericType = (CtTypeParameterReference) asEnum.getFormalTypeParameters().get(0);
+		assertNotNull(genericType);
+		assertEquals(1, genericType.getBounds().size());
+
+		final CtTypeReference<?> extendsGeneric = genericType.getBounds().get(0);
+		assertNotNull(extendsGeneric);
+		assertEquals(1, extendsGeneric.getActualTypeArguments().size());
+
+		final CtTypeReference circularRef = extendsGeneric.getActualTypeArguments().get(0);
+		assertNotNull(circularRef);
+		assertTrue(circularRef instanceof CtCircularTypeReference);
+	}
+
 	class A {
 		class Tacos<K> {
 		}
diff --git a/src/test/java/spoon/test/reference/testclasses/EnumValue.java b/src/test/java/spoon/test/reference/testclasses/EnumValue.java
new file mode 100644
index 000000000..bd527ef68
--- /dev/null
+++ b/src/test/java/spoon/test/reference/testclasses/EnumValue.java
@@ -0,0 +1,16 @@
+package spoon.test.reference.testclasses;
+
+public class EnumValue {
+
+	public EnumValue() {
+	}
+
+	public <T extends Enum<T>> T asEnum() //StackOverflow when referenced
+	{
+		return null;
+	}
+
+	public Object unwrap() {
+		return asEnum();
+	}
+}
