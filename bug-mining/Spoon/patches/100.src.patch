diff --git a/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java b/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
index 224f3a0df..aac2dddd8 100644
--- a/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
+++ b/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
@@ -2763,7 +2763,7 @@ public class JDTTreeBuilder extends ASTVisitor {
 				int sourceStart = (int) (positions[0] >>> 32);
 				for (FieldBinding b : qualifiedNameReference.otherBindings) {
 					CtFieldAccess<Object> other;
-					if (qualifiedNameReference.otherBindings.length == i + 1 && context.stack.peek().element instanceof CtAssignment) {
+					if (qualifiedNameReference.otherBindings.length == i + 1 && context.stack.peek().element instanceof CtAssignment && context.assigned) {
 						other = factory.Core().createFieldWrite();
 					} else {
 						other = factory.Core().createFieldRead();
diff --git a/src/test/java/spoon/test/fieldaccesses/BUG20160112.java b/src/test/java/spoon/test/fieldaccesses/BUG20160112.java
new file mode 100644
index 000000000..0e58ed7f1
--- /dev/null
+++ b/src/test/java/spoon/test/fieldaccesses/BUG20160112.java
@@ -0,0 +1,12 @@
+package spoon.test.fieldaccesses;
+
+public class BUG20160112 {
+    BUG20160112 a;
+    int us;
+
+    public void test() {
+        int z = 0;
+        z += a.us;
+        return;
+    }
+}
\ No newline at end of file
diff --git a/src/test/java/spoon/test/fieldaccesses/FieldAccessTest.java b/src/test/java/spoon/test/fieldaccesses/FieldAccessTest.java
index 4518ed164..8ed4c1509 100644
--- a/src/test/java/spoon/test/fieldaccesses/FieldAccessTest.java
+++ b/src/test/java/spoon/test/fieldaccesses/FieldAccessTest.java
@@ -3,6 +3,8 @@ package spoon.test.fieldaccesses;
 import org.junit.Test;
 import spoon.Launcher;
 import spoon.reflect.code.CtArrayWrite;
+
+import spoon.reflect.code.CtExpression;
 import spoon.reflect.code.CtFieldAccess;
 import spoon.reflect.code.CtFieldRead;
 import spoon.reflect.code.CtFieldWrite;
@@ -11,7 +13,7 @@ import spoon.reflect.code.CtLocalVariable;
 import spoon.reflect.code.CtUnaryOperator;
 import spoon.reflect.code.CtVariableWrite;
 import spoon.reflect.code.UnaryOperatorKind;
-import spoon.reflect.declaration.CtElement;
+import spoon.reflect.code.CtOperatorAssignment;
 import spoon.reflect.declaration.CtField;
 import spoon.reflect.declaration.CtMethod;
 import spoon.reflect.declaration.CtType;
@@ -28,6 +30,7 @@ import java.util.logging.Logger;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 import static spoon.test.TestUtils.build;
 
@@ -123,6 +126,17 @@ public class FieldAccessTest {
 
 	}
 
+	@Test
+	public void testBUG20160112() throws Exception {
+		CtType<?> type = build("spoon.test.fieldaccesses", "BUG20160112");
+		assertEquals("BUG20160112", type.getSimpleName());
+		CtOperatorAssignment<?, ?> ass = type.getElements(
+				new TypeFilter<CtOperatorAssignment<?,?>>(CtOperatorAssignment.class)).get(0);
+		assertNotNull("z+=a.us", ass);
+		CtExpression<?> righthand = ass.getAssignment();
+		assertTrue("a.us should be CtFieldRead", righthand instanceof CtFieldRead);
+	}
+
 	@Test
 	public void testTargetedAccessPosition() throws Exception{
 		CtType<?> type = build("spoon.test.fieldaccesses", "TargetedAccessPosition");
