diff --git a/src/main/java/spoon/reflect/declaration/CtTypeParameter.java b/src/main/java/spoon/reflect/declaration/CtTypeParameter.java
index ded89d850..79eb78150 100644
--- a/src/main/java/spoon/reflect/declaration/CtTypeParameter.java
+++ b/src/main/java/spoon/reflect/declaration/CtTypeParameter.java
@@ -16,10 +16,11 @@
  */
 package spoon.reflect.declaration;
 
-import java.util.List;
-
+import spoon.reflect.reference.CtIntersectionTypeReference;
 import spoon.reflect.reference.CtTypeReference;
 
+import java.util.List;
+
 /**
  * This element defines a type parameter (aka generics).
  */
@@ -30,22 +31,37 @@ public interface CtTypeParameter extends CtNamedElement {
 	 * the <i>extends</i> clause. If there is no explicit <i>extends</i> clause,
 	 * then <tt>java.lang.Object</tt> is considered to be the sole bound.
 	 */
+	@Deprecated
 	List<CtTypeReference<?>> getBounds();
 
 	/**
 	 * Sets the bounds of this type parameter.
 	 */
+	@Deprecated
 	<T extends CtTypeParameter> T setBounds(List<CtTypeReference<?>> bounds);
 
 	/**
 	 * @param bounds
 	 * @return
 	 */
+	@Deprecated
 	<T extends CtTypeParameter> T addBound(CtTypeReference<?> bounds);
 
 	/**
 	 * @param bounds
 	 * @return
 	 */
+	@Deprecated
 	boolean removeBound(CtTypeReference<?> bounds);
+
+	/**
+	 * A type parameter can have an <code>extends</code> clause which declare
+	 * one ({@link CtTypeReference} or more ({@link CtIntersectionTypeReference} references.
+	 */
+	CtTypeReference<?> getSuperType();
+
+	/**
+	 * Sets the <code>extends</code> clause of the type parameter.
+	 */
+	<T extends CtTypeParameter> T setSuperType(CtTypeReference<?> superType);
 }
diff --git a/src/main/java/spoon/reflect/factory/CoreFactory.java b/src/main/java/spoon/reflect/factory/CoreFactory.java
index c7d4043cd..9089c0b33 100644
--- a/src/main/java/spoon/reflect/factory/CoreFactory.java
+++ b/src/main/java/spoon/reflect/factory/CoreFactory.java
@@ -80,6 +80,7 @@ import spoon.reflect.reference.CtArrayTypeReference;
 import spoon.reflect.reference.CtCatchVariableReference;
 import spoon.reflect.reference.CtExecutableReference;
 import spoon.reflect.reference.CtFieldReference;
+import spoon.reflect.reference.CtIntersectionTypeReference;
 import spoon.reflect.reference.CtLocalVariableReference;
 import spoon.reflect.reference.CtPackageReference;
 import spoon.reflect.reference.CtParameterReference;
@@ -403,6 +404,11 @@ public interface CoreFactory {
 	 */
 	CtTypeParameterReference createTypeParameterReference();
 
+	/**
+	 * Creates an intersection type reference.
+	 */
+	<T> CtIntersectionTypeReference<T> createIntersectionTypeReference();
+
 	/**
 	 * Creates a type reference.
 	 */
diff --git a/src/main/java/spoon/reflect/factory/TypeFactory.java b/src/main/java/spoon/reflect/factory/TypeFactory.java
index be05a0826..6292dbc2f 100644
--- a/src/main/java/spoon/reflect/factory/TypeFactory.java
+++ b/src/main/java/spoon/reflect/factory/TypeFactory.java
@@ -23,6 +23,7 @@ import spoon.reflect.declaration.CtPackage;
 import spoon.reflect.declaration.CtType;
 import spoon.reflect.declaration.CtTypeParameter;
 import spoon.reflect.reference.CtArrayTypeReference;
+import spoon.reflect.reference.CtIntersectionTypeReference;
 import spoon.reflect.reference.CtTypeParameterReference;
 import spoon.reflect.reference.CtTypeReference;
 import spoon.reflect.visitor.filter.TypeFilter;
@@ -375,7 +376,7 @@ public class TypeFactory extends SubFactory {
 	public CtTypeParameter createTypeParameter(CtElement owner, String name, List<CtTypeReference<?>> bounds) {
 		CtTypeParameter typeParam = factory.Core().createTypeParameter();
 		typeParam.setSimpleName(name);
-		typeParam.setBounds(bounds);
+		typeParam.setSuperType(createIntersectionTypeReference(bounds));
 		return typeParam;
 	}
 
@@ -402,8 +403,26 @@ public class TypeFactory extends SubFactory {
 	public CtTypeParameterReference createTypeParameterReference(String name, List<CtTypeReference<?>> bounds) {
 		CtTypeParameterReference typeParam = factory.Core().createTypeParameterReference();
 		typeParam.setSimpleName(name);
-		typeParam.setBounds(bounds);
+		typeParam.setBoundingType(createIntersectionTypeReference(bounds));
 		return typeParam;
 	}
 
+	/**
+	 * Creates an intersection type reference.
+	 *
+	 * @param bounds
+	 * 		List of bounds saved in the intersection type. The first bound will be the intersection type.
+	 * @param <T>
+	 * 		Type of the first bound.
+	 */
+	public <T> CtIntersectionTypeReference<T> createIntersectionTypeReference(List<CtTypeReference<?>> bounds) {
+		final CtIntersectionTypeReference<T> intersectionRef = factory.Core().createIntersectionTypeReference();
+		intersectionRef.setSimpleName(bounds.get(0).getSimpleName());
+		intersectionRef.setDeclaringType(bounds.get(0).getDeclaringType());
+		intersectionRef.setPackage(bounds.get(0).getPackage());
+		intersectionRef.setActualTypeArguments(bounds.get(0).getActualTypeArguments());
+		intersectionRef.setBounds(bounds);
+		return intersectionRef;
+	}
+
 }
diff --git a/src/main/java/spoon/reflect/reference/CtIntersectionTypeReference.java b/src/main/java/spoon/reflect/reference/CtIntersectionTypeReference.java
new file mode 100644
index 000000000..357f76b40
--- /dev/null
+++ b/src/main/java/spoon/reflect/reference/CtIntersectionTypeReference.java
@@ -0,0 +1,47 @@
+/**
+ * Copyright (C) 2006-2015 INRIA and contributors
+ * Spoon - http://spoon.gforge.inria.fr/
+ *
+ * This software is governed by the CeCILL-C License under French law and
+ * abiding by the rules of distribution of free software. You can use, modify
+ * and/or redistribute the software under the terms of the CeCILL-C license as
+ * circulated by CEA, CNRS and INRIA at http://www.cecill.info.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the CeCILL-C License for more details.
+ *
+ * The fact that you are presently reading this means that you have had
+ * knowledge of the CeCILL-C license and that you accept its terms.
+ */
+package spoon.reflect.reference;
+
+import java.util.List;
+
+/**
+ * This interface defines a reference to an intersection type in generics or in casts.
+ */
+public interface CtIntersectionTypeReference<T> extends CtTypeReference<T> {
+	/**
+	 * Gets the bounds of the intersection type. Note that the first bound correspond to the current intersection type.
+	 * <pre>
+	 *     T extends Interface1 & Interface2 // CtTypeParameterReference#getBoundingType == Interface1 and getBounds().get(0) == Interface1
+	 * </pre>
+	 */
+	List<CtTypeReference<?>> getBounds();
+
+	/**
+	 * Sets the bounds of the intersection type.
+	 */
+	<C extends CtIntersectionTypeReference> C setBounds(List<CtTypeReference<?>> bounds);
+
+	/**
+	 * Adds a bound.
+	 */
+	<C extends CtIntersectionTypeReference> C addBound(CtTypeReference<?> bound);
+
+	/**
+	 * Removes a bound.
+	 */
+	boolean removeBound(CtTypeReference<?> bound);
+}
diff --git a/src/main/java/spoon/reflect/reference/CtTypeParameterReference.java b/src/main/java/spoon/reflect/reference/CtTypeParameterReference.java
index ba677da9d..1fd75c4b9 100644
--- a/src/main/java/spoon/reflect/reference/CtTypeParameterReference.java
+++ b/src/main/java/spoon/reflect/reference/CtTypeParameterReference.java
@@ -27,31 +27,56 @@ public interface CtTypeParameterReference extends CtTypeReference<Object> {
 	/**
 	 * Gets the bounds (aka generics) of the referenced parameter.
 	 */
+	@Deprecated
 	List<CtTypeReference<?>> getBounds();
 
 	/**
-	 * Returns {@code true} if the bounds are upper bounds.
+	 * Returns {@code true} if the bounds are in <code>extends</code> clause.
+	 * {@code false} means a <code>super</code> clause.
 	 */
 	boolean isUpper();
 
 	/**
 	 * Sets the bounds (aka generics) of the referenced parameter.
 	 */
+	@Deprecated
 	<T extends CtTypeParameterReference> T setBounds(List<CtTypeReference<?>> bounds);
 
 	/**
-	 * Set to {@code true} if the bounds are upper bounds.
+	 * Set to {@code true} to write <code>extends</code> clause for bounds types.
 	 */
 	<T extends CtTypeParameterReference> T setUpper(boolean upper);
 
 	/**
 	 * Adds a bound.
 	 */
+	@Deprecated
 	<T extends CtTypeParameterReference> T addBound(CtTypeReference<?> bound);
 
 	/**
 	 * Removes a bound.
 	 */
+	@Deprecated
 	boolean removeBound(CtTypeReference<?> bound);
 
+	/**
+	 * A type parameter can have an <code>extends</code> clause which declare
+	 * one ({@link CtTypeReference} or more ({@link CtIntersectionTypeReference} references.
+	 * <pre>
+	 *     // Extends with generics.
+	 *     T extends Interface1
+	 *     // Intersection type with generics.
+	 *     T extends Interface1 & Interface2
+	 *     // Type in cast.
+	 *     (Runnable) () -> System.out.println("");
+	 *     // Intersection type with casts.
+	 *     (Runnable & Serializable) () -> System.out.println("");
+	 * </pre>
+	 */
+	CtTypeReference<?> getBoundingType();
+
+	/**
+	 * Sets the <code>extends</code> clause of the type parameter.
+	 */
+	<T extends CtTypeParameterReference> T setBoundingType(CtTypeReference<?> superType);
 }
diff --git a/src/main/java/spoon/reflect/reference/CtTypeReference.java b/src/main/java/spoon/reflect/reference/CtTypeReference.java
index dfe45ee45..ef47cbac9 100644
--- a/src/main/java/spoon/reflect/reference/CtTypeReference.java
+++ b/src/main/java/spoon/reflect/reference/CtTypeReference.java
@@ -101,4 +101,9 @@ public interface CtTypeReference<T> extends CtReference, CtGenericElementReferen
 	 * Replaces a type reference by another one.
 	 */
 	void replace(CtTypeReference<?> reference);
+
+	/**
+	 * Casts the type reference in {@link CtIntersectionTypeReference}.
+	 */
+	CtIntersectionTypeReference<T> asCtIntersectionTypeReference();
 }
diff --git a/src/main/java/spoon/reflect/visitor/CtAbstractVisitor.java b/src/main/java/spoon/reflect/visitor/CtAbstractVisitor.java
index 631a6a639..3101e497b 100644
--- a/src/main/java/spoon/reflect/visitor/CtAbstractVisitor.java
+++ b/src/main/java/spoon/reflect/visitor/CtAbstractVisitor.java
@@ -83,6 +83,7 @@ import spoon.reflect.reference.CtArrayTypeReference;
 import spoon.reflect.reference.CtCatchVariableReference;
 import spoon.reflect.reference.CtExecutableReference;
 import spoon.reflect.reference.CtFieldReference;
+import spoon.reflect.reference.CtIntersectionTypeReference;
 import spoon.reflect.reference.CtLocalVariableReference;
 import spoon.reflect.reference.CtPackageReference;
 import spoon.reflect.reference.CtParameterReference;
@@ -376,6 +377,11 @@ public abstract class CtAbstractVisitor implements CtVisitor {
 
 	}
 
+	@Override
+	public <T> void visitCtIntersectionTypeReference(CtIntersectionTypeReference<T> reference) {
+
+	}
+
 	@Override
 	public <T> void visitCtTypeReference(CtTypeReference<T> reference) {
 
diff --git a/src/main/java/spoon/reflect/visitor/CtInheritanceScanner.java b/src/main/java/spoon/reflect/visitor/CtInheritanceScanner.java
index dd45088d1..0e45edead 100644
--- a/src/main/java/spoon/reflect/visitor/CtInheritanceScanner.java
+++ b/src/main/java/spoon/reflect/visitor/CtInheritanceScanner.java
@@ -103,6 +103,7 @@ import spoon.reflect.reference.CtExecutableReference;
 import spoon.reflect.reference.CtFieldReference;
 import spoon.reflect.reference.CtGenericElementReference;
 import spoon.reflect.internal.CtImplicitTypeReference;
+import spoon.reflect.reference.CtIntersectionTypeReference;
 import spoon.reflect.reference.CtLocalVariableReference;
 import spoon.reflect.reference.CtPackageReference;
 import spoon.reflect.reference.CtParameterReference;
@@ -779,6 +780,11 @@ public abstract class CtInheritanceScanner implements CtVisitor {
 		visitCtTypeReference(e);
 	}
 
+	@Override
+	public <T> void visitCtIntersectionTypeReference(CtIntersectionTypeReference<T> e) {
+		visitCtTypeReference(e);
+	}
+
 	public <T> void visitCtTypeReference(CtTypeReference<T> e) {
 		scanCtReference(e);
 		scanCtTypeInformation(e);
diff --git a/src/main/java/spoon/reflect/visitor/CtScanner.java b/src/main/java/spoon/reflect/visitor/CtScanner.java
index 71fbfcebc..a0417b318 100644
--- a/src/main/java/spoon/reflect/visitor/CtScanner.java
+++ b/src/main/java/spoon/reflect/visitor/CtScanner.java
@@ -84,6 +84,7 @@ import spoon.reflect.reference.CtArrayTypeReference;
 import spoon.reflect.reference.CtCatchVariableReference;
 import spoon.reflect.reference.CtExecutableReference;
 import spoon.reflect.reference.CtFieldReference;
+import spoon.reflect.reference.CtIntersectionTypeReference;
 import spoon.reflect.reference.CtLocalVariableReference;
 import spoon.reflect.reference.CtPackageReference;
 import spoon.reflect.reference.CtParameterReference;
@@ -663,7 +664,7 @@ public abstract class CtScanner implements CtVisitor {
 	public void visitCtTypeParameter(CtTypeParameter typeParameter) {
 		enter(typeParameter);
 		scan(typeParameter.getAnnotations());
-		scan(typeParameter.getBounds());
+		scan(typeParameter.getSuperType());
 		exit(typeParameter);
 	}
 
@@ -673,10 +674,17 @@ public abstract class CtScanner implements CtVisitor {
 		scan(ref.getDeclaringType());
 		scan(ref.getActualTypeArguments());
 		scan(ref.getAnnotations());
-		scan(ref.getBounds());
+		scan(ref.getBoundingType());
 		exit(ref);
 	}
 
+	@Override
+	public <T> void visitCtIntersectionTypeReference(CtIntersectionTypeReference<T> reference) {
+		enter(reference);
+		scan(reference.getBounds());
+		exit(reference);
+	}
+
 	public <T> void visitCtTypeReference(CtTypeReference<T> reference) {
 		enter(reference);
 		scan(reference.getPackage());
diff --git a/src/main/java/spoon/reflect/visitor/CtVisitor.java b/src/main/java/spoon/reflect/visitor/CtVisitor.java
index c481f20f7..3bd1ea829 100644
--- a/src/main/java/spoon/reflect/visitor/CtVisitor.java
+++ b/src/main/java/spoon/reflect/visitor/CtVisitor.java
@@ -81,6 +81,7 @@ import spoon.reflect.reference.CtArrayTypeReference;
 import spoon.reflect.reference.CtCatchVariableReference;
 import spoon.reflect.reference.CtExecutableReference;
 import spoon.reflect.reference.CtFieldReference;
+import spoon.reflect.reference.CtIntersectionTypeReference;
 import spoon.reflect.reference.CtLocalVariableReference;
 import spoon.reflect.reference.CtPackageReference;
 import spoon.reflect.reference.CtParameterReference;
@@ -389,6 +390,11 @@ public interface CtVisitor {
 	 */
 	void visitCtTypeParameterReference(CtTypeParameterReference ref);
 
+	/**
+	 * Visits an intersection type.
+	 */
+	<T> void visitCtIntersectionTypeReference(CtIntersectionTypeReference<T> reference);
+
 	/**
 	 * Visits a reference to a type.
 	 */
diff --git a/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java b/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java
index 826afbdca..2db67b07b 100644
--- a/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java
+++ b/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java
@@ -101,6 +101,7 @@ import spoon.reflect.reference.CtCatchVariableReference;
 import spoon.reflect.reference.CtExecutableReference;
 import spoon.reflect.reference.CtFieldReference;
 import spoon.reflect.reference.CtGenericElementReference;
+import spoon.reflect.reference.CtIntersectionTypeReference;
 import spoon.reflect.reference.CtLocalVariableReference;
 import spoon.reflect.reference.CtPackageReference;
 import spoon.reflect.reference.CtParameterReference;
@@ -1864,13 +1865,9 @@ public class DefaultJavaPrettyPrinter implements CtVisitor, PrettyPrinter {
 
 	public void visitCtTypeParameter(CtTypeParameter typeParameter) {
 		write(typeParameter.getSimpleName());
-		if (!typeParameter.getBounds().isEmpty()) {
+		if (typeParameter.getSuperType() != null) {
 			write(" extends ");
-			for (CtTypeReference<?> ref : typeParameter.getBounds()) {
-				scan(ref);
-				write(" & ");
-			}
-			removeLastChar();
+			scan(typeParameter.getSuperType());
 		}
 	}
 
@@ -1881,20 +1878,23 @@ public class DefaultJavaPrettyPrinter implements CtVisitor, PrettyPrinter {
 		} else {
 			write(ref.getQualifiedName());
 		}
-		if ((!context.isInvocation || "?".equals(ref.getSimpleName()))
-				&& ref.getBounds() != null
-				&& !ref.getBounds().isEmpty()) {
+		if ((!context.isInvocation || "?".equals(ref.getSimpleName())) && ref.getBoundingType() != null) {
 			if (ref.isUpper()) {
 				write(" extends ");
 			} else {
 				write(" super ");
 			}
-			for (CtTypeReference<?> b : ref.getBounds()) {
-				scan(b);
-				write(" & ");
-			}
-			removeLastChar();
+			scan(ref.getBoundingType());
+		}
+	}
+
+	@Override
+	public <T> void visitCtIntersectionTypeReference(CtIntersectionTypeReference<T> reference) {
+		for (CtTypeReference<?> bound : reference.getBounds()) {
+			scan(bound);
+			write(" & ");
 		}
+		removeLastChar();
 	}
 
 	public <T> void visitCtTypeReference(CtTypeReference<T> ref) {
diff --git a/src/main/java/spoon/support/DefaultCoreFactory.java b/src/main/java/spoon/support/DefaultCoreFactory.java
index f0541d64e..c167c7245 100644
--- a/src/main/java/spoon/support/DefaultCoreFactory.java
+++ b/src/main/java/spoon/support/DefaultCoreFactory.java
@@ -84,6 +84,7 @@ import spoon.reflect.reference.CtArrayTypeReference;
 import spoon.reflect.reference.CtCatchVariableReference;
 import spoon.reflect.reference.CtExecutableReference;
 import spoon.reflect.reference.CtFieldReference;
+import spoon.reflect.reference.CtIntersectionTypeReference;
 import spoon.reflect.reference.CtLocalVariableReference;
 import spoon.reflect.reference.CtPackageReference;
 import spoon.reflect.reference.CtParameterReference;
@@ -155,6 +156,7 @@ import spoon.support.reflect.reference.CtArrayTypeReferenceImpl;
 import spoon.support.reflect.reference.CtCatchVariableReferenceImpl;
 import spoon.support.reflect.reference.CtExecutableReferenceImpl;
 import spoon.support.reflect.reference.CtFieldReferenceImpl;
+import spoon.support.reflect.reference.CtIntersectionTypeReferenceImpl;
 import spoon.support.reflect.reference.CtLocalVariableReferenceImpl;
 import spoon.support.reflect.reference.CtPackageReferenceImpl;
 import spoon.support.reflect.reference.CtParameterReferenceImpl;
@@ -614,6 +616,13 @@ public class DefaultCoreFactory implements CoreFactory, Serializable {
 		return e;
 	}
 
+	@Override
+	public <T> CtIntersectionTypeReference<T> createIntersectionTypeReference() {
+		CtIntersectionTypeReference<T> e = new CtIntersectionTypeReferenceImpl<T>();
+		e.setFactory(getMainFactory());
+		return e;
+	}
+
 	public <T> CtTypeReference<T> createTypeReference() {
 		CtTypeReference<T> e = new CtTypeReferenceImpl<T>();
 		e.setFactory(getMainFactory());
diff --git a/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java b/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
index efdfa1a6c..a3f094e4a 100644
--- a/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
+++ b/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
@@ -646,7 +646,7 @@ public class JDTTreeBuilder extends ASTVisitor {
 			if (name.contains("extends") || name.contains("super")) {
 				String[] split = name.contains("extends") ? name.split("extends") : name.split("super");
 				param.setSimpleName(split[0].trim());
-				param.addBound(getTypeReference(split[split.length - 1].trim()));
+				param.setBoundingType(getTypeReference(split[split.length - 1].trim()));
 			} else if (name.matches(".*(<.+>)")) {
 				Pattern pattern = Pattern.compile("([^<]+)<(.+)>");
 				Matcher m = pattern.matcher(name);
@@ -754,17 +754,18 @@ public class JDTTreeBuilder extends ASTVisitor {
 					} else if (b.superclass != null && b.firstBound == b.superclass) {
 						bounds = false;
 						bindingCache.put(binding, ref);
-						((CtTypeParameterReference) ref).addBound(getTypeReference(b.superclass));
+						((CtTypeParameterReference) ref).setBoundingType(getTypeReference(b.superclass));
 						bounds = oldBounds;
 					}
 				}
 				if (bounds && b.superInterfaces != null && b.superInterfaces != Binding.NO_SUPERINTERFACES) {
 					bounds = false;
 					bindingCache.put(binding, ref);
-					for (int i = 0, length = b.superInterfaces.length; i < length; i++) {
-						TypeBinding tb = b.superInterfaces[i];
-						((CtTypeParameterReference) ref).addBound(getTypeReference(tb));
+					List<CtTypeReference<?>> bounds = new ArrayList<CtTypeReference<?>>(b.superInterfaces.length);
+					for (ReferenceBinding superInterface : b.superInterfaces) {
+						bounds.add(getTypeReference(superInterface));
 					}
+					((CtTypeParameterReference) ref).setBoundingType(factory.Type().createIntersectionTypeReference(bounds));
 				}
 				if (binding instanceof CaptureBinding) {
 					bounds = false;
@@ -798,9 +799,9 @@ public class JDTTreeBuilder extends ASTVisitor {
 				if (((WildcardBinding) binding).bound != null && ref instanceof CtTypeParameterReference) {
 					if (bindingCache.containsKey(((WildcardBinding) binding).bound)) {
 						final CtCircularTypeReference circularRef = getCtCircularTypeReference(((WildcardBinding) binding).bound);
-						((CtTypeParameterReference) ref).addBound(circularRef);
+						((CtTypeParameterReference) ref).setBoundingType(circularRef);
 					} else {
-						((CtTypeParameterReference) ref).addBound(getTypeReference(((WildcardBinding) binding).bound));
+						((CtTypeParameterReference) ref).setBoundingType(getTypeReference(((WildcardBinding) binding).bound));
 					}
 				}
 			} else if (binding instanceof LocalTypeBinding) {
@@ -876,7 +877,11 @@ public class JDTTreeBuilder extends ASTVisitor {
 				ref.setSimpleName(new String(binding.sourceName()));
 				ref.setDeclaringType(getTypeReference(binding.enclosingType()));
 			} else if (binding instanceof IntersectionTypeBinding18) {
-				ref = getTypeReference(binding.getIntersectingTypes()[0]);
+				List<CtTypeReference<?>> bounds = new ArrayList<CtTypeReference<?>>(binding.getIntersectingTypes().length);
+				for (ReferenceBinding superInterface : binding.getIntersectingTypes()) {
+					bounds.add(getTypeReference(superInterface));
+				}
+				ref = factory.Type().createIntersectionTypeReference(bounds);
 			} else {
 				throw new RuntimeException("Unknown TypeBinding: " + binding.getClass() + " " + binding);
 			}
diff --git a/src/main/java/spoon/support/reflect/declaration/CtTypeParameterImpl.java b/src/main/java/spoon/support/reflect/declaration/CtTypeParameterImpl.java
index c4ac27c42..150a30a2d 100644
--- a/src/main/java/spoon/support/reflect/declaration/CtTypeParameterImpl.java
+++ b/src/main/java/spoon/support/reflect/declaration/CtTypeParameterImpl.java
@@ -17,14 +17,14 @@
 package spoon.support.reflect.declaration;
 
 import spoon.reflect.declaration.CtTypeParameter;
+import spoon.reflect.reference.CtIntersectionTypeReference;
 import spoon.reflect.reference.CtTypeReference;
 import spoon.reflect.visitor.CtVisitor;
 
-import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
 
-import static spoon.reflect.ModelElementContainerDefaultCapacities.TYPE_BOUNDS_CONTAINER_DEFAULT_CAPACITY;
-
 /**
  * The implementation for {@link spoon.reflect.declaration.CtTypeParameter}.
  *
@@ -33,7 +33,7 @@ import static spoon.reflect.ModelElementContainerDefaultCapacities.TYPE_BOUNDS_C
 public class CtTypeParameterImpl extends CtNamedElementImpl implements CtTypeParameter {
 	private static final long serialVersionUID = 1L;
 
-	List<CtTypeReference<?>> bounds = emptyList();
+	CtTypeReference<?> superType;
 
 	public CtTypeParameterImpl() {
 		super();
@@ -46,33 +46,68 @@ public class CtTypeParameterImpl extends CtNamedElementImpl implements CtTypePar
 
 	@Override
 	public <T extends CtTypeParameter> T addBound(CtTypeReference<?> bound) {
-		if (bounds == CtElementImpl.<CtTypeReference<?>>emptyList()) {
-			bounds = new ArrayList<CtTypeReference<?>>(TYPE_BOUNDS_CONTAINER_DEFAULT_CAPACITY);
+		if (bound == null) {
+			return (T) this;
+		}
+		if (getSuperType() == null) {
+			setSuperType(bound);
+		} else if (getSuperType() instanceof CtIntersectionTypeReference<?>) {
+			getSuperType().asCtIntersectionTypeReference().addBound(bound);
+		} else {
+			setSuperType(getFactory().Type().createIntersectionTypeReference(Arrays.asList(getSuperType(), bound)));
 		}
-		bound.setParent(this);
-		this.bounds.add(bound);
 		return (T) this;
 	}
 
 	@Override
 	public boolean removeBound(CtTypeReference<?> bound) {
-		return bounds != CtElementImpl.<CtTypeReference<?>>emptyList() && this.bounds.remove(bound);
+		if (bound == null || getSuperType() == null) {
+			return false;
+		}
+		if (getSuperType() instanceof CtIntersectionTypeReference<?>) {
+			return getSuperType().asCtIntersectionTypeReference().removeBound(bound);
+		} else {
+			setSuperType(null);
+			return true;
+		}
 	}
 
 	@Override
 	public List<CtTypeReference<?>> getBounds() {
-		return bounds;
+		if (getSuperType() instanceof CtIntersectionTypeReference<?>) {
+			return getSuperType().asCtIntersectionTypeReference().getBounds();
+		} else if (getSuperType() != null) {
+			return Collections.<CtTypeReference<?>>singletonList(getSuperType());
+		}
+		return emptyList();
 	}
 
 	@Override
 	public <T extends CtTypeParameter> T setBounds(List<CtTypeReference<?>> bounds) {
-		if (this.bounds == CtElementImpl.<CtTypeReference<?>>emptyList()) {
-			this.bounds = new ArrayList<CtTypeReference<?>>(TYPE_BOUNDS_CONTAINER_DEFAULT_CAPACITY);
+		if (bounds == null) {
+			return (T) this;
+		}
+		if (getSuperType() instanceof CtIntersectionTypeReference<?>) {
+			getSuperType().asCtIntersectionTypeReference().setBounds(bounds);
+		} else if (bounds.size() > 1) {
+			setSuperType(getFactory().Type().createIntersectionTypeReference(bounds));
+		} else {
+			setSuperType(bounds.get(0));
 		}
-		this.bounds.clear();
-		for (CtTypeReference<?> bound : bounds) {
-			addBound(bound);
+		return (T) this;
+	}
+
+	@Override
+	public CtTypeReference<?> getSuperType() {
+		return superType;
+	}
+
+	@Override
+	public <T extends CtTypeParameter> T setSuperType(CtTypeReference<?> superType) {
+		if (superType != null) {
+			superType.setParent(this);
 		}
+		this.superType = superType;
 		return (T) this;
 	}
 }
diff --git a/src/main/java/spoon/support/reflect/eval/VisitorPartialEvaluator.java b/src/main/java/spoon/support/reflect/eval/VisitorPartialEvaluator.java
index 4a98c18bd..17e869872 100644
--- a/src/main/java/spoon/support/reflect/eval/VisitorPartialEvaluator.java
+++ b/src/main/java/spoon/support/reflect/eval/VisitorPartialEvaluator.java
@@ -96,6 +96,7 @@ import spoon.reflect.reference.CtCatchVariableReference;
 import spoon.reflect.reference.CtExecutableReference;
 import spoon.reflect.reference.CtFieldReference;
 import spoon.reflect.reference.CtGenericElementReference;
+import spoon.reflect.reference.CtIntersectionTypeReference;
 import spoon.reflect.reference.CtLocalVariableReference;
 import spoon.reflect.reference.CtPackageReference;
 import spoon.reflect.reference.CtParameterReference;
@@ -727,6 +728,11 @@ public class VisitorPartialEvaluator implements CtVisitor, PartialEvaluator {
 		throw new RuntimeException("Unknow Element");
 	}
 
+	@Override
+	public <T> void visitCtIntersectionTypeReference(CtIntersectionTypeReference<T> reference) {
+		throw new RuntimeException("Unknown Element");
+	}
+
 	public <T> void visitCtTypeReference(CtTypeReference<T> reference) {
 		throw new RuntimeException("Unknow Element");
 	}
diff --git a/src/main/java/spoon/support/reflect/reference/CtIntersectionTypeReferenceImpl.java b/src/main/java/spoon/support/reflect/reference/CtIntersectionTypeReferenceImpl.java
new file mode 100644
index 000000000..73e4a08a4
--- /dev/null
+++ b/src/main/java/spoon/support/reflect/reference/CtIntersectionTypeReferenceImpl.java
@@ -0,0 +1,71 @@
+/**
+ * Copyright (C) 2006-2015 INRIA and contributors
+ * Spoon - http://spoon.gforge.inria.fr/
+ *
+ * This software is governed by the CeCILL-C License under French law and
+ * abiding by the rules of distribution of free software. You can use, modify
+ * and/or redistribute the software under the terms of the CeCILL-C license as
+ * circulated by CEA, CNRS and INRIA at http://www.cecill.info.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the CeCILL-C License for more details.
+ *
+ * The fact that you are presently reading this means that you have had
+ * knowledge of the CeCILL-C license and that you accept its terms.
+ */
+package spoon.support.reflect.reference;
+
+import spoon.reflect.reference.CtIntersectionTypeReference;
+import spoon.reflect.reference.CtTypeReference;
+import spoon.reflect.visitor.CtVisitor;
+import spoon.support.reflect.declaration.CtElementImpl;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import static spoon.reflect.ModelElementContainerDefaultCapacities.TYPE_BOUNDS_CONTAINER_DEFAULT_CAPACITY;
+
+public class CtIntersectionTypeReferenceImpl<T> extends CtTypeReferenceImpl<T> implements CtIntersectionTypeReference<T> {
+	List<CtTypeReference<?>> bounds = CtElementImpl.emptyList();
+
+	@Override
+	public void accept(CtVisitor visitor) {
+		visitor.visitCtIntersectionTypeReference(this);
+	}
+
+	@Override
+	public List<CtTypeReference<?>> getBounds() {
+		return Collections.unmodifiableList(bounds);
+	}
+
+	@Override
+	public <C extends CtIntersectionTypeReference> C setBounds(List<CtTypeReference<?>> bounds) {
+		if (this.bounds == CtElementImpl.<CtTypeReference<?>>emptyList()) {
+			this.bounds = new ArrayList<CtTypeReference<?>>(TYPE_BOUNDS_CONTAINER_DEFAULT_CAPACITY);
+		}
+		this.bounds.clear();
+		final List<CtTypeReference<?>> newBounds = new ArrayList<CtTypeReference<?>>();
+		newBounds.addAll(bounds);
+		for (CtTypeReference<?> bound : newBounds) {
+			addBound(bound);
+		}
+		return (C) this;
+	}
+
+	@Override
+	public <C extends CtIntersectionTypeReference> C addBound(CtTypeReference<?> bound) {
+		if (bounds == CtElementImpl.<CtTypeReference<?>>emptyList()) {
+			bounds = new ArrayList<CtTypeReference<?>>(TYPE_BOUNDS_CONTAINER_DEFAULT_CAPACITY);
+		}
+		bound.setParent(this);
+		bounds.add(bound);
+		return (C) this;
+	}
+
+	@Override
+	public boolean removeBound(CtTypeReference<?> bound) {
+		return bounds != CtElementImpl.<CtTypeReference<?>>emptyList() && bounds.remove(bound);
+	}
+}
diff --git a/src/main/java/spoon/support/reflect/reference/CtTypeParameterReferenceImpl.java b/src/main/java/spoon/support/reflect/reference/CtTypeParameterReferenceImpl.java
index c8052713b..8a4c59015 100644
--- a/src/main/java/spoon/support/reflect/reference/CtTypeParameterReferenceImpl.java
+++ b/src/main/java/spoon/support/reflect/reference/CtTypeParameterReferenceImpl.java
@@ -17,6 +17,7 @@
 package spoon.support.reflect.reference;
 
 import spoon.reflect.reference.CtGenericElementReference;
+import spoon.reflect.reference.CtIntersectionTypeReference;
 import spoon.reflect.reference.CtReference;
 import spoon.reflect.reference.CtTypeParameterReference;
 import spoon.reflect.reference.CtTypeReference;
@@ -25,16 +26,16 @@ import spoon.support.reflect.declaration.CtElementImpl;
 
 import java.lang.reflect.AnnotatedElement;
 import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
 
-import static spoon.reflect.ModelElementContainerDefaultCapacities.TYPE_BOUNDS_CONTAINER_DEFAULT_CAPACITY;
 import static spoon.reflect.ModelElementContainerDefaultCapacities.TYPE_TYPE_PARAMETERS_CONTAINER_DEFAULT_CAPACITY;
 
-public class CtTypeParameterReferenceImpl extends CtTypeReferenceImpl<Object>
-		implements CtTypeParameterReference {
+public class CtTypeParameterReferenceImpl extends CtTypeReferenceImpl<Object> implements CtTypeParameterReference {
 	private static final long serialVersionUID = 1L;
 
-	List<CtTypeReference<?>> bounds = CtElementImpl.emptyList();
+	CtTypeReference<?> superType;
 
 	boolean upper = true;
 
@@ -49,7 +50,12 @@ public class CtTypeParameterReferenceImpl extends CtTypeReferenceImpl<Object>
 
 	@Override
 	public List<CtTypeReference<?>> getBounds() {
-		return bounds;
+		if (getBoundingType() instanceof CtIntersectionTypeReference<?>) {
+			return getBoundingType().asCtIntersectionTypeReference().getBounds();
+		} else if (getBoundingType() != null) {
+			return Collections.<CtTypeReference<?>>singletonList(getBoundingType());
+		}
+		return emptyList();
 	}
 
 	@Override
@@ -59,12 +65,15 @@ public class CtTypeParameterReferenceImpl extends CtTypeReferenceImpl<Object>
 
 	@Override
 	public <T extends CtTypeParameterReference> T setBounds(List<CtTypeReference<?>> bounds) {
-		if (this.bounds == CtElementImpl.<CtTypeReference<?>>emptyList()) {
-			this.bounds = new ArrayList<CtTypeReference<?>>(TYPE_BOUNDS_CONTAINER_DEFAULT_CAPACITY);
+		if (bounds == null) {
+			return (T) this;
 		}
-		this.bounds.clear();
-		for (CtTypeReference<?> bound : bounds) {
-			addBound(bound);
+		if (getBoundingType() instanceof CtIntersectionTypeReference<?>) {
+			getBoundingType().asCtIntersectionTypeReference().setBounds(bounds);
+		} else if (bounds.size() > 1) {
+			setBoundingType(getFactory().Type().createIntersectionTypeReference(bounds));
+		} else {
+			setBoundingType(bounds.get(0));
 		}
 		return (T) this;
 	}
@@ -94,10 +103,10 @@ public class CtTypeParameterReferenceImpl extends CtTypeReferenceImpl<Object>
 	@SuppressWarnings("unchecked")
 	public Class<Object> getActualClass() {
 		if (isUpper()) {
-			if (getBounds().isEmpty()) {
+			if (getBoundingType() == null) {
 				return Object.class;
 			}
-			return (Class<Object>) getBounds().get(0).getActualClass();
+			return (Class<Object>) getBoundingType().getActualClass();
 		}
 		return null;
 	}
@@ -121,17 +130,44 @@ public class CtTypeParameterReferenceImpl extends CtTypeReferenceImpl<Object>
 
 	@Override
 	public <T extends CtTypeParameterReference> T addBound(CtTypeReference<?> bound) {
-		if (bounds == CtElementImpl.<CtTypeReference<?>>emptyList()) {
-			bounds = new ArrayList<CtTypeReference<?>>(TYPE_BOUNDS_CONTAINER_DEFAULT_CAPACITY);
+		if (bound == null) {
+			return (T) this;
+		}
+		if (getBoundingType() == null) {
+			setBoundingType(bound);
+		} else if (getBoundingType() instanceof CtIntersectionTypeReference<?>) {
+			getBoundingType().asCtIntersectionTypeReference().addBound(bound);
+		} else {
+			setBoundingType(getFactory().Type().createIntersectionTypeReference(Arrays.asList(getBoundingType(), bound)));
 		}
-		bound.setParent(this);
-		bounds.add(bound);
 		return (T) this;
 	}
 
 	@Override
 	public boolean removeBound(CtTypeReference<?> bound) {
-		return bounds != CtElementImpl.<CtTypeReference<?>>emptyList() && bounds.remove(bound);
+		if (bound == null || getBoundingType() == null) {
+			return false;
+		}
+		if (getBoundingType() instanceof CtIntersectionTypeReference<?>) {
+			return getBoundingType().asCtIntersectionTypeReference().removeBound(bound);
+		} else {
+			setBoundingType(null);
+			return true;
+		}
+	}
+
+	@Override
+	public CtTypeReference<?> getBoundingType() {
+		return superType;
+	}
+
+	@Override
+	public <T extends CtTypeParameterReference> T setBoundingType(CtTypeReference<?> superType) {
+		if (superType != null) {
+			superType.setParent(this);
+		}
+		this.superType = superType;
+		return (T) this;
 	}
 
 	@Override
diff --git a/src/main/java/spoon/support/reflect/reference/CtTypeReferenceImpl.java b/src/main/java/spoon/support/reflect/reference/CtTypeReferenceImpl.java
index e3db50adf..abee2870c 100644
--- a/src/main/java/spoon/support/reflect/reference/CtTypeReferenceImpl.java
+++ b/src/main/java/spoon/support/reflect/reference/CtTypeReferenceImpl.java
@@ -25,6 +25,7 @@ import spoon.reflect.reference.CtArrayTypeReference;
 import spoon.reflect.reference.CtExecutableReference;
 import spoon.reflect.reference.CtFieldReference;
 import spoon.reflect.reference.CtGenericElementReference;
+import spoon.reflect.reference.CtIntersectionTypeReference;
 import spoon.reflect.reference.CtPackageReference;
 import spoon.reflect.reference.CtTypeParameterReference;
 import spoon.reflect.reference.CtTypeReference;
@@ -295,6 +296,11 @@ public class CtTypeReferenceImpl<T> extends CtReferenceImpl implements CtTypeRef
 		super.replace(reference);
 	}
 
+	@Override
+	public CtIntersectionTypeReference<T> asCtIntersectionTypeReference() {
+		return (CtIntersectionTypeReference<T>) this;
+	}
+
 	@Override
 	public CtTypeReference<?> unbox() {
 		if (isPrimitive()) {
diff --git a/src/main/java/spoon/support/visitor/SignaturePrinter.java b/src/main/java/spoon/support/visitor/SignaturePrinter.java
index 7ec8039c3..49555576b 100644
--- a/src/main/java/spoon/support/visitor/SignaturePrinter.java
+++ b/src/main/java/spoon/support/visitor/SignaturePrinter.java
@@ -22,6 +22,7 @@ import spoon.reflect.declaration.CtMethod;
 import spoon.reflect.declaration.CtParameter;
 import spoon.reflect.reference.CtArrayTypeReference;
 import spoon.reflect.reference.CtExecutableReference;
+import spoon.reflect.reference.CtIntersectionTypeReference;
 import spoon.reflect.reference.CtTypeParameterReference;
 import spoon.reflect.reference.CtTypeReference;
 import spoon.reflect.visitor.CtInheritanceScanner;
@@ -78,22 +79,26 @@ public class SignaturePrinter extends  CtInheritanceScanner {
 	@Override
 	public void visitCtTypeParameterReference(CtTypeParameterReference ref) {
 		write(ref.getQualifiedName());
-		if (ref.getBounds() != null && !ref.getBounds().isEmpty()) {
+		if (ref.getBoundingType() != null) {
 			if (ref.isUpper()) {
 				write(" extends ");
 			} else {
 				write(" super ");
 			}
-			for (CtTypeReference<?> b: ref.getBounds()) {
-				scan(b);
-				write(",");
-			}
-			if (ref.getBounds().size() > 0) {
-				clearLast();
-			}
+			scan(ref.getBoundingType());
 		}
 	}
 
+	@Override
+	public <T> void visitCtIntersectionTypeReference(CtIntersectionTypeReference<T> reference) {
+		for (CtTypeReference<?> bound : reference.getBounds()) {
+			scan(bound);
+			write(", ");
+		}
+		clearLast();
+		clearLast();
+	}
+
 	@Override
 	public <T> void visitCtConstructor(CtConstructor<T> c) {
 		write(c.getDeclaringType().getQualifiedName());
@@ -108,8 +113,6 @@ public class SignaturePrinter extends  CtInheritanceScanner {
 		write(")");
 	}
 
-
-
 	@Override
 	public <T> void visitCtMethod(CtMethod<T> m) {
 		if (!m.getFormalTypeParameters().isEmpty()) {
@@ -142,7 +145,6 @@ public class SignaturePrinter extends  CtInheritanceScanner {
 		return this;
 	}
 
-
 	protected SignaturePrinter write(String value) {
 		signature.append(value);
 		return this;
diff --git a/src/test/java/spoon/test/generics/GenericsTest.java b/src/test/java/spoon/test/generics/GenericsTest.java
index a8585a655..269cb186e 100644
--- a/src/test/java/spoon/test/generics/GenericsTest.java
+++ b/src/test/java/spoon/test/generics/GenericsTest.java
@@ -34,16 +34,12 @@ import spoon.test.generics.testclasses.Panini;
 import spoon.test.generics.testclasses.Spaghetti;
 import spoon.test.generics.testclasses.Tacos;
 
-import java.io.File;
-import java.io.FileReader;
-import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
-import static spoon.testing.Assert.assertThat;
 import static spoon.testing.utils.ModelUtils.build;
 import static spoon.testing.utils.ModelUtils.canBeBuilt;
 import static spoon.testing.utils.ModelUtils.createFactory;
@@ -73,8 +69,8 @@ public class GenericsTest {
 		CtTypeParameterReference generic = (CtTypeParameterReference) type
 				.getFormalTypeParameters().get(0);
 		assertEquals("V", generic.getSimpleName());
-		assertEquals("[java.io.Serializable, java.lang.Comparable<V>]", generic
-				.getBounds().toString());
+		assertEquals("[java.io.Serializable, java.lang.Comparable<V>]", generic.getBounds().toString());
+		assertEquals("[java.io.Serializable, java.lang.Comparable<V>]", generic.getBoundingType().asCtIntersectionTypeReference().getBounds().toString());
 
 		CtMethod<?> node5 = type.getElements(
 				new NameFilter<CtMethod<?>>("node5")).get(0);
diff --git a/src/test/java/spoon/test/intercession/IntercessionTest.java b/src/test/java/spoon/test/intercession/IntercessionTest.java
index 1ccafc5ef..b4ce6bded 100644
--- a/src/test/java/spoon/test/intercession/IntercessionTest.java
+++ b/src/test/java/spoon/test/intercession/IntercessionTest.java
@@ -24,6 +24,7 @@ import spoon.reflect.declaration.CtClass;
 import spoon.reflect.declaration.CtConstructor;
 import spoon.reflect.declaration.CtMethod;
 import spoon.reflect.factory.Factory;
+import spoon.reflect.reference.CtIntersectionTypeReference;
 import spoon.reflect.reference.CtTypeParameterReference;
 import spoon.reflect.reference.CtTypeReference;
 import spoon.reflect.visitor.Query;
@@ -217,7 +218,7 @@ public class IntercessionTest {
 
 					if (!setter.getDeclaringType()
 							   .getSimpleName()
-							   .equals(((CtTypeParameterReference) ctTypeReference).getBounds().get(0).getSimpleName())) {
+							   .equals(((CtTypeParameterReference) ctTypeReference).getBoundingType().asCtIntersectionTypeReference().getBounds().get(0).getSimpleName())) {
 						fail("Your setter " + methodLog +
 									 " has a type reference who don't extends " +
 									 setter.getDeclaringType().getSimpleName());
diff --git a/src/test/java/spoon/test/parent/ParentContractTest.java b/src/test/java/spoon/test/parent/ParentContractTest.java
index 403ff2084..13f196858 100644
--- a/src/test/java/spoon/test/parent/ParentContractTest.java
+++ b/src/test/java/spoon/test/parent/ParentContractTest.java
@@ -107,6 +107,7 @@ public class ParentContractTest<T extends CtVisitable> {
 		for (Method setter : getMethodsToInvoke(toTest)) {
 
 			// special case: impossible methods on some objects (they throw an UnsupportedOperationException)
+			if (setter.getAnnotation(Deprecated.class) != null) continue;
 			if (o instanceof CtAnnotationType && "addMethod".equals(setter.getName())) continue;
 			if (o instanceof CtAnnotationType && "addFormalTypeParameter".equals(setter.getName())) continue;
 			if (o instanceof CtParameter && "setDefaultExpression".equals(setter.getName())) continue;
diff --git a/src/test/java/spoon/test/reference/TypeReferenceTest.java b/src/test/java/spoon/test/reference/TypeReferenceTest.java
index bc1aa7e7b..aa87d84ba 100644
--- a/src/test/java/spoon/test/reference/TypeReferenceTest.java
+++ b/src/test/java/spoon/test/reference/TypeReferenceTest.java
@@ -224,18 +224,29 @@ public class TypeReferenceTest {
 
 		final CtTypeParameterReference genericType = (CtTypeParameterReference) returnType.getActualTypeArguments().get(0);
 		assertNotNull(genericType);
-		assertEquals(1, genericType.getBounds().size());
+		assertNotNull(genericType.getBoundingType());
 
-		final CtTypeReference<?> extendsGeneric = genericType.getBounds().get(0);
+		// Deprecated.
+		CtTypeReference<?> extendsGeneric = genericType.getBounds().get(0);
 		assertNotNull(extendsGeneric);
 		assertEquals(1, extendsGeneric.getActualTypeArguments().size());
 
-		final CtTypeParameterReference genericExtends = (CtTypeParameterReference) extendsGeneric.getActualTypeArguments().get(0);
+		CtTypeParameterReference genericExtends = (CtTypeParameterReference) extendsGeneric.getActualTypeArguments().get(0);
 		assertNotNull(genericExtends);
-		assertEquals(1, genericExtends.getBounds().size());
+		assertNotNull(genericExtends.getBounds().get(0));
 
-		final CtTypeReference<?> circularRef = genericExtends.getBounds().get(0);
-		assertTrue(circularRef instanceof CtCircularTypeReference);
+		assertTrue(genericExtends.getBounds().get(0) instanceof CtCircularTypeReference);
+
+		// New.
+		extendsGeneric = genericType.getBoundingType();
+		assertNotNull(extendsGeneric);
+		assertEquals(1, extendsGeneric.getActualTypeArguments().size());
+
+		genericExtends = (CtTypeParameterReference) extendsGeneric.getActualTypeArguments().get(0);
+		assertNotNull(genericExtends);
+		assertNotNull(genericExtends.getBoundingType());
+
+		assertTrue(genericExtends.getBoundingType() instanceof CtCircularTypeReference);
 	}
 
 	@Test
@@ -250,9 +261,9 @@ public class TypeReferenceTest {
 
 		final CtTypeParameterReference genericType = (CtTypeParameterReference) asEnum.getFormalTypeParameters().get(0);
 		assertNotNull(genericType);
-		assertEquals(1, genericType.getBounds().size());
+		assertNotNull(genericType.getBoundingType());
 
-		final CtTypeReference<?> extendsGeneric = genericType.getBounds().get(0);
+		final CtTypeReference<?> extendsGeneric = genericType.getBoundingType();
 		assertNotNull(extendsGeneric);
 		assertEquals(1, extendsGeneric.getActualTypeArguments().size());
 
@@ -341,11 +352,17 @@ public class TypeReferenceTest {
 		final CtTypeReference<?> second = superInterface.getActualTypeArguments().get(1);
 		assertTrue(second instanceof CtTypeParameterReference);
 		assertEquals("?", second.getSimpleName());
+
 		final List<CtTypeReference<?>> bounds = ((CtTypeParameterReference) second).getBounds();
 		assertEquals(1, bounds.size());
 		assertEquals("Tacos", bounds.get(0).getSimpleName());
 		assertEquals(1, bounds.get(0).getActualTypeArguments().size());
 		assertEquals("?", bounds.get(0).getActualTypeArguments().get(0).getSimpleName());
+
+		final CtTypeReference<?> bound = ((CtTypeParameterReference) second).getBoundingType();
+		assertEquals("Tacos", bound.getSimpleName());
+		assertEquals(1, bound.getActualTypeArguments().size());
+		assertEquals("?", bound.getActualTypeArguments().get(0).getSimpleName());
 		assertEquals("example.FooBar", superInterface.getDeclaringType().getQualifiedName());
 		assertEquals("example.FooBar<?, ? extends Tacos<?>>.Bar<?, ? extends Tacos<?>>", superInterface.toString());
 	}
diff --git a/src/test/java/spoon/test/type/TypeTest.java b/src/test/java/spoon/test/type/TypeTest.java
index 84377051c..48efe5d7a 100644
--- a/src/test/java/spoon/test/type/TypeTest.java
+++ b/src/test/java/spoon/test/type/TypeTest.java
@@ -29,13 +29,18 @@ import spoon.reflect.code.CtTypeAccess;
 import spoon.reflect.declaration.CtClass;
 import spoon.reflect.declaration.CtMethod;
 import spoon.reflect.factory.Factory;
+import spoon.reflect.reference.CtIntersectionTypeReference;
+import spoon.reflect.reference.CtTypeParameterReference;
+import spoon.reflect.reference.CtTypeReference;
 import spoon.reflect.visitor.filter.TypeFilter;
 import spoon.test.type.testclasses.Pozole;
 
+import java.io.Serializable;
 import java.util.List;
 
 import static junit.framework.TestCase.assertFalse;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 import static spoon.testing.utils.ModelUtils.canBeBuilt;
 import static spoon.testing.utils.ModelUtils.createFactory;
@@ -142,7 +147,7 @@ public class TypeTest {
 	}
 
 	@Test
-	public void testIntersectionBindingReturnsFirstType() throws Exception {
+	public void testIntersectionTypeReferenceInGenericsAndCasts() throws Exception {
 		final String target = "./target/type";
 		final Launcher launcher = new Launcher();
 		launcher.addInputResource("./src/test/java/spoon/test/type/testclasses");
@@ -153,11 +158,65 @@ public class TypeTest {
 		final CtClass<Pozole> aPozole = launcher.getFactory().Class().get(Pozole.class);
 		final CtMethod<?> prepare = aPozole.getMethodsByName("prepare").get(0);
 
+		// Intersection type in generic types.
+		final List<CtClass> localTypes = prepare.getElements(new TypeFilter<>(CtClass.class));
+		assertEquals(1, localTypes.size());
+
+		final CtTypeParameterReference generic = (CtTypeParameterReference) localTypes.get(0).getFormalTypeParameters().get(0);
+		assertNotNull(generic);
+		assertEquals("T", generic.getSimpleName());
+		assertNotNull(generic.getBoundingType());
+		assertTrue(generic.getBoundingType() instanceof CtIntersectionTypeReference);
+		assertEquals("java.lang.Runnable & java.io.Serializable", generic.getBoundingType().toString());
+		final CtIntersectionTypeReference<?> superType = generic.getBoundingType().asCtIntersectionTypeReference();
+		assertEquals(aPozole.getFactory().Type().createReference(Runnable.class), superType.getBounds().get(0));
+		assertEquals(aPozole.getFactory().Type().createReference(Serializable.class), superType.getBounds().get(1));
+
+		// Intersection type in casts.
+		final List<CtLambda<?>> lambdas = prepare.getElements(new TypeFilter<CtLambda<?>>(CtLambda.class));
+		assertEquals(1, lambdas.size());
+
+		assertEquals(1, lambdas.get(0).getTypeCasts().size());
+		assertTrue(lambdas.get(0).getTypeCasts().get(0) instanceof CtIntersectionTypeReference);
+		final CtIntersectionTypeReference<?> intersectionType = lambdas.get(0).getTypeCasts().get(0).asCtIntersectionTypeReference();
+		assertEquals("java.lang.Runnable & java.io.Serializable", intersectionType.toString());
+		assertEquals(aPozole.getFactory().Type().createReference(Runnable.class), intersectionType.getBounds().get(0));
+		assertEquals(aPozole.getFactory().Type().createReference(Serializable.class), intersectionType.getBounds().get(1));
+
+		canBeBuilt(target, 8, true);
+	}
+
+	@Test
+	public void testTypeReferenceInGenericsAndCasts() throws Exception {
+		final String target = "./target/type";
+		final Launcher launcher = new Launcher();
+		launcher.addInputResource("./src/test/java/spoon/test/type/testclasses");
+		launcher.setSourceOutputDirectory(target);
+		launcher.getEnvironment().setNoClasspath(true);
+		launcher.run();
+
+		final CtClass<Pozole> aPozole = launcher.getFactory().Class().get(Pozole.class);
+		final CtMethod<?> prepare = aPozole.getMethodsByName("finish").get(0);
+
+		// Intersection type in generic types.
+		final List<CtClass> localTypes = prepare.getElements(new TypeFilter<>(CtClass.class));
+		assertEquals(1, localTypes.size());
+
+		final CtTypeParameterReference generic = (CtTypeParameterReference) localTypes.get(0).getFormalTypeParameters().get(0);
+		assertNotNull(generic);
+		assertEquals("T", generic.getSimpleName());
+		assertNotNull(generic.getBoundingType());
+		assertTrue(generic.getBoundingType() instanceof CtTypeReference);
+		assertEquals("java.lang.Runnable", generic.getBoundingType().toString());
+		assertEquals(aPozole.getFactory().Type().createReference(Runnable.class), generic.getBoundingType());
+
+		// Intersection type in casts.
 		final List<CtLambda<?>> lambdas = prepare.getElements(new TypeFilter<CtLambda<?>>(CtLambda.class));
 		assertEquals(1, lambdas.size());
 
 		assertEquals(1, lambdas.get(0).getTypeCasts().size());
 		assertEquals("java.lang.Runnable", lambdas.get(0).getTypeCasts().get(0).toString());
+		assertEquals(aPozole.getFactory().Type().createReference(Runnable.class), lambdas.get(0).getTypeCasts().get(0));
 
 		canBeBuilt(target, 8, true);
 	}
diff --git a/src/test/java/spoon/test/type/testclasses/Pozole.java b/src/test/java/spoon/test/type/testclasses/Pozole.java
index d53d0d876..ae90da7f2 100644
--- a/src/test/java/spoon/test/type/testclasses/Pozole.java
+++ b/src/test/java/spoon/test/type/testclasses/Pozole.java
@@ -52,6 +52,14 @@ public class Pozole<A extends Annotation> {
 	}
 
 	public void prepare() {
+		class Test<T extends Runnable & Serializable> {
+		}
 		final Runnable runnable = (Runnable & Serializable) () -> System.err.println("");
 	}
+
+	public void finish() {
+		class Test<T extends Runnable> {
+		}
+		final Runnable runnable = (Runnable) () -> System.err.println("");
+	}
 }
