diff --git a/src/main/java/spoon/reflect/reference/CtExecutableReference.java b/src/main/java/spoon/reflect/reference/CtExecutableReference.java
index acd0f5460..22fbee17f 100644
--- a/src/main/java/spoon/reflect/reference/CtExecutableReference.java
+++ b/src/main/java/spoon/reflect/reference/CtExecutableReference.java
@@ -17,12 +17,12 @@
 
 package spoon.reflect.reference;
 
+import spoon.reflect.declaration.CtExecutable;
+
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Method;
 import java.util.List;
 
-import spoon.reflect.declaration.CtExecutable;
-
 /**
  * This interface defines a reference to a
  * {@link spoon.reflect.declaration.CtExecutable}. It can be a
@@ -125,4 +125,9 @@ public interface CtExecutableReference<T> extends CtReference, CtGenericElementR
 	 * Tells if the referenced executable is final.
 	 */
 	boolean isFinal();
+
+	/**
+	 * Replaces an executable reference by another one.
+	 */
+	void replace(CtExecutableReference<?> reference);
 }
diff --git a/src/main/java/spoon/reflect/reference/CtPackageReference.java b/src/main/java/spoon/reflect/reference/CtPackageReference.java
index 2c8046ee9..63e7f20c6 100644
--- a/src/main/java/spoon/reflect/reference/CtPackageReference.java
+++ b/src/main/java/spoon/reflect/reference/CtPackageReference.java
@@ -33,4 +33,9 @@ public interface CtPackageReference extends CtReference {
 	 * Gets the package element when available in the class path.
 	 */
 	Package getActualPackage();
+
+	/**
+	 * Replace a package reference by another one.
+	 */
+	void replace(CtPackageReference packageReference);
 }
diff --git a/src/main/java/spoon/reflect/reference/CtReference.java b/src/main/java/spoon/reflect/reference/CtReference.java
index fb529bc9c..d9e62f6b9 100644
--- a/src/main/java/spoon/reflect/reference/CtReference.java
+++ b/src/main/java/spoon/reflect/reference/CtReference.java
@@ -19,6 +19,7 @@ package spoon.reflect.reference;
 
 import spoon.processing.FactoryAccessor;
 import spoon.reflect.declaration.CtElement;
+import spoon.reflect.declaration.ParentNotInitializedException;
 import spoon.reflect.visitor.CtVisitable;
 import spoon.reflect.visitor.Root;
 
@@ -44,6 +45,22 @@ public interface CtReference extends FactoryAccessor, CtVisitable {
 	 */
 	<T extends CtReference> T setSimpleName(String simpleName);
 
+	/**
+	 * Gets the parent of current reference.
+	 *
+	 * @throws ParentNotInitializedException
+	 * 		when the parent of this element is not initialized
+	 */
+	Object getParent() throws ParentNotInitializedException;
+
+	/**
+	 * Manually sets the parent element of the current element.
+	 *
+	 * @param parent
+	 * 		parent reference.
+	 */
+	<E extends CtReference> E setParent(Object parent);
+
 	/**
 	 * Tries to get the declaration that corresponds to the referenced element.
 	 *
diff --git a/src/main/java/spoon/reflect/reference/CtTypeReference.java b/src/main/java/spoon/reflect/reference/CtTypeReference.java
index e81a9e4f1..ac4063fbb 100644
--- a/src/main/java/spoon/reflect/reference/CtTypeReference.java
+++ b/src/main/java/spoon/reflect/reference/CtTypeReference.java
@@ -91,4 +91,9 @@ public interface CtTypeReference<T>
 	 * Sets the reference to the declaring package.
 	 */
 	<C extends CtTypeReference<T>> C setPackage(CtPackageReference pack);
+
+	/**
+	 * Replaces a type reference by another one.
+	 */
+	void replace(CtTypeReference<?> reference);
 }
diff --git a/src/main/java/spoon/reflect/reference/CtVariableReference.java b/src/main/java/spoon/reflect/reference/CtVariableReference.java
index 2d8cac1e0..c4bea583d 100644
--- a/src/main/java/spoon/reflect/reference/CtVariableReference.java
+++ b/src/main/java/spoon/reflect/reference/CtVariableReference.java
@@ -47,4 +47,9 @@ public interface CtVariableReference<T> extends CtReference {
 	 * Gets modifiers of the reference.
 	 */
 	Set<ModifierKind> getModifiers();
+
+	/**
+	 * Replace a variable reference by another one.
+	 */
+	void replace(CtVariableReference<?> reference);
 }
diff --git a/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java b/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
index ef66bc8a8..9a6748f63 100644
--- a/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
+++ b/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
@@ -600,6 +600,8 @@ public class JDTTreeBuilder extends ASTVisitor {
 						ref = factory.Core().createTypeReference();
 						ref.setSimpleName(name);
 						basestypes.put(name, ref);
+					} else {
+						ref = factory.Core().clone(ref);
 					}
 				}
 			} else if (binding instanceof WildcardBinding) {
diff --git a/src/main/java/spoon/support/reflect/code/CtAssignmentImpl.java b/src/main/java/spoon/support/reflect/code/CtAssignmentImpl.java
index cdff3bf58..81ee37957 100644
--- a/src/main/java/spoon/support/reflect/code/CtAssignmentImpl.java
+++ b/src/main/java/spoon/support/reflect/code/CtAssignmentImpl.java
@@ -17,9 +17,6 @@
 
 package spoon.support.reflect.code;
 
-import java.util.ArrayList;
-import java.util.List;
-
 import spoon.reflect.code.CtAssignment;
 import spoon.reflect.code.CtCodeElement;
 import spoon.reflect.code.CtExpression;
@@ -31,6 +28,9 @@ import spoon.reflect.reference.CtTypeReference;
 import spoon.reflect.visitor.CtVisitor;
 import spoon.support.reflect.declaration.CtElementImpl;
 
+import java.util.ArrayList;
+import java.util.List;
+
 import static spoon.reflect.ModelElementContainerDefaultCapacities.CASTS_CONTAINER_DEFAULT_CAPACITY;
 
 public class CtAssignmentImpl<T, A extends T> extends CtStatementImpl implements CtAssignment<T, A> {
@@ -85,13 +85,22 @@ public class CtAssignmentImpl<T, A extends T> extends CtStatementImpl implements
 
 	@Override
 	public <C extends CtTypedElement> C setType(CtTypeReference<T> type) {
+		if (type != null) {
+			type.setParent(this);
+		}
 		this.type = type;
 		return (C) this;
 	}
 
 	@Override
 	public <C extends CtExpression<T>> C setTypeCasts(List<CtTypeReference<?>> casts) {
-		this.typeCasts = casts;
+		if (this.typeCasts == CtElementImpl.<CtTypeReference<?>>emptyList()) {
+			this.typeCasts = new ArrayList<CtTypeReference<?>>(CASTS_CONTAINER_DEFAULT_CAPACITY);
+		}
+		this.typeCasts.clear();
+		for (CtTypeReference<?> cast : casts) {
+			addTypeCast(cast);
+		}
 		return (C) this;
 	}
 
@@ -100,6 +109,7 @@ public class CtAssignmentImpl<T, A extends T> extends CtStatementImpl implements
 		if (typeCasts == CtElementImpl.<CtTypeReference<?>>emptyList()) {
 			typeCasts = new ArrayList<CtTypeReference<?>>(CASTS_CONTAINER_DEFAULT_CAPACITY);
 		}
+		type.setParent(this);
 		typeCasts.add(type);
 		return (C) this;
 	}
diff --git a/src/main/java/spoon/support/reflect/code/CtCatchVariableImpl.java b/src/main/java/spoon/support/reflect/code/CtCatchVariableImpl.java
index 8ca9055ea..95c1be256 100644
--- a/src/main/java/spoon/support/reflect/code/CtCatchVariableImpl.java
+++ b/src/main/java/spoon/support/reflect/code/CtCatchVariableImpl.java
@@ -70,6 +70,9 @@ public class CtCatchVariableImpl<T> extends CtCodeElementImpl implements CtCatch
 
 	@Override
 	public <C extends CtTypedElement> C setType(CtTypeReference<T> type) {
+		if (type != null) {
+			type.setParent(this);
+		}
 		this.type = type;
 		return (C) this;
 	}
@@ -80,6 +83,7 @@ public class CtCatchVariableImpl<T> extends CtCodeElementImpl implements CtCatch
 			types = new ArrayList<CtTypeReference<?>>(
 					CATCH_VARIABLE_MULTI_TYPES_CONTAINER_DEFAULT_CAPACITY);
 		}
+		ref.setParent(this);
 		types.add(ref);
 		return (T) this;
 	}
diff --git a/src/main/java/spoon/support/reflect/code/CtConstructorCallImpl.java b/src/main/java/spoon/support/reflect/code/CtConstructorCallImpl.java
index 3030f6e9d..8bf85a780 100644
--- a/src/main/java/spoon/support/reflect/code/CtConstructorCallImpl.java
+++ b/src/main/java/spoon/support/reflect/code/CtConstructorCallImpl.java
@@ -84,6 +84,9 @@ public class CtConstructorCallImpl<T> extends CtTargetedExpressionImpl<T, CtExpr
 
 	@Override
 	public <C extends CtAbstractInvocation<T>> C setArguments(List<CtExpression<?>> arguments) {
+		if (this.arguments == CtElementImpl.<CtExpression<?>>emptyList()) {
+			this.arguments = new ArrayList<CtExpression<?>>(PARAMETERS_CONTAINER_DEFAULT_CAPACITY);
+		}
 		this.arguments.clear();
 		for (CtExpression<?> expr : arguments) {
 			addArgument(expr);
@@ -110,6 +113,9 @@ public class CtConstructorCallImpl<T> extends CtTargetedExpressionImpl<T, CtExpr
 
 	@Override
 	public <C extends CtAbstractInvocation<T>> C setExecutable(CtExecutableReference<T> executable) {
+		if (executable != null) {
+			executable.setParent(this);
+		}
 		this.executable = executable;
 		return (C) this;
 	}
@@ -131,9 +137,15 @@ public class CtConstructorCallImpl<T> extends CtTargetedExpressionImpl<T, CtExpr
 	}
 
 	@Override
-	public <T extends CtGenericElementReference> T setActualTypeArguments(
-			List<CtTypeReference<?>> actualTypeArguments) {
-		this.actualTypeArguments = actualTypeArguments;
+	public <T extends CtGenericElementReference> T setActualTypeArguments(List<CtTypeReference<?>> actualTypeArguments) {
+		if (this.actualTypeArguments == CtElementImpl.<CtTypeReference<?>>emptyList()) {
+			this.actualTypeArguments = new ArrayList<CtTypeReference<?>>(
+					CONSTRUCTOR_CALL_TYPE_PARAMETERS_CONTAINER_DEFAULT_CAPACITY);
+		}
+		this.actualTypeArguments.clear();
+		for (CtTypeReference<?> actualTypeArgument : actualTypeArguments) {
+			addActualTypeArgument(actualTypeArgument);
+		}
 		return (T) this;
 	}
 
@@ -144,6 +156,7 @@ public class CtConstructorCallImpl<T> extends CtTargetedExpressionImpl<T, CtExpr
 			actualTypeArguments = new ArrayList<CtTypeReference<?>>(
 					CONSTRUCTOR_CALL_TYPE_PARAMETERS_CONTAINER_DEFAULT_CAPACITY);
 		}
+		actualTypeArgument.setParent(this);
 		actualTypeArguments.add(actualTypeArgument);
 		return (T) this;
 	}
diff --git a/src/main/java/spoon/support/reflect/code/CtExecutableReferenceExpressionImpl.java b/src/main/java/spoon/support/reflect/code/CtExecutableReferenceExpressionImpl.java
index 6028b2e0a..b75499986 100644
--- a/src/main/java/spoon/support/reflect/code/CtExecutableReferenceExpressionImpl.java
+++ b/src/main/java/spoon/support/reflect/code/CtExecutableReferenceExpressionImpl.java
@@ -21,6 +21,9 @@ public class CtExecutableReferenceExpressionImpl<T, E extends CtExpression<?>>
 
 	@Override
 	public <C extends CtExecutableReferenceExpression<T, E>> C setExecutable(CtExecutableReference<T> executable) {
+		if (executable != null) {
+			executable.setParent(this);
+		}
 		this.executable = executable;
 		return (C) this;
 	}
diff --git a/src/main/java/spoon/support/reflect/code/CtExpressionImpl.java b/src/main/java/spoon/support/reflect/code/CtExpressionImpl.java
index 4b49eef57..1a50f5aca 100644
--- a/src/main/java/spoon/support/reflect/code/CtExpressionImpl.java
+++ b/src/main/java/spoon/support/reflect/code/CtExpressionImpl.java
@@ -47,13 +47,23 @@ public abstract class CtExpressionImpl<T> extends CtCodeElementImpl implements
 
 	@Override
 	public <C extends CtTypedElement> C setType(CtTypeReference<T> type) {
+		if (type != null) {
+			type.setParent(this);
+		}
 		this.type = type;
 		return (C) this;
 	}
 
 	@Override
 	public <C extends CtExpression<T>> C setTypeCasts(List<CtTypeReference<?>> casts) {
-		this.typeCasts = casts;
+		if (this.typeCasts == CtElementImpl.<CtTypeReference<?>>emptyList()) {
+			this.typeCasts = new ArrayList<CtTypeReference<?>>(
+					CASTS_CONTAINER_DEFAULT_CAPACITY);
+		}
+		this.typeCasts.clear();
+		for (CtTypeReference<?> cast : casts) {
+			addTypeCast(cast);
+		}
 		return (C) this;
 	}
 
@@ -63,6 +73,7 @@ public abstract class CtExpressionImpl<T> extends CtCodeElementImpl implements
 			typeCasts = new ArrayList<CtTypeReference<?>>(
 					CASTS_CONTAINER_DEFAULT_CAPACITY);
 		}
+		type.setParent(this);
 		typeCasts.add(type);
 		return (C) this;
 	}
diff --git a/src/main/java/spoon/support/reflect/code/CtInvocationImpl.java b/src/main/java/spoon/support/reflect/code/CtInvocationImpl.java
index 0b068e888..c16461843 100644
--- a/src/main/java/spoon/support/reflect/code/CtInvocationImpl.java
+++ b/src/main/java/spoon/support/reflect/code/CtInvocationImpl.java
@@ -102,6 +102,9 @@ public class CtInvocationImpl<T> extends CtTargetedExpressionImpl<T, CtExpressio
 
 	@Override
 	public <C extends CtAbstractInvocation<T>> C setArguments(List<CtExpression<?>> arguments) {
+		if (this.arguments == CtElementImpl.<CtExpression<?>>emptyList()) {
+			this.arguments = new ArrayList<CtExpression<?>>(PARAMETERS_CONTAINER_DEFAULT_CAPACITY);
+		}
 		this.arguments.clear();
 		for (CtExpression<?> expr : arguments) {
 			addArgument(expr);
@@ -111,6 +114,9 @@ public class CtInvocationImpl<T> extends CtTargetedExpressionImpl<T, CtExpressio
 
 	@Override
 	public <C extends CtAbstractInvocation<T>> C setExecutable(CtExecutableReference<T> executable) {
+		if (executable != null) {
+			executable.setParent(this);
+		}
 		this.executable = executable;
 		return (C) this;
 	}
diff --git a/src/main/java/spoon/support/reflect/code/CtLambdaImpl.java b/src/main/java/spoon/support/reflect/code/CtLambdaImpl.java
index 93c4659d2..36e1e303c 100644
--- a/src/main/java/spoon/support/reflect/code/CtLambdaImpl.java
+++ b/src/main/java/spoon/support/reflect/code/CtLambdaImpl.java
@@ -54,7 +54,9 @@ public class CtLambdaImpl<T> extends CtExpressionImpl<T> implements CtLambda<T>
 		if (expression != null) {
 			throw new SpoonException("A lambda can't have two bodys.");
 		}
-		body.setParent(this);
+		if (body != null) {
+			body.setParent(this);
+		}
 		this.body = body;
 		return (C) this;
 	}
@@ -66,6 +68,10 @@ public class CtLambdaImpl<T> extends CtExpressionImpl<T> implements CtLambda<T>
 
 	@Override
 	public <C extends CtExecutable<T>> C setParameters(List<CtParameter<?>> params) {
+		if (this.parameters == CtElementImpl.<CtParameter<?>>emptyList()) {
+			this.parameters = new ArrayList<CtParameter<?>>(
+					PARAMETERS_CONTAINER_DEFAULT_CAPACITY);
+		}
 		this.parameters.clear();
 		for (CtParameter<?> p : params) {
 			addParameter(p);
@@ -97,7 +103,13 @@ public class CtLambdaImpl<T> extends CtExpressionImpl<T> implements CtLambda<T>
 
 	@Override
 	public <C extends CtExecutable<T>> C setThrownTypes(Set<CtTypeReference<? extends Throwable>> thrownTypes) {
-		this.thrownTypes = thrownTypes;
+		if (this.thrownTypes == CtElementImpl.<CtTypeReference<? extends Throwable>>emptySet()) {
+			this.thrownTypes = new TreeSet<CtTypeReference<? extends Throwable>>();
+		}
+		this.thrownTypes.clear();
+		for (CtTypeReference<? extends Throwable> thrownType : thrownTypes) {
+			addThrownType(thrownType);
+		}
 		return (C) this;
 	}
 
@@ -106,6 +118,7 @@ public class CtLambdaImpl<T> extends CtExpressionImpl<T> implements CtLambda<T>
 		if (thrownTypes == CtElementImpl.<CtTypeReference<? extends Throwable>>emptySet()) {
 			thrownTypes = new TreeSet<CtTypeReference<? extends Throwable>>();
 		}
+		throwType.setParent(this);
 		thrownTypes.add(throwType);
 		return (C) this;
 	}
@@ -130,7 +143,9 @@ public class CtLambdaImpl<T> extends CtExpressionImpl<T> implements CtLambda<T>
 		if (body != null) {
 			throw new SpoonException("A lambda can't have two bodys.");
 		}
-		expression.setParent(this);
+		if (expression != null) {
+			expression.setParent(this);
+		}
 		this.expression = expression;
 		return (C) this;
 	}
diff --git a/src/main/java/spoon/support/reflect/code/CtLocalVariableImpl.java b/src/main/java/spoon/support/reflect/code/CtLocalVariableImpl.java
index 5f3c07d5b..6cfec38ab 100644
--- a/src/main/java/spoon/support/reflect/code/CtLocalVariableImpl.java
+++ b/src/main/java/spoon/support/reflect/code/CtLocalVariableImpl.java
@@ -17,9 +17,6 @@
 
 package spoon.support.reflect.code;
 
-import java.util.EnumSet;
-import java.util.Set;
-
 import spoon.reflect.code.CtExpression;
 import spoon.reflect.code.CtLocalVariable;
 import spoon.reflect.code.CtRHSReceiver;
@@ -33,6 +30,9 @@ import spoon.reflect.reference.CtTypeReference;
 import spoon.reflect.visitor.CtVisitor;
 import spoon.support.reflect.declaration.CtElementImpl;
 
+import java.util.EnumSet;
+import java.util.Set;
+
 public class CtLocalVariableImpl<T> extends CtStatementImpl implements CtLocalVariable<T> {
 	private static final long serialVersionUID = 1L;
 
@@ -86,6 +86,9 @@ public class CtLocalVariableImpl<T> extends CtStatementImpl implements CtLocalVa
 
 	@Override
 	public <C extends CtTypedElement> C setType(CtTypeReference<T> type) {
+		if (type != null) {
+			type.setParent(this);
+		}
 		this.type = type;
 		return (C) this;
 	}
diff --git a/src/main/java/spoon/support/reflect/code/CtThrowImpl.java b/src/main/java/spoon/support/reflect/code/CtThrowImpl.java
index 106d91b79..ee5584e2f 100644
--- a/src/main/java/spoon/support/reflect/code/CtThrowImpl.java
+++ b/src/main/java/spoon/support/reflect/code/CtThrowImpl.java
@@ -40,8 +40,10 @@ public class CtThrowImpl extends CtStatementImpl implements CtThrow {
 
 	@Override
 	public <T extends CtThrow> T setThrownExpression(CtExpression<? extends Throwable> expression) {
+		if (expression != null) {
+			expression.setParent(this);
+		}
 		this.throwExpression = expression;
-		throwExpression.setParent(this);
 		return (T) this;
 	}
 
diff --git a/src/main/java/spoon/support/reflect/code/CtVariableAccessImpl.java b/src/main/java/spoon/support/reflect/code/CtVariableAccessImpl.java
index e50330f63..192c490a7 100644
--- a/src/main/java/spoon/support/reflect/code/CtVariableAccessImpl.java
+++ b/src/main/java/spoon/support/reflect/code/CtVariableAccessImpl.java
@@ -21,6 +21,9 @@ public abstract class CtVariableAccessImpl<T> extends CtExpressionImpl<T> implem
 
 	@Override
 	public <C extends CtVariableAccess<T>> C setVariable(CtVariableReference<T> variable) {
+		if (variable != null) {
+			variable.setParent(this);
+		}
 		this.variable = variable;
 		return (C) this;
 	}
diff --git a/src/main/java/spoon/support/reflect/declaration/CtAnnotationImpl.java b/src/main/java/spoon/support/reflect/declaration/CtAnnotationImpl.java
index 066a928cb..3d1102f70 100644
--- a/src/main/java/spoon/support/reflect/declaration/CtAnnotationImpl.java
+++ b/src/main/java/spoon/support/reflect/declaration/CtAnnotationImpl.java
@@ -17,19 +17,6 @@
 
 package spoon.support.reflect.declaration;
 
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Array;
-import java.lang.reflect.Field;
-import java.lang.reflect.InvocationHandler;
-import java.lang.reflect.Method;
-import java.lang.reflect.Proxy;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-import java.util.Map;
-import java.util.Map.Entry;
-import java.util.TreeMap;
-
 import spoon.Launcher;
 import spoon.reflect.code.CtCodeElement;
 import spoon.reflect.code.CtExpression;
@@ -49,10 +36,24 @@ import spoon.reflect.declaration.CtParameter;
 import spoon.reflect.declaration.CtType;
 import spoon.reflect.eval.PartialEvaluator;
 import spoon.reflect.reference.CtFieldReference;
+import spoon.reflect.reference.CtReference;
 import spoon.reflect.reference.CtTypeReference;
 import spoon.reflect.visitor.CtVisitor;
 import spoon.support.reflect.code.CtExpressionImpl;
 
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Array;
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationHandler;
+import java.lang.reflect.Method;
+import java.lang.reflect.Proxy;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.TreeMap;
+
 /**
  * The implementation for {@link spoon.reflect.declaration.CtAnnotation}.
  *
@@ -130,6 +131,8 @@ public class CtAnnotationImpl<A extends Annotation> extends CtExpressionImpl<A>
 			elementValues.put(elementName, value);
 			if (value instanceof CtElement) {
 				((CtElement) value).setParent(this);
+			} else if (value instanceof CtReference) {
+				((CtReference) value).setParent(this);
 			}
 		} else {
 			Object o = elementValues.get(elementName);
@@ -312,6 +315,9 @@ public class CtAnnotationImpl<A extends Annotation> extends CtExpressionImpl<A>
 	@Override
 	@SuppressWarnings("unchecked")
 	public <T extends CtAnnotation<A>> T setAnnotationType(CtTypeReference<? extends Annotation> annotationType) {
+		if (annotationType != null) {
+			annotationType.setParent(this);
+		}
 		this.annotationType = (CtTypeReference<A>) annotationType;
 		return (T) this;
 	}
diff --git a/src/main/java/spoon/support/reflect/declaration/CtClassImpl.java b/src/main/java/spoon/support/reflect/declaration/CtClassImpl.java
index 35027877f..a0d0be66f 100644
--- a/src/main/java/spoon/support/reflect/declaration/CtClassImpl.java
+++ b/src/main/java/spoon/support/reflect/declaration/CtClassImpl.java
@@ -17,15 +17,6 @@
 
 package spoon.support.reflect.declaration;
 
-import static spoon.reflect.ModelElementContainerDefaultCapacities.ANONYMOUS_EXECUTABLES_CONTAINER_DEFAULT_CAPACITY;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.List;
-import java.util.Set;
-import java.util.TreeSet;
-
 import spoon.reflect.code.CtCodeElement;
 import spoon.reflect.code.CtStatement;
 import spoon.reflect.code.CtStatementList;
@@ -40,6 +31,15 @@ import spoon.reflect.visitor.CtVisitor;
 import spoon.support.reflect.code.CtStatementImpl;
 import spoon.support.reflect.eval.VisitorPartialEvaluator;
 
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+import java.util.Set;
+import java.util.TreeSet;
+
+import static spoon.reflect.ModelElementContainerDefaultCapacities.ANONYMOUS_EXECUTABLES_CONTAINER_DEFAULT_CAPACITY;
+
 /**
  * The implementation for {@link spoon.reflect.declaration.CtClass}.
  *
@@ -109,6 +109,10 @@ public class CtClassImpl<T extends Object> extends CtTypeImpl<T> implements CtCl
 
 	@Override
 	public <C extends CtClass<T>> C setAnonymousExecutables(List<CtAnonymousExecutable> anonymousExecutables) {
+		if (this.anonymousExecutables == CtElementImpl.<CtAnonymousExecutable>emptyList()) {
+			this.anonymousExecutables = new ArrayList<CtAnonymousExecutable>(
+					ANONYMOUS_EXECUTABLES_CONTAINER_DEFAULT_CAPACITY);
+		}
 		this.anonymousExecutables.clear();
 		for (CtAnonymousExecutable exec : anonymousExecutables) {
 			addAnonymousExecutable(exec);
@@ -118,7 +122,13 @@ public class CtClassImpl<T extends Object> extends CtTypeImpl<T> implements CtCl
 
 	@Override
 	public <C extends CtClass<T>> C setConstructors(Set<CtConstructor<T>> constructors) {
-		this.constructors = constructors;
+		if (this.constructors == CtElementImpl.<CtConstructor<T>>emptySet()) {
+			this.constructors = new TreeSet<CtConstructor<T>>();
+		}
+		this.constructors.clear();
+		for (CtConstructor<T> constructor : constructors) {
+			addConstructor(constructor);
+		}
 		return (C) this;
 	}
 
@@ -150,6 +160,9 @@ public class CtClassImpl<T extends Object> extends CtTypeImpl<T> implements CtCl
 
 	@Override
 	public <C extends CtClass<T>> C setSuperclass(CtTypeReference<?> superClass) {
+		if (superClass != null) {
+			superClass.setParent(this);
+		}
 		this.superClass = superClass;
 		return (C) this;
 	}
diff --git a/src/main/java/spoon/support/reflect/declaration/CtConstructorImpl.java b/src/main/java/spoon/support/reflect/declaration/CtConstructorImpl.java
index c00396c99..95bcc4fe1 100644
--- a/src/main/java/spoon/support/reflect/declaration/CtConstructorImpl.java
+++ b/src/main/java/spoon/support/reflect/declaration/CtConstructorImpl.java
@@ -90,13 +90,21 @@ public class CtConstructorImpl<T> extends CtExecutableImpl<T> implements CtConst
 			formalTypeParameters = new ArrayList<CtTypeReference<?>>(
 					CONSTRUCTOR_TYPE_PARAMETERS_CONTAINER_DEFAULT_CAPACITY);
 		}
+		formalTypeParameter.setParent(this);
 		formalTypeParameters.add(formalTypeParameter);
 		return (T) this;
 	}
 
 	@Override
 	public <T extends CtGenericElement> T setFormalTypeParameters(List<CtTypeReference<?>> formalTypeParameters) {
-		this.formalTypeParameters = formalTypeParameters;
+		if (this.formalTypeParameters == CtElementImpl.<CtTypeReference<?>>emptyList()) {
+			this.formalTypeParameters = new ArrayList<CtTypeReference<?>>(
+					CONSTRUCTOR_TYPE_PARAMETERS_CONTAINER_DEFAULT_CAPACITY);
+		}
+		this.formalTypeParameters.clear();
+		for (CtTypeReference<?> formalTypeParameter : formalTypeParameters) {
+			addFormalTypeParameter(formalTypeParameter);
+		}
 		return (T) this;
 	}
 
diff --git a/src/main/java/spoon/support/reflect/declaration/CtExecutableImpl.java b/src/main/java/spoon/support/reflect/declaration/CtExecutableImpl.java
index 764960ae6..d109be0c9 100644
--- a/src/main/java/spoon/support/reflect/declaration/CtExecutableImpl.java
+++ b/src/main/java/spoon/support/reflect/declaration/CtExecutableImpl.java
@@ -56,7 +56,9 @@ public abstract class CtExecutableImpl<R> extends CtNamedElementImpl implements
 
 	@Override
 	public <B extends R, T extends CtExecutable<R>> T setBody(CtBlock<B> body) {
-		body.setParent(this);
+		if (body != null) {
+			body.setParent(this);
+		}
 		this.body = body;
 		return (T) this;
 	}
@@ -68,6 +70,10 @@ public abstract class CtExecutableImpl<R> extends CtNamedElementImpl implements
 
 	@Override
 	public <T extends CtExecutable<R>> T setParameters(List<CtParameter<?>> parameters) {
+		if (this.parameters == CtElementImpl.<CtParameter<?>>emptyList()) {
+			this.parameters = new ArrayList<CtParameter<?>>(
+					PARAMETERS_CONTAINER_DEFAULT_CAPACITY);
+		}
 		this.parameters.clear();
 		for (CtParameter<?> p : parameters) {
 			addParameter(p);
@@ -98,7 +104,13 @@ public abstract class CtExecutableImpl<R> extends CtNamedElementImpl implements
 
 	@Override
 	public <T extends CtExecutable<R>> T setThrownTypes(Set<CtTypeReference<? extends Throwable>> thrownTypes) {
-		this.thrownTypes = thrownTypes;
+		if (this.thrownTypes == CtElementImpl.<CtTypeReference<? extends Throwable>>emptySet()) {
+			this.thrownTypes = new TreeSet<CtTypeReference<? extends Throwable>>();
+		}
+		this.thrownTypes.clear();
+		for (CtTypeReference<? extends Throwable> thrownType : thrownTypes) {
+			addThrownType(thrownType);
+		}
 		return (T) this;
 	}
 
@@ -107,6 +119,7 @@ public abstract class CtExecutableImpl<R> extends CtNamedElementImpl implements
 		if (thrownTypes == CtElementImpl.<CtTypeReference<? extends Throwable>>emptySet()) {
 			thrownTypes = new TreeSet<CtTypeReference<? extends Throwable>>();
 		}
+		throwType.setParent(this);
 		thrownTypes.add(throwType);
 		return (T) this;
 	}
diff --git a/src/main/java/spoon/support/reflect/declaration/CtFieldImpl.java b/src/main/java/spoon/support/reflect/declaration/CtFieldImpl.java
index 8d78d5ee8..b897e8daf 100644
--- a/src/main/java/spoon/support/reflect/declaration/CtFieldImpl.java
+++ b/src/main/java/spoon/support/reflect/declaration/CtFieldImpl.java
@@ -17,9 +17,6 @@
 
 package spoon.support.reflect.declaration;
 
-import java.util.EnumSet;
-import java.util.Set;
-
 import spoon.reflect.code.CtExpression;
 import spoon.reflect.code.CtRHSReceiver;
 import spoon.reflect.declaration.CtElement;
@@ -33,6 +30,9 @@ import spoon.reflect.reference.CtFieldReference;
 import spoon.reflect.reference.CtTypeReference;
 import spoon.reflect.visitor.CtVisitor;
 
+import java.util.EnumSet;
+import java.util.Set;
+
 /**
  * The implementation for {@link spoon.reflect.declaration.CtField}.
  *
@@ -87,6 +87,9 @@ public class CtFieldImpl<T> extends CtNamedElementImpl implements CtField<T> {
 
 	@Override
 	public <C extends CtTypedElement> C setType(CtTypeReference<T> type) {
+		if (type != null) {
+			type.setParent(this);
+		}
 		this.type = type;
 		return (C) this;
 	}
diff --git a/src/main/java/spoon/support/reflect/declaration/CtMethodImpl.java b/src/main/java/spoon/support/reflect/declaration/CtMethodImpl.java
index b225c9f2d..7798f2101 100644
--- a/src/main/java/spoon/support/reflect/declaration/CtMethodImpl.java
+++ b/src/main/java/spoon/support/reflect/declaration/CtMethodImpl.java
@@ -66,6 +66,9 @@ public class CtMethodImpl<T> extends CtExecutableImpl<T> implements CtMethod<T>
 
 	@Override
 	public <C extends CtTypedElement> C setType(CtTypeReference<T> type) {
+		if (type != null) {
+			type.setParent(this);
+		}
 		this.returnType = type;
 		return (C) this;
 	}
@@ -100,13 +103,21 @@ public class CtMethodImpl<T> extends CtExecutableImpl<T> implements CtMethod<T>
 			formalTypeParameters = new ArrayList<CtTypeReference<?>>(
 					METHOD_TYPE_PARAMETERS_CONTAINER_DEFAULT_CAPACITY);
 		}
+		formalTypeParameter.setParent(this);
 		formalTypeParameters.add(formalTypeParameter);
 		return (T) this;
 	}
 
 	@Override
 	public <T extends CtGenericElement> T setFormalTypeParameters(List<CtTypeReference<?>> formalTypeParameters) {
-		this.formalTypeParameters = formalTypeParameters;
+		if (this.formalTypeParameters == CtElementImpl.<CtTypeReference<?>>emptyList()) {
+			this.formalTypeParameters = new ArrayList<CtTypeReference<?>>(
+					METHOD_TYPE_PARAMETERS_CONTAINER_DEFAULT_CAPACITY);
+		}
+		this.formalTypeParameters.clear();
+		for (CtTypeReference<?> formalTypeParameter : formalTypeParameters) {
+			addFormalTypeParameter(formalTypeParameter);
+		}
 		return (T) this;
 	}
 
diff --git a/src/main/java/spoon/support/reflect/declaration/CtParameterImpl.java b/src/main/java/spoon/support/reflect/declaration/CtParameterImpl.java
index 5a0125d41..ed9646865 100644
--- a/src/main/java/spoon/support/reflect/declaration/CtParameterImpl.java
+++ b/src/main/java/spoon/support/reflect/declaration/CtParameterImpl.java
@@ -17,9 +17,6 @@
 
 package spoon.support.reflect.declaration;
 
-import java.util.EnumSet;
-import java.util.Set;
-
 import spoon.reflect.code.CtExpression;
 import spoon.reflect.declaration.CtExecutable;
 import spoon.reflect.declaration.CtModifiable;
@@ -31,6 +28,9 @@ import spoon.reflect.reference.CtParameterReference;
 import spoon.reflect.reference.CtTypeReference;
 import spoon.reflect.visitor.CtVisitor;
 
+import java.util.EnumSet;
+import java.util.Set;
+
 /**
  * The implementation for {@link spoon.reflect.declaration.CtParameter}.
  *
@@ -76,6 +76,9 @@ public class CtParameterImpl<T> extends CtNamedElementImpl implements CtParamete
 
 	@Override
 	public <C extends CtTypedElement> C setType(CtTypeReference<T> type) {
+		if (type != null) {
+			type.setParent(this);
+		}
 		this.type = type;
 		return (C) this;
 	}
diff --git a/src/main/java/spoon/support/reflect/declaration/CtTypeImpl.java b/src/main/java/spoon/support/reflect/declaration/CtTypeImpl.java
index aedea2ef3..0ee5f0919 100644
--- a/src/main/java/spoon/support/reflect/declaration/CtTypeImpl.java
+++ b/src/main/java/spoon/support/reflect/declaration/CtTypeImpl.java
@@ -419,6 +419,7 @@ public abstract class CtTypeImpl<T> extends CtNamedElementImpl implements CtType
 		if (interfaces == CtElementImpl.<CtTypeReference<?>>emptySet()) {
 			interfaces = new TreeSet<CtTypeReference<?>>();
 		}
+		interfac.setParent(this);
 		interfaces.add(interfac);
 		return (C) this;
 	}
@@ -445,6 +446,7 @@ public abstract class CtTypeImpl<T> extends CtNamedElementImpl implements CtType
 		if (formalTypeParameters == CtElementImpl.<CtTypeReference<?>>emptyList()) {
 			formalTypeParameters = new ArrayList<CtTypeReference<?>>(TYPE_TYPE_PARAMETERS_CONTAINER_DEFAULT_CAPACITY);
 		}
+		formalTypeParameter.setParent(this);
 		formalTypeParameters.add(formalTypeParameter);
 		return (C) this;
 	}
@@ -556,7 +558,13 @@ public abstract class CtTypeImpl<T> extends CtNamedElementImpl implements CtType
 
 	@Override
 	public <C extends CtGenericElement> C setFormalTypeParameters(List<CtTypeReference<?>> formalTypeParameters) {
-		this.formalTypeParameters = formalTypeParameters;
+		if (this.formalTypeParameters == CtElementImpl.<CtTypeReference<?>>emptyList()) {
+			this.formalTypeParameters = new ArrayList<CtTypeReference<?>>(TYPE_TYPE_PARAMETERS_CONTAINER_DEFAULT_CAPACITY);
+		}
+		this.formalTypeParameters.clear();
+		for (CtTypeReference<?> formalTypeParameter : formalTypeParameters) {
+			addFormalTypeParameter(formalTypeParameter);
+		}
 		return (C) this;
 	}
 
@@ -571,7 +579,13 @@ public abstract class CtTypeImpl<T> extends CtNamedElementImpl implements CtType
 
 	@Override
 	public <C extends CtType<T>> C setSuperInterfaces(Set<CtTypeReference<?>> interfaces) {
-		this.interfaces = interfaces;
+		if (this.interfaces == CtElementImpl.<CtTypeReference<?>>emptySet()) {
+			this.interfaces = new TreeSet<CtTypeReference<?>>();
+		}
+		this.interfaces.clear();
+		for (CtTypeReference<?> anInterface : interfaces) {
+			addSuperInterface(anInterface);
+		}
 		return (C) this;
 	}
 
diff --git a/src/main/java/spoon/support/reflect/declaration/CtTypeParameterImpl.java b/src/main/java/spoon/support/reflect/declaration/CtTypeParameterImpl.java
index 3ee851faf..83ffa0a0d 100644
--- a/src/main/java/spoon/support/reflect/declaration/CtTypeParameterImpl.java
+++ b/src/main/java/spoon/support/reflect/declaration/CtTypeParameterImpl.java
@@ -17,15 +17,14 @@
 
 package spoon.support.reflect.declaration;
 
-import java.util.ArrayList;
-import java.util.List;
-
 import spoon.reflect.declaration.CtTypeParameter;
 import spoon.reflect.reference.CtTypeReference;
 import spoon.reflect.visitor.CtVisitor;
 
-import static spoon.reflect.ModelElementContainerDefaultCapacities
-		.TYPE_BOUNDS_CONTAINER_DEFAULT_CAPACITY;
+import java.util.ArrayList;
+import java.util.List;
+
+import static spoon.reflect.ModelElementContainerDefaultCapacities.TYPE_BOUNDS_CONTAINER_DEFAULT_CAPACITY;
 
 /**
  * The implementation for {@link spoon.reflect.declaration.CtTypeParameter}.
@@ -51,6 +50,7 @@ public class CtTypeParameterImpl extends CtNamedElementImpl implements CtTypePar
 		if (bounds == CtElementImpl.<CtTypeReference<?>>emptyList()) {
 			bounds = new ArrayList<CtTypeReference<?>>(TYPE_BOUNDS_CONTAINER_DEFAULT_CAPACITY);
 		}
+		bound.setParent(this);
 		this.bounds.add(bound);
 		return (T) this;
 	}
@@ -67,7 +67,13 @@ public class CtTypeParameterImpl extends CtNamedElementImpl implements CtTypePar
 
 	@Override
 	public <T extends CtTypeParameter> T setBounds(List<CtTypeReference<?>> bounds) {
-		this.bounds = bounds;
+		if (this.bounds == CtElementImpl.<CtTypeReference<?>>emptyList()) {
+			this.bounds = new ArrayList<CtTypeReference<?>>(TYPE_BOUNDS_CONTAINER_DEFAULT_CAPACITY);
+		}
+		this.bounds.clear();
+		for (CtTypeReference<?> bound : bounds) {
+			addBound(bound);
+		}
 		return (T) this;
 	}
 }
diff --git a/src/main/java/spoon/support/reflect/reference/CtArrayTypeReferenceImpl.java b/src/main/java/spoon/support/reflect/reference/CtArrayTypeReferenceImpl.java
index f007ad9c1..3eb6257ad 100644
--- a/src/main/java/spoon/support/reflect/reference/CtArrayTypeReferenceImpl.java
+++ b/src/main/java/spoon/support/reflect/reference/CtArrayTypeReferenceImpl.java
@@ -17,12 +17,12 @@
 
 package spoon.support.reflect.reference;
 
-import java.lang.reflect.Array;
-
 import spoon.reflect.reference.CtArrayTypeReference;
 import spoon.reflect.reference.CtTypeReference;
 import spoon.reflect.visitor.CtVisitor;
 
+import java.lang.reflect.Array;
+
 public class CtArrayTypeReferenceImpl<T> extends CtTypeReferenceImpl<T>
 		implements CtArrayTypeReference<T> {
 	private static final long serialVersionUID = 1L;
@@ -45,6 +45,9 @@ public class CtArrayTypeReferenceImpl<T> extends CtTypeReferenceImpl<T>
 
 	@Override
 	public <C extends CtArrayTypeReference<T>> C setComponentType(CtTypeReference<?> componentType) {
+		if (componentType != null) {
+			componentType.setParent(this);
+		}
 		this.componentType = componentType;
 		return (C) this;
 	}
diff --git a/src/main/java/spoon/support/reflect/reference/CtExecutableReferenceImpl.java b/src/main/java/spoon/support/reflect/reference/CtExecutableReferenceImpl.java
index 033410abe..c93a3ed43 100644
--- a/src/main/java/spoon/support/reflect/reference/CtExecutableReferenceImpl.java
+++ b/src/main/java/spoon/support/reflect/reference/CtExecutableReferenceImpl.java
@@ -17,16 +17,6 @@
 
 package spoon.support.reflect.reference;
 
-import java.lang.reflect.AnnotatedElement;
-import java.lang.reflect.Constructor;
-import java.lang.reflect.Method;
-import java.lang.reflect.Modifier;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-import java.util.Set;
-import java.util.TreeSet;
-
 import spoon.Launcher;
 import spoon.reflect.declaration.CtClass;
 import spoon.reflect.declaration.CtConstructor;
@@ -41,6 +31,16 @@ import spoon.reflect.visitor.CtVisitor;
 import spoon.support.reflect.declaration.CtElementImpl;
 import spoon.support.util.RtHelper;
 
+import java.lang.reflect.AnnotatedElement;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Set;
+import java.util.TreeSet;
+
 import static spoon.reflect.ModelElementContainerDefaultCapacities.METHOD_TYPE_PARAMETERS_CONTAINER_DEFAULT_CAPACITY;
 
 public class CtExecutableReferenceImpl<T> extends CtReferenceImpl
@@ -179,7 +179,14 @@ public class CtExecutableReferenceImpl<T> extends CtReferenceImpl
 	public <C extends CtExecutableReference<T>> C setParameters(List<CtTypeReference<?>> parameters) {
 		if (this.parameters == CtElementImpl.<CtTypeReference<?>>emptyList()) {
 			this.parameters = new ArrayList<CtTypeReference<?>>();
-			this.parameters.addAll(parameters);
+		}
+		this.parameters.clear();
+		for (CtTypeReference<?> parameter : parameters) {
+			if (parameter == null) {
+				continue;
+			}
+			parameter.setParent(this);
+			this.parameters.add(parameter);
 		}
 		return (C) this;
 	}
@@ -218,18 +225,28 @@ public class CtExecutableReferenceImpl<T> extends CtReferenceImpl
 	@Override
 	public <C extends CtGenericElementReference> C setActualTypeArguments(
 			List<CtTypeReference<?>> actualTypeArguments) {
-		this.actualTypeArguments = actualTypeArguments;
+		if (this.actualTypeArguments == CtElementImpl.<CtTypeReference<?>>emptyList()) {
+			this.actualTypeArguments = new ArrayList<CtTypeReference<?>>();
+		}
+		this.actualTypeArguments.clear();
+		for (CtTypeReference<?> actualTypeArgument : actualTypeArguments) {
+			addActualTypeArgument(actualTypeArgument);
+		}
 		return (C) this;
 	}
 
 	@Override
 	public <C extends CtExecutableReference<T>> C setDeclaringType(CtTypeReference<?> declaringType) {
+		declaringType.setParent(this);
 		this.declaringType = declaringType;
 		return (C) this;
 	}
 
 	@Override
 	public <C extends CtExecutableReference<T>> C setType(CtTypeReference<T> type) {
+		if (type != null) {
+			type.setParent(this);
+		}
 		this.type = type;
 		return (C) this;
 	}
@@ -313,6 +330,11 @@ public class CtExecutableReferenceImpl<T> extends CtReferenceImpl
 		return m != null && Modifier.isFinal(m.getModifiers());
 	}
 
+	@Override
+	public void replace(CtExecutableReference<?> reference) {
+		super.replace(reference);
+	}
+
 	public Set<ModifierKind> getModifiers() {
 		CtExecutable<T> e = getDeclaration();
 		if (e != null) {
@@ -370,6 +392,7 @@ public class CtExecutableReferenceImpl<T> extends CtReferenceImpl
 			actualTypeArguments = new ArrayList<CtTypeReference<?>>(
 					METHOD_TYPE_PARAMETERS_CONTAINER_DEFAULT_CAPACITY);
 		}
+		actualTypeArgument.setParent(this);
 		actualTypeArguments.add(actualTypeArgument);
 		return (C) this;
 	}
diff --git a/src/main/java/spoon/support/reflect/reference/CtFieldReferenceImpl.java b/src/main/java/spoon/support/reflect/reference/CtFieldReferenceImpl.java
index b64d74772..2b8052d39 100644
--- a/src/main/java/spoon/support/reflect/reference/CtFieldReferenceImpl.java
+++ b/src/main/java/spoon/support/reflect/reference/CtFieldReferenceImpl.java
@@ -17,11 +17,6 @@
 
 package spoon.support.reflect.reference;
 
-import java.lang.reflect.AnnotatedElement;
-import java.lang.reflect.Member;
-import java.util.Set;
-import java.util.TreeSet;
-
 import spoon.Launcher;
 import spoon.reflect.declaration.CtField;
 import spoon.reflect.declaration.CtType;
@@ -32,6 +27,11 @@ import spoon.reflect.reference.CtTypeReference;
 import spoon.reflect.visitor.CtVisitor;
 import spoon.support.util.RtHelper;
 
+import java.lang.reflect.AnnotatedElement;
+import java.lang.reflect.Member;
+import java.util.Set;
+import java.util.TreeSet;
+
 public class CtFieldReferenceImpl<T> extends CtVariableReferenceImpl<T>
 		implements CtFieldReference<T> {
 	private static final long serialVersionUID = 1L;
@@ -161,6 +161,9 @@ public class CtFieldReferenceImpl<T> extends CtVariableReferenceImpl<T>
 
 	@Override
 	public <C extends CtFieldReference<T>> C setDeclaringType(CtTypeReference<?> declaringType) {
+		if (declaringType != null) {
+			declaringType.setParent(this);
+		}
 		this.declaringType = declaringType;
 		return (C) this;
 	}
diff --git a/src/main/java/spoon/support/reflect/reference/CtPackageReferenceImpl.java b/src/main/java/spoon/support/reflect/reference/CtPackageReferenceImpl.java
index 70d9ad5a8..27fd8e613 100644
--- a/src/main/java/spoon/support/reflect/reference/CtPackageReferenceImpl.java
+++ b/src/main/java/spoon/support/reflect/reference/CtPackageReferenceImpl.java
@@ -17,12 +17,12 @@
 
 package spoon.support.reflect.reference;
 
-import java.lang.reflect.AnnotatedElement;
-
 import spoon.reflect.declaration.CtPackage;
 import spoon.reflect.reference.CtPackageReference;
 import spoon.reflect.visitor.CtVisitor;
 
+import java.lang.reflect.AnnotatedElement;
+
 public class CtPackageReferenceImpl extends CtReferenceImpl
 		implements CtPackageReference {
 	private static final long serialVersionUID = 1L;
@@ -46,6 +46,11 @@ public class CtPackageReferenceImpl extends CtReferenceImpl
 		return Package.getPackage(getSimpleName());
 	}
 
+	@Override
+	public void replace(CtPackageReference packageReference) {
+		super.replace(packageReference);
+	}
+
 	@Override
 	protected AnnotatedElement getActualAnnotatedElement() {
 		return getActualPackage();
diff --git a/src/main/java/spoon/support/reflect/reference/CtParameterReferenceImpl.java b/src/main/java/spoon/support/reflect/reference/CtParameterReferenceImpl.java
index a202cde9e..2d013ed29 100644
--- a/src/main/java/spoon/support/reflect/reference/CtParameterReferenceImpl.java
+++ b/src/main/java/spoon/support/reflect/reference/CtParameterReferenceImpl.java
@@ -17,14 +17,14 @@
 
 package spoon.support.reflect.reference;
 
-import java.util.List;
-
 import spoon.reflect.declaration.CtExecutable;
 import spoon.reflect.declaration.CtParameter;
 import spoon.reflect.reference.CtExecutableReference;
 import spoon.reflect.reference.CtParameterReference;
 import spoon.reflect.visitor.CtVisitor;
 
+import java.util.List;
+
 public class CtParameterReferenceImpl<T> extends CtVariableReferenceImpl<T>
 		implements CtParameterReference<T> {
 	private static final long serialVersionUID = 1L;
@@ -64,6 +64,9 @@ public class CtParameterReferenceImpl<T> extends CtVariableReferenceImpl<T>
 
 	@Override
 	public <C extends CtParameterReference<T>> C setDeclaringExecutable(CtExecutableReference<?> executable) {
+		if (executable != null) {
+			executable.setParent(this);
+		}
 		this.executable = executable;
 		return (C) this;
 	}
diff --git a/src/main/java/spoon/support/reflect/reference/CtReferenceImpl.java b/src/main/java/spoon/support/reflect/reference/CtReferenceImpl.java
index 255ad7f51..109de9a82 100644
--- a/src/main/java/spoon/support/reflect/reference/CtReferenceImpl.java
+++ b/src/main/java/spoon/support/reflect/reference/CtReferenceImpl.java
@@ -17,21 +17,31 @@
 
 package spoon.support.reflect.reference;
 
-import java.io.Serializable;
-import java.lang.reflect.AnnotatedElement;
-
+import spoon.Launcher;
+import spoon.processing.FactoryAccessor;
+import spoon.reflect.declaration.ParentNotInitializedException;
 import spoon.reflect.factory.Factory;
 import spoon.reflect.factory.FactoryImpl;
 import spoon.reflect.reference.CtReference;
 import spoon.reflect.visitor.DefaultJavaPrettyPrinter;
+import spoon.support.reflect.declaration.CtUncomparableException;
+import spoon.support.util.RtHelper;
 import spoon.support.visitor.SignaturePrinter;
 
+import java.io.Serializable;
+import java.lang.reflect.AnnotatedElement;
+import java.lang.reflect.Field;
+import java.util.Collection;
+import java.util.List;
+
 public abstract class CtReferenceImpl implements CtReference, Serializable, Comparable<CtReference> {
 
 	private static final long serialVersionUID = 1L;
 
 	String simplename;
 
+	Object parent;
+
 	transient Factory factory;
 
 	public CtReferenceImpl() {
@@ -78,6 +88,20 @@ public abstract class CtReferenceImpl implements CtReference, Serializable, Comp
 		return (T) this;
 	}
 
+	@Override
+	public Object getParent() throws ParentNotInitializedException {
+		if (parent == null) {
+			throw new ParentNotInitializedException("parent not initialized for " + getSimpleName() + "(" + this.getClass() + ")");
+		}
+		return parent;
+	}
+
+	@Override
+	public <E extends CtReference> E setParent(Object parent) {
+		this.parent = parent;
+		return (E) this;
+	}
+
 	@Override
 	public String toString() {
 		DefaultJavaPrettyPrinter printer = new DefaultJavaPrettyPrinter(
@@ -95,4 +119,59 @@ public abstract class CtReferenceImpl implements CtReference, Serializable, Comp
 	public void setFactory(Factory factory) {
 		this.factory = factory;
 	}
+
+	protected void replace(CtReference reference) {
+		try {
+			replaceIn(this, reference, getParent());
+		} catch (CtUncomparableException e1) {
+			// do nothing
+		} catch (Exception e1) {
+			Launcher.LOGGER.error(e1.getMessage(), e1);
+		}
+	}
+
+	private <T extends FactoryAccessor> void replaceIn(Object toReplace, T replacement, Object parent) throws IllegalArgumentException, IllegalAccessException {
+
+		for (Field f : RtHelper.getAllFields(parent.getClass())) {
+			f.setAccessible(true);
+			Object tmp = f.get(parent);
+
+			if (tmp != null) {
+				if (tmp instanceof List) {
+					@SuppressWarnings("unchecked") List<T> lst = (List<T>) tmp;
+					for (int i = 0; i < lst.size(); i++) {
+						if (lst.get(i) != null && compare(lst.get(i), toReplace)) {
+							lst.remove(i);
+							if (replacement != null) {
+								lst.add(i, getReplacement(replacement, parent));
+							}
+						}
+					}
+				} else if (tmp instanceof Collection) {
+					@SuppressWarnings("unchecked") Collection<T> collect = (Collection<T>) tmp;
+					Object[] array = collect.toArray();
+					for (Object obj : array) {
+						if (compare(obj, toReplace)) {
+							collect.remove(obj);
+							collect.add(getReplacement(replacement, parent));
+						}
+					}
+				} else if (compare(tmp, toReplace)) {
+					f.set(parent, getReplacement(replacement, parent));
+				}
+			}
+		}
+	}
+
+	private <T extends FactoryAccessor> T getReplacement(T replacement, Object parent) {
+		// T ret = replacement.getFactory().Core().clone(replacement);
+		if (replacement instanceof CtReference && parent instanceof CtReference) {
+			((CtReference) replacement).setParent(parent);
+		}
+		return replacement;
+	}
+
+	private boolean compare(Object o1, Object o2) {
+		return o1 == o2;
+	}
 }
diff --git a/src/main/java/spoon/support/reflect/reference/CtTypeParameterReferenceImpl.java b/src/main/java/spoon/support/reflect/reference/CtTypeParameterReferenceImpl.java
index 0938d3871..3a7317aae 100644
--- a/src/main/java/spoon/support/reflect/reference/CtTypeParameterReferenceImpl.java
+++ b/src/main/java/spoon/support/reflect/reference/CtTypeParameterReferenceImpl.java
@@ -17,13 +17,6 @@
 
 package spoon.support.reflect.reference;
 
-import static spoon.reflect.ModelElementContainerDefaultCapacities.TYPE_BOUNDS_CONTAINER_DEFAULT_CAPACITY;
-import static spoon.reflect.ModelElementContainerDefaultCapacities.TYPE_TYPE_PARAMETERS_CONTAINER_DEFAULT_CAPACITY;
-
-import java.lang.reflect.AnnotatedElement;
-import java.util.ArrayList;
-import java.util.List;
-
 import spoon.reflect.reference.CtGenericElementReference;
 import spoon.reflect.reference.CtReference;
 import spoon.reflect.reference.CtTypeParameterReference;
@@ -31,6 +24,13 @@ import spoon.reflect.reference.CtTypeReference;
 import spoon.reflect.visitor.CtVisitor;
 import spoon.support.reflect.declaration.CtElementImpl;
 
+import java.lang.reflect.AnnotatedElement;
+import java.util.ArrayList;
+import java.util.List;
+
+import static spoon.reflect.ModelElementContainerDefaultCapacities.TYPE_BOUNDS_CONTAINER_DEFAULT_CAPACITY;
+import static spoon.reflect.ModelElementContainerDefaultCapacities.TYPE_TYPE_PARAMETERS_CONTAINER_DEFAULT_CAPACITY;
+
 public class CtTypeParameterReferenceImpl extends CtTypeReferenceImpl<Object>
 		implements CtTypeParameterReference {
 	private static final long serialVersionUID = 1L;
@@ -60,7 +60,13 @@ public class CtTypeParameterReferenceImpl extends CtTypeReferenceImpl<Object>
 
 	@Override
 	public <T extends CtTypeParameterReference> T setBounds(List<CtTypeReference<?>> bounds) {
-		this.bounds = bounds;
+		if (this.bounds == CtElementImpl.<CtTypeReference<?>>emptyList()) {
+			this.bounds = new ArrayList<CtTypeReference<?>>(TYPE_BOUNDS_CONTAINER_DEFAULT_CAPACITY);
+		}
+		this.bounds.clear();
+		for (CtTypeReference<?> bound : bounds) {
+			addBound(bound);
+		}
 		return (T) this;
 	}
 
@@ -103,6 +109,7 @@ public class CtTypeParameterReferenceImpl extends CtTypeReferenceImpl<Object>
 			actualTypeArguments = new ArrayList<CtTypeReference<?>>(
 					TYPE_TYPE_PARAMETERS_CONTAINER_DEFAULT_CAPACITY);
 		}
+		actualTypeArgument.setParent(this);
 		actualTypeArguments.add(actualTypeArgument);
 		return (C) this;
 	}
@@ -118,6 +125,7 @@ public class CtTypeParameterReferenceImpl extends CtTypeReferenceImpl<Object>
 		if (bounds == CtElementImpl.<CtTypeReference<?>>emptyList()) {
 			bounds = new ArrayList<CtTypeReference<?>>(TYPE_BOUNDS_CONTAINER_DEFAULT_CAPACITY);
 		}
+		bound.setParent(this);
 		bounds.add(bound);
 		return (T) this;
 	}
diff --git a/src/main/java/spoon/support/reflect/reference/CtTypeReferenceImpl.java b/src/main/java/spoon/support/reflect/reference/CtTypeReferenceImpl.java
index 77a3bbc89..660075958 100644
--- a/src/main/java/spoon/support/reflect/reference/CtTypeReferenceImpl.java
+++ b/src/main/java/spoon/support/reflect/reference/CtTypeReferenceImpl.java
@@ -294,22 +294,39 @@ public class CtTypeReferenceImpl<T> extends CtReferenceImpl implements CtTypeRef
 
 	@Override
 	public <C extends CtGenericElementReference> C setActualTypeArguments(List<CtTypeReference<?>> actualTypeArguments) {
-		this.actualTypeArguments = actualTypeArguments;
+		if (this.actualTypeArguments == CtElementImpl.<CtTypeReference<?>>emptyList()) {
+			this.actualTypeArguments = new ArrayList<CtTypeReference<?>>(TYPE_TYPE_PARAMETERS_CONTAINER_DEFAULT_CAPACITY);
+		}
+		this.actualTypeArguments.clear();
+		for (CtTypeReference<?> actualTypeArgument : actualTypeArguments) {
+			addActualTypeArgument(actualTypeArgument);
+		}
 		return (C) this;
 	}
 
 	@Override
 	public <C extends CtTypeReference<T>> C setDeclaringType(CtTypeReference<?> declaringType) {
+		if (declaringType != null) {
+			declaringType.setParent(this);
+		}
 		this.declaringType = declaringType;
 		return (C) this;
 	}
 
 	@Override
 	public <C extends CtTypeReference<T>> C setPackage(CtPackageReference pack) {
+		if (pack != null) {
+			pack.setParent(this);
+		}
 		this.pack = pack;
 		return (C) this;
 	}
 
+	@Override
+	public void replace(CtTypeReference<?> reference) {
+		super.replace(reference);
+	}
+
 	@Override
 	public CtTypeReference<?> unbox() {
 		if (isPrimitive()) {
@@ -470,6 +487,7 @@ public class CtTypeReferenceImpl<T> extends CtReferenceImpl implements CtTypeRef
 		if (actualTypeArguments == CtElementImpl.<CtTypeReference<?>>emptyList()) {
 			actualTypeArguments = new ArrayList<CtTypeReference<?>>(TYPE_TYPE_PARAMETERS_CONTAINER_DEFAULT_CAPACITY);
 		}
+		actualTypeArgument.setParent(this);
 		actualTypeArguments.add(actualTypeArgument);
 		return (C) this;
 	}
diff --git a/src/main/java/spoon/support/reflect/reference/CtVariableReferenceImpl.java b/src/main/java/spoon/support/reflect/reference/CtVariableReferenceImpl.java
index 360631c44..311b6041d 100644
--- a/src/main/java/spoon/support/reflect/reference/CtVariableReferenceImpl.java
+++ b/src/main/java/spoon/support/reflect/reference/CtVariableReferenceImpl.java
@@ -17,16 +17,16 @@
 
 package spoon.support.reflect.reference;
 
-import java.lang.reflect.AnnotatedElement;
-import java.util.Set;
-import java.util.TreeSet;
-
 import spoon.reflect.declaration.CtVariable;
 import spoon.reflect.declaration.ModifierKind;
 import spoon.reflect.reference.CtTypeReference;
 import spoon.reflect.reference.CtVariableReference;
 import spoon.reflect.visitor.CtVisitor;
 
+import java.lang.reflect.AnnotatedElement;
+import java.util.Set;
+import java.util.TreeSet;
+
 public abstract class CtVariableReferenceImpl<T> extends CtReferenceImpl
 		implements CtVariableReference<T> {
 	private static final long serialVersionUID = 1L;
@@ -49,6 +49,9 @@ public abstract class CtVariableReferenceImpl<T> extends CtReferenceImpl
 
 	@Override
 	public <C extends CtVariableReference<T>> C setType(CtTypeReference<T> type) {
+		if (type != null) {
+			type.setParent(this);
+		}
 		this.type = type;
 		return (C) this;
 	}
@@ -87,4 +90,9 @@ public abstract class CtVariableReferenceImpl<T> extends CtReferenceImpl
 		}
 		return new TreeSet<ModifierKind>();
 	}
+
+	@Override
+	public void replace(CtVariableReference<?> reference) {
+		super.replace(reference);
+	}
 }
diff --git a/src/test/java/spoon/test/replace/ReplaceTest.java b/src/test/java/spoon/test/replace/ReplaceTest.java
index f725a941f..a1735ab7c 100644
--- a/src/test/java/spoon/test/replace/ReplaceTest.java
+++ b/src/test/java/spoon/test/replace/ReplaceTest.java
@@ -7,22 +7,41 @@ import spoon.Launcher;
 import spoon.compiler.SpoonResourceHelper;
 import spoon.reflect.code.CtAssignment;
 import spoon.reflect.code.CtBlock;
+import spoon.reflect.code.CtConstructorCall;
 import spoon.reflect.code.CtExpression;
 import spoon.reflect.code.CtInvocation;
 import spoon.reflect.code.CtLiteral;
 import spoon.reflect.code.CtLocalVariable;
+import spoon.reflect.code.CtReturn;
 import spoon.reflect.code.CtStatement;
+import spoon.reflect.code.CtVariableRead;
 import spoon.reflect.declaration.CtClass;
 import spoon.reflect.declaration.CtElement;
 import spoon.reflect.declaration.CtField;
 import spoon.reflect.declaration.CtMethod;
+import spoon.reflect.declaration.CtType;
 import spoon.reflect.declaration.CtVariable;
 import spoon.reflect.factory.Factory;
+import spoon.reflect.reference.CtExecutableReference;
+import spoon.reflect.reference.CtFieldReference;
+import spoon.reflect.reference.CtParameterReference;
+import spoon.reflect.reference.CtReference;
+import spoon.reflect.reference.CtTypeParameterReference;
+import spoon.reflect.reference.CtTypeReference;
+import spoon.reflect.reference.CtVariableReference;
+import spoon.reflect.visitor.Query;
 import spoon.reflect.visitor.filter.NameFilter;
+import spoon.reflect.visitor.filter.ReferenceTypeFilter;
 import spoon.reflect.visitor.filter.TypeFilter;
+import spoon.support.reflect.reference.CtTypeParameterReferenceImpl;
+import spoon.support.reflect.reference.CtTypeReferenceImpl;
+import spoon.test.replace.testclasses.Tacos;
+
+import java.util.List;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
 
 public class ReplaceTest {
 
@@ -35,17 +54,17 @@ public class ReplaceTest {
 		spoon.createCompiler(
 				factory,
 				SpoonResourceHelper
-						.resources("./src/test/java/spoon/test/replace/Foo.java"))
+						.resources("./src/test/java/spoon/test/replace/testclasses"))
 				.build();
 	}
 
 	@Test
 	public void testReplaceSet() throws Exception {
 
-		CtClass<?> foo = factory.Package().get("spoon.test.replace")
+		CtClass<?> foo = factory.Package().get("spoon.test.replace.testclasses")
 				.getType("Foo");
 		assertEquals("Foo", foo.getSimpleName());
-		CtClass<?> bar = factory.Package().get("spoon.test.replace")
+		CtClass<?> bar = factory.Package().get("spoon.test.replace.testclasses")
 				.getType("Bar");
 		assertEquals("Bar", bar.getSimpleName());
 
@@ -69,7 +88,7 @@ public class ReplaceTest {
 
 	@Test
 	public void testReplaceBlock() throws Exception {
-		CtClass<?> foo = factory.Package().get("spoon.test.replace")
+		CtClass<?> foo = factory.Package().get("spoon.test.replace.testclasses")
 				.getType("Foo");
 		CtMethod<?> m = foo.getElements(
 				new NameFilter<CtMethod<?>>("foo")).get(0);
@@ -100,7 +119,7 @@ public class ReplaceTest {
 	@Test
 	public void testReplaceReplace() throws Exception {
 		// bug found by Benoit
-		CtClass<?> foo = factory.Package().get("spoon.test.replace")
+		CtClass<?> foo = factory.Package().get("spoon.test.replace.testclasses")
 				.getType("Foo");
 
 		CtMethod<?> fooMethod = foo.getElements(
@@ -130,7 +149,7 @@ public class ReplaceTest {
 
 	@Test
 	public void testReplaceStmtByList() {
-		CtClass<?> sample = factory.Package().get("spoon.test.replace")
+		CtClass<?> sample = factory.Package().get("spoon.test.replace.testclasses")
 				.getType("Foo");
 
 		// replace retry content by statements
@@ -146,7 +165,7 @@ public class ReplaceTest {
 
 	@Test
 	public void testReplaceField() {
-		CtClass<?> sample = factory.Package().get("spoon.test.replace")
+		CtClass<?> sample = factory.Package().get("spoon.test.replace.testclasses")
 				.getType("Foo");
 
 		Assert.assertEquals(factory.Type().createReference(int.class), sample.getField("i").getType());
@@ -170,7 +189,7 @@ public class ReplaceTest {
 
 	@Test
 	public void testReplaceMethod() {
-		CtClass<?> sample = factory.Package().get("spoon.test.replace")
+		CtClass<?> sample = factory.Package().get("spoon.test.replace.testclasses")
 				.getType("Foo");
 
 		Assert.assertNotNull(sample.getMethod("foo"));
@@ -187,7 +206,7 @@ public class ReplaceTest {
 
 	@Test
 	public void testReplaceExpression() {
-		CtMethod<?> sample = factory.Package().get("spoon.test.replace")
+		CtMethod<?> sample = factory.Package().get("spoon.test.replace.testclasses")
 				.getType("Foo").getMethod("foo");
 
 		CtVariable<?> var = sample.getBody().getStatement(0);
@@ -205,7 +224,7 @@ public class ReplaceTest {
 
 	@Test
 	public void testReplaceStatement() {
-		CtMethod<?> sample = factory.Package().get("spoon.test.replace")
+		CtMethod<?> sample = factory.Package().get("spoon.test.replace.testclasses")
 				.getType("Foo").getMethod("foo");
 
 		Assert.assertTrue(sample.getBody().getStatement(0) instanceof CtVariable);
@@ -216,4 +235,106 @@ public class ReplaceTest {
 		Assert.assertTrue(sample.getBody().getStatement(0) instanceof CtInvocation);
 	}
 
+	@Test
+	public void testReplaceIntegerReference() throws Exception {
+		// contract: replace a primitive type reference by another one.
+		final CtType<Tacos> aTacos = factory.Type().get(Tacos.class);
+		final CtMethod<?> aMethod = aTacos.getMethodsByName("m").get(0);
+
+		assertEquals(factory.Type().INTEGER_PRIMITIVE, aMethod.getType());
+
+		aMethod.getType().replace(factory.Type().DOUBLE_PRIMITIVE);
+
+		assertEquals(factory.Type().DOUBLE_PRIMITIVE, aMethod.getType());
+	}
+
+	@Test
+	public void testReplaceAllTypeRefenceWithGenerics() throws Exception {
+		// contract: replace all type references with a generic to the same type reference without generics.
+		final List<CtTypeReference> references = Query.getReferences(factory, new ReferenceTypeFilter<CtTypeReference>(CtTypeReference.class) {
+			@Override
+			public boolean matches(CtTypeReference reference) {
+				return reference.getActualTypeArguments().size() > 0 && super.matches(reference);
+			}
+		});
+
+		for (CtTypeReference reference : references) {
+			assertTrue(reference.getActualTypeArguments().size() > 0);
+		}
+
+		for (CtTypeReference<?> reference : references) {
+			reference.replace(factory.Type().createReference(reference.getQualifiedName()));
+		}
+
+		final CtType<Tacos> aTacos = factory.Type().get(Tacos.class);
+		final CtMethod<?> aMethod = aTacos.getMethodsByName("m2").get(0);
+
+		final CtTypeReference<Object> expected = factory.Type().createReference("spoon.test.replace.testclasses.Tacos");
+		assertEquals(expected, aMethod.getType());
+		assertEquals(expected, aMethod.getElements(new TypeFilter<>(CtConstructorCall.class)).get(0).getType());
+	}
+
+	@Test
+	public void testReplaceAPackageReferenceByAnotherOne() throws Exception {
+		// contract: replace a package reference of a reference to another package.
+		final Launcher launcher = new Launcher();
+		launcher.getEnvironment().setNoClasspath(true);
+		launcher.addInputResource("./src/test/resources/reference-package");
+		launcher.setSourceOutputDirectory("./target/trash");
+		launcher.run();
+
+		final CtType<Object> panini = launcher.getFactory().Type().get("Panini");
+
+		final CtTypeReference<?> burritos = panini.getReferences(new ReferenceTypeFilter<CtTypeReference<?>>(CtTypeReference.class) {
+			@Override
+			public boolean matches(CtTypeReference<?> reference) {
+				return "Burritos".equals(reference.getSimpleName()) && super.matches(reference);
+			}
+		}).get(0);
+
+		assertEquals("com.awesome", burritos.getPackage().toString());
+		assertEquals("com.awesome.Burritos", panini.getMethodsByName("m").get(0).getType().toString());
+
+		burritos.getPackage().replace(launcher.getFactory().Package().createReference("com.best"));
+
+		assertEquals("com.best", burritos.getPackage().toString());
+		assertEquals("com.best.Burritos", panini.getMethodsByName("m").get(0).getType().toString());
+	}
+
+	@Test
+	public void testReplaceAParameterReferenceToFieldReference() throws Exception {
+		// contract: replace a parameter reference to a field reference.
+		final CtType<Tacos> aTacos = factory.Type().get(Tacos.class);
+
+		final CtInvocation inv = aTacos.getMethodsByName("m3").get(0).getElements(new TypeFilter<>(CtInvocation.class)).get(0);
+		final CtVariableRead<?> variableRead = (CtVariableRead<?>) inv.getArguments().get(0);
+		final CtParameterReference<?> aParameterReference = (CtParameterReference<?>) variableRead.getVariable();
+		final CtFieldReference<?> aFieldReference = aTacos.getField("field").getReference();
+
+		assertEquals(variableRead.getVariable(), aParameterReference);
+		assertEquals("java.lang.System.err.println(param)", inv.toString());
+
+		aParameterReference.replace(aFieldReference);
+
+		assertEquals(variableRead.getVariable(), aFieldReference);
+		assertEquals("java.lang.System.err.println(field)", inv.toString());
+	}
+
+	@Test
+	public void testReplaceExecutableReferenceByAnotherOne() throws Exception {
+		// contract: replace an executable reference to another one in an invocation.
+		final CtType<Tacos> aTacos = factory.Type().get(Tacos.class);
+
+		final CtInvocation inv = aTacos.getMethodsByName("m3").get(0).getElements(new TypeFilter<>(CtInvocation.class)).get(0);
+		final CtExecutableReference oldExecutable = inv.getExecutable();
+		final CtExecutableReference<Object> newExecutable = factory.Executable().createReference("void java.io.PrintStream#print(java.lang.String)");
+
+		assertEquals(inv.getExecutable(), oldExecutable);
+		assertEquals("java.io.PrintStream#println(java.lang.String)", inv.getExecutable().toString());
+
+		oldExecutable.replace(newExecutable);
+
+		assertEquals(inv.getExecutable(), newExecutable);
+		assertEquals("java.io.PrintStream#print(java.lang.String)", inv.getExecutable().toString());
+	}
 }
diff --git a/src/test/java/spoon/test/replace/Foo.java b/src/test/java/spoon/test/replace/testclasses/Foo.java
similarity index 87%
rename from src/test/java/spoon/test/replace/Foo.java
rename to src/test/java/spoon/test/replace/testclasses/Foo.java
index c5faf7f59..f2af202c0 100644
--- a/src/test/java/spoon/test/replace/Foo.java
+++ b/src/test/java/spoon/test/replace/testclasses/Foo.java
@@ -1,4 +1,4 @@
-package spoon.test.replace;
+package spoon.test.replace.testclasses;
 
 class Foo {
 	int i;
@@ -8,7 +8,7 @@ class Foo {
 		z= x+1;
 		System.out.println(z);
 	}
-	
+
 	void bar() {
 		int y = 4;
 	}
diff --git a/src/test/java/spoon/test/replace/testclasses/Tacos.java b/src/test/java/spoon/test/replace/testclasses/Tacos.java
new file mode 100644
index 000000000..033ad3af7
--- /dev/null
+++ b/src/test/java/spoon/test/replace/testclasses/Tacos.java
@@ -0,0 +1,17 @@
+package spoon.test.replace.testclasses;
+
+public class Tacos<T> {
+	String field;
+
+	public int m() {
+		return 1;
+	}
+
+	public Tacos<Integer> m2() {
+		return new Tacos<>();
+	}
+
+	public void m3(String param) {
+		System.err.println(param);
+	}
+}
diff --git a/src/test/resources/reference-package/Panini.java b/src/test/resources/reference-package/Panini.java
new file mode 100644
index 000000000..f261c9ef5
--- /dev/null
+++ b/src/test/resources/reference-package/Panini.java
@@ -0,0 +1,8 @@
+
+import com.awesome.Burritos;
+
+public class Panini {
+	public Burritos m() {
+		return null;
+	}
+}
\ No newline at end of file
