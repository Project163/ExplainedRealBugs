diff --git a/src/main/java/spoon/reflect/code/CtThisAccess.java b/src/main/java/spoon/reflect/code/CtThisAccess.java
index 676062e3e..40a4345f7 100644
--- a/src/main/java/spoon/reflect/code/CtThisAccess.java
+++ b/src/main/java/spoon/reflect/code/CtThisAccess.java
@@ -19,20 +19,9 @@ package spoon.reflect.code;
 
 /**
  * This code element defines an access to this.
- * 
+ *
  * @param <T>
- *            Type of this
+ * 		Type of this
  */
-public interface CtThisAccess<T> extends CtExpression<T> {
-
-	/**
-	 * Tells if this access must be qualified by the class it refers to.
-	 */
-	boolean isQualified();
-
-	/**
-	 * Sets this access to be qualified by the class it refers to.
-	 */
-	void setQualified(boolean qualified);
-
+public interface CtThisAccess<T> extends CtTargetedExpression<T, CtExpression<?>> {
 }
diff --git a/src/main/java/spoon/reflect/visitor/CtInheritanceScanner.java b/src/main/java/spoon/reflect/visitor/CtInheritanceScanner.java
index 17417e178..7779e6417 100644
--- a/src/main/java/spoon/reflect/visitor/CtInheritanceScanner.java
+++ b/src/main/java/spoon/reflect/visitor/CtInheritanceScanner.java
@@ -490,6 +490,7 @@ public abstract class CtInheritanceScanner implements CtVisitor {
 	}
 
 	public <T> void visitCtThisAccess(CtThisAccess<T> e) {
+		scanCtTargetedExpression(e);
 		scanCtExpression(e);
 		scanCtCodeElement(e);
 		scanCtTypedElement(e);
diff --git a/src/main/java/spoon/reflect/visitor/CtScanner.java b/src/main/java/spoon/reflect/visitor/CtScanner.java
index 6d46176f5..2fac07f29 100644
--- a/src/main/java/spoon/reflect/visitor/CtScanner.java
+++ b/src/main/java/spoon/reflect/visitor/CtScanner.java
@@ -369,6 +369,7 @@ public abstract class CtScanner implements CtVisitor {
 		enter(thisAccess);
 		scan(thisAccess.getType());
 		scanReferences(thisAccess.getTypeCasts());
+		scan(thisAccess.getTarget());
 		exit(thisAccess);
 	}
 
diff --git a/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java b/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java
index fb0b70b1a..fde90ba58 100644
--- a/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java
+++ b/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java
@@ -1032,10 +1032,10 @@ public class DefaultJavaPrettyPrinter implements CtVisitor, PrettyPrinter {
 	@Override
 	public <T> void visitCtThisAccess(CtThisAccess<T> thisAccess) {
 		enterCtExpression(thisAccess);
-		if (thisAccess.isQualified() && thisAccess.isImplicit()) {
+		if (thisAccess.getTarget() != null && thisAccess.isImplicit()) {
 			throw new RuntimeException("inconsistent this definition");
 		}
-		if (thisAccess.isQualified()) {
+		if (thisAccess.getTarget() != null) {
 			visitCtTypeReferenceWithoutGenerics(thisAccess.getType());
 			write(".");
 		}
diff --git a/src/main/java/spoon/reflect/visitor/ImportScannerImpl.java b/src/main/java/spoon/reflect/visitor/ImportScannerImpl.java
index 233479351..f45354828 100644
--- a/src/main/java/spoon/reflect/visitor/ImportScannerImpl.java
+++ b/src/main/java/spoon/reflect/visitor/ImportScannerImpl.java
@@ -10,7 +10,6 @@ import java.util.TreeMap;
 import spoon.reflect.code.CtCatchVariable;
 import spoon.reflect.code.CtFieldAccess;
 import spoon.reflect.code.CtInvocation;
-import spoon.reflect.code.CtSuperAccess;
 import spoon.reflect.declaration.CtAnnotationType;
 import spoon.reflect.declaration.CtClass;
 import spoon.reflect.declaration.CtElement;
diff --git a/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java b/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
index 0dfc5755b..7a4973b26 100644
--- a/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
+++ b/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
@@ -1264,8 +1264,7 @@ public class JDTTreeBuilder extends ASTVisitor {
 	}
 
 	@Override
-	public void endVisit(QualifiedSuperReference qualifiedsuperReference,
-			BlockScope scope) {
+	public void endVisit(QualifiedSuperReference qualifiedsuperReference, BlockScope scope) {
 		context.exit(qualifiedsuperReference);
 	}
 
@@ -1274,6 +1273,17 @@ public class JDTTreeBuilder extends ASTVisitor {
 		context.exit(superReference);
 	}
 
+	@Override
+	public void endVisit(QualifiedThisReference qualifiedThisReference, ClassScope scope) {
+		super.endVisit(qualifiedThisReference, scope);
+		context.exit(qualifiedThisReference);
+	}
+
+	@Override
+	public void endVisit(ThisReference thisReference, BlockScope scope) {
+		context.exit(thisReference);
+	}
+
 	@Override
 	public void endVisit(SwitchStatement switchStatement, BlockScope scope) {
 		context.exit(switchStatement);
@@ -1285,11 +1295,6 @@ public class JDTTreeBuilder extends ASTVisitor {
 		context.exit(synchronizedStatement);
 	}
 
-	@Override
-	public void endVisit(ThisReference thisReference, BlockScope scope) {
-		context.exit(thisReference);
-	}
-
 	@Override
 	public void endVisit(ThrowStatement throwStatement, BlockScope scope) {
 		context.exit(throwStatement);
@@ -2491,12 +2496,6 @@ public class JDTTreeBuilder extends ASTVisitor {
 		}
 	}
 
-	@Override
-	public boolean visit(QualifiedThisReference qualifiedThisReference,
-			BlockScope scope) {
-		return visit((ThisReference) qualifiedThisReference, scope);
-	}
-
 	@Override
 	public boolean visit(QualifiedTypeReference arg0, BlockScope arg1) {
 		if (skipTypeInAnnotation) {
@@ -2581,15 +2580,28 @@ public class JDTTreeBuilder extends ASTVisitor {
 		return super.visit(superReference, scope);
 	}
 
+	@Override
+	public boolean visit(QualifiedThisReference qualifiedThisReference, BlockScope scope) {
+		final CtTypeReference<Object> typeRefOfThis = references.getTypeReference(qualifiedThisReference.qualification.resolvedType);
+		CtThisAccess<Object> thisAccess = factory.Core().createThisAccess();
+		thisAccess.setImplicit(qualifiedThisReference.isImplicitThis());
+		thisAccess.setType(typeRefOfThis);
+
+		CtTypeAccess<Object> typeAccess = factory.Core().createTypeAccess();
+		typeAccess.setType(typeRefOfThis);
+		thisAccess.setTarget(typeAccess);
+
+		context.enter(thisAccess, qualifiedThisReference);
+		return true;
+	}
+
 	@Override
 	public boolean visit(ThisReference thisReference, BlockScope scope) {
-		CtThisAccess<Object> fa = factory.Core().createThisAccess();
-		fa.setImplicit(thisReference.isImplicitThis());
-		if (thisReference instanceof QualifiedThisReference) {
-			fa.setQualified(true);
-		}
-		fa.setType(references.getTypeReference(thisReference.resolvedType));
-		context.enter(fa, thisReference);
+		CtThisAccess<Object> thisAccess = factory.Core().createThisAccess();
+		thisAccess.setImplicit(thisReference.isImplicitThis());
+		thisAccess.setType(references.getTypeReference(thisReference.resolvedType));
+
+		context.enter(thisAccess, thisReference);
 		return true;
 	}
 
diff --git a/src/main/java/spoon/support/reflect/code/CtThisAccessImpl.java b/src/main/java/spoon/support/reflect/code/CtThisAccessImpl.java
index b427185f6..b5a927b8f 100644
--- a/src/main/java/spoon/support/reflect/code/CtThisAccessImpl.java
+++ b/src/main/java/spoon/support/reflect/code/CtThisAccessImpl.java
@@ -17,29 +17,16 @@
 
 package spoon.support.reflect.code;
 
+import spoon.reflect.code.CtExpression;
 import spoon.reflect.code.CtThisAccess;
 import spoon.reflect.visitor.CtVisitor;
 
-public class CtThisAccessImpl<T> extends CtExpressionImpl<T> implements
-		CtThisAccess<T> {
+public class CtThisAccessImpl<T> extends CtTargetedExpressionImpl<T, CtExpression<?>> implements CtThisAccess<T> {
 
 	private static final long serialVersionUID = 1L;
 
-	boolean qualified = false;
-
-	@Override
-	public boolean isQualified() {
-		return qualified;
-	}
-
-	@Override
-	public void setQualified(boolean qualified) {
-		this.qualified = qualified;
-	}
-
 	public void accept(CtVisitor visitor) {
 		visitor.visitCtThisAccess(this);
 	}
 
-	
 }
diff --git a/src/main/java/spoon/support/template/SubstitutionVisitor.java b/src/main/java/spoon/support/template/SubstitutionVisitor.java
index 2335f2fd5..282372e4a 100644
--- a/src/main/java/spoon/support/template/SubstitutionVisitor.java
+++ b/src/main/java/spoon/support/template/SubstitutionVisitor.java
@@ -35,7 +35,6 @@ import spoon.reflect.code.CtLiteral;
 import spoon.reflect.code.CtReturn;
 import spoon.reflect.code.CtStatement;
 import spoon.reflect.code.CtStatementList;
-import spoon.reflect.code.CtSuperAccess;
 import spoon.reflect.code.CtTargetedAccess;
 import spoon.reflect.code.CtVariableAccess;
 import spoon.reflect.declaration.CtAnnotation;
diff --git a/src/main/java/spoon/support/visitor/TypeReferenceScanner.java b/src/main/java/spoon/support/visitor/TypeReferenceScanner.java
index aadb8846f..5bde2dd3e 100644
--- a/src/main/java/spoon/support/visitor/TypeReferenceScanner.java
+++ b/src/main/java/spoon/support/visitor/TypeReferenceScanner.java
@@ -5,7 +5,6 @@ import java.util.HashSet;
 import java.util.Set;
 
 import spoon.reflect.code.CtFieldAccess;
-import spoon.reflect.code.CtSuperAccess;
 import spoon.reflect.declaration.CtAnnotationType;
 import spoon.reflect.declaration.CtClass;
 import spoon.reflect.declaration.CtEnum;
diff --git a/src/test/java/spoon/test/factory/FieldFactoryTest.java b/src/test/java/spoon/test/factory/FieldFactoryTest.java
index 84ab39465..f3aa97cd8 100644
--- a/src/test/java/spoon/test/factory/FieldFactoryTest.java
+++ b/src/test/java/spoon/test/factory/FieldFactoryTest.java
@@ -43,7 +43,7 @@ public class FieldFactoryTest {
 	public void testCreateFromSource() throws Exception {
 
 		CtClass<?> target = build("spoon.test", "SampleClass");
-		CtClass<?> type = build("spoon.test.fieldaccesses.testclasses", "Foo");
+		CtClass<?> type = build("spoon.test.targeted.testclasses", "Foo");
 		CtField<?> source = type.getField("i");
 		FieldFactory ff = type.getFactory().Field();
 		TypeFactory tf = type.getFactory().Type();
diff --git a/src/test/java/spoon/test/fieldaccesses/FieldAccessTest.java b/src/test/java/spoon/test/fieldaccesses/FieldAccessTest.java
index 85bdf76f0..36406334f 100644
--- a/src/test/java/spoon/test/fieldaccesses/FieldAccessTest.java
+++ b/src/test/java/spoon/test/fieldaccesses/FieldAccessTest.java
@@ -68,26 +68,6 @@ public class FieldAccessTest {
 
 	}
 
-	@Test
-	public void testModelBuildingOuterThisAccesses() throws Exception {
-		CtType<?> type = build("spoon.test.fieldaccesses",
-				"InnerClassThisAccess");
-		assertEquals("InnerClassThisAccess", type.getSimpleName());
-
-		CtMethod<?> meth1 = type.getElements(
-				new NameFilter<CtMethod<?>>("method2")).get(0);
-		assertEquals(
-				"spoon.test.fieldaccesses.InnerClassThisAccess.this.method()",
-				meth1.getBody().getStatements().get(0).toString());
-
-		CtClass<?> c = type.getElements(
-				new NameFilter<CtClass<?>>("InnerClass")).get(0);
-		assertEquals("InnerClass", c.getSimpleName());
-		CtConstructor<?> ctr = c.getConstructor(type.getFactory().Type()
-				.createReference(boolean.class));
-		assertEquals("this.b = b", ctr.getBody().getLastStatement().toString());
-	}
-
 	@Test
 	public void testBCUBug20140402() throws Exception {
 		CtType<?> type = build("spoon.test.fieldaccesses",
@@ -136,16 +116,4 @@ public class FieldAccessTest {
 		assertEquals(0, ((CtTargetedAccess<?>)vars.get(0).getTarget()).getTarget().getPosition().getSourceEnd() - 
 				((CtTargetedAccess<?>)vars.get(0).getTarget()).getTarget().getPosition().getSourceStart());
 	}
-
-	@Test
-	public void testTargetOfFieldAccess() throws Exception {
-		CtClass<?> type = build("spoon.test.fieldaccesses.testclasses", "Foo");
-		CtConstructor<?> constructor = type.getConstructors().toArray(new CtConstructor<?>[0])[0];
-
-		final List<CtFieldAccess<?>> elements = constructor.getElements(new TypeFilter<CtFieldAccess<?>>(CtFieldAccess.class));
-		assertEquals(2, elements.size());
-
-		assertEquals("Target is CtThisAccessImpl if there is a 'this' explicit.", CtThisAccessImpl.class, elements.get(0).getTarget().getClass());
-		assertNull("Targets is null if there isn't a 'this' explicit.", elements.get(1).getTarget());
-	}
 }
diff --git a/src/test/java/spoon/test/targeted/TargetedExpressionTest.java b/src/test/java/spoon/test/targeted/TargetedExpressionTest.java
index cc33534c5..b55ce4c65 100644
--- a/src/test/java/spoon/test/targeted/TargetedExpressionTest.java
+++ b/src/test/java/spoon/test/targeted/TargetedExpressionTest.java
@@ -1,12 +1,17 @@
 package spoon.test.targeted;
 
 import org.junit.Test;
+import spoon.reflect.code.CtFieldAccess;
 import spoon.reflect.code.CtSuperAccess;
 import spoon.reflect.declaration.CtClass;
+import spoon.reflect.declaration.CtConstructor;
 import spoon.reflect.declaration.CtMethod;
+import spoon.reflect.declaration.CtType;
 import spoon.reflect.factory.Factory;
 import spoon.reflect.visitor.filter.AbstractFilter;
 import spoon.reflect.visitor.filter.NameFilter;
+import spoon.reflect.visitor.filter.TypeFilter;
+import spoon.support.reflect.code.CtThisAccessImpl;
 import spoon.test.targeted.testclasses.InternalSuperCall;
 
 import java.util.List;
@@ -18,7 +23,7 @@ import static spoon.test.TestUtils.build;
 
 public class TargetedExpressionTest {
 	@Test
-	public void testTargetOfSuperAccesses() throws Exception {
+	public void testCtSuperAccess() throws Exception {
 		final Factory factory = build(InternalSuperCall.class);
 		final CtClass<?> ctClass = factory.Class().get(InternalSuperCall.class);
 		final List<CtSuperAccess> superAccesses = ctClass.getElements(new AbstractFilter<CtSuperAccess>(CtSuperAccess.class) {
@@ -41,4 +46,32 @@ public class TargetedExpressionTest {
 				"return super.toString()",
 				toString.getBody().getStatements().get(0).toString());
 	}
+
+	@Test
+	public void testCtThisAccess() throws Exception {
+		CtType<?> type = build("spoon.test.targeted.testclasses", "InnerClassThisAccess");
+		assertEquals("InnerClassThisAccess", type.getSimpleName());
+
+		CtMethod<?> meth1 = type.getElements(new NameFilter<CtMethod<?>>("method2")).get(0);
+		assertEquals(
+				"spoon.test.targeted.testclasses.InnerClassThisAccess.this.method()",
+				meth1.getBody().getStatements().get(0).toString());
+
+		CtClass<?> c = type.getElements(new NameFilter<CtClass<?>>("InnerClass")).get(0);
+		assertEquals("InnerClass", c.getSimpleName());
+		CtConstructor<?> ctr = c.getConstructor(type.getFactory().Type().createReference(boolean.class));
+		assertEquals("this.b = b", ctr.getBody().getLastStatement().toString());
+	}
+
+	@Test
+	public void testTargetOfFieldAccess() throws Exception {
+		CtClass<?> type = build("spoon.test.targeted.testclasses", "Foo");
+		CtConstructor<?> constructor = type.getConstructors().toArray(new CtConstructor<?>[0])[0];
+
+		final List<CtFieldAccess<?>> elements = constructor.getElements(new TypeFilter<CtFieldAccess<?>>(CtFieldAccess.class));
+		assertEquals(2, elements.size());
+
+		assertEquals("Target is CtThisAccessImpl if there is a 'this' explicit.", CtThisAccessImpl.class, elements.get(0).getTarget().getClass());
+		assertNull("Targets is null if there isn't a 'this' explicit.", elements.get(1).getTarget());
+	}
 }
diff --git a/src/test/java/spoon/test/fieldaccesses/testclasses/Foo.java b/src/test/java/spoon/test/targeted/testclasses/Foo.java
similarity index 70%
rename from src/test/java/spoon/test/fieldaccesses/testclasses/Foo.java
rename to src/test/java/spoon/test/targeted/testclasses/Foo.java
index 4205184b0..475dc3a36 100644
--- a/src/test/java/spoon/test/fieldaccesses/testclasses/Foo.java
+++ b/src/test/java/spoon/test/targeted/testclasses/Foo.java
@@ -1,4 +1,4 @@
-package spoon.test.fieldaccesses.testclasses;
+package spoon.test.targeted.testclasses;
 
 public class Foo {
 	private int i;
diff --git a/src/test/java/spoon/test/fieldaccesses/InnerClassThisAccess.java b/src/test/java/spoon/test/targeted/testclasses/InnerClassThisAccess.java
similarity index 92%
rename from src/test/java/spoon/test/fieldaccesses/InnerClassThisAccess.java
rename to src/test/java/spoon/test/targeted/testclasses/InnerClassThisAccess.java
index ad0a9e62f..eebcfe892 100644
--- a/src/test/java/spoon/test/fieldaccesses/InnerClassThisAccess.java
+++ b/src/test/java/spoon/test/targeted/testclasses/InnerClassThisAccess.java
@@ -1,4 +1,4 @@
-package spoon.test.fieldaccesses;
+package spoon.test.targeted.testclasses;
 
 
 public class InnerClassThisAccess {
