diff --git a/src/main/java/spoon/reflect/visitor/CtScanner.java b/src/main/java/spoon/reflect/visitor/CtScanner.java
index a5462d27b..10a8766c5 100644
--- a/src/main/java/spoon/reflect/visitor/CtScanner.java
+++ b/src/main/java/spoon/reflect/visitor/CtScanner.java
@@ -225,6 +225,7 @@ public abstract class CtScanner implements CtVisitor {
 		scan(reference.getPackage());
 		scan(reference.getComponentType());
 		scan(reference.getActualTypeArguments());
+		scan(reference.getAnnotations());
 		exit(reference);
 	}
 
@@ -356,6 +357,7 @@ public abstract class CtScanner implements CtVisitor {
 		scan(reference.getDeclaringType());
 		scan(reference.getType());
 		scan(reference.getActualTypeArguments());
+		scan(reference.getAnnotations());
 		exit(reference);
 	}
 
@@ -391,6 +393,7 @@ public abstract class CtScanner implements CtVisitor {
 		enter(reference);
 		scan(reference.getDeclaringType());
 		scan(reference.getType());
+		scan(reference.getAnnotations());
 		exit(reference);
 	}
 
@@ -464,6 +467,7 @@ public abstract class CtScanner implements CtVisitor {
 			CtLocalVariableReference<T> reference) {
 		enter(reference);
 		scan(reference.getType());
+		scan(reference.getAnnotations());
 		exit(reference);
 	}
 
@@ -477,6 +481,7 @@ public abstract class CtScanner implements CtVisitor {
 	public <T> void visitCtCatchVariableReference(CtCatchVariableReference<T> reference) {
 		enter(reference);
 		scan(reference.getType());
+		scan(reference.getAnnotations());
 		exit(reference);
 	}
 
@@ -581,6 +586,7 @@ public abstract class CtScanner implements CtVisitor {
 	public <T> void visitCtParameterReference(CtParameterReference<T> reference) {
 		enter(reference);
 		scan(reference.getType());
+		scan(reference.getAnnotations());
 		exit(reference);
 	}
 
@@ -653,6 +659,7 @@ public abstract class CtScanner implements CtVisitor {
 		scan(ref.getPackage());
 		scan(ref.getDeclaringType());
 		scan(ref.getActualTypeArguments());
+		scan(ref.getAnnotations());
 		scan(ref.getBounds());
 		exit(ref);
 	}
@@ -662,6 +669,7 @@ public abstract class CtScanner implements CtVisitor {
 		scan(reference.getPackage());
 		scan(reference.getDeclaringType());
 		scan(reference.getActualTypeArguments());
+		scan(reference.getAnnotations());
 		exit(reference);
 	}
 
diff --git a/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java b/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java
index 63a8cd81b..d73fd34bf 100644
--- a/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java
+++ b/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java
@@ -1948,7 +1948,9 @@ public class DefaultJavaPrettyPrinter implements CtVisitor, PrettyPrinter {
 
 	@Override
 	public <T> void visitCtTypeAccess(CtTypeAccess<T> typeAccess) {
+		enterCtExpression(typeAccess);
 		scan(typeAccess.getType());
+		exitCtExpression(typeAccess);
 	}
 
 	public void visitCtTypeReferenceWithoutGenerics(CtTypeReference<?> ref) {
@@ -2043,10 +2045,8 @@ public class DefaultJavaPrettyPrinter implements CtVisitor, PrettyPrinter {
 	 * Writes an annotation element.
 	 */
 	public DefaultJavaPrettyPrinter writeAnnotationElement(Factory factory, Object value) {
-		if (value instanceof CtTypeReference) {
-			context.ignoreGenerics = true;
-			scan((CtTypeReference<?>) value).write(".class");
-			context.ignoreGenerics = false;
+		if (value instanceof CtTypeAccess) {
+			scan((CtTypeAccess) value).write(".class");
 		} else if (value instanceof CtFieldReference) {
 			scan(((CtFieldReference<?>) value).getDeclaringType());
 			write("." + ((CtFieldReference<?>) value).getSimpleName());
diff --git a/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java b/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
index 30b1e42e7..3c7798e45 100644
--- a/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
+++ b/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
@@ -749,7 +749,7 @@ public class JDTTreeBuilder extends ASTVisitor {
 			} else if (value instanceof FieldBinding) {
 				return getVariableReference((FieldBinding) value);
 			} else if (value instanceof BinaryTypeBinding) {
-				return getTypeReference((BinaryTypeBinding) value);
+				return buildFieldReadClass(getTypeReference((BinaryTypeBinding) value));
 			} else if (value instanceof Object[]) {
 				Collection<Object> values = new ArrayList<Object>();
 				for (Object currentValue : (Object[]) value) {
@@ -1973,18 +1973,26 @@ public class JDTTreeBuilder extends ASTVisitor {
 
 	@Override
 	public boolean visit(ClassLiteralAccess classLiteral, BlockScope scope) {
-		CtTypeReference<Class<Object>> ref = references.getTypeReference(classLiteral.targetType);
-		CtFieldReference<Class<Object>> fr = factory.Core().createFieldReference();
-		fr.setSimpleName("class");
-		fr.setType(ref);
-		fr.setDeclaringType(ref);
+		CtFieldRead<?> fieldRead = buildFieldReadClass(references.getTypeReference(classLiteral.targetType));
 
-		CtFieldRead<Class<Object>> fa = factory.Core().createFieldRead();
-		fa.setType(ref);
-		fa.setVariable(fr);
+		context.enter(fieldRead, classLiteral);
+		return false;
+	}
 
-		context.enter(fa, classLiteral);
-		return true;
+	private <T> CtFieldRead<T> buildFieldReadClass(CtTypeReference<T> ref) {
+		CtTypeAccess<T> typeAccess = factory.Core().createTypeAccess();
+		typeAccess.setType(ref);
+
+		CtFieldReference<T> fieldReference = factory.Core().createFieldReference();
+		fieldReference.setSimpleName("class");
+		fieldReference.setType(ref);
+		fieldReference.setDeclaringType(ref);
+
+		CtFieldRead<T> fieldRead = factory.Core().createFieldRead();
+		fieldRead.setType(ref);
+		fieldRead.setVariable(fieldReference);
+		fieldRead.setTarget(typeAccess);
+		return fieldRead;
 	}
 
 	@Override
diff --git a/src/main/java/spoon/support/compiler/jdt/ParentExiter.java b/src/main/java/spoon/support/compiler/jdt/ParentExiter.java
index 14d9b5133..3846bc92d 100644
--- a/src/main/java/spoon/support/compiler/jdt/ParentExiter.java
+++ b/src/main/java/spoon/support/compiler/jdt/ParentExiter.java
@@ -33,6 +33,7 @@ import spoon.reflect.code.CtConstructorCall;
 import spoon.reflect.code.CtDo;
 import spoon.reflect.code.CtExecutableReferenceExpression;
 import spoon.reflect.code.CtExpression;
+import spoon.reflect.code.CtFieldRead;
 import spoon.reflect.code.CtFor;
 import spoon.reflect.code.CtForEach;
 import spoon.reflect.code.CtIf;
@@ -178,10 +179,8 @@ public class ParentExiter extends CtInheritanceScanner {
 		String name = this.jdtTreeBuilder.context.annotationValueName.peek();
 		Object value = child;
 
-		if (value instanceof CtVariableAccess) {
+		if (value instanceof CtVariableAccess && !"class".equals(((CtVariableAccess) value).getVariable().getSimpleName())) {
 			value = ((CtVariableAccess<?>) value).getVariable();
-		} else if (value instanceof CtFieldReference && ((CtFieldReference<?>) value).getSimpleName().equals("class")) {
-			value = ((CtFieldReference<?>) value).getType();
 		}
 		annotation.addValue(name, value);
 		super.visitCtAnnotation(annotation);
diff --git a/src/main/java/spoon/support/reflect/declaration/CtAnnotationImpl.java b/src/main/java/spoon/support/reflect/declaration/CtAnnotationImpl.java
index 3892871be..331bf8ac7 100644
--- a/src/main/java/spoon/support/reflect/declaration/CtAnnotationImpl.java
+++ b/src/main/java/spoon/support/reflect/declaration/CtAnnotationImpl.java
@@ -35,7 +35,6 @@ import spoon.reflect.declaration.CtParameter;
 import spoon.reflect.declaration.CtType;
 import spoon.reflect.eval.PartialEvaluator;
 import spoon.reflect.reference.CtFieldReference;
-import spoon.reflect.reference.CtReference;
 import spoon.reflect.reference.CtTypeParameterReference;
 import spoon.reflect.reference.CtTypeReference;
 import spoon.reflect.visitor.CtVisitor;
@@ -48,6 +47,7 @@ import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.Method;
 import java.lang.reflect.Proxy;
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
@@ -131,8 +131,12 @@ public class CtAnnotationImpl<A extends Annotation> extends CtExpressionImpl<A>
 			elementValues.put(elementName, value);
 			if (value instanceof CtElement) {
 				((CtElement) value).setParent(this);
-			} else if (value instanceof CtReference) {
-				((CtReference) value).setParent(this);
+			} else if (value instanceof Collection) {
+				for (Object element : (Collection) value) {
+					if (element instanceof CtElement) {
+						((CtElement) element).setParent(this);
+					}
+				}
 			}
 		} else {
 			Object o = elementValues.get(elementName);
diff --git a/src/main/java/spoon/support/reflect/eval/VisitorPartialEvaluator.java b/src/main/java/spoon/support/reflect/eval/VisitorPartialEvaluator.java
index 535e94de6..ac070a20d 100644
--- a/src/main/java/spoon/support/reflect/eval/VisitorPartialEvaluator.java
+++ b/src/main/java/spoon/support/reflect/eval/VisitorPartialEvaluator.java
@@ -424,12 +424,12 @@ public class VisitorPartialEvaluator implements CtVisitor, PartialEvaluator {
 	}
 
 	private <T> void visitFieldAccess(CtFieldAccess<T> fieldAccess) {
-		if (fieldAccess.getVariable().getSimpleName().equals("class")) {
-			Class<?> c = fieldAccess.getVariable().getDeclaringType().getActualClass();
-			if (c != null) {
-				CtLiteral<Class<?>> l = fieldAccess.getFactory().Core().createLiteral();
-				l.setValue(c);
-				setResult(l);
+		if ("class".equals(fieldAccess.getVariable().getSimpleName())) {
+			Class<?> actualClass = fieldAccess.getVariable().getDeclaringType().getActualClass();
+			if (actualClass != null) {
+				CtLiteral<Class<?>> literal = fieldAccess.getFactory().Core().createLiteral();
+				literal.setValue(actualClass);
+				setResult(literal);
 				return;
 			}
 		}
diff --git a/src/test/java/spoon/test/type/TypeTest.java b/src/test/java/spoon/test/type/TypeTest.java
new file mode 100644
index 000000000..a3944ff25
--- /dev/null
+++ b/src/test/java/spoon/test/type/TypeTest.java
@@ -0,0 +1,89 @@
+/*
+ * Copyright (C) 2006-2015 INRIA and contributors
+ * Spoon - http://spoon.gforge.inria.fr/
+ *
+ * This software is governed by the CeCILL-C License under French law and
+ * abiding by the rules of distribution of free software. You can use, modify
+ * and/or redistribute the software under the terms of the CeCILL-C license as
+ * circulated by CEA, CNRS and INRIA at http://www.cecill.info.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the CeCILL-C License for more details.
+ *
+ * The fact that you are presently reading this means that you have had
+ * knowledge of the CeCILL-C license and that you accept its terms.
+ */
+
+package spoon.test.type;
+
+import org.junit.Test;
+import spoon.Launcher;
+import spoon.reflect.code.CtBinaryOperator;
+import spoon.reflect.code.CtBlock;
+import spoon.reflect.code.CtFieldRead;
+import spoon.reflect.code.CtLocalVariable;
+import spoon.reflect.code.CtTypeAccess;
+import spoon.reflect.declaration.CtAnnotation;
+import spoon.reflect.declaration.CtClass;
+import spoon.reflect.declaration.CtMethod;
+import spoon.reflect.factory.Factory;
+import spoon.reflect.visitor.filter.TypeFilter;
+import spoon.test.TestUtils;
+import spoon.test.type.testclasses.Pozole;
+
+import java.util.List;
+
+import static junit.framework.TestCase.assertFalse;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+public class TypeTest {
+	@Test
+	public void testTypeAccessForDotClass() throws Exception {
+		// contract: When we use .class on a type, this must be a CtTypeAccess.
+		final String target = "./target/type";
+		final Launcher launcher = new Launcher();
+		launcher.addInputResource("./src/test/java/spoon/test/type/testclasses");
+		launcher.setSourceOutputDirectory(target);
+		launcher.getEnvironment().setNoClasspath(true);
+		launcher.run();
+
+		final CtClass<Pozole> aPozole = launcher.getFactory().Class().get(Pozole.class);
+		final CtMethod<?> make = aPozole.getMethodsByName("make").get(0);
+
+		final List<CtFieldRead<?>> fieldClasses = make.getElements(new TypeFilter<CtFieldRead<?>>(CtFieldRead.class) {
+			@Override
+			public boolean matches(CtFieldRead<?> element) {
+				return "class".equals(element.getVariable().getSimpleName()) && super.matches(element);
+			}
+		});
+		assertEquals(4, fieldClasses.size());
+		for (CtFieldRead<?> fieldClass : fieldClasses) {
+			assertTrue(fieldClass.getTarget() instanceof CtTypeAccess);
+		}
+
+		TestUtils.canBeBuilt(target, 8, true);
+	}
+
+	@Test
+	public void testTypeAccessOnPrimitive() throws Exception {
+		Factory factory = TestUtils.createFactory();
+		CtClass<?> clazz = factory.Code().createCodeSnippetStatement( //
+				"class X {" //
+						+ "public void foo() {" //
+						+ " Class klass=null;" //
+						+ "  boolean x= (klass == short.class);" //
+						+ "}};").compile();
+		CtMethod<?> foo = (CtMethod<?>) clazz.getMethods().toArray()[0];
+
+		CtBlock<?> body = foo.getBody();
+		CtLocalVariable<?> ass = body.getStatement(1);
+		CtBinaryOperator<?> op = (CtBinaryOperator<?>) ass.getDefaultExpression();
+		assertEquals("Class", op.getLeftHandOperand().getType().getSimpleName());
+		assertFalse(op.getLeftHandOperand().getType().isPrimitive());
+		assertEquals("short", op.getRightHandOperand().getType().getSimpleName());
+		assertTrue(op.getRightHandOperand() instanceof CtFieldRead);
+		assertTrue(op.getRightHandOperand().getType().isPrimitive());
+	}
+}
diff --git a/src/test/java/spoon/test/type/testclasses/Pozole.java b/src/test/java/spoon/test/type/testclasses/Pozole.java
new file mode 100644
index 000000000..1cead6888
--- /dev/null
+++ b/src/test/java/spoon/test/type/testclasses/Pozole.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2006-2015 INRIA and contributors
+ * Spoon - http://spoon.gforge.inria.fr/
+ *
+ * This software is governed by the CeCILL-C License under French law and
+ * abiding by the rules of distribution of free software. You can use, modify
+ * and/or redistribute the software under the terms of the CeCILL-C license as
+ * circulated by CEA, CNRS and INRIA at http://www.cecill.info.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the CeCILL-C License for more details.
+ *
+ * The fact that you are presently reading this means that you have had
+ * knowledge of the CeCILL-C license and that you accept its terms.
+ */
+
+package spoon.test.type.testclasses;
+
+import spoon.test.annotation.testclasses.TypeAnnotation;
+
+import java.lang.annotation.Annotation;
+import java.util.ArrayList;
+import java.util.List;
+
+public class Pozole<A extends Annotation> {
+	@Spice(klass = Pozole.class)
+	public void make() {
+		List<A> list = new ArrayList<@TypeAnnotation(clazz = Float.class, classes = {Integer.class}) A>();
+		addDeliciousIngredient((Class<? extends A>) Annotation.class);
+	}
+
+	void addDeliciousIngredient(java.lang.Class<? extends A> ingredient) {
+	}
+}
diff --git a/src/test/java/spoon/test/type/testclasses/Spice.java b/src/test/java/spoon/test/type/testclasses/Spice.java
new file mode 100644
index 000000000..668ee49aa
--- /dev/null
+++ b/src/test/java/spoon/test/type/testclasses/Spice.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2006-2015 INRIA and contributors
+ * Spoon - http://spoon.gforge.inria.fr/
+ *
+ * This software is governed by the CeCILL-C License under French law and
+ * abiding by the rules of distribution of free software. You can use, modify
+ * and/or redistribute the software under the terms of the CeCILL-C license as
+ * circulated by CEA, CNRS and INRIA at http://www.cecill.info.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the CeCILL-C License for more details.
+ *
+ * The fact that you are presently reading this means that you have had
+ * knowledge of the CeCILL-C license and that you accept its terms.
+ */
+
+package spoon.test.type.testclasses;
+
+public @interface Spice {
+	Class<?> klass();
+}
