diff --git a/src/main/java/spoon/reflect/factory/ExecutableFactory.java b/src/main/java/spoon/reflect/factory/ExecutableFactory.java
index 3e4713f62..e52192b4e 100644
--- a/src/main/java/spoon/reflect/factory/ExecutableFactory.java
+++ b/src/main/java/spoon/reflect/factory/ExecutableFactory.java
@@ -24,6 +24,7 @@ import spoon.reflect.declaration.CtConstructor;
 import spoon.reflect.declaration.CtExecutable;
 import spoon.reflect.declaration.CtMethod;
 import spoon.reflect.declaration.CtParameter;
+import spoon.reflect.declaration.CtType;
 import spoon.reflect.reference.CtExecutableReference;
 import spoon.reflect.reference.CtParameterReference;
 import spoon.reflect.reference.CtTypeReference;
@@ -103,8 +104,7 @@ public class ExecutableFactory extends SubFactory {
 		if (e instanceof CtMethod) {
 			return createReference(((CtMethod<T>) e).getDeclaringType().getReference(), ((CtMethod<T>) e).getType().clone(), e.getSimpleName(), refs);
 		} else if (e instanceof CtLambda) {
-			// A lambda isn't a structural element and doesn't have a declaring type like a method or a constructor.
-			return createReference(null, e.getType(), e.getSimpleName(), refs);
+			return createReference(e.getParent(CtType.class).getReference(), e.getType(), e.getSimpleName(), refs);
 		}
 		return createReference(((CtConstructor<T>) e).getDeclaringType().getReference(), ((CtConstructor<T>) e).getType().clone(), CtExecutableReference.CONSTRUCTOR_NAME, refs);
 	}
diff --git a/src/test/java/spoon/test/reference/VariableAccessTest.java b/src/test/java/spoon/test/reference/VariableAccessTest.java
index 671a3bfb0..93cfd1c01 100644
--- a/src/test/java/spoon/test/reference/VariableAccessTest.java
+++ b/src/test/java/spoon/test/reference/VariableAccessTest.java
@@ -6,7 +6,9 @@ import spoon.reflect.code.CtArrayWrite;
 import spoon.reflect.code.CtLocalVariable;
 import spoon.reflect.code.CtVariableAccess;
 import spoon.reflect.declaration.CtClass;
+import spoon.reflect.declaration.CtExecutable;
 import spoon.reflect.declaration.CtMethod;
+import spoon.reflect.declaration.CtParameter;
 import spoon.reflect.declaration.CtType;
 import spoon.reflect.reference.CtParameterReference;
 import spoon.reflect.reference.CtVariableReference;
@@ -15,6 +17,9 @@ import spoon.reflect.visitor.filter.TypeFilter;
 import spoon.test.reference.testclasses.Pozole;
 import spoon.testing.utils.ModelUtils;
 
+import java.util.List;
+import java.util.stream.Collectors;
+
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.fail;
@@ -70,4 +75,36 @@ public class VariableAccessTest {
 			}
 		});
 	}
+
+	@Test
+	public void testDeclaringTypeOfALambdaReferencedByParameterReference() {
+		final spoon.Launcher launcher = new spoon.Launcher();
+		launcher.addInputResource("src/test/resources/noclasspath/Foo3.java");
+		launcher.getEnvironment().setNoClasspath(true);
+		launcher.getEnvironment().setComplianceLevel(8);
+		launcher.buildModel();
+
+		launcher.getModel().getElements(new TypeFilter<CtExecutable<?>>(CtExecutable.class) {
+			@Override
+			public boolean matches(CtExecutable<?> exec) {
+				final List<CtParameterReference<?>> guiParams = exec.getParameters().stream().map(CtParameter::getReference).collect(Collectors.toList());
+
+				if (guiParams.size() != 1) {
+					return false;
+				}
+
+				final CtParameterReference<?> param = guiParams.get(0);
+
+				exec.getBody().getElements(new TypeFilter<CtParameterReference<?>>(CtParameterReference.class) {
+					@Override
+					public boolean matches(CtParameterReference<?> p) {
+						assertEquals(p, param);
+						return super.matches(p);
+					}
+				});
+
+				return super.matches(exec);
+			}
+		});
+	}
 }
diff --git a/src/test/resources/noclasspath/Foo3.java b/src/test/resources/noclasspath/Foo3.java
new file mode 100644
index 000000000..78cbe94a5
--- /dev/null
+++ b/src/test/resources/noclasspath/Foo3.java
@@ -0,0 +1,18 @@
+import javax.swing.*;
+import java.awt.*;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+import java.util.ArrayList;
+import java.util.List;
+
+class Foo3 {
+	final JButton b = new JButton();
+	final JButton a = new JButton();
+	public Foo() {
+		b.addActionListener(e -> {
+			if(e.getSource()==a) {
+				System.out.println(((JButton) e.getSource()).getName()); // Command 1
+			}
+		});
+	}
+}
\ No newline at end of file
