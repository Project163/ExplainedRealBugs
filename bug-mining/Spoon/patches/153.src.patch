diff --git a/doc/_jekyll/images/references-elements.png b/doc/_jekyll/images/references-elements.png
index ae1c4eac4..5b8924ead 100644
Binary files a/doc/_jekyll/images/references-elements.png and b/doc/_jekyll/images/references-elements.png differ
diff --git a/doc/_jekyll/images/structural-elements.png b/doc/_jekyll/images/structural-elements.png
index adbbb971b..d0528e181 100644
Binary files a/doc/_jekyll/images/structural-elements.png and b/doc/_jekyll/images/structural-elements.png differ
diff --git a/doc/_release/spoon-models.graffle b/doc/_release/spoon-models.graffle
index 9edf80500..2ce7997f6 100644
Binary files a/doc/_release/spoon-models.graffle and b/doc/_release/spoon-models.graffle differ
diff --git a/src/main/java/spoon/reflect/factory/CoreFactory.java b/src/main/java/spoon/reflect/factory/CoreFactory.java
index cbbb9f0c6..141148d2a 100644
--- a/src/main/java/spoon/reflect/factory/CoreFactory.java
+++ b/src/main/java/spoon/reflect/factory/CoreFactory.java
@@ -89,6 +89,7 @@ import spoon.reflect.reference.CtParameterReference;
 import spoon.reflect.reference.CtTypeParameterReference;
 import spoon.reflect.reference.CtTypeReference;
 import spoon.reflect.reference.CtUnboundVariableReference;
+import spoon.reflect.reference.CtWildcardReference;
 
 import java.lang.annotation.Annotation;
 
@@ -408,6 +409,11 @@ public interface CoreFactory {
 	 */
 	CtTypeParameterReference createTypeParameterReference();
 
+	/**
+	 * Creates a wildcard reference.
+	 */
+	CtWildcardReference createWildcardReference();
+
 	/**
 	 * Creates an intersection type reference.
 	 */
diff --git a/src/main/java/spoon/reflect/reference/CtWildcardReference.java b/src/main/java/spoon/reflect/reference/CtWildcardReference.java
new file mode 100644
index 000000000..249972c6f
--- /dev/null
+++ b/src/main/java/spoon/reflect/reference/CtWildcardReference.java
@@ -0,0 +1,25 @@
+/**
+ * Copyright (C) 2006-2016 INRIA and contributors
+ * Spoon - http://spoon.gforge.inria.fr/
+ *
+ * This software is governed by the CeCILL-C License under French law and
+ * abiding by the rules of distribution of free software. You can use, modify
+ * and/or redistribute the software under the terms of the CeCILL-C license as
+ * circulated by CEA, CNRS and INRIA at http://www.cecill.info.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the CeCILL-C License for more details.
+ *
+ * The fact that you are presently reading this means that you have had
+ * knowledge of the CeCILL-C license and that you accept its terms.
+ */
+package spoon.reflect.reference;
+
+/**
+ * Represents a wildcard in generic type annotations, i.e. the "?" (e.g. the "?" in Collection&lt;?&gt; or Collection&lt;? extends List&gt;).
+ */
+public interface CtWildcardReference extends CtTypeParameterReference {
+	@Override
+	CtWildcardReference clone();
+}
diff --git a/src/main/java/spoon/reflect/visitor/CtAbstractVisitor.java b/src/main/java/spoon/reflect/visitor/CtAbstractVisitor.java
index d1b84cae1..cf1586a14 100644
--- a/src/main/java/spoon/reflect/visitor/CtAbstractVisitor.java
+++ b/src/main/java/spoon/reflect/visitor/CtAbstractVisitor.java
@@ -87,6 +87,7 @@ import spoon.reflect.reference.CtParameterReference;
 import spoon.reflect.reference.CtTypeParameterReference;
 import spoon.reflect.reference.CtTypeReference;
 import spoon.reflect.reference.CtUnboundVariableReference;
+import spoon.reflect.reference.CtWildcardReference;
 
 import java.lang.annotation.Annotation;
 
@@ -371,6 +372,11 @@ public abstract class CtAbstractVisitor implements CtVisitor {
 
 	}
 
+	@Override
+	public void visitCtWildcardReference(CtWildcardReference wildcardReference) {
+
+	}
+
 	@Override
 	public <T> void visitCtIntersectionTypeReference(CtIntersectionTypeReference<T> reference) {
 
diff --git a/src/main/java/spoon/reflect/visitor/CtBiScannerDefault.java b/src/main/java/spoon/reflect/visitor/CtBiScannerDefault.java
index 90b8dbe81..c2f77fc93 100644
--- a/src/main/java/spoon/reflect/visitor/CtBiScannerDefault.java
+++ b/src/main/java/spoon/reflect/visitor/CtBiScannerDefault.java
@@ -15,8 +15,10 @@
  * knowledge of the CeCILL-C license and that you accept its terms.
  */
 
+
 package spoon.reflect.visitor;
 
+
 /**
  * This visitor implements a deep-search scan on the model for 2 elements.
  *
@@ -620,6 +622,15 @@ public abstract class CtBiScannerDefault extends spoon.reflect.visitor.CtAbstrac
 		exit(ref);
 	}
 
+	@java.lang.Override
+	public void visitCtWildcardReference(spoon.reflect.reference.CtWildcardReference wildcardReference) {
+		spoon.reflect.reference.CtWildcardReference other = ((spoon.reflect.reference.CtWildcardReference) (stack.peek()));
+		enter(wildcardReference);
+		biScan(wildcardReference.getAnnotations(), other.getAnnotations());
+		biScan(wildcardReference.getBoundingType(), other.getBoundingType());
+		exit(wildcardReference);
+	}
+
 	@java.lang.Override
 	public <T> void visitCtIntersectionTypeReference(final spoon.reflect.reference.CtIntersectionTypeReference<T> reference) {
 		spoon.reflect.reference.CtIntersectionTypeReference other = ((spoon.reflect.reference.CtIntersectionTypeReference) (stack.peek()));
diff --git a/src/main/java/spoon/reflect/visitor/CtInheritanceScanner.java b/src/main/java/spoon/reflect/visitor/CtInheritanceScanner.java
index 5a1f5d55d..7d2d3d665 100644
--- a/src/main/java/spoon/reflect/visitor/CtInheritanceScanner.java
+++ b/src/main/java/spoon/reflect/visitor/CtInheritanceScanner.java
@@ -111,6 +111,7 @@ import spoon.reflect.reference.CtTypeParameterReference;
 import spoon.reflect.reference.CtTypeReference;
 import spoon.reflect.reference.CtUnboundVariableReference;
 import spoon.reflect.reference.CtVariableReference;
+import spoon.reflect.reference.CtWildcardReference;
 
 import java.lang.annotation.Annotation;
 import java.util.Collection;
@@ -773,6 +774,11 @@ public abstract class CtInheritanceScanner implements CtVisitor {
 		visitCtTypeReference(e);
 	}
 
+	@Override
+	public void visitCtWildcardReference(CtWildcardReference wildcardReference) {
+		visitCtTypeParameterReference(wildcardReference);
+	}
+
 	@Override
 	public <T> void visitCtIntersectionTypeReference(CtIntersectionTypeReference<T> e) {
 		visitCtTypeReference(e);
diff --git a/src/main/java/spoon/reflect/visitor/CtScanner.java b/src/main/java/spoon/reflect/visitor/CtScanner.java
index a1c9c0591..2a6c68e6c 100644
--- a/src/main/java/spoon/reflect/visitor/CtScanner.java
+++ b/src/main/java/spoon/reflect/visitor/CtScanner.java
@@ -90,6 +90,7 @@ import spoon.reflect.reference.CtReference;
 import spoon.reflect.reference.CtTypeParameterReference;
 import spoon.reflect.reference.CtTypeReference;
 import spoon.reflect.reference.CtUnboundVariableReference;
+import spoon.reflect.reference.CtWildcardReference;
 
 import java.lang.annotation.Annotation;
 import java.util.Collection;
@@ -715,6 +716,14 @@ public abstract class CtScanner implements CtVisitor {
 		exit(ref);
 	}
 
+	@Override
+	public void visitCtWildcardReference(CtWildcardReference wildcardReference) {
+		enter(wildcardReference);
+		scan(wildcardReference.getAnnotations());
+		scan(wildcardReference.getBoundingType());
+		exit(wildcardReference);
+	}
+
 	@Override
 	public <T> void visitCtIntersectionTypeReference(final CtIntersectionTypeReference<T> reference) {
 		enter(reference);
diff --git a/src/main/java/spoon/reflect/visitor/CtVisitor.java b/src/main/java/spoon/reflect/visitor/CtVisitor.java
index ab13dfd3b..1ff29ae68 100644
--- a/src/main/java/spoon/reflect/visitor/CtVisitor.java
+++ b/src/main/java/spoon/reflect/visitor/CtVisitor.java
@@ -87,6 +87,7 @@ import spoon.reflect.reference.CtParameterReference;
 import spoon.reflect.reference.CtTypeParameterReference;
 import spoon.reflect.reference.CtTypeReference;
 import spoon.reflect.reference.CtUnboundVariableReference;
+import spoon.reflect.reference.CtWildcardReference;
 
 import java.lang.annotation.Annotation;
 
@@ -384,6 +385,11 @@ public interface CtVisitor {
 	 */
 	void visitCtTypeParameterReference(CtTypeParameterReference ref);
 
+	/**
+	 * Visits a reference to a wildcard.
+	 */
+	void visitCtWildcardReference(CtWildcardReference wildcardReference);
+
 	/**
 	 * Visits an intersection type.
 	 */
diff --git a/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java b/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java
index bffb6d863..e2bc8ba69 100644
--- a/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java
+++ b/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java
@@ -101,6 +101,7 @@ import spoon.reflect.reference.CtReference;
 import spoon.reflect.reference.CtTypeParameterReference;
 import spoon.reflect.reference.CtTypeReference;
 import spoon.reflect.reference.CtUnboundVariableReference;
+import spoon.reflect.reference.CtWildcardReference;
 import spoon.reflect.visitor.printer.CommentOffset;
 import spoon.reflect.visitor.printer.ElementPrinterHelper;
 import spoon.reflect.visitor.printer.PrinterHelper;
@@ -1602,6 +1603,11 @@ public class DefaultJavaPrettyPrinter implements CtVisitor, PrettyPrinter {
 		}
 	}
 
+	@Override
+	public void visitCtWildcardReference(CtWildcardReference wildcardReference) {
+		visitCtTypeParameterReference(wildcardReference);
+	}
+
 	private boolean printQualified(CtTypeReference<?> ref) {
 		if (importsContext.isImported(ref)) {
 			// If my.pkg.Something is imported, but we are in the context of a class which is
diff --git a/src/main/java/spoon/support/DefaultCoreFactory.java b/src/main/java/spoon/support/DefaultCoreFactory.java
index ba4078f54..520eb6356 100644
--- a/src/main/java/spoon/support/DefaultCoreFactory.java
+++ b/src/main/java/spoon/support/DefaultCoreFactory.java
@@ -92,6 +92,7 @@ import spoon.reflect.reference.CtParameterReference;
 import spoon.reflect.reference.CtTypeParameterReference;
 import spoon.reflect.reference.CtTypeReference;
 import spoon.reflect.reference.CtUnboundVariableReference;
+import spoon.reflect.reference.CtWildcardReference;
 import spoon.support.reflect.code.CtAnnotationFieldAccessImpl;
 import spoon.support.reflect.code.CtArrayReadImpl;
 import spoon.support.reflect.code.CtArrayWriteImpl;
@@ -164,6 +165,7 @@ import spoon.support.reflect.reference.CtParameterReferenceImpl;
 import spoon.support.reflect.reference.CtTypeParameterReferenceImpl;
 import spoon.support.reflect.reference.CtTypeReferenceImpl;
 import spoon.support.reflect.reference.CtUnboundVariableReferenceImpl;
+import spoon.support.reflect.reference.CtWildcardReferenceImpl;
 import spoon.support.visitor.equals.CloneHelper;
 
 import java.io.Serializable;
@@ -548,6 +550,13 @@ public class DefaultCoreFactory extends SubFactory implements CoreFactory, Seria
 		return e;
 	}
 
+	@Override
+	public CtWildcardReference createWildcardReference() {
+		CtWildcardReference e = new CtWildcardReferenceImpl();
+		e.setFactory(getMainFactory());
+		return e;
+	}
+
 	@Override
 	public <T> CtIntersectionTypeReference<T> createIntersectionTypeReference() {
 		CtIntersectionTypeReference<T> e = new CtIntersectionTypeReferenceImpl<>();
diff --git a/src/main/java/spoon/support/compiler/jdt/ReferenceBuilder.java b/src/main/java/spoon/support/compiler/jdt/ReferenceBuilder.java
index 8c16f2799..eec0af675 100644
--- a/src/main/java/spoon/support/compiler/jdt/ReferenceBuilder.java
+++ b/src/main/java/spoon/support/compiler/jdt/ReferenceBuilder.java
@@ -556,7 +556,7 @@ public class ReferenceBuilder {
 			Pattern pattern = Pattern.compile("([^<]+)<(.+)>");
 			Matcher m = pattern.matcher(name);
 			if (name.startsWith("?")) {
-				main = (CtTypeReference) this.jdtTreeBuilder.getFactory().Core().createTypeParameterReference();
+				main = (CtTypeReference) this.jdtTreeBuilder.getFactory().Core().createWildcardReference();
 			} else {
 				main = this.jdtTreeBuilder.getFactory().Core().createTypeReference();
 			}
@@ -571,7 +571,7 @@ public class ReferenceBuilder {
 			main = this.jdtTreeBuilder.getFactory().Core().createTypeReference();
 			main.setSimpleName(name);
 		} else if (name.startsWith("?")) {
-			return (CtTypeReference) this.jdtTreeBuilder.getFactory().Type().createTypeParameterReference(name);
+			return (CtTypeReference) this.jdtTreeBuilder.getFactory().Core().createWildcardReference();
 		}
 		return main;
 	}
@@ -584,7 +584,7 @@ public class ReferenceBuilder {
 		CtTypeParameterReference param = this.jdtTreeBuilder.getFactory().Core().createTypeParameterReference();
 		if (name.contains("extends") || name.contains("super")) {
 			String[] split = name.contains("extends") ? name.split("extends") : name.split("super");
-			param.setSimpleName(split[0].trim());
+			param = getTypeParameterReference(split[0].trim());
 			param.setBoundingType(getTypeReference(split[split.length - 1].trim()));
 		} else if (name.matches(".*(<.+>)")) {
 			Pattern pattern = Pattern.compile("([^<]+)<(.+)>");
@@ -596,6 +596,8 @@ public class ReferenceBuilder {
 					param.addActualTypeArgument(getTypeParameterReference(parameter.trim()));
 				}
 			}
+		} else if (name.contains("?")) {
+			param = this.jdtTreeBuilder.getFactory().Core().createWildcardReference();
 		} else {
 			param.setSimpleName(name);
 		}
@@ -665,7 +667,7 @@ public class ReferenceBuilder {
 			boolean oldBounds = bounds;
 			ref = this.jdtTreeBuilder.getFactory().Core().createTypeParameterReference();
 			if (binding instanceof CaptureBinding) {
-				ref.setSimpleName("?");
+				ref = this.jdtTreeBuilder.getFactory().Core().createWildcardReference();
 				bounds = true;
 			} else {
 				ref.setSimpleName(new String(binding.sourceName()));
@@ -708,8 +710,7 @@ public class ReferenceBuilder {
 				ref = ref == null ? ref : ref.clone();
 			}
 		} else if (binding instanceof WildcardBinding) {
-			ref = this.jdtTreeBuilder.getFactory().Core().createTypeParameterReference();
-			ref.setSimpleName("?");
+			ref = this.jdtTreeBuilder.getFactory().Core().createWildcardReference();
 			if (((WildcardBinding) binding).boundKind == Wildcard.SUPER && ref instanceof CtTypeParameterReference) {
 				((CtTypeParameterReference) ref).setUpper(false);
 			}
diff --git a/src/main/java/spoon/support/reflect/eval/VisitorPartialEvaluator.java b/src/main/java/spoon/support/reflect/eval/VisitorPartialEvaluator.java
index 34c6e1223..de8ad6422 100644
--- a/src/main/java/spoon/support/reflect/eval/VisitorPartialEvaluator.java
+++ b/src/main/java/spoon/support/reflect/eval/VisitorPartialEvaluator.java
@@ -104,6 +104,7 @@ import spoon.reflect.reference.CtTypeParameterReference;
 import spoon.reflect.reference.CtTypeReference;
 import spoon.reflect.reference.CtUnboundVariableReference;
 import spoon.reflect.reference.CtVariableReference;
+import spoon.reflect.reference.CtWildcardReference;
 import spoon.reflect.visitor.CtVisitor;
 import spoon.support.util.RtHelper;
 
@@ -723,6 +724,11 @@ public class VisitorPartialEvaluator implements CtVisitor, PartialEvaluator {
 		throw new RuntimeException("Unknown Element");
 	}
 
+	@Override
+	public void visitCtWildcardReference(CtWildcardReference wildcardReference) {
+		throw new RuntimeException("Unknown Element");
+	}
+
 	@Override
 	public <T> void visitCtIntersectionTypeReference(CtIntersectionTypeReference<T> reference) {
 		throw new RuntimeException("Unknown Element");
diff --git a/src/main/java/spoon/support/reflect/internal/CtCircularTypeReferenceImpl.java b/src/main/java/spoon/support/reflect/internal/CtCircularTypeReferenceImpl.java
index cd82537c7..e851f3b62 100644
--- a/src/main/java/spoon/support/reflect/internal/CtCircularTypeReferenceImpl.java
+++ b/src/main/java/spoon/support/reflect/internal/CtCircularTypeReferenceImpl.java
@@ -17,6 +17,7 @@
 package spoon.support.reflect.internal;
 
 import spoon.reflect.internal.CtCircularTypeReference;
+import spoon.reflect.reference.CtReference;
 import spoon.reflect.visitor.CtVisitor;
 import spoon.support.reflect.reference.CtTypeParameterReferenceImpl;
 
@@ -26,6 +27,12 @@ public class CtCircularTypeReferenceImpl extends CtTypeParameterReferenceImpl im
 		visitor.visitCtCircularTypeReference(this);
 	}
 
+	@Override
+	public <T extends CtReference> T setSimpleName(String simplename) {
+		this.simplename = simplename;
+		return (T) this;
+	}
+
 	@Override
 	public CtCircularTypeReference clone() {
 		return (CtCircularTypeReference) super.clone();
diff --git a/src/main/java/spoon/support/reflect/reference/CtReferenceImpl.java b/src/main/java/spoon/support/reflect/reference/CtReferenceImpl.java
index 611d488af..38f3efece 100644
--- a/src/main/java/spoon/support/reflect/reference/CtReferenceImpl.java
+++ b/src/main/java/spoon/support/reflect/reference/CtReferenceImpl.java
@@ -31,7 +31,7 @@ public abstract class CtReferenceImpl extends CtElementImpl implements CtReferen
 
 	private static final long serialVersionUID = 1L;
 
-	String simplename;
+	protected String simplename;
 
 	public CtReferenceImpl() {
 		super();
diff --git a/src/main/java/spoon/support/reflect/reference/CtTypeParameterReferenceImpl.java b/src/main/java/spoon/support/reflect/reference/CtTypeParameterReferenceImpl.java
index be8fc7847..74373f50f 100644
--- a/src/main/java/spoon/support/reflect/reference/CtTypeParameterReferenceImpl.java
+++ b/src/main/java/spoon/support/reflect/reference/CtTypeParameterReferenceImpl.java
@@ -18,7 +18,6 @@ package spoon.support.reflect.reference;
 
 import spoon.reflect.reference.CtActualTypeContainer;
 import spoon.reflect.reference.CtIntersectionTypeReference;
-import spoon.reflect.reference.CtReference;
 import spoon.reflect.reference.CtTypeParameterReference;
 import spoon.reflect.reference.CtTypeReference;
 import spoon.reflect.visitor.CtVisitor;
@@ -174,12 +173,6 @@ public class CtTypeParameterReferenceImpl extends CtTypeReferenceImpl<Object> im
 		return null;
 	}
 
-	@Override
-	public <T extends CtReference> T setSimpleName(String simplename) {
-		this.simplename = simplename;
-		return (T) this;
-	}
-
 	@Override
 	public CtTypeParameterReference clone() {
 		return (CtTypeParameterReference) super.clone();
diff --git a/src/main/java/spoon/support/reflect/reference/CtWildcardReferenceImpl.java b/src/main/java/spoon/support/reflect/reference/CtWildcardReferenceImpl.java
new file mode 100644
index 000000000..1607440b9
--- /dev/null
+++ b/src/main/java/spoon/support/reflect/reference/CtWildcardReferenceImpl.java
@@ -0,0 +1,42 @@
+/**
+ * Copyright (C) 2006-2016 INRIA and contributors
+ * Spoon - http://spoon.gforge.inria.fr/
+ *
+ * This software is governed by the CeCILL-C License under French law and
+ * abiding by the rules of distribution of free software. You can use, modify
+ * and/or redistribute the software under the terms of the CeCILL-C license as
+ * circulated by CEA, CNRS and INRIA at http://www.cecill.info.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the CeCILL-C License for more details.
+ *
+ * The fact that you are presently reading this means that you have had
+ * knowledge of the CeCILL-C license and that you accept its terms.
+ */
+package spoon.support.reflect.reference;
+
+import spoon.reflect.reference.CtReference;
+import spoon.reflect.reference.CtWildcardReference;
+import spoon.reflect.visitor.CtVisitor;
+
+public class CtWildcardReferenceImpl extends CtTypeParameterReferenceImpl implements CtWildcardReference {
+	@Override
+	public void accept(CtVisitor visitor) {
+		visitor.visitCtWildcardReference(this);
+	}
+
+	public CtWildcardReferenceImpl() {
+		simplename = "?";
+	}
+
+	@Override
+	public <T extends CtReference> T setSimpleName(String simplename) {
+		return (T) this;
+	}
+
+	@Override
+	public CtWildcardReference clone() {
+		return (CtWildcardReference) super.clone();
+	}
+}
diff --git a/src/main/java/spoon/support/visitor/ShortRepresentationPrinter.java b/src/main/java/spoon/support/visitor/ShortRepresentationPrinter.java
index 94aaa375c..25c49e25d 100644
--- a/src/main/java/spoon/support/visitor/ShortRepresentationPrinter.java
+++ b/src/main/java/spoon/support/visitor/ShortRepresentationPrinter.java
@@ -91,6 +91,7 @@ import spoon.reflect.reference.CtParameterReference;
 import spoon.reflect.reference.CtTypeParameterReference;
 import spoon.reflect.reference.CtTypeReference;
 import spoon.reflect.reference.CtUnboundVariableReference;
+import spoon.reflect.reference.CtWildcardReference;
 import spoon.reflect.visitor.CtVisitor;
 
 import java.lang.annotation.Annotation;
@@ -638,6 +639,11 @@ public class ShortRepresentationPrinter implements CtVisitor {
 		scan(ref.getBoundingType());
 	}
 
+	@Override
+	public void visitCtWildcardReference(CtWildcardReference wildcardReference) {
+		visitCtTypeParameterReference(wildcardReference);
+	}
+
 	@Override
 	public <T> void visitCtIntersectionTypeReference(CtIntersectionTypeReference<T> reference) {
 		for (CtTypeReference<?> ctTypeReference : reference.getBounds()) {
diff --git a/src/main/java/spoon/support/visitor/clone/CloneVisitor.java b/src/main/java/spoon/support/visitor/clone/CloneVisitor.java
index f23924793..bdb9b085f 100644
--- a/src/main/java/spoon/support/visitor/clone/CloneVisitor.java
+++ b/src/main/java/spoon/support/visitor/clone/CloneVisitor.java
@@ -625,6 +625,15 @@ public class CloneVisitor extends spoon.reflect.visitor.CtScanner {
 		this.other = aCtTypeParameterReference;
 	}
 
+	// auto-generated, see spoon.generating.CloneVisitorGenerator
+	@java.lang.Override
+	public void visitCtWildcardReference(spoon.reflect.reference.CtWildcardReference wildcardReference) {
+		spoon.reflect.reference.CtWildcardReference aCtWildcardReference = spoon.support.visitor.clone.CloneBuilder.build(this.builder, wildcardReference, wildcardReference.getFactory().Core().createWildcardReference());
+		aCtWildcardReference.setAnnotations(spoon.support.visitor.equals.CloneHelper.clone(wildcardReference.getAnnotations()));
+		aCtWildcardReference.setBoundingType(spoon.support.visitor.equals.CloneHelper.clone(wildcardReference.getBoundingType()));
+		this.other = aCtWildcardReference;
+	}
+
 	// auto-generated, see spoon.generating.CloneVisitorGenerator
 	@java.lang.Override
 	public <T> void visitCtIntersectionTypeReference(final spoon.reflect.reference.CtIntersectionTypeReference<T> reference) {
diff --git a/src/main/java/spoon/support/visitor/equals/EqualsVisitor.java b/src/main/java/spoon/support/visitor/equals/EqualsVisitor.java
index 760bcf5e0..75350a6e0 100644
--- a/src/main/java/spoon/support/visitor/equals/EqualsVisitor.java
+++ b/src/main/java/spoon/support/visitor/equals/EqualsVisitor.java
@@ -583,6 +583,15 @@ public class EqualsVisitor extends spoon.reflect.visitor.CtAbstractBiScanner {
 		exit(ref);
 	}
 
+	@java.lang.Override
+	public void visitCtWildcardReference(spoon.reflect.reference.CtWildcardReference wildcardReference) {
+		spoon.reflect.reference.CtWildcardReference other = ((spoon.reflect.reference.CtWildcardReference) (stack.peek()));
+		enter(wildcardReference);
+		biScan(wildcardReference.getAnnotations(), other.getAnnotations());
+		biScan(wildcardReference.getBoundingType(), other.getBoundingType());
+		exit(wildcardReference);
+	}
+
 	@java.lang.Override
 	public <T> void visitCtIntersectionTypeReference(final spoon.reflect.reference.CtIntersectionTypeReference<T> reference) {
 		spoon.reflect.reference.CtIntersectionTypeReference other = ((spoon.reflect.reference.CtIntersectionTypeReference) (stack.peek()));
diff --git a/src/main/java/spoon/support/visitor/java/JavaReflectionTreeBuilder.java b/src/main/java/spoon/support/visitor/java/JavaReflectionTreeBuilder.java
index f8213ebb8..12d7037a7 100644
--- a/src/main/java/spoon/support/visitor/java/JavaReflectionTreeBuilder.java
+++ b/src/main/java/spoon/support/visitor/java/JavaReflectionTreeBuilder.java
@@ -36,6 +36,7 @@ import spoon.reflect.reference.CtExecutableReference;
 import spoon.reflect.reference.CtFieldReference;
 import spoon.reflect.reference.CtTypeParameterReference;
 import spoon.reflect.reference.CtTypeReference;
+import spoon.reflect.reference.CtWildcardReference;
 import spoon.support.visitor.java.internal.AnnotationRuntimeBuilderContext;
 import spoon.support.visitor.java.internal.ExecutableRuntimeBuilderContext;
 import spoon.support.visitor.java.internal.PackageRuntimeBuilderContext;
@@ -341,15 +342,14 @@ public class JavaReflectionTreeBuilder extends JavaReflectionVisitorImpl {
 
 	@Override
 	public void visitType(WildcardType type) {
-		final CtTypeParameterReference ctTypeReference = factory.Core().createTypeParameterReference();
-		ctTypeReference.setSimpleName("?");
-		ctTypeReference.setUpper(type.getUpperBounds() != null && !type.getUpperBounds()[0].equals(Object.class));
+		final CtWildcardReference wildcard = factory.Core().createWildcardReference();
+		wildcard.setUpper(type.getUpperBounds() != null && !type.getUpperBounds()[0].equals(Object.class));
 
-		enter(new TypeReferenceRuntimeBuilderContext(ctTypeReference));
+		enter(new TypeReferenceRuntimeBuilderContext(wildcard));
 		super.visitType(type);
 		exit();
 
-		contexts.peek().addTypeName(ctTypeReference);
+		contexts.peek().addTypeName(wildcard);
 	}
 
 	private String getTypeName(Type type) {
diff --git a/src/main/java/spoon/support/visitor/replace/ReplacementVisitor.java b/src/main/java/spoon/support/visitor/replace/ReplacementVisitor.java
index 76594f73f..5a8322ec6 100644
--- a/src/main/java/spoon/support/visitor/replace/ReplacementVisitor.java
+++ b/src/main/java/spoon/support/visitor/replace/ReplacementVisitor.java
@@ -1619,6 +1619,12 @@ public class ReplacementVisitor extends spoon.reflect.visitor.CtScanner {
 		replaceElementIfExist(ref.getBoundingType(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypeParameterReferenceBoundingTypeReplaceListener(ref));
 	}
 
+	@java.lang.Override
+	public void visitCtWildcardReference(spoon.reflect.reference.CtWildcardReference wildcardReference) {
+		replaceInListIfExist(wildcardReference.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(wildcardReference));
+		replaceElementIfExist(wildcardReference.getBoundingType(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypeParameterReferenceBoundingTypeReplaceListener(wildcardReference));
+	}
+
 	@java.lang.Override
 	public <T> void visitCtIntersectionTypeReference(final spoon.reflect.reference.CtIntersectionTypeReference<T> reference) {
 		replaceInSetIfExist(reference.getBounds(), new spoon.support.visitor.replace.ReplacementVisitor.CtIntersectionTypeReferenceBoundsReplaceListener(reference));
diff --git a/src/test/java/spoon/test/generics/GenericsTest.java b/src/test/java/spoon/test/generics/GenericsTest.java
index 3ab2d7cac..6afd57b08 100644
--- a/src/test/java/spoon/test/generics/GenericsTest.java
+++ b/src/test/java/spoon/test/generics/GenericsTest.java
@@ -23,6 +23,7 @@ import spoon.reflect.declaration.CtType;
 import spoon.reflect.factory.Factory;
 import spoon.reflect.reference.CtTypeParameterReference;
 import spoon.reflect.reference.CtTypeReference;
+import spoon.reflect.reference.CtWildcardReference;
 import spoon.reflect.visitor.DefaultJavaPrettyPrinter;
 import spoon.reflect.visitor.filter.AbstractFilter;
 import spoon.reflect.visitor.filter.NameFilter;
@@ -30,6 +31,7 @@ import spoon.reflect.visitor.filter.ReferenceTypeFilter;
 import spoon.reflect.visitor.filter.TypeFilter;
 import spoon.support.StandardEnvironment;
 import spoon.test.generics.testclasses.Mole;
+import spoon.test.generics.testclasses.Paella;
 import spoon.test.generics.testclasses.Panini;
 import spoon.test.generics.testclasses.Spaghetti;
 import spoon.test.generics.testclasses.Tacos;
@@ -510,4 +512,9 @@ public class GenericsTest {
 		assertEquals(1, newPrepare.getType().getActualTypeArguments().size());
 		assertEquals("java.lang.String", newPrepare.getType().getActualTypeArguments().get(0).toString());
 	}
+
+	@Test
+	public void testWildcard() throws Exception {
+		assertEquals(3, buildClass(Paella.class).getElements(new TypeFilter<CtWildcardReference>(CtWildcardReference.class)).size());
+	}
 }
diff --git a/src/test/java/spoon/test/generics/testclasses/Paella.java b/src/test/java/spoon/test/generics/testclasses/Paella.java
new file mode 100644
index 000000000..928384d5d
--- /dev/null
+++ b/src/test/java/spoon/test/generics/testclasses/Paella.java
@@ -0,0 +1,12 @@
+package spoon.test.generics.testclasses;
+
+import java.util.Comparator;
+
+public class Paella<T extends Comparator<? extends String>> {
+	public <T extends Comparator<? extends String>> Paella() {
+	}
+
+	public <T extends Comparator<? extends String>> T make() {
+		return null;
+	}
+}
