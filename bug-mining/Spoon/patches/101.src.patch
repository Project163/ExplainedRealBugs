diff --git a/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java b/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
index 224f3a0df..a1f0ea0af 100644
--- a/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
+++ b/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
@@ -228,6 +228,8 @@ import java.util.Set;
 import java.util.Stack;
 import java.util.TreeMap;
 import java.util.TreeSet;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
 
 import static spoon.reflect.ModelElementContainerDefaultCapacities.CASTS_CONTAINER_DEFAULT_CAPACITY;
 
@@ -529,12 +531,127 @@ public class JDTTreeBuilder extends ASTVisitor {
 
 		public <T> CtTypeReference<T> getTypeReference(TypeBinding binding, TypeReference ref) {
 			CtTypeReference<T> ctRef = getTypeReference(binding);
-			if (ctRef != null) {
+			if (ctRef != null && isCorrectTypeReference(ref)) {
+				insertGenericTypesInNoClasspathFromJDTInSpoon(ref, ctRef);
 				return ctRef;
 			}
-			ctRef = factory.Core().createTypeReference();
-			ctRef.setSimpleName(new String(createTypeName(ref.getTypeName())));
-			return ctRef;
+			return getTypeReference(ref);
+		}
+
+		/**
+		 * In no classpath, the model of the super interface isn't always correct.
+		 */
+		private boolean isCorrectTypeReference(TypeReference ref) {
+			if (ref.resolvedType == null) {
+				return false;
+			}
+			if (!(ref.resolvedType instanceof ProblemReferenceBinding)) {
+				return true;
+			}
+			final String[] compoundName = CharOperation.charArrayToStringArray(((ProblemReferenceBinding) ref.resolvedType).compoundName);
+			final String[] typeName = CharOperation.charArrayToStringArray(ref.getTypeName());
+			if (compoundName.length == 0 || typeName.length == 0) {
+				return false;
+			}
+			return compoundName[compoundName.length - 1].equals(typeName[typeName.length - 1]);
+		}
+
+		private <T> void insertGenericTypesInNoClasspathFromJDTInSpoon(TypeReference original, CtTypeReference<T> type) {
+			if (original.resolvedType instanceof ProblemReferenceBinding && original.getTypeArguments() != null) {
+				for (TypeReference[] typeReferences : original.getTypeArguments()) {
+					for (TypeReference typeReference : typeReferences) {
+						type.addActualTypeArgument(references.getTypeReference(typeReference.resolvedType));
+					}
+				}
+			}
+		}
+
+		/**
+		 * JDT doesn't returns a correct AST with the resolved type of the reference.
+		 * This method try to build a correct Spoon AST from the name of the JDT
+		 * reference, thanks to the parsing of the string, the name parameterized from
+		 * the JDT reference and java convention.
+		 * Returns a complete Spoon AST when the name is correct, otherwise a spoon type
+		 * reference with a name that correspond to the name of the JDT type reference.
+		 */
+		public <T> CtTypeReference<T> getTypeReference(TypeReference ref) {
+			CtTypeReference<T> res = null;
+			CtReference current = null;
+			final String[] namesParameterized = CharOperation.charArrayToStringArray(ref.getParameterizedTypeName());
+			for (int index = namesParameterized.length - 1; index >= 0; index--) {
+				// Start at the end to get the class name first.
+				CtReference main = getTypeReference(namesParameterized[index]);
+				if (main == null) {
+					main = factory.Package().createReference(namesParameterized[index]);
+				}
+				if (main instanceof CtTypeReference && index == namesParameterized.length - 1) {
+					res = (CtTypeReference<T>) main;
+				}
+				if (main instanceof CtPackageReference) {
+					if (current instanceof CtTypeReference) {
+						((CtTypeReference<T>) current).setPackage((CtPackageReference) main);
+					} else if (current instanceof CtPackage) {
+						((CtPackage) current).addPackage((CtPackage) main);
+					}
+				} else if (current instanceof CtTypeReference) {
+					((CtTypeReference) current).setDeclaringType((CtTypeReference<?>) main);
+				}
+				current = main;
+			}
+			if (res == null) {
+				return factory.Type().<T>createReference(CharOperation.toString(ref.getParameterizedTypeName()));
+			}
+			return res;
+		}
+
+		/**
+		 * Try to build a CtTypeReference from a simple name with specified generic types but
+		 * returns null if the name doesn't correspond to a type (not start by an upper case).
+		 */
+		public <T> CtTypeReference<T> getTypeReference(String name) {
+			CtTypeReference<T> main = null;
+			if (name.matches(".*(<.+>)")) {
+				main = factory.Core().createTypeReference();
+				Pattern pattern = Pattern.compile("([^<]+)<(.+)>");
+				Matcher m = pattern.matcher(name);
+				if (m.find()) {
+					main.setSimpleName(m.group(1));
+					final String[] split = m.group(2).split(",");
+					for (String parameter : split) {
+						((CtTypeReference) main).addActualTypeArgument(getTypeParameterReference(parameter.trim()));
+					}
+				}
+			} else if (Character.isUpperCase(name.charAt(0))) {
+				main = factory.Core().createTypeReference();
+				main.setSimpleName(name);
+			}
+			return main;
+		}
+
+		/**
+		 * Try to build a CtTypeParameterReference from a single name with specified generic types but
+		 * keep in mind that if you give wrong data in the strong, reference will be wrong.
+		 */
+		public CtTypeParameterReference getTypeParameterReference(String name) {
+			CtTypeParameterReference param = factory.Core().createTypeParameterReference();
+			if (name.contains("extends") || name.contains("super")) {
+				String[] split = name.contains("extends") ? name.split("extends") : name.split("super");
+				param.setSimpleName(split[0].trim());
+				param.addBound(getTypeReference(split[split.length - 1].trim()));
+			} else if (name.matches(".*(<.+>)")) {
+				Pattern pattern = Pattern.compile("([^<]+)<(.+)>");
+				Matcher m = pattern.matcher(name);
+				if (m.find()) {
+					param.setSimpleName(m.group(1));
+					final String[] split = m.group(2).split(",");
+					for (String parameter : split) {
+						param.addActualTypeArgument(getTypeParameterReference(parameter.trim()));
+					}
+				}
+			} else {
+				param.setSimpleName(name);
+			}
+			return param;
 		}
 
 		@SuppressWarnings("unchecked")
@@ -1028,9 +1145,7 @@ public class JDTTreeBuilder extends ASTVisitor {
 			CtEnum<?> e = factory.Core().createEnum();
 			if (typeDeclaration.superInterfaces != null) {
 				for (TypeReference ref : typeDeclaration.superInterfaces) {
-					final CtTypeReference<Object> currentInterface = references.getTypeReference(ref.resolvedType);
-					e.addSuperInterface(currentInterface);
-					insertGenericTypesInNoClasspathFromJDTInSpoon(ref, currentInterface);
+					e.addSuperInterface(references.getTypeReference(ref.resolvedType, ref));
 				}
 			}
 			type = e;
@@ -1038,9 +1153,7 @@ public class JDTTreeBuilder extends ASTVisitor {
 			CtInterface<?> interf = factory.Core().createInterface();
 			if (typeDeclaration.superInterfaces != null) {
 				for (TypeReference ref : typeDeclaration.superInterfaces) {
-					final CtTypeReference<Object> currentInterface = references.getTypeReference(ref.resolvedType);
-					interf.addSuperInterface(currentInterface);
-					insertGenericTypesInNoClasspathFromJDTInSpoon(ref, currentInterface);
+					interf.addSuperInterface(references.getTypeReference(ref.resolvedType, ref));
 				}
 			}
 			if (typeDeclaration.typeParameters != null) {
@@ -1068,9 +1181,7 @@ public class JDTTreeBuilder extends ASTVisitor {
 				}
 			}
 			if (typeDeclaration.superclass != null) {
-				final CtTypeReference<Object> superClass = references.getTypeReference(typeDeclaration.superclass.resolvedType);
-				cl.setSuperclass(superClass);
-				insertGenericTypesInNoClasspathFromJDTInSpoon(typeDeclaration.superclass, superClass);
+				cl.setSuperclass(references.getTypeReference(typeDeclaration.superclass.resolvedType, typeDeclaration.superclass));
 			}
 
 			// If the current class is an anonymous class with a super interface and generic types, we add generic
@@ -1090,9 +1201,7 @@ public class JDTTreeBuilder extends ASTVisitor {
 
 			if (typeDeclaration.superInterfaces != null) {
 				for (TypeReference ref : typeDeclaration.superInterfaces) {
-					final CtTypeReference<Object> currentInterface = references.getTypeReference(ref.resolvedType);
-					cl.addSuperInterface(currentInterface);
-					insertGenericTypesInNoClasspathFromJDTInSpoon(ref, currentInterface);
+					cl.addSuperInterface(references.getTypeReference(ref.resolvedType, ref));
 				}
 			}
 			if (typeDeclaration.typeParameters != null) {
@@ -1120,16 +1229,6 @@ public class JDTTreeBuilder extends ASTVisitor {
 		return type;
 	}
 
-	private void insertGenericTypesInNoClasspathFromJDTInSpoon(TypeReference original, CtTypeReference<Object> type) {
-		if (original.resolvedType instanceof ProblemReferenceBinding && original.getTypeArguments() != null) {
-			for (TypeReference[] typeReferences : original.getTypeArguments()) {
-				for (TypeReference typeReference : typeReferences) {
-					type.addActualTypeArgument(references.getTypeReference(typeReference.resolvedType));
-				}
-			}
-		}
-	}
-
 	class SpoonReferenceBinding extends ReferenceBinding {
 		private ReferenceBinding enclosingType;
 
diff --git a/src/test/java/spoon/test/constructorcallnewclass/NewClassTest.java b/src/test/java/spoon/test/constructorcallnewclass/NewClassTest.java
index a380ccf6e..2cd23dc96 100644
--- a/src/test/java/spoon/test/constructorcallnewclass/NewClassTest.java
+++ b/src/test/java/spoon/test/constructorcallnewclass/NewClassTest.java
@@ -157,7 +157,10 @@ public class NewClassTest {
 		final CtClass anonymousClass = ctNewClass.getAnonymousClass();
 		assertNotNull(anonymousClass);
 		assertNotNull(anonymousClass.getSuperclass());
-		assertEquals("Lock.With", anonymousClass.getSuperclass().getSimpleName());
+		assertEquals("With", anonymousClass.getSuperclass().getSimpleName());
+		assertEquals("Lock$With", anonymousClass.getSuperclass().getQualifiedName());
+		assertEquals("Lock", anonymousClass.getSuperclass().getDeclaringType().getSimpleName());
+		assertEquals("Lock.With", anonymousClass.getSuperclass().toString());
 		assertNull(anonymousClass.getSimpleName()); // In noclasspath, we don't have this information.
 		assertEquals(1, anonymousClass.getMethods().size());
 
diff --git a/src/test/java/spoon/test/reference/TypeReferenceTest.java b/src/test/java/spoon/test/reference/TypeReferenceTest.java
index 01c64b916..41ec65733 100644
--- a/src/test/java/spoon/test/reference/TypeReferenceTest.java
+++ b/src/test/java/spoon/test/reference/TypeReferenceTest.java
@@ -318,6 +318,35 @@ public class TypeReferenceTest {
 		}
 	}
 
+	@Test
+	public void testTypeReferenceSpecifiedInClassDeclarationInNoClasspathWithGenerics() throws Exception {
+		// contract: Gets the import of a type specified in the declaration of a class.
+		final Launcher launcher = new Launcher();
+		launcher.addInputResource("./src/test/resources/noclasspath/Demo2.java");
+		launcher.setSourceOutputDirectory("./target/class-declaration");
+		launcher.getEnvironment().setNoClasspath(true);
+		launcher.run();
+
+		final CtClass<Object> aClass = launcher.getFactory().Class().get("Demo2");
+		Set<CtTypeReference<?>> superInterfaces = aClass.getSuperInterfaces();
+		final CtTypeReference superInterface = superInterfaces.toArray(new CtTypeReference[superInterfaces.size()])[0];
+		assertEquals("Bar", superInterface.getSimpleName());
+		assertEquals(2, superInterface.getActualTypeArguments().size());
+		final CtTypeReference<?> first = superInterface.getActualTypeArguments().get(0);
+		assertTrue(first instanceof CtTypeParameterReference);
+		assertEquals("?", first.getSimpleName());
+		final CtTypeReference<?> second = superInterface.getActualTypeArguments().get(1);
+		assertTrue(second instanceof CtTypeParameterReference);
+		assertEquals("?", second.getSimpleName());
+		final List<CtTypeReference<?>> bounds = ((CtTypeParameterReference) second).getBounds();
+		assertEquals(1, bounds.size());
+		assertEquals("Tacos", bounds.get(0).getSimpleName());
+		assertEquals(1, bounds.get(0).getActualTypeArguments().size());
+		assertEquals("?", bounds.get(0).getActualTypeArguments().get(0).getSimpleName());
+		assertEquals("example.FooBar", superInterface.getDeclaringType().getQualifiedName());
+		assertEquals("example.FooBar<?, ? extends Tacos<?>>.Bar<?, ? extends Tacos<?>>", superInterface.toString());
+	}
+
 	class A {
 		class Tacos<K> {
 		}
diff --git a/src/test/resources/noclasspath/Demo2.java b/src/test/resources/noclasspath/Demo2.java
new file mode 100644
index 000000000..22d089948
--- /dev/null
+++ b/src/test/resources/noclasspath/Demo2.java
@@ -0,0 +1,4 @@
+
+public class Demo2 implements example.FooBar<?, ? extends Tacos<?>>.Bar<?, ? extends Tacos<?>> {
+
+}
\ No newline at end of file
