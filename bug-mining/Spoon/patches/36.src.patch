diff --git a/src/main/java/spoon/processing/AbstractAnnotationProcessor.java b/src/main/java/spoon/processing/AbstractAnnotationProcessor.java
index 6fa1cfba6..bbb39a261 100644
--- a/src/main/java/spoon/processing/AbstractAnnotationProcessor.java
+++ b/src/main/java/spoon/processing/AbstractAnnotationProcessor.java
@@ -28,10 +28,13 @@ import java.util.TreeSet;
 import spoon.Launcher;
 import spoon.reflect.declaration.CtAnnotation;
 import spoon.reflect.declaration.CtElement;
+import spoon.reflect.declaration.CtType;
+import spoon.reflect.declaration.CtTypedElement;
+import spoon.reflect.visitor.TypeAnnotationVisitor;
 
 /**
  * This class defines an abstract annotation processor to be subclassed by the
- * user for defining new annotation processors.
+ * user for defining new annotation processors including Java 8 annotations.
  */
 public abstract class AbstractAnnotationProcessor<A extends Annotation, E extends CtElement>
 		extends AbstractProcessor<E> implements AnnotationProcessor<A, E> {
@@ -40,6 +43,8 @@ public abstract class AbstractAnnotationProcessor<A extends Annotation, E extend
 
 	Map<String, Class<? extends A>> processedAnnotationTypes = new TreeMap<String, Class<? extends A>>();
 
+	private TypeAnnotationVisitor visitor;
+
 	/**
 	 * Empty constructor only for all processors (invoked by Spoon).
 	 */
@@ -137,24 +142,32 @@ public abstract class AbstractAnnotationProcessor<A extends Annotation, E extend
 	 */
 	@Override
 	final public boolean isToBeProcessed(E element) {
+		boolean isToBeProcessed = false;
 		if ((element != null) && (element.getAnnotations() != null)) {
-			for (CtAnnotation<? extends Annotation> a : element
-					.getAnnotations()) {
+			for (CtAnnotation<? extends Annotation> a : element.getAnnotations()) {
 				if (shoudBeProcessed(a)) {
-					return true;
+					isToBeProcessed = true;
 				}
 			}
 		}
-		return false;
+
+		if (!(element instanceof CtTypedElement) && !(element instanceof CtType)) {
+			return isToBeProcessed;
+		}
+
+		visitor = new TypeAnnotationVisitor(isToBeProcessed);
+		visitor.scan(element);
+		return visitor.isToBeProcessed();
 	}
 
 	@SuppressWarnings("unchecked")
 	final public void process(E element) {
-		for (CtAnnotation<? extends Annotation> annotation : new ArrayList<CtAnnotation<?>>(
-				element.getAnnotations())) {
+		boolean alreadyProcessed = false;
+		for (CtAnnotation<? extends Annotation> annotation : visitor.getAnnotations()) {
 			if (shoudBeProcessed(annotation)) {
 				try {
 					process((A) annotation.getActualAnnotation(), element);
+					alreadyProcessed = true;
 				} catch (Exception e) {
 					Launcher.logger.error(e.getMessage(), e);
 				}
@@ -163,6 +176,21 @@ public abstract class AbstractAnnotationProcessor<A extends Annotation, E extend
 				}
 			}
 		}
+		if (!alreadyProcessed) {
+			for (CtAnnotation<? extends Annotation> annotation : new ArrayList<CtAnnotation<?>>(
+					element.getAnnotations())) {
+				if (shoudBeProcessed(annotation)) {
+					try {
+						process((A) annotation.getActualAnnotation(), element);
+					} catch (Exception e) {
+						Launcher.logger.error(e.getMessage(), e);
+					}
+					if (shoudBeConsumed(annotation)) {
+						element.removeAnnotation(annotation);
+					}
+				}
+			}
+		}
 	}
 
 	/**
@@ -172,20 +200,14 @@ public abstract class AbstractAnnotationProcessor<A extends Annotation, E extend
 	 */
 	@Override
 	public boolean shoudBeConsumed(CtAnnotation<? extends Annotation> annotation) {
-		if (consumedAnnotationTypes.containsKey(annotation.getAnnotationType()
-				.getQualifiedName())) {
-			return true;
-		}
-		return false;
+		return consumedAnnotationTypes.containsKey(annotation.getAnnotationType()
+															 .getQualifiedName());
 	}
 
-	private boolean shoudBeProcessed(
+	protected boolean shoudBeProcessed(
 			CtAnnotation<? extends Annotation> annotation) {
-		if (processedAnnotationTypes.containsKey(annotation.getAnnotationType()
-				.getQualifiedName())) {
-			return true;
-		}
-		return false;
+		return processedAnnotationTypes.containsKey(annotation.getAnnotationType()
+															  .getQualifiedName());
 	}
 
 }
diff --git a/src/main/java/spoon/reflect/visitor/TypeAnnotationVisitor.java b/src/main/java/spoon/reflect/visitor/TypeAnnotationVisitor.java
new file mode 100644
index 000000000..b2087d734
--- /dev/null
+++ b/src/main/java/spoon/reflect/visitor/TypeAnnotationVisitor.java
@@ -0,0 +1,107 @@
+package spoon.reflect.visitor;
+
+import spoon.reflect.code.CtExpression;
+import spoon.reflect.declaration.CtAnnotation;
+import spoon.reflect.declaration.CtExecutable;
+import spoon.reflect.declaration.CtGenericElement;
+import spoon.reflect.declaration.CtTypeInformation;
+import spoon.reflect.declaration.CtTypedElement;
+import spoon.reflect.reference.CtTypeReference;
+
+import java.lang.annotation.Annotation;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+/**
+ * Visitor used to get all type annotations (integrated by the Java 8 version).
+ */
+public class TypeAnnotationVisitor extends CtInheritanceScanner {
+	private final Set<CtAnnotation<? extends Annotation>> annotations =
+			new HashSet<CtAnnotation<? extends Annotation>>();
+	private boolean isToBeProcessed;
+
+	public TypeAnnotationVisitor(boolean isToBeProcessed) {
+		this.isToBeProcessed = isToBeProcessed;
+	}
+
+	@Override
+	public <T> void scanCtExpression(CtExpression<T> expression) {
+		super.scanCtExpression(expression);
+
+		if (!isToBeProcessed && expression.getTypeCasts().size() > 0) {
+			isToBeProcessed = iterateOnTypeReference(expression.getTypeCasts());
+		}
+	}
+
+	@Override
+	public <R> void scanCtExecutable(CtExecutable<R> e) {
+		super.scanCtExecutable(e);
+
+		if (!isToBeProcessed &&  e.getThrownTypes().size() > 0) {
+			isToBeProcessed = iterateOnTypeReference(((CtExecutable) e).getThrownTypes());
+		}
+	}
+
+	@Override
+	public void scanCtGenericElement(CtGenericElement e) {
+		super.scanCtGenericElement(e);
+
+		if (!isToBeProcessed) {
+			isToBeProcessed = iterateOnTypeReference(e.getFormalTypeParameters());
+		}
+	}
+
+	@Override
+	public <T> void scanCtTypeInformation(CtTypeInformation typeInfo) {
+		super.scanCtTypeInformation(typeInfo);
+
+		if (!isToBeProcessed) {
+			if (typeInfo.getSuperclass() != null) {
+				isToBeProcessed = typeInfo.getSuperclass().getTypeAnnotations().size() > 0;
+				if (isToBeProcessed) {
+					annotations.addAll(typeInfo.getSuperclass().getTypeAnnotations());
+				}
+			}
+			if (typeInfo.getSuperInterfaces() != null && !isToBeProcessed) {
+				isToBeProcessed = iterateOnTypeReference(typeInfo.getSuperInterfaces());
+			}
+		}
+	}
+
+	@Override
+	public <T> void scanCtTypedElement(CtTypedElement<T> e) {
+		super.scanCtTypedElement(e);
+
+		if (!isToBeProcessed && e.getType() != null) {
+			isToBeProcessed = e.getType().getTypeAnnotations().size() > 0;
+			if (isToBeProcessed) {
+				annotations.addAll(e.getType().getTypeAnnotations());
+			}
+			final List<CtTypeReference<?>> typeArguments = e.getType().getActualTypeArguments();
+			if (typeArguments.size() > 0 && !isToBeProcessed) {
+				isToBeProcessed = iterateOnTypeReference(typeArguments);
+			}
+		}
+	}
+
+	private boolean iterateOnTypeReference(Iterable<CtTypeReference<?>> typeReferences) {
+		boolean isToBeProcessed = false;
+		for (CtTypeReference<?> ref: typeReferences) {
+			isToBeProcessed = ref.getTypeAnnotations().size() > 0;
+			if (isToBeProcessed) {
+				annotations.addAll(ref.getTypeAnnotations());
+				break;
+			}
+		}
+		return isToBeProcessed;
+	}
+
+	public boolean isToBeProcessed() {
+		return isToBeProcessed;
+	}
+
+	public Set<CtAnnotation<? extends Annotation>> getAnnotations() {
+		return annotations;
+	}
+}
diff --git a/src/test/java/spoon/test/annotation/AnnotationTest.java b/src/test/java/spoon/test/annotation/AnnotationTest.java
index 1ad550190..604fb0345 100644
--- a/src/test/java/spoon/test/annotation/AnnotationTest.java
+++ b/src/test/java/spoon/test/annotation/AnnotationTest.java
@@ -10,6 +10,7 @@ import java.io.File;
 import java.lang.annotation.Annotation;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+import java.util.ArrayList;
 import java.util.List;
 import java.util.Set;
 
@@ -17,6 +18,8 @@ import org.junit.Before;
 import org.junit.Test;
 
 import spoon.Launcher;
+import spoon.processing.AbstractAnnotationProcessor;
+import spoon.processing.ProcessingManager;
 import spoon.reflect.code.CtBlock;
 import spoon.reflect.code.CtConstructorCall;
 import spoon.reflect.code.CtExpression;
@@ -45,6 +48,7 @@ import spoon.reflect.visitor.DefaultJavaPrettyPrinter;
 import spoon.reflect.visitor.filter.AbstractFilter;
 import spoon.reflect.visitor.filter.NameFilter;
 import spoon.reflect.visitor.filter.TypeFilter;
+import spoon.support.QueueProcessingManager;
 import spoon.test.TestUtils;
 import spoon.test.annotation.testclasses.AnnotArray;
 import spoon.test.annotation.testclasses.AnnotParamTypeEnum;
@@ -58,6 +62,7 @@ import spoon.test.annotation.testclasses.Foo;
 import spoon.test.annotation.testclasses.Foo.InnerAnnotation;
 import spoon.test.annotation.testclasses.Foo.MiddleAnnotation;
 import spoon.test.annotation.testclasses.Foo.OuterAnnotation;
+import spoon.test.annotation.testclasses.GlobalAnnotation;
 import spoon.test.annotation.testclasses.InnerAnnot;
 import spoon.test.annotation.testclasses.Main;
 import spoon.test.annotation.testclasses.TestInterface;
@@ -535,7 +540,9 @@ public class AnnotationTest {
 		final CtMethod<?> method = ctClass.getMethodsByName("m4").get(0);
 		final List<CtTypeReference<?>> formalTypeParameters = method.getFormalTypeParameters();
 		assertEquals("Method has 1 generic parameter", 1, formalTypeParameters.size());
-		assertEquals("Method with an type annotation must be well printed", "@spoon.test.annotation.testclasses.TypeAnnotation" + System.lineSeparator() + "T", formalTypeParameters.get(0).toString());
+		assertEquals("Method with an type annotation must be well printed",
+					 "@spoon.test.annotation.testclasses.TypeAnnotation" + System.lineSeparator()
+							 + "T", formalTypeParameters.get(0).toString());
 
 		final CtBlock<?> body = method.getBody();
 		final String expectedFirstStatement =
@@ -731,6 +738,84 @@ public class AnnotationTest {
 		assertEquals(2,annot.value().length);
 	}
 
+	@Test
+	public void testAbstractAllAnnotationProcessor() throws Exception {
+		Launcher spoon = new Launcher();
+		spoon.addInputResource("./src/test/java/spoon/test/annotation/testclasses/AnnotationsAppliedOnAnyTypeInAClass.java");
+		spoon.addInputResource("./src/test/java/spoon/test/annotation/testclasses/BasicAnnotation.java");
+		spoon.addInputResource("./src/test/java/spoon/test/annotation/testclasses/TypeAnnotation.java");
+		spoon.addInputResource("./src/test/java/spoon/test/annotation/testclasses/AnnotParamTypeEnum.java");
+		spoon.addInputResource("./src/test/java/spoon/test/annotation/testclasses/InnerAnnot.java");
+		spoon.addInputResource("./src/test/java/spoon/test/annotation/testclasses/Inception.java");
+		spoon.addInputResource("./src/test/java/spoon/test/annotation/testclasses/TestAnnotation.java");
+		spoon.addInputResource("./src/test/java/spoon/test/annotation/testclasses/AnnotArrayInnerClass.java");
+		factory = spoon.getFactory();
+		spoon.buildModel();
+
+		// create the processor
+		final ProcessingManager p = new QueueProcessingManager(factory);
+		final TypeAnnotationProcessor processor = new TypeAnnotationProcessor();
+		p.addProcessor(processor);
+		p.process(factory.Class().getAll());
+
+		assertEquals(27, processor.elements.size());
+	}
+
+	@Test
+	public void testAbstractAllAnnotationProcessorWithGlobalAnnotation() throws Exception {
+		Launcher spoon = new Launcher();
+		spoon.addInputResource("./src/test/java/spoon/test/annotation/testclasses/ClassProcessed.java");
+		spoon.addInputResource("./src/test/java/spoon/test/annotation/testclasses/TypeAnnotation.java");
+		spoon.addInputResource("./src/test/java/spoon/test/annotation/testclasses/AnnotParamTypeEnum.java");
+		spoon.addInputResource("./src/test/java/spoon/test/annotation/testclasses/InnerAnnot.java");
+		spoon.addInputResource("./src/test/java/spoon/test/annotation/testclasses/Inception.java");
+		spoon.addInputResource("./src/test/java/spoon/test/annotation/testclasses/GlobalAnnotation.java");
+		spoon.addInputResource("./src/test/java/spoon/test/annotation/testclasses/TestAnnotation.java");
+		factory = spoon.getFactory();
+		spoon.buildModel();
+
+		// create the processor
+		final ProcessingManager p = new QueueProcessingManager(factory);
+		final GlobalProcessor processor = new GlobalProcessor();
+		p.addProcessor(processor);
+		final TypeAnnotationMethodProcessor methodProcessor = new TypeAnnotationMethodProcessor();
+		p.addProcessor(methodProcessor);
+		p.process(factory.Class().getAll());
+
+		assertEquals(5, processor.elements.size());
+		assertEquals(1, methodProcessor.elements.size());
+	}
+
+	abstract class AbstractElementsProcessor<A extends Annotation, E extends CtElement>
+			extends AbstractAnnotationProcessor<A, E> {
+		final List<CtElement> elements = new ArrayList<>();
+		@Override
+		public void process(A annotation, E element) {
+			elements.add(element);
+		}
+	}
+
+	class GlobalProcessor extends AbstractElementsProcessor<GlobalAnnotation, CtElement> {
+		@Override
+		public void process(GlobalAnnotation annotation, CtElement element) {
+			super.process(annotation, element);
+		}
+	}
+
+	class TypeAnnotationProcessor extends AbstractElementsProcessor<TypeAnnotation, CtElement> {
+		@Override
+		public void process(TypeAnnotation annotation, CtElement element) {
+			super.process(annotation, element);
+		}
+	}
+
+	class TypeAnnotationMethodProcessor extends AbstractElementsProcessor<TypeAnnotation, CtMethod<?>> {
+		@Override
+		public void process(TypeAnnotation annotation, CtMethod<?> element) {
+			super.process(annotation, element);
+		}
+	}
+
 	public static Class<? extends Annotation> getActualClassFromAnnotation(CtAnnotation<? extends Annotation> annotation) {
 		return annotation.getAnnotationType().getActualClass();
 	}
diff --git a/src/test/java/spoon/test/annotation/testclasses/ClassProcessed.java b/src/test/java/spoon/test/annotation/testclasses/ClassProcessed.java
new file mode 100644
index 000000000..858876b04
--- /dev/null
+++ b/src/test/java/spoon/test/annotation/testclasses/ClassProcessed.java
@@ -0,0 +1,17 @@
+package spoon.test.annotation.testclasses;
+
+import java.util.ArrayList;
+
+@GlobalAnnotation
+public class ClassProcessed<@TypeAnnotation T> {
+	@GlobalAnnotation
+	public ClassProcessed() {
+		@GlobalAnnotation
+		String s = new @TypeAnnotation String();
+	}
+
+	@GlobalAnnotation
+	public void m() throws @TypeAnnotation Exception {
+		new ArrayList<@GlobalAnnotation T>();
+	}
+}
diff --git a/src/test/java/spoon/test/annotation/testclasses/GlobalAnnotation.java b/src/test/java/spoon/test/annotation/testclasses/GlobalAnnotation.java
new file mode 100644
index 000000000..3d3838894
--- /dev/null
+++ b/src/test/java/spoon/test/annotation/testclasses/GlobalAnnotation.java
@@ -0,0 +1,13 @@
+package spoon.test.annotation.testclasses;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Target;
+
+@Target({
+		ElementType.TYPE_USE, ElementType.ANNOTATION_TYPE, ElementType.TYPE,
+		ElementType.TYPE_PARAMETER, ElementType.CONSTRUCTOR, ElementType.FIELD,
+		ElementType.LOCAL_VARIABLE, ElementType.METHOD, ElementType.PACKAGE,
+		ElementType.PARAMETER
+})
+public @interface GlobalAnnotation {
+}
