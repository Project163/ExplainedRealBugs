diff --git a/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java b/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java
index baba56f4b..fe306d8fd 100644
--- a/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java
+++ b/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java
@@ -1617,11 +1617,7 @@ public class DefaultJavaPrettyPrinter implements CtVisitor, PrettyPrinter {
 		// call and the declaring type of the type of the constructor call are equals or not.
 		// If yes, Bar is a intern class of Foo and we don't need to print fully qualified name.
 		// See https://bugs.eclipse.org/bugs/show_bug.cgi?id=474593
-		CtType<?> topLevelType = getTopLevelType(ctConstructorCall);
-		CtTypeReference<?> constructorDeclaringType = ctConstructorCall.getType().getDeclaringType();
-		if (topLevelType != null
-				&& topLevelType.getReference().equals(constructorDeclaringType)
-				&& constructorDeclaringType.getActualTypeArguments().size() > 0) {
+		if (hasDeclaringTypeWithGenerics(ctConstructorCall.getType())) {
 			context.ignoreEnclosingClass = true;
 		}
 
@@ -1650,38 +1646,25 @@ public class DefaultJavaPrettyPrinter implements CtVisitor, PrettyPrinter {
 		exitCtExpression(ctConstructorCall);
 	}
 
-	/**
-	 * Get the top level type. The method returns null if the parent is not initialized.
-	 * @param e the element
-	 * @return the top level types or null if not initialized.
-	 */
-	private CtType<?> getTopLevelType(CtElement e) {
-		CtType parent;
-		try {
-			parent = e.getParent(CtType.class);
-		} catch (ParentNotInitializedException ex) {
-			parent = null;
-		}
-		if (parent == null && this instanceof CtType) {
-			return (CtType<?>) this;
+	private <T> boolean hasDeclaringTypeWithGenerics(CtTypeReference<T> reference) {
+		// We don't have a declaring type, it can't have generics.
+		if (reference == null) {
+			return false;
 		}
-		return getTypeParent(parent);
-	}
-
-	private CtType<?> getTypeParent(CtType<?> parent) {
-		if (parent == null) {
-			return null;
+		// If the declaring type isn't a type, we don't need this hack.
+		if (reference.getDeclaringType() == null) {
+			return false;
 		}
-		CtType typeParent;
-		try {
-			typeParent = parent.getParent(CtType.class);
-		} catch (ParentNotInitializedException ex) {
-			typeParent = null;
+		// If current reference is a class declared in a method, we don't need this hack.
+		if (reference.isLocalType()) {
+			return false;
 		}
-		if (typeParent == null) {
-			return parent;
+		// If declaring type have generics, we return true.
+		if (reference.getDeclaringType().getActualTypeArguments().size() != 0) {
+			return true;
 		}
-		return getTypeParent(typeParent);
+		// Checks if the declaring type has generic types.
+		return hasDeclaringTypeWithGenerics(reference.getDeclaringType());
 	}
 
 	public <T> void visitCtNewClass(CtNewClass<T> newClass) {
diff --git a/src/test/java/spoon/test/generics/GenericsTest.java b/src/test/java/spoon/test/generics/GenericsTest.java
index 567ce921b..a8585a655 100644
--- a/src/test/java/spoon/test/generics/GenericsTest.java
+++ b/src/test/java/spoon/test/generics/GenericsTest.java
@@ -1,16 +1,6 @@
 package spoon.test.generics;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-import static spoon.testing.utils.ModelUtils.build;
-import static spoon.testing.utils.ModelUtils.canBeBuilt;
-import static spoon.testing.utils.ModelUtils.createFactory;
-
-import java.util.ArrayList;
-import java.util.List;
-
 import org.junit.Test;
-
 import spoon.Launcher;
 import spoon.compiler.SpoonCompiler;
 import spoon.compiler.SpoonResourceHelper;
@@ -32,7 +22,6 @@ import spoon.reflect.declaration.CtParameter;
 import spoon.reflect.declaration.CtType;
 import spoon.reflect.factory.Factory;
 import spoon.reflect.internal.CtImplicitTypeReference;
-import spoon.reflect.reference.CtReference;
 import spoon.reflect.reference.CtTypeParameterReference;
 import spoon.reflect.reference.CtTypeReference;
 import spoon.reflect.visitor.DefaultJavaPrettyPrinter;
@@ -45,6 +34,20 @@ import spoon.test.generics.testclasses.Panini;
 import spoon.test.generics.testclasses.Spaghetti;
 import spoon.test.generics.testclasses.Tacos;
 
+import java.io.File;
+import java.io.FileReader;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+import static spoon.testing.Assert.assertThat;
+import static spoon.testing.utils.ModelUtils.build;
+import static spoon.testing.utils.ModelUtils.canBeBuilt;
+import static spoon.testing.utils.ModelUtils.createFactory;
+
 public class GenericsTest {
 
 	@Test
@@ -450,7 +453,6 @@ public class GenericsTest {
 		assertEquals("? extends java.lang.Long", apply.getParameters().get(0).getType().getActualTypeArguments().get(0).toString());
 	}
 
-
 	@Test
 	public void testGenericInField() throws Exception {
 		final Factory build = build(Spaghetti.class);
@@ -463,4 +465,25 @@ public class GenericsTest {
 		assertTrue(aSpaghetti.toString().contains("private spoon.test.generics.testclasses.Spaghetti<java.lang.String>.That<java.lang.String, java.lang.String> field1;"));
 		assertTrue(aSpaghetti.toString().contains("private spoon.test.generics.testclasses.Spaghetti<java.lang.Number>.That<java.lang.String, java.lang.String> field2;"));
 	}
+
+	@Test
+	public void testGenericsInQualifiedNameInConstructorCall() throws Exception {
+		final Launcher launcher = new Launcher();
+		launcher.run(new String[] {
+				"-i", "./src/test/java/spoon/test/generics/testclasses/",
+				"-o", "./target/spooned/"
+		});
+
+		final CtClass<Tacos> aTacos = launcher.getFactory().Class().get(Tacos.class);
+		final CtType<?> burritos = aTacos.getNestedType("Burritos");
+
+		final List<CtConstructorCall> elements = burritos.getElements(new TypeFilter<>(CtConstructorCall.class));
+		assertEquals(2, elements.size());
+		assertEquals(0, elements.get(0).getExecutable().getType().getActualTypeArguments().size());
+		assertNotNull(elements.get(0).getType().getDeclaringType());
+		assertEquals("new Pozole()", elements.get(0).toString());
+		assertEquals(2, elements.get(1).getExecutable().getType().getActualTypeArguments().size());
+		assertNotNull(elements.get(1).getType().getDeclaringType());
+		assertEquals("new Burritos<K, V>()", elements.get(1).toString());
+	}
 }
diff --git a/src/test/java/spoon/test/generics/testclasses/Tacos.java b/src/test/java/spoon/test/generics/testclasses/Tacos.java
index 70e15995d..59703a5f1 100644
--- a/src/test/java/spoon/test/generics/testclasses/Tacos.java
+++ b/src/test/java/spoon/test/generics/testclasses/Tacos.java
@@ -1,11 +1,8 @@
 package spoon.test.generics.testclasses;
 
 import javax.lang.model.util.SimpleTypeVisitor7;
-import java.util.AbstractSet;
 import java.util.ArrayList;
-import java.util.Iterator;
 import java.util.List;
-import java.util.Map;
 
 public class Tacos<K, V extends String> implements ITacos<V> {
 
@@ -50,6 +47,17 @@ public class Tacos<K, V extends String> implements ITacos<V> {
 	}
 
 	class Burritos<K, V> implements IBurritos<K, V> {
+		Tacos<K, String>.Burritos<K, V> burritos;
+		public Tacos<K, String>.Burritos<K, V> b() {
+			new Burritos<K, V>();
+			return null;
+		}
+		class Pozole {
+			public Tacos<K, String>.Burritos<K, V>.Pozole p() {
+				new Pozole();
+				return null;
+			}
+		}
 	}
 
 	public class BeerFactory {
