diff --git a/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java b/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
index 649192623..8f6004ab4 100644
--- a/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
+++ b/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
@@ -2373,13 +2373,12 @@ public class JDTTreeBuilder extends ASTVisitor {
 	public boolean visit(MethodDeclaration methodDeclaration, ClassScope scope) {
 		CtMethod<Object> m = factory.Core().createMethod();
 		m.setSimpleName(new String(methodDeclaration.selector));
-		m.setType(references.getTypeReference(methodDeclaration.returnType.resolvedType));
+		m.setType(references.getTypeReference(methodDeclaration.returnType.resolvedType, methodDeclaration.returnType));
 		m.setModifiers(getModifiers(methodDeclaration.modifiers));
 		m.setDefaultMethod(methodDeclaration.isDefaultMethod());
 		if (methodDeclaration.thrownExceptions != null) {
 			for (TypeReference r : methodDeclaration.thrownExceptions) {
-				CtTypeReference<? extends Throwable> tr = references.getTypeReference(r.resolvedType);
-				m.addThrownType(tr);
+				m.addThrownType(references.<Throwable>getTypeReference(r.resolvedType, r));
 			}
 		}
 
@@ -2753,6 +2752,18 @@ public class JDTTreeBuilder extends ASTVisitor {
 			} else {
 				va = factory.Core().createFieldRead();
 			}
+		} else if (singleNameReference.binding == null) {
+			// In this case, we are in no classpath so we don't know if the access is a variable, a field or a type.
+			// By default, we assume that when we don't have any information, we create a variable access.
+			if (context.stack.peek().element instanceof CtAssignment && context.assigned) {
+				va = factory.Core().createVariableWrite();
+			} else {
+				va = factory.Core().createVariableRead();
+			}
+			CtLocalVariableReference ref = factory.Core().createLocalVariableReference();
+			ref.setSimpleName(new String(singleNameReference.token));
+			ref.setDeclaration((CtLocalVariable) getLocalVariableDeclaration(ref.getSimpleName()));
+			va.setVariable(ref);
 		}
 		if (va != null) {
 			context.enter(va, singleNameReference);
@@ -3001,8 +3012,17 @@ public class JDTTreeBuilder extends ASTVisitor {
 
 	@Override
 	public boolean visit(TypeDeclaration localTypeDeclaration, BlockScope scope) {
-		CtType<?> t = createType(localTypeDeclaration);
-		t.setDocComment(getJavaDoc(localTypeDeclaration.javadoc, scope.referenceCompilationUnit()));
+		CtType<?> t;
+		if (localTypeDeclaration.binding == null) {
+			// no classpath mode but JDT returns nothing. We create an empty class.
+			t = factory.Core().createClass();
+			((CtClass) t).setSuperclass(references.getTypeReference(null, localTypeDeclaration.allocation.type));
+		} else {
+			t = createType(localTypeDeclaration);
+		}
+		if (localTypeDeclaration.javadoc != null) {
+			t.setDocComment(getJavaDoc(localTypeDeclaration.javadoc, scope.referenceCompilationUnit()));
+		}
 		context.enter(t, localTypeDeclaration);
 
 		// AST bug HACK (see TypeDeclaration.traverse)
diff --git a/src/main/java/spoon/support/compiler/jdt/ParentExiter.java b/src/main/java/spoon/support/compiler/jdt/ParentExiter.java
index fc007a8b9..20b125949 100644
--- a/src/main/java/spoon/support/compiler/jdt/ParentExiter.java
+++ b/src/main/java/spoon/support/compiler/jdt/ParentExiter.java
@@ -1,11 +1,7 @@
 package spoon.support.compiler.jdt;
 
-import java.util.ArrayList;
-
 import org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression;
-import org.eclipse.jdt.internal.compiler.lookup.LocalTypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;
-
 import spoon.reflect.code.CtArrayAccess;
 import spoon.reflect.code.CtAssert;
 import spoon.reflect.code.CtAssignment;
@@ -55,6 +51,8 @@ import spoon.reflect.declaration.CtVariable;
 import spoon.reflect.reference.CtFieldReference;
 import spoon.reflect.visitor.CtInheritanceScanner;
 
+import java.util.ArrayList;
+
 @SuppressWarnings("unchecked")
 public class ParentExiter extends CtInheritanceScanner {
 
@@ -401,10 +399,10 @@ public class ParentExiter extends CtInheritanceScanner {
 		} else if (child instanceof CtClass) {
 			newClass.setAnonymousClass((CtClass<?>) child);
 			final QualifiedAllocationExpression node = (QualifiedAllocationExpression) jdtTreeBuilder.context.stack.peek().node;
-			final ReferenceBinding[] referenceBindings = ((LocalTypeBinding) node.resolvedType).superInterfaces();
+			final ReferenceBinding[] referenceBindings = node.resolvedType == null ? null : node.resolvedType.superInterfaces();
 			if (referenceBindings != null && referenceBindings.length > 0) {
 				((CtClass<?>) child).addSuperInterface(newClass.getType());
-			} else {
+			} else if (newClass.getType() != null) {
 				((CtClass<?>) child).setSuperclass(newClass.getType());
 			}
 			return;
diff --git a/src/test/java/spoon/test/TestUtils.java b/src/test/java/spoon/test/TestUtils.java
index b5f84b905..745163f86 100644
--- a/src/test/java/spoon/test/TestUtils.java
+++ b/src/test/java/spoon/test/TestUtils.java
@@ -56,10 +56,19 @@ public class TestUtils {
 		return build(classToBuild).Class().get(classToBuild);
 	}
 
-	public static void canBeBuild(File outputDirectoryFile, int complianceLevel) {
+	public static void canBeBuilt(File outputDirectoryFile, int complianceLevel) {
+		canBeBuilt(outputDirectoryFile, complianceLevel, false);
+	}
+
+	public static void canBeBuilt(String outputDirectory, int complianceLevel) {
+		canBeBuilt(outputDirectory, complianceLevel, false);
+	}
+
+	public static void canBeBuilt(File outputDirectoryFile, int complianceLevel, boolean noClasspath) {
 		final Launcher launcher = new Launcher();
 		final Factory factory = launcher.createFactory();
 		factory.getEnvironment().setComplianceLevel(complianceLevel);
+		factory.getEnvironment().setNoClasspath(noClasspath);
 		final SpoonCompiler compiler = launcher.createCompiler(factory);
 		compiler.addInputSource(outputDirectoryFile);
 		try {
@@ -69,8 +78,8 @@ public class TestUtils {
 		}
 	}
 
-	public static void canBeBuild(String outputDirectory, int complianceLevel) {
-		canBeBuild(new File(outputDirectory), complianceLevel);
+	public static void canBeBuilt(String outputDirectory, int complianceLevel, boolean noClasspath) {
+		canBeBuilt(new File(outputDirectory), complianceLevel, noClasspath);
 	}
 
 	public static File getSpoonedDirectory(Class testClass) {
diff --git a/src/test/java/spoon/test/annotation/AnnotationTest.java b/src/test/java/spoon/test/annotation/AnnotationTest.java
index 6ae4cf527..f8bc1a8ea 100644
--- a/src/test/java/spoon/test/annotation/AnnotationTest.java
+++ b/src/test/java/spoon/test/annotation/AnnotationTest.java
@@ -621,7 +621,7 @@ public class AnnotationTest {
 
 	@Test
 	public void testOutputGeneratedByTypeAnnotation() throws Exception {
-		TestUtils.canBeBuild(new File("./target/spooned/spoon/test/annotation/testclasses/"), 8);
+		TestUtils.canBeBuilt(new File("./target/spooned/spoon/test/annotation/testclasses/"), 8);
 	}
 
 	@Test
diff --git a/src/test/java/spoon/test/constructor/ConstructorTest.java b/src/test/java/spoon/test/constructor/ConstructorTest.java
index c64a8c522..090eac829 100644
--- a/src/test/java/spoon/test/constructor/ConstructorTest.java
+++ b/src/test/java/spoon/test/constructor/ConstructorTest.java
@@ -8,12 +8,12 @@ import spoon.reflect.declaration.CtClass;
 import spoon.reflect.declaration.CtConstructor;
 import spoon.reflect.factory.Factory;
 import spoon.reflect.visitor.filter.TypeFilter;
+import spoon.test.TestUtils;
 import spoon.test.constructor.testclasses.AClass;
 import spoon.test.constructor.testclasses.Tacos;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
-import static spoon.test.TestUtils.canBeBuild;
 
 public class ConstructorTest {
 	private Factory factory;
@@ -38,7 +38,7 @@ public class ConstructorTest {
 		assertEquals(2, ctConstructor.getBody().getStatements().size());
 		assertEquals("super()", ctConstructor.getBody().getStatement(0).toString());
 
-		canBeBuild("./target/spooned/spoon/test/constructor/testclasses/", 8);
+		TestUtils.canBeBuilt("./target/spooned/spoon/test/constructor/testclasses/", 8);
 	}
 
 	@Test
diff --git a/src/test/java/spoon/test/constructorcallnewclass/NewClassTest.java b/src/test/java/spoon/test/constructorcallnewclass/NewClassTest.java
index 58a658174..a380ccf6e 100644
--- a/src/test/java/spoon/test/constructorcallnewclass/NewClassTest.java
+++ b/src/test/java/spoon/test/constructorcallnewclass/NewClassTest.java
@@ -2,6 +2,7 @@ package spoon.test.constructorcallnewclass;
 
 import org.junit.Before;
 import org.junit.Test;
+import spoon.Launcher;
 import spoon.reflect.code.CtExpression;
 import spoon.reflect.code.CtNewClass;
 import spoon.reflect.declaration.CtClass;
@@ -18,6 +19,7 @@ import spoon.test.constructorcallnewclass.testclasses.Foo2;
 import java.util.List;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
@@ -140,4 +142,25 @@ public class NewClassTest {
 		assertEquals(Foo2.class.getCanonicalName() + "$12", elements.get(11).getAnonymousClass().getQualifiedName());
 		assertEquals(Foo2.class.getCanonicalName() + "$12$1", elements.get(12).getAnonymousClass().getQualifiedName());
 	}
+
+	@Test
+	public void testCtNewClassInNoClasspath() throws Exception {
+		final Launcher launcher = new Launcher();
+		launcher.addInputResource("./src/test/resources/new-class");
+		launcher.setSourceOutputDirectory("./target/new-class");
+		launcher.getEnvironment().setNoClasspath(true);
+		launcher.run();
+
+		final CtClass<Object> aClass = launcher.getFactory().Class().get("IndexWriter");
+		final CtNewClass ctNewClass = aClass.getElements(new TypeFilter<>(CtNewClass.class)).get(0);
+
+		final CtClass anonymousClass = ctNewClass.getAnonymousClass();
+		assertNotNull(anonymousClass);
+		assertNotNull(anonymousClass.getSuperclass());
+		assertEquals("Lock.With", anonymousClass.getSuperclass().getSimpleName());
+		assertNull(anonymousClass.getSimpleName()); // In noclasspath, we don't have this information.
+		assertEquals(1, anonymousClass.getMethods().size());
+
+		TestUtils.canBeBuilt("./target/new-class", 8, true);
+	}
 }
diff --git a/src/test/java/spoon/test/generics/GenericsTest.java b/src/test/java/spoon/test/generics/GenericsTest.java
index 825b59224..376a9b37a 100644
--- a/src/test/java/spoon/test/generics/GenericsTest.java
+++ b/src/test/java/spoon/test/generics/GenericsTest.java
@@ -346,7 +346,7 @@ public class GenericsTest {
 		assertEquals(2, constructorCall2.getType().getActualTypeArguments().size());
 		assertEquals("new spoon.test.generics.testclasses.Tacos<>()", constructorCall2.toString());
 
-		TestUtils.canBeBuild("./target/spooned/spoon/test/generics/testclasses/", 8);
+		TestUtils.canBeBuilt("./target/spooned/spoon/test/generics/testclasses/", 8);
 	}
 
 	@Test
@@ -373,7 +373,7 @@ public class GenericsTest {
 		assertEquals(0, invocation2.getExecutable().getActualTypeArguments().size());
 		assertEquals("makeTacos(null)", invocation2.toString());
 
-		TestUtils.canBeBuild("./target/spooned/spoon/test/generics/testclasses/", 8);
+		TestUtils.canBeBuilt("./target/spooned/spoon/test/generics/testclasses/", 8);
 	}
 
 	@Test
@@ -397,7 +397,7 @@ public class GenericsTest {
 		assertEquals(2, newClass2.getType().getActualTypeArguments().size());
 		assertEquals("new javax.lang.model.util.SimpleTypeVisitor7<spoon.test.generics.testclasses.Tacos, java.lang.Void>() {}", newClass2.toString());
 
-		TestUtils.canBeBuild("./target/spooned/spoon/test/generics/testclasses/", 8);
+		TestUtils.canBeBuilt("./target/spooned/spoon/test/generics/testclasses/", 8);
 	}
 
 	@Test
diff --git a/src/test/java/spoon/test/invocations/InvocationTest.java b/src/test/java/spoon/test/invocations/InvocationTest.java
index cc8ce1fc9..2d72eea39 100644
--- a/src/test/java/spoon/test/invocations/InvocationTest.java
+++ b/src/test/java/spoon/test/invocations/InvocationTest.java
@@ -26,19 +26,17 @@ public class InvocationTest {
 	public void testTypeOfStaticInvocation() throws Exception {
 		SpoonAPI launcher = new Launcher();
 		launcher.run(new String[] {
-				"-i", "./src/test/java/spoon/test/invocations/testclasses/",
-				"-o", "./target/spooned/"
+				"-i", "./src/test/java/spoon/test/invocations/testclasses/", "-o", "./target/spooned/"
 		});
 		Factory factory = launcher.getFactory();
 		CtClass<?> aClass = factory.Class().get(Foo.class);
 
-		final List<CtInvocation<?>> elements = aClass
-				.getElements(new AbstractFilter<CtInvocation<?>>(CtInvocation.class) {
-					@Override
-					public boolean matches(CtInvocation<?> element) {
-						return element.getTarget() != null;
-					}
-				});
+		final List<CtInvocation<?>> elements = aClass.getElements(new AbstractFilter<CtInvocation<?>>(CtInvocation.class) {
+			@Override
+			public boolean matches(CtInvocation<?> element) {
+				return element.getTarget() != null;
+			}
+		});
 
 		assertEquals(2, elements.size());
 		assertTrue(elements.get(0).getTarget() instanceof CtTypeAccess);
diff --git a/src/test/java/spoon/test/lambda/LambdaTest.java b/src/test/java/spoon/test/lambda/LambdaTest.java
index 6835035e1..2a386c408 100644
--- a/src/test/java/spoon/test/lambda/LambdaTest.java
+++ b/src/test/java/spoon/test/lambda/LambdaTest.java
@@ -198,7 +198,7 @@ public class LambdaTest {
 
 	@Test
 	public void testCompileLambdaGeneratedBySpoon() throws Exception {
-		TestUtils.canBeBuild(TestUtils.getSpoonedDirectory(getClass()), 8);
+		TestUtils.canBeBuilt(TestUtils.getSpoonedDirectory(getClass()), 8);
 	}
 
 	@Test
diff --git a/src/test/java/spoon/test/methodreference/MethodReferenceTest.java b/src/test/java/spoon/test/methodreference/MethodReferenceTest.java
index 2c7d15d1f..6bf05b037 100644
--- a/src/test/java/spoon/test/methodreference/MethodReferenceTest.java
+++ b/src/test/java/spoon/test/methodreference/MethodReferenceTest.java
@@ -11,7 +11,6 @@ import spoon.reflect.code.CtLiteral;
 import spoon.reflect.code.CtTypeAccess;
 import spoon.reflect.code.CtVariableRead;
 import spoon.reflect.declaration.CtClass;
-import spoon.reflect.declaration.CtElement;
 import spoon.reflect.factory.Factory;
 import spoon.reflect.reference.CtExecutableReference;
 import spoon.reflect.reference.CtTypeReference;
@@ -23,7 +22,6 @@ import spoon.test.methodreference.testclasses.Foo;
 
 import java.io.File;
 import java.util.Comparator;
-import java.util.List;
 import java.util.function.Supplier;
 
 import static org.junit.Assert.assertEquals;
@@ -144,7 +142,7 @@ public class MethodReferenceTest {
 
 	@Test
 	public void testCompileMethodReferenceGeneratedBySpoon() throws Exception {
-		TestUtils.canBeBuild(new File("./target/spooned/spoon/test/methodreference/testclasses/"), 8);
+		TestUtils.canBeBuilt(new File("./target/spooned/spoon/test/methodreference/testclasses/"), 8);
 	}
 
 	@Test
diff --git a/src/test/java/spoon/test/visibility/VisibilityTest.java b/src/test/java/spoon/test/visibility/VisibilityTest.java
index 90bff3ee4..fd5fecc2d 100644
--- a/src/test/java/spoon/test/visibility/VisibilityTest.java
+++ b/src/test/java/spoon/test/visibility/VisibilityTest.java
@@ -1,15 +1,6 @@
 package spoon.test.visibility;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static spoon.test.TestUtils.build;
-import static spoon.test.TestUtils.canBeBuild;
-
-import java.io.File;
-import java.util.List;
-
 import org.junit.Test;
-
 import spoon.Launcher;
 import spoon.OutputType;
 import spoon.SpoonAPI;
@@ -20,6 +11,14 @@ import spoon.reflect.factory.Factory;
 import spoon.reflect.reference.CtFieldReference;
 import spoon.reflect.visitor.Query;
 import spoon.reflect.visitor.filter.AbstractReferenceFilter;
+import spoon.test.TestUtils;
+
+import java.io.File;
+import java.util.List;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static spoon.test.TestUtils.build;
 
 public class VisibilityTest {
     @Test
@@ -60,7 +59,7 @@ public class VisibilityTest {
 		assertNotNull(aFloat);
 		assertEquals(spoon.test.visibility.testclasses.Float.class, aFloat.getActualClass());
 
-		canBeBuild(new File("./target/spooned/spoon/test/visibility_package/testclasses/"), 7);
+		TestUtils.canBeBuilt(new File("./target/spooned/spoon/test/visibility_package/testclasses/"), 7);
 	}
 
 	@Test
@@ -71,7 +70,7 @@ public class VisibilityTest {
 				"-o", "./target/spooned/spoon/test/visibility_generics/testclasses/"
 		});
 
-		canBeBuild("./target/spooned/spoon/test/visibility_generics/testclasses/", 8);
+		TestUtils.canBeBuilt("./target/spooned/spoon/test/visibility_generics/testclasses/", 8);
 	}
 
 	@Test
diff --git a/src/test/resources/new-class/IndexWriter.java b/src/test/resources/new-class/IndexWriter.java
new file mode 100644
index 000000000..5c44b2637
--- /dev/null
+++ b/src/test/resources/new-class/IndexWriter.java
@@ -0,0 +1,329 @@
+import java.io.IOException;
+import java.io.File;
+import java.io.PrintStream;
+import java.util.Vector;
+
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.RAMDirectory;
+import org.apache.lucene.store.FSDirectory;
+import org.apache.lucene.store.Lock;
+import org.apache.lucene.store.InputStream;
+import org.apache.lucene.store.OutputStream;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.analysis.Analyzer;
+
+public final class IndexWriter {
+	private Directory directory;			  // where this index resides
+	private Analyzer analyzer;			  // how to analyze text
+
+	private SegmentInfos segmentInfos = new SegmentInfos(); // the segments
+	private final Directory ramDirectory = new RAMDirectory(); // for temp segs
+
+	/** Constructs an IndexWriter for the index in <code>path</code>.  Text will
+	 be analyzed with <code>a</code>.  If <code>create</code> is true, then a
+	 new, empty index will be created in <code>d</code>, replacing the index
+	 already there, if any. */
+	public IndexWriter(String path, Analyzer a, boolean create)
+	throws IOException {
+		this(FSDirectory.getDirectory(path, create), a, create);
+	}
+
+	/** Constructs an IndexWriter for the index in <code>path</code>.  Text will
+	 be analyzed with <code>a</code>.  If <code>create</code> is true, then a
+	 new, empty index will be created in <code>d</code>, replacing the index
+	 already there, if any. */
+	public IndexWriter(File path, Analyzer a, boolean create)
+	throws IOException {
+		this(FSDirectory.getDirectory(path, create), a, create);
+	}
+
+	/** Constructs an IndexWriter for the index in <code>d</code>.  Text will be
+	 analyzed with <code>a</code>.  If <code>create</code> is true, then a new,
+	 empty index will be created in <code>d</code>, replacing the index already
+	 there, if any. */
+	public IndexWriter(Directory d, Analyzer a, final boolean create)
+	throws IOException {
+		directory = d;
+		analyzer = a;
+
+		Lock writeLock = directory.makeLock("write.lock");
+		if (!writeLock.obtain())			  // obtain write lock
+			throw new IOException("Index locked for write: " + writeLock);
+
+		synchronized (directory) {			  // in- & inter-process sync
+			new Lock.With(directory.makeLock("commit.lock")) {
+				public Object doBody() throws IOException {
+					if (create)
+						segmentInfos.write(directory);
+					else
+						segmentInfos.read(directory);
+					return null;
+				}
+			}.run();
+		}
+	}
+
+	/** Flushes all changes to an index, closes all associated files, and closes
+	 the directory that the index is stored in. */
+	public final synchronized void close() throws IOException {
+		flushRamSegments();
+		ramDirectory.close();
+		directory.makeLock("write.lock").release();  // release write lock
+		directory.close();
+	}
+
+	/** Returns the number of documents currently in this index. */
+	public final synchronized int docCount() {
+		int count = 0;
+		for (int i = 0; i < segmentInfos.size(); i++) {
+			SegmentInfo si = segmentInfos.info(i);
+			count += si.docCount;
+		}
+		return count;
+	}
+
+	/** The maximum number of terms that will be indexed for a single field in a
+	 document.  This limits the amount of memory required for indexing, so that
+	 collections with very large files will not crash the indexing process by
+	 running out of memory.
+
+	 <p>By default, no more than 10,000 terms will be indexed for a field. */
+	public int maxFieldLength = 10000;
+
+	/** Adds a document to this index.*/
+	public final void addDocument(Document doc) throws IOException {
+		DocumentWriter dw =
+				new DocumentWriter(ramDirectory, analyzer, maxFieldLength);
+		String segmentName = newSegmentName();
+		dw.addDocument(segmentName, doc);
+		synchronized (this) {
+			segmentInfos.addElement(new SegmentInfo(segmentName, 1, ramDirectory));
+			maybeMergeSegments();
+		}
+	}
+
+	private final synchronized String newSegmentName() {
+		return "_" + Integer.toString(segmentInfos.counter++, Character.MAX_RADIX);
+	}
+
+	/** Determines how often segment indexes are merged by addDocument().  With
+	 * smaller values, less RAM is used while indexing, and searches on
+	 * unoptimized indexes are faster, but indexing speed is slower.  With larger
+	 * values more RAM is used while indexing and searches on unoptimized indexes
+	 * are slower, but indexing is faster.  Thus larger values (> 10) are best
+	 * for batched index creation, and smaller values (< 10) for indexes that are
+	 * interactively maintained.
+	 *
+	 * <p>This must never be less than 2.  The default value is 10.*/
+	public int mergeFactor = 10;
+
+	/** Determines the largest number of documents ever merged by addDocument().
+	 * Small values (e.g., less than 10,000) are best for interactive indexing,
+	 * as this limits the length of pauses while indexing to a few seconds.
+	 * Larger values are best for batched indexing and speedier searches.
+	 *
+	 * <p>The default value is {@link Integer#MAX_VALUE}. */
+	public int maxMergeDocs = Integer.MAX_VALUE;
+
+	/** If non-null, information about merges will be printed to this. */
+	public PrintStream infoStream = null;
+
+	/** Merges all segments together into a single segment, optimizing an index
+	 for search. */
+	public final synchronized void optimize() throws IOException {
+		flushRamSegments();
+		while (segmentInfos.size() > 1 ||
+				(segmentInfos.size() == 1 &&
+						SegmentReader.hasDeletions(segmentInfos.info(0)))){
+			int minSegment = segmentInfos.size() - mergeFactor;
+			mergeSegments(minSegment < 0 ? 0 : minSegment);
+		}
+	}
+
+	/** Merges all segments from an array of indexes into this index.
+	 *
+	 * <p>This may be used to parallelize batch indexing.  A large document
+	 * collection can be broken into sub-collections.  Each sub-collection can be
+	 * indexed in parallel, on a different thread, process or machine.  The
+	 * complete index can then be created by merging sub-collection indexes
+	 * with this method.
+	 *
+	 * <p>After this completes, the index is optimized. */
+	public final synchronized void addIndexes(Directory[] dirs)
+	throws IOException {
+		optimize();					  // start with zero or 1 seg
+		int minSegment = segmentInfos.size();
+		int segmentsAddedSinceMerge = 0;
+		for (int i = 0; i < dirs.length; i++) {
+			SegmentInfos sis = new SegmentInfos();	  // read infos from dir
+			sis.read(dirs[i]);
+			for (int j = 0; j < sis.size(); j++) {
+				segmentInfos.addElement(sis.info(j));	  // add each info
+
+				// merge whenever mergeFactor segments have been added
+				if (++segmentsAddedSinceMerge == mergeFactor) {
+					mergeSegments(minSegment++, false);
+					segmentsAddedSinceMerge = 0;
+				}
+			}
+		}
+		optimize();					  // final cleanup
+	}
+
+	/** Merges all RAM-resident segments. */
+	private final void flushRamSegments() throws IOException {
+		int minSegment = segmentInfos.size()-1;
+		int docCount = 0;
+		while (minSegment >= 0 &&
+				(segmentInfos.info(minSegment)).dir == ramDirectory) {
+			docCount += segmentInfos.info(minSegment).docCount;
+			minSegment--;
+		}
+		if (minSegment < 0 ||			  // add one FS segment?
+				(docCount + segmentInfos.info(minSegment).docCount) > mergeFactor ||
+				!(segmentInfos.info(segmentInfos.size()-1).dir == ramDirectory))
+			minSegment++;
+		if (minSegment >= segmentInfos.size())
+			return;					  // none to merge
+		mergeSegments(minSegment);
+	}
+
+	/** Incremental segment merger.  */
+	private final void maybeMergeSegments() throws IOException {
+		long targetMergeDocs = mergeFactor;
+		while (targetMergeDocs <= maxMergeDocs) {
+			// find segments smaller than current target size
+			int minSegment = segmentInfos.size();
+			int mergeDocs = 0;
+			while (--minSegment >= 0) {
+				SegmentInfo si = segmentInfos.info(minSegment);
+				if (si.docCount >= targetMergeDocs)
+					break;
+				mergeDocs += si.docCount;
+			}
+
+			if (mergeDocs >= targetMergeDocs)		  // found a merge to do
+				mergeSegments(minSegment+1);
+			else
+				break;
+
+			targetMergeDocs *= mergeFactor;		  // increase target size
+		}
+	}
+
+	/** Pops segments off of segmentInfos stack down to minSegment, merges them,
+	 and pushes the merged index onto the top of the segmentInfos stack. */
+	private final void mergeSegments(int minSegment) throws IOException {
+		mergeSegments(minSegment, true);
+	}
+
+	/** Pops segments off of segmentInfos stack down to minSegment, merges them,
+	 and pushes the merged index onto the top of the segmentInfos stack. */
+	private final void mergeSegments(int minSegment, boolean delete)
+	throws IOException {
+		String mergedName = newSegmentName();
+		int mergedDocCount = 0;
+		if (infoStream != null) infoStream.print("merging segments");
+		SegmentMerger merger = new SegmentMerger(directory, mergedName);
+		final Vector segmentsToDelete = new Vector();
+		for (int i = minSegment; i < segmentInfos.size(); i++) {
+			SegmentInfo si = segmentInfos.info(i);
+			if (infoStream != null)
+				infoStream.print(" " + si.name + " (" + si.docCount + " docs)");
+			SegmentReader reader = new SegmentReader(si);
+			merger.add(reader);
+			if (delete)
+				segmentsToDelete.addElement(reader);	  // queue for deletion
+			mergedDocCount += si.docCount;
+		}
+		if (infoStream != null) {
+			infoStream.println();
+			infoStream.println(" into "+mergedName+" ("+mergedDocCount+" docs)");
+		}
+		merger.merge();
+
+		segmentInfos.setSize(minSegment);		  // pop old infos & add new
+		segmentInfos.addElement(new SegmentInfo(mergedName, mergedDocCount,
+				directory));
+
+		synchronized (directory) {			  // in- & inter-process sync
+			new Lock.With(directory.makeLock("commit.lock")) {
+				public Object doBody() throws IOException {
+					segmentInfos.write(directory);	  // commit before deleting
+					deleteSegments(segmentsToDelete);	  // delete now-unused segments
+					return null;
+				}
+			}.run();
+		}
+	}
+
+  /* Some operating systems (e.g. Windows) don't permit a file to be deleted
+     while it is opened for read (e.g. by another process or thread).  So we
+     assume that when a delete fails it is because the file is open in another
+     process, and queue the file for subsequent deletion. */
+
+	private final void deleteSegments(Vector segments) throws IOException {
+		Vector deletable = new Vector();
+
+		deleteFiles(readDeleteableFiles(), deletable); // try to delete deleteable
+
+		for (int i = 0; i < segments.size(); i++) {
+			SegmentReader reader = (SegmentReader)segments.elementAt(i);
+			if (reader.directory == this.directory)
+				deleteFiles(reader.files(), deletable);	  // try to delete our files
+			else
+				deleteFiles(reader.files(), reader.directory); // delete, eg, RAM files
+		}
+
+		writeDeleteableFiles(deletable);		  // note files we can't delete
+	}
+
+	private final void deleteFiles(Vector files, Directory directory)
+	throws IOException {
+		for (int i = 0; i < files.size(); i++)
+			directory.deleteFile((String)files.elementAt(i));
+	}
+
+	private final void deleteFiles(Vector files, Vector deletable)
+	throws IOException {
+		for (int i = 0; i < files.size(); i++) {
+			String file = (String)files.elementAt(i);
+			try {
+				directory.deleteFile(file);		  // try to delete each file
+			} catch (IOException e) {			  // if delete fails
+				if (directory.fileExists(file)) {
+					if (infoStream != null)
+						infoStream.println(e.getMessage() + "; Will re-try later.");
+					deletable.addElement(file);		  // add to deletable
+				}
+			}
+		}
+	}
+
+	private final Vector readDeleteableFiles() throws IOException {
+		Vector result = new Vector();
+		if (!directory.fileExists("deletable"))
+			return result;
+
+		InputStream input = directory.openFile("deletable");
+		try {
+			for (int i = input.readInt(); i > 0; i--)	  // read file names
+				result.addElement(input.readString());
+		} finally {
+			input.close();
+		}
+		return result;
+	}
+
+	private final void writeDeleteableFiles(Vector files) throws IOException {
+		OutputStream output = directory.createFile("deleteable.new");
+		try {
+			output.writeInt(files.size());
+			for (int i = 0; i < files.size(); i++)
+				output.writeString((String)files.elementAt(i));
+		} finally {
+			output.close();
+		}
+		directory.renameFile("deleteable.new", "deletable");
+	}
+}
\ No newline at end of file
