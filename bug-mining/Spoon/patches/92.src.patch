diff --git a/src/main/java/spoon/reflect/code/CtTypeAccess.java b/src/main/java/spoon/reflect/code/CtTypeAccess.java
index 238fecf7d..b9f3dcd55 100644
--- a/src/main/java/spoon/reflect/code/CtTypeAccess.java
+++ b/src/main/java/spoon/reflect/code/CtTypeAccess.java
@@ -16,13 +16,47 @@
  */
 package spoon.reflect.code;
 
+import spoon.reflect.reference.CtTypeReference;
+
 /**
  * This code element defines an access to a type.
  *
  * In Java, it is generally of the form: <code>Type</code>.
  *
- * @param <T>
- * 		type in the expression.
+ * For example, you can have:
+ *
+ * <pre>
+ *     Type.staticField
+ *     Type.staticMethod()
+ *     Type::method
+ *     t instanceof Type
+ *     Type.class
+ * </pre>
+ *
+ * @param <A>
+ * 		Access type of the expression.
  */
-public interface CtTypeAccess<T> extends CtExpression<T> {
+public interface CtTypeAccess<A> extends CtExpression<Void> {
+	/**
+	 * Returns type represented and contained in the type access.
+	 *
+	 * @return CtTypeReference.
+	 */
+	CtTypeReference<A> getAccessedType();
+
+	/**
+	 * Set the accessed type.
+	 *
+	 * @param accessedType
+	 * 		CtTypeReference.
+	 */
+	<C extends CtTypeAccess<A>> C setAccessedType(CtTypeReference<A> accessedType);
+
+	/**
+	 * Returns always VOID.
+	 *
+	 * @see #getAccessedType() to get the accessed type.
+	 */
+	@Override
+	CtTypeReference<Void> getType();
 }
diff --git a/src/main/java/spoon/reflect/factory/CodeFactory.java b/src/main/java/spoon/reflect/factory/CodeFactory.java
index 179462aed..ab062e3f8 100644
--- a/src/main/java/spoon/reflect/factory/CodeFactory.java
+++ b/src/main/java/spoon/reflect/factory/CodeFactory.java
@@ -89,6 +89,18 @@ public class CodeFactory extends SubFactory {
 		return factory.Core().<T>createBinaryOperator().setLeftHandOperand(left).setKind(kind).setRightHandOperand(right);
 	}
 
+	/**
+	 * Creates a accessed type.
+	 * @param accessedType a type reference to the accessed type.
+	 * @param <T> the type of the expression.
+	 * @return a accessed type expression.
+	 */
+	public <T> CtTypeAccess<T> createTypeAccess(CtTypeReference<T> accessedType) {
+		final CtTypeAccess<T> typeAccess = factory.Core().createTypeAccess();
+		typeAccess.setAccessedType(accessedType);
+		return typeAccess;
+	}
+
 	/**
 	 * Creates a class access expression of the form <code>C.class</code>.
 	 *
@@ -100,8 +112,7 @@ public class CodeFactory extends SubFactory {
 	 */
 	public <T> CtFieldAccess<Class<T>> createClassAccess(CtTypeReference<T> type) {
 		@SuppressWarnings({ "rawtypes", "unchecked" }) CtTypeReference<Class<T>> classType = (CtTypeReference) factory.Type().createReference(Class.class);
-		CtTypeAccess<T> typeAccess = factory.Core().createTypeAccess();
-		typeAccess.setType(type);
+		CtTypeAccess<T> typeAccess = factory.Code().createTypeAccess(type);
 
 		CtFieldReference<Class<T>> fieldReference = factory.Core().createFieldReference();
 		fieldReference.setSimpleName("class");
diff --git a/src/main/java/spoon/reflect/visitor/CtScanner.java b/src/main/java/spoon/reflect/visitor/CtScanner.java
index 4f8c3f5f5..2a82d584a 100644
--- a/src/main/java/spoon/reflect/visitor/CtScanner.java
+++ b/src/main/java/spoon/reflect/visitor/CtScanner.java
@@ -695,6 +695,7 @@ public abstract class CtScanner implements CtVisitor {
 		scan(typeAccess.getAnnotations());
 		scan(typeAccess.getType());
 		scan(typeAccess.getTypeCasts());
+		scan(typeAccess.getAccessedType());
 		exit(typeAccess);
 	}
 
diff --git a/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java b/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java
index d73fd34bf..1c1fecd11 100644
--- a/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java
+++ b/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java
@@ -1949,7 +1949,7 @@ public class DefaultJavaPrettyPrinter implements CtVisitor, PrettyPrinter {
 	@Override
 	public <T> void visitCtTypeAccess(CtTypeAccess<T> typeAccess) {
 		enterCtExpression(typeAccess);
-		scan(typeAccess.getType());
+		scan(typeAccess.getAccessedType());
 		exitCtExpression(typeAccess);
 	}
 
diff --git a/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java b/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
index efbfd6c41..a04ccd453 100644
--- a/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
+++ b/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
@@ -1932,9 +1932,7 @@ public class JDTTreeBuilder extends ASTVisitor {
 
 	@Override
 	public boolean visit(ArrayTypeReference arrayTypeReference, BlockScope scope) {
-		final CtTypeAccess<Object> typeAccess = factory.Core().createTypeAccess();
-		typeAccess.setType(references.getTypeReference(arrayTypeReference.resolvedType));
-		context.enter(typeAccess, arrayTypeReference);
+		context.enter(factory.Code().createTypeAccess(references.getTypeReference(arrayTypeReference.resolvedType)), arrayTypeReference);
 		return true;
 	}
 
@@ -1945,9 +1943,7 @@ public class JDTTreeBuilder extends ASTVisitor {
 
 	@Override
 	public boolean visit(ArrayQualifiedTypeReference arrayQualifiedTypeReference, BlockScope scope) {
-		final CtTypeAccess<Object> typeAccess = factory.Core().createTypeAccess();
-		typeAccess.setType(references.getTypeReference(arrayQualifiedTypeReference.resolvedType));
-		context.enter(typeAccess, arrayQualifiedTypeReference);
+		context.enter(factory.Code().createTypeAccess(references.getTypeReference(arrayQualifiedTypeReference.resolvedType)), arrayQualifiedTypeReference);
 		return true;
 	}
 
@@ -2436,8 +2432,7 @@ public class JDTTreeBuilder extends ASTVisitor {
 				if (messageSend.binding instanceof ProblemMethodBinding) {
 					// We are in a static complex in noclasspath mode.
 					if (inv.getExecutable() != null && inv.getExecutable().getDeclaringType() != null) {
-						final CtTypeAccess ta = factory.Core().createTypeAccess();
-						ta.setType(inv.getExecutable().getDeclaringType());
+						final CtTypeAccess ta = factory.Code().createTypeAccess(inv.getExecutable().getDeclaringType());
 						inv.setTarget(ta);
 					}
 					if (messageSend.expectedType() != null) {
@@ -2631,8 +2626,7 @@ public class JDTTreeBuilder extends ASTVisitor {
 		if (skipTypeInAnnotation) {
 			return true;
 		}
-		final CtTypeAccess<Object> typeAccess = factory.Core().createTypeAccess();
-		typeAccess.setType(references.getTypeReference(parameterizedQualifiedTypeReference.resolvedType));
+		final CtTypeAccess<Object> typeAccess = factory.Code().createTypeAccess(references.getTypeReference(parameterizedQualifiedTypeReference.resolvedType));
 		context.enter(typeAccess, parameterizedQualifiedTypeReference);
 		return true;
 	}
@@ -2642,8 +2636,7 @@ public class JDTTreeBuilder extends ASTVisitor {
 		if (skipTypeInAnnotation) {
 			return true;
 		}
-		final CtTypeAccess<Object> typeAccess = factory.Core().createTypeAccess();
-		typeAccess.setType(references.getTypeReference(parameterizedQualifiedTypeReference.resolvedType));
+		final CtTypeAccess<Object> typeAccess = factory.Code().createTypeAccess(references.getTypeReference(parameterizedQualifiedTypeReference.resolvedType));
 		context.enter(typeAccess, parameterizedQualifiedTypeReference);
 		return true;
 	}
@@ -2653,8 +2646,7 @@ public class JDTTreeBuilder extends ASTVisitor {
 		if (skipTypeInAnnotation) {
 			return true;
 		}
-		final CtTypeAccess<Object> typeAccess = factory.Core().createTypeAccess();
-		typeAccess.setType(references.getTypeReference(parameterizedSingleTypeReference.resolvedType));
+		final CtTypeAccess<Object> typeAccess = factory.Code().createTypeAccess(references.getTypeReference(parameterizedSingleTypeReference.resolvedType));
 		context.enter(typeAccess, parameterizedSingleTypeReference);
 		return true;
 	}
@@ -2664,8 +2656,7 @@ public class JDTTreeBuilder extends ASTVisitor {
 		if (skipTypeInAnnotation) {
 			return true;
 		}
-		final CtTypeAccess<Object> typeAccess = factory.Core().createTypeAccess();
-		typeAccess.setType(references.getTypeReference(parameterizedSingleTypeReference.resolvedType));
+		final CtTypeAccess<Object> typeAccess = factory.Code().createTypeAccess(references.getTypeReference(parameterizedSingleTypeReference.resolvedType));
 		context.enter(typeAccess, parameterizedSingleTypeReference);
 		return super.visit(parameterizedSingleTypeReference, scope);
 	}
@@ -2819,17 +2810,15 @@ public class JDTTreeBuilder extends ASTVisitor {
 			context.enter(va, qualifiedNameReference);
 			return false;
 		} else if (qualifiedNameReference.binding instanceof TypeBinding) {
-			CtTypeAccess<Object> ta = factory.Core().createTypeAccess();
-			ta.setType(references.getTypeReference((TypeBinding) qualifiedNameReference.binding));
+			CtTypeAccess<Object> ta = factory.Code().createTypeAccess(references.getTypeReference((TypeBinding) qualifiedNameReference.binding));
 			context.enter(ta, qualifiedNameReference);
 			return false;
 		} else if (qualifiedNameReference.binding instanceof ProblemBinding) {
 			CtVariableAccess<Object> va;
 			if (context.stack.peek().element instanceof CtInvocation) {
-				final CtTypeAccess<Object> ta = factory.Core().createTypeAccess();
 				final CtTypeReference<Object> typeReference = factory.Core().createTypeReference();
 				typeReference.setSimpleName(qualifiedNameReference.toString());
-				ta.setType(typeReference);
+				final CtTypeAccess<Object> ta = factory.Code().createTypeAccess(typeReference);
 				context.enter(ta, qualifiedNameReference);
 				return false;
 			}  else if (context.stack.peek().element instanceof CtAssignment && context.assigned) {
@@ -2869,8 +2858,7 @@ public class JDTTreeBuilder extends ASTVisitor {
 		if (skipTypeInAnnotation) {
 			return true;
 		}
-		final CtTypeAccess<Object> typeAccess = factory.Core().createTypeAccess();
-		typeAccess.setType(references.getTypeReference(arg0.resolvedType));
+		final CtTypeAccess<Object> typeAccess = factory.Code().createTypeAccess(references.getTypeReference(arg0.resolvedType));
 		context.enter(typeAccess, arg0);
 		return true; // do nothing by default, keep traversing
 	}
@@ -2917,12 +2905,10 @@ public class JDTTreeBuilder extends ASTVisitor {
 			}
 			va.setVariable(references.getVariableReference((VariableBinding) singleNameReference.binding));
 		} else if (singleNameReference.binding instanceof TypeBinding) {
-			CtTypeAccess<Object> ta = factory.Core().createTypeAccess();
-			ta.setType(references.getTypeReference((TypeBinding) singleNameReference.binding));
+			CtTypeAccess<Object> ta = factory.Code().createTypeAccess(references.getTypeReference((TypeBinding) singleNameReference.binding));
 			context.enter(ta, singleNameReference);
 		} else if (singleNameReference.binding instanceof ProblemBinding) {
 			if (context.stack.peek().element instanceof CtInvocation) {
-				final CtTypeAccess<Object> ta = factory.Core().createTypeAccess();
 				CtTypeReference<Object> typeReference = factory.Core().createTypeReference();
 				typeReference.setSimpleName(new String(singleNameReference.binding.readableName()));
 				final CtReference declaring = references.getDeclaringReferenceFromImports(singleNameReference.token);
@@ -2931,7 +2917,7 @@ public class JDTTreeBuilder extends ASTVisitor {
 				} else if (declaring instanceof CtTypeReference) {
 					typeReference = (CtTypeReference<Object>) declaring;
 				}
-				ta.setType(typeReference);
+				final CtTypeAccess<Object> ta = factory.Code().createTypeAccess(typeReference);
 				context.enter(ta, singleNameReference);
 				return true;
 			} else if (context.stack.peek().element instanceof CtAssignment && context.assigned) {
@@ -2967,8 +2953,7 @@ public class JDTTreeBuilder extends ASTVisitor {
 		CtTypeReference<Object> typeRefOfSuper = references.getTypeReference(qualifiedSuperReference.qualification.resolvedType);
 		final CtSuperAccess<Object> superAccess = factory.Core().createSuperAccess();
 
-		CtTypeAccess<Object> typeAccess = factory.Core().createTypeAccess();
-		typeAccess.setType(typeRefOfSuper);
+		CtTypeAccess<Object> typeAccess = factory.Code().createTypeAccess(typeRefOfSuper);
 		superAccess.setTarget(typeAccess);
 
 		context.enter(superAccess, qualifiedSuperReference);
@@ -2988,8 +2973,7 @@ public class JDTTreeBuilder extends ASTVisitor {
 		thisAccess.setImplicit(qualifiedThisReference.isImplicitThis());
 		thisAccess.setType(typeRefOfThis);
 
-		CtTypeAccess<Object> typeAccess = factory.Core().createTypeAccess();
-		typeAccess.setType(typeRefOfThis);
+		CtTypeAccess<Object> typeAccess = factory.Code().createTypeAccess(typeRefOfThis);
 		thisAccess.setTarget(typeAccess);
 
 		context.enter(thisAccess, qualifiedThisReference);
@@ -3011,16 +2995,14 @@ public class JDTTreeBuilder extends ASTVisitor {
 		if (skipTypeInAnnotation) {
 			return true;
 		}
-		final CtTypeAccess<Object> typeAccess = factory.Core().createTypeAccess();
-		typeAccess.setType(references.getTypeReference(singleTypeReference.resolvedType));
+		final CtTypeAccess<Object> typeAccess = factory.Code().createTypeAccess(references.getTypeReference(singleTypeReference.resolvedType));
 		context.enter(typeAccess, singleTypeReference);
 		return true; // do nothing by default, keep traversing
 	}
 
 	@Override
 	public boolean visit(SingleTypeReference singleTypeReference, ClassScope scope) {
-		CtTypeAccess<Object> typeAccess = factory.Core().createTypeAccess();
-		typeAccess.setType(references.getTypeReference(singleTypeReference.resolvedType));
+		CtTypeAccess<Object> typeAccess = factory.Code().createTypeAccess(references.getTypeReference(singleTypeReference.resolvedType));
 		context.enter(typeAccess, singleTypeReference);
 		return true; // do nothing by default, keep traversing
 	}
diff --git a/src/main/java/spoon/support/reflect/code/CtTypeAccessImpl.java b/src/main/java/spoon/support/reflect/code/CtTypeAccessImpl.java
index 586d7bfb4..ea95e8eb7 100644
--- a/src/main/java/spoon/support/reflect/code/CtTypeAccessImpl.java
+++ b/src/main/java/spoon/support/reflect/code/CtTypeAccessImpl.java
@@ -17,11 +17,45 @@
 package spoon.support.reflect.code;
 
 import spoon.reflect.code.CtTypeAccess;
+import spoon.reflect.declaration.CtTypedElement;
+import spoon.reflect.reference.CtTypeReference;
 import spoon.reflect.visitor.CtVisitor;
 
-public class CtTypeAccessImpl<T> extends CtExpressionImpl<T> implements CtTypeAccess<T> {
+public class CtTypeAccessImpl<A> extends CtExpressionImpl<Void> implements CtTypeAccess<A> {
+	private CtTypeReference<Void> voidType;
+	private CtTypeReference<A> type;
+
 	@Override
 	public void accept(CtVisitor visitor) {
 		visitor.visitCtTypeAccess(this);
 	}
+
+	@Override
+	public CtTypeReference<A> getAccessedType() {
+		return type;
+	}
+
+	@Override
+	public <C extends CtTypeAccess<A>> C setAccessedType(CtTypeReference<A> accessedType) {
+		if (accessedType != null) {
+			accessedType.setParent(this);
+		}
+		type = accessedType;
+		return (C) this;
+	}
+
+	@Override
+	public CtTypeReference<Void> getType() {
+		if (voidType == null) {
+			voidType = getFactory().Core().clone(getFactory().Type().VOID_PRIMITIVE);
+			voidType.setParent(this);
+		}
+		return voidType;
+	}
+
+	@Override
+	public <C extends CtTypedElement> C setType(CtTypeReference<Void> type) {
+		// type is used in setAccessedType now.
+		return (C) this;
+	}
 }
diff --git a/src/main/java/spoon/support/visitor/SignaturePrinter.java b/src/main/java/spoon/support/visitor/SignaturePrinter.java
index 058ee3bfe..a47afdd6c 100644
--- a/src/main/java/spoon/support/visitor/SignaturePrinter.java
+++ b/src/main/java/spoon/support/visitor/SignaturePrinter.java
@@ -650,7 +650,7 @@ public class SignaturePrinter implements CtVisitor {
 
 	@Override
 	public <T> void visitCtTypeAccess(CtTypeAccess<T> typeAccess) {
-		scan(typeAccess.getType());
+		scan(typeAccess.getAccessedType());
 	}
 
 	public <T> void visitCtUnaryOperator(CtUnaryOperator<T> operator) {
diff --git a/src/test/java/spoon/test/parent/ParentContractTest.java b/src/test/java/spoon/test/parent/ParentContractTest.java
index b4e327efb..cfcea97b2 100644
--- a/src/test/java/spoon/test/parent/ParentContractTest.java
+++ b/src/test/java/spoon/test/parent/ParentContractTest.java
@@ -9,6 +9,7 @@ import spoon.reflect.code.CtCatchVariable;
 import spoon.reflect.code.CtConstructorCall;
 import spoon.reflect.code.CtInvocation;
 import spoon.reflect.code.CtNewClass;
+import spoon.reflect.code.CtTypeAccess;
 import spoon.reflect.declaration.CtAnnotationType;
 import spoon.reflect.declaration.CtAnonymousExecutable;
 import spoon.reflect.declaration.CtConstructor;
@@ -117,6 +118,7 @@ public class ParentContractTest<T extends CtVisitable> {
 			if (o instanceof CtAnonymousExecutable && ("addParameter".equals(setter.getName()) || "setParameters".equals(setter.getName()))) continue;
 			if (o instanceof CtAnonymousExecutable && ("addThrownType".equals(setter.getName()) || "setThrownTypes".equals(setter.getName()))) continue;
 			if (o instanceof CtAnonymousExecutable && "setType".equals(setter.getName())) continue;
+			if (o instanceof CtTypeAccess && "setType".equals(setter.getName())) continue;
 
 			CtElement mockedArgument = (CtElement) mock(setter.getParameters()[0].getType(),  Mockito.withSettings().extraInterfaces(Comparable.class));
 			try {
