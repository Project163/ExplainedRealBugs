diff --git a/src/main/java/spoon/support/reflect/declaration/CtTypeImpl.java b/src/main/java/spoon/support/reflect/declaration/CtTypeImpl.java
index 9aeb0223f..fa0461081 100644
--- a/src/main/java/spoon/support/reflect/declaration/CtTypeImpl.java
+++ b/src/main/java/spoon/support/reflect/declaration/CtTypeImpl.java
@@ -217,18 +217,26 @@ public abstract class CtTypeImpl<T> extends CtNamedElementImpl implements CtType
 	@Override
 	public Set<CtTypeReference<?>> getUsedTypes(boolean includeSamePackage) {
 		Set<CtTypeReference<?>> typeRefs = new HashSet<>();
-		for (CtTypeReference<?> typeRef : Query
-				.getReferences(this, new ReferenceTypeFilter<CtTypeReference<?>>(CtTypeReference.class))) {
-			if (!(typeRef.isPrimitive() || (typeRef instanceof CtArrayTypeReference) || typeRef.toString()
-					.equals(CtTypeReference.NULL_TYPE_NAME) || ((typeRef.getPackage() != null) && "java.lang"
-					.equals(typeRef.getPackage().toString()))) && !(!includeSamePackage && getPackageReference(typeRef)
-					.equals(this.getPackage().getReference()))) {
+		for (CtTypeReference<?> typeRef : Query.getReferences(this, new ReferenceTypeFilter<CtTypeReference<?>>(CtTypeReference.class))) {
+			if (isValidTypeReference(typeRef) && shouldIncludeSamePackage(includeSamePackage, typeRef)) {
 				typeRefs.add(typeRef);
 			}
 		}
 		return typeRefs;
 	}
 
+	private boolean shouldIncludeSamePackage(boolean includeSamePackage, CtTypeReference<?> typeRef) {
+		return includeSamePackage || (getPackage() != null && !getPackageReference(typeRef).equals(getPackage().getReference()));
+	}
+
+	private boolean isValidTypeReference(CtTypeReference<?> typeRef) {
+		return !(isFromJavaLang(typeRef) || typeRef.isPrimitive() || typeRef instanceof CtArrayTypeReference || CtTypeReference.NULL_TYPE_NAME.equals(typeRef.toString()));
+	}
+
+	private boolean isFromJavaLang(CtTypeReference<?> typeRef) {
+		return typeRef.getPackage() != null && "java.lang".equals(typeRef.getPackage().toString());
+	}
+
 	/**
 	 * Return the package reference for the corresponding type reference. For
 	 * inner type, return the package reference of the top-most enclosing type.
diff --git a/src/test/java/spoon/test/model/TypeTest.java b/src/test/java/spoon/test/model/TypeTest.java
index ce823ab12..ee98c0c25 100644
--- a/src/test/java/spoon/test/model/TypeTest.java
+++ b/src/test/java/spoon/test/model/TypeTest.java
@@ -1,6 +1,7 @@
 package spoon.test.model;
 
 import org.junit.Test;
+import spoon.reflect.declaration.CtClass;
 import spoon.reflect.declaration.CtType;
 import spoon.reflect.factory.TypeFactory;
 import spoon.reflect.reference.CtExecutableReference;
@@ -13,6 +14,7 @@ import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static spoon.testing.utils.ModelUtils.build;
+import static spoon.testing.utils.ModelUtils.createFactory;
 
 public class TypeTest {
 
@@ -54,4 +56,10 @@ public class TypeTest {
 		CtTypeReference<?> inface = interfaces.iterator().next();
 		assertNull(inface.getSuperclass());
 	}
+
+	@Test
+	public void testGetUsedTypesForTypeInRootPackage() throws Exception {
+		CtClass<?> cl = createFactory().Code().createCodeSnippetStatement("class X { X x; }").compile();
+		assertEquals(0, cl.getUsedTypes(false).size());
+	}
 }
