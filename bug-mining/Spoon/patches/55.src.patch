diff --git a/src/main/java/spoon/reflect/factory/Factory.java b/src/main/java/spoon/reflect/factory/Factory.java
index 83a4541d2..4985a2eb5 100644
--- a/src/main/java/spoon/reflect/factory/Factory.java
+++ b/src/main/java/spoon/reflect/factory/Factory.java
@@ -40,4 +40,6 @@ public interface Factory {
 	EvalFactory Eval(); // used 4 times
 
 	ConstructorFactory Constructor(); // used 3 times
+
+	InternalFactory Internal();
 }
diff --git a/src/main/java/spoon/reflect/factory/FactoryImpl.java b/src/main/java/spoon/reflect/factory/FactoryImpl.java
index ef79c73ca..43e18aee2 100644
--- a/src/main/java/spoon/reflect/factory/FactoryImpl.java
+++ b/src/main/java/spoon/reflect/factory/FactoryImpl.java
@@ -17,11 +17,6 @@
 
 package spoon.reflect.factory;
 
-import java.io.Serializable;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Random;
-
 import spoon.compiler.Environment;
 import spoon.reflect.cu.CompilationUnit;
 import spoon.reflect.declaration.CtAnnotationType;
@@ -35,8 +30,14 @@ import spoon.reflect.declaration.CtMethod;
 import spoon.reflect.declaration.CtPackage;
 import spoon.reflect.declaration.CtType;
 import spoon.support.DefaultCoreFactory;
+import spoon.support.DefaultInternalFactory;
 import spoon.support.StandardEnvironment;
 
+import java.io.Serializable;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Random;
+
 /**
  * Implements {@link Factory}
  */
@@ -253,6 +254,16 @@ public class FactoryImpl implements Factory, Serializable {
 		return type;
 	}
 
+	private transient InternalFactory internal;
+
+	@Override
+	public InternalFactory Internal() {
+		if (internal == null) {
+			internal = new DefaultInternalFactory(this);
+		}
+		return internal;
+	}
+
 	/**
 	 * A constructor that takes the parent factory
 	 */
diff --git a/src/main/java/spoon/reflect/factory/InternalFactory.java b/src/main/java/spoon/reflect/factory/InternalFactory.java
new file mode 100644
index 000000000..0ac5ef2b9
--- /dev/null
+++ b/src/main/java/spoon/reflect/factory/InternalFactory.java
@@ -0,0 +1,15 @@
+package spoon.reflect.factory;
+
+import spoon.reflect.internal.CtCircularTypeReference;
+
+/**
+ * This interface defines the creation methods for internal nodes of the
+ * meta-model. These nodes are available in the AST provided by Spoon
+ * but their creation should be used only in internal of Spoon.
+ */
+public interface InternalFactory {
+	/**
+	 * Creates a circular type reference.
+	 */
+	<T> CtCircularTypeReference createCircularTypeReference();
+}
diff --git a/src/main/java/spoon/reflect/internal/CtCircularTypeReference.java b/src/main/java/spoon/reflect/internal/CtCircularTypeReference.java
new file mode 100644
index 000000000..905732ca6
--- /dev/null
+++ b/src/main/java/spoon/reflect/internal/CtCircularTypeReference.java
@@ -0,0 +1,16 @@
+package spoon.reflect.internal;
+
+import spoon.reflect.reference.CtTypeParameterReference;
+import spoon.reflect.reference.CtTypeReference;
+
+/**
+ * When we build a {@link CtTypeReference}, we can have a circular when
+ * we got this kind of generic type: {@code <T extends Comparable<? super T>>}.
+ * In this case, where we are at the last T, we come back at the first
+ * one and we are in a circular.
+ *
+ * Now, the last T is a CtCircularTypeReference and we stop the circular
+ * when we build the generic or when we scan an AST given.
+ */
+public interface CtCircularTypeReference extends CtTypeParameterReference {
+}
diff --git a/src/main/java/spoon/reflect/visitor/CtAbstractVisitor.java b/src/main/java/spoon/reflect/visitor/CtAbstractVisitor.java
index 8531d32a1..8eda59fcb 100644
--- a/src/main/java/spoon/reflect/visitor/CtAbstractVisitor.java
+++ b/src/main/java/spoon/reflect/visitor/CtAbstractVisitor.java
@@ -63,6 +63,7 @@ import spoon.reflect.declaration.CtParameter;
 import spoon.reflect.declaration.CtTypeParameter;
 import spoon.reflect.reference.CtArrayTypeReference;
 import spoon.reflect.reference.CtCatchVariableReference;
+import spoon.reflect.internal.CtCircularTypeReference;
 import spoon.reflect.reference.CtExecutableReference;
 import spoon.reflect.reference.CtFieldReference;
 import spoon.reflect.reference.CtLocalVariableReference;
@@ -388,6 +389,11 @@ public abstract class CtAbstractVisitor implements CtVisitor {
 
 	}
 
+	@Override
+	public <T> void visitCtCircularTypeReference(CtCircularTypeReference reference) {
+
+	}
+
 	@Override
 	public <T> void visitCtTypeAccess(CtTypeAccess<T> typeAccess) {
 
diff --git a/src/main/java/spoon/reflect/visitor/CtInheritanceScanner.java b/src/main/java/spoon/reflect/visitor/CtInheritanceScanner.java
index 0ff3b4e31..02c6407a3 100644
--- a/src/main/java/spoon/reflect/visitor/CtInheritanceScanner.java
+++ b/src/main/java/spoon/reflect/visitor/CtInheritanceScanner.java
@@ -97,6 +97,7 @@ import spoon.reflect.declaration.CtTypedElement;
 import spoon.reflect.declaration.CtVariable;
 import spoon.reflect.reference.CtArrayTypeReference;
 import spoon.reflect.reference.CtCatchVariableReference;
+import spoon.reflect.internal.CtCircularTypeReference;
 import spoon.reflect.reference.CtExecutableReference;
 import spoon.reflect.reference.CtFieldReference;
 import spoon.reflect.reference.CtGenericElementReference;
@@ -763,6 +764,11 @@ public abstract class CtInheritanceScanner implements CtVisitor {
 		scanCtVisitable(e);
 	}
 
+	@Override
+	public <T> void visitCtCircularTypeReference(CtCircularTypeReference e) {
+		visitCtTypeParameterReference(e);
+	}
+
 	@Override
 	public <T> void visitCtTypeAccess(CtTypeAccess<T> e) {
 		scanCtExpression(e);
diff --git a/src/main/java/spoon/reflect/visitor/CtScanner.java b/src/main/java/spoon/reflect/visitor/CtScanner.java
index 29cff57a7..d77848d42 100644
--- a/src/main/java/spoon/reflect/visitor/CtScanner.java
+++ b/src/main/java/spoon/reflect/visitor/CtScanner.java
@@ -17,9 +17,6 @@
 
 package spoon.reflect.visitor;
 
-import java.lang.annotation.Annotation;
-import java.util.Collection;
-
 import spoon.reflect.code.CtAnnotationFieldAccess;
 import spoon.reflect.code.CtArrayAccess;
 import spoon.reflect.code.CtArrayRead;
@@ -65,8 +62,8 @@ import spoon.reflect.code.CtTry;
 import spoon.reflect.code.CtTryWithResource;
 import spoon.reflect.code.CtTypeAccess;
 import spoon.reflect.code.CtUnaryOperator;
-import spoon.reflect.code.CtVariableRead;
 import spoon.reflect.code.CtVariableAccess;
+import spoon.reflect.code.CtVariableRead;
 import spoon.reflect.code.CtVariableWrite;
 import spoon.reflect.code.CtWhile;
 import spoon.reflect.declaration.CtAnnotation;
@@ -84,6 +81,7 @@ import spoon.reflect.declaration.CtParameter;
 import spoon.reflect.declaration.CtTypeParameter;
 import spoon.reflect.reference.CtArrayTypeReference;
 import spoon.reflect.reference.CtCatchVariableReference;
+import spoon.reflect.internal.CtCircularTypeReference;
 import spoon.reflect.reference.CtExecutableReference;
 import spoon.reflect.reference.CtFieldReference;
 import spoon.reflect.reference.CtLocalVariableReference;
@@ -94,6 +92,9 @@ import spoon.reflect.reference.CtTypeParameterReference;
 import spoon.reflect.reference.CtTypeReference;
 import spoon.reflect.reference.CtUnboundVariableReference;
 
+import java.lang.annotation.Annotation;
+import java.util.Collection;
+
 /**
  * This visitor implements a deep-search scan on the metamodel.
  */
@@ -683,6 +684,10 @@ public abstract class CtScanner implements CtVisitor {
 		exitReference(reference);
 	}
 
+	@Override
+	public <T> void visitCtCircularTypeReference(CtCircularTypeReference reference) {
+	}
+
 	@Override
 	public <T> void visitCtTypeAccess(CtTypeAccess<T> typeAccess) {
 		enter(typeAccess);
diff --git a/src/main/java/spoon/reflect/visitor/CtVisitor.java b/src/main/java/spoon/reflect/visitor/CtVisitor.java
index 861b0c4cd..1bccf76b1 100644
--- a/src/main/java/spoon/reflect/visitor/CtVisitor.java
+++ b/src/main/java/spoon/reflect/visitor/CtVisitor.java
@@ -79,6 +79,7 @@ import spoon.reflect.declaration.CtParameter;
 import spoon.reflect.declaration.CtTypeParameter;
 import spoon.reflect.reference.CtArrayTypeReference;
 import spoon.reflect.reference.CtCatchVariableReference;
+import spoon.reflect.internal.CtCircularTypeReference;
 import spoon.reflect.reference.CtExecutableReference;
 import spoon.reflect.reference.CtFieldReference;
 import spoon.reflect.reference.CtLocalVariableReference;
@@ -388,6 +389,11 @@ public interface CtVisitor {
 	 */
 	<T> void visitCtTypeReference(CtTypeReference<T> reference);
 
+	/**
+	 * Visits a circular reference.
+	 */
+	<T> void visitCtCircularTypeReference(CtCircularTypeReference reference);
+
 	/**
 	 * Visits a type access.
 	 */
diff --git a/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java b/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java
index 9d4b24f28..ce5abe756 100644
--- a/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java
+++ b/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java
@@ -17,16 +17,6 @@
 
 package spoon.reflect.visitor;
 
-import java.lang.annotation.Annotation;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Map.Entry;
-import java.util.Stack;
-
 import org.apache.log4j.Level;
 import spoon.compiler.Environment;
 import spoon.reflect.code.BinaryOperatorKind;
@@ -77,8 +67,8 @@ import spoon.reflect.code.CtTry;
 import spoon.reflect.code.CtTryWithResource;
 import spoon.reflect.code.CtTypeAccess;
 import spoon.reflect.code.CtUnaryOperator;
-import spoon.reflect.code.CtVariableRead;
 import spoon.reflect.code.CtVariableAccess;
+import spoon.reflect.code.CtVariableRead;
 import spoon.reflect.code.CtVariableWrite;
 import spoon.reflect.code.CtWhile;
 import spoon.reflect.code.UnaryOperatorKind;
@@ -105,6 +95,7 @@ import spoon.reflect.declaration.ParentNotInitializedException;
 import spoon.reflect.factory.Factory;
 import spoon.reflect.reference.CtArrayTypeReference;
 import spoon.reflect.reference.CtCatchVariableReference;
+import spoon.reflect.internal.CtCircularTypeReference;
 import spoon.reflect.reference.CtExecutableReference;
 import spoon.reflect.reference.CtFieldReference;
 import spoon.reflect.reference.CtGenericElementReference;
@@ -120,6 +111,16 @@ import spoon.support.reflect.cu.CtLineElementComparator;
 import spoon.support.util.SortedList;
 import spoon.support.visitor.SignaturePrinter;
 
+import java.lang.annotation.Annotation;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Stack;
+
 /**
  * A visitor for generating Java code from the program compile-time model.
  */
@@ -1828,6 +1829,11 @@ public class DefaultJavaPrettyPrinter implements CtVisitor, PrettyPrinter {
 		}
 	}
 
+	@Override
+	public <T> void visitCtCircularTypeReference(CtCircularTypeReference reference) {
+		visitCtTypeReference(reference);
+	}
+
 	private <T> boolean hasDeclaringTypeWithGenerics(CtTypeReference<T> reference) {
 		// If current reference use generic types, we don't need this hack.
 		if (reference.getActualTypeArguments().size() != 0) {
diff --git a/src/main/java/spoon/support/DefaultInternalFactory.java b/src/main/java/spoon/support/DefaultInternalFactory.java
new file mode 100644
index 000000000..c3efa53ce
--- /dev/null
+++ b/src/main/java/spoon/support/DefaultInternalFactory.java
@@ -0,0 +1,21 @@
+package spoon.support;
+
+import spoon.reflect.factory.Factory;
+import spoon.reflect.factory.InternalFactory;
+import spoon.reflect.internal.CtCircularTypeReference;
+import spoon.support.reflect.internal.CtCircularTypeReferenceImpl;
+
+public class DefaultInternalFactory implements InternalFactory {
+	Factory mainFactory;
+
+	public DefaultInternalFactory(Factory factory) {
+		mainFactory = factory;
+	}
+
+	@Override
+	public <T> CtCircularTypeReference createCircularTypeReference() {
+		CtCircularTypeReference e = new CtCircularTypeReferenceImpl();
+		e.setFactory(mainFactory);
+		return e;
+	}
+}
diff --git a/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java b/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
index 37ef9a628..de4ab3c72 100644
--- a/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
+++ b/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
@@ -17,19 +17,6 @@
 
 package spoon.support.compiler.jdt;
 
-import static spoon.reflect.ModelElementContainerDefaultCapacities.CASTS_CONTAINER_DEFAULT_CAPACITY;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.EnumSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.Stack;
-import java.util.TreeMap;
-import java.util.TreeSet;
-
 import org.apache.log4j.Logger;
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.ASTVisitor;
@@ -151,7 +138,6 @@ import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding;
 import org.eclipse.jdt.internal.compiler.lookup.VariableBinding;
 import org.eclipse.jdt.internal.compiler.lookup.WildcardBinding;
-
 import spoon.reflect.code.BinaryOperatorKind;
 import spoon.reflect.code.CtAnnotationFieldAccess;
 import spoon.reflect.code.CtArrayAccess;
@@ -213,6 +199,7 @@ import spoon.reflect.factory.CoreFactory;
 import spoon.reflect.factory.Factory;
 import spoon.reflect.reference.CtArrayTypeReference;
 import spoon.reflect.reference.CtCatchVariableReference;
+import spoon.reflect.internal.CtCircularTypeReference;
 import spoon.reflect.reference.CtExecutableReference;
 import spoon.reflect.reference.CtFieldReference;
 import spoon.reflect.reference.CtLocalVariableReference;
@@ -225,6 +212,20 @@ import spoon.reflect.visitor.Query;
 import spoon.reflect.visitor.filter.TypeFilter;
 import spoon.support.reflect.reference.CtUnboundVariableReferenceImpl;
 
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.EnumSet;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.Stack;
+import java.util.TreeMap;
+import java.util.TreeSet;
+
+import static spoon.reflect.ModelElementContainerDefaultCapacities.CASTS_CONTAINER_DEFAULT_CAPACITY;
+
 /**
  * A visitor for iterating through the parse tree.
  */
@@ -439,8 +440,7 @@ public class JDTTreeBuilder extends ASTVisitor {
 			return ref;
 		}
 
-		// Map<TypeBinding, CtTypeReference<?>> bindingCache = new
-		// HashMap<TypeBinding, CtTypeReference<?>>();
+		final Map<TypeBinding, CtTypeReference> bindingCache = new HashMap<TypeBinding, CtTypeReference>();
 
 		public <T> CtTypeReference<T> getTypeReference(TypeBinding binding, TypeReference ref) {
 			CtTypeReference<T> ctRef = getTypeReference(binding);
@@ -544,7 +544,7 @@ public class JDTTreeBuilder extends ASTVisitor {
 				}
 				if (bounds && b.superInterfaces != null && b.superInterfaces != Binding.NO_SUPERINTERFACES) {
 					bounds = false;
-					// bindingCache.put(binding, ref);
+					bindingCache.put(binding, ref);
 					for (int i = 0, length = b.superInterfaces.length; i < length; i++) {
 						TypeBinding tb = b.superInterfaces[i];
 						((CtTypeParameterReference) ref).addBound(getTypeReference(tb));
@@ -574,7 +574,18 @@ public class JDTTreeBuilder extends ASTVisitor {
 				}
 
 				if (((WildcardBinding) binding).bound != null && ref instanceof CtTypeParameterReference) {
-					((CtTypeParameterReference) ref).addBound(getTypeReference(((WildcardBinding) binding).bound));
+					if (bindingCache.containsKey(((WildcardBinding) binding).bound)) {
+						final CtCircularTypeReference circularRef = factory.Internal().createCircularTypeReference();
+						final CtTypeReference originalRef = bindingCache.get(((WildcardBinding) binding).bound);
+						circularRef.setPackage(originalRef.getPackage());
+						circularRef.setSimpleName(originalRef.getSimpleName());
+						circularRef.setDeclaringType(originalRef.getDeclaringType());
+						circularRef.setActualTypeArguments(originalRef.getActualTypeArguments());
+						circularRef.setTypeAnnotations(originalRef.getTypeAnnotations());
+						((CtTypeParameterReference) ref).addBound(circularRef);
+					} else {
+						((CtTypeParameterReference) ref).addBound(getTypeReference(((WildcardBinding) binding).bound));
+					}
 				}
 			} else if (binding instanceof LocalTypeBinding) {
 				if (!JDTTreeBuilder.this.context.isGenericTypeExplicit) {
@@ -639,7 +650,7 @@ public class JDTTreeBuilder extends ASTVisitor {
 			} else {
 				throw new RuntimeException("Unknown TypeBinding: " + binding.getClass() + " " + binding);
 			}
-			// bindingCache.remove(binding);
+			bindingCache.remove(binding);
 			addTypeAnnotationFromBindingToReference(binding, ref);
 			return (CtTypeReference<T>) ref;
 		}
diff --git a/src/main/java/spoon/support/reflect/eval/VisitorPartialEvaluator.java b/src/main/java/spoon/support/reflect/eval/VisitorPartialEvaluator.java
index 3b8a64419..ecccc264a 100644
--- a/src/main/java/spoon/support/reflect/eval/VisitorPartialEvaluator.java
+++ b/src/main/java/spoon/support/reflect/eval/VisitorPartialEvaluator.java
@@ -90,6 +90,7 @@ import spoon.reflect.declaration.ModifierKind;
 import spoon.reflect.eval.PartialEvaluator;
 import spoon.reflect.reference.CtArrayTypeReference;
 import spoon.reflect.reference.CtCatchVariableReference;
+import spoon.reflect.internal.CtCircularTypeReference;
 import spoon.reflect.reference.CtExecutableReference;
 import spoon.reflect.reference.CtFieldReference;
 import spoon.reflect.reference.CtGenericElementReference;
@@ -720,6 +721,11 @@ public class VisitorPartialEvaluator implements CtVisitor, PartialEvaluator {
 		throw new RuntimeException("Unknow Element");
 	}
 
+	@Override
+	public <T> void visitCtCircularTypeReference(CtCircularTypeReference reference) {
+		throw new RuntimeException("Unknow Element");
+	}
+
 	@Override
 	public <T> void visitCtTypeAccess(CtTypeAccess<T> typeAccess) {
 		throw new RuntimeException("Unknown Element");
diff --git a/src/main/java/spoon/support/reflect/internal/CtCircularTypeReferenceImpl.java b/src/main/java/spoon/support/reflect/internal/CtCircularTypeReferenceImpl.java
new file mode 100644
index 000000000..b3bca44e4
--- /dev/null
+++ b/src/main/java/spoon/support/reflect/internal/CtCircularTypeReferenceImpl.java
@@ -0,0 +1,12 @@
+package spoon.support.reflect.internal;
+
+import spoon.reflect.internal.CtCircularTypeReference;
+import spoon.reflect.visitor.CtVisitor;
+import spoon.support.reflect.reference.CtTypeParameterReferenceImpl;
+
+public class CtCircularTypeReferenceImpl extends CtTypeParameterReferenceImpl implements CtCircularTypeReference {
+	@Override
+	public void accept(CtVisitor visitor) {
+		visitor.visitCtCircularTypeReference(this);
+	}
+}
diff --git a/src/main/java/spoon/support/visitor/SignaturePrinter.java b/src/main/java/spoon/support/visitor/SignaturePrinter.java
index 17824f8df..e8a9a6bfb 100644
--- a/src/main/java/spoon/support/visitor/SignaturePrinter.java
+++ b/src/main/java/spoon/support/visitor/SignaturePrinter.java
@@ -82,6 +82,7 @@ import spoon.reflect.declaration.CtParameter;
 import spoon.reflect.declaration.CtTypeParameter;
 import spoon.reflect.reference.CtArrayTypeReference;
 import spoon.reflect.reference.CtCatchVariableReference;
+import spoon.reflect.internal.CtCircularTypeReference;
 import spoon.reflect.reference.CtExecutableReference;
 import spoon.reflect.reference.CtFieldReference;
 import spoon.reflect.reference.CtLocalVariableReference;
@@ -621,6 +622,11 @@ public class SignaturePrinter implements CtVisitor {
 		write(reference.getQualifiedName());
 	}
 
+	@Override
+	public <T> void visitCtCircularTypeReference(CtCircularTypeReference reference) {
+		visitCtTypeReference(reference);
+	}
+
 	@Override
 	public <T> void visitCtTypeAccess(CtTypeAccess<T> typeAccess) {
 		scan(typeAccess.getType());
diff --git a/src/test/java/spoon/test/reference/TypeReferenceTest.java b/src/test/java/spoon/test/reference/TypeReferenceTest.java
index 6bb9e2010..b666b28de 100644
--- a/src/test/java/spoon/test/reference/TypeReferenceTest.java
+++ b/src/test/java/spoon/test/reference/TypeReferenceTest.java
@@ -5,15 +5,19 @@ import spoon.Launcher;
 import spoon.compiler.SpoonCompiler;
 import spoon.compiler.SpoonResource;
 import spoon.compiler.SpoonResourceHelper;
+import spoon.reflect.code.CtInvocation;
 import spoon.reflect.declaration.CtField;
 import spoon.reflect.declaration.CtInterface;
 import spoon.reflect.declaration.CtType;
 import spoon.reflect.factory.Factory;
+import spoon.reflect.internal.CtCircularTypeReference;
 import spoon.reflect.reference.CtExecutableReference;
 import spoon.reflect.reference.CtFieldReference;
+import spoon.reflect.reference.CtTypeParameterReference;
 import spoon.reflect.reference.CtTypeReference;
 import spoon.reflect.visitor.Query;
 import spoon.reflect.visitor.filter.ReferenceTypeFilter;
+import spoon.reflect.visitor.filter.TypeFilter;
 
 import java.util.Collection;
 import java.util.List;
@@ -21,6 +25,8 @@ import java.util.List;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
 
 /**
  * @author Lionel Seinturier
@@ -180,6 +186,41 @@ public class TypeReferenceTest {
 		assertNotEquals(firstRef, secondRef);
 	}
 
+	@Test
+	public void testRecursiveTypeReference() throws Exception {
+		final Launcher launcher = new Launcher();
+		launcher.addInputResource("./src/test/java/spoon/test/reference/testclasses/Tacos.java");
+		launcher.setSourceOutputDirectory("./target/spoon-test");
+		launcher.run();
+
+		final CtInvocation<?> inv = Query.getElements(launcher.getFactory(), new TypeFilter<CtInvocation<?>>(CtInvocation.class) {
+			@Override
+			public boolean matches(CtInvocation<?> element) {
+				return !element.getExecutable().isConstructor() && super.matches(element);
+			}
+		}).get(0);
+
+		assertNotNull(inv.getExecutable());
+		final CtTypeReference<?> returnType = inv.getExecutable().getType();
+		assertNotNull(returnType);
+		assertEquals(1, returnType.getActualTypeArguments().size());
+
+		final CtTypeParameterReference genericType = (CtTypeParameterReference) returnType.getActualTypeArguments().get(0);
+		assertNotNull(genericType);
+		assertEquals(1, genericType.getBounds().size());
+
+		final CtTypeReference<?> extendsGeneric = genericType.getBounds().get(0);
+		assertNotNull(extendsGeneric);
+		assertEquals(1, extendsGeneric.getActualTypeArguments().size());
+
+		final CtTypeParameterReference genericExtends = (CtTypeParameterReference) extendsGeneric.getActualTypeArguments().get(0);
+		assertNotNull(genericExtends);
+		assertEquals(1, genericExtends.getBounds().size());
+
+		final CtTypeReference<?> circularRef = genericExtends.getBounds().get(0);
+		assertTrue(circularRef instanceof CtCircularTypeReference);
+	}
+
 	class A {
 		class Tacos<K> {
 		}
diff --git a/src/test/java/spoon/test/reference/testclasses/Tacos.java b/src/test/java/spoon/test/reference/testclasses/Tacos.java
new file mode 100644
index 000000000..ad178b7c9
--- /dev/null
+++ b/src/test/java/spoon/test/reference/testclasses/Tacos.java
@@ -0,0 +1,10 @@
+package spoon.test.reference.testclasses;
+
+import java.util.Comparator;
+
+public class Tacos {
+	@SuppressWarnings({ "unchecked", "rawtypes"})
+	public final void toSortedList() {
+		Comparator.naturalOrder();
+	}
+}
\ No newline at end of file
