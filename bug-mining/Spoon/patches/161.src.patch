diff --git a/src/main/java/spoon/reflect/factory/ExecutableFactory.java b/src/main/java/spoon/reflect/factory/ExecutableFactory.java
index 1320bf6a3..7b1f8ea9f 100644
--- a/src/main/java/spoon/reflect/factory/ExecutableFactory.java
+++ b/src/main/java/spoon/reflect/factory/ExecutableFactory.java
@@ -99,7 +99,10 @@ public class ExecutableFactory extends SubFactory {
 		CtTypeReference<?> refs[] = new CtTypeReference[e.getParameters().size()];
 		int i = 0;
 		for (CtParameter<?> param : e.getParameters()) {
-			refs[i++] = param.getType().clone();
+			if (param.getType() != null) {
+				// With a lambda and in noclasspath (when the type of parameters isn't specified), we don't have a type.
+				refs[i++] = param.getType().clone();
+			}
 		}
 		if (e instanceof CtMethod) {
 			return createReference(((CtMethod<T>) e).getDeclaringType().getReference(), ((CtMethod<T>) e).getType().clone(), e.getSimpleName(), refs);
diff --git a/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilderHelper.java b/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilderHelper.java
index 5ff572762..f830f8da6 100644
--- a/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilderHelper.java
+++ b/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilderHelper.java
@@ -50,6 +50,7 @@ import spoon.reflect.reference.CtArrayTypeReference;
 import spoon.reflect.reference.CtExecutableReference;
 import spoon.reflect.reference.CtFieldReference;
 import spoon.reflect.reference.CtLocalVariableReference;
+import spoon.reflect.reference.CtParameterReference;
 import spoon.reflect.reference.CtReference;
 import spoon.reflect.reference.CtTypeReference;
 import spoon.reflect.reference.CtVariableReference;
@@ -164,6 +165,7 @@ class JDTTreeBuilderHelper {
 		CtVariableReference<T> ref;
 		if (jdtTreeBuilder.getContextBuilder().isBuildLambda) {
 			ref = jdtTreeBuilder.getFactory().Core().createParameterReference();
+			((CtParameterReference) ref).setDeclaringExecutable(jdtTreeBuilder.getReferencesBuilder().getLambdaExecutableReference(singleNameReference));
 		} else {
 			ref = jdtTreeBuilder.getFactory().Core().createLocalVariableReference();
 			((CtLocalVariableReference<T>) ref).setDeclaration(jdtTreeBuilder.getContextBuilder().<T>getLocalVariableDeclaration(name));
diff --git a/src/main/java/spoon/support/compiler/jdt/ReferenceBuilder.java b/src/main/java/spoon/support/compiler/jdt/ReferenceBuilder.java
index 4845f573b..7e0d97cf0 100644
--- a/src/main/java/spoon/support/compiler/jdt/ReferenceBuilder.java
+++ b/src/main/java/spoon/support/compiler/jdt/ReferenceBuilder.java
@@ -66,8 +66,10 @@ import org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding;
 import org.eclipse.jdt.internal.compiler.lookup.VariableBinding;
 import org.eclipse.jdt.internal.compiler.lookup.WildcardBinding;
 import spoon.reflect.code.CtCatchVariable;
+import spoon.reflect.code.CtLambda;
 import spoon.reflect.code.CtLocalVariable;
 import spoon.reflect.declaration.CtPackage;
+import spoon.reflect.declaration.CtParameter;
 import spoon.reflect.declaration.ModifierKind;
 import spoon.reflect.reference.CtArrayTypeReference;
 import spoon.reflect.reference.CtCatchVariableReference;
@@ -492,8 +494,10 @@ public class ReferenceBuilder {
 	private <T> void insertGenericTypesInNoClasspathFromJDTInSpoon(TypeReference original, CtTypeReference<T> type) {
 		if (original.resolvedType instanceof ProblemReferenceBinding && original.getTypeArguments() != null) {
 			for (TypeReference[] typeReferences : original.getTypeArguments()) {
-				for (TypeReference typeReference : typeReferences) {
-					type.addActualTypeArgument(this.getTypeReference(typeReference.resolvedType));
+				if (typeReferences != null) {
+					for (TypeReference typeReference : typeReferences) {
+						type.addActualTypeArgument(this.getTypeReference(typeReference.resolvedType));
+					}
 				}
 			}
 		}
@@ -905,4 +909,42 @@ public class ReferenceBuilder {
 			throw new AssertionError("unexpected declaring type: " + declaring.getClass() + " of " + declaring);
 		}
 	}
+
+	/**
+	 * In noclasspath, lambda doesn't have always a binding for their variables accesses in their block/expression.
+	 * Here, we make the job of JDT and bind their variables accesses to their parameters.
+	 *
+	 * @param singleNameReference Name of the variable access.
+	 * @return executable reference which corresponds to the lambda.
+	 */
+	public CtExecutableReference<?> getLambdaExecutableReference(SingleNameReference singleNameReference) {
+		ASTPair potentialLambda = null;
+		for (ASTPair astPair : jdtTreeBuilder.getContextBuilder().stack) {
+			if (astPair.node instanceof LambdaExpression) {
+				potentialLambda = astPair;
+			}
+		}
+		if (potentialLambda == null) {
+			return null;
+		}
+		LambdaExpression lambdaJDT = (LambdaExpression) potentialLambda.node;
+		for (Argument argument : lambdaJDT.arguments()) {
+			if (CharOperation.equals(argument.name, singleNameReference.token)) {
+				CtTypeReference<?> declaringType = null;
+				if (lambdaJDT.enclosingScope instanceof MethodScope) {
+					declaringType = jdtTreeBuilder.getReferencesBuilder().getTypeReference(((MethodScope) lambdaJDT.enclosingScope).parent.enclosingSourceType());
+				}
+				CtLambda<?> ctLambda = (CtLambda<?>) potentialLambda.element;
+				List<CtTypeReference<?>> parametersType = new ArrayList<>();
+				List<CtParameter<?>> parameters = ctLambda.getParameters();
+				for (CtParameter<?> parameter : parameters) {
+					if (parameter.getType() != null) {
+						parametersType.add(parameter.getType().clone());
+					}
+				}
+				return jdtTreeBuilder.getFactory().Executable().createReference(declaringType, ctLambda.getType(), ctLambda.getSimpleName(), parametersType);
+			}
+		}
+		return null;
+	}
 }
diff --git a/src/test/java/spoon/test/parameters/ParameterTest.java b/src/test/java/spoon/test/parameters/ParameterTest.java
index 6d4b2e0b8..5b784d757 100644
--- a/src/test/java/spoon/test/parameters/ParameterTest.java
+++ b/src/test/java/spoon/test/parameters/ParameterTest.java
@@ -3,8 +3,13 @@ package spoon.test.parameters;
 import org.junit.Test;
 import spoon.Launcher;
 import spoon.reflect.declaration.CtClass;
+import spoon.reflect.declaration.CtMethod;
 import spoon.reflect.declaration.CtParameter;
+import spoon.reflect.reference.CtParameterReference;
 import spoon.reflect.visitor.filter.NameFilter;
+import spoon.reflect.visitor.filter.TypeFilter;
+
+import java.util.List;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
@@ -26,4 +31,33 @@ public class ParameterTest {
 		assertEquals("org.eclipse.swt.graphics.Font", parameter.getType().toString());
 		assertEquals("org.eclipse.swt.graphics.Font font", parameter.toString());
 	}
+
+	@Test
+	public void testGetParameterReferenceInLambdaNoClasspath() throws Exception {
+		Launcher launcher = new Launcher();
+		launcher.addInputResource("./src/test/resources/noclasspath/Tacos.java");
+		launcher.getEnvironment().setNoClasspath(true);
+		launcher.buildModel();
+
+		CtMethod<?> ctMethod = launcher.getFactory().Type().get("Tacos").getMethodsByName("setStarRatings").get(0);
+		CtParameter ctParameter = ctMethod.getBody().getStatement(0).getElements(new TypeFilter<CtParameter>(CtParameter.class) {
+			@Override
+			public boolean matches(CtParameter element) {
+				return "entryPair".equals(element.getSimpleName()) && super.matches(element);
+			}
+		}).get(0);
+		assertNotNull(ctParameter.getReference());
+
+		List<CtParameterReference> elements = ctMethod.getBody().getStatement(0).getElements(new TypeFilter<CtParameterReference>(CtParameterReference.class) {
+			@Override
+			public boolean matches(CtParameterReference element) {
+				return "entryPair".equals(element.getSimpleName()) && super.matches(element);
+			}
+		});
+		assertEquals(2, elements.size());
+		for (CtParameterReference element : elements) {
+			assertEquals(ctParameter, element.getDeclaration());
+			assertEquals(ctParameter.getReference(), element);
+		}
+	}
 }
diff --git a/src/test/resources/noclasspath/Tacos.java b/src/test/resources/noclasspath/Tacos.java
new file mode 100644
index 000000000..b46792edc
--- /dev/null
+++ b/src/test/resources/noclasspath/Tacos.java
@@ -0,0 +1,6 @@
+
+public class Tacos {
+	public void setStarRatings(java.lang.HashMap<ViolationType, java.lang.Integer> userRatings) {
+		userRatings.entrySet().forEach(entryPair -> typeRatingFilters.get(entryPair.getKey()).setCurrentNumberOfStars(entryPair.getValue()));
+	}
+}
\ No newline at end of file
