diff --git a/src/main/java/spoon/reflect/factory/ClassFactory.java b/src/main/java/spoon/reflect/factory/ClassFactory.java
index e168e87aa..a7ffbedfc 100644
--- a/src/main/java/spoon/reflect/factory/ClassFactory.java
+++ b/src/main/java/spoon/reflect/factory/ClassFactory.java
@@ -61,9 +61,9 @@ public class ClassFactory extends TypeFactory {
 		CtClass<T> c = factory.Core().createClass();
 		c.setSimpleName(simpleName);
 		if (owner.getTypes().contains(c)) {
-			owner.getTypes().remove(c);
+			owner.removeType(c);
 		}
-		owner.getTypes().add(c);
+		owner.addType(c);
 		c.setParent(owner);
 		return c;
 	}
diff --git a/src/main/java/spoon/reflect/factory/PackageFactory.java b/src/main/java/spoon/reflect/factory/PackageFactory.java
index 2ae8e9bf9..0500f992e 100644
--- a/src/main/java/spoon/reflect/factory/PackageFactory.java
+++ b/src/main/java/spoon/reflect/factory/PackageFactory.java
@@ -58,7 +58,7 @@ public class PackageFactory extends SubFactory implements Serializable {
 
 		@Override
 		public String getSimpleName() {
-			return "";
+			return super.getSimpleName();
 		}
 
 		@Override
diff --git a/src/main/java/spoon/support/compiler/SnippetCompilationHelper.java b/src/main/java/spoon/support/compiler/SnippetCompilationHelper.java
index 9032e0dd8..31edfbf53 100644
--- a/src/main/java/spoon/support/compiler/SnippetCompilationHelper.java
+++ b/src/main/java/spoon/support/compiler/SnippetCompilationHelper.java
@@ -12,26 +12,27 @@ import spoon.reflect.code.CtExpression;
 import spoon.reflect.code.CtReturn;
 import spoon.reflect.code.CtStatement;
 import spoon.reflect.declaration.CtClass;
+import spoon.reflect.declaration.CtElement;
 import spoon.reflect.declaration.CtMethod;
 import spoon.reflect.declaration.CtParameter;
 import spoon.reflect.declaration.CtType;
 import spoon.reflect.declaration.ModifierKind;
 import spoon.reflect.factory.Factory;
 import spoon.reflect.reference.CtTypeReference;
-import spoon.reflect.visitor.Filter;
-import spoon.reflect.visitor.Query;
 import spoon.support.compiler.jdt.JDTSnippetCompiler;
 import spoon.support.reflect.declaration.CtElementImpl;
 
 public class SnippetCompilationHelper {
 
+	private static final String WRAPPER_CLASS_NAME = "Wrapper";
+	private static final String WRAPPER_METHOD_NAME = "wrap";
+
 	public static void compileAndReplaceSnippetsIn(CtType<?> c) {
 		Factory f = c.getFactory();
 		CtType<?> workCopy = c;
 		Set<ModifierKind> backup = EnumSet.noneOf(ModifierKind.class);
 		backup.addAll(workCopy.getModifiers());
-
-		workCopy.getModifiers().remove(ModifierKind.PUBLIC);
+		workCopy.removeModifier(ModifierKind.PUBLIC);
 
 		try {
 			build(f, workCopy.toString());
@@ -39,7 +40,6 @@ public class SnippetCompilationHelper {
 			// restore modifiers
 			c.setModifiers(backup);
 		}
-
 	}
 
 	public static CtStatement compileStatement(CtCodeSnippetStatement st)
@@ -47,64 +47,41 @@ public class SnippetCompilationHelper {
 		return internalCompileStatement(st);
 	}
 
-	private static CtStatement internalCompileStatement(CtStatement st) {
+	private static CtStatement internalCompileStatement(CtElement st) {
 		Factory f = st.getFactory();
 
 		CtClass<?> w = createWrapper(st, f);
 
-		compile(f, w);
+		build(f, w);
 
-		CtType<?> c = f.Type().get("Wrapper");
+		CtType<?> c = f.Type().get(WRAPPER_CLASS_NAME);
 
 		// Get the part we want
 
-		CtMethod<?> wrapper = Query.getElements(c, new Filter<CtMethod<?>>() {
-
-			public boolean matches(CtMethod<?> element) {
-				return element.getSimpleName().equals("wrap");
-			}
-
-		}).get(0);
+		CtMethod<?> wrapper = c.getMethod(WRAPPER_METHOD_NAME);
 
 		CtStatement ret = wrapper.getBody().getStatements().get(0);
 
 		// Clean up
 		c.getPackage().getTypes().remove(c);
 
-		// check typing?
-
 		return ret;
 	}
 
-	private static CtClass<?> createWrapper(CtStatement st, Factory f) {
-		CtClass<?> w = f.Class().create("Wrapper");
-
-		CtBlock<Void> body = f.Core().createBlock();
-
-		body.addStatement(st);
-
-		Set<ModifierKind> x = EnumSet.noneOf(ModifierKind.class);
+	@SuppressWarnings("unchecked")
+	public static <T> CtExpression<T> compileExpression(
+			CtCodeSnippetExpression<T> expr) throws SnippetCompilationError {
 
-		f.Method().create(
-				w,
-				x,
-				f.Type().createReference(void.class),
-				"wrap",
-				CtElementImpl.<CtParameter<?>>emptyList(),
-				CtElementImpl
-						.<CtTypeReference<? extends Throwable>>emptySet(),
-				body);
+		CtReturn<T> ret = (CtReturn<T>) internalCompileStatement(expr);
 
-		return w;
+		return ret.getReturnedExpression();
 	}
 
-	private static void compile(Factory f, CtType<?> w)
-			throws SnippetCompilationError {
+	private static void build(Factory f, CtType<?> w) {
 
 		String contents = w.toString();
 
 		build(f, contents);
-
 	}
 
 	private static void build(Factory f, String contents) {
@@ -113,63 +90,37 @@ public class SnippetCompilationHelper {
 		try {
 			builder.build();
 		} catch (Exception e) {
-			throw new ModelBuildingException(
-					"snippet compilation error while compiling: " + contents, e);
+			throw new ModelBuildingException("snippet compilation error while compiling: " + contents, e);
 		}
 	}
 
-	@SuppressWarnings("unchecked")
-	public static <T> CtExpression<T> compileExpression(
-			CtCodeSnippetExpression<T> expr) throws SnippetCompilationError {
-		// create wrapping template
-
-		Factory f = expr.getFactory();
-		CtClass<?> w = createWrapper(expr, f);
-
-		String contents = w.toString();
-
-		build(f, contents);
-
-		CtType<?> c = f.Type().get("Wrapper");
-
-		// Get the part we want
-
-		CtMethod<T> wrapper = Query.getElements(c, new Filter<CtMethod<T>>() {
-
-			public boolean matches(CtMethod<T> element) {
-				return element.getSimpleName().equals("wrap");
-			}
-
-		}).get(0);
-
-		CtReturn<T> ret = (CtReturn<T>) wrapper.getBody().getStatements()
-				.get(0);
+	private static CtClass<?> createWrapper(CtElement element, Factory f) {
+		CtClass<?> w = f.Class().create(WRAPPER_CLASS_NAME);
 
 		// Clean up (delete wrapper from factory)
-		c.getPackage().getTypes().remove(c);
-
-		return ret.getReturnedExpression();
-	}
-
-	private static <R, B extends R> CtClass<?> createWrapper(
-			CtExpression<B> st, Factory f) {
-		CtClass<?> w = f.Class().create("Wrapper");
-
-		CtBlock<B> body = f.Core().createBlock();
-		CtReturn<B> ret = f.Core().createReturn();
-		ret.setReturnedExpression(st);
-		body.addStatement(ret);
+		w.getPackage().getTypes().remove(w);
+
+		CtBlock body = f.Core().createBlock();
+
+		CtTypeReference returnType = f.Type().VOID_PRIMITIVE;
+		if (element instanceof CtStatement) {
+			body.addStatement((CtStatement) element);
+		} else if (element instanceof CtExpression) {
+			CtReturn ret = f.Core().createReturn();
+			ret.setReturnedExpression((CtExpression) element);
+			body.addStatement(ret);
+			returnType = f.Type().OBJECT;
+		}
 
-		Set<ModifierKind> x = EnumSet.noneOf(ModifierKind.class);
+		Set<ModifierKind> modifiers = EnumSet.noneOf(ModifierKind.class);
 
 		f.Method().create(
 				w,
-				x,
-				f.Type().createReference(Object.class),
-				"wrap",
+				modifiers,
+				returnType,
+				WRAPPER_METHOD_NAME,
 				CtElementImpl.<CtParameter<?>>emptyList(),
-				CtElementImpl
-						.<CtTypeReference<? extends Throwable>>emptySet(),
+				CtElementImpl.<CtTypeReference<? extends Throwable>>emptySet(),
 				body);
 
 		return w;
