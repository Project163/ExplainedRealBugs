diff --git a/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java b/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java
index b62856b26..11975d0b1 100644
--- a/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java
+++ b/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java
@@ -118,6 +118,7 @@ import spoon.reflect.reference.CtTypeReference;
 import spoon.reflect.reference.CtUnboundVariableReference;
 import spoon.support.reflect.cu.CtLineElementComparator;
 import spoon.support.util.SortedList;
+import spoon.support.visitor.SignaturePrinter;
 
 /**
  * A visitor for generating Java code from the program compile-time model.
@@ -943,15 +944,9 @@ public class DefaultJavaPrettyPrinter implements CtVisitor, PrettyPrinter {
 	}
 
 	public <T> void visitCtExecutableReference(CtExecutableReference<T> reference) {
-		scan(reference.getDeclaringType());
-		write(".");
-		if (reference.getSimpleName().equals("<init>")) {
-			write(reference.getDeclaringType().getSimpleName());
-		} else {
-			write(reference.getSimpleName());
-		}
-		writeActualTypeArguments(reference);
-		writeParameters(reference.getActualTypeArguments());
+		SignaturePrinter pr = new SignaturePrinter();
+		pr.scan(reference);
+		write(pr.getSignature());
 	}
 
 	public <T> void visitCtField(CtField<T> f) {
diff --git a/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java b/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
index 5a9392e56..bd889f8ee 100644
--- a/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
+++ b/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
@@ -2218,6 +2218,22 @@ public class JDTTreeBuilder extends ASTVisitor {
 			} else {
 				CtExecutableReference<Object> ref = factory.Core().createExecutableReference();
 				ref.setSimpleName(new String(messageSend.selector));
+				ref.setType(references.getTypeReference(messageSend.expectedType()));
+				if (messageSend.receiver.resolvedType == null && messageSend.receiver instanceof SingleNameReference) {
+					// It is crisis dude! static context, we don't have much more information.
+					final CtTypeReference<Object> typeReference = factory.Core().createTypeReference();
+					typeReference.setSimpleName(new String(((SingleNameReference) messageSend.receiver).binding.readableName()));
+					ref.setDeclaringType(typeReference);
+				} else {
+					ref.setDeclaringType(references.getTypeReference(messageSend.receiver.resolvedType));
+				}
+				if (messageSend.arguments != null) {
+					final List<CtTypeReference<?>> parameters = new ArrayList<CtTypeReference<?>>();
+					for (Expression argument : messageSend.arguments) {
+						parameters.add(references.getTypeReference(argument.resolvedType));
+					}
+					ref.setParameters(parameters);
+				}
 				inv.setExecutable(ref);
 			}
 			// inv
@@ -2614,7 +2630,14 @@ public class JDTTreeBuilder extends ASTVisitor {
 			ta.setType(references.getTypeReference((TypeBinding) singleNameReference.binding));
 			context.enter(ta, singleNameReference);
 		} else if (singleNameReference.binding instanceof ProblemBinding) {
-			if (context.stack.peek().element instanceof CtAssignment) {
+			if (context.stack.peek().element instanceof CtInvocation) {
+				final CtTypeAccess<Object> ta = factory.Core().createTypeAccess();
+				final CtTypeReference<Object> typeReference = factory.Core().createTypeReference();
+				typeReference.setSimpleName(new String(singleNameReference.binding.readableName()));
+				ta.setType(typeReference);
+				context.enter(ta, singleNameReference);
+				return true;
+			} else if (context.stack.peek().element instanceof CtAssignment) {
 				va = factory.Core().createFieldWrite();
 			} else {
 				va = factory.Core().createFieldRead();
diff --git a/src/main/java/spoon/support/visitor/SignaturePrinter.java b/src/main/java/spoon/support/visitor/SignaturePrinter.java
index b0b7e343e..2405c7a82 100644
--- a/src/main/java/spoon/support/visitor/SignaturePrinter.java
+++ b/src/main/java/spoon/support/visitor/SignaturePrinter.java
@@ -273,19 +273,22 @@ public class SignaturePrinter implements CtVisitor {
 		write("enum ").write(ctEnum.getQualifiedName());
 	}
 
-	public <T> void visitCtExecutableReference(
-			CtExecutableReference<T> reference) {
-		if (reference.getDeclaringType() != null) { // null in noclasspath
-			write(reference.getDeclaringType().getQualifiedName());
-		}
+	public <T> void visitCtExecutableReference(CtExecutableReference<T> reference) {
+		scan(reference.getDeclaringType());
+
 		write(CtExecutable.EXECUTABLE_SEPARATOR);
-		write(reference.getSimpleName());
-		write("(");
-		for (CtTypeReference<?> ref : reference.getActualTypeArguments()) {
-			scan(ref);
-			write(",");
+		if (reference.isConstructor()) {
+			write(reference.getDeclaringType().getSimpleName());
+		} else {
+			write(reference.getSimpleName());
 		}
-		if (!reference.getActualTypeArguments().isEmpty()) {
+		write("(");
+		if (reference.getParameters().size() > 0) {
+			for (CtTypeReference<?> param : reference.getParameters()) {
+				scan(param);
+				write(", ");
+			}
+			clearLast();
 			clearLast();
 		}
 		write(")");
diff --git a/src/test/java/spoon/test/reference/ExecutableReferenceGenericTest.java b/src/test/java/spoon/test/reference/ExecutableReferenceGenericTest.java
index f551cf3a2..33389cb00 100644
--- a/src/test/java/spoon/test/reference/ExecutableReferenceGenericTest.java
+++ b/src/test/java/spoon/test/reference/ExecutableReferenceGenericTest.java
@@ -228,7 +228,7 @@ public class ExecutableReferenceGenericTest {
 		assertEquals(9, refsExecutableClass1.size());
 		for (CtExecutableReference<?> ref : refsExecutableClass1) {
 			assertNotNull(ref);
-			if (!ref.toString().equals("java.lang.Object.Object")) {
+			if (!ref.toString().equals("java.lang.Object#Object()")) {
 				assertNotNull(ref.getDeclaration());
 			}
 		}
@@ -236,7 +236,7 @@ public class ExecutableReferenceGenericTest {
 		assertEquals(9, refsExecutableClass2.size());
 		for (CtExecutableReference<?> ref : refsExecutableClass2) {
 			assertNotNull(ref);
-			if (!ref.toString().equals("java.lang.Object.Object")) {
+			if (!ref.toString().equals("java.lang.Object#Object()")) {
 				assertNotNull(ref.getDeclaration());
 			}
 		}
diff --git a/src/test/java/spoon/test/reference/ExecutableReferenceTest.java b/src/test/java/spoon/test/reference/ExecutableReferenceTest.java
new file mode 100644
index 000000000..037c0c4c1
--- /dev/null
+++ b/src/test/java/spoon/test/reference/ExecutableReferenceTest.java
@@ -0,0 +1,81 @@
+package spoon.test.reference;
+
+import org.junit.Test;
+import spoon.Launcher;
+import spoon.reflect.code.CtInvocation;
+import spoon.reflect.declaration.CtElement;
+import spoon.reflect.reference.CtExecutableReference;
+import spoon.reflect.visitor.Query;
+import spoon.reflect.visitor.filter.AbstractFilter;
+import spoon.reflect.visitor.filter.ReferenceTypeFilter;
+import spoon.reflect.visitor.filter.TypeFilter;
+
+import java.util.List;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+
+public class ExecutableReferenceTest {
+	@Test
+	public void testCallMethodOfClassNotPresent() throws Exception {
+		final Launcher launcher = new Launcher();
+		launcher.run(new String[] {
+				"-i", "./src/test/resources/executable-reference", "-o", "./target/spooned/test/resources", "--noclasspath"
+		});
+		final List<CtExecutableReference<?>> references = Query.getReferences(launcher.getFactory(), new ReferenceTypeFilter<CtExecutableReference<?>>(CtExecutableReference.class) {
+			@Override
+			public boolean matches(CtExecutableReference<?> reference) {
+				return !reference.isConstructor() && super.matches(reference);
+			}
+		});
+
+		final List<CtInvocation<?>> invocations = Query.getElements(launcher.getFactory(), new TypeFilter<CtInvocation<?>>(CtInvocation.class) {
+			@Override
+			public boolean matches(CtInvocation<?> element) {
+				return !element.getExecutable().isConstructor() && super.matches(element);
+			}
+		});
+
+		assertEquals(4, references.size());
+		assertEquals(4, invocations.size());
+
+		// Executable reference with 0 parameter.
+		final CtExecutableReference<?> executableZeroParameter = references.get(0);
+		assertNotNull(executableZeroParameter.getDeclaringType());
+		assertNull(executableZeroParameter.getType());
+		assertEquals(0, executableZeroParameter.getParameters().size());
+		assertEquals("Bar#m()", executableZeroParameter.toString());
+		assertEquals("new Bar().m()", invocations.get(0).toString());
+
+		// Executable reference with 1 parameter and return type.
+		final CtExecutableReference<?> executableOneParameter = references.get(1);
+		assertNotNull(executableOneParameter.getDeclaringType());
+		assertNotNull(executableOneParameter.getType());
+		assertEquals(1, executableOneParameter.getParameters().size());
+		assertNotEquals(executableZeroParameter, executableOneParameter);
+		assertEquals("Bar#m(int)", executableOneParameter.toString());
+		assertEquals("bar.m(1)", invocations.get(1).toString());
+
+		// Executable reference with 2 parameters.
+		final CtExecutableReference<?> executableTwoParameters = references.get(2);
+		assertNotNull(executableTwoParameters.getDeclaringType());
+		assertNull(executableTwoParameters.getType());
+		assertEquals(2, executableTwoParameters.getParameters().size());
+		assertNotEquals(executableTwoParameters, executableZeroParameter);
+		assertNotEquals(executableTwoParameters, executableOneParameter);
+		assertEquals("Bar#m(int, java.lang.String)", executableTwoParameters.toString());
+		assertEquals("new Bar().m(1, \"5\")", invocations.get(2).toString());
+
+		// Static Executable reference.
+		final CtExecutableReference<?> staticExecutable = references.get(3);
+		assertNotNull(staticExecutable.getDeclaringType());
+		assertNull(staticExecutable.getType());
+		assertEquals(1, staticExecutable.getParameters().size());
+		assertNotEquals(staticExecutable, executableZeroParameter);
+		assertNotEquals(staticExecutable, executableOneParameter);
+		assertEquals("Bar#m(java.lang.String)", staticExecutable.toString());
+		assertEquals("Bar.m(\"42\")", invocations.get(3).toString());
+	}
+}
diff --git a/src/test/java/spoon/test/secondaryclasses/ClassesTest.java b/src/test/java/spoon/test/secondaryclasses/ClassesTest.java
index 8d5838375..44ad22e62 100644
--- a/src/test/java/spoon/test/secondaryclasses/ClassesTest.java
+++ b/src/test/java/spoon/test/secondaryclasses/ClassesTest.java
@@ -84,7 +84,7 @@ public class ClassesTest {
 
 		assertNotNull(y.getType().getDeclaration());
 
-		assertEquals("spoon.test.secondaryclasses.AnonymousClass.2.2", y.getExecutable().toString());
+		assertEquals("spoon.test.secondaryclasses.AnonymousClass$2#2()", y.getExecutable().toString());
 
 		assertEquals(type.getFactory().Type().createReference(I.class), y.getAnonymousClass().getSuperInterfaces().toArray(new CtTypeReference[0])[0]);
 
diff --git a/src/test/resources/executable-reference/Foo.java b/src/test/resources/executable-reference/Foo.java
new file mode 100644
index 000000000..c8f8b4fd1
--- /dev/null
+++ b/src/test/resources/executable-reference/Foo.java
@@ -0,0 +1,9 @@
+public class Foo {
+	public void m() {
+		new Bar().m();
+		final Bar bar = new Bar("");
+		final Tacos t = bar.m(1);
+		new Bar().m(1, "5");
+		Bar.m("42")
+	}
+}
\ No newline at end of file
