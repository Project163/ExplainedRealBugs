diff --git a/spoon-smpl/src/main/java/spoon/smpl/SmPLMethodCFG.java b/spoon-smpl/src/main/java/spoon/smpl/SmPLMethodCFG.java
index 335de57b7..4fa92ccf9 100644
--- a/spoon-smpl/src/main/java/spoon/smpl/SmPLMethodCFG.java
+++ b/spoon-smpl/src/main/java/spoon/smpl/SmPLMethodCFG.java
@@ -32,6 +32,8 @@ import spoon.reflect.code.CtAssignment;
 import spoon.reflect.code.CtBreak;
 import spoon.reflect.code.CtConditional;
 import spoon.reflect.code.CtExpression;
+import spoon.reflect.code.CtFor;
+import spoon.reflect.code.CtForEach;
 import spoon.reflect.code.CtIf;
 import spoon.reflect.code.CtInvocation;
 import spoon.reflect.code.CtLiteral;
@@ -58,11 +60,14 @@ import java.util.HashSet;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
+import java.util.Optional;
 import java.util.Set;
 
 import static fr.inria.controlflow.NaiveExceptionControlFlowStrategy.Options.AddPathsForEmptyTryBlocks;
 import static fr.inria.controlflow.NaiveExceptionControlFlowStrategy.Options.ReturnWithoutFinalizers;
 
+import org.slf4j.LoggerFactory;
+
 // TODO: rename since its not just methods but rather executables?
 
 /**
@@ -117,6 +122,16 @@ public class SmPLMethodCFG {
 			replace(whileLoop);
 		}
 
+		@Override
+		public void visitCtFor(CtFor forLoop) {
+			replace(forLoop);
+		}
+
+		@Override
+		public void visitCtForEach(CtForEach forLoop) {
+			replace(forLoop);
+		}
+
 		@Override
 		public void visitCtBreak(CtBreak breakStatement) {
 			replace(breakStatement);
@@ -163,12 +178,45 @@ public class SmPLMethodCFG {
 				throw new IllegalStateException("there should never be a call to replace() while restoring");
 			}
 
+			logReplacementWarning(e);
+
 			swappedElements.put(swapIndex, e);
 			e.replace(createReplacementInvocation(e.getFactory(), swapIndex));
 
 			swapIndex += 1;
 		}
 
+		/**
+		 * Log a warning about a replaced element.
+		 * @param e Element about to be replaced
+		 */
+		private void logReplacementWarning(CtElement e) {
+			String file = Optional.ofNullable(e.getPosition())
+									.map(x -> x.getFile())
+									.map(x -> x.getName())
+									.orElse("[unknown file]");
+
+			String line = Optional.ofNullable(e.getPosition())
+									.map(x -> x.getLine())
+									.map(x -> Integer.toString(x))
+									.orElse("-");
+
+			String code = Optional.ofNullable(e.getPosition())
+									.map(x -> x.getFile())
+									.map(x -> e.getOriginalSourceFragment())
+									.map(x -> x.getSourceCode())
+									.orElse(e.toString());
+
+			code = code.strip()
+				.replace("\n", " ")
+				.substring(0, Math.min(40, code.length()));
+
+			LoggerFactory.getLogger("spoon-smpl")
+					.warn("Unsupported element excluded from control flow graph: "
+						+ e.getClass().getSimpleName()
+						+ "(" + file + ":" + line + " \"" +  code + " ..\")");
+		}
+
 		/**
 		 * Create a marker element for substituting a single unsupported element.
 		 *
diff --git a/spoon-smpl/src/test/java/spoon/smpl/SmPLMethodCFGTest.java b/spoon-smpl/src/test/java/spoon/smpl/SmPLMethodCFGTest.java
index 49eda2703..8de7b2c55 100644
--- a/spoon-smpl/src/test/java/spoon/smpl/SmPLMethodCFGTest.java
+++ b/spoon-smpl/src/test/java/spoon/smpl/SmPLMethodCFGTest.java
@@ -25,8 +25,11 @@ package spoon.smpl;
 import fr.inria.controlflow.*;
 import org.junit.jupiter.api.Test;
 import spoon.Launcher;
+import spoon.reflect.code.CtFor;
+import spoon.reflect.code.CtForEach;
 import spoon.reflect.declaration.CtClass;
 import spoon.reflect.declaration.CtMethod;
+import spoon.reflect.visitor.filter.TypeFilter;
 import spoon.support.compiler.VirtualFile;
 import static org.junit.jupiter.api.Assertions.*;
 
@@ -132,4 +135,52 @@ public class SmPLMethodCFGTest {
 
 		assertFalse(method.toString().contains("__SmPLUnsupported__"));
 	}
+
+	@Test
+	public void testForLoopUnsupportedSwap() {
+
+		// contract: the UnsupportedElementSwapper should replace CtFor elements
+
+		Launcher launcher = new Launcher();
+		launcher.getEnvironment().setAutoImports(false);
+		launcher.addInputResource(new VirtualFile("class A {\n" +
+												  "  private void forLoop() {\n" +
+												  "    for (int i = 0; i < 10; ++i) {\n" +
+												  "      System.out.println(i);\n" +
+												  "    }\n" +
+												  "  }\n" +
+												  "}\n"));
+		launcher.buildModel();
+		CtMethod<?> method = launcher.getModel().getRootPackage().getType("A").getMethodsByName("forLoop").get(0);
+
+		assertTrue(method.filterChildren(new TypeFilter<>(CtFor.class)).list().size() == 1);
+
+		SmPLMethodCFG.UnsupportedElementSwapper ues = new SmPLMethodCFG.UnsupportedElementSwapper(method);
+
+		assertTrue(method.filterChildren(new TypeFilter<>(CtFor.class)).list().size() == 0);
+	}
+
+	@Test
+	public void testForEachLoopUnsupportedSwap() {
+
+		// contract: the UnsupportedElementSwapper should replace CtForEach elements
+
+		Launcher launcher = new Launcher();
+		launcher.getEnvironment().setAutoImports(false);
+		launcher.addInputResource(new VirtualFile("class A {\n" +
+												  "  private void forEachLoop() {\n" +
+												  "    for (int i : Arrays.asList(1, 2, 3, 4)) {\n" +
+												  "      System.out.println(i);\n" +
+												  "    }\n" +
+												  "  }\n" +
+												  "}\n"));
+		launcher.buildModel();
+		CtMethod<?> method = launcher.getModel().getRootPackage().getType("A").getMethodsByName("forEachLoop").get(0);
+
+		assertTrue(method.filterChildren(new TypeFilter<>(CtForEach.class)).list().size() == 1);
+
+		SmPLMethodCFG.UnsupportedElementSwapper ues = new SmPLMethodCFG.UnsupportedElementSwapper(method);
+
+		assertTrue(method.filterChildren(new TypeFilter<>(CtForEach.class)).list().size() == 0);
+	}
 }
