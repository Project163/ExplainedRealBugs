diff --git a/src/main/java/spoon/reflect/declaration/CtAnnotationMethod.java b/src/main/java/spoon/reflect/declaration/CtAnnotationMethod.java
new file mode 100644
index 000000000..4e037cfbf
--- /dev/null
+++ b/src/main/java/spoon/reflect/declaration/CtAnnotationMethod.java
@@ -0,0 +1,37 @@
+/**
+ * Copyright (C) 2006-2016 INRIA and contributors
+ * Spoon - http://spoon.gforge.inria.fr/
+ *
+ * This software is governed by the CeCILL-C License under French law and
+ * abiding by the rules of distribution of free software. You can use, modify
+ * and/or redistribute the software under the terms of the CeCILL-C license as
+ * circulated by CEA, CNRS and INRIA at http://www.cecill.info.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the CeCILL-C License for more details.
+ *
+ * The fact that you are presently reading this means that you have had
+ * knowledge of the CeCILL-C license and that you accept its terms.
+ */
+package spoon.reflect.declaration;
+
+import spoon.reflect.code.CtExpression;
+
+/**
+ * This element defines an annotation method declared in an annotation type.
+ */
+public interface CtAnnotationMethod<T> extends CtMethod<T> {
+	/**
+	 * Gets the default expression assigned to the annotation method.
+	 */
+	CtExpression<T> getDefaultExpression();
+
+	/**
+	 * Sets the default expression assigned to the annotation method.
+	 */
+	<C extends CtAnnotationMethod<T>> C setDefaultExpression(CtExpression<T> assignedExpression);
+
+	@Override
+	CtAnnotationMethod<T> clone();
+}
diff --git a/src/main/java/spoon/reflect/declaration/CtAnnotationType.java b/src/main/java/spoon/reflect/declaration/CtAnnotationType.java
index adf570845..ca1ef47b3 100644
--- a/src/main/java/spoon/reflect/declaration/CtAnnotationType.java
+++ b/src/main/java/spoon/reflect/declaration/CtAnnotationType.java
@@ -17,11 +17,32 @@
 package spoon.reflect.declaration;
 
 import java.lang.annotation.Annotation;
+import java.util.Set;
 
 /**
  * This element defines an annotation type.
  */
 public interface CtAnnotationType<T extends Annotation> extends CtType<T> {
+
+	/**
+	 * Gets the methods of this annotation type which are necessarily {@link CtAnnotationMethod}.
+	 */
+	Set<CtAnnotationMethod<?>> getAnnotationMethods();
+
+	/**
+	 * {@inheritDoc}
+	 * The method passed as parameter must be a {@link CtAnnotationMethod}.
+	 */
+	@Override
+	<M, C extends CtType<T>> C addMethod(CtMethod<M> method);
+
+	/**
+	 * {@inheritDoc}
+	 * The methods passed as parameter must be typed by {@link CtAnnotationMethod}.
+	 */
+	@Override
+	<C extends CtType<T>> C setMethods(Set<CtMethod<?>> methods);
+
 	@Override
 	CtAnnotationType<T> clone();
 }
diff --git a/src/main/java/spoon/reflect/factory/AnnotationFactory.java b/src/main/java/spoon/reflect/factory/AnnotationFactory.java
index 7ffc01d78..00da96982 100644
--- a/src/main/java/spoon/reflect/factory/AnnotationFactory.java
+++ b/src/main/java/spoon/reflect/factory/AnnotationFactory.java
@@ -19,7 +19,7 @@ package spoon.reflect.factory;
 import spoon.reflect.declaration.CtAnnotation;
 import spoon.reflect.declaration.CtAnnotationType;
 import spoon.reflect.declaration.CtElement;
-import spoon.reflect.declaration.CtField;
+import spoon.reflect.declaration.CtMethod;
 import spoon.reflect.declaration.CtPackage;
 import spoon.reflect.declaration.CtType;
 import spoon.reflect.reference.CtArrayTypeReference;
@@ -113,7 +113,7 @@ public class AnnotationFactory extends TypeFactory {
 		// try with CT reflection
 		CtAnnotationType<A> ctAnnotationType = ((CtAnnotationType<A>) annotation.getAnnotationType().getDeclaration());
 		if (ctAnnotationType != null) {
-			CtField<?> e = ctAnnotationType.getField(annotationElementName);
+			CtMethod<?> e = ctAnnotationType.getMethod(annotationElementName);
 			isArray = (e.getType() instanceof CtArrayTypeReference);
 		} else {
 			Method m;
diff --git a/src/main/java/spoon/reflect/factory/CoreFactory.java b/src/main/java/spoon/reflect/factory/CoreFactory.java
index dcf08d4bb..cbbb9f0c6 100644
--- a/src/main/java/spoon/reflect/factory/CoreFactory.java
+++ b/src/main/java/spoon/reflect/factory/CoreFactory.java
@@ -65,6 +65,7 @@ import spoon.reflect.code.CtWhile;
 import spoon.reflect.cu.CompilationUnit;
 import spoon.reflect.cu.SourcePosition;
 import spoon.reflect.declaration.CtAnnotation;
+import spoon.reflect.declaration.CtAnnotationMethod;
 import spoon.reflect.declaration.CtAnnotationType;
 import spoon.reflect.declaration.CtAnonymousExecutable;
 import spoon.reflect.declaration.CtClass;
@@ -305,6 +306,11 @@ public interface CoreFactory {
 	 */
 	<T> CtMethod<T> createMethod();
 
+	/**
+	 * Creates an annotation method.
+	 */
+	<T> CtAnnotationMethod<T> createAnnotationMethod();
+
 	/**
 	 * Creates a new array expression.
 	 */
diff --git a/src/main/java/spoon/reflect/visitor/CtAbstractVisitor.java b/src/main/java/spoon/reflect/visitor/CtAbstractVisitor.java
index 28af0af52..d1b84cae1 100644
--- a/src/main/java/spoon/reflect/visitor/CtAbstractVisitor.java
+++ b/src/main/java/spoon/reflect/visitor/CtAbstractVisitor.java
@@ -63,6 +63,7 @@ import spoon.reflect.code.CtVariableRead;
 import spoon.reflect.code.CtVariableWrite;
 import spoon.reflect.code.CtWhile;
 import spoon.reflect.declaration.CtAnnotation;
+import spoon.reflect.declaration.CtAnnotationMethod;
 import spoon.reflect.declaration.CtAnnotationType;
 import spoon.reflect.declaration.CtAnonymousExecutable;
 import spoon.reflect.declaration.CtClass;
@@ -274,6 +275,11 @@ public abstract class CtAbstractVisitor implements CtVisitor {
 
 	}
 
+	@Override
+	public <T> void visitCtAnnotationMethod(CtAnnotationMethod<T> annotationMethod) {
+
+	}
+
 	@Override
 	public <T> void visitCtNewArray(CtNewArray<T> newArray) {
 
diff --git a/src/main/java/spoon/reflect/visitor/CtBiScannerDefault.java b/src/main/java/spoon/reflect/visitor/CtBiScannerDefault.java
index a7c85ee62..90b8dbe81 100644
--- a/src/main/java/spoon/reflect/visitor/CtBiScannerDefault.java
+++ b/src/main/java/spoon/reflect/visitor/CtBiScannerDefault.java
@@ -17,7 +17,6 @@
 
 package spoon.reflect.visitor;
 
-
 /**
  * This visitor implements a deep-search scan on the model for 2 elements.
  *
@@ -419,6 +418,17 @@ public abstract class CtBiScannerDefault extends spoon.reflect.visitor.CtAbstrac
 		exit(m);
 	}
 
+	@java.lang.Override
+	public <T> void visitCtAnnotationMethod(spoon.reflect.declaration.CtAnnotationMethod<T> annotationMethod) {
+		spoon.reflect.declaration.CtAnnotationMethod other = ((spoon.reflect.declaration.CtAnnotationMethod) (stack.peek()));
+		enter(annotationMethod);
+		biScan(annotationMethod.getAnnotations(), other.getAnnotations());
+		biScan(annotationMethod.getType(), other.getType());
+		biScan(annotationMethod.getDefaultExpression(), other.getDefaultExpression());
+		biScan(annotationMethod.getComments(), other.getComments());
+		exit(annotationMethod);
+	}
+
 	public <T> void visitCtNewArray(final spoon.reflect.code.CtNewArray<T> newArray) {
 		spoon.reflect.code.CtNewArray other = ((spoon.reflect.code.CtNewArray) (stack.peek()));
 		enter(newArray);
diff --git a/src/main/java/spoon/reflect/visitor/CtInheritanceScanner.java b/src/main/java/spoon/reflect/visitor/CtInheritanceScanner.java
index d4c397aaf..5a1f5d55d 100644
--- a/src/main/java/spoon/reflect/visitor/CtInheritanceScanner.java
+++ b/src/main/java/spoon/reflect/visitor/CtInheritanceScanner.java
@@ -72,6 +72,7 @@ import spoon.reflect.code.CtVariableRead;
 import spoon.reflect.code.CtVariableWrite;
 import spoon.reflect.code.CtWhile;
 import spoon.reflect.declaration.CtAnnotation;
+import spoon.reflect.declaration.CtAnnotationMethod;
 import spoon.reflect.declaration.CtAnnotationType;
 import spoon.reflect.declaration.CtAnonymousExecutable;
 import spoon.reflect.declaration.CtClass;
@@ -636,6 +637,11 @@ public abstract class CtInheritanceScanner implements CtVisitor {
 		scanCtVisitable(e);
 	}
 
+	@Override
+	public <T> void visitCtAnnotationMethod(CtAnnotationMethod<T> annotationMethod) {
+		visitCtMethod(annotationMethod);
+	}
+
 	public <T> void visitCtNewArray(CtNewArray<T> e) {
 		scanCtExpression(e);
 		scanCtCodeElement(e);
diff --git a/src/main/java/spoon/reflect/visitor/CtScanner.java b/src/main/java/spoon/reflect/visitor/CtScanner.java
index dd4bb72b6..a1c9c0591 100644
--- a/src/main/java/spoon/reflect/visitor/CtScanner.java
+++ b/src/main/java/spoon/reflect/visitor/CtScanner.java
@@ -64,6 +64,7 @@ import spoon.reflect.code.CtVariableRead;
 import spoon.reflect.code.CtVariableWrite;
 import spoon.reflect.code.CtWhile;
 import spoon.reflect.declaration.CtAnnotation;
+import spoon.reflect.declaration.CtAnnotationMethod;
 import spoon.reflect.declaration.CtAnnotationType;
 import spoon.reflect.declaration.CtAnonymousExecutable;
 import spoon.reflect.declaration.CtClass;
@@ -529,6 +530,16 @@ public abstract class CtScanner implements CtVisitor {
 		exit(m);
 	}
 
+	@Override
+	public <T> void visitCtAnnotationMethod(CtAnnotationMethod<T> annotationMethod) {
+		enter(annotationMethod);
+		scan(annotationMethod.getAnnotations());
+		scan(annotationMethod.getType());
+		scan(annotationMethod.getDefaultExpression());
+		scan(annotationMethod.getComments());
+		exit(annotationMethod);
+	}
+
 	public <T> void visitCtNewArray(final CtNewArray<T> newArray) {
 		enter(newArray);
 		scan(newArray.getAnnotations());
diff --git a/src/main/java/spoon/reflect/visitor/CtVisitor.java b/src/main/java/spoon/reflect/visitor/CtVisitor.java
index c443cf751..ab13dfd3b 100644
--- a/src/main/java/spoon/reflect/visitor/CtVisitor.java
+++ b/src/main/java/spoon/reflect/visitor/CtVisitor.java
@@ -63,6 +63,7 @@ import spoon.reflect.code.CtVariableRead;
 import spoon.reflect.code.CtVariableWrite;
 import spoon.reflect.code.CtWhile;
 import spoon.reflect.declaration.CtAnnotation;
+import spoon.reflect.declaration.CtAnnotationMethod;
 import spoon.reflect.declaration.CtAnnotationType;
 import spoon.reflect.declaration.CtAnonymousExecutable;
 import spoon.reflect.declaration.CtClass;
@@ -286,6 +287,11 @@ public interface CtVisitor {
 	 */
 	<T> void visitCtMethod(CtMethod<T> m);
 
+	/**
+	 * Visits an annotation method declaration.
+	 */
+	<T> void visitCtAnnotationMethod(CtAnnotationMethod<T> annotationMethod);
+
 	/**
 	 * Visits an array construction.
 	 */
diff --git a/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java b/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java
index 71d3727c2..bffb6d863 100644
--- a/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java
+++ b/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java
@@ -71,6 +71,7 @@ import spoon.reflect.code.CtWhile;
 import spoon.reflect.cu.CompilationUnit;
 import spoon.reflect.cu.SourcePosition;
 import spoon.reflect.declaration.CtAnnotation;
+import spoon.reflect.declaration.CtAnnotationMethod;
 import spoon.reflect.declaration.CtAnnotationType;
 import spoon.reflect.declaration.CtAnonymousExecutable;
 import spoon.reflect.declaration.CtClass;
@@ -348,6 +349,7 @@ public class DefaultJavaPrettyPrinter implements CtVisitor, PrettyPrinter {
 		SortedList<CtElement> lst = new SortedList<>(new CtLineElementComparator());
 		lst.addAll(annotationType.getNestedTypes());
 		lst.addAll(annotationType.getFields());
+		lst.addAll(annotationType.getMethods());
 		elementPrinterHelper.writeElementList(lst);
 		printer.decTab().writeTabs().write("}");
 	}
@@ -681,17 +683,9 @@ public class DefaultJavaPrettyPrinter implements CtVisitor, PrettyPrinter {
 		printer.write(" ");
 		printer.write(f.getSimpleName());
 
-		if (f.getDeclaringType().isAnnotationType()) {
-			printer.write("()");
-			if (f.getDefaultExpression() != null) {
-				printer.write(" default ");
-				scan(f.getDefaultExpression());
-			}
-		} else {
-			if (f.getDefaultExpression() != null) {
-				printer.write(" = ");
-				scan(f.getDefaultExpression());
-			}
+		if (f.getDefaultExpression() != null) {
+			printer.write(" = ");
+			scan(f.getDefaultExpression());
 		}
 		printer.write(";");
 	}
@@ -1250,6 +1244,23 @@ public class DefaultJavaPrettyPrinter implements CtVisitor, PrettyPrinter {
 		}
 	}
 
+	@Override
+	public <T> void visitCtAnnotationMethod(CtAnnotationMethod<T> annotationMethod) {
+		elementPrinterHelper.writeComment(annotationMethod);
+		elementPrinterHelper.visitCtNamedElement(annotationMethod, sourceCompilationUnit);
+		elementPrinterHelper.writeModifiers(annotationMethod);
+		scan(annotationMethod.getType());
+		printer.write(" ");
+		printer.write(annotationMethod.getSimpleName());
+
+		printer.write("()");
+		if (annotationMethod.getDefaultExpression() != null) {
+			printer.write(" default ");
+			scan(annotationMethod.getDefaultExpression());
+		}
+		printer.write(";");
+	}
+
 	@Override
 	@SuppressWarnings("rawtypes")
 	public <T> void visitCtNewArray(CtNewArray<T> newArray) {
diff --git a/src/main/java/spoon/support/DefaultCoreFactory.java b/src/main/java/spoon/support/DefaultCoreFactory.java
index 0fcbe7c8a..ba4078f54 100644
--- a/src/main/java/spoon/support/DefaultCoreFactory.java
+++ b/src/main/java/spoon/support/DefaultCoreFactory.java
@@ -65,6 +65,7 @@ import spoon.reflect.code.CtWhile;
 import spoon.reflect.cu.CompilationUnit;
 import spoon.reflect.cu.SourcePosition;
 import spoon.reflect.declaration.CtAnnotation;
+import spoon.reflect.declaration.CtAnnotationMethod;
 import spoon.reflect.declaration.CtAnnotationType;
 import spoon.reflect.declaration.CtAnonymousExecutable;
 import spoon.reflect.declaration.CtClass;
@@ -140,6 +141,7 @@ import spoon.support.reflect.cu.CompilationUnitImpl;
 import spoon.support.reflect.cu.SourcePositionImpl;
 import spoon.support.reflect.declaration.CompilationUnitVirtualImpl;
 import spoon.support.reflect.declaration.CtAnnotationImpl;
+import spoon.support.reflect.declaration.CtAnnotationMethodImpl;
 import spoon.support.reflect.declaration.CtAnnotationTypeImpl;
 import spoon.support.reflect.declaration.CtAnonymousExecutableImpl;
 import spoon.support.reflect.declaration.CtClassImpl;
@@ -426,6 +428,13 @@ public class DefaultCoreFactory extends SubFactory implements CoreFactory, Seria
 		return e;
 	}
 
+	@Override
+	public <T> CtAnnotationMethod<T> createAnnotationMethod() {
+		CtAnnotationMethod<T> e = new CtAnnotationMethodImpl<T>();
+		e.setFactory(getMainFactory());
+		return e;
+	}
+
 	public <T> CtNewArray<T> createNewArray() {
 		CtNewArray<T> e = new CtNewArrayImpl<>();
 		e.setFactory(getMainFactory());
diff --git a/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java b/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
index d3373de58..da7512b7a 100644
--- a/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
+++ b/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
@@ -131,6 +131,7 @@ import spoon.reflect.code.CtTry;
 import spoon.reflect.code.CtTypeAccess;
 import spoon.reflect.code.CtUnaryOperator;
 import spoon.reflect.code.UnaryOperatorKind;
+import spoon.reflect.declaration.CtAnnotationMethod;
 import spoon.reflect.declaration.CtAnonymousExecutable;
 import spoon.reflect.declaration.CtClass;
 import spoon.reflect.declaration.CtConstructor;
@@ -786,9 +787,9 @@ public class JDTTreeBuilder extends ASTVisitor {
 
 	@Override
 	public boolean visit(AnnotationMethodDeclaration annotationTypeDeclaration, ClassScope classScope) {
-		CtField<Object> f = factory.Core().createField();
-		f.setSimpleName(new String(annotationTypeDeclaration.selector));
-		context.enter(f, annotationTypeDeclaration);
+		CtAnnotationMethod<Object> ctAnnotationMethod = factory.Core().createAnnotationMethod();
+		ctAnnotationMethod.setSimpleName(CharOperation.charToString(annotationTypeDeclaration.selector));
+		context.enter(ctAnnotationMethod, annotationTypeDeclaration);
 		return true;
 	}
 
diff --git a/src/main/java/spoon/support/compiler/jdt/ParentExiter.java b/src/main/java/spoon/support/compiler/jdt/ParentExiter.java
index 3859f0afb..a4fa45e7b 100644
--- a/src/main/java/spoon/support/compiler/jdt/ParentExiter.java
+++ b/src/main/java/spoon/support/compiler/jdt/ParentExiter.java
@@ -77,6 +77,7 @@ import spoon.reflect.code.CtUnaryOperator;
 import spoon.reflect.code.CtWhile;
 import spoon.reflect.declaration.CtAnnotatedElementType;
 import spoon.reflect.declaration.CtAnnotation;
+import spoon.reflect.declaration.CtAnnotationMethod;
 import spoon.reflect.declaration.CtAnonymousExecutable;
 import spoon.reflect.declaration.CtClass;
 import spoon.reflect.declaration.CtConstructor;
@@ -291,6 +292,23 @@ public class ParentExiter extends CtInheritanceScanner {
 				&& !child.equals(ctMethod.getType());
 	}
 
+	@Override
+	public <T> void visitCtAnnotationMethod(CtAnnotationMethod<T> annotationMethod) {
+		if (child instanceof CtExpression && hasChildEqualsToDefaultValue(annotationMethod)) {
+			annotationMethod.setDefaultExpression((CtExpression) child);
+			return;
+		}
+		super.visitCtAnnotationMethod(annotationMethod);
+	}
+
+	private <T> boolean hasChildEqualsToDefaultValue(CtAnnotationMethod<T> ctAnnotationMethod) {
+		final AnnotationMethodDeclaration parent = (AnnotationMethodDeclaration) jdtTreeBuilder.getContextBuilder().stack.peek().node;
+		// Default value is equals to the jdt child.
+		return parent.defaultValue != null && parent.defaultValue.equals(childJDT)
+				// Default value not yet initialized.
+				&& !child.equals(ctAnnotationMethod.getDefaultExpression());
+	}
+
 	@Override
 	public void visitCtAnonymousExecutable(CtAnonymousExecutable e) {
 		if (child instanceof CtBlock) {
diff --git a/src/main/java/spoon/support/reflect/declaration/CtAnnotationImpl.java b/src/main/java/spoon/support/reflect/declaration/CtAnnotationImpl.java
index 75cb91c2e..0f69d10dd 100644
--- a/src/main/java/spoon/support/reflect/declaration/CtAnnotationImpl.java
+++ b/src/main/java/spoon/support/reflect/declaration/CtAnnotationImpl.java
@@ -28,6 +28,7 @@ import spoon.reflect.code.CtNewArray;
 import spoon.reflect.code.CtTypeAccess;
 import spoon.reflect.declaration.CtAnnotatedElementType;
 import spoon.reflect.declaration.CtAnnotation;
+import spoon.reflect.declaration.CtAnnotationMethod;
 import spoon.reflect.declaration.CtAnnotationType;
 import spoon.reflect.declaration.CtConstructor;
 import spoon.reflect.declaration.CtElement;
@@ -257,8 +258,8 @@ public class CtAnnotationImpl<A extends Annotation> extends CtExpressionImpl<A>
 		// Try by CT reflection
 		CtType<?> t = getAnnotationType().getDeclaration();
 		if (t != null) {
-			CtField<?> f = t.getField(name);
-			return f.getType().getActualClass();
+			CtMethod<?> method = t.getMethod(name);
+			return method.getType().getActualClass();
 		}
 		// Try with RT reflection
 		Class<?> c = getAnnotationType().getActualClass();
@@ -278,7 +279,7 @@ public class CtAnnotationImpl<A extends Annotation> extends CtExpressionImpl<A>
 		Object ret = null;
 		CtAnnotationType<?> at = (CtAnnotationType<?>) getAnnotationType().getDeclaration();
 		if (at != null) {
-			CtField<?> f = at.getField(fieldName);
+			CtAnnotationMethod<?> f = (CtAnnotationMethod) at.getMethod(fieldName);
 			ret = f.getDefaultExpression();
 		}
 		return ret;
diff --git a/src/main/java/spoon/support/reflect/declaration/CtAnnotationMethodImpl.java b/src/main/java/spoon/support/reflect/declaration/CtAnnotationMethodImpl.java
new file mode 100644
index 000000000..84c0e8b90
--- /dev/null
+++ b/src/main/java/spoon/support/reflect/declaration/CtAnnotationMethodImpl.java
@@ -0,0 +1,52 @@
+/**
+ * Copyright (C) 2006-2016 INRIA and contributors
+ * Spoon - http://spoon.gforge.inria.fr/
+ *
+ * This software is governed by the CeCILL-C License under French law and
+ * abiding by the rules of distribution of free software. You can use, modify
+ * and/or redistribute the software under the terms of the CeCILL-C license as
+ * circulated by CEA, CNRS and INRIA at http://www.cecill.info.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the CeCILL-C License for more details.
+ *
+ * The fact that you are presently reading this means that you have had
+ * knowledge of the CeCILL-C license and that you accept its terms.
+ */
+package spoon.support.reflect.declaration;
+
+import spoon.reflect.code.CtExpression;
+import spoon.reflect.declaration.CtAnnotationMethod;
+import spoon.reflect.visitor.CtVisitor;
+
+/**
+ * The implementation for {@link spoon.reflect.declaration.CtAnnotationMethod}.
+ */
+public class CtAnnotationMethodImpl<T> extends CtMethodImpl<T> implements CtAnnotationMethod<T> {
+	CtExpression<T> defaultExpression;
+
+	@Override
+	public void accept(CtVisitor v) {
+		v.visitCtAnnotationMethod(this);
+	}
+
+	@Override
+	public CtExpression<T> getDefaultExpression() {
+		return defaultExpression;
+	}
+
+	@Override
+	public <C extends CtAnnotationMethod<T>> C setDefaultExpression(CtExpression<T> assignedExpression) {
+		if (assignedExpression != null) {
+			assignedExpression.setParent(this);
+		}
+		this.defaultExpression = assignedExpression;
+		return (C) this;
+	}
+
+	@Override
+	public CtAnnotationMethod<T> clone() {
+		return (CtAnnotationMethod<T>) super.clone();
+	}
+}
diff --git a/src/main/java/spoon/support/reflect/declaration/CtAnnotationTypeImpl.java b/src/main/java/spoon/support/reflect/declaration/CtAnnotationTypeImpl.java
index 0a0a04cab..77348403a 100644
--- a/src/main/java/spoon/support/reflect/declaration/CtAnnotationTypeImpl.java
+++ b/src/main/java/spoon/support/reflect/declaration/CtAnnotationTypeImpl.java
@@ -16,21 +16,18 @@
  */
 package spoon.support.reflect.declaration;
 
-import spoon.reflect.code.CtComment;
-import spoon.reflect.declaration.CtAnnotation;
+import spoon.reflect.declaration.CtAnnotationMethod;
 import spoon.reflect.declaration.CtAnnotationType;
-import spoon.reflect.declaration.CtField;
 import spoon.reflect.declaration.CtFormalTypeDeclarer;
 import spoon.reflect.declaration.CtMethod;
 import spoon.reflect.declaration.CtType;
-import spoon.reflect.reference.CtExecutableReference;
 import spoon.reflect.reference.CtTypeParameterReference;
 import spoon.reflect.reference.CtTypeReference;
 import spoon.reflect.visitor.CtVisitor;
 
 import java.lang.annotation.Annotation;
-import java.util.Collection;
 import java.util.Collections;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 
@@ -52,64 +49,6 @@ public class CtAnnotationTypeImpl<T extends Annotation> extends CtTypeImpl<T> im
 		return true;
 	}
 
-	private <R> CtMethod<R> createGhostMethod(CtField<R> field) {
-		if (field == null) {
-			return null;
-		}
-		final CtMethod<R> method = factory.Core().createMethod();
-		method.setImplicit(true);
-		method.setSimpleName(field.getSimpleName());
-		method.setModifiers(field.getModifiers());
-		method.setType(field.getType() == null ? null : field.getType().clone());
-		for (CtAnnotation<? extends Annotation> ctAnnotation : field.getAnnotations()) {
-			method.addAnnotation(ctAnnotation.clone());
-		}
-		for (CtComment ctComment : field.getComments()) {
-			method.addComment(ctComment.clone());
-		}
-		method.setDocComment(field.getDocComment());
-		method.setPosition(field.getPosition());
-		method.setShadow(field.isShadow());
-		return method;
-	}
-
-	private <R> void addGhostMethod(CtField<R> field) {
-		super.addMethod(createGhostMethod(field));
-	}
-
-	@Override
-	public <F, C extends CtType<T>> C addField(CtField<F> field) {
-		addGhostMethod(field);
-		return super.addField(field);
-	}
-
-	@Override
-	public <F, C extends CtType<T>> C addField(int index, CtField<F> field) {
-		addGhostMethod(field);
-		return super.addField(index, field);
-	}
-
-	@Override
-	public <F, C extends CtType<T>> C addFieldAtTop(CtField<F> field) {
-		addGhostMethod(field);
-		return super.addFieldAtTop(field);
-	}
-
-	@Override
-	public <C extends CtType<T>> C setFields(List<CtField<?>> fields) {
-		methods.clear();
-		for (CtField<?> field : fields) {
-			super.addMethod(createGhostMethod(field));
-		}
-		return super.setFields(fields);
-	}
-
-	@Override
-	public <F> boolean removeField(CtField<F> field) {
-		super.removeMethod(createGhostMethod(field));
-		return super.removeField(field);
-	}
-
 	@Override
 	public Set<CtTypeReference<?>> getSuperInterfaces() {
 		return Collections.emptySet();
@@ -125,31 +64,6 @@ public class CtAnnotationTypeImpl<T extends Annotation> extends CtTypeImpl<T> im
 		return false;
 	}
 
-	@Override
-	public Collection<CtExecutableReference<?>> getDeclaredExecutables() {
-		return Collections.emptyList();
-	}
-
-	@Override
-	public Collection<CtExecutableReference<?>> getAllExecutables() {
-		return Collections.emptyList();
-	}
-
-	@Override
-	public <C extends CtType<T>> C setMethods(Set<CtMethod<?>> methods) {
-		throw new UnsupportedOperationException("You can't have methods in an annotation.");
-	}
-
-	@Override
-	public <M, C extends CtType<T>> C addMethod(CtMethod<M> method) {
-		throw new UnsupportedOperationException("You can't have methods in an annotation.");
-	}
-
-	@Override
-	public <M> boolean removeMethod(CtMethod<M> method) {
-		throw new UnsupportedOperationException("You can't have methods in an annotation.");
-	}
-
 	@Override
 	public <C extends CtFormalTypeDeclarer> C setFormalTypeParameters(List<CtTypeParameterReference> formalTypeParameters) {
 		throw new UnsupportedOperationException("You can't have generics in an annotation.");
@@ -169,4 +83,21 @@ public class CtAnnotationTypeImpl<T extends Annotation> extends CtTypeImpl<T> im
 	public CtAnnotationType<T> clone() {
 		return (CtAnnotationType<T>) super.clone();
 	}
+
+	@Override
+	public Set<CtAnnotationMethod<?>> getAnnotationMethods() {
+		Set<CtAnnotationMethod<?>> annotationsMethods = new HashSet<>();
+		for (CtMethod<?> method : methods) {
+			annotationsMethods.add((CtAnnotationMethod<?>) method);
+		}
+		return annotationsMethods;
+	}
+
+	@Override
+	public <M, C extends CtType<T>> C addMethod(CtMethod<M> method) {
+		if (method != null && !(method instanceof CtAnnotationMethod)) {
+			throw new IllegalArgumentException("The method " + method.getSignature() + " should be a " + CtAnnotationMethod.class.getName());
+		}
+		return super.addMethod(method);
+	}
 }
diff --git a/src/main/java/spoon/support/reflect/eval/VisitorPartialEvaluator.java b/src/main/java/spoon/support/reflect/eval/VisitorPartialEvaluator.java
index 7d1496bd6..34c6e1223 100644
--- a/src/main/java/spoon/support/reflect/eval/VisitorPartialEvaluator.java
+++ b/src/main/java/spoon/support/reflect/eval/VisitorPartialEvaluator.java
@@ -70,6 +70,7 @@ import spoon.reflect.code.CtVariableRead;
 import spoon.reflect.code.CtVariableWrite;
 import spoon.reflect.code.CtWhile;
 import spoon.reflect.declaration.CtAnnotation;
+import spoon.reflect.declaration.CtAnnotationMethod;
 import spoon.reflect.declaration.CtAnnotationType;
 import spoon.reflect.declaration.CtAnonymousExecutable;
 import spoon.reflect.declaration.CtClass;
@@ -623,6 +624,11 @@ public class VisitorPartialEvaluator implements CtVisitor, PartialEvaluator {
 		throw new RuntimeException("Unknown Element");
 	}
 
+	@Override
+	public <T> void visitCtAnnotationMethod(CtAnnotationMethod<T> annotationMethod) {
+		throw new RuntimeException("Unknown Element");
+	}
+
 	public <T> void visitCtNewArray(CtNewArray<T> newArray) {
 		setResult(newArray.clone());
 	}
diff --git a/src/main/java/spoon/support/visitor/EqualVisitor.java b/src/main/java/spoon/support/visitor/EqualVisitor.java
index 9a854260e..d1d126c89 100644
--- a/src/main/java/spoon/support/visitor/EqualVisitor.java
+++ b/src/main/java/spoon/support/visitor/EqualVisitor.java
@@ -62,6 +62,7 @@ import spoon.reflect.code.CtUnaryOperator;
 import spoon.reflect.code.CtVariableWrite;
 import spoon.reflect.code.CtWhile;
 import spoon.reflect.declaration.CtAnnotation;
+import spoon.reflect.declaration.CtAnnotationMethod;
 import spoon.reflect.declaration.CtAnnotationType;
 import spoon.reflect.declaration.CtAnonymousExecutable;
 import spoon.reflect.declaration.CtClass;
@@ -427,6 +428,11 @@ public class EqualVisitor extends CtScanner {
 		scan(m.getBody());
 	}
 
+	@Override
+	public <T> void visitCtAnnotationMethod(CtAnnotationMethod<T> annotationMethod) {
+		write(annotationMethod.getSignature());
+	}
+
 	@Override
 	public <T> void visitCtNewArray(CtNewArray<T> newArray) {
 		write("new ");
diff --git a/src/main/java/spoon/support/visitor/ShortRepresentationPrinter.java b/src/main/java/spoon/support/visitor/ShortRepresentationPrinter.java
index 7c8bace46..94aaa375c 100644
--- a/src/main/java/spoon/support/visitor/ShortRepresentationPrinter.java
+++ b/src/main/java/spoon/support/visitor/ShortRepresentationPrinter.java
@@ -65,6 +65,7 @@ import spoon.reflect.code.CtVariableRead;
 import spoon.reflect.code.CtVariableWrite;
 import spoon.reflect.code.CtWhile;
 import spoon.reflect.declaration.CtAnnotation;
+import spoon.reflect.declaration.CtAnnotationMethod;
 import spoon.reflect.declaration.CtAnnotationType;
 import spoon.reflect.declaration.CtAnonymousExecutable;
 import spoon.reflect.declaration.CtClass;
@@ -460,6 +461,11 @@ public class ShortRepresentationPrinter implements CtVisitor {
 		write(")");
 	}
 
+	@Override
+	public <T> void visitCtAnnotationMethod(CtAnnotationMethod<T> annotationMethod) {
+		visitCtMethod(annotationMethod);
+	}
+
 	private void scan(List<CtTypeParameterReference> formalTypeParameters) {
 		if (formalTypeParameters != null && formalTypeParameters.size() > 0) {
 			write("<");
diff --git a/src/main/java/spoon/support/visitor/clone/CloneBuilder.java b/src/main/java/spoon/support/visitor/clone/CloneBuilder.java
index ad5a9aff3..80b5c3cd6 100644
--- a/src/main/java/spoon/support/visitor/clone/CloneBuilder.java
+++ b/src/main/java/spoon/support/visitor/clone/CloneBuilder.java
@@ -15,6 +15,7 @@
  * knowledge of the CeCILL-C license and that you accept its terms.
  */
 
+
 package spoon.support.visitor.clone;
 
 
diff --git a/src/main/java/spoon/support/visitor/clone/CloneVisitor.java b/src/main/java/spoon/support/visitor/clone/CloneVisitor.java
index 02e22a6de..f23924793 100644
--- a/src/main/java/spoon/support/visitor/clone/CloneVisitor.java
+++ b/src/main/java/spoon/support/visitor/clone/CloneVisitor.java
@@ -15,6 +15,7 @@
  * knowledge of the CeCILL-C license and that you accept its terms.
  */
 
+
 package spoon.support.visitor.clone;
 
 
@@ -422,6 +423,17 @@ public class CloneVisitor extends spoon.reflect.visitor.CtScanner {
 		this.other = aCtMethod;
 	}
 
+	// auto-generated, see spoon.generating.CloneVisitorGenerator
+	@java.lang.Override
+	public <T> void visitCtAnnotationMethod(spoon.reflect.declaration.CtAnnotationMethod<T> annotationMethod) {
+		spoon.reflect.declaration.CtAnnotationMethod<T> aCtAnnotationMethod = spoon.support.visitor.clone.CloneBuilder.build(this.builder, annotationMethod, annotationMethod.getFactory().Core().createAnnotationMethod());
+		aCtAnnotationMethod.setAnnotations(spoon.support.visitor.equals.CloneHelper.clone(annotationMethod.getAnnotations()));
+		aCtAnnotationMethod.setType(spoon.support.visitor.equals.CloneHelper.clone(annotationMethod.getType()));
+		aCtAnnotationMethod.setDefaultExpression(spoon.support.visitor.equals.CloneHelper.clone(annotationMethod.getDefaultExpression()));
+		aCtAnnotationMethod.setComments(spoon.support.visitor.equals.CloneHelper.clone(annotationMethod.getComments()));
+		this.other = aCtAnnotationMethod;
+	}
+
 	// auto-generated, see spoon.generating.CloneVisitorGenerator
 	public <T> void visitCtNewArray(final spoon.reflect.code.CtNewArray<T> newArray) {
 		spoon.reflect.code.CtNewArray<T> aCtNewArray = spoon.support.visitor.clone.CloneBuilder.build(this.builder, newArray, newArray.getFactory().Core().createNewArray());
diff --git a/src/main/java/spoon/support/visitor/equals/EqualsVisitor.java b/src/main/java/spoon/support/visitor/equals/EqualsVisitor.java
index 9bc0c132b..760bcf5e0 100644
--- a/src/main/java/spoon/support/visitor/equals/EqualsVisitor.java
+++ b/src/main/java/spoon/support/visitor/equals/EqualsVisitor.java
@@ -15,6 +15,7 @@
  * knowledge of the CeCILL-C license and that you accept its terms.
  */
 
+
 package spoon.support.visitor.equals;
 
 
@@ -396,6 +397,16 @@ public class EqualsVisitor extends spoon.reflect.visitor.CtAbstractBiScanner {
 		exit(m);
 	}
 
+	@java.lang.Override
+	public <T> void visitCtAnnotationMethod(spoon.reflect.declaration.CtAnnotationMethod<T> annotationMethod) {
+		spoon.reflect.declaration.CtAnnotationMethod other = ((spoon.reflect.declaration.CtAnnotationMethod) (stack.peek()));
+		enter(annotationMethod);
+		biScan(annotationMethod.getAnnotations(), other.getAnnotations());
+		biScan(annotationMethod.getType(), other.getType());
+		biScan(annotationMethod.getDefaultExpression(), other.getDefaultExpression());
+		exit(annotationMethod);
+	}
+
 	public <T> void visitCtNewArray(final spoon.reflect.code.CtNewArray<T> newArray) {
 		spoon.reflect.code.CtNewArray other = ((spoon.reflect.code.CtNewArray) (stack.peek()));
 		enter(newArray);
diff --git a/src/main/java/spoon/support/visitor/replace/ReplacementVisitor.java b/src/main/java/spoon/support/visitor/replace/ReplacementVisitor.java
index d7b3f328b..76594f73f 100644
--- a/src/main/java/spoon/support/visitor/replace/ReplacementVisitor.java
+++ b/src/main/java/spoon/support/visitor/replace/ReplacementVisitor.java
@@ -90,6 +90,19 @@ public class ReplacementVisitor extends spoon.reflect.visitor.CtScanner {
 		}
 	}
 
+	class CtAnnotationMethodDefaultExpressionReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtExpression> {
+		private final spoon.reflect.declaration.CtAnnotationMethod element;
+
+		CtAnnotationMethodDefaultExpressionReplaceListener(spoon.reflect.declaration.CtAnnotationMethod element) {
+			this.element = element;
+		}
+
+		@java.lang.Override
+		public void set(spoon.reflect.code.CtExpression replace) {
+			this.element.setDefaultExpression(replace);
+		}
+	}
+
 	class CtAnnotationValuesReplaceListener implements spoon.generating.replace.ReplaceMapListener<java.util.Map> {
 		private final spoon.reflect.declaration.CtAnnotation element;
 
@@ -1461,6 +1474,14 @@ public class ReplacementVisitor extends spoon.reflect.visitor.CtScanner {
 		replaceInListIfExist(m.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(m));
 	}
 
+	@java.lang.Override
+	public <T> void visitCtAnnotationMethod(spoon.reflect.declaration.CtAnnotationMethod<T> annotationMethod) {
+		replaceInListIfExist(annotationMethod.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(annotationMethod));
+		replaceElementIfExist(annotationMethod.getType(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypedElementTypeReplaceListener(annotationMethod));
+		replaceElementIfExist(annotationMethod.getDefaultExpression(), new spoon.support.visitor.replace.ReplacementVisitor.CtAnnotationMethodDefaultExpressionReplaceListener(annotationMethod));
+		replaceInListIfExist(annotationMethod.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(annotationMethod));
+	}
+
 	public <T> void visitCtNewArray(final spoon.reflect.code.CtNewArray<T> newArray) {
 		replaceInListIfExist(newArray.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(newArray));
 		replaceElementIfExist(newArray.getType(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypedElementTypeReplaceListener(newArray));
diff --git a/src/test/java/spoon/reflect/ast/IntercessionScanner.java b/src/test/java/spoon/reflect/ast/IntercessionScanner.java
index d5e46f7c5..1d60d9430 100644
--- a/src/test/java/spoon/reflect/ast/IntercessionScanner.java
+++ b/src/test/java/spoon/reflect/ast/IntercessionScanner.java
@@ -78,9 +78,7 @@ public abstract class IntercessionScanner extends CtScanner {
 				&& !(candidate.getSimpleName().equals("setAssignment") && candidate.getDeclaringType().getSimpleName().equals("CtLocalVariableImpl")) //
 				&& !(candidate.getSimpleName().equals("setType") && candidate.getDeclaringType().getSimpleName().equals("CtTypeAccessImpl")) //
 				&& !(candidate.getSimpleName().equals("setAssignment") && candidate.getDeclaringType().getSimpleName().equals("CtFieldImpl")) //
-				&& !(candidate.getSimpleName().equals("addField") && candidate.getDeclaringType().getSimpleName().equals("CtAnnotationTypeImpl")) //
-				&& !(candidate.getSimpleName().equals("addFieldAtTop") && candidate.getDeclaringType().getSimpleName().equals("CtAnnotationTypeImpl")) //
-				&& !(candidate.getSimpleName().equals("setFields") && candidate.getDeclaringType().getSimpleName().equals("CtAnnotationTypeImpl")) //
+				&& !(candidate.getSimpleName().equals("addMethod") && candidate.getDeclaringType().getSimpleName().equals("CtAnnotationTypeImpl")) //
 				&& !(candidate.getSimpleName().equals("setBounds") && candidate.getDeclaringType().getSimpleName().equals("CtTypeParameterReferenceImpl")) //
 				&& !candidate.getSimpleName().equals("setDeclaration");
 	}
diff --git a/src/test/java/spoon/test/annotation/AnnotationTest.java b/src/test/java/spoon/test/annotation/AnnotationTest.java
index cfc904e5c..13bf8de1b 100644
--- a/src/test/java/spoon/test/annotation/AnnotationTest.java
+++ b/src/test/java/spoon/test/annotation/AnnotationTest.java
@@ -15,6 +15,7 @@ import spoon.reflect.code.CtReturn;
 import spoon.reflect.code.CtStatement;
 import spoon.reflect.declaration.CtAnnotatedElementType;
 import spoon.reflect.declaration.CtAnnotation;
+import spoon.reflect.declaration.CtAnnotationMethod;
 import spoon.reflect.declaration.CtAnnotationType;
 import spoon.reflect.declaration.CtClass;
 import spoon.reflect.declaration.CtConstructor;
@@ -51,6 +52,7 @@ import spoon.test.annotation.testclasses.Foo.OuterAnnotation;
 import spoon.test.annotation.testclasses.GlobalAnnotation;
 import spoon.test.annotation.testclasses.InnerAnnot;
 import spoon.test.annotation.testclasses.Main;
+import spoon.test.annotation.testclasses.SuperAnnotation;
 import spoon.test.annotation.testclasses.TestInterface;
 import spoon.test.annotation.testclasses.TypeAnnotation;
 
@@ -67,6 +69,7 @@ import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
+import static spoon.testing.utils.ModelUtils.buildClass;
 import static spoon.testing.utils.ModelUtils.canBeBuilt;
 
 public class AnnotationTest {
@@ -317,7 +320,7 @@ public class AnnotationTest {
 		CtAnnotationType<?> annotationType = pkg.getType("Bound");
 		assertEquals(Bound.class, annotationType.getActualClass());
 		assertNull(annotationType.getSuperclass());
-		assertEquals(annotationType.getFields().size(),annotationType.getMethods().size());
+		assertEquals(1, annotationType.getMethods().size());
 		assertEquals(0,annotationType.getSuperInterfaces().size());
 
 		annotations = annotationType.getAnnotations();
@@ -334,12 +337,12 @@ public class AnnotationTest {
 		CtType<?> annotationInnerClass = type.getNestedType("Annotation");
 		assertEquals("Annotation", annotationInnerClass.getSimpleName());
 		assertEquals(1, annotationInnerClass.getAnnotations().size());
-		assertEquals(res, annotationInnerClass.getField("value").toString());
+		assertEquals(res, annotationInnerClass.getMethod("value").toString());
 
 		CtType<?> annotation = this.factory.Type().get("spoon.test.annotation.testclasses.AnnotArray");
 		assertEquals("AnnotArray", annotation.getSimpleName());
 		assertEquals(1, annotation.getAnnotations().size());
-		assertEquals(res, annotation.getField("value").toString());
+		assertEquals(res, annotation.getMethod("value").toString());
 	}
 
 	@Test
@@ -731,10 +734,10 @@ public class AnnotationTest {
 	public void testDefaultValueInAnnotationsForAnnotationFields() throws Exception {
 		final CtType<?> annotation = factory.Type().get(AnnotationDefaultAnnotation.class);
 
-		final CtField<?> ctField = annotation.getFields().get(0);
-		assertEquals("Field is typed by an annotation.", InnerAnnot.class, ctField.getType().getActualClass());
+		final CtAnnotationMethod<?> ctAnnotations = annotation.getMethods().toArray(new CtAnnotationMethod<?>[0])[0];
+		assertEquals("Field is typed by an annotation.", InnerAnnot.class, ctAnnotations.getType().getActualClass());
 		assertEquals("Default value of a field typed by an annotation must be an annotation",
-				InnerAnnot.class, ctField.getDefaultExpression().getType().getActualClass());
+				InnerAnnot.class, ctAnnotations.getDefaultExpression().getType().getActualClass());
 	}
 
 	@Test
@@ -802,6 +805,24 @@ public class AnnotationTest {
 		assertEquals("annotation.equals(null)", statement.toString());
 	}
 
+	@Test
+	public void testFieldAndMethodInAnnotation() throws Exception {
+		final CtType<SuperAnnotation> aTypeAnnotation = buildClass(SuperAnnotation.class);
+		final CtField<?> fieldValue = aTypeAnnotation.getField("value");
+		assertNotNull(fieldValue);
+		assertEquals("java.lang.String value = \"\";", fieldValue.toString());
+		final CtMethod<Object> methodValue = aTypeAnnotation.getMethod("value");
+		assertTrue(methodValue instanceof CtAnnotationMethod);
+		assertEquals("java.lang.String value() default spoon.test.annotation.testclasses.SuperAnnotation.value;", methodValue.toString());
+		final CtMethod<Object> methodNoDefault = aTypeAnnotation.getMethod("value1");
+		assertTrue(methodNoDefault instanceof CtAnnotationMethod);
+		assertEquals("java.lang.String value1();", methodNoDefault.toString());
+
+		assertEquals(2, aTypeAnnotation.getMethods().size());
+		aTypeAnnotation.addMethod(methodValue.clone());
+		assertEquals(2, aTypeAnnotation.getMethods().size());
+	}
+
 	abstract class AbstractElementsProcessor<A extends Annotation, E extends CtElement>
 			extends AbstractAnnotationProcessor<A, E> {
 		final List<CtElement> elements = new ArrayList<>();
diff --git a/src/test/java/spoon/test/annotation/testclasses/SuperAnnotation.java b/src/test/java/spoon/test/annotation/testclasses/SuperAnnotation.java
new file mode 100644
index 000000000..a11ccef4d
--- /dev/null
+++ b/src/test/java/spoon/test/annotation/testclasses/SuperAnnotation.java
@@ -0,0 +1,9 @@
+package spoon.test.annotation.testclasses;
+
+public @interface SuperAnnotation {
+	String value = "";
+
+	String value() default value;
+
+	String value1();
+}
diff --git a/src/test/java/spoon/test/reference/AnnotationFieldReferenceTest.java b/src/test/java/spoon/test/reference/AnnotationFieldReferenceTest.java
index bbe279fc2..cbd220b53 100644
--- a/src/test/java/spoon/test/reference/AnnotationFieldReferenceTest.java
+++ b/src/test/java/spoon/test/reference/AnnotationFieldReferenceTest.java
@@ -3,7 +3,6 @@ package spoon.test.reference;
 import org.junit.Test;
 import spoon.reflect.code.CtInvocation;
 import spoon.reflect.declaration.CtExecutable;
-import spoon.reflect.declaration.CtField;
 import spoon.reflect.declaration.CtMethod;
 import spoon.reflect.factory.Factory;
 import spoon.reflect.visitor.filter.TypeFilter;
@@ -22,7 +21,7 @@ public class AnnotationFieldReferenceTest {
 		final CtInvocation<?> annotationInv = make.getElements(new TypeFilter<CtInvocation<?>>(CtInvocation.class)).get(0);
 		final CtExecutable<?> executableDeclaration = annotationInv.getExecutable().getExecutableDeclaration();
 		assertNotNull(executableDeclaration);
-		final CtField<?> value = factory.Annotation().get(Parameter.class).getField("value");
+		final CtMethod<?> value = factory.Annotation().get(Parameter.class).getMethod("value");
 		assertNotNull(value);
 		assertEquals(value.getSimpleName(), executableDeclaration.getSimpleName());
 		assertEquals(value.getType(), executableDeclaration.getType());
