diff --git a/src/main/java/spoon/generating/CloneVisitorGenerator.java b/src/main/java/spoon/generating/CloneVisitorGenerator.java
index ffa738b91..75fb24db4 100644
--- a/src/main/java/spoon/generating/CloneVisitorGenerator.java
+++ b/src/main/java/spoon/generating/CloneVisitorGenerator.java
@@ -52,6 +52,7 @@ import spoon.reflect.visitor.Query;
 import spoon.reflect.visitor.ReferenceFilter;
 import spoon.reflect.visitor.filter.OverridingMethodFilter;
 import spoon.reflect.visitor.filter.TypeFilter;
+import spoon.support.reflect.cu.CtLineElementComparator;
 import spoon.support.visitor.clone.CloneBuilder;
 
 import java.util.ArrayList;
@@ -505,6 +506,9 @@ public class CloneVisitorGenerator extends AbstractManualProcessor {
 				return ctField.getModifiers().contains(ModifierKind.FINAL) || ctField.getModifiers().contains(ModifierKind.STATIC);
 			}
 		}.scan(getFactory().Class().get(CtInheritanceScanner.class));
+
+		Collections.sort(target.getTypeMembers(), new CtLineElementComparator());
+		Collections.sort(targetBuilder.getTypeMembers(), new CtLineElementComparator());
 	}
 
 	private CtClass<Object> createCloneVisitor() {
diff --git a/src/main/java/spoon/reflect/declaration/CtEnum.java b/src/main/java/spoon/reflect/declaration/CtEnum.java
index a8c065c08..651af3e95 100644
--- a/src/main/java/spoon/reflect/declaration/CtEnum.java
+++ b/src/main/java/spoon/reflect/declaration/CtEnum.java
@@ -56,6 +56,11 @@ public interface CtEnum<T extends Enum<?>> extends CtClass<T> {
 	 */
 	List<CtEnumValue<?>> getEnumValues();
 
+	/**
+	 *Sets all enum values of the enum.
+	 */
+	<C extends CtEnum<T>> C setEnumValues(List<CtEnumValue<?>> enumValues);
+
 	@Override
 	CtEnum<T> clone();
 }
diff --git a/src/main/java/spoon/reflect/declaration/CtType.java b/src/main/java/spoon/reflect/declaration/CtType.java
index 83eb552ac..de7364da8 100644
--- a/src/main/java/spoon/reflect/declaration/CtType.java
+++ b/src/main/java/spoon/reflect/declaration/CtType.java
@@ -252,6 +252,32 @@ public interface CtType<T> extends CtNamedElement, CtTypeInformation, CtTypeMemb
 	 */
 	<S> boolean removeSuperInterface(CtTypeReference<S> interfac);
 
+	/**
+	 * Gets all type members of the type like fields, methods, anonymous block, etc.
+	 */
+	List<CtTypeMember> getTypeMembers();
+
+	/**
+	 * Adds a type member at the end of all type member of the type.
+	 */
+	<C extends CtType<T>> C addTypeMember(CtTypeMember member);
+
+	/**
+	 * Adds a type member at a given position. Think to use this method if the order is
+	 * important for you.
+	 */
+	<C extends CtType<T>> C addTypeMemberAt(int position, CtTypeMember member);
+
+	/**
+	 * Removes the type member.
+	 */
+	boolean removeTypeMember(CtTypeMember member);
+
+	/**
+	 * Removes all types members with these new members.
+	 */
+	<C extends CtType<T>> C setTypeMembers(List<CtTypeMember> members);
+
 	@Override
 	CtType<T> clone();
 }
diff --git a/src/main/java/spoon/reflect/factory/InterfaceFactory.java b/src/main/java/spoon/reflect/factory/InterfaceFactory.java
index 89c8dbb01..c49390667 100644
--- a/src/main/java/spoon/reflect/factory/InterfaceFactory.java
+++ b/src/main/java/spoon/reflect/factory/InterfaceFactory.java
@@ -49,10 +49,10 @@ public class InterfaceFactory extends TypeFactory {
 	 * Creates an inner interface
 	 */
 	public <T> CtInterface<T> create(CtType<T> owner, String simpleName) {
-		CtInterface<T> i = factory.Core().createInterface();
-		i.setSimpleName(simpleName);
-		owner.getNestedTypes().add(i);
-		return i;
+		CtInterface<T> ctInterface = factory.Core().createInterface();
+		ctInterface.setSimpleName(simpleName);
+		owner.addNestedType(ctInterface);
+		return ctInterface;
 	}
 
 	/**
diff --git a/src/main/java/spoon/reflect/visitor/CtBiScannerDefault.java b/src/main/java/spoon/reflect/visitor/CtBiScannerDefault.java
index 40c60eb3c..284b9f669 100644
--- a/src/main/java/spoon/reflect/visitor/CtBiScannerDefault.java
+++ b/src/main/java/spoon/reflect/visitor/CtBiScannerDefault.java
@@ -43,8 +43,7 @@ public abstract class CtBiScannerDefault extends spoon.reflect.visitor.CtAbstrac
 		spoon.reflect.declaration.CtAnnotationType other = ((spoon.reflect.declaration.CtAnnotationType) (stack.peek()));
 		enter(annotationType);
 		biScan(annotationType.getAnnotations(), other.getAnnotations());
-		biScan(annotationType.getNestedTypes(), other.getNestedTypes());
-		biScan(annotationType.getFields(), other.getFields());
+		biScan(annotationType.getTypeMembers(), other.getTypeMembers());
 		biScan(annotationType.getComments(), other.getComments());
 		exit(annotationType);
 	}
@@ -173,16 +172,12 @@ public abstract class CtBiScannerDefault extends spoon.reflect.visitor.CtAbstrac
 		biScan(ctClass.getSuperclass(), other.getSuperclass());
 		biScan(ctClass.getSuperInterfaces(), other.getSuperInterfaces());
 		biScan(ctClass.getFormalCtTypeParameters(), other.getFormalCtTypeParameters());
-		biScan(ctClass.getAnonymousExecutables(), other.getAnonymousExecutables());
-		biScan(ctClass.getNestedTypes(), other.getNestedTypes());
-		biScan(ctClass.getFields(), other.getFields());
-		biScan(ctClass.getConstructors(), other.getConstructors());
-		biScan(ctClass.getMethods(), other.getMethods());
+		biScan(ctClass.getTypeMembers(), other.getTypeMembers());
 		biScan(ctClass.getComments(), other.getComments());
 		exit(ctClass);
 	}
 
-	@Override
+	@java.lang.Override
 	public void visitCtTypeParameter(spoon.reflect.declaration.CtTypeParameter typeParameter) {
 		spoon.reflect.declaration.CtTypeParameter other = ((spoon.reflect.declaration.CtTypeParameter) (stack.peek()));
 		enter(typeParameter);
@@ -240,10 +235,8 @@ public abstract class CtBiScannerDefault extends spoon.reflect.visitor.CtAbstrac
 		enter(ctEnum);
 		biScan(ctEnum.getAnnotations(), other.getAnnotations());
 		biScan(ctEnum.getSuperInterfaces(), other.getSuperInterfaces());
-		biScan(ctEnum.getFields(), other.getFields());
-		biScan(ctEnum.getConstructors(), other.getConstructors());
-		biScan(ctEnum.getMethods(), other.getMethods());
-		biScan(ctEnum.getNestedTypes(), other.getNestedTypes());
+		biScan(ctEnum.getTypeMembers(), other.getTypeMembers());
+		biScan(ctEnum.getEnumValues(), other.getEnumValues());
 		biScan(ctEnum.getComments(), other.getComments());
 		exit(ctEnum);
 	}
@@ -353,9 +346,7 @@ public abstract class CtBiScannerDefault extends spoon.reflect.visitor.CtAbstrac
 		biScan(intrface.getAnnotations(), other.getAnnotations());
 		biScan(intrface.getSuperInterfaces(), other.getSuperInterfaces());
 		biScan(intrface.getFormalCtTypeParameters(), other.getFormalCtTypeParameters());
-		biScan(intrface.getNestedTypes(), other.getNestedTypes());
-		biScan(intrface.getFields(), other.getFields());
-		biScan(intrface.getMethods(), other.getMethods());
+		biScan(intrface.getTypeMembers(), other.getTypeMembers());
 		biScan(intrface.getComments(), other.getComments());
 		exit(intrface);
 	}
diff --git a/src/main/java/spoon/reflect/visitor/CtScanner.java b/src/main/java/spoon/reflect/visitor/CtScanner.java
index e7f6d6a78..a228ec3c5 100644
--- a/src/main/java/spoon/reflect/visitor/CtScanner.java
+++ b/src/main/java/spoon/reflect/visitor/CtScanner.java
@@ -179,8 +179,7 @@ public abstract class CtScanner implements CtVisitor {
 			final CtAnnotationType<A> annotationType) {
 		enter(annotationType);
 		scan(annotationType.getAnnotations());
-		scan(annotationType.getNestedTypes());
-		scan(annotationType.getFields());
+		scan(annotationType.getTypeMembers());
 		scan(annotationType.getComments());
 		exit(annotationType);
 	}
@@ -298,11 +297,7 @@ public abstract class CtScanner implements CtVisitor {
 		scan(ctClass.getSuperclass());
 		scan(ctClass.getSuperInterfaces());
 		scan(ctClass.getFormalCtTypeParameters());
-		scan(ctClass.getAnonymousExecutables());
-		scan(ctClass.getNestedTypes());
-		scan(ctClass.getFields());
-		scan(ctClass.getConstructors());
-		scan(ctClass.getMethods());
+		scan(ctClass.getTypeMembers());
 		scan(ctClass.getComments());
 		exit(ctClass);
 	}
@@ -359,10 +354,8 @@ public abstract class CtScanner implements CtVisitor {
 		enter(ctEnum);
 		scan(ctEnum.getAnnotations());
 		scan(ctEnum.getSuperInterfaces());
-		scan(ctEnum.getFields());
-		scan(ctEnum.getConstructors());
-		scan(ctEnum.getMethods());
-		scan(ctEnum.getNestedTypes());
+		scan(ctEnum.getTypeMembers());
+		scan(ctEnum.getEnumValues());
 		scan(ctEnum.getComments());
 		exit(ctEnum);
 	}
@@ -464,9 +457,7 @@ public abstract class CtScanner implements CtVisitor {
 		scan(intrface.getAnnotations());
 		scan(intrface.getSuperInterfaces());
 		scan(intrface.getFormalCtTypeParameters());
-		scan(intrface.getNestedTypes());
-		scan(intrface.getFields());
-		scan(intrface.getMethods());
+		scan(intrface.getTypeMembers());
 		scan(intrface.getComments());
 		exit(intrface);
 	}
diff --git a/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java b/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java
index 5b14dd8b0..d21bb2870 100644
--- a/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java
+++ b/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java
@@ -105,8 +105,6 @@ import spoon.reflect.reference.CtWildcardReference;
 import spoon.reflect.visitor.printer.CommentOffset;
 import spoon.reflect.visitor.printer.ElementPrinterHelper;
 import spoon.reflect.visitor.printer.PrinterHelper;
-import spoon.support.reflect.cu.CtLineElementComparator;
-import spoon.support.util.SortedList;
 
 import java.lang.annotation.Annotation;
 import java.util.ArrayDeque;
@@ -347,11 +345,7 @@ public class DefaultJavaPrettyPrinter implements CtVisitor, PrettyPrinter {
 		visitCtType(annotationType);
 		printer.write("@interface " + annotationType.getSimpleName() + " {").incTab();
 
-		SortedList<CtElement> lst = new SortedList<>(new CtLineElementComparator());
-		lst.addAll(annotationType.getNestedTypes());
-		lst.addAll(annotationType.getFields());
-		lst.addAll(annotationType.getMethods());
-		elementPrinterHelper.writeElementList(lst);
+		elementPrinterHelper.writeElementList(annotationType.getTypeMembers());
 		printer.decTab().writeTabs().write("}");
 	}
 
@@ -513,7 +507,6 @@ public class DefaultJavaPrettyPrinter implements CtVisitor, PrettyPrinter {
 
 	@Override
 	public <T> void visitCtClass(CtClass<T> ctClass) {
-		SortedList<CtElement> lst = new SortedList<>(new CtLineElementComparator());
 		if (ctClass.getSimpleName() != null && !CtType.NAME_UNKNOWN.equals(ctClass.getSimpleName()) && !ctClass.isAnonymous()) {
 			visitCtType(ctClass);
 			if (ctClass.isLocalType()) {
@@ -525,21 +518,12 @@ public class DefaultJavaPrettyPrinter implements CtVisitor, PrettyPrinter {
 			elementPrinterHelper.writeFormalTypeParameters(ctClass);
 			elementPrinterHelper.writeExtendsClause(ctClass);
 			elementPrinterHelper.writeImplementsClause(ctClass);
-			for (CtConstructor<T> c : ctClass.getConstructors()) {
-				if (!c.isImplicit()) {
-					lst.add(c);
-				}
-			}
 		}
-		lst.addAll(ctClass.getAnonymousExecutables());
-		lst.addAll(ctClass.getNestedTypes());
-		lst.addAll(ctClass.getFields());
-		lst.addAll(ctClass.getMethods());
-		lst.addAll(elementPrinterHelper.getComments(ctClass, CommentOffset.INSIDE));
+		// lst.addAll(elementPrinterHelper.getComments(ctClass, CommentOffset.INSIDE));
 
 		context.currentThis.push(ctClass.getReference());
 		printer.write(" {").incTab();
-		elementPrinterHelper.writeElementList(lst);
+		elementPrinterHelper.writeElementList(ctClass.getTypeMembers());
 		printer.decTab().writeTabs().write("}");
 		context.currentThis.pop();
 	}
@@ -659,27 +643,7 @@ public class DefaultJavaPrettyPrinter implements CtVisitor, PrettyPrinter {
 			printer.write(";");
 		}
 
-		for (CtField<?> field : ctEnum.getFields()) {
-			if (!(field instanceof CtEnumValue)) {
-				printer.writeln().writeTabs();
-				scan(field);
-			}
-		}
-
-		for (CtConstructor<?> c : ctEnum.getConstructors()) {
-			if (!c.isImplicit()) {
-				printer.writeln().writeTabs();
-				scan(c);
-			}
-		}
-
-		SortedList<CtElement> lst = new SortedList<>(new CtLineElementComparator());
-
-		lst.addAll(ctEnum.getAnonymousExecutables());
-		lst.addAll(ctEnum.getNestedTypes());
-		lst.addAll(ctEnum.getMethods());
-
-		elementPrinterHelper.writeElementList(lst);
+		elementPrinterHelper.writeElementList(ctEnum.getTypeMembers());
 		printer.decTab().writeTabs().write("}");
 		context.currentThis.pop();
 	}
@@ -1031,12 +995,8 @@ public class DefaultJavaPrettyPrinter implements CtVisitor, PrettyPrinter {
 			printer.removeLastChar();
 		}
 		printer.write(" {").incTab();
-		SortedList<CtElement> lst = new SortedList<>(new CtLineElementComparator());
-		lst.addAll(intrface.getNestedTypes());
-		lst.addAll(intrface.getFields());
-		lst.addAll(intrface.getMethods());
 		// Content
-		elementPrinterHelper.writeElementList(lst);
+		elementPrinterHelper.writeElementList(intrface.getTypeMembers());
 		printer.decTab().writeTabs().write("}");
 	}
 
diff --git a/src/main/java/spoon/reflect/visitor/ImportScannerImpl.java b/src/main/java/spoon/reflect/visitor/ImportScannerImpl.java
index ac32c3abe..fe7bae690 100644
--- a/src/main/java/spoon/reflect/visitor/ImportScannerImpl.java
+++ b/src/main/java/spoon/reflect/visitor/ImportScannerImpl.java
@@ -26,6 +26,7 @@ import spoon.reflect.declaration.CtElement;
 import spoon.reflect.declaration.CtEnum;
 import spoon.reflect.declaration.CtInterface;
 import spoon.reflect.declaration.CtType;
+import spoon.reflect.declaration.CtTypeMember;
 import spoon.reflect.reference.CtArrayTypeReference;
 import spoon.reflect.reference.CtExecutableReference;
 import spoon.reflect.reference.CtFieldReference;
@@ -142,8 +143,11 @@ public class ImportScannerImpl extends CtScanner implements ImportScanner {
 	@Override
 	public <T> void visitCtInterface(CtInterface<T> intrface) {
 		addImport(intrface.getReference());
-		for (CtType<?> t : intrface.getNestedTypes()) {
-			addImport(t.getReference());
+		for (CtTypeMember t : intrface.getTypeMembers()) {
+			if (!(t instanceof CtType)) {
+				continue;
+			}
+			addImport(((CtType) t).getReference());
 		}
 		super.visitCtInterface(intrface);
 	}
@@ -151,8 +155,11 @@ public class ImportScannerImpl extends CtScanner implements ImportScanner {
 	@Override
 	public <T> void visitCtClass(CtClass<T> ctClass) {
 		addImport(ctClass.getReference());
-		for (CtType<?> t : ctClass.getNestedTypes()) {
-			addImport(t.getReference());
+		for (CtTypeMember t : ctClass.getTypeMembers()) {
+			if (!(t instanceof CtType)) {
+				continue;
+			}
+			addImport(((CtType) t).getReference());
 		}
 		super.visitCtClass(ctClass);
 	}
diff --git a/src/main/java/spoon/reflect/visitor/printer/ElementPrinterHelper.java b/src/main/java/spoon/reflect/visitor/printer/ElementPrinterHelper.java
index 0082a4b9e..8e78d1261 100644
--- a/src/main/java/spoon/reflect/visitor/printer/ElementPrinterHelper.java
+++ b/src/main/java/spoon/reflect/visitor/printer/ElementPrinterHelper.java
@@ -31,6 +31,7 @@ import spoon.reflect.code.CtWhile;
 import spoon.reflect.cu.CompilationUnit;
 import spoon.reflect.declaration.CtAnnotation;
 import spoon.reflect.declaration.CtClass;
+import spoon.reflect.declaration.CtConstructor;
 import spoon.reflect.declaration.CtElement;
 import spoon.reflect.declaration.CtExecutable;
 import spoon.reflect.declaration.CtFormalTypeDeclarer;
@@ -38,6 +39,7 @@ import spoon.reflect.declaration.CtModifiable;
 import spoon.reflect.declaration.CtNamedElement;
 import spoon.reflect.declaration.CtParameter;
 import spoon.reflect.declaration.CtType;
+import spoon.reflect.declaration.CtTypeMember;
 import spoon.reflect.declaration.CtTypeParameter;
 import spoon.reflect.declaration.ModifierKind;
 import spoon.reflect.factory.Factory;
@@ -45,7 +47,6 @@ import spoon.reflect.reference.CtActualTypeContainer;
 import spoon.reflect.reference.CtFieldReference;
 import spoon.reflect.reference.CtTypeReference;
 import spoon.reflect.visitor.DefaultJavaPrettyPrinter;
-import spoon.support.util.SortedList;
 
 import java.util.ArrayList;
 import java.util.Collection;
@@ -141,8 +142,11 @@ public class ElementPrinterHelper {
 		writeComment(statement, CommentOffset.AFTER);
 	}
 
-	public void writeElementList(SortedList<CtElement> elements) {
-		for (CtElement element : elements) {
+	public void writeElementList(List<CtTypeMember> elements) {
+		for (CtTypeMember element : elements) {
+			if (element instanceof CtConstructor && element.isImplicit()) {
+				continue;
+			}
 			printer.writeln().writeTabs();
 			prettyPrinter.scan(element);
 			if (!env.isPreserveLineNumbers()) {
diff --git a/src/main/java/spoon/support/compiler/jdt/JDTCommentBuilder.java b/src/main/java/spoon/support/compiler/jdt/JDTCommentBuilder.java
index 8c39aac37..431d588ef 100644
--- a/src/main/java/spoon/support/compiler/jdt/JDTCommentBuilder.java
+++ b/src/main/java/spoon/support/compiler/jdt/JDTCommentBuilder.java
@@ -40,6 +40,7 @@ import spoon.reflect.declaration.CtField;
 import spoon.reflect.declaration.CtInterface;
 import spoon.reflect.declaration.CtMethod;
 import spoon.reflect.declaration.CtParameter;
+import spoon.reflect.declaration.CtTypeMember;
 import spoon.reflect.declaration.ParentNotInitializedException;
 import spoon.reflect.factory.Factory;
 import spoon.reflect.visitor.CtInheritanceScanner;
@@ -243,10 +244,12 @@ class JDTCommentBuilder {
 					e.addComment(comment);
 					return;
 				}
-				List<CtElement> elements = new ArrayList<>();
-				elements.addAll(e.getFields());
-				elements.addAll(e.getMethods());
-				elements.addAll(e.getConstructors());
+				final List<CtElement> elements = new ArrayList<>();
+				for (CtTypeMember typeMember : e.getTypeMembers()) {
+					if (typeMember instanceof CtField || typeMember instanceof CtMethod || typeMember instanceof CtConstructor) {
+						elements.add(typeMember);
+					}
+				}
 				addCommentToNear(comment, elements);
 
 				try {
@@ -258,9 +261,12 @@ class JDTCommentBuilder {
 
 			@Override
 			public <T> void visitCtInterface(CtInterface<T> e) {
-				List<CtElement> elements = new ArrayList<>();
-				elements.addAll(e.getFields());
-				elements.addAll(e.getMethods());
+				final List<CtElement> elements = new ArrayList<>();
+				for (CtTypeMember typeMember : e.getTypeMembers()) {
+					if (typeMember instanceof CtField || typeMember instanceof CtMethod) {
+						elements.add(typeMember);
+					}
+				}
 				addCommentToNear(comment, elements);
 
 				try {
diff --git a/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java b/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
index d8a94c001..02de23742 100644
--- a/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
+++ b/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
@@ -146,6 +146,9 @@ import spoon.reflect.factory.Factory;
 import spoon.reflect.reference.CtArrayTypeReference;
 import spoon.reflect.reference.CtTypeReference;
 import spoon.reflect.reference.CtUnboundVariableReference;
+import spoon.support.reflect.cu.CtLineElementComparator;
+
+import java.util.Collections;
 
 import static spoon.support.compiler.jdt.JDTTreeBuilderQuery.getBinaryOperatorKind;
 import static spoon.support.compiler.jdt.JDTTreeBuilderQuery.getModifiers;
@@ -675,12 +678,14 @@ public class JDTTreeBuilder extends ASTVisitor {
 
 	@Override
 	public void endVisit(TypeDeclaration localTypeDeclaration, BlockScope scope) {
+		Collections.sort(((CtType) context.stack.peek().element).getTypeMembers(), new CtLineElementComparator());
 		context.exit(localTypeDeclaration);
 	}
 
 	@Override
 	public void endVisit(TypeDeclaration memberTypeDeclaration, ClassScope scope) {
 		while (!context.stack.isEmpty() && context.stack.peek().node == memberTypeDeclaration) {
+			Collections.sort(((CtType) context.stack.peek().element).getTypeMembers(), new CtLineElementComparator());
 			context.exit(memberTypeDeclaration);
 		}
 	}
@@ -688,6 +693,9 @@ public class JDTTreeBuilder extends ASTVisitor {
 	@Override
 	public void endVisit(TypeDeclaration typeDeclaration, CompilationUnitScope scope) {
 		while (!context.stack.isEmpty() && context.stack.peek().node == typeDeclaration) {
+			if (context.stack.peek().element instanceof CtType) {
+				Collections.sort(((CtType) context.stack.peek().element).getTypeMembers(), new CtLineElementComparator());
+			}
 			context.exit(typeDeclaration);
 		}
 	}
diff --git a/src/main/java/spoon/support/compiler/jdt/ParentExiter.java b/src/main/java/spoon/support/compiler/jdt/ParentExiter.java
index fe207f436..2e1fba412 100644
--- a/src/main/java/spoon/support/compiler/jdt/ParentExiter.java
+++ b/src/main/java/spoon/support/compiler/jdt/ParentExiter.java
@@ -209,8 +209,8 @@ public class ParentExiter extends CtInheritanceScanner {
 	@Override
 	public <T> void scanCtType(CtType<T> type) {
 		if (child instanceof CtType && !(child instanceof CtTypeParameter)) {
-			if (type.getNestedTypes().contains(child)) {
-				type.getNestedTypes().remove(child);
+			if (type.getTypeMembers().contains(child)) {
+				type.removeTypeMember((CtType) child);
 			}
 			type.addNestedType((CtType<?>) child);
 			return;
diff --git a/src/main/java/spoon/support/reflect/declaration/CtAnnotationTypeImpl.java b/src/main/java/spoon/support/reflect/declaration/CtAnnotationTypeImpl.java
index 078b59b15..8d31bec5e 100644
--- a/src/main/java/spoon/support/reflect/declaration/CtAnnotationTypeImpl.java
+++ b/src/main/java/spoon/support/reflect/declaration/CtAnnotationTypeImpl.java
@@ -69,7 +69,7 @@ public class CtAnnotationTypeImpl<T extends Annotation> extends CtTypeImpl<T> im
 	@Override
 	public Set<CtAnnotationMethod<?>> getAnnotationMethods() {
 		Set<CtAnnotationMethod<?>> annotationsMethods = new HashSet<>();
-		for (CtMethod<?> method : methods) {
+		for (CtMethod<?> method : getMethods()) {
 			annotationsMethods.add((CtAnnotationMethod<?>) method);
 		}
 		return annotationsMethods;
diff --git a/src/main/java/spoon/support/reflect/declaration/CtClassImpl.java b/src/main/java/spoon/support/reflect/declaration/CtClassImpl.java
index f77289770..54321c604 100644
--- a/src/main/java/spoon/support/reflect/declaration/CtClassImpl.java
+++ b/src/main/java/spoon/support/reflect/declaration/CtClassImpl.java
@@ -25,6 +25,7 @@ import spoon.reflect.declaration.CtConstructor;
 import spoon.reflect.declaration.CtElement;
 import spoon.reflect.declaration.CtExecutable;
 import spoon.reflect.declaration.CtType;
+import spoon.reflect.declaration.CtTypeMember;
 import spoon.reflect.reference.CtExecutableReference;
 import spoon.reflect.reference.CtTypeReference;
 import spoon.reflect.visitor.CtVisitor;
@@ -38,8 +39,6 @@ import java.util.List;
 import java.util.Set;
 import java.util.TreeSet;
 
-import static spoon.reflect.ModelElementContainerDefaultCapacities.ANONYMOUS_EXECUTABLES_CONTAINER_DEFAULT_CAPACITY;
-
 /**
  * The implementation for {@link spoon.reflect.declaration.CtClass}.
  *
@@ -48,10 +47,6 @@ import static spoon.reflect.ModelElementContainerDefaultCapacities.ANONYMOUS_EXE
 public class CtClassImpl<T extends Object> extends CtTypeImpl<T> implements CtClass<T> {
 	private static final long serialVersionUID = 1L;
 
-	List<CtAnonymousExecutable> anonymousExecutables = emptyList();
-
-	Set<CtConstructor<T>> constructors = emptySet();
-
 	CtTypeReference<?> superClass;
 
 	@Override
@@ -61,12 +56,22 @@ public class CtClassImpl<T extends Object> extends CtTypeImpl<T> implements CtCl
 
 	@Override
 	public List<CtAnonymousExecutable> getAnonymousExecutables() {
+		List<CtAnonymousExecutable> anonymousExecutables = new ArrayList<>();
+		for (CtTypeMember typeMember : typeMembers) {
+			if (typeMember instanceof CtAnonymousExecutable) {
+				anonymousExecutables.add((CtAnonymousExecutable) typeMember);
+			}
+		}
 		return anonymousExecutables;
 	}
 
 	@Override
 	public CtConstructor<T> getConstructor(CtTypeReference<?>... parameterTypes) {
-		for (CtConstructor<T> c : constructors) {
+		for (CtTypeMember typeMember : getTypeMembers()) {
+			if (!(typeMember instanceof CtConstructor)) {
+				continue;
+			}
+			CtConstructor<T> c = (CtConstructor<T>) typeMember;
 			boolean cont = c.getParameters().size() == parameterTypes.length;
 			for (int i = 0; cont && (i < c.getParameters().size()) && (i < parameterTypes.length); i++) {
 				if (!parameterTypes[i].equals(c.getParameters().get(i).getType())) {
@@ -82,26 +87,23 @@ public class CtClassImpl<T extends Object> extends CtTypeImpl<T> implements CtCl
 
 	@Override
 	public Set<CtConstructor<T>> getConstructors() {
+		Set<CtConstructor<T>> constructors = new TreeSet<>();
+		for (CtTypeMember typeMember : typeMembers) {
+			if (typeMember instanceof CtConstructor) {
+				constructors.add((CtConstructor<T>) typeMember);
+			}
+		}
 		return constructors;
 	}
 
 	@Override
 	public <C extends CtClass<T>> C addAnonymousExecutable(CtAnonymousExecutable e) {
-		if (e == null) {
-			return (C) this;
-		}
-		if (anonymousExecutables == CtElementImpl.<CtAnonymousExecutable>emptyList()) {
-			anonymousExecutables = new ArrayList<>(ANONYMOUS_EXECUTABLES_CONTAINER_DEFAULT_CAPACITY);
-		}
-		e.setParent(this);
-		anonymousExecutables.add(e);
-		return (C) this;
+		return addTypeMember(e);
 	}
 
 	@Override
 	public boolean removeAnonymousExecutable(CtAnonymousExecutable e) {
-		return anonymousExecutables != CtElementImpl.<CtAnonymousExecutable>emptyList() && anonymousExecutables
-				.remove(e);
+		return removeTypeMember(e);
 	}
 
 	@Override
@@ -112,13 +114,10 @@ public class CtClassImpl<T extends Object> extends CtTypeImpl<T> implements CtCl
 	@Override
 	public <C extends CtClass<T>> C setAnonymousExecutables(List<CtAnonymousExecutable> anonymousExecutables) {
 		if (anonymousExecutables == null || anonymousExecutables.isEmpty()) {
-			this.anonymousExecutables = CtElementImpl.emptyList();
+			this.typeMembers.removeAll(getAnonymousExecutables());
 			return (C) this;
 		}
-		if (this.anonymousExecutables == CtElementImpl.<CtAnonymousExecutable>emptyList()) {
-			this.anonymousExecutables = new ArrayList<>(ANONYMOUS_EXECUTABLES_CONTAINER_DEFAULT_CAPACITY);
-		}
-		this.anonymousExecutables.clear();
+		typeMembers.removeAll(getAnonymousExecutables());
 		for (CtAnonymousExecutable exec : anonymousExecutables) {
 			addAnonymousExecutable(exec);
 		}
@@ -128,13 +127,10 @@ public class CtClassImpl<T extends Object> extends CtTypeImpl<T> implements CtCl
 	@Override
 	public <C extends CtClass<T>> C setConstructors(Set<CtConstructor<T>> constructors) {
 		if (constructors == null || constructors.isEmpty()) {
-			this.constructors = CtElementImpl.emptySet();
+			this.typeMembers.removeAll(getConstructors());
 			return (C) this;
 		}
-		if (this.constructors == CtElementImpl.<CtConstructor<T>>emptySet()) {
-			this.constructors = new TreeSet<>();
-		}
-		this.constructors.clear();
+		typeMembers.removeAll(getConstructors());
 		for (CtConstructor<T> constructor : constructors) {
 			addConstructor(constructor);
 		}
@@ -143,31 +139,12 @@ public class CtClassImpl<T extends Object> extends CtTypeImpl<T> implements CtCl
 
 	@Override
 	public <C extends CtClass<T>> C addConstructor(CtConstructor<T> constructor) {
-		if (constructor == null) {
-			return (C) this;
-		}
-		if (constructors == CtElementImpl.<CtConstructor<T>>emptySet()) {
-			constructors = new TreeSet<>();
-		}
-		// this needs to be done because of the set that needs the constructor's
-		// signature : we should use lists!!!
-		// TODO: CHANGE SETS TO LIST TO AVOID HAVING TO DO THIS
-		constructor.setParent(this);
-		constructors.add(constructor);
-		return (C) this;
+		return addTypeMember(constructor);
 	}
 
 	@Override
 	public void removeConstructor(CtConstructor<T> constructor) {
-		if (!constructors.isEmpty()) {
-			if (constructors.size() == 1) {
-				if (constructors.contains(constructor)) {
-					constructors = CtElementImpl.<CtConstructor<T>>emptySet();
-				}
-			} else {
-				constructors.remove(constructor);
-			}
-		}
+		removeTypeMember(constructor);
 	}
 
 	@Override
diff --git a/src/main/java/spoon/support/reflect/declaration/CtEnumImpl.java b/src/main/java/spoon/support/reflect/declaration/CtEnumImpl.java
index 0c8b15e43..6c41f2689 100644
--- a/src/main/java/spoon/support/reflect/declaration/CtEnumImpl.java
+++ b/src/main/java/spoon/support/reflect/declaration/CtEnumImpl.java
@@ -20,6 +20,7 @@ import spoon.reflect.declaration.CtEnum;
 import spoon.reflect.declaration.CtEnumValue;
 import spoon.reflect.declaration.CtField;
 import spoon.reflect.declaration.CtMethod;
+import spoon.reflect.declaration.ModifierKind;
 import spoon.reflect.reference.CtTypeReference;
 import spoon.reflect.visitor.CtVisitor;
 
@@ -28,12 +29,11 @@ import java.util.Collections;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
-import spoon.reflect.declaration.ModifierKind;
 
 public class CtEnumImpl<T extends Enum<?>> extends CtClassImpl<T> implements CtEnum<T> {
 	private static final long serialVersionUID = 1L;
 
-	private List<CtEnumValue<?>> enumValues = CtElementImpl.<CtEnumValue<?>>emptyList();
+	private List<CtEnumValue<?>> enumValues = CtElementImpl.emptyList();
 
 	private CtMethod<T[]> valuesMethod;
 
@@ -99,6 +99,19 @@ public class CtEnumImpl<T extends Enum<?>> extends CtClassImpl<T> implements CtE
 		return Collections.unmodifiableList(enumValues);
 	}
 
+	@Override
+	public <C extends CtEnum<T>> C setEnumValues(List<CtEnumValue<?>> enumValues) {
+		if (enumValues == null || enumValues.isEmpty()) {
+			this.enumValues = emptyList();
+			return (C) this;
+		}
+		this.enumValues.clear();
+		for (CtEnumValue<?> enumValue : enumValues) {
+			addEnumValue(enumValue);
+		}
+		return (C) this;
+	}
+
 	@Override
 	public List<CtField<?>> getFields() {
 		List<CtField<?>> result = new ArrayList<>();
diff --git a/src/main/java/spoon/support/reflect/declaration/CtTypeImpl.java b/src/main/java/spoon/support/reflect/declaration/CtTypeImpl.java
index 7296ff374..7017935b4 100644
--- a/src/main/java/spoon/support/reflect/declaration/CtTypeImpl.java
+++ b/src/main/java/spoon/support/reflect/declaration/CtTypeImpl.java
@@ -20,6 +20,7 @@ import spoon.reflect.cu.CompilationUnit;
 import spoon.reflect.declaration.CtAnnotation;
 import spoon.reflect.declaration.CtAnnotationType;
 import spoon.reflect.declaration.CtClass;
+import spoon.reflect.declaration.CtConstructor;
 import spoon.reflect.declaration.CtElement;
 import spoon.reflect.declaration.CtExecutable;
 import spoon.reflect.declaration.CtField;
@@ -29,6 +30,7 @@ import spoon.reflect.declaration.CtModifiable;
 import spoon.reflect.declaration.CtPackage;
 import spoon.reflect.declaration.CtShadowable;
 import spoon.reflect.declaration.CtType;
+import spoon.reflect.declaration.CtTypeMember;
 import spoon.reflect.declaration.CtTypeParameter;
 import spoon.reflect.declaration.ModifierKind;
 import spoon.reflect.declaration.ParentNotInitializedException;
@@ -55,7 +57,6 @@ import java.util.List;
 import java.util.Set;
 import java.util.TreeSet;
 
-import static spoon.reflect.ModelElementContainerDefaultCapacities.FIELDS_CONTAINER_DEFAULT_CAPACITY;
 import static spoon.reflect.ModelElementContainerDefaultCapacities.TYPE_TYPE_PARAMETERS_CONTAINER_DEFAULT_CAPACITY;
 
 /**
@@ -65,84 +66,101 @@ public abstract class CtTypeImpl<T> extends CtNamedElementImpl implements CtType
 
 	private static final long serialVersionUID = 1L;
 
-	List<CtTypeParameterReference> formalTypeParameters = emptyList();
-
 	List<CtTypeParameter> formalCtTypeParameters = emptyList();
 
 	Set<CtTypeReference<?>> interfaces = emptySet();
 
-	Set<CtMethod<?>> methods = emptySet();
-
-	List<CtField<?>> fields = emptyList();
-
-	Set<CtType<?>> nestedTypes = emptySet();
-
 	Set<ModifierKind> modifiers = emptySet();
 
+	List<CtTypeMember> typeMembers = emptyList();
+
 	public CtTypeImpl() {
 		super();
 	}
 
 	@Override
-	public <F, C extends CtType<T>> C addFieldAtTop(CtField<F> field) {
-		if (field == null) {
+	public List<CtTypeMember> getTypeMembers() {
+		return typeMembers;
+	}
+
+	@Override
+	public <C extends CtType<T>> C addTypeMember(CtTypeMember member) {
+		if (member == null) {
+			return (C) this;
+		}
+		return addTypeMemberAt(typeMembers.size(), member);
+	}
+
+	@Override
+	public <C extends CtType<T>> C addTypeMemberAt(int position, CtTypeMember member) {
+		if (member == null) {
 			return (C) this;
 		}
-		if (this.fields == CtElementImpl.<CtField<?>>emptyList()) {
-			this.fields = new ArrayList<>(FIELDS_CONTAINER_DEFAULT_CAPACITY);
+		if (this.typeMembers == CtElementImpl.<CtTypeMember>emptyList()) {
+			this.typeMembers = new ArrayList<>();
 		}
-		if (!this.fields.contains(field)) {
-			field.setParent(this);
-			CompilationUnit compilationUnit = null;
-			if (getPosition() != null) {
-				compilationUnit = getPosition().getCompilationUnit();
-			}
-			field.setPosition(getFactory().Core().createSourcePosition(compilationUnit, -1, -1, -1, new int[0]));
-			this.fields.add(field);
+		if (!this.typeMembers.contains(member)) {
+			member.setParent(this);
+			this.typeMembers.add(position, member);
 		}
-
-		// field already exists
 		return (C) this;
 	}
 
 	@Override
-	public <F, C extends CtType<T>> C addField(CtField<F> field) {
-		if (field == null) {
-			return (C) this;
+	public boolean removeTypeMember(CtTypeMember member) {
+		if (typeMembers.size() == 1) {
+			if (typeMembers.contains(member)) {
+				typeMembers = emptyList();
+				return true;
+			} else {
+				return false;
+			}
 		}
-		if (this.fields == CtElementImpl.<CtField<?>>emptyList()) {
-			this.fields = new ArrayList<>(FIELDS_CONTAINER_DEFAULT_CAPACITY);
+		return typeMembers.remove(member);
+	}
+
+	@Override
+	public <C extends CtType<T>> C setTypeMembers(List<CtTypeMember> members) {
+		if (members == null || members.isEmpty()) {
+			this.typeMembers = emptyList();
+			return (C) this;
 		}
-		if (!this.fields.contains(field)) {
-			field.setParent(this);
-			this.fields.add(field);
+		typeMembers.clear();
+		for (CtTypeMember typeMember : members) {
+			addTypeMember(typeMember);
 		}
-
-		// field already exists
 		return (C) this;
 	}
 
 	@Override
-	public <F, C extends CtType<T>> C addField(int index, CtField<F> field) {
-		if (this.fields == CtElementImpl.<CtField<?>>emptyList()) {
-			this.fields = new ArrayList<>(FIELDS_CONTAINER_DEFAULT_CAPACITY);
-		}
-		if (!this.fields.contains(field)) {
-			field.setParent(this);
-			this.fields.add(index, field);
+	public <F, C extends CtType<T>> C addFieldAtTop(CtField<F> field) {
+		if (field != null && !this.typeMembers.contains(field)) {
+			CompilationUnit compilationUnit = null;
+			if (getPosition() != null) {
+				compilationUnit = getPosition().getCompilationUnit();
+			}
+			field.setPosition(getFactory().Core().createSourcePosition(compilationUnit, -1, -1, -1, new int[0]));
 		}
+		return addTypeMemberAt(0, field);
+	}
 
-		// field already exists
-		return (C) this;
+	@Override
+	public <F, C extends CtType<T>> C addField(CtField<F> field) {
+		return addTypeMember(field);
+	}
+
+	@Override
+	public <F, C extends CtType<T>> C addField(int index, CtField<F> field) {
+		return addTypeMemberAt(index, field);
 	}
 
 	@Override
 	public <C extends CtType<T>> C setFields(List<CtField<?>> fields) {
 		if (fields == null || fields.isEmpty()) {
-			this.fields = CtElementImpl.emptyList();
+			this.typeMembers.removeAll(getFields());
 			return (C) this;
 		}
-		this.fields.clear();
+		typeMembers.removeAll(getFields());
 		for (CtField<?> field : fields) {
 			addField(field);
 		}
@@ -151,14 +169,14 @@ public abstract class CtTypeImpl<T> extends CtNamedElementImpl implements CtType
 
 	@Override
 	public <F> boolean removeField(CtField<F> field) {
-		return this.fields.remove(field);
+		return removeTypeMember(field);
 	}
 
 	@Override
 	public CtField<?> getField(String name) {
-		for (CtField<?> f : fields) {
-			if (f.getSimpleName().equals(name)) {
-				return f;
+		for (CtTypeMember typeMember : typeMembers) {
+			if (typeMember instanceof CtField && ((CtField) typeMember).getSimpleName().equals(name)) {
+				return (CtField<?>) typeMember;
 			}
 		}
 		return null;
@@ -166,48 +184,32 @@ public abstract class CtTypeImpl<T> extends CtNamedElementImpl implements CtType
 
 	@Override
 	public List<CtField<?>> getFields() {
+		List<CtField<?>> fields = new ArrayList<>();
+		for (CtTypeMember typeMember : typeMembers) {
+			if (typeMember instanceof CtField) {
+				fields.add((CtField<?>) typeMember);
+			}
+		}
 		return fields;
 	}
 
 	@Override
 	public <N, C extends CtType<T>> C addNestedType(CtType<N> nestedType) {
-		if (nestedType == null) {
-			return (C) this;
-		}
-		if (nestedTypes == CtElementImpl.<CtType<?>>emptySet()) {
-			nestedTypes = new TreeSet<>();
-		}
-		nestedType.setParent(this);
-		this.nestedTypes.add(nestedType);
-		return (C) this;
+		return addTypeMember(nestedType);
 	}
 
 	@Override
 	public <N> boolean removeNestedType(CtType<N> nestedType) {
-		if (nestedTypes.isEmpty()) {
-			return false;
-		} else if (nestedTypes.size() == 1) {
-			if (nestedTypes.contains(nestedType)) {
-				nestedTypes = CtElementImpl.<CtType<?>>emptySet();
-				return true;
-			} else {
-				return false;
-			}
-		} else {
-			return this.nestedTypes.remove(nestedType);
-		}
+		return removeTypeMember(nestedType);
 	}
 
 	@Override
 	public <C extends CtType<T>> C setNestedTypes(Set<CtType<?>> nestedTypes) {
 		if (nestedTypes == null || nestedTypes.isEmpty()) {
-			this.nestedTypes = CtElementImpl.emptySet();
+			this.typeMembers.removeAll(getNestedTypes());
 			return (C) this;
 		}
-		if (this.nestedTypes == CtElementImpl.<CtType<?>>emptySet()) {
-			this.nestedTypes = new TreeSet<>();
-		}
-		this.nestedTypes.clear();
+		typeMembers.removeAll(getNestedTypes());
 		for (CtType<?> nestedType : nestedTypes) {
 			addNestedType(nestedType);
 		}
@@ -289,26 +291,39 @@ public abstract class CtTypeImpl<T> extends CtNamedElementImpl implements CtType
 			@Override
 			public <U> void visitCtClass(spoon.reflect.declaration.CtClass<U> ctClass) {
 				if (!checkType(ctClass)) {
-					scan(ctClass.getNestedTypes());
-					scan(ctClass.getConstructors());
-					scan(ctClass.getMethods());
+					final List<CtTypeMember> typeMembers = new ArrayList<>();
+					for (CtTypeMember typeMember : ctClass.getTypeMembers()) {
+						if (typeMember instanceof CtType || typeMember instanceof CtConstructor || typeMember instanceof CtMethod) {
+							typeMembers.add(typeMember);
+						}
+					}
+					scan(typeMembers);
 				}
 			}
 
 			@Override
 			public <U> void visitCtInterface(spoon.reflect.declaration.CtInterface<U> intrface) {
 				if (!checkType(intrface)) {
-					scan(intrface.getNestedTypes());
-					scan(intrface.getMethods());
+					final List<CtTypeMember> typeMembers = new ArrayList<>();
+					for (CtTypeMember typeMember : intrface.getTypeMembers()) {
+						if (typeMember instanceof CtType || typeMember instanceof CtMethod) {
+							typeMembers.add(typeMember);
+						}
+					}
+					scan(typeMembers);
 				}
 			}
 
 			@Override
 			public <U extends java.lang.Enum<?>> void visitCtEnum(spoon.reflect.declaration.CtEnum<U> ctEnum) {
 				if (!checkType(ctEnum)) {
-					scan(ctEnum.getNestedTypes());
-					scan(ctEnum.getConstructors());
-					scan(ctEnum.getMethods());
+					final List<CtTypeMember> typeMembers = new ArrayList<>();
+					for (CtTypeMember typeMember : ctEnum.getTypeMembers()) {
+						if (typeMember instanceof CtType || typeMember instanceof CtConstructor || typeMember instanceof CtMethod) {
+							typeMembers.add(typeMember);
+						}
+					}
+					scan(typeMembers);
 				}
 			}
 
@@ -326,6 +341,12 @@ public abstract class CtTypeImpl<T> extends CtNamedElementImpl implements CtType
 
 	@Override
 	public Set<CtType<?>> getNestedTypes() {
+		Set<CtType<?>> nestedTypes = new TreeSet<>();
+		for (CtTypeMember typeMember : typeMembers) {
+			if (typeMember instanceof CtType) {
+				nestedTypes.add((CtType<?>) typeMember);
+			}
+		}
 		return nestedTypes;
 	}
 
@@ -449,29 +470,28 @@ public abstract class CtTypeImpl<T> extends CtNamedElementImpl implements CtType
 
 	@Override
 	public List<CtFieldReference<?>> getAllFields() {
-		List<CtFieldReference<?>> l = new ArrayList<>(getFields().size());
-		for (CtField<?> f : getFields()) {
-			l.add(f.getReference());
-		}
+		final List<CtFieldReference<?>> fields = getDeclaredFields();
 		if (this instanceof CtClass) {
 			CtTypeReference<?> st = ((CtClass<?>) this).getSuperclass();
 			if (st != null) {
-				l.addAll(st.getAllFields());
+				fields.addAll(st.getAllFields());
 			}
 		}
-		return l;
+		return fields;
 	}
 
 	@Override
-	public Collection<CtFieldReference<?>> getDeclaredFields() {
-		if (getFields().isEmpty()) {
+	public List<CtFieldReference<?>> getDeclaredFields() {
+		if (typeMembers.isEmpty()) {
 			return Collections.emptyList();
 		}
-		List<CtFieldReference<?>> l = new ArrayList<>(getFields().size());
-		for (CtField<?> f : getFields()) {
-			l.add(f.getReference());
+		final List<CtFieldReference<?>> fields = new ArrayList<>(typeMembers.size());
+		for (CtTypeMember typeMember : typeMembers) {
+			if (typeMember instanceof CtField) {
+				fields.add(((CtField) typeMember).getReference());
+			}
 		}
-		return Collections.unmodifiableList(l);
+		return fields;
 	}
 
 	/**
@@ -489,49 +509,30 @@ public abstract class CtTypeImpl<T> extends CtNamedElementImpl implements CtType
 
 	@Override
 	public <M, C extends CtType<T>> C addMethod(CtMethod<M> method) {
-		if (method == null) {
-			return (C) this;
-		}
-		if (methods == CtElementImpl.<CtMethod<?>>emptySet()) {
-			methods = new TreeSet<>();
-		}
-		for (CtMethod m: new ArrayList<>(methods)) {
-			if (m.getSignature().equals(method.getSignature())) {
-				// replace old method by new one (based on signature and not equality)
-				// we have to do it by hand
-				methods.remove(m);
-			} else {
-				// checking contract signature implies equal
-				if (!factory.getEnvironment().checksAreSkipped() && m.equals(method)) {
-					throw new AssertionError("violation of core contract! different signature but same equal");
+		if (method != null) {
+			for (CtTypeMember typeMember: typeMembers) {
+				if (!(typeMember instanceof CtMethod)) {
+					continue;
+				}
+				CtMethod<?> m = (CtMethod<?>) typeMember;
+				if (m.getSignature().equals(method.getSignature())) {
+					// replace old method by new one (based on signature and not equality)
+					// we have to do it by hand
+					typeMembers.remove(m);
+				} else {
+					// checking contract signature implies equal
+					if (!factory.getEnvironment().checksAreSkipped() && m.equals(method)) {
+						throw new AssertionError("violation of core contract! different signature but same equal");
+					}
 				}
 			}
 		}
-		method.setParent(this);
-		methods.add(method);
-		return (C) this;
+		return addTypeMember(method);
 	}
 
 	@Override
 	public <M> boolean removeMethod(CtMethod<M> method) {
-		if (methods.isEmpty()) {
-			return false;
-		} else if (methods.size() == 1) {
-			if (methods.contains(method)) {
-				methods = CtElementImpl.<CtMethod<?>>emptySet();
-				return true;
-			} else {
-				return false;
-			}
-		} else {
-			// This contains() is not needed for dealing with empty and
-			// singleton sets (as they are dealt above), but removing contains()
-			// check here might broke someone's code like
-			// type.setMethods(immutableSet(a, b, c));
-			// ...
-			// type.removeMethod(d)
-			return methods.contains(method) && methods.remove(method);
-		}
+		return removeTypeMember(method);
 	}
 
 	@Override
@@ -605,18 +606,19 @@ public abstract class CtTypeImpl<T> extends CtNamedElementImpl implements CtType
 
 	@Override
 	@SuppressWarnings("unchecked")
-	public <R> CtMethod<R> getMethod(CtTypeReference<R> returnType, String name, CtTypeReference<?>...
-			parameterTypes) {
-		for (CtMethod<?> mm : methods) {
-			CtMethod<R> m = (CtMethod<R>) mm;
+	public <R> CtMethod<R> getMethod(CtTypeReference<R> returnType, String name, CtTypeReference<?>... parameterTypes) {
+		for (CtTypeMember typeMember : typeMembers) {
+			if (!(typeMember instanceof CtMethod)) {
+				continue;
+			}
+			CtMethod<R> m = (CtMethod<R>) typeMember;
 			if (m.getSimpleName().equals(name)) {
 				if (!m.getType().equals(returnType)) {
 					continue;
 				}
 				boolean cont = m.getParameters().size() == parameterTypes.length;
 				for (int i = 0; cont && (i < m.getParameters().size()) && (i < parameterTypes.length); i++) {
-					if (!m.getParameters().get(i).getType().getQualifiedName()
-							.equals(parameterTypes[i].getQualifiedName())) {
+					if (!m.getParameters().get(i).getType().getQualifiedName().equals(parameterTypes[i].getQualifiedName())) {
 						cont = false;
 					}
 				}
@@ -694,13 +696,23 @@ public abstract class CtTypeImpl<T> extends CtNamedElementImpl implements CtType
 
 	@Override
 	public Set<CtMethod<?>> getMethods() {
+		Set<CtMethod<?>> methods = new TreeSet<>();
+		for (CtTypeMember typeMember : typeMembers) {
+			if (typeMember instanceof CtMethod) {
+				methods.add((CtMethod<?>) typeMember);
+			}
+		}
 		return methods;
 	}
 
 	@Override
 	public Set<CtMethod<?>> getMethodsAnnotatedWith(CtTypeReference<?>... annotationTypes) {
 		Set<CtMethod<?>> result = new HashSet<>();
-		for (CtMethod<?> m : methods) {
+		for (CtTypeMember typeMember : typeMembers) {
+			if (!(typeMember instanceof CtMethod)) {
+				continue;
+			}
+			CtMethod<?> m = (CtMethod<?>) typeMember;
 			for (CtAnnotation<?> a : m.getAnnotations()) {
 				if (Arrays.asList(annotationTypes).contains(a.getAnnotationType())) {
 					result.add(m);
@@ -713,7 +725,11 @@ public abstract class CtTypeImpl<T> extends CtNamedElementImpl implements CtType
 	@Override
 	public List<CtMethod<?>> getMethodsByName(String name) {
 		List<CtMethod<?>> result = new ArrayList<>(1);
-		for (CtMethod<?> m : methods) {
+		for (CtTypeMember typeMember : typeMembers) {
+			if (!(typeMember instanceof CtMethod)) {
+				continue;
+			}
+			CtMethod<?> m = (CtMethod<?>) typeMember;
 			if (name.equals(m.getSimpleName())) {
 				result.add(m);
 			}
@@ -744,10 +760,10 @@ public abstract class CtTypeImpl<T> extends CtNamedElementImpl implements CtType
 	@Override
 	public <C extends CtType<T>> C setMethods(Set<CtMethod<?>> methods) {
 		if (methods == null || methods.isEmpty()) {
-			this.methods = CtElementImpl.emptySet();
+			this.typeMembers.removeAll(getMethods());
 			return (C) this;
 		}
-		this.methods.clear();
+		typeMembers.removeAll(getMethods());
 		for (CtMethod<?> meth : methods) {
 			addMethod(meth);
 		}
diff --git a/src/main/java/spoon/support/reflect/declaration/CtTypeParameterImpl.java b/src/main/java/spoon/support/reflect/declaration/CtTypeParameterImpl.java
index 720c2545f..f055c3332 100644
--- a/src/main/java/spoon/support/reflect/declaration/CtTypeParameterImpl.java
+++ b/src/main/java/spoon/support/reflect/declaration/CtTypeParameterImpl.java
@@ -202,7 +202,7 @@ public class CtTypeParameterImpl extends CtTypeImpl<Object> implements CtTypePar
 	}
 
 	@Override
-	public Collection<CtFieldReference<?>> getDeclaredFields() {
+	public List<CtFieldReference<?>> getDeclaredFields() {
 		return Collections.emptyList();
 	}
 
diff --git a/src/main/java/spoon/support/template/Parameters.java b/src/main/java/spoon/support/template/Parameters.java
index 5789265f8..0009ebc8c 100644
--- a/src/main/java/spoon/support/template/Parameters.java
+++ b/src/main/java/spoon/support/template/Parameters.java
@@ -16,20 +16,13 @@
  */
 package spoon.support.template;
 
-import java.lang.reflect.Field;
-import java.lang.reflect.Modifier;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
 import spoon.Launcher;
 import spoon.reflect.code.CtArrayAccess;
 import spoon.reflect.code.CtExpression;
 import spoon.reflect.code.CtLiteral;
 import spoon.reflect.declaration.CtClass;
 import spoon.reflect.declaration.CtField;
+import spoon.reflect.declaration.CtTypeMember;
 import spoon.reflect.factory.Factory;
 import spoon.reflect.reference.CtFieldReference;
 import spoon.reflect.reference.CtTypeParameterReference;
@@ -39,6 +32,14 @@ import spoon.template.Parameter;
 import spoon.template.Template;
 import spoon.template.TemplateParameter;
 
+import java.lang.reflect.Field;
+import java.lang.reflect.Modifier;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
 /**
  * This class defines an API to manipulate template parameters.
  */
@@ -101,7 +102,11 @@ public abstract class Parameters {
 	static Map<Template<?>, Map<String, Object>> finals = new HashMap<>();
 
 	public static CtField<?> getParameterField(CtClass<? extends Template<?>> templateClass, String parameterName) {
-		for (CtField<?> f : templateClass.getFields()) {
+		for (CtTypeMember typeMember : templateClass.getTypeMembers()) {
+			if (!(typeMember instanceof CtField)) {
+				continue;
+			}
+			CtField<?> f = (CtField<?>) typeMember;
 			Parameter p = f.getAnnotation(Parameter.class);
 			if (p == null) {
 				continue;
diff --git a/src/main/java/spoon/support/template/SubstitutionVisitor.java b/src/main/java/spoon/support/template/SubstitutionVisitor.java
index e8b5f104c..37e5948df 100644
--- a/src/main/java/spoon/support/template/SubstitutionVisitor.java
+++ b/src/main/java/spoon/support/template/SubstitutionVisitor.java
@@ -45,6 +45,7 @@ import spoon.reflect.declaration.CtMethod;
 import spoon.reflect.declaration.CtNamedElement;
 import spoon.reflect.declaration.CtParameter;
 import spoon.reflect.declaration.CtType;
+import spoon.reflect.declaration.CtTypeMember;
 import spoon.reflect.declaration.CtTypedElement;
 import spoon.reflect.factory.Factory;
 import spoon.reflect.reference.CtArrayTypeReference;
@@ -193,7 +194,11 @@ public class SubstitutionVisitor extends CtScanner {
 					it.remove();
 				}
 			}
-			for (CtField<?> field : new TreeSet<>(ctClass.getFields())) {
+			for (CtTypeMember typeMember : ctClass.getTypeMembers()) {
+				if (!(typeMember instanceof CtField)) {
+					continue;
+				}
+				CtField<?> field = (CtField<?>) typeMember;
 				if ((field.getAnnotation(Local.class) != null) || Parameters.isParameterSource(field.getReference())) {
 					ctClass.removeField(field);
 					continue;
@@ -203,15 +208,14 @@ public class SubstitutionVisitor extends CtScanner {
 				for (String pname : parameterNames) {
 					if (name.equals(pname)) {
 						Object value = Parameters.getValue(template, pname, null);
-						int i = ctClass.getFields().indexOf(field);
+						int i = ctClass.getTypeMembers().indexOf(field);
 						if (value instanceof List) {
-							List<?> l = (List<?>) value;
-							for (Object f : l) {
+							List<?> list = (List<?>) value;
+							for (Object f : list) {
 								CtField<?> f2 = ((CtField<?>) f).clone();
-								f2.setParent(ctClass);
-								ctClass.getFields().add(i++, f2);
+								ctClass.addTypeMemberAt(i++, f2);
 							}
-							ctClass.removeField(field);
+							ctClass.removeTypeMember(field);
 						}
 					}
 				}
diff --git a/src/main/java/spoon/support/visitor/TypeReferenceScanner.java b/src/main/java/spoon/support/visitor/TypeReferenceScanner.java
index 6e3f83c48..a4e812cf0 100644
--- a/src/main/java/spoon/support/visitor/TypeReferenceScanner.java
+++ b/src/main/java/spoon/support/visitor/TypeReferenceScanner.java
@@ -23,6 +23,7 @@ import spoon.reflect.declaration.CtClass;
 import spoon.reflect.declaration.CtEnum;
 import spoon.reflect.declaration.CtInterface;
 import spoon.reflect.declaration.CtType;
+import spoon.reflect.declaration.CtTypeMember;
 import spoon.reflect.reference.CtArrayTypeReference;
 import spoon.reflect.reference.CtExecutableReference;
 import spoon.reflect.reference.CtFieldReference;
@@ -144,8 +145,10 @@ public class TypeReferenceScanner extends CtScanner {
 	@Override
 	public <T> void visitCtInterface(CtInterface<T> intrface) {
 		addReference(intrface.getReference());
-		for (CtType<?> t : intrface.getNestedTypes()) {
-			addReference(t.getReference());
+		for (CtTypeMember typeMember : intrface.getTypeMembers()) {
+			if (typeMember instanceof CtType) {
+				addReference(((CtType) typeMember).getReference());
+			}
 		}
 		super.visitCtInterface(intrface);
 	}
@@ -153,8 +156,10 @@ public class TypeReferenceScanner extends CtScanner {
 	@Override
 	public <T> void visitCtClass(CtClass<T> ctClass) {
 		addReference(ctClass.getReference());
-		for (CtType<?> t : ctClass.getNestedTypes()) {
-			addReference(t.getReference());
+		for (CtTypeMember typeMember : ctClass.getTypeMembers()) {
+			if (typeMember instanceof CtType) {
+				addReference(((CtType) typeMember).getReference());
+			}
 		}
 		super.visitCtClass(ctClass);
 	}
diff --git a/src/main/java/spoon/support/visitor/clone/CloneVisitor.java b/src/main/java/spoon/support/visitor/clone/CloneVisitor.java
index 45e95b2e1..6d57975e3 100644
--- a/src/main/java/spoon/support/visitor/clone/CloneVisitor.java
+++ b/src/main/java/spoon/support/visitor/clone/CloneVisitor.java
@@ -46,8 +46,7 @@ public class CloneVisitor extends spoon.reflect.visitor.CtScanner {
 	public <A extends java.lang.annotation.Annotation> void visitCtAnnotationType(final spoon.reflect.declaration.CtAnnotationType<A> annotationType) {
 		spoon.reflect.declaration.CtAnnotationType<A> aCtAnnotationType = spoon.support.visitor.clone.CloneBuilder.build(this.builder, annotationType, annotationType.getFactory().Core().createAnnotationType());
 		aCtAnnotationType.setAnnotations(spoon.support.visitor.equals.CloneHelper.clone(annotationType.getAnnotations()));
-		aCtAnnotationType.setNestedTypes(spoon.support.visitor.equals.CloneHelper.clone(annotationType.getNestedTypes()));
-		aCtAnnotationType.setFields(spoon.support.visitor.equals.CloneHelper.clone(annotationType.getFields()));
+		aCtAnnotationType.setTypeMembers(spoon.support.visitor.equals.CloneHelper.clone(annotationType.getTypeMembers()));
 		aCtAnnotationType.setComments(spoon.support.visitor.equals.CloneHelper.clone(annotationType.getComments()));
 		this.other = aCtAnnotationType;
 	}
@@ -176,11 +175,7 @@ public class CloneVisitor extends spoon.reflect.visitor.CtScanner {
 		aCtClass.setSuperclass(spoon.support.visitor.equals.CloneHelper.clone(ctClass.getSuperclass()));
 		aCtClass.setSuperInterfaces(spoon.support.visitor.equals.CloneHelper.clone(ctClass.getSuperInterfaces()));
 		aCtClass.setFormalCtTypeParameters(spoon.support.visitor.equals.CloneHelper.clone(ctClass.getFormalCtTypeParameters()));
-		aCtClass.setAnonymousExecutables(spoon.support.visitor.equals.CloneHelper.clone(ctClass.getAnonymousExecutables()));
-		aCtClass.setNestedTypes(spoon.support.visitor.equals.CloneHelper.clone(ctClass.getNestedTypes()));
-		aCtClass.setFields(spoon.support.visitor.equals.CloneHelper.clone(ctClass.getFields()));
-		aCtClass.setConstructors(spoon.support.visitor.equals.CloneHelper.clone(ctClass.getConstructors()));
-		aCtClass.setMethods(spoon.support.visitor.equals.CloneHelper.clone(ctClass.getMethods()));
+		aCtClass.setTypeMembers(spoon.support.visitor.equals.CloneHelper.clone(ctClass.getTypeMembers()));
 		aCtClass.setComments(spoon.support.visitor.equals.CloneHelper.clone(ctClass.getComments()));
 		this.other = aCtClass;
 	}
@@ -243,10 +238,8 @@ public class CloneVisitor extends spoon.reflect.visitor.CtScanner {
 		spoon.reflect.declaration.CtEnum<T> aCtEnum = spoon.support.visitor.clone.CloneBuilder.build(this.builder, ctEnum, ctEnum.getFactory().Core().createEnum());
 		aCtEnum.setAnnotations(spoon.support.visitor.equals.CloneHelper.clone(ctEnum.getAnnotations()));
 		aCtEnum.setSuperInterfaces(spoon.support.visitor.equals.CloneHelper.clone(ctEnum.getSuperInterfaces()));
-		aCtEnum.setFields(spoon.support.visitor.equals.CloneHelper.clone(ctEnum.getFields()));
-		aCtEnum.setConstructors(spoon.support.visitor.equals.CloneHelper.clone(ctEnum.getConstructors()));
-		aCtEnum.setMethods(spoon.support.visitor.equals.CloneHelper.clone(ctEnum.getMethods()));
-		aCtEnum.setNestedTypes(spoon.support.visitor.equals.CloneHelper.clone(ctEnum.getNestedTypes()));
+		aCtEnum.setTypeMembers(spoon.support.visitor.equals.CloneHelper.clone(ctEnum.getTypeMembers()));
+		aCtEnum.setEnumValues(spoon.support.visitor.equals.CloneHelper.clone(ctEnum.getEnumValues()));
 		aCtEnum.setComments(spoon.support.visitor.equals.CloneHelper.clone(ctEnum.getComments()));
 		this.other = aCtEnum;
 	}
@@ -356,9 +349,7 @@ public class CloneVisitor extends spoon.reflect.visitor.CtScanner {
 		aCtInterface.setAnnotations(spoon.support.visitor.equals.CloneHelper.clone(intrface.getAnnotations()));
 		aCtInterface.setSuperInterfaces(spoon.support.visitor.equals.CloneHelper.clone(intrface.getSuperInterfaces()));
 		aCtInterface.setFormalCtTypeParameters(spoon.support.visitor.equals.CloneHelper.clone(intrface.getFormalCtTypeParameters()));
-		aCtInterface.setNestedTypes(spoon.support.visitor.equals.CloneHelper.clone(intrface.getNestedTypes()));
-		aCtInterface.setFields(spoon.support.visitor.equals.CloneHelper.clone(intrface.getFields()));
-		aCtInterface.setMethods(spoon.support.visitor.equals.CloneHelper.clone(intrface.getMethods()));
+		aCtInterface.setTypeMembers(spoon.support.visitor.equals.CloneHelper.clone(intrface.getTypeMembers()));
 		aCtInterface.setComments(spoon.support.visitor.equals.CloneHelper.clone(intrface.getComments()));
 		this.other = aCtInterface;
 	}
diff --git a/src/main/java/spoon/support/visitor/equals/EqualsVisitor.java b/src/main/java/spoon/support/visitor/equals/EqualsVisitor.java
index 15e235db6..15857e34f 100644
--- a/src/main/java/spoon/support/visitor/equals/EqualsVisitor.java
+++ b/src/main/java/spoon/support/visitor/equals/EqualsVisitor.java
@@ -18,6 +18,7 @@
 
 package spoon.support.visitor.equals;
 
+
 /**
  * Used to check equality between an element and another one.
  *
@@ -30,15 +31,6 @@ public class EqualsVisitor extends spoon.reflect.visitor.CtAbstractBiScanner {
 
 	private final spoon.support.visitor.equals.EqualsChecker checker = new spoon.support.visitor.equals.EqualsChecker();
 
-	public <A extends java.lang.annotation.Annotation> void visitCtAnnotation(final spoon.reflect.declaration.CtAnnotation<A> annotation) {
-		spoon.reflect.declaration.CtAnnotation other = ((spoon.reflect.declaration.CtAnnotation) (stack.peek()));
-		enter(annotation);
-		biScan(annotation.getAnnotationType(), other.getAnnotationType());
-		biScan(annotation.getAnnotations(), other.getAnnotations());
-		biScan(annotation.getValues().values(), other.getValues().values());
-		exit(annotation);
-	}
-
 	@java.lang.Override
 	protected void enter(spoon.reflect.declaration.CtElement e) {
 		super.enter(e);
@@ -49,12 +41,20 @@ public class EqualsVisitor extends spoon.reflect.visitor.CtAbstractBiScanner {
 		}
 	}
 
+	public <A extends java.lang.annotation.Annotation> void visitCtAnnotation(final spoon.reflect.declaration.CtAnnotation<A> annotation) {
+		spoon.reflect.declaration.CtAnnotation other = ((spoon.reflect.declaration.CtAnnotation) (stack.peek()));
+		enter(annotation);
+		biScan(annotation.getAnnotationType(), other.getAnnotationType());
+		biScan(annotation.getAnnotations(), other.getAnnotations());
+		biScan(annotation.getValues().values(), other.getValues().values());
+		exit(annotation);
+	}
+
 	public <A extends java.lang.annotation.Annotation> void visitCtAnnotationType(final spoon.reflect.declaration.CtAnnotationType<A> annotationType) {
 		spoon.reflect.declaration.CtAnnotationType other = ((spoon.reflect.declaration.CtAnnotationType) (stack.peek()));
 		enter(annotationType);
 		biScan(annotationType.getAnnotations(), other.getAnnotations());
-		biScan(annotationType.getNestedTypes(), other.getNestedTypes());
-		biScan(annotationType.getFields(), other.getFields());
+		biScan(annotationType.getTypeMembers(), other.getTypeMembers());
 		exit(annotationType);
 	}
 
@@ -171,15 +171,11 @@ public class EqualsVisitor extends spoon.reflect.visitor.CtAbstractBiScanner {
 		biScan(ctClass.getSuperclass(), other.getSuperclass());
 		biScan(ctClass.getSuperInterfaces(), other.getSuperInterfaces());
 		biScan(ctClass.getFormalCtTypeParameters(), other.getFormalCtTypeParameters());
-		biScan(ctClass.getAnonymousExecutables(), other.getAnonymousExecutables());
-		biScan(ctClass.getNestedTypes(), other.getNestedTypes());
-		biScan(ctClass.getFields(), other.getFields());
-		biScan(ctClass.getConstructors(), other.getConstructors());
-		biScan(ctClass.getMethods(), other.getMethods());
+		biScan(ctClass.getTypeMembers(), other.getTypeMembers());
 		exit(ctClass);
 	}
 
-	@Override
+	@java.lang.Override
 	public void visitCtTypeParameter(spoon.reflect.declaration.CtTypeParameter typeParameter) {
 		spoon.reflect.declaration.CtTypeParameter other = ((spoon.reflect.declaration.CtTypeParameter) (stack.peek()));
 		enter(typeParameter);
@@ -232,10 +228,8 @@ public class EqualsVisitor extends spoon.reflect.visitor.CtAbstractBiScanner {
 		enter(ctEnum);
 		biScan(ctEnum.getAnnotations(), other.getAnnotations());
 		biScan(ctEnum.getSuperInterfaces(), other.getSuperInterfaces());
-		biScan(ctEnum.getFields(), other.getFields());
-		biScan(ctEnum.getConstructors(), other.getConstructors());
-		biScan(ctEnum.getMethods(), other.getMethods());
-		biScan(ctEnum.getNestedTypes(), other.getNestedTypes());
+		biScan(ctEnum.getTypeMembers(), other.getTypeMembers());
+		biScan(ctEnum.getEnumValues(), other.getEnumValues());
 		exit(ctEnum);
 	}
 
@@ -334,9 +328,7 @@ public class EqualsVisitor extends spoon.reflect.visitor.CtAbstractBiScanner {
 		biScan(intrface.getAnnotations(), other.getAnnotations());
 		biScan(intrface.getSuperInterfaces(), other.getSuperInterfaces());
 		biScan(intrface.getFormalCtTypeParameters(), other.getFormalCtTypeParameters());
-		biScan(intrface.getNestedTypes(), other.getNestedTypes());
-		biScan(intrface.getFields(), other.getFields());
-		biScan(intrface.getMethods(), other.getMethods());
+		biScan(intrface.getTypeMembers(), other.getTypeMembers());
 		exit(intrface);
 	}
 
diff --git a/src/main/java/spoon/support/visitor/replace/ReplacementVisitor.java b/src/main/java/spoon/support/visitor/replace/ReplacementVisitor.java
index 7acd7d81e..8607cfd56 100644
--- a/src/main/java/spoon/support/visitor/replace/ReplacementVisitor.java
+++ b/src/main/java/spoon/support/visitor/replace/ReplacementVisitor.java
@@ -25,45 +25,91 @@ package spoon.support.visitor.replace;
  * This class is generated automatically by the processor {@link spoon.generating.ReplacementVisitorGenerator}.
  */
 public class ReplacementVisitor extends spoon.reflect.visitor.CtScanner {
-	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtAbstractInvocationArgumentsReplaceListener implements spoon.generating.replace.ReplaceListListener<java.util.List> {
-		private final spoon.reflect.code.CtAbstractInvocation element;
-
-		CtAbstractInvocationArgumentsReplaceListener(spoon.reflect.code.CtAbstractInvocation element) {
-			this.element = element;
-		}
-
-		@java.lang.Override
-		public void set(java.util.List replace) {
-			this.element.setArguments(replace);
+	public static void replace(spoon.reflect.declaration.CtElement original, spoon.reflect.declaration.CtElement replace) {
+		try {
+			new spoon.support.visitor.replace.ReplacementVisitor(original, replace).scan(original.getParent());
+		} catch (spoon.SpoonException ignore) {
 		}
 	}
 
-	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtAbstractInvocationExecutableReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.reference.CtExecutableReference> {
-		private final spoon.reflect.code.CtAbstractInvocation element;
+	private spoon.reflect.declaration.CtElement original;
 
-		CtAbstractInvocationExecutableReplaceListener(spoon.reflect.code.CtAbstractInvocation element) {
-			this.element = element;
-		}
+	private spoon.reflect.declaration.CtElement replace;
 
-		@java.lang.Override
-		public void set(spoon.reflect.reference.CtExecutableReference replace) {
-			this.element.setExecutable(replace);
+	private ReplacementVisitor(spoon.reflect.declaration.CtElement original, spoon.reflect.declaration.CtElement replace) {
+		spoon.support.visitor.replace.ReplacementVisitor.this.original = original;
+		spoon.support.visitor.replace.ReplacementVisitor.this.replace = replace;
+	}
+
+	private <K, V extends spoon.reflect.declaration.CtElement> void replaceInMapIfExist(java.util.Map<K, V> mapProtected, spoon.generating.replace.ReplaceMapListener listener) {
+		java.util.Map<K, V> map = new java.util.HashMap<>(mapProtected);
+		V shouldBeDeleted = null;
+		K key = null;
+		for (java.util.Map.Entry<K, V> entry : map.entrySet()) {
+			if ((entry.getValue()) == (original)) {
+				shouldBeDeleted = entry.getValue();
+				key = entry.getKey();
+				break;
+			}
+		}
+		if (shouldBeDeleted != null) {
+			if ((replace) != null) {
+				map.put(key, ((V) (replace)));
+				replace.setParent(shouldBeDeleted.getParent());
+			} else {
+				map.remove(key);
+			}
+			listener.set(map);
 		}
 	}
 
-	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtActualTypeContainerActualTypeArgumentsReplaceListener implements spoon.generating.replace.ReplaceListListener<java.util.List> {
-		private final spoon.reflect.reference.CtActualTypeContainer element;
+	private <T extends spoon.reflect.declaration.CtElement> void replaceInSetIfExist(java.util.Set<T> setProtected, spoon.generating.replace.ReplaceSetListener listener) {
+		java.util.Set<T> set = new java.util.HashSet<>(setProtected);
+		T shouldBeDeleted = null;
+		for (T element : set) {
+			if (element == (original)) {
+				shouldBeDeleted = element;
+				break;
+			}
+		}
+		if (shouldBeDeleted != null) {
+			set.remove(shouldBeDeleted);
+			if ((replace) != null) {
+				set.add(((T) (replace)));
+				replace.setParent(shouldBeDeleted.getParent());
+			}
+			listener.set(set);
+		}
+	}
 
-		CtActualTypeContainerActualTypeArgumentsReplaceListener(spoon.reflect.reference.CtActualTypeContainer element) {
-			this.element = element;
+	private <T extends spoon.reflect.declaration.CtElement> void replaceInListIfExist(java.util.List<T> listProtected, spoon.generating.replace.ReplaceListListener listener) {
+		java.util.List<T> list = new java.util.ArrayList<>(listProtected);
+		T shouldBeDeleted = null;
+		int index = 0;
+		for (int i = 0; i < (list.size()); i++) {
+			if ((list.get(i)) == (original)) {
+				index = i;
+				shouldBeDeleted = list.get(i);
+				break;
+			}
+		}
+		if (shouldBeDeleted != null) {
+			if ((replace) != null) {
+				list.set(index, ((T) (replace)));
+				replace.setParent(shouldBeDeleted.getParent());
+			} else {
+				list.remove(index);
+			}
+			listener.set(list);
 		}
+	}
 
-		@java.lang.Override
-		public void set(java.util.List replace) {
-			this.element.setActualTypeArguments(replace);
+	private void replaceElementIfExist(spoon.reflect.declaration.CtElement candidate, spoon.generating.replace.ReplaceListener listener) {
+		if (candidate == (original)) {
+			listener.set(replace);
+			if ((replace) != null) {
+				replace.setParent(candidate.getParent());
+			}
 		}
 	}
 
@@ -82,30 +128,16 @@ public class ReplacementVisitor extends spoon.reflect.visitor.CtScanner {
 	}
 
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtAnnotationFieldAccessVariableReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.reference.CtFieldReference> {
-		private final spoon.reflect.code.CtVariableAccess element;
-
-		CtAnnotationFieldAccessVariableReplaceListener(spoon.reflect.code.CtVariableAccess element) {
-			this.element = element;
-		}
-
-		@java.lang.Override
-		public void set(spoon.reflect.reference.CtFieldReference replace) {
-			this.element.setVariable(replace);
-		}
-	}
-
-	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtAnnotationMethodDefaultExpressionReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtExpression> {
-		private final spoon.reflect.declaration.CtAnnotationMethod element;
+	class CtElementAnnotationsReplaceListener implements spoon.generating.replace.ReplaceListListener<java.util.List> {
+		private final spoon.reflect.declaration.CtElement element;
 
-		CtAnnotationMethodDefaultExpressionReplaceListener(spoon.reflect.declaration.CtAnnotationMethod element) {
+		CtElementAnnotationsReplaceListener(spoon.reflect.declaration.CtElement element) {
 			this.element = element;
 		}
 
 		@java.lang.Override
-		public void set(spoon.reflect.code.CtExpression replace) {
-			this.element.setDefaultExpression(replace);
+		public void set(java.util.List replace) {
+			this.element.setAnnotations(replace);
 		}
 	}
 
@@ -124,1386 +156,829 @@ public class ReplacementVisitor extends spoon.reflect.visitor.CtScanner {
 	}
 
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtArrayAccessIndexExpressionReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtExpression> {
-		private final spoon.reflect.code.CtArrayAccess element;
+	public <A extends java.lang.annotation.Annotation> void visitCtAnnotation(final spoon.reflect.declaration.CtAnnotation<A> annotation) {
+		replaceElementIfExist(annotation.getAnnotationType(), new spoon.support.visitor.replace.ReplacementVisitor.CtAnnotationAnnotationTypeReplaceListener(annotation));
+		replaceInListIfExist(annotation.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(annotation));
+		replaceInMapIfExist(annotation.getValues(), new spoon.support.visitor.replace.ReplacementVisitor.CtAnnotationValuesReplaceListener(annotation));
+	}
 
-		CtArrayAccessIndexExpressionReplaceListener(spoon.reflect.code.CtArrayAccess element) {
+	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
+	class CtTypeTypeMembersReplaceListener implements spoon.generating.replace.ReplaceListListener<java.util.List> {
+		private final spoon.reflect.declaration.CtType element;
+
+		CtTypeTypeMembersReplaceListener(spoon.reflect.declaration.CtType element) {
 			this.element = element;
 		}
 
 		@java.lang.Override
-		public void set(spoon.reflect.code.CtExpression replace) {
-			this.element.setIndexExpression(replace);
+		public void set(java.util.List replace) {
+			this.element.setTypeMembers(replace);
 		}
 	}
 
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtArrayTypeReferenceComponentTypeReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.reference.CtTypeReference> {
-		private final spoon.reflect.reference.CtArrayTypeReference element;
+	class CtElementCommentsReplaceListener implements spoon.generating.replace.ReplaceListListener<java.util.List> {
+		private final spoon.reflect.declaration.CtElement element;
 
-		CtArrayTypeReferenceComponentTypeReplaceListener(spoon.reflect.reference.CtArrayTypeReference element) {
+		CtElementCommentsReplaceListener(spoon.reflect.declaration.CtElement element) {
 			this.element = element;
 		}
 
 		@java.lang.Override
-		public void set(spoon.reflect.reference.CtTypeReference replace) {
-			this.element.setComponentType(replace);
+		public void set(java.util.List replace) {
+			this.element.setComments(replace);
 		}
 	}
 
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtAssertAssertExpressionReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtExpression> {
-		private final spoon.reflect.code.CtAssert element;
+	public <A extends java.lang.annotation.Annotation> void visitCtAnnotationType(final spoon.reflect.declaration.CtAnnotationType<A> annotationType) {
+		replaceInListIfExist(annotationType.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(annotationType));
+		replaceInListIfExist(annotationType.getTypeMembers(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypeTypeMembersReplaceListener(annotationType));
+		replaceInListIfExist(annotationType.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(annotationType));
+	}
 
-		CtAssertAssertExpressionReplaceListener(spoon.reflect.code.CtAssert element) {
+	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
+	class CtExecutableBodyReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtBlock> {
+		private final spoon.reflect.declaration.CtExecutable element;
+
+		CtExecutableBodyReplaceListener(spoon.reflect.declaration.CtExecutable element) {
 			this.element = element;
 		}
 
 		@java.lang.Override
-		public void set(spoon.reflect.code.CtExpression replace) {
-			this.element.setAssertExpression(replace);
+		public void set(spoon.reflect.code.CtBlock replace) {
+			this.element.setBody(replace);
 		}
 	}
 
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtAssertExpressionReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtExpression> {
-		private final spoon.reflect.code.CtAssert element;
+	public void visitCtAnonymousExecutable(final spoon.reflect.declaration.CtAnonymousExecutable anonymousExec) {
+		replaceInListIfExist(anonymousExec.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(anonymousExec));
+		replaceElementIfExist(anonymousExec.getBody(), new spoon.support.visitor.replace.ReplacementVisitor.CtExecutableBodyReplaceListener(anonymousExec));
+		replaceInListIfExist(anonymousExec.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(anonymousExec));
+	}
 
-		CtAssertExpressionReplaceListener(spoon.reflect.code.CtAssert element) {
+	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
+	class CtTypedElementTypeReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.reference.CtTypeReference> {
+		private final spoon.reflect.declaration.CtTypedElement element;
+
+		CtTypedElementTypeReplaceListener(spoon.reflect.declaration.CtTypedElement element) {
 			this.element = element;
 		}
 
 		@java.lang.Override
-		public void set(spoon.reflect.code.CtExpression replace) {
-			this.element.setExpression(replace);
+		public void set(spoon.reflect.reference.CtTypeReference replace) {
+			this.element.setType(replace);
 		}
 	}
 
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtAssignmentAssignedReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtExpression> {
-		private final spoon.reflect.code.CtAssignment element;
+	class CtExpressionTypeCastsReplaceListener implements spoon.generating.replace.ReplaceListListener<java.util.List> {
+		private final spoon.reflect.code.CtExpression element;
 
-		CtAssignmentAssignedReplaceListener(spoon.reflect.code.CtAssignment element) {
+		CtExpressionTypeCastsReplaceListener(spoon.reflect.code.CtExpression element) {
 			this.element = element;
 		}
 
 		@java.lang.Override
-		public void set(spoon.reflect.code.CtExpression replace) {
-			this.element.setAssigned(replace);
+		public void set(java.util.List replace) {
+			this.element.setTypeCasts(replace);
 		}
 	}
 
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtBinaryOperatorLeftHandOperandReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtExpression> {
-		private final spoon.reflect.code.CtBinaryOperator element;
+	class CtTargetedExpressionTargetReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtExpression> {
+		private final spoon.reflect.code.CtTargetedExpression element;
 
-		CtBinaryOperatorLeftHandOperandReplaceListener(spoon.reflect.code.CtBinaryOperator element) {
+		CtTargetedExpressionTargetReplaceListener(spoon.reflect.code.CtTargetedExpression element) {
 			this.element = element;
 		}
 
 		@java.lang.Override
 		public void set(spoon.reflect.code.CtExpression replace) {
-			this.element.setLeftHandOperand(replace);
+			this.element.setTarget(replace);
 		}
 	}
 
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtBinaryOperatorRightHandOperandReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtExpression> {
-		private final spoon.reflect.code.CtBinaryOperator element;
+	class CtArrayAccessIndexExpressionReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtExpression> {
+		private final spoon.reflect.code.CtArrayAccess element;
 
-		CtBinaryOperatorRightHandOperandReplaceListener(spoon.reflect.code.CtBinaryOperator element) {
+		CtArrayAccessIndexExpressionReplaceListener(spoon.reflect.code.CtArrayAccess element) {
 			this.element = element;
 		}
 
 		@java.lang.Override
 		public void set(spoon.reflect.code.CtExpression replace) {
-			this.element.setRightHandOperand(replace);
+			this.element.setIndexExpression(replace);
 		}
 	}
 
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtCaseCaseExpressionReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtExpression> {
-		private final spoon.reflect.code.CtCase element;
+	@java.lang.Override
+	public <T> void visitCtArrayRead(final spoon.reflect.code.CtArrayRead<T> arrayRead) {
+		replaceInListIfExist(arrayRead.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(arrayRead));
+		replaceElementIfExist(arrayRead.getType(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypedElementTypeReplaceListener(arrayRead));
+		replaceInListIfExist(arrayRead.getTypeCasts(), new spoon.support.visitor.replace.ReplacementVisitor.CtExpressionTypeCastsReplaceListener(arrayRead));
+		replaceElementIfExist(arrayRead.getTarget(), new spoon.support.visitor.replace.ReplacementVisitor.CtTargetedExpressionTargetReplaceListener(arrayRead));
+		replaceElementIfExist(arrayRead.getIndexExpression(), new spoon.support.visitor.replace.ReplacementVisitor.CtArrayAccessIndexExpressionReplaceListener(arrayRead));
+		replaceInListIfExist(arrayRead.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(arrayRead));
+	}
 
-		CtCaseCaseExpressionReplaceListener(spoon.reflect.code.CtCase element) {
+	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
+	@java.lang.Override
+	public <T> void visitCtArrayWrite(final spoon.reflect.code.CtArrayWrite<T> arrayWrite) {
+		replaceInListIfExist(arrayWrite.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(arrayWrite));
+		replaceElementIfExist(arrayWrite.getType(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypedElementTypeReplaceListener(arrayWrite));
+		replaceInListIfExist(arrayWrite.getTypeCasts(), new spoon.support.visitor.replace.ReplacementVisitor.CtExpressionTypeCastsReplaceListener(arrayWrite));
+		replaceElementIfExist(arrayWrite.getTarget(), new spoon.support.visitor.replace.ReplacementVisitor.CtTargetedExpressionTargetReplaceListener(arrayWrite));
+		replaceElementIfExist(arrayWrite.getIndexExpression(), new spoon.support.visitor.replace.ReplacementVisitor.CtArrayAccessIndexExpressionReplaceListener(arrayWrite));
+		replaceInListIfExist(arrayWrite.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(arrayWrite));
+	}
+
+	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
+	class CtTypeReferenceDeclaringTypeReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.reference.CtTypeReference> {
+		private final spoon.reflect.reference.CtTypeReference element;
+
+		CtTypeReferenceDeclaringTypeReplaceListener(spoon.reflect.reference.CtTypeReference element) {
 			this.element = element;
 		}
 
 		@java.lang.Override
-		public void set(spoon.reflect.code.CtExpression replace) {
-			this.element.setCaseExpression(replace);
+		public void set(spoon.reflect.reference.CtTypeReference replace) {
+			this.element.setDeclaringType(replace);
 		}
 	}
 
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtCatchBodyReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtBlock> {
-		private final spoon.reflect.code.CtCatch element;
+	class CtTypeReferencePackageReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.reference.CtPackageReference> {
+		private final spoon.reflect.reference.CtTypeReference element;
 
-		CtCatchBodyReplaceListener(spoon.reflect.code.CtCatch element) {
+		CtTypeReferencePackageReplaceListener(spoon.reflect.reference.CtTypeReference element) {
 			this.element = element;
 		}
 
 		@java.lang.Override
-		public void set(spoon.reflect.code.CtBlock replace) {
-			this.element.setBody(replace);
+		public void set(spoon.reflect.reference.CtPackageReference replace) {
+			this.element.setPackage(replace);
 		}
 	}
 
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtCatchParameterReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtCatchVariable> {
-		private final spoon.reflect.code.CtCatch element;
+	class CtArrayTypeReferenceComponentTypeReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.reference.CtTypeReference> {
+		private final spoon.reflect.reference.CtArrayTypeReference element;
 
-		CtCatchParameterReplaceListener(spoon.reflect.code.CtCatch element) {
+		CtArrayTypeReferenceComponentTypeReplaceListener(spoon.reflect.reference.CtArrayTypeReference element) {
 			this.element = element;
 		}
 
 		@java.lang.Override
-		public void set(spoon.reflect.code.CtCatchVariable replace) {
-			this.element.setParameter(replace);
+		public void set(spoon.reflect.reference.CtTypeReference replace) {
+			this.element.setComponentType(replace);
 		}
 	}
 
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtClassAnonymousExecutablesReplaceListener implements spoon.generating.replace.ReplaceListListener<java.util.List> {
-		private final spoon.reflect.declaration.CtClass element;
+	class CtActualTypeContainerActualTypeArgumentsReplaceListener implements spoon.generating.replace.ReplaceListListener<java.util.List> {
+		private final spoon.reflect.reference.CtActualTypeContainer element;
 
-		CtClassAnonymousExecutablesReplaceListener(spoon.reflect.declaration.CtClass element) {
+		CtActualTypeContainerActualTypeArgumentsReplaceListener(spoon.reflect.reference.CtActualTypeContainer element) {
 			this.element = element;
 		}
 
 		@java.lang.Override
 		public void set(java.util.List replace) {
-			this.element.setAnonymousExecutables(replace);
+			this.element.setActualTypeArguments(replace);
 		}
 	}
 
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtClassConstructorsReplaceListener implements spoon.generating.replace.ReplaceSetListener<java.util.Set> {
-		private final spoon.reflect.declaration.CtClass element;
-
-		CtClassConstructorsReplaceListener(spoon.reflect.declaration.CtClass element) {
-			this.element = element;
-		}
-
-		@java.lang.Override
-		public void set(java.util.Set replace) {
-			this.element.setConstructors(replace);
-		}
+	public <T> void visitCtArrayTypeReference(final spoon.reflect.reference.CtArrayTypeReference<T> reference) {
+		replaceElementIfExist(reference.getDeclaringType(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypeReferenceDeclaringTypeReplaceListener(reference));
+		replaceElementIfExist(reference.getPackage(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypeReferencePackageReplaceListener(reference));
+		replaceElementIfExist(reference.getComponentType(), new spoon.support.visitor.replace.ReplacementVisitor.CtArrayTypeReferenceComponentTypeReplaceListener(reference));
+		replaceInListIfExist(reference.getActualTypeArguments(), new spoon.support.visitor.replace.ReplacementVisitor.CtActualTypeContainerActualTypeArgumentsReplaceListener(reference));
+		replaceInListIfExist(reference.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(reference));
 	}
 
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtClassFieldsReplaceListener implements spoon.generating.replace.ReplaceListListener<java.util.List> {
-		private final spoon.reflect.declaration.CtType element;
+	class CtAssertAssertExpressionReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtExpression> {
+		private final spoon.reflect.code.CtAssert element;
 
-		CtClassFieldsReplaceListener(spoon.reflect.declaration.CtType element) {
+		CtAssertAssertExpressionReplaceListener(spoon.reflect.code.CtAssert element) {
 			this.element = element;
 		}
 
 		@java.lang.Override
-		public void set(java.util.List replace) {
-			this.element.setFields(replace);
+		public void set(spoon.reflect.code.CtExpression replace) {
+			this.element.setAssertExpression(replace);
 		}
 	}
 
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtConditionalConditionReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtExpression> {
-		private final spoon.reflect.code.CtConditional element;
+	class CtAssertExpressionReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtExpression> {
+		private final spoon.reflect.code.CtAssert element;
 
-		CtConditionalConditionReplaceListener(spoon.reflect.code.CtConditional element) {
+		CtAssertExpressionReplaceListener(spoon.reflect.code.CtAssert element) {
 			this.element = element;
 		}
 
 		@java.lang.Override
 		public void set(spoon.reflect.code.CtExpression replace) {
-			this.element.setCondition(replace);
+			this.element.setExpression(replace);
 		}
 	}
 
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtConditionalElseExpressionReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtExpression> {
-		private final spoon.reflect.code.CtConditional element;
+	public <T> void visitCtAssert(final spoon.reflect.code.CtAssert<T> asserted) {
+		replaceInListIfExist(asserted.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(asserted));
+		replaceElementIfExist(asserted.getAssertExpression(), new spoon.support.visitor.replace.ReplacementVisitor.CtAssertAssertExpressionReplaceListener(asserted));
+		replaceElementIfExist(asserted.getExpression(), new spoon.support.visitor.replace.ReplacementVisitor.CtAssertExpressionReplaceListener(asserted));
+		replaceInListIfExist(asserted.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(asserted));
+	}
 
-		CtConditionalElseExpressionReplaceListener(spoon.reflect.code.CtConditional element) {
+	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
+	class CtAssignmentAssignedReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtExpression> {
+		private final spoon.reflect.code.CtAssignment element;
+
+		CtAssignmentAssignedReplaceListener(spoon.reflect.code.CtAssignment element) {
 			this.element = element;
 		}
 
 		@java.lang.Override
 		public void set(spoon.reflect.code.CtExpression replace) {
-			this.element.setElseExpression(replace);
+			this.element.setAssigned(replace);
 		}
 	}
 
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtConditionalThenExpressionReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtExpression> {
-		private final spoon.reflect.code.CtConditional element;
+	class CtRHSReceiverAssignmentReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtExpression> {
+		private final spoon.reflect.code.CtRHSReceiver element;
 
-		CtConditionalThenExpressionReplaceListener(spoon.reflect.code.CtConditional element) {
+		CtRHSReceiverAssignmentReplaceListener(spoon.reflect.code.CtRHSReceiver element) {
 			this.element = element;
 		}
 
 		@java.lang.Override
 		public void set(spoon.reflect.code.CtExpression replace) {
-			this.element.setThenExpression(replace);
+			this.element.setAssignment(replace);
 		}
 	}
 
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtContinueLabelledStatementReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtStatement> {
-		private final spoon.reflect.code.CtContinue element;
-
-		CtContinueLabelledStatementReplaceListener(spoon.reflect.code.CtContinue element) {
-			this.element = element;
-		}
-
-		@java.lang.Override
-		public void set(spoon.reflect.code.CtStatement replace) {
-			this.element.setLabelledStatement(replace);
-		}
+	public <T, A extends T> void visitCtAssignment(final spoon.reflect.code.CtAssignment<T, A> assignement) {
+		replaceInListIfExist(assignement.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(assignement));
+		replaceElementIfExist(assignement.getType(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypedElementTypeReplaceListener(assignement));
+		replaceInListIfExist(assignement.getTypeCasts(), new spoon.support.visitor.replace.ReplacementVisitor.CtExpressionTypeCastsReplaceListener(assignement));
+		replaceElementIfExist(assignement.getAssigned(), new spoon.support.visitor.replace.ReplacementVisitor.CtAssignmentAssignedReplaceListener(assignement));
+		replaceElementIfExist(assignement.getAssignment(), new spoon.support.visitor.replace.ReplacementVisitor.CtRHSReceiverAssignmentReplaceListener(assignement));
+		replaceInListIfExist(assignement.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(assignement));
 	}
 
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtDoLoopingExpressionReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtExpression> {
-		private final spoon.reflect.code.CtDo element;
+	class CtBinaryOperatorLeftHandOperandReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtExpression> {
+		private final spoon.reflect.code.CtBinaryOperator element;
 
-		CtDoLoopingExpressionReplaceListener(spoon.reflect.code.CtDo element) {
+		CtBinaryOperatorLeftHandOperandReplaceListener(spoon.reflect.code.CtBinaryOperator element) {
 			this.element = element;
 		}
 
 		@java.lang.Override
 		public void set(spoon.reflect.code.CtExpression replace) {
-			this.element.setLoopingExpression(replace);
+			this.element.setLeftHandOperand(replace);
 		}
 	}
 
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtElementAnnotationsReplaceListener implements spoon.generating.replace.ReplaceListListener<java.util.List> {
-		private final spoon.reflect.declaration.CtElement element;
+	class CtBinaryOperatorRightHandOperandReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtExpression> {
+		private final spoon.reflect.code.CtBinaryOperator element;
 
-		CtElementAnnotationsReplaceListener(spoon.reflect.declaration.CtElement element) {
+		CtBinaryOperatorRightHandOperandReplaceListener(spoon.reflect.code.CtBinaryOperator element) {
 			this.element = element;
 		}
 
 		@java.lang.Override
-		public void set(java.util.List replace) {
-			this.element.setAnnotations(replace);
+		public void set(spoon.reflect.code.CtExpression replace) {
+			this.element.setRightHandOperand(replace);
 		}
 	}
 
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtElementCommentsReplaceListener implements spoon.generating.replace.ReplaceListListener<java.util.List> {
-		private final spoon.reflect.declaration.CtElement element;
+	public <T> void visitCtBinaryOperator(final spoon.reflect.code.CtBinaryOperator<T> operator) {
+		replaceInListIfExist(operator.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(operator));
+		replaceElementIfExist(operator.getType(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypedElementTypeReplaceListener(operator));
+		replaceInListIfExist(operator.getTypeCasts(), new spoon.support.visitor.replace.ReplacementVisitor.CtExpressionTypeCastsReplaceListener(operator));
+		replaceElementIfExist(operator.getLeftHandOperand(), new spoon.support.visitor.replace.ReplacementVisitor.CtBinaryOperatorLeftHandOperandReplaceListener(operator));
+		replaceElementIfExist(operator.getRightHandOperand(), new spoon.support.visitor.replace.ReplacementVisitor.CtBinaryOperatorRightHandOperandReplaceListener(operator));
+		replaceInListIfExist(operator.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(operator));
+	}
 
-		CtElementCommentsReplaceListener(spoon.reflect.declaration.CtElement element) {
+	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
+	class CtStatementListStatementsReplaceListener implements spoon.generating.replace.ReplaceListListener<java.util.List> {
+		private final spoon.reflect.code.CtStatementList element;
+
+		CtStatementListStatementsReplaceListener(spoon.reflect.code.CtStatementList element) {
 			this.element = element;
 		}
 
 		@java.lang.Override
 		public void set(java.util.List replace) {
-			this.element.setComments(replace);
+			this.element.setStatements(replace);
 		}
 	}
 
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtExecutableBodyReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtBlock> {
-		private final spoon.reflect.declaration.CtExecutable element;
-
-		CtExecutableBodyReplaceListener(spoon.reflect.declaration.CtExecutable element) {
-			this.element = element;
-		}
+	public <R> void visitCtBlock(final spoon.reflect.code.CtBlock<R> block) {
+		replaceInListIfExist(block.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(block));
+		replaceInListIfExist(block.getStatements(), new spoon.support.visitor.replace.ReplacementVisitor.CtStatementListStatementsReplaceListener(block));
+		replaceInListIfExist(block.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(block));
+	}
 
-		@java.lang.Override
-		public void set(spoon.reflect.code.CtBlock replace) {
-			this.element.setBody(replace);
-		}
+	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
+	public void visitCtBreak(final spoon.reflect.code.CtBreak breakStatement) {
+		replaceInListIfExist(breakStatement.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(breakStatement));
+		replaceInListIfExist(breakStatement.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(breakStatement));
 	}
 
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtExecutableParametersReplaceListener implements spoon.generating.replace.ReplaceListListener<java.util.List> {
-		private final spoon.reflect.declaration.CtExecutable element;
+	class CtCaseCaseExpressionReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtExpression> {
+		private final spoon.reflect.code.CtCase element;
 
-		CtExecutableParametersReplaceListener(spoon.reflect.declaration.CtExecutable element) {
+		CtCaseCaseExpressionReplaceListener(spoon.reflect.code.CtCase element) {
 			this.element = element;
 		}
 
 		@java.lang.Override
-		public void set(java.util.List replace) {
-			this.element.setParameters(replace);
+		public void set(spoon.reflect.code.CtExpression replace) {
+			this.element.setCaseExpression(replace);
 		}
 	}
 
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtExecutableReferenceDeclaringTypeReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.reference.CtTypeReference> {
-		private final spoon.reflect.reference.CtExecutableReference element;
-
-		CtExecutableReferenceDeclaringTypeReplaceListener(spoon.reflect.reference.CtExecutableReference element) {
-			this.element = element;
-		}
-
-		@java.lang.Override
-		public void set(spoon.reflect.reference.CtTypeReference replace) {
-			this.element.setDeclaringType(replace);
-		}
+	public <S> void visitCtCase(final spoon.reflect.code.CtCase<S> caseStatement) {
+		replaceInListIfExist(caseStatement.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(caseStatement));
+		replaceElementIfExist(caseStatement.getCaseExpression(), new spoon.support.visitor.replace.ReplacementVisitor.CtCaseCaseExpressionReplaceListener(caseStatement));
+		replaceInListIfExist(caseStatement.getStatements(), new spoon.support.visitor.replace.ReplacementVisitor.CtStatementListStatementsReplaceListener(caseStatement));
+		replaceInListIfExist(caseStatement.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(caseStatement));
 	}
 
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtExecutableReferenceExpressionExecutableReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.reference.CtExecutableReference> {
-		private final spoon.reflect.code.CtExecutableReferenceExpression element;
+	class CtCatchParameterReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtCatchVariable> {
+		private final spoon.reflect.code.CtCatch element;
 
-		CtExecutableReferenceExpressionExecutableReplaceListener(spoon.reflect.code.CtExecutableReferenceExpression element) {
+		CtCatchParameterReplaceListener(spoon.reflect.code.CtCatch element) {
 			this.element = element;
 		}
 
 		@java.lang.Override
-		public void set(spoon.reflect.reference.CtExecutableReference replace) {
-			this.element.setExecutable(replace);
+		public void set(spoon.reflect.code.CtCatchVariable replace) {
+			this.element.setParameter(replace);
 		}
 	}
 
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtExecutableReferenceParametersReplaceListener implements spoon.generating.replace.ReplaceListListener<java.util.List> {
-		private final spoon.reflect.reference.CtExecutableReference element;
+	class CtCatchBodyReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtBlock> {
+		private final spoon.reflect.code.CtCatch element;
 
-		CtExecutableReferenceParametersReplaceListener(spoon.reflect.reference.CtExecutableReference element) {
+		CtCatchBodyReplaceListener(spoon.reflect.code.CtCatch element) {
 			this.element = element;
 		}
 
 		@java.lang.Override
-		public void set(java.util.List replace) {
-			this.element.setParameters(replace);
+		public void set(spoon.reflect.code.CtBlock replace) {
+			this.element.setBody(replace);
 		}
 	}
 
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtExecutableReferenceTypeReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.reference.CtTypeReference> {
-		private final spoon.reflect.reference.CtExecutableReference element;
+	public void visitCtCatch(final spoon.reflect.code.CtCatch catchBlock) {
+		replaceInListIfExist(catchBlock.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(catchBlock));
+		replaceElementIfExist(catchBlock.getParameter(), new spoon.support.visitor.replace.ReplacementVisitor.CtCatchParameterReplaceListener(catchBlock));
+		replaceElementIfExist(catchBlock.getBody(), new spoon.support.visitor.replace.ReplacementVisitor.CtCatchBodyReplaceListener(catchBlock));
+		replaceInListIfExist(catchBlock.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(catchBlock));
+	}
 
-		CtExecutableReferenceTypeReplaceListener(spoon.reflect.reference.CtExecutableReference element) {
+	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
+	class CtTypeInformationSuperclassReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.reference.CtTypeReference> {
+		private final spoon.reflect.declaration.CtType element;
+
+		CtTypeInformationSuperclassReplaceListener(spoon.reflect.declaration.CtType element) {
 			this.element = element;
 		}
 
 		@java.lang.Override
 		public void set(spoon.reflect.reference.CtTypeReference replace) {
-			this.element.setType(replace);
+			this.element.setSuperclass(replace);
 		}
 	}
 
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtExecutableThrownTypesReplaceListener implements spoon.generating.replace.ReplaceSetListener<java.util.Set> {
-		private final spoon.reflect.declaration.CtExecutable element;
+	class CtTypeInformationSuperInterfacesReplaceListener implements spoon.generating.replace.ReplaceSetListener<java.util.Set> {
+		private final spoon.reflect.declaration.CtType element;
 
-		CtExecutableThrownTypesReplaceListener(spoon.reflect.declaration.CtExecutable element) {
+		CtTypeInformationSuperInterfacesReplaceListener(spoon.reflect.declaration.CtType element) {
 			this.element = element;
 		}
 
 		@java.lang.Override
 		public void set(java.util.Set replace) {
-			this.element.setThrownTypes(replace);
+			this.element.setSuperInterfaces(replace);
 		}
 	}
 
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtExpressionTypeCastsReplaceListener implements spoon.generating.replace.ReplaceListListener<java.util.List> {
-		private final spoon.reflect.code.CtExpression element;
+	class CtFormalTypeDeclarerFormalCtTypeParametersReplaceListener implements spoon.generating.replace.ReplaceListListener<java.util.List> {
+		private final spoon.reflect.declaration.CtFormalTypeDeclarer element;
 
-		CtExpressionTypeCastsReplaceListener(spoon.reflect.code.CtExpression element) {
+		CtFormalTypeDeclarerFormalCtTypeParametersReplaceListener(spoon.reflect.declaration.CtFormalTypeDeclarer element) {
 			this.element = element;
 		}
 
 		@java.lang.Override
 		public void set(java.util.List replace) {
-			this.element.setTypeCasts(replace);
+			this.element.setFormalCtTypeParameters(replace);
 		}
 	}
 
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtFieldAccessVariableReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.reference.CtFieldReference> {
-		private final spoon.reflect.code.CtVariableAccess element;
+	public <T> void visitCtClass(final spoon.reflect.declaration.CtClass<T> ctClass) {
+		replaceInListIfExist(ctClass.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(ctClass));
+		replaceElementIfExist(ctClass.getSuperclass(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypeInformationSuperclassReplaceListener(ctClass));
+		replaceInSetIfExist(ctClass.getSuperInterfaces(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypeInformationSuperInterfacesReplaceListener(ctClass));
+		replaceInListIfExist(ctClass.getFormalCtTypeParameters(), new spoon.support.visitor.replace.ReplacementVisitor.CtFormalTypeDeclarerFormalCtTypeParametersReplaceListener(ctClass));
+		replaceInListIfExist(ctClass.getTypeMembers(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypeTypeMembersReplaceListener(ctClass));
+		replaceInListIfExist(ctClass.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(ctClass));
+	}
 
-		CtFieldAccessVariableReplaceListener(spoon.reflect.code.CtVariableAccess element) {
+	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
+	@java.lang.Override
+	public void visitCtTypeParameter(spoon.reflect.declaration.CtTypeParameter typeParameter) {
+		replaceInListIfExist(typeParameter.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(typeParameter));
+		replaceElementIfExist(typeParameter.getSuperclass(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypeInformationSuperclassReplaceListener(typeParameter));
+		replaceInListIfExist(typeParameter.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(typeParameter));
+	}
+
+	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
+	class CtConditionalConditionReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtExpression> {
+		private final spoon.reflect.code.CtConditional element;
+
+		CtConditionalConditionReplaceListener(spoon.reflect.code.CtConditional element) {
 			this.element = element;
 		}
 
 		@java.lang.Override
-		public void set(spoon.reflect.reference.CtFieldReference replace) {
-			this.element.setVariable(replace);
+		public void set(spoon.reflect.code.CtExpression replace) {
+			this.element.setCondition(replace);
 		}
 	}
 
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtFieldReferenceDeclaringTypeReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.reference.CtTypeReference> {
-		private final spoon.reflect.reference.CtFieldReference element;
+	class CtConditionalThenExpressionReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtExpression> {
+		private final spoon.reflect.code.CtConditional element;
 
-		CtFieldReferenceDeclaringTypeReplaceListener(spoon.reflect.reference.CtFieldReference element) {
+		CtConditionalThenExpressionReplaceListener(spoon.reflect.code.CtConditional element) {
 			this.element = element;
 		}
 
 		@java.lang.Override
-		public void set(spoon.reflect.reference.CtTypeReference replace) {
-			this.element.setDeclaringType(replace);
+		public void set(spoon.reflect.code.CtExpression replace) {
+			this.element.setThenExpression(replace);
 		}
 	}
 
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtForEachExpressionReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtExpression> {
-		private final spoon.reflect.code.CtForEach element;
+	class CtConditionalElseExpressionReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtExpression> {
+		private final spoon.reflect.code.CtConditional element;
 
-		CtForEachExpressionReplaceListener(spoon.reflect.code.CtForEach element) {
+		CtConditionalElseExpressionReplaceListener(spoon.reflect.code.CtConditional element) {
 			this.element = element;
 		}
 
 		@java.lang.Override
 		public void set(spoon.reflect.code.CtExpression replace) {
-			this.element.setExpression(replace);
+			this.element.setElseExpression(replace);
 		}
 	}
 
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtForEachVariableReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtLocalVariable> {
-		private final spoon.reflect.code.CtForEach element;
-
-		CtForEachVariableReplaceListener(spoon.reflect.code.CtForEach element) {
-			this.element = element;
-		}
-
-		@java.lang.Override
-		public void set(spoon.reflect.code.CtLocalVariable replace) {
-			this.element.setVariable(replace);
-		}
+	public <T> void visitCtConditional(final spoon.reflect.code.CtConditional<T> conditional) {
+		replaceInListIfExist(conditional.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(conditional));
+		replaceElementIfExist(conditional.getCondition(), new spoon.support.visitor.replace.ReplacementVisitor.CtConditionalConditionReplaceListener(conditional));
+		replaceElementIfExist(conditional.getThenExpression(), new spoon.support.visitor.replace.ReplacementVisitor.CtConditionalThenExpressionReplaceListener(conditional));
+		replaceElementIfExist(conditional.getElseExpression(), new spoon.support.visitor.replace.ReplacementVisitor.CtConditionalElseExpressionReplaceListener(conditional));
+		replaceInListIfExist(conditional.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(conditional));
+		replaceInListIfExist(conditional.getTypeCasts(), new spoon.support.visitor.replace.ReplacementVisitor.CtExpressionTypeCastsReplaceListener(conditional));
 	}
 
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtForExpressionReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtExpression> {
-		private final spoon.reflect.code.CtFor element;
+	class CtExecutableParametersReplaceListener implements spoon.generating.replace.ReplaceListListener<java.util.List> {
+		private final spoon.reflect.declaration.CtExecutable element;
 
-		CtForExpressionReplaceListener(spoon.reflect.code.CtFor element) {
+		CtExecutableParametersReplaceListener(spoon.reflect.declaration.CtExecutable element) {
 			this.element = element;
 		}
 
 		@java.lang.Override
-		public void set(spoon.reflect.code.CtExpression replace) {
-			this.element.setExpression(replace);
+		public void set(java.util.List replace) {
+			this.element.setParameters(replace);
 		}
 	}
 
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtForForInitReplaceListener implements spoon.generating.replace.ReplaceListListener<java.util.List> {
-		private final spoon.reflect.code.CtFor element;
+	class CtExecutableThrownTypesReplaceListener implements spoon.generating.replace.ReplaceSetListener<java.util.Set> {
+		private final spoon.reflect.declaration.CtExecutable element;
 
-		CtForForInitReplaceListener(spoon.reflect.code.CtFor element) {
+		CtExecutableThrownTypesReplaceListener(spoon.reflect.declaration.CtExecutable element) {
 			this.element = element;
 		}
 
 		@java.lang.Override
-		public void set(java.util.List replace) {
-			this.element.setForInit(replace);
+		public void set(java.util.Set replace) {
+			this.element.setThrownTypes(replace);
 		}
 	}
 
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtForForUpdateReplaceListener implements spoon.generating.replace.ReplaceListListener<java.util.List> {
-		private final spoon.reflect.code.CtFor element;
-
-		CtForForUpdateReplaceListener(spoon.reflect.code.CtFor element) {
-			this.element = element;
-		}
-
-		@java.lang.Override
-		public void set(java.util.List replace) {
-			this.element.setForUpdate(replace);
-		}
+	public <T> void visitCtConstructor(final spoon.reflect.declaration.CtConstructor<T> c) {
+		replaceInListIfExist(c.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(c));
+		replaceInListIfExist(c.getParameters(), new spoon.support.visitor.replace.ReplacementVisitor.CtExecutableParametersReplaceListener(c));
+		replaceInSetIfExist(c.getThrownTypes(), new spoon.support.visitor.replace.ReplacementVisitor.CtExecutableThrownTypesReplaceListener(c));
+		replaceInListIfExist(c.getFormalCtTypeParameters(), new spoon.support.visitor.replace.ReplacementVisitor.CtFormalTypeDeclarerFormalCtTypeParametersReplaceListener(c));
+		replaceElementIfExist(c.getBody(), new spoon.support.visitor.replace.ReplacementVisitor.CtExecutableBodyReplaceListener(c));
+		replaceInListIfExist(c.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(c));
 	}
 
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtFormalTypeDeclarerFormalCtTypeParametersReplaceListener implements spoon.generating.replace.ReplaceListListener<java.util.List> {
-		private final spoon.reflect.declaration.CtFormalTypeDeclarer element;
+	class CtContinueLabelledStatementReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtStatement> {
+		private final spoon.reflect.code.CtContinue element;
 
-		CtFormalTypeDeclarerFormalCtTypeParametersReplaceListener(spoon.reflect.declaration.CtFormalTypeDeclarer element) {
+		CtContinueLabelledStatementReplaceListener(spoon.reflect.code.CtContinue element) {
 			this.element = element;
 		}
 
 		@java.lang.Override
-		public void set(java.util.List replace) {
-			this.element.setFormalCtTypeParameters(replace);
+		public void set(spoon.reflect.code.CtStatement replace) {
+			this.element.setLabelledStatement(replace);
 		}
 	}
 
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtIfConditionReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtExpression> {
-		private final spoon.reflect.code.CtIf element;
+	public void visitCtContinue(final spoon.reflect.code.CtContinue continueStatement) {
+		replaceInListIfExist(continueStatement.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(continueStatement));
+		replaceElementIfExist(continueStatement.getLabelledStatement(), new spoon.support.visitor.replace.ReplacementVisitor.CtContinueLabelledStatementReplaceListener(continueStatement));
+		replaceInListIfExist(continueStatement.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(continueStatement));
+	}
 
-		CtIfConditionReplaceListener(spoon.reflect.code.CtIf element) {
+	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
+	class CtDoLoopingExpressionReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtExpression> {
+		private final spoon.reflect.code.CtDo element;
+
+		CtDoLoopingExpressionReplaceListener(spoon.reflect.code.CtDo element) {
 			this.element = element;
 		}
 
 		@java.lang.Override
 		public void set(spoon.reflect.code.CtExpression replace) {
-			this.element.setCondition(replace);
+			this.element.setLoopingExpression(replace);
 		}
 	}
 
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtIfElseStatementReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtStatement> {
-		private final spoon.reflect.code.CtIf element;
+	class CtLoopBodyReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtStatement> {
+		private final spoon.reflect.code.CtLoop element;
 
-		CtIfElseStatementReplaceListener(spoon.reflect.code.CtIf element) {
+		CtLoopBodyReplaceListener(spoon.reflect.code.CtLoop element) {
 			this.element = element;
 		}
 
 		@java.lang.Override
 		public void set(spoon.reflect.code.CtStatement replace) {
-			this.element.setElseStatement(replace);
+			this.element.setBody(replace);
 		}
 	}
 
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtIfThenStatementReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtStatement> {
-		private final spoon.reflect.code.CtIf element;
-
-		CtIfThenStatementReplaceListener(spoon.reflect.code.CtIf element) {
-			this.element = element;
-		}
-
-		@java.lang.Override
-		public void set(spoon.reflect.code.CtStatement replace) {
-			this.element.setThenStatement(replace);
-		}
+	public void visitCtDo(final spoon.reflect.code.CtDo doLoop) {
+		replaceInListIfExist(doLoop.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(doLoop));
+		replaceElementIfExist(doLoop.getLoopingExpression(), new spoon.support.visitor.replace.ReplacementVisitor.CtDoLoopingExpressionReplaceListener(doLoop));
+		replaceElementIfExist(doLoop.getBody(), new spoon.support.visitor.replace.ReplacementVisitor.CtLoopBodyReplaceListener(doLoop));
+		replaceInListIfExist(doLoop.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(doLoop));
 	}
 
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtIntersectionTypeReferenceBoundsReplaceListener implements spoon.generating.replace.ReplaceSetListener<java.util.Set> {
-		private final spoon.reflect.reference.CtIntersectionTypeReference element;
+	class CtEnumEnumValuesReplaceListener implements spoon.generating.replace.ReplaceListListener<java.util.List> {
+		private final spoon.reflect.declaration.CtEnum element;
 
-		CtIntersectionTypeReferenceBoundsReplaceListener(spoon.reflect.reference.CtIntersectionTypeReference element) {
+		CtEnumEnumValuesReplaceListener(spoon.reflect.declaration.CtEnum element) {
 			this.element = element;
 		}
 
 		@java.lang.Override
-		public void set(java.util.Set replace) {
-			this.element.setBounds(replace);
+		public void set(java.util.List replace) {
+			this.element.setEnumValues(replace);
 		}
 	}
 
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtLambdaExpressionReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtExpression> {
-		private final spoon.reflect.code.CtLambda element;
-
-		CtLambdaExpressionReplaceListener(spoon.reflect.code.CtLambda element) {
-			this.element = element;
-		}
-
-		@java.lang.Override
-		public void set(spoon.reflect.code.CtExpression replace) {
-			this.element.setExpression(replace);
-		}
+	public <T extends java.lang.Enum<?>> void visitCtEnum(final spoon.reflect.declaration.CtEnum<T> ctEnum) {
+		replaceInListIfExist(ctEnum.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(ctEnum));
+		replaceInSetIfExist(ctEnum.getSuperInterfaces(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypeInformationSuperInterfacesReplaceListener(ctEnum));
+		replaceInListIfExist(ctEnum.getTypeMembers(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypeTypeMembersReplaceListener(ctEnum));
+		replaceInListIfExist(ctEnum.getEnumValues(), new spoon.support.visitor.replace.ReplacementVisitor.CtEnumEnumValuesReplaceListener(ctEnum));
+		replaceInListIfExist(ctEnum.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(ctEnum));
 	}
 
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtLoopBodyReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtStatement> {
-		private final spoon.reflect.code.CtLoop element;
+	class CtExecutableReferenceDeclaringTypeReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.reference.CtTypeReference> {
+		private final spoon.reflect.reference.CtExecutableReference element;
 
-		CtLoopBodyReplaceListener(spoon.reflect.code.CtLoop element) {
+		CtExecutableReferenceDeclaringTypeReplaceListener(spoon.reflect.reference.CtExecutableReference element) {
 			this.element = element;
 		}
 
 		@java.lang.Override
-		public void set(spoon.reflect.code.CtStatement replace) {
-			this.element.setBody(replace);
+		public void set(spoon.reflect.reference.CtTypeReference replace) {
+			this.element.setDeclaringType(replace);
 		}
 	}
 
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtNewArrayDimensionExpressionsReplaceListener implements spoon.generating.replace.ReplaceListListener<java.util.List> {
-		private final spoon.reflect.code.CtNewArray element;
+	class CtExecutableReferenceTypeReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.reference.CtTypeReference> {
+		private final spoon.reflect.reference.CtExecutableReference element;
 
-		CtNewArrayDimensionExpressionsReplaceListener(spoon.reflect.code.CtNewArray element) {
+		CtExecutableReferenceTypeReplaceListener(spoon.reflect.reference.CtExecutableReference element) {
 			this.element = element;
 		}
 
 		@java.lang.Override
-		public void set(java.util.List replace) {
-			this.element.setDimensionExpressions(replace);
+		public void set(spoon.reflect.reference.CtTypeReference replace) {
+			this.element.setType(replace);
 		}
 	}
 
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtNewArrayElementsReplaceListener implements spoon.generating.replace.ReplaceListListener<java.util.List> {
-		private final spoon.reflect.code.CtNewArray element;
+	class CtExecutableReferenceParametersReplaceListener implements spoon.generating.replace.ReplaceListListener<java.util.List> {
+		private final spoon.reflect.reference.CtExecutableReference element;
 
-		CtNewArrayElementsReplaceListener(spoon.reflect.code.CtNewArray element) {
+		CtExecutableReferenceParametersReplaceListener(spoon.reflect.reference.CtExecutableReference element) {
 			this.element = element;
 		}
 
 		@java.lang.Override
 		public void set(java.util.List replace) {
-			this.element.setElements(replace);
+			this.element.setParameters(replace);
 		}
 	}
 
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtNewClassAnonymousClassReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.declaration.CtClass> {
-		private final spoon.reflect.code.CtNewClass element;
-
-		CtNewClassAnonymousClassReplaceListener(spoon.reflect.code.CtNewClass element) {
-			this.element = element;
-		}
-
-		@java.lang.Override
-		public void set(spoon.reflect.declaration.CtClass replace) {
-			this.element.setAnonymousClass(replace);
-		}
+	public <T> void visitCtExecutableReference(final spoon.reflect.reference.CtExecutableReference<T> reference) {
+		replaceElementIfExist(reference.getDeclaringType(), new spoon.support.visitor.replace.ReplacementVisitor.CtExecutableReferenceDeclaringTypeReplaceListener(reference));
+		replaceElementIfExist(reference.getType(), new spoon.support.visitor.replace.ReplacementVisitor.CtExecutableReferenceTypeReplaceListener(reference));
+		replaceInListIfExist(reference.getParameters(), new spoon.support.visitor.replace.ReplacementVisitor.CtExecutableReferenceParametersReplaceListener(reference));
+		replaceInListIfExist(reference.getActualTypeArguments(), new spoon.support.visitor.replace.ReplacementVisitor.CtActualTypeContainerActualTypeArgumentsReplaceListener(reference));
+		replaceInListIfExist(reference.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(reference));
+		replaceInListIfExist(reference.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(reference));
 	}
 
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtPackagePackagesReplaceListener implements spoon.generating.replace.ReplaceSetListener<java.util.Set> {
-		private final spoon.reflect.declaration.CtPackage element;
+	class CtVariableDefaultExpressionReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtExpression> {
+		private final spoon.reflect.declaration.CtVariable element;
 
-		CtPackagePackagesReplaceListener(spoon.reflect.declaration.CtPackage element) {
+		CtVariableDefaultExpressionReplaceListener(spoon.reflect.declaration.CtVariable element) {
 			this.element = element;
 		}
 
 		@java.lang.Override
-		public void set(java.util.Set replace) {
-			this.element.setPackages(replace);
+		public void set(spoon.reflect.code.CtExpression replace) {
+			this.element.setDefaultExpression(replace);
 		}
 	}
 
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtPackageTypesReplaceListener implements spoon.generating.replace.ReplaceSetListener<java.util.Set> {
-		private final spoon.reflect.declaration.CtPackage element;
+	public <T> void visitCtField(final spoon.reflect.declaration.CtField<T> f) {
+		replaceInListIfExist(f.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(f));
+		replaceElementIfExist(f.getType(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypedElementTypeReplaceListener(f));
+		replaceElementIfExist(f.getDefaultExpression(), new spoon.support.visitor.replace.ReplacementVisitor.CtVariableDefaultExpressionReplaceListener(f));
+		replaceInListIfExist(f.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(f));
+	}
 
-		CtPackageTypesReplaceListener(spoon.reflect.declaration.CtPackage element) {
-			this.element = element;
-		}
+	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
+	@java.lang.Override
+	public <T> void visitCtEnumValue(final spoon.reflect.declaration.CtEnumValue<T> enumValue) {
+		replaceInListIfExist(enumValue.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(enumValue));
+		replaceElementIfExist(enumValue.getType(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypedElementTypeReplaceListener(enumValue));
+		replaceElementIfExist(enumValue.getDefaultExpression(), new spoon.support.visitor.replace.ReplacementVisitor.CtVariableDefaultExpressionReplaceListener(enumValue));
+		replaceInListIfExist(enumValue.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(enumValue));
+	}
 
-		@java.lang.Override
-		public void set(java.util.Set replace) {
-			this.element.setTypes(replace);
-		}
+	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
+	@java.lang.Override
+	public <T> void visitCtThisAccess(final spoon.reflect.code.CtThisAccess<T> thisAccess) {
+		replaceElementIfExist(thisAccess.getType(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypedElementTypeReplaceListener(thisAccess));
+		replaceInListIfExist(thisAccess.getTypeCasts(), new spoon.support.visitor.replace.ReplacementVisitor.CtExpressionTypeCastsReplaceListener(thisAccess));
+		replaceElementIfExist(thisAccess.getTarget(), new spoon.support.visitor.replace.ReplacementVisitor.CtTargetedExpressionTargetReplaceListener(thisAccess));
+		replaceInListIfExist(thisAccess.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(thisAccess));
 	}
 
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtParameterReferenceDeclaringExecutableReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.reference.CtExecutableReference> {
-		private final spoon.reflect.reference.CtParameterReference element;
+	class CtAnnotationFieldAccessVariableReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.reference.CtFieldReference> {
+		private final spoon.reflect.code.CtVariableAccess element;
 
-		CtParameterReferenceDeclaringExecutableReplaceListener(spoon.reflect.reference.CtParameterReference element) {
+		CtAnnotationFieldAccessVariableReplaceListener(spoon.reflect.code.CtVariableAccess element) {
 			this.element = element;
 		}
 
 		@java.lang.Override
-		public void set(spoon.reflect.reference.CtExecutableReference replace) {
-			this.element.setDeclaringExecutable(replace);
+		public void set(spoon.reflect.reference.CtFieldReference replace) {
+			this.element.setVariable(replace);
 		}
 	}
 
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtRHSReceiverAssignmentReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtExpression> {
-		private final spoon.reflect.code.CtRHSReceiver element;
+	public <T> void visitCtAnnotationFieldAccess(final spoon.reflect.code.CtAnnotationFieldAccess<T> annotationFieldAccess) {
+		replaceInListIfExist(annotationFieldAccess.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(annotationFieldAccess));
+		replaceElementIfExist(annotationFieldAccess.getType(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypedElementTypeReplaceListener(annotationFieldAccess));
+		replaceInListIfExist(annotationFieldAccess.getTypeCasts(), new spoon.support.visitor.replace.ReplacementVisitor.CtExpressionTypeCastsReplaceListener(annotationFieldAccess));
+		replaceElementIfExist(annotationFieldAccess.getTarget(), new spoon.support.visitor.replace.ReplacementVisitor.CtTargetedExpressionTargetReplaceListener(annotationFieldAccess));
+		replaceElementIfExist(annotationFieldAccess.getVariable(), new spoon.support.visitor.replace.ReplacementVisitor.CtAnnotationFieldAccessVariableReplaceListener(annotationFieldAccess));
+		replaceInListIfExist(annotationFieldAccess.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(annotationFieldAccess));
+	}
 
-		CtRHSReceiverAssignmentReplaceListener(spoon.reflect.code.CtRHSReceiver element) {
+	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
+	class CtFieldReferenceDeclaringTypeReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.reference.CtTypeReference> {
+		private final spoon.reflect.reference.CtFieldReference element;
+
+		CtFieldReferenceDeclaringTypeReplaceListener(spoon.reflect.reference.CtFieldReference element) {
 			this.element = element;
 		}
 
 		@java.lang.Override
-		public void set(spoon.reflect.code.CtExpression replace) {
-			this.element.setAssignment(replace);
+		public void set(spoon.reflect.reference.CtTypeReference replace) {
+			this.element.setDeclaringType(replace);
 		}
 	}
 
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtReturnReturnedExpressionReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtExpression> {
-		private final spoon.reflect.code.CtReturn element;
+	class CtVariableReferenceTypeReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.reference.CtTypeReference> {
+		private final spoon.reflect.reference.CtVariableReference element;
 
-		CtReturnReturnedExpressionReplaceListener(spoon.reflect.code.CtReturn element) {
+		CtVariableReferenceTypeReplaceListener(spoon.reflect.reference.CtVariableReference element) {
 			this.element = element;
 		}
 
 		@java.lang.Override
-		public void set(spoon.reflect.code.CtExpression replace) {
-			this.element.setReturnedExpression(replace);
+		public void set(spoon.reflect.reference.CtTypeReference replace) {
+			this.element.setType(replace);
 		}
 	}
 
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtStatementListStatementsReplaceListener implements spoon.generating.replace.ReplaceListListener<java.util.List> {
-		private final spoon.reflect.code.CtStatementList element;
-
-		CtStatementListStatementsReplaceListener(spoon.reflect.code.CtStatementList element) {
-			this.element = element;
-		}
-
-		@java.lang.Override
-		public void set(java.util.List replace) {
-			this.element.setStatements(replace);
-		}
-	}
-
-	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtSwitchCasesReplaceListener implements spoon.generating.replace.ReplaceListListener<java.util.List> {
-		private final spoon.reflect.code.CtSwitch element;
-
-		CtSwitchCasesReplaceListener(spoon.reflect.code.CtSwitch element) {
-			this.element = element;
-		}
-
-		@java.lang.Override
-		public void set(java.util.List replace) {
-			this.element.setCases(replace);
-		}
-	}
-
-	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtSwitchSelectorReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtExpression> {
-		private final spoon.reflect.code.CtSwitch element;
-
-		CtSwitchSelectorReplaceListener(spoon.reflect.code.CtSwitch element) {
-			this.element = element;
-		}
-
-		@java.lang.Override
-		public void set(spoon.reflect.code.CtExpression replace) {
-			this.element.setSelector(replace);
-		}
-	}
-
-	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtSynchronizedBlockReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtBlock> {
-		private final spoon.reflect.code.CtSynchronized element;
-
-		CtSynchronizedBlockReplaceListener(spoon.reflect.code.CtSynchronized element) {
-			this.element = element;
-		}
-
-		@java.lang.Override
-		public void set(spoon.reflect.code.CtBlock replace) {
-			this.element.setBlock(replace);
-		}
-	}
-
-	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtSynchronizedExpressionReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtExpression> {
-		private final spoon.reflect.code.CtSynchronized element;
-
-		CtSynchronizedExpressionReplaceListener(spoon.reflect.code.CtSynchronized element) {
-			this.element = element;
-		}
-
-		@java.lang.Override
-		public void set(spoon.reflect.code.CtExpression replace) {
-			this.element.setExpression(replace);
-		}
-	}
-
-	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtTargetedExpressionTargetReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtExpression> {
-		private final spoon.reflect.code.CtTargetedExpression element;
-
-		CtTargetedExpressionTargetReplaceListener(spoon.reflect.code.CtTargetedExpression element) {
-			this.element = element;
-		}
-
-		@java.lang.Override
-		public void set(spoon.reflect.code.CtExpression replace) {
-			this.element.setTarget(replace);
-		}
-	}
-
-	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtThrowThrownExpressionReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtExpression> {
-		private final spoon.reflect.code.CtThrow element;
-
-		CtThrowThrownExpressionReplaceListener(spoon.reflect.code.CtThrow element) {
-			this.element = element;
-		}
-
-		@java.lang.Override
-		public void set(spoon.reflect.code.CtExpression replace) {
-			this.element.setThrownExpression(replace);
-		}
-	}
-
-	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtTryBodyReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtBlock> {
-		private final spoon.reflect.code.CtTry element;
-
-		CtTryBodyReplaceListener(spoon.reflect.code.CtTry element) {
-			this.element = element;
-		}
-
-		@java.lang.Override
-		public void set(spoon.reflect.code.CtBlock replace) {
-			this.element.setBody(replace);
-		}
-	}
-
-	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtTryCatchersReplaceListener implements spoon.generating.replace.ReplaceListListener<java.util.List> {
-		private final spoon.reflect.code.CtTry element;
-
-		CtTryCatchersReplaceListener(spoon.reflect.code.CtTry element) {
-			this.element = element;
-		}
-
-		@java.lang.Override
-		public void set(java.util.List replace) {
-			this.element.setCatchers(replace);
-		}
-	}
-
-	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtTryFinalizerReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtBlock> {
-		private final spoon.reflect.code.CtTry element;
-
-		CtTryFinalizerReplaceListener(spoon.reflect.code.CtTry element) {
-			this.element = element;
-		}
-
-		@java.lang.Override
-		public void set(spoon.reflect.code.CtBlock replace) {
-			this.element.setFinalizer(replace);
-		}
-	}
-
-	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtTryWithResourceResourcesReplaceListener implements spoon.generating.replace.ReplaceListListener<java.util.List> {
-		private final spoon.reflect.code.CtTryWithResource element;
-
-		CtTryWithResourceResourcesReplaceListener(spoon.reflect.code.CtTryWithResource element) {
-			this.element = element;
-		}
-
-		@java.lang.Override
-		public void set(java.util.List replace) {
-			this.element.setResources(replace);
-		}
-	}
-
-	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtTypeAccessAccessedTypeReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.reference.CtTypeReference> {
-		private final spoon.reflect.code.CtTypeAccess element;
-
-		CtTypeAccessAccessedTypeReplaceListener(spoon.reflect.code.CtTypeAccess element) {
-			this.element = element;
-		}
-
-		@java.lang.Override
-		public void set(spoon.reflect.reference.CtTypeReference replace) {
-			this.element.setAccessedType(replace);
-		}
-	}
-
-	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtTypeFieldsReplaceListener implements spoon.generating.replace.ReplaceListListener<java.util.List> {
-		private final spoon.reflect.declaration.CtType element;
-
-		CtTypeFieldsReplaceListener(spoon.reflect.declaration.CtType element) {
-			this.element = element;
-		}
-
-		@java.lang.Override
-		public void set(java.util.List replace) {
-			this.element.setFields(replace);
-		}
-	}
-
-	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtTypeInformationSuperInterfacesReplaceListener implements spoon.generating.replace.ReplaceSetListener<java.util.Set> {
-		private final spoon.reflect.declaration.CtType element;
-
-		CtTypeInformationSuperInterfacesReplaceListener(spoon.reflect.declaration.CtType element) {
-			this.element = element;
-		}
-
-		@java.lang.Override
-		public void set(java.util.Set replace) {
-			this.element.setSuperInterfaces(replace);
-		}
-	}
-
-	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtTypeInformationSuperclassReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.reference.CtTypeReference> {
-		private final spoon.reflect.declaration.CtType element;
-
-		CtTypeInformationSuperclassReplaceListener(spoon.reflect.declaration.CtType element) {
-			this.element = element;
-		}
-
-		@java.lang.Override
-		public void set(spoon.reflect.reference.CtTypeReference replace) {
-			this.element.setSuperclass(replace);
-		}
-	}
-
-	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtTypeMethodsReplaceListener implements spoon.generating.replace.ReplaceSetListener<java.util.Set> {
-		private final spoon.reflect.declaration.CtType element;
-
-		CtTypeMethodsReplaceListener(spoon.reflect.declaration.CtType element) {
-			this.element = element;
-		}
-
-		@java.lang.Override
-		public void set(java.util.Set replace) {
-			this.element.setMethods(replace);
-		}
-	}
-
-	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtTypeNestedTypesReplaceListener implements spoon.generating.replace.ReplaceSetListener<java.util.Set> {
-		private final spoon.reflect.declaration.CtType element;
-
-		CtTypeNestedTypesReplaceListener(spoon.reflect.declaration.CtType element) {
-			this.element = element;
-		}
-
-		@java.lang.Override
-		public void set(java.util.Set replace) {
-			this.element.setNestedTypes(replace);
-		}
-	}
-
-	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtTypeParameterReferenceBoundingTypeReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.reference.CtTypeReference> {
-		private final spoon.reflect.reference.CtTypeParameterReference element;
-
-		CtTypeParameterReferenceBoundingTypeReplaceListener(spoon.reflect.reference.CtTypeParameterReference element) {
-			this.element = element;
-		}
-
-		@java.lang.Override
-		public void set(spoon.reflect.reference.CtTypeReference replace) {
-			this.element.setBoundingType(replace);
-		}
-	}
-
-	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtTypeReferenceDeclaringTypeReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.reference.CtTypeReference> {
-		private final spoon.reflect.reference.CtTypeReference element;
-
-		CtTypeReferenceDeclaringTypeReplaceListener(spoon.reflect.reference.CtTypeReference element) {
-			this.element = element;
-		}
-
-		@java.lang.Override
-		public void set(spoon.reflect.reference.CtTypeReference replace) {
-			this.element.setDeclaringType(replace);
-		}
-	}
-
-	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtTypeReferencePackageReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.reference.CtPackageReference> {
-		private final spoon.reflect.reference.CtTypeReference element;
-
-		CtTypeReferencePackageReplaceListener(spoon.reflect.reference.CtTypeReference element) {
-			this.element = element;
-		}
-
-		@java.lang.Override
-		public void set(spoon.reflect.reference.CtPackageReference replace) {
-			this.element.setPackage(replace);
-		}
-	}
-
-	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtTypedElementTypeReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.reference.CtTypeReference> {
-		private final spoon.reflect.declaration.CtTypedElement element;
-
-		CtTypedElementTypeReplaceListener(spoon.reflect.declaration.CtTypedElement element) {
-			this.element = element;
-		}
-
-		@java.lang.Override
-		public void set(spoon.reflect.reference.CtTypeReference replace) {
-			this.element.setType(replace);
-		}
-	}
-
-	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtUnaryOperatorOperandReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtExpression> {
-		private final spoon.reflect.code.CtUnaryOperator element;
-
-		CtUnaryOperatorOperandReplaceListener(spoon.reflect.code.CtUnaryOperator element) {
-			this.element = element;
-		}
-
-		@java.lang.Override
-		public void set(spoon.reflect.code.CtExpression replace) {
-			this.element.setOperand(replace);
-		}
-	}
-
-	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtVariableAccessVariableReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.reference.CtVariableReference> {
-		private final spoon.reflect.code.CtVariableAccess element;
-
-		CtVariableAccessVariableReplaceListener(spoon.reflect.code.CtVariableAccess element) {
-			this.element = element;
-		}
-
-		@java.lang.Override
-		public void set(spoon.reflect.reference.CtVariableReference replace) {
-			this.element.setVariable(replace);
-		}
-	}
-
-	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtVariableDefaultExpressionReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtExpression> {
-		private final spoon.reflect.declaration.CtVariable element;
-
-		CtVariableDefaultExpressionReplaceListener(spoon.reflect.declaration.CtVariable element) {
-			this.element = element;
-		}
-
-		@java.lang.Override
-		public void set(spoon.reflect.code.CtExpression replace) {
-			this.element.setDefaultExpression(replace);
-		}
-	}
-
-	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtVariableReferenceTypeReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.reference.CtTypeReference> {
-		private final spoon.reflect.reference.CtVariableReference element;
-
-		CtVariableReferenceTypeReplaceListener(spoon.reflect.reference.CtVariableReference element) {
-			this.element = element;
-		}
-
-		@java.lang.Override
-		public void set(spoon.reflect.reference.CtTypeReference replace) {
-			this.element.setType(replace);
-		}
-	}
-
-	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	class CtWhileLoopingExpressionReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtExpression> {
-		private final spoon.reflect.code.CtWhile element;
-
-		CtWhileLoopingExpressionReplaceListener(spoon.reflect.code.CtWhile element) {
-			this.element = element;
-		}
-
-		@java.lang.Override
-		public void set(spoon.reflect.code.CtExpression replace) {
-			this.element.setLoopingExpression(replace);
-		}
-	}
-
-	public static void replace(spoon.reflect.declaration.CtElement original, spoon.reflect.declaration.CtElement replace) {
-		try {
-			new spoon.support.visitor.replace.ReplacementVisitor(original, replace).scan(original.getParent());
-		} catch (spoon.SpoonException ignore) {
-		}
-	}
-
-	private spoon.reflect.declaration.CtElement original;
-
-	private spoon.reflect.declaration.CtElement replace;
-
-	private ReplacementVisitor(spoon.reflect.declaration.CtElement original, spoon.reflect.declaration.CtElement replace) {
-		spoon.support.visitor.replace.ReplacementVisitor.this.original = original;
-		spoon.support.visitor.replace.ReplacementVisitor.this.replace = replace;
-	}
-
-	private <K, V extends spoon.reflect.declaration.CtElement> void replaceInMapIfExist(java.util.Map<K, V> mapProtected, spoon.generating.replace.ReplaceMapListener listener) {
-		java.util.Map<K, V> map = new java.util.HashMap<>(mapProtected);
-		V shouldBeDeleted = null;
-		K key = null;
-		for (java.util.Map.Entry<K, V> entry : map.entrySet()) {
-			if ((entry.getValue()) == (original)) {
-				shouldBeDeleted = entry.getValue();
-				key = entry.getKey();
-				break;
-			}
-		}
-		if (shouldBeDeleted != null) {
-			if ((replace) != null) {
-				map.put(key, ((V) (replace)));
-				replace.setParent(shouldBeDeleted.getParent());
-			} else {
-				map.remove(key);
-			}
-			listener.set(map);
-		}
-	}
-
-	private <T extends spoon.reflect.declaration.CtElement> void replaceInSetIfExist(java.util.Set<T> setProtected, spoon.generating.replace.ReplaceSetListener listener) {
-		java.util.Set<T> set = new java.util.HashSet<>(setProtected);
-		T shouldBeDeleted = null;
-		for (T element : set) {
-			if (element == (original)) {
-				shouldBeDeleted = element;
-				break;
-			}
-		}
-		if (shouldBeDeleted != null) {
-			set.remove(shouldBeDeleted);
-			if ((replace) != null) {
-				set.add(((T) (replace)));
-				replace.setParent(shouldBeDeleted.getParent());
-			}
-			listener.set(set);
-		}
-	}
-
-	private <T extends spoon.reflect.declaration.CtElement> void replaceInListIfExist(java.util.List<T> listProtected, spoon.generating.replace.ReplaceListListener listener) {
-		java.util.List<T> list = new java.util.ArrayList<>(listProtected);
-		T shouldBeDeleted = null;
-		int index = 0;
-		for (int i = 0; i < (list.size()); i++) {
-			if ((list.get(i)) == (original)) {
-				index = i;
-				shouldBeDeleted = list.get(i);
-				break;
-			}
-		}
-		if (shouldBeDeleted != null) {
-			if ((replace) != null) {
-				list.set(index, ((T) (replace)));
-				replace.setParent(shouldBeDeleted.getParent());
-			} else {
-				list.remove(index);
-			}
-			listener.set(list);
-		}
-	}
-
-	private void replaceElementIfExist(spoon.reflect.declaration.CtElement candidate, spoon.generating.replace.ReplaceListener listener) {
-		if (candidate == (original)) {
-			listener.set(replace);
-			if ((replace) != null) {
-				replace.setParent(candidate.getParent());
-			}
-		}
-	}
-
-	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	public <A extends java.lang.annotation.Annotation> void visitCtAnnotation(final spoon.reflect.declaration.CtAnnotation<A> annotation) {
-		replaceElementIfExist(annotation.getAnnotationType(), new spoon.support.visitor.replace.ReplacementVisitor.CtAnnotationAnnotationTypeReplaceListener(annotation));
-		replaceInListIfExist(annotation.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(annotation));
-		replaceInMapIfExist(annotation.getValues(), new spoon.support.visitor.replace.ReplacementVisitor.CtAnnotationValuesReplaceListener(annotation));
-	}
-
-	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	public <A extends java.lang.annotation.Annotation> void visitCtAnnotationType(final spoon.reflect.declaration.CtAnnotationType<A> annotationType) {
-		replaceInListIfExist(annotationType.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(annotationType));
-		replaceInSetIfExist(annotationType.getNestedTypes(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypeNestedTypesReplaceListener(annotationType));
-		replaceInListIfExist(annotationType.getFields(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypeFieldsReplaceListener(annotationType));
-		replaceInListIfExist(annotationType.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(annotationType));
-	}
-
-	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	public void visitCtAnonymousExecutable(final spoon.reflect.declaration.CtAnonymousExecutable anonymousExec) {
-		replaceInListIfExist(anonymousExec.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(anonymousExec));
-		replaceElementIfExist(anonymousExec.getBody(), new spoon.support.visitor.replace.ReplacementVisitor.CtExecutableBodyReplaceListener(anonymousExec));
-		replaceInListIfExist(anonymousExec.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(anonymousExec));
-	}
-
-	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	@java.lang.Override
-	public <T> void visitCtArrayRead(final spoon.reflect.code.CtArrayRead<T> arrayRead) {
-		replaceInListIfExist(arrayRead.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(arrayRead));
-		replaceElementIfExist(arrayRead.getType(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypedElementTypeReplaceListener(arrayRead));
-		replaceInListIfExist(arrayRead.getTypeCasts(), new spoon.support.visitor.replace.ReplacementVisitor.CtExpressionTypeCastsReplaceListener(arrayRead));
-		replaceElementIfExist(arrayRead.getTarget(), new spoon.support.visitor.replace.ReplacementVisitor.CtTargetedExpressionTargetReplaceListener(arrayRead));
-		replaceElementIfExist(arrayRead.getIndexExpression(), new spoon.support.visitor.replace.ReplacementVisitor.CtArrayAccessIndexExpressionReplaceListener(arrayRead));
-		replaceInListIfExist(arrayRead.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(arrayRead));
-	}
-
-	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	@java.lang.Override
-	public <T> void visitCtArrayWrite(final spoon.reflect.code.CtArrayWrite<T> arrayWrite) {
-		replaceInListIfExist(arrayWrite.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(arrayWrite));
-		replaceElementIfExist(arrayWrite.getType(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypedElementTypeReplaceListener(arrayWrite));
-		replaceInListIfExist(arrayWrite.getTypeCasts(), new spoon.support.visitor.replace.ReplacementVisitor.CtExpressionTypeCastsReplaceListener(arrayWrite));
-		replaceElementIfExist(arrayWrite.getTarget(), new spoon.support.visitor.replace.ReplacementVisitor.CtTargetedExpressionTargetReplaceListener(arrayWrite));
-		replaceElementIfExist(arrayWrite.getIndexExpression(), new spoon.support.visitor.replace.ReplacementVisitor.CtArrayAccessIndexExpressionReplaceListener(arrayWrite));
-		replaceInListIfExist(arrayWrite.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(arrayWrite));
-	}
-
-	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	public <T> void visitCtArrayTypeReference(final spoon.reflect.reference.CtArrayTypeReference<T> reference) {
-		replaceElementIfExist(reference.getDeclaringType(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypeReferenceDeclaringTypeReplaceListener(reference));
-		replaceElementIfExist(reference.getPackage(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypeReferencePackageReplaceListener(reference));
-		replaceElementIfExist(reference.getComponentType(), new spoon.support.visitor.replace.ReplacementVisitor.CtArrayTypeReferenceComponentTypeReplaceListener(reference));
-		replaceInListIfExist(reference.getActualTypeArguments(), new spoon.support.visitor.replace.ReplacementVisitor.CtActualTypeContainerActualTypeArgumentsReplaceListener(reference));
-		replaceInListIfExist(reference.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(reference));
-	}
-
-	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	public <T> void visitCtAssert(final spoon.reflect.code.CtAssert<T> asserted) {
-		replaceInListIfExist(asserted.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(asserted));
-		replaceElementIfExist(asserted.getAssertExpression(), new spoon.support.visitor.replace.ReplacementVisitor.CtAssertAssertExpressionReplaceListener(asserted));
-		replaceElementIfExist(asserted.getExpression(), new spoon.support.visitor.replace.ReplacementVisitor.CtAssertExpressionReplaceListener(asserted));
-		replaceInListIfExist(asserted.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(asserted));
-	}
-
-	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	public <T, A extends T> void visitCtAssignment(final spoon.reflect.code.CtAssignment<T, A> assignement) {
-		replaceInListIfExist(assignement.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(assignement));
-		replaceElementIfExist(assignement.getType(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypedElementTypeReplaceListener(assignement));
-		replaceInListIfExist(assignement.getTypeCasts(), new spoon.support.visitor.replace.ReplacementVisitor.CtExpressionTypeCastsReplaceListener(assignement));
-		replaceElementIfExist(assignement.getAssigned(), new spoon.support.visitor.replace.ReplacementVisitor.CtAssignmentAssignedReplaceListener(assignement));
-		replaceElementIfExist(assignement.getAssignment(), new spoon.support.visitor.replace.ReplacementVisitor.CtRHSReceiverAssignmentReplaceListener(assignement));
-		replaceInListIfExist(assignement.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(assignement));
-	}
-
-	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	public <T> void visitCtBinaryOperator(final spoon.reflect.code.CtBinaryOperator<T> operator) {
-		replaceInListIfExist(operator.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(operator));
-		replaceElementIfExist(operator.getType(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypedElementTypeReplaceListener(operator));
-		replaceInListIfExist(operator.getTypeCasts(), new spoon.support.visitor.replace.ReplacementVisitor.CtExpressionTypeCastsReplaceListener(operator));
-		replaceElementIfExist(operator.getLeftHandOperand(), new spoon.support.visitor.replace.ReplacementVisitor.CtBinaryOperatorLeftHandOperandReplaceListener(operator));
-		replaceElementIfExist(operator.getRightHandOperand(), new spoon.support.visitor.replace.ReplacementVisitor.CtBinaryOperatorRightHandOperandReplaceListener(operator));
-		replaceInListIfExist(operator.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(operator));
-	}
-
-	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	public <R> void visitCtBlock(final spoon.reflect.code.CtBlock<R> block) {
-		replaceInListIfExist(block.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(block));
-		replaceInListIfExist(block.getStatements(), new spoon.support.visitor.replace.ReplacementVisitor.CtStatementListStatementsReplaceListener(block));
-		replaceInListIfExist(block.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(block));
-	}
-
-	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	public void visitCtBreak(final spoon.reflect.code.CtBreak breakStatement) {
-		replaceInListIfExist(breakStatement.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(breakStatement));
-		replaceInListIfExist(breakStatement.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(breakStatement));
-	}
-
-	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	public <S> void visitCtCase(final spoon.reflect.code.CtCase<S> caseStatement) {
-		replaceInListIfExist(caseStatement.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(caseStatement));
-		replaceElementIfExist(caseStatement.getCaseExpression(), new spoon.support.visitor.replace.ReplacementVisitor.CtCaseCaseExpressionReplaceListener(caseStatement));
-		replaceInListIfExist(caseStatement.getStatements(), new spoon.support.visitor.replace.ReplacementVisitor.CtStatementListStatementsReplaceListener(caseStatement));
-		replaceInListIfExist(caseStatement.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(caseStatement));
-	}
-
-	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	public void visitCtCatch(final spoon.reflect.code.CtCatch catchBlock) {
-		replaceInListIfExist(catchBlock.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(catchBlock));
-		replaceElementIfExist(catchBlock.getParameter(), new spoon.support.visitor.replace.ReplacementVisitor.CtCatchParameterReplaceListener(catchBlock));
-		replaceElementIfExist(catchBlock.getBody(), new spoon.support.visitor.replace.ReplacementVisitor.CtCatchBodyReplaceListener(catchBlock));
-		replaceInListIfExist(catchBlock.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(catchBlock));
-	}
-
-	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	public <T> void visitCtClass(final spoon.reflect.declaration.CtClass<T> ctClass) {
-		replaceInListIfExist(ctClass.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(ctClass));
-		replaceElementIfExist(ctClass.getSuperclass(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypeInformationSuperclassReplaceListener(ctClass));
-		replaceInSetIfExist(ctClass.getSuperInterfaces(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypeInformationSuperInterfacesReplaceListener(ctClass));
-		replaceInListIfExist(ctClass.getFormalCtTypeParameters(), new spoon.support.visitor.replace.ReplacementVisitor.CtFormalTypeDeclarerFormalCtTypeParametersReplaceListener(ctClass));
-		replaceInListIfExist(ctClass.getAnonymousExecutables(), new spoon.support.visitor.replace.ReplacementVisitor.CtClassAnonymousExecutablesReplaceListener(ctClass));
-		replaceInSetIfExist(ctClass.getNestedTypes(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypeNestedTypesReplaceListener(ctClass));
-		replaceInListIfExist(ctClass.getFields(), new spoon.support.visitor.replace.ReplacementVisitor.CtClassFieldsReplaceListener(ctClass));
-		replaceInSetIfExist(ctClass.getConstructors(), new spoon.support.visitor.replace.ReplacementVisitor.CtClassConstructorsReplaceListener(ctClass));
-		replaceInSetIfExist(ctClass.getMethods(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypeMethodsReplaceListener(ctClass));
-		replaceInListIfExist(ctClass.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(ctClass));
-	}
-
-	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	@java.lang.Override
-	public void visitCtTypeParameter(spoon.reflect.declaration.CtTypeParameter typeParameter) {
-		replaceInListIfExist(typeParameter.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(typeParameter));
-		replaceElementIfExist(typeParameter.getSuperclass(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypeInformationSuperclassReplaceListener(typeParameter));
-		replaceInListIfExist(typeParameter.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(typeParameter));
-	}
-
-	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	public <T> void visitCtConditional(final spoon.reflect.code.CtConditional<T> conditional) {
-		replaceInListIfExist(conditional.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(conditional));
-		replaceElementIfExist(conditional.getCondition(), new spoon.support.visitor.replace.ReplacementVisitor.CtConditionalConditionReplaceListener(conditional));
-		replaceElementIfExist(conditional.getThenExpression(), new spoon.support.visitor.replace.ReplacementVisitor.CtConditionalThenExpressionReplaceListener(conditional));
-		replaceElementIfExist(conditional.getElseExpression(), new spoon.support.visitor.replace.ReplacementVisitor.CtConditionalElseExpressionReplaceListener(conditional));
-		replaceInListIfExist(conditional.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(conditional));
-		replaceInListIfExist(conditional.getTypeCasts(), new spoon.support.visitor.replace.ReplacementVisitor.CtExpressionTypeCastsReplaceListener(conditional));
-	}
-
-	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	public <T> void visitCtConstructor(final spoon.reflect.declaration.CtConstructor<T> c) {
-		replaceInListIfExist(c.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(c));
-		replaceInListIfExist(c.getParameters(), new spoon.support.visitor.replace.ReplacementVisitor.CtExecutableParametersReplaceListener(c));
-		replaceInSetIfExist(c.getThrownTypes(), new spoon.support.visitor.replace.ReplacementVisitor.CtExecutableThrownTypesReplaceListener(c));
-		replaceInListIfExist(c.getFormalCtTypeParameters(), new spoon.support.visitor.replace.ReplacementVisitor.CtFormalTypeDeclarerFormalCtTypeParametersReplaceListener(c));
-		replaceElementIfExist(c.getBody(), new spoon.support.visitor.replace.ReplacementVisitor.CtExecutableBodyReplaceListener(c));
-		replaceInListIfExist(c.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(c));
-	}
-
-	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	public void visitCtContinue(final spoon.reflect.code.CtContinue continueStatement) {
-		replaceInListIfExist(continueStatement.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(continueStatement));
-		replaceElementIfExist(continueStatement.getLabelledStatement(), new spoon.support.visitor.replace.ReplacementVisitor.CtContinueLabelledStatementReplaceListener(continueStatement));
-		replaceInListIfExist(continueStatement.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(continueStatement));
-	}
-
-	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	public void visitCtDo(final spoon.reflect.code.CtDo doLoop) {
-		replaceInListIfExist(doLoop.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(doLoop));
-		replaceElementIfExist(doLoop.getLoopingExpression(), new spoon.support.visitor.replace.ReplacementVisitor.CtDoLoopingExpressionReplaceListener(doLoop));
-		replaceElementIfExist(doLoop.getBody(), new spoon.support.visitor.replace.ReplacementVisitor.CtLoopBodyReplaceListener(doLoop));
-		replaceInListIfExist(doLoop.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(doLoop));
-	}
-
-	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	public <T extends java.lang.Enum<?>> void visitCtEnum(final spoon.reflect.declaration.CtEnum<T> ctEnum) {
-		replaceInListIfExist(ctEnum.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(ctEnum));
-		replaceInSetIfExist(ctEnum.getSuperInterfaces(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypeInformationSuperInterfacesReplaceListener(ctEnum));
-		replaceInListIfExist(ctEnum.getFields(), new spoon.support.visitor.replace.ReplacementVisitor.CtClassFieldsReplaceListener(ctEnum));
-		replaceInSetIfExist(ctEnum.getConstructors(), new spoon.support.visitor.replace.ReplacementVisitor.CtClassConstructorsReplaceListener(ctEnum));
-		replaceInSetIfExist(ctEnum.getMethods(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypeMethodsReplaceListener(ctEnum));
-		replaceInSetIfExist(ctEnum.getNestedTypes(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypeNestedTypesReplaceListener(ctEnum));
-		replaceInListIfExist(ctEnum.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(ctEnum));
-	}
-
-	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	public <T> void visitCtExecutableReference(final spoon.reflect.reference.CtExecutableReference<T> reference) {
-		replaceElementIfExist(reference.getDeclaringType(), new spoon.support.visitor.replace.ReplacementVisitor.CtExecutableReferenceDeclaringTypeReplaceListener(reference));
-		replaceElementIfExist(reference.getType(), new spoon.support.visitor.replace.ReplacementVisitor.CtExecutableReferenceTypeReplaceListener(reference));
-		replaceInListIfExist(reference.getParameters(), new spoon.support.visitor.replace.ReplacementVisitor.CtExecutableReferenceParametersReplaceListener(reference));
-		replaceInListIfExist(reference.getActualTypeArguments(), new spoon.support.visitor.replace.ReplacementVisitor.CtActualTypeContainerActualTypeArgumentsReplaceListener(reference));
+	public <T> void visitCtFieldReference(final spoon.reflect.reference.CtFieldReference<T> reference) {
+		replaceElementIfExist(reference.getDeclaringType(), new spoon.support.visitor.replace.ReplacementVisitor.CtFieldReferenceDeclaringTypeReplaceListener(reference));
+		replaceElementIfExist(reference.getType(), new spoon.support.visitor.replace.ReplacementVisitor.CtVariableReferenceTypeReplaceListener(reference));
 		replaceInListIfExist(reference.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(reference));
-		replaceInListIfExist(reference.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(reference));
-	}
-
-	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	public <T> void visitCtField(final spoon.reflect.declaration.CtField<T> f) {
-		replaceInListIfExist(f.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(f));
-		replaceElementIfExist(f.getType(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypedElementTypeReplaceListener(f));
-		replaceElementIfExist(f.getDefaultExpression(), new spoon.support.visitor.replace.ReplacementVisitor.CtVariableDefaultExpressionReplaceListener(f));
-		replaceInListIfExist(f.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(f));
-	}
-
-	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	@java.lang.Override
-	public <T> void visitCtEnumValue(final spoon.reflect.declaration.CtEnumValue<T> enumValue) {
-		replaceInListIfExist(enumValue.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(enumValue));
-		replaceElementIfExist(enumValue.getType(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypedElementTypeReplaceListener(enumValue));
-		replaceElementIfExist(enumValue.getDefaultExpression(), new spoon.support.visitor.replace.ReplacementVisitor.CtVariableDefaultExpressionReplaceListener(enumValue));
-		replaceInListIfExist(enumValue.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(enumValue));
 	}
 
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	@java.lang.Override
-	public <T> void visitCtThisAccess(final spoon.reflect.code.CtThisAccess<T> thisAccess) {
-		replaceElementIfExist(thisAccess.getType(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypedElementTypeReplaceListener(thisAccess));
-		replaceInListIfExist(thisAccess.getTypeCasts(), new spoon.support.visitor.replace.ReplacementVisitor.CtExpressionTypeCastsReplaceListener(thisAccess));
-		replaceElementIfExist(thisAccess.getTarget(), new spoon.support.visitor.replace.ReplacementVisitor.CtTargetedExpressionTargetReplaceListener(thisAccess));
-		replaceInListIfExist(thisAccess.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(thisAccess));
+	class CtForForInitReplaceListener implements spoon.generating.replace.ReplaceListListener<java.util.List> {
+		private final spoon.reflect.code.CtFor element;
+
+		CtForForInitReplaceListener(spoon.reflect.code.CtFor element) {
+			this.element = element;
+		}
+
+		@java.lang.Override
+		public void set(java.util.List replace) {
+			this.element.setForInit(replace);
+		}
 	}
 
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	public <T> void visitCtAnnotationFieldAccess(final spoon.reflect.code.CtAnnotationFieldAccess<T> annotationFieldAccess) {
-		replaceInListIfExist(annotationFieldAccess.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(annotationFieldAccess));
-		replaceElementIfExist(annotationFieldAccess.getType(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypedElementTypeReplaceListener(annotationFieldAccess));
-		replaceInListIfExist(annotationFieldAccess.getTypeCasts(), new spoon.support.visitor.replace.ReplacementVisitor.CtExpressionTypeCastsReplaceListener(annotationFieldAccess));
-		replaceElementIfExist(annotationFieldAccess.getTarget(), new spoon.support.visitor.replace.ReplacementVisitor.CtTargetedExpressionTargetReplaceListener(annotationFieldAccess));
-		replaceElementIfExist(annotationFieldAccess.getVariable(), new spoon.support.visitor.replace.ReplacementVisitor.CtAnnotationFieldAccessVariableReplaceListener(annotationFieldAccess));
-		replaceInListIfExist(annotationFieldAccess.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(annotationFieldAccess));
+	class CtForExpressionReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtExpression> {
+		private final spoon.reflect.code.CtFor element;
+
+		CtForExpressionReplaceListener(spoon.reflect.code.CtFor element) {
+			this.element = element;
+		}
+
+		@java.lang.Override
+		public void set(spoon.reflect.code.CtExpression replace) {
+			this.element.setExpression(replace);
+		}
 	}
 
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
-	public <T> void visitCtFieldReference(final spoon.reflect.reference.CtFieldReference<T> reference) {
-		replaceElementIfExist(reference.getDeclaringType(), new spoon.support.visitor.replace.ReplacementVisitor.CtFieldReferenceDeclaringTypeReplaceListener(reference));
-		replaceElementIfExist(reference.getType(), new spoon.support.visitor.replace.ReplacementVisitor.CtVariableReferenceTypeReplaceListener(reference));
-		replaceInListIfExist(reference.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(reference));
+	class CtForForUpdateReplaceListener implements spoon.generating.replace.ReplaceListListener<java.util.List> {
+		private final spoon.reflect.code.CtFor element;
+
+		CtForForUpdateReplaceListener(spoon.reflect.code.CtFor element) {
+			this.element = element;
+		}
+
+		@java.lang.Override
+		public void set(java.util.List replace) {
+			this.element.setForUpdate(replace);
+		}
 	}
 
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
@@ -1516,6 +991,34 @@ public class ReplacementVisitor extends spoon.reflect.visitor.CtScanner {
 		replaceInListIfExist(forLoop.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(forLoop));
 	}
 
+	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
+	class CtForEachVariableReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtLocalVariable> {
+		private final spoon.reflect.code.CtForEach element;
+
+		CtForEachVariableReplaceListener(spoon.reflect.code.CtForEach element) {
+			this.element = element;
+		}
+
+		@java.lang.Override
+		public void set(spoon.reflect.code.CtLocalVariable replace) {
+			this.element.setVariable(replace);
+		}
+	}
+
+	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
+	class CtForEachExpressionReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtExpression> {
+		private final spoon.reflect.code.CtForEach element;
+
+		CtForEachExpressionReplaceListener(spoon.reflect.code.CtForEach element) {
+			this.element = element;
+		}
+
+		@java.lang.Override
+		public void set(spoon.reflect.code.CtExpression replace) {
+			this.element.setExpression(replace);
+		}
+	}
+
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
 	public void visitCtForEach(final spoon.reflect.code.CtForEach foreach) {
 		replaceInListIfExist(foreach.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(foreach));
@@ -1525,6 +1028,48 @@ public class ReplacementVisitor extends spoon.reflect.visitor.CtScanner {
 		replaceInListIfExist(foreach.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(foreach));
 	}
 
+	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
+	class CtIfConditionReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtExpression> {
+		private final spoon.reflect.code.CtIf element;
+
+		CtIfConditionReplaceListener(spoon.reflect.code.CtIf element) {
+			this.element = element;
+		}
+
+		@java.lang.Override
+		public void set(spoon.reflect.code.CtExpression replace) {
+			this.element.setCondition(replace);
+		}
+	}
+
+	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
+	class CtIfThenStatementReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtStatement> {
+		private final spoon.reflect.code.CtIf element;
+
+		CtIfThenStatementReplaceListener(spoon.reflect.code.CtIf element) {
+			this.element = element;
+		}
+
+		@java.lang.Override
+		public void set(spoon.reflect.code.CtStatement replace) {
+			this.element.setThenStatement(replace);
+		}
+	}
+
+	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
+	class CtIfElseStatementReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtStatement> {
+		private final spoon.reflect.code.CtIf element;
+
+		CtIfElseStatementReplaceListener(spoon.reflect.code.CtIf element) {
+			this.element = element;
+		}
+
+		@java.lang.Override
+		public void set(spoon.reflect.code.CtStatement replace) {
+			this.element.setElseStatement(replace);
+		}
+	}
+
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
 	public void visitCtIf(final spoon.reflect.code.CtIf ifElement) {
 		replaceInListIfExist(ifElement.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(ifElement));
@@ -1539,12 +1084,38 @@ public class ReplacementVisitor extends spoon.reflect.visitor.CtScanner {
 		replaceInListIfExist(intrface.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(intrface));
 		replaceInSetIfExist(intrface.getSuperInterfaces(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypeInformationSuperInterfacesReplaceListener(intrface));
 		replaceInListIfExist(intrface.getFormalCtTypeParameters(), new spoon.support.visitor.replace.ReplacementVisitor.CtFormalTypeDeclarerFormalCtTypeParametersReplaceListener(intrface));
-		replaceInSetIfExist(intrface.getNestedTypes(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypeNestedTypesReplaceListener(intrface));
-		replaceInListIfExist(intrface.getFields(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypeFieldsReplaceListener(intrface));
-		replaceInSetIfExist(intrface.getMethods(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypeMethodsReplaceListener(intrface));
+		replaceInListIfExist(intrface.getTypeMembers(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypeTypeMembersReplaceListener(intrface));
 		replaceInListIfExist(intrface.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(intrface));
 	}
 
+	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
+	class CtAbstractInvocationExecutableReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.reference.CtExecutableReference> {
+		private final spoon.reflect.code.CtAbstractInvocation element;
+
+		CtAbstractInvocationExecutableReplaceListener(spoon.reflect.code.CtAbstractInvocation element) {
+			this.element = element;
+		}
+
+		@java.lang.Override
+		public void set(spoon.reflect.reference.CtExecutableReference replace) {
+			this.element.setExecutable(replace);
+		}
+	}
+
+	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
+	class CtAbstractInvocationArgumentsReplaceListener implements spoon.generating.replace.ReplaceListListener<java.util.List> {
+		private final spoon.reflect.code.CtAbstractInvocation element;
+
+		CtAbstractInvocationArgumentsReplaceListener(spoon.reflect.code.CtAbstractInvocation element) {
+			this.element = element;
+		}
+
+		@java.lang.Override
+		public void set(java.util.List replace) {
+			this.element.setArguments(replace);
+		}
+	}
+
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
 	public <T> void visitCtInvocation(final spoon.reflect.code.CtInvocation<T> invocation) {
 		replaceInListIfExist(invocation.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(invocation));
@@ -1601,6 +1172,20 @@ public class ReplacementVisitor extends spoon.reflect.visitor.CtScanner {
 		replaceInListIfExist(m.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(m));
 	}
 
+	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
+	class CtAnnotationMethodDefaultExpressionReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtExpression> {
+		private final spoon.reflect.declaration.CtAnnotationMethod element;
+
+		CtAnnotationMethodDefaultExpressionReplaceListener(spoon.reflect.declaration.CtAnnotationMethod element) {
+			this.element = element;
+		}
+
+		@java.lang.Override
+		public void set(spoon.reflect.code.CtExpression replace) {
+			this.element.setDefaultExpression(replace);
+		}
+	}
+
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
 	@java.lang.Override
 	public <T> void visitCtAnnotationMethod(spoon.reflect.declaration.CtAnnotationMethod<T> annotationMethod) {
@@ -1610,6 +1195,34 @@ public class ReplacementVisitor extends spoon.reflect.visitor.CtScanner {
 		replaceInListIfExist(annotationMethod.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(annotationMethod));
 	}
 
+	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
+	class CtNewArrayElementsReplaceListener implements spoon.generating.replace.ReplaceListListener<java.util.List> {
+		private final spoon.reflect.code.CtNewArray element;
+
+		CtNewArrayElementsReplaceListener(spoon.reflect.code.CtNewArray element) {
+			this.element = element;
+		}
+
+		@java.lang.Override
+		public void set(java.util.List replace) {
+			this.element.setElements(replace);
+		}
+	}
+
+	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
+	class CtNewArrayDimensionExpressionsReplaceListener implements spoon.generating.replace.ReplaceListListener<java.util.List> {
+		private final spoon.reflect.code.CtNewArray element;
+
+		CtNewArrayDimensionExpressionsReplaceListener(spoon.reflect.code.CtNewArray element) {
+			this.element = element;
+		}
+
+		@java.lang.Override
+		public void set(java.util.List replace) {
+			this.element.setDimensionExpressions(replace);
+		}
+	}
+
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
 	public <T> void visitCtNewArray(final spoon.reflect.code.CtNewArray<T> newArray) {
 		replaceInListIfExist(newArray.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(newArray));
@@ -1631,6 +1244,20 @@ public class ReplacementVisitor extends spoon.reflect.visitor.CtScanner {
 		replaceInListIfExist(ctConstructorCall.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(ctConstructorCall));
 	}
 
+	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
+	class CtNewClassAnonymousClassReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.declaration.CtClass> {
+		private final spoon.reflect.code.CtNewClass element;
+
+		CtNewClassAnonymousClassReplaceListener(spoon.reflect.code.CtNewClass element) {
+			this.element = element;
+		}
+
+		@java.lang.Override
+		public void set(spoon.reflect.declaration.CtClass replace) {
+			this.element.setAnonymousClass(replace);
+		}
+	}
+
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
 	public <T> void visitCtNewClass(final spoon.reflect.code.CtNewClass<T> newClass) {
 		replaceInListIfExist(newClass.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(newClass));
@@ -1642,6 +1269,20 @@ public class ReplacementVisitor extends spoon.reflect.visitor.CtScanner {
 		replaceInListIfExist(newClass.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(newClass));
 	}
 
+	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
+	class CtLambdaExpressionReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtExpression> {
+		private final spoon.reflect.code.CtLambda element;
+
+		CtLambdaExpressionReplaceListener(spoon.reflect.code.CtLambda element) {
+			this.element = element;
+		}
+
+		@java.lang.Override
+		public void set(spoon.reflect.code.CtExpression replace) {
+			this.element.setExpression(replace);
+		}
+	}
+
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
 	@java.lang.Override
 	public <T> void visitCtLambda(final spoon.reflect.code.CtLambda<T> lambda) {
@@ -1654,6 +1295,20 @@ public class ReplacementVisitor extends spoon.reflect.visitor.CtScanner {
 		replaceInListIfExist(lambda.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(lambda));
 	}
 
+	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
+	class CtExecutableReferenceExpressionExecutableReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.reference.CtExecutableReference> {
+		private final spoon.reflect.code.CtExecutableReferenceExpression element;
+
+		CtExecutableReferenceExpressionExecutableReplaceListener(spoon.reflect.code.CtExecutableReferenceExpression element) {
+			this.element = element;
+		}
+
+		@java.lang.Override
+		public void set(spoon.reflect.reference.CtExecutableReference replace) {
+			this.element.setExecutable(replace);
+		}
+	}
+
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
 	@java.lang.Override
 	public <T, E extends spoon.reflect.code.CtExpression<?>> void visitCtExecutableReferenceExpression(final spoon.reflect.code.CtExecutableReferenceExpression<T, E> expression) {
@@ -1673,6 +1328,34 @@ public class ReplacementVisitor extends spoon.reflect.visitor.CtScanner {
 		replaceInListIfExist(assignment.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(assignment));
 	}
 
+	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
+	class CtPackagePackagesReplaceListener implements spoon.generating.replace.ReplaceSetListener<java.util.Set> {
+		private final spoon.reflect.declaration.CtPackage element;
+
+		CtPackagePackagesReplaceListener(spoon.reflect.declaration.CtPackage element) {
+			this.element = element;
+		}
+
+		@java.lang.Override
+		public void set(java.util.Set replace) {
+			this.element.setPackages(replace);
+		}
+	}
+
+	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
+	class CtPackageTypesReplaceListener implements spoon.generating.replace.ReplaceSetListener<java.util.Set> {
+		private final spoon.reflect.declaration.CtPackage element;
+
+		CtPackageTypesReplaceListener(spoon.reflect.declaration.CtPackage element) {
+			this.element = element;
+		}
+
+		@java.lang.Override
+		public void set(java.util.Set replace) {
+			this.element.setTypes(replace);
+		}
+	}
+
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
 	public void visitCtPackage(final spoon.reflect.declaration.CtPackage ctPackage) {
 		replaceInListIfExist(ctPackage.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(ctPackage));
@@ -1691,6 +1374,20 @@ public class ReplacementVisitor extends spoon.reflect.visitor.CtScanner {
 		replaceInListIfExist(parameter.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(parameter));
 	}
 
+	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
+	class CtParameterReferenceDeclaringExecutableReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.reference.CtExecutableReference> {
+		private final spoon.reflect.reference.CtParameterReference element;
+
+		CtParameterReferenceDeclaringExecutableReplaceListener(spoon.reflect.reference.CtParameterReference element) {
+			this.element = element;
+		}
+
+		@java.lang.Override
+		public void set(spoon.reflect.reference.CtExecutableReference replace) {
+			this.element.setDeclaringExecutable(replace);
+		}
+	}
+
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
 	public <T> void visitCtParameterReference(final spoon.reflect.reference.CtParameterReference<T> reference) {
 		replaceElementIfExist(reference.getType(), new spoon.support.visitor.replace.ReplacementVisitor.CtVariableReferenceTypeReplaceListener(reference));
@@ -1698,6 +1395,20 @@ public class ReplacementVisitor extends spoon.reflect.visitor.CtScanner {
 		replaceElementIfExist(reference.getDeclaringExecutable(), new spoon.support.visitor.replace.ReplacementVisitor.CtParameterReferenceDeclaringExecutableReplaceListener(reference));
 	}
 
+	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
+	class CtReturnReturnedExpressionReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtExpression> {
+		private final spoon.reflect.code.CtReturn element;
+
+		CtReturnReturnedExpressionReplaceListener(spoon.reflect.code.CtReturn element) {
+			this.element = element;
+		}
+
+		@java.lang.Override
+		public void set(spoon.reflect.code.CtExpression replace) {
+			this.element.setReturnedExpression(replace);
+		}
+	}
+
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
 	public <R> void visitCtReturn(final spoon.reflect.code.CtReturn<R> returnStatement) {
 		replaceInListIfExist(returnStatement.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(returnStatement));
@@ -1712,6 +1423,34 @@ public class ReplacementVisitor extends spoon.reflect.visitor.CtScanner {
 		replaceInListIfExist(statements.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(statements));
 	}
 
+	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
+	class CtSwitchSelectorReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtExpression> {
+		private final spoon.reflect.code.CtSwitch element;
+
+		CtSwitchSelectorReplaceListener(spoon.reflect.code.CtSwitch element) {
+			this.element = element;
+		}
+
+		@java.lang.Override
+		public void set(spoon.reflect.code.CtExpression replace) {
+			this.element.setSelector(replace);
+		}
+	}
+
+	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
+	class CtSwitchCasesReplaceListener implements spoon.generating.replace.ReplaceListListener<java.util.List> {
+		private final spoon.reflect.code.CtSwitch element;
+
+		CtSwitchCasesReplaceListener(spoon.reflect.code.CtSwitch element) {
+			this.element = element;
+		}
+
+		@java.lang.Override
+		public void set(java.util.List replace) {
+			this.element.setCases(replace);
+		}
+	}
+
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
 	public <S> void visitCtSwitch(final spoon.reflect.code.CtSwitch<S> switchStatement) {
 		replaceInListIfExist(switchStatement.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(switchStatement));
@@ -1720,6 +1459,34 @@ public class ReplacementVisitor extends spoon.reflect.visitor.CtScanner {
 		replaceInListIfExist(switchStatement.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(switchStatement));
 	}
 
+	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
+	class CtSynchronizedExpressionReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtExpression> {
+		private final spoon.reflect.code.CtSynchronized element;
+
+		CtSynchronizedExpressionReplaceListener(spoon.reflect.code.CtSynchronized element) {
+			this.element = element;
+		}
+
+		@java.lang.Override
+		public void set(spoon.reflect.code.CtExpression replace) {
+			this.element.setExpression(replace);
+		}
+	}
+
+	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
+	class CtSynchronizedBlockReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtBlock> {
+		private final spoon.reflect.code.CtSynchronized element;
+
+		CtSynchronizedBlockReplaceListener(spoon.reflect.code.CtSynchronized element) {
+			this.element = element;
+		}
+
+		@java.lang.Override
+		public void set(spoon.reflect.code.CtBlock replace) {
+			this.element.setBlock(replace);
+		}
+	}
+
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
 	public void visitCtSynchronized(final spoon.reflect.code.CtSynchronized synchro) {
 		replaceInListIfExist(synchro.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(synchro));
@@ -1728,6 +1495,20 @@ public class ReplacementVisitor extends spoon.reflect.visitor.CtScanner {
 		replaceInListIfExist(synchro.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(synchro));
 	}
 
+	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
+	class CtThrowThrownExpressionReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtExpression> {
+		private final spoon.reflect.code.CtThrow element;
+
+		CtThrowThrownExpressionReplaceListener(spoon.reflect.code.CtThrow element) {
+			this.element = element;
+		}
+
+		@java.lang.Override
+		public void set(spoon.reflect.code.CtExpression replace) {
+			this.element.setThrownExpression(replace);
+		}
+	}
+
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
 	public void visitCtThrow(final spoon.reflect.code.CtThrow throwStatement) {
 		replaceInListIfExist(throwStatement.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(throwStatement));
@@ -1735,6 +1516,48 @@ public class ReplacementVisitor extends spoon.reflect.visitor.CtScanner {
 		replaceInListIfExist(throwStatement.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(throwStatement));
 	}
 
+	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
+	class CtTryBodyReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtBlock> {
+		private final spoon.reflect.code.CtTry element;
+
+		CtTryBodyReplaceListener(spoon.reflect.code.CtTry element) {
+			this.element = element;
+		}
+
+		@java.lang.Override
+		public void set(spoon.reflect.code.CtBlock replace) {
+			this.element.setBody(replace);
+		}
+	}
+
+	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
+	class CtTryCatchersReplaceListener implements spoon.generating.replace.ReplaceListListener<java.util.List> {
+		private final spoon.reflect.code.CtTry element;
+
+		CtTryCatchersReplaceListener(spoon.reflect.code.CtTry element) {
+			this.element = element;
+		}
+
+		@java.lang.Override
+		public void set(java.util.List replace) {
+			this.element.setCatchers(replace);
+		}
+	}
+
+	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
+	class CtTryFinalizerReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtBlock> {
+		private final spoon.reflect.code.CtTry element;
+
+		CtTryFinalizerReplaceListener(spoon.reflect.code.CtTry element) {
+			this.element = element;
+		}
+
+		@java.lang.Override
+		public void set(spoon.reflect.code.CtBlock replace) {
+			this.element.setFinalizer(replace);
+		}
+	}
+
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
 	public void visitCtTry(final spoon.reflect.code.CtTry tryBlock) {
 		replaceInListIfExist(tryBlock.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(tryBlock));
@@ -1744,6 +1567,20 @@ public class ReplacementVisitor extends spoon.reflect.visitor.CtScanner {
 		replaceInListIfExist(tryBlock.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(tryBlock));
 	}
 
+	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
+	class CtTryWithResourceResourcesReplaceListener implements spoon.generating.replace.ReplaceListListener<java.util.List> {
+		private final spoon.reflect.code.CtTryWithResource element;
+
+		CtTryWithResourceResourcesReplaceListener(spoon.reflect.code.CtTryWithResource element) {
+			this.element = element;
+		}
+
+		@java.lang.Override
+		public void set(java.util.List replace) {
+			this.element.setResources(replace);
+		}
+	}
+
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
 	@java.lang.Override
 	public void visitCtTryWithResource(final spoon.reflect.code.CtTryWithResource tryWithResource) {
@@ -1755,6 +1592,20 @@ public class ReplacementVisitor extends spoon.reflect.visitor.CtScanner {
 		replaceInListIfExist(tryWithResource.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(tryWithResource));
 	}
 
+	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
+	class CtTypeParameterReferenceBoundingTypeReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.reference.CtTypeReference> {
+		private final spoon.reflect.reference.CtTypeParameterReference element;
+
+		CtTypeParameterReferenceBoundingTypeReplaceListener(spoon.reflect.reference.CtTypeParameterReference element) {
+			this.element = element;
+		}
+
+		@java.lang.Override
+		public void set(spoon.reflect.reference.CtTypeReference replace) {
+			this.element.setBoundingType(replace);
+		}
+	}
+
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
 	public void visitCtTypeParameterReference(final spoon.reflect.reference.CtTypeParameterReference ref) {
 		replaceElementIfExist(ref.getPackage(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypeReferencePackageReplaceListener(ref));
@@ -1770,6 +1621,20 @@ public class ReplacementVisitor extends spoon.reflect.visitor.CtScanner {
 		replaceElementIfExist(wildcardReference.getBoundingType(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypeParameterReferenceBoundingTypeReplaceListener(wildcardReference));
 	}
 
+	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
+	class CtIntersectionTypeReferenceBoundsReplaceListener implements spoon.generating.replace.ReplaceSetListener<java.util.Set> {
+		private final spoon.reflect.reference.CtIntersectionTypeReference element;
+
+		CtIntersectionTypeReferenceBoundsReplaceListener(spoon.reflect.reference.CtIntersectionTypeReference element) {
+			this.element = element;
+		}
+
+		@java.lang.Override
+		public void set(java.util.Set replace) {
+			this.element.setBounds(replace);
+		}
+	}
+
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
 	@java.lang.Override
 	public <T> void visitCtIntersectionTypeReference(final spoon.reflect.reference.CtIntersectionTypeReference<T> reference) {
@@ -1785,6 +1650,20 @@ public class ReplacementVisitor extends spoon.reflect.visitor.CtScanner {
 		replaceInListIfExist(reference.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(reference));
 	}
 
+	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
+	class CtTypeAccessAccessedTypeReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.reference.CtTypeReference> {
+		private final spoon.reflect.code.CtTypeAccess element;
+
+		CtTypeAccessAccessedTypeReplaceListener(spoon.reflect.code.CtTypeAccess element) {
+			this.element = element;
+		}
+
+		@java.lang.Override
+		public void set(spoon.reflect.reference.CtTypeReference replace) {
+			this.element.setAccessedType(replace);
+		}
+	}
+
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
 	@java.lang.Override
 	public <T> void visitCtTypeAccess(final spoon.reflect.code.CtTypeAccess<T> typeAccess) {
@@ -1794,6 +1673,20 @@ public class ReplacementVisitor extends spoon.reflect.visitor.CtScanner {
 		replaceInListIfExist(typeAccess.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(typeAccess));
 	}
 
+	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
+	class CtUnaryOperatorOperandReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtExpression> {
+		private final spoon.reflect.code.CtUnaryOperator element;
+
+		CtUnaryOperatorOperandReplaceListener(spoon.reflect.code.CtUnaryOperator element) {
+			this.element = element;
+		}
+
+		@java.lang.Override
+		public void set(spoon.reflect.code.CtExpression replace) {
+			this.element.setOperand(replace);
+		}
+	}
+
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
 	public <T> void visitCtUnaryOperator(final spoon.reflect.code.CtUnaryOperator<T> operator) {
 		replaceInListIfExist(operator.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(operator));
@@ -1803,6 +1696,20 @@ public class ReplacementVisitor extends spoon.reflect.visitor.CtScanner {
 		replaceInListIfExist(operator.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(operator));
 	}
 
+	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
+	class CtVariableAccessVariableReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.reference.CtVariableReference> {
+		private final spoon.reflect.code.CtVariableAccess element;
+
+		CtVariableAccessVariableReplaceListener(spoon.reflect.code.CtVariableAccess element) {
+			this.element = element;
+		}
+
+		@java.lang.Override
+		public void set(spoon.reflect.reference.CtVariableReference replace) {
+			this.element.setVariable(replace);
+		}
+	}
+
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
 	@java.lang.Override
 	public <T> void visitCtVariableRead(final spoon.reflect.code.CtVariableRead<T> variableRead) {
@@ -1821,6 +1728,20 @@ public class ReplacementVisitor extends spoon.reflect.visitor.CtScanner {
 		replaceInListIfExist(variableWrite.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(variableWrite));
 	}
 
+	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
+	class CtWhileLoopingExpressionReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.code.CtExpression> {
+		private final spoon.reflect.code.CtWhile element;
+
+		CtWhileLoopingExpressionReplaceListener(spoon.reflect.code.CtWhile element) {
+			this.element = element;
+		}
+
+		@java.lang.Override
+		public void set(spoon.reflect.code.CtExpression replace) {
+			this.element.setLoopingExpression(replace);
+		}
+	}
+
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
 	public void visitCtWhile(final spoon.reflect.code.CtWhile whileLoop) {
 		replaceInListIfExist(whileLoop.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(whileLoop));
@@ -1838,6 +1759,20 @@ public class ReplacementVisitor extends spoon.reflect.visitor.CtScanner {
 	public <T> void visitCtUnboundVariableReference(final spoon.reflect.reference.CtUnboundVariableReference<T> reference) {
 	}
 
+	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
+	class CtFieldAccessVariableReplaceListener implements spoon.generating.replace.ReplaceListener<spoon.reflect.reference.CtFieldReference> {
+		private final spoon.reflect.code.CtVariableAccess element;
+
+		CtFieldAccessVariableReplaceListener(spoon.reflect.code.CtVariableAccess element) {
+			this.element = element;
+		}
+
+		@java.lang.Override
+		public void set(spoon.reflect.reference.CtFieldReference replace) {
+			this.element.setVariable(replace);
+		}
+	}
+
 	// auto-generated, see spoon.generating.ReplacementVisitorGenerator
 	@java.lang.Override
 	public <T> void visitCtFieldRead(final spoon.reflect.code.CtFieldRead<T> fieldRead) {
diff --git a/src/main/java/spoon/template/Substitution.java b/src/main/java/spoon/template/Substitution.java
index e3e2b2be1..ef012db97 100644
--- a/src/main/java/spoon/template/Substitution.java
+++ b/src/main/java/spoon/template/Substitution.java
@@ -28,6 +28,7 @@ import spoon.reflect.declaration.CtField;
 import spoon.reflect.declaration.CtInterface;
 import spoon.reflect.declaration.CtMethod;
 import spoon.reflect.declaration.CtType;
+import spoon.reflect.declaration.CtTypeMember;
 import spoon.reflect.reference.CtPackageReference;
 import spoon.reflect.reference.CtTypeReference;
 import spoon.reflect.visitor.Query;
@@ -119,26 +120,27 @@ public abstract class Substitution {
 				((CtClass<?>) targetType).addAnonymousExecutable(substitute(targetType, template, e));
 			}
 		}
-		// insert all the fields
-		for (CtField<?> f : templateClass.getFields()) {
-			if (f.getAnnotation(Local.class) != null) {
-				continue;
-			}
-			if (Parameters.isParameterSource(f.getReference())) {
-				continue;
-			}
+		for (CtTypeMember typeMember : templateClass.getTypeMembers()) {
+			if (typeMember instanceof CtField) {
+				// insert all the fields
+				CtField<?> f = (CtField<?>) typeMember;
+				if (f.getAnnotation(Local.class) != null) {
+					continue;
+				}
+				if (Parameters.isParameterSource(f.getReference())) {
+					continue;
+				}
 
-			insertField(targetType, template, f);
-		}
-		// insert all the inner types
-		for (CtType<?> t : templateClass.getNestedTypes()) {
-			if (t.getAnnotation(Local.class) != null) {
-				continue;
+				insertField(targetType, template, f);
+			} else if (typeMember instanceof CtType) {
+				// insert all the inner types
+				if (typeMember.getAnnotation(Local.class) != null) {
+					continue;
+				}
+				CtType<?> result = substitute(templateClass, template, (CtType) typeMember);
+				targetType.addNestedType(result);
 			}
-			CtType<?> result = substitute(templateClass, template, t);
-			targetType.addNestedType(result);
 		}
-
 	}
 
 	/**
@@ -220,7 +222,11 @@ public abstract class Substitution {
 
 		CtClass<?> sourceClass = targetType.getFactory().Class().get(template.getClass());
 		// insert all the fields
-		for (CtField<?> f : sourceClass.getFields()) {
+		for (CtTypeMember typeMember: sourceClass.getTypeMembers()) {
+			if (!(typeMember instanceof CtField)) {
+				continue;
+			}
+			CtField<?> f = (CtField<?>) typeMember;
 			if (f.getAnnotation(Local.class) != null) {
 				continue;
 			}
diff --git a/src/test/java/spoon/reflect/ast/IntercessionScanner.java b/src/test/java/spoon/reflect/ast/IntercessionScanner.java
index c9d0a5a45..d38731546 100644
--- a/src/test/java/spoon/reflect/ast/IntercessionScanner.java
+++ b/src/test/java/spoon/reflect/ast/IntercessionScanner.java
@@ -81,6 +81,16 @@ public abstract class IntercessionScanner extends CtScanner {
 				&& !(candidate.getSimpleName().equals("addMethod") && candidate.getDeclaringType().getSimpleName().equals("CtAnnotationTypeImpl")) //
 				&& !(candidate.getSimpleName().equals("setBounds") && candidate.getDeclaringType().getSimpleName().equals("CtTypeParameterReferenceImpl")) //
 				&& !(candidate.getSimpleName().equals("setSuperclass") && candidate.getDeclaringType().getSimpleName().equals("CtTypeImpl")) //
+				&& !(candidate.getSimpleName().startsWith("addField") && candidate.getDeclaringType().getSimpleName().equals("CtTypeImpl")) //
+				&& !(candidate.getSimpleName().equals("setFields") && candidate.getDeclaringType().getSimpleName().equals("CtTypeImpl")) //
+				&& !(candidate.getSimpleName().equals("addMethod") && candidate.getDeclaringType().getSimpleName().equals("CtTypeImpl")) //
+				&& !(candidate.getSimpleName().equals("setMethods") && candidate.getDeclaringType().getSimpleName().equals("CtTypeImpl")) //
+				&& !(candidate.getSimpleName().equals("addNestedType") && candidate.getDeclaringType().getSimpleName().equals("CtTypeImpl")) //
+				&& !(candidate.getSimpleName().equals("setNestedTypes") && candidate.getDeclaringType().getSimpleName().equals("CtTypeImpl")) //
+				&& !(candidate.getSimpleName().equals("addConstructor") && candidate.getDeclaringType().getSimpleName().equals("CtClassImpl")) //
+				&& !(candidate.getSimpleName().equals("setConstructors") && candidate.getDeclaringType().getSimpleName().equals("CtClassImpl")) //
+				&& !(candidate.getSimpleName().equals("addAnonymousExecutable") && candidate.getDeclaringType().getSimpleName().equals("CtClassImpl")) //
+				&& !(candidate.getSimpleName().equals("setAnonymousExecutables") && candidate.getDeclaringType().getSimpleName().equals("CtClassImpl")) //
 				&& !candidate.getSimpleName().equals("setDeclaration");
 	}
 }
diff --git a/src/test/java/spoon/test/field/FieldTest.java b/src/test/java/spoon/test/field/FieldTest.java
index 930c7c2d0..9ba8d582a 100644
--- a/src/test/java/spoon/test/field/FieldTest.java
+++ b/src/test/java/spoon/test/field/FieldTest.java
@@ -19,12 +19,9 @@ package spoon.test.field;
 
 import org.junit.Test;
 import spoon.reflect.declaration.CtClass;
-import spoon.reflect.declaration.CtElement;
 import spoon.reflect.declaration.CtField;
 import spoon.reflect.declaration.ModifierKind;
 import spoon.reflect.factory.Factory;
-import spoon.support.reflect.cu.CtLineElementComparator;
-import spoon.support.util.SortedList;
 import spoon.test.field.testclasses.AddFieldAtTop;
 
 import java.io.File;
@@ -75,12 +72,9 @@ public class FieldTest {
 
 		assertEquals(3, aClass.getFields().size());
 		// For now, DefaultJavaPrettyPrinter sorts elements according to their position.
-		final SortedList<CtElement> sorted = new SortedList<CtElement>(new CtLineElementComparator());
-		sorted.addAll(aClass.getFields());
-		sorted.addAll(aClass.getAnonymousExecutables());
-		assertEquals(generated, sorted.get(0));
-		assertEquals(generated2, sorted.get(1));
-		assertEquals(aClass.getAnonymousExecutables().get(0), sorted.get(2));
+		assertEquals(generated2, aClass.getTypeMembers().get(0));
+		assertEquals(generated, aClass.getTypeMembers().get(1));
+		assertEquals(aClass.getAnonymousExecutables().get(0), aClass.getTypeMembers().get(3));
 
 		assertThat(aClass).isEqualTo(build(new File("./src/test/resources/expected/AddFieldAtTop.java")).Type().get("AddFieldAtTop"));
 	}
diff --git a/src/test/java/spoon/test/generics/GenericsTest.java b/src/test/java/spoon/test/generics/GenericsTest.java
index c1b8c42cc..18c764968 100644
--- a/src/test/java/spoon/test/generics/GenericsTest.java
+++ b/src/test/java/spoon/test/generics/GenericsTest.java
@@ -474,17 +474,17 @@ public class GenericsTest {
 		assertEquals(3, elements.size());
 
 		// Constructor call.
-		assertEquals(0, elements.get(0).getExecutable().getType().getActualTypeArguments().size());
+		assertEquals(0, elements.get(1).getExecutable().getType().getActualTypeArguments().size());
+		assertNotNull(elements.get(1).getType().getDeclaringType());
+		assertEquals("new Pozole()", elements.get(1).toString());
+		assertEquals(2, elements.get(0).getExecutable().getType().getActualTypeArguments().size());
 		assertNotNull(elements.get(0).getType().getDeclaringType());
-		assertEquals("new Pozole()", elements.get(0).toString());
-		assertEquals(2, elements.get(2).getExecutable().getType().getActualTypeArguments().size());
-		assertNotNull(elements.get(2).getType().getDeclaringType());
-		assertEquals("new Burritos<K, V>()", elements.get(2).toString());
+		assertEquals("new Burritos<K, V>()", elements.get(0).toString());
 
 		// New class.
-		assertEquals(2, elements.get(1).getExecutable().getType().getActualTypeArguments().size());
-		assertNotNull(elements.get(1).getType().getDeclaringType());
-		assertEquals("new Burritos<K, V>() {}", elements.get(1).toString());
+		assertEquals(2, elements.get(2).getExecutable().getType().getActualTypeArguments().size());
+		assertNotNull(elements.get(2).getType().getDeclaringType());
+		assertEquals("new Burritos<K, V>() {}", elements.get(2).toString());
 	}
 
 	@Test
diff --git a/src/test/java/spoon/test/literal/LiteralTest.java b/src/test/java/spoon/test/literal/LiteralTest.java
index f96cdb579..bbd534007 100644
--- a/src/test/java/spoon/test/literal/LiteralTest.java
+++ b/src/test/java/spoon/test/literal/LiteralTest.java
@@ -8,6 +8,8 @@ import spoon.reflect.factory.CodeFactory;
 import spoon.reflect.factory.Factory;
 import spoon.reflect.visitor.filter.TypeFilter;
 
+import java.util.List;
+
 import static org.junit.Assert.assertEquals;
 import static spoon.testing.utils.ModelUtils.canBeBuilt;
 
@@ -21,12 +23,13 @@ public class LiteralTest {
 		launcher.run();
 
 		final CtClass<Object> aClass = launcher.getFactory().Class().get("org.apache.cassandra.index.SecondaryIndexManager");
-		final CtLiteral<Character> charLiteral = aClass.getElements(new TypeFilter<CtLiteral<Character>>(CtLiteral.class) {
+		final List<CtLiteral<Character>> elements = aClass.getElements(new TypeFilter<CtLiteral<Character>>(CtLiteral.class) {
 			@Override
 			public boolean matches(CtLiteral element) {
 				return element.getValue() instanceof Character && super.matches(element);
 			}
-		}).get(0);
+		});
+		final CtLiteral<Character> charLiteral = elements.get(1);
 
 		assertEquals(':', (char) charLiteral.getValue());
 		canBeBuilt("./target/literal", 8, true);
diff --git a/src/test/java/spoon/test/main/MainTest.java b/src/test/java/spoon/test/main/MainTest.java
index 3c5318a30..15f21f5b5 100644
--- a/src/test/java/spoon/test/main/MainTest.java
+++ b/src/test/java/spoon/test/main/MainTest.java
@@ -313,7 +313,7 @@ public class MainTest {
 	}
 
 	private void checkParentConsistency(CtPackage pack) {
-		Set<CtElement> inconsistentParents = new HashSet<>();
+		final Set<CtElement> inconsistentParents = new HashSet<>();
 		new CtScanner() {
 			private Deque<CtElement> previous = new ArrayDeque();
 			@Override
diff --git a/src/test/java/spoon/test/path/PathTest.java b/src/test/java/spoon/test/path/PathTest.java
index a3383aea7..176823970 100644
--- a/src/test/java/spoon/test/path/PathTest.java
+++ b/src/test/java/spoon/test/path/PathTest.java
@@ -18,8 +18,11 @@ import spoon.reflect.path.CtPathStringBuilder;
 
 import java.util.Arrays;
 import java.util.Collection;
+import java.util.Set;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
 
 /**
  * Created by nicolas on 10/06/2015.
@@ -45,18 +48,24 @@ public class PathTest {
 		assertArrayEquals(elements, result.toArray(new CtElement[0]));
 	}
 
+	private void equalsSet(CtPath path, Set<? extends CtElement> elements) {
+		Collection<CtElement> result = path.evaluateOn(Arrays.asList(factory.Package().getRootPackage()));
+		assertEquals(elements.size(), result.size());
+		assertTrue(result.containsAll(elements));
+	}
+
 	@Test
 	public void testBuilderMethod() throws Exception {
-		equals(
+		equalsSet(
 				new CtPathBuilder().name("spoon").name("test").name("path").name("Foo").type(CtMethod.class).build(),
 
-				factory.Type().get("spoon.test.path.Foo").getMethods().toArray(new CtMethod[0])
+				factory.Type().get("spoon.test.path.Foo").getMethods()
 		);
 
-		equals(
+		equalsSet(
 				new CtPathStringBuilder().fromString(".spoon.test.path.Foo/CtMethod"),
 
-				factory.Type().get("spoon.test.path.Foo").getMethods().toArray(new CtMethod[0])
+				factory.Type().get("spoon.test.path.Foo").getMethods()
 		);
 	}
 
diff --git a/src/test/java/spoon/test/prettyprinter/DefaultPrettyPrinterTest.java b/src/test/java/spoon/test/prettyprinter/DefaultPrettyPrinterTest.java
index 87310a797..d581597ae 100644
--- a/src/test/java/spoon/test/prettyprinter/DefaultPrettyPrinterTest.java
+++ b/src/test/java/spoon/test/prettyprinter/DefaultPrettyPrinterTest.java
@@ -208,12 +208,13 @@ public class DefaultPrettyPrinterTest {
 		expected =
 			"public enum ENUM {" +nl+
 			"E1(spoon.test.prettyprinter.testclasses.sub.TypeIdentifierCollision.globalField,spoon.test.prettyprinter.testclasses.sub.TypeIdentifierCollision.ENUM.E1);" +nl+
-			"    final int NUM;" +nl+
-			"    final Enum<?> e;" +nl+
+			"    final int NUM;" +nl+nl+
+			"    final Enum<?> e;" +nl+nl+
 			"    private ENUM(int num, Enum<?> e) {" +nl+
 			"        NUM = num;" +nl+
 			"        this.e = e;" +nl+
-			"    }}"
+			"    }" +nl+
+			"}"
 		;
 		computed = aClass.getNestedType("ENUM").toString();
 		assertEquals( "Parameters in an enum constructor should be fully typed when they refer to externally defined static field of a class with the same identifier as another locally defined type", expected, computed );
diff --git a/src/test/java/spoon/test/secondaryclasses/ClassesTest.java b/src/test/java/spoon/test/secondaryclasses/ClassesTest.java
index f4091643c..c4212502c 100644
--- a/src/test/java/spoon/test/secondaryclasses/ClassesTest.java
+++ b/src/test/java/spoon/test/secondaryclasses/ClassesTest.java
@@ -108,8 +108,8 @@ public class ClassesTest {
 		assertTrue(anonymousClass.get(0).isAnonymous());
 		assertTrue(anonymousClass.get(1).isAnonymous());
 		assertEquals(2, anonymousClass.size());
-		assertEquals("spoon.test.secondaryclasses.AnonymousClass$2", anonymousClass.get(0).getQualifiedName());
-		assertEquals("spoon.test.secondaryclasses.AnonymousClass$1", anonymousClass.get(1).getQualifiedName());
+		assertEquals("spoon.test.secondaryclasses.AnonymousClass$1", anonymousClass.get(0).getQualifiedName());
+		assertEquals("spoon.test.secondaryclasses.AnonymousClass$2", anonymousClass.get(1).getQualifiedName());
 	}
 
 	@Test
diff --git a/src/test/resources/expected/AddFieldAtTop.java b/src/test/resources/expected/AddFieldAtTop.java
index 07c02356b..6d3cf2ec7 100644
--- a/src/test/resources/expected/AddFieldAtTop.java
+++ b/src/test/resources/expected/AddFieldAtTop.java
@@ -1,14 +1,16 @@
 public class AddFieldAtTop {
+    java.lang.String generated2;
+
+    java.lang.String generated;
+
+    public AddFieldAtTop() {
+    }
 
     static {
     }
 
     int i;
 
-    java.lang.String generated;
-
-    java.lang.String generated2;
-
     void m() {
     }
 }
\ No newline at end of file
