diff --git a/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java b/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
index 0c4c5e260..07b3e6ed7 100644
--- a/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
+++ b/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
@@ -20,6 +20,7 @@ package spoon.support.compiler.jdt;
 import static spoon.reflect.ModelElementContainerDefaultCapacities.CASTS_CONTAINER_DEFAULT_CAPACITY;
 
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collection;
 import java.util.EnumSet;
 import java.util.List;
@@ -132,12 +133,14 @@ import org.eclipse.jdt.internal.compiler.lookup.ElementValuePair;
 import org.eclipse.jdt.internal.compiler.lookup.FieldBinding;
 import org.eclipse.jdt.internal.compiler.lookup.LocalTypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.LocalVariableBinding;
+import org.eclipse.jdt.internal.compiler.lookup.MemberTypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.MethodBinding;
 import org.eclipse.jdt.internal.compiler.lookup.MethodScope;
 import org.eclipse.jdt.internal.compiler.lookup.PackageBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ProblemReferenceBinding;
 import org.eclipse.jdt.internal.compiler.lookup.RawTypeBinding;
+import org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;
 import org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding;
@@ -570,6 +573,10 @@ public class JDTTreeBuilder extends ASTVisitor {
 				// Spoon is able to analyze also without the classpath
 				ref = factory.Core().createTypeReference();
 				ref.setSimpleName(new String(binding.readableName()));
+			} else if(binding instanceof SpoonReferenceBinding) {
+				ref = factory.Core().createTypeReference();
+				ref.setSimpleName(new String(binding.sourceName()));
+				ref.setDeclaringType(getTypeReference(binding.enclosingType()));
 			} else {
 				throw new RuntimeException("Unknown TypeBinding: "
 						+ binding.getClass() + " " + binding);
@@ -852,8 +859,32 @@ public class JDTTreeBuilder extends ASTVisitor {
 			type = interf;
 		} else {
 			CtClass<?> cl = factory.Core().createClass();
+			if (typeDeclaration.superclass != null &&
+					typeDeclaration.superclass.resolvedType != null &&
+					!new String(typeDeclaration.superclass.resolvedType.qualifiedPackageName()).equals(new String(typeDeclaration.binding.qualifiedPackageName()))) {
+
+				// Sorry for this hack but see the test case ImportTest#testImportOfAnInnerClassInASuperClassPackage.
+				// JDT isn't smart enough to return me a super class available. So, I modify their AST when
+				// superclasses aren't in the same package and when their visibilities are "default".
+				List<ModifierKind> modifiers = Arrays.asList(ModifierKind.PUBLIC, ModifierKind.PROTECTED);
+				final TypeBinding resolvedType = typeDeclaration.superclass.resolvedType;
+				if (resolvedType instanceof MemberTypeBinding &&
+						resolvedType.enclosingType() != null &&
+						!getModifiers(resolvedType.enclosingType().modifiers).containsAll(modifiers)) {
+					typeDeclaration.superclass.resolvedType = new SpoonReferenceBinding(
+							typeDeclaration.superclass.resolvedType.sourceName(),
+							(ReferenceBinding) typeDeclaration.enclosingType.superclass.resolvedType);
+				} else if (resolvedType instanceof BinaryTypeBinding &&
+						resolvedType.enclosingType() != null &&
+						!getModifiers(resolvedType.enclosingType().modifiers).containsAll(modifiers)) {
+					typeDeclaration.superclass.resolvedType = new SpoonReferenceBinding(
+							typeDeclaration.superclass.resolvedType.sourceName(),
+							(ReferenceBinding) typeDeclaration.enclosingType.superclass.resolvedType);
+				}
+			}
 			if (typeDeclaration.superclass != null) {
-				cl.setSuperclass(references.getTypeReference(typeDeclaration.superclass.resolvedType));
+				cl.setSuperclass(
+						references.getTypeReference(typeDeclaration.superclass.resolvedType));
 			}
 
 			// If the current class is an anonymous class with a super interface and generic types, we add generic types
@@ -900,6 +931,20 @@ public class JDTTreeBuilder extends ASTVisitor {
 		return type;
 	}
 
+	class SpoonReferenceBinding extends ReferenceBinding {
+		private ReferenceBinding enclosingType;
+
+		public SpoonReferenceBinding(char[] sourceName, ReferenceBinding enclosingType) {
+			this.sourceName = sourceName;
+			this.enclosingType = enclosingType;
+		}
+
+		@Override
+		public ReferenceBinding enclosingType() {
+			return enclosingType;
+		}
+	}
+
 	private String computeAnonymousName(SourceTypeBinding binding) {
 		final String poolName = String.valueOf(binding.constantPoolName());
 		final int lastIndexSeparator = poolName.lastIndexOf(CtType.INNERTTYPE_SEPARATOR);
diff --git a/src/test/java/spoon/test/imports/ImportTest.java b/src/test/java/spoon/test/imports/ImportTest.java
index 3e05a3cd4..0aeeab0c4 100644
--- a/src/test/java/spoon/test/imports/ImportTest.java
+++ b/src/test/java/spoon/test/imports/ImportTest.java
@@ -9,8 +9,10 @@ import org.junit.Test;
 
 import spoon.Launcher;
 import spoon.compiler.SpoonCompiler;
+import spoon.compiler.SpoonResource;
 import spoon.compiler.SpoonResourceHelper;
 import spoon.reflect.code.CtConstructorCall;
+import spoon.reflect.code.CtInvocation;
 import spoon.reflect.declaration.CtClass;
 import spoon.reflect.declaration.CtMethod;
 import spoon.reflect.declaration.CtType;
@@ -18,13 +20,12 @@ import spoon.reflect.factory.Factory;
 import spoon.reflect.visitor.Query;
 import spoon.reflect.visitor.filter.AbstractFilter;
 import spoon.reflect.visitor.filter.NameFilter;
+import spoon.reflect.visitor.filter.TypeFilter;
 import spoon.test.imports.testclasses.SubClass;
 
 public class ImportTest {
 
-	// TODO This test is ignored because we have proposed a wrong fix for the issue #114 on GitHub.
 	@Test
-	@Ignore
 	public void testImportOfAnInnerClassInASuperClassPackage() throws Exception {
 		Launcher spoon = new Launcher();
 		Factory factory = spoon.createFactory();
@@ -48,6 +49,27 @@ public class ImportTest {
 		assertEquals(expected, innerClass.getSuperclass().toString());
 	}
 
+	@Test
+	public void testImportOfAnInnerClassInASuperClassAvailableInLibrary() throws Exception {
+		SpoonCompiler comp = new Launcher().createCompiler();
+		List<SpoonResource> fileToBeSpooned = SpoonResourceHelper.resources("./src/test/resources/visibility/YamlRepresenter.java");
+		assertEquals(1, fileToBeSpooned.size());
+		comp.addInputSources(fileToBeSpooned);
+		List<SpoonResource> classpath = SpoonResourceHelper.resources("./src/test/resources/visibility/snakeyaml-1.9.jar");
+		assertEquals(1, classpath.size());
+		comp.setSourceClasspath(classpath.get(0).getPath());
+		comp.build();
+		Factory factory = comp.getFactory();
+		CtType<?> theClass = factory.Type().get("visibility.YamlRepresenter");
+
+		final CtClass<?> innerClass = theClass.getNestedType("RepresentConfigurationSection");
+		String expected = "visibility.YamlRepresenter.RepresentConfigurationSection";
+		assertEquals(expected, innerClass.getReference().toString());
+
+		expected = "org.yaml.snakeyaml.representer.Representer.RepresentMap";
+		assertEquals(expected, innerClass.getSuperclass().toString());
+	}
+
 	@Test
 	public void testImportOfAnInnerClassInAClassPackage() throws Exception {
 		Launcher spoon = new Launcher();
diff --git a/src/test/resources/visibility/YamlRepresenter.java b/src/test/resources/visibility/YamlRepresenter.java
new file mode 100644
index 000000000..77d79ca32
--- /dev/null
+++ b/src/test/resources/visibility/YamlRepresenter.java
@@ -0,0 +1,17 @@
+package visibility;
+
+import org.yaml.snakeyaml.nodes.Node;
+import org.yaml.snakeyaml.representer.Representer;
+
+public class YamlRepresenter extends Representer {
+
+    public YamlRepresenter() {
+    }
+
+    private class RepresentConfigurationSection extends RepresentMap {
+        @Override
+        public Node representData(Object data) {
+            return null;
+        }
+    }
+}
diff --git a/src/test/resources/visibility/snakeyaml-1.9.jar b/src/test/resources/visibility/snakeyaml-1.9.jar
new file mode 100644
index 000000000..7e24a71b9
Binary files /dev/null and b/src/test/resources/visibility/snakeyaml-1.9.jar differ
