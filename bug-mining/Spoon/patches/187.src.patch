diff --git a/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java b/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java
index 267dabc5b..a1f2deb1c 100644
--- a/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java
+++ b/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java
@@ -139,10 +139,56 @@ public class DefaultJavaPrettyPrinter implements CtVisitor, PrettyPrinter {
 	 */
 	public static final String LINE_SEPARATOR = System.getProperty("line.separator");
 
+	protected static class TypeContext {
+		CtTypeReference<?> type;
+		Set<String> memberNames;
+
+		TypeContext(CtTypeReference<?> p_type) {
+			type = p_type;
+		}
+
+		public boolean isNameConflict(String name) {
+			if (memberNames == null) {
+				Collection<CtFieldReference<?>> allFields = type.getAllFields();
+				memberNames = new HashSet<>(allFields.size());
+				for (CtFieldReference<?> field : allFields) {
+					memberNames.add(field.getSimpleName());
+				}
+			}
+			return memberNames.contains(name);
+		}
+
+		public String getSimpleName() {
+			return type.getSimpleName();
+		}
+
+		public CtPackageReference getPackage() {
+			return type.getPackage();
+		}
+	}
+
 	public class PrintingContext {
 		boolean noTypeDecl = false;
 
-		Deque<CtTypeReference<?>> currentThis = new ArrayDeque<>();
+		Deque<TypeContext> currentThis = new ArrayDeque<>();
+
+		public CtTypeReference<?> getCurrentTypeReference() {
+			if (context.currentTopLevel != null) {
+				if (currentThis != null && currentThis.size() > 0) {
+					return currentThis.peekFirst().type;
+				}
+				return context.currentTopLevel.getReference();
+			}
+			return null;
+		}
+
+		public void pushCurrentThis(CtTypeReference<?> type) {
+			currentThis.push(new TypeContext(type));
+		}
+		public void popCurrentThis() {
+			currentThis.pop();
+		}
+
 
 		Deque<CtElement> elementStack = new ArrayDeque<>();
 
@@ -510,7 +556,7 @@ public class DefaultJavaPrettyPrinter implements CtVisitor, PrettyPrinter {
 
 	@Override
 	public <T> void visitCtClass(CtClass<T> ctClass) {
-		context.currentThis.push(ctClass.getReference());
+		context.pushCurrentThis(ctClass.getReference());
 
 		if (ctClass.getSimpleName() != null && !CtType.NAME_UNKNOWN.equals(ctClass.getSimpleName()) && !ctClass.isAnonymous()) {
 			visitCtType(ctClass);
@@ -529,7 +575,7 @@ public class DefaultJavaPrettyPrinter implements CtVisitor, PrettyPrinter {
 		printer.write(" {").incTab();
 		elementPrinterHelper.writeElementList(ctClass.getTypeMembers());
 		printer.decTab().writeTabs().write("}");
-		context.currentThis.pop();
+		context.popCurrentThis();
 	}
 
 	@Override
@@ -634,7 +680,7 @@ public class DefaultJavaPrettyPrinter implements CtVisitor, PrettyPrinter {
 		visitCtType(ctEnum);
 		printer.write("enum " + ctEnum.getSimpleName());
 		elementPrinterHelper.writeImplementsClause(ctEnum);
-		context.currentThis.push(ctEnum.getReference());
+		context.pushCurrentThis(ctEnum.getReference());
 		printer.write(" {").incTab().writeln();
 
 		if (ctEnum.getEnumValues().size() == 0) {
@@ -650,7 +696,7 @@ public class DefaultJavaPrettyPrinter implements CtVisitor, PrettyPrinter {
 
 		elementPrinterHelper.writeElementList(ctEnum.getTypeMembers());
 		printer.decTab().writeTabs().write("}");
-		context.currentThis.pop();
+		context.popCurrentThis();
 	}
 
 	@Override
@@ -891,13 +937,8 @@ public class DefaultJavaPrettyPrinter implements CtVisitor, PrettyPrinter {
 
 		if (reference.isFinal() && reference.isStatic()) {
 			CtTypeReference<?> declTypeRef = reference.getDeclaringType();
-			if (context.currentTopLevel != null) {
-				CtTypeReference<?> ref2;
-				if (context.currentThis != null && context.currentThis.size() > 0) {
-					ref2 = context.currentThis.peekFirst();
-				} else {
-					ref2 = context.currentTopLevel.getReference();
-				}
+			CtTypeReference<?> ref2 = context.getCurrentTypeReference();
+			if (ref2 != null) {
 				// print type if not anonymous class ref and not within the
 				// current scope
 				printType = !"".equals(declTypeRef.getSimpleName()) && !(declTypeRef.equals(ref2));
@@ -1556,11 +1597,16 @@ public class DefaultJavaPrettyPrinter implements CtVisitor, PrettyPrinter {
 
 	private boolean printQualified(CtTypeReference<?> ref) {
 		if (importsContext.isImported(ref)) {
-			// If my.pkg.Something is imported, but we are in the context of a class which is
-			// also called "Something", we should still use qualified version my.pkg.Something
-			for (CtTypeReference<?> enclosingClassRef : context.currentThis) {
-				if (enclosingClassRef.getSimpleName().equals(ref.getSimpleName())
-						&& !Objects.equals(enclosingClassRef.getPackage(), ref.getPackage())) {
+			// If my.pkg.Something is imported, but
+			//A) we are in the context of a class which is also called "Something",
+			//B) we are in the context of a class which defines field which is also called "Something",
+			//	we should still use qualified version my.pkg.Something
+			for (TypeContext typeContext : context.currentThis) {
+				if (typeContext.getSimpleName().equals(ref.getSimpleName())
+						&& !Objects.equals(typeContext.getPackage(), ref.getPackage())) {
+					return true;
+				}
+				if (typeContext.isNameConflict(ref.getSimpleName())) {
 					return true;
 				}
 			}
@@ -1570,6 +1616,7 @@ public class DefaultJavaPrettyPrinter implements CtVisitor, PrettyPrinter {
 		}
 	}
 
+
 	@Override
 	public <T> void visitCtIntersectionTypeReference(CtIntersectionTypeReference<T> reference) {
 		for (CtTypeReference<?> bound : reference.getBounds()) {
diff --git a/src/main/java/spoon/support/compiler/SnippetCompilationHelper.java b/src/main/java/spoon/support/compiler/SnippetCompilationHelper.java
index 666b05787..e81ec5550 100644
--- a/src/main/java/spoon/support/compiler/SnippetCompilationHelper.java
+++ b/src/main/java/spoon/support/compiler/SnippetCompilationHelper.java
@@ -73,9 +73,9 @@ public class SnippetCompilationHelper {
 	private static CtStatement internalCompileStatement(CtElement st, CtTypeReference returnType) {
 		Factory f = st.getFactory();
 
-		CtClass<?> w = createWrapper(st, f, returnType);
+		String contents = createWrapperContent(st, f, returnType);
 
-		build(f, w);
+		build(f, contents);
 
 		CtType<?> c = f.Type().get(WRAPPER_CLASS_NAME);
 
@@ -107,13 +107,6 @@ public class SnippetCompilationHelper {
 		return ret.getReturnedExpression();
 	}
 
-	private static void build(Factory f, CtType<?> w) {
-
-		String contents = w.toString();
-
-		build(f, contents);
-	}
-
 	private static void build(Factory f, String contents) {
 		// Build contents
 		SpoonCompiler builder = new JDTSnippetCompiler(f, contents);
@@ -124,14 +117,11 @@ public class SnippetCompilationHelper {
 		}
 	}
 
-	private static CtClass<?> createWrapper(final CtElement element, final Factory f, final CtTypeReference returnType) {
+	private static String createWrapperContent(final CtElement element, final Factory f, final CtTypeReference returnType) {
 		CtClass<?> w = f.Class().create(WRAPPER_CLASS_NAME);
 
-		// Clean up (delete wrapper from factory)
-		w.getPackage().getTypes().remove(w);
-
 		CtBlock body = f.Core().createBlock();
-;
+
 		if (element instanceof CtStatement) {
 			body.addStatement((CtStatement) element);
 		} else if (element instanceof CtExpression) {
@@ -153,7 +143,11 @@ public class SnippetCompilationHelper {
 				thrownTypes,
 				body);
 
-		return w;
+		String contents = w.toString();
+		// Clean up (delete wrapper from factory) after it is printed. The DefaultJavaPrettyPrinter needs w in model to be able to print it correctly
+		w.getPackage().getTypes().remove(w);
+
+		return contents;
 	}
 
 }
diff --git a/src/main/java/spoon/support/reflect/declaration/CtTypeImpl.java b/src/main/java/spoon/support/reflect/declaration/CtTypeImpl.java
index f390b4457..dec319e87 100644
--- a/src/main/java/spoon/support/reflect/declaration/CtTypeImpl.java
+++ b/src/main/java/spoon/support/reflect/declaration/CtTypeImpl.java
@@ -510,6 +510,10 @@ public abstract class CtTypeImpl<T> extends CtNamedElementImpl implements CtType
 			if (st != null) {
 				fields.addAll(st.getAllFields());
 			}
+			Set<CtTypeReference<?>> superIFaces = ((CtClass<?>) this).getSuperInterfaces();
+			for (CtTypeReference<?> superIFace : superIFaces) {
+				fields.addAll(superIFace.getAllFields());
+			}
 		}
 		return fields;
 	}
diff --git a/src/main/java/spoon/support/reflect/reference/CtTypeReferenceImpl.java b/src/main/java/spoon/support/reflect/reference/CtTypeReferenceImpl.java
index 21eae0c20..3ac1b9439 100644
--- a/src/main/java/spoon/support/reflect/reference/CtTypeReferenceImpl.java
+++ b/src/main/java/spoon/support/reflect/reference/CtTypeReferenceImpl.java
@@ -472,15 +472,23 @@ public class CtTypeReferenceImpl<T> extends CtReferenceImpl implements CtTypeRef
 
 	@Override
 	public Collection<CtFieldReference<?>> getAllFields() {
-		CtType<?> t = getDeclaration();
-		if (t == null) {
-			try {
-				return RtHelper.getAllFields(getActualClass(), getFactory());
-			} catch (SpoonClassNotFoundException cnfe) {
-				return handleParentNotFound(cnfe);
-			}
-		} else {
+		try {
+			CtType<?> t = getTypeDeclaration();
 			return t.getAllFields();
+		} catch (SpoonClassNotFoundException cnfe) {
+			//START OF Hack of Hack in JDTTreeBuilderHelper.createType(...)
+			CtTypeReference<?> declaringTypeRef = this.getDeclaringType();
+			if (declaringTypeRef != null) {
+				CtType<?> declaringType = declaringTypeRef.getDeclaration();
+				if (declaringType != null && declaringType.getNestedType(getSimpleName()) == null) {
+					//this type does not know it's real fully qualified name, so we cannot access it's java class.
+					//See the spoon.test.imports.ImportTest, whose class spoon.test.imports.testclasses.internal.SuperClass$InnerClassProtected is this case
+					Launcher.LOGGER.warn("cannot load class with access path: " + getQualifiedName());
+					return Collections.emptyList();
+				}
+			}
+			//END OF Hack
+			return handleParentNotFound(cnfe);
 		}
 	}
 
diff --git a/src/main/java/spoon/support/util/RtHelper.java b/src/main/java/spoon/support/util/RtHelper.java
index 540f9d5de..5c7f9aeb9 100644
--- a/src/main/java/spoon/support/util/RtHelper.java
+++ b/src/main/java/spoon/support/util/RtHelper.java
@@ -46,19 +46,25 @@ public abstract class RtHelper {
 
 	/**
 	 * Gets all the runtime fields for a given class (including the
-	 * superclasses').
+	 * superclasses and superinterfaces).
 	 */
 	public static Field[] getAllFields(Class<?> c) {
 		List<Field> fields = new ArrayList<>();
-		while (c != null && c != Object.class) {
+		addAllFields(c, fields);
+		Field[] result = new Field[fields.size()];
+		return fields.toArray(result);
+	}
+
+	private static void addAllFields(Class<?> c, List<Field> fields) {
+		if (c != null && c != Object.class) {
 			for (Field f : c.getDeclaredFields()) {
 				fields.add(f);
 			}
-			// fields.addAll(Arrays.asList(c.getDeclaredFields()));
-			c = c.getSuperclass();
+			addAllFields(c.getSuperclass(), fields);
+			for (Class<?> iface : c.getInterfaces()) {
+				addAllFields(iface, fields);
+			}
 		}
-		Field[] result = new Field[fields.size()];
-		return fields.toArray(result);
 	}
 
 	/**
diff --git a/src/test/java/spoon/test/staticFieldAccess2/ALong.java b/src/test/java/spoon/test/staticFieldAccess2/ALong.java
new file mode 100644
index 000000000..c18b3e4f7
--- /dev/null
+++ b/src/test/java/spoon/test/staticFieldAccess2/ALong.java
@@ -0,0 +1,6 @@
+package spoon.test.staticFieldAccess2;
+
+public @interface ALong
+{
+	public long number() default 7;
+}
diff --git a/src/test/java/spoon/test/staticFieldAccess2/AmbiguousImplicitFieldReference.java b/src/test/java/spoon/test/staticFieldAccess2/AmbiguousImplicitFieldReference.java
new file mode 100644
index 000000000..b28894792
--- /dev/null
+++ b/src/test/java/spoon/test/staticFieldAccess2/AmbiguousImplicitFieldReference.java
@@ -0,0 +1,25 @@
+package spoon.test.staticFieldAccess2;
+
+public class AmbiguousImplicitFieldReference {
+	/*
+	 * The static field has exactly same name like the Class name.
+	 * for example Apache CXF generates classes like that  
+	 */
+	public static String AmbiguousImplicitFieldReference = "c1";
+	public String memberField;
+
+	public String getMemberField() {
+		return memberField;
+	}
+
+	public void setMemberField(String p_memberField) {
+		memberField = p_memberField;
+	}
+	public void setMemberField2(String memberField) {
+		this.memberField = memberField;
+	}
+	
+	public void testLocalMethodInvocations() {
+		getMemberField();
+	}
+}
diff --git a/src/test/java/spoon/test/staticFieldAccess2/ChildOfConstants.java b/src/test/java/spoon/test/staticFieldAccess2/ChildOfConstants.java
new file mode 100644
index 000000000..4e3f7e419
--- /dev/null
+++ b/src/test/java/spoon/test/staticFieldAccess2/ChildOfConstants.java
@@ -0,0 +1,9 @@
+package spoon.test.staticFieldAccess2;
+
+//the PRIO must be prefixed by Constants because we are not yet in scope of Constants class 
+@ALong(number = Constants.PRIO)
+public class ChildOfConstants extends Constants
+{
+	long p1 = Constants.PRIO;
+	long p2 = PRIO;
+}
diff --git a/src/test/java/spoon/test/staticFieldAccess2/ChildOfGenericsWithAmbiguousStaticField.java b/src/test/java/spoon/test/staticFieldAccess2/ChildOfGenericsWithAmbiguousStaticField.java
new file mode 100644
index 000000000..46256b49a
--- /dev/null
+++ b/src/test/java/spoon/test/staticFieldAccess2/ChildOfGenericsWithAmbiguousStaticField.java
@@ -0,0 +1,11 @@
+package spoon.test.staticFieldAccess2;
+
+public class ChildOfGenericsWithAmbiguousStaticField extends GenericsWithAmbiguousStaticField
+{
+
+    public <V, C extends java.util.List<V>> void m1() {
+    	spoon.test.staticFieldAccess2.GenericsWithAmbiguousStaticField.<V, C>genericMethod();
+    	genericMethod();
+    }
+
+}
diff --git a/src/test/java/spoon/test/staticFieldAccess2/Constants.java b/src/test/java/spoon/test/staticFieldAccess2/Constants.java
new file mode 100644
index 000000000..4abc9240c
--- /dev/null
+++ b/src/test/java/spoon/test/staticFieldAccess2/Constants.java
@@ -0,0 +1,6 @@
+package spoon.test.staticFieldAccess2;
+
+public class Constants
+{
+	public static final long PRIO = 1;
+}
diff --git a/src/test/java/spoon/test/staticFieldAccess2/GenericsWithAmbiguousMemberField.java b/src/test/java/spoon/test/staticFieldAccess2/GenericsWithAmbiguousMemberField.java
new file mode 100644
index 000000000..f8fe860a8
--- /dev/null
+++ b/src/test/java/spoon/test/staticFieldAccess2/GenericsWithAmbiguousMemberField.java
@@ -0,0 +1,17 @@
+package spoon.test.staticFieldAccess2;
+
+public class GenericsWithAmbiguousMemberField {
+	
+	String GenericsWithAmbiguousMemberField = "x";
+
+    public <V, C extends java.util.List<V>> void m1() {
+    	spoon.test.staticFieldAccess2.GenericsWithAmbiguousMemberField.<V, C>genericMethod();
+    	GenericsWithAmbiguousMemberField.length();
+    	genericMethod();
+    }
+
+    public static <V, C extends java.util.List<V>> java.util.List<C> genericMethod() {
+        return null;
+    }
+	
+}
diff --git a/src/test/java/spoon/test/staticFieldAccess2/GenericsWithAmbiguousStaticField.java b/src/test/java/spoon/test/staticFieldAccess2/GenericsWithAmbiguousStaticField.java
new file mode 100644
index 000000000..a5fddb093
--- /dev/null
+++ b/src/test/java/spoon/test/staticFieldAccess2/GenericsWithAmbiguousStaticField.java
@@ -0,0 +1,16 @@
+package spoon.test.staticFieldAccess2;
+
+public class GenericsWithAmbiguousStaticField {
+	
+	static String GenericsWithAmbiguousStaticField = "x";
+
+    public <V, C extends java.util.List<V>> void m1() {
+    	spoon.test.staticFieldAccess2.GenericsWithAmbiguousStaticField.<V, C>genericMethod();
+    	genericMethod();
+    }
+
+    public static <V, C extends java.util.List<V>> java.util.List<C> genericMethod() {
+        return null;
+    }
+	
+}
diff --git a/src/test/java/spoon/test/staticFieldAccess2/ImplicitFieldReference.java b/src/test/java/spoon/test/staticFieldAccess2/ImplicitFieldReference.java
new file mode 100644
index 000000000..736469e71
--- /dev/null
+++ b/src/test/java/spoon/test/staticFieldAccess2/ImplicitFieldReference.java
@@ -0,0 +1,20 @@
+package spoon.test.staticFieldAccess2;
+
+public class ImplicitFieldReference {
+	public String memberField;
+
+	public String getMemberField() {
+		return memberField;
+	}
+
+	public void setMemberField(String p_memberField) {
+		memberField = p_memberField;
+	}
+	public void setMemberField2(String memberField) {
+		this.memberField = memberField;
+	}
+	
+	public void testLocalMethodInvocations() {
+		getMemberField();
+	}
+}
diff --git a/src/test/java/spoon/test/staticFieldAccess2/ImplicitStaticClassAccess.java b/src/test/java/spoon/test/staticFieldAccess2/ImplicitStaticClassAccess.java
new file mode 100644
index 000000000..445ec6ded
--- /dev/null
+++ b/src/test/java/spoon/test/staticFieldAccess2/ImplicitStaticClassAccess.java
@@ -0,0 +1,18 @@
+package spoon.test.staticFieldAccess2;
+
+public class ImplicitStaticClassAccess {
+	static String ImplicitStaticClassAccess = "";
+	
+	ImplicitStaticClassAccess() {
+		this(ImplicitStaticClassAccess.class);
+	}
+	
+	ImplicitStaticClassAccess(Class<?> clazz) {
+		ImplicitStaticClassAccess.class.getName();
+	}
+
+	public void testLocalMethodInvocations() {
+		ImplicitStaticClassAccess.class.getName();
+	}
+	
+}
diff --git a/src/test/java/spoon/test/staticFieldAccess2/ImplicitStaticFieldReference.java b/src/test/java/spoon/test/staticFieldAccess2/ImplicitStaticFieldReference.java
new file mode 100644
index 000000000..d803b3c4b
--- /dev/null
+++ b/src/test/java/spoon/test/staticFieldAccess2/ImplicitStaticFieldReference.java
@@ -0,0 +1,32 @@
+package spoon.test.staticFieldAccess2;
+
+
+public class ImplicitStaticFieldReference {
+	/*
+	 * The static field has exactly same name like the Class name.
+	 * for example Apache CXF generates classes like that  
+	 */
+	public static String ImplicitStaticFieldReference = "c1";
+	public static long staticField = Constants.PRIO;
+
+	public String reader() {
+		return ImplicitStaticFieldReference;
+	}
+	
+	public void writer(String value) {
+		ImplicitStaticFieldReference = value;
+	}
+	
+	public static long longReader() {
+		return staticField;
+	}
+	
+	public static void longWriter(long value) {
+		staticField = value;
+	}
+
+	public void testLocalMethodInvocations() {
+		reader();
+		longWriter(7);
+	}
+}
diff --git a/src/test/java/spoon/test/staticFieldAccess2/ImplicitStaticFieldReferenceTest.java b/src/test/java/spoon/test/staticFieldAccess2/ImplicitStaticFieldReferenceTest.java
new file mode 100644
index 000000000..9b4ef1b31
--- /dev/null
+++ b/src/test/java/spoon/test/staticFieldAccess2/ImplicitStaticFieldReferenceTest.java
@@ -0,0 +1,157 @@
+package spoon.test.staticFieldAccess2;
+
+import static spoon.testing.utils.ModelUtils.canBeBuilt;
+
+import static org.junit.Assert.*;
+import org.junit.Test;
+
+import spoon.Launcher;
+import spoon.reflect.declaration.CtClass;
+
+public class ImplicitStaticFieldReferenceTest
+{
+	private static final boolean expectImplicit = false;
+
+    @Test
+    public void testImplicitStaticFieldReference() throws Exception {
+    	Launcher launcher = checkFile(false, "ImplicitStaticFieldReference.java");
+    	if(expectImplicit) {
+        	CtClass<?> cls = launcher.getFactory().Class().get(ImplicitStaticFieldReference.class);
+        	assertEquals("return ImplicitStaticFieldReference", cls.getMethod("reader").getBody().getStatements().get(0).toString());
+        	assertEquals("ImplicitStaticFieldReference = value", cls.getMethodsByName("writer").get(0).getBody().getStatements().get(0).toString());
+        	assertEquals("reader()", cls.getMethodsByName("testLocalMethodInvocations").get(0).getBody().getStatements().get(0).toString());
+        	assertEquals("longWriter(7)", cls.getMethodsByName("testLocalMethodInvocations").get(0).getBody().getStatements().get(1).toString());
+    	}
+    }
+
+    @Test
+    public void testImplicitStaticFieldReferenceAutoImport() throws Exception {
+    	Launcher launcher = checkFile(true, "ImplicitStaticFieldReference.java");
+    	if(expectImplicit) {
+        	CtClass<?> cls = launcher.getFactory().Class().get(ImplicitStaticFieldReference.class);
+        	assertEquals("return ImplicitStaticFieldReference", cls.getMethod("reader").getBody().getStatements().get(0).toString());
+        	assertEquals("ImplicitStaticFieldReference = value", cls.getMethodsByName("writer").get(0).getBody().getStatements().get(0).toString());
+        	assertEquals("reader()", cls.getMethodsByName("testLocalMethodInvocations").get(0).getBody().getStatements().get(0).toString());
+        	assertEquals("longWriter(7)", cls.getMethodsByName("testLocalMethodInvocations").get(0).getBody().getStatements().get(1).toString());
+    	}
+    }
+
+    @Test
+    public void testImplicitFieldReference() throws Exception {
+    	Launcher launcher = checkFile(false, "ImplicitFieldReference.java");
+    	if(expectImplicit) {
+        	CtClass<?> cls = launcher.getFactory().Class().get(ImplicitFieldReference.class);
+        	assertEquals("return memberField", cls.getMethod("getMemberField").getBody().getStatements().get(0).toString());
+        	assertEquals("memberField = p_memberField", cls.getMethodsByName("setMemberField").get(0).getBody().getStatements().get(0).toString());
+//        	assertEquals("this.memberField = memberField", cls.getMethodsByName("setMemberField2").get(0).getBody().getStatements().get(0).toString());
+        	assertEquals("getMemberField()", cls.getMethodsByName("testLocalMethodInvocations").get(0).getBody().getStatements().get(0).toString());
+    	}
+    }
+    @Test
+    public void testImplicitFieldReferenceAutoImport() throws Exception {
+    	Launcher launcher = checkFile(true, "ImplicitFieldReference.java");
+    	if(expectImplicit) {
+        	CtClass<?> cls = launcher.getFactory().Class().get(ImplicitFieldReference.class);
+        	assertEquals("return memberField", cls.getMethod("getMemberField").getBody().getStatements().get(0).toString());
+        	assertEquals("memberField = p_memberField", cls.getMethodsByName("setMemberField").get(0).getBody().getStatements().get(0).toString());
+//        	assertEquals("this.memberField = memberField", cls.getMethodsByName("setMemberField2").get(0).getBody().getStatements().get(0).toString());
+        	assertEquals("getMemberField()", cls.getMethodsByName("testLocalMethodInvocations").get(0).getBody().getStatements().get(0).toString());
+    	}
+    }
+    
+    @Test
+    public void testAmbiguousImplicitFieldReference() throws Exception {
+    	Launcher launcher = checkFile(false, "AmbiguousImplicitFieldReference.java");
+    	if(expectImplicit) {
+        	CtClass<?> cls = launcher.getFactory().Class().get(AmbiguousImplicitFieldReference.class);
+        	assertEquals("return memberField", cls.getMethod("getMemberField").getBody().getStatements().get(0).toString());
+        	assertEquals("memberField = p_memberField", cls.getMethodsByName("setMemberField").get(0).getBody().getStatements().get(0).toString());
+//        	assertEquals("this.memberField = memberField", cls.getMethodsByName("setMemberField2").get(0).getBody().getStatements().get(0).toString());
+        	assertEquals("getMemberField()", cls.getMethodsByName("testLocalMethodInvocations").get(0).getBody().getStatements().get(0).toString());
+    	}
+    }
+    @Test
+    public void testAmbiguousImplicitFieldReferenceAutoImport() throws Exception {
+    	Launcher launcher = checkFile(true, "AmbiguousImplicitFieldReference.java");
+    	if(expectImplicit) {
+        	CtClass<?> cls = launcher.getFactory().Class().get(AmbiguousImplicitFieldReference.class);
+        	assertEquals("return memberField", cls.getMethod("getMemberField").getBody().getStatements().get(0).toString());
+        	assertEquals("memberField = p_memberField", cls.getMethodsByName("setMemberField").get(0).getBody().getStatements().get(0).toString());
+//        	assertEquals("this.memberField = memberField", cls.getMethodsByName("setMemberField2").get(0).getBody().getStatements().get(0).toString());
+        	assertEquals("getMemberField()", cls.getMethodsByName("testLocalMethodInvocations").get(0).getBody().getStatements().get(0).toString());
+    	}
+    }
+
+    @Test
+    public void testImplicitStaticClassAccess() throws Exception {
+    	Launcher launcher = checkFile(false, "ImplicitStaticClassAccess.java");
+    }
+    @Test
+    public void testImplicitStaticClassAccessAutoImport() throws Exception {
+    	Launcher launcher = checkFile(true, "ImplicitStaticClassAccess.java");
+    }
+    @Test
+    public void testGenericsWithAmbiguousStaticField() throws Exception {
+    	Launcher launcher = checkFile(false, "GenericsWithAmbiguousStaticField.java");
+    }
+    @Test
+    public void testGenericsWithAmbiguousStaticFieldAutoImport() throws Exception {
+    	Launcher launcher = checkFile(true, "GenericsWithAmbiguousStaticField.java");
+    }
+    
+    @Test
+    public void testChildOfGenericsWithAmbiguousStaticField() throws Exception {
+    	Launcher launcher = checkFile(false, "ChildOfGenericsWithAmbiguousStaticField.java");
+    }
+    
+    @Test
+    public void testChildOfGenericsWithAmbiguousStaticFieldAutoImport() throws Exception {
+    	Launcher launcher = checkFile(true, "ChildOfGenericsWithAmbiguousStaticField.java");
+    	if(expectImplicit) {
+        	CtClass<?> cls = launcher.getFactory().Class().get(ChildOfGenericsWithAmbiguousStaticField.class);
+        	//The toString of the method does not have a context of class, so it different result 
+//        	assertEquals("spoon.test.staticFieldAccess2.GenericsWithAmbiguousStaticField.<V, C>genericMethod()", cls.getMethod("m1").getBody().getStatements().get(0).toString());
+        	assertTrue(cls.toString().indexOf("spoon.test.staticFieldAccess2.GenericsWithAmbiguousStaticField.<V, C>genericMethod()")>=0);
+        	assertEquals("genericMethod()", cls.getMethod("m1").getBody().getStatements().get(1).toString());
+    	}
+    }
+
+    @Test
+    public void testGenericsWithAmbiguousMemberField() throws Exception {
+    	Launcher launcher = checkFile(false, "GenericsWithAmbiguousMemberField.java");
+    }
+    @Test
+    public void testGenericsWithAmbiguousMemberFieldAutoImport() throws Exception {
+    	Launcher launcher = checkFile(true, "GenericsWithAmbiguousMemberField.java");
+    }
+
+    @Test
+    public void testAnnotationInChildWithConstants() throws Exception {
+    	Launcher launcher = checkFile(false, "ChildOfConstants.java", "Constants.java");
+    }
+
+    @Test
+    public void testAnnotationInChildWithConstantsAutoImport() throws Exception {
+    	Launcher launcher = checkFile(true, "ChildOfConstants.java", "Constants.java");
+    }
+    
+    private static Launcher checkFile(boolean autoImports, String... fileName) {
+		Launcher launcher = new Launcher();
+		launcher.getEnvironment().setAutoImports(autoImports);
+
+		String pckg = "spoon/test/staticFieldAccess2/";
+		for (String fn : fileName)
+		{
+			launcher.addInputResource("src/test/java/"+pckg+fn);
+		}
+		String targetDir = "./target/spooned"+(autoImports?"-autoImports":"");
+		launcher.setSourceOutputDirectory(targetDir);
+		launcher.buildModel();
+		launcher.prettyprint();
+		for (String fn : fileName)
+		{
+			canBeBuilt(targetDir+"/"+pckg+fn, 8);
+		}
+		return launcher;
+    }
+}
