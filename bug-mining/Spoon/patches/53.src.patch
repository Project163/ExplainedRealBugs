diff --git a/src/main/java/spoon/reflect/code/CtInvocation.java b/src/main/java/spoon/reflect/code/CtInvocation.java
index bed343eab..36b57a2a2 100644
--- a/src/main/java/spoon/reflect/code/CtInvocation.java
+++ b/src/main/java/spoon/reflect/code/CtInvocation.java
@@ -17,6 +17,8 @@
 
 package spoon.reflect.code;
 
+import spoon.reflect.reference.CtTypeReference;
+
 /**
  * This code element defines a concrete invocation.
  *
@@ -26,4 +28,11 @@ package spoon.reflect.code;
 public interface CtInvocation<T>
 		extends CtAbstractInvocation<T>, CtStatement,
 				CtTargetedExpression<T, CtExpression<?>> {
+	/**
+	 * Return the type returned by the invocation. If the invocation is to a
+	 * method where the returned type is a generic type, this method returns
+	 * the actual type bound to this particular invocation.
+	 */
+	@Override
+	CtTypeReference<T> getType();
 }
diff --git a/src/test/java/spoon/test/casts/CastTest.java b/src/test/java/spoon/test/casts/CastTest.java
index 5fc211eec..6020dc651 100644
--- a/src/test/java/spoon/test/casts/CastTest.java
+++ b/src/test/java/spoon/test/casts/CastTest.java
@@ -1,19 +1,21 @@
 package spoon.test.casts;
 
-import static org.junit.Assert.assertEquals;
-import static spoon.test.TestUtils.build;
-
 import org.junit.Test;
-
+import spoon.reflect.code.CtInvocation;
 import spoon.reflect.code.CtVariableRead;
 import spoon.reflect.declaration.CtClass;
+import spoon.reflect.declaration.CtElement;
 import spoon.reflect.declaration.CtMethod;
 import spoon.reflect.declaration.CtType;
 import spoon.reflect.factory.Factory;
+import spoon.reflect.visitor.Query;
 import spoon.reflect.visitor.filter.NameFilter;
 import spoon.reflect.visitor.filter.TypeFilter;
 import spoon.test.TestUtils;
 
+import static org.junit.Assert.assertEquals;
+import static spoon.test.TestUtils.build;
+
 public class CastTest {
 	Factory factory = TestUtils.createFactory();
 	@Test
@@ -69,6 +71,21 @@ public class CastTest {
 
 	@Test
 	public void testCase4() throws Exception {
+		// contract: If the invocation is to a method where the returned type is a generic type,
+		// getType returns the actual type bound to this particular invocation.
 		CtType<?> type = build("spoon.test.casts", "Castings");
+
+		final CtMethod<?> getValueMethod = type.getMethodsByName("getValue").get(0);
+		final CtInvocation<?> getValueInvocation = Query.getElements(type, new TypeFilter<CtInvocation<?>>(CtInvocation.class) {
+			@Override
+			public boolean matches(CtInvocation element) {
+				return "getValue".equals(element.getExecutable().getSimpleName()) && super.matches(element);
+			}
+		}).get(0);
+
+		assertEquals("T", getValueMethod.getType().getSimpleName());
+		assertEquals("T", getValueMethod.getParameters().get(0).getType().getActualTypeArguments().get(0).toString());
+
+		assertEquals(type.getFactory().Class().INTEGER, getValueInvocation.getType());
 	}
 }
diff --git a/src/test/java/spoon/test/casts/Castings.java b/src/test/java/spoon/test/casts/Castings.java
index fdf5fe0e3..14781704d 100644
--- a/src/test/java/spoon/test/casts/Castings.java
+++ b/src/test/java/spoon/test/casts/Castings.java
@@ -4,7 +4,8 @@ import java.util.ArrayList;
 import java.util.List;
 
 public class Castings {
-	public void test(double a) {}
+	public void test(double a) {
+	}
 
 	public void foo() {
 		List<Integer> list = new ArrayList<Integer>(1);
@@ -12,8 +13,7 @@ public class Castings {
 		test(getValue(list));
 	}
 
-	public final <T> T getValue(List<T> list)
-	{
+	public final <T> T getValue(List<T> list) {
 		return list.get(0);
 	}
 }
