diff --git a/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java b/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java
index 1c1fecd11..65e9b14f6 100644
--- a/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java
+++ b/src/main/java/spoon/reflect/visitor/DefaultJavaPrettyPrinter.java
@@ -1003,12 +1003,12 @@ public class DefaultJavaPrettyPrinter implements CtVisitor, PrettyPrinter {
 
 	private <T> void printCtFieldAccess(CtFieldAccess<T> f) {
 		enterCtExpression(f);
+		context.ignoreGenerics = true;
 		if (f.getTarget() != null) {
 			scan(f.getTarget());
 			write(".");
 			context.ignoreStaticAccess = true;
 		}
-		context.ignoreGenerics = true;
 		scan(f.getVariable());
 
 		context.ignoreGenerics = false;
diff --git a/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java b/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
index 224f3a0df..fc9da1d11 100644
--- a/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
+++ b/src/main/java/spoon/support/compiler/jdt/JDTTreeBuilder.java
@@ -2746,6 +2746,7 @@ public class JDTTreeBuilder extends ASTVisitor {
 			// StaticAccessTest#testReferences test to have an example about that.
 			if (ref.isStatic()) {
 				ref.setDeclaringType(references.getTypeReference(qualifiedNameReference.actualReceiverType));
+				fa.setTarget(factory.Code().createTypeAccess(ref.getDeclaringType()));
 			}
 			fa.setVariable(ref);
 
@@ -2922,6 +2923,14 @@ public class JDTTreeBuilder extends ASTVisitor {
 				va = factory.Core().createFieldRead();
 			}
 			va.setVariable(references.getVariableReference(singleNameReference.fieldBinding()));
+			if (va.getVariable() instanceof CtFieldReference) {
+				final CtFieldReference<Object> ref = (CtFieldReference<Object>) va.getVariable();
+
+				if (ref.isStatic() && !ref.getDeclaringType().isAnonymous()) {
+					final CtTypeAccess typeAccess = factory.Code().createTypeAccess(ref.getDeclaringType());
+					((CtFieldAccess) va).setTarget(typeAccess);
+				}
+			}
 		} else if (singleNameReference.binding instanceof VariableBinding) {
 			if (context.stack.peek().element instanceof CtAssignment && context.assigned) {
 				va = factory.Core().createVariableWrite();
diff --git a/src/test/java/spoon/test/factory/FieldFactoryTest.java b/src/test/java/spoon/test/factory/FieldFactoryTest.java
index 240dbfca8..b99e335dd 100644
--- a/src/test/java/spoon/test/factory/FieldFactoryTest.java
+++ b/src/test/java/spoon/test/factory/FieldFactoryTest.java
@@ -6,9 +6,12 @@ import spoon.reflect.declaration.CtClass;
 import spoon.reflect.declaration.CtElement;
 import spoon.reflect.declaration.CtField;
 import spoon.reflect.declaration.ModifierKind;
+import spoon.reflect.factory.Factory;
 import spoon.reflect.factory.FieldFactory;
 import spoon.reflect.factory.TypeFactory;
 import spoon.reflect.reference.CtTypeReference;
+import spoon.test.targeted.testclasses.Bar;
+import spoon.test.targeted.testclasses.Foo;
 
 import java.util.HashSet;
 import java.util.Set;
@@ -42,7 +45,8 @@ public class FieldFactoryTest {
 	public void testCreateFromSource() throws Exception {
 
 		CtClass<?> target = build("spoon.test", "SampleClass");
-		CtClass<?> type = build("spoon.test.targeted.testclasses", "Foo");
+		Factory factory = build(Foo.class, Bar.class);
+		final CtClass<Object> type = factory.Class().get(Foo.class);
 		CtField<?> source = type.getField("i");
 		FieldFactory ff = type.getFactory().Field();
 		TypeFactory tf = type.getFactory().Type();
diff --git a/src/test/java/spoon/test/targeted/TargetedExpressionTest.java b/src/test/java/spoon/test/targeted/TargetedExpressionTest.java
index d815eed85..bb7ec0210 100644
--- a/src/test/java/spoon/test/targeted/TargetedExpressionTest.java
+++ b/src/test/java/spoon/test/targeted/TargetedExpressionTest.java
@@ -2,7 +2,11 @@ package spoon.test.targeted;
 
 import org.junit.Test;
 import spoon.reflect.code.CtFieldAccess;
+import spoon.reflect.code.CtFieldRead;
+import spoon.reflect.code.CtFieldWrite;
 import spoon.reflect.code.CtSuperAccess;
+import spoon.reflect.code.CtThisAccess;
+import spoon.reflect.code.CtTypeAccess;
 import spoon.reflect.declaration.CtClass;
 import spoon.reflect.declaration.CtConstructor;
 import spoon.reflect.declaration.CtField;
@@ -10,10 +14,12 @@ import spoon.reflect.declaration.CtMethod;
 import spoon.reflect.declaration.CtType;
 import spoon.reflect.factory.Factory;
 import spoon.reflect.reference.CtFieldReference;
+import spoon.reflect.reference.CtTypeReference;
 import spoon.reflect.visitor.filter.AbstractFilter;
 import spoon.reflect.visitor.filter.NameFilter;
 import spoon.reflect.visitor.filter.TypeFilter;
 import spoon.support.reflect.code.CtThisAccessImpl;
+import spoon.test.targeted.testclasses.Bar;
 import spoon.test.targeted.testclasses.Foo;
 import spoon.test.targeted.testclasses.InternalSuperCall;
 
@@ -22,7 +28,9 @@ import java.util.List;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
 import static spoon.test.TestUtils.build;
+import static spoon.test.TestUtils.buildClass;
 
 public class TargetedExpressionTest {
 	@Test
@@ -68,7 +76,8 @@ public class TargetedExpressionTest {
 
 	@Test
 	public void testTargetOfFieldAccess() throws Exception {
-		CtClass<?> type = build("spoon.test.targeted.testclasses", "Foo");
+		Factory factory = build(Foo.class, Bar.class);
+		final CtClass<Object> type = factory.Class().get(Foo.class);
 		CtConstructor<?> constructor = type.getConstructors().toArray(new CtConstructor<?>[0])[0];
 
 		final List<CtFieldAccess<?>> elements = constructor.getElements(new TypeFilter<CtFieldAccess<?>>(CtFieldAccess.class));
@@ -80,7 +89,7 @@ public class TargetedExpressionTest {
 
 	@Test
 	public void testNotTargetedExpression() throws Exception {
-		Factory factory = build(Foo.class);
+		Factory factory = build(Foo.class, Bar.class);
 		CtClass<Object> fooClass = factory.Class().get(Foo.class);
 		CtField<?> iField = fooClass.getField("i");
 		CtFieldAccess<?> fieldAccess = factory.Core().createFieldRead();
@@ -92,4 +101,60 @@ public class TargetedExpressionTest {
 		fieldAccess.setTarget(null);
 		assertEquals("i", fieldAccess.toString());
 	}
+
+	@Test
+	public void testStaticTargets() throws Exception {
+		final Factory factory = build(Foo.class, Bar.class);
+		final CtClass<Foo> type = factory.Class().get(Foo.class);
+		final CtTypeReference<Foo> expectedType = type.getReference();
+		final CtTypeReference<Bar> expectedBarType = factory.Class().<Bar>get(Bar.class).getReference();
+		final CtMethod<?> constructor = type.getMethodsByName("m").get(0);
+
+		final List<CtFieldAccess<?>> elements = constructor.getElements(new TypeFilter<CtFieldAccess<?>>(CtFieldAccess.class));
+		assertEquals(10, elements.size());
+
+		assertTrue(elements.get(0) instanceof CtFieldRead);
+		assertTrue(elements.get(1) instanceof CtFieldRead);
+		assertTrue(elements.get(2) instanceof CtFieldRead);
+
+		assertTrue(elements.get(3) instanceof CtFieldWrite);
+		assertTrue(elements.get(4) instanceof CtFieldWrite);
+		assertTrue(elements.get(5) instanceof CtFieldWrite);
+
+		assertTrue(elements.get(6) instanceof CtFieldRead);
+		assertTrue(elements.get(7) instanceof CtFieldRead);
+
+		assertTrue(elements.get(8) instanceof CtFieldWrite);
+		assertTrue(elements.get(9) instanceof CtFieldWrite);
+
+		// contract for static calls, declaring type of all variables are the same.
+		assertEquals(expectedType, elements.get(0).getVariable().getDeclaringType());
+		assertEquals(expectedType, elements.get(1).getVariable().getDeclaringType());
+		assertEquals(expectedType, elements.get(2).getVariable().getDeclaringType());
+		assertEquals(expectedType, elements.get(3).getVariable().getDeclaringType());
+		assertEquals(expectedType, elements.get(4).getVariable().getDeclaringType());
+		assertEquals(expectedType, elements.get(5).getVariable().getDeclaringType());
+
+		assertEquals(expectedBarType, elements.get(6).getVariable().getDeclaringType());
+		assertEquals(expectedBarType, elements.get(7).getVariable().getDeclaringType());
+		assertEquals(expectedBarType, elements.get(8).getVariable().getDeclaringType());
+		assertEquals(expectedBarType, elements.get(9).getVariable().getDeclaringType());
+
+		// contract for static calls getTarget() have a this or type access.
+		final CtThisAccess<Foo> exepectedThisAccess = type.getFactory().Core().createThisAccess();
+		exepectedThisAccess.setType(expectedType);
+		final CtTypeAccess<Foo> expectedTypeAccess = type.getFactory().Code().createTypeAccess(expectedType);
+		final CtTypeAccess<Bar> expectedBarTypeAccess = type.getFactory().Code().createTypeAccess(expectedBarType);
+
+		assertEquals(exepectedThisAccess, elements.get(0).getTarget());
+		assertEquals(expectedTypeAccess, elements.get(1).getTarget());
+		assertEquals(expectedTypeAccess, elements.get(2).getTarget());
+		assertEquals(exepectedThisAccess, elements.get(3).getTarget());
+		assertEquals(expectedTypeAccess, elements.get(4).getTarget());
+		assertEquals(expectedTypeAccess, elements.get(5).getTarget());
+		assertEquals(expectedBarTypeAccess, elements.get(6).getTarget());
+		assertEquals(expectedBarTypeAccess, elements.get(7).getTarget());
+		assertEquals(expectedBarTypeAccess, elements.get(8).getTarget());
+		assertEquals(expectedBarTypeAccess, elements.get(9).getTarget());
+	}
 }
diff --git a/src/test/java/spoon/test/targeted/testclasses/Bar.java b/src/test/java/spoon/test/targeted/testclasses/Bar.java
new file mode 100644
index 000000000..c5023a859
--- /dev/null
+++ b/src/test/java/spoon/test/targeted/testclasses/Bar.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2006-2015 INRIA and contributors
+ * Spoon - http://spoon.gforge.inria.fr/
+ *
+ * This software is governed by the CeCILL-C License under French law and
+ * abiding by the rules of distribution of free software. You can use, modify
+ * and/or redistribute the software under the terms of the CeCILL-C license as
+ * circulated by CEA, CNRS and INRIA at http://www.cecill.info.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the CeCILL-C License for more details.
+ *
+ * The fact that you are presently reading this means that you have had
+ * knowledge of the CeCILL-C license and that you accept its terms.
+ */
+
+package spoon.test.targeted.testclasses;
+
+public class Bar {
+	static int FIELD = 1;
+}
diff --git a/src/test/java/spoon/test/targeted/testclasses/Foo.java b/src/test/java/spoon/test/targeted/testclasses/Foo.java
index 475dc3a36..7cc8894e9 100644
--- a/src/test/java/spoon/test/targeted/testclasses/Foo.java
+++ b/src/test/java/spoon/test/targeted/testclasses/Foo.java
@@ -1,8 +1,25 @@
 package spoon.test.targeted.testclasses;
 
+import static spoon.test.targeted.testclasses.Bar.FIELD;
+
 public class Foo {
 	private int i;
 	private int j;
+	static int k;
+
+	public void m() {
+		int x;
+		x= this.k;
+		x= Foo.k;
+		x= k;
+		this.k = x;
+		k=x;
+		Foo.k=x;
+		x = Bar.FIELD;
+		x = FIELD;
+		Bar.FIELD = x;
+		FIELD = x;
+	}
 
 	public Foo(int i, int k) {
 		this.i = i;
