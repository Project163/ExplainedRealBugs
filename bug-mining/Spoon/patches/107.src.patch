diff --git a/doc/faq.md b/doc/faq.md
index e38812df2..d82fcde0d 100644
--- a/doc/faq.md
+++ b/doc/faq.md
@@ -67,3 +67,17 @@ if(t.getActualClass()==int.class) { ... }
 Factory f=...
 t=f.Type().createReference(int.class);
 ```
+
+## How to parametrized the JDT compiler arguments?
+
+`SpoonModelBuilder` exposes a method named `build(JDTBuilder)`. This method compiles the target source code with data specified in the JDTBuilder parameter.
+
+```java
+final String[] builder = new JDTBuilderImpl() //
+		.classpathOptions(new ClasspathOptions().classpath(TEST_CLASSPATH).bootclasspath(TEST_CLASSPATH).binaries(".").encoding("UTF-8")) //
+		.complianceOptions(new ComplianceOptions().compliance(8)) //
+		.annotationProcessingOptions(new AnnotationProcessingOptions().compileProcessors()) //
+		.advancedOptions(new AdvancedOptions().continueExecution().enableJavadoc().preserveUnusedVars()) //
+		.sources(new SourceOptions().sources(".")) //
+		.build();
+```
diff --git a/src/main/java/spoon/SpoonModelBuilder.java b/src/main/java/spoon/SpoonModelBuilder.java
index d5fd9cc1f..4d33492a7 100644
--- a/src/main/java/spoon/SpoonModelBuilder.java
+++ b/src/main/java/spoon/SpoonModelBuilder.java
@@ -17,6 +17,7 @@
 package spoon;
 
 import spoon.compiler.SpoonResource;
+import spoon.compiler.builder.JDTBuilder;
 import spoon.processing.Processor;
 import spoon.reflect.declaration.CtElement;
 import spoon.reflect.declaration.CtType;
@@ -46,42 +47,96 @@ import java.util.Set;
 public interface SpoonModelBuilder {
 
 	/**
-	 * Adds a file/directory to be built. By default, the files could be Java
-	 * source files or Jar files. Directories are processed recursively.
+	 * Builds the program's model with this compiler's factory and stores the
+	 * result into this factory. Note that this method should only be used once
+	 * on a given factory.
 	 *
-	 * @param source
-	 * 		file or directory to add
+	 * @return true if the Java was successfully compiled with the core Java
+	 * compiler, false if some errors were encountered while compiling
+	 * @throws spoon.SpoonException
+	 * 		when a building problem occurs
+	 * @see #getSourceClasspath()
+	 * @see #getTemplateClasspath()
 	 */
-	void addInputSource(File source);
+	boolean build();
 
 	/**
-	 * Sets the output directory for binary generated.
+	 * Builds the program's model with this compiler's factory and stores the
+	 * result into this factory. Note that this method should only be used once
+	 * on a given factory.
 	 *
-	 * @param binaryOutputDirectory
-	 * 		{@link File} for binary output directory.
+	 * @param builder
+	 * 		Parameters given at JDT compiler.
+	 * @return true if the Java was successfully compiled with the core Java
+	 * compiler, false if some errors were encountered while compiling
+	 * @throws spoon.SpoonException
+	 * 		when a building problem occurs
+	 * @see #getSourceClasspath()
+	 * @see #getTemplateClasspath()
 	 */
-	void setBinaryOutputDirectory(File binaryOutputDirectory);
+	boolean build(JDTBuilder builder);
 
 	/**
-	 * Gets the binary output directory of the compiler.
+	 * Generates the bytecode associated to the classes stored in this
+	 * compiler's factory. The bytecode is generated in the directory given by
+	 * {@link #getBinaryOutputDirectory()}.
+	 *
+	 * @see #getSourceClasspath()
 	 */
-	File getBinaryOutputDirectory();
+	boolean compile();
 
 	/**
-	 * Sets the output directory for source generated.
+	 * Generates the bytecode by compiling the input sources. The bytecode is
+	 * generated in the directory given by {@link #getBinaryOutputDirectory()}.
 	 *
-	 * @param outputDirectory
-	 * 		{@link File} for output directory.
+	 * @see #getSourceClasspath()
 	 */
-	void setSourceOutputDirectory(File outputDirectory);
+	boolean compileInputSources();
 
 	/**
-	 * Gets the output directory of this compiler.
+	 * Takes a list of fully qualified name processors and instantiates them to process
+	 * the Java model.
 	 */
-	File getSourceOutputDirectory();
+	void instantiateAndProcess(List<String> processors);
 
 	/**
-	 * Adds a file/directory (as a CtResource) to be built. By default, the
+	 * Processes the Java model with the given processors.
+	 */
+	void process(Collection<Processor<? extends CtElement>> processors);
+
+	/**
+	 * Generates the source code associated to the classes stored in this
+	 * compiler's factory. The source code is generated in the directory given
+	 * by {@link #getSourceOutputDirectory()}.
+	 *
+	 * @param outputType
+	 * 		the output method
+	 */
+	void generateProcessedSourceFiles(OutputType outputType);
+
+	/**
+	 * Generates the source code associated to the classes stored in this
+	 * compiler's factory. The source code is generated in the directory given
+	 * by {@link #getSourceOutputDirectory()}.
+	 *
+	 * @param outputType
+	 * 		the output method
+	 * @param typeFilter
+	 * 		Filter on CtType to know which type Spoon must print.
+	 */
+	void generateProcessedSourceFiles(OutputType outputType, Filter<CtType<?>> typeFilter);
+
+	/**
+	 * Adds a file/directory to be built. By default, the files could be Java
+	 * source files or Jar files. Directories are processed recursively.
+	 *
+	 * @param source
+	 * 		file or directory to add
+	 */
+	void addInputSource(File source);
+
+	/**
+	 * Adds a file/directory (as a {@link SpoonResource}) to be built. By default, the
 	 * files could be Java source files or Jar files. Directories are processed
 	 * recursively.
 	 *
@@ -90,6 +145,16 @@ public interface SpoonModelBuilder {
 	 */
 	void addInputSource(SpoonResource source);
 
+	/**
+	 * Adds a list of files/directories (as a {@link SpoonResource} to be built.
+	 * By default, the files could be Java source files of Java files. Directories
+	 * are processed recursively.
+	 *
+	 * @param resources
+	 * 		files or directories to add.
+	 */
+	void addInputSources(List<SpoonResource> resources);
+
 	/**
 	 * Gets all the files/directories given as input sources to this builder
 	 * (see {@link #addInputSource(File)}).
@@ -109,7 +174,7 @@ public interface SpoonModelBuilder {
 	void addTemplateSource(File source);
 
 	/**
-	 * Adds a file/directory (as a CtResource) to be used to build templates. By
+	 * Adds a file/directory (as a {@link SpoonResource}) to be used to build templates. By
 	 * default, the files should be Java source files or Jar files containing
 	 * the sources. Directories are processed recursively. Templates are set
 	 * apart from the program to be processed for logical reasons. However, if a
@@ -122,78 +187,49 @@ public interface SpoonModelBuilder {
 	void addTemplateSource(SpoonResource source);
 
 	/**
-	 * Gets all the files/directories given as template sources to this builder
-	 * (see {@link #addTemplateSource(File)}).
-	 */
-	Set<File> getTemplateSources();
-
-	void addInputSources(List<SpoonResource> resources);
-
-	void addTemplateSources(List<SpoonResource> resources);
-
-	/**
-	 * Builds the program's model with this compiler's factory and stores the
-	 * result into this factory. Note that this method should only be used once
-	 * on a given factory.
+	 * Adds a list of files/directories (as a CtResource) to be used to build templates. By
+	 * default, the files should be Java source files or Jar files containing
+	 * the sources. Directories are processed recursively. Templates are set
+	 * apart from the program to be processed for logical reasons. However, if a
+	 * template was needed to be processed, it could be added as an input
+	 * source.
 	 *
-	 * @return true if the Java was successfully compiled with the core Java
-	 * compiler, false if some errors were encountered while compiling
-	 * @throws spoon.SpoonException
-	 * 		when a building problem occurs
-	 * @see #getSourceClasspath()
-	 * @see #getTemplateClasspath()
+	 * @param resources
+	 * 		files or directories to add.
 	 */
-	boolean build();
-
-	/**
-	 * Takes a list of fully qualified name processors and instantiates them to process
-	 * the Java model.
-	 */
-	void instantiateAndProcess(List<String> processors);
+	void addTemplateSources(List<SpoonResource> resources);
 
 	/**
-	 * Processes the Java model with the given processors.
+	 * Gets all the files/directories given as template sources to this builder
+	 * (see {@link #addTemplateSource(File)}).
 	 */
-	void process(Collection<Processor<? extends CtElement>> processors);
+	Set<File> getTemplateSources();
 
 	/**
-	 * Generates the source code associated to the classes stored in this
-	 * compiler's factory. The source code is generated in the directory given
-	 * by {@link #getSourceOutputDirectory()}.
+	 * Sets the output directory for source generated.
 	 *
-	 * @param outputType
-	 * 		the output method
+	 * @param outputDirectory
+	 * 		{@link File} for output directory.
 	 */
-	void generateProcessedSourceFiles(OutputType outputType);
+	void setSourceOutputDirectory(File outputDirectory);
 
 	/**
-	 * Generates the source code associated to the classes stored in this
-	 * compiler's factory. The source code is generated in the directory given
-	 * by {@link #getSourceOutputDirectory()}.
-	 *
-	 * @param outputType
-	 * 		the output method
-	 * @param typeFilter
-	 * 		Filter on CtType to know which type Spoon must print.
+	 * Gets the output directory of this compiler.
 	 */
-	void generateProcessedSourceFiles(OutputType outputType, Filter<CtType<?>> typeFilter);
+	File getSourceOutputDirectory();
 
 	/**
-	 * Generates the bytecode associated to the classes stored in this
-	 * compiler's factory. The bytecode is generated in the directory given by
-	 * {@link #getBinaryOutputDirectory()}.
+	 * Sets the output directory for binary generated.
 	 *
-	 * @see #getSourceClasspath()
+	 * @param binaryOutputDirectory
+	 * 		{@link File} for binary output directory.
 	 */
-	boolean compile();
+	void setBinaryOutputDirectory(File binaryOutputDirectory);
 
 	/**
-	 * Generates the bytecode by compiling the input sources. The bytecode is
-	 * generated in the directory given by {@link #getBinaryOutputDirectory()}.
-	 *
-	 * @see #getSourceClasspath()
+	 * Gets the binary output directory of the compiler.
 	 */
-	boolean compileInputSources();
+	File getBinaryOutputDirectory();
 
 	/**
 	 * Gets the classpath that is used to build/compile the input sources.
@@ -252,5 +288,4 @@ public interface SpoonModelBuilder {
 	 * Returns the working factory
 	 */
 	Factory getFactory();
-
 }
diff --git a/src/main/java/spoon/compiler/builder/AdvancedOptions.java b/src/main/java/spoon/compiler/builder/AdvancedOptions.java
new file mode 100644
index 000000000..9077e6d42
--- /dev/null
+++ b/src/main/java/spoon/compiler/builder/AdvancedOptions.java
@@ -0,0 +1,38 @@
+/**
+ * Copyright (C) 2006-2015 INRIA and contributors
+ * Spoon - http://spoon.gforge.inria.fr/
+ *
+ * This software is governed by the CeCILL-C License under French law and
+ * abiding by the rules of distribution of free software. You can use, modify
+ * and/or redistribute the software under the terms of the CeCILL-C license as
+ * circulated by CEA, CNRS and INRIA at http://www.cecill.info.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the CeCILL-C License for more details.
+ *
+ * The fact that you are presently reading this means that you have had
+ * knowledge of the CeCILL-C license and that you accept its terms.
+ */
+package spoon.compiler.builder;
+
+public class AdvancedOptions<T extends AdvancedOptions<T>> extends Options<T> {
+	public AdvancedOptions() {
+		super(AdvancedOptions.class);
+	}
+
+	public T continueExecution() {
+		args.add("-noExit");
+		return myself;
+	}
+
+	public T enableJavadoc() {
+		args.add("-enableJavadoc");
+		return myself;
+	}
+
+	public T preserveUnusedVars() {
+		args.add("-preserveAllLocals");
+		return myself;
+	}
+}
diff --git a/src/main/java/spoon/compiler/builder/AnnotationProcessingOptions.java b/src/main/java/spoon/compiler/builder/AnnotationProcessingOptions.java
new file mode 100644
index 000000000..c3324c067
--- /dev/null
+++ b/src/main/java/spoon/compiler/builder/AnnotationProcessingOptions.java
@@ -0,0 +1,49 @@
+/**
+ * Copyright (C) 2006-2015 INRIA and contributors
+ * Spoon - http://spoon.gforge.inria.fr/
+ *
+ * This software is governed by the CeCILL-C License under French law and
+ * abiding by the rules of distribution of free software. You can use, modify
+ * and/or redistribute the software under the terms of the CeCILL-C license as
+ * circulated by CEA, CNRS and INRIA at http://www.cecill.info.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the CeCILL-C License for more details.
+ *
+ * The fact that you are presently reading this means that you have had
+ * knowledge of the CeCILL-C license and that you accept its terms.
+ */
+package spoon.compiler.builder;
+
+public class AnnotationProcessingOptions<T extends AnnotationProcessingOptions<T>> extends Options<T> {
+	public AnnotationProcessingOptions() {
+		super(AnnotationProcessingOptions.class);
+	}
+
+	public T processors(String processors) {
+		if (processors == null || processors.isEmpty()) {
+			return myself;
+		}
+		args.add("-processor");
+		args.add(processors);
+		return myself;
+	}
+
+	public T processors(String... processors) {
+		if (processors == null || processors.length == 0) {
+			return myself;
+		}
+		return processors(join(COMMA_DELIMITER, processors));
+	}
+
+	public T runProcessors() {
+		args.add("-proc:only");
+		return myself;
+	}
+
+	public T compileProcessors() {
+		args.add("-proc:none");
+		return myself;
+	}
+}
diff --git a/src/main/java/spoon/compiler/builder/ClasspathOptions.java b/src/main/java/spoon/compiler/builder/ClasspathOptions.java
new file mode 100644
index 000000000..2a1573a2c
--- /dev/null
+++ b/src/main/java/spoon/compiler/builder/ClasspathOptions.java
@@ -0,0 +1,105 @@
+/**
+ * Copyright (C) 2006-2015 INRIA and contributors
+ * Spoon - http://spoon.gforge.inria.fr/
+ *
+ * This software is governed by the CeCILL-C License under French law and
+ * abiding by the rules of distribution of free software. You can use, modify
+ * and/or redistribute the software under the terms of the CeCILL-C license as
+ * circulated by CEA, CNRS and INRIA at http://www.cecill.info.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the CeCILL-C License for more details.
+ *
+ * The fact that you are presently reading this means that you have had
+ * knowledge of the CeCILL-C license and that you accept its terms.
+ */
+package spoon.compiler.builder;
+
+import java.io.File;
+import java.net.URL;
+import java.net.URLClassLoader;
+
+public class ClasspathOptions<T extends ClasspathOptions<T>> extends Options<T> {
+	public ClasspathOptions() {
+		super(ClasspathOptions.class);
+	}
+
+	public T classpath(String classpath) {
+		if (classpath == null) {
+			return myself;
+		}
+		args.add("-cp");
+		args.add(classpath);
+		return myself;
+	}
+
+	public T classpath(String... classpaths) {
+		if (classpaths == null || classpaths.length == 0) {
+			return myself;
+		}
+		return classpath(join(File.pathSeparator, classpaths));
+	}
+
+	public T classpathFromListOrClassLoader(String... classpaths) {
+		return (classpaths != null && classpaths.length > 0) ? classpath(classpaths) : classpathFromCurrentClassLoader();
+	}
+
+	public T classpathFromCurrentClassLoader() {
+		ClassLoader currentClassLoader = Thread.currentThread().getContextClassLoader();
+		if (currentClassLoader instanceof URLClassLoader) {
+			final URL[] urls = ((URLClassLoader) currentClassLoader).getURLs();
+			if (urls != null && urls.length > 0) {
+				String classpath = ".";
+				for (URL url : urls) {
+					classpath += File.pathSeparator + url.getFile();
+				}
+				classpath(classpath);
+			}
+		}
+		return myself;
+	}
+
+	public T bootclasspath(String bootclasspath) {
+		if (bootclasspath == null) {
+			return myself;
+		}
+		args.add("-bootclasspath");
+		args.add(bootclasspath);
+		return myself;
+	}
+
+	public T bootclasspath(String... bootclasspaths) {
+		if (bootclasspaths == null || bootclasspaths.length == 0) {
+			return myself;
+		}
+		return bootclasspath(join(File.pathSeparator, bootclasspaths));
+	}
+
+	public T binaries(String directory) {
+		if (directory == null) {
+			return binaries((File) null);
+		}
+		return binaries(new File(directory));
+	}
+
+	public T binaries(File directory) {
+		if (directory == null) {
+			args.add("-d");
+			args.add("none");
+		} else {
+			args.add("-d");
+			args.add(directory.getAbsolutePath());
+		}
+		return myself;
+	}
+
+	public T encoding(String encoding) {
+		if (encoding == null || encoding.isEmpty()) {
+			return myself;
+		}
+		args.add("-encoding");
+		args.add(encoding);
+		return myself;
+	}
+}
diff --git a/src/main/java/spoon/compiler/builder/ComplianceOptions.java b/src/main/java/spoon/compiler/builder/ComplianceOptions.java
new file mode 100644
index 000000000..a90825c3a
--- /dev/null
+++ b/src/main/java/spoon/compiler/builder/ComplianceOptions.java
@@ -0,0 +1,28 @@
+/**
+ * Copyright (C) 2006-2015 INRIA and contributors
+ * Spoon - http://spoon.gforge.inria.fr/
+ *
+ * This software is governed by the CeCILL-C License under French law and
+ * abiding by the rules of distribution of free software. You can use, modify
+ * and/or redistribute the software under the terms of the CeCILL-C license as
+ * circulated by CEA, CNRS and INRIA at http://www.cecill.info.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the CeCILL-C License for more details.
+ *
+ * The fact that you are presently reading this means that you have had
+ * knowledge of the CeCILL-C license and that you accept its terms.
+ */
+package spoon.compiler.builder;
+
+public class ComplianceOptions<T extends ComplianceOptions<T>> extends Options<T> {
+	public ComplianceOptions() {
+		super(ComplianceOptions.class);
+	}
+
+	public T compliance(int version) {
+		args.add("-1." + version);
+		return myself;
+	}
+}
diff --git a/src/main/java/spoon/compiler/builder/JDTBuilder.java b/src/main/java/spoon/compiler/builder/JDTBuilder.java
new file mode 100644
index 000000000..8b476e7f0
--- /dev/null
+++ b/src/main/java/spoon/compiler/builder/JDTBuilder.java
@@ -0,0 +1,52 @@
+/**
+ * Copyright (C) 2006-2015 INRIA and contributors
+ * Spoon - http://spoon.gforge.inria.fr/
+ *
+ * This software is governed by the CeCILL-C License under French law and
+ * abiding by the rules of distribution of free software. You can use, modify
+ * and/or redistribute the software under the terms of the CeCILL-C license as
+ * circulated by CEA, CNRS and INRIA at http://www.cecill.info.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the CeCILL-C License for more details.
+ *
+ * The fact that you are presently reading this means that you have had
+ * knowledge of the CeCILL-C license and that you accept its terms.
+ */
+package spoon.compiler.builder;
+
+/**
+ * Helper to build arguments for the JDT compiler.
+ */
+public interface JDTBuilder {
+	/**
+	 * Classpath options for the compiler.
+	 */
+	JDTBuilder classpathOptions(ClasspathOptions<?> options);
+
+	/**
+	 * Compliance options for the compiler.
+	 */
+	JDTBuilder complianceOptions(ComplianceOptions<?> options);
+
+	/**
+	 * Annotation processing options for the compiler.
+	 */
+	JDTBuilder annotationProcessingOptions(AnnotationProcessingOptions<?> options);
+
+	/**
+	 * Advanced options for the compiler.
+	 */
+	JDTBuilder advancedOptions(AdvancedOptions<?> options);
+
+	/**
+	 * Sources for the compiler.
+	 */
+	JDTBuilder sources(SourceOptions<?> options);
+
+	/**
+	 * Builds arguments.
+	 */
+	String[] build();
+}
diff --git a/src/main/java/spoon/compiler/builder/JDTBuilderImpl.java b/src/main/java/spoon/compiler/builder/JDTBuilderImpl.java
new file mode 100644
index 000000000..cb1ffd68d
--- /dev/null
+++ b/src/main/java/spoon/compiler/builder/JDTBuilderImpl.java
@@ -0,0 +1,72 @@
+/**
+ * Copyright (C) 2006-2015 INRIA and contributors
+ * Spoon - http://spoon.gforge.inria.fr/
+ *
+ * This software is governed by the CeCILL-C License under French law and
+ * abiding by the rules of distribution of free software. You can use, modify
+ * and/or redistribute the software under the terms of the CeCILL-C license as
+ * circulated by CEA, CNRS and INRIA at http://www.cecill.info.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the CeCILL-C License for more details.
+ *
+ * The fact that you are presently reading this means that you have had
+ * knowledge of the CeCILL-C license and that you accept its terms.
+ */
+package spoon.compiler.builder;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+public class JDTBuilderImpl implements JDTBuilder {
+	private final List<String> args = new ArrayList<String>();
+	private boolean hasSources = false;
+
+	@Override
+	public JDTBuilder classpathOptions(ClasspathOptions<?> options) {
+		checkSources();
+		args.addAll(Arrays.asList(options.build()));
+		return this;
+	}
+
+	@Override
+	public JDTBuilder complianceOptions(ComplianceOptions<?> options) {
+		checkSources();
+		args.addAll(Arrays.asList(options.build()));
+		return this;
+	}
+
+	@Override
+	public JDTBuilder annotationProcessingOptions(AnnotationProcessingOptions<?> options) {
+		checkSources();
+		args.addAll(Arrays.asList(options.build()));
+		return this;
+	}
+
+	@Override
+	public JDTBuilder advancedOptions(AdvancedOptions<?> options) {
+		checkSources();
+		args.addAll(Arrays.asList(options.build()));
+		return this;
+	}
+
+	@Override
+	public JDTBuilder sources(SourceOptions<?> options) {
+		hasSources = true;
+		args.addAll(Arrays.asList(options.build()));
+		return this;
+	}
+
+	@Override
+	public String[] build() {
+		return args.toArray(new String[args.size()]);
+	}
+
+	private void checkSources() {
+		if (hasSources) {
+			throw new RuntimeException("Please, specify sources at the end.");
+		}
+	}
+}
diff --git a/src/main/java/spoon/compiler/builder/Options.java b/src/main/java/spoon/compiler/builder/Options.java
new file mode 100644
index 000000000..7eb41e2a0
--- /dev/null
+++ b/src/main/java/spoon/compiler/builder/Options.java
@@ -0,0 +1,46 @@
+/**
+ * Copyright (C) 2006-2015 INRIA and contributors
+ * Spoon - http://spoon.gforge.inria.fr/
+ *
+ * This software is governed by the CeCILL-C License under French law and
+ * abiding by the rules of distribution of free software. You can use, modify
+ * and/or redistribute the software under the terms of the CeCILL-C license as
+ * circulated by CEA, CNRS and INRIA at http://www.cecill.info.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the CeCILL-C License for more details.
+ *
+ * The fact that you are presently reading this means that you have had
+ * knowledge of the CeCILL-C license and that you accept its terms.
+ */
+package spoon.compiler.builder;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public abstract class Options<T extends Options<T>> {
+	final String COMMA_DELIMITER = ",";
+	final List<String> args = new ArrayList<String>();
+	final T myself;
+
+	public Options(Class<?> type) {
+		this.myself = (T) type.cast(this);
+	}
+
+	public String[] build() {
+		return args.toArray(new String[args.size()]);
+	}
+
+	protected String join(String delimiter, String[] classpath) {
+		if (classpath == null || classpath.length == 0) {
+			return "";
+		}
+		final StringBuilder builder = new StringBuilder();
+		for (String entry : classpath) {
+			builder.append(entry);
+			builder.append(delimiter);
+		}
+		return builder.toString();
+	}
+}
diff --git a/src/main/java/spoon/compiler/builder/SourceOptions.java b/src/main/java/spoon/compiler/builder/SourceOptions.java
new file mode 100644
index 000000000..d36d164fe
--- /dev/null
+++ b/src/main/java/spoon/compiler/builder/SourceOptions.java
@@ -0,0 +1,70 @@
+/**
+ * Copyright (C) 2006-2015 INRIA and contributors
+ * Spoon - http://spoon.gforge.inria.fr/
+ *
+ * This software is governed by the CeCILL-C License under French law and
+ * abiding by the rules of distribution of free software. You can use, modify
+ * and/or redistribute the software under the terms of the CeCILL-C license as
+ * circulated by CEA, CNRS and INRIA at http://www.cecill.info.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the CeCILL-C License for more details.
+ *
+ * The fact that you are presently reading this means that you have had
+ * knowledge of the CeCILL-C license and that you accept its terms.
+ */
+package spoon.compiler.builder;
+
+import org.apache.commons.io.IOUtils;
+import spoon.compiler.SpoonFile;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.List;
+
+public class SourceOptions<T extends SourceOptions<T>> extends Options<T> {
+	public SourceOptions() {
+		super(SourceOptions.class);
+	}
+
+	public T sources(String sources) {
+		if (sources == null || sources.isEmpty()) {
+			return myself;
+		}
+		return sources(sources.split(File.pathSeparator));
+	}
+
+	public T sources(String... sources) {
+		if (sources == null || sources.length == 0) {
+			args.add(".");
+			return myself;
+		}
+		args.addAll(Arrays.asList(sources));
+		return myself;
+	}
+
+	public T sources(List<SpoonFile> sources) {
+		if (sources == null || sources.size() == 0) {
+			args.add(".");
+			return myself;
+		}
+		for (SpoonFile source : sources) {
+			if (source.isActualFile()) {
+				args.add(source.toString());
+			} else {
+				try {
+					File file = File.createTempFile(source.getName(), ".java");
+					file.deleteOnExit();
+					IOUtils.copy(source.getContent(), new FileOutputStream(file));
+					args.add(file.toString());
+				} catch (IOException e) {
+					throw new RuntimeException(e.getMessage(), e);
+				}
+			}
+		}
+		return myself;
+	}
+}
diff --git a/src/main/java/spoon/support/compiler/jdt/JDTBasedSpoonCompiler.java b/src/main/java/spoon/support/compiler/jdt/JDTBasedSpoonCompiler.java
index 9edf5b313..093eb17fb 100644
--- a/src/main/java/spoon/support/compiler/jdt/JDTBasedSpoonCompiler.java
+++ b/src/main/java/spoon/support/compiler/jdt/JDTBasedSpoonCompiler.java
@@ -34,6 +34,13 @@ import spoon.compiler.SpoonFile;
 import spoon.compiler.SpoonFolder;
 import spoon.compiler.SpoonResource;
 import spoon.compiler.SpoonResourceHelper;
+import spoon.compiler.builder.AdvancedOptions;
+import spoon.compiler.builder.AnnotationProcessingOptions;
+import spoon.compiler.builder.ClasspathOptions;
+import spoon.compiler.builder.ComplianceOptions;
+import spoon.compiler.builder.JDTBuilder;
+import spoon.compiler.builder.JDTBuilderImpl;
+import spoon.compiler.builder.SourceOptions;
 import spoon.processing.ProcessingManager;
 import spoon.processing.Processor;
 import spoon.reflect.declaration.CtElement;
@@ -45,7 +52,6 @@ import spoon.reflect.visitor.Filter;
 import spoon.reflect.visitor.PrettyPrinter;
 import spoon.reflect.visitor.Query;
 import spoon.support.QueueProcessingManager;
-import spoon.support.compiler.FileSystemFile;
 import spoon.support.compiler.VirtualFolder;
 
 import java.io.ByteArrayInputStream;
@@ -54,8 +60,8 @@ import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.URL;
-import java.net.URLClassLoader;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
@@ -65,42 +71,21 @@ import java.util.Map;
 import java.util.Set;
 
 public class JDTBasedSpoonCompiler implements SpoonCompiler {
-
-	public int javaCompliance = 7;
-
-	private String[] templateClasspath = new String[0];
-
-	/**
-	 * output directory for source code .java file
-	 */
-	File outputDirectory = new File(Launcher.OUTPUTDIR);
-
-	boolean buildOnlyOutdatedFiles = false;
-
-	@Override
-	public void setSourceOutputDirectory(File outputDirectory) {
-		this.outputDirectory = outputDirectory;
-	}
-
-	@Override
-	public File getSourceOutputDirectory() {
-		return outputDirectory;
-	}
-
-	/**
-	 * output directory for binary code .class file
-	 */
-	File binaryOutputDirectory;
-
-	@Override
-	public void setBinaryOutputDirectory(File binaryOutputDirectory) {
-		this.binaryOutputDirectory = binaryOutputDirectory;
-	}
-
-	@Override
-	public File getBinaryOutputDirectory() {
-		return binaryOutputDirectory;
-	}
+	protected INameEnvironment environment = null;
+	protected final List<CategorizedProblem> probs = new ArrayList<CategorizedProblem>();
+	protected final TreeBuilderRequestor requestor = new TreeBuilderRequestor(this);
+	protected Map<String, char[]> loadedContent = new HashMap<String, char[]>();
+	protected Factory factory;
+	protected int javaCompliance = 7;
+	protected boolean build = false;
+	protected SpoonFolder sources = new VirtualFolder();
+	protected SpoonFolder templates = new VirtualFolder();
+	protected String[] templateClasspath = new String[0];
+	protected boolean buildOnlyOutdatedFiles = false;
+	protected File outputDirectory = new File(Launcher.OUTPUTDIR);
+	protected File binaryOutputDirectory;
+	protected List<SpoonResource> forceBuildList = new ArrayList<SpoonResource>();
+	protected String encoding;
 
 	/**
 	 * Default constructor
@@ -109,321 +94,183 @@ public class JDTBasedSpoonCompiler implements SpoonCompiler {
 		this.factory = factory;
 	}
 
-	// example usage (please do not use directly, use instead the spoon.Launcher
-	// API to create the factory)
-	public static void main(String[] args) throws Exception {
-		Launcher main = new Launcher();
-		JDTBasedSpoonCompiler comp = new JDTBasedSpoonCompiler(main.createFactory());
-		comp.createBatchCompiler().printUsage();
-		SpoonFile file = new FileSystemFile(new File("./src/main/java/spoon/support/compiler/JDTCompiler.java"));
-		comp.addInputSource(file);
-		try {
-			comp.build();
-			final Set<CtType<?>> types = comp.getFactory().Package().get("spoon.support.compiler").getTypes();
-			for (CtType<?> type : types) {
-				main.getEnvironment().debugMessage(type.toString());
-			}
-		} catch (Exception e) {
-			throw new RuntimeException(e);
-		}
+	protected JDTBatchCompiler createBatchCompiler() {
+		return createBatchCompiler(false);
 	}
 
 	protected JDTBatchCompiler createBatchCompiler(boolean useFactory) {
 		return new JDTBatchCompiler(this, useFactory);
 	}
 
-	protected JDTBatchCompiler createBatchCompiler() {
-		return createBatchCompiler(false);
+	@Override
+	public boolean build() {
+		return build(null);
 	}
 
-	protected void keepOutdatedFiles(List<SpoonFile> files, Collection<File> outputFiles) {
-		// System.out.println("outputfiles: " + outputFiles);
-
-		int offset = outputDirectory.getAbsolutePath().length() + 1;
-		Collection<String> relativeOutputPaths = new ArrayList<String>();
-		for (File f : outputFiles) {
-			relativeOutputPaths.add(f.getAbsolutePath().substring(offset));
+	@Override
+	public boolean build(JDTBuilder builder) {
+		if (factory == null) {
+			throw new SpoonException("Factory not initialized");
 		}
-		for (SpoonFile sf : new ArrayList<SpoonFile>(files)) {
-			if (forceBuildList.contains(sf)) {
-				continue;
-			}
-			File f = sf.toFile();
-			for (String s : relativeOutputPaths) {
-				if (f.getAbsolutePath().endsWith(s)) {
-					if (f.lastModified() <= new File(outputDirectory, s).lastModified()) {
-						files.remove(sf);
-					}
-				}
-			}
+		if (build) {
+			throw new SpoonException("Model already built");
 		}
-		// System.out.println("filtered: " + files);
-	}
+		build = true;
 
-	protected boolean buildSources() {
-		if (sources.getAllJavaFiles().isEmpty()) {
-			return true;
-		}
-		initInputClassLoader();
-		// long t=System.currentTimeMillis();
-		// Build input
-		JDTBatchCompiler batchCompiler = createBatchCompiler();
-		List<String> args = new ArrayList<String>();
-		args.add("-1." + javaCompliance);
-		if (encoding != null) {
-			args.add("-encoding");
-			args.add(encoding);
-		}
-		args.add("-preserveAllLocals");
-		args.add("-enableJavadoc");
-		args.add("-noExit");
-		// args.add("-d");
-		// args.add("none");
-
-		if (getSourceClasspath() != null) {
-			addClasspathToJDTArgs(args);
-		} else {
-			ClassLoader currentClassLoader = Thread.currentThread().getContextClassLoader();
-			if (currentClassLoader instanceof URLClassLoader) {
-				URL[] urls = ((URLClassLoader) currentClassLoader).getURLs();
-				if (urls != null && urls.length > 0) {
-					String classpath = ".";
-					for (URL url : urls) {
-						classpath += File.pathSeparator + url.getFile();
-					}
-					if (classpath != null) {
-						args.add("-cp");
-						args.add(classpath);
-					}
-				}
-			}
-		}
-		// args.add("-nowarn");
-		// Set<String> paths = new HashSet<String>();
-		// for (SpoonFile file : files) {
-		// // We can not use file.getPath() because of in-memory code or files
-		// // within archives
-		// paths.add(file.getFileSystemParent().getPath());
-		// }
-		args.addAll(toStringList(sources.getAllJavaFiles()));
+		boolean srcSuccess, templateSuccess;
+		factory.getEnvironment().debugMessage("building sources: " + sources.getAllJavaFiles());
+		long t = System.currentTimeMillis();
+		javaCompliance = factory.getEnvironment().getComplianceLevel();
+		srcSuccess = buildSources(builder);
 
-		getFactory().getEnvironment().debugMessage("build args: " + args);
+		reportProblems(factory.getEnvironment());
 
-		batchCompiler.configure(args.toArray(new String[0]));
+		factory.getEnvironment().debugMessage("built in " + (System.currentTimeMillis() - t) + " ms");
+		factory.getEnvironment().debugMessage("building templates: " + templates.getAllJavaFiles());
+		t = System.currentTimeMillis();
+		templateSuccess = buildTemplates(builder);
+		factory.getEnvironment().debugMessage("built in " + (System.currentTimeMillis() - t) + " ms");
+		return srcSuccess && templateSuccess;
+	}
 
-		List<SpoonFile> filesToBuild = sources.getAllJavaFiles();
+	@Override
+	public boolean compile() {
+		initInputClassLoader();
+		factory.getEnvironment().debugMessage("compiling sources: " + factory.CompilationUnit().getMap().keySet());
+		long t = System.currentTimeMillis();
+		javaCompliance = factory.getEnvironment().getComplianceLevel();
+
+		JDTBatchCompiler batchCompiler = createBatchCompiler(true);
+		final SourceOptions sourcesOptions = new SourceOptions();
 		if (buildOnlyOutdatedFiles) {
+			// ignore the files that are not outdated
 			if (outputDirectory.exists()) {
 				@SuppressWarnings("unchecked") Collection<File> outputFiles = FileUtils.listFiles(outputDirectory, new String[] { "java" }, true);
-				keepOutdatedFiles(filesToBuild, outputFiles);
-			} else {
-				keepOutdatedFiles(filesToBuild, new ArrayList<File>());
-			}
-		}
-		CompilationUnitDeclaration[] units = batchCompiler.getUnits(filesToBuild);
-
-		// here we build the model
-		JDTTreeBuilder builder = new JDTTreeBuilder(factory);
-		for (CompilationUnitDeclaration unit : units) {
-			unit.traverse(builder, unit.scope);
-		}
-
-		return probs.size() == 0;
-	}
-
-	private Collection<? extends String> toStringList(List<SpoonFile> files) {
-		List<String> res = new ArrayList<String>();
-		for (SpoonFile f : files) {
-			if (f.isActualFile()) {
-				res.add(f.toString());
-			} else {
-				try {
-					File file = File.createTempFile(f.getName(), ".java");
-					file.deleteOnExit();
-					IOUtils.copy(f.getContent(), new FileOutputStream(file));
-
-					res.add(file.toString());
-				} catch (IOException e) {
-					throw new RuntimeException(e.getMessage(), e);
+				int offset = outputDirectory.getAbsolutePath().length() + 1;
+				Collection<String> relativeOutputPaths = new ArrayList<String>();
+				for (File f : outputFiles) {
+					relativeOutputPaths.add(f.getAbsolutePath().substring(offset));
+				}
+				for (SpoonFile sf : sources.getAllJavaFiles()) {
+					if (factory.CompilationUnit().getMap().containsKey(sf.getPath())) {
+						continue;
+					}
+					File source = sf.toFile();
+					for (String out : relativeOutputPaths) {
+						if (source.getAbsolutePath().endsWith(out)) {
+							if (source.lastModified() <= new File(outputDirectory, out).lastModified()) {
+								batchCompiler.ignoreFile(new File(outputDirectory, out).getAbsolutePath());
+							}
+						}
+					}
 				}
 			}
-		}
-		return res;
-	}
-
-	protected String computeTemplateClasspath() {
-		return this.computeClasspath(this.getTemplateClasspath());
-	}
-
-	protected String computeJdtClassPath() {
-		return this.computeClasspath(this.getSourceClasspath());
-	}
-
-	private String computeClasspath(String[] classpath) {
-		if (classpath == null || classpath.length == 0) {
-			return "";
-		}
-
-		StringBuilder builder = new StringBuilder();
-		for (String entry : classpath) {
-			builder.append(entry);
-			builder.append(File.pathSeparatorChar);
+			sourcesOptions.sources(getBinaryOutputDirectory().getAbsolutePath());
+		} else {
+			sourcesOptions.sources(this.sources.getAllJavaFiles());
 		}
 
-		return builder.toString();
-	}
+		final String[] args = new JDTBuilderImpl() //
+				.classpathOptions(new ClasspathOptions().encoding(this.encoding).classpathFromListOrClassLoader(getSourceClasspath()).binaries(getBinaryOutputDirectory())) //
+				.complianceOptions(new ComplianceOptions().compliance(javaCompliance)) //
+				.annotationProcessingOptions(new AnnotationProcessingOptions().compileProcessors()) //
+				.advancedOptions(new AdvancedOptions().preserveUnusedVars().continueExecution().enableJavadoc()) //
+				.sources(sourcesOptions) //
+				.build();
 
-	protected void addClasspathToJDTArgs(List<String> args) {
-		args.add("-cp");
-		args.add(computeJdtClassPath());
-	}
+		getFactory().getEnvironment().debugMessage("compile args: " + Arrays.toString(args));
+		System.setProperty("jdt.compiler.useSingleThread", "true");
+		batchCompiler.compile(args);
 
-	// this function is used to hack the JDT compiler...
-	protected File createTmpJavaFile(File folder) {
-		File f = new File(folder, "Tmp.java");
-		if (f.exists()) {
-			return f;
-		}
-		try {
-			FileUtils.writeStringToFile(f, "class Tmp {}");
-			f.deleteOnExit();
-		} catch (Exception e) {
-			Launcher.LOGGER.error(e.getMessage(), e);
-		}
-		return f;
+		reportProblems(factory.getEnvironment());
+		factory.getEnvironment().debugMessage("compiled in " + (System.currentTimeMillis() - t) + " ms");
+		return probs.size() == 0;
 	}
 
-	protected boolean buildTemplates() {
-		if (templates.getAllJavaFiles().isEmpty()) {
-			return true;
-		}
-		JDTBatchCompiler batchCompiler = createBatchCompiler();
-		List<String> args = new ArrayList<String>();
-		args.add("-1." + javaCompliance);
-		if (encoding != null) {
-			args.add("-encoding");
-			args.add(encoding);
-		}
-		args.add("-preserveAllLocals");
-		args.add("-enableJavadoc");
-		args.add("-noExit");
-		// args.add("-verbose");
-		// args.add("-d");
-		// args.add("none");
-		// args.add("-g");
-		// args.add("-nowarn");
-
-		File f = null;
-
-		if (this.templateClasspath != null && this.templateClasspath.length > 0) {
-			args.add("-cp");
-			args.add(this.computeTemplateClasspath());
-
-			// Set<String> paths = new HashSet<String>();
-			// String sourcePaths = "";
-			// for (SpoonFolder file : templates.getSubFolders()) {
-			// if (file.isArchive()) {
-			// sourcePaths += file.getPath() + File.pathSeparator;
-			// }
-			// }
-			// for (SpoonFile file : files) {
-			// if (!paths.contains(file.getFileSystemParent().getPath())) {
-			// sourcePaths += file.getParent().getPath()
-			// + File.pathSeparator;
-			// }
-			// paths.add(file.getPath());
-			// }
-			// args.add("-sourcepath");
-			// args.add(sourcePaths.substring(0, sourcePaths.length() - 1));
-			// args.addAll(paths);
-			// args.add(".");
-			for (SpoonFolder file : templates.getSubFolders()) {
-				if (file.isArchive()) {
-					// JDT bug HACK
-					f = createTmpJavaFile(file.getFileSystemParent());
-				}
-			}
-			args.addAll(toStringList(templates.getAllJavaFiles()));
-		} else {
-			// when no class path is defined, we are probably in test and we try
-			// to get as much source as we can compiled
-			args.add(".");
-		}
+	@Override
+	public boolean compileInputSources() {
+		initInputClassLoader();
+		factory.getEnvironment().debugMessage("compiling input sources: " + sources.getAllJavaFiles());
+		long t = System.currentTimeMillis();
+		javaCompliance = factory.getEnvironment().getComplianceLevel();
 
-		getFactory().getEnvironment().debugMessage("template build args: " + args);
-		// printUsage();
-		// System.out.println("=>" + args);
-		batchCompiler.configure(args.toArray(new String[0]));
-		CompilationUnitDeclaration[] units = batchCompiler.getUnits(templates.getAllJavaFiles());
+		Main batchCompiler = createBatchCompiler(false);
 
-		if (f != null && f.exists()) {
-			f.delete();
-		}
+		final String[] args = new JDTBuilderImpl() //
+				.classpathOptions(new ClasspathOptions().encoding(this.encoding).classpathFromListOrClassLoader(getSourceClasspath()).binaries(getBinaryOutputDirectory())) //
+				.complianceOptions(new ComplianceOptions().compliance(javaCompliance)) //
+				.advancedOptions(new AdvancedOptions().preserveUnusedVars().continueExecution().enableJavadoc()) //
+				.annotationProcessingOptions(new AnnotationProcessingOptions().compileProcessors()) //
+				.sources(new SourceOptions().sources(sources.getAllJavaFiles())) //
+				.build();
 
-		// here we build the model in the template factory
-		JDTTreeBuilder builder = new JDTTreeBuilder(factory);
-		for (CompilationUnitDeclaration unit : units) {
-			unit.traverse(builder, unit.scope);
-		}
+		batchCompiler.compile(args);
 
+		factory.getEnvironment().debugMessage("compiled in " + (System.currentTimeMillis() - t) + " ms");
 		return probs.size() == 0;
-
 	}
 
-	INameEnvironment environment = null;
+	@Override
+	public void instantiateAndProcess(List<String> processors) {
+		initInputClassLoader();
+
+		// processing (consume all the processors)
+		ProcessingManager processing = new QueueProcessingManager(factory);
+		for (String processorName : processors) {
+			processing.addProcessor(processorName);
+			factory.getEnvironment().debugMessage("Loaded processor " + processorName + ".");
+		}
 
-	public void setEnvironment(INameEnvironment environment) {
-		this.environment = environment;
+		processing.process(factory.Package().getRootPackage());
 	}
 
-	private final List<CategorizedProblem> probs = new ArrayList<CategorizedProblem>();
-
-	/**
-	 * report a compilation problem (callback for JDT)
-	 */
-	public void reportProblem(CategorizedProblem pb) {
-		if (pb == null) {
-			return;
-		}
+	@Override
+	public void process(Collection<Processor<? extends CtElement>> processors) {
+		initInputClassLoader();
 
-		// we can not accept this problem, even in noclasspath mode
-		// otherwise a nasty null pointer exception occurs later
-		if (pb.getID() == IProblem.DuplicateTypes) {
-			throw new ModelBuildingException(pb.getMessage());
+		// processing (consume all the processors)
+		ProcessingManager processing = new QueueProcessingManager(factory);
+		for (Processor<? extends CtElement> processorName : processors) {
+			processing.addProcessor(processorName);
+			factory.getEnvironment().debugMessage("Loaded processor " + processorName + ".");
 		}
 
-		probs.add(pb);
+		processing.process(factory.Package().getRootPackage());
 	}
 
-	public final TreeBuilderRequestor requestor = new TreeBuilderRequestor(this);
-
-	/**
-	 * returns the list of current problems
-	 */
-	public List<CategorizedProblem> getProblems() {
-		return Collections.unmodifiableList(this.probs);
+	@Override
+	public void generateProcessedSourceFiles(OutputType outputType) {
+		generateProcessedSourceFiles(outputType, null);
 	}
 
-	private boolean build = false;
-
-	SpoonFolder sources = new VirtualFolder();
-
-	SpoonFolder templates = new VirtualFolder();
-
 	@Override
-	public void addInputSources(List<SpoonResource> resources) {
-		for (SpoonResource r : resources) {
-			addInputSource(r);
+	public void generateProcessedSourceFiles(OutputType outputType, Filter<CtType<?>> typeFilter) {
+		initInputClassLoader();
+		switch (outputType) {
+		case CLASSES:
+			generateProcessedSourceFilesUsingTypes(typeFilter);
+			break;
+		case COMPILATION_UNITS:
+			generateProcessedSourceFilesUsingCUs();
+			break;
+		case NO_OUTPUT:
 		}
 	}
 
 	@Override
-	public void addTemplateSources(List<SpoonResource> resources) {
-		for (SpoonResource r : resources) {
-			addTemplateSource(r);
+	public void addInputSource(File source) {
+		try {
+			if (SpoonResourceHelper.isFile(source)) {
+				this.sources.addFile(SpoonResourceHelper.createFile(source));
+			} else {
+				this.sources.addFolder(SpoonResourceHelper.createFolder(source));
+			}
+		} catch (Exception e) {
+			throw new SpoonException(e);
 		}
 	}
 
+	@Override
 	public void addInputSource(SpoonResource source) {
 		if (source.isFile()) {
 			this.sources.addFile((SpoonFile) source);
@@ -432,18 +279,23 @@ public class JDTBasedSpoonCompiler implements SpoonCompiler {
 		}
 	}
 
-	public void addInputSource(File source) {
-		try {
-			if (SpoonResourceHelper.isFile(source)) {
-				this.sources.addFile(SpoonResourceHelper.createFile(source));
-			} else {
-				this.sources.addFolder(SpoonResourceHelper.createFolder(source));
-			}
-		} catch (Exception e) {
-			throw new SpoonException(e);
+	@Override
+	public void addInputSources(List<SpoonResource> resources) {
+		for (SpoonResource r : resources) {
+			addInputSource(r);
+		}
+	}
+
+	@Override
+	public Set<File> getInputSources() {
+		Set<File> files = new HashSet<File>();
+		for (SpoonFolder file : getSource().getSubFolders()) {
+			files.add(new File(file.getPath()));
 		}
+		return files;
 	}
 
+	@Override
 	public void addTemplateSource(SpoonResource source) {
 		if (source.isFile()) {
 			this.templates.addFile((SpoonFile) source);
@@ -452,6 +304,7 @@ public class JDTBasedSpoonCompiler implements SpoonCompiler {
 		}
 	}
 
+	@Override
 	public void addTemplateSource(File source) {
 		try {
 			if (SpoonResourceHelper.isFile(source)) {
@@ -462,214 +315,175 @@ public class JDTBasedSpoonCompiler implements SpoonCompiler {
 		} catch (Exception e) {
 			throw new SpoonException(e);
 		}
-
 	}
 
-	public boolean build() {
-		if (factory == null) {
-			throw new SpoonException("Factory not initialized");
-		}
-		if (build) {
-			throw new SpoonException("Model already built");
+	@Override
+	public void addTemplateSources(List<SpoonResource> resources) {
+		for (SpoonResource r : resources) {
+			addTemplateSource(r);
 		}
-		build = true;
+	}
 
-		boolean srcSuccess, templateSuccess;
-		factory.getEnvironment().debugMessage("building sources: " + sources.getAllJavaFiles());
-		long t = System.currentTimeMillis();
-		javaCompliance = factory.getEnvironment().getComplianceLevel();
-		srcSuccess = buildSources();
+	@Override
+	public Set<File> getTemplateSources() {
+		Set<File> files = new HashSet<File>();
+		for (SpoonFolder file : getTemplates().getSubFolders()) {
+			files.add(new File(file.getPath()));
+		}
+		return files;
+	}
 
-		reportProblems(factory.getEnvironment());
+	@Override
+	public void setSourceOutputDirectory(File outputDirectory) {
+		this.outputDirectory = outputDirectory;
+	}
 
-		factory.getEnvironment().debugMessage("built in " + (System.currentTimeMillis() - t) + " ms");
-		factory.getEnvironment().debugMessage("building templates: " + templates.getAllJavaFiles());
-		t = System.currentTimeMillis();
-		templateSuccess = buildTemplates();
-		// factory.Template().parseTypes();
-		factory.getEnvironment().debugMessage("built in " + (System.currentTimeMillis() - t) + " ms");
-		return srcSuccess && templateSuccess;
+	@Override
+	public File getSourceOutputDirectory() {
+		return outputDirectory;
 	}
 
-	protected void report(Environment environment, CategorizedProblem problem) {
-		if (problem == null) {
-			throw new IllegalArgumentException("problem cannot be null");
-		}
+	@Override
+	public void setBinaryOutputDirectory(File binaryOutputDirectory) {
+		this.binaryOutputDirectory = binaryOutputDirectory;
+	}
 
-		File file = new File(new String(problem.getOriginatingFileName()));
-		String filename = file.getAbsolutePath();
+	@Override
+	public File getBinaryOutputDirectory() {
+		return binaryOutputDirectory;
+	}
 
-		String message = problem.getMessage() + " at " + filename + ":" + problem.getSourceLineNumber();
+	@Override
+	public String[] getSourceClasspath() {
+		return getEnvironment().getSourceClasspath();
+	}
 
-		if (problem.isError()) {
-			if (!environment.getNoClasspath()) {
-				// by default, compilation errors are notified as exception
-				throw new ModelBuildingException(message);
-			} else {
-				// in noclasspath mode, errors are only reported
-				environment.report(null, problem.isError() ? Level.ERROR : Level.WARN, message);
-			}
-		}
+	@Override
+	public void setSourceClasspath(String... classpath) {
+		getEnvironment().setSourceClasspath(classpath);
+	}
 
+	@Override
+	public String[] getTemplateClasspath() {
+		return templateClasspath;
 	}
 
-	public void reportProblems(Environment environment) {
-		if (getProblems().size() > 0) {
-			for (CategorizedProblem problem : getProblems()) {
-				if (problem != null) {
-					report(environment, problem);
-				}
-			}
-		}
+	@Override
+	public void setTemplateClasspath(String... classpath) {
+		this.templateClasspath = classpath;
 	}
 
-	public Set<File> getInputSources() {
-		Set<File> files = new HashSet<File>();
-		for (SpoonFolder file : getSource().getSubFolders()) {
-			files.add(new File(file.getPath()));
-		}
-		return files;
+	@Override
+	public void setBuildOnlyOutdatedFiles(boolean buildOnlyOutdatedFiles) {
+		this.buildOnlyOutdatedFiles = buildOnlyOutdatedFiles;
 	}
 
-	public SpoonFolder getSource() {
-		return sources;
+	@Override
+	public void forceBuild(SpoonResource source) {
+		forceBuildList.add(source);
 	}
 
-	public SpoonFolder getTemplates() {
-		return templates;
+	@Override
+	public String getEncoding() {
+		return encoding;
 	}
 
-	public Set<File> getTemplateSources() {
-		Set<File> files = new HashSet<File>();
-		for (SpoonFolder file : getTemplates().getSubFolders()) {
-			files.add(new File(file.getPath()));
-		}
-		return files;
+	@Override
+	public void setEncoding(String encoding) {
+		this.encoding = encoding;
 	}
 
 	@Override
-	public boolean compile() {
-		initInputClassLoader();
-		factory.getEnvironment().debugMessage("compiling sources: " + factory.CompilationUnit().getMap().keySet());
-		long t = System.currentTimeMillis();
-		javaCompliance = factory.getEnvironment().getComplianceLevel();
+	public Factory getFactory() {
+		return factory;
+	}
 
-		JDTBatchCompiler batchCompiler = createBatchCompiler(true);
-		List<String> args = new ArrayList<String>();
-		args.add("-1." + javaCompliance);
-		if (encoding != null) {
-			args.add("-encoding");
-			args.add(encoding);
-		}
-		args.add("-preserveAllLocals");
-		args.add("-enableJavadoc");
-		args.add("-noExit");
-		// args.add("-verbose");
-		args.add("-proc:none");
-		if (getBinaryOutputDirectory() != null) {
-			args.add("-d");
-			args.add(getBinaryOutputDirectory().getAbsolutePath());
-		} else {
-			args.add("-d");
-			args.add("none");
+	protected boolean buildSources(JDTBuilder jdtBuilder) {
+		if (sources.getAllJavaFiles().isEmpty()) {
+			return true;
 		}
-
-		// args.add("-d");
-		// args.add(getDestinationDirectory().toString());
-
-		String finalClassPath = null;
-		if (getSourceClasspath() != null) {
-			finalClassPath = computeJdtClassPath();
+		initInputClassLoader();
+		JDTBatchCompiler batchCompiler = createBatchCompiler();
+		String[] args;
+		if (jdtBuilder == null) {
+			args = new JDTBuilderImpl() //
+					.classpathOptions(new ClasspathOptions().encoding(this.encoding).classpathFromListOrClassLoader(getSourceClasspath())) //
+					.complianceOptions(new ComplianceOptions().compliance(javaCompliance)) //
+					.advancedOptions(new AdvancedOptions().preserveUnusedVars().continueExecution().enableJavadoc()) //
+					.sources(new SourceOptions().sources(sources.getAllJavaFiles())) //
+					.build();
 		} else {
-			ClassLoader currentClassLoader = Thread.currentThread().getContextClassLoader();
-			if (currentClassLoader instanceof URLClassLoader) {
-				URL[] urls = ((URLClassLoader) currentClassLoader).getURLs();
-				if (urls != null && urls.length > 0) {
-					String classpath = ".";
-					for (URL url : urls) {
-						classpath += File.pathSeparator + url.getFile();
-					}
-					if (classpath != null) {
-						finalClassPath = classpath;
-					}
-				}
-			}
+			args = jdtBuilder.build();
 		}
+		getFactory().getEnvironment().debugMessage("build args: " + Arrays.toString(args));
 
-		args.add("-cp");
-		args.add(finalClassPath);
+		batchCompiler.configure(args);
 
+		List<SpoonFile> filesToBuild = sources.getAllJavaFiles();
 		if (buildOnlyOutdatedFiles) {
-
-			// ignore the files that are not outdated
 			if (outputDirectory.exists()) {
 				@SuppressWarnings("unchecked") Collection<File> outputFiles = FileUtils.listFiles(outputDirectory, new String[] { "java" }, true);
-				int offset = outputDirectory.getAbsolutePath().length() + 1;
-				Collection<String> relativeOutputPaths = new ArrayList<String>();
-				for (File f : outputFiles) {
-					relativeOutputPaths.add(f.getAbsolutePath().substring(offset));
-				}
-				for (SpoonFile sf : sources.getAllJavaFiles()) {
-					if (factory.CompilationUnit().getMap().containsKey(sf.getPath())) {
-						continue;
-					}
-					File source = sf.toFile();
-					for (String out : relativeOutputPaths) {
-						if (source.getAbsolutePath().endsWith(out)) {
-							if (source.lastModified() <= new File(outputDirectory, out).lastModified()) {
-								batchCompiler.ignoreFile(new File(outputDirectory, out).getAbsolutePath());
-							}
-						}
-					}
-				}
+				keepOutdatedFiles(filesToBuild, outputFiles);
+			} else {
+				keepOutdatedFiles(filesToBuild, new ArrayList<File>());
 			}
-
-			args.add(getBinaryOutputDirectory().getAbsolutePath());
-
-		} else {
-			args.addAll(toStringList(sources.getAllJavaFiles()));
 		}
+		CompilationUnitDeclaration[] units = batchCompiler.getUnits(filesToBuild);
 
-		getFactory().getEnvironment().debugMessage("compile args: " + args);
-
-		// batchCompiler.batchCompiler.useSingleThread = true;
-
-		System.setProperty("jdt.compiler.useSingleThread", "true");
-
-		batchCompiler.compile(args.toArray(new String[0]));
-
-		reportProblems(factory.getEnvironment());
+		// here we build the model
+		JDTTreeBuilder builder = new JDTTreeBuilder(factory);
+		for (CompilationUnitDeclaration unit : units) {
+			unit.traverse(builder, unit.scope);
+		}
 
-		factory.getEnvironment().debugMessage("compiled in " + (System.currentTimeMillis() - t) + " ms");
 		return probs.size() == 0;
-
 	}
 
-	Factory factory;
+	protected boolean buildTemplates(JDTBuilder jdtBuilder) {
+		if (templates.getAllJavaFiles().isEmpty()) {
+			return true;
+		}
+		JDTBatchCompiler batchCompiler = createBatchCompiler();
 
-	Map<String, char[]> loadedContent = new HashMap<String, char[]>();
+		File f = null;
+		String[] templateClasspath = new String[0];
+		if (getTemplateClasspath() != null && getTemplateClasspath().length > 0) {
+			templateClasspath = getTemplateClasspath();
+			for (SpoonFolder file : templates.getSubFolders()) {
+				if (file.isArchive()) {
+					// JDT bug HACK
+					f = createTmpJavaFile(file.getFileSystemParent());
+				}
+			}
+		}
 
-	@Override
-	public void generateProcessedSourceFiles(OutputType outputType) {
-		generateProcessedSourceFiles(outputType, null);
-	}
+		String[] args;
+		if (jdtBuilder == null) {
+			args = new JDTBuilderImpl() //
+					.classpathOptions(new ClasspathOptions().encoding(this.encoding).classpath(templateClasspath)) //
+					.complianceOptions(new ComplianceOptions().compliance(javaCompliance)) //
+					.advancedOptions(new AdvancedOptions().preserveUnusedVars().continueExecution().enableJavadoc()) //
+					.sources(new SourceOptions().sources(templates.getAllJavaFiles())) //
+					.build();
+		} else {
+			args = jdtBuilder.build();
+		}
 
-	@Override
-	public void generateProcessedSourceFiles(OutputType outputType, Filter<CtType<?>> typeFilter) {
-		initInputClassLoader();
-		switch (outputType) {
-		case CLASSES:
-			generateProcessedSourceFilesUsingTypes(typeFilter);
-			break;
-		case COMPILATION_UNITS:
-			generateProcessedSourceFilesUsingCUs();
-			break;
-		case NO_OUTPUT:
+		getFactory().getEnvironment().debugMessage("template build args: " + Arrays.toString(args));
+		batchCompiler.configure(args);
+		CompilationUnitDeclaration[] units = batchCompiler.getUnits(templates.getAllJavaFiles());
+
+		if (f != null && f.exists()) {
+			f.delete();
+		}
+
+		// here we build the model in the template factory
+		JDTTreeBuilder builder = new JDTTreeBuilder(factory);
+		for (CompilationUnitDeclaration unit : units) {
+			unit.traverse(builder, unit.scope);
 		}
-	}
 
-	protected void generateProcessedSourceFilesUsingTypes() {
-		generateProcessedSourceFilesUsingTypes(null);
+		return probs.size() == 0;
 	}
 
 	protected void generateProcessedSourceFilesUsingTypes(Filter<CtType<?>> typeFilter) {
@@ -753,134 +567,119 @@ public class JDTBasedSpoonCompiler implements SpoonCompiler {
 		}
 	}
 
-	protected InputStream getCompilationUnitInputStream(String path) {
-		Environment env = factory.getEnvironment();
-		spoon.reflect.cu.CompilationUnit cu = factory.CompilationUnit().getMap().get(path);
-		List<CtType<?>> toBePrinted = cu.getDeclaredTypes();
-
-		PrettyPrinter printer = null;
-
-		if (printer == null) {
-			printer = new DefaultJavaPrettyPrinter(env);
+	// this function is used to hack the JDT compiler...
+	protected File createTmpJavaFile(File folder) {
+		File f = new File(folder, "Tmp.java");
+		if (f.exists()) {
+			return f;
 		}
-		printer.calculate(cu, toBePrinted);
-
-		return new ByteArrayInputStream(printer.getResult().toString().getBytes());
-	}
-
-	@Override
-	public Factory getFactory() {
-		return factory;
+		try {
+			FileUtils.writeStringToFile(f, "class Tmp {}");
+			f.deleteOnExit();
+		} catch (Exception e) {
+			Launcher.LOGGER.error(e.getMessage(), e);
+		}
+		return f;
 	}
 
-	@Override
-	public boolean compileInputSources() {
-		initInputClassLoader();
-		factory.getEnvironment().debugMessage("compiling input sources: " + sources.getAllJavaFiles());
-		long t = System.currentTimeMillis();
-		javaCompliance = factory.getEnvironment().getComplianceLevel();
-
-		Main batchCompiler = createBatchCompiler(false);
-		List<String> args = new ArrayList<String>();
-		args.add("-1." + javaCompliance);
-		if (encoding != null) {
-			args.add("-encoding");
-			args.add(encoding);
-		}
-		args.add("-preserveAllLocals");
-		args.add("-enableJavadoc");
-		args.add("-noExit");
-		args.add("-proc:none");
-		if (getBinaryOutputDirectory() != null) {
-			args.add("-d");
-			args.add(getBinaryOutputDirectory().getAbsolutePath());
-		} else {
-			args.add("-d");
-			args.add("none");
+	protected void keepOutdatedFiles(List<SpoonFile> files, Collection<File> outputFiles) {
+		int offset = outputDirectory.getAbsolutePath().length() + 1;
+		Collection<String> relativeOutputPaths = new ArrayList<String>();
+		for (File f : outputFiles) {
+			relativeOutputPaths.add(f.getAbsolutePath().substring(offset));
 		}
-
-		String finalClassPath = null;
-		if (getSourceClasspath() != null) {
-			finalClassPath = computeJdtClassPath();
-		} else {
-			ClassLoader currentClassLoader = Thread.currentThread().getContextClassLoader();
-			if (currentClassLoader instanceof URLClassLoader) {
-				URL[] urls = ((URLClassLoader) currentClassLoader).getURLs();
-				if (urls != null && urls.length > 0) {
-					String classpath = ".";
-					for (URL url : urls) {
-						classpath += File.pathSeparator + url.getFile();
-					}
-					if (classpath != null) {
-						finalClassPath = classpath;
+		for (SpoonFile sf : new ArrayList<SpoonFile>(files)) {
+			if (forceBuildList.contains(sf)) {
+				continue;
+			}
+			File f = sf.toFile();
+			for (String s : relativeOutputPaths) {
+				if (f.getAbsolutePath().endsWith(s)) {
+					if (f.lastModified() <= new File(outputDirectory, s).lastModified()) {
+						files.remove(sf);
 					}
 				}
 			}
 		}
+	}
 
-		args.add("-cp");
-		args.add(finalClassPath);
+	public void setEnvironment(INameEnvironment environment) {
+		this.environment = environment;
+	}
 
-		// Set<String> paths = new HashSet<String>();
-		// for (SpoonFile file : sources.getAllJavaFiles()) {
-		// paths.add(file.getParent().getPath());
-		// }
-		// args.addAll(paths);
+	/**
+	 * report a compilation problem (callback for JDT)
+	 */
+	public void reportProblem(CategorizedProblem pb) {
+		if (pb == null) {
+			return;
+		}
 
-		args.addAll(toStringList(sources.getAllJavaFiles()));
+		// we can not accept this problem, even in noclasspath mode
+		// otherwise a nasty null pointer exception occurs later
+		if (pb.getID() == IProblem.DuplicateTypes) {
+			throw new ModelBuildingException(pb.getMessage());
+		}
 
-		// configure(args.toArray(new String[0]));
+		probs.add(pb);
+	}
 
-		batchCompiler.compile(args.toArray(new String[0]));
+	public void reportProblems(Environment environment) {
+		if (getProblems().size() > 0) {
+			for (CategorizedProblem problem : getProblems()) {
+				if (problem != null) {
+					report(environment, problem);
+				}
+			}
+		}
+	}
 
-		factory.getEnvironment().debugMessage("compiled in " + (System.currentTimeMillis() - t) + " ms");
-		return probs.size() == 0;
+	protected void report(Environment environment, CategorizedProblem problem) {
+		if (problem == null) {
+			throw new IllegalArgumentException("problem cannot be null");
+		}
 
-	}
+		File file = new File(new String(problem.getOriginatingFileName()));
+		String filename = file.getAbsolutePath();
 
-	@Override
-	public String[] getTemplateClasspath() {
-		return templateClasspath;
-	}
+		String message = problem.getMessage() + " at " + filename + ":" + problem.getSourceLineNumber();
 
-	@Override
-	public String[] getSourceClasspath() {
-		return getEnvironment().getSourceClasspath();
-	}
+		if (problem.isError()) {
+			if (!environment.getNoClasspath()) {
+				// by default, compilation errors are notified as exception
+				throw new ModelBuildingException(message);
+			} else {
+				// in noclasspath mode, errors are only reported
+				environment.report(null, problem.isError() ? Level.ERROR : Level.WARN, message);
+			}
+		}
 
-	@Override
-	public void setSourceClasspath(String... classpath) {
-		getEnvironment().setSourceClasspath(classpath);
-		;
 	}
 
-	@Override
-	public void setTemplateClasspath(String... classpath) {
-		this.templateClasspath = classpath;
+	/**
+	 * returns the list of current problems
+	 */
+	public List<CategorizedProblem> getProblems() {
+		return Collections.unmodifiableList(this.probs);
 	}
 
-	@Override
-	public void setBuildOnlyOutdatedFiles(boolean buildOnlyOutdatedFiles) {
-		this.buildOnlyOutdatedFiles = buildOnlyOutdatedFiles;
+	public SpoonFolder getSource() {
+		return sources;
 	}
 
-	List<SpoonResource> forceBuildList = new ArrayList<SpoonResource>();
-
-	@Override
-	public void forceBuild(SpoonResource source) {
-		forceBuildList.add(source);
+	public SpoonFolder getTemplates() {
+		return templates;
 	}
 
-	protected String encoding;
+	protected InputStream getCompilationUnitInputStream(String path) {
+		Environment env = factory.getEnvironment();
+		spoon.reflect.cu.CompilationUnit cu = factory.CompilationUnit().getMap().get(path);
+		List<CtType<?>> toBePrinted = cu.getDeclaredTypes();
 
-	@Override
-	public String getEncoding() {
-		return encoding;
-	}
+		PrettyPrinter printer = new DefaultJavaPrettyPrinter(env);
+		printer.calculate(cu, toBePrinted);
 
-	@Override
-	public void setEncoding(String encoding) {
-		this.encoding = encoding;
+		return new ByteArrayInputStream(printer.getResult().toString().getBytes());
 	}
 
 	private CompilerClassLoader getCompilerClassLoader(ClassLoader initialClassLoader) {
@@ -924,34 +723,6 @@ public class JDTBasedSpoonCompiler implements SpoonCompiler {
 		}
 	}
 
-	@Override
-	public void instantiateAndProcess(List<String> processors) {
-		initInputClassLoader();
-
-		// processing (consume all the processors)
-		ProcessingManager processing = new QueueProcessingManager(factory);
-		for (String processorName : processors) {
-			processing.addProcessor(processorName);
-			factory.getEnvironment().debugMessage("Loaded processor " + processorName + ".");
-		}
-
-		processing.process(factory.Package().getRootPackage());
-	}
-
-	@Override
-	public void process(Collection<Processor<? extends CtElement>> processors) {
-		initInputClassLoader();
-
-		// processing (consume all the processors)
-		ProcessingManager processing = new QueueProcessingManager(factory);
-		for (Processor<? extends CtElement> processorName : processors) {
-			processing.addProcessor(processorName);
-			factory.getEnvironment().debugMessage("Loaded processor " + processorName + ".");
-		}
-
-		processing.process(factory.Package().getRootPackage());
-	}
-
 	protected Environment getEnvironment() {
 		return getFactory().getEnvironment();
 	}
diff --git a/src/main/java/spoon/support/compiler/jdt/JDTSnippetCompiler.java b/src/main/java/spoon/support/compiler/jdt/JDTSnippetCompiler.java
index 527dba8d0..9f3919081 100644
--- a/src/main/java/spoon/support/compiler/jdt/JDTSnippetCompiler.java
+++ b/src/main/java/spoon/support/compiler/jdt/JDTSnippetCompiler.java
@@ -16,21 +16,23 @@
  */
 package spoon.support.compiler.jdt;
 
-import java.io.File;
-import java.net.URL;
-import java.net.URLClassLoader;
-import java.util.ArrayList;
-import java.util.List;
-
 import org.eclipse.jdt.core.compiler.CategorizedProblem;
 import org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;
-
 import spoon.SpoonException;
 import spoon.compiler.Environment;
+import spoon.compiler.builder.AdvancedOptions;
+import spoon.compiler.builder.ClasspathOptions;
+import spoon.compiler.builder.ComplianceOptions;
+import spoon.compiler.builder.JDTBuilder;
+import spoon.compiler.builder.JDTBuilderImpl;
+import spoon.compiler.builder.SourceOptions;
 import spoon.reflect.factory.Factory;
 import spoon.support.compiler.SnippetCompilationError;
 import spoon.support.compiler.VirtualFile;
 
+import java.io.File;
+import java.util.Arrays;
+
 public class JDTSnippetCompiler extends JDTBasedSpoonCompiler {
 
 	public JDTSnippetCompiler(Factory factory, String contents) {
@@ -40,6 +42,11 @@ public class JDTSnippetCompiler extends JDTBasedSpoonCompiler {
 
 	@Override
 	public boolean build() {
+		return build(null);
+	}
+
+	@Override
+	public boolean build(JDTBuilder builder) {
 		if (factory == null) {
 			throw new SpoonException("Factory not initialized");
 		}
@@ -48,72 +55,40 @@ public class JDTSnippetCompiler extends JDTBasedSpoonCompiler {
 		factory.getEnvironment().debugMessage("compiling sources: " + sources.getAllJavaFiles());
 		long t = System.currentTimeMillis();
 		javaCompliance = factory.getEnvironment().getComplianceLevel();
-		srcSuccess = buildSources();
+		srcSuccess = buildSources(builder);
 		reportProblems(factory.getEnvironment());
 		factory.getEnvironment().debugMessage("compiled in " + (System.currentTimeMillis() - t) + " ms");
-		t = System.currentTimeMillis();
 		return srcSuccess;
 	}
 
 	@Override
-	protected boolean buildSources() {
+	protected boolean buildSources(JDTBuilder jdtBuilder) {
 		if (sources.getAllJavaFiles().isEmpty()) {
 			return true;
 		}
-		// long t=System.currentTimeMillis();
-		// Build input
 		JDTBatchCompiler batchCompiler = createBatchCompiler();
-		List<String> args = new ArrayList<String>();
-		args.add("-1." + javaCompliance);
-		if (encoding != null) {
-			args.add("-encoding");
-			args.add(encoding);
-		}
-		args.add("-preserveAllLocals");
-		args.add("-enableJavadoc");
-		args.add("-noExit");
-		// args.add("-d");
-		// args.add("none");
-
-		if (getSourceClasspath() != null) {
-			args.add("-cp");
-			args.add(computeJdtClassPath());
+
+		File source = createTmpJavaFile(new File("."));
+		String[] args;
+		if (jdtBuilder == null) {
+			args = new JDTBuilderImpl() //
+					.classpathOptions(new ClasspathOptions().encoding(this.encoding).classpathFromListOrClassLoader(getSourceClasspath())) //
+					.complianceOptions(new ComplianceOptions().compliance(javaCompliance)) //
+					.advancedOptions(new AdvancedOptions().preserveUnusedVars().continueExecution().enableJavadoc()) //
+					.sources(new SourceOptions().sources(source.getPath())) //
+					.build();
 		} else {
-			ClassLoader currentClassLoader = Thread.currentThread().getContextClassLoader();
-			if (currentClassLoader instanceof URLClassLoader) {
-				URL[] urls = ((URLClassLoader) currentClassLoader).getURLs();
-				if (urls != null && urls.length > 0) {
-					String classpath = ".";
-					for (URL url : urls) {
-						classpath += File.pathSeparator + url.getFile();
-					}
-					if (classpath != null) {
-						args.add("-cp");
-						args.add(classpath);
-					}
-				}
-			}
+			args = jdtBuilder.build();
 		}
-		// args.add("-nowarn");
-		// Set<String> paths = new HashSet<String>();
-		// for (SpoonFile file : sources.getAllJavaFiles()) {
-		// // We can not use file.getPath() because of in-memory code or files
-		// // within archives
-		// paths.add(file.getParent().getPath());
-		// }
-		// args.addAll(paths);
-		// args.addAll(sources.getRootJavaPaths());
-
-		File f = createTmpJavaFile(new File("."));
-		args.add(f.getPath());
-		getFactory().getEnvironment().debugMessage("build args: " + args);
-
-		batchCompiler.configure(args.toArray(new String[0]));
+
+		getFactory().getEnvironment().debugMessage("build args: " + Arrays.toString(args));
+
+		batchCompiler.configure(args);
 
 		CompilationUnitDeclaration[] units = batchCompiler.getUnits(sources.getAllJavaFiles());
 
-		if (f != null && f.exists()) {
-			f.delete();
+		if (source.exists()) {
+			source.delete();
 		}
 
 		// here we build the model
@@ -128,7 +103,5 @@ public class JDTSnippetCompiler extends JDTBasedSpoonCompiler {
 	@Override
 	protected void report(Environment environment, CategorizedProblem problem) {
 		throw new SnippetCompilationError(problem.getMessage() + "at line " + problem.getSourceLineNumber());
-
 	}
-
 }
diff --git a/src/test/java/spoon/support/compiler/classpath/ComputeClasspathTest.java b/src/test/java/spoon/support/compiler/classpath/ComputeClasspathTest.java
index effbe7117..c75cecc04 100644
--- a/src/test/java/spoon/support/compiler/classpath/ComputeClasspathTest.java
+++ b/src/test/java/spoon/support/compiler/classpath/ComputeClasspathTest.java
@@ -3,16 +3,15 @@ package spoon.support.compiler.classpath;
 import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Test;
-
-import java.io.File;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-
 import spoon.Launcher;
 import spoon.compiler.SpoonCompiler;
+import spoon.compiler.builder.ClasspathOptions;
 import spoon.reflect.factory.Factory;
 import spoon.support.compiler.jdt.JDTBasedSpoonCompiler;
 
+import java.io.File;
+import java.lang.reflect.InvocationTargetException;
+
 public class ComputeClasspathTest {
 
 	private final static String TEST_CLASSPATH =
@@ -48,32 +47,8 @@ public class ComputeClasspathTest {
 	}
 
 	@Test
-	public void testTemplateClasspath()
-			throws NoSuchMethodException, InvocationTargetException,
-			IllegalAccessException {
-
-		// load protected method which computes the template classpath
-		Method method = this.compilerClass
-				.getDeclaredMethod("computeTemplateClasspath");
-		method.setAccessible(true);
-
-		this.compiler.setTemplateClasspath(this.systemClasspath);
-
-		Assert.assertEquals(TEST_CLASSPATH, method.invoke(this.compiler));
-	}
-
-	@Test
-	public void testSourceClasspath()
-			throws NoSuchMethodException, InvocationTargetException,
-			IllegalAccessException {
-
-		// load protected method which computes the source classpath
-		Method method = this.compilerClass
-				.getDeclaredMethod("computeJdtClassPath");
-		method.setAccessible(true);
-
-		this.compiler.setSourceClasspath(this.systemClasspath);
-
-		Assert.assertEquals(TEST_CLASSPATH, method.invoke(this.compiler));
+	public void testSourceClasspath() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
+		final ClasspathOptions options = new ClasspathOptions().classpath(systemClasspath);
+		Assert.assertEquals("-cp " + TEST_CLASSPATH, String.join(" ", options.build()));
 	}
 }
diff --git a/src/test/java/spoon/support/compiler/jdt/JDTBuilderTest.java b/src/test/java/spoon/support/compiler/jdt/JDTBuilderTest.java
new file mode 100644
index 000000000..7ddfbad05
--- /dev/null
+++ b/src/test/java/spoon/support/compiler/jdt/JDTBuilderTest.java
@@ -0,0 +1,43 @@
+package spoon.support.compiler.jdt;
+
+import org.junit.Test;
+import spoon.compiler.builder.AdvancedOptions;
+import spoon.compiler.builder.AnnotationProcessingOptions;
+import spoon.compiler.builder.ClasspathOptions;
+import spoon.compiler.builder.ComplianceOptions;
+import spoon.compiler.builder.JDTBuilderImpl;
+import spoon.compiler.builder.SourceOptions;
+
+import java.io.File;
+
+import static org.junit.Assert.assertEquals;
+
+public class JDTBuilderTest {
+	private final static String TEST_CLASSPATH = "./src/test/java/spoon/test/";
+
+	@Test
+	public void testJdtBuilder() throws Exception {
+		final String[] builder = new JDTBuilderImpl() //
+				.classpathOptions(new ClasspathOptions().classpath(TEST_CLASSPATH).bootclasspath(TEST_CLASSPATH).binaries(".").encoding("UTF-8")) //
+				.complianceOptions(new ComplianceOptions().compliance(8)) //
+				.annotationProcessingOptions(new AnnotationProcessingOptions().compileProcessors()) //
+				.advancedOptions(new AdvancedOptions().continueExecution().enableJavadoc().preserveUnusedVars()) //
+				.sources(new SourceOptions().sources(".")) //
+				.build();
+
+		assertEquals("-cp", builder[0]);
+		assertEquals(TEST_CLASSPATH, builder[1]);
+		assertEquals("-bootclasspath", builder[2]);
+		assertEquals(TEST_CLASSPATH, builder[3]);
+		assertEquals("-d", builder[4]);
+		assertEquals(new File(".").getAbsolutePath(), builder[5]);
+		assertEquals("-encoding", builder[6]);
+		assertEquals("UTF-8", builder[7]);
+		assertEquals("-1.8", builder[8]);
+		assertEquals("-proc:none", builder[9]);
+		assertEquals("-noExit", builder[10]);
+		assertEquals("-enableJavadoc", builder[11]);
+		assertEquals("-preserveAllLocals", builder[12]);
+		assertEquals(".", builder[13]);
+	}
+}
