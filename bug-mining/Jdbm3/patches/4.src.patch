diff --git a/src/main/java/net/kotek/jdbm/BlockIo.java b/src/main/java/net/kotek/jdbm/BlockIo.java
index 83db371..e303b5f 100644
--- a/src/main/java/net/kotek/jdbm/BlockIo.java
+++ b/src/main/java/net/kotek/jdbm/BlockIo.java
@@ -372,7 +372,7 @@ final class BlockIo {
      */
     boolean pageHeaderMagicOk() {
         int magic = pageHeaderGetMagic();
-        return magic >= Magic.BLOCK  && magic <= (Magic.BLOCK + Magic.FREEPHYSIDS_PAGE);
+        return magic >= Magic.BLOCK  && magic <= (Magic.BLOCK + Magic.FREEPHYSIDS_ROOT_PAGE);
     }
 
     /**
@@ -421,21 +421,6 @@ final class BlockIo {
     }
 
 
-//    long pageHeaderGetLocationBlock(short pos) {
-//        return readSixByteLong(pos + PhysicalRowId_O_LOCATION);
-//    }
-//
-//    void pageHeaderSetLocationBlock(short pos, long value) {
-//        writeSixByteLong(pos + PhysicalRowId_O_LOCATION, value);
-//    }
-
-//    short pageHeaderGetLocationOffset(short pos) {
-//        return readShort(pos + PhysicalRowId_O_OFFSET);
-//    }
-//
-//    void pageHeaderSetLocationOffset(short pos, short value) {
-//        writeShort(pos + PhysicalRowId_O_OFFSET, value);
-//    }
 
     short dataPageGetFirst() {
         return readShort(DATA_PAGE_O_FIRST);
@@ -449,91 +434,6 @@ final class BlockIo {
     }
 
 
-    /**
-     * Returns the number of free rowids
-     */
-    short FreePhysicalRowId_getCount() {
-        return readShort(FreePhysicalRowId_O_COUNT);
-    }
-
-    /**
-     * Sets the number of free rowids
-     */
-    private void FreePhysicalRowId_setCount(short i) {
-        writeShort(FreePhysicalRowId_O_COUNT, i);
-    }
-
-    /**
-     * Frees a slot
-     */
-    void FreePhysicalRowId_free(int slot) {
-        short pos = FreePhysicalRowId_slotToOffset(slot);
-        FreePhysicalRowId_setSize(pos, 0);
-        //get(slot).setSize(0);
-        FreePhysicalRowId_setCount((short) (FreePhysicalRowId_getCount() - 1));
-    }
-
-    /**
-     * Allocates a slot
-     */
-    short FreePhysicalRowId_alloc(int slot) {
-        FreePhysicalRowId_setCount((short) (FreePhysicalRowId_getCount() + 1));
-        return FreePhysicalRowId_slotToOffset(slot);
-    }
-
-    /**
-     * Returns true if a slot is free
-     */
-    boolean FreePhysicalRowId_isFree(int slot) {
-        short pos = FreePhysicalRowId_slotToOffset(slot);
-        return FreePhysicalRowId_getSize(pos) == 0;
-    }
-
-    /**
-     * Converts slot to offset
-     */
-    short FreePhysicalRowId_slotToOffset(int slot) {
-        return (short) (FreePhysicalRowId_O_FREE + (slot * FreePhysicalRowId_SIZE));
-    }
-
-    int FreePhysicalRowId_offsetToSlot(short pos) {
-        int pos2 = pos;
-        return (pos2 - FreePhysicalRowId_O_FREE) / FreePhysicalRowId_SIZE;
-    }
-
-
-    /**
-     * Returns first free slot, -1 if no slots are available
-     */
-    int FreePhysicalRowId_getFirstFree() {
-        if(FreeLogicalRowId_getCount()==FreePhysicalRowId_ELEMS_PER_PAGE)
-            return -1;
-        for (int i = 0; i < FreePhysicalRowId_ELEMS_PER_PAGE; i++) {
-            if (FreePhysicalRowId_isFree(i))
-                return i;
-        }
-        return -1;
-    }
-
-    /**
-     * Returns the size
-     */
-    int FreePhysicalRowId_getSize(short pos) {
-        return readInt(pos + FreePhysicalRowId_O_SIZE);
-    }
-
-    /**
-     * Sets the size
-     */
-    void FreePhysicalRowId_setSize(short pos, int value) {
-        writeInt(pos + FreePhysicalRowId_O_SIZE, value);
-    }
-
-    public long FreePhysicalRowId_slotToLocation(int slot) {
-        short pos = FreePhysicalRowId_slotToOffset(slot);
-        return pageHeaderGetLocation(pos);
-    }
-
 
     short FreeLogicalRowId_getCount() {
         return readShort(Magic.FreeLogicalRowId_O_COUNT);
diff --git a/src/main/java/net/kotek/jdbm/DBCache.java b/src/main/java/net/kotek/jdbm/DBCache.java
index 87b715b..2b9bf09 100644
--- a/src/main/java/net/kotek/jdbm/DBCache.java
+++ b/src/main/java/net/kotek/jdbm/DBCache.java
@@ -39,11 +39,11 @@ abstract class DBCache extends DBStore{
      */
     public DBCache(String filename, boolean readonly, boolean transactionDisabled,
                       Cipher cipherIn, Cipher cipherOut, boolean useRandomAccessFile,
-                      boolean autodefrag,boolean deleteFilesAfterClose){
+                     boolean deleteFilesAfterClose){
 
         super(filename, readonly, transactionDisabled,
                 cipherIn, cipherOut, useRandomAccessFile,
-                autodefrag,deleteFilesAfterClose);
+                deleteFilesAfterClose);
 
     }
 
diff --git a/src/main/java/net/kotek/jdbm/DBCacheMRU.java b/src/main/java/net/kotek/jdbm/DBCacheMRU.java
index aece133..26858e8 100644
--- a/src/main/java/net/kotek/jdbm/DBCacheMRU.java
+++ b/src/main/java/net/kotek/jdbm/DBCacheMRU.java
@@ -69,10 +69,10 @@ class DBCacheMRU
      */
     public DBCacheMRU(String filename, boolean readonly, boolean transactionDisabled,
                       Cipher cipherIn, Cipher cipherOut, boolean useRandomAccessFile,
-                      boolean autodefrag,boolean deleteFilesAfterClose, int cacheMaxRecords)  {
+                     boolean deleteFilesAfterClose, int cacheMaxRecords)  {
         super(filename, readonly, transactionDisabled,
             cipherIn, cipherOut, useRandomAccessFile,
-            autodefrag,deleteFilesAfterClose);
+            deleteFilesAfterClose);
 
         _hash = new LongHashMap<CacheEntry>(cacheMaxRecords);
         _max = cacheMaxRecords;
diff --git a/src/main/java/net/kotek/jdbm/DBCacheRef.java b/src/main/java/net/kotek/jdbm/DBCacheRef.java
index c3a0b48..83541b4 100644
--- a/src/main/java/net/kotek/jdbm/DBCacheRef.java
+++ b/src/main/java/net/kotek/jdbm/DBCacheRef.java
@@ -78,12 +78,12 @@ public class DBCacheRef
      */
     public DBCacheRef(String filename, boolean readonly, boolean transactionDisabled,
                       Cipher cipherIn, Cipher cipherOut, boolean useRandomAccessFile,
-                      boolean autodefrag,boolean deleteFilesAfterClose,
+                      boolean deleteFilesAfterClose,
                       byte cacheType, boolean cacheAutoClearOnLowMem) {
 
         super(filename, readonly, transactionDisabled,
                 cipherIn, cipherOut, useRandomAccessFile,
-                autodefrag,deleteFilesAfterClose);
+                deleteFilesAfterClose);
 
 
         this._cacheType = cacheType;
diff --git a/src/main/java/net/kotek/jdbm/DBMaker.java b/src/main/java/net/kotek/jdbm/DBMaker.java
index 0d02445..3a9a61b 100755
--- a/src/main/java/net/kotek/jdbm/DBMaker.java
+++ b/src/main/java/net/kotek/jdbm/DBMaker.java
@@ -41,7 +41,6 @@ public class DBMaker {
     private boolean useAES256Bit = true;
     private boolean useRandomAccessFile = false;
     private boolean autoClearRefCacheOnLowMem = true;
-    private boolean autoDefrag = true;
     private  boolean closeOnJVMExit = false;
     private  boolean deleteFilesAfterCloseFlag = false;
 
@@ -246,29 +245,6 @@ public class DBMaker {
         return this;
     }
 
-    /**
-     * JDBM is not very good at reclaiming free space after massive deletes.
-     * For this reason JDBM tracks store fragmentation and if performance
-     * penalty is too high, it automatically triggers defragmentation.
-     * <p/>
-     * Autodefragmentation always takes place after commit, so it is
-     * transparent to user, except delay while store is defragmented.
-     * With disabled transactions autodefrag may take place any time
-     * after write operation.
-     * <p/>
-     * Use this option to disable automatic defragmentation.
-     * You can reach better performance with manual defrag.
-     * For example when doing massive delete, it is best to
-     * trigger defrag after delete completed. Auto defrag could trigger
-     * more then once during delete operation.
-     *
-     * @return this builder
-     */
-    public DBMaker disableAutoDefrag(){
-        this.autoDefrag = false;
-        return this;
-    }
-
 
     /**
      * Registers shutdown hook and close database on JVM exit, if it was not already closed; 
@@ -338,11 +314,11 @@ public class DBMaker {
 
 
         if (cacheType == DBCacheRef.MRU){
-          db = new DBCacheMRU(location, readonly, disableTransactions, cipherIn, cipherOut,useRandomAccessFile,autoDefrag,deleteFilesAfterCloseFlag, mruCacheSize);
+          db = new DBCacheMRU(location, readonly, disableTransactions, cipherIn, cipherOut,useRandomAccessFile,deleteFilesAfterCloseFlag, mruCacheSize);
         }else if( cacheType == DBCacheRef.SOFT || cacheType == DBCacheRef.HARD || cacheType == DBCacheRef.WEAK) {
-            db = new DBCacheRef(location, readonly, disableTransactions, cipherIn, cipherOut,useRandomAccessFile,autoDefrag,deleteFilesAfterCloseFlag, cacheType,autoClearRefCacheOnLowMem);
+            db = new DBCacheRef(location, readonly, disableTransactions, cipherIn, cipherOut,useRandomAccessFile,deleteFilesAfterCloseFlag, cacheType,autoClearRefCacheOnLowMem);
         } else if (cacheType == DBCacheRef.NONE) {
-            db = new DBStore(location, readonly, disableTransactions, cipherIn, cipherOut,useRandomAccessFile,autoDefrag,deleteFilesAfterCloseFlag);
+            db = new DBStore(location, readonly, disableTransactions, cipherIn, cipherOut,useRandomAccessFile,deleteFilesAfterCloseFlag);
         } else {
             throw new IllegalArgumentException("Unknown cache type: " + cacheType);
         }
diff --git a/src/main/java/net/kotek/jdbm/DBStore.java b/src/main/java/net/kotek/jdbm/DBStore.java
index db2bced..4f706dd 100644
--- a/src/main/java/net/kotek/jdbm/DBStore.java
+++ b/src/main/java/net/kotek/jdbm/DBStore.java
@@ -76,7 +76,6 @@ class DBStore
      */
     private final boolean readonly;
     private final boolean transactionsDisabled;
-    private final boolean autodefrag;
     private final boolean deleteFilesAfterClose;
 
     private static final int AUTOCOMMIT_AFTER_N_PAGES = 1024 * 5;
@@ -131,7 +130,7 @@ class DBStore
     private final String _filename;
 
     public DBStore(String filename, boolean readonly, boolean transactionDisabled) throws IOException {
-        this(filename, readonly, transactionDisabled, null, null, false,true,false);
+        this(filename, readonly, transactionDisabled, null, null, false,false);
     }
 
 
@@ -143,14 +142,13 @@ class DBStore
      */
     public DBStore(String filename, boolean readonly, boolean transactionDisabled,
                    Cipher cipherIn, Cipher cipherOut, boolean useRandomAccessFile,
-                   boolean autodefrag,boolean deleteFilesAfterClose){
+                   boolean deleteFilesAfterClose){
         _filename = filename;
         this.readonly = readonly;
         this.transactionsDisabled = transactionDisabled;
         this.cipherIn = cipherIn;
         this.cipherOut = cipherOut;
         this.useRandomAccessFile = useRandomAccessFile;
-        this.autodefrag = autodefrag;
         this.deleteFilesAfterClose = deleteFilesAfterClose;
         reopen();
     }
@@ -160,8 +158,7 @@ class DBStore
         try{
         _file = new RecordFile(_filename, readonly, transactionsDisabled, cipherIn, cipherOut,useRandomAccessFile);
         _pageman = new PageManager(_file);
-        _physMgr = new PhysicalRowIdManager(_file, _pageman,
-                new PhysicalRowIdPageManagerFree(_file, _pageman));
+        _physMgr = new PhysicalRowIdManager(_file, _pageman);
 
         _logicMgr = new LogicalRowIdManager(_file, _pageman);
 
@@ -233,7 +230,7 @@ class DBStore
 
     boolean needsAutoCommit() {
         return  transactionsDisabled && !commitInProgress &&
-                (_file.getDirtyPageCount() >= AUTOCOMMIT_AFTER_N_PAGES || _physMgr.freeman.needsDefragementation);
+                (_file.getDirtyPageCount() >= AUTOCOMMIT_AFTER_N_PAGES );
     }
 
 
@@ -448,11 +445,6 @@ class DBStore
             _pageman.commit();
 
 
-            if(autodefrag && _physMgr.freeman.needsDefragementation){
-
-                _physMgr.freeman.needsDefragementation = false;
-                defrag(false);
-            }
         } catch (IOException e) {
             throw new IOError(e);
         }finally {
@@ -536,6 +528,18 @@ class DBStore
                 z.closeEntry();
                 _file.release(block);
             }
+            for (long pageid = _pageman.getFirst(Magic.FREEPHYSIDS_ROOT_PAGE);
+                 pageid != 0;
+                 pageid = _pageman.getNext(pageid)
+                    ) {
+                BlockIo block = _file.get(pageid);
+                String file = zip2 + pageid;
+                z.putNextEntry(new ZipEntry(file));
+                z.write(Utils.encrypt(cipherIn, block.getData()));
+                z.closeEntry();
+                _file.release(block);
+            }
+
             z.close();
 
         } catch (IOException e) {
@@ -666,7 +670,7 @@ class DBStore
             commit();
             final String filename2 = _filename + "_defrag" + System.currentTimeMillis();
             final String filename1 = _filename;
-            DBStore db2 = new DBStore(filename2, false, true, cipherIn, cipherOut, false,true,false);
+            DBStore db2 = new DBStore(filename2, false, true, cipherIn, cipherOut, false,false);
 
             //recreate logical file with original page layout
             {
diff --git a/src/main/java/net/kotek/jdbm/Magic.java b/src/main/java/net/kotek/jdbm/Magic.java
index 869dfad..fe6aca8 100644
--- a/src/main/java/net/kotek/jdbm/Magic.java
+++ b/src/main/java/net/kotek/jdbm/Magic.java
@@ -38,11 +38,12 @@ interface Magic {
     short TRANSLATION_PAGE = 2;
     short FREELOGIDS_PAGE = 3;
     short FREEPHYSIDS_PAGE = 4;
+    short FREEPHYSIDS_ROOT_PAGE = 5;
 
     /**
      * Number of lists in a file
      */
-    short NLISTS = 5;
+    short NLISTS = 6;
 
     /**
      * Magic for transaction file
@@ -97,13 +98,6 @@ interface Magic {
     short DATA_PER_PAGE = (short) (Storage.BLOCK_SIZE - DATA_PAGE_O_DATA);
 
 
-    short FreePhysicalRowId_O_SIZE = Magic.PhysicalRowId_SIZE; // int size
-    short FreePhysicalRowId_SIZE = FreePhysicalRowId_O_SIZE + Magic.SZ_INT;
-
-    // offsets
-    short FreePhysicalRowId_O_COUNT = Magic.PAGE_HEADER_SIZE; // short count
-    short FreePhysicalRowId_O_FREE = FreePhysicalRowId_O_COUNT + Magic.SZ_SHORT;
-    short FreePhysicalRowId_ELEMS_PER_PAGE = (short) ((Storage.BLOCK_SIZE - FreePhysicalRowId_O_FREE) / FreePhysicalRowId_SIZE);
 
 
     // offsets
diff --git a/src/main/java/net/kotek/jdbm/PhysicalFreeRowIdManager.java b/src/main/java/net/kotek/jdbm/PhysicalFreeRowIdManager.java
new file mode 100644
index 0000000..29f670e
--- /dev/null
+++ b/src/main/java/net/kotek/jdbm/PhysicalFreeRowIdManager.java
@@ -0,0 +1,230 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package net.kotek.jdbm;
+
+import java.io.IOException;
+import java.util.Arrays;
+
+/**
+ * This class manages free physical rowid pages and provides methods to free and allocate physical rowids on a high
+ * level.
+ */
+final class PhysicalFreeRowIdManager {
+
+    /** maximal record size which can be hold. If record crosses multiple pages, it is trimmed before added to free list */
+    static final int MAX_REC_SIZE = Storage.BLOCK_SIZE *2;
+
+    /** where data on root page starts, there are no extra data in page header */
+    static final int ROOT_HEADER_SIZE = Magic.PAGE_HEADER_SIZE;
+
+    /** page header size for slot page */
+    static final int SLOT_PAGE_HEADER_SIZE = Magic.PAGE_HEADER_SIZE + Magic.SZ_SHORT + Magic.SZ_SIX_BYTE_LONG;
+
+    /**  number of recids on slot page */
+    static final int OFFSET_SLOT_PAGE_REC_COUNT = Magic.PAGE_HEADER_SIZE;
+
+    static final int SLOT_PAGE_REC_NUM = (Storage.BLOCK_SIZE - SLOT_PAGE_HEADER_SIZE)/6;
+
+    /** pointer to next slo page in slot page header */
+    static final int OFFSET_SLOT_PAGE_NEXT = Magic.PAGE_HEADER_SIZE + Magic.SZ_SHORT;
+
+    /** number of size slots held in root page */
+    static final int ROOT_SLOT_NUM = (Storage.BLOCK_SIZE  -ROOT_HEADER_SIZE-6) / 6; //6 is size of page pointer
+
+    /** free records are grouped into slots by record size. Here is max diff in record size per group */
+    static final int ROOT_SLOT_SIZE = 1+MAX_REC_SIZE/ ROOT_SLOT_NUM;
+
+
+    protected final RecordFile file;
+
+    protected final PageManager pageman;
+
+    private long[] inTransRecid = new long[8];
+    private short[] inTransCapacity = new short[8];
+    private int inTransSize = 0;
+
+    /**
+     * Creates a new instance using the indicated record file and page manager.
+     */
+    PhysicalFreeRowIdManager(RecordFile file, PageManager pageman) throws IOException {
+        this.file = file;
+        this.pageman = pageman;
+    }
+
+    long getFreeRecord(final int size) throws IOException {
+        if(size >= MAX_REC_SIZE) return 0;
+
+        final BlockIo root = getRootPage();
+        final int  rootPageOffset = sizeToRootOffset(size+ ROOT_SLOT_SIZE);
+        final long slotPageId = root.readSixByteLong(rootPageOffset);
+
+        if(slotPageId==0){
+            file.release(root);
+            return 0;
+        }
+
+        BlockIo slotPage = file.get(slotPageId);
+
+        short recidCount = slotPage.readShort(OFFSET_SLOT_PAGE_REC_COUNT);
+        if(recidCount<=0){
+            file.release(slotPage);
+            file.release(root);
+            return 0;
+        }
+
+        final int offset = (recidCount-1) * 6 + SLOT_PAGE_HEADER_SIZE;
+        final long recid = slotPage.readSixByteLong(offset);
+
+        recidCount --;
+        if(recidCount>0){
+            //decrease counter and zero out old record
+            slotPage.writeSixByteLong(offset,0);
+            slotPage.writeShort(OFFSET_SLOT_PAGE_REC_COUNT, recidCount);
+            file.release(root);
+            file.release(slotPage);
+        }else{
+            //release this page
+            long prevSlotPageId = slotPage.readSixByteLong(OFFSET_SLOT_PAGE_NEXT);
+            root.writeSixByteLong(rootPageOffset,prevSlotPageId);
+            file.release(root);
+            file.release(slotPage);
+            pageman.free(Magic.FREEPHYSIDS_PAGE,slotPageId);
+
+        }
+
+        return recid;
+    }
+
+    static final  int sizeToRootOffset(int size) {
+        return ROOT_HEADER_SIZE + 6 * (size/ROOT_SLOT_SIZE);
+    }
+
+
+    /**
+     * Puts the indicated rowid on the free list, which awaits for commit
+     */
+    void putFreeRecord(final long rowid, final int size) throws IOException {
+        //ensure capacity
+        if(inTransSize==inTransRecid.length){
+            inTransRecid = Arrays.copyOf(inTransRecid, inTransRecid.length * 2);
+            inTransCapacity = Arrays.copyOf(inTransCapacity, inTransCapacity.length * 2);
+        }
+        inTransRecid[inTransSize] = rowid;
+        inTransCapacity[inTransSize] = (short) size;
+        inTransSize++;
+    }
+
+
+    public void commit() throws IOException {
+
+        if(inTransSize==0)
+            return;
+
+        Utils.quickSort(inTransRecid, inTransCapacity, 0, inTransSize - 1);
+
+        //try to merge records released next to each other into single one
+        int prevIndex = 0;
+        for(int i=1;i<inTransSize;i++){
+            if(inTransCapacity[i] == 0) continue;
+
+            if(inTransCapacity[i] + inTransCapacity[prevIndex]<Short.MAX_VALUE &&
+                inTransRecid[prevIndex] + inTransCapacity[i] == inTransRecid[i]){
+                //increase previous record size and effectively delete old record size
+                final long blockId = Location.getBlock(inTransRecid[prevIndex]);
+                BlockIo b = file.get(blockId);
+                RecordHeader.setCurrentSize(b,Location.getOffset(inTransRecid[prevIndex]), 0);
+                inTransCapacity[prevIndex]+=inTransCapacity[i];
+                RecordHeader.setAvailableSize(b,Location.getOffset(inTransRecid[prevIndex]), inTransCapacity[prevIndex]);
+                file.release(b);
+                //zero out curr record, so it does not get added to list
+                inTransRecid[i] = 0;
+                inTransCapacity[i] = 0;
+                //move to next, without leaving previous record
+                i++;
+                continue;
+            }
+            prevIndex = i;
+        }
+
+        //write all uncommited free records
+        final BlockIo root = getRootPage();
+
+        for(int rowIdPos = 0; rowIdPos<inTransSize; rowIdPos++){
+                final int size = inTransCapacity[rowIdPos];
+                if(size == 0){
+                    continue;
+                }
+
+                final long rowid = inTransRecid[rowIdPos];
+                final int rootPageOffset = sizeToRootOffset(size);
+
+                long slotPageId  = root.readSixByteLong(rootPageOffset);
+                if(slotPageId == 0){
+                        //create new page for this slot
+                        slotPageId = pageman.allocate(Magic.FREEPHYSIDS_PAGE);
+                        root.writeSixByteLong(rootPageOffset,slotPageId);
+                }
+                BlockIo slotPage = file.get(slotPageId);
+
+                short recidCount = slotPage.readShort(OFFSET_SLOT_PAGE_REC_COUNT);
+                if(recidCount==ROOT_SLOT_NUM){
+                    file.release(slotPage);
+                    //allocate new slot page and update links
+                    final long newSlotPageId = pageman.allocate(Magic.FREEPHYSIDS_PAGE);
+                    slotPage = file.get(newSlotPageId);
+                    slotPage.writeSixByteLong(OFFSET_SLOT_PAGE_NEXT,slotPageId);
+                    slotPage.writeShort(OFFSET_SLOT_PAGE_REC_COUNT,(short)0);
+                    recidCount = 0;
+                    slotPageId = newSlotPageId;
+                    root.writeSixByteLong(rootPageOffset,newSlotPageId);
+                }
+
+                //write new recid
+                slotPage.writeSixByteLong(recidCount * 6 + SLOT_PAGE_HEADER_SIZE,rowid);
+
+                //and increase count
+                recidCount++;
+                slotPage.writeShort(OFFSET_SLOT_PAGE_REC_COUNT,recidCount);
+                file.release(slotPage);
+        }
+
+        file.release(root);
+        clearFreeInTrans();
+    }
+
+
+    public void rollback() {
+        clearFreeInTrans();
+    }
+
+    private void clearFreeInTrans() {
+        if(inTransRecid.length>128)
+            inTransRecid = new long[8];
+        if(inTransCapacity.length>128)
+            inTransCapacity = new short[8];
+        inTransSize = 0;
+    }
+
+    /** return free phys row page. If not found create it */
+    final  BlockIo getRootPage() throws IOException {
+        long blockId = pageman.getFirst(Magic.FREEPHYSIDS_ROOT_PAGE);
+        if(blockId == 0){
+            blockId = pageman.allocate(Magic.FREEPHYSIDS_ROOT_PAGE);
+        }
+        return file.get(blockId);
+    }
+}
diff --git a/src/main/java/net/kotek/jdbm/PhysicalRowIdManager.java b/src/main/java/net/kotek/jdbm/PhysicalRowIdManager.java
index 29cb8ed..ee1a83e 100755
--- a/src/main/java/net/kotek/jdbm/PhysicalRowIdManager.java
+++ b/src/main/java/net/kotek/jdbm/PhysicalRowIdManager.java
@@ -28,7 +28,7 @@ final class PhysicalRowIdManager {
     // The file we're talking to and the associated page manager.
     final private RecordFile file;
     final private PageManager pageman;
-    final PhysicalRowIdPageManagerFree freeman;
+    final PhysicalFreeRowIdManager freeman;
     static final private short DATA_PER_PAGE = (short) (BLOCK_SIZE - Magic.DATA_PAGE_O_DATA);
     //caches offset after last allocation. So we dont have to iterate throw page every allocation
     private long cachedLastAllocatedRecordPage = Long.MIN_VALUE;
@@ -37,16 +37,13 @@ final class PhysicalRowIdManager {
     /**
      * Creates a new rowid manager using the indicated record file. and page manager.
      */
-    PhysicalRowIdManager(RecordFile file, PageManager pageManager, PhysicalRowIdPageManagerFree freeman) throws IOException {
+    PhysicalRowIdManager(RecordFile file, PageManager pageManager) throws IOException {
         this.file = file;
         this.pageman = pageManager;
-        this.freeman = freeman;
+        this.freeman = new PhysicalFreeRowIdManager(file, pageManager);
 
     }
 
-    public PhysicalRowIdManager(RecordFile f, PageManager pm) throws IOException {
-        this(f,pm,new PhysicalRowIdPageManagerFree(f, pm));
-    }
 
     /**
      * Inserts a new record. Returns the new physical rowid.
diff --git a/src/main/java/net/kotek/jdbm/PhysicalRowIdPageManagerFree.java b/src/main/java/net/kotek/jdbm/PhysicalRowIdPageManagerFree.java
deleted file mode 100644
index aedb250..0000000
--- a/src/main/java/net/kotek/jdbm/PhysicalRowIdPageManagerFree.java
+++ /dev/null
@@ -1,322 +0,0 @@
-/*******************************************************************************
- * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package net.kotek.jdbm;
-
-import java.io.IOException;
-import java.util.Arrays;
-
-/**
- * This class manages free physical rowid pages and provides methods to free and allocate physical rowids on a high
- * level.
- */
-final class PhysicalRowIdPageManagerFree {
-
-    /**
-     * massive deletes leaves lot of free phys pages. 
-     * This slows down new allocations, so this is one of the criteria for 
-     * autodefragmentation 
-     */
-    static final int DEFRAGMENT_AFTER_N_PAGES = 255;
-
-    boolean needsDefragementation = false;
-
-    
-    /**
-     * Used to place a limit on the wasted capacity resulting in a modified first fit policy for re-allocated of free
-     * records. This value is the maximum first fit waste that is accepted when scanning the available slots on a given
-     * page of the free physical row page list.
-     */
-    static final transient int wasteMargin = 128;
-
-    /**
-     * Used to place a limit on the wasted capacity resulting in a modified first fit policy for re-allocated of free
-     * records. This value is the upper bound of waste that is accepted before scanning another page on the free
-     * physical row page list. If no page can be found whose waste for the re-allocation request would be less than this
-     * value then a new page will be allocated and the requested physical row will be allocated from that new page.
-     */
-    static final transient int wasteMargin2 = Magic.PAGE_HEADER_SIZE / 4;
-    
-    // our record file
-    protected RecordFile _file;
-
-    // our page manager
-    protected PageManager _pageman;
-
-    private long[] inTransRecid = new long[4];
-    private int[] inTransCapacity = new int[4];
-    private int inTransSize = 0;
-
-    /**
-     * Creates a new instance using the indicated record file and page manager.
-     */
-    PhysicalRowIdPageManagerFree(RecordFile file, PageManager pageman) throws IOException {
-        _file = file;
-        _pageman = pageman;
-    }
-
-    private int lastMaxSize = -1;
-
-    /**
-     * Returns first slot with available size >= indicated size, or minus maximal size available on this page
-     *
-     * @param b  BlockIO
-     * @param requestedSize requested allocation size.
-     */
-    static int getFirstFreeLargerThan(BlockIo b, final int requestedSize) {
-
-        int maxSize = 0;
-        /*
-           * Tracks slot of the smallest available physical row on the page.
-           */
-        int bestSlot = -1;
-        /*
-           * Tracks size of the smallest available physical row on the page.
-           */
-        int bestSlotSize = 0;
-        /*
-           * Scan each slot in the page.
-           */
-        for (int i = 0; i < Magic.FreePhysicalRowId_ELEMS_PER_PAGE; i++) {
-            /*
-                * When large allocations are used, the space wasted by the first fit policy can become very large (25% of
-                * the store). The first fit policy has been modified to only accept a record with a maximum amount of
-                * wasted capacity given the requested allocation size.
-                */
-            // Note: isAllocated(i) is equiv to get(i).getSize() != 0
-            //long theSize = get(i).getSize(); // capacity of this free record.
-            short pos = b.FreePhysicalRowId_slotToOffset(i);
-            int currentRecSize = b.FreePhysicalRowId_getSize(pos); // capacity of this free record.
-            if (currentRecSize > maxSize) maxSize = currentRecSize;
-            int waste = currentRecSize - requestedSize; // when non-negative, record has suf. capacity.
-            if (waste >= 0) {
-                if (waste < wasteMargin) {
-                    return i; // record has suf. capacity and not too much waste.
-                } else if (bestSlotSize >= currentRecSize) {
-                    /*
-                          * This slot is a better fit that any that we have seen so far on this page so we update the slot#
-                          * and available size for that slot.
-                          */
-                    bestSlot = i;
-                    bestSlotSize = currentRecSize;
-                }
-            }
-        }
-        if (bestSlot != -1) {
-            /*
-                * An available slot was identified that is large enough, but it exceeds the first wasted capacity limit. At
-                * this point we check to see whether it is under our second wasted capacity limit. If it is, then we return
-                * that slot.
-                */
-            long waste = bestSlotSize - requestedSize; // when non-negative, record has suf. capacity.
-            if (waste >= 0 && waste < wasteMargin2) {
-                // record has suf. capacity and not too much waste.
-                return bestSlot;
-            }
-            /*
-                * Will scan next page on the free physical row page list.
-                */
-        }
-
-        return -maxSize;
-    }
-
-    /**
-     * Returns a free physical rowid of the indicated size, or null if nothing was found. This scans the free physical
-     * row table, which is modeled as a linked list of pages. Each page on that list has slots that are either free
-     * (awaiting the insertion of the location of a free physical row) or available for reallocation requests. An
-     * allocated slot is indicated by a non-zero size field in that slot and the size is the size of the available free
-     * record in bytes.
-     */
-    long getFreeRecord(final int size) throws IOException {
-        //first check data in transaction, maybe some of them are usable
-
-        for(int i = 0;i<inTransSize;i++){
-            //check if size is in limits
-            if(inTransCapacity[i]>=size &&  inTransCapacity[i]<size + wasteMargin)
-            {
-                final long ret = inTransRecid[i];
-                //move last item to current pos and delete current item
-                inTransSize--;
-                inTransRecid[i] = inTransRecid[inTransSize];
-                inTransCapacity[i] = inTransCapacity[inTransSize];
-
-                return ret;
-            }
-                
-        }
-
-        int pageCounter = 0;
-
-        //requested record is bigger than any previously found
-        if (lastMaxSize != -1 && size > lastMaxSize)
-            return 0;
-
-        // Loop through the free physical rowid list until we get
-        // a rowid that's large enough.
-        long retval = 0;
-
-        int maxSize = -1;
-        for (long current = _pageman.getFirst(Magic.FREEPHYSIDS_PAGE); current != 0; current = _pageman.getNext(current)) {
-            BlockIo fp = _file.get(current);
-            pageCounter++;
-            int slot = getFirstFreeLargerThan(fp, size);
-            if (slot > 0) {
-                //reset maximal size, as record has changed
-                lastMaxSize = -1;
-                // got one!
-                retval = fp.FreePhysicalRowId_slotToLocation(slot);
-
-                fp.FreePhysicalRowId_free(slot);
-                if (fp.FreePhysicalRowId_getCount() == 0) {
-                    // page became empty - free it
-                    _file.release(current, false);
-                    _pageman.free(Magic.FREEPHYSIDS_PAGE, current);
-                } else {
-                    _file.release(current, true);
-                }
-
-
-
-                if(pageCounter>DEFRAGMENT_AFTER_N_PAGES)
-                    needsDefragementation = true;
-
-                return retval;
-            } else {
-                if (maxSize < -slot)
-                    maxSize = -slot;
-                // no luck, go to next page
-                _file.release(current, false);
-            }
-
-        }
-        //update maximal size available
-        lastMaxSize = maxSize;
-
-
-        if(pageCounter>DEFRAGMENT_AFTER_N_PAGES)
-            needsDefragementation = true;
-
-        return 0;
-    }
-
-
-    /**
-     * Puts the indicated rowid on the free list, which avaits for commit
-     */
-    void putFreeRecord(final long rowid, final int size) throws IOException {
-        //ensure capacity
-        if(inTransSize==inTransRecid.length){
-            inTransRecid = Arrays.copyOf(inTransRecid, inTransRecid.length * 2);
-            inTransCapacity = Arrays.copyOf(inTransCapacity, inTransCapacity.length * 2);
-        }
-        inTransRecid[inTransSize] = rowid;
-        inTransCapacity[inTransSize] = size;
-        inTransSize++;
-    }
-
-    public void commit() throws IOException {
-        if(inTransSize==0)
-            return;
-
-        Utils.quickSort(inTransRecid, inTransCapacity, 0, inTransSize - 1);
-
-        //try to merge records released next to each other into single one
-        int prevIndex = 0;
-        for(int i=1;i<inTransSize;i++){
-            if(inTransCapacity[i] == 0) continue;
-
-            if(inTransCapacity[i] + inTransCapacity[prevIndex]<Short.MAX_VALUE &&
-                inTransRecid[prevIndex] + inTransCapacity[i] == inTransRecid[i]){
-                //increase previous record size and effectively delete old record size
-                final long blockId = Location.getBlock(inTransRecid[prevIndex]);
-                BlockIo b = _file.get(blockId);
-                RecordHeader.setCurrentSize(b,Location.getOffset(inTransRecid[prevIndex]), 0);
-                inTransCapacity[prevIndex]+=inTransCapacity[i];
-                RecordHeader.setAvailableSize(b,Location.getOffset(inTransRecid[prevIndex]), inTransCapacity[prevIndex]);
-                _file.release(b);
-                //zero out curr record, so it does not get added to list
-                inTransRecid[i] = 0;
-                inTransCapacity[i] = 0;
-                //move to next, without leaving previous record
-                i++;
-                continue;
-            }
-            prevIndex = i;
-        }
-
-        //write all uncommited free records
-        int rowidpos = 0;
-
-
-        //iterate over free recid pages
-
-        long curpage = _pageman.getFirst(Magic.FREEPHYSIDS_PAGE);
-
-
-        if(_file.transactionsDisabled && inTransSize>200){
-            //iterating over existing free pages can be time consuming
-            //so disable it under some conditions and start allocating new freePhys pages
-            //straight away
-            curpage = 0;
-        }
-
-        while (rowidpos < inTransSize) {
-
-            //get next page for free recid, allocate new page if needed
-            BlockIo fp = curpage!=0 ? _file.get(curpage) :
-                    _file.get(_pageman.allocate(Magic.FREEPHYSIDS_PAGE));
-            
-            int slot = fp.FreePhysicalRowId_getFirstFree();
-            //iterate over free slots in page and fill them
-            while (slot != -1 && rowidpos < inTransSize) {
-                int size = inTransCapacity[rowidpos];
-                long rowid = inTransRecid[rowidpos++];
-                if(size == 0) continue;
-
-                short freePhysPos = fp.FreePhysicalRowId_alloc(slot);
-                fp.pageHeaderSetLocation(freePhysPos, rowid);
-                fp.FreePhysicalRowId_setSize(freePhysPos, size);
-                slot = fp.FreePhysicalRowId_getFirstFree();
-
-
-            }
-            _file.release(fp);
-            if (!(rowidpos < inTransSize))
-                break;
-
-
-            if(curpage!=0){
-                    curpage = _pageman.getNext(curpage);
-            }
-        }
-
-        clearFreeInTrans();
-    }
-
-
-    public void rollback() {
-        clearFreeInTrans();
-    }
-
-    private void clearFreeInTrans() {
-        if(inTransRecid.length>128)
-            inTransRecid = new long[4];
-        if(inTransCapacity.length>128)
-            inTransCapacity = new int[4];
-        inTransSize = 0;
-    }
-}
diff --git a/src/main/java/net/kotek/jdbm/Utils.java b/src/main/java/net/kotek/jdbm/Utils.java
index cea5469..1eafaa2 100644
--- a/src/main/java/net/kotek/jdbm/Utils.java
+++ b/src/main/java/net/kotek/jdbm/Utils.java
@@ -107,9 +107,10 @@ class Utils {
 
 
     /** quick sort which also sorts elements in second array*/
-    static void quickSort(final long array[], final int array2[], final int low, final int n){
+    static void quickSort(final long array[], final short array2[], final int low, final int n){
         long temp;
         int temp2;
+        short temp3;
         int lo = low;
         int hi = n;
         if (lo >= n) {
@@ -127,9 +128,9 @@ class Utils {
                 temp = array[lo];
                 array[lo] = array[hi];
                 array[hi] = temp;
-                temp2 = array2[lo];
+                temp3 = array2[lo];
                 array2[lo] = array2[hi];
-                array2[hi] = temp2;
+                array2[hi] = temp3;
             }
         }
         if (hi < lo) {
diff --git a/src/test/java/net/kotek/jdbm/FreePhysicalRowIdPageTest.java b/src/test/java/net/kotek/jdbm/FreePhysicalRowIdPageTest.java
deleted file mode 100644
index 27784a4..0000000
--- a/src/test/java/net/kotek/jdbm/FreePhysicalRowIdPageTest.java
+++ /dev/null
@@ -1,83 +0,0 @@
-/*******************************************************************************
- * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package net.kotek.jdbm;
-
-import junit.framework.TestCase;
-
-public class FreePhysicalRowIdPageTest extends TestCase {
-
-
-    /**
-     * Test basics
-     */
-    public void testBasics() throws Exception {
-        byte[] data = new byte[Storage.BLOCK_SIZE];
-        BlockIo page = new BlockIo(0, data);
-
-
-        // we have a completely empty page.
-        assertEquals("zero count", 0, page.FreePhysicalRowId_getCount());
-
-        // three allocs
-        short id = page.FreePhysicalRowId_alloc(0);
-        id = page.FreePhysicalRowId_alloc(1);
-        id = page.FreePhysicalRowId_alloc(2);
-        assertEquals("three count", 3, page.FreePhysicalRowId_getCount());
-
-        // setup last id (2)
-        page.pageHeaderSetLocation(id, Location.toLong(1, (short) 2));
-        page.FreePhysicalRowId_setSize(id, 3);
-
-        // two frees
-        page.FreePhysicalRowId_free(0);
-        page.FreePhysicalRowId_free(1);
-        assertEquals("one left count", 1, page.FreePhysicalRowId_getCount());
-        assertTrue("isfree 0", page.FreePhysicalRowId_isFree(0));
-        assertTrue("isfree 1", page.FreePhysicalRowId_isFree(1));
-        assertTrue("isalloc 2", !page.FreePhysicalRowId_isFree(2));
-
-        // now, create a new page over the data and check whether
-        // it's all the same.
-        page = new BlockIo(0,data);
-
-        assertEquals("2: one left count", 1, page.FreePhysicalRowId_getCount());
-        assertTrue("2: isfree 0", page.FreePhysicalRowId_isFree(0));
-        assertTrue("2: isfree 1", page.FreePhysicalRowId_isFree(1));
-        assertTrue("2: isalloc 2", !page.FreePhysicalRowId_isFree(2));
-
-        id = page.FreePhysicalRowId_slotToOffset(2);
-        long loc = page.pageHeaderGetLocation(id);
-        assertEquals("block", 1, Location.getBlock(loc));
-        assertEquals("offset", 2, Location.getOffset(loc));
-        assertEquals("size", 3, page.FreePhysicalRowId_getSize(id));
-
-    }
-
-
-    public void testOffsetSlotConversion() {
-        byte[] data = new byte[Storage.BLOCK_SIZE];
-        BlockIo page = new BlockIo(0, data);
-
-        for (int slot = 0; slot < 1e5; slot++) {
-            short pos = page.FreePhysicalRowId_slotToOffset(slot);
-            if (pos > 20000) return; //out of page size
-            int slot2 = page.FreePhysicalRowId_offsetToSlot(pos);
-            assertEquals("failed for " + slot + " , " + pos, slot, slot2);
-        }
-    }
-
-}
diff --git a/src/test/java/net/kotek/jdbm/PhysicalFreeRowIdManagerTest.java b/src/test/java/net/kotek/jdbm/PhysicalFreeRowIdManagerTest.java
new file mode 100644
index 0000000..d942001
--- /dev/null
+++ b/src/test/java/net/kotek/jdbm/PhysicalFreeRowIdManagerTest.java
@@ -0,0 +1,116 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package net.kotek.jdbm;
+
+
+import java.io.IOException;
+
+/**
+ * This class contains all Unit tests for {@link PhysicalFreeRowIdManager}.
+ */
+public class PhysicalFreeRowIdManagerTest extends TestCaseWithTestFile {
+
+    /**
+     * Test constructor
+     */
+    public void testCtor() throws Exception {
+        RecordFile f = newRecordFile();
+        PageManager pm = new PageManager(f);
+        PhysicalFreeRowIdManager freeMgr = new PhysicalFreeRowIdManager(
+                f, pm);
+
+        pm.close();
+        f.close();
+    }
+
+    /**
+     * Test basics
+     */
+    public void testBasics() throws Exception {
+
+        RecordFile f = newRecordFile();
+        PageManager pm = new PageManager(f);
+        PhysicalFreeRowIdManager freeMgr = new PhysicalFreeRowIdManager(f, pm);
+
+        // allocate 10,000 bytes - should fail on an empty file.
+        long loc = freeMgr.getFreeRecord(10000);
+        assertTrue("loc is not null?", loc == 0);
+
+        pm.close();
+        f.close();
+    }
+
+    public void testPhysRecRootPage() throws IOException {
+        RecordFile f = newRecordFile();
+        PageManager pm = new PageManager(f);
+
+        long pageid = pm.allocate(Magic.FREEPHYSIDS_ROOT_PAGE);
+        BlockIo p = f.get(pageid);
+        p.writeInt(100,100);
+        f.release(p);
+        pm.commit();
+        f.commit();
+
+        p = f.get(pageid);
+        assertEquals(p.readInt(100),100);
+
+    }
+
+    public void test_size_to_root_offset(){
+        for(int i = 1;i<PhysicalFreeRowIdManager.MAX_REC_SIZE;i++){
+            int offset = PhysicalFreeRowIdManager.sizeToRootOffset(i);
+
+            assertTrue(offset<=Storage.BLOCK_SIZE);
+        }
+    }
+
+
+    public void test_record_reallocation() throws IOException {
+        RecordFile f = newRecordFile();
+        PageManager pm = new PageManager(f);
+        PhysicalFreeRowIdManager freeMgr = new PhysicalFreeRowIdManager(f, pm);
+
+        freeMgr.putFreeRecord(1000,100);
+        freeMgr.commit();
+
+        assertEquals(1000,freeMgr.getFreeRecord(100-PhysicalFreeRowIdManager.ROOT_SLOT_SIZE));
+        assertEquals(0,freeMgr.getFreeRecord(100-PhysicalFreeRowIdManager.ROOT_SLOT_SIZE));
+
+    }
+
+
+    public void test_all_sizes_deallocation() throws IOException {
+        RecordFile f = newRecordFile();
+        PageManager pm = new PageManager(f);
+        PhysicalFreeRowIdManager freeMgr = new PhysicalFreeRowIdManager(f, pm);
+
+        for(int i = 1; i<PhysicalFreeRowIdManager.MAX_REC_SIZE; i++){
+
+
+            freeMgr.putFreeRecord(1000,i);
+            freeMgr.commit();
+
+            assertEquals(1000,freeMgr.getFreeRecord(i-PhysicalFreeRowIdManager.ROOT_SLOT_SIZE));
+            assertEquals(0,freeMgr.getFreeRecord(i-PhysicalFreeRowIdManager.ROOT_SLOT_SIZE));
+        }
+        pm.close();
+        f.close();
+
+    }
+
+}
+
diff --git a/src/test/java/net/kotek/jdbm/PhysicalRowIdManagerTest.java b/src/test/java/net/kotek/jdbm/PhysicalRowIdManagerTest.java
index aadd337..b000e86 100644
--- a/src/test/java/net/kotek/jdbm/PhysicalRowIdManagerTest.java
+++ b/src/test/java/net/kotek/jdbm/PhysicalRowIdManagerTest.java
@@ -37,7 +37,7 @@ public class PhysicalRowIdManagerTest extends TestCaseWithTestFile {
         RecordFile free = newRecordFile();
         PageManager pmfree = new PageManager(free);
 
-        PhysicalRowIdManager physMgr = new PhysicalRowIdManager(f, pm, new PhysicalRowIdPageManagerFree(free, pmfree));
+        PhysicalRowIdManager physMgr = new PhysicalRowIdManager(f, pm);
 
         f.forceClose();
     }
@@ -51,7 +51,7 @@ public class PhysicalRowIdManagerTest extends TestCaseWithTestFile {
         PageManager pm = new PageManager(f);
         RecordFile free = newRecordFile();
         PageManager pmfree = new PageManager(free);
-        PhysicalRowIdManager physMgr = new PhysicalRowIdManager(f, pm, new PhysicalRowIdPageManagerFree(free, pmfree));
+        PhysicalRowIdManager physMgr = new PhysicalRowIdManager(f, pm);
 
         // insert a 10,000 byte record.
         byte[] data = UtilTT.makeRecord(10000, (byte) 1);
diff --git a/src/test/java/net/kotek/jdbm/PhysicalRowIdPageManagerFreeTest.java b/src/test/java/net/kotek/jdbm/PhysicalRowIdPageManagerFreeTest.java
deleted file mode 100644
index 8469a0c..0000000
--- a/src/test/java/net/kotek/jdbm/PhysicalRowIdPageManagerFreeTest.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/*******************************************************************************
- * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package net.kotek.jdbm;
-
-
-/**
- * This class contains all Unit tests for {@link PhysicalRowIdPageManagerFree}.
- */
-public class PhysicalRowIdPageManagerFreeTest extends TestCaseWithTestFile {
-
-    /**
-     * Test constructor
-     */
-    public void testCtor() throws Exception {
-        RecordFile f = newRecordFile();
-        PageManager pm = new PageManager(f);
-        PhysicalRowIdPageManagerFree freeMgr = new PhysicalRowIdPageManagerFree(
-                f, pm);
-
-        pm.close();
-        f.close();
-    }
-
-    /**
-     * Test basics
-     */
-    public void testBasics() throws Exception {
-
-        RecordFile f = newRecordFile();
-        PageManager pm = new PageManager(f);
-        PhysicalRowIdPageManagerFree freeMgr = new PhysicalRowIdPageManagerFree(
-                f, pm);
-
-        // allocate 10,000 bytes - should fail on an empty file.
-        long loc = freeMgr.getFreeRecord(10000);
-        assertTrue("loc is not null?", loc == 0);
-
-        pm.close();
-        f.close();
-    }
-}
-
