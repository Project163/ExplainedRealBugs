diff --git a/src/main/java/com/fasterxml/jackson/module/afterburner/deser/DeserializerModifier.java b/src/main/java/com/fasterxml/jackson/module/afterburner/deser/DeserializerModifier.java
index 90e79da..72561fd 100644
--- a/src/main/java/com/fasterxml/jackson/module/afterburner/deser/DeserializerModifier.java
+++ b/src/main/java/com/fasterxml/jackson/module/afterburner/deser/DeserializerModifier.java
@@ -54,12 +54,12 @@ public class DeserializerModifier extends BeanDeserializerModifier
                 return builder;
             }
         }
-        PropertyMutatorCollector collector = new PropertyMutatorCollector();
+        PropertyMutatorCollector collector = new PropertyMutatorCollector(beanClass);
         List<OptimizedSettableBeanProperty<?>> newProps = findOptimizableProperties(
                 config, collector, builder.getProperties());
         // and if we found any, create mutator proxy, replace property objects
         if (!newProps.isEmpty()) {
-            BeanPropertyMutator mutator = collector.buildMutator(beanClass, _classLoader);
+            BeanPropertyMutator mutator = collector.buildMutator(_classLoader);
             for (OptimizedSettableBeanProperty<?> prop : newProps) {
                 builder.addOrReplaceProperty(prop.withMutator(mutator), true);
             }
@@ -134,7 +134,7 @@ public class DeserializerModifier extends BeanDeserializerModifier
                     }
                 }
             } else if (prop instanceof FieldProperty) { // regular fields
-                Class<?> type = ((AnnotatedField) member).getRawType();
+                Class<?> type = member.getRawType();
                 if (type.isPrimitive()) {
                     if (type == Integer.TYPE) {
                         newProps.add(collector.addIntField(prop));
diff --git a/src/main/java/com/fasterxml/jackson/module/afterburner/deser/PropertyMutatorCollector.java b/src/main/java/com/fasterxml/jackson/module/afterburner/deser/PropertyMutatorCollector.java
index 480cd97..dbdbe78 100644
--- a/src/main/java/com/fasterxml/jackson/module/afterburner/deser/PropertyMutatorCollector.java
+++ b/src/main/java/com/fasterxml/jackson/module/afterburner/deser/PropertyMutatorCollector.java
@@ -33,7 +33,13 @@ public class PropertyMutatorCollector
     private final ArrayList<SettableStringFieldProperty> _stringFields = new ArrayList<SettableStringFieldProperty>();
     private final ArrayList<SettableObjectFieldProperty> _objectFields = new ArrayList<SettableObjectFieldProperty>();
 
-    public PropertyMutatorCollector() { }
+    private final Class<?> beanClass;
+    private final String beanClassName;
+
+    public PropertyMutatorCollector(Class<?> beanClass) {
+        this.beanClass = beanClass;
+        this.beanClassName = Type.getInternalName(beanClass);
+    }
     
     /*
     /**********************************************************
@@ -89,15 +95,14 @@ public class PropertyMutatorCollector
      * Method for building generic mutator class for specified bean
      * type.
      */
-    public BeanPropertyMutator buildMutator(Class<?> beanType,
-            MyClassLoader classLoader)
+    public BeanPropertyMutator buildMutator(MyClassLoader classLoader)
     {
         // if we weren't passed a class loader, we will base it on value type CL, try to use parent
         if (classLoader == null) {
-            classLoader = new MyClassLoader(beanType.getClassLoader(), true);
+            classLoader = new MyClassLoader(beanClass.getClassLoader(), true);
         }
 
-        String srcName = beanType.getName() + "$Access4JacksonDeserializer";
+        String srcName = beanClass.getName() + "$Access4JacksonDeserializer";
 
         String generatedClass = internalClassName(srcName);
         Class<?> accessorClass = null;
@@ -105,7 +110,7 @@ public class PropertyMutatorCollector
             accessorClass = classLoader.loadClass(srcName);
         } catch (ClassNotFoundException e) { }
         if (accessorClass == null) {
-            accessorClass = generateMutatorClass(beanType, classLoader, srcName, generatedClass);
+            accessorClass = generateMutatorClass(classLoader, srcName, generatedClass);
         }
         try {
             return (BeanPropertyMutator) accessorClass.newInstance();
@@ -114,8 +119,7 @@ public class PropertyMutatorCollector
         }
     }
 
-    public Class<?> generateMutatorClass(Class<?> beanType,
-            MyClassLoader classLoader, String srcName, String generatedClass)
+    public Class<?> generateMutatorClass(MyClassLoader classLoader, String srcName, String generatedClass)
     {
         ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);
         String superClass = internalClassName(BeanPropertyMutator.class.getName());
@@ -133,34 +137,32 @@ public class PropertyMutatorCollector
         mv.visitMaxs(0, 0); // don't care (real values: 1,1)
         mv.visitEnd();
 
-        final String beanClass = internalClassName(beanType.getName());
-
         // and then add various accessors; first field accessors:
         if (!_intFields.isEmpty()) {
-            _addFields(cw, _intFields, beanClass, "intField", Type.INT_TYPE, ILOAD);
+            _addFields(cw, _intFields, "intField", Type.INT_TYPE, ILOAD);
         }
         if (!_longFields.isEmpty()) {
-            _addFields(cw, _longFields, beanClass, "longField", Type.LONG_TYPE, LLOAD);
+            _addFields(cw, _longFields, "longField", Type.LONG_TYPE, LLOAD);
         }
         if (!_stringFields.isEmpty()) {
-            _addFields(cw, _stringFields, beanClass, "stringField", STRING_TYPE, ALOAD);
+            _addFields(cw, _stringFields, "stringField", STRING_TYPE, ALOAD);
         }
         if (!_objectFields.isEmpty()) {
-            _addFields(cw, _objectFields, beanClass, "objectField", OBJECT_TYPE, ALOAD);
+            _addFields(cw, _objectFields, "objectField", OBJECT_TYPE, ALOAD);
         }
 
         // and then method accessors:
         if (!_intSetters.isEmpty()) {
-            _addSetters(cw, _intSetters, beanClass, "intSetter", Type.INT_TYPE, ILOAD);
+            _addSetters(cw, _intSetters, "intSetter", Type.INT_TYPE, ILOAD);
         }
         if (!_longSetters.isEmpty()) {
-            _addSetters(cw, _longSetters, beanClass, "longSetter", Type.LONG_TYPE, LLOAD);
+            _addSetters(cw, _longSetters, "longSetter", Type.LONG_TYPE, LLOAD);
         }
         if (!_stringSetters.isEmpty()) {
-            _addSetters(cw, _stringSetters, beanClass, "stringSetter", STRING_TYPE, ALOAD);
+            _addSetters(cw, _stringSetters, "stringSetter", STRING_TYPE, ALOAD);
         }
         if (!_objectSetters.isEmpty()) {
-            _addSetters(cw, _objectSetters, beanClass, "objectSetter", OBJECT_TYPE, ALOAD);
+            _addSetters(cw, _objectSetters, "objectSetter", OBJECT_TYPE, ALOAD);
         }
 
         cw.visitEnd();
@@ -174,26 +176,26 @@ public class PropertyMutatorCollector
     /**********************************************************
      */
 
-    private static <T extends OptimizedSettableBeanProperty<T>> void _addSetters(ClassWriter cw, List<T> props,
-            String beanClass, String methodName, Type parameterType, int loadValueCode)
+    private <T extends OptimizedSettableBeanProperty<T>> void _addSetters(ClassWriter cw, List<T> props,
+            String methodName, Type parameterType, int loadValueCode)
     {
         MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, methodName, "(Ljava/lang/Object;I"+parameterType+")V", /*generic sig*/null, null);
         mv.visitCode();
         // first: cast bean to proper type
         mv.visitVarInsn(ALOAD, 1);
-        mv.visitTypeInsn(CHECKCAST, beanClass);
+        mv.visitTypeInsn(CHECKCAST, beanClassName);
         int localVarIndex = 4 + (parameterType.equals(Type.LONG_TYPE) ? 1 : 0);
         mv.visitVarInsn(ASTORE, localVarIndex); // 3 args (0 == this), so 4 is the first local var slot, 5 for long
 
         boolean mustCast = parameterType.equals(OBJECT_TYPE);
         // Ok; minor optimization, 4 or less accessors, just do IFs; over that, use switch
         if (props.size() <= 4) {
-            _addSettersUsingIf(mv, props, beanClass, loadValueCode, localVarIndex, mustCast);
+            _addSettersUsingIf(mv, props, loadValueCode, localVarIndex, mustCast);
         } else {
-            _addSettersUsingSwitch(mv, props, beanClass, loadValueCode, localVarIndex, mustCast);
+            _addSettersUsingSwitch(mv, props, loadValueCode, localVarIndex, mustCast);
         }
         // and if no match, generate exception:
-        generateException(mv, beanClass, props.size());
+        generateException(mv, beanClassName, props.size());
         mv.visitMaxs(0, 0); // don't care (real values: 1,1)
         mv.visitEnd();
     }
@@ -204,26 +206,26 @@ public class PropertyMutatorCollector
     /**********************************************************
      */
 
-    private static <T extends OptimizedSettableBeanProperty<T>> void _addFields(ClassWriter cw, List<T> props,
-            String beanClass, String methodName, Type parameterType, int loadValueCode)
+    private <T extends OptimizedSettableBeanProperty<T>> void _addFields(ClassWriter cw, List<T> props,
+            String methodName, Type parameterType, int loadValueCode)
     {
         MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, methodName, "(Ljava/lang/Object;I"+parameterType+")V", /*generic sig*/null, null);
         mv.visitCode();
         // first: cast bean to proper type
         mv.visitVarInsn(ALOAD, 1);
-        mv.visitTypeInsn(CHECKCAST, beanClass);
+        mv.visitTypeInsn(CHECKCAST, beanClassName);
         int localVarIndex = 4 + (parameterType.equals(Type.LONG_TYPE) ? 1 : 0);
         mv.visitVarInsn(ASTORE, localVarIndex); // 3 args (0 == this), so 4 is the first local var slot, 5 for long
 
         boolean mustCast = parameterType.equals(OBJECT_TYPE);
         // Ok; minor optimization, less than 4 accessors, just do IFs; over that, use switch
         if (props.size() < 4) {
-            _addFieldsUsingIf(mv, props, beanClass, loadValueCode, localVarIndex, mustCast);
+            _addFieldsUsingIf(mv, props, loadValueCode, localVarIndex, mustCast);
         } else {
-            _addFieldsUsingSwitch(mv, props, beanClass, loadValueCode, localVarIndex, mustCast);
+            _addFieldsUsingSwitch(mv, props, loadValueCode, localVarIndex, mustCast);
         }
         // and if no match, generate exception:
-        generateException(mv, beanClass, props.size());
+        generateException(mv, beanClassName, props.size());
         mv.visitMaxs(0, 0); // don't care (real values: 1,1)
         mv.visitEnd();
     }
@@ -234,9 +236,8 @@ public class PropertyMutatorCollector
     /**********************************************************
      */
 
-    private static <T extends OptimizedSettableBeanProperty<T>> void _addSettersUsingIf(MethodVisitor mv,
-            List<T> props, String beanClass, int loadValueCode, int beanIndex,
-            boolean mustCast)
+    private <T extends OptimizedSettableBeanProperty<T>> void _addSettersUsingIf(MethodVisitor mv,
+            List<T> props, int loadValueCode, int beanIndex, boolean mustCast)
     {
         mv.visitVarInsn(ILOAD, 2); // load second arg (index)
         Label next = new Label();
@@ -251,11 +252,9 @@ public class PropertyMutatorCollector
             mv.visitTypeInsn(CHECKCAST, type.getInternalName());
         }
         // to fix [Issue-5] (don't assume return type is 'void'), we need to:
-        Class<?> returnType = method.getReturnType();
-        String returnTypeStr = (returnType == Void.class) ? "V"
-            : Type.getType(returnType).getDescriptor();
+        Type returnType = Type.getType(method.getReturnType());
 
-        mv.visitMethodInsn(INVOKEVIRTUAL, beanClass, method.getName(), "("+type.getDescriptor()+")"+returnTypeStr);
+        mv.visitMethodInsn(INVOKEVIRTUAL, beanClassName, method.getName(), "("+type+")"+returnType);
         mv.visitInsn(RETURN);
 
         // And from this point on, loop a bit
@@ -270,22 +269,19 @@ public class PropertyMutatorCollector
             method = (Method) (props.get(i).getMember().getMember());
             type = Type.getType(method.getParameterTypes()[0]);
 
-            returnType = method.getReturnType();
-            returnTypeStr = (returnType == Void.class) ? "V"
-                : Type.getType(returnType).getDescriptor();
+            returnType = Type.getType(method.getReturnType());
 
             if (mustCast) {
                 mv.visitTypeInsn(CHECKCAST, type.getInternalName());
             }
-            mv.visitMethodInsn(INVOKEVIRTUAL, beanClass, method.getName(), "("+type.getDescriptor()+")"+returnTypeStr);
+            mv.visitMethodInsn(INVOKEVIRTUAL, beanClassName, method.getName(), "("+type+")"+returnType);
             mv.visitInsn(RETURN);
         }
         mv.visitLabel(next);
     }
 
-    private static <T extends OptimizedSettableBeanProperty<T>> void _addSettersUsingSwitch(MethodVisitor mv,
-            List<T> props, String beanClass, int loadValueCode, int beanIndex,
-            boolean mustCast)
+    private <T extends OptimizedSettableBeanProperty<T>> void _addSettersUsingSwitch(MethodVisitor mv,
+            List<T> props, int loadValueCode, int beanIndex, boolean mustCast)
     {
         mv.visitVarInsn(ILOAD, 2); // load second arg (index)
 
@@ -302,22 +298,19 @@ public class PropertyMutatorCollector
             Method method = (Method) (props.get(i).getMember().getMember());
             Type type = Type.getType(method.getParameterTypes()[0]);
 
-            Class<?> returnType = method.getReturnType();
-            String returnTypeStr = (returnType == Void.class) ? "V"
-                : Type.getType(returnType).getDescriptor();
+            Type returnType = Type.getType(method.getReturnType());
 
             if (mustCast) {
                 mv.visitTypeInsn(CHECKCAST, type.getInternalName());
             }
-            mv.visitMethodInsn(INVOKEVIRTUAL, beanClass, method.getName(), "("+type.getDescriptor()+")"+returnTypeStr);
+            mv.visitMethodInsn(INVOKEVIRTUAL, beanClassName, method.getName(), "("+type+")"+returnType);
             mv.visitInsn(RETURN);
         }
         mv.visitLabel(defaultLabel);
     }
 
-    private static <T extends OptimizedSettableBeanProperty<T>> void _addFieldsUsingIf(MethodVisitor mv,
-            List<T> props, String beanClass, int loadValueCode, int beanIndex,
-            boolean mustCast)
+    private <T extends OptimizedSettableBeanProperty<T>> void _addFieldsUsingIf(MethodVisitor mv,
+            List<T> props, int loadValueCode, int beanIndex, boolean mustCast)
     {
         mv.visitVarInsn(ILOAD, 2); // load second arg (index)
         Label next = new Label();
@@ -332,7 +325,7 @@ public class PropertyMutatorCollector
         if (mustCast) {
             mv.visitTypeInsn(CHECKCAST, type.getInternalName());
         }
-        mv.visitFieldInsn(PUTFIELD, beanClass, field.getName(), type.getDescriptor());
+        mv.visitFieldInsn(PUTFIELD, beanClassName, field.getName(), type.getDescriptor());
         mv.visitInsn(RETURN);
 
         // And from this point on, loop a bit
@@ -349,15 +342,14 @@ public class PropertyMutatorCollector
             if (mustCast) {
                 mv.visitTypeInsn(CHECKCAST, type.getInternalName());
             }
-            mv.visitFieldInsn(PUTFIELD, beanClass, field.getName(), type.getDescriptor());
+            mv.visitFieldInsn(PUTFIELD, beanClassName, field.getName(), type.getDescriptor());
             mv.visitInsn(RETURN);
         }
         mv.visitLabel(next);
     }
 
-    private static <T extends OptimizedSettableBeanProperty<T>> void _addFieldsUsingSwitch(MethodVisitor mv,
-            List<T> props, String beanClass, int loadValueCode, int beanIndex,
-            boolean mustCast)
+    private <T extends OptimizedSettableBeanProperty<T>> void _addFieldsUsingSwitch(MethodVisitor mv,
+            List<T> props, int loadValueCode, int beanIndex, boolean mustCast)
     {
         mv.visitVarInsn(ILOAD, 2); // load second arg (index)
 
@@ -376,7 +368,7 @@ public class PropertyMutatorCollector
             if (mustCast) {
                 mv.visitTypeInsn(CHECKCAST, type.getInternalName());
             }
-            mv.visitFieldInsn(PUTFIELD, beanClass, field.getName(), type.getDescriptor());
+            mv.visitFieldInsn(PUTFIELD, beanClassName, field.getName(), type.getDescriptor());
             mv.visitInsn(RETURN);
         }
         mv.visitLabel(defaultLabel);
diff --git a/src/main/java/com/fasterxml/jackson/module/afterburner/ser/PropertyAccessorCollector.java b/src/main/java/com/fasterxml/jackson/module/afterburner/ser/PropertyAccessorCollector.java
index 76a9618..0a99762 100644
--- a/src/main/java/com/fasterxml/jackson/module/afterburner/ser/PropertyAccessorCollector.java
+++ b/src/main/java/com/fasterxml/jackson/module/afterburner/ser/PropertyAccessorCollector.java
@@ -31,8 +31,14 @@ public class PropertyAccessorCollector
     private final ArrayList<LongFieldPropertyWriter> _longFields = new ArrayList<LongFieldPropertyWriter>();
     private final ArrayList<StringFieldPropertyWriter> _stringFields = new ArrayList<StringFieldPropertyWriter>();
     private final ArrayList<ObjectFieldPropertyWriter> _objectFields = new ArrayList<ObjectFieldPropertyWriter>();
-    
-    public PropertyAccessorCollector() { }
+
+    private final Class<?> beanClass;
+    private final String beanClassName;
+
+    public PropertyAccessorCollector(Class<?> beanClass) {
+        this.beanClass = beanClass;
+        this.beanClassName = Type.getInternalName(beanClass);
+    }
     
     /*
     /**********************************************************
@@ -84,15 +90,14 @@ public class PropertyAccessorCollector
     /**********************************************************
      */
 
-    public BeanPropertyAccessor findAccessor(Class<?> beanType,
-            MyClassLoader classLoader)
+    public BeanPropertyAccessor findAccessor(MyClassLoader classLoader)
     {
         // if we weren't passed a class loader, we will base it on value type CL, try to use parent
         if (classLoader == null) {
-            classLoader = new MyClassLoader(beanType.getClassLoader(), true);
+            classLoader = new MyClassLoader(beanClass.getClassLoader(), true);
         }
         
-        String srcName = beanType.getName() + "$Access4JacksonSerializer";
+        String srcName = beanClass.getName() + "$Access4JacksonSerializer";
         
         String generatedClass = internalClassName(srcName);
         Class<?> accessorClass = null;
@@ -100,7 +105,7 @@ public class PropertyAccessorCollector
             accessorClass = classLoader.loadClass(srcName);
         } catch (ClassNotFoundException e) { }
         if (accessorClass == null) {
-            accessorClass = generateAccessorClass(beanType, classLoader, srcName, generatedClass);
+            accessorClass = generateAccessorClass(classLoader, srcName, generatedClass);
         }
         try {
             return (BeanPropertyAccessor) accessorClass.newInstance();
@@ -108,9 +113,9 @@ public class PropertyAccessorCollector
             throw new IllegalStateException("Failed to generate accessor class '"+srcName+"': "+e.getMessage(), e);
         }
     }
-        
-    public Class<?> generateAccessorClass(Class<?> beanType,
-            MyClassLoader classLoader, String srcName, String generatedClass)
+
+    public Class<?> generateAccessorClass(MyClassLoader classLoader,
+                                          String srcName, String generatedClass)
     {
         ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);
         String superClass = internalClassName(BeanPropertyAccessor.class.getName());
@@ -127,35 +132,33 @@ public class PropertyAccessorCollector
         mv.visitInsn(RETURN);
         mv.visitMaxs(0, 0); // don't care (real values: 1,1)
         mv.visitEnd();
-        
-        final String beanClass = internalClassName(beanType.getName());
- 
+
         // and then add various accessors; first field accessors:
         if (!_intFields.isEmpty()) {
-            _addFields(cw, _intFields, beanClass, "intField", Type.INT_TYPE, IRETURN);
+            _addFields(cw, _intFields, "intField", Type.INT_TYPE, IRETURN);
         }
         if (!_longFields.isEmpty()) {
-            _addFields(cw, _longFields, beanClass, "longField", Type.LONG_TYPE, LRETURN);
+            _addFields(cw, _longFields, "longField", Type.LONG_TYPE, LRETURN);
         }
         if (!_stringFields.isEmpty()) {
-            _addFields(cw, _stringFields, beanClass, "stringField", STRING_TYPE, ARETURN);
+            _addFields(cw, _stringFields, "stringField", STRING_TYPE, ARETURN);
         }
         if (!_objectFields.isEmpty()) {
-            _addFields(cw, _objectFields, beanClass, "objectField", OBJECT_TYPE, ARETURN);
+            _addFields(cw, _objectFields, "objectField", OBJECT_TYPE, ARETURN);
         }
 
         // and then method accessors:
         if (!_intGetters.isEmpty()) {
-            _addGetters(cw, _intGetters, beanClass, "intGetter", Type.INT_TYPE, IRETURN);
+            _addGetters(cw, _intGetters, "intGetter", Type.INT_TYPE, IRETURN);
         }
         if (!_longGetters.isEmpty()) {
-            _addGetters(cw, _longGetters, beanClass, "longGetter", Type.LONG_TYPE, LRETURN);
+            _addGetters(cw, _longGetters, "longGetter", Type.LONG_TYPE, LRETURN);
         }
         if (!_stringGetters.isEmpty()) {
-            _addGetters(cw, _stringGetters, beanClass, "stringGetter", STRING_TYPE, ARETURN);
+            _addGetters(cw, _stringGetters, "stringGetter", STRING_TYPE, ARETURN);
         }
         if (!_objectGetters.isEmpty()) {
-            _addGetters(cw, _objectGetters, beanClass, "objectGetter", OBJECT_TYPE, ARETURN);
+            _addGetters(cw, _objectGetters, "objectGetter", OBJECT_TYPE, ARETURN);
         }
 
         cw.visitEnd();
@@ -169,24 +172,24 @@ public class PropertyAccessorCollector
     /**********************************************************
      */
 
-    private static <T extends OptimizedBeanPropertyWriter<T>> void _addGetters(ClassWriter cw, List<T> props,
-            String beanClass, String methodName, Type returnType, int returnOpcode)
+    private <T extends OptimizedBeanPropertyWriter<T>> void _addGetters(ClassWriter cw, List<T> props,
+            String methodName, Type returnType, int returnOpcode)
     {
         MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, methodName, "(Ljava/lang/Object;I)"+returnType, /*generic sig*/null, null);
         mv.visitCode();
         // first: cast bean to proper type
         mv.visitVarInsn(ALOAD, 1);
-        mv.visitTypeInsn(CHECKCAST, beanClass);
+        mv.visitTypeInsn(CHECKCAST, beanClassName);
         mv.visitVarInsn(ASTORE, 3);
 
         // Ok; minor optimization, 4 or less accessors, just do IFs; over that, use switch
         if (props.size() <= 4) {
-            _addGettersUsingIf(mv, props, beanClass, returnOpcode, ALL_INT_CONSTS);
+            _addGettersUsingIf(mv, props, returnOpcode, ALL_INT_CONSTS);
         } else {
-            _addGettersUsingSwitch(mv, props, beanClass, returnOpcode);
+            _addGettersUsingSwitch(mv, props, returnOpcode);
         }
         // and if no match, generate exception:
-        generateException(mv, beanClass, props.size());
+        generateException(mv, beanClassName, props.size());
         mv.visitMaxs(0, 0); // don't care (real values: 1,1)
         mv.visitEnd();
     }
@@ -197,24 +200,24 @@ public class PropertyAccessorCollector
     /**********************************************************
      */
     
-    private static <T extends OptimizedBeanPropertyWriter<T>> void _addFields(ClassWriter cw, List<T> props,
-            String beanClass, String methodName, Type returnType, int returnOpcode)
+    private <T extends OptimizedBeanPropertyWriter<T>> void _addFields(ClassWriter cw, List<T> props,
+            String methodName, Type returnType, int returnOpcode)
     {
         MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, methodName, "(Ljava/lang/Object;I)"+returnType, /*generic sig*/null, null);
         mv.visitCode();
         // first: cast bean to proper type
         mv.visitVarInsn(ALOAD, 1);
-        mv.visitTypeInsn(CHECKCAST, beanClass);
+        mv.visitTypeInsn(CHECKCAST, beanClassName);
         mv.visitVarInsn(ASTORE, 3);
 
         // Ok; minor optimization, less than 4 accessors, just do IFs; over that, use switch
         if (props.size() < 4) {
-            _addFieldsUsingIf(mv, props, beanClass, returnOpcode, ALL_INT_CONSTS);
+            _addFieldsUsingIf(mv, props, returnOpcode, ALL_INT_CONSTS);
         } else {
-            _addFieldsUsingSwitch(mv, props, beanClass, returnOpcode);
+            _addFieldsUsingSwitch(mv, props, returnOpcode);
         }
         // and if no match, generate exception:
-        generateException(mv, beanClass, props.size());
+        generateException(mv, beanClassName, props.size());
         mv.visitMaxs(0, 0); // don't care (real values: 1,1)
         mv.visitEnd();
     }
@@ -225,9 +228,8 @@ public class PropertyAccessorCollector
     /**********************************************************
      */
 
-    private static <T extends OptimizedBeanPropertyWriter<T>> void _addGettersUsingIf(MethodVisitor mv,
-            List<T> props, String beanClass, int returnOpcode,
-            int[] constantOpcodes)
+    private <T extends OptimizedBeanPropertyWriter<T>> void _addGettersUsingIf(MethodVisitor mv,
+            List<T> props, int returnOpcode, int[] constantOpcodes)
     {
         mv.visitVarInsn(ILOAD, 2); // load second arg (index)
         Label next = new Label();
@@ -236,8 +238,9 @@ public class PropertyAccessorCollector
 
         // call first getter:
         mv.visitVarInsn(ALOAD, 3); // load local for cast bean
+        int invokeInsn = beanClass.isInterface() ? INVOKEINTERFACE : INVOKEVIRTUAL;
         Method method = (Method) (props.get(0).getMember().getMember());
-        mv.visitMethodInsn(INVOKEVIRTUAL, beanClass, method.getName(), "()"+Type.getDescriptor(method.getReturnType()));
+        mv.visitMethodInsn(invokeInsn, beanClassName, method.getName(), Type.getMethodDescriptor(method));
         mv.visitInsn(returnOpcode);
 
         // And from this point on, loop a bit
@@ -249,14 +252,14 @@ public class PropertyAccessorCollector
             mv.visitJumpInsn(IF_ICMPNE, next);
             mv.visitVarInsn(ALOAD, 3); // load bean
             method = (Method) (props.get(i).getMember().getMember());
-            mv.visitMethodInsn(INVOKEVIRTUAL, beanClass, method.getName(), "()"+Type.getDescriptor(method.getReturnType()));
+            mv.visitMethodInsn(invokeInsn, beanClassName, method.getName(), Type.getMethodDescriptor(method));
             mv.visitInsn(returnOpcode);
         }
         mv.visitLabel(next);
     }
 
-    private static <T extends OptimizedBeanPropertyWriter<T>> void _addGettersUsingSwitch(MethodVisitor mv,
-            List<T> props, String beanClass, int returnOpcode)
+    private <T extends OptimizedBeanPropertyWriter<T>> void _addGettersUsingSwitch(MethodVisitor mv,
+            List<T> props, int returnOpcode)
     {
         mv.visitVarInsn(ILOAD, 2); // load second arg (index)
 
@@ -266,18 +269,19 @@ public class PropertyAccessorCollector
         }
         Label defaultLabel = new Label();
         mv.visitTableSwitchInsn(0, labels.length - 1, defaultLabel, labels);
+        int invokeInsn = beanClass.isInterface() ? INVOKEINTERFACE : INVOKEVIRTUAL;
         for (int i = 0, len = labels.length; i < len; ++i) {
             mv.visitLabel(labels[i]);
             mv.visitVarInsn(ALOAD, 3); // load bean
             Method method = (Method) (props.get(i).getMember().getMember());
-            mv.visitMethodInsn(INVOKEVIRTUAL, beanClass, method.getName(), "()"+Type.getDescriptor(method.getReturnType()));
+            mv.visitMethodInsn(invokeInsn, beanClassName, method.getName(), Type.getMethodDescriptor(method));
             mv.visitInsn(returnOpcode);
         }
         mv.visitLabel(defaultLabel);
     }
 
-    private static <T extends OptimizedBeanPropertyWriter<T>> void _addFieldsUsingIf(MethodVisitor mv,
-            List<T> props, String beanClass, int returnOpcode,
+    private <T extends OptimizedBeanPropertyWriter<T>> void _addFieldsUsingIf(MethodVisitor mv,
+            List<T> props, int returnOpcode,
             int[] constantOpcodes)
     {
         mv.visitVarInsn(ILOAD, 2); // load second arg (index)
@@ -288,7 +292,7 @@ public class PropertyAccessorCollector
         // first field accessor
         mv.visitVarInsn(ALOAD, 3); // load local for cast bean
         AnnotatedField field = (AnnotatedField) props.get(0).getMember();
-        mv.visitFieldInsn(GETFIELD, beanClass, field.getName(), Type.getDescriptor(field.getRawType()));
+        mv.visitFieldInsn(GETFIELD, beanClassName, field.getName(), Type.getDescriptor(field.getRawType()));
         mv.visitInsn(returnOpcode);
 
         // And from this point on, loop a bit
@@ -300,14 +304,14 @@ public class PropertyAccessorCollector
             mv.visitJumpInsn(IF_ICMPNE, next);
             mv.visitVarInsn(ALOAD, 3); // load bean
             field = (AnnotatedField) props.get(i).getMember();
-            mv.visitFieldInsn(GETFIELD, beanClass, field.getName(), Type.getDescriptor(field.getRawType()));
+            mv.visitFieldInsn(GETFIELD, beanClassName, field.getName(), Type.getDescriptor(field.getRawType()));
             mv.visitInsn(returnOpcode);
         }
         mv.visitLabel(next);
     }
 
-    private static <T extends OptimizedBeanPropertyWriter<T>> void _addFieldsUsingSwitch(MethodVisitor mv,
-            List<T> props, String beanClass, int returnOpcode)
+    private <T extends OptimizedBeanPropertyWriter<T>> void _addFieldsUsingSwitch(MethodVisitor mv,
+            List<T> props, int returnOpcode)
     {
         mv.visitVarInsn(ILOAD, 2); // load second arg (index)
 
@@ -321,7 +325,7 @@ public class PropertyAccessorCollector
             mv.visitLabel(labels[i]);
             mv.visitVarInsn(ALOAD, 3); // load bean
             AnnotatedField field = (AnnotatedField) props.get(i).getMember();
-            mv.visitFieldInsn(GETFIELD, beanClass, field.getName(), Type.getDescriptor(field.getRawType()));
+            mv.visitFieldInsn(GETFIELD, beanClassName, field.getName(), Type.getDescriptor(field.getRawType()));
             mv.visitInsn(returnOpcode);
         }
         mv.visitLabel(defaultLabel);
diff --git a/src/main/java/com/fasterxml/jackson/module/afterburner/ser/SerializerModifier.java b/src/main/java/com/fasterxml/jackson/module/afterburner/ser/SerializerModifier.java
index 79e2995..d9af3be 100644
--- a/src/main/java/com/fasterxml/jackson/module/afterburner/ser/SerializerModifier.java
+++ b/src/main/java/com/fasterxml/jackson/module/afterburner/ser/SerializerModifier.java
@@ -46,13 +46,13 @@ public class SerializerModifier extends BeanSerializerModifier
             }
         }
         
-        PropertyAccessorCollector collector = findProperties(config, beanProperties);
+        PropertyAccessorCollector collector = findProperties(beanClass, config, beanProperties);
         if (collector.isEmpty()) {
             return beanProperties;
         }
         
         // if we had a match, need to materialize
-        BeanPropertyAccessor acc = collector.findAccessor(beanClass, _classLoader);
+        BeanPropertyAccessor acc = collector.findAccessor(_classLoader);
         // and then link accessors to bean property writers:
         ListIterator<BeanPropertyWriter> it = beanProperties.listIterator();
         while (it.hasNext()) {
@@ -64,10 +64,10 @@ public class SerializerModifier extends BeanSerializerModifier
         return beanProperties;
     }
 
-    protected PropertyAccessorCollector findProperties(SerializationConfig config,
-            List<BeanPropertyWriter> beanProperties)
+    protected PropertyAccessorCollector findProperties(Class<?> beanClass,
+            SerializationConfig config, List<BeanPropertyWriter> beanProperties)
     {
-        PropertyAccessorCollector collector = new PropertyAccessorCollector();
+        PropertyAccessorCollector collector = new PropertyAccessorCollector(beanClass);
         ListIterator<BeanPropertyWriter> it = beanProperties.listIterator();
         while (it.hasNext()) {
             BeanPropertyWriter bpw = it.next();
diff --git a/src/main/java/com/fasterxml/jackson/module/afterburner/util/MyClassLoader.java b/src/main/java/com/fasterxml/jackson/module/afterburner/util/MyClassLoader.java
index 3727d48..6927634 100644
--- a/src/main/java/com/fasterxml/jackson/module/afterburner/util/MyClassLoader.java
+++ b/src/main/java/com/fasterxml/jackson/module/afterburner/util/MyClassLoader.java
@@ -31,18 +31,13 @@ public class MyClassLoader extends ClassLoader
      */
     public static boolean canAddClassInPackageOf(Class<?> cls)
     {
-        // TODO: we should be able to do this, but currently causes IncompatibleClassChangeError
-        if (cls.isInterface()) {
-            return false;
-        }
-
         final Package beanPackage = cls.getPackage();
         if (beanPackage != null) {
             // 01-May-2013, tatu: How about "javax."?
             if (beanPackage.isSealed() || beanPackage.getName().startsWith("java.")) {
                 return false;
             }
-        } 
+        }
         return true;
     }
     
@@ -64,12 +59,12 @@ public class MyClassLoader extends ClassLoader
         // First: let's try calling it directly on parent, to be able to access protected/package-access stuff:
         if (_cfgUseParentLoader) {
             try {
-                Method method = ClassLoader.class.getDeclaredMethod("defineClass", 
+                Method method = ClassLoader.class.getDeclaredMethod("defineClass",
                         new Class[] {String.class, byte[].class, int.class,
                         int.class});
                 method.setAccessible(true);
                 return (Class<?>)method.invoke(getParent(),
-                        new Object[] { className, byteCode, Integer.valueOf(0), Integer.valueOf(byteCode.length)});
+                        className, byteCode, 0, byteCode.length);
             } catch (Exception e) { }
         }
 
@@ -77,7 +72,7 @@ public class MyClassLoader extends ClassLoader
         try {
             impl = defineClass(className, byteCode, 0, byteCode.length);
         } catch (LinkageError e) {
-            throw new IllegalArgumentException("Failed to load class '"+className+"': "+e.getMessage() ,e);
+            throw new IllegalArgumentException("Failed to load class '"+className+"': "+e.getMessage(), e);
         }
         // important: must also resolve the class...
         resolveClass(impl);
diff --git a/src/test/java/com/fasterxml/jackson/module/afterburner/ser/TestAccessorGeneration.java b/src/test/java/com/fasterxml/jackson/module/afterburner/ser/TestAccessorGeneration.java
index e595753..a5fbce1 100644
--- a/src/test/java/com/fasterxml/jackson/module/afterburner/ser/TestAccessorGeneration.java
+++ b/src/test/java/com/fasterxml/jackson/module/afterburner/ser/TestAccessorGeneration.java
@@ -47,14 +47,14 @@ public class TestAccessorGeneration extends AfterburnerTestBase
     {
         Method method = Bean1.class.getDeclaredMethod("getX");
         AnnotatedMethod annMethod = new AnnotatedMethod(method, null, null);
-        PropertyAccessorCollector coll = new PropertyAccessorCollector();
+        PropertyAccessorCollector coll = new PropertyAccessorCollector(Bean1.class);
         BeanPropertyWriter bpw = new BeanPropertyWriter(SimpleBeanPropertyDefinition.construct(null, annMethod, "x"),
                 annMethod, null,
                 null,
                 null, null, null,
                 false, null);
         coll.addIntGetter(bpw);
-        BeanPropertyAccessor acc = coll.findAccessor(Bean1.class, null);
+        BeanPropertyAccessor acc = coll.findAccessor(null);
         Bean1 bean = new Bean1();
         int value = acc.intGetter(bean, 0);
         assertEquals(bean.getX(), value);
@@ -62,7 +62,7 @@ public class TestAccessorGeneration extends AfterburnerTestBase
 
     public void testDualIntAccessorGeneration() throws Exception
     {
-        PropertyAccessorCollector coll = new PropertyAccessorCollector();
+        PropertyAccessorCollector coll = new PropertyAccessorCollector(Bean3.class);
 
         String[] methodNames = new String[] {
                 "getX", "getY", "get3"
@@ -87,7 +87,7 @@ public class TestAccessorGeneration extends AfterburnerTestBase
                     false, null));
         }
 
-        BeanPropertyAccessor acc = coll.findAccessor(Bean3.class, null);
+        BeanPropertyAccessor acc = coll.findAccessor(null);
         Bean3 bean = new Bean3();
 
         assertEquals(bean.getX(), acc.intGetter(bean, 0));
@@ -98,7 +98,7 @@ public class TestAccessorGeneration extends AfterburnerTestBase
     // And then test to ensure Switch-table construction also works...
     public void testLotsaIntAccessorGeneration() throws Exception
     {
-        PropertyAccessorCollector coll = new PropertyAccessorCollector();
+        PropertyAccessorCollector coll = new PropertyAccessorCollector(BeanN.class);
         String[] methodNames = new String[] {
                 "getX", "getY", "get3", "get4", "get5", "get6", "get7"
         };
@@ -112,7 +112,7 @@ public class TestAccessorGeneration extends AfterburnerTestBase
                     false, null));
         }
 
-        BeanPropertyAccessor acc = coll.findAccessor(BeanN.class, null);
+        BeanPropertyAccessor acc = coll.findAccessor(null);
         BeanN bean = new BeanN();
 
         assertEquals(bean.getX(), acc.intGetter(bean, 0));
