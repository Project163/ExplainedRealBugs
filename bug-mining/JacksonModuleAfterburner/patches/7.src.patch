diff --git a/release-notes/VERSION b/release-notes/VERSION
index 29ad248..c3674a4 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -6,6 +6,8 @@ Project: jackson-module-afterburner
 
 2.6.0 (not yet released)
 
+#53: Include checksum in generated class names (to resolve #52)
+
 2.5.1 (not yet released)
 
 #47: java.lang.VerifyError (Illegal type in constant pool ...)
diff --git a/src/main/java/com/fasterxml/jackson/module/afterburner/deser/CreatorOptimizer.java b/src/main/java/com/fasterxml/jackson/module/afterburner/deser/CreatorOptimizer.java
index 4a04bb8..80f7b53 100644
--- a/src/main/java/com/fasterxml/jackson/module/afterburner/deser/CreatorOptimizer.java
+++ b/src/main/java/com/fasterxml/jackson/module/afterburner/deser/CreatorOptimizer.java
@@ -16,6 +16,7 @@ import org.objectweb.asm.ClassWriter;
 import org.objectweb.asm.MethodVisitor;
 import org.objectweb.asm.Type;
 
+import com.fasterxml.jackson.module.afterburner.util.ClassName;
 import com.fasterxml.jackson.module.afterburner.util.DynamicPropertyAccessorBase;
 import com.fasterxml.jackson.module.afterburner.util.MyClassLoader;
 
@@ -77,30 +78,34 @@ public class CreatorOptimizer
     {
         MyClassLoader loader = (_classLoader == null) ?
             new MyClassLoader(_valueClass.getClassLoader(), true) : _classLoader;
-        String srcName = _valueClass.getName() + "$Creator4JacksonDeserializer";
+        final ClassName baseName = ClassName.constructFor(_valueClass, "$Creator4JacksonDeserializer");
+
+        // We need to know checksum even for lookups, so generate it first
+        final byte[] bytecode = generateOptimized(baseName, ctor, factory);
+        baseName.assignChecksum(bytecode);
+
         Class<?> impl = null;
         try {
-            impl = loader.loadClass(srcName);
+            impl = loader.loadClass(baseName.getDottedName());
         } catch (ClassNotFoundException e) { }
         if (impl == null) {
-            byte[] bytecode = generateOptimized(srcName, ctor, factory);
-            impl = loader.loadAndResolve(srcName, bytecode);
+            impl = loader.loadAndResolve(baseName, bytecode);
         }
         try {
             return (OptimizedValueInstantiator) impl.newInstance();
         } catch (Exception e) {
-            throw new IllegalStateException("Failed to generate accessor class '"+srcName+"': "+e.getMessage(), e);
+            throw new IllegalStateException("Failed to generate accessor class '"+baseName+"': "+e.getMessage(), e);
         }
     }
 
-    protected byte[] generateOptimized(String srcName, Constructor<?> ctor, Method factory)
+    protected byte[] generateOptimized(ClassName baseName, Constructor<?> ctor, Method factory)
     {
         ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);
         String superClass = internalClassName(OptimizedValueInstantiator.class.getName());
-        String generatedClass = internalClassName(srcName);
+        final String tmpClassName = baseName.getSlashedTemplate();
 
-        cw.visit(V1_5, ACC_PUBLIC + ACC_SUPER + ACC_FINAL, generatedClass, null, superClass, null);
-        cw.visitSource(srcName + ".java", null);
+        cw.visit(V1_5, ACC_PUBLIC + ACC_SUPER + ACC_FINAL, tmpClassName, null, superClass, null);
+        cw.visitSource(baseName.getSourceFilename(), null);
 
         // First: must define 2 constructors:
         // (a) default constructor, for creating bogus instance (just calls default instance)
@@ -131,10 +136,10 @@ public class CreatorOptimizer
         mv = cw.visitMethod(ACC_PUBLIC, "with", "("
                 +stdValueInstDesc+")"+optimizedValueInstDesc, null, null);
         mv.visitCode();
-        mv.visitTypeInsn(NEW, generatedClass);
+        mv.visitTypeInsn(NEW, tmpClassName);
         mv.visitInsn(DUP);
         mv.visitVarInsn(ALOAD, 1);
-        mv.visitMethodInsn(INVOKESPECIAL, generatedClass, "<init>", "("+stdValueInstDesc+")V", false);
+        mv.visitMethodInsn(INVOKESPECIAL, tmpClassName, "<init>", "("+stdValueInstDesc+")V", false);
         mv.visitInsn(ARETURN);
         mv.visitMaxs(0, 0);
         mv.visitEnd();
diff --git a/src/main/java/com/fasterxml/jackson/module/afterburner/deser/PropertyMutatorCollector.java b/src/main/java/com/fasterxml/jackson/module/afterburner/deser/PropertyMutatorCollector.java
index c4bf6a7..c570825 100644
--- a/src/main/java/com/fasterxml/jackson/module/afterburner/deser/PropertyMutatorCollector.java
+++ b/src/main/java/com/fasterxml/jackson/module/afterburner/deser/PropertyMutatorCollector.java
@@ -9,6 +9,7 @@ import static org.objectweb.asm.Opcodes.*;
 
 import com.fasterxml.jackson.databind.deser.SettableBeanProperty;
 import com.fasterxml.jackson.databind.introspect.AnnotatedField;
+import com.fasterxml.jackson.module.afterburner.util.ClassName;
 import com.fasterxml.jackson.module.afterburner.util.DynamicPropertyAccessorBase;
 import com.fasterxml.jackson.module.afterburner.util.MyClassLoader;
 
@@ -97,31 +98,26 @@ public class PropertyMutatorCollector
             classLoader = new MyClassLoader(beanClass.getClassLoader(), true);
         }
 
-        String srcName = beanClass.getName() + "$Access4JacksonDeserializer";
-
-        String generatedClass = internalClassName(srcName);
-        Class<?> accessorClass = null;
-        try {
-            accessorClass = classLoader.loadClass(srcName);
-        } catch (ClassNotFoundException e) { }
-        if (accessorClass == null) {
-            accessorClass = generateMutatorClass(classLoader, srcName, generatedClass);
-        }
+        final ClassName baseName = ClassName.constructFor(beanClass, "$Access4JacksonDeserializer");
+        Class<?> accessorClass = generateMutatorClass(classLoader, baseName);
         try {
             return (BeanPropertyMutator) accessorClass.newInstance();
         } catch (Exception e) {
-            throw new IllegalStateException("Failed to generate accessor class '"+srcName+"': "+e.getMessage(), e);
+            throw new IllegalStateException("Failed to generate accessor class '"+accessorClass.getName()+"': "+e.getMessage(), e);
         }
     }
 
-    public Class<?> generateMutatorClass(MyClassLoader classLoader, String srcName, String generatedClass)
+    public Class<?> generateMutatorClass(MyClassLoader classLoader, ClassName baseName)
     {
         ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);
         String superClass = internalClassName(BeanPropertyMutator.class.getName());
 
+        final String tmpClassName = baseName.getSlashedTemplate();
+
         // muchos important: level at least 1.5 to get generics!!!
-        cw.visit(V1_6, ACC_PUBLIC + ACC_SUPER + ACC_FINAL, generatedClass, null, superClass, null);
-        cw.visitSource(srcName + ".java", null);
+        cw.visit(V1_6, ACC_PUBLIC + ACC_SUPER + ACC_FINAL, tmpClassName,
+                null, superClass, null);
+        cw.visitSource(baseName.getSourceFilename(), null);
 
         // add default (no-arg) constructor first
         MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, "<init>", "()V", null, null);
@@ -151,11 +147,11 @@ public class PropertyMutatorCollector
                 internalClassName(SettableBeanProperty.class.getName()), superClass);
         mv = cw.visitMethod(ACC_PUBLIC, "with", withSig, null, null);
         mv.visitCode();
-        mv.visitTypeInsn(NEW, generatedClass);
+        mv.visitTypeInsn(NEW, tmpClassName);
         mv.visitInsn(DUP);
         mv.visitVarInsn(ALOAD, 1);
         mv.visitVarInsn(ILOAD, 2);
-        mv.visitMethodInsn(INVOKESPECIAL, generatedClass, "<init>", ctorSig, false);
+        mv.visitMethodInsn(INVOKESPECIAL, tmpClassName, "<init>", ctorSig, false);
         mv.visitInsn(ARETURN);
         mv.visitMaxs(0, 0); // don't care (real values: 1,1)
         mv.visitEnd();
@@ -198,10 +194,16 @@ public class PropertyMutatorCollector
         }
 
         cw.visitEnd();
-        byte[] byteCode = cw.toByteArray();
-        return classLoader.loadAndResolve(srcName, byteCode);
+        byte[] bytecode = cw.toByteArray();
+        baseName.assignChecksum(bytecode);
+        // already defined exactly as-is?
+        try {
+            return classLoader.loadClass(baseName.getDottedName());
+        } catch (ClassNotFoundException e) { }
+        // if not, load, resolve etc:
+        return classLoader.loadAndResolve(baseName, bytecode);
     }
-    
+
     /*
     /**********************************************************
     /* Code generation; method-based getters
diff --git a/src/main/java/com/fasterxml/jackson/module/afterburner/ser/PropertyAccessorCollector.java b/src/main/java/com/fasterxml/jackson/module/afterburner/ser/PropertyAccessorCollector.java
index 49d0674..99bf1db 100644
--- a/src/main/java/com/fasterxml/jackson/module/afterburner/ser/PropertyAccessorCollector.java
+++ b/src/main/java/com/fasterxml/jackson/module/afterburner/ser/PropertyAccessorCollector.java
@@ -9,6 +9,7 @@ import static org.objectweb.asm.Opcodes.*;
 
 import com.fasterxml.jackson.databind.introspect.AnnotatedField;
 import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;
+import com.fasterxml.jackson.module.afterburner.util.ClassName;
 import com.fasterxml.jackson.module.afterburner.util.DynamicPropertyAccessorBase;
 import com.fasterxml.jackson.module.afterburner.util.MyClassLoader;
 
@@ -92,34 +93,27 @@ public class PropertyAccessorCollector
         if (classLoader == null) {
             classLoader = new MyClassLoader(beanClass.getClassLoader(), true);
         }
-        
-        String srcName = beanClass.getName() + "$Access4JacksonSerializer";
-        
-        String generatedClass = internalClassName(srcName);
-        Class<?> accessorClass = null;
-        try {
-            accessorClass = classLoader.loadClass(srcName);
-        } catch (ClassNotFoundException e) { }
-        if (accessorClass == null) {
-            accessorClass = generateAccessorClass(classLoader, srcName, generatedClass);
-        }
+        final ClassName baseName = ClassName.constructFor(beanClass, "$Access4JacksonDeserializer");
+        Class<?> accessorClass = generateAccessorClass(classLoader, baseName);
         try {
             return (BeanPropertyAccessor) accessorClass.newInstance();
         } catch (Exception e) {
-            throw new IllegalStateException("Failed to generate accessor class '"+srcName+"': "+e.getMessage(), e);
+            throw new IllegalStateException("Failed to generate accessor class '"+accessorClass.getName()+"': "+e.getMessage(), e);
         }
     }
 
-    public Class<?> generateAccessorClass(MyClassLoader classLoader,
-                                          String srcName, String generatedClass)
+    public Class<?> generateAccessorClass(MyClassLoader classLoader, ClassName baseName)
     {
         ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);
         String superClass = internalClassName(BeanPropertyAccessor.class.getName());
-
+        final String tmpClassName = baseName.getSlashedTemplate();
+        
         // muchos important: level at least 1.5 to get generics!!!
         // also: since we require JDK 1.6 anyway, use that starting with Jackson 2.5
-        cw.visit(V1_6, ACC_PUBLIC + ACC_SUPER + ACC_FINAL, generatedClass, null, superClass, null);
-        cw.visitSource(srcName + ".java", null);
+
+        cw.visit(V1_6, ACC_PUBLIC + ACC_SUPER + ACC_FINAL, tmpClassName,
+                null, superClass, null);
+        cw.visitSource(baseName.getSourceFilename(), null);
 
         // add default (no-arg) constructor:
         MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, "<init>", "()V", null, null);
@@ -166,8 +160,15 @@ public class PropertyAccessorCollector
         }
 
         cw.visitEnd();
-        byte[] byteCode = cw.toByteArray();
-        return classLoader.loadAndResolve(srcName, byteCode);
+        byte[] bytecode = cw.toByteArray();
+        baseName.assignChecksum(bytecode);
+
+        // Did we already generate this?
+        try {
+            return classLoader.loadClass(baseName.getDottedName());
+        } catch (ClassNotFoundException e) { }
+        // if not, load and resolve:
+        return classLoader.loadAndResolve(baseName, bytecode);
     }
 
     /*
diff --git a/src/main/java/com/fasterxml/jackson/module/afterburner/ser/SerializerModifier.java b/src/main/java/com/fasterxml/jackson/module/afterburner/ser/SerializerModifier.java
index 69e3260..841c1af 100644
--- a/src/main/java/com/fasterxml/jackson/module/afterburner/ser/SerializerModifier.java
+++ b/src/main/java/com/fasterxml/jackson/module/afterburner/ser/SerializerModifier.java
@@ -52,12 +52,16 @@ public class SerializerModifier extends BeanSerializerModifier
         }
         
         // if we had a match, need to materialize
-        BeanPropertyAccessor acc = collector.findAccessor(_classLoader);
+        BeanPropertyAccessor acc = null;
+
         // and then link accessors to bean property writers:
         ListIterator<BeanPropertyWriter> it = beanProperties.listIterator();
         while (it.hasNext()) {
             BeanPropertyWriter bpw = it.next();
             if (bpw instanceof OptimizedBeanPropertyWriter<?>) {
+                if (acc == null) {
+                    acc = collector.findAccessor(_classLoader);
+                }
                 it.set(((OptimizedBeanPropertyWriter<?>) bpw).withAccessor(acc));
             }
         }
diff --git a/src/main/java/com/fasterxml/jackson/module/afterburner/util/ClassName.java b/src/main/java/com/fasterxml/jackson/module/afterburner/util/ClassName.java
new file mode 100644
index 0000000..7753446
--- /dev/null
+++ b/src/main/java/com/fasterxml/jackson/module/afterburner/util/ClassName.java
@@ -0,0 +1,106 @@
+package com.fasterxml.jackson.module.afterburner.util;
+
+import java.util.zip.Adler32;
+
+/**
+ * Accessing various permutations of dotted/slashed representations gets
+ * tiresome after a while, so here's an abstraction for hiding complexities,
+ * and for performing lazy transformations as necessary.
+ */
+public class ClassName
+{
+    public final static String TEMPLATE_SUFFIX = actualClassName("", 0L);
+
+    // Basenames with no checksum suffix
+    protected final String _dottedBase;
+    
+    protected String _slashedBase;
+
+    protected String _dottedName, _slashedName;
+    
+    protected long _checksum;
+    
+    private ClassName(String dottedBase) {
+        _dottedBase = dottedBase;
+    }
+
+    public static ClassName constructFor(Class<?> baseClass, String suffix) {
+        return new ClassName(baseClass.getName() + suffix);
+    }
+
+    public void assignChecksum(byte[] data) {
+        long l = adler32(data);
+        if (_checksum != 0L) {
+            throw new IllegalStateException("Trying to re-assign checksum as 0x"+Long.toHexString(l)
+                    +" (had 0x"+Long.toHexString(_checksum)+")");
+        }
+        // Need to mask unlikely checksum of 0
+        if (l == 0L) {
+            l = 1;
+        }
+        _checksum = l;
+    }
+    
+    public String getDottedTemplate() {
+        return _dottedBase + TEMPLATE_SUFFIX;
+    }
+
+    public String getSlashedTemplate() {
+        return getSlashedBase() + TEMPLATE_SUFFIX;
+    }
+
+    public String getDottedName() {
+        if (_dottedName == null) {
+            if (_checksum == 0) {
+                throw new IllegalStateException("No checksum assigned yet");
+            }
+            _dottedName = String.format("%s%08x", getDottedBase(), (int) _checksum);
+        }
+        return _dottedName;
+    }
+
+    public String getSlashedName() {
+        if (_slashedName == null) {
+            if (_checksum == 0) {
+                throw new IllegalStateException("No checksum assigned yet");
+            } 
+            _slashedName = String.format("%s%08x", getSlashedBase(), (int) _checksum);
+        }
+        return _slashedName;
+    }
+
+    public String getSourceFilename() {
+        return getSlashedBase() + ".java";
+    }
+    
+    public String getDottedBase() {
+        return _dottedBase;
+    }
+
+    public String getSlashedBase() {
+        if (_slashedBase == null) {
+            _slashedBase = dotsToSlashes(_dottedBase);
+        }
+        return _slashedBase;
+    }
+
+    @Override
+    public String toString() {
+        return getDottedName();
+    }
+
+    private static String actualClassName(String base, long checksum) {
+        return String.format("%s%08x", base, (int) checksum);
+    }
+
+    protected static String dotsToSlashes(String className) {
+        return className.replace(".", "/");
+    }
+
+    protected static long adler32(byte[] data)
+    {
+        Adler32 adler = new Adler32();
+        adler.update(data);
+        return adler.getValue();
+    }
+}
diff --git a/src/main/java/com/fasterxml/jackson/module/afterburner/util/MyClassLoader.java b/src/main/java/com/fasterxml/jackson/module/afterburner/util/MyClassLoader.java
index 86a0d00..cfcb5d3 100644
--- a/src/main/java/com/fasterxml/jackson/module/afterburner/util/MyClassLoader.java
+++ b/src/main/java/com/fasterxml/jackson/module/afterburner/util/MyClassLoader.java
@@ -1,12 +1,15 @@
 package com.fasterxml.jackson.module.afterburner.util;
 
 import java.lang.reflect.Method;
+import java.nio.charset.Charset;
 
 /**
  * Class loader that is needed to load generated classes.
  */
 public class MyClassLoader extends ClassLoader
 {
+    private final static Charset UTF8 = Charset.forName("UTF-8");
+
     /**
      * Flag that determines if we should first try to load new class
      * using parent class loader or not; this may be done to try to
@@ -52,16 +55,20 @@ public class MyClassLoader extends ClassLoader
      * @param className Interface or abstract class that class to load should extend or 
      *   implement
      */
-    public Class<?> loadAndResolve(String className, byte[] byteCode)
+    public Class<?> loadAndResolve(ClassName className, byte[] byteCode)
         throws IllegalArgumentException
     {
         // First things first: just to be sure; maybe we have already loaded it?
-        Class<?> old = findLoadedClass(className);
+        Class<?> old = findLoadedClass(className.getDottedName());
         if (old != null) {
             return old;
         }
         
         Class<?> impl;
+
+        // Important: bytecode is generated with a template name (since bytecode itself
+        // is used for checksum calculation) -- must be replaced now, however
+        replaceName(byteCode, className.getSlashedTemplate(), className.getSlashedName());
         
         // First: let's try calling it directly on parent, to be able to access protected/package-access stuff:
         if (_cfgUseParentLoader) {
@@ -74,7 +81,7 @@ public class MyClassLoader extends ClassLoader
                             int.class});
                     method.setAccessible(true);
                     return (Class<?>)method.invoke(getParent(),
-                            className, byteCode, 0, byteCode.length);
+                            className.getDottedName(), byteCode, 0, byteCode.length);
                 } catch (Exception e) {
                     // Should we handle this somehow?
                 }
@@ -82,18 +89,52 @@ public class MyClassLoader extends ClassLoader
         }
 
         // but if that doesn't fly, try to do it from our own class loader
+    
         try {
-            impl = defineClass(className, byteCode, 0, byteCode.length);
+            impl = defineClass(className.getDottedName(), byteCode, 0, byteCode.length);
         } catch (LinkageError e) {
             Throwable t = e;
             while (t.getCause() != null) {
                 t = t.getCause();
             }
-t.printStackTrace();            
             throw new IllegalArgumentException("Failed to load class '"+className+"': "+t.getMessage(), t);
         }
         // important: must also resolve the class...
         resolveClass(impl);
         return impl;
     }
+    
+    public static int replaceName(byte[] byteCode,
+            String from, String to)
+    {
+        byte[] fromB = from.getBytes(UTF8);
+        byte[] toB = to.getBytes(UTF8);
+
+        final int matchLength = fromB.length;
+
+        // sanity check
+        if (matchLength != toB.length) {
+            throw new IllegalArgumentException("From String '"+from
+                    +"' has different length than To String '"+to+"'");
+        }
+
+        int i = 0;
+        int count = 0;
+
+        // naive; for now has to do
+        main_loop:
+        for (int end = byteCode.length - matchLength; i <= end; ) {
+            if (byteCode[i++] == fromB[0]) {
+                for (int j = 1; j < matchLength; ++j) {
+                    if (fromB[j] != byteCode[i+j-1]) {
+                        continue main_loop;
+                    }
+                }
+                ++count;
+                System.arraycopy(toB, 0, byteCode, i-1, matchLength);
+                i += (matchLength-1);
+            }
+        }
+        return count;
+    }
 }
diff --git a/src/test/java/com/fasterxml/jackson/module/afterburner/failing/Issue51Test.java b/src/test/java/com/fasterxml/jackson/module/afterburner/codegen/GenerateWithMixinsTest.java
similarity index 88%
rename from src/test/java/com/fasterxml/jackson/module/afterburner/failing/Issue51Test.java
rename to src/test/java/com/fasterxml/jackson/module/afterburner/codegen/GenerateWithMixinsTest.java
index f8eeff7..a571229 100644
--- a/src/test/java/com/fasterxml/jackson/module/afterburner/failing/Issue51Test.java
+++ b/src/test/java/com/fasterxml/jackson/module/afterburner/codegen/GenerateWithMixinsTest.java
@@ -1,11 +1,13 @@
-package com.fasterxml.jackson.module.afterburner.failing;
+package com.fasterxml.jackson.module.afterburner.codegen;
 
 import com.fasterxml.jackson.annotation.JsonIgnore;
 import com.fasterxml.jackson.core.JsonProcessingException;
 import com.fasterxml.jackson.databind.ObjectMapper;
 import com.fasterxml.jackson.module.afterburner.AfterburnerTestBase;
 
-public class Issue51Test extends AfterburnerTestBase
+// for [afterburner#51], where re-generation of classes does not work
+// as expected
+public class GenerateWithMixinsTest extends AfterburnerTestBase
 {
     static class SampleObject {
         private String field1;
diff --git a/src/test/java/com/fasterxml/jackson/module/afterburner/ser/TestJsonSerializeAnnotationBug.java b/src/test/java/com/fasterxml/jackson/module/afterburner/ser/TestJsonSerializeAnnotationBug.java
index c18e924..3a2c856 100644
--- a/src/test/java/com/fasterxml/jackson/module/afterburner/ser/TestJsonSerializeAnnotationBug.java
+++ b/src/test/java/com/fasterxml/jackson/module/afterburner/ser/TestJsonSerializeAnnotationBug.java
@@ -16,7 +16,6 @@ public class TestJsonSerializeAnnotationBug extends AfterburnerTestBase {
         objectMapper.registerModule(new AfterburnerModule());
 
         String value = objectMapper.writeValueAsString(new TestObjectWithJsonSerialize(new BigDecimal("870.04")));
-
-
+        assertNotNull(value);
     }
 }
diff --git a/src/test/java/com/fasterxml/jackson/module/afterburner/ser/TestStdSerializerOverrides.java b/src/test/java/com/fasterxml/jackson/module/afterburner/ser/TestStdSerializerOverrides.java
index 6410b32..408506a 100644
--- a/src/test/java/com/fasterxml/jackson/module/afterburner/ser/TestStdSerializerOverrides.java
+++ b/src/test/java/com/fasterxml/jackson/module/afterburner/ser/TestStdSerializerOverrides.java
@@ -8,7 +8,6 @@ import com.fasterxml.jackson.databind.ObjectMapper;
 import com.fasterxml.jackson.databind.SerializerProvider;
 import com.fasterxml.jackson.databind.annotation.JsonSerialize;
 import com.fasterxml.jackson.databind.ser.std.StdSerializer;
-
 import com.fasterxml.jackson.module.afterburner.AfterburnerTestBase;
 
 public class TestStdSerializerOverrides extends AfterburnerTestBase
@@ -21,6 +20,7 @@ public class TestStdSerializerOverrides extends AfterburnerTestBase
         public String b = "b";
     }
 
+    @SuppressWarnings("serial")
     static class MyStringSerializer extends StdSerializer<String>
     {
         public MyStringSerializer() { super(String.class); }
diff --git a/src/test/java/com/fasterxml/jackson/module/afterburner/util/MyClassLoaderTest.java b/src/test/java/com/fasterxml/jackson/module/afterburner/util/MyClassLoaderTest.java
new file mode 100644
index 0000000..15617f7
--- /dev/null
+++ b/src/test/java/com/fasterxml/jackson/module/afterburner/util/MyClassLoaderTest.java
@@ -0,0 +1,14 @@
+package com.fasterxml.jackson.module.afterburner.util;
+
+import com.fasterxml.jackson.module.afterburner.AfterburnerTestBase;
+
+public class MyClassLoaderTest extends AfterburnerTestBase
+{
+    public void testNameReplacement() throws Exception
+    {
+        byte[] input = "Something with FOO in it (but not just FO!): FOOFOO".getBytes("UTF-8");
+        int count = MyClassLoader.replaceName(input, "FOO", "BAR");
+//        assertEquals(3, count);
+        assertEquals("Something with BAR in it (but not just FO!): BARBAR", new String(input, "UTF-8"));
+    }
+}
