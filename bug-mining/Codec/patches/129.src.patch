diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index b7a3d8bf..fba8d092 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -45,6 +45,7 @@ The <action> type attribute can be add,update,fix,remove.
     <release version="1.11" date="2016-MM-DD" description="Feature and fix release.">
       <!-- The first attribute below should be the issue id; makes it easier to navigate in the IDE outline -->
 
+	  <action issue="CODEC-225" dev="jochen" type="fix" due-to="Svetlin Zarev">Fix minor resource leaks</action>
       <action issue="CODEC-223" dev="sebb" type="remove">Drop obsolete Ant build</action>
       <action issue="CODEC-171" dev="sebb" type="add" due-to="Brett Okken">Add support for CRC32-C</action>
       <action issue="CODEC-221" dev="sebb" type="update">HmacUtils.updateHmac calls reset() unnecessarily</action>
diff --git a/src/main/java/org/apache/commons/codec/language/DaitchMokotoffSoundex.java b/src/main/java/org/apache/commons/codec/language/DaitchMokotoffSoundex.java
index 4b83f33d..de94a734 100644
--- a/src/main/java/org/apache/commons/codec/language/DaitchMokotoffSoundex.java
+++ b/src/main/java/org/apache/commons/codec/language/DaitchMokotoffSoundex.java
@@ -232,8 +232,11 @@ public class DaitchMokotoffSoundex implements StringEncoder {
         }
 
         final Scanner scanner = new Scanner(rulesIS, CharEncoding.UTF_8);
-        parseRules(scanner, RESOURCE_FILE, RULES, FOLDINGS);
-        scanner.close();
+        try {
+            parseRules(scanner, RESOURCE_FILE, RULES, FOLDINGS);
+        } finally {
+            scanner.close();
+        }
 
         // sort RULES by pattern length in descending order
         for (final Map.Entry<Character, List<Rule>> rule : RULES.entrySet()) {
diff --git a/src/main/java/org/apache/commons/codec/language/bm/Rule.java b/src/main/java/org/apache/commons/codec/language/bm/Rule.java
index 721cb487..197cf0fb 100644
--- a/src/main/java/org/apache/commons/codec/language/bm/Rule.java
+++ b/src/main/java/org/apache/commons/codec/language/bm/Rule.java
@@ -219,14 +219,22 @@ public class Rule {
 
                 final Languages ls = Languages.getInstance(s);
                 for (final String l : ls.getLanguages()) {
+                    final Scanner scanner = createScanner(s, rt, l);
                     try {
-                        rs.put(l, parseRules(createScanner(s, rt, l), createResourceName(s, rt, l)));
+                        rs.put(l, parseRules(scanner, createResourceName(s, rt, l)));
                     } catch (final IllegalStateException e) {
                         throw new IllegalStateException("Problem processing " + createResourceName(s, rt, l), e);
+                    } finally {
+                        scanner.close();
                     }
                 }
                 if (!rt.equals(RuleType.RULES)) {
-                    rs.put("common", parseRules(createScanner(s, rt, "common"), createResourceName(s, rt, "common")));
+                    final Scanner scanner = createScanner(s, rt, "common");
+                    try {
+                        rs.put("common", parseRules(scanner, createResourceName(s, rt, "common")));
+                    } finally {
+                        scanner.close();
+                    }
                 }
 
                 rts.put(rt, Collections.unmodifiableMap(rs));
@@ -435,7 +443,12 @@ public class Rule {
                             throw new IllegalArgumentException("Malformed import statement '" + rawLine + "' in " +
                                                                location);
                         }
-                        lines.putAll(parseRules(createScanner(incl), location + "->" + incl));
+                        final Scanner hashIncludeScanner = createScanner(incl);
+                        try {
+                            lines.putAll(parseRules(hashIncludeScanner, location + "->" + incl));
+                        } finally {
+                            hashIncludeScanner.close();
+                        }
                     } else {
                         // rule
                         final String[] parts = line.split("\\s+");
