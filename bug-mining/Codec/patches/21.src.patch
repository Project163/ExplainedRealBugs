diff --git a/src/java/org/apache/commons/codec/binary/Hex.java b/src/java/org/apache/commons/codec/binary/Hex.java
index 13c6ae2c..0553c1ac 100644
--- a/src/java/org/apache/commons/codec/binary/Hex.java
+++ b/src/java/org/apache/commons/codec/binary/Hex.java
@@ -17,13 +17,17 @@
 
 package org.apache.commons.codec.binary;
 
+import java.io.UnsupportedEncodingException;
+
 import org.apache.commons.codec.BinaryDecoder;
 import org.apache.commons.codec.BinaryEncoder;
+import org.apache.commons.codec.CharEncoding;
 import org.apache.commons.codec.DecoderException;
 import org.apache.commons.codec.EncoderException;
 
 /**
- * Hex encoder and decoder.
+ * Hex encoder and decoder. The charset used for certain operation can be set, the default is set in
+ * {@link #DEFAULT_CHARSET_NAME}
  * 
  * @since 1.1
  * @author Apache Software Foundation
@@ -31,34 +35,31 @@ import org.apache.commons.codec.EncoderException;
  */
 public class Hex implements BinaryEncoder, BinaryDecoder {
 
-    /** 
-     * Used to build output as Hex 
+    /**
+     * Default charset name is {@link CharEncoding#UTF_8}
      */
-    private static final char[] DIGITS_LOWER = {
-        '0', '1', '2', '3', '4', '5', '6', '7',
-           '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
-    };
+    public static final String DEFAULT_CHARSET_NAME = CharEncoding.UTF_8;
 
-    /** 
-     * Used to build output as Hex 
+    /**
+     * Used to build output as Hex
      */
-    private static final char[] DIGITS_UPPER = {
-        '0', '1', '2', '3', '4', '5', '6', '7',
-           '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'
-    };
+    private static final char[] DIGITS_LOWER = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};
 
     /**
-     * Converts an array of characters representing hexadecimal values into an
-     * array of bytes of those same values. The returned array will be half the
-     * length of the passed array, as it takes two characters to represent any
-     * given byte. An exception is thrown if the passed char array has an odd
-     * number of elements.
+     * Used to build output as Hex
+     */
+    private static final char[] DIGITS_UPPER = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
+
+    /**
+     * Converts an array of characters representing hexadecimal values into an array of bytes of those same values. The
+     * returned array will be half the length of the passed array, as it takes two characters to represent any given
+     * byte. An exception is thrown if the passed char array has an odd number of elements.
      * 
-     * @param data An array of characters containing hexadecimal digits
-     * @return A byte array containing binary data decoded from
-     *         the supplied char array.
-     * @throws DecoderException Thrown if an odd number or illegal of characters 
-     *         is supplied
+     * @param data
+     *            An array of characters containing hexadecimal digits
+     * @return A byte array containing binary data decoded from the supplied char array.
+     * @throws DecoderException
+     *             Thrown if an odd number or illegal of characters is supplied
      */
     public static byte[] decodeHex(char[] data) throws DecoderException {
 
@@ -82,22 +83,6 @@ public class Hex implements BinaryEncoder, BinaryDecoder {
         return out;
     }
 
-    /**
-     * Converts a hexadecimal character to an integer.
-     *  
-     * @param ch A character to convert to an integer digit
-     * @param index The index of the character in the source
-     * @return An integer
-     * @throws DecoderException Thrown if ch is an illegal hex character
-     */
-    protected static int toDigit(char ch, int index) throws DecoderException {
-        int digit = Character.digit(ch, 16);
-        if (digit == -1) {
-            throw new DecoderException("Illegal hexadecimal charcter " + ch + " at index " + index);
-        }
-        return digit;
-    }
-
     /**
      * Converts an array of bytes into an array of characters representing the hexadecimal values of each byte in order.
      * The returned array will be double the length of the passed array, as it takes two characters to represent any
@@ -151,35 +136,87 @@ public class Hex implements BinaryEncoder, BinaryDecoder {
     }
 
     /**
-     * Converts an array of character bytes representing hexadecimal values into an
-     * array of bytes of those same values. The returned array will be half the
-     * length of the passed array, as it takes two characters to represent any
-     * given byte. An exception is thrown if the passed char array has an odd
-     * number of elements.
+     * Converts an array of bytes into a String representing the hexadecimal values of each byte in order. The returned
+     * String will be double the length of the passed array, as it takes two characters to represent any given byte.
+     * 
+     * @param data
+     *            a byte[] to convert to Hex characters
+     * @return A String containing hexadecimal characters
+     * @since 1.4
+     */
+    public static String encodeHexString(byte[] data) {
+        return new String(encodeHex(data));
+    }
+
+    /**
+     * Converts a hexadecimal character to an integer.
      * 
-     * @param array An array of character bytes containing hexadecimal digits
-     * @return A byte array containing binary data decoded from
-     *         the supplied byte array (representing characters).
-     * @throws DecoderException Thrown if an odd number of characters is supplied
-     *                   to this function
+     * @param ch
+     *            A character to convert to an integer digit
+     * @param index
+     *            The index of the character in the source
+     * @return An integer
+     * @throws DecoderException
+     *             Thrown if ch is an illegal hex character
+     */
+    protected static int toDigit(char ch, int index) throws DecoderException {
+        int digit = Character.digit(ch, 16);
+        if (digit == -1) {
+            throw new DecoderException("Illegal hexadecimal charcter " + ch + " at index " + index);
+        }
+        return digit;
+    }
+
+    private String charsetName = DEFAULT_CHARSET_NAME;
+
+    /**
+     * Creates a new codec with the default charset name {@link #DEFAULT_CHARSET_NAME}
+     */
+    public Hex() {
+        // use default encoding
+    }
+
+    /**
+     * Creates a new codec with the given charset name.
+     * 
+     * @param csName
+     *            the charset name.
+     */
+    public Hex(String csName) {
+        setCharsetName(csName);
+    }
+
+    /**
+     * Converts an array of character bytes representing hexadecimal values into an array of bytes of those same values.
+     * The returned array will be half the length of the passed array, as it takes two characters to represent any given
+     * byte. An exception is thrown if the passed char array has an odd number of elements.
+     * 
+     * @param array
+     *            An array of character bytes containing hexadecimal digits
+     * @return A byte array containing binary data decoded from the supplied byte array (representing characters).
+     * @throws DecoderException
+     *             Thrown if an odd number of characters is supplied to this function
      * @see #decodeHex(char[])
      */
     public byte[] decode(byte[] array) throws DecoderException {
-        return decodeHex(new String(array).toCharArray());
+        try {
+            return decodeHex(new String(array, getCharsetName()).toCharArray());
+        } catch (UnsupportedEncodingException e) {
+            throw new DecoderException(e.getMessage(), e);
+        }
     }
-    
+
     /**
-     * Converts a String or an array of character bytes representing hexadecimal values into an
-     * array of bytes of those same values. The returned array will be half the
-     * length of the passed String or array, as it takes two characters to represent any
-     * given byte. An exception is thrown if the passed char array has an odd
-     * number of elements.
+     * Converts a String or an array of character bytes representing hexadecimal values into an array of bytes of those
+     * same values. The returned array will be half the length of the passed String or array, as it takes two characters
+     * to represent any given byte. An exception is thrown if the passed char array has an odd number of elements.
      * 
-     * @param object A String or, an array of character bytes containing hexadecimal digits
-     * @return A byte array containing binary data decoded from
-     *         the supplied byte array (representing characters).
-     * @throws DecoderException Thrown if an odd number of characters is supplied
-     *                   to this function or the object is not a String or char[]
+     * @param object
+     *            A String or, an array of character bytes containing hexadecimal digits
+     * @return A byte array containing binary data decoded from the supplied byte array (representing characters).
+     * @throws DecoderException
+     *             Thrown if an odd number of characters is supplied to this function or the object is not a String or
+     *             char[]
      * @see #decodeHex(char[])
      */
     public Object decode(Object object) throws DecoderException {
@@ -192,38 +229,73 @@ public class Hex implements BinaryEncoder, BinaryDecoder {
     }
 
     /**
-     * Converts an array of bytes into an array of bytes for the characters representing the
-     * hexadecimal values of each byte in order. The returned array will be
-     * double the length of the passed array, as it takes two characters to
+     * Converts an array of bytes into an array of bytes for the characters representing the hexadecimal values of each
+     * byte in order. The returned array will be double the length of the passed array, as it takes two characters to
      * represent any given byte.
-     *
-     * @param array a byte[] to convert to Hex characters
+     * <p>
+     * The conversion from hexadecimal characters to the returned bytes is performed with the charset named by
+     * {@link #getCharsetName()}.
+     * </p>
+     * 
+     * @param array
+     *            a byte[] to convert to Hex characters
      * @return A byte[] containing the bytes of the hexadecimal characters
+     * @throws IllegalStateException
+     *             if the charsetName is invalid. This API throws {@link IllegalStateException} instead of
+     *             {@link UnsupportedEncodingException} for backward compatibility.
      * @see #encodeHex(byte[])
      */
     public byte[] encode(byte[] array) {
-        return new String(encodeHex(array)).getBytes();
+        return StringUtils.getBytesUnchecked(encodeHexString(array), getCharsetName());
     }
 
     /**
-     * Converts a String or an array of bytes into an array of characters representing the
-     * hexadecimal values of each byte in order. The returned array will be
-     * double the length of the passed String or array, as it takes two characters to
-     * represent any given byte.
-     *
-     * @param object a String, or byte[] to convert to Hex characters
+     * Converts a String or an array of bytes into an array of characters representing the hexadecimal values of each
+     * byte in order. The returned array will be double the length of the passed String or array, as it takes two
+     * characters to represent any given byte.
+     * <p>
+     * The conversion from hexadecimal characters to bytes to be encoded to performed with the charset named by
+     * {@link #getCharsetName()}.
+     * </p>
+     * 
+     * @param object
+     *            a String, or byte[] to convert to Hex characters
      * @return A char[] containing hexadecimal characters
-     * @throws EncoderException Thrown if the given object is not a String or byte[]
+     * @throws EncoderException
+     *             Thrown if the given object is not a String or byte[]
      * @see #encodeHex(byte[])
      */
-    public Object encode(Object object) throws EncoderException {    
+    public Object encode(Object object) throws EncoderException {
         try {
-            byte[] byteArray = object instanceof String ? ((String) object).getBytes() : (byte[]) object;
+            byte[] byteArray = object instanceof String ? ((String) object).getBytes(getCharsetName()) : (byte[]) object;
             return encodeHex(byteArray);
         } catch (ClassCastException e) {
             throw new EncoderException(e.getMessage(), e);
+        } catch (UnsupportedEncodingException e) {
+            throw new EncoderException(e.getMessage(), e);
         }
     }
 
-}
+    /**
+     * Gets the charset name.
+     * 
+     * @return the charset name.
+     */
+    public String getCharsetName() {
+        return this.charsetName;
+    }
+
+    /**
+     * Sets the charset name.
+     * 
+     * @param charsetName
+     *            the charset name.
+     */
+    public void setCharsetName(String charsetName) {
+        this.charsetName = charsetName;
+    }
 
+    public String toString() {
+        return super.toString() + "[charsetName=" + this.charsetName + "]";
+    }
+}
diff --git a/src/java/org/apache/commons/codec/binary/StringUtils.java b/src/java/org/apache/commons/codec/binary/StringUtils.java
index 9de8a256..2e6f5790 100644
--- a/src/java/org/apache/commons/codec/binary/StringUtils.java
+++ b/src/java/org/apache/commons/codec/binary/StringUtils.java
@@ -43,10 +43,10 @@ public class StringUtils {
      * @throws IllegalStateException
      *             Thrown when the charset is missing, which should be never according the the Java specification.
      * @see <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html">Standard charsets</a>
-     * @see #getSupportedBytes(String, String)
+     * @see #getBytesUnchecked(String, String)
      */
     public static byte[] getBytesIso8859_1(String string) {
-        return StringUtils.getSupportedBytes(string, CharEncoding.ISO_8859_1);
+        return StringUtils.getBytesUnchecked(string, CharEncoding.ISO_8859_1);
     }
 
     /**
@@ -59,10 +59,10 @@ public class StringUtils {
      * @throws IllegalStateException
      *             Thrown when the charset is missing, which should be never according the the Java specification.
      * @see <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html">Standard charsets</a>
-     * @see #getSupportedBytes(String, String)
+     * @see #getBytesUnchecked(String, String)
      */
     public static byte[] getBytesUsAscii(String string) {
-        return StringUtils.getSupportedBytes(string, CharEncoding.US_ASCII);
+        return StringUtils.getBytesUnchecked(string, CharEncoding.US_ASCII);
     }
 
     /**
@@ -75,10 +75,10 @@ public class StringUtils {
      * @throws IllegalStateException
      *             Thrown when the charset is missing, which should be never according the the Java specification.
      * @see <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html">Standard charsets</a>
-     * @see #getSupportedBytes(String, String)
+     * @see #getBytesUnchecked(String, String)
      */
     public static byte[] getBytesUtf16(String string) {
-        return StringUtils.getSupportedBytes(string, CharEncoding.UTF_16);
+        return StringUtils.getBytesUnchecked(string, CharEncoding.UTF_16);
     }
 
     /**
@@ -91,10 +91,10 @@ public class StringUtils {
      * @throws IllegalStateException
      *             Thrown when the charset is missing, which should be never according the the Java specification.
      * @see <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html">Standard charsets</a>
-     * @see #getSupportedBytes(String, String)
+     * @see #getBytesUnchecked(String, String)
      */
     public static byte[] getBytesUtf16Be(String string) {
-        return StringUtils.getSupportedBytes(string, CharEncoding.UTF_16BE);
+        return StringUtils.getBytesUnchecked(string, CharEncoding.UTF_16BE);
     }
 
     /**
@@ -107,10 +107,10 @@ public class StringUtils {
      * @throws IllegalStateException
      *             Thrown when the charset is missing, which should be never according the the Java specification.
      * @see <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html">Standard charsets</a>
-     * @see #getSupportedBytes(String, String)
+     * @see #getBytesUnchecked(String, String)
      */
     public static byte[] getBytesUtf16Le(String string) {
-        return StringUtils.getSupportedBytes(string, CharEncoding.UTF_16LE);
+        return StringUtils.getBytesUnchecked(string, CharEncoding.UTF_16LE);
     }
 
     /**
@@ -123,10 +123,10 @@ public class StringUtils {
      * @throws IllegalStateException
      *             Thrown when the charset is missing, which should be never according the the Java specification.
      * @see <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html">Standard charsets</a>
-     * @see #getSupportedBytes(String, String)
+     * @see #getBytesUnchecked(String, String)
      */
     public static byte[] getBytesUtf8(String string) {
-        return StringUtils.getSupportedBytes(string, CharEncoding.UTF_8);
+        return StringUtils.getBytesUnchecked(string, CharEncoding.UTF_8);
     }
 
     /**
@@ -148,7 +148,7 @@ public class StringUtils {
      * @see CharEncoding
      * @see String#getBytes(String)
      */
-    public static byte[] getSupportedBytes(String string, String charsetName) {
+    public static byte[] getBytesUnchecked(String string, String charsetName) {
         if (string == null) {
             return null;
         }
diff --git a/src/java/org/apache/commons/codec/digest/DigestUtils.java b/src/java/org/apache/commons/codec/digest/DigestUtils.java
index 547d39fe..762cef57 100644
--- a/src/java/org/apache/commons/codec/digest/DigestUtils.java
+++ b/src/java/org/apache/commons/codec/digest/DigestUtils.java
@@ -198,7 +198,7 @@ public class DigestUtils {
      * @return MD5 digest as a hex string
      */
     public static String md5Hex(byte[] data) {
-        return new String(Hex.encodeHex(md5(data)));
+        return Hex.encodeHexString(md5(data));
     }
 
     /**
@@ -212,7 +212,7 @@ public class DigestUtils {
      * @since 1.4
      */
     public static String md5Hex(InputStream data) throws IOException {
-        return new String(Hex.encodeHex(md5(data)));
+        return Hex.encodeHexString(md5(data));
     }
 
     /**
@@ -223,7 +223,7 @@ public class DigestUtils {
      * @return MD5 digest as a hex string
      */
     public static String md5Hex(String data) {
-        return new String(Hex.encodeHex(md5(data)));
+        return Hex.encodeHexString(md5(data));
     }
 
     /**
@@ -321,7 +321,7 @@ public class DigestUtils {
      * @since 1.4
      */
     public static String sha256Hex(byte[] data) {
-        return new String(Hex.encodeHex(sha256(data)));
+        return Hex.encodeHexString(sha256(data));
     }
 
     /**
@@ -338,7 +338,7 @@ public class DigestUtils {
      * @since 1.4
      */
     public static String sha256Hex(InputStream data) throws IOException {
-        return new String(Hex.encodeHex(sha256(data)));
+        return Hex.encodeHexString(sha256(data));
     }
 
     /**
@@ -353,7 +353,7 @@ public class DigestUtils {
      * @since 1.4
      */
     public static String sha256Hex(String data) {
-        return new String(Hex.encodeHex(sha256(data)));
+        return Hex.encodeHexString(sha256(data));
     }
 
     /**
@@ -415,7 +415,7 @@ public class DigestUtils {
      * @since 1.4
      */
     public static String sha384Hex(byte[] data) {
-        return new String(Hex.encodeHex(sha384(data)));
+        return Hex.encodeHexString(sha384(data));
     }
 
     /**
@@ -432,7 +432,7 @@ public class DigestUtils {
      * @since 1.4
      */
     public static String sha384Hex(InputStream data) throws IOException {
-        return new String(Hex.encodeHex(sha384(data)));
+        return Hex.encodeHexString(sha384(data));
     }
 
     /**
@@ -447,7 +447,7 @@ public class DigestUtils {
      * @since 1.4
      */
     public static String sha384Hex(String data) {
-        return new String(Hex.encodeHex(sha384(data)));
+        return Hex.encodeHexString(sha384(data));
     }
 
     /**
@@ -509,7 +509,7 @@ public class DigestUtils {
      * @since 1.4
      */
     public static String sha512Hex(byte[] data) {
-        return new String(Hex.encodeHex(sha512(data)));
+        return Hex.encodeHexString(sha512(data));
     }
 
     /**
@@ -526,7 +526,7 @@ public class DigestUtils {
      * @since 1.4
      */
     public static String sha512Hex(InputStream data) throws IOException {
-        return new String(Hex.encodeHex(sha512(data)));
+        return Hex.encodeHexString(sha512(data));
     }
 
     /**
@@ -541,7 +541,7 @@ public class DigestUtils {
      * @since 1.4
      */
     public static String sha512Hex(String data) {
-        return new String(Hex.encodeHex(sha512(data)));
+        return Hex.encodeHexString(sha512(data));
     }
 
     /**
@@ -552,7 +552,7 @@ public class DigestUtils {
      * @return SHA-1 digest as a hex string
      */
     public static String shaHex(byte[] data) {
-        return new String(Hex.encodeHex(sha(data)));
+        return Hex.encodeHexString(sha(data));
     }
 
     /**
@@ -566,7 +566,7 @@ public class DigestUtils {
      * @since 1.4
      */
     public static String shaHex(InputStream data) throws IOException {
-        return new String(Hex.encodeHex(sha(data)));
+        return Hex.encodeHexString(sha(data));
     }
 
     /**
@@ -577,6 +577,6 @@ public class DigestUtils {
      * @return SHA-1 digest as a hex string
      */
     public static String shaHex(String data) {
-        return new String(Hex.encodeHex(sha(data)));
+        return Hex.encodeHexString(sha(data));
     }
 }
diff --git a/src/test/org/apache/commons/codec/binary/Base64Test.java b/src/test/org/apache/commons/codec/binary/Base64Test.java
index 90042c20..fd7e5fdb 100644
--- a/src/test/org/apache/commons/codec/binary/Base64Test.java
+++ b/src/test/org/apache/commons/codec/binary/Base64Test.java
@@ -940,24 +940,24 @@ public class Base64Test extends TestCase {
             // Very important debugging output should anyone
             // ever need to delve closely into this stuff.
             if (false) {
-                System.out.println("reference: [" + new String(Hex.encodeHex(ids[i])) + "]");
+                System.out.println("reference: [" + Hex.encodeHexString(ids[i]) + "]");
                 System.out.println("standard:  [" +
-                    new String(Hex.encodeHex(decodedStandard)) +
+                        Hex.encodeHexString(decodedStandard) +
                     "] From: [" +
                     StringUtils.newStringUtf8(standard[i]) +
                     "]");
                 System.out.println("safe1:     [" +
-                    new String(Hex.encodeHex(decodedUrlSafe1)) +
+                        Hex.encodeHexString(decodedUrlSafe1) +
                     "] From: [" +
                     StringUtils.newStringUtf8(urlSafe1[i]) +
                     "]");
                 System.out.println("safe2:     [" +
-                    new String(Hex.encodeHex(decodedUrlSafe2)) +
+                        Hex.encodeHexString(decodedUrlSafe2) +
                     "] From: [" +
                     StringUtils.newStringUtf8(urlSafe2[i]) +
                     "]");
                 System.out.println("safe3:     [" +
-                    new String(Hex.encodeHex(decodedUrlSafe3)) +
+                        Hex.encodeHexString(decodedUrlSafe3) +
                     "] From: [" +
                     StringUtils.newStringUtf8(urlSafe3[i]) +
                     "]");
diff --git a/src/test/org/apache/commons/codec/binary/HexTest.java b/src/test/org/apache/commons/codec/binary/HexTest.java
index 2c62a1f2..2f0c3618 100644
--- a/src/test/org/apache/commons/codec/binary/HexTest.java
+++ b/src/test/org/apache/commons/codec/binary/HexTest.java
@@ -17,9 +17,15 @@
 
 package org.apache.commons.codec.binary;
 
+import java.io.UnsupportedEncodingException;
+import java.nio.charset.Charset;
 import java.util.Arrays;
+import java.util.Iterator;
 import java.util.Random;
+import java.util.Set;
+import java.util.SortedMap;
 
+import junit.framework.Assert;
 import junit.framework.TestCase;
 
 import org.apache.commons.codec.DecoderException;
@@ -31,19 +37,112 @@ import org.apache.commons.codec.EncoderException;
  * @author Apache Software Foundation
  * @version $Id$
  */
-
 public class HexTest extends TestCase {
 
+    private final static boolean LOG = false;
+
     public HexTest(String name) {
         super(name);
     }
-    
-    public void testDecodeArrayOddCharacters() {
+
+    /**
+     * @param data
+     */
+    private void checkDecodeHexOddCharacters(char[] data) {
         try {
-            new Hex().decode(new byte[] { 65 });
+            Hex.decodeHex(data);
             fail("An exception wasn't thrown when trying to decode an odd number of characters");
+        } catch (DecoderException e) {
+            // Expected exception
+        }
+    }
+
+    private void log(String s) {
+        if (LOG) {
+            System.out.println(s);
+        }
+    }
+
+    public void testCustomCharset() throws UnsupportedEncodingException, DecoderException {
+        SortedMap map = Charset.availableCharsets();
+        Set keys = map.keySet();
+        Iterator iterator = keys.iterator();
+        log("testCustomCharset: Checking " + keys.size() + " charsets...");
+        while (iterator.hasNext()) {
+            String name = (String) iterator.next();
+            testCustomCharset(name, "testCustomCharset");
         }
-        catch (DecoderException e) {
+    }
+
+    /**
+     * @param name
+     * @param parent
+     *            TODO
+     * @throws UnsupportedEncodingException
+     * @throws DecoderException
+     */
+    private void testCustomCharset(String name, String parent) throws UnsupportedEncodingException, DecoderException {
+        if (charsetSanityCheck(name) == false) {
+            log("Interesting Java charset oddity: Charset sanity check failed for " + name);
+            return;
+        }
+        log(parent + "=" + name);
+        Hex customCodec = new Hex(name);
+        // source data
+        String sourceString = "Hello World";
+        byte[] sourceBytes = sourceString.getBytes(name);
+        // test 1
+        // encode source to hex string to bytes with charset
+        byte[] actualEncodedBytes = customCodec.encode(sourceBytes);
+        // encode source to hex string...
+        String expectedHexString = Hex.encodeHexString(sourceBytes);
+        // ... and get the bytes in the expected charset
+        byte[] expectedHexStringBytes = expectedHexString.getBytes(name);
+        Assert.assertTrue(Arrays.equals(expectedHexStringBytes, actualEncodedBytes));
+        // test 2
+        String actualStringFromBytes = new String(actualEncodedBytes, name);
+        assertEquals(name + ", expectedHexString=" + expectedHexString + ", actualStringFromBytes=" + actualStringFromBytes,
+                expectedHexString, actualStringFromBytes);
+        // second test:
+        Hex utf8Codec = new Hex();
+        expectedHexString = "48656c6c6f20576f726c64";
+        byte[] decodedUtf8Bytes = (byte[]) utf8Codec.decode(expectedHexString);
+        actualStringFromBytes = new String(decodedUtf8Bytes, utf8Codec.getCharsetName());
+        // sanity check:
+        assertEquals(name, sourceString, actualStringFromBytes);
+        // actual check:
+        byte[] decodedCustomBytes = customCodec.decode(actualEncodedBytes);
+        actualStringFromBytes = new String(decodedCustomBytes, name);
+        assertEquals(name, sourceString, actualStringFromBytes);
+    }
+
+    private boolean charsetSanityCheck(String name) {
+        final String source = "the quick brown dog jumped over the lazy fox";
+        try {
+            byte[] bytes = source.getBytes(name);
+            String str = new String(bytes, name);
+            return source.equals(str);
+        } catch (UnsupportedEncodingException e) {
+            // Should NEVER happen since we are getting the name from the Charset class.
+            if (LOG) {
+                e.printStackTrace();
+            }
+            return false;
+        } catch (UnsupportedOperationException e) {
+            // Happens with:
+            // x-JIS0208 on Windows XP and Java Sun 1.6.0_14
+            if (LOG) {
+                e.printStackTrace();
+            }
+            return false;
+        }
+    }
+
+    public void testDecodeArrayOddCharacters() {
+        try {
+            new Hex().decode(new byte[]{65});
+            fail("An exception wasn't thrown when trying to decode an odd number of characters");
+        } catch (DecoderException e) {
             // Expected exception
         }
     }
@@ -52,8 +151,7 @@ public class HexTest extends TestCase {
         try {
             new Hex().decode("q0");
             fail("An exception wasn't thrown when trying to decode an illegal character");
-        }
-        catch (DecoderException e) {
+        } catch (DecoderException e) {
             // Expected exception
         }
     }
@@ -62,38 +160,37 @@ public class HexTest extends TestCase {
         try {
             new Hex().decode("0q");
             fail("An exception wasn't thrown when trying to decode an illegal character");
-        }
-        catch (DecoderException e) {
+        } catch (DecoderException e) {
             // Expected exception
         }
     }
 
     public void testDecodeClassCastException() {
         try {
-            new Hex().decode(new int[] { 65 });
+            new Hex().decode(new int[]{65});
             fail("An exception wasn't thrown when trying to decode.");
-        }
-        catch (DecoderException e) {
+        } catch (DecoderException e) {
             // Expected exception
         }
     }
 
-    public void testDecodeHexOddCharacters() {
-        try {
-            Hex.decodeHex(new char[] { 'A' });
-            fail("An exception wasn't thrown when trying to decode an odd number of characters");
-        }
-        catch (DecoderException e) {
-            // Expected exception
-        }
+    public void testDecodeHexOddCharacters1() {
+        checkDecodeHexOddCharacters(new char[]{'A'});
+    }
+
+    public void testDecodeHexOddCharacters3() {
+        checkDecodeHexOddCharacters(new char[]{'A', 'B', 'C'});
+    }
+
+    public void testDecodeHexOddCharacters5() {
+        checkDecodeHexOddCharacters(new char[]{'A', 'B', 'C', 'D', 'E'});
     }
 
     public void testDecodeStringOddCharacters() {
         try {
             new Hex().decode("6");
             fail("An exception wasn't thrown when trying to decode an odd number of characters");
-        }
-        catch (DecoderException e) {
+        } catch (DecoderException e) {
             // Expected exception
         }
     }
@@ -101,15 +198,14 @@ public class HexTest extends TestCase {
     public void testDencodeEmpty() throws DecoderException {
         assertTrue(Arrays.equals(new byte[0], Hex.decodeHex(new char[0])));
         assertTrue(Arrays.equals(new byte[0], new Hex().decode(new byte[0])));
-        assertTrue(Arrays.equals(new byte[0], (byte[])new Hex().decode("")));
+        assertTrue(Arrays.equals(new byte[0], (byte[]) new Hex().decode("")));
     }
-    
+
     public void testEncodeClassCastException() {
         try {
-            new Hex().encode(new int[] { 65 });
+            new Hex().encode(new int[]{65});
             fail("An exception wasn't thrown when trying to encode.");
-        }
-        catch (EncoderException e) {
+        } catch (EncoderException e) {
             // Expected exception
         }
     }
@@ -126,7 +222,7 @@ public class HexTest extends TestCase {
             char[] encodedChars = Hex.encodeHex(data);
             byte[] decodedBytes = Hex.decodeHex(encodedChars);
             assertTrue(Arrays.equals(data, decodedBytes));
-            
+
             // instance API with array parameter
             byte[] encodedStringBytes = hex.encode(data);
             decodedBytes = hex.decode(encodedStringBytes);
@@ -134,34 +230,31 @@ public class HexTest extends TestCase {
 
             // instance API with char[] (Object) parameter
             String dataString = new String(encodedChars);
-            char[] encodedStringChars = (char[])hex.encode(dataString);
-            decodedBytes = (byte[])hex.decode(encodedStringChars);
-            assertTrue(Arrays.equals(dataString.getBytes(), decodedBytes));
+            char[] encodedStringChars = (char[]) hex.encode(dataString);
+            decodedBytes = (byte[]) hex.decode(encodedStringChars);
+            assertTrue(Arrays.equals(StringUtils.getBytesUtf8(dataString), decodedBytes));
 
             // instance API with String (Object) parameter
             dataString = new String(encodedChars);
-            encodedStringChars = (char[])hex.encode(dataString);
-            decodedBytes = (byte[])hex.decode(new String(encodedStringChars));
-            assertTrue(Arrays.equals(dataString.getBytes(), decodedBytes));
+            encodedStringChars = (char[]) hex.encode(dataString);
+            decodedBytes = (byte[]) hex.decode(new String(encodedStringChars));
+            assertTrue(Arrays.equals(StringUtils.getBytesUtf8(dataString), decodedBytes));
         }
     }
 
     public void testEncodeEmpty() throws EncoderException {
         assertTrue(Arrays.equals(new char[0], Hex.encodeHex(new byte[0])));
         assertTrue(Arrays.equals(new byte[0], new Hex().encode(new byte[0])));
-        assertTrue(Arrays.equals(new char[0], (char[])new Hex().encode("")));
+        assertTrue(Arrays.equals(new char[0], (char[]) new Hex().encode("")));
     }
 
     public void testEncodeZeroes() {
         char[] c = Hex.encodeHex(new byte[36]);
-        assertEquals(
-            "000000000000000000000000000000000000"
-                + "000000000000000000000000000000000000",
-            new String(c));
+        assertEquals("000000000000000000000000000000000000000000000000000000000000000000000000", new String(c));
     }
 
     public void testHelloWorldLowerCaseHex() {
-        byte[] b = "Hello World".getBytes();
+        byte[] b = StringUtils.getBytesUtf8("Hello World");
         final String expected = "48656c6c6f20576f726c64";
         char[] actual;
         actual = Hex.encodeHex(b);
@@ -173,7 +266,7 @@ public class HexTest extends TestCase {
     }
 
     public void testHelloWorldUpperCaseHex() {
-        byte[] b = "Hello World".getBytes();
+        byte[] b = StringUtils.getBytesUtf8("Hello World");
         final String expected = "48656C6C6F20576F726C64";
         char[] actual;
         actual = Hex.encodeHex(b);
@@ -183,4 +276,13 @@ public class HexTest extends TestCase {
         actual = Hex.encodeHex(b, false);
         assertTrue(expected.equals(new String(actual)));
     }
+
+    public void testRequiredCharset() throws UnsupportedEncodingException, DecoderException {
+        testCustomCharset("UTF-8", "testRequiredCharset");
+        testCustomCharset("UTF-16", "testRequiredCharset");
+        testCustomCharset("UTF-16BE", "testRequiredCharset");
+        testCustomCharset("UTF-16LE", "testRequiredCharset");
+        testCustomCharset("US-ASCII", "testRequiredCharset");
+        testCustomCharset("ISO8859_1", "testRequiredCharset");
+    }
 }
diff --git a/src/test/org/apache/commons/codec/binary/StringUtilsTest.java b/src/test/org/apache/commons/codec/binary/StringUtilsTest.java
index 8f616836..4d9399f3 100644
--- a/src/test/org/apache/commons/codec/binary/StringUtilsTest.java
+++ b/src/test/org/apache/commons/codec/binary/StringUtilsTest.java
@@ -53,15 +53,21 @@ public class StringUtilsTest extends TestCase {
 
     public void testGetBytesIso8859_1() throws UnsupportedEncodingException {
         String charsetName = "ISO-8859-1";
-        testGetSupportedBytes(charsetName);
+        testGetBytesUnchecked(charsetName);
         byte[] expected = STRING_FIXTURE.getBytes(charsetName);
         byte[] actual = StringUtils.getBytesIso8859_1(STRING_FIXTURE);
         Assert.assertTrue(Arrays.equals(expected, actual));
     }
 
+    private void testGetBytesUnchecked(String charsetName) throws UnsupportedEncodingException {
+        byte[] expected = STRING_FIXTURE.getBytes(charsetName);
+        byte[] actual = StringUtils.getBytesUnchecked(STRING_FIXTURE, charsetName);
+        Assert.assertTrue(Arrays.equals(expected, actual));
+    }
+
     public void testGetBytesUsAscii() throws UnsupportedEncodingException {
         String charsetName = "US-ASCII";
-        testGetSupportedBytes(charsetName);
+        testGetBytesUnchecked(charsetName);
         byte[] expected = STRING_FIXTURE.getBytes(charsetName);
         byte[] actual = StringUtils.getBytesUsAscii(STRING_FIXTURE);
         Assert.assertTrue(Arrays.equals(expected, actual));
@@ -69,7 +75,7 @@ public class StringUtilsTest extends TestCase {
 
     public void testGetBytesUtf16() throws UnsupportedEncodingException {
         String charsetName = "UTF-16";
-        testGetSupportedBytes(charsetName);
+        testGetBytesUnchecked(charsetName);
         byte[] expected = STRING_FIXTURE.getBytes(charsetName);
         byte[] actual = StringUtils.getBytesUtf16(STRING_FIXTURE);
         Assert.assertTrue(Arrays.equals(expected, actual));
@@ -77,7 +83,7 @@ public class StringUtilsTest extends TestCase {
 
     public void testGetBytesUtf16Be() throws UnsupportedEncodingException {
         String charsetName = "UTF-16BE";
-        testGetSupportedBytes(charsetName);
+        testGetBytesUnchecked(charsetName);
         byte[] expected = STRING_FIXTURE.getBytes(charsetName);
         byte[] actual = StringUtils.getBytesUtf16Be(STRING_FIXTURE);
         Assert.assertTrue(Arrays.equals(expected, actual));
@@ -85,7 +91,7 @@ public class StringUtilsTest extends TestCase {
 
     public void testGetBytesUtf16Le() throws UnsupportedEncodingException {
         String charsetName = "UTF-16LE";
-        testGetSupportedBytes(charsetName);
+        testGetBytesUnchecked(charsetName);
         byte[] expected = STRING_FIXTURE.getBytes(charsetName);
         byte[] actual = StringUtils.getBytesUtf16Le(STRING_FIXTURE);
         Assert.assertTrue(Arrays.equals(expected, actual));
@@ -93,21 +99,15 @@ public class StringUtilsTest extends TestCase {
 
     public void testGetBytesUtf8() throws UnsupportedEncodingException {
         String charsetName = "UTF-8";
-        testGetSupportedBytes(charsetName);
+        testGetBytesUnchecked(charsetName);
         byte[] expected = STRING_FIXTURE.getBytes(charsetName);
         byte[] actual = StringUtils.getBytesUtf8(STRING_FIXTURE);
         Assert.assertTrue(Arrays.equals(expected, actual));
     }
 
-    private void testGetSupportedBytes(String charsetName) throws UnsupportedEncodingException {
-        byte[] expected = STRING_FIXTURE.getBytes(charsetName);
-        byte[] actual = StringUtils.getSupportedBytes(STRING_FIXTURE, charsetName);
-        Assert.assertTrue(Arrays.equals(expected, actual));
-    }
-
-    public void testGetSupportedBytesBadEnc() {
+    public void testGetBytesUncheckedBadName() {
         try {
-            StringUtils.getSupportedBytes(STRING_FIXTURE, "UNKNOWN");
+            StringUtils.getBytesUnchecked(STRING_FIXTURE, "UNKNOWN");
             Assert.fail("Expected " + IllegalStateException.class.getName());
         } catch (IllegalStateException e) {
             // Expected
