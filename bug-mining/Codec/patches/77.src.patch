diff --git a/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java b/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java
index d1eb77bb..6c335ecf 100644
--- a/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java
+++ b/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java
@@ -30,10 +30,10 @@ import java.io.InputStream;
  */
 public class BaseNCodecInputStream extends FilterInputStream {
 
-    private final boolean doEncode;
-
     private final BaseNCodec baseNCodec;
 
+    private final boolean doEncode;
+
     private final byte[] singleByte = new byte[1];
 
     protected BaseNCodecInputStream(InputStream in, BaseNCodec baseNCodec, boolean doEncode) {
@@ -42,6 +42,31 @@ public class BaseNCodecInputStream extends FilterInputStream {
         this.baseNCodec = baseNCodec;
     }
 
+    /**
+     * {@inheritDoc}
+     *
+     * @return <code>0</code> if the {@link InputStream} has reached <code>EOF</code>,
+     * <code>1</code> otherwise
+     */
+    public int available() throws IOException {
+        // Note: the logic is similar to the InflaterInputStream:
+        //       as long as we have not reached EOF, indicate that there is more
+        //       data available. As we do not know for sure how much data is left,
+        //       just return 1 as a safe guess.
+
+        // use the EOF flag of the underlying codec instance
+        return baseNCodec.eof ? 0 : 1;
+    }
+
+    /**
+     * {@inheritDoc}
+     * 
+     * @return false
+     */
+    @Override
+    public boolean markSupported() {
+        return false; // not an easy job to support marks
+    }
     /**
      * Reads one <code>byte</code> from this input stream.
      * 
@@ -124,15 +149,6 @@ public class BaseNCodecInputStream extends FilterInputStream {
             return readLen;
         }
     }
-    /**
-     * {@inheritDoc}
-     * 
-     * @return false
-     */
-    @Override
-    public boolean markSupported() {
-        return false; // not an easy job to support marks
-    }
 
     /**
      * {@inheritDoc}
@@ -142,7 +158,7 @@ public class BaseNCodecInputStream extends FilterInputStream {
     @Override
     public long skip(long n) throws IOException {
         if (n < 0) {
-            throw new IllegalArgumentException("Negative skip length");
+            throw new IllegalArgumentException("Negative skip length: " + n);
         }
 
         // skip in chunks of 512 bytes
@@ -164,24 +180,4 @@ public class BaseNCodecInputStream extends FilterInputStream {
 
         return total;
     }
-
-    /**
-     * {@inheritDoc}
-     *
-     * @return <code>0</code> if the {@link InputStream} has reached <code>EOF</code>,
-     * <code>1</code> otherwise
-     */
-    public int available() throws IOException {
-        // Note: the logic is similar to the InflaterInputStream:
-        //       as long as we have not reached EOF, indicate that there is more
-        //       data available. As we do not know for sure how much data is left,
-        //       just return 1 as a safe guess.
-
-        // use the EOF flag of the underlying codec instance
-        if (baseNCodec.eof) {
-            return 0;
-        } else {
-            return 1;
-        }
-    }
 }
