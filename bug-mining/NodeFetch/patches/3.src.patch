diff --git a/src/headers.js b/src/headers.js
index fd7a14e..ad2e9e4 100644
--- a/src/headers.js
+++ b/src/headers.js
@@ -5,137 +5,211 @@
  * Headers class offers convenient helpers
  */
 
-module.exports = Headers;
-
-/**
- * Headers class
- *
- * @param   Object  headers  Response headers
- * @return  Void
- */
-function Headers(headers) {
+export const MAP = Symbol('map');
+
+export default class Headers {
+	/**
+	 * Headers class
+	 *
+	 * @param   Object  headers  Response headers
+	 * @return  Void
+	 */
+	constructor(headers) {
+		this[MAP] = {};
+
+		// Headers
+		if (headers instanceof Headers) {
+			headers = headers.raw();
+		}
 
-	var self = this;
-	this._headers = {};
+		// plain object
+		for (const prop in headers) {
+			if (!headers.hasOwnProperty(prop)) {
+				continue;
+			}
+
+			if (typeof headers[prop] === 'string') {
+				this.set(prop, headers[prop]);
+			} else if (typeof headers[prop] === 'number' && !isNaN(headers[prop])) {
+				this.set(prop, headers[prop].toString());
+			} else if (headers[prop] instanceof Array) {
+				headers[prop].forEach(item => {
+					this.append(prop, item.toString());
+				});
+			}
+		}
+	}
 
-	// Headers
-	if (headers instanceof Headers) {
-		headers = headers.raw();
+	/**
+	 * Return first header value given name
+	 *
+	 * @param   String  name  Header name
+	 * @return  Mixed
+	 */
+	get(name) {
+		const list = this[MAP][name.toLowerCase()];
+		return list ? list[0] : null;
 	}
 
-	// plain object
-	for (var prop in headers) {
-		if (!headers.hasOwnProperty(prop)) {
-			continue;
+	/**
+	 * Return all header values given name
+	 *
+	 * @param   String  name  Header name
+	 * @return  Array
+	 */
+	getAll(name) {
+		if (!this.has(name)) {
+			return [];
 		}
 
-		if (typeof headers[prop] === 'string') {
-			this.set(prop, headers[prop]);
-
-		} else if (typeof headers[prop] === 'number' && !isNaN(headers[prop])) {
-			this.set(prop, headers[prop].toString());
+		return this[MAP][name.toLowerCase()];
+	}
 
-		} else if (headers[prop] instanceof Array) {
-			headers[prop].forEach(function(item) {
-				self.append(prop, item.toString());
+	/**
+	 * Iterate over all headers
+	 *
+	 * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
+	 * @param   Boolean   thisArg   `this` context for callback function
+	 * @return  Void
+	 */
+	forEach(callback, thisArg) {
+		Object.getOwnPropertyNames(this[MAP]).forEach(name => {
+			this[MAP][name].forEach(value => {
+				callback.call(thisArg, value, name, this);
 			});
+		});
+	}
+
+	/**
+	 * Overwrite header values given name
+	 *
+	 * @param   String  name   Header name
+	 * @param   String  value  Header value
+	 * @return  Void
+	 */
+	set(name, value) {
+		this[MAP][name.toLowerCase()] = [value];
+	}
+
+	/**
+	 * Append a value onto existing header
+	 *
+	 * @param   String  name   Header name
+	 * @param   String  value  Header value
+	 * @return  Void
+	 */
+	append(name, value) {
+		if (!this.has(name)) {
+			this.set(name, value);
+			return;
 		}
+
+		this[MAP][name.toLowerCase()].push(value);
 	}
 
-}
+	/**
+	 * Check for header name existence
+	 *
+	 * @param   String   name  Header name
+	 * @return  Boolean
+	 */
+	has(name) {
+		return this[MAP].hasOwnProperty(name.toLowerCase());
+	}
 
-/**
- * Return first header value given name
- *
- * @param   String  name  Header name
- * @return  Mixed
- */
-Headers.prototype.get = function(name) {
-	var list = this._headers[name.toLowerCase()];
-	return list ? list[0] : null;
-};
+	/**
+	 * Delete all header values given name
+	 *
+	 * @param   String  name  Header name
+	 * @return  Void
+	 */
+	delete(name) {
+		delete this[MAP][name.toLowerCase()];
+	};
+
+	/**
+	 * Return raw headers (non-spec api)
+	 *
+	 * @return  Object
+	 */
+	raw() {
+		return this[MAP];
+	}
 
-/**
- * Return all header values given name
- *
- * @param   String  name  Header name
- * @return  Array
- */
-Headers.prototype.getAll = function(name) {
-	if (!this.has(name)) {
-		return [];
+	/**
+	 * Get an iterator on keys.
+	 *
+	 * @return  Iterator
+	 */
+	keys() {
+		const keys = [];
+		this.forEach((_, name) => keys.push(name));
+		return new Iterator(keys);
 	}
 
-	return this._headers[name.toLowerCase()];
-};
+	/**
+	 * Get an iterator on values.
+	 *
+	 * @return  Iterator
+	 */
+	values() {
+		const values = [];
+		this.forEach(value => values.push(value));
+		return new Iterator(values);
+	}
 
-/**
- * Iterate over all headers
- *
- * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
- * @param   Boolean   thisArg   `this` context for callback function
- * @return  Void
- */
-Headers.prototype.forEach = function(callback, thisArg) {
-	Object.getOwnPropertyNames(this._headers).forEach(function(name) {
-		this._headers[name].forEach(function(value) {
-			callback.call(thisArg, value, name, this)
-		}, this)
-	}, this)
-}
+	/**
+	 * Get an iterator on entries.
+	 *
+	 * @return  Iterator
+	 */
+	entries() {
+		const entries = [];
+		this.forEach((value, name) => entries.push([name, value]));
+		return new Iterator(entries);
+	}
 
-/**
- * Overwrite header values given name
- *
- * @param   String  name   Header name
- * @param   String  value  Header value
- * @return  Void
- */
-Headers.prototype.set = function(name, value) {
-	this._headers[name.toLowerCase()] = [value];
-};
+	/**
+	 * Get an iterator on entries.
+	 *
+	 * This is the default iterator of the Headers object.
+	 *
+	 * @return  Iterator
+	 */
+	[Symbol.iterator]() {
+		return this.entries();
+	}
 
-/**
- * Append a value onto existing header
- *
- * @param   String  name   Header name
- * @param   String  value  Header value
- * @return  Void
- */
-Headers.prototype.append = function(name, value) {
-	if (!this.has(name)) {
-		this.set(name, value);
-		return;
+	/**
+	 * Tag used by `Object.prototype.toString()`.
+	 */
+	get [Symbol.toStringTag]() {
+		return 'Headers';
 	}
+}
 
-	this._headers[name.toLowerCase()].push(value);
-};
+const ITEMS = Symbol('items');
+class Iterator {
+	constructor(items) {
+		this[ITEMS] = items;
+	}
 
-/**
- * Check for header name existence
- *
- * @param   String   name  Header name
- * @return  Boolean
- */
-Headers.prototype.has = function(name) {
-	return this._headers.hasOwnProperty(name.toLowerCase());
-};
+	next() {
+		if (!this[ITEMS].length) {
+			return {
+				value: undefined,
+				done: true
+			};
+		}
 
-/**
- * Delete all header values given name
- *
- * @param   String  name  Header name
- * @return  Void
- */
-Headers.prototype['delete'] = function(name) {
-	delete this._headers[name.toLowerCase()];
-};
+		return {
+			value: this[ITEMS].shift(),
+			done: false
+		};
 
-/**
- * Return raw headers (non-spec api)
- *
- * @return  Object
- */
-Headers.prototype.raw = function() {
-	return this._headers;
-};
+	}
+
+	[Symbol.iterator]() {
+		return this;
+	}
+}
diff --git a/src/index.js b/src/index.js
index 676b57a..d30c2d8 100644
--- a/src/index.js
+++ b/src/index.js
@@ -14,7 +14,7 @@ var stream = require('stream');
 
 var Body = require('./body');
 var Response = require('./response');
-var Headers = require('./headers');
+import Headers from './headers';
 var Request = require('./request');
 var FetchError = require('./fetch-error');
 
diff --git a/src/request.js b/src/request.js
index 1a29c29..ec80635 100644
--- a/src/request.js
+++ b/src/request.js
@@ -6,7 +6,7 @@
  */
 
 var parse_url = require('url').parse;
-var Headers = require('./headers');
+import Headers from './headers';
 var Body = require('./body');
 
 module.exports = Request;
diff --git a/src/response.js b/src/response.js
index f96aa85..b079bd0 100644
--- a/src/response.js
+++ b/src/response.js
@@ -6,7 +6,7 @@
  */
 
 var http = require('http');
-var Headers = require('./headers');
+import Headers from './headers';
 var Body = require('./body');
 
 module.exports = Response;
diff --git a/test/test.js b/test/test.js
index a7ce43e..b593407 100644
--- a/test/test.js
+++ b/test/test.js
@@ -17,7 +17,7 @@ var TestServer = require('./server');
 
 // test subjects
 var fetch = require('../src/index.js');
-var Headers = require('../src/headers.js');
+import Headers from '../src/headers.js';
 var Response = require('../src/response.js');
 var Request = require('../src/request.js');
 var Body = require('../src/body.js');
@@ -1131,6 +1131,65 @@ describe('node-fetch', function() {
 		expect(result).to.deep.equal(expected);
 	});
 
+	it('should allow iterating through all headers', function() {
+		var headers = new Headers({
+			a: 1
+			, b: [2, 3]
+			, c: [4]
+		});
+		expect(headers).to.have.property(Symbol.iterator);
+		expect(headers).to.have.property('keys');
+		expect(headers).to.have.property('values');
+		expect(headers).to.have.property('entries');
+
+		var result, expected;
+
+		result = [];
+		for (let [key, val] of headers) {
+			result.push([key, val]);
+		}
+
+		expected = [
+			["a", "1"]
+			, ["b", "2"]
+			, ["b", "3"]
+			, ["c", "4"]
+		];
+		expect(result).to.deep.equal(expected);
+
+		result = [];
+		for (let [key, val] of headers.entries()) {
+			result.push([key, val]);
+		}
+		expect(result).to.deep.equal(expected);
+
+		result = [];
+		for (let key of headers.keys()) {
+			result.push(key);
+		}
+
+		expected = [
+			"a"
+			, "b"
+			, "b"
+			, "c"
+		];
+		expect(result).to.deep.equal(expected);
+
+		result = [];
+		for (let key of headers.values()) {
+			result.push(key);
+		}
+
+		expected = [
+			"1"
+			, "2"
+			, "3"
+			, "4"
+		];
+		expect(result).to.deep.equal(expected);
+	});
+
 	it('should allow deleting header', function() {
 		url = base + '/cookie';
 		return fetch(url).then(function(res) {
@@ -1178,49 +1237,53 @@ describe('node-fetch', function() {
 		res.m = new Buffer('test');
 
 		var h1 = new Headers(res);
+		var h1Raw = h1.raw();
 
-		expect(h1._headers['a']).to.include('string');
-		expect(h1._headers['b']).to.include('1');
-		expect(h1._headers['b']).to.include('2');
-		expect(h1._headers['c']).to.include('');
-		expect(h1._headers['d']).to.be.undefined;
+		expect(h1Raw['a']).to.include('string');
+		expect(h1Raw['b']).to.include('1');
+		expect(h1Raw['b']).to.include('2');
+		expect(h1Raw['c']).to.include('');
+		expect(h1Raw['d']).to.be.undefined;
 
-		expect(h1._headers['e']).to.include('1');
-		expect(h1._headers['f']).to.include('1');
-		expect(h1._headers['f']).to.include('2');
+		expect(h1Raw['e']).to.include('1');
+		expect(h1Raw['f']).to.include('1');
+		expect(h1Raw['f']).to.include('2');
 
-		expect(h1._headers['g']).to.be.undefined;
-		expect(h1._headers['h']).to.be.undefined;
-		expect(h1._headers['i']).to.be.undefined;
-		expect(h1._headers['j']).to.be.undefined;
-		expect(h1._headers['k']).to.be.undefined;
-		expect(h1._headers['l']).to.be.undefined;
-		expect(h1._headers['m']).to.be.undefined;
+		expect(h1Raw['g']).to.be.undefined;
+		expect(h1Raw['h']).to.be.undefined;
+		expect(h1Raw['i']).to.be.undefined;
+		expect(h1Raw['j']).to.be.undefined;
+		expect(h1Raw['k']).to.be.undefined;
+		expect(h1Raw['l']).to.be.undefined;
+		expect(h1Raw['m']).to.be.undefined;
 
-		expect(h1._headers['z']).to.be.undefined;
+		expect(h1Raw['z']).to.be.undefined;
 	});
 
 	it('should wrap headers', function() {
 		var h1 = new Headers({
 			a: '1'
 		});
+		var h1Raw = h1.raw();
 
 		var h2 = new Headers(h1);
 		h2.set('b', '1');
+		var h2Raw = h2.raw();
 
 		var h3 = new Headers(h2);
 		h3.append('a', '2');
+		var h3Raw = h3.raw();
 
-		expect(h1._headers['a']).to.include('1');
-		expect(h1._headers['a']).to.not.include('2');
+		expect(h1Raw['a']).to.include('1');
+		expect(h1Raw['a']).to.not.include('2');
 
-		expect(h2._headers['a']).to.include('1');
-		expect(h2._headers['a']).to.not.include('2');
-		expect(h2._headers['b']).to.include('1');
+		expect(h2Raw['a']).to.include('1');
+		expect(h2Raw['a']).to.not.include('2');
+		expect(h2Raw['b']).to.include('1');
 
-		expect(h3._headers['a']).to.include('1');
-		expect(h3._headers['a']).to.include('2');
-		expect(h3._headers['b']).to.include('1');
+		expect(h3Raw['a']).to.include('1');
+		expect(h3Raw['a']).to.include('2');
+		expect(h3Raw['b']).to.include('1');
 	});
 
 	it('should support fetch with Request instance', function() {
