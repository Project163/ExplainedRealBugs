{"url":"https://api.github.com/repos/node-fetch/node-fetch/issues/1735","repository_url":"https://api.github.com/repos/node-fetch/node-fetch","labels_url":"https://api.github.com/repos/node-fetch/node-fetch/issues/1735/labels{/name}","comments_url":"https://api.github.com/repos/node-fetch/node-fetch/issues/1735/comments","events_url":"https://api.github.com/repos/node-fetch/node-fetch/issues/1735/events","html_url":"https://github.com/node-fetch/node-fetch/issues/1735","id":1675398469,"node_id":"I_kwDOAcd5ZM5j3I1F","number":1735,"title":"\"socket hang up\" / ECONNRESET on consecutive requests with Node.js 19 and Node.js 20","user":{"login":"dhedey","id":8008816,"node_id":"MDQ6VXNlcjgwMDg4MTY=","avatar_url":"https://avatars.githubusercontent.com/u/8008816?v=4","gravatar_id":"","url":"https://api.github.com/users/dhedey","html_url":"https://github.com/dhedey","followers_url":"https://api.github.com/users/dhedey/followers","following_url":"https://api.github.com/users/dhedey/following{/other_user}","gists_url":"https://api.github.com/users/dhedey/gists{/gist_id}","starred_url":"https://api.github.com/users/dhedey/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dhedey/subscriptions","organizations_url":"https://api.github.com/users/dhedey/orgs","repos_url":"https://api.github.com/users/dhedey/repos","events_url":"https://api.github.com/users/dhedey/events{/privacy}","received_events_url":"https://api.github.com/users/dhedey/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[{"id":170428667,"node_id":"MDU6TGFiZWwxNzA0Mjg2Njc=","url":"https://api.github.com/repos/node-fetch/node-fetch/labels/bug","name":"bug","color":"fc2929","default":true,"description":null},{"id":3750093845,"node_id":"LA_kwDOAcd5ZM7fheQV","url":"https://api.github.com/repos/node-fetch/node-fetch/labels/released","name":"released","color":"ededed","default":false,"description":null},{"id":5001310607,"node_id":"LA_kwDOAcd5ZM8AAAABKhnxjw","url":"https://api.github.com/repos/node-fetch/node-fetch/labels/released%20on%20@2.x","name":"released on @2.x","color":"ededed","default":false,"description":null}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":15,"created_at":"2023-04-19T18:21:23Z","updated_at":"2025-01-24T16:01:59Z","closed_at":"2023-07-25T11:49:46Z","author_association":"CONTRIBUTOR","type":null,"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"# Overview\r\n\r\nWhen using `node-fetch` on Node.js 19+ to make two consecutive requests to the same web server, we always get the error: `FetchError: request to <URL> failed, reason: socket hang up`\r\n\r\n> TLDR: This issue is caused by https://github.com/nodejs/node/issues/47130 in nodejs, exacerbated by an issue with `node-fetch` blindly sending `Connection: Close` headers. This was fixed via #1736 in `node-fetch` v3.3.2 (note: 3.x is only ESM-enabled). This will hopefully be fixed in `node-fetch` v2 once #1765 is merged and released.\r\n\r\n## Details\r\n\r\nThis error only arises with `node-fetch` and Node.js 19+ (tested using 19.9.0 and 20.0.0), and the web server we were using was Axum. We didn't see this issue when using a node-based proxy to help with debugging - I imagine it depends slightly on the order of TCP packet delivery and latency and the internal state machines of the HTTP servers - but it seems like many HTTP servers would see this issue.\r\n\r\nThe error appears to only occur where the **second request to the same server in the same round of the event loop as the first request was awaited**, which gives the error:\r\n\r\n```\r\nFetchError: request to <URL> failed, reason: socket hang up\r\n```\r\n\r\n# Explanation \r\n## Root cause\r\n\r\nWe believe the following explains what we're seeing, and is backed up by logs at the end of this post:\r\n\r\n* `fetch` sends a `connection: close` header in its first HTTP request...\r\n  * The server responds with a http response, which `fetch` hands back to the caller.\r\n  * The server actions the close connection request by following up the http response with a TCP packet with the `FIN` flag. This marks the end of the connection from the server's point of view. At this point, it does not expect to receive any further requests.\r\n  \r\n* Still in the same event loop, the caller calls fetch again to make its second HTTP request to the same origin.\r\n  * Node.js attempts to send the next request to the host using _the same connection_\r\n  * But the TCP connection is closed at the server's end, so returns a `conn reset` at the TCP layer\r\n  * Resulting in the `socket hang up`\r\n\r\nAnd I believe this may be the cause:\r\n\r\n* The first response from the server is handed back to the caller likely in the [poll phase of the event loop round](https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick#phases-overview)).\r\n* In the mean time, the server has responded to close the TCP connection - but the event loop doesn't get round to handling it (not least because it's not yet in the `close callbacks` phase)\r\n* The caller then attempts to send a new request. But as far as the event loop is concerned, we're still at the `poll` stage, and haven't yet handled the socket close event...\r\n* So I would guess that Node.js internally has yet to close the connection (because it's waiting for the `close callbacks` stage?), so attempts to send the HTTP request on the same (as yet unclosed) connection.\r\n* The server receives this request but has already closed the connection - so responds with connection reset message... which results in `fetch` raising the `socket hang` error.\r\n\r\nBasically it's a race condition between the server closing the connection and the client sending the second request... but it happens reproducibly 100% of the time, and is caused by buggy behaviour, possibly in the Node.js agent?\r\n\r\nI would imagine that Node.js 19 changed some internal handling of socket closes which delayed the handling of the close when a connection close http request is sent, and introduced - but I'm not sure if it's Node.js or `node-fetch` at fault.\r\n\r\n# Actions\r\n## Workarounds\r\n\r\nThe following both appeared to work - but for what it's worth, I don't think either of these is a \"fix\" because it's no longer an easy isomorphic drop in for the browser fetch.\r\n\r\n* It appears that inserting the line `await new Promise((resolve) => setTimeout(resolve, 0))` before every API call to try to ensure any connections are closed fixes the problem.\r\n* Using a [custom http / https agent](https://github.com/node-fetch/node-fetch#custom-agent) with `keepalive`, eg:\r\n```ts\r\nimport http from 'node:http';\r\nimport https from 'node:https';\r\n\r\nconst httpAgent = new http.Agent({ keepAlive: true });\r\nconst httpsAgent = new https.Agent({ keepAlive: true });\r\nconst agentSelector = function(_parsedURL: any) {\r\n    if (_parsedURL.protocol == 'http:') {\r\n        return httpAgent;\r\n    } else {\r\n        return httpsAgent;\r\n    }\r\n}\r\n\r\n// ...\r\n\r\nconst response = await fetch(url, { agent: agentSelector });\r\n```\r\n\r\n## Suggestions for fixes\r\n\r\n> TLDR: [These lines are incorrect in node-fetch](https://github.com/node-fetch/node-fetch/blob/bcfb71c7d10da252280d13818daab6925e12c368/src/request.js#L291)\r\n\r\nThere is arguablably issues in both `node-fetch` and Node.js itself.\r\n\r\nHowever this is done, there are race conditions where a server can close a connection at the same time as you try to send another message on the connection - and this needs to be handled - I guess normally this is where applications implement retry logic (although it's an argument that libraries should have this - although maybe not `node-fetch`!)\r\n\r\nBUT there is a perfect storm that makes this race condition happen every time (100% reproducible for me and my colleagues):\r\n* It looks like Node.js 19 [changed the default agent to have keepalive true](https://github.com/nodejs/node/commit/4267b92604ad78584244488e7f7508a690cb80d0) - previously the default didn't use keep alive.\r\n* But `node-fetch` is [adding a header to close connections if no agent is specified](https://github.com/node-fetch/node-fetch/blob/bcfb71c7d10da252280d13818daab6925e12c368/src/request.js#L292).\r\n\r\nPreviously, sending the `Connection: close` header explicitly didn't do anything wrong (even if it wasn't strictly needed). BUT sending a connection close down a keepalive connection isn't very nice behaviour - and trips up node's handling of the connection.\r\n\r\nThe following are three key fixes that could be made - all of which would fix the issue to various degrees:\r\n* `node-fetch` should not default to sending a `Connection: Close` header if the default agent is set up to use keepalive... Maybe it shouldn't send the connection close header at all and should let Node.js handle it? (raised in #1736 )\r\n* `Node.js` could fix itself so that if it receives a `FIN` it immediately doesn't attempt to send more requests on the same connection. (mentioned in this comment: https://github.com/nodejs/node/issues/47130 as point 1)\r\n* `Node.js` could better pre-emptively handle the scenario where a caller sends a `Connection: close` header (mentioned in this comment: https://github.com/nodejs/node/issues/47130 as point 2)\r\n\r\n### Related to point the node-fetch point:\r\n\r\nThe [node docs on http](https://nodejs.org/api/http.html) say this about the `keepalive` option on the agent:\r\n\r\n> `keepAlive` [boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) - Keep sockets around even when there are no outstanding requests, so they can be used for future requests without having to reestablish a TCP connection. Not to be confused with the `keep-alive` value of the `Connection` header. The `Connection: keep-alive` header is always sent when using an agent except when the Connection header is explicitly specified or when the `keepAlive` and `maxSockets` options are respectively set to `false` and `Infinity`, in which case `Connection: close` will be used. Default: `false`.\r\n\r\nThis suggests to me that Node.js has decent default handling, and we should be letting Node.js handle this and not take matters into our own hands by sending a confusing `Connection: close` header. By sending the header, we could be interfering with Node.js's ability to keep the socket alive if (for example) the `maxSockets` are reached.\r\n\r\nAlso - the fact we only set `Connection: close` on the request when a user doesn't provide an agent feels a little weird - either it's worth doing when the agent is set to keepalive or not - regardless of whether we use the default agent or not.\r\n\r\n-Finally - perhaps `node-fetch` could consider consider respecting the `keepalive` option of `fetch` itself and create the correct agent - with a cache - to prevent it from using the `default` agent - or not even use the `default` agent at all.-\r\nEDIT: Sorry - I'm wrong. The `keepalive` option on fetch is an entirely separate concept, to do with keeping the connection alive after the page ends in the browser (eg a `navigator.sendBeacon` replacement) and not related to http keepalive - which makes sense - fetch is more high-level than that.\r\n\r\n# Logs\r\n\r\n## TCP Dump\r\nFrom running `tcpdump -A -ni lo tcp port 3333` to monitor the TCP messages between the server and the `node-fetch` client.\r\n\r\nThe key parts are ([see reference](https://gist.github.com/tuxfight3r/9ac030cb0d707bb446c7)):\r\n* A 47630->3333 http connection:close request\r\n* Server responds with the http response, followed by a Flags [F.] `FIN` packet (seq\r\n* Another request attempt on the same connection (same port and seq number continues)\r\n* Server response with the reset flag (Flags [R]) `RST` - reset connection packet.\r\n\r\n```\r\n19:28:09.351131 IP 127.0.0.1.47630 > 127.0.0.1.3333: Flags [P.], seq 1:225, ack 1, win 512, options [nop,nop,TS val 109329269 ecr 109329241], length 224\r\n\r\nPOST <PATH1> HTTP/1.1\r\nConnection: close\r\nHost: 127.0.0.1:3333\r\n\r\n19:28:09.351166 IP 127.0.0.1.3333 > 127.0.0.1.47630: Flags [.], ack 225, win 510, options [nop,nop,TS val 109329269 ecr 109329269], length 0\r\n19:28:09.352154 IP 127.0.0.1.3333 > 127.0.0.1.47630: Flags [P.], seq 1:2730, ack 225, win 512, options [nop,nop,TS val 109329270 ecr 109329269], length 2729\r\nHTTP/1.1 200 OK\r\ncontent-type: application/json\r\ncontent-length: 2619\r\ndate: Wed, 19 Apr 2023 17:28:09 GMT\r\n\r\n<<response-payload>>\r\n19:28:09.352163 IP 127.0.0.1.47630 > 127.0.0.1.3333: Flags [.], ack 2730, win 497, options [nop,nop,TS val 109329270 ecr 109329270], length 0\r\n19:28:09.352175 IP 127.0.0.1.3333 > 127.0.0.1.47630: Flags [F.], seq 2730, ack 225, win 512, options [nop,nop,TS val 109329270 ecr 109329270], length 0\r\n\r\n// Second request\r\n\r\n19:28:09.365378 IP 127.0.0.1.47630 > 127.0.0.1.3333: Flags [P.], seq 225:506, ack 2731, win 512, options [nop,nop,TS val 109329283 ecr 109329270], length 281\r\nPOST <PATH2> HTTP/1.1\r\nContent-Type: application/json\r\nAccept: */*\r\nContent-Length: 24\r\nUser-Agent: node-fetch/1.0 (+https://github.com/bitinn/node-fetch)\r\nAccept-Encoding: gzip,deflate\r\nConnection: close\r\nHost: 127.0.0.1:3333\r\n\r\n<REQUEST_BODY_2>\r\n19:28:09.365401 IP 127.0.0.1.3333 > 127.0.0.1.47630: Flags [R], seq 594996662, win 0, length 0\r\n```\r\n\r\n## `NODE_DEBUG=net` logs\r\n\r\nFrom running `NODE_DEBUG=net yarn test`\r\n\r\n```\r\n/// FIRST REQUEST\r\n\r\nNET 54331: createConnection [\r\n  [Object: null prototype] {\r\n    protocol: 'http:',\r\n    slashes: true,\r\n    auth: null,\r\n    host: '127.0.0.1',\r\n    port: '3333',\r\n    hostname: '127.0.0.1',\r\n    hash: null,\r\n    search: null,\r\n    query: null,\r\n    pathname: '<PATH>',\r\n    path: null,\r\n    href: 'http://127.0.0.1:3333/<URL>',\r\n    method: 'POST',\r\n    headers: [Object: null prototype] {\r\n      Accept: [Array],\r\n      'Content-Length': [Array],\r\n      'User-Agent': [Array],\r\n      'Accept-Encoding': [Array],\r\n      Connection: [Array]\r\n    },\r\n    agent: undefined,\r\n    keepAlive: true,\r\n    scheduling: 'lifo',\r\n    timeout: 5000,\r\n    noDelay: true,\r\n    servername: '',\r\n    _agentKey: '127.0.0.1:3333:',\r\n    encoding: null,\r\n    keepAliveInitialDelay: 1000\r\n  },\r\n  [Function (anonymous)],\r\n  [Symbol(normalizedArgs)]: true\r\n]\r\nNET 54331: pipe false null\r\nNET 54331: connect: attempting to connect to 127.0.0.1:3333 (addressType: 4)\r\nNET 54331: _read - n 16384 isConnecting? true hasHandle? true\r\nNET 54331: _read wait for connection\r\nNET 54331: afterConnect\r\nNET 54331: _read - n 16384 isConnecting? false hasHandle? true\r\nNET 54331: Socket._handle.readStart\r\nNET 54331: _read - n 16384 isConnecting? false hasHandle? true\r\n\r\n/// SECOND REQUEST\r\n\r\nNET 54331: destroy\r\nNET 54331: close\r\nNET 54331: close handle\r\n```","closed_by":{"login":"jimmywarting","id":1148376,"node_id":"MDQ6VXNlcjExNDgzNzY=","avatar_url":"https://avatars.githubusercontent.com/u/1148376?v=4","gravatar_id":"","url":"https://api.github.com/users/jimmywarting","html_url":"https://github.com/jimmywarting","followers_url":"https://api.github.com/users/jimmywarting/followers","following_url":"https://api.github.com/users/jimmywarting/following{/other_user}","gists_url":"https://api.github.com/users/jimmywarting/gists{/gist_id}","starred_url":"https://api.github.com/users/jimmywarting/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jimmywarting/subscriptions","organizations_url":"https://api.github.com/users/jimmywarting/orgs","repos_url":"https://api.github.com/users/jimmywarting/repos","events_url":"https://api.github.com/users/jimmywarting/events{/privacy}","received_events_url":"https://api.github.com/users/jimmywarting/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/node-fetch/node-fetch/issues/1735/reactions","total_count":60,"+1":30,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":25,"rocket":5,"eyes":0},"timeline_url":"https://api.github.com/repos/node-fetch/node-fetch/issues/1735/timeline","performed_via_github_app":null,"state_reason":"completed"}