diff --git a/CHANGES.txt b/CHANGES.txt
index 3f0463731e..b2f894eb22 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 2.1.4
+ * Enforce SSTableReader.first/last (CASSANDRA-8744)
  * Cleanup SegmentedFile API (CASSANDRA-8749)
  * Avoid overlap with early compaction replacement (CASSANDRA-8683)
  * Safer Resource Management++ (CASSANDRA-8707)
diff --git a/src/java/org/apache/cassandra/io/sstable/SSTableReader.java b/src/java/org/apache/cassandra/io/sstable/SSTableReader.java
index f59e632c4a..5abd1b7f2a 100644
--- a/src/java/org/apache/cassandra/io/sstable/SSTableReader.java
+++ b/src/java/org/apache/cassandra/io/sstable/SSTableReader.java
@@ -1062,17 +1062,20 @@ public class SSTableReader extends SSTable implements RefCounted<SSTableReader>
 
     /**
      * Gets the position in the index file to start scanning to find the given key (at most indexInterval keys away,
-     * modulo downsampling of the index summary).
+     * modulo downsampling of the index summary). Always returns a value >= 0
      */
     public long getIndexScanPosition(RowPosition key)
     {
+        if (openReason == OpenReason.MOVED_START && key.compareTo(first) < 0)
+            key = first;
+
         return getIndexScanPositionFromBinarySearchResult(indexSummary.binarySearch(key), indexSummary);
     }
 
     private static long getIndexScanPositionFromBinarySearchResult(int binarySearchResult, IndexSummary referencedIndexSummary)
     {
         if (binarySearchResult == -1)
-            return -1;
+            return 0;
         else
             return referencedIndexSummary.getPosition(getIndexSummaryIndexFromBinarySearchResult(binarySearchResult));
     }
@@ -1314,7 +1317,7 @@ public class SSTableReader extends SSTable implements RefCounted<SSTableReader>
                          ? (openReason == OpenReason.EARLY
                             // if opened early, we overlap with the old sstables by one key, so we know that the last
                             // (and further) key(s) will be streamed from these if necessary
-                            ? getPosition(last.getToken().maxKeyBound(), Operator.GT).position
+                            ? getPosition(last, Operator.GT, false, true).position
                             : uncompressedLength())
                          : getPosition(rightBound, Operator.GT).position;
 
@@ -1394,6 +1397,10 @@ public class SSTableReader extends SSTable implements RefCounted<SSTableReader>
      * @return The index entry corresponding to the key, or null if the key is not present
      */
     public RowIndexEntry getPosition(RowPosition key, Operator op, boolean updateCacheAndStats)
+    {
+        return getPosition(key, op, updateCacheAndStats, false);
+    }
+    private RowIndexEntry getPosition(RowPosition key, Operator op, boolean updateCacheAndStats, boolean permitMatchPastLast)
     {
         // first, check bloom filter
         if (op == Operator.EQ)
@@ -1420,25 +1427,36 @@ public class SSTableReader extends SSTable implements RefCounted<SSTableReader>
         }
 
         // check the smallest and greatest keys in the sstable to see if it can't be present
-        if (first.compareTo(key) > 0 || last.compareTo(key) < 0)
+        boolean skip = false;
+        if (key.compareTo(first) < 0)
+        {
+            if (op == Operator.EQ)
+                skip = true;
+            else
+                key = first;
+
+            op = Operator.EQ;
+        }
+        else
+        {
+            int l = last.compareTo(key);
+            // l <= 0  => we may be looking past the end of the file; we then narrow our behaviour to:
+            //             1) skipping if strictly greater for GE and EQ;
+            //             2) skipping if equal and searching GT, and we aren't permitting matching past last
+            skip = l <= 0 && (l < 0 || (!permitMatchPastLast && op == Operator.GT));
+        }
+        if (skip)
         {
             if (op == Operator.EQ && updateCacheAndStats)
                 bloomFilterTracker.addFalsePositive();
-
-            if (op.apply(1) < 0)
-            {
-                Tracing.trace("Check against min and max keys allows skipping sstable {}", descriptor.generation);
-                return null;
-            }
+            Tracing.trace("Check against min and max keys allows skipping sstable {}", descriptor.generation);
+            return null;
         }
 
         int binarySearchResult = indexSummary.binarySearch(key);
         long sampledPosition = getIndexScanPositionFromBinarySearchResult(binarySearchResult, indexSummary);
         int sampledIndex = getIndexSummaryIndexFromBinarySearchResult(binarySearchResult);
 
-        // if we matched the -1th position, we'll start at the first position
-        sampledPosition = sampledPosition == -1 ? 0 : sampledPosition;
-
         int effectiveInterval = indexSummary.getEffectiveIndexIntervalAfterIndex(sampledIndex);
 
         // scan the on-disk index, starting at the nearest sampled position.
@@ -1535,9 +1553,10 @@ public class SSTableReader extends SSTable implements RefCounted<SSTableReader>
      */
     public DecoratedKey firstKeyBeyond(RowPosition token)
     {
+        if (token.compareTo(first) < 0)
+            return first;
+
         long sampledPosition = getIndexScanPosition(token);
-        if (sampledPosition == -1)
-            sampledPosition = 0;
 
         Iterator<FileDataInput> segments = ifile.iterator(sampledPosition);
         while (segments.hasNext())
diff --git a/src/java/org/apache/cassandra/io/sstable/SSTableScanner.java b/src/java/org/apache/cassandra/io/sstable/SSTableScanner.java
index 676f87d988..c05103bddb 100644
--- a/src/java/org/apache/cassandra/io/sstable/SSTableScanner.java
+++ b/src/java/org/apache/cassandra/io/sstable/SSTableScanner.java
@@ -21,6 +21,7 @@ import java.io.IOException;
 import java.util.*;
 
 import com.google.common.collect.AbstractIterator;
+import com.google.common.collect.Ordering;
 import com.google.common.util.concurrent.RateLimiter;
 
 import org.apache.cassandra.db.DataRange;
@@ -81,16 +82,30 @@ public class SSTableScanner implements ISSTableScanner
         this.dataRange = dataRange;
 
         List<AbstractBounds<RowPosition>> boundsList = new ArrayList<>(2);
-        if (dataRange.isWrapAround() && !dataRange.stopKey().isMinimum(sstable.partitioner))
+        if (dataRange.isWrapAround())
         {
-            // split the wrapping range into two parts: 1) the part that starts at the beginning of the sstable, and
-            // 2) the part that comes before the wrap-around
-            boundsList.add(new Bounds<>(sstable.partitioner.getMinimumToken().minKeyBound(), dataRange.stopKey(), sstable.partitioner));
-            boundsList.add(new Bounds<>(dataRange.startKey(), sstable.partitioner.getMinimumToken().maxKeyBound(), sstable.partitioner));
+            if (dataRange.stopKey().isMinimum(sstable.partitioner)
+                || dataRange.stopKey().compareTo(sstable.last) >= 0
+                || dataRange.startKey().compareTo(sstable.first) <= 0)
+            {
+                boundsList.add(new Bounds<RowPosition>(sstable.first, sstable.last, sstable.partitioner));
+            }
+            else
+            {
+                if (dataRange.startKey().compareTo(sstable.last) <= 0)
+                    boundsList.add(new Bounds<>(dataRange.startKey(), sstable.last, sstable.partitioner));
+                if (dataRange.stopKey().compareTo(sstable.first) >= 0)
+                    boundsList.add(new Bounds<>(sstable.first, dataRange.stopKey(), sstable.partitioner));
+            }
         }
         else
         {
-            boundsList.add(new Bounds<>(dataRange.startKey(), dataRange.stopKey(), sstable.partitioner));
+            assert dataRange.startKey().compareTo(dataRange.stopKey()) <= 0 || dataRange.stopKey().isMinimum();
+            RowPosition left = Ordering.natural().max(dataRange.startKey(), sstable.first);
+            // apparently isWrapAround() doesn't count Bounds that extend to the limit (min) as wrapping
+            RowPosition right = dataRange.stopKey().isMinimum() ? sstable.last : Ordering.natural().min(dataRange.stopKey(), sstable.last);
+            if (left.compareTo(right) <= 0)
+                boundsList.add(new Bounds<>(left, right, sstable.partitioner));
         }
         this.rangeIterator = boundsList.iterator();
     }
@@ -112,29 +127,28 @@ public class SSTableScanner implements ISSTableScanner
         List<Range<Token>> normalized = Range.normalize(tokenRanges);
         List<AbstractBounds<RowPosition>> boundsList = new ArrayList<>(normalized.size());
         for (Range<Token> range : normalized)
-            boundsList.add(new Range<RowPosition>(range.left.maxKeyBound(sstable.partitioner),
-                                                  range.right.maxKeyBound(sstable.partitioner),
-                                                  sstable.partitioner));
+        {
+            // cap our ranges by the start/end of the sstable
+            RowPosition right = range.right.maxKeyBound(sstable.partitioner);
+            if (right.compareTo(sstable.last) > 0)
+                right = sstable.last;
+
+            RowPosition left = range.left.maxKeyBound(sstable.partitioner);
+            if (left.compareTo(sstable.first) < 0)
+            {
+                if (sstable.first.compareTo(right) <= 0)
+                    boundsList.add(new Bounds<>(sstable.first, right, sstable.partitioner));
+            }
+            else if (left.compareTo(right) < 0)
+                boundsList.add(new Range<>(left, right, sstable.partitioner));
+        }
 
         this.rangeIterator = boundsList.iterator();
     }
 
     private void seekToCurrentRangeStart()
     {
-        if (currentRange.left.isMinimum(sstable.partitioner))
-            return;
-
         long indexPosition = sstable.getIndexScanPosition(currentRange.left);
-        // -1 means the key is before everything in the sstable. So just start from the beginning.
-        if (indexPosition == -1)
-        {
-            // Note: this method shouldn't assume we're at the start of the sstable already (see #6638) and
-            // the seeks are no-op anyway if we are.
-            ifile.seek(0);
-            dfile.seek(0);
-            return;
-        }
-
         ifile.seek(indexPosition);
         try
         {
@@ -143,10 +157,7 @@ public class SSTableScanner implements ISSTableScanner
             {
                 indexPosition = ifile.getFilePointer();
                 DecoratedKey indexDecoratedKey = sstable.partitioner.decorateKey(ByteBufferUtil.readWithShortLength(ifile));
-                int comparison = indexDecoratedKey.compareTo(currentRange.left);
-                // because our range start may be inclusive or exclusive, we need to also contains()
-                // instead of just checking (comparison >= 0)
-                if (comparison > 0 || currentRange.contains(indexDecoratedKey))
+                if (indexDecoratedKey.compareTo(currentRange.left) > 0 || currentRange.contains(indexDecoratedKey))
                 {
                     // Found, just read the dataPosition and seek into index and data files
                     long dataPosition = ifile.readLong();
