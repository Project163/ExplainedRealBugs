diff --git a/src/java/org/apache/cassandra/concurrent/NamedThreadFactory.java b/src/java/org/apache/cassandra/concurrent/NamedThreadFactory.java
index 4c6763c242..c4abab89de 100644
--- a/src/java/org/apache/cassandra/concurrent/NamedThreadFactory.java
+++ b/src/java/org/apache/cassandra/concurrent/NamedThreadFactory.java
@@ -30,6 +30,8 @@ public class NamedThreadFactory implements ThreadFactory
 {
     protected final String id;
     private final int priority;
+    private final ClassLoader contextClassLoader;
+    private final ThreadGroup threadGroup;
     protected final AtomicInteger n = new AtomicInteger(1);
 
     public NamedThreadFactory(String id)
@@ -39,17 +41,26 @@ public class NamedThreadFactory implements ThreadFactory
 
     public NamedThreadFactory(String id, int priority)
     {
+        this(id, priority, null, null);
+    }
 
+    public NamedThreadFactory(String id, int priority, ClassLoader contextClassLoader, ThreadGroup threadGroup)
+    {
         this.id = id;
         this.priority = priority;
+        this.contextClassLoader = contextClassLoader;
+        this.threadGroup = threadGroup;
     }
 
     public Thread newThread(Runnable runnable)
     {
-        String name = id + ":" + n.getAndIncrement();
-        Thread thread = new Thread(runnable, name);
-        thread.setPriority(priority);
+        String name = id + ':' + n.getAndIncrement();
+        Thread thread = new Thread(threadGroup, runnable, name);
         thread.setDaemon(true);
+        thread.setPriority(priority);
+        if (contextClassLoader != null)
+            thread.setContextClassLoader(contextClassLoader);
         return thread;
     }
+
 }
diff --git a/src/java/org/apache/cassandra/utils/FBUtilities.java b/src/java/org/apache/cassandra/utils/FBUtilities.java
index 8492fed72a..14a8d71ac5 100644
--- a/src/java/org/apache/cassandra/utils/FBUtilities.java
+++ b/src/java/org/apache/cassandra/utils/FBUtilities.java
@@ -378,17 +378,41 @@ public class FBUtilities
 
     public static <T> List<T> waitOnFutures(Iterable<? extends Future<? extends T>> futures)
     {
+        return waitOnFutures(futures, -1, null);
+    }
+
+    /**
+     * Block for a collection of futures, with optional timeout.
+     *
+     * @param futures
+     * @param timeout The number of units to wait in total. If this value is less than or equal to zero,
+     *           no tiemout value will be passed to {@link Future#get()}.
+     * @param units The units of timeout.
+     */
+    public static <T> List<T> waitOnFutures(Iterable<? extends Future<? extends T>> futures, long timeout, TimeUnit units)
+    {
+        long endNanos = 0;
+        if (timeout > 0)
+            endNanos = System.nanoTime() + units.toNanos(timeout);
         List<T> results = new ArrayList<>();
         Throwable fail = null;
         for (Future<? extends T> f : futures)
         {
             try
             {
-                results.add(f.get());
+                if (endNanos == 0)
+                {
+                    results.add(f.get());
+                }
+                else
+                {
+                    long waitFor = Math.max(1, endNanos - System.nanoTime());
+                    results.add(f.get(waitFor, TimeUnit.NANOSECONDS));
+                }
             }
-            catch (InterruptedException | ExecutionException e)
+            catch (Throwable t)
             {
-                fail = Throwables.merge(fail, e);
+                fail = Throwables.merge(fail, t);
             }
         }
         Throwables.maybeFail(fail);
diff --git a/src/java/org/apache/cassandra/utils/memory/MemtablePool.java b/src/java/org/apache/cassandra/utils/memory/MemtablePool.java
index 76631034f3..b4efaa64cf 100644
--- a/src/java/org/apache/cassandra/utils/memory/MemtablePool.java
+++ b/src/java/org/apache/cassandra/utils/memory/MemtablePool.java
@@ -60,7 +60,7 @@ public abstract class MemtablePool
     }
 
     public abstract boolean needToCopyOnHeap();
-    
+
     @VisibleForTesting
     public void shutdown() throws InterruptedException
     {
diff --git a/test/conf/logback-dtest.xml b/test/conf/logback-dtest.xml
index b8019f6d0b..df8cac813e 100644
--- a/test/conf/logback-dtest.xml
+++ b/test/conf/logback-dtest.xml
@@ -23,9 +23,6 @@
   <!-- Shutdown hook ensures that async appender flushes -->
   <shutdownHook class="ch.qos.logback.core.hook.DelayingShutdownHook"/>
 
-  <!-- Status listener is used to wrap stdout/stderr and tee to log file -->
-  <statusListener class="org.apache.cassandra.LogbackStatusListener" />
-
   <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
 
     <file>./build/test/logs/${cassandra.testtag}/TEST-${suitename}.log</file>
@@ -45,35 +42,45 @@
     </encoder>
   </appender>
 
-  <appender name="STDOUT" target="System.out" class="org.apache.cassandra.ConsoleAppender">
+  <appender name="ASYNCFILE" class="ch.qos.logback.classic.AsyncAppender">
+    <discardingThreshold>0</discardingThreshold>
+    <maxFlushTime>0</maxFlushTime>
+    <queueSize>1024</queueSize>
+    <appender-ref ref="FILE"/>
+  </appender>
+
+  <appender name="STDERR" target="System.err" class="ch.qos.logback.core.ConsoleAppender">
     <encoder>
-      <pattern>%-5level [%thread] ${instance_id} %date{ISO8601} %F:%L - %msg%n</pattern>
+      <pattern>%-5level %date{HH:mm:ss,SSS} %msg%n</pattern>
     </encoder>
     <filter class="ch.qos.logback.classic.filter.ThresholdFilter">
-      <level>DEBUG</level>
+      <level>WARN</level>
     </filter>
   </appender>
 
-  <appender name="TEE" class="org.apache.cassandra.TeeingAppender">
-      <appender-ref ref="FILE"/>
-      <appender-ref ref="STDOUT"/>
+  <appender name="STDOUT" target="System.out" class="ch.qos.logback.core.ConsoleAppender">
+    <encoder>
+      <pattern>%-5level %date{HH:mm:ss,SSS} %msg%n</pattern>
+    </encoder>
+    <filter class="ch.qos.logback.classic.filter.ThresholdFilter">
+      <level>WARN</level>
+    </filter>
   </appender>
 
-  <logger name="org.apache.hadoop" level="WARN"/>
-
-  <logger name="org.apache.cassandra.db.monitoring" level="DEBUG"/>
-
-  <!-- Do not change the name of this appender. LogbackStatusListener uses the thread name
-       tied to the appender name to know when to write to real stdout/stderr vs forwarding to logback -->
-  <appender name="ASYNC" class="ch.qos.logback.classic.AsyncAppender">
-      <discardingThreshold>0</discardingThreshold>
-      <maxFlushTime>0</maxFlushTime>
-      <queueSize>1024</queueSize>
-      <appender-ref ref="TEE"/>
-      <includeCallerData>true</includeCallerData>
+  <appender name="STDOUT" target="System.out" class="ch.qos.logback.core.ConsoleAppender">
+    <encoder>
+      <pattern>%-5level [%thread] ${instance_id} %date{ISO8601} %F:%L - %msg%n</pattern>
+    </encoder>
+    <filter class="ch.qos.logback.classic.filter.ThresholdFilter">
+      <level>DEBUG</level>
+    </filter>
   </appender>
 
+  <logger name="org.apache.hadoop" level="WARN"/>
+
   <root level="DEBUG">
-    <appender-ref ref="ASYNC" />
+    <appender-ref ref="ASYNCFILE" />
+    <appender-ref ref="STDERR" />
+    <appender-ref ref="STDOUT" />
   </root>
 </configuration>
diff --git a/test/distributed/org/apache/cassandra/distributed/Instance.java b/test/distributed/org/apache/cassandra/distributed/Instance.java
index 37be73c7b3..c8977d7c2a 100644
--- a/test/distributed/org/apache/cassandra/distributed/Instance.java
+++ b/test/distributed/org/apache/cassandra/distributed/Instance.java
@@ -30,6 +30,8 @@ import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.UUID;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Future;
 import java.util.function.BiConsumer;
 import java.util.function.Function;
 
@@ -83,7 +85,7 @@ public class Instance extends InvokableInstance
 
     public Instance(InstanceConfig config, ClassLoader classLoader)
     {
-        super(classLoader);
+        super("node" + config.num, classLoader);
         this.config = config;
     }
 
@@ -332,9 +334,9 @@ public class Instance extends InvokableInstance
 
     void shutdown()
     {
-        runOnInstance(() -> {
+        acceptsOnInstance((ExecutorService executor) -> {
             Throwable error = null;
-            error = runAndMergeThrowable(error,
+            error = parallelRun(error, executor,
                     Gossiper.instance::stop,
                     CompactionManager.instance::forceShutdown,
                     CommitLog.instance::shutdownBlocking,
@@ -345,32 +347,54 @@ public class Instance extends InvokableInstance
                     StorageService.instance::shutdownBGMonitor,
                     Ref::shutdownReferenceReaper,
                     Memtable.MEMORY_POOL::shutdown,
-                    StageManager::shutdownAndWait,
-                    MessagingService.instance()::shutdown,
-                    SharedExecutorPool.SHARED::shutdown,
                     ScheduledExecutors::shutdownAndWait,
-                    SSTableReader::shutdownBlocking);
-
+                    SSTableReader::shutdownBlocking
+            );
+            error = parallelRun(error, executor,
+                                MessagingService.instance()::shutdown
+            );
+            error = parallelRun(error, executor,
+                                StageManager::shutdownAndWait,
+                                SharedExecutorPool.SHARED::shutdown
+            );
             LoggerContext loggerContext = (LoggerContext) LoggerFactory.getILoggerFactory();
             loggerContext.stop();
             Throwables.maybeFail(error);
-        });
+        }).accept(isolatedExecutor);
+        super.shutdown();
     }
 
-    private static Throwable runAndMergeThrowable(Throwable existing, ThrowingRunnable ... runnables)
+    private static Throwable parallelRun(Throwable accumulate, ExecutorService runOn, ThrowingRunnable ... runnables)
     {
+        List<Future<Throwable>> results = new ArrayList<>();
         for (ThrowingRunnable runnable : runnables)
+        {
+            results.add(runOn.submit(() -> {
+                try
+                {
+                    runnable.run();
+                    return null;
+                }
+                catch (Throwable t)
+                {
+                    return t;
+                }
+            }));
+        }
+        for (Future<Throwable> future : results)
         {
             try
             {
-                runnable.run();
+                Throwable t = future.get();
+                if (t != null)
+                    throw t;
             }
             catch (Throwable t)
             {
-                existing = Throwables.merge(existing, t);
+                accumulate = Throwables.merge(accumulate, t);
             }
         }
-        return existing;
+        return accumulate;
     }
 
     public static interface ThrowingRunnable
diff --git a/test/distributed/org/apache/cassandra/distributed/InstanceClassLoader.java b/test/distributed/org/apache/cassandra/distributed/InstanceClassLoader.java
index 036f6b1ee4..9958fd3960 100644
--- a/test/distributed/org/apache/cassandra/distributed/InstanceClassLoader.java
+++ b/test/distributed/org/apache/cassandra/distributed/InstanceClassLoader.java
@@ -98,4 +98,12 @@ public class InstanceClassLoader extends URLClassLoader
         return id -> new InstanceClassLoader(id, urls, commonClassNames::contains, contextClassLoader);
     }
 
+    /**
+     * @return true iff this class was loaded by an InstanceClassLoader, and as such is used by a dtest node
+     */
+    public static boolean wasLoadedByAnInstanceClassLoader(Class<?> clazz)
+    {
+        return clazz.getClassLoader().getClass().getName().equals(InstanceClassLoader.class.getName());
+    }
+
 }
diff --git a/test/distributed/org/apache/cassandra/distributed/InvokableInstance.java b/test/distributed/org/apache/cassandra/distributed/InvokableInstance.java
index f646ae1f8f..9fb543d288 100644
--- a/test/distributed/org/apache/cassandra/distributed/InvokableInstance.java
+++ b/test/distributed/org/apache/cassandra/distributed/InvokableInstance.java
@@ -20,6 +20,7 @@ package org.apache.cassandra.distributed;
 
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
+import java.io.Closeable;
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
@@ -27,18 +28,26 @@ import java.io.Serializable;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
 import java.util.function.BiConsumer;
 import java.util.function.BiFunction;
 import java.util.function.Consumer;
 import java.util.function.Function;
 
+import org.apache.cassandra.concurrent.NamedThreadFactory;
+import org.apache.cassandra.utils.Throwables;
+
 public abstract class InvokableInstance
 {
+    protected final ExecutorService isolatedExecutor;
     private final ClassLoader classLoader;
     private final Method deserializeOnInstance;
 
-    public InvokableInstance(ClassLoader classLoader)
+    public InvokableInstance(String name, ClassLoader classLoader)
     {
+        this.isolatedExecutor = Executors.newCachedThreadPool(new NamedThreadFactory(name, Thread.NORM_PRIORITY, classLoader, new ThreadGroup(name)));
         this.classLoader = classLoader;
         try
         {
@@ -50,31 +59,34 @@ public abstract class InvokableInstance
         }
     }
 
-    public interface SerializableCallable<T> extends Callable<T>, Serializable { public T call(); }
-    public <T> SerializableCallable<T> callsOnInstance(SerializableCallable<T> call) { return (SerializableCallable<T>) transferOneObject(call); }
+    public interface CallableNoExcept<T> extends Callable<T> { public T call(); }
+    public interface SerializableCallable<T> extends CallableNoExcept<T>, Serializable { }
+    public <T> CallableNoExcept<T> callsOnInstance(SerializableCallable<T> call) { return invokesOnExecutor((SerializableCallable<T>) transferOneObject(call), isolatedExecutor); }
     public <T> T callOnInstance(SerializableCallable<T> call) { return callsOnInstance(call).call(); }
 
     public interface SerializableRunnable extends Runnable, Serializable {}
-    public SerializableRunnable runsOnInstance(SerializableRunnable run) { return (SerializableRunnable) transferOneObject(run); }
+    public Runnable runsOnInstance(SerializableRunnable run) { return invokesOnExecutor((SerializableRunnable) transferOneObject(run), isolatedExecutor); }
     public void runOnInstance(SerializableRunnable run) { runsOnInstance(run).run(); }
 
     public interface SerializableConsumer<T> extends Consumer<T>, Serializable {}
-    public <T> SerializableConsumer<T> acceptsOnInstance(SerializableConsumer<T> consumer) { return (SerializableConsumer<T>) transferOneObject(consumer); }
+    public <T> Consumer<T> acceptsOnInstance(SerializableConsumer<T> consumer) { return invokesOnExecutor((SerializableConsumer<T>) transferOneObject(consumer), isolatedExecutor); }
 
     public interface SerializableBiConsumer<T1, T2> extends BiConsumer<T1, T2>, Serializable {}
-    public <T1, T2> SerializableBiConsumer<T1, T2> acceptsOnInstance(SerializableBiConsumer<T1, T2> consumer) { return (SerializableBiConsumer<T1, T2>) transferOneObject(consumer); }
+    public <T1, T2> BiConsumer<T1, T2> acceptsOnInstance(SerializableBiConsumer<T1, T2> consumer) { return invokesOnExecutor((SerializableBiConsumer<T1, T2>) transferOneObject(consumer), isolatedExecutor); }
 
     public interface SerializableFunction<I, O> extends Function<I, O>, Serializable {}
-    public <I, O> SerializableFunction<I, O> appliesOnInstance(SerializableFunction<I, O> f) { return (SerializableFunction<I, O>) transferOneObject(f); }
+    public <I, O> Function<I, O> appliesOnInstance(SerializableFunction<I, O> f) { return invokesOnExecutor((SerializableFunction<I, O>) transferOneObject(f), isolatedExecutor); }
 
     public interface SerializableBiFunction<I1, I2, O> extends BiFunction<I1, I2, O>, Serializable {}
-    public <I1, I2, O> SerializableBiFunction<I1, I2, O> appliesOnInstance(SerializableBiFunction<I1, I2, O> f) { return (SerializableBiFunction<I1, I2, O>) transferOneObject(f); }
+    public <I1, I2, O> BiFunction<I1, I2, O> appliesOnInstance(SerializableBiFunction<I1, I2, O> f) { return invokesOnExecutor((SerializableBiFunction<I1, I2, O>) transferOneObject(f), isolatedExecutor); }
 
-    public interface SerializableTriFunction<I1, I2, I3, O> extends Serializable
+    public interface TriFunction<I1, I2, I3, O>
     {
         O apply(I1 i1, I2 i2, I3 i3);
     }
-    public <I1, I2, I3, O> SerializableTriFunction<I1, I2, I3, O> appliesOnInstance(SerializableTriFunction<I1, I2, I3, O> f) { return (SerializableTriFunction<I1, I2, I3, O>) transferOneObject(f); }
+    public interface SerializableTriFunction<I1, I2, I3, O> extends Serializable, TriFunction<I1, I2, I3, O> { }
+
+    public <I1, I2, I3, O> TriFunction<I1, I2, I3, O> appliesOnInstance(SerializableTriFunction<I1, I2, I3, O> f) { return invokesOnExecutor((SerializableTriFunction<I1, I2, I3, O>) transferOneObject(f), isolatedExecutor); }
 
     public interface InstanceFunction<I, O> extends SerializableBiFunction<Instance, I, O> {}
 
@@ -130,4 +142,72 @@ public abstract class InvokableInstance
         }
     }
 
+    private static <V> CallableNoExcept<V> invokesOnExecutor(SerializableCallable<V> callable, ExecutorService invokeOn)
+    {
+        return () -> {
+            try
+            {
+                return invokeOn.submit(callable).get();
+            }
+            catch (InterruptedException e)
+            {
+                throw new RuntimeException(e);
+            }
+            catch (ExecutionException e)
+            {
+                Throwables.maybeFail(e.getCause());
+                throw new AssertionError();
+            }
+        };
+    }
+
+    private static Runnable invokesOnExecutor(SerializableRunnable runnable, ExecutorService invokeOn)
+    {
+        return () -> {
+            try
+            {
+                invokeOn.submit(runnable).get();
+            }
+            catch (InterruptedException e)
+            {
+                throw new RuntimeException(e);
+            }
+            catch (ExecutionException e)
+            {
+                Throwables.maybeFail(e.getCause());
+                throw new AssertionError();
+            }
+        };
+    }
+
+    private static <A> Consumer<A> invokesOnExecutor(SerializableConsumer<A> consumer, ExecutorService invokeOn)
+    {
+        return (a) -> invokesOnExecutor(() -> consumer.accept(a), invokeOn).run();
+    }
+
+    private static <A, B> BiConsumer<A, B> invokesOnExecutor(SerializableBiConsumer<A, B> consumer, ExecutorService invokeOn)
+    {
+        return (a, b) -> invokesOnExecutor(() -> consumer.accept(a, b), invokeOn).run();
+    }
+
+    private static <A, B> Function<A, B> invokesOnExecutor(SerializableFunction<A, B> f, ExecutorService invokeOn)
+    {
+        return (a) -> invokesOnExecutor(() -> f.apply(a), invokeOn).call();
+    }
+
+    private static <A, B, C> BiFunction<A, B, C> invokesOnExecutor(SerializableBiFunction<A, B, C> f, ExecutorService invokeOn)
+    {
+        return (a, b) -> invokesOnExecutor(() -> f.apply(a, b), invokeOn).call();
+    }
+
+    private static <A, B, C, D> SerializableTriFunction<A, B, C, D> invokesOnExecutor(SerializableTriFunction<A, B, C, D> f, ExecutorService invokeOn)
+    {
+        return (a, b, c) -> invokesOnExecutor(() -> f.apply(a, b, c), invokeOn).call();
+    }
+
+    void shutdown()
+    {
+        isolatedExecutor.shutdownNow();
+    }
+
 }
diff --git a/test/distributed/org/apache/cassandra/distributed/TestCluster.java b/test/distributed/org/apache/cassandra/distributed/TestCluster.java
index 82b775aa3a..245030641d 100644
--- a/test/distributed/org/apache/cassandra/distributed/TestCluster.java
+++ b/test/distributed/org/apache/cassandra/distributed/TestCluster.java
@@ -31,24 +31,19 @@ import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.locks.LockSupport;
-import java.util.concurrent.TimeoutException;
 import java.util.function.IntFunction;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 
 import com.google.common.collect.Sets;
 
-import io.netty.util.concurrent.FastThreadLocal;
-import io.netty.util.concurrent.FastThreadLocalThread;
-import io.netty.util.internal.InternalThreadLocalMap;
-import org.apache.cassandra.concurrent.NamedThreadFactory;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
+import org.apache.cassandra.concurrent.NamedThreadFactory;
 import org.apache.cassandra.db.ColumnFamilyStore;
 import org.apache.cassandra.db.ConsistencyLevel;
 import org.apache.cassandra.db.Keyspace;
@@ -56,7 +51,6 @@ import org.apache.cassandra.io.util.FileUtils;
 import org.apache.cassandra.locator.InetAddressAndPort;
 import org.apache.cassandra.net.MessagingService;
 import org.apache.cassandra.utils.FBUtilities;
-import org.apache.cassandra.utils.Throwables;
 
 /**
  * TestCluster creates, initializes and manages Cassandra instances ({@link Instance}.
@@ -84,7 +78,10 @@ import org.apache.cassandra.utils.Throwables;
  */
 public class TestCluster implements AutoCloseable
 {
-    private final ExecutorService exec = Executors.newCachedThreadPool(new NamedThreadFactory("cluster-async-tasks"));
+    // WARNING: we have this logger not (necessarily) for logging, but
+    // to ensure we have instantiated the main classloader's LoggerFactory (and any LogbackStatusListener)
+    // before we instantiate any for a new instance
+    private static final Logger logger = LoggerFactory.getLogger(TestCluster.class);
 
     private final File root;
     private final List<Instance> instances;
@@ -104,7 +101,7 @@ public class TestCluster implements AutoCloseable
     void launch()
     {
         FBUtilities.waitOnFutures(instances.stream()
-                .map(i -> exec.submit(() -> i.launch(this)))
+                .map(i -> i.isolatedExecutor.submit(() -> i.launch(this)))
                 .collect(Collectors.toList())
         );
         for (Instance instance : instances)
@@ -247,37 +244,17 @@ public class TestCluster implements AutoCloseable
     }
 
     @Override
-    public void close() throws InterruptedException, TimeoutException, ExecutionException
+    public void close()
     {
         List<Future<?>> futures = instances.stream()
-                .map(i -> exec.submit(i::shutdown))
+                .map(i -> i.isolatedExecutor.submit(i::shutdown))
                 .collect(Collectors.toList());
 
         // Make sure to only delete directory when threads are stopped
-        Future combined = exec.submit(() -> {
-            FBUtilities.waitOnFutures(futures);
-            FileUtils.deleteRecursive(root);
-        });
-
-        combined.get(60, TimeUnit.SECONDS);
-
-        exec.shutdownNow();
-        exec.awaitTermination(10, TimeUnit.SECONDS);
-
-//        withThreadLeakCheck(futures);
-        Set<Thread> threadSet = Thread.getAllStackTraces().keySet();
-        for (Thread thread : threadSet)
-        {
-            if (thread instanceof FastThreadLocalThread)
-                ((FastThreadLocalThread)thread).setThreadLocalMap(null);
-        }
-
-        InternalThreadLocalMap.remove();
-        InternalThreadLocalMap.destroy();
-
-        FastThreadLocal.removeAll();
-        FastThreadLocal.destroy();
+        FBUtilities.waitOnFutures(futures, 60, TimeUnit.SECONDS);
+        FileUtils.deleteRecursive(root);
 
+        //withThreadLeakCheck(futures);
         System.gc();
     }
 
@@ -299,26 +276,5 @@ public class TestCluster implements AutoCloseable
         }
     }
 
-    public void runAndWait(Instance.ThrowingRunnable runnable)
-    {
-        try
-        {
-            exec.submit(() -> {
-                try
-                {
-                    runnable.run();
-                }
-                catch (Throwable throwable)
-                {
-                    Throwables.maybeFail(throwable);
-                }
-            }).get();
-        }
-        catch (Exception e)
-        {
-            Throwables.maybeFail(e.getCause());
-        }
-    }
-
 }
 
