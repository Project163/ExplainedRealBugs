diff --git a/test/distributed/org/apache/cassandra/fuzz/ring/ConsistentBootstrapTest.java b/test/distributed/org/apache/cassandra/fuzz/ring/ConsistentBootstrapTest.java
index c6e8db78b1..57c12b7684 100644
--- a/test/distributed/org/apache/cassandra/fuzz/ring/ConsistentBootstrapTest.java
+++ b/test/distributed/org/apache/cassandra/fuzz/ring/ConsistentBootstrapTest.java
@@ -35,10 +35,11 @@ import org.apache.cassandra.distributed.api.TokenSupplier;
 import org.apache.cassandra.distributed.shared.NetworkTopology;
 import org.apache.cassandra.distributed.test.log.FuzzTestBase;
 import org.apache.cassandra.harry.SchemaSpec;
-import org.apache.cassandra.harry.op.Visit;
 import org.apache.cassandra.harry.dsl.HistoryBuilder;
 import org.apache.cassandra.harry.dsl.HistoryBuilderHelper;
+import org.apache.cassandra.harry.dsl.ReplayingHistoryBuilder;
 import org.apache.cassandra.harry.execution.DataTracker;
+import org.apache.cassandra.harry.execution.InJvmDTestVisitExecutor;
 import org.apache.cassandra.harry.execution.RingAwareInJvmDTestVisitExecutor;
 import org.apache.cassandra.harry.gen.Generator;
 import org.apache.cassandra.harry.gen.Generators;
@@ -163,7 +164,11 @@ public class ConsistentBootstrapTest extends FuzzTestBase
                 SchemaSpec schema = schemaGen.generate(rng);
                 Generator<Integer> ckGen = Generators.int32(0, Math.min(schema.valueGenerators.ckPopulation(), 1000));
 
-                HistoryBuilder history = new HistoryBuilder(schema.valueGenerators);
+                HistoryBuilder history = new ReplayingHistoryBuilder(schema.valueGenerators,
+                                                                     hb -> RingAwareInJvmDTestVisitExecutor.builder()
+                                                                                                           .replicationFactor(new TokenPlacementModel.SimpleReplicationFactor(3))
+                                                                                                           .consistencyLevel(ConsistencyLevel.ALL)
+                                                                                                           .build(schema, hb, cluster));
 
                 cluster.schemaChange(String.format("CREATE KEYSPACE %s WITH replication = {'class': 'SimpleStrategy', 'replication_factor' : 3};", KEYSPACE));
                 cluster.schemaChange(schema.compile());
@@ -177,39 +182,36 @@ public class ConsistentBootstrapTest extends FuzzTestBase
                        .drop()
                        .on();
 
-                IInstanceConfig config = cluster.newInstanceConfig()
-                                                .set("auto_bootstrap", true)
-                                                .set(Constants.KEY_DTEST_FULL_STARTUP, true)
-                                                .set("progress_barrier_default_consistency_level", "NODE_LOCAL");
-                IInvokableInstance newInstance = cluster.bootstrap(config);
-                // Prime the CMS node to pause before the finish join event is committed
-                long[] metricCounts = new long[4];
-                for (int i = 1; i <= 4; i++)
-                    metricCounts[i - 1] = cluster.get(i).callOnInstance(() -> TCMMetrics.instance.coordinatorBehindPlacements.getCount());
-
                 DataTracker tracker = new DataTracker.SequentialDataTracker();
                 RingAwareInJvmDTestVisitExecutor executor = RingAwareInJvmDTestVisitExecutor.builder()
                                                                                             .replicationFactor(new TokenPlacementModel.SimpleReplicationFactor(2))
                                                                                             .nodeSelector(i -> 2)
                                                                                             .consistencyLevel(ConsistencyLevel.ALL)
+                                                                                            .retryPolicy(InJvmDTestVisitExecutor.RetryPolicy.NO_RETRY)
                                                                                             .build(schema,
                                                                                                    tracker,
                                                                                                    new QuiescentChecker(schema.valueGenerators, tracker, history),
                                                                                                    cluster);
 
+                // Prime the CMS node to pause before the finish join event is committed
+                Callable<?> pending = pauseBeforeCommit(cmsInstance, (e) -> e instanceof PrepareJoin.MidJoin);
+                IInstanceConfig config = cluster.newInstanceConfig()
+                                                .set("auto_bootstrap", true)
+                                                .set(Constants.KEY_DTEST_FULL_STARTUP, true)
+                                                .set("progress_barrier_default_consistency_level", "NODE_LOCAL");
+                IInvokableInstance newInstance = cluster.bootstrap(config);
+                long[] metricCounts = new long[4];
+                for (int i = 1; i <= 4; i++)
+                    metricCounts[i - 1] = cluster.get(i).callOnInstance(() -> TCMMetrics.instance.coordinatorBehindPlacements.getCount());
                 Thread startup = new Thread(() -> newInstance.startup());
-
-                history.customThrowing(() -> {
-                    Callable<?> pending = pauseBeforeCommit(cmsInstance, (e) -> e instanceof PrepareJoin.MidJoin);
-                    startup.start();
-                    pending.call();
-                }, "Startup");
+                startup.start();
+                pending.call();
 
                 long[] markers = new long[4];
-                history.custom(() -> {
-                    for (int n = 0; n < 4; n++)
-                        markers[n] = cluster.get(n + 1).logs().mark();
-                }, "Start grep");
+                for (int n = 0; n < 4; n++)
+                    markers[n] = cluster.get(n + 1).logs().mark();
+
+                boolean triggered = false;
 
                 outer:
                 for (int i = 0; i < history.valueGenerators().pkPopulation(); i++)
@@ -219,15 +221,17 @@ public class ConsistentBootstrapTest extends FuzzTestBase
                     {
                         if (cluster.get(1).config().broadcastAddress().toString().contains(replica.node().id()))
                         {
-                            HistoryBuilderHelper.insertRandomData(schema, i, ckGen.generate(rng), rng, history);
-                            break outer;
+                            try
+                            {
+                                HistoryBuilderHelper.insertRandomData(schema, i, ckGen.generate(rng), rng, history);
+                            }
+                            catch (Throwable t)
+                            {
+                                // ignore; expected
+                            }
                         }
                     }
-                }
 
-
-                history.customThrowing(() -> {
-                    boolean triggered = false;
                     for (int n = 0; n < markers.length; n++)
                     {
                         if ((n + 1) == 2) // skip 2nd node
@@ -240,31 +244,28 @@ public class ConsistentBootstrapTest extends FuzzTestBase
                                     .isEmpty())
                         {
                             triggered = true;
-                            break;
+                            break outer;
                         }
                     }
+                }
 
-                    Assert.assertTrue("Should have triggered routing exception on the replica", triggered);
-                    boolean metricTriggered = false;
-                    for (int i = 1; i <= 4; i++)
+                Assert.assertTrue("Should have triggered routing exception on the replica", triggered);
+                boolean metricTriggered = false;
+                for (int i = 1; i <= 4; i++)
+                {
+                    long prevMetric = metricCounts[i - 1];
+                    long newMetric = cluster.get(i).callOnInstance(() -> TCMMetrics.instance.coordinatorBehindPlacements.getCount());
+                    if (newMetric - prevMetric > 0)
                     {
-                        long prevMetric = metricCounts[i - 1];
-                        long newMetric = cluster.get(i).callOnInstance(() -> TCMMetrics.instance.coordinatorBehindPlacements.getCount());
-                        if (newMetric - prevMetric > 0)
-                        {
-                            metricTriggered = true;
-                            break;
-                        }
+                        metricTriggered = true;
+                        break;
                     }
-                    Assert.assertTrue("Metric CoordinatorBehindRing should have been bumped by at least one replica", metricTriggered);
-
-                    cluster.filters().reset();
-                    unpauseCommits(cmsInstance);
-                    startup.join();
-                }, "Validate triggered");
+                }
+                Assert.assertTrue("Metric CoordinatorBehindRing should have been bumped by at least one replica", metricTriggered);
 
-                for (Visit visit : history)
-                    executor.execute(visit);
+                cluster.filters().reset();
+                unpauseCommits(cmsInstance);
+                startup.join();
             });
         }
         catch (Throwable t)
diff --git a/test/harry/main/org/apache/cassandra/harry/execution/InJvmDTestVisitExecutor.java b/test/harry/main/org/apache/cassandra/harry/execution/InJvmDTestVisitExecutor.java
index 8362a3111b..dca2b7001f 100644
--- a/test/harry/main/org/apache/cassandra/harry/execution/InJvmDTestVisitExecutor.java
+++ b/test/harry/main/org/apache/cassandra/harry/execution/InJvmDTestVisitExecutor.java
@@ -296,6 +296,7 @@ public class InJvmDTestVisitExecutor extends CQLVisitExecutor
                    AssertionUtils.isInstanceof(RequestTimeoutException.class)
                                  .matches(Throwables.getRootCause(t));
         };
+        RetryPolicy NO_RETRY = (t) -> false;
         boolean retry(Throwable t);
     }
 
