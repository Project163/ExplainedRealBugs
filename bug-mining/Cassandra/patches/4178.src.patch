diff --git a/CHANGES.txt b/CHANGES.txt
index 4b505f8c4b..04c9204f07 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 2.1.14
+ * Don't do defragmentation if reading from repaired sstables (CASSANDRA-10342)
  * Fix streaming_socket_timeout_in_ms not enforced (CASSANDRA-11286)
  * Avoid dropping message too quickly due to missing unit conversion (CASSANDRA-11302)
  * COPY FROM on large datasets: fix progress report and debug performance (CASSANDRA-11053)
diff --git a/src/java/org/apache/cassandra/db/CollationController.java b/src/java/org/apache/cassandra/db/CollationController.java
index 5c6a3db5f0..8a966bca6d 100644
--- a/src/java/org/apache/cassandra/db/CollationController.java
+++ b/src/java/org/apache/cassandra/db/CollationController.java
@@ -108,7 +108,7 @@ public class CollationController
 
             /* add the SSTables on disk */
             Collections.sort(view.sstables, SSTableReader.maxTimestampComparator);
-
+            boolean onlyUnrepaired = true;
             // read sorted sstables
             for (SSTableReader sstable : view.sstables)
             {
@@ -122,7 +122,8 @@ public class CollationController
                 reduceNameFilter(reducedFilter, container, currentMaxTs);
                 if (((NamesQueryFilter) reducedFilter.filter).columns.isEmpty())
                     break;
-
+                if (sstable.isRepaired())
+                    onlyUnrepaired = false;
                 Tracing.trace("Merging data from sstable {}", sstable.descriptor.generation);
                 sstable.incrementReadCount();
                 OnDiskAtomIterator iter = reducedFilter.getSSTableColumnIterator(sstable);
@@ -149,6 +150,7 @@ public class CollationController
 
             // "hoist up" the requested data into a more recent sstable
             if (sstablesIterated > cfs.getMinimumCompactionThreshold()
+                && onlyUnrepaired
                 && !cfs.isAutoCompactionDisabled()
                 && cfs.getCompactionStrategy().shouldDefragment())
             {
