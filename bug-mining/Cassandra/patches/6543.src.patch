diff --git a/CHANGES.txt b/CHANGES.txt
index 1255333b9c..252b9c919c 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 5.1
+ * Make TableParams.Serializer set allowAutoSnapshots and incrementalBackups (CASSANDRA-19954)
  * Make sstabledump possible to show tombstones only (CASSANDRA-19939)
  * Ensure that RFP queries potentially stale replicas even with only key columns in the row filter (CASSANDRA-19938)
  * Allow nodes to change IP address while upgrading to TCM (CASSANDRA-19921)
diff --git a/src/java/org/apache/cassandra/schema/TableParams.java b/src/java/org/apache/cassandra/schema/TableParams.java
index f279bc041f..1c68c8e977 100644
--- a/src/java/org/apache/cassandra/schema/TableParams.java
+++ b/src/java/org/apache/cassandra/schema/TableParams.java
@@ -510,6 +510,11 @@ public final class TableParams
             serializeMapBB(t.extensions, out);
             out.writeBoolean(t.cdc);
             out.writeUTF(t.readRepair.name());
+            if (version.isAtLeast(Version.V3))
+            {
+                out.writeBoolean(t.allowAutoSnapshot);
+                out.writeBoolean(t.incrementalBackups);
+            }
         }
 
         public TableParams deserialize(DataInputPlus in, Version version) throws IOException
@@ -531,7 +536,9 @@ public final class TableParams
                    .compression(CompressionParams.fromMap(deserializeMap(in)))
                    .extensions(deserializeMapBB(in))
                    .cdc(in.readBoolean())
-                   .readRepair(ReadRepairStrategy.fromString(in.readUTF()));
+                   .readRepair(ReadRepairStrategy.fromString(in.readUTF()))
+                   .allowAutoSnapshot(!version.isAtLeast(Version.V3) || in.readBoolean())
+                   .incrementalBackups(!version.isAtLeast(Version.V3) || in.readBoolean());
             return builder.build();
         }
 
@@ -553,7 +560,9 @@ public final class TableParams
                    serializedSizeMap(t.compression.asMap()) +
                    serializedSizeMapBB(t.extensions) +
                    sizeof(t.cdc) +
-                   sizeof(t.readRepair.name());
+                   sizeof(t.readRepair.name()) +
+                   (version.isAtLeast(Version.V3) ? sizeof(t.allowAutoSnapshot) : 0) +
+                   (version.isAtLeast(Version.V3) ? sizeof(t.incrementalBackups) : 0);
         }
 
         private void serializeMap(Map<String, String> map, DataOutputPlus out) throws IOException
diff --git a/src/java/org/apache/cassandra/tcm/membership/NodeVersion.java b/src/java/org/apache/cassandra/tcm/membership/NodeVersion.java
index 4428a169e3..2d8523adfb 100644
--- a/src/java/org/apache/cassandra/tcm/membership/NodeVersion.java
+++ b/src/java/org/apache/cassandra/tcm/membership/NodeVersion.java
@@ -34,7 +34,7 @@ import static org.apache.cassandra.db.TypeSizes.sizeofUnsignedVInt;
 public class NodeVersion implements Comparable<NodeVersion>
 {
     public static final Serializer serializer = new Serializer();
-    public static final Version CURRENT_METADATA_VERSION = Version.V2;
+    public static final Version CURRENT_METADATA_VERSION = Version.V3;
     public static final NodeVersion CURRENT = new NodeVersion(new CassandraVersion(FBUtilities.getReleaseVersionString()), CURRENT_METADATA_VERSION);
     private static final CassandraVersion SINCE_VERSION = CassandraVersion.CASSANDRA_5_0;
 
diff --git a/src/java/org/apache/cassandra/tcm/serialization/Version.java b/src/java/org/apache/cassandra/tcm/serialization/Version.java
index ae2afb6f00..7960c963ed 100644
--- a/src/java/org/apache/cassandra/tcm/serialization/Version.java
+++ b/src/java/org/apache/cassandra/tcm/serialization/Version.java
@@ -38,6 +38,10 @@ public enum Version
      *  - Serialize MemtableParams when serializing TableParams
      */
     V2(2),
+    /**
+     *  - Serialize allowAutoSnapshot and incrementalBackups when serializing TableParams
+     */
+    V3(3),
 
     UNKNOWN(Integer.MAX_VALUE);
 
diff --git a/test/unit/org/apache/cassandra/schema/TableMetadataSerDeTest.java b/test/unit/org/apache/cassandra/schema/TableMetadataSerDeTest.java
index a8714899f6..cb8febde7f 100644
--- a/test/unit/org/apache/cassandra/schema/TableMetadataSerDeTest.java
+++ b/test/unit/org/apache/cassandra/schema/TableMetadataSerDeTest.java
@@ -29,6 +29,7 @@ import org.junit.Test;
 import org.apache.cassandra.cql3.CQL3Type;
 import org.apache.cassandra.distributed.Cluster;
 import org.apache.cassandra.distributed.api.ConsistencyLevel;
+import org.apache.cassandra.distributed.api.IIsolatedExecutor;
 import org.apache.cassandra.distributed.test.TestBaseImpl;
 import org.apache.cassandra.io.util.DataInputBuffer;
 import org.apache.cassandra.io.util.DataOutputBuffer;
@@ -37,6 +38,80 @@ import org.apache.cassandra.tcm.membership.NodeVersion;
 
 public class TableMetadataSerDeTest extends TestBaseImpl
 {
+    @Test
+    public void testCASSANDRA_19954() throws Throwable
+    {
+        try (Cluster cluster = builder().withNodes(1)
+                                        .start())
+        {
+            cluster.coordinator(1).execute("CREATE KEYSPACE ks WITH replication = {'class': 'SimpleStrategy', 'replication_factor' : 1};",
+                                           ConsistencyLevel.ALL);
+
+            cluster.coordinator(1).execute("CREATE TABLE ks.tbl (pk int,\n" +
+                                           "    ck int,\n" +
+                                           "    v1 int,\n" +
+                                           "    v2 text,\n" +
+                                           "    v3 text,\n" +
+                                           "    v4 text,\n" +
+                                           "    v5 text,\n" +
+                                           "    PRIMARY KEY (pk, ck))",
+                                           ConsistencyLevel.ALL);
+
+            assertTableState(cluster, true, true);
+
+            cluster.coordinator(1).execute("ALTER TABLE ks.tbl WITH allow_auto_snapshot = false", ConsistencyLevel.ALL);
+            assertTableState(cluster, false, true);
+
+            cluster.coordinator(1).execute("ALTER TABLE ks.tbl WITH allow_auto_snapshot = true", ConsistencyLevel.ALL);
+            assertTableState(cluster, true, true);
+
+            cluster.coordinator(1).execute("ALTER TABLE ks.tbl WITH incremental_backups = false", ConsistencyLevel.ALL);
+            assertTableState(cluster, true, false);
+
+            cluster.coordinator(1).execute("ALTER TABLE ks.tbl WITH incremental_backups = true", ConsistencyLevel.ALL);
+            assertTableState(cluster, true, true);
+
+            cluster.coordinator(1).execute("ALTER TABLE ks.tbl WITH incremental_backups = false AND allow_auto_snapshot = false", ConsistencyLevel.ALL);
+            assertTableState(cluster, false, false);
+        }
+    }
+
+    private void assertTableState(Cluster cluster, boolean expectedAllowAutoSnapshot, boolean expectedIncrementalBackups)
+    {
+        cluster.get(1).acceptsOnInstance((IIsolatedExecutor.SerializableBiConsumer<Boolean, Boolean>) (snapshots, backups) -> {
+            TableMetadata tableMetadata = ClusterMetadata.current().schema.getKeyspaceMetadata("ks").getTableOrViewNullable("tbl");
+
+            Assert.assertNotNull(tableMetadata);
+            Assert.assertEquals(snapshots, tableMetadata.params.allowAutoSnapshot);
+            Assert.assertEquals(backups, tableMetadata.params.incrementalBackups);
+
+            ByteBuffer out = null;
+            try (DataOutputBuffer dob = new DataOutputBuffer())
+            {
+                TableMetadata.serializer.serialize(tableMetadata, dob, NodeVersion.CURRENT_METADATA_VERSION);
+                out = dob.buffer();
+            }
+            catch (IOException e)
+            {
+                throw new RuntimeException(e);
+            }
+
+            Assert.assertEquals(out.limit(), TableMetadata.serializer.serializedSize(tableMetadata, NodeVersion.CURRENT_METADATA_VERSION));
+            TableMetadata rt = null;
+            try
+            {
+                rt = TableMetadata.serializer.deserialize(new DataInputBuffer(out, true), Types.builder().build(), UserFunctions.builder().build(), NodeVersion.CURRENT_METADATA_VERSION);
+            }
+            catch (IOException e)
+            {
+                e.printStackTrace();
+                throw new RuntimeException(e);
+            }
+
+            Assert.assertEquals(rt, tableMetadata);
+        }).accept(expectedAllowAutoSnapshot, expectedIncrementalBackups);
+    }
+
     @Test
     public void droppedColumnsTest() throws Throwable
     {
