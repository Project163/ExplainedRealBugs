diff --git a/CHANGES.txt b/CHANGES.txt
index 7fdb073877..9b4a5bd860 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -61,16 +61,8 @@
  * Ensure compacted files are never used, to avoid counter overcount (CASSANDRA-4436)
 Merged from 1.0:
  * Push the validation of secondary index values to the SecondaryIndexManager (CASSANDRA-4240)
- * allow dropping columns shadowed by not-yet-expired supercolumn or row
-   tombstones in PrecompactedRow (CASSANDRA-4396)
- * fix 1.0.x node join to mixed version cluster, other nodes >= 1.1 (CASSANDRA-4195)
- * Fix LCS splitting sstable base on uncompressed size (CASSANDRA-4419)
- * Bootstraps that fail are detected upon restart and will retry safely without
-   needing to delete existing data first (CASSANDRA-4427)
- * seed status no longer disables bootstrap (CASSANDRA-4427)
- * (cqlsh) add a COPY TO command to copy a CF to a CSV file (CASSANDRA-4434)
- * Don't purge columns during upgradesstables (CASSANDRA-4462)
- * Push the validation of secondary index values to the SecondaryIndexManager (CASSANDRA-4240)
+ * (Hadoop) fix iterating through a resultset consisting entirely
+   of tombstoned rows (CASSANDRA-4466)
 
 
 1.1.2
diff --git a/src/java/org/apache/cassandra/hadoop/ColumnFamilyRecordReader.java b/src/java/org/apache/cassandra/hadoop/ColumnFamilyRecordReader.java
index d5786b528f..afbda7f59c 100644
--- a/src/java/org/apache/cassandra/hadoop/ColumnFamilyRecordReader.java
+++ b/src/java/org/apache/cassandra/hadoop/ColumnFamilyRecordReader.java
@@ -368,18 +368,21 @@ public class ColumnFamilyRecordReader extends RecordReader<ByteBuffer, SortedMap
                 if (isEmptyPredicate)
                 {
                     Iterator<KeySlice> it = rows.iterator();
-                    while (it.hasNext())
+                    KeySlice ks;
+                    do
                     {
-                        KeySlice ks = it.next();
+                        ks = it.next();
                         if (ks.getColumnsSize() == 0)
                         {
                             it.remove();
                         }
-                    }
+                    } while (it.hasNext());
 
                     // all ghosts, spooky
                     if (rows.isEmpty())
                     {
+                        // maybeInit assumes it can get the start-with key from the rows collection, so add back the last
+                        rows.add(ks);
                         maybeInit();
                         return;
                     }
