diff --git a/CHANGES.txt b/CHANGES.txt
index 038befb580..21222278fc 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 3.11.0
+ * Fix static column indexes (CASSANDRA-13277) 
  * DataOutputBuffer.asNewBuffer broken (CASSANDRA-13298)
  * unittest CipherFactoryTest failed on MacOS (CASSANDRA-13370)
  * Forbid SELECT restrictions and CREATE INDEX over non-frozen UDT columns (CASSANDRA-13247)
diff --git a/src/java/org/apache/cassandra/index/internal/composites/CompositesSearcher.java b/src/java/org/apache/cassandra/index/internal/composites/CompositesSearcher.java
index 324d939e08..e777620b23 100644
--- a/src/java/org/apache/cassandra/index/internal/composites/CompositesSearcher.java
+++ b/src/java/org/apache/cassandra/index/internal/composites/CompositesSearcher.java
@@ -114,6 +114,12 @@ public class CompositesSearcher extends CassandraIndexSearcher
                     List<IndexEntry> entries = new ArrayList<>();
                     if (isStaticColumn())
                     {
+                        // The index hit may not match the commad key constraint
+                        if (!isMatchingEntry(partitionKey, nextEntry, command)) {
+                            nextEntry = indexHits.hasNext() ? index.decodeEntry(indexKey, indexHits.next()) : null;
+                            continue;
+                        }
+
                         // If the index is on a static column, we just need to do a full read on the partition.
                         // Note that we want to re-use the command.columnFilter() in case of future change.
                         dataCmd = SinglePartitionReadCommand.create(index.baseCfs.metadata,
diff --git a/test/unit/org/apache/cassandra/index/internal/CassandraIndexTest.java b/test/unit/org/apache/cassandra/index/internal/CassandraIndexTest.java
index 5c7d8404aa..59d68608d4 100644
--- a/test/unit/org/apache/cassandra/index/internal/CassandraIndexTest.java
+++ b/test/unit/org/apache/cassandra/index/internal/CassandraIndexTest.java
@@ -357,6 +357,32 @@ public class CassandraIndexTest extends CQLTester
                         .run();
     }
 
+    @Test
+    public void indexOnStaticColumn() throws Throwable
+    {
+        Object[] row1 = row("k0", "c0", "s0");
+        Object[] row2 = row("k0", "c1", "s0");
+        Object[] row3 = row("k1", "c0", "s1");
+        Object[] row4 = row("k1", "c1", "s1");
+
+        createTable("CREATE TABLE %s (k text, c text, s text static, PRIMARY KEY (k, c));");
+        createIndex("CREATE INDEX sc_index on %s(s)");
+
+        execute("INSERT INTO %s (k, c, s) VALUES (?, ?, ?)", row1);
+        execute("INSERT INTO %s (k, c, s) VALUES (?, ?, ?)", row2);
+        execute("INSERT INTO %s (k, c, s) VALUES (?, ?, ?)", row3);
+        execute("INSERT INTO %s (k, c, s) VALUES (?, ?, ?)", row4);
+
+        assertRows(execute("SELECT * FROM %s WHERE s = ?", "s0"), row1, row2);
+        assertRows(execute("SELECT * FROM %s WHERE s = ?", "s1"), row3, row4);
+
+        assertRows(execute("SELECT * FROM %s WHERE s = ? AND token(k) >= token(?)", "s0", "k0"), row1, row2);
+        assertRows(execute("SELECT * FROM %s WHERE s = ? AND token(k) >= token(?)", "s1", "k1"), row3, row4);
+
+        assertEmpty(execute("SELECT * FROM %s WHERE s = ? AND token(k) < token(?)", "s0", "k0"));
+        assertEmpty(execute("SELECT * FROM %s WHERE s = ? AND token(k) < token(?)", "s1", "k1"));
+    }
+
     @Test
     public void createIndexesOnMultipleMapDimensions() throws Throwable
     {
