diff --git a/CHANGES.txt b/CHANGES.txt
index 3722f2dbfb..7eaefaa8b7 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -10,6 +10,7 @@
  * Make upgradeSSTable skip current version sstables by default (CASSANDRA-5366)
  * Optimize min/max timestamp collection (CASSANDRA-5373)
  * Invalid streamId in cql binary protocol when using invalid CL (CASSANDRA-5164)
+ * Fix validation for IN where clauses with collections (CASSANDRA-5376)
 Merged from 1.1:
  * cli: Quote ks and cf names in schema output when needed (CASSANDRA-5052)
  * Fix bad default for min/max timestamp in SSTableMetadata (CASSANDRA-5372)
diff --git a/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java b/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
index d5a7425851..b218975b69 100644
--- a/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
+++ b/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
@@ -406,7 +406,7 @@ public class SelectStatement implements CQLStatement
             return false;
 
         // However, collections always entails one
-        if (cfDef.hasCollections)
+        if (selectACollection())
             return true;
 
         // Otherwise, it is a range query if it has at least one the column alias
@@ -473,7 +473,7 @@ public class SelectStatement implements CQLStatement
         {
             // Collections require doing a slice query because a given collection is a
             // non-know set of columns, so we shouldn't get there
-            assert !cfDef.hasCollections;
+            assert !selectACollection();
 
             SortedSet<ByteBuffer> columns = new TreeSet<ByteBuffer>(cfDef.cfm.comparator);
 
@@ -505,6 +505,20 @@ public class SelectStatement implements CQLStatement
         }
     }
 
+    private boolean selectACollection()
+    {
+        if (!cfDef.hasCollections)
+            return false;
+
+        for (CFDefinition.Name name : selection.getColumnsList())
+        {
+            if (name.type instanceof CollectionType)
+                return true;
+        }
+
+        return false;
+    }
+
     private static ByteBuffer buildBound(Bound bound,
                                          Collection<CFDefinition.Name> names,
                                          Restriction[] restrictions,
@@ -986,9 +1000,12 @@ public class SelectStatement implements CQLStatement
                 }
                 // We only support IN for the last name so far
                 // TODO: #3885 allows us to extend to other parts (cf. #4762)
-                else if (restriction.eqValues.size() > 1 && i != stmt.columnRestrictions.length - 1)
+                else if (restriction.eqValues.size() > 1)
                 {
-                    throw new InvalidRequestException(String.format("PRIMARY KEY part %s cannot be restricted by IN relation", cname));
+                    if (i != stmt.columnRestrictions.length - 1)
+                        throw new InvalidRequestException(String.format("PRIMARY KEY part %s cannot be restricted by IN relation", cname));
+                    else if (stmt.selectACollection())
+                        throw new InvalidRequestException(String.format("Cannot restrict PRIMARY KEY part %s by IN relation as a collection is selected by the query", cname));
                 }
 
                 previous = cname;
