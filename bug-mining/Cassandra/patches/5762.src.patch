diff --git a/CHANGES.txt b/CHANGES.txt
index 82c8fa98eb..f906180abe 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 3.0.25:
+ * Ensure that existing empty rows are properly returned (CASSANDRA-16671)
  * Invalidate prepared statements on DROP COMPACT (CASSANDRA-16712)
  * Failure to execute queries should emit a KPI other than read timeout/unavailable so it can be alerted/tracked (CASSANDRA-16581)
  * Don't wait on schema versions from replacement target when replacing (CASSANDRA-16692)
diff --git a/src/java/org/apache/cassandra/db/SinglePartitionReadCommand.java b/src/java/org/apache/cassandra/db/SinglePartitionReadCommand.java
index 1e1953bdfc..d2ed3f25ea 100644
--- a/src/java/org/apache/cassandra/db/SinglePartitionReadCommand.java
+++ b/src/java/org/apache/cassandra/db/SinglePartitionReadCommand.java
@@ -995,8 +995,6 @@ public class SinglePartitionReadCommand extends ReadCommand
         NavigableSet<Clustering> clusterings = filter.requestedRows();
 
         // We want to remove rows for which we have values for all requested columns. We have to deal with both static and regular rows.
-        // TODO: we could also remove a selected column if we've found values for every requested row but we'll leave
-        // that for later.
 
         boolean removeStatic = false;
         if (!columns.statics.isEmpty())
@@ -1049,26 +1047,20 @@ public class SinglePartitionReadCommand extends ReadCommand
      */
     private boolean isRowComplete(Row row, Columns requestedColumns, long sstableTimestamp)
     {
+
         // Note that compact tables will always have an empty primary key liveness info.
-        if (!row.primaryKeyLivenessInfo().isEmpty() && row.primaryKeyLivenessInfo().timestamp() <= sstableTimestamp)
+        if (metadata().isCQLTable() && (row.primaryKeyLivenessInfo().isEmpty() || row.primaryKeyLivenessInfo().timestamp() <= sstableTimestamp))
             return false;
 
-        boolean hasLiveCell = false;
-
         for (ColumnDefinition column : requestedColumns)
         {
             Cell cell = row.getCell(column);
 
             if (cell == null || cell.timestamp() <= sstableTimestamp)
                 return false;
-
-            if (!cell.isTombstone())
-                hasLiveCell = true;
         }
 
-        // If we've gotten here w/ a compact table or at least one non-tombstone cell, the row is considered
-        // complete and we can avoid any further searching of older SSTables.
-        return hasLiveCell || !metadata().isCQLTable();
+        return true;
     }
 
     @Override
diff --git a/test/distributed/org/apache/cassandra/distributed/test/SinglePartitionReadCommandTest.java b/test/distributed/org/apache/cassandra/distributed/test/SinglePartitionReadCommandTest.java
new file mode 100644
index 0000000000..0b7b0e7543
--- /dev/null
+++ b/test/distributed/org/apache/cassandra/distributed/test/SinglePartitionReadCommandTest.java
@@ -0,0 +1,147 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.cassandra.distributed.test;
+
+import org.junit.Test;
+
+import org.apache.cassandra.distributed.Cluster;
+import org.apache.cassandra.distributed.api.ConsistencyLevel;
+
+import static org.apache.cassandra.distributed.shared.AssertUtils.assertRows;
+import static org.apache.cassandra.distributed.shared.AssertUtils.row;
+
+public class SinglePartitionReadCommandTest extends TestBaseImpl
+{
+    @Test
+    public void testNonCompactTableWithOnlyUpdatedColumnOnOneNodeAndColumnDeletionOnTheOther() throws Throwable
+    {
+        try (Cluster cluster = init(builder().withNodes(2).start()))
+        {
+            cluster.schemaChange(withKeyspace("CREATE TABLE %s.tbl (pk int, ck text, v1 int, v2 int, PRIMARY KEY (pk, ck)) WITH dclocal_read_repair_chance=0"));
+            cluster.get(1).executeInternal(withKeyspace("UPDATE %s.tbl USING TIMESTAMP 1000 SET v1 = 1, v2 = 2 WHERE pk = 1 AND ck = '1'"));
+            cluster.get(1).executeInternal(withKeyspace("UPDATE %s.tbl USING TIMESTAMP 1001 SET v1 = 1, v2 = 2 WHERE pk = 2 AND ck = '1'"));
+            cluster.get(1).flush(KEYSPACE);
+
+            cluster.get(2).executeInternal(withKeyspace("DELETE v1 FROM %s.tbl USING TIMESTAMP 2000 WHERE pk=1 AND ck='1'"));
+            cluster.get(2).executeInternal(withKeyspace("DELETE v1 FROM %s.tbl USING TIMESTAMP 2001 WHERE pk=2 AND ck='1'"));
+            cluster.get(2).flush(KEYSPACE);
+            cluster.get(2).executeInternal(withKeyspace("DELETE v2 FROM %s.tbl USING TIMESTAMP 3000 WHERE pk=2 AND ck='1'"));
+            cluster.get(2).flush(KEYSPACE);
+
+            assertRows(cluster.coordinator(2).execute(withKeyspace("SELECT * FROM %s.tbl WHERE pk=1 AND ck='1'"), ConsistencyLevel.ALL),
+                       row(1, "1", null, 2));
+            assertRows(cluster.coordinator(2).execute(withKeyspace("SELECT v1 FROM %s.tbl WHERE pk=1 AND ck='1'"), ConsistencyLevel.ALL),
+                       row((Integer) null));
+            assertRows(cluster.coordinator(2).execute(withKeyspace("SELECT v2 FROM %s.tbl WHERE pk=1 AND ck='1'"), ConsistencyLevel.ALL),
+                       row((Integer) 2));
+
+            assertRows(cluster.coordinator(2).execute(withKeyspace("SELECT * FROM %s.tbl WHERE pk=2 AND ck='1'"), ConsistencyLevel.ALL));
+            assertRows(cluster.coordinator(2).execute(withKeyspace("SELECT v1 FROM %s.tbl WHERE pk=2 AND ck='1'"), ConsistencyLevel.ALL));
+            assertRows(cluster.coordinator(2).execute(withKeyspace("SELECT v2 FROM %s.tbl WHERE pk=2 AND ck='1'"), ConsistencyLevel.ALL));
+        }
+    }
+
+    @Test
+    public void testNonCompactTableWithRowOnOneNodeAndColumnDeletionOnTheOther() throws Throwable
+    {
+        try (Cluster cluster = init(builder().withNodes(2).start()))
+        {
+            cluster.schemaChange(withKeyspace("CREATE TABLE %s.tbl (pk int, ck text, v int, PRIMARY KEY (pk, ck))"));
+            cluster.get(1).executeInternal(withKeyspace("INSERT INTO %s.tbl (pk, ck, v) VALUES (1, '1', 1) USING TIMESTAMP 1000"));
+            cluster.get(1).flush(KEYSPACE);
+            cluster.get(1).executeInternal(withKeyspace("UPDATE %s.tbl USING TIMESTAMP 2000 SET v = 2 WHERE pk = 1 AND ck = '1'"));
+            cluster.get(1).flush(KEYSPACE);
+
+            cluster.get(2).executeInternal(withKeyspace("DELETE v FROM %s.tbl USING TIMESTAMP 3000 WHERE pk=1 AND ck='1'"));
+            cluster.get(2).flush(KEYSPACE);
+
+            assertRows(cluster.coordinator(2).execute(withKeyspace("SELECT * FROM %s.tbl WHERE pk=1 AND ck='1'"), ConsistencyLevel.ALL),
+                       row(1, "1", null));
+            assertRows(cluster.coordinator(2).execute(withKeyspace("SELECT v FROM %s.tbl WHERE pk=1 AND ck='1'"), ConsistencyLevel.ALL),
+                       row((Integer) null));
+
+        }
+    }
+
+    @Test
+    public void testCompactTableWithRowOnOneNodeAndColumnDeletionOnTheOther() throws Throwable
+    {
+        try (Cluster cluster = init(builder().withNodes(2).start()))
+        {
+            cluster.schemaChange(withKeyspace("CREATE TABLE %s.tbl (pk int PRIMARY KEY, v1 int, v2 int) WITH COMPACT STORAGE"));
+            cluster.get(1).executeInternal(withKeyspace("INSERT INTO %s.tbl (pk, v1, v2) VALUES (1, 1, 1) USING TIMESTAMP 1000"));
+            cluster.get(1).flush(KEYSPACE);
+            cluster.get(1).executeInternal(withKeyspace("DELETE v1 FROM %s.tbl USING TIMESTAMP 3000 WHERE pk = 1"));
+            cluster.get(1).flush(KEYSPACE);
+
+            cluster.get(2).executeInternal(withKeyspace("INSERT INTO %s.tbl(pk, v1) VALUES (1, 2) USING TIMESTAMP 2000"));
+            cluster.get(2).flush(KEYSPACE);
+
+            assertRows(cluster.coordinator(2).execute(withKeyspace("SELECT * FROM %s.tbl WHERE pk=1"), ConsistencyLevel.ALL),
+                       row(1, null, 1));
+            assertRows(cluster.coordinator(2).execute(withKeyspace("SELECT v1, v2 FROM %s.tbl WHERE pk=1"), ConsistencyLevel.ALL),
+                       row((Integer) null, 1));
+            assertRows(cluster.coordinator(2).execute(withKeyspace("SELECT v1 FROM %s.tbl WHERE pk=1"), ConsistencyLevel.ALL),
+                       row((Integer) null));
+
+        }
+    }
+
+    @Test
+    public void testPartitionWithStaticColumnsOnlyOnOneNodeAndColumnDeletionOnTheOther() throws Throwable
+    {
+        try (Cluster cluster = init(builder().withNodes(2).start()))
+        {
+            cluster.schemaChange(withKeyspace("CREATE TABLE %s.tbl (pk int, ck int, s1 int static, s2 int static, v int, PRIMARY KEY (pk, ck)) WITH dclocal_read_repair_chance=0"));
+
+            cluster.get(1).executeInternal(withKeyspace("INSERT INTO %s.tbl (pk, s1, s2) VALUES (1, 1, 1) USING TIMESTAMP 1000"));
+            cluster.get(1).executeInternal(withKeyspace("INSERT INTO %s.tbl (pk, s1, s2) VALUES (2, 1, 1) USING TIMESTAMP 1001"));
+            cluster.get(1).flush(KEYSPACE);
+            cluster.get(1).executeInternal(withKeyspace("UPDATE %s.tbl USING TIMESTAMP 2000 SET s1 = 2 WHERE pk = 1"));
+            cluster.get(1).executeInternal(withKeyspace("UPDATE %s.tbl USING TIMESTAMP 2001 SET s1 = 2 WHERE pk = 2"));
+            cluster.get(1).flush(KEYSPACE);
+
+            cluster.get(2).executeInternal(withKeyspace("DELETE s1 FROM %s.tbl USING TIMESTAMP 3000 WHERE pk = 1"));
+            cluster.get(2).executeInternal(withKeyspace("DELETE s1 FROM %s.tbl USING TIMESTAMP 3001 WHERE pk = 2"));
+            cluster.get(2).flush(KEYSPACE);
+            cluster.get(2).executeInternal(withKeyspace("DELETE s2 FROM %s.tbl USING TIMESTAMP 4000 WHERE pk = 2"));
+            cluster.get(2).flush(KEYSPACE);
+
+            assertRows(cluster.coordinator(2).execute(withKeyspace("SELECT * FROM %s.tbl WHERE pk=1"), ConsistencyLevel.ALL),
+                       row(1, null, null, 1, null));
+            assertRows(cluster.coordinator(2).execute(withKeyspace("SELECT s1, s2 FROM %s.tbl WHERE pk=1"), ConsistencyLevel.ALL),
+                       row((Integer) null, 1));
+            assertRows(cluster.coordinator(2).execute(withKeyspace("SELECT DISTINCT s1, s2 FROM %s.tbl WHERE pk=1"), ConsistencyLevel.ALL),
+                       row((Integer) null, 1));
+            assertRows(cluster.coordinator(2).execute(withKeyspace("SELECT ck FROM %s.tbl WHERE pk=1"), ConsistencyLevel.ALL),
+                       row((Integer) null));
+            assertRows(cluster.coordinator(2).execute(withKeyspace("SELECT s1 FROM %s.tbl WHERE pk=1"), ConsistencyLevel.ALL),
+                       row((Integer) null));
+            assertRows(cluster.coordinator(2).execute(withKeyspace("SELECT DISTINCT s1 FROM %s.tbl WHERE pk=1"), ConsistencyLevel.ALL),
+                       row((Integer) null));
+
+            assertRows(cluster.coordinator(2).execute(withKeyspace("SELECT * FROM %s.tbl WHERE pk=2"), ConsistencyLevel.ALL));
+            assertRows(cluster.coordinator(2).execute(withKeyspace("SELECT s1, s2 FROM %s.tbl WHERE pk=2"), ConsistencyLevel.ALL));
+            assertRows(cluster.coordinator(2).execute(withKeyspace("SELECT DISTINCT s1, s2 FROM %s.tbl WHERE pk=2"), ConsistencyLevel.ALL));
+            assertRows(cluster.coordinator(2).execute(withKeyspace("SELECT ck FROM %s.tbl WHERE pk=2"), ConsistencyLevel.ALL));
+            assertRows(cluster.coordinator(2).execute(withKeyspace("SELECT s1 FROM %s.tbl WHERE pk=2"), ConsistencyLevel.ALL));
+            assertRows(cluster.coordinator(2).execute(withKeyspace("SELECT DISTINCT s1 FROM %s.tbl WHERE pk=2"), ConsistencyLevel.ALL));
+        }
+    }
+}
\ No newline at end of file
diff --git a/test/unit/org/apache/cassandra/cql3/validation/miscellaneous/SSTablesIteratedTest.java b/test/unit/org/apache/cassandra/cql3/validation/miscellaneous/SSTablesIteratedTest.java
index 2700d3090f..684f158dbd 100644
--- a/test/unit/org/apache/cassandra/cql3/validation/miscellaneous/SSTablesIteratedTest.java
+++ b/test/unit/org/apache/cassandra/cql3/validation/miscellaneous/SSTablesIteratedTest.java
@@ -106,13 +106,16 @@ public class SSTablesIteratedTest extends CQLTester
         executeAndCheck("SELECT * FROM %s WHERE pk = 2 AND c > 20", 2,
                         row(2, 40, "42"));
 
+        executeAndCheck("SELECT * FROM %s WHERE pk = 2 AND c > 20", 2,
+                        row(2, 40, "42"));
+
         executeAndCheck("SELECT * FROM %s WHERE pk = 2 AND c > 20 ORDER BY c DESC", 2,
                         row(2, 40, "42"));
 
         // Test with only 1 of the 3 SSTables being merged and a Name filter
         // This test checks the SinglePartitionReadCommand::queryMemtableAndSSTablesInTimestampOrder which is only
         // used for ClusteringIndexNamesFilter when there are no multi-cell columns
-        executeAndCheck("SELECT * FROM %s WHERE pk = 2 AND c = 10", 1,
+        executeAndCheck("SELECT * FROM %s WHERE pk = 2 AND c = 10", 2,
                         row(2, 10, "12"));
 
         // For partition range queries the metric must not be updated. The reason being that range queries simply
@@ -196,7 +199,7 @@ public class SSTablesIteratedTest extends CQLTester
         executeAndCheck("SELECT * FROM %s WHERE pk = 1 AND ck = 51", 1, row(1, 51, "5"));
 
         execute("ALTER TABLE %s DROP COMPACT STORAGE");
-        executeAndCheck("SELECT * FROM %s WHERE pk = 1 AND ck = 51", 1, row(1, 51, "5"));
+        executeAndCheck("SELECT * FROM %s WHERE pk = 1 AND ck = 51", 2, row(1, 51, "5"));
     }
 
     @Test
@@ -217,7 +220,27 @@ public class SSTablesIteratedTest extends CQLTester
         executeAndCheck("SELECT * FROM %s WHERE pk = 1 AND ck = 51", 1, row(1, 51));
 
         execute("ALTER TABLE %s DROP COMPACT STORAGE");
-        executeAndCheck("SELECT * FROM %s WHERE pk = 1 AND ck = 51", 1, row(1, 51, null));
+
+        // The fact that non-compact table insert do not have primary key liveness force us to hit an extra sstable
+        executeAndCheck("SELECT * FROM %s WHERE pk = 1 AND ck = 51", 2, row(1, 51, null));
+    }
+
+    @Test
+    public void testNonCompactTableSkippingPkOnly() throws Throwable
+    {
+        createTable("CREATE TABLE %s (pk int, ck int, PRIMARY KEY (pk, ck))");
+
+        execute("INSERT INTO %s (pk, ck) VALUES (1, 1) USING TIMESTAMP 1000000");
+        execute("INSERT INTO %s (pk, ck) VALUES (1, 50) USING TIMESTAMP 1000001");
+        execute("INSERT INTO %s (pk, ck) VALUES (1, 100) USING TIMESTAMP 1000002");
+        flush();
+
+        execute("INSERT INTO %s (pk, ck) VALUES (1, 2) USING TIMESTAMP 2000000");
+        execute("INSERT INTO %s (pk, ck) VALUES (1, 51) USING TIMESTAMP 2000001");
+        execute("INSERT INTO %s (pk, ck) VALUES (1, 101) USING TIMESTAMP 2000002");
+        flush();
+
+        executeAndCheck("SELECT * FROM %s WHERE pk = 1 AND ck = 51", 1, row(1, 51));
     }
 
     @Test
@@ -271,7 +294,6 @@ public class SSTablesIteratedTest extends CQLTester
         execute("DELETE FROM %s WHERE a=? AND b=?", 1, 1);
         flush();
 
-        // Even with a compact table, we can't short-circuit for a range deletion rather than a cell tombstone.
         executeAndCheck("SELECT * FROM %s WHERE a=1 AND b=1 AND c=1", 2);
 
         execute("ALTER TABLE %s DROP COMPACT STORAGE");
@@ -294,7 +316,6 @@ public class SSTablesIteratedTest extends CQLTester
         execute("DELETE FROM %s WHERE a=? AND b=?", 1, 1);
         flush();
 
-        // The range delete will subsume the row delete, and the latter will not factor into skipping decisions.
         executeAndCheck("SELECT * FROM %s WHERE a=1 AND b=1 AND c=1", 3);
 
         execute("ALTER TABLE %s DROP COMPACT STORAGE");
@@ -338,7 +359,21 @@ public class SSTablesIteratedTest extends CQLTester
         executeAndCheck("SELECT * FROM %s WHERE pk = 1 AND ck = 1", 1, row(1, 1, "2"));
 
         execute("ALTER TABLE %s DROP COMPACT STORAGE");
-        executeAndCheck("SELECT * FROM %s WHERE pk = 1 AND ck = 1", 1, row(1, 1, "2"));
+        executeAndCheck("SELECT * FROM %s WHERE pk = 1 AND ck = 1", 2, row(1, 1, "2"));
+    }
+
+    @Test
+    public void testNonCompactTableCellUpdate() throws Throwable
+    {
+        createTable("CREATE TABLE %s (pk int, ck int, v text, PRIMARY KEY (pk, ck))");
+
+        execute("INSERT INTO %s (pk, ck, v) VALUES (1, 1, '1')");
+        flush();
+
+        execute("UPDATE %s SET v = '2' WHERE pk = 1 AND ck = 1");
+        flush();
+
+        executeAndCheck("SELECT * FROM %s WHERE pk = 1 AND ck = 1", 2, row(1, 1, "2"));
     }
 
     @Test
@@ -363,4 +398,589 @@ public class SSTablesIteratedTest extends CQLTester
         execute("ALTER TABLE %s DROP COMPACT STORAGE");
         executeAndCheck("SELECT * FROM %s WHERE pk = 1 AND ck = 51", 3);
     }
+
+    @Test
+    public void testNonCompactTableWithClusteringColumnAndMultipleRegularColumnsAndNullColumn() throws Throwable
+    {
+        createTable("CREATE TABLE %s (pk int, c int, v1 int, v2 int, PRIMARY KEY(pk, c))");
+
+        execute("INSERT INTO %s (pk, c, v1) VALUES (?, ?, ?) USING TIMESTAMP 1000", 1, 1, 1);
+        execute("INSERT INTO %s (pk, c, v1) VALUES (?, ?, ?) USING TIMESTAMP 1001", 1, 2, 1);
+        execute("INSERT INTO %s (pk, c, v1) VALUES (?, ?, ?) USING TIMESTAMP 1002", 1, 3, 1);
+        flush();
+        execute("INSERT INTO %s (pk, c, v1) VALUES (?, ?, ?) USING TIMESTAMP 2000", 1, 1, 2);
+        execute("INSERT INTO %s (pk, c, v1) VALUES (?, ?, ?) USING TIMESTAMP 2001", 1, 2, 2);
+        execute("UPDATE %s USING TIMESTAMP 2002 SET v1 = ? WHERE pk = ? AND c = ?", 2, 1, 3);
+        flush();
+        execute("INSERT INTO %s (pk, c, v1) VALUES (?, ?, ?) USING TIMESTAMP 3000", 1, 1, 3);
+        execute("UPDATE %s USING TIMESTAMP 3001 SET v1 = ? WHERE pk = ? AND c = ?", 3, 1, 2);
+        execute("UPDATE %s USING TIMESTAMP 3002 SET v1 = ? WHERE pk = ? AND c = ?", 3, 1, 3);
+        flush();
+
+        executeAndCheck("SELECT * FROM %s WHERE pk = 1 AND c = 1", 3, row(1, 1, 3, null));
+        executeAndCheck("SELECT * FROM %s WHERE pk = 1 AND c = 2", 3, row(1, 2, 3, null));
+        executeAndCheck("SELECT * FROM %s WHERE pk = 1 AND c = 3", 3, row(1, 3, 3, null));
+
+        executeAndCheck("SELECT c, v1 FROM %s WHERE pk = 1 AND c = 1", 3, row(1, 3));
+        executeAndCheck("SELECT c, v1 FROM %s WHERE pk = 1 AND c = 2", 3, row(2, 3));
+        executeAndCheck("SELECT c, v1 FROM %s WHERE pk = 1 AND c = 3", 3, row(3, 3));
+
+        executeAndCheck("SELECT v1 FROM %s WHERE pk = 1 AND c = 1", 3, row(3));
+        executeAndCheck("SELECT v1 FROM %s WHERE pk = 1 AND c = 2", 3, row(3));
+        executeAndCheck("SELECT v1 FROM %s WHERE pk = 1 AND c = 3", 3, row(3));
+
+        executeAndCheck("SELECT v1, v2 FROM %s WHERE pk = 1 AND c = 1", 3, row(3, (Integer) null));
+        executeAndCheck("SELECT v1, v2 FROM %s WHERE pk = 1 AND c = 2", 3, row(3, (Integer) null));
+        executeAndCheck("SELECT v1, v2 FROM %s WHERE pk = 1 AND c = 3", 3, row(3, (Integer) null));
+
+        executeAndCheck("SELECT v2 FROM %s WHERE pk = 1 AND c = 1", 3, row((Integer) null));
+        executeAndCheck("SELECT v2 FROM %s WHERE pk = 1 AND c = 2", 3, row((Integer) null));
+        executeAndCheck("SELECT v2 FROM %s WHERE pk = 1 AND c = 3", 3, row((Integer) null));
+    }
+
+    @Test
+    public void testNonCompactTableWithClusteringColumnAndMultipleRegularColumns() throws Throwable
+    {
+        createTable("CREATE TABLE %s (pk int, c int, v1 int, v2 int, PRIMARY KEY(pk, c))");
+
+        execute("INSERT INTO %s (pk, c, v1, v2) VALUES (?, ?, ?, ?) USING TIMESTAMP 1000", 1, 1, 1, 1);
+        execute("INSERT INTO %s (pk, c, v1, v2) VALUES (?, ?, ?, ?) USING TIMESTAMP 1001", 1, 2, 1, 1);
+        execute("INSERT INTO %s (pk, c, v1, v2) VALUES (?, ?, ?, ?) USING TIMESTAMP 1002", 1, 3, 1, 1);
+        flush();
+        execute("INSERT INTO %s (pk, c, v1) VALUES (?, ?, ?) USING TIMESTAMP 2000", 1, 1, 2);
+        execute("INSERT INTO %s (pk, c, v1) VALUES (?, ?, ?) USING TIMESTAMP 2001", 1, 2, 2);
+        execute("UPDATE %s  USING TIMESTAMP 2002 SET v1 = ? WHERE pk = ? AND c = ?", 2, 1, 3);
+        flush();
+        execute("INSERT INTO %s (pk, c, v1) VALUES (?, ?, ?) USING TIMESTAMP 3000", 1, 1, 3);
+        execute("UPDATE %s USING TIMESTAMP 3001 SET v1 = ? WHERE pk = ? AND c = ?", 3, 1, 2);
+        execute("UPDATE %s USING TIMESTAMP 3002 SET v1 = ? WHERE pk = ? AND c = ?", 3, 1, 3);
+        flush();
+
+        executeAndCheck("SELECT * FROM %s WHERE pk = 1 AND c = 1", 3, row(1, 1, 3, 1));
+        executeAndCheck("SELECT * FROM %s WHERE pk = 1 AND c = 2", 3, row(1, 2, 3, 1));
+        executeAndCheck("SELECT * FROM %s WHERE pk = 1 AND c = 3", 3, row(1, 3, 3, 1));
+
+        executeAndCheck("SELECT c, v1 FROM %s WHERE pk = 1 AND c = 1", 3, row(1, 3));
+        executeAndCheck("SELECT c, v1 FROM %s WHERE pk = 1 AND c = 2", 3, row(2, 3));
+
+        executeAndCheck("SELECT v1 FROM %s WHERE pk = 1 AND c = 1", 3, row(3));
+        executeAndCheck("SELECT v1 FROM %s WHERE pk = 1 AND c = 2", 3, row(3));
+
+        executeAndCheck("SELECT v1, v2 FROM %s WHERE pk = 1 AND c = 1", 3, row(3, 1));
+        executeAndCheck("SELECT v1, v2 FROM %s WHERE pk = 1 AND c = 2", 3, row(3, 1));
+
+        executeAndCheck("SELECT v2 FROM %s WHERE pk = 1 AND c = 1", 3, row(1));
+        executeAndCheck("SELECT v2 FROM %s WHERE pk = 1 AND c = 2", 3, row(1));
+    }
+
+    @Test
+    public void testNonCompactTableWithStaticColumnValueMissing() throws Throwable
+    {
+        createTable("CREATE TABLE %s (pk int, c int, s int static, v int, PRIMARY KEY(pk, c))");
+
+        execute("INSERT INTO %s (pk, c, v) VALUES (?, ?, ?) USING TIMESTAMP 1000", 1, 1, 1);
+        execute("INSERT INTO %s (pk, c, s, v) VALUES (?, ?, ?, ?) USING TIMESTAMP 1001", 2, 2, 1, 1);
+        execute("INSERT INTO %s (pk, c, v) VALUES (?, ?, ?) USING TIMESTAMP 1001", 3, 3, 1);
+        flush();
+        execute("INSERT INTO %s (pk, c, v) VALUES (?, ?, ?) USING TIMESTAMP 2000", 1, 1, 2);
+        execute("INSERT INTO %s (pk, s) VALUES (?, ?) USING TIMESTAMP 2002", 3, 2);
+        flush();
+        execute("INSERT INTO %s (pk, c, v) VALUES (?, ?, ?) USING TIMESTAMP 3000", 1, 1, 3);
+        execute("UPDATE %s  USING TIMESTAMP 3001 SET v = ? WHERE pk = ? AND c = ?", 3, 2, 1);
+        execute("INSERT INTO %s (pk, s) VALUES (?, ?) USING TIMESTAMP 3002", 3, 3);
+        flush();
+
+        executeAndCheck("SELECT * FROM %s WHERE pk = 1 AND c = 1", 3, row(1, 1, null, 3));
+        executeAndCheck("SELECT * FROM %s WHERE pk = 2 AND c = 1", 2, row(2, 1, 1, 3));
+        executeAndCheck("SELECT * FROM %s WHERE pk = 3 AND c = 3", 3, row(3, 3, 3, 1));
+        executeAndCheck("SELECT s, v FROM %s WHERE pk = 1 AND c = 1", 3, row(null, 3));
+        executeAndCheck("SELECT s, v FROM %s WHERE pk = 2 AND c = 1", 2, row(1, 3));
+        executeAndCheck("SELECT s, v FROM %s WHERE pk = 3 AND c = 3", 3, row(3, 1));
+        executeAndCheck("SELECT v FROM %s WHERE pk = 1 AND c = 1", 3, row(3));
+        executeAndCheck("SELECT v FROM %s WHERE pk = 2 AND c = 1", 2, row(3));
+        executeAndCheck("SELECT v FROM %s WHERE pk = 3 AND c = 3", 3, row(1));
+        executeAndCheck("SELECT s FROM %s WHERE pk = 1", 3, row((Integer) null));
+        executeAndCheck("SELECT s FROM %s WHERE pk = 2", 2, row(1), row(1));
+        executeAndCheck("SELECT DISTINCT s FROM %s WHERE pk = 2", 2, row(1));
+        executeAndCheck("SELECT s FROM %s WHERE pk = 3", 3, row(3));
+        executeAndCheck("SELECT DISTINCT s FROM %s WHERE pk = 3", 3, row(3));
+    }
+
+    @Test
+    public void testNonCompactTableWithClusteringColumnAndNullColumn() throws Throwable
+    {
+        createTable("CREATE TABLE %s (pk int, c int, v int, PRIMARY KEY(pk, c))");
+
+        execute("INSERT INTO %s (pk, c) VALUES (?, ?) USING TIMESTAMP 1000", 1, 1);
+        execute("INSERT INTO %s (pk, c) VALUES (?, ?) USING TIMESTAMP 1001", 1, 2);
+        execute("INSERT INTO %s (pk, c) VALUES (?, ?) USING TIMESTAMP 1001", 1, 3);
+        flush();
+        execute("INSERT INTO %s (pk, c, v) VALUES (?, ?, ?) USING TIMESTAMP 2000", 1, 1, 2);
+        execute("INSERT INTO %s (pk, c) VALUES (?, ?) USING TIMESTAMP 2001", 1, 2);
+        execute("UPDATE %s USING TIMESTAMP 2002 SET v = ? WHERE pk = ? AND c = ?", 2, 1, 3);
+        flush();
+        execute("INSERT INTO %s (pk, c) VALUES (?, ?) USING TIMESTAMP 3000", 1, 1);
+        execute("INSERT INTO %s (pk, c) VALUES (?, ?) USING TIMESTAMP 3001", 1, 2);
+        execute("INSERT INTO %s (pk, c) VALUES (?, ?) USING TIMESTAMP 3002", 1, 3);
+        flush();
+
+        executeAndCheck("SELECT * FROM %s WHERE pk = 1 AND c = 1", 2, row(1, 1, 2));
+        executeAndCheck("SELECT c, v FROM %s WHERE pk = 1 AND c = 1", 2, row(1, 2));
+        executeAndCheck("SELECT v FROM %s WHERE pk = 1 AND c = 1", 2, row(2));
+
+        executeAndCheck("SELECT * FROM %s WHERE pk = 1 AND c = 2", 3, row(1, 2, (Integer) null));
+        executeAndCheck("SELECT c, v FROM %s WHERE pk = 1 AND c = 2", 3, row(2, (Integer) null));
+        executeAndCheck("SELECT v FROM %s WHERE pk = 1 AND c = 2", 3, row((Integer) null));
+
+        executeAndCheck("SELECT * FROM %s WHERE pk = 1 AND c = 3", 2, row(1, 3, 2));
+        executeAndCheck("SELECT c, v FROM %s WHERE pk = 1 AND c = 3", 2, row(3, 2));
+        executeAndCheck("SELECT v FROM %s WHERE pk = 1 AND c = 3", 2, row(2));
+    }
+
+    @Test
+    public void testNonCompactTableWithMulticellColumn() throws Throwable
+    {
+        createTable("CREATE TABLE %s (pk int, c int, v1 int, v2 int, s set<int>, PRIMARY KEY(pk, c))");
+
+        execute("INSERT INTO %s (pk, c, v1, s) VALUES (?, ?, ?, ?) USING TIMESTAMP 1000", 1, 1, 1, set(1, 2));
+        execute("INSERT INTO %s (pk, c, v1, s) VALUES (?, ?, ?, ?) USING TIMESTAMP 1001", 1, 2, 1, set(1, 2));
+        flush();
+        execute("INSERT INTO %s (pk, c, v1, s) VALUES (?, ?, ?, ?) USING TIMESTAMP 2000", 1, 1, 2, set(2, 3));
+        execute("UPDATE %s USING TIMESTAMP 2001 SET v1 = ?, s = ? WHERE pk = ? AND c = ?", 2, set(2, 3), 1, 2);
+        flush();
+        execute("INSERT INTO %s (pk, c, v1, s) VALUES (?, ?, ?, ?) USING TIMESTAMP 3000", 1, 1, 3, set(3, 4));
+        execute("UPDATE %s USING TIMESTAMP 3001 SET v1 = ?, s = ? WHERE pk = ? AND c = ?", 3, set(3, 4), 1, 2);
+        flush();
+
+        executeAndCheck("SELECT c, v1 FROM %s WHERE pk = 1 AND c = 1", 3, row(1, 3));
+        executeAndCheck("SELECT v1 FROM %s WHERE pk = 1 AND c = 1", 3, row(3));
+        executeAndCheck("SELECT * FROM %s WHERE pk = 1 AND c = 1", 3, row(1, 1, set(3, 4), 3, null));
+        executeAndCheck("SELECT c, s FROM %s WHERE pk = 1 AND c = 1", 3, row(1, set(3, 4)));
+
+        executeAndCheck("SELECT c, v1 FROM %s WHERE pk = 1 AND c = 2", 3, row(2, 3));
+        executeAndCheck("SELECT v1 FROM %s WHERE pk = 1 AND c = 2", 3, row(3));
+        executeAndCheck("SELECT * FROM %s WHERE pk = 1 AND c = 2", 3, row(1, 2, set(3, 4), 3, null));
+        executeAndCheck("SELECT c, s FROM %s WHERE pk = 1 AND c = 2", 3, row(2, set(3, 4)));
+    }
+
+    @Test
+    public void testNonCompactTableWithStaticColumnValueMissingAndMulticellColumn() throws Throwable
+    {
+        createTable("CREATE TABLE %s (pk int, c int, s int static, v set<int>, PRIMARY KEY(pk, c))");
+
+        execute("INSERT INTO %s (pk, c, v) VALUES (?, ?, ?) USING TIMESTAMP 1000", 1, 1, set(1));
+        execute("INSERT INTO %s (pk, c, s, v) VALUES (?, ?, ?, ?) USING TIMESTAMP 1001", 2, 2, 1, set(1));
+        execute("INSERT INTO %s (pk, c, v) VALUES (?, ?, ?) USING TIMESTAMP 1001", 3, 3, set(1));
+        flush();
+        execute("INSERT INTO %s (pk, c, v) VALUES (?, ?, ?) USING TIMESTAMP 2000", 1, 1, set(2));
+        execute("INSERT INTO %s (pk, s) VALUES (?, ?) USING TIMESTAMP 2002", 3, 2);
+        flush();
+        execute("INSERT INTO %s (pk, c, v) VALUES (?, ?, ?) USING TIMESTAMP 3000", 1, 1, set(3));
+        execute("UPDATE %s  USING TIMESTAMP 3001 SET v = ? WHERE pk = ? AND c = ?", set(3), 2, 1);
+        execute("INSERT INTO %s (pk, s) VALUES (?, ?) USING TIMESTAMP 3002", 3, 3);
+        flush();
+
+        executeAndCheck("SELECT * FROM %s WHERE pk = 1 AND c = 1", 3, row(1, 1, null, set(3)));
+        executeAndCheck("SELECT * FROM %s WHERE pk = 2 AND c = 1", 2, row(2, 1, 1, set(3)));
+        executeAndCheck("SELECT * FROM %s WHERE pk = 3 AND c = 3", 3, row(3, 3, 3, set(1)));
+        executeAndCheck("SELECT s, v FROM %s WHERE pk = 1 AND c = 1", 3, row(null, set(3)));
+        executeAndCheck("SELECT s, v FROM %s WHERE pk = 2 AND c = 1", 2, row(1, set(3)));
+        executeAndCheck("SELECT s, v FROM %s WHERE pk = 3 AND c = 3", 3, row(3, set(1)));
+        executeAndCheck("SELECT v FROM %s WHERE pk = 1 AND c = 1", 3, row(set(3)));
+        executeAndCheck("SELECT v FROM %s WHERE pk = 2 AND c = 1", 2, row(set(3)));
+        executeAndCheck("SELECT v FROM %s WHERE pk = 3 AND c = 3", 3, row(set(1)));
+        executeAndCheck("SELECT s FROM %s WHERE pk = 1", 3, row((Integer) null));
+        executeAndCheck("SELECT s FROM %s WHERE pk = 2", 2, row(1), row(1));
+        executeAndCheck("SELECT DISTINCT s FROM %s WHERE pk = 2", 2, row(1));
+        executeAndCheck("SELECT s FROM %s WHERE pk = 3", 3, row(3));
+        executeAndCheck("SELECT DISTINCT s FROM %s WHERE pk = 3", 3, row(3));
+    }
+
+    @Test
+    public void testNonCompactTableWithClusteringColumnAndMultipleRegularColumnsAndPartitionTombstones() throws Throwable
+    {
+        createTable("CREATE TABLE %s (pk int, c int, v1 int, v2 int, PRIMARY KEY(pk, c))");
+
+        execute("INSERT INTO %s (pk, c, v1, v2) VALUES (?, ?, ?, ?) USING TIMESTAMP 1000", 1, 1, 1, 1);
+        execute("INSERT INTO %s (pk, c, v1, v2) VALUES (?, ?, ?, ?) USING TIMESTAMP 1001", 2, 1, 1, 1);
+        execute("INSERT INTO %s (pk, c, v1, v2) VALUES (?, ?, ?, ?) USING TIMESTAMP 1002", 3, 1, 1, 1);
+        execute("INSERT INTO %s (pk, c, v1, v2) VALUES (?, ?, ?, ?) USING TIMESTAMP 1003", 4, 1, 1, 1);
+        flush();
+        execute("INSERT INTO %s (pk, c, v1) VALUES (?, ?, ?) USING TIMESTAMP 2000", 1, 1, 2);
+        execute("DELETE FROM %s USING TIMESTAMP 2001 WHERE pk = ?", 2);
+        execute("UPDATE %s USING TIMESTAMP 2002 SET v1 = ? WHERE pk = ? AND c = ?", 2, 3, 1);
+        execute("DELETE FROM %s USING TIMESTAMP 2003 WHERE pk = ?", 4);
+        flush();
+        execute("DELETE FROM %s USING TIMESTAMP 3000 WHERE pk = ?", 1);
+        execute("INSERT INTO %s (pk, c, v1) VALUES (?, ?, ?) USING TIMESTAMP 3001", 2, 1, 3);
+        execute("DELETE FROM %s USING TIMESTAMP 3002 WHERE pk = ?", 3);
+        execute("UPDATE %s USING TIMESTAMP 3003 SET v1 = ? WHERE pk = ? AND c = ?", 3, 4, 1);
+        flush();
+
+        executeAndCheck("SELECT * FROM %s WHERE pk = 1 AND c = 1", 1);
+        executeAndCheck("SELECT c, v1 FROM %s WHERE pk = 1 AND c = 1", 1);
+        executeAndCheck("SELECT v1, v2 FROM %s WHERE pk = 1 AND c = 1", 1);
+
+        executeAndCheck("SELECT * FROM %s WHERE pk = 2 AND c = 1", 2, row(2, 1, 3, null));
+        executeAndCheck("SELECT v1, v2 FROM %s WHERE pk = 2 AND c = 1", 2, row(3, null));
+        executeAndCheck("SELECT v2 FROM %s WHERE pk = 2 AND c = 1", 2, row((Integer) null));
+
+        executeAndCheck("SELECT * FROM %s WHERE pk = 3 AND c = 1", 1);
+        executeAndCheck("SELECT c, v1 FROM %s WHERE pk = 3 AND c = 1", 1);
+        executeAndCheck("SELECT v1, v2 FROM %s WHERE pk = 3 AND c = 1", 1);
+
+        executeAndCheck("SELECT * FROM %s WHERE pk = 4 AND c = 1", 2, row(4, 1, 3, null));
+        executeAndCheck("SELECT v1, v2 FROM %s WHERE pk = 4 AND c = 1", 2, row(3, null));
+        executeAndCheck("SELECT v2 FROM %s WHERE pk = 4 AND c = 1", 2, row((Integer) null));
+    }
+
+    @Test
+    public void testCompactAndNonCompactTableWithPartitionTombstones() throws Throwable
+    {
+        for (Boolean compact  : new Boolean[] {Boolean.FALSE, Boolean.TRUE})
+        {
+            String with = compact ? " WITH COMPACT STORAGE" : "";
+            createTable("CREATE TABLE %s (pk int PRIMARY KEY, v1 int, v2 int)" + with);
+
+            execute("INSERT INTO %s (pk, v1, v2) VALUES (?, ?, ?) USING TIMESTAMP 1000", 1, 1, 1);
+            execute("INSERT INTO %s (pk, v1, v2) VALUES (?, ?, ?) USING TIMESTAMP 1001", 2, 1, 1);
+            execute("INSERT INTO %s (pk, v1, v2) VALUES (?, ?, ?) USING TIMESTAMP 1002", 3, 1, 1);
+            execute("INSERT INTO %s (pk, v1, v2) VALUES (?, ?, ?) USING TIMESTAMP 1003", 4, 1, 1);
+            flush();
+            execute("INSERT INTO %s (pk, v1) VALUES (?, ?) USING TIMESTAMP 2000", 1, 2);
+            execute("DELETE FROM %s USING TIMESTAMP 2001 WHERE pk = ?", 2);
+            execute("UPDATE %s USING TIMESTAMP 2002 SET v1 = ? WHERE pk = ?", 2, 3);
+            execute("DELETE FROM %s USING TIMESTAMP 2003 WHERE pk = ?", 4);
+            flush();
+            execute("DELETE FROM %s USING TIMESTAMP 3000 WHERE pk = ?", 1);
+            execute("INSERT INTO %s (pk, v1) VALUES (?, ?) USING TIMESTAMP 3001", 2, 3);
+            execute("DELETE FROM %s USING TIMESTAMP 3002 WHERE pk = ?", 3);
+            execute("UPDATE %s USING TIMESTAMP 3003 SET v1 = ? WHERE pk = ?", 3, 4);
+            flush();
+
+            executeAndCheck("SELECT * FROM %s WHERE pk = 1", 1);
+            executeAndCheck("SELECT pk, v1 FROM %s WHERE pk = 1", 1);
+            executeAndCheck("SELECT v1, v2 FROM %s WHERE pk = 1", 1);
+
+            executeAndCheck("SELECT * FROM %s WHERE pk = 2", 2, row(2, 3, null));
+            executeAndCheck("SELECT v1, v2 FROM %s WHERE pk = 2", 2, row(3, null));
+            executeAndCheck("SELECT v2 FROM %s WHERE pk = 2", 2, row((Integer) null));
+
+            executeAndCheck("SELECT * FROM %s WHERE pk = 3", 1);
+            executeAndCheck("SELECT pk, v1 FROM %s WHERE pk = 3", 1);
+            executeAndCheck("SELECT v1, v2 FROM %s WHERE pk = 3", 1);
+
+            executeAndCheck("SELECT * FROM %s WHERE pk = 4", 2, row(4, 3, null));
+            executeAndCheck("SELECT v1, v2 FROM %s WHERE pk = 4", 2, row(3, null));
+            executeAndCheck("SELECT v2 FROM %s WHERE pk = 4", 2, row((Integer) null));
+
+            if (compact)
+            {
+                execute("ALTER TABLE %s DROP COMPACT STORAGE");
+                executeAndCheck("SELECT * FROM %s WHERE pk = 1", 1);
+                executeAndCheck("SELECT pk, v1 FROM %s WHERE pk = 1", 1);
+                executeAndCheck("SELECT v1, v2 FROM %s WHERE pk = 1", 1);
+
+                assertColumnNames(execute("SELECT * FROM %s WHERE pk = 1"), "pk", "column1", "v1", "v2", "value");
+                executeAndCheck("SELECT * FROM %s WHERE pk = 2", 2, row(2, null, 3, null, null));
+                executeAndCheck("SELECT v1, v2 FROM %s WHERE pk = 2", 2, row(3, null));
+                executeAndCheck("SELECT v2 FROM %s WHERE pk = 2", 2, row((Integer) null));
+
+                executeAndCheck("SELECT * FROM %s WHERE pk = 3", 1);
+                executeAndCheck("SELECT pk, v1 FROM %s WHERE pk = 3", 1);
+                executeAndCheck("SELECT v1, v2 FROM %s WHERE pk = 3", 1);
+
+                executeAndCheck("SELECT * FROM %s WHERE pk = 4", 2, row(4, null, 3, null, null));
+                executeAndCheck("SELECT v1, v2 FROM %s WHERE pk = 4", 2, row(3, null));
+                executeAndCheck("SELECT v2 FROM %s WHERE pk = 4", 2, row((Integer) null));
+            }
+        }
+    }
+
+    @Test
+    public void testNonCompactTableWithStaticColumnAndPartitionTombstones() throws Throwable
+    {
+        createTable("CREATE TABLE %s (pk int, c int, s int static, v int, PRIMARY KEY(pk, c))");
+
+        execute("INSERT INTO %s (pk, c, s, v) VALUES (?, ?, ?, ?) USING TIMESTAMP 1000", 1, 1, 1, 1);
+        execute("INSERT INTO %s (pk, c, s, v) VALUES (?, ?, ?, ?) USING TIMESTAMP 1001", 2, 1, 1, 1);
+        execute("INSERT INTO %s (pk, c, s, v) VALUES (?, ?, ?, ?) USING TIMESTAMP 1002", 3, 1, 1, 1);
+        execute("INSERT INTO %s (pk, c, s, v) VALUES (?, ?, ?, ?) USING TIMESTAMP 1003", 4, 1, 1, 1);
+        flush();
+        execute("INSERT INTO %s (pk, c, s) VALUES (?, ?, ?) USING TIMESTAMP 2000", 1, 1, 2);
+        execute("DELETE FROM %s USING TIMESTAMP 2001 WHERE pk = ?", 2);
+        execute("UPDATE %s USING TIMESTAMP 2002 SET s = ? WHERE pk = ?", 2, 3);
+        execute("DELETE FROM %s USING TIMESTAMP 2003 WHERE pk = ?", 4);
+        flush();
+        execute("DELETE FROM %s USING TIMESTAMP 3000 WHERE pk = ?", 1);
+        execute("INSERT INTO %s (pk, c, s) VALUES (?, ?, ?) USING TIMESTAMP 3001", 2, 1, 3);
+        execute("DELETE FROM %s USING TIMESTAMP 3002 WHERE pk = ?", 3);
+        execute("UPDATE %s USING TIMESTAMP 3003 SET s = ? WHERE pk = ?", 3, 4);
+        flush();
+
+        executeAndCheck("SELECT * FROM %s WHERE pk = 1 AND c = 1", 1);
+        executeAndCheck("SELECT s, v FROM %s WHERE pk = 1 AND c = 1", 1);
+        executeAndCheck("SELECT DISTINCT s FROM %s WHERE pk = 1", 1);
+        executeAndCheck("SELECT v FROM %s WHERE pk = 1 AND c = 1", 1);
+
+        executeAndCheck("SELECT * FROM %s WHERE pk = 2 AND c = 1", 2, row(2, 1, 3, null));
+        executeAndCheck("SELECT s, v FROM %s WHERE pk = 2 AND c = 1", 2, row(3, null));
+        executeAndCheck("SELECT DISTINCT s FROM %s WHERE pk = 2", 2, row(3));
+        executeAndCheck("SELECT v FROM %s WHERE pk = 2 AND c = 1", 2, row((Integer) null));
+
+        executeAndCheck("SELECT * FROM %s WHERE pk = 3 AND c = 1", 1);
+        executeAndCheck("SELECT s, v FROM %s WHERE pk = 3 AND c = 1", 1);
+        executeAndCheck("SELECT DISTINCT s FROM %s WHERE pk = 3", 1);
+        executeAndCheck("SELECT v FROM %s WHERE pk = 3 AND c = 1", 1);
+
+        executeAndCheck("SELECT * FROM %s WHERE pk = 4 AND c = 1", 2);
+        executeAndCheck("SELECT s, v FROM %s WHERE pk = 4 AND c = 1", 2);
+        executeAndCheck("SELECT DISTINCT s FROM %s WHERE pk = 4", 2, row(3));
+        executeAndCheck("SELECT v FROM %s WHERE pk = 4 AND c = 1", 2);
+    }
+
+    @Test
+    public void testNonCompactTableWithClusteringColumnAndMultipleRegularColumnsAndRowDeletion() throws Throwable
+    {
+        createTable("CREATE TABLE %s (pk int, c int, v1 int, v2 int, PRIMARY KEY(pk, c))");
+
+        execute("INSERT INTO %s (pk, c, v1, v2) VALUES (?, ?, ?, ?) USING TIMESTAMP 1000", 1, 1, 1, 1);
+        execute("INSERT INTO %s (pk, c, v1, v2) VALUES (?, ?, ?, ?) USING TIMESTAMP 1001", 2, 1, 1, 1);
+        execute("INSERT INTO %s (pk, c, v1, v2) VALUES (?, ?, ?, ?) USING TIMESTAMP 1002", 3, 1, 1, 1);
+        execute("INSERT INTO %s (pk, c, v1, v2) VALUES (?, ?, ?, ?) USING TIMESTAMP 1003", 4, 1, 1, 1);
+        flush();
+        execute("INSERT INTO %s (pk, c, v1) VALUES (?, ?, ?) USING TIMESTAMP 2000", 1, 1, 2);
+        execute("DELETE FROM %s USING TIMESTAMP 2001 WHERE pk = ? AND c = ? ", 2, 1);
+        execute("UPDATE %s USING TIMESTAMP 2002 SET v1 = ? WHERE pk = ? AND c = ?", 2, 3, 1);
+        execute("DELETE FROM %s USING TIMESTAMP 2003 WHERE pk = ? AND c = ? ", 4, 1);
+        flush();
+        execute("DELETE FROM %s USING TIMESTAMP 3000 WHERE pk = ? AND c = ?", 1, 1);
+        execute("INSERT INTO %s (pk, c, v1) VALUES (?, ?, ?) USING TIMESTAMP 3001", 2, 1, 3);
+        execute("DELETE FROM %s USING TIMESTAMP 3002 WHERE pk = ? AND c = ?", 3, 1);
+        execute("UPDATE %s USING TIMESTAMP 3003 SET v1 = ? WHERE pk = ? AND c = ?", 3, 4, 1);
+        flush();
+
+        executeAndCheck("SELECT * FROM %s WHERE pk = 1 AND c = 1", 3);
+        executeAndCheck("SELECT c, v1 FROM %s WHERE pk = 1 AND c = 1", 3);
+        executeAndCheck("SELECT v1, v2 FROM %s WHERE pk = 1 AND c = 1", 3);
+
+        executeAndCheck("SELECT * FROM %s WHERE pk = 2 AND c = 1", 3, row(2, 1, 3, null));
+        executeAndCheck("SELECT v1, v2 FROM %s WHERE pk = 2 AND c = 1", 3, row(3, null));
+        executeAndCheck("SELECT v2 FROM %s WHERE pk = 2 AND c = 1", 3, row((Integer) null));
+
+        executeAndCheck("SELECT * FROM %s WHERE pk = 3 AND c = 1", 3);
+        executeAndCheck("SELECT c, v1 FROM %s WHERE pk = 3 AND c = 1", 3);
+        executeAndCheck("SELECT v1, v2 FROM %s WHERE pk = 3 AND c = 1", 3);
+
+        executeAndCheck("SELECT * FROM %s WHERE pk = 4 AND c = 1", 3, row(4, 1, 3, null));
+        executeAndCheck("SELECT v1, v2 FROM %s WHERE pk = 4 AND c = 1", 3, row(3, null));
+        executeAndCheck("SELECT v2 FROM %s WHERE pk = 4 AND c = 1", 3, row((Integer) null));
+    }
+
+    @Test
+    public void testNonCompactTableWithClusteringColumnAndMultipleRegularColumnsAndRowRangeDeletion() throws Throwable
+    {
+        createTable("CREATE TABLE %s (pk int, c int, v1 int, v2 int, PRIMARY KEY(pk, c))");
+
+        execute("INSERT INTO %s (pk, c, v1, v2) VALUES (?, ?, ?, ?) USING TIMESTAMP 1000", 1, 1, 1, 1);
+        execute("INSERT INTO %s (pk, c, v1, v2) VALUES (?, ?, ?, ?) USING TIMESTAMP 1001", 2, 1, 1, 1);
+        execute("INSERT INTO %s (pk, c, v1, v2) VALUES (?, ?, ?, ?) USING TIMESTAMP 1002", 3, 1, 1, 1);
+        execute("INSERT INTO %s (pk, c, v1, v2) VALUES (?, ?, ?, ?) USING TIMESTAMP 1003", 4, 1, 1, 1);
+        flush();
+        execute("INSERT INTO %s (pk, c, v1) VALUES (?, ?, ?) USING TIMESTAMP 2000", 1, 1, 2);
+        execute("DELETE FROM %s USING TIMESTAMP 2001 WHERE pk = ? AND c >= ? ", 2, 1);
+        execute("UPDATE %s USING TIMESTAMP 2002 SET v1 = ? WHERE pk = ? AND c = ?", 2, 3, 1);
+        execute("DELETE FROM %s USING TIMESTAMP 2003 WHERE pk = ? AND c >= ? ", 4, 1);
+        flush();
+        execute("DELETE FROM %s USING TIMESTAMP 3000 WHERE pk = ? AND c <= ?", 1, 1);
+        execute("INSERT INTO %s (pk, c, v1) VALUES (?, ?, ?) USING TIMESTAMP 3001", 2, 1, 3);
+        execute("DELETE FROM %s USING TIMESTAMP 3002 WHERE pk = ? AND c <= ?", 3, 1);
+        execute("UPDATE %s USING TIMESTAMP 3003 SET v1 = ? WHERE pk = ? AND c = ?", 3, 4, 1);
+        flush();
+
+        executeAndCheck("SELECT * FROM %s WHERE pk = 1 AND c = 1", 3);
+        executeAndCheck("SELECT c, v1 FROM %s WHERE pk = 1 AND c = 1", 3);
+        executeAndCheck("SELECT v1, v2 FROM %s WHERE pk = 1 AND c = 1", 3);
+
+        executeAndCheck("SELECT * FROM %s WHERE pk = 2 AND c = 1", 3, row(2, 1, 3, null));
+        executeAndCheck("SELECT v1, v2 FROM %s WHERE pk = 2 AND c = 1", 3, row(3, null));
+        executeAndCheck("SELECT v2 FROM %s WHERE pk = 2 AND c = 1", 3, row((Integer) null));
+
+        executeAndCheck("SELECT * FROM %s WHERE pk = 3 AND c = 1", 3);
+        executeAndCheck("SELECT c, v1 FROM %s WHERE pk = 3 AND c = 1", 3);
+        executeAndCheck("SELECT v1, v2 FROM %s WHERE pk = 3 AND c = 1", 3);
+
+        executeAndCheck("SELECT * FROM %s WHERE pk = 4 AND c = 1", 3, row(4, 1, 3, null));
+        executeAndCheck("SELECT v1, v2 FROM %s WHERE pk = 4 AND c = 1", 3, row(3, null));
+        executeAndCheck("SELECT v2 FROM %s WHERE pk = 4 AND c = 1", 3, row((Integer) null));
+    }
+
+    @Test
+    public void testNonCompactTableWithClusteringColumnAndMultipleRegularColumnsAndColumnDeletion() throws Throwable
+    {
+        createTable("CREATE TABLE %s (pk int, c int, v1 int, v2 int, PRIMARY KEY(pk, c))");
+
+        execute("INSERT INTO %s (pk, c, v1, v2) VALUES (?, ?, ?, ?) USING TIMESTAMP 1000", 1, 1, 1, 1);
+        execute("INSERT INTO %s (pk, c, v1, v2) VALUES (?, ?, ?, ?) USING TIMESTAMP 1001", 2, 1, 1, 1);
+        execute("INSERT INTO %s (pk, c, v1, v2) VALUES (?, ?, ?, ?) USING TIMESTAMP 1002", 3, 1, 1, 1);
+        execute("INSERT INTO %s (pk, c, v1, v2) VALUES (?, ?, ?, ?) USING TIMESTAMP 1003", 4, 1, 1, 1);
+        flush();
+        execute("INSERT INTO %s (pk, c, v1) VALUES (?, ?, ?) USING TIMESTAMP 2000", 1, 1, 2);
+        execute("DELETE v2 FROM %s USING TIMESTAMP 2001 WHERE pk = ? AND c = ?", 2, 1);
+        execute("UPDATE %s USING TIMESTAMP 2002 SET v1 = ? WHERE pk = ? AND c = ?", 2, 3, 1);
+        execute("DELETE v2 FROM %s USING TIMESTAMP 2003 WHERE pk = ? AND c = ?", 4, 1);
+        flush();
+        execute("DELETE v1 FROM %s USING TIMESTAMP 3000 WHERE pk = ? AND c = ?", 1, 1);
+        execute("INSERT INTO %s (pk, c, v1) VALUES (?, ?, ?) USING TIMESTAMP 3001", 2, 1, 3);
+        execute("DELETE v1 FROM %s USING TIMESTAMP 3002 WHERE pk = ? AND c = ?", 3, 1);
+        execute("UPDATE %s USING TIMESTAMP 3003 SET v1 = ? WHERE pk = ? AND c = ?", 3, 4, 1);
+        flush();
+
+        executeAndCheck("SELECT * FROM %s WHERE pk = 1 AND c = 1", 3, row(1, 1, null, 1));
+        executeAndCheck("SELECT c, v1 FROM %s WHERE pk = 1 AND c = 1", 3, row(1, null));
+        executeAndCheck("SELECT v1 FROM %s WHERE pk = 1 AND c = 1", 3, row((Integer) null));
+
+        executeAndCheck("SELECT * FROM %s WHERE pk = 2 AND c = 1", 2, row(2, 1, 3, null));
+        executeAndCheck("SELECT v1, v2 FROM %s WHERE pk = 2 AND c = 1", 2, row(3, null));
+        executeAndCheck("SELECT v2 FROM %s WHERE pk = 2 AND c = 1", 2, row((Integer) null));
+
+        executeAndCheck("SELECT * FROM %s WHERE pk = 3 AND c = 1", 3, row(3, 1, null, 1));
+        executeAndCheck("SELECT c, v1 FROM %s WHERE pk = 3 AND c = 1", 3, row(1, null));
+        executeAndCheck("SELECT v1 FROM %s WHERE pk = 3 AND c = 1", 3, row((Integer) null));
+
+        executeAndCheck("SELECT * FROM %s WHERE pk = 4 AND c = 1", 3, row(4, 1, 3, null));
+        executeAndCheck("SELECT v1, v2 FROM %s WHERE pk = 4 AND c = 1", 3, row(3, null));
+        executeAndCheck("SELECT v2 FROM %s WHERE pk = 4 AND c = 1", 3, row((Integer) null));
+    }
+
+    @Test
+    public void testNonCompactTableWithClusteringColumnAndColumnDeletion() throws Throwable
+    {
+        createTable("CREATE TABLE %s (pk int, c int, v int, PRIMARY KEY(pk, c))");
+
+        execute("INSERT INTO %s (pk, c, v) VALUES (?, ?, ?) USING TIMESTAMP 2000", 1, 1, 2);
+        flush();
+        execute("DELETE v FROM %s USING TIMESTAMP 3000 WHERE pk = ? AND c = ?", 1, 1);
+        flush();
+
+        executeAndCheck("SELECT * FROM %s WHERE pk = 1 AND c = 1", 2, row(1, 1, null));
+        executeAndCheck("SELECT c, v FROM %s WHERE pk = 1 AND c = 1", 2, row(1, null));
+        executeAndCheck("SELECT v FROM %s WHERE pk = 1 AND c = 1", 2, row((Integer) null));
+    }
+
+    @Test
+    public void testCompactTableWithClusteringColumnAndColumnDeletion() throws Throwable
+    {
+        createTable("CREATE TABLE %s (pk int, c int, v int, PRIMARY KEY(pk, c)) WITH COMPACT STORAGE");
+
+        execute("INSERT INTO %s (pk, c, v) VALUES (?, ?, ?) USING TIMESTAMP 2000", 1, 1, 2);
+        flush();
+        execute("DELETE v FROM %s USING TIMESTAMP 3000 WHERE pk = ? AND c = ?", 1, 1);
+        flush();
+
+        executeAndCheck("SELECT * FROM %s WHERE pk = 1 AND c = 1", 1);
+        executeAndCheck("SELECT c, v FROM %s WHERE pk = 1 AND c = 1", 1);
+        executeAndCheck("SELECT v FROM %s WHERE pk = 1 AND c = 1", 1);
+
+        execute("ALTER TABLE %s DROP COMPACT STORAGE");
+
+        executeAndCheck("SELECT * FROM %s WHERE pk = 1 AND c = 1", 2);
+        executeAndCheck("SELECT c, v FROM %s WHERE pk = 1 AND c = 1", 2);
+        executeAndCheck("SELECT v FROM %s WHERE pk = 1 AND c = 1", 2);
+    }
+
+    @Test
+    public void testNonCompactTableWithMultipleRegularColumnsAndColumnDeletion() throws Throwable
+    {
+        createTable("CREATE TABLE %s (pk int PRIMARY KEY, v1 int, v2 int)");
+
+        execute("INSERT INTO %s (pk, v1, v2) VALUES (?, ?, ?) USING TIMESTAMP 1000", 1, 1, 1);
+        execute("INSERT INTO %s (pk, v1, v2) VALUES (?, ?, ?) USING TIMESTAMP 1001", 2, 1, 1);
+        execute("INSERT INTO %s (pk, v1, v2) VALUES (?, ?, ?) USING TIMESTAMP 1002", 3, 1, 1);
+        execute("INSERT INTO %s (pk, v1, v2) VALUES (?, ?, ?) USING TIMESTAMP 1003", 4, 1, 1);
+        flush();
+        execute("INSERT INTO %s (pk, v1) VALUES (?, ?) USING TIMESTAMP 2000", 1, 2);
+        execute("DELETE v2 FROM %s USING TIMESTAMP 2001 WHERE pk = ?", 2);
+        execute("UPDATE %s USING TIMESTAMP 2003 SET v1 = ? WHERE pk = ?", 2, 3);
+        execute("DELETE v2 FROM %s USING TIMESTAMP 2004 WHERE pk = ?", 4);
+        flush();
+        execute("DELETE v1 FROM %s USING TIMESTAMP 3000 WHERE pk = ?", 1);
+        execute("INSERT INTO %s (pk, v1) VALUES (?, ?) USING TIMESTAMP 3001", 2, 3);
+        execute("DELETE v1 FROM %s USING TIMESTAMP 3002 WHERE pk = ?", 3);
+        execute("UPDATE %s USING TIMESTAMP 3004 SET v1 = ? WHERE pk = ?", 3, 4);
+        flush();
+
+        executeAndCheck("SELECT * FROM %s WHERE pk = 1", 3, row(1, null, 1));
+        executeAndCheck("SELECT v1, v2 FROM %s WHERE pk = 1", 3, row((Integer) null, 1));
+        executeAndCheck("SELECT v1 FROM %s WHERE pk = 1", 3, row((Integer) null));
+
+        executeAndCheck("SELECT * FROM %s WHERE pk = 2", 2, row(2, 3, null));
+        executeAndCheck("SELECT v1, v2 FROM %s WHERE pk = 2", 2, row(3, null));
+        executeAndCheck("SELECT v2 FROM %s WHERE pk = 2", 2, row((Integer) null));
+
+        executeAndCheck("SELECT * FROM %s WHERE pk = 3", 3, row(3, null, 1));
+        executeAndCheck("SELECT v1, v2 FROM %s WHERE pk = 3", 3, row((Integer) null, 1));
+        executeAndCheck("SELECT v1 FROM %s WHERE pk = 3", 3, row((Integer) null));
+
+        executeAndCheck("SELECT * FROM %s WHERE pk = 4", 3, row(4, 3, null));
+        executeAndCheck("SELECT v1, v2 FROM %s WHERE pk = 4", 3, row(3, null));
+        executeAndCheck("SELECT v2 FROM %s WHERE pk = 4", 3, row((Integer) null));
+    }
+
+    @Test
+    public void testCompactTableWithMultipleRegularColumnsAndColumnDeletion() throws Throwable
+    {
+        createTable("CREATE TABLE %s (pk int PRIMARY KEY, v1 int, v2 int) WITH COMPACT STORAGE");
+
+        execute("INSERT INTO %s (pk, v1, v2) VALUES (?, ?, ?) USING TIMESTAMP 1000", 1, 1, 1);
+        execute("INSERT INTO %s (pk, v1, v2) VALUES (?, ?, ?) USING TIMESTAMP 1001", 2, 1, 1);
+        execute("INSERT INTO %s (pk, v1, v2) VALUES (?, ?, ?) USING TIMESTAMP 1002", 3, 1, 1);
+        execute("INSERT INTO %s (pk, v1, v2) VALUES (?, ?, ?) USING TIMESTAMP 1003", 4, 1, 1);
+        flush();
+        execute("INSERT INTO %s (pk, v1) VALUES (?, ?) USING TIMESTAMP 2000", 1, 2);
+        execute("DELETE v2 FROM %s USING TIMESTAMP 2001 WHERE pk = ?", 2);
+        execute("UPDATE %s USING TIMESTAMP 2003 SET v1 = ? WHERE pk = ?", 2, 3);
+        execute("DELETE v2 FROM %s USING TIMESTAMP 2004 WHERE pk = ?", 4);
+        flush();
+        execute("DELETE v1 FROM %s USING TIMESTAMP 3000 WHERE pk = ?", 1);
+        execute("INSERT INTO %s (pk, v1) VALUES (?, ?) USING TIMESTAMP 3001", 2, 3);
+        execute("DELETE v1 FROM %s USING TIMESTAMP 3002 WHERE pk = ?", 3);
+        execute("UPDATE %s USING TIMESTAMP 3004 SET v1 = ? WHERE pk = ?", 3, 4);
+        flush();
+
+        executeAndCheck("SELECT * FROM %s WHERE pk = 1", 3, row(1, null, 1));
+        executeAndCheck("SELECT v1, v2 FROM %s WHERE pk = 1", 3, row((Integer) null, 1));
+        executeAndCheck("SELECT v1 FROM %s WHERE pk = 1", 3, row((Integer) null));
+
+        executeAndCheck("SELECT * FROM %s WHERE pk = 2", 2, row(2, 3, null));
+        executeAndCheck("SELECT v1, v2 FROM %s WHERE pk = 2", 2, row(3, null));
+        executeAndCheck("SELECT v2 FROM %s WHERE pk = 2", 2, row((Integer) null));
+
+        executeAndCheck("SELECT * FROM %s WHERE pk = 3", 3, row(3, null, 1));
+        executeAndCheck("SELECT v1, v2 FROM %s WHERE pk = 3", 3, row((Integer) null, 1));
+        executeAndCheck("SELECT v1 FROM %s WHERE pk = 3", 3, row((Integer) null));
+
+        executeAndCheck("SELECT * FROM %s WHERE pk = 4", 2, row(4, 3, null));
+        executeAndCheck("SELECT v1, v2 FROM %s WHERE pk = 4", 2, row(3, null));
+        executeAndCheck("SELECT v2 FROM %s WHERE pk = 4", 2, row((Integer) null));
+
+        execute("ALTER TABLE %s DROP COMPACT STORAGE");
+
+        assertColumnNames(execute("SELECT * FROM %s WHERE pk = 1"), "pk", "column1", "v1", "v2", "value");
+        executeAndCheck("SELECT * FROM %s WHERE pk = 1", 3, row(1, null, null, 1, null));
+        executeAndCheck("SELECT v1, v2 FROM %s WHERE pk = 1", 3, row((Integer) null, 1));
+        executeAndCheck("SELECT v1 FROM %s WHERE pk = 1", 3, row((Integer) null));
+
+        executeAndCheck("SELECT * FROM %s WHERE pk = 2", 3, row(2, null, 3, null, null));
+        executeAndCheck("SELECT v1, v2 FROM %s WHERE pk = 2", 3, row(3, null));
+        executeAndCheck("SELECT v2 FROM %s WHERE pk = 2", 3, row((Integer) null));
+
+        executeAndCheck("SELECT * FROM %s WHERE pk = 3", 3, row(3, null, null, 1, null));
+        executeAndCheck("SELECT v1, v2 FROM %s WHERE pk = 3", 3, row((Integer) null, 1));
+        executeAndCheck("SELECT v1 FROM %s WHERE pk = 3", 3, row((Integer) null));
+
+        executeAndCheck("SELECT * FROM %s WHERE pk = 4", 3, row(4, null, 3, null, null));
+        executeAndCheck("SELECT v1, v2 FROM %s WHERE pk = 4", 3, row(3, null));
+        executeAndCheck("SELECT v2 FROM %s WHERE pk = 4", 3, row((Integer) null));
+    }
 }
