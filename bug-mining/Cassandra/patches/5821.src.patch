diff --git a/CHANGES.txt b/CHANGES.txt
index 7485920b24..2f3543f51e 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 3.11.12
+ * Validate SASI tokenizer options before adding index to schema (CASSANDRA-15135)
  * Fixup scrub output when no data post-scrub and clear up old use of row, which really means partition (CASSANDRA-16835)
  * Fix ant-junit dependency issue (CASSANDRA-16827)
  * Reduce thread contention in CommitLogSegment and HintsBuffer (CASSANDRA-16072)
diff --git a/src/java/org/apache/cassandra/index/sasi/analyzer/AbstractAnalyzer.java b/src/java/org/apache/cassandra/index/sasi/analyzer/AbstractAnalyzer.java
index e3bb7a28a2..8630c67e49 100644
--- a/src/java/org/apache/cassandra/index/sasi/analyzer/AbstractAnalyzer.java
+++ b/src/java/org/apache/cassandra/index/sasi/analyzer/AbstractAnalyzer.java
@@ -22,7 +22,9 @@ import java.text.Normalizer;
 import java.util.Iterator;
 import java.util.Map;
 
+import org.apache.cassandra.config.ColumnDefinition;
 import org.apache.cassandra.db.marshal.AbstractType;
+import org.apache.cassandra.exceptions.ConfigurationException;
 
 public abstract class AbstractAnalyzer implements Iterator<ByteBuffer>
 {
@@ -38,17 +40,25 @@ public abstract class AbstractAnalyzer implements Iterator<ByteBuffer>
         throw new UnsupportedOperationException();
     }
 
-    public abstract void init(Map<String, String> options, AbstractType validator);
+    public void validate(Map<String, String> options, ColumnDefinition cd) throws ConfigurationException
+    {
+        if (!isCompatibleWith(cd.type))
+            throw new ConfigurationException(String.format("%s does not support type %s",
+                                                           this.getClass().getSimpleName(),
+                                                           cd.type.asCQL3Type()));
+    }
+
+    public abstract void init(Map<String, String> options, AbstractType<?> validator);
 
     public abstract void reset(ByteBuffer input);
 
     /**
      * Test whether the given validator is compatible with the underlying analyzer.
      *
-     * @param validator
-     * @return
+     * @param validator the validator to test the compatibility with
+     * @return true if the give validator is compatible, false otherwise
      */
-    public abstract boolean isCompatibleWith(AbstractType<?> validator);
+    protected abstract boolean isCompatibleWith(AbstractType<?> validator);
 
     /**
      * @return true if current analyzer provides text tokenization, false otherwise.
diff --git a/src/java/org/apache/cassandra/index/sasi/analyzer/DelimiterAnalyzer.java b/src/java/org/apache/cassandra/index/sasi/analyzer/DelimiterAnalyzer.java
index fea4b4f042..05dfedc6c4 100644
--- a/src/java/org/apache/cassandra/index/sasi/analyzer/DelimiterAnalyzer.java
+++ b/src/java/org/apache/cassandra/index/sasi/analyzer/DelimiterAnalyzer.java
@@ -51,19 +51,16 @@ public class DelimiterAnalyzer extends AbstractAnalyzer
     {
     }
 
+    @Override
     public ByteBuffer next()
     {
         return iter.next();
     }
 
-    public void init(Map<String, String> options, AbstractType validator)
+    public void init(Map<String, String> options, AbstractType<?> validator)
     {
         DelimiterTokenizingOptions tokenizingOptions = DelimiterTokenizingOptions.buildFromMap(options);
         delimiter = tokenizingOptions.getDelimiter();
-
-        if (!VALID_ANALYZABLE_TYPES.containsKey(validator))
-            throw new IllegalArgumentException(String.format("Only text types supported, got %s", validator));
-
         charset = VALID_ANALYZABLE_TYPES.get(validator);
     }
 
@@ -100,7 +97,7 @@ public class DelimiterAnalyzer extends AbstractAnalyzer
         };
     }
 
-
+    @Override
     public boolean isTokenizing()
     {
         return true;
diff --git a/src/java/org/apache/cassandra/index/sasi/analyzer/NoOpAnalyzer.java b/src/java/org/apache/cassandra/index/sasi/analyzer/NoOpAnalyzer.java
index 5c9b748dfd..1a42789791 100644
--- a/src/java/org/apache/cassandra/index/sasi/analyzer/NoOpAnalyzer.java
+++ b/src/java/org/apache/cassandra/index/sasi/analyzer/NoOpAnalyzer.java
@@ -31,7 +31,7 @@ public class NoOpAnalyzer extends AbstractAnalyzer
     private ByteBuffer input;
     private boolean hasNext = false;
 
-    public void init(Map<String, String> options, AbstractType validator)
+    public void init(Map<String, String> options, AbstractType<?> validator)
     {}
 
     public boolean hasNext()
diff --git a/src/java/org/apache/cassandra/index/sasi/analyzer/NonTokenizingAnalyzer.java b/src/java/org/apache/cassandra/index/sasi/analyzer/NonTokenizingAnalyzer.java
index 82084bcddb..30c8506b16 100644
--- a/src/java/org/apache/cassandra/index/sasi/analyzer/NonTokenizingAnalyzer.java
+++ b/src/java/org/apache/cassandra/index/sasi/analyzer/NonTokenizingAnalyzer.java
@@ -22,6 +22,8 @@ import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
 
+import org.apache.cassandra.config.ColumnDefinition;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.index.sasi.analyzer.filter.BasicResultFilters;
 import org.apache.cassandra.index.sasi.analyzer.filter.FilterPipelineBuilder;
 import org.apache.cassandra.index.sasi.analyzer.filter.FilterPipelineExecutor;
@@ -49,19 +51,30 @@ public class NonTokenizingAnalyzer extends AbstractAnalyzer
             add(AsciiType.instance);
     }};
 
-    private AbstractType validator;
+    private AbstractType<?> validator;
     private NonTokenizingOptions options;
     private FilterPipelineTask filterPipeline;
 
     private ByteBuffer input;
     private boolean hasNext = false;
 
-    public void init(Map<String, String> options, AbstractType validator)
+    @Override
+    public void validate(Map<String, String> options, ColumnDefinition cd) throws ConfigurationException
+    {
+        super.validate(options, cd);
+        if (options.containsKey(NonTokenizingOptions.CASE_SENSITIVE) &&
+            (options.containsKey(NonTokenizingOptions.NORMALIZE_LOWERCASE)
+             || options.containsKey(NonTokenizingOptions.NORMALIZE_UPPERCASE)))
+            throw new ConfigurationException("case_sensitive option cannot be specified together " +
+                                               "with either normalize_lowercase or normalize_uppercase");
+    }
+
+    public void init(Map<String, String> options, AbstractType<?> validator)
     {
         init(NonTokenizingOptions.buildFromMap(options), validator);
     }
 
-    public void init(NonTokenizingOptions tokenizerOptions, AbstractType validator)
+    public void init(NonTokenizingOptions tokenizerOptions, AbstractType<?> validator)
     {
         this.validator = validator;
         this.options = tokenizerOptions;
diff --git a/src/java/org/apache/cassandra/index/sasi/analyzer/NonTokenizingOptions.java b/src/java/org/apache/cassandra/index/sasi/analyzer/NonTokenizingOptions.java
index 303087bf0c..d7830287e4 100644
--- a/src/java/org/apache/cassandra/index/sasi/analyzer/NonTokenizingOptions.java
+++ b/src/java/org/apache/cassandra/index/sasi/analyzer/NonTokenizingOptions.java
@@ -105,11 +105,6 @@ public class NonTokenizingOptions
     {
         OptionsBuilder optionsBuilder = new OptionsBuilder();
 
-        if (optionsMap.containsKey(CASE_SENSITIVE) && (optionsMap.containsKey(NORMALIZE_LOWERCASE)
-                || optionsMap.containsKey(NORMALIZE_UPPERCASE)))
-            throw new IllegalArgumentException("case_sensitive option cannot be specified together " +
-                    "with either normalize_lowercase or normalize_uppercase");
-
         for (Map.Entry<String, String> entry : optionsMap.entrySet())
         {
             switch (entry.getKey())
diff --git a/src/java/org/apache/cassandra/index/sasi/analyzer/StandardAnalyzer.java b/src/java/org/apache/cassandra/index/sasi/analyzer/StandardAnalyzer.java
index e1a4a44b04..3156156221 100644
--- a/src/java/org/apache/cassandra/index/sasi/analyzer/StandardAnalyzer.java
+++ b/src/java/org/apache/cassandra/index/sasi/analyzer/StandardAnalyzer.java
@@ -87,7 +87,7 @@ public class StandardAnalyzer extends AbstractAnalyzer
         }
     }
 
-    private AbstractType validator;
+    private AbstractType<?> validator;
 
     private StandardTokenizerInterface scanner;
     private StandardTokenizerOptions options;
@@ -148,7 +148,7 @@ public class StandardAnalyzer extends AbstractAnalyzer
         return builder.build();
     }
 
-    public void init(Map<String, String> options, AbstractType validator)
+    public void init(Map<String, String> options, AbstractType<?> validator)
     {
         init(StandardTokenizerOptions.buildFromMap(options), validator);
     }
@@ -159,7 +159,7 @@ public class StandardAnalyzer extends AbstractAnalyzer
         init(options, UTF8Type.instance);
     }
 
-    public void init(StandardTokenizerOptions tokenizerOptions, AbstractType validator)
+    public void init(StandardTokenizerOptions tokenizerOptions, AbstractType<?> validator)
     {
         this.validator = validator;
         this.options = tokenizerOptions;
@@ -206,6 +206,7 @@ public class StandardAnalyzer extends AbstractAnalyzer
         this.inputReader = reader;
     }
 
+    @Override
     public boolean isTokenizing()
     {
         return true;
diff --git a/src/java/org/apache/cassandra/index/sasi/conf/IndexMode.java b/src/java/org/apache/cassandra/index/sasi/conf/IndexMode.java
index 60a19a65d0..e9ee703f75 100644
--- a/src/java/org/apache/cassandra/index/sasi/conf/IndexMode.java
+++ b/src/java/org/apache/cassandra/index/sasi/conf/IndexMode.java
@@ -114,10 +114,7 @@ public class IndexMode
             try
             {
                 analyzer = (AbstractAnalyzer) analyzerClass.newInstance();
-                if (!analyzer.isCompatibleWith(cd.type))
-                    throw new ConfigurationException(String.format("%s does not support type %s",
-                                                                   analyzerClass.getSimpleName(),
-                                                                   cd.type.asCQL3Type()));
+                analyzer.validate(indexOptions, cd);
             }
             catch (InstantiationException | IllegalAccessException e)
             {
diff --git a/test/unit/org/apache/cassandra/index/sasi/SASIIndexTest.java b/test/unit/org/apache/cassandra/index/sasi/SASIIndexTest.java
index afc2e7b613..73bc1dd48d 100644
--- a/test/unit/org/apache/cassandra/index/sasi/SASIIndexTest.java
+++ b/test/unit/org/apache/cassandra/index/sasi/SASIIndexTest.java
@@ -86,6 +86,7 @@ import org.apache.cassandra.transport.messages.ResultMessage;
 import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.cassandra.utils.FBUtilities;
 import org.apache.cassandra.utils.Pair;
+import org.assertj.core.api.Assertions;
 
 import com.google.common.collect.Iterables;
 import com.google.common.util.concurrent.Uninterruptibles;
@@ -2484,6 +2485,37 @@ public class SASIIndexTest
         });
     }
 
+    @Test
+    public void testIllegalArgumentsForAnalyzerShouldFail()
+    {
+        String baseTable = "illegal_argument_test";
+        String indexName = "illegal_index";
+        QueryProcessor.executeOnceInternal(String.format("CREATE KEYSPACE IF NOT EXISTS %s WITH replication = {'class': 'SimpleStrategy', 'replication_factor': '1'}", KS_NAME));
+        QueryProcessor.executeOnceInternal(String.format("CREATE TABLE IF NOT EXISTS %s.%s (k int primary key, v text);", KS_NAME, baseTable));
+
+        try
+        {
+            QueryProcessor.executeOnceInternal(String.format("CREATE CUSTOM INDEX IF NOT EXISTS %s ON %s.%s(v) " +
+                            "USING 'org.apache.cassandra.index.sasi.SASIIndex' WITH OPTIONS = { 'mode' : 'CONTAINS', " +
+                            "'analyzer_class': 'org.apache.cassandra.index.sasi.analyzer.NonTokenizingAnalyzer', " +
+                            "'case_sensitive': 'false'," +
+                            "'normalize_uppercase': 'true'};",
+                    indexName, KS_NAME, baseTable));
+
+            Assert.fail("creation of index analyzer with illegal options should fail");
+        }
+        catch (ConfigurationException e)
+        {
+            //correct behaviour
+            //confirm that it wasn't written to the schema
+            String query = String.format("SELECT * FROM system_schema.indexes WHERE keyspace_name = '%s' " +
+                                         "and table_name = '%s' and index_name = '%s';", KS_NAME, baseTable, indexName);
+            Assertions.assertThat(QueryProcessor.executeOnceInternal(query)).isEmpty();
+
+            Assert.assertEquals("case_sensitive option cannot be specified together with either normalize_lowercase or normalize_uppercase", e.getMessage());
+        }
+    }
+
     private ColumnFamilyStore loadData(Map<String, Pair<String, Integer>> data, boolean forceFlush)
     {
         return loadData(data, forceFlush, ++timestamp);
diff --git a/test/unit/org/apache/cassandra/index/sasi/analyzer/DelimiterAnalyzerTest.java b/test/unit/org/apache/cassandra/index/sasi/analyzer/DelimiterAnalyzerTest.java
index 16f9f0658a..f5f007f855 100644
--- a/test/unit/org/apache/cassandra/index/sasi/analyzer/DelimiterAnalyzerTest.java
+++ b/test/unit/org/apache/cassandra/index/sasi/analyzer/DelimiterAnalyzerTest.java
@@ -19,11 +19,15 @@ package org.apache.cassandra.index.sasi.analyzer;
 
 import java.nio.ByteBuffer;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 
+import org.apache.cassandra.config.ColumnDefinition;
 import org.apache.cassandra.db.marshal.Int32Type;
+import org.apache.cassandra.db.marshal.SetType;
 import org.apache.cassandra.db.marshal.UTF8Type;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.commons.io.IOUtils;
 
@@ -81,10 +85,18 @@ public class DelimiterAnalyzerTest
         Assert.assertFalse(testString.toLowerCase().equals(output.toString()));
     }
 
-    @Test(expected = IllegalArgumentException.class)
-    public void ensureIncompatibleInputSkipped() throws Exception
+    @Test(expected = ConfigurationException.class)
+    public void ensureIncompatibleInputOnCollectionTypeSkipped()
     {
-        new DelimiterAnalyzer().init(new HashMap(), Int32Type.instance);
+        new DelimiterAnalyzer().validate(Collections.emptyMap(),
+                                         ColumnDefinition.regularDef("a", "b", "c", SetType.getInstance(UTF8Type.instance, true)));
+    }
+
+    @Test(expected = ConfigurationException.class)
+    public void ensureIncompatibleInputSkipped()
+    {
+        new DelimiterAnalyzer().validate(Collections.emptyMap(),
+                                         ColumnDefinition.regularDef("a", "b", "c", Int32Type.instance));
     }
 
     @Test
