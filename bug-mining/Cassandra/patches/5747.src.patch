diff --git a/test/long/org/apache/cassandra/cql3/ViewComplexTest.java b/test/long/org/apache/cassandra/cql3/ViewComplexTest.java
deleted file mode 100644
index b5dc021599..0000000000
--- a/test/long/org/apache/cassandra/cql3/ViewComplexTest.java
+++ /dev/null
@@ -1,1450 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.cassandra.cql3;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-import java.nio.ByteBuffer;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Comparator;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.TimeUnit;
-import java.util.stream.Collectors;
-
-import com.datastax.driver.core.exceptions.OperationTimedOutException;
-import org.apache.cassandra.concurrent.SEPExecutor;
-import org.apache.cassandra.concurrent.Stage;
-import org.apache.cassandra.db.ColumnFamilyStore;
-import org.apache.cassandra.db.Keyspace;
-import org.apache.cassandra.db.compaction.CompactionManager;
-import org.apache.cassandra.transport.ProtocolVersion;
-import org.apache.cassandra.utils.FBUtilities;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.BeforeClass;
-import org.junit.Ignore;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.Timeout;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-
-import com.google.common.base.Objects;
-
-@RunWith(Parameterized.class)
-public class ViewComplexTest extends CQLTester
-{
-    @Parameterized.Parameter
-    public ProtocolVersion version;
-
-    @Parameterized.Parameters()
-    public static Collection<Object[]> versions()
-    {
-        return ProtocolVersion.SUPPORTED.stream()
-                                        .map(v -> new Object[]{v})
-                                        .collect(Collectors.toList());
-    }
-
-    private final List<String> views = new ArrayList<>();
-
-    @BeforeClass
-    public static void startup()
-    {
-        requireNetwork();
-    }
-
-    @Before
-    public void begin()
-    {
-        views.clear();
-    }
-
-    @After
-    public void end() throws Throwable
-    {
-        for (String viewName : views)
-            executeNet(version, "DROP MATERIALIZED VIEW " + viewName);
-    }
-
-    private void createView(String name, String query) throws Throwable
-    {
-        try
-        {
-            executeNet(version, String.format(query, name));
-            // If exception is thrown, the view will not be added to the list; since it shouldn't have been created, this is
-            // the desired behavior
-            views.add(name);
-        }
-        catch (OperationTimedOutException ex)
-        {
-            // ... except for timeout, when we actually do not know whether the view was created or not
-            views.add(name);
-            throw ex;
-        }
-    }
-
-    private void updateView(String query, Object... params) throws Throwable
-    {
-        updateViewWithFlush(query, false, params);
-    }
-
-    private void updateViewWithFlush(String query, boolean flush, Object... params) throws Throwable
-    {
-        executeNet(version, query, params);
-        while (!(((SEPExecutor) Stage.VIEW_MUTATION.executor()).getPendingTaskCount() == 0
-                && ((SEPExecutor) Stage.VIEW_MUTATION.executor()).getActiveTaskCount() == 0))
-        {
-            Thread.sleep(1);
-        }
-        if (flush)
-            Keyspace.open(keyspace()).flush();
-    }
-
-    // for now, unselected column cannot be fully supported, SEE CASSANDRA-11500
-    @Ignore
-    @Test
-    public void testPartialDeleteUnselectedColumn() throws Throwable
-    {
-        boolean flush = true;
-        execute("USE " + keyspace());
-        executeNet(version, "USE " + keyspace());
-        createTable("CREATE TABLE %s (k int, c int, a int, b int, PRIMARY KEY (k, c))");
-        createView("mv",
-                   "CREATE MATERIALIZED VIEW %s AS SELECT k,c FROM %%s WHERE k IS NOT NULL AND c IS NOT NULL PRIMARY KEY (k,c)");
-        Keyspace ks = Keyspace.open(keyspace());
-        ks.getColumnFamilyStore("mv").disableAutoCompaction();
-
-        updateView("UPDATE %s USING TIMESTAMP 10 SET b=1 WHERE k=1 AND c=1");
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-        assertRows(execute("SELECT * from %s"), row(1, 1, null, 1));
-        assertRows(execute("SELECT * from mv"), row(1, 1));
-        updateView("DELETE b FROM %s USING TIMESTAMP 11 WHERE k=1 AND c=1");
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-        assertEmpty(execute("SELECT * from %s"));
-        assertEmpty(execute("SELECT * from mv"));
-        updateView("UPDATE %s USING TIMESTAMP 1 SET a=1 WHERE k=1 AND c=1");
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-        assertRows(execute("SELECT * from %s"), row(1, 1, 1, null));
-        assertRows(execute("SELECT * from mv"), row(1, 1));
-
-        execute("truncate %s;");
-
-        // removal generated by unselected column should not shadow PK update with smaller timestamp
-        updateViewWithFlush("UPDATE %s USING TIMESTAMP 18 SET a=1 WHERE k=1 AND c=1", flush);
-        assertRows(execute("SELECT * from %s"), row(1, 1, 1, null));
-        assertRows(execute("SELECT * from mv"), row(1, 1));
-
-        updateViewWithFlush("UPDATE %s USING TIMESTAMP 20 SET a=null WHERE k=1 AND c=1", flush);
-        assertRows(execute("SELECT * from %s"));
-        assertRows(execute("SELECT * from mv"));
-
-        updateViewWithFlush("INSERT INTO %s(k,c) VALUES(1,1) USING TIMESTAMP 15", flush);
-        assertRows(execute("SELECT * from %s"), row(1, 1, null, null));
-        assertRows(execute("SELECT * from mv"), row(1, 1));
-    }
-
-    @Test
-    public void testPartialDeleteSelectedColumnWithFlush() throws Throwable
-    {
-        testPartialDeleteSelectedColumn(true);
-    }
-
-    @Test
-    public void testPartialDeleteSelectedColumnWithoutFlush() throws Throwable
-    {
-        testPartialDeleteSelectedColumn(false);
-    }
-
-    private void testPartialDeleteSelectedColumn(boolean flush) throws Throwable
-    {
-        execute("USE " + keyspace());
-        executeNet(version, "USE " + keyspace());
-        createTable("CREATE TABLE %s (k int, c int, a int, b int, e int, f int, PRIMARY KEY (k, c))");
-        createView("mv",
-                   "CREATE MATERIALIZED VIEW %s AS SELECT a, b, c, k FROM %%s WHERE k IS NOT NULL AND c IS NOT NULL PRIMARY KEY (k,c)");
-        Keyspace ks = Keyspace.open(keyspace());
-        ks.getColumnFamilyStore("mv").disableAutoCompaction();
-
-        updateViewWithFlush("UPDATE %s USING TIMESTAMP 10 SET b=1 WHERE k=1 AND c=1", flush);
-        assertRows(execute("SELECT * from %s"), row(1, 1, null, 1, null, null));
-        assertRows(execute("SELECT * from mv"), row(1, 1, null, 1));
-
-        updateViewWithFlush("DELETE b FROM %s USING TIMESTAMP 11 WHERE k=1 AND c=1", flush);
-        assertEmpty(execute("SELECT * from %s"));
-        assertEmpty(execute("SELECT * from mv"));
-
-        updateViewWithFlush("UPDATE %s USING TIMESTAMP 1 SET a=1 WHERE k=1 AND c=1", flush);
-        assertRows(execute("SELECT * from %s"), row(1, 1, 1, null, null, null));
-        assertRows(execute("SELECT * from mv"), row(1, 1, 1, null));
-
-        updateViewWithFlush("DELETE a FROM %s USING TIMESTAMP 1 WHERE k=1 AND c=1", flush);
-        assertEmpty(execute("SELECT * from %s"));
-        assertEmpty(execute("SELECT * from mv"));
-
-        // view livenessInfo should not be affected by selected column ts or tb
-        updateViewWithFlush("INSERT INTO %s(k,c) VALUES(1,1) USING TIMESTAMP 0", flush);
-        assertRows(execute("SELECT * from %s"), row(1, 1, null, null, null, null));
-        assertRows(execute("SELECT * from mv"), row(1, 1, null, null));
-
-        updateViewWithFlush("UPDATE %s USING TIMESTAMP 12 SET b=1 WHERE k=1 AND c=1", flush);
-        assertRows(execute("SELECT * from %s"), row(1, 1, null, 1, null, null));
-        assertRows(execute("SELECT * from mv"), row(1, 1, null, 1));
-
-        updateViewWithFlush("DELETE b FROM %s USING TIMESTAMP 13 WHERE k=1 AND c=1", flush);
-        assertRows(execute("SELECT * from %s"), row(1, 1, null, null, null, null));
-        assertRows(execute("SELECT * from mv"), row(1, 1, null, null));
-
-        updateViewWithFlush("DELETE FROM %s USING TIMESTAMP 14 WHERE k=1 AND c=1", flush);
-        assertEmpty(execute("SELECT * from %s"));
-        assertEmpty(execute("SELECT * from mv"));
-
-        updateViewWithFlush("INSERT INTO %s(k,c) VALUES(1,1) USING TIMESTAMP 15", flush);
-        assertRows(execute("SELECT * from %s"), row(1, 1, null, null, null, null));
-        assertRows(execute("SELECT * from mv"), row(1, 1, null, null));
-
-        updateViewWithFlush("UPDATE %s USING TTL 3 SET b=1 WHERE k=1 AND c=1", flush);
-        assertRows(execute("SELECT * from %s"), row(1, 1, null, 1, null, null));
-        assertRows(execute("SELECT * from mv"), row(1, 1, null, 1));
-
-        TimeUnit.SECONDS.sleep(4);
-
-        assertRows(execute("SELECT * from %s"), row(1, 1, null, null, null, null));
-        assertRows(execute("SELECT * from mv"), row(1, 1, null, null));
-
-        updateViewWithFlush("DELETE FROM %s USING TIMESTAMP 15 WHERE k=1 AND c=1", flush);
-        assertEmpty(execute("SELECT * from %s"));
-        assertEmpty(execute("SELECT * from mv"));
-
-        execute("truncate %s;");
-
-        // removal generated by unselected column should not shadow selected column with smaller timestamp
-        updateViewWithFlush("UPDATE %s USING TIMESTAMP 18 SET e=1 WHERE k=1 AND c=1", flush);
-        assertRows(execute("SELECT * from %s"), row(1, 1, null, null, 1, null));
-        assertRows(execute("SELECT * from mv"), row(1, 1, null, null));
-
-        updateViewWithFlush("UPDATE %s USING TIMESTAMP 18 SET e=null WHERE k=1 AND c=1", flush);
-        assertRows(execute("SELECT * from %s"));
-        assertRows(execute("SELECT * from mv"));
-
-        updateViewWithFlush("UPDATE %s USING TIMESTAMP 16 SET a=1 WHERE k=1 AND c=1", flush);
-        assertRows(execute("SELECT * from %s"), row(1, 1, 1, null, null, null));
-        assertRows(execute("SELECT * from mv"), row(1, 1, 1, null));
-    }
-
-    @Test
-    public void testUpdateColumnInViewPKWithTTLWithFlush() throws Throwable
-    {
-        // CASSANDRA-13657
-        testUpdateColumnInViewPKWithTTL(true);
-    }
-
-    @Test
-    public void testUpdateColumnInViewPKWithTTLWithoutFlush() throws Throwable
-    {
-        // CASSANDRA-13657
-        testUpdateColumnInViewPKWithTTL(false);
-    }
-
-    private void testUpdateColumnInViewPKWithTTL(boolean flush) throws Throwable
-    {
-        // CASSANDRA-13657 if base column used in view pk is ttled, then view row is considered dead
-        createTable("create table %s (k int primary key, a int, b int)");
-
-        execute("USE " + keyspace());
-        executeNet(version, "USE " + keyspace());
-        Keyspace ks = Keyspace.open(keyspace());
-
-        createView("mv",
-                   "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE k IS NOT NULL AND a IS NOT NULL PRIMARY KEY (a, k)");
-        ks.getColumnFamilyStore("mv").disableAutoCompaction();
-
-        updateView("UPDATE %s SET a = 1 WHERE k = 1;");
-
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-
-        assertRows(execute("SELECT * from %s"), row(1, 1, null));
-        assertRows(execute("SELECT * from mv"), row(1, 1, null));
-
-        updateView("DELETE a FROM %s WHERE k = 1");
-
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-
-        assertRows(execute("SELECT * from %s"));
-        assertEmpty(execute("SELECT * from mv"));
-
-        updateView("INSERT INTO %s (k) VALUES (1);");
-
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-
-        assertRows(execute("SELECT * from %s"), row(1, null, null));
-        assertEmpty(execute("SELECT * from mv"));
-
-        updateView("UPDATE %s USING TTL 5 SET a = 10 WHERE k = 1;");
-
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-
-        assertRows(execute("SELECT * from %s"), row(1, 10, null));
-        assertRows(execute("SELECT * from mv"), row(10, 1, null));
-
-        updateView("UPDATE %s SET b = 100 WHERE k = 1;");
-
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-
-        assertRows(execute("SELECT * from %s"), row(1, 10, 100));
-        assertRows(execute("SELECT * from mv"), row(10, 1, 100));
-
-        Thread.sleep(5000);
-
-        // 'a' is TTL of 5 and removed.
-        assertRows(execute("SELECT * from %s"), row(1, null, 100));
-        assertEmpty(execute("SELECT * from mv"));
-        assertEmpty(execute("SELECT * from mv WHERE k = ? AND a = ?", 1, 10));
-
-        updateView("DELETE b FROM %s WHERE k=1");
-
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-
-        assertRows(execute("SELECT * from %s"), row(1, null, null));
-        assertEmpty(execute("SELECT * from mv"));
-
-        updateView("DELETE FROM %s WHERE k=1;");
-
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-
-        assertEmpty(execute("SELECT * from %s"));
-        assertEmpty(execute("SELECT * from mv"));
-    }
-
-    @Test
-    public void testUpdateColumnNotInViewWithFlush() throws Throwable
-    {
-        testUpdateColumnNotInView(true);
-    }
-
-    @Test
-    public void testUpdateColumnNotInViewWithoutFlush() throws Throwable
-    {
-        // CASSANDRA-13127
-        testUpdateColumnNotInView(false);
-    }
-
-    private void testUpdateColumnNotInView(boolean flush) throws Throwable
-    {
-        // CASSANDRA-13127: if base column not selected in view are alive, then pk of view row should be alive
-        String baseTable = createTable("create table %s (p int, c int, v1 int, v2 int, primary key(p, c))");
-
-        execute("USE " + keyspace());
-        executeNet(version, "USE " + keyspace());
-        Keyspace ks = Keyspace.open(keyspace());
-
-        createView("mv",
-                   "CREATE MATERIALIZED VIEW %s AS SELECT p, c FROM %%s WHERE p IS NOT NULL AND c IS NOT NULL PRIMARY KEY (c, p);");
-        ks.getColumnFamilyStore("mv").disableAutoCompaction();
-
-        updateView("UPDATE %s USING TIMESTAMP 0 SET v1 = 1 WHERE p = 0 AND c = 0");
-
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-
-        assertRowsIgnoringOrder(execute("SELECT * from %s WHERE c = ? AND p = ?", 0, 0), row(0, 0, 1, null));
-        assertRowsIgnoringOrder(execute("SELECT * from mv WHERE c = ? AND p = ?", 0, 0), row(0, 0));
-
-        updateView("DELETE v1 FROM %s USING TIMESTAMP 1 WHERE p = 0 AND c = 0");
-
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-
-        assertEmpty(execute("SELECT * from %s WHERE c = ? AND p = ?", 0, 0));
-        assertEmpty(execute("SELECT * from mv WHERE c = ? AND p = ?", 0, 0));
-
-        // shadowed by tombstone
-        updateView("UPDATE %s USING TIMESTAMP 1 SET v1 = 1 WHERE p = 0 AND c = 0");
-
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-
-        assertEmpty(execute("SELECT * from %s WHERE c = ? AND p = ?", 0, 0));
-        assertEmpty(execute("SELECT * from mv WHERE c = ? AND p = ?", 0, 0));
-
-        updateView("UPDATE %s USING TIMESTAMP 2 SET v2 = 1 WHERE p = 0 AND c = 0");
-
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-
-        assertRowsIgnoringOrder(execute("SELECT * from %s WHERE c = ? AND p = ?", 0, 0), row(0, 0, null, 1));
-        assertRowsIgnoringOrder(execute("SELECT * from mv WHERE c = ? AND p = ?", 0, 0), row(0, 0));
-
-        updateView("DELETE v1 FROM %s USING TIMESTAMP 3 WHERE p = 0 AND c = 0");
-
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-
-        assertRowsIgnoringOrder(execute("SELECT * from %s WHERE c = ? AND p = ?", 0, 0), row(0, 0, null, 1));
-        assertRowsIgnoringOrder(execute("SELECT * from mv WHERE c = ? AND p = ?", 0, 0), row(0, 0));
-
-        updateView("DELETE v2 FROM %s USING TIMESTAMP 4 WHERE p = 0 AND c = 0");
-
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-
-        assertEmpty(execute("SELECT * from %s WHERE c = ? AND p = ?", 0, 0));
-        assertEmpty(execute("SELECT * from mv WHERE c = ? AND p = ?", 0, 0));
-
-        updateView("UPDATE %s USING TTL 3 SET v2 = 1 WHERE p = 0 AND c = 0");
-
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-
-        assertRowsIgnoringOrder(execute("SELECT * from %s WHERE c = ? AND p = ?", 0, 0), row(0, 0, null, 1));
-        assertRowsIgnoringOrder(execute("SELECT * from mv WHERE c = ? AND p = ?", 0, 0), row(0, 0));
-
-        Thread.sleep(TimeUnit.SECONDS.toMillis(3));
-
-        assertRowsIgnoringOrder(execute("SELECT * from %s WHERE c = ? AND p = ?", 0, 0));
-        assertRowsIgnoringOrder(execute("SELECT * from mv WHERE c = ? AND p = ?", 0, 0));
-
-        updateView("UPDATE %s SET v2 = 1 WHERE p = 0 AND c = 0");
-
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-
-        assertRowsIgnoringOrder(execute("SELECT * from %s WHERE c = ? AND p = ?", 0, 0), row(0, 0, null, 1));
-        assertRowsIgnoringOrder(execute("SELECT * from mv WHERE c = ? AND p = ?", 0, 0), row(0, 0));
-
-        assertInvalidMessage(String.format("Cannot drop column v2 on base table %s with materialized views", baseTable), "ALTER TABLE %s DROP v2");
-        // // drop unselected base column, unselected metadata should be removed, thus view row is dead
-        // updateView("ALTER TABLE %s DROP v2");
-        // assertRowsIgnoringOrder(execute("SELECT * from %s WHERE c = ? AND p = ?", 0, 0));
-        // assertRowsIgnoringOrder(execute("SELECT * from mv WHERE c = ? AND p = ?", 0, 0));
-        // assertRowsIgnoringOrder(execute("SELECT * from %s"));
-        // assertRowsIgnoringOrder(execute("SELECT * from mv"));
-    }
-
-    @Test
-    public void testPartialUpdateWithUnselectedCollectionsWithFlush() throws Throwable
-    {
-        testPartialUpdateWithUnselectedCollections(true);
-    }
-
-    @Test
-    public void testPartialUpdateWithUnselectedCollectionsWithoutFlush() throws Throwable
-    {
-        testPartialUpdateWithUnselectedCollections(false);
-    }
-
-    public void testPartialUpdateWithUnselectedCollections(boolean flush) throws Throwable
-    {
-        execute("USE " + keyspace());
-        executeNet(version, "USE " + keyspace());
-        String baseTable = createTable("CREATE TABLE %s (k int, c int, a int, b int, l list<int>, s set<int>, m map<int,int>, PRIMARY KEY (k, c))");
-        createView("mv",
-                   "CREATE MATERIALIZED VIEW %s AS SELECT a, b, c, k FROM %%s WHERE k IS NOT NULL AND c IS NOT NULL PRIMARY KEY (c, k)");
-        Keyspace ks = Keyspace.open(keyspace());
-        ks.getColumnFamilyStore("mv").disableAutoCompaction();
-
-        updateView("UPDATE %s SET l=l+[1,2,3] WHERE k = 1 AND c = 1");
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-        assertRows(execute("SELECT * from mv"), row(1, 1, null, null));
-
-        updateView("UPDATE %s SET l=l-[1,2] WHERE k = 1 AND c = 1");
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-        assertRows(execute("SELECT * from mv"), row(1, 1, null, null));
-
-        updateView("UPDATE %s SET b=3 WHERE k=1 AND c=1");
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-        assertRows(execute("SELECT * from mv"), row(1, 1, null, 3));
-
-        updateView("UPDATE %s SET b=null, l=l-[3], s=s-{3} WHERE k = 1 AND c = 1");
-        if (flush)
-        {
-            FBUtilities.waitOnFutures(ks.flush());
-            ks.getColumnFamilyStore("mv").forceMajorCompaction();
-        }
-        assertRowsIgnoringOrder(execute("SELECT k,c,a,b from %s"));
-        assertRowsIgnoringOrder(execute("SELECT * from mv"));
-
-        updateView("UPDATE %s SET m=m+{3:3}, l=l-[1], s=s-{2} WHERE k = 1 AND c = 1");
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-        assertRowsIgnoringOrder(execute("SELECT k,c,a,b from %s"), row(1, 1, null, null));
-        assertRowsIgnoringOrder(execute("SELECT * from mv"), row(1, 1, null, null));
-
-        assertInvalidMessage(String.format("Cannot drop column m on base table %s with materialized views", baseTable), "ALTER TABLE %s DROP m");
-        // executeNet(version, "ALTER TABLE %s DROP m");
-        // ks.getColumnFamilyStore("mv").forceMajorCompaction();
-        // assertRowsIgnoringOrder(execute("SELECT k,c,a,b from %s WHERE k = 1 AND c = 1"));
-        // assertRowsIgnoringOrder(execute("SELECT * from mv WHERE k = 1 AND c = 1"));
-        // assertRowsIgnoringOrder(execute("SELECT k,c,a,b from %s"));
-        // assertRowsIgnoringOrder(execute("SELECT * from mv"));
-    }
-
-    @Test
-    public void testUnselectedColumnsTTLWithFlush() throws Throwable
-    {
-        // CASSANDRA-13127
-        testUnselectedColumnsTTL(true);
-    }
-
-    @Test
-    public void testUnselectedColumnsTTLWithoutFlush() throws Throwable
-    {
-        // CASSANDRA-13127
-        testUnselectedColumnsTTL(false);
-    }
-
-    private void testUnselectedColumnsTTL(boolean flush) throws Throwable
-    {
-        // CASSANDRA-13127 not ttled unselected column in base should keep view row alive
-        createTable("create table %s (p int, c int, v int, primary key(p, c))");
-
-        execute("USE " + keyspace());
-        executeNet(version, "USE " + keyspace());
-        Keyspace ks = Keyspace.open(keyspace());
-
-        createView("mv",
-                   "CREATE MATERIALIZED VIEW %s AS SELECT p, c FROM %%s WHERE p IS NOT NULL AND c IS NOT NULL PRIMARY KEY (c, p);");
-        ks.getColumnFamilyStore("mv").disableAutoCompaction();
-
-        updateViewWithFlush("INSERT INTO %s (p, c) VALUES (0, 0) USING TTL 3;", flush);
-
-        updateViewWithFlush("UPDATE %s USING TTL 1000 SET v = 0 WHERE p = 0 and c = 0;", flush);
-
-        assertRowsIgnoringOrder(execute("SELECT * from mv WHERE c = ? AND p = ?", 0, 0), row(0, 0));
-
-        Thread.sleep(3000);
-
-        UntypedResultSet.Row row = execute("SELECT v, ttl(v) from %s WHERE c = ? AND p = ?", 0, 0).one();
-        assertTrue("row should have value of 0", row.getInt("v") == 0);
-        assertTrue("row should have ttl less than 1000", row.getInt("ttl(v)") < 1000);
-        assertRowsIgnoringOrder(execute("SELECT * from mv WHERE c = ? AND p = ?", 0, 0), row(0, 0));
-
-        updateViewWithFlush("DELETE FROM %s WHERE p = 0 and c = 0;", flush);
-        assertRowsIgnoringOrder(execute("SELECT * from mv WHERE c = ? AND p = ?", 0, 0));
-
-        updateViewWithFlush("INSERT INTO %s (p, c) VALUES (0, 0) ", flush);
-        assertRowsIgnoringOrder(execute("SELECT * from mv WHERE c = ? AND p = ?", 0, 0), row(0, 0));
-
-        // already have a live row, no need to apply the unselected cell ttl
-        updateViewWithFlush("UPDATE %s USING TTL 3 SET v = 0 WHERE p = 0 and c = 0;", flush);
-        assertRowsIgnoringOrder(execute("SELECT * from mv WHERE c = ? AND p = ?", 0, 0), row(0, 0));
-
-        updateViewWithFlush("INSERT INTO %s (p, c) VALUES (1, 1) USING TTL 3", flush);
-        assertRowsIgnoringOrder(execute("SELECT * from mv WHERE c = ? AND p = ?", 1, 1), row(1, 1));
-
-        Thread.sleep(4000);
-
-        assertRowsIgnoringOrder(execute("SELECT * from mv WHERE c = ? AND p = ?", 0, 0), row(0, 0));
-        assertRowsIgnoringOrder(execute("SELECT * from mv WHERE c = ? AND p = ?", 1, 1));
-
-        // unselected should keep view row alive
-        updateViewWithFlush("UPDATE %s SET v = 0 WHERE p = 1 and c = 1;", flush);
-        assertRowsIgnoringOrder(execute("SELECT * from mv WHERE c = ? AND p = ?", 1, 1), row(1, 1));
-
-    }
-
-    @Test
-    public void testRangeDeletionWithFlush() throws Throwable
-    {
-        testRangeDeletion(true);
-    }
-
-    @Test
-    public void testRangeDeletionWithoutFlush() throws Throwable
-    {
-        testRangeDeletion(false);
-    }
-
-    public void testRangeDeletion(boolean flush) throws Throwable
-    {
-        // for partition range deletion, need to know that existing row is shadowed instead of not existed.
-        createTable("CREATE TABLE %s (a int, b int, c int, d int, PRIMARY KEY (a))");
-
-        execute("USE " + keyspace());
-        executeNet(version, "USE " + keyspace());
-
-        createView("mv_test1",
-                   "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a IS NOT NULL AND b IS NOT NULL PRIMARY KEY (a, b)");
-
-        Keyspace ks = Keyspace.open(keyspace());
-        ks.getColumnFamilyStore("mv_test1").disableAutoCompaction();
-
-        execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?) using timestamp 0", 1, 1, 1, 1);
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test1"), row(1, 1, 1, 1));
-
-        // remove view row
-        updateView("UPDATE %s using timestamp 1 set b = null WHERE a=1");
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test1"));
-        // remove base row, no view updated generated.
-        updateView("DELETE FROM %s using timestamp 2 where a=1");
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test1"));
-
-        // restor view row with b,c column. d is still tombstone
-        updateView("UPDATE %s using timestamp 3 set b = 1,c = 1 where a=1"); // upsert
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test1"), row(1, 1, 1, null));
-    }
-
-    @Test
-    public void testBaseTTLWithSameTimestampTest() throws Throwable
-    {
-        // CASSANDRA-13127 when liveness timestamp tie, greater localDeletionTime should win if both are expiring.
-        createTable("create table %s (p int, c int, v int, primary key(p, c))");
-
-        execute("USE " + keyspace());
-        executeNet(version, "USE " + keyspace());
-        Keyspace ks = Keyspace.open(keyspace());
-
-        updateView("INSERT INTO %s (p, c, v) VALUES (0, 0, 0) using timestamp 1;");
-
-        FBUtilities.waitOnFutures(ks.flush());
-
-        updateView("INSERT INTO %s (p, c, v) VALUES (0, 0, 0) USING TTL 3 and timestamp 1;");
-
-        FBUtilities.waitOnFutures(ks.flush());
-
-        Thread.sleep(4000);
-
-        assertEmpty(execute("SELECT * from %s WHERE c = ? AND p = ?", 0, 0));
-
-        // reversed order
-        execute("truncate %s;");
-
-        updateView("INSERT INTO %s (p, c, v) VALUES (0, 0, 0) USING TTL 3 and timestamp 1;");
-
-        FBUtilities.waitOnFutures(ks.flush());
-
-        updateView("INSERT INTO %s (p, c, v) VALUES (0, 0, 0) USING timestamp 1;");
-
-        FBUtilities.waitOnFutures(ks.flush());
-
-        Thread.sleep(4000);
-
-        assertEmpty(execute("SELECT * from %s WHERE c = ? AND p = ?", 0, 0));
-
-    }
-
-    @Test
-    public void testCommutativeRowDeletionFlush() throws Throwable
-    {
-        // CASSANDRA-13409
-        testCommutativeRowDeletion(true);
-    }
-
-    @Test
-    public void testCommutativeRowDeletionWithoutFlush() throws Throwable
-    {
-        // CASSANDRA-13409
-        testCommutativeRowDeletion(false);
-    }
-
-    private void testCommutativeRowDeletion(boolean flush) throws Throwable
-    {
-        // CASSANDRA-13409 new update should not resurrect previous deleted data in view
-        createTable("create table %s (p int primary key, v1 int, v2 int)");
-
-        execute("USE " + keyspace());
-        executeNet(version, "USE " + keyspace());
-        Keyspace ks = Keyspace.open(keyspace());
-
-        createView("mv",
-                   "create materialized view %s as select * from %%s where p is not null and v1 is not null primary key (v1, p);");
-        ks.getColumnFamilyStore("mv").disableAutoCompaction();
-
-        // sstable-1, Set initial values TS=1
-        updateView("Insert into %s (p, v1, v2) values (3, 1, 3) using timestamp 1;");
-
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-
-        assertRowsIgnoringOrder(execute("SELECT v2, WRITETIME(v2) from mv WHERE v1 = ? AND p = ?", 1, 3), row(3, 1L));
-        // sstable-2
-        updateView("Delete from %s using timestamp 2 where p = 3;");
-
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-
-        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from mv"));
-        // sstable-3
-        updateView("Insert into %s (p, v1) values (3, 1) using timestamp 3;");
-
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-
-        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from mv"), row(1, 3, null, null));
-        // sstable-4
-        updateView("UPdate %s using timestamp 4 set v1 = 2 where p = 3;");
-
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-
-        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from mv"), row(2, 3, null, null));
-        // sstable-5
-        updateView("UPdate %s using timestamp 5 set v1 = 1 where p = 3;");
-
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-
-        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from mv"), row(1, 3, null, null));
-
-        if (flush)
-        {
-            // compact sstable 2 and 4, 5;
-            ColumnFamilyStore cfs = ks.getColumnFamilyStore("mv");
-            List<String> sstables = cfs.getLiveSSTables()
-                                       .stream()
-                                       .sorted((s1, s2) -> s1.descriptor.generation - s2.descriptor.generation)
-                                       .map(s -> s.getFilename())
-                                       .collect(Collectors.toList());
-            String dataFiles = String.join(",", Arrays.asList(sstables.get(1), sstables.get(3), sstables.get(4)));
-            CompactionManager.instance.forceUserDefinedCompaction(dataFiles);
-            assertEquals(3, cfs.getLiveSSTables().size());
-        }
-        // regular tombstone should be retained after compaction
-        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from mv"), row(1, 3, null, null));
-    }
-
-    @Test
-    public void testUnselectedColumnWithExpiredLivenessInfo() throws Throwable
-    {
-        boolean flush = true;
-        createTable("create table %s (k int, c int, a int, b int, PRIMARY KEY(k, c))");
-
-        execute("USE " + keyspace());
-        executeNet(version, "USE " + keyspace());
-        Keyspace ks = Keyspace.open(keyspace());
-
-        createView("mv",
-                   "create materialized view %s as select k,c,b from %%s where c is not null and k is not null primary key (c, k);");
-        ks.getColumnFamilyStore("mv").disableAutoCompaction();
-
-        // sstable-1, Set initial values TS=1
-        updateViewWithFlush("UPDATE %s SET a = 1 WHERE k = 1 AND c = 1;", flush);
-
-        assertRowsIgnoringOrder(execute("SELECT * from %s WHERE k = 1 AND c = 1;"),
-                                row(1, 1, 1, null));
-        assertRowsIgnoringOrder(execute("SELECT k,c,b from mv WHERE k = 1 AND c = 1;"),
-                                row(1, 1, null));
-
-        // sstable-2
-        updateViewWithFlush("INSERT INTO %s(k,c) VALUES(1,1) USING TTL 5", flush);
-
-        assertRowsIgnoringOrder(execute("SELECT * from %s WHERE k = 1 AND c = 1;"),
-                                row(1, 1, 1, null));
-        assertRowsIgnoringOrder(execute("SELECT k,c,b from mv WHERE k = 1 AND c = 1;"),
-                                row(1, 1, null));
-
-        Thread.sleep(5001);
-
-        assertRowsIgnoringOrder(execute("SELECT * from %s WHERE k = 1 AND c = 1;"),
-                                row(1, 1, 1, null));
-        assertRowsIgnoringOrder(execute("SELECT k,c,b from mv WHERE k = 1 AND c = 1;"),
-                                row(1, 1, null));
-
-        // sstable-3
-        updateViewWithFlush("Update %s set a = null where k = 1 AND c = 1;", flush);
-
-        assertRowsIgnoringOrder(execute("SELECT * from %s WHERE k = 1 AND c = 1;"));
-        assertRowsIgnoringOrder(execute("SELECT k,c,b from mv WHERE k = 1 AND c = 1;"));
-
-        // sstable-4
-        updateViewWithFlush("Update %s USING TIMESTAMP 1 set b = 1 where k = 1 AND c = 1;", flush);
-
-        assertRowsIgnoringOrder(execute("SELECT * from %s WHERE k = 1 AND c = 1;"),
-                                row(1, 1, null, 1));
-        assertRowsIgnoringOrder(execute("SELECT k,c,b from mv WHERE k = 1 AND c = 1;"),
-                                row(1, 1, 1));
-    }
-
-    @Test
-    public void testUpdateWithColumnTimestampSmallerThanPkWithFlush() throws Throwable
-    {
-        testUpdateWithColumnTimestampSmallerThanPk(true);
-    }
-
-    @Test
-    public void testUpdateWithColumnTimestampSmallerThanPkWithoutFlush() throws Throwable
-    {
-        testUpdateWithColumnTimestampSmallerThanPk(false);
-    }
-
-    public void testUpdateWithColumnTimestampSmallerThanPk(boolean flush) throws Throwable
-    {
-        createTable("create table %s (p int primary key, v1 int, v2 int)");
-
-        execute("USE " + keyspace());
-        executeNet(version, "USE " + keyspace());
-        Keyspace ks = Keyspace.open(keyspace());
-
-        createView("mv",
-                   "create materialized view %s as select * from %%s where p is not null and v1 is not null primary key (v1, p);");
-        ks.getColumnFamilyStore("mv").disableAutoCompaction();
-
-        // reset value
-        updateView("Insert into %s (p, v1, v2) values (3, 1, 3) using timestamp 6;");
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from mv"), row(1, 3, 3, 6L));
-        // increase pk's timestamp to 20
-        updateView("Insert into %s (p) values (3) using timestamp 20;");
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from mv"), row(1, 3, 3, 6L));
-        // change v1's to 2 and remove existing view row with ts7
-        updateView("UPdate %s using timestamp 7 set v1 = 2 where p = 3;");
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from mv"), row(2, 3, 3, 6L));
-        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from mv limit 1"), row(2, 3, 3, 6L));
-        // change v1's to 1 and remove existing view row with ts8
-        updateView("UPdate %s using timestamp 8 set v1 = 1 where p = 3;");
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from mv"), row(1, 3, 3, 6L));
-    }
-
-    @Test
-    public void testExpiredLivenessLimitWithFlush() throws Throwable
-    {
-        // CASSANDRA-13883
-        testExpiredLivenessLimit(true);
-    }
-
-    @Test
-    public void testExpiredLivenessLimitWithoutFlush() throws Throwable
-    {
-        // CASSANDRA-13883
-        testExpiredLivenessLimit(false);
-    }
-
-    private void testExpiredLivenessLimit(boolean flush) throws Throwable
-    {
-        createTable("CREATE TABLE %s (k int PRIMARY KEY, a int, b int);");
-
-        execute("USE " + keyspace());
-        executeNet(version, "USE " + keyspace());
-        Keyspace ks = Keyspace.open(keyspace());
-
-        createView("mv1", "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE k IS NOT NULL AND a IS NOT NULL PRIMARY KEY (k, a);");
-        createView("mv2", "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE k IS NOT NULL AND a IS NOT NULL PRIMARY KEY (a, k);");
-        ks.getColumnFamilyStore("mv1").disableAutoCompaction();
-        ks.getColumnFamilyStore("mv2").disableAutoCompaction();
-
-        for (int i = 1; i <= 100; i++)
-            updateView("INSERT INTO %s(k, a, b) VALUES (?, ?, ?);", i, i, i);
-        for (int i = 1; i <= 100; i++)
-        {
-            if (i % 50 == 0)
-                continue;
-            // create expired liveness
-            updateView("DELETE a FROM %s WHERE k = ?;", i);
-        }
-        if (flush)
-        {
-            ks.getColumnFamilyStore("mv1").forceBlockingFlush();
-            ks.getColumnFamilyStore("mv2").forceBlockingFlush();
-        }
-
-        for (String view : Arrays.asList("mv1", "mv2"))
-        {
-            // paging
-            assertEquals(1, executeNetWithPaging(version, String.format("SELECT k,a,b FROM %s limit 1", view), 1).all().size());
-            assertEquals(2, executeNetWithPaging(version, String.format("SELECT k,a,b FROM %s limit 2", view), 1).all().size());
-            assertEquals(2, executeNetWithPaging(version, String.format("SELECT k,a,b FROM %s", view), 1).all().size());
-            assertRowsNet(version, executeNetWithPaging(version, String.format("SELECT k,a,b FROM %s ", view), 1),
-                          row(50, 50, 50),
-                          row(100, 100, 100));
-            // limit
-            assertEquals(1, execute(String.format("SELECT k,a,b FROM %s limit 1", view)).size());
-            assertRowsIgnoringOrder(execute(String.format("SELECT k,a,b FROM %s limit 2", view)),
-                                    row(50, 50, 50),
-                                    row(100, 100, 100));
-        }
-    }
-
-    @Test
-    public void testUpdateWithColumnTimestampBiggerThanPkWithFlush() throws Throwable
-    {
-        // CASSANDRA-11500
-        testUpdateWithColumnTimestampBiggerThanPk(true);
-    }
-
-    @Test
-    public void testUpdateWithColumnTimestampBiggerThanPkWithoutFlush() throws Throwable
-    {
-        // CASSANDRA-11500
-        testUpdateWithColumnTimestampBiggerThanPk(false);
-    }
-
-    public void testUpdateWithColumnTimestampBiggerThanPk(boolean flush) throws Throwable
-    {
-        // CASSANDRA-11500 able to shadow old view row with column ts greater tahn pk's ts and re-insert the view row
-        String baseTable = createTable("CREATE TABLE %s (k int PRIMARY KEY, a int, b int);");
-
-        execute("USE " + keyspace());
-        executeNet(version, "USE " + keyspace());
-        Keyspace ks = Keyspace.open(keyspace());
-
-        createView("mv",
-                   "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE k IS NOT NULL AND a IS NOT NULL PRIMARY KEY (k, a);");
-        ks.getColumnFamilyStore("mv").disableAutoCompaction();
-        updateView("DELETE FROM %s USING TIMESTAMP 0 WHERE k = 1;");
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-        // sstable-1, Set initial values TS=1
-        updateView("INSERT INTO %s(k, a, b) VALUES (1, 1, 1) USING TIMESTAMP 1;");
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-        assertRowsIgnoringOrder(execute("SELECT k,a,b from mv"), row(1, 1, 1));
-        updateView("UPDATE %s USING TIMESTAMP 10 SET b = 2 WHERE k = 1;");
-        assertRowsIgnoringOrder(execute("SELECT k,a,b from mv"), row(1, 1, 2));
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-        assertRowsIgnoringOrder(execute("SELECT k,a,b from mv"), row(1, 1, 2));
-        updateView("UPDATE %s USING TIMESTAMP 2 SET a = 2 WHERE k = 1;");
-        assertRowsIgnoringOrder(execute("SELECT k,a,b from mv"), row(1, 2, 2));
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-        ks.getColumnFamilyStore("mv").forceMajorCompaction();
-        assertRowsIgnoringOrder(execute("SELECT k,a,b from mv"), row(1, 2, 2));
-        assertRowsIgnoringOrder(execute("SELECT k,a,b from mv limit 1"), row(1, 2, 2));
-        updateView("UPDATE %s USING TIMESTAMP 11 SET a = 1 WHERE k = 1;");
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-        assertRowsIgnoringOrder(execute("SELECT k,a,b from mv"), row(1, 1, 2));
-        assertRowsIgnoringOrder(execute("SELECT k,a,b from %s"), row(1, 1, 2));
-
-        // set non-key base column as tombstone, view row is removed with shadowable
-        updateView("UPDATE %s USING TIMESTAMP 12 SET a = null WHERE k = 1;");
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-        assertRowsIgnoringOrder(execute("SELECT k,a,b from mv"));
-        assertRowsIgnoringOrder(execute("SELECT k,a,b from %s"), row(1, null, 2));
-
-        // column b should be alive
-        updateView("UPDATE %s USING TIMESTAMP 13 SET a = 1 WHERE k = 1;");
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-        assertRowsIgnoringOrder(execute("SELECT k,a,b from mv"), row(1, 1, 2));
-        assertRowsIgnoringOrder(execute("SELECT k,a,b from %s"), row(1, 1, 2));
-
-        assertInvalidMessage(String.format("Cannot drop column a on base table %s with materialized views", baseTable), "ALTER TABLE %s DROP a");
-    }
-
-    @Test
-    public void testNonBaseColumnInViewPkWithFlush() throws Throwable
-    {
-        testNonBaseColumnInViewPk(true);
-    }
-
-    @Test
-    public void testNonBaseColumnInViewPkWithoutFlush() throws Throwable
-    {
-        testNonBaseColumnInViewPk(true);
-    }
-
-    public void testNonBaseColumnInViewPk(boolean flush) throws Throwable
-    {
-        createTable("create table %s (p1 int, p2 int, v1 int, v2 int, primary key (p1,p2))");
-
-        execute("USE " + keyspace());
-        executeNet(version, "USE " + keyspace());
-        Keyspace ks = Keyspace.open(keyspace());
-
-        createView("mv",
-                   "create materialized view %s as select * from %%s where p1 is not null and p2 is not null primary key (p2, p1)"
-                           + " with gc_grace_seconds=5;");
-        ColumnFamilyStore cfs = ks.getColumnFamilyStore("mv");
-        cfs.disableAutoCompaction();
-
-        updateView("UPDATE %s USING TIMESTAMP 1 set v1 =1 where p1 = 1 AND p2 = 1;");
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-        assertRowsIgnoringOrder(execute("SELECT p1, p2, v1, v2 from %s"), row(1, 1, 1, null));
-        assertRowsIgnoringOrder(execute("SELECT p1, p2, v1, v2 from mv"), row(1, 1, 1, null));
-
-        updateView("UPDATE %s USING TIMESTAMP 2 set v1 = null, v2 = 1 where p1 = 1 AND p2 = 1;");
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-        assertRowsIgnoringOrder(execute("SELECT p1, p2, v1, v2 from %s"), row(1, 1, null, 1));
-        assertRowsIgnoringOrder(execute("SELECT p1, p2, v1, v2 from mv"), row(1, 1, null, 1));
-
-        updateView("UPDATE %s USING TIMESTAMP 2 set v2 = null where p1 = 1 AND p2 = 1;");
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-        assertRowsIgnoringOrder(execute("SELECT p1, p2, v1, v2 from %s"));
-        assertRowsIgnoringOrder(execute("SELECT p1, p2, v1, v2 from mv"));
-
-        updateView("INSERT INTO %s (p1,p2) VALUES(1,1) USING TIMESTAMP 3;");
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-        assertRowsIgnoringOrder(execute("SELECT p1, p2, v1, v2 from %s"), row(1, 1, null, null));
-        assertRowsIgnoringOrder(execute("SELECT p1, p2, v1, v2 from mv"), row(1, 1, null, null));
-
-        updateView("DELETE FROM %s USING TIMESTAMP 4 WHERE p1 =1 AND p2 = 1;");
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-        assertRowsIgnoringOrder(execute("SELECT p1, p2, v1, v2 from %s"));
-        assertRowsIgnoringOrder(execute("SELECT p1, p2, v1, v2 from mv"));
-
-        updateView("UPDATE %s USING TIMESTAMP 5 set v2 = 1 where p1 = 1 AND p2 = 1;");
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-        assertRowsIgnoringOrder(execute("SELECT p1, p2, v1, v2 from %s"), row(1, 1, null, 1));
-        assertRowsIgnoringOrder(execute("SELECT p1, p2, v1, v2 from mv"), row(1, 1, null, 1));
-    }
-
-    @Test
-    public void testStrictLivenessTombstone() throws Throwable
-    {
-        createTable("create table %s (p int primary key, v1 int, v2 int)");
-
-        execute("USE " + keyspace());
-        executeNet(version, "USE " + keyspace());
-        Keyspace ks = Keyspace.open(keyspace());
-
-        createView("mv",
-                   "create materialized view %s as select * from %%s where p is not null and v1 is not null primary key (v1, p)"
-                           + " with gc_grace_seconds=5;");
-        ColumnFamilyStore cfs = ks.getColumnFamilyStore("mv");
-        cfs.disableAutoCompaction();
-
-        updateView("Insert into %s (p, v1, v2) values (1, 1, 1) ;");
-        assertRowsIgnoringOrder(execute("SELECT p, v1, v2 from mv"), row(1, 1, 1));
-
-        updateView("Update %s set v1 = null WHERE p = 1");
-        FBUtilities.waitOnFutures(ks.flush());
-        assertRowsIgnoringOrder(execute("SELECT p, v1, v2 from mv"));
-
-        cfs.forceMajorCompaction(); // before gc grace second, strict-liveness tombstoned dead row remains
-        assertEquals(1, cfs.getLiveSSTables().size());
-
-        Thread.sleep(6000);
-        assertEquals(1, cfs.getLiveSSTables().size()); // no auto compaction.
-
-        cfs.forceMajorCompaction(); // after gc grace second, no data left
-        assertEquals(0, cfs.getLiveSSTables().size());
-
-        updateView("Update %s using ttl 5 set v1 = 1 WHERE p = 1");
-        FBUtilities.waitOnFutures(ks.flush());
-        assertRowsIgnoringOrder(execute("SELECT p, v1, v2 from mv"), row(1, 1, 1));
-
-        cfs.forceMajorCompaction(); // before ttl+gc_grace_second, strict-liveness ttled dead row remains
-        assertEquals(1, cfs.getLiveSSTables().size());
-        assertRowsIgnoringOrder(execute("SELECT p, v1, v2 from mv"), row(1, 1, 1));
-
-        Thread.sleep(5500); // after expired, before gc_grace_second
-        cfs.forceMajorCompaction();// before ttl+gc_grace_second, strict-liveness ttled dead row remains
-        assertEquals(1, cfs.getLiveSSTables().size());
-        assertRowsIgnoringOrder(execute("SELECT p, v1, v2 from mv"));
-
-        Thread.sleep(5500); // after expired + gc_grace_second
-        assertEquals(1, cfs.getLiveSSTables().size()); // no auto compaction.
-
-        cfs.forceMajorCompaction(); // after gc grace second, no data left
-        assertEquals(0, cfs.getLiveSSTables().size());
-    }
-
-    @Test
-    public void testCellTombstoneAndShadowableTombstonesWithFlush() throws Throwable
-    {
-        testCellTombstoneAndShadowableTombstones(true);
-    }
-
-    @Test
-    public void testCellTombstoneAndShadowableTombstonesWithoutFlush() throws Throwable
-    {
-        testCellTombstoneAndShadowableTombstones(false);
-    }
-
-    private void testCellTombstoneAndShadowableTombstones(boolean flush) throws Throwable
-    {
-        createTable("create table %s (p int primary key, v1 int, v2 int)");
-
-        execute("USE " + keyspace());
-        executeNet(version, "USE " + keyspace());
-        Keyspace ks = Keyspace.open(keyspace());
-
-        createView("mv",
-                   "create materialized view %s as select * from %%s where p is not null and v1 is not null primary key (v1, p);");
-        ks.getColumnFamilyStore("mv").disableAutoCompaction();
-
-        // sstable 1, Set initial values TS=1
-        updateView("Insert into %s (p, v1, v2) values (3, 1, 3) using timestamp 1;");
-
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-
-        assertRowsIgnoringOrder(execute("SELECT v2, WRITETIME(v2) from mv WHERE v1 = ? AND p = ?", 1, 3), row(3, 1L));
-        // sstable 2
-        updateView("UPdate %s using timestamp 2 set v2 = null where p = 3");
-
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-
-        assertRowsIgnoringOrder(execute("SELECT v2, WRITETIME(v2) from mv WHERE v1 = ? AND p = ?", 1, 3),
-                                row(null, null));
-        // sstable 3
-        updateView("UPdate %s using timestamp 3 set v1 = 2 where p = 3");
-
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-
-        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from mv"), row(2, 3, null, null));
-        // sstable 4
-        updateView("UPdate %s using timestamp 4 set v1 = 1 where p = 3");
-
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-
-        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from mv"), row(1, 3, null, null));
-
-        if (flush)
-        {
-            // compact sstable 2 and 3;
-            ColumnFamilyStore cfs = ks.getColumnFamilyStore("mv");
-            List<String> sstables = cfs.getLiveSSTables()
-                                       .stream()
-                                       .sorted(Comparator.comparingInt(s -> s.descriptor.generation))
-                                       .map(s -> s.getFilename())
-                                       .collect(Collectors.toList());
-            String dataFiles = String.join(",", Arrays.asList(sstables.get(1), sstables.get(2)));
-            CompactionManager.instance.forceUserDefinedCompaction(dataFiles);
-        }
-        // cell-tombstone in sstable 4 is not compacted away, because the shadowable tombstone is shadowed by new row.
-        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from mv"), row(1, 3, null, null));
-        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from mv limit 1"), row(1, 3, null, null));
-    }
-
-    @Test
-    public void complexTimestampDeletionTestWithFlush() throws Throwable
-    {
-        complexTimestampWithbaseNonPKColumnsInViewPKDeletionTest(true);
-        complexTimestampWithbasePKColumnsInViewPKDeletionTest(true);
-    }
-
-    @Test
-    public void complexTimestampDeletionTestWithoutFlush() throws Throwable
-    {
-        complexTimestampWithbaseNonPKColumnsInViewPKDeletionTest(false);
-        complexTimestampWithbasePKColumnsInViewPKDeletionTest(false);
-    }
-
-    private void complexTimestampWithbasePKColumnsInViewPKDeletionTest(boolean flush) throws Throwable
-    {
-        createTable("create table %s (p1 int, p2 int, v1 int, v2 int, primary key(p1, p2))");
-
-        execute("USE " + keyspace());
-        executeNet(version, "USE " + keyspace());
-        Keyspace ks = Keyspace.open(keyspace());
-
-        createView("mv2",
-                   "create materialized view %s as select * from %%s where p1 is not null and p2 is not null primary key (p2, p1);");
-        ks.getColumnFamilyStore("mv2").disableAutoCompaction();
-
-        // Set initial values TS=1
-        updateView("Insert into %s (p1, p2, v1, v2) values (1, 2, 3, 4) using timestamp 1;");
-
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-
-        assertRowsIgnoringOrder(execute("SELECT v1, v2, WRITETIME(v2) from mv2 WHERE p1 = ? AND p2 = ?", 1, 2),
-                                row(3, 4, 1L));
-        // remove row/mv TS=2
-        updateView("Delete from %s using timestamp 2 where p1 = 1 and p2 = 2;");
-
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-        // view are empty
-        assertRowsIgnoringOrder(execute("SELECT * from mv2"));
-        // insert PK with TS=3
-        updateView("Insert into %s (p1, p2) values (1, 2) using timestamp 3;");
-
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-        // deleted column in MV remained dead
-        assertRowsIgnoringOrder(execute("SELECT * from mv2"), row(2, 1, null, null));
-
-        ks.getColumnFamilyStore("mv2").forceMajorCompaction();
-        assertRowsIgnoringOrder(execute("SELECT * from mv2"), row(2, 1, null, null));
-
-        // reset values
-        updateView("Insert into %s (p1, p2, v1, v2) values (1, 2, 3, 4) using timestamp 10;");
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-
-        assertRowsIgnoringOrder(execute("SELECT v1, v2, WRITETIME(v2) from mv2 WHERE p1 = ? AND p2 = ?", 1, 2),
-                                row(3, 4, 10L));
-
-        updateView("UPDATE %s using timestamp 20 SET v2 = 5 WHERE p1 = 1 and p2 = 2");
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-
-        assertRowsIgnoringOrder(execute("SELECT v1, v2, WRITETIME(v2) from mv2 WHERE p1 = ? AND p2 = ?", 1, 2),
-                                row(3, 5, 20L));
-
-        updateView("DELETE FROM %s using timestamp 10 WHERE p1 = 1 and p2 = 2");
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-
-        assertRowsIgnoringOrder(execute("SELECT v1, v2, WRITETIME(v2) from mv2 WHERE p1 = ? AND p2 = ?", 1, 2),
-                                row(null, 5, 20L));
-    }
-
-    public void complexTimestampWithbaseNonPKColumnsInViewPKDeletionTest(boolean flush) throws Throwable
-    {
-        createTable("create table %s (p int primary key, v1 int, v2 int)");
-
-        execute("USE " + keyspace());
-        executeNet(version, "USE " + keyspace());
-        Keyspace ks = Keyspace.open(keyspace());
-
-        createView("mv",
-                   "create materialized view %s as select * from %%s where p is not null and v1 is not null primary key (v1, p);");
-        ks.getColumnFamilyStore("mv").disableAutoCompaction();
-
-        // Set initial values TS=1
-        updateView("Insert into %s (p, v1, v2) values (3, 1, 5) using timestamp 1;");
-
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-
-        assertRowsIgnoringOrder(execute("SELECT v2, WRITETIME(v2) from mv WHERE v1 = ? AND p = ?", 1, 3), row(5, 1L));
-        // remove row/mv TS=2
-        updateView("Delete from %s using timestamp 2 where p = 3;");
-
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-        // view are empty
-        assertRowsIgnoringOrder(execute("SELECT * from mv"));
-        // insert PK with TS=3
-        updateView("Insert into %s (p, v1) values (3, 1) using timestamp 3;");
-
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-        // deleted column in MV remained dead
-        assertRowsIgnoringOrder(execute("SELECT * from mv"), row(1, 3, null));
-
-        // insert values TS=2, it should be considered dead due to previous tombstone
-        updateView("Insert into %s (p, v1, v2) values (3, 1, 5) using timestamp 2;");
-
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-        // deleted column in MV remained dead
-        assertRowsIgnoringOrder(execute("SELECT * from mv"), row(1, 3, null));
-        assertRowsIgnoringOrder(execute("SELECT * from mv limit 1"), row(1, 3, null));
-
-        // insert values TS=2, it should be considered dead due to previous tombstone
-        executeNet(version, "UPDATE %s USING TIMESTAMP 3 SET v2 = ? WHERE p = ?", 4, 3);
-
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-
-        assertRows(execute("SELECT v1, p, v2, WRITETIME(v2) from mv"), row(1, 3, 4, 3L));
-
-        ks.getColumnFamilyStore("mv").forceMajorCompaction();
-        assertRows(execute("SELECT v1, p, v2, WRITETIME(v2) from mv"), row(1, 3, 4, 3L));
-        assertRows(execute("SELECT v1, p, v2, WRITETIME(v2) from mv limit 1"), row(1, 3, 4, 3L));
-    }
-
-    @Test
-    public void testMVWithDifferentColumnsWithFlush() throws Throwable
-    {
-        testMVWithDifferentColumns(true);
-    }
-
-    @Test
-    public void testMVWithDifferentColumnsWithoutFlush() throws Throwable
-    {
-        testMVWithDifferentColumns(false);
-    }
-
-    private void testMVWithDifferentColumns(boolean flush) throws Throwable
-    {
-        createTable("CREATE TABLE %s (a int, b int, c int, d int, e int, f int, PRIMARY KEY(a, b))");
-
-        execute("USE " + keyspace());
-        executeNet(version, "USE " + keyspace());
-        List<String> viewNames = new ArrayList<>();
-        List<String> mvStatements = Arrays.asList(
-                                                  // all selected
-                                                  "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a IS NOT NULL AND b IS NOT NULL PRIMARY KEY (a,b)",
-                                                  // unselected e,f
-                                                  "CREATE MATERIALIZED VIEW %s AS SELECT a,b,c,d FROM %%s WHERE a IS NOT NULL AND b IS NOT NULL PRIMARY KEY (a,b)",
-                                                  // no selected
-                                                  "CREATE MATERIALIZED VIEW %s AS SELECT a,b FROM %%s WHERE a IS NOT NULL AND b IS NOT NULL PRIMARY KEY (a,b)",
-                                                  // all selected, re-order keys
-                                                  "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a IS NOT NULL AND b IS NOT NULL PRIMARY KEY (b,a)",
-                                                  // unselected e,f, re-order keys
-                                                  "CREATE MATERIALIZED VIEW %s AS SELECT a,b,c,d FROM %%s WHERE a IS NOT NULL AND b IS NOT NULL PRIMARY KEY (b,a)",
-                                                  // no selected, re-order keys
-                                                  "CREATE MATERIALIZED VIEW %s AS SELECT a,b FROM %%s WHERE a IS NOT NULL AND b IS NOT NULL PRIMARY KEY (b,a)");
-
-        Keyspace ks = Keyspace.open(keyspace());
-
-        for (int i = 0; i < mvStatements.size(); i++)
-        {
-            String name = "mv" + i;
-            viewNames.add(name);
-            createView(name, mvStatements.get(i));
-            ks.getColumnFamilyStore(name).disableAutoCompaction();
-        }
-
-        // insert
-        updateViewWithFlush("INSERT INTO %s (a,b,c,d,e,f) VALUES(1,1,1,1,1,1) using timestamp 1", flush);
-        assertBaseViews(row(1, 1, 1, 1, 1, 1), viewNames);
-
-        updateViewWithFlush("UPDATE %s using timestamp 2 SET c=0, d=0 WHERE a=1 AND b=1", flush);
-        assertBaseViews(row(1, 1, 0, 0, 1, 1), viewNames);
-
-        updateViewWithFlush("UPDATE %s using timestamp 2 SET e=0, f=0 WHERE a=1 AND b=1", flush);
-        assertBaseViews(row(1, 1, 0, 0, 0, 0), viewNames);
-
-        updateViewWithFlush("DELETE FROM %s using timestamp 2 WHERE a=1 AND b=1", flush);
-        assertBaseViews(null, viewNames);
-
-        // partial update unselected, selected
-        updateViewWithFlush("UPDATE %s using timestamp 3 SET f=1 WHERE a=1 AND b=1", flush);
-        assertBaseViews(row(1, 1, null, null, null, 1), viewNames);
-
-        updateViewWithFlush("UPDATE %s using timestamp 4 SET e = 1, f=null WHERE a=1 AND b=1", flush);
-        assertBaseViews(row(1, 1, null, null, 1, null), viewNames);
-
-        updateViewWithFlush("UPDATE %s using timestamp 4 SET e = null WHERE a=1 AND b=1", flush);
-        assertBaseViews(null, viewNames);
-
-        updateViewWithFlush("UPDATE %s using timestamp 5 SET c = 1 WHERE a=1 AND b=1", flush);
-        assertBaseViews(row(1, 1, 1, null, null, null), viewNames);
-
-        updateViewWithFlush("UPDATE %s using timestamp 5 SET c = null WHERE a=1 AND b=1", flush);
-        assertBaseViews(null, viewNames);
-
-        updateViewWithFlush("UPDATE %s using timestamp 6 SET d = 1 WHERE a=1 AND b=1", flush);
-        assertBaseViews(row(1, 1, null, 1, null, null), viewNames);
-
-        updateViewWithFlush("UPDATE %s using timestamp 7 SET d = null WHERE a=1 AND b=1", flush);
-        assertBaseViews(null, viewNames);
-
-        updateViewWithFlush("UPDATE %s using timestamp 8 SET f = 1 WHERE a=1 AND b=1", flush);
-        assertBaseViews(row(1, 1, null, null, null, 1), viewNames);
-
-        updateViewWithFlush("UPDATE %s using timestamp 6 SET c = 1 WHERE a=1 AND b=1", flush);
-        assertBaseViews(row(1, 1, 1, null, null, 1), viewNames);
-
-        // view row still alive due to c=1@6
-        updateViewWithFlush("UPDATE %s using timestamp 8 SET f = null WHERE a=1 AND b=1", flush);
-        assertBaseViews(row(1, 1, 1, null, null, null), viewNames);
-
-        updateViewWithFlush("UPDATE %s using timestamp 6 SET c = null WHERE a=1 AND b=1", flush);
-        assertBaseViews(null, viewNames);
-    }
-
-    private void assertBaseViews(Object[] row, List<String> viewNames) throws Throwable
-    {
-        UntypedResultSet result = execute("SELECT * FROM %s");
-        if (row == null)
-            assertRowsIgnoringOrder(result);
-        else
-            assertRowsIgnoringOrder(result, row);
-        for (int i = 0; i < viewNames.size(); i++)
-            assertBaseView(result, execute(String.format("SELECT * FROM %s", viewNames.get(i))), viewNames.get(i));
-    }
-
-    private void assertBaseView(UntypedResultSet base, UntypedResultSet view, String mv)
-    {
-        List<ColumnSpecification> baseMeta = base.metadata();
-        List<ColumnSpecification> viewMeta = view.metadata();
-
-        Iterator<UntypedResultSet.Row> iter = base.iterator();
-        Iterator<UntypedResultSet.Row> viewIter = view.iterator();
-
-        List<UntypedResultSet.Row> baseData = com.google.common.collect.Lists.newArrayList(iter);
-        List<UntypedResultSet.Row> viewData = com.google.common.collect.Lists.newArrayList(viewIter);
-
-        if (baseData.size() != viewData.size())
-            fail(String.format("Mismatch number of rows in view %s: <%s>, in base <%s>",
-                               mv,
-                               makeRowStrings(view),
-                               makeRowStrings(base)));
-        if (baseData.size() == 0)
-            return;
-        if (viewData.size() != 1)
-            fail(String.format("Expect only one row in view %s, but got <%s>",
-                               mv,
-                               makeRowStrings(view)));
-
-        UntypedResultSet.Row row = baseData.get(0);
-        UntypedResultSet.Row viewRow = viewData.get(0);
-
-        Map<String, ByteBuffer> baseValues = new HashMap<>();
-        for (int j = 0; j < baseMeta.size(); j++)
-        {
-            ColumnSpecification column = baseMeta.get(j);
-            ByteBuffer actualValue = row.getBytes(column.name.toString());
-            baseValues.put(column.name.toString(), actualValue);
-        }
-        for (int j = 0; j < viewMeta.size(); j++)
-        {
-            ColumnSpecification column = viewMeta.get(j);
-            String name = column.name.toString();
-            ByteBuffer viewValue = viewRow.getBytes(name);
-            if (!baseValues.containsKey(name))
-            {
-                fail(String.format("Extra column: %s with value %s in view", name, column.type.compose(viewValue)));
-            }
-            else if (!Objects.equal(baseValues.get(name), viewValue))
-            {
-                fail(String.format("Non equal column: %s, expected <%s> but got <%s>",
-                                   name,
-                                   column.type.compose(baseValues.get(name)),
-                                   column.type.compose(viewValue)));
-            }
-        }
-    }
-}
diff --git a/test/long/org/apache/cassandra/cql3/ViewFilteringTest.java b/test/long/org/apache/cassandra/cql3/ViewFilteringTest.java
deleted file mode 100644
index c8b130db7e..0000000000
--- a/test/long/org/apache/cassandra/cql3/ViewFilteringTest.java
+++ /dev/null
@@ -1,2167 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.cassandra.cql3;
-
-import java.util.*;
-import java.util.stream.Collectors;
-
-import org.junit.After;
-import org.junit.AfterClass;
-import org.junit.Before;
-import org.junit.BeforeClass;
-import org.junit.Ignore;
-import org.junit.Test;
-
-import com.datastax.driver.core.exceptions.InvalidQueryException;
-import org.junit.Assert;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-
-import com.datastax.driver.core.exceptions.OperationTimedOutException;
-import org.apache.cassandra.concurrent.SEPExecutor;
-import org.apache.cassandra.concurrent.Stage;
-import org.apache.cassandra.db.Keyspace;
-import org.apache.cassandra.db.SystemKeyspace;
-import org.apache.cassandra.transport.ProtocolVersion;
-import org.apache.cassandra.utils.FBUtilities;
-
-@RunWith(Parameterized.class)
-public class ViewFilteringTest extends CQLTester
-{
-    @Parameterized.Parameter
-    public ProtocolVersion version;
-
-    @Parameterized.Parameters()
-    public static Collection<Object[]> versions()
-    {
-        return ProtocolVersion.SUPPORTED.stream()
-                                        .map(v -> new Object[]{v})
-                                        .collect(Collectors.toList());
-    }
-
-    private final List<String> views = new ArrayList<>();
-
-    @BeforeClass
-    public static void startup()
-    {
-        requireNetwork();
-        System.setProperty("cassandra.mv.allow_filtering_nonkey_columns_unsafe", "true");
-    }
-
-    @AfterClass
-    public static void TearDown()
-    {
-        System.setProperty("cassandra.mv.allow_filtering_nonkey_columns_unsafe", "false");
-    }
-
-    @Before
-    public void begin()
-    {
-        views.clear();
-    }
-
-    @After
-    public void end() throws Throwable
-    {
-        for (String viewName : views)
-            executeNet(version, "DROP MATERIALIZED VIEW " + viewName);
-    }
-
-    private void createView(String name, String query) throws Throwable
-    {
-        try
-        {
-            executeNet(version, String.format(query, name));
-            // If exception is thrown, the view will not be added to the list; since it shouldn't have been created, this is
-            // the desired behavior
-            views.add(name);
-        }
-        catch (OperationTimedOutException ex)
-        {
-            // ... except for timeout, when we actually do not know whether the view was created or not
-            views.add(name);
-            throw ex;
-        }
-    }
-
-    private void updateView(String query, Object... params) throws Throwable
-    {
-        executeNet(version, query, params);
-        while (!(((SEPExecutor) Stage.VIEW_MUTATION.executor()).getPendingTaskCount() == 0
-                 && ((SEPExecutor) Stage.VIEW_MUTATION.executor()).getActiveTaskCount() == 0))
-        {
-            Thread.sleep(1);
-        }
-    }
-
-    private void dropView(String name) throws Throwable
-    {
-        executeNet(version, "DROP MATERIALIZED VIEW " + name);
-        views.remove(name);
-    }
-
-    // TODO will revise the non-pk filter condition in MV, see CASSANDRA-11500
-    @Ignore
-    @Test
-    public void testViewFilteringWithFlush() throws Throwable
-    {
-        testViewFiltering(true);
-    }
-
-    // TODO will revise the non-pk filter condition in MV, see CASSANDRA-11500
-    @Ignore
-    @Test
-    public void testViewFilteringWithoutFlush() throws Throwable
-    {
-        testViewFiltering(false);
-    }
-
-    public void testViewFiltering(boolean flush) throws Throwable
-    {
-        // CASSANDRA-13547: able to shadow entire view row if base column used in filter condition is modified
-        createTable("CREATE TABLE %s (a int, b int, c int, d int, PRIMARY KEY (a))");
-
-        execute("USE " + keyspace());
-        executeNet(version, "USE " + keyspace());
-
-        createView("mv_test1",
-                   "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a IS NOT NULL AND b IS NOT NULL and c = 1  PRIMARY KEY (a, b)");
-        createView("mv_test2",
-                   "CREATE MATERIALIZED VIEW %s AS SELECT c, d FROM %%s WHERE a IS NOT NULL AND b IS NOT NULL and c = 1 and d = 1 PRIMARY KEY (a, b)");
-        createView("mv_test3",
-                   "CREATE MATERIALIZED VIEW %s AS SELECT a, b, c, d FROM %%s WHERE a IS NOT NULL AND b IS NOT NULL PRIMARY KEY (a, b)");
-        createView("mv_test4",
-                   "CREATE MATERIALIZED VIEW %s AS SELECT c FROM %%s WHERE a IS NOT NULL AND b IS NOT NULL and c = 1 PRIMARY KEY (a, b)");
-        createView("mv_test5",
-                   "CREATE MATERIALIZED VIEW %s AS SELECT c FROM %%s WHERE a IS NOT NULL and d = 1 PRIMARY KEY (a, d)");
-        createView("mv_test6",
-                   "CREATE MATERIALIZED VIEW %s AS SELECT c FROM %%s WHERE a = 1 and d IS NOT NULL PRIMARY KEY (a, d)");
-
-        waitForView(keyspace(), "mv_test1");
-        waitForView(keyspace(), "mv_test2");
-        waitForView(keyspace(), "mv_test3");
-        waitForView(keyspace(), "mv_test4");
-        waitForView(keyspace(), "mv_test5");
-        waitForView(keyspace(), "mv_test6");
-
-        Keyspace ks = Keyspace.open(keyspace());
-        ks.getColumnFamilyStore("mv_test1").disableAutoCompaction();
-        ks.getColumnFamilyStore("mv_test2").disableAutoCompaction();
-        ks.getColumnFamilyStore("mv_test3").disableAutoCompaction();
-        ks.getColumnFamilyStore("mv_test4").disableAutoCompaction();
-        ks.getColumnFamilyStore("mv_test5").disableAutoCompaction();
-        ks.getColumnFamilyStore("mv_test6").disableAutoCompaction();
-
-
-        execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?) using timestamp 0", 1, 1, 1, 1);
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-
-        // views should be updated.
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test1"), row(1, 1, 1, 1));
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test2"), row(1, 1, 1, 1));
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test3"), row(1, 1, 1, 1));
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test4"), row(1, 1, 1));
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test5"), row(1, 1, 1));
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test6"), row(1, 1, 1));
-
-        updateView("UPDATE %s using timestamp 1 set c = ? WHERE a=?", 0, 1);
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-
-        assertRowCount(execute("SELECT * FROM mv_test1"), 0);
-        assertRowCount(execute("SELECT * FROM mv_test2"), 0);
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test3"), row(1, 1, 0, 1));
-        assertRowCount(execute("SELECT * FROM mv_test4"), 0);
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test5"), row(1, 1, 0));
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test6"), row(1, 1, 0));
-
-        updateView("UPDATE %s using timestamp 2 set c = ? WHERE a=?", 1, 1);
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-
-        // row should be back in views.
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test1"), row(1, 1, 1, 1));
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test2"), row(1, 1, 1, 1));
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test3"), row(1, 1, 1, 1));
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test4"), row(1, 1, 1));
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test5"), row(1, 1, 1));
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test6"), row(1, 1, 1));
-
-        updateView("UPDATE %s using timestamp 3 set d = ? WHERE a=?", 0, 1);
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test1"), row(1, 1, 1, 0));
-        assertRowCount(execute("SELECT * FROM mv_test2"), 0);
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test3"), row(1, 1, 1, 0));
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test4"), row(1, 1, 1));
-        assertRowCount(execute("SELECT * FROM mv_test5"), 0);
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test6"), row(1, 0, 1));
-
-        updateView("UPDATE %s using timestamp 4 set c = ? WHERE a=?", 0, 1);
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-
-        assertRowCount(execute("SELECT * FROM mv_test1"), 0);
-        assertRowCount(execute("SELECT * FROM mv_test2"), 0);
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test3"), row(1, 1, 0, 0));
-        assertRowCount(execute("SELECT * FROM mv_test4"), 0);
-        assertRowCount(execute("SELECT * FROM mv_test5"), 0);
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test6"), row(1, 0, 0));
-
-        updateView("UPDATE %s using timestamp 5 set d = ? WHERE a=?", 1, 1);
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-
-        // should not update as c=0
-        assertRowCount(execute("SELECT * FROM mv_test1"), 0);
-        assertRowCount(execute("SELECT * FROM mv_test2"), 0);
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test3"), row(1, 1, 0, 1));
-        assertRowCount(execute("SELECT * FROM mv_test4"), 0);
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test5"), row(1, 1, 0));
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test6"), row(1, 1, 0));
-
-        updateView("UPDATE %s using timestamp 6 set c = ? WHERE a=?", 1, 1);
-
-        // row should be back in views.
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test1"), row(1, 1, 1, 1));
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test2"), row(1, 1, 1, 1));
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test3"), row(1, 1, 1, 1));
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test4"), row(1, 1, 1));
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test5"), row(1, 1, 1));
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test6"), row(1, 1, 1));
-
-        updateView("UPDATE %s using timestamp 7 set b = ? WHERE a=?", 2, 1);
-        if (flush)
-        {
-            FBUtilities.waitOnFutures(ks.flush());
-            for (String view : views)
-                ks.getColumnFamilyStore(view).forceMajorCompaction();
-        }
-        // row should be back in views.
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test1"), row(1, 2, 1, 1));
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test2"), row(1, 2, 1, 1));
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test3"), row(1, 2, 1, 1));
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test4"), row(1, 2, 1));
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test5"), row(1, 1, 1));
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test6"), row(1, 1, 1));
-
-        updateView("DELETE b, c FROM %s using timestamp 6 WHERE a=?", 1);
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-
-        assertRowsIgnoringOrder(execute("SELECT * FROM %s"), row(1, 2, null, 1));
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test1"));
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test2"));
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test3"), row(1, 2, null, 1));
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test4"));
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test5"), row(1, 1, null));
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test6"), row(1, 1, null));
-
-        updateView("DELETE FROM %s using timestamp 8 where a=?", 1);
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-
-        assertRowCount(execute("SELECT * FROM mv_test1"), 0);
-        assertRowCount(execute("SELECT * FROM mv_test2"), 0);
-        assertRowCount(execute("SELECT * FROM mv_test3"), 0);
-        assertRowCount(execute("SELECT * FROM mv_test4"), 0);
-        assertRowCount(execute("SELECT * FROM mv_test5"), 0);
-        assertRowCount(execute("SELECT * FROM mv_test6"), 0);
-
-        updateView("UPDATE %s using timestamp 9 set b = ?,c = ? where a=?", 1, 1, 1); // upsert
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test1"), row(1, 1, 1, null));
-        assertRows(execute("SELECT * FROM mv_test2"));
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test3"), row(1, 1, 1, null));
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test4"), row(1, 1, 1));
-        assertRows(execute("SELECT * FROM mv_test5"));
-        assertRows(execute("SELECT * FROM mv_test6"));
-
-        updateView("DELETE FROM %s using timestamp 10 where a=?", 1);
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-
-        assertRowCount(execute("SELECT * FROM mv_test1"), 0);
-        assertRowCount(execute("SELECT * FROM mv_test2"), 0);
-        assertRowCount(execute("SELECT * FROM mv_test3"), 0);
-        assertRowCount(execute("SELECT * FROM mv_test4"), 0);
-        assertRowCount(execute("SELECT * FROM mv_test5"), 0);
-        assertRowCount(execute("SELECT * FROM mv_test6"), 0);
-
-        execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?) using timestamp 11", 1, 1, 1, 1);
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-
-        // row should be back in views.
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test1"), row(1, 1, 1, 1));
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test2"), row(1, 1, 1, 1));
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test3"), row(1, 1, 1, 1));
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test4"), row(1, 1, 1));
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test5"), row(1, 1, 1));
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test6"), row(1, 1, 1));
-
-        updateView("DELETE FROM %s using timestamp 12 where a=?", 1);
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-
-        assertRowCount(execute("SELECT * FROM mv_test1"), 0);
-        assertRowCount(execute("SELECT * FROM mv_test2"), 0);
-        assertRowCount(execute("SELECT * FROM mv_test3"), 0);
-        assertRowCount(execute("SELECT * FROM mv_test4"), 0);
-        assertRowCount(execute("SELECT * FROM mv_test5"), 0);
-        assertRowCount(execute("SELECT * FROM mv_test6"), 0);
-
-        dropView("mv_test1");
-        dropView("mv_test2");
-        dropView("mv_test3");
-        dropView("mv_test4");
-        dropView("mv_test5");
-        dropView("mv_test6");
-        dropTable("DROP TABLE %s");
-    }
-
-    // TODO will revise the non-pk filter condition in MV, see CASSANDRA-11500
-    @Ignore
-    @Test
-    public void testMVFilteringWithComplexColumn() throws Throwable
-    {
-        createTable("CREATE TABLE %s (a int, b int, c int, l list<int>, s set<int>, m map<int,int>, PRIMARY KEY (a, b))");
-
-        execute("USE " + keyspace());
-        executeNet(version, "USE " + keyspace());
-
-        createView("mv_test1",
-                   "CREATE MATERIALIZED VIEW %s AS SELECT a,b,c FROM %%s WHERE a IS NOT NULL AND b IS NOT NULL AND c IS NOT NULL "
-                   + "and l contains (1) AND s contains (1) AND m contains key (1) PRIMARY KEY (a, b, c)");
-        createView("mv_test2",
-                   "CREATE MATERIALIZED VIEW %s AS SELECT a,b FROM %%s WHERE a IS NOT NULL and b IS NOT NULL AND l contains (1) PRIMARY KEY (a, b)");
-        createView("mv_test3",
-                   "CREATE MATERIALIZED VIEW %s AS SELECT a,b FROM %%s WHERE a IS NOT NULL AND b IS NOT NULL AND s contains (1) PRIMARY KEY (a, b)");
-        createView("mv_test4",
-                   "CREATE MATERIALIZED VIEW %s AS SELECT a,b FROM %%s WHERE a IS NOT NULL AND b IS NOT NULL AND m contains key (1) PRIMARY KEY (a, b)");
-
-        waitForView(keyspace(), "mv_test1");
-        waitForView(keyspace(), "mv_test2");
-        waitForView(keyspace(), "mv_test3");
-        waitForView(keyspace(), "mv_test4");
-
-        // not able to drop base column filtered in view
-        assertInvalidMessage("Cannot drop column l, depended on by materialized views", "ALTER TABLE %s DROP l");
-        assertInvalidMessage("Cannot drop column s, depended on by materialized views", "ALTER TABLE %S DROP s");
-        assertInvalidMessage("Cannot drop column m, depended on by materialized views", "ALTER TABLE %s DROP m");
-
-        Keyspace ks = Keyspace.open(keyspace());
-        ks.getColumnFamilyStore("mv_test1").disableAutoCompaction();
-        ks.getColumnFamilyStore("mv_test2").disableAutoCompaction();
-        ks.getColumnFamilyStore("mv_test3").disableAutoCompaction();
-        ks.getColumnFamilyStore("mv_test4").disableAutoCompaction();
-
-        execute("INSERT INTO %s (a, b, c, l, s, m) VALUES (?, ?, ?, ?, ?, ?) ",
-                1,
-                1,
-                1,
-                list(1, 1, 2),
-                set(1, 2),
-                map(1, 1, 2, 2));
-        FBUtilities.waitOnFutures(ks.flush());
-
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test1"), row(1, 1, 1));
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test2"), row(1, 1));
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test3"), row(1, 1));
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test4"), row(1, 1));
-
-
-        execute("UPDATE %s SET l=l-[1] WHERE a = 1 AND b = 1" );
-        FBUtilities.waitOnFutures(ks.flush());
-
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test1"));
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test2"));
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test3"), row(1, 1));
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test4"), row(1, 1));
-
-        execute("UPDATE %s SET s=s-{2}, m=m-{2} WHERE a = 1 AND b = 1");
-        FBUtilities.waitOnFutures(ks.flush());
-
-        assertRowsIgnoringOrder(execute("SELECT a,b,c FROM %s"), row(1, 1, 1));
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test1"));
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test2"));
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test3"), row(1, 1));
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test4"), row(1, 1));
-
-        execute("UPDATE %s SET  m=m-{1} WHERE a = 1 AND b = 1");
-        FBUtilities.waitOnFutures(ks.flush());
-
-        assertRowsIgnoringOrder(execute("SELECT a,b,c FROM %s"), row(1, 1, 1));
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test1"));
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test2"));
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test3"), row(1, 1));
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test4"));
-
-        // filter conditions result not changed
-        execute("UPDATE %s SET  l=l+[2], s=s-{0}, m=m+{3:3} WHERE a = 1 AND b = 1");
-        FBUtilities.waitOnFutures(ks.flush());
-
-        assertRowsIgnoringOrder(execute("SELECT a,b,c FROM %s"), row(1, 1, 1));
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test1"));
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test2"));
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test3"), row(1, 1));
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test4"));
-    }
-
-    @Test
-    public void testMVCreationSelectRestrictions() throws Throwable
-    {
-        createTable("CREATE TABLE %s (a int, b int, c int, d int, e int, PRIMARY KEY((a, b), c, d))");
-
-        execute("USE " + keyspace());
-        executeNet(version, "USE " + keyspace());
-
-        // IS NOT NULL is required on all PK statements that are not otherwise restricted
-        List<String> badStatements = Arrays.asList(
-        "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE b IS NOT NULL AND c IS NOT NULL AND d is NOT NULL PRIMARY KEY ((a, b), c, d)",
-        "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a IS NOT NULL AND c IS NOT NULL AND d is NOT NULL PRIMARY KEY ((a, b), c, d)",
-        "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a IS NOT NULL AND b IS NOT NULL AND d is NOT NULL PRIMARY KEY ((a, b), c, d)",
-        "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a IS NOT NULL AND b IS NOT NULL AND c is NOT NULL PRIMARY KEY ((a, b), c, d)",
-        "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a = ? AND b IS NOT NULL AND c is NOT NULL PRIMARY KEY ((a, b), c, d)",
-        "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a = blobAsInt(?) AND b IS NOT NULL AND c is NOT NULL PRIMARY KEY ((a, b), c, d)",
-        "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s PRIMARY KEY (a, b, c, d)"
-        );
-
-        for (String badStatement : badStatements)
-        {
-            try
-            {
-                createView("mv1_test", badStatement);
-                Assert.fail("Create MV statement should have failed due to missing IS NOT NULL restriction: " + badStatement);
-            }
-            catch (InvalidQueryException exc) {}
-        }
-
-        List<String> goodStatements = Arrays.asList(
-        "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a = 1 AND b = 1 AND c IS NOT NULL AND d is NOT NULL PRIMARY KEY ((a, b), c, d)",
-        "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a IS NOT NULL AND b IS NOT NULL AND c = 1 AND d IS NOT NULL PRIMARY KEY ((a, b), c, d)",
-        "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a IS NOT NULL AND b IS NOT NULL AND c = 1 AND d = 1 PRIMARY KEY ((a, b), c, d)",
-        "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a = 1 AND b = 1 AND c = 1 AND d = 1 PRIMARY KEY ((a, b), c, d)",
-        "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a = 1 AND b = 1 AND c > 1 AND d IS NOT NULL PRIMARY KEY ((a, b), c, d)",
-        "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a = 1 AND b = 1 AND c = 1 AND d IN (1, 2, 3) PRIMARY KEY ((a, b), c, d)",
-        "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a = 1 AND b = 1 AND (c, d) = (1, 1) PRIMARY KEY ((a, b), c, d)",
-        "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a = 1 AND b = 1 AND (c, d) > (1, 1) PRIMARY KEY ((a, b), c, d)",
-        "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a = 1 AND b = 1 AND (c, d) IN ((1, 1), (2, 2)) PRIMARY KEY ((a, b), c, d)",
-        "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a = (int) 1 AND b = 1 AND c = 1 AND d = 1 PRIMARY KEY ((a, b), c, d)",
-        "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a = blobAsInt(intAsBlob(1)) AND b = 1 AND c = 1 AND d = 1 PRIMARY KEY ((a, b), c, d)"
-        );
-
-        for (int i = 0; i < goodStatements.size(); i++)
-        {
-            try
-            {
-                createView("mv" + i + "_test", goodStatements.get(i));
-            }
-            catch (Exception e)
-            {
-                throw new RuntimeException("MV creation failed: " + goodStatements.get(i), e);
-            }
-
-            try
-            {
-                executeNet(version, "ALTER MATERIALIZED VIEW mv" + i + "_test WITH compaction = { 'class' : 'LeveledCompactionStrategy' }");
-            }
-            catch (Exception e)
-            {
-                throw new RuntimeException("MV alter failed: " + goodStatements.get(i), e);
-            }
-        }
-    }
-
-    @Test
-    public void testCaseSensitivity() throws Throwable
-    {
-        createTable("CREATE TABLE %s (\"theKey\" int, \"theClustering\" int, \"the\"\"Value\" int, PRIMARY KEY (\"theKey\", \"theClustering\"))");
-
-        execute("USE " + keyspace());
-        executeNet(version, "USE " + keyspace());
-
-        execute("INSERT INTO %s (\"theKey\", \"theClustering\", \"the\"\"Value\") VALUES (?, ?, ?)", 0, 0, 0);
-        execute("INSERT INTO %s (\"theKey\", \"theClustering\", \"the\"\"Value\") VALUES (?, ?, ?)", 0, 1, 0);
-        execute("INSERT INTO %s (\"theKey\", \"theClustering\", \"the\"\"Value\") VALUES (?, ?, ?)", 1, 0, 0);
-        execute("INSERT INTO %s (\"theKey\", \"theClustering\", \"the\"\"Value\") VALUES (?, ?, ?)", 1, 1, 0);
-
-        createView("mv_test", "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s " +
-                              "WHERE \"theKey\" = 1 AND \"theClustering\" = 1 AND \"the\"\"Value\" IS NOT NULL " +
-                              "PRIMARY KEY (\"theKey\", \"theClustering\")");
-
-        while (!SystemKeyspace.isViewBuilt(keyspace(), "mv_test"))
-            Thread.sleep(10);
-        createView("mv_test2", "CREATE MATERIALIZED VIEW %s AS SELECT \"theKey\", \"theClustering\", \"the\"\"Value\" FROM %%s " +
-                               "WHERE \"theKey\" = 1 AND \"theClustering\" = 1 AND \"the\"\"Value\" IS NOT NULL " +
-                               "PRIMARY KEY (\"theKey\", \"theClustering\")");
-        while (!SystemKeyspace.isViewBuilt(keyspace(), "mv_test2"))
-            Thread.sleep(10);
-
-        for (String mvname : Arrays.asList("mv_test", "mv_test2"))
-        {
-            assertRowsIgnoringOrder(execute("SELECT \"theKey\", \"theClustering\", \"the\"\"Value\" FROM " + mvname),
-                                    row(1, 1, 0)
-            );
-        }
-
-        executeNet(version, "ALTER TABLE %s RENAME \"theClustering\" TO \"Col\"");
-
-        for (String mvname : Arrays.asList("mv_test", "mv_test2"))
-        {
-            assertRowsIgnoringOrder(execute("SELECT \"theKey\", \"Col\", \"the\"\"Value\" FROM " + mvname),
-                                    row(1, 1, 0)
-            );
-        }
-    }
-
-    @Test
-    public void testFilterWithFunction() throws Throwable
-    {
-        createTable("CREATE TABLE %s (a int, b int, c int, PRIMARY KEY (a, b))");
-
-        execute("USE " + keyspace());
-        executeNet(version, "USE " + keyspace());
-
-        execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?)", 0, 0, 0);
-        execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?)", 0, 1, 1);
-        execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?)", 1, 0, 2);
-        execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?)", 1, 1, 3);
-
-        createView("mv_test", "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s " +
-                              "WHERE a = blobAsInt(intAsBlob(1)) AND b IS NOT NULL " +
-                              "PRIMARY KEY (a, b)");
-
-        while (!SystemKeyspace.isViewBuilt(keyspace(), "mv_test"))
-            Thread.sleep(10);
-
-        assertRows(execute("SELECT a, b, c FROM mv_test"),
-                   row(1, 0, 2),
-                   row(1, 1, 3)
-        );
-
-        executeNet(version, "ALTER TABLE %s RENAME a TO foo");
-
-        assertRows(execute("SELECT foo, b, c FROM mv_test"),
-                   row(1, 0, 2),
-                   row(1, 1, 3)
-        );
-    }
-
-    @Test
-    public void testFilterWithTypecast() throws Throwable
-    {
-        createTable("CREATE TABLE %s (a int, b int, c int, PRIMARY KEY (a, b))");
-
-        execute("USE " + keyspace());
-        executeNet(version, "USE " + keyspace());
-
-        execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?)", 0, 0, 0);
-        execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?)", 0, 1, 1);
-        execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?)", 1, 0, 2);
-        execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?)", 1, 1, 3);
-
-        createView("mv_test", "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s " +
-                              "WHERE a = (int) 1 AND b IS NOT NULL " +
-                              "PRIMARY KEY (a, b)");
-
-        while (!SystemKeyspace.isViewBuilt(keyspace(), "mv_test"))
-            Thread.sleep(10);
-
-        assertRows(execute("SELECT a, b, c FROM mv_test"),
-                   row(1, 0, 2),
-                   row(1, 1, 3)
-        );
-
-        executeNet(version, "ALTER TABLE %s RENAME a TO foo");
-
-        assertRows(execute("SELECT foo, b, c FROM mv_test"),
-                   row(1, 0, 2),
-                   row(1, 1, 3)
-        );
-    }
-
-    @Test
-    public void testPartitionKeyFilteringUnrestrictedPart() throws Throwable
-    {
-        List<String> mvPrimaryKeys = Arrays.asList("((a, b), c)", "((b, a), c)", "(a, b, c)", "(c, b, a)", "((c, a), b)");
-        for (int i = 0; i < mvPrimaryKeys.size(); i++)
-        {
-            createTable("CREATE TABLE %s (a int, b int, c int, d int, PRIMARY KEY ((a, b), c))");
-
-            execute("USE " + keyspace());
-            executeNet(version, "USE " + keyspace());
-
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 0, 0, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 1, 0, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 0, 0, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 0, 1, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 0, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 1, 0);
-
-            logger.info("Testing MV primary key: {}", mvPrimaryKeys.get(i));
-
-            // only accept rows where a = 1
-            String viewName= "mv_test" + i;
-            createView(viewName, "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a = 1 AND b IS NOT NULL AND c IS NOT NULL PRIMARY KEY " + mvPrimaryKeys.get(i));
-
-            waitForView(keyspace(), viewName);
-
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(1, 0, 0, 0),
-                                    row(1, 0, 1, 0),
-                                    row(1, 1, 0, 0),
-                                    row(1, 1, 1, 0)
-            );
-
-            // insert new rows that do not match the filter
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 2, 0, 0, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 2, 1, 0, 0);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(1, 0, 0, 0),
-                                    row(1, 0, 1, 0),
-                                    row(1, 1, 0, 0),
-                                    row(1, 1, 1, 0)
-            );
-
-            // insert new row that does match the filter
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 2, 0);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(1, 0, 0, 0),
-                                    row(1, 0, 1, 0),
-                                    row(1, 1, 0, 0),
-                                    row(1, 1, 1, 0),
-                                    row(1, 1, 2, 0)
-            );
-
-            // update rows that don't match the filter
-            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 0, 0, 0);
-            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 0, 1, 0);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(1, 0, 0, 0),
-                                    row(1, 0, 1, 0),
-                                    row(1, 1, 0, 0),
-                                    row(1, 1, 1, 0),
-                                    row(1, 1, 2, 0)
-            );
-
-            // update a row that does match the filter
-            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 1, 1, 0);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(1, 0, 0, 0),
-                                    row(1, 0, 1, 0),
-                                    row(1, 1, 0, 1),
-                                    row(1, 1, 1, 0),
-                                    row(1, 1, 2, 0)
-            );
-
-            // delete rows that don't match the filter
-            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 0, 0, 0);
-            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 0, 1, 0);
-            execute("DELETE FROM %s WHERE a = ? AND b = ?", 0, 0);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(1, 0, 0, 0),
-                                    row(1, 0, 1, 0),
-                                    row(1, 1, 0, 1),
-                                    row(1, 1, 1, 0),
-                                    row(1, 1, 2, 0)
-            );
-
-            // delete a row that does match the filter
-            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 1, 1, 0);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(1, 0, 0, 0),
-                                    row(1, 0, 1, 0),
-                                    row(1, 1, 1, 0),
-                                    row(1, 1, 2, 0)
-            );
-
-            // delete a partition that matches the filter
-            execute("DELETE FROM %s WHERE a = ? AND b = ?", 1, 0);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(1, 1, 1, 0),
-                                    row(1, 1, 2, 0));
-            execute("DELETE FROM %s WHERE a = ? AND b = ?", 1, 1);
-            assertEmpty(execute("SELECT * FROM mv_test" + i));
-        }
-    }
-
-    @Test
-    public void testPartitionKeyFilteringWithSlice() throws Throwable
-    {
-        List<String> mvPrimaryKeys = Arrays.asList("((a, b), c)", "((b, a), c)", "(a, b, c)", "(c, b, a)", "((c, a), b)");
-        for (int i = 0; i < mvPrimaryKeys.size(); i++)
-        {
-            createTable("CREATE TABLE %s (a int, b int, c int, d int, PRIMARY KEY ((a, b), c))");
-
-            execute("USE " + keyspace());
-            executeNet(version, "USE " + keyspace());
-
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 0,  1, 1);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 10, 1, 2);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 0,  2, 1);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 10, 2, 2);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 2, 1,  3, 1);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 2, 10, 3, 2);
-
-            logger.info("Testing MV primary key: {}", mvPrimaryKeys.get(i));
-
-            // only accept rows where a = 1
-            String viewName= "mv_test" + i;
-            createView(viewName, "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a > 0 AND b > 5 AND c IS NOT NULL PRIMARY KEY " + mvPrimaryKeys.get(i));
-
-            waitForView(keyspace(), viewName);
-
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(1, 10, 2, 2),
-                                    row(2, 10, 3, 2)
-            );
-
-            // insert new rows that do not match the filter
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 2, 0, 0, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 2, 1, 0, 0);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(1, 10, 2, 2),
-                                    row(2, 10, 3, 2)
-            );
-
-            // insert new row that does match the filter
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 3, 10, 4, 2);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(1, 10, 2, 2),
-                                    row(2, 10, 3, 2),
-                                    row(3, 10, 4, 2)
-            );
-
-            // update rows that don't match the filter
-            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 0, 0, 0);
-            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 0, 1, 0);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(1, 10, 2, 2),
-                                    row(2, 10, 3, 2),
-                                    row(3, 10, 4, 2)
-            );
-
-            // update a row that does match the filter
-            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 100, 3, 10, 4);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(1, 10, 2, 2),
-                                    row(2, 10, 3, 2),
-                                    row(3, 10, 4, 100)
-            );
-
-            // delete rows that don't match the filter
-            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 0, 0, 0);
-            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 0, 1, 0);
-            execute("DELETE FROM %s WHERE a = ? AND b = ?", 0, 0);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(1, 10, 2, 2),
-                                    row(2, 10, 3, 2),
-                                    row(3, 10, 4, 100)
-            );
-
-            // delete a row that does match the filter
-            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 1, 1, 0);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(1, 10, 2, 2),
-                                    row(2, 10, 3, 2),
-                                    row(3, 10, 4, 100)
-            );
-
-            // delete a partition that matches the filter
-            execute("DELETE FROM %s WHERE a = ? AND b = ?", 1, 10);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(2, 10, 3, 2),
-                                    row(3, 10, 4, 100));
-        }
-    }
-
-
-
-
-    private static void waitForView(String keyspace, String view) throws InterruptedException
-    {
-        while (!SystemKeyspace.isViewBuilt(keyspace, view))
-            Thread.sleep(10);
-    }
-
-    @Test
-    public void testPartitionKeyRestrictions() throws Throwable
-    {
-        List<String> mvPrimaryKeys = Arrays.asList("((a, b), c)", "((b, a), c)", "(a, b, c)", "(c, b, a)", "((c, a), b)");
-        for (int i = 0; i < mvPrimaryKeys.size(); i++)
-        {
-            createTable("CREATE TABLE %s (a int, b int, c int, d int, PRIMARY KEY (a, b, c))");
-
-            execute("USE " + keyspace());
-            executeNet(version, "USE " + keyspace());
-
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 0, 0, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 1, 0, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 0, 0, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 0, 1, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 0, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 1, 0);
-
-            logger.info("Testing MV primary key: {}", mvPrimaryKeys.get(i));
-
-            // only accept rows where a = 1
-            createView("mv_test" + i, "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a = 1 AND b IS NOT NULL AND c IS NOT NULL PRIMARY KEY " + mvPrimaryKeys.get(i));
-
-            while (!SystemKeyspace.isViewBuilt(keyspace(), "mv_test" + i))
-                Thread.sleep(10);
-
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(1, 0, 0, 0),
-                                    row(1, 0, 1, 0),
-                                    row(1, 1, 0, 0),
-                                    row(1, 1, 1, 0)
-            );
-
-            // insert new rows that do not match the filter
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 2, 0, 0, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 2, 1, 0, 0);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(1, 0, 0, 0),
-                                    row(1, 0, 1, 0),
-                                    row(1, 1, 0, 0),
-                                    row(1, 1, 1, 0)
-            );
-
-            // insert new row that does match the filter
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 2, 0);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(1, 0, 0, 0),
-                                    row(1, 0, 1, 0),
-                                    row(1, 1, 0, 0),
-                                    row(1, 1, 1, 0),
-                                    row(1, 1, 2, 0)
-            );
-
-            // update rows that don't match the filter
-            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 0, 0, 0);
-            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 0, 1, 0);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(1, 0, 0, 0),
-                                    row(1, 0, 1, 0),
-                                    row(1, 1, 0, 0),
-                                    row(1, 1, 1, 0),
-                                    row(1, 1, 2, 0)
-            );
-
-            // update a row that does match the filter
-            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 1, 1, 0);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(1, 0, 0, 0),
-                                    row(1, 0, 1, 0),
-                                    row(1, 1, 0, 1),
-                                    row(1, 1, 1, 0),
-                                    row(1, 1, 2, 0)
-            );
-
-            // delete rows that don't match the filter
-            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 0, 0, 0);
-            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 0, 1, 0);
-            execute("DELETE FROM %s WHERE a = ? AND b = ?", 0, 0);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(1, 0, 0, 0),
-                                    row(1, 0, 1, 0),
-                                    row(1, 1, 0, 1),
-                                    row(1, 1, 1, 0),
-                                    row(1, 1, 2, 0)
-            );
-
-            // delete a row that does match the filter
-            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 1, 1, 0);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(1, 0, 0, 0),
-                                    row(1, 0, 1, 0),
-                                    row(1, 1, 1, 0),
-                                    row(1, 1, 2, 0)
-            );
-
-            // delete a partition that matches the filter
-            execute("DELETE FROM %s WHERE a = ?", 1);
-            assertEmpty(execute("SELECT * FROM mv_test" + i));
-        }
-    }
-
-    @Test
-    public void testCompoundPartitionKeyRestrictions() throws Throwable
-    {
-        List<String> mvPrimaryKeys = Arrays.asList("((a, b), c)", "((b, a), c)", "(a, b, c)", "(c, b, a)", "((c, a), b)");
-        for (int i = 0; i < mvPrimaryKeys.size(); i++)
-        {
-            createTable("CREATE TABLE %s (a int, b int, c int, d int, PRIMARY KEY ((a, b), c))");
-
-            execute("USE " + keyspace());
-            executeNet(version, "USE " + keyspace());
-
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 0, 0, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 0, 1, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 1, 0, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 1, 1, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 0, 0, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 0, 1, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 0, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 1, 0);
-
-            logger.info("Testing MV primary key: {}", mvPrimaryKeys.get(i));
-
-            // only accept rows where a = 1 and b = 1
-            createView("mv_test" + i, "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a = 1 AND b = 1 AND c IS NOT NULL PRIMARY KEY " + mvPrimaryKeys.get(i));
-
-            while (!SystemKeyspace.isViewBuilt(keyspace(), "mv_test" + i))
-                Thread.sleep(10);
-
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(1, 1, 0, 0),
-                                    row(1, 1, 1, 0)
-            );
-
-            // insert new rows that do not match the filter
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 2, 0, 0, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 2, 1, 0, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 2, 0, 0);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(1, 1, 0, 0),
-                                    row(1, 1, 1, 0)
-            );
-
-            // insert new row that does match the filter
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 2, 0);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(1, 1, 0, 0),
-                                    row(1, 1, 1, 0),
-                                    row(1, 1, 2, 0)
-            );
-
-            // update rows that don't match the filter
-            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 0, 0, 0);
-            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 1, 0, 0);
-            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 0, 1, 0);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(1, 1, 0, 0),
-                                    row(1, 1, 1, 0),
-                                    row(1, 1, 2, 0)
-            );
-
-            // update a row that does match the filter
-            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 1, 1, 0);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(1, 1, 0, 1),
-                                    row(1, 1, 1, 0),
-                                    row(1, 1, 2, 0)
-            );
-
-            // delete rows that don't match the filter
-            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 0, 0, 0);
-            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 1, 0, 0);
-            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 0, 1, 0);
-            execute("DELETE FROM %s WHERE a = ? AND b = ?", 0, 0);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(1, 1, 0, 1),
-                                    row(1, 1, 1, 0),
-                                    row(1, 1, 2, 0)
-            );
-
-            // delete a row that does match the filter
-            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 1, 1, 0);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(1, 1, 1, 0),
-                                    row(1, 1, 2, 0)
-            );
-
-            // delete a partition that matches the filter
-            execute("DELETE FROM %s WHERE a = ? AND b = ?", 1, 1);
-            assertEmpty(execute("SELECT * FROM mv_test" + i));
-        }
-    }
-
-    @Test
-    public void testCompoundPartitionKeyRestrictionsNotIncludeAll() throws Throwable
-    {
-        createTable("CREATE TABLE %s (a int, b int, c int, d int, PRIMARY KEY ((a, b), c))");
-        execute("USE " + keyspace());
-        executeNet(version, "USE " + keyspace());
-
-        execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 0, 0, 0);
-        execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 0, 1, 0);
-        execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 1, 0, 0);
-        execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 1, 1, 0);
-        execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 0, 0, 0);
-        execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 0, 1, 0);
-        execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 0, 0);
-        execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 1, 0);
-
-        // only accept rows where a = 1 and b = 1, don't include column d in the selection
-        createView("mv_test", "CREATE MATERIALIZED VIEW %s AS SELECT a, b, c FROM %%s WHERE a = 1 AND b = 1 AND c IS NOT NULL PRIMARY KEY ((a, b), c)");
-
-        while (!SystemKeyspace.isViewBuilt(keyspace(), "mv_test"))
-            Thread.sleep(10);
-
-        assertRows(execute("SELECT * FROM mv_test"),
-                   row(1, 1, 0),
-                   row(1, 1, 1)
-        );
-
-        // insert new rows that do not match the filter
-        execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 2, 0, 0, 0);
-        execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 2, 1, 0, 0);
-        execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 2, 0, 0);
-        assertRows(execute("SELECT * FROM mv_test"),
-                   row(1, 1, 0),
-                   row(1, 1, 1)
-        );
-
-        // insert new row that does match the filter
-        execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 2, 0);
-        assertRows(execute("SELECT * FROM mv_test"),
-                   row(1, 1, 0),
-                   row(1, 1, 1),
-                   row(1, 1, 2)
-        );
-
-        // update rows that don't match the filter
-        execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 0, 0, 0);
-        execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 1, 0, 0);
-        execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 0, 1, 0);
-        assertRows(execute("SELECT * FROM mv_test"),
-                   row(1, 1, 0),
-                   row(1, 1, 1),
-                   row(1, 1, 2)
-        );
-
-        // update a row that does match the filter
-        execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 1, 1, 0);
-        assertRows(execute("SELECT * FROM mv_test"),
-                   row(1, 1, 0),
-                   row(1, 1, 1),
-                   row(1, 1, 2)
-        );
-
-        // delete rows that don't match the filter
-        execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 0, 0, 0);
-        execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 1, 0, 0);
-        execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 0, 1, 0);
-        execute("DELETE FROM %s WHERE a = ? AND b = ?", 0, 0);
-        assertRows(execute("SELECT * FROM mv_test"),
-                   row(1, 1, 0),
-                   row(1, 1, 1),
-                   row(1, 1, 2)
-        );
-
-        // delete a row that does match the filter
-        execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 1, 1, 0);
-        assertRows(execute("SELECT * FROM mv_test"),
-                   row(1, 1, 1),
-                   row(1, 1, 2)
-        );
-
-        // delete a partition that matches the filter
-        execute("DELETE FROM %s WHERE a = ? AND b = ?", 1, 1);
-        assertEmpty(execute("SELECT * FROM mv_test"));
-    }
-
-    @Test
-    public void testClusteringKeyEQRestrictions() throws Throwable
-    {
-        List<String> mvPrimaryKeys = Arrays.asList("((a, b), c)", "((b, a), c)", "(a, b, c)", "(c, b, a)", "((c, a), b)");
-        for (int i = 0; i < mvPrimaryKeys.size(); i++)
-        {
-            createTable("CREATE TABLE %s (a int, b int, c int, d int, PRIMARY KEY (a, b, c))");
-
-            execute("USE " + keyspace());
-            executeNet(version, "USE " + keyspace());
-
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 0, 0, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 0, 1, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 1, 0, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 1, 1, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 0, 0, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 0, 1, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 0, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 1, 0);
-
-            logger.info("Testing MV primary key: {}", mvPrimaryKeys.get(i));
-
-            // only accept rows where b = 1
-            createView("mv_test" + i, "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a IS NOT NULL AND b = 1 AND c IS NOT NULL PRIMARY KEY " + mvPrimaryKeys.get(i));
-
-            while (!SystemKeyspace.isViewBuilt(keyspace(), "mv_test" + i))
-                Thread.sleep(10);
-
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(0, 1, 0, 0),
-                                    row(0, 1, 1, 0),
-                                    row(1, 1, 0, 0),
-                                    row(1, 1, 1, 0)
-            );
-
-            // insert new rows that do not match the filter
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 2, 0, 0, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 2, 2, 0, 0);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(0, 1, 0, 0),
-                                    row(0, 1, 1, 0),
-                                    row(1, 1, 0, 0),
-                                    row(1, 1, 1, 0)
-            );
-
-            // insert new row that does match the filter
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 2, 0);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(0, 1, 0, 0),
-                                    row(0, 1, 1, 0),
-                                    row(1, 1, 0, 0),
-                                    row(1, 1, 1, 0),
-                                    row(1, 1, 2, 0)
-            );
-
-            // update rows that don't match the filter
-            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 2, 0, 0);
-            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 2, 2, 0);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(0, 1, 0, 0),
-                                    row(0, 1, 1, 0),
-                                    row(1, 1, 0, 0),
-                                    row(1, 1, 1, 0),
-                                    row(1, 1, 2, 0)
-            );
-
-            // update a row that does match the filter
-            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 1, 1, 0);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(0, 1, 0, 0),
-                                    row(0, 1, 1, 0),
-                                    row(1, 1, 0, 1),
-                                    row(1, 1, 1, 0),
-                                    row(1, 1, 2, 0)
-            );
-
-            // delete rows that don't match the filter
-            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 2, 0, 0);
-            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 2, 2, 0);
-            execute("DELETE FROM %s WHERE a = ? AND b = ?", 0, 0);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(0, 1, 0, 0),
-                                    row(0, 1, 1, 0),
-                                    row(1, 1, 0, 1),
-                                    row(1, 1, 1, 0),
-                                    row(1, 1, 2, 0)
-            );
-
-            // delete a row that does match the filter
-            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 1, 1, 0);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(0, 1, 0, 0),
-                                    row(0, 1, 1, 0),
-                                    row(1, 1, 1, 0),
-                                    row(1, 1, 2, 0)
-            );
-
-            // delete a partition that matches the filter
-            execute("DELETE FROM %s WHERE a = ?", 1);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(0, 1, 0, 0),
-                                    row(0, 1, 1, 0)
-            );
-
-            dropView("mv_test" + i);
-            dropTable("DROP TABLE %s");
-        }
-    }
-
-    @Test
-    public void testClusteringKeySliceRestrictions() throws Throwable
-    {
-        List<String> mvPrimaryKeys = Arrays.asList("((a, b), c)", "((b, a), c)", "(a, b, c)", "(c, b, a)", "((c, a), b)");
-        for (int i = 0; i < mvPrimaryKeys.size(); i++)
-        {
-            createTable("CREATE TABLE %s (a int, b int, c int, d int, PRIMARY KEY (a, b, c))");
-
-            execute("USE " + keyspace());
-            executeNet(version, "USE " + keyspace());
-
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 0, 0, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 0, 1, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 1, 0, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 1, 1, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 0, 0, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 0, 1, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 0, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 1, 0);
-
-            logger.info("Testing MV primary key: {}", mvPrimaryKeys.get(i));
-
-            createView("mv_test" + i, "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a IS NOT NULL AND b >= 1 AND c IS NOT NULL PRIMARY KEY " + mvPrimaryKeys.get(i));
-
-            while (!SystemKeyspace.isViewBuilt(keyspace(), "mv_test" + i))
-                Thread.sleep(10);
-
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(0, 1, 0, 0),
-                                    row(0, 1, 1, 0),
-                                    row(1, 1, 0, 0),
-                                    row(1, 1, 1, 0)
-            );
-
-            // insert new rows that do not match the filter
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 2, -1, 0, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 2, 0, 0, 0);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(0, 1, 0, 0),
-                                    row(0, 1, 1, 0),
-                                    row(1, 1, 0, 0),
-                                    row(1, 1, 1, 0)
-            );
-
-            // insert new row that does match the filter
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 2, 0);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(0, 1, 0, 0),
-                                    row(0, 1, 1, 0),
-                                    row(1, 1, 0, 0),
-                                    row(1, 1, 1, 0),
-                                    row(1, 1, 2, 0)
-            );
-
-            // update rows that don't match the filter
-            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 2, -1, 0);
-            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 2, 0, 0);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(0, 1, 0, 0),
-                                    row(0, 1, 1, 0),
-                                    row(1, 1, 0, 0),
-                                    row(1, 1, 1, 0),
-                                    row(1, 1, 2, 0)
-            );
-
-            // update a row that does match the filter
-            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 1, 1, 0);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(0, 1, 0, 0),
-                                    row(0, 1, 1, 0),
-                                    row(1, 1, 0, 1),
-                                    row(1, 1, 1, 0),
-                                    row(1, 1, 2, 0)
-            );
-
-            // delete rows that don't match the filter
-            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 2, -1, 0);
-            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 2, 0, 0);
-            execute("DELETE FROM %s WHERE a = ? AND b = ?", 0, 0);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(0, 1, 0, 0),
-                                    row(0, 1, 1, 0),
-                                    row(1, 1, 0, 1),
-                                    row(1, 1, 1, 0),
-                                    row(1, 1, 2, 0)
-            );
-
-            // delete a row that does match the filter
-            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 1, 1, 0);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(0, 1, 0, 0),
-                                    row(0, 1, 1, 0),
-                                    row(1, 1, 1, 0),
-                                    row(1, 1, 2, 0)
-            );
-
-            // delete a partition that matches the filter
-            execute("DELETE FROM %s WHERE a = ?", 1);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(0, 1, 0, 0),
-                                    row(0, 1, 1, 0)
-            );
-
-            dropView("mv_test" + i);
-            dropTable("DROP TABLE %s");
-        }
-    }
-
-    @Test
-    public void testClusteringKeyINRestrictions() throws Throwable
-    {
-        List<String> mvPrimaryKeys = Arrays.asList("((a, b), c)", "((b, a), c)", "(a, b, c)", "(c, b, a)", "((c, a), b)");
-        for (int i = 0; i < mvPrimaryKeys.size(); i++)
-        {
-            createTable("CREATE TABLE %s (a int, b int, c int, d int, PRIMARY KEY (a, b, c))");
-
-            execute("USE " + keyspace());
-            executeNet(version, "USE " + keyspace());
-
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 0, 0, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 0, 1, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 1, 0, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 1, 1, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 0, 0, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 0, 1, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 0, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 1, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 2, 1, 0);
-
-            logger.info("Testing MV primary key: {}", mvPrimaryKeys.get(i));
-
-            // only accept rows where b = 1
-            createView("mv_test" + i, "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a IS NOT NULL AND b IN (1, 2) AND c IS NOT NULL PRIMARY KEY " + mvPrimaryKeys.get(i));
-
-            while (!SystemKeyspace.isViewBuilt(keyspace(), "mv_test" + i))
-                Thread.sleep(10);
-
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(0, 1, 0, 0),
-                                    row(0, 1, 1, 0),
-                                    row(1, 1, 0, 0),
-                                    row(1, 1, 1, 0),
-                                    row(1, 2, 1, 0)
-            );
-
-            // insert new rows that do not match the filter
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 2, -1, 0, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 2, 0, 0, 0);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(0, 1, 0, 0),
-                                    row(0, 1, 1, 0),
-                                    row(1, 1, 0, 0),
-                                    row(1, 1, 1, 0),
-                                    row(1, 2, 1, 0)
-            );
-
-            // insert new row that does match the filter
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 2, 0);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(0, 1, 0, 0),
-                                    row(0, 1, 1, 0),
-                                    row(1, 1, 0, 0),
-                                    row(1, 1, 1, 0),
-                                    row(1, 1, 2, 0),
-                                    row(1, 2, 1, 0)
-            );
-
-            // update rows that don't match the filter
-            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 2, -1, 0);
-            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 2, 0, 0);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(0, 1, 0, 0),
-                                    row(0, 1, 1, 0),
-                                    row(1, 1, 0, 0),
-                                    row(1, 1, 1, 0),
-                                    row(1, 1, 2, 0),
-                                    row(1, 2, 1, 0)
-            );
-
-            // update a row that does match the filter
-            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 1, 1, 0);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(0, 1, 0, 0),
-                                    row(0, 1, 1, 0),
-                                    row(1, 1, 0, 1),
-                                    row(1, 1, 1, 0),
-                                    row(1, 1, 2, 0),
-                                    row(1, 2, 1, 0)
-            );
-
-            // delete rows that don't match the filter
-            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 2, -1, 0);
-            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 2, 0, 0);
-            execute("DELETE FROM %s WHERE a = ? AND b = ?", 0, 0);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(0, 1, 0, 0),
-                                    row(0, 1, 1, 0),
-                                    row(1, 1, 0, 1),
-                                    row(1, 1, 1, 0),
-                                    row(1, 1, 2, 0),
-                                    row(1, 2, 1, 0)
-            );
-
-            // delete a row that does match the filter
-            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 1, 1, 0);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(0, 1, 0, 0),
-                                    row(0, 1, 1, 0),
-                                    row(1, 1, 1, 0),
-                                    row(1, 1, 2, 0),
-                                    row(1, 2, 1, 0)
-            );
-
-            // delete a partition that matches the filter
-            execute("DELETE FROM %s WHERE a = ?", 1);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(0, 1, 0, 0),
-                                    row(0, 1, 1, 0)
-            );
-
-            dropView("mv_test" + i);
-            dropTable("DROP TABLE %s");
-        }
-    }
-
-    @Test
-    public void testClusteringKeyMultiColumnRestrictions() throws Throwable
-    {
-        List<String> mvPrimaryKeys = Arrays.asList("((a, b), c)", "((b, a), c)", "(a, b, c)", "(c, b, a)", "((c, a), b)");
-        for (int i = 0; i < mvPrimaryKeys.size(); i++)
-        {
-            createTable("CREATE TABLE %s (a int, b int, c int, d int, PRIMARY KEY (a, b, c))");
-
-            execute("USE " + keyspace());
-            executeNet(version, "USE " + keyspace());
-
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 0, 0, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 0, 1, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 1, 0, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 1, 1, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 0, 0, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 0, 1, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, -1, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 0, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 1, 0);
-
-            logger.info("Testing MV primary key: {}", mvPrimaryKeys.get(i));
-
-            // only accept rows where b = 1
-            createView("mv_test" + i, "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a IS NOT NULL AND (b, c) >= (1, 0) PRIMARY KEY " + mvPrimaryKeys.get(i));
-
-            while (!SystemKeyspace.isViewBuilt(keyspace(), "mv_test" + i))
-                Thread.sleep(10);
-
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(0, 1, 0, 0),
-                                    row(0, 1, 1, 0),
-                                    row(1, 1, 0, 0),
-                                    row(1, 1, 1, 0)
-            );
-
-            // insert new rows that do not match the filter
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 2, -1, 0, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 2, 0, 0, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 2, 1, -1, 0);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(0, 1, 0, 0),
-                                    row(0, 1, 1, 0),
-                                    row(1, 1, 0, 0),
-                                    row(1, 1, 1, 0)
-            );
-
-            // insert new row that does match the filter
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 2, 0);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(0, 1, 0, 0),
-                                    row(0, 1, 1, 0),
-                                    row(1, 1, 0, 0),
-                                    row(1, 1, 1, 0),
-                                    row(1, 1, 2, 0)
-            );
-
-            // update rows that don't match the filter
-            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 1, -1, 0);
-            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 2, -1, 0);
-            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 2, 0, 0);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(0, 1, 0, 0),
-                                    row(0, 1, 1, 0),
-                                    row(1, 1, 0, 0),
-                                    row(1, 1, 1, 0),
-                                    row(1, 1, 2, 0)
-            );
-
-            // update a row that does match the filter
-            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 1, 1, 0);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(0, 1, 0, 0),
-                                    row(0, 1, 1, 0),
-                                    row(1, 1, 0, 1),
-                                    row(1, 1, 1, 0),
-                                    row(1, 1, 2, 0)
-            );
-
-            // delete rows that don't match the filter
-            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 1, 1, -1);
-            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 2, -1, 0);
-            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 2, 0, 0);
-            execute("DELETE FROM %s WHERE a = ? AND b = ?", 0, 0);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(0, 1, 0, 0),
-                                    row(0, 1, 1, 0),
-                                    row(1, 1, 0, 1),
-                                    row(1, 1, 1, 0),
-                                    row(1, 1, 2, 0)
-            );
-
-            // delete a row that does match the filter
-            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 1, 1, 0);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(0, 1, 0, 0),
-                                    row(0, 1, 1, 0),
-                                    row(1, 1, 1, 0),
-                                    row(1, 1, 2, 0)
-            );
-
-            // delete a partition that matches the filter
-            execute("DELETE FROM %s WHERE a = ?", 1);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(0, 1, 0, 0),
-                                    row(0, 1, 1, 0)
-            );
-
-            dropView("mv_test" + i);
-            dropTable("DROP TABLE %s");
-        }
-    }
-
-    @Test
-    public void testClusteringKeyFilteringRestrictions() throws Throwable
-    {
-        List<String> mvPrimaryKeys = Arrays.asList("((a, b), c)", "((b, a), c)", "(a, b, c)", "(c, b, a)", "((c, a), b)");
-        for (int i = 0; i < mvPrimaryKeys.size(); i++)
-        {
-            createTable("CREATE TABLE %s (a int, b int, c int, d int, PRIMARY KEY (a, b, c))");
-
-            execute("USE " + keyspace());
-            executeNet(version, "USE " + keyspace());
-
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 0, 0, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 0, 1, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 1, 0, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 1, 1, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 0, 0, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 0, 1, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, -1, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 0, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 1, 0);
-
-            logger.info("Testing MV primary key: {}", mvPrimaryKeys.get(i));
-
-            // only accept rows where b = 1
-            createView("mv_test" + i, "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a IS NOT NULL AND b IS NOT NULL AND c = 1 PRIMARY KEY " + mvPrimaryKeys.get(i));
-
-            while (!SystemKeyspace.isViewBuilt(keyspace(), "mv_test" + i))
-                Thread.sleep(10);
-
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(0, 0, 1, 0),
-                                    row(0, 1, 1, 0),
-                                    row(1, 0, 1, 0),
-                                    row(1, 1, 1, 0)
-            );
-
-            // insert new rows that do not match the filter
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 2, 0, 0, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 2, 1, -1, 0);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(0, 0, 1, 0),
-                                    row(0, 1, 1, 0),
-                                    row(1, 0, 1, 0),
-                                    row(1, 1, 1, 0)
-            );
-
-            // insert new row that does match the filter
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 2, 1, 0);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(0, 0, 1, 0),
-                                    row(0, 1, 1, 0),
-                                    row(1, 0, 1, 0),
-                                    row(1, 1, 1, 0),
-                                    row(1, 2, 1, 0)
-            );
-
-            // update rows that don't match the filter
-            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 1, -1, 0);
-            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 2, 0, 0);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(0, 0, 1, 0),
-                                    row(0, 1, 1, 0),
-                                    row(1, 0, 1, 0),
-                                    row(1, 1, 1, 0),
-                                    row(1, 2, 1, 0)
-            );
-
-            // update a row that does match the filter
-            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 2, 1, 1, 1);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(0, 0, 1, 0),
-                                    row(0, 1, 1, 0),
-                                    row(1, 0, 1, 0),
-                                    row(1, 1, 1, 2),
-                                    row(1, 2, 1, 0)
-            );
-
-            // delete rows that don't match the filter
-            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 1, 1, -1);
-            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 2, -1, 0);
-            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 2, 0, 0);
-            execute("DELETE FROM %s WHERE a = ? AND b = ?", 0, -1);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(0, 0, 1, 0),
-                                    row(0, 1, 1, 0),
-                                    row(1, 0, 1, 0),
-                                    row(1, 1, 1, 2),
-                                    row(1, 2, 1, 0)
-            );
-
-            // delete a row that does match the filter
-            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 1, 1, 1);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(0, 0, 1, 0),
-                                    row(0, 1, 1, 0),
-                                    row(1, 0, 1, 0),
-                                    row(1, 2, 1, 0)
-            );
-
-            // delete a partition that matches the filter
-            execute("DELETE FROM %s WHERE a = ?", 1);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(0, 0, 1, 0),
-                                    row(0, 1, 1, 0)
-            );
-
-            // insert a partition with one matching and one non-matching row using a batch (CASSANDRA-10614)
-            String tableName = KEYSPACE + "." + currentTable();
-            execute("BEGIN BATCH " +
-                    "INSERT INTO " + tableName + " (a, b, c, d) VALUES (?, ?, ?, ?); " +
-                    "INSERT INTO " + tableName + " (a, b, c, d) VALUES (?, ?, ?, ?); " +
-                    "APPLY BATCH",
-                    4, 4, 0, 0,
-                    4, 4, 1, 1);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(0, 0, 1, 0),
-                                    row(0, 1, 1, 0),
-                                    row(4, 4, 1, 1)
-            );
-
-            dropView("mv_test" + i);
-            dropTable("DROP TABLE %s");
-        }
-    }
-
-    @Test
-    public void testPartitionKeyAndClusteringKeyFilteringRestrictions() throws Throwable
-    {
-        List<String> mvPrimaryKeys = Arrays.asList("((a, b), c)", "((b, a), c)", "(a, b, c)", "(c, b, a)", "((c, a), b)");
-        for (int i = 0; i < mvPrimaryKeys.size(); i++)
-        {
-            createTable("CREATE TABLE %s (a int, b int, c int, d int, PRIMARY KEY (a, b, c))");
-
-            execute("USE " + keyspace());
-            executeNet(version, "USE " + keyspace());
-
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 0, 0, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 0, 1, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 1, 0, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 1, 1, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 0, 0, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 0, 1, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, -1, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 0, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 1, 0);
-
-            logger.info("Testing MV primary key: {}", mvPrimaryKeys.get(i));
-
-            // only accept rows where b = 1
-            createView("mv_test" + i, "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a = 1 AND b IS NOT NULL AND c = 1 PRIMARY KEY " + mvPrimaryKeys.get(i));
-
-            while (!SystemKeyspace.isViewBuilt(keyspace(), "mv_test" + i))
-                Thread.sleep(10);
-
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(1, 0, 1, 0),
-                                    row(1, 1, 1, 0)
-            );
-
-            // insert new rows that do not match the filter
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 0, 1, 0);
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 0, 0);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(1, 0, 1, 0),
-                                    row(1, 1, 1, 0)
-            );
-
-            // insert new row that does match the filter
-            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 2, 1, 0);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(1, 0, 1, 0),
-                                    row(1, 1, 1, 0),
-                                    row(1, 2, 1, 0)
-            );
-
-            // update rows that don't match the filter
-            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 1, -1, 0);
-            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 0, 1, 1, 0);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(1, 0, 1, 0),
-                                    row(1, 1, 1, 0),
-                                    row(1, 2, 1, 0)
-            );
-
-            // update a row that does match the filter
-            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 2, 1, 1, 1);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(1, 0, 1, 0),
-                                    row(1, 1, 1, 2),
-                                    row(1, 2, 1, 0)
-            );
-
-            // delete rows that don't match the filter
-            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 1, 1, -1);
-            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 2, 0, 1);
-            execute("DELETE FROM %s WHERE a = ?", 0);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(1, 0, 1, 0),
-                                    row(1, 1, 1, 2),
-                                    row(1, 2, 1, 0)
-            );
-
-            // delete a row that does match the filter
-            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 1, 1, 1);
-            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
-                                    row(1, 0, 1, 0),
-                                    row(1, 2, 1, 0)
-            );
-
-            // delete a partition that matches the filter
-            execute("DELETE FROM %s WHERE a = ?", 1);
-            assertEmpty(execute("SELECT a, b, c, d FROM mv_test" + i));
-
-            dropView("mv_test" + i);
-            dropTable("DROP TABLE %s");
-        }
-    }
-
-    @Test
-    public void testAllTypes() throws Throwable
-    {
-        String myType = createType("CREATE TYPE %s (a int, b uuid, c set<text>)");
-        String columnNames = "asciival, " +
-                             "bigintval, " +
-                             "blobval, " +
-                             "booleanval, " +
-                             "dateval, " +
-                             "decimalval, " +
-                             "doubleval, " +
-                             "floatval, " +
-                             "inetval, " +
-                             "intval, " +
-                             "textval, " +
-                             "timeval, " +
-                             "timestampval, " +
-                             "timeuuidval, " +
-                             "uuidval," +
-                             "varcharval, " +
-                             "varintval, " +
-                             "frozenlistval, " +
-                             "frozensetval, " +
-                             "frozenmapval, " +
-                             "tupleval, " +
-                             "udtval";
-
-        createTable(
-        "CREATE TABLE %s (" +
-        "asciival ascii, " +
-        "bigintval bigint, " +
-        "blobval blob, " +
-        "booleanval boolean, " +
-        "dateval date, " +
-        "decimalval decimal, " +
-        "doubleval double, " +
-        "floatval float, " +
-        "inetval inet, " +
-        "intval int, " +
-        "textval text, " +
-        "timeval time, " +
-        "timestampval timestamp, " +
-        "timeuuidval timeuuid, " +
-        "uuidval uuid," +
-        "varcharval varchar, " +
-        "varintval varint, " +
-        "frozenlistval frozen<list<int>>, " +
-        "frozensetval frozen<set<uuid>>, " +
-        "frozenmapval frozen<map<ascii, int>>," +
-        "tupleval frozen<tuple<int, ascii, uuid>>," +
-        "udtval frozen<" + myType + ">, " +
-        "PRIMARY KEY (" + columnNames + "))");
-
-        execute("USE " + keyspace());
-        executeNet(version, "USE " + keyspace());
-
-
-        createView(
-        "mv_test",
-        "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE " +
-        "asciival = 'abc' AND " +
-        "bigintval = 123 AND " +
-        "blobval = 0xfeed AND " +
-        "booleanval = true AND " +
-        "dateval = '1987-03-23' AND " +
-        "decimalval = 123.123 AND " +
-        "doubleval = 123.123 AND " +
-        "floatval = 123.123 AND " +
-        "inetval = '127.0.0.1' AND " +
-        "intval = 123 AND " +
-        "textval = 'abc' AND " +
-        "timeval = '07:35:07.000111222' AND " +
-        "timestampval = 123123123 AND " +
-        "timeuuidval = 6BDDC89A-5644-11E4-97FC-56847AFE9799 AND " +
-        "uuidval = 6BDDC89A-5644-11E4-97FC-56847AFE9799 AND " +
-        "varcharval = 'abc' AND " +
-        "varintval = 123123123 AND " +
-        "frozenlistval = [1, 2, 3] AND " +
-        "frozensetval = {6BDDC89A-5644-11E4-97FC-56847AFE9799} AND " +
-        "frozenmapval = {'a': 1, 'b': 2} AND " +
-        "tupleval = (1, 'foobar', 6BDDC89A-5644-11E4-97FC-56847AFE9799) AND " +
-        "udtval = {a: 1, b: 6BDDC89A-5644-11E4-97FC-56847AFE9799, c: {'foo', 'bar'}} " +
-        "PRIMARY KEY (" + columnNames + ")");
-
-        execute("INSERT INTO %s (" + columnNames + ") VALUES (" +
-                "'abc'," +
-                "123," +
-                "0xfeed," +
-                "true," +
-                "'1987-03-23'," +
-                "123.123," +
-                "123.123," +
-                "123.123," +
-                "'127.0.0.1'," +
-                "123," +
-                "'abc'," +
-                "'07:35:07.000111222'," +
-                "123123123," +
-                "6BDDC89A-5644-11E4-97FC-56847AFE9799," +
-                "6BDDC89A-5644-11E4-97FC-56847AFE9799," +
-                "'abc'," +
-                "123123123," +
-                "[1, 2, 3]," +
-                "{6BDDC89A-5644-11E4-97FC-56847AFE9799}," +
-                "{'a': 1, 'b': 2}," +
-                "(1, 'foobar', 6BDDC89A-5644-11E4-97FC-56847AFE9799)," +
-                "{a: 1, b: 6BDDC89A-5644-11E4-97FC-56847AFE9799, c: {'foo', 'bar'}})");
-
-        assert !execute("SELECT * FROM mv_test").isEmpty();
-
-        executeNet(version, "ALTER TABLE %s RENAME inetval TO foo");
-        assert !execute("SELECT * FROM mv_test").isEmpty();
-    }
-
-    @Test
-    public void testMVCreationWithNonPrimaryRestrictions() throws Throwable
-    {
-        createTable("CREATE TABLE %s (a int, b int, c int, d int, PRIMARY KEY (a, b))");
-
-        execute("USE " + keyspace());
-        executeNet(version, "USE " + keyspace());
-
-        try {
-            createView("mv_test", "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a IS NOT NULL AND b IS NOT NULL AND c IS NOT NULL AND d = 1 PRIMARY KEY (a, b, c)");
-            dropView("mv_test");
-        } catch(Exception e) {
-            throw new RuntimeException("MV creation with non primary column restrictions failed.", e);
-        }
-
-        dropTable("DROP TABLE %s");
-    }
-
-    @Test
-    public void testNonPrimaryRestrictions() throws Throwable
-    {
-        createTable("CREATE TABLE %s (a int, b int, c int, d int, PRIMARY KEY (a, b))");
-
-        execute("USE " + keyspace());
-        executeNet(version, "USE " + keyspace());
-
-        execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 0, 0, 0);
-        execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 0, 1, 0);
-        execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 1, 0, 0);
-        execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 1, 1, 0);
-        execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 0, 0, 0);
-        execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 0, 1, 0);
-        execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 0, 0);
-        execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 1, 0);
-
-        // only accept rows where c = 1
-        createView("mv_test", "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a IS NOT NULL AND b IS NOT NULL AND c IS NOT NULL AND c = 1 PRIMARY KEY (a, b, c)");
-
-        while (!SystemKeyspace.isViewBuilt(keyspace(), "mv_test"))
-            Thread.sleep(10);
-
-        assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test"),
-                                row(0, 0, 1, 0),
-                                row(0, 1, 1, 0),
-                                row(1, 0, 1, 0),
-                                row(1, 1, 1, 0)
-        );
-
-        // insert new rows that do not match the filter
-        execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 2, 0, 0, 0);
-        execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 2, 1, 2, 0);
-        assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test"),
-                                row(0, 0, 1, 0),
-                                row(0, 1, 1, 0),
-                                row(1, 0, 1, 0),
-                                row(1, 1, 1, 0)
-        );
-
-        // insert new row that does match the filter
-        execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 2, 1, 0);
-        assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test"),
-                                row(0, 0, 1, 0),
-                                row(0, 1, 1, 0),
-                                row(1, 0, 1, 0),
-                                row(1, 1, 1, 0),
-                                row(1, 2, 1, 0)
-        );
-
-        // update rows that don't match the filter
-        execute("UPDATE %s SET d = ? WHERE a = ? AND b = ?", 2, 2, 0);
-        execute("UPDATE %s SET d = ? WHERE a = ? AND b = ?", 1, 2, 1);
-        assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test"),
-                                row(0, 0, 1, 0),
-                                row(0, 1, 1, 0),
-                                row(1, 0, 1, 0),
-                                row(1, 1, 1, 0),
-                                row(1, 2, 1, 0)
-        );
-
-        // update a row that does match the filter
-        execute("UPDATE %s SET d = ? WHERE a = ? AND b = ?", 1, 1, 0);
-        assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test"),
-                                row(0, 0, 1, 0),
-                                row(0, 1, 1, 0),
-                                row(1, 0, 1, 1),
-                                row(1, 1, 1, 0),
-                                row(1, 2, 1, 0)
-        );
-
-        // delete rows that don't match the filter
-        execute("DELETE FROM %s WHERE a = ? AND b = ?", 2, 0);
-        assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test"),
-                                row(0, 0, 1, 0),
-                                row(0, 1, 1, 0),
-                                row(1, 0, 1, 1),
-                                row(1, 1, 1, 0),
-                                row(1, 2, 1, 0)
-        );
-
-        // delete a row that does match the filter
-        execute("DELETE FROM %s WHERE a = ? AND b = ?", 1, 2);
-        assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test"),
-                                row(0, 0, 1, 0),
-                                row(0, 1, 1, 0),
-                                row(1, 0, 1, 1),
-                                row(1, 1, 1, 0)
-        );
-
-        // delete a partition that matches the filter
-        execute("DELETE FROM %s WHERE a = ?", 1);
-        assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test"),
-                                row(0, 0, 1, 0),
-                                row(0, 1, 1, 0)
-        );
-
-        dropView("mv_test");
-        dropTable("DROP TABLE %s");
-    }
-
-    @Test
-    public void complexRestrictedTimestampUpdateTestWithFlush() throws Throwable
-    {
-        complexRestrictedTimestampUpdateTest(true);
-    }
-
-    @Test
-    public void complexRestrictedTimestampUpdateTestWithoutFlush() throws Throwable
-    {
-        complexRestrictedTimestampUpdateTest(false);
-    }
-
-    public void complexRestrictedTimestampUpdateTest(boolean flush) throws Throwable
-    {
-        createTable("CREATE TABLE %s (a int, b int, c int, d int, e int, PRIMARY KEY (a, b))");
-
-        execute("USE " + keyspace());
-        executeNet(version, "USE " + keyspace());
-        Keyspace ks = Keyspace.open(keyspace());
-
-        createView("mv", "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a IS NOT NULL AND b IS NOT NULL AND c IS NOT NULL AND c = 1 PRIMARY KEY (c, a, b)");
-        ks.getColumnFamilyStore("mv").disableAutoCompaction();
-
-        //Set initial values TS=0, matching the restriction and verify view
-        executeNet(version, "INSERT INTO %s (a, b, c, d) VALUES (0, 0, 1, 0) USING TIMESTAMP 0");
-        assertRows(execute("SELECT d from mv WHERE c = ? and a = ? and b = ?", 1, 0, 0), row(0));
-
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-
-        //update c's timestamp TS=2
-        executeNet(version, "UPDATE %s USING TIMESTAMP 2 SET c = ? WHERE a = ? and b = ? ", 1, 0, 0);
-        assertRows(execute("SELECT d from mv WHERE c = ? and a = ? and b = ?", 1, 0, 0), row(0));
-
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-
-        //change c's value and TS=3, tombstones c=1 and adds c=0 record
-        executeNet(version, "UPDATE %s USING TIMESTAMP 3 SET c = ? WHERE a = ? and b = ? ", 0, 0, 0);
-        assertRows(execute("SELECT d from mv WHERE c = ? and a = ? and b = ?", 0, 0, 0));
-
-        if(flush)
-        {
-            ks.getColumnFamilyStore("mv").forceMajorCompaction();
-            FBUtilities.waitOnFutures(ks.flush());
-        }
-
-        //change c's value back to 1 with TS=4, check we can see d
-        executeNet(version, "UPDATE %s USING TIMESTAMP 4 SET c = ? WHERE a = ? and b = ? ", 1, 0, 0);
-        if (flush)
-        {
-            ks.getColumnFamilyStore("mv").forceMajorCompaction();
-            FBUtilities.waitOnFutures(ks.flush());
-        }
-
-        assertRows(execute("SELECT d, e from mv WHERE c = ? and a = ? and b = ?", 1, 0, 0), row(0, null));
-
-
-        //Add e value @ TS=1
-        executeNet(version, "UPDATE %s USING TIMESTAMP 1 SET e = ? WHERE a = ? and b = ? ", 1, 0, 0);
-        assertRows(execute("SELECT d, e from mv WHERE c = ? and a = ? and b = ?", 1, 0, 0), row(0, 1));
-
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-
-
-        //Change d value @ TS=2
-        executeNet(version, "UPDATE %s USING TIMESTAMP 2 SET d = ? WHERE a = ? and b = ? ", 2, 0, 0);
-        assertRows(execute("SELECT d from mv WHERE c = ? and a = ? and b = ?", 1, 0, 0), row(2));
-
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush());
-
-
-        //Change d value @ TS=3
-        executeNet(version, "UPDATE %s USING TIMESTAMP 3 SET d = ? WHERE a = ? and b = ? ", 1, 0, 0);
-        assertRows(execute("SELECT d from mv WHERE c = ? and a = ? and b = ?", 1, 0, 0), row(1));
-
-
-        //Tombstone c
-        executeNet(version, "DELETE FROM %s WHERE a = ? and b = ?", 0, 0);
-        assertRowsIgnoringOrder(execute("SELECT d from mv"));
-        assertRows(execute("SELECT d from mv"));
-
-        //Add back without D
-        executeNet(version, "INSERT INTO %s (a, b, c) VALUES (0, 0, 1)");
-
-        //Make sure D doesn't pop back in.
-        assertRows(execute("SELECT d from mv WHERE c = ? and a = ? and b = ?", 1, 0, 0), row((Object) null));
-
-
-        //New partition
-        // insert a row with timestamp 0
-        executeNet(version, "INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?) USING TIMESTAMP 0", 1, 0, 1, 0, 0);
-
-        // overwrite pk and e with timestamp 1, but don't overwrite d
-        executeNet(version, "INSERT INTO %s (a, b, c, e) VALUES (?, ?, ?, ?) USING TIMESTAMP 1", 1, 0, 1, 0);
-
-        // delete with timestamp 0 (which should only delete d)
-        executeNet(version, "DELETE FROM %s USING TIMESTAMP 0 WHERE a = ? AND b = ?", 1, 0);
-        assertRows(execute("SELECT a, b, c, d, e from mv WHERE c = ? and a = ? and b = ?", 1, 1, 0),
-                   row(1, 0, 1, null, 0)
-        );
-
-        executeNet(version, "UPDATE %s USING TIMESTAMP 2 SET c = ? WHERE a = ? AND b = ?", 1, 1, 1);
-        executeNet(version, "UPDATE %s USING TIMESTAMP 3 SET c = ? WHERE a = ? AND b = ?", 1, 1, 0);
-        assertRows(execute("SELECT a, b, c, d, e from mv WHERE c = ? and a = ? and b = ?", 1, 1, 0),
-                   row(1, 0, 1, null, 0)
-        );
-
-        executeNet(version, "UPDATE %s USING TIMESTAMP 3 SET d = ? WHERE a = ? AND b = ?", 0, 1, 0);
-        assertRows(execute("SELECT a, b, c, d, e from mv WHERE c = ? and a = ? and b = ?", 1, 1, 0),
-                   row(1, 0, 1, 0, 0)
-        );
-    }
-
-    @Test
-    public void testRestrictedRegularColumnTimestampUpdates() throws Throwable
-    {
-        // Regression test for CASSANDRA-10910
-
-        createTable("CREATE TABLE %s (" +
-                    "k int PRIMARY KEY, " +
-                    "c int, " +
-                    "val int)");
-
-        execute("USE " + keyspace());
-        executeNet(version, "USE " + keyspace());
-
-        createView("mv_rctstest", "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE k IS NOT NULL AND c IS NOT NULL AND c = 1 PRIMARY KEY (k,c)");
-
-        updateView("UPDATE %s SET c = ?, val = ? WHERE k = ?", 0, 0, 0);
-        updateView("UPDATE %s SET val = ? WHERE k = ?", 1, 0);
-        updateView("UPDATE %s SET c = ? WHERE k = ?", 1, 0);
-        assertRows(execute("SELECT c, k, val FROM mv_rctstest"), row(1, 0, 1));
-
-        updateView("TRUNCATE %s");
-
-        updateView("UPDATE %s USING TIMESTAMP 1 SET c = ?, val = ? WHERE k = ?", 0, 0, 0);
-        updateView("UPDATE %s USING TIMESTAMP 3 SET c = ? WHERE k = ?", 1, 0);
-        updateView("UPDATE %s USING TIMESTAMP 2 SET val = ? WHERE k = ?", 1, 0);
-        updateView("UPDATE %s USING TIMESTAMP 4 SET c = ? WHERE k = ?", 1, 0);
-        updateView("UPDATE %s USING TIMESTAMP 3 SET val = ? WHERE k = ?", 2, 0);
-        assertRows(execute("SELECT c, k, val FROM mv_rctstest"), row(1, 0, 2));
-    }
-
-    @Test
-    public void testOldTimestampsWithRestrictions() throws Throwable
-    {
-        createTable("CREATE TABLE %s (" +
-                    "k int, " +
-                    "c int, " +
-                    "val text, " + "" +
-                    "PRIMARY KEY(k, c))");
-
-        execute("USE " + keyspace());
-        executeNet(version, "USE " + keyspace());
-
-        createView("mv_tstest", "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE val IS NOT NULL AND k IS NOT NULL AND c IS NOT NULL AND val = 'baz' PRIMARY KEY (val,k,c)");
-
-        for (int i = 0; i < 100; i++)
-            updateView("INSERT into %s (k,c,val)VALUES(?,?,?)", 0, i % 2, "baz");
-
-        Keyspace.open(keyspace()).getColumnFamilyStore(currentTable()).forceBlockingFlush();
-
-        Assert.assertEquals(2, execute("select * from %s").size());
-        Assert.assertEquals(2, execute("select * from mv_tstest").size());
-
-        assertRows(execute("SELECT val from %s where k = 0 and c = 0"), row("baz"));
-        assertRows(execute("SELECT c from mv_tstest where k = 0 and val = ?", "baz"), row(0), row(1));
-
-        //Make sure an old TS does nothing
-        updateView("UPDATE %s USING TIMESTAMP 100 SET val = ? where k = ? AND c = ?", "bar", 0, 1);
-        assertRows(execute("SELECT val from %s where k = 0 and c = 1"), row("baz"));
-        assertRows(execute("SELECT c from mv_tstest where k = 0 and val = ?", "baz"), row(0), row(1));
-        assertRows(execute("SELECT c from mv_tstest where k = 0 and val = ?", "bar"));
-
-        //Latest TS
-        updateView("UPDATE %s SET val = ? where k = ? AND c = ?", "bar", 0, 1);
-        assertRows(execute("SELECT val from %s where k = 0 and c = 1"), row("bar"));
-        assertRows(execute("SELECT c from mv_tstest where k = 0 and val = ?", "bar"));
-        assertRows(execute("SELECT c from mv_tstest where k = 0 and val = ?", "baz"), row(0));
-    }
-}
diff --git a/test/unit/org/apache/cassandra/cql3/ViewComplexDeletionsTest.java b/test/unit/org/apache/cassandra/cql3/ViewComplexDeletionsTest.java
new file mode 100644
index 0000000000..e6662f2f75
--- /dev/null
+++ b/test/unit/org/apache/cassandra/cql3/ViewComplexDeletionsTest.java
@@ -0,0 +1,501 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.cassandra.cql3;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+import java.util.stream.Collectors;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.Ignore;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import org.apache.cassandra.db.ColumnFamilyStore;
+import org.apache.cassandra.db.Keyspace;
+import org.apache.cassandra.db.compaction.CompactionManager;
+import org.apache.cassandra.transport.ProtocolVersion;
+import org.apache.cassandra.utils.FBUtilities;
+
+import static org.apache.cassandra.cql3.ViewComplexTest.createView;
+import static org.apache.cassandra.cql3.ViewComplexTest.updateView;
+import static org.apache.cassandra.cql3.ViewComplexTest.updateViewWithFlush;
+import static org.junit.Assert.assertEquals;
+
+/* This class been split into multiple ones bc of timeout issues CASSANDRA-16670
+ * Any changes here check if they apply to the other classes:
+ * - ViewComplexUpdatesTest
+ * - ViewComplexDeletionsTest
+ * - ViewComplexTTLTest
+ * - ViewComplexTest
+ */
+@RunWith(Parameterized.class)
+public class ViewComplexDeletionsTest extends CQLTester
+{
+    @Parameterized.Parameter
+    public ProtocolVersion version;
+
+    @Parameterized.Parameters()
+    public static Collection<Object[]> versions()
+    {
+        return ViewComplexTest.versions();
+    }
+
+    private final List<String> views = new ArrayList<>();
+
+    @BeforeClass
+    public static void startup()
+    {
+        ViewComplexTest.startup();
+    }
+
+    @Before
+    public void begin()
+    {
+        ViewComplexTest.beginSetup(views);
+    }
+
+    @After
+    public void end() throws Throwable
+    {
+        ViewComplexTest.endTearDown(views, version, this);
+    }
+
+    // for now, unselected column cannot be fully supported, SEE CASSANDRA-11500
+    @Ignore
+    @Test
+    public void testPartialDeleteUnselectedColumn() throws Throwable
+    {
+        boolean flush = true;
+        execute("USE " + keyspace());
+        executeNet(version, "USE " + keyspace());
+        createTable("CREATE TABLE %s (k int, c int, a int, b int, PRIMARY KEY (k, c))");
+        createView("mv",
+                   "CREATE MATERIALIZED VIEW %s AS SELECT k,c FROM %%s WHERE k IS NOT NULL AND c IS NOT NULL PRIMARY KEY (k,c)",
+                   version,
+                   this,
+                   views);
+        Keyspace ks = Keyspace.open(keyspace());
+        ks.getColumnFamilyStore("mv").disableAutoCompaction();
+
+        updateView("UPDATE %s USING TIMESTAMP 10 SET b=1 WHERE k=1 AND c=1", version, this);
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+        assertRows(execute("SELECT * from %s"), row(1, 1, null, 1));
+        assertRows(execute("SELECT * from mv"), row(1, 1));
+        updateView("DELETE b FROM %s USING TIMESTAMP 11 WHERE k=1 AND c=1", version, this);
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+        assertEmpty(execute("SELECT * from %s"));
+        assertEmpty(execute("SELECT * from mv"));
+        updateView("UPDATE %s USING TIMESTAMP 1 SET a=1 WHERE k=1 AND c=1", version, this);
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+        assertRows(execute("SELECT * from %s"), row(1, 1, 1, null));
+        assertRows(execute("SELECT * from mv"), row(1, 1));
+
+        execute("truncate %s;");
+
+        // removal generated by unselected column should not shadow PK update with smaller timestamp
+        updateViewWithFlush("UPDATE %s USING TIMESTAMP 18 SET a=1 WHERE k=1 AND c=1", flush, version, this);
+        assertRows(execute("SELECT * from %s"), row(1, 1, 1, null));
+        assertRows(execute("SELECT * from mv"), row(1, 1));
+
+        updateViewWithFlush("UPDATE %s USING TIMESTAMP 20 SET a=null WHERE k=1 AND c=1", flush, version, this);
+        assertRows(execute("SELECT * from %s"));
+        assertRows(execute("SELECT * from mv"));
+
+        updateViewWithFlush("INSERT INTO %s(k,c) VALUES(1,1) USING TIMESTAMP 15", flush, version, this);
+        assertRows(execute("SELECT * from %s"), row(1, 1, null, null));
+        assertRows(execute("SELECT * from mv"), row(1, 1));
+    }
+
+    @Test
+    public void testPartialDeleteSelectedColumnWithFlush() throws Throwable
+    {
+        testPartialDeleteSelectedColumn(true);
+    }
+
+    @Test
+    public void testPartialDeleteSelectedColumnWithoutFlush() throws Throwable
+    {
+        testPartialDeleteSelectedColumn(false);
+    }
+
+    private void testPartialDeleteSelectedColumn(boolean flush) throws Throwable
+    {
+        execute("USE " + keyspace());
+        executeNet(version, "USE " + keyspace());
+        createTable("CREATE TABLE %s (k int, c int, a int, b int, e int, f int, PRIMARY KEY (k, c))");
+        createView("mv",
+                   "CREATE MATERIALIZED VIEW %s AS SELECT a, b, c, k FROM %%s WHERE k IS NOT NULL AND c IS NOT NULL PRIMARY KEY (k,c)",
+                   version,
+                   this,
+                   views);
+        Keyspace ks = Keyspace.open(keyspace());
+        ks.getColumnFamilyStore("mv").disableAutoCompaction();
+
+        updateViewWithFlush("UPDATE %s USING TIMESTAMP 10 SET b=1 WHERE k=1 AND c=1", flush, version, this);
+        assertRows(execute("SELECT * from %s"), row(1, 1, null, 1, null, null));
+        assertRows(execute("SELECT * from mv"), row(1, 1, null, 1));
+
+        updateViewWithFlush("DELETE b FROM %s USING TIMESTAMP 11 WHERE k=1 AND c=1", flush, version, this);
+        assertEmpty(execute("SELECT * from %s"));
+        assertEmpty(execute("SELECT * from mv"));
+
+        updateViewWithFlush("UPDATE %s USING TIMESTAMP 1 SET a=1 WHERE k=1 AND c=1", flush, version, this);
+        assertRows(execute("SELECT * from %s"), row(1, 1, 1, null, null, null));
+        assertRows(execute("SELECT * from mv"), row(1, 1, 1, null));
+
+        updateViewWithFlush("DELETE a FROM %s USING TIMESTAMP 1 WHERE k=1 AND c=1", flush, version, this);
+        assertEmpty(execute("SELECT * from %s"));
+        assertEmpty(execute("SELECT * from mv"));
+
+        // view livenessInfo should not be affected by selected column ts or tb
+        updateViewWithFlush("INSERT INTO %s(k,c) VALUES(1,1) USING TIMESTAMP 0", flush, version, this);
+        assertRows(execute("SELECT * from %s"), row(1, 1, null, null, null, null));
+        assertRows(execute("SELECT * from mv"), row(1, 1, null, null));
+
+        updateViewWithFlush("UPDATE %s USING TIMESTAMP 12 SET b=1 WHERE k=1 AND c=1", flush, version, this);
+        assertRows(execute("SELECT * from %s"), row(1, 1, null, 1, null, null));
+        assertRows(execute("SELECT * from mv"), row(1, 1, null, 1));
+
+        updateViewWithFlush("DELETE b FROM %s USING TIMESTAMP 13 WHERE k=1 AND c=1", flush, version, this);
+        assertRows(execute("SELECT * from %s"), row(1, 1, null, null, null, null));
+        assertRows(execute("SELECT * from mv"), row(1, 1, null, null));
+
+        updateViewWithFlush("DELETE FROM %s USING TIMESTAMP 14 WHERE k=1 AND c=1", flush, version, this);
+        assertEmpty(execute("SELECT * from %s"));
+        assertEmpty(execute("SELECT * from mv"));
+
+        updateViewWithFlush("INSERT INTO %s(k,c) VALUES(1,1) USING TIMESTAMP 15", flush, version, this);
+        assertRows(execute("SELECT * from %s"), row(1, 1, null, null, null, null));
+        assertRows(execute("SELECT * from mv"), row(1, 1, null, null));
+
+        updateViewWithFlush("UPDATE %s USING TTL 3 SET b=1 WHERE k=1 AND c=1", flush, version, this);
+        assertRows(execute("SELECT * from %s"), row(1, 1, null, 1, null, null));
+        assertRows(execute("SELECT * from mv"), row(1, 1, null, 1));
+
+        TimeUnit.SECONDS.sleep(4);
+
+        assertRows(execute("SELECT * from %s"), row(1, 1, null, null, null, null));
+        assertRows(execute("SELECT * from mv"), row(1, 1, null, null));
+
+        updateViewWithFlush("DELETE FROM %s USING TIMESTAMP 15 WHERE k=1 AND c=1", flush, version, this);
+        assertEmpty(execute("SELECT * from %s"));
+        assertEmpty(execute("SELECT * from mv"));
+
+        execute("truncate %s;");
+
+        // removal generated by unselected column should not shadow selected column with smaller timestamp
+        updateViewWithFlush("UPDATE %s USING TIMESTAMP 18 SET e=1 WHERE k=1 AND c=1", flush, version, this);
+        assertRows(execute("SELECT * from %s"), row(1, 1, null, null, 1, null));
+        assertRows(execute("SELECT * from mv"), row(1, 1, null, null));
+
+        updateViewWithFlush("UPDATE %s USING TIMESTAMP 18 SET e=null WHERE k=1 AND c=1", flush, version, this);
+        assertRows(execute("SELECT * from %s"));
+        assertRows(execute("SELECT * from mv"));
+
+        updateViewWithFlush("UPDATE %s USING TIMESTAMP 16 SET a=1 WHERE k=1 AND c=1", flush, version, this);
+        assertRows(execute("SELECT * from %s"), row(1, 1, 1, null, null, null));
+        assertRows(execute("SELECT * from mv"), row(1, 1, 1, null));
+    }
+
+    @Test
+    public void testRangeDeletionWithFlush() throws Throwable
+    {
+        testRangeDeletion(true);
+    }
+
+    @Test
+    public void testRangeDeletionWithoutFlush() throws Throwable
+    {
+        testRangeDeletion(false);
+    }
+
+    public void testRangeDeletion(boolean flush) throws Throwable
+    {
+        // for partition range deletion, need to know that existing row is shadowed instead of not existed.
+        createTable("CREATE TABLE %s (a int, b int, c int, d int, PRIMARY KEY (a))");
+
+        execute("USE " + keyspace());
+        executeNet(version, "USE " + keyspace());
+
+        createView("mv_test1",
+                   "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a IS NOT NULL AND b IS NOT NULL PRIMARY KEY (a, b)",
+                   version,
+                   this,
+                   views);
+
+        Keyspace ks = Keyspace.open(keyspace());
+        ks.getColumnFamilyStore("mv_test1").disableAutoCompaction();
+
+        execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?) using timestamp 0", 1, 1, 1, 1);
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test1"), row(1, 1, 1, 1));
+
+        // remove view row
+        updateView("UPDATE %s using timestamp 1 set b = null WHERE a=1", version, this);
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test1"));
+        // remove base row, no view updated generated.
+        updateView("DELETE FROM %s using timestamp 2 where a=1", version, this);
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test1"));
+
+        // restor view row with b,c column. d is still tombstone
+        updateView("UPDATE %s using timestamp 3 set b = 1,c = 1 where a=1", version, this); // upsert
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test1"), row(1, 1, 1, null));
+    }
+
+    @Test
+    public void testCommutativeRowDeletionFlush() throws Throwable
+    {
+        // CASSANDRA-13409
+        testCommutativeRowDeletion(true);
+    }
+
+    @Test
+    public void testCommutativeRowDeletionWithoutFlush() throws Throwable
+    {
+        // CASSANDRA-13409
+        testCommutativeRowDeletion(false);
+    }
+
+    private void testCommutativeRowDeletion(boolean flush) throws Throwable
+    {
+        // CASSANDRA-13409 new update should not resurrect previous deleted data in view
+        createTable("create table %s (p int primary key, v1 int, v2 int)");
+
+        execute("USE " + keyspace());
+        executeNet(version, "USE " + keyspace());
+        Keyspace ks = Keyspace.open(keyspace());
+
+        createView("mv",
+                   "create materialized view %s as select * from %%s where p is not null and v1 is not null primary key (v1, p);",
+                   version,
+                   this,
+                   views);
+        ks.getColumnFamilyStore("mv").disableAutoCompaction();
+
+        // sstable-1, Set initial values TS=1
+        updateView("Insert into %s (p, v1, v2) values (3, 1, 3) using timestamp 1;", version, this);
+
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+
+        assertRowsIgnoringOrder(execute("SELECT v2, WRITETIME(v2) from mv WHERE v1 = ? AND p = ?", 1, 3), row(3, 1L));
+        // sstable-2
+        updateView("Delete from %s using timestamp 2 where p = 3;", version, this);
+
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+
+        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from mv"));
+        // sstable-3
+        updateView("Insert into %s (p, v1) values (3, 1) using timestamp 3;", version, this);
+
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+
+        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from mv"), row(1, 3, null, null));
+        // sstable-4
+        updateView("UPdate %s using timestamp 4 set v1 = 2 where p = 3;", version, this);
+
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+
+        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from mv"), row(2, 3, null, null));
+        // sstable-5
+        updateView("UPdate %s using timestamp 5 set v1 = 1 where p = 3;", version, this);
+
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+
+        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from mv"), row(1, 3, null, null));
+
+        if (flush)
+        {
+            // compact sstable 2 and 4, 5;
+            ColumnFamilyStore cfs = ks.getColumnFamilyStore("mv");
+            List<String> sstables = cfs.getLiveSSTables()
+                                       .stream()
+                                       .sorted((s1, s2) -> s1.descriptor.generation - s2.descriptor.generation)
+                                       .map(s -> s.getFilename())
+                                       .collect(Collectors.toList());
+            String dataFiles = String.join(",", Arrays.asList(sstables.get(1), sstables.get(3), sstables.get(4)));
+            CompactionManager.instance.forceUserDefinedCompaction(dataFiles);
+            assertEquals(3, cfs.getLiveSSTables().size());
+        }
+        // regular tombstone should be retained after compaction
+        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from mv"), row(1, 3, null, null));
+    }
+
+    @Test
+    public void testComplexTimestampDeletionTestWithFlush() throws Throwable
+    {
+        complexTimestampWithbaseNonPKColumnsInViewPKDeletionTest(true);
+        complexTimestampWithbasePKColumnsInViewPKDeletionTest(true);
+    }
+
+    @Test
+    public void testComplexTimestampDeletionTestWithoutFlush() throws Throwable
+    {
+        complexTimestampWithbaseNonPKColumnsInViewPKDeletionTest(false);
+        complexTimestampWithbasePKColumnsInViewPKDeletionTest(false);
+    }
+
+    private void complexTimestampWithbasePKColumnsInViewPKDeletionTest(boolean flush) throws Throwable
+    {
+        createTable("create table %s (p1 int, p2 int, v1 int, v2 int, primary key(p1, p2))");
+
+        execute("USE " + keyspace());
+        executeNet(version, "USE " + keyspace());
+        Keyspace ks = Keyspace.open(keyspace());
+
+        createView("mv2",
+                   "create materialized view %s as select * from %%s where p1 is not null and p2 is not null primary key (p2, p1);",
+                   version,
+                   this,
+                   views);
+        ks.getColumnFamilyStore("mv2").disableAutoCompaction();
+
+        // Set initial values TS=1
+        updateView("Insert into %s (p1, p2, v1, v2) values (1, 2, 3, 4) using timestamp 1;", version, this);
+
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+
+        assertRowsIgnoringOrder(execute("SELECT v1, v2, WRITETIME(v2) from mv2 WHERE p1 = ? AND p2 = ?", 1, 2),
+                                row(3, 4, 1L));
+        // remove row/mv TS=2
+        updateView("Delete from %s using timestamp 2 where p1 = 1 and p2 = 2;", version, this);
+
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+        // view are empty
+        assertRowsIgnoringOrder(execute("SELECT * from mv2"));
+        // insert PK with TS=3
+        updateView("Insert into %s (p1, p2) values (1, 2) using timestamp 3;", version, this);
+
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+        // deleted column in MV remained dead
+        assertRowsIgnoringOrder(execute("SELECT * from mv2"), row(2, 1, null, null));
+
+        ks.getColumnFamilyStore("mv2").forceMajorCompaction();
+        assertRowsIgnoringOrder(execute("SELECT * from mv2"), row(2, 1, null, null));
+
+        // reset values
+        updateView("Insert into %s (p1, p2, v1, v2) values (1, 2, 3, 4) using timestamp 10;", version, this);
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+
+        assertRowsIgnoringOrder(execute("SELECT v1, v2, WRITETIME(v2) from mv2 WHERE p1 = ? AND p2 = ?", 1, 2),
+                                row(3, 4, 10L));
+
+        updateView("UPDATE %s using timestamp 20 SET v2 = 5 WHERE p1 = 1 and p2 = 2", version, this);
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+
+        assertRowsIgnoringOrder(execute("SELECT v1, v2, WRITETIME(v2) from mv2 WHERE p1 = ? AND p2 = ?", 1, 2),
+                                row(3, 5, 20L));
+
+        updateView("DELETE FROM %s using timestamp 10 WHERE p1 = 1 and p2 = 2", version, this);
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+
+        assertRowsIgnoringOrder(execute("SELECT v1, v2, WRITETIME(v2) from mv2 WHERE p1 = ? AND p2 = ?", 1, 2),
+                                row(null, 5, 20L));
+    }
+
+    public void complexTimestampWithbaseNonPKColumnsInViewPKDeletionTest(boolean flush) throws Throwable
+    {
+        createTable("create table %s (p int primary key, v1 int, v2 int)");
+
+        execute("USE " + keyspace());
+        executeNet(version, "USE " + keyspace());
+        Keyspace ks = Keyspace.open(keyspace());
+
+        createView("mv",
+                   "create materialized view %s as select * from %%s where p is not null and v1 is not null primary key (v1, p);",
+                   version,
+                   this,
+                   views);
+        ks.getColumnFamilyStore("mv").disableAutoCompaction();
+
+        // Set initial values TS=1
+        updateView("Insert into %s (p, v1, v2) values (3, 1, 5) using timestamp 1;", version, this);
+
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+
+        assertRowsIgnoringOrder(execute("SELECT v2, WRITETIME(v2) from mv WHERE v1 = ? AND p = ?", 1, 3), row(5, 1L));
+        // remove row/mv TS=2
+        updateView("Delete from %s using timestamp 2 where p = 3;", version, this);
+
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+        // view are empty
+        assertRowsIgnoringOrder(execute("SELECT * from mv"));
+        // insert PK with TS=3
+        updateView("Insert into %s (p, v1) values (3, 1) using timestamp 3;", version, this);
+
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+        // deleted column in MV remained dead
+        assertRowsIgnoringOrder(execute("SELECT * from mv"), row(1, 3, null));
+
+        // insert values TS=2, it should be considered dead due to previous tombstone
+        updateView("Insert into %s (p, v1, v2) values (3, 1, 5) using timestamp 2;", version, this);
+
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+        // deleted column in MV remained dead
+        assertRowsIgnoringOrder(execute("SELECT * from mv"), row(1, 3, null));
+        assertRowsIgnoringOrder(execute("SELECT * from mv limit 1"), row(1, 3, null));
+
+        // insert values TS=2, it should be considered dead due to previous tombstone
+        executeNet(version, "UPDATE %s USING TIMESTAMP 3 SET v2 = ? WHERE p = ?", 4, 3);
+
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+
+        assertRows(execute("SELECT v1, p, v2, WRITETIME(v2) from mv"), row(1, 3, 4, 3L));
+
+        ks.getColumnFamilyStore("mv").forceMajorCompaction();
+        assertRows(execute("SELECT v1, p, v2, WRITETIME(v2) from mv"), row(1, 3, 4, 3L));
+        assertRows(execute("SELECT v1, p, v2, WRITETIME(v2) from mv limit 1"), row(1, 3, 4, 3L));
+    }
+}
diff --git a/test/unit/org/apache/cassandra/cql3/ViewComplexTTLTest.java b/test/unit/org/apache/cassandra/cql3/ViewComplexTTLTest.java
new file mode 100644
index 0000000000..01bc33a85b
--- /dev/null
+++ b/test/unit/org/apache/cassandra/cql3/ViewComplexTTLTest.java
@@ -0,0 +1,277 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.cassandra.cql3;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import org.apache.cassandra.db.Keyspace;
+import org.apache.cassandra.transport.ProtocolVersion;
+import org.apache.cassandra.utils.FBUtilities;
+
+import static org.apache.cassandra.cql3.ViewComplexTest.createView;
+import static org.apache.cassandra.cql3.ViewComplexTest.updateView;
+import static org.apache.cassandra.cql3.ViewComplexTest.updateViewWithFlush;
+import static org.junit.Assert.assertTrue;
+
+/* This class been split into multiple ones bc of timeout issues CASSANDRA-16670
+ * Any changes here check if they apply to the other classes:
+ * - ViewComplexUpdatesTest
+ * - ViewComplexDeletionsTest
+ * - ViewComplexTTLTest
+ * - ViewComplexTest
+ */
+@RunWith(Parameterized.class)
+public class ViewComplexTTLTest extends CQLTester
+{
+    @Parameterized.Parameter
+    public ProtocolVersion version;
+
+    @Parameterized.Parameters()
+    public static Collection<Object[]> versions()
+    {
+        return ViewComplexTest.versions();
+    }
+
+    private final List<String> views = new ArrayList<>();
+
+    @BeforeClass
+    public static void startup()
+    {
+        ViewComplexTest.startup();
+    }
+
+    @Before
+    public void begin()
+    {
+        ViewComplexTest.beginSetup(views);
+    }
+
+    @After
+    public void end() throws Throwable
+    {
+        ViewComplexTest.endTearDown(views, version, this);
+    }
+
+    @Test
+    public void testUpdateColumnInViewPKWithTTLWithFlush() throws Throwable
+    {
+        // CASSANDRA-13657
+        testUpdateColumnInViewPKWithTTL(true);
+    }
+
+    @Test
+    public void testUpdateColumnInViewPKWithTTLWithoutFlush() throws Throwable
+    {
+        // CASSANDRA-13657
+        testUpdateColumnInViewPKWithTTL(false);
+    }
+
+    private void testUpdateColumnInViewPKWithTTL(boolean flush) throws Throwable
+    {
+        // CASSANDRA-13657 if base column used in view pk is ttled, then view row is considered dead
+        createTable("create table %s (k int primary key, a int, b int)");
+
+        execute("USE " + keyspace());
+        executeNet(version, "USE " + keyspace());
+        Keyspace ks = Keyspace.open(keyspace());
+
+        createView("mv",
+                   "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE k IS NOT NULL AND a IS NOT NULL PRIMARY KEY (a, k)",
+                   version,
+                   this,
+                   views);
+        ks.getColumnFamilyStore("mv").disableAutoCompaction();
+
+        updateView("UPDATE %s SET a = 1 WHERE k = 1;", version, this);
+
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+
+        assertRows(execute("SELECT * from %s"), row(1, 1, null));
+        assertRows(execute("SELECT * from mv"), row(1, 1, null));
+
+        updateView("DELETE a FROM %s WHERE k = 1", version, this);
+
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+
+        assertRows(execute("SELECT * from %s"));
+        assertEmpty(execute("SELECT * from mv"));
+
+        updateView("INSERT INTO %s (k) VALUES (1);", version, this);
+
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+
+        assertRows(execute("SELECT * from %s"), row(1, null, null));
+        assertEmpty(execute("SELECT * from mv"));
+
+        updateView("UPDATE %s USING TTL 5 SET a = 10 WHERE k = 1;", version, this);
+
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+
+        assertRows(execute("SELECT * from %s"), row(1, 10, null));
+        assertRows(execute("SELECT * from mv"), row(10, 1, null));
+
+        updateView("UPDATE %s SET b = 100 WHERE k = 1;", version, this);
+
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+
+        assertRows(execute("SELECT * from %s"), row(1, 10, 100));
+        assertRows(execute("SELECT * from mv"), row(10, 1, 100));
+
+        Thread.sleep(5000);
+
+        // 'a' is TTL of 5 and removed.
+        assertRows(execute("SELECT * from %s"), row(1, null, 100));
+        assertEmpty(execute("SELECT * from mv"));
+        assertEmpty(execute("SELECT * from mv WHERE k = ? AND a = ?", 1, 10));
+
+        updateView("DELETE b FROM %s WHERE k=1", version, this);
+
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+
+        assertRows(execute("SELECT * from %s"), row(1, null, null));
+        assertEmpty(execute("SELECT * from mv"));
+
+        updateView("DELETE FROM %s WHERE k=1;", version, this);
+
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+
+        assertEmpty(execute("SELECT * from %s"));
+        assertEmpty(execute("SELECT * from mv"));
+    }
+    @Test
+    public void testUnselectedColumnsTTLWithFlush() throws Throwable
+    {
+        // CASSANDRA-13127
+        testUnselectedColumnsTTL(true);
+    }
+
+    @Test
+    public void testUnselectedColumnsTTLWithoutFlush() throws Throwable
+    {
+        // CASSANDRA-13127
+        testUnselectedColumnsTTL(false);
+    }
+
+    private void testUnselectedColumnsTTL(boolean flush) throws Throwable
+    {
+        // CASSANDRA-13127 not ttled unselected column in base should keep view row alive
+        createTable("create table %s (p int, c int, v int, primary key(p, c))");
+
+        execute("USE " + keyspace());
+        executeNet(version, "USE " + keyspace());
+        Keyspace ks = Keyspace.open(keyspace());
+
+        createView("mv",
+                   "CREATE MATERIALIZED VIEW %s AS SELECT p, c FROM %%s WHERE p IS NOT NULL AND c IS NOT NULL PRIMARY KEY (c, p);",
+                   version,
+                   this,
+                   views);
+        ks.getColumnFamilyStore("mv").disableAutoCompaction();
+
+        updateViewWithFlush("INSERT INTO %s (p, c) VALUES (0, 0) USING TTL 3;", flush, version, this);
+
+        updateViewWithFlush("UPDATE %s USING TTL 1000 SET v = 0 WHERE p = 0 and c = 0;", flush, version, this);
+
+        assertRowsIgnoringOrder(execute("SELECT * from mv WHERE c = ? AND p = ?", 0, 0), row(0, 0));
+
+        Thread.sleep(3000);
+
+        UntypedResultSet.Row row = execute("SELECT v, ttl(v) from %s WHERE c = ? AND p = ?", 0, 0).one();
+        assertTrue("row should have value of 0", row.getInt("v") == 0);
+        assertTrue("row should have ttl less than 1000", row.getInt("ttl(v)") < 1000);
+        assertRowsIgnoringOrder(execute("SELECT * from mv WHERE c = ? AND p = ?", 0, 0), row(0, 0));
+
+        updateViewWithFlush("DELETE FROM %s WHERE p = 0 and c = 0;", flush, version, this);
+        assertRowsIgnoringOrder(execute("SELECT * from mv WHERE c = ? AND p = ?", 0, 0));
+
+        updateViewWithFlush("INSERT INTO %s (p, c) VALUES (0, 0) ", flush, version, this);
+        assertRowsIgnoringOrder(execute("SELECT * from mv WHERE c = ? AND p = ?", 0, 0), row(0, 0));
+
+        // already have a live row, no need to apply the unselected cell ttl
+        updateViewWithFlush("UPDATE %s USING TTL 3 SET v = 0 WHERE p = 0 and c = 0;", flush, version, this);
+        assertRowsIgnoringOrder(execute("SELECT * from mv WHERE c = ? AND p = ?", 0, 0), row(0, 0));
+
+        updateViewWithFlush("INSERT INTO %s (p, c) VALUES (1, 1) USING TTL 3", flush, version, this);
+        assertRowsIgnoringOrder(execute("SELECT * from mv WHERE c = ? AND p = ?", 1, 1), row(1, 1));
+
+        Thread.sleep(4000);
+
+        assertRowsIgnoringOrder(execute("SELECT * from mv WHERE c = ? AND p = ?", 0, 0), row(0, 0));
+        assertRowsIgnoringOrder(execute("SELECT * from mv WHERE c = ? AND p = ?", 1, 1));
+
+        // unselected should keep view row alive
+        updateViewWithFlush("UPDATE %s SET v = 0 WHERE p = 1 and c = 1;", flush, version, this);
+        assertRowsIgnoringOrder(execute("SELECT * from mv WHERE c = ? AND p = ?", 1, 1), row(1, 1));
+
+    } 
+
+    @Test
+    public void testBaseTTLWithSameTimestampTest() throws Throwable
+    {
+        // CASSANDRA-13127 when liveness timestamp tie, greater localDeletionTime should win if both are expiring.
+        createTable("create table %s (p int, c int, v int, primary key(p, c))");
+
+        execute("USE " + keyspace());
+        executeNet(version, "USE " + keyspace());
+        Keyspace ks = Keyspace.open(keyspace());
+
+        updateView("INSERT INTO %s (p, c, v) VALUES (0, 0, 0) using timestamp 1;", version, this);
+
+        FBUtilities.waitOnFutures(ks.flush());
+
+        updateView("INSERT INTO %s (p, c, v) VALUES (0, 0, 0) USING TTL 3 and timestamp 1;", version, this);
+
+        FBUtilities.waitOnFutures(ks.flush());
+
+        Thread.sleep(4000);
+
+        assertEmpty(execute("SELECT * from %s WHERE c = ? AND p = ?", 0, 0));
+
+        // reversed order
+        execute("truncate %s;");
+
+        updateView("INSERT INTO %s (p, c, v) VALUES (0, 0, 0) USING TTL 3 and timestamp 1;", version, this);
+
+        FBUtilities.waitOnFutures(ks.flush());
+
+        updateView("INSERT INTO %s (p, c, v) VALUES (0, 0, 0) USING timestamp 1;", version, this);
+
+        FBUtilities.waitOnFutures(ks.flush());
+
+        Thread.sleep(4000);
+
+        assertEmpty(execute("SELECT * from %s WHERE c = ? AND p = ?", 0, 0));
+    }    
+}
diff --git a/test/unit/org/apache/cassandra/cql3/ViewComplexTest.java b/test/unit/org/apache/cassandra/cql3/ViewComplexTest.java
new file mode 100644
index 0000000000..3d0e347cb4
--- /dev/null
+++ b/test/unit/org/apache/cassandra/cql3/ViewComplexTest.java
@@ -0,0 +1,609 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.cassandra.cql3;
+
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Comparator;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.stream.Collectors;
+
+import com.google.common.base.Objects;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import com.datastax.driver.core.exceptions.OperationTimedOutException;
+import org.apache.cassandra.concurrent.SEPExecutor;
+import org.apache.cassandra.concurrent.Stage;
+import org.apache.cassandra.db.ColumnFamilyStore;
+import org.apache.cassandra.db.Keyspace;
+import org.apache.cassandra.db.compaction.CompactionManager;
+import org.apache.cassandra.transport.ProtocolVersion;
+import org.apache.cassandra.utils.FBUtilities;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+/* This class been split into multiple ones bc of timeout issues CASSANDRA-16670
+ * Any changes here check if they apply to the other classes:
+ * - ViewComplexUpdatesTest
+ * - ViewComplexDeletionsTest
+ * - ViewComplexTTLTest
+ * - ViewComplexTest
+ */
+@RunWith(Parameterized.class)
+public class ViewComplexTest extends CQLTester
+{
+    @Parameterized.Parameter
+    public ProtocolVersion version;
+
+    @Parameterized.Parameters()
+    public static Collection<Object[]> versions()
+    {
+        return ProtocolVersion.SUPPORTED.stream()
+                                        .map(v -> new Object[]{v})
+                                        .collect(Collectors.toList());
+    }
+
+    private final List<String> views = new ArrayList<>();
+
+    @BeforeClass
+    public static void startup()
+    {
+        requireNetwork();
+    }
+
+    @Before
+    public void begin()
+    {
+        beginSetup(views);
+    }
+
+    public static void beginSetup(List<String> views)
+    {
+        views.clear();
+    }
+
+    @After
+    public void end() throws Throwable
+    {
+        endTearDown(views, version, this);
+    }
+
+    public static void endTearDown(List<String> views, ProtocolVersion version, CQLTester cqlTester) throws Throwable
+    {
+        for (String viewName : views)
+            cqlTester.executeNet(version, "DROP MATERIALIZED VIEW " + viewName);
+    }
+
+    public static void createView(String name, String query, ProtocolVersion version, CQLTester cqlTester, List<String> views) throws Throwable
+    {
+        try
+        {
+            cqlTester.executeNet(version, String.format(query, name));
+            // If exception is thrown, the view will not be added to the list; since it shouldn't have been created, this is
+            // the desired behavior
+            views.add(name);
+        }
+        catch (OperationTimedOutException ex)
+        {
+            // ... except for timeout, when we actually do not know whether the view was created or not
+            views.add(name);
+            throw ex;
+        }
+    }
+
+    public static void updateView(String query, ProtocolVersion version, CQLTester cqlTester, Object... params) throws Throwable
+    {
+        updateViewWithFlush(query, false, version, cqlTester, params);
+    }
+
+    public static void updateViewWithFlush(String query, boolean flush, ProtocolVersion version, CQLTester cqlTester, Object... params) throws Throwable
+    {
+        cqlTester.executeNet(version, query, params);
+        while (!(((SEPExecutor) Stage.VIEW_MUTATION.executor()).getPendingTaskCount() == 0
+                && ((SEPExecutor) Stage.VIEW_MUTATION.executor()).getActiveTaskCount() == 0))
+        {
+            Thread.sleep(1);
+        }
+        if (flush)
+            Keyspace.open(cqlTester.keyspace()).flush();
+    }
+
+    @Test
+    public void testUnselectedColumnWithExpiredLivenessInfo() throws Throwable
+    {
+        boolean flush = true;
+        createTable("create table %s (k int, c int, a int, b int, PRIMARY KEY(k, c))");
+
+        execute("USE " + keyspace());
+        executeNet(version, "USE " + keyspace());
+        Keyspace ks = Keyspace.open(keyspace());
+
+        createView("mv",
+                   "create materialized view %s as select k,c,b from %%s where c is not null and k is not null primary key (c, k);",
+                   version,
+                   this,
+                   views);
+        ks.getColumnFamilyStore("mv").disableAutoCompaction();
+
+        // sstable-1, Set initial values TS=1
+        updateViewWithFlush("UPDATE %s SET a = 1 WHERE k = 1 AND c = 1;", flush, version, this);
+
+        assertRowsIgnoringOrder(execute("SELECT * from %s WHERE k = 1 AND c = 1;"),
+                                row(1, 1, 1, null));
+        assertRowsIgnoringOrder(execute("SELECT k,c,b from mv WHERE k = 1 AND c = 1;"),
+                                row(1, 1, null));
+
+        // sstable-2
+        updateViewWithFlush("INSERT INTO %s(k,c) VALUES(1,1) USING TTL 5", flush, version, this);
+
+        assertRowsIgnoringOrder(execute("SELECT * from %s WHERE k = 1 AND c = 1;"),
+                                row(1, 1, 1, null));
+        assertRowsIgnoringOrder(execute("SELECT k,c,b from mv WHERE k = 1 AND c = 1;"),
+                                row(1, 1, null));
+
+        Thread.sleep(5001);
+
+        assertRowsIgnoringOrder(execute("SELECT * from %s WHERE k = 1 AND c = 1;"),
+                                row(1, 1, 1, null));
+        assertRowsIgnoringOrder(execute("SELECT k,c,b from mv WHERE k = 1 AND c = 1;"),
+                                row(1, 1, null));
+
+        // sstable-3
+        updateViewWithFlush("Update %s set a = null where k = 1 AND c = 1;", flush, version, this);
+
+        assertRowsIgnoringOrder(execute("SELECT * from %s WHERE k = 1 AND c = 1;"));
+        assertRowsIgnoringOrder(execute("SELECT k,c,b from mv WHERE k = 1 AND c = 1;"));
+
+        // sstable-4
+        updateViewWithFlush("Update %s USING TIMESTAMP 1 set b = 1 where k = 1 AND c = 1;", flush, version, this);
+
+        assertRowsIgnoringOrder(execute("SELECT * from %s WHERE k = 1 AND c = 1;"),
+                                row(1, 1, null, 1));
+        assertRowsIgnoringOrder(execute("SELECT k,c,b from mv WHERE k = 1 AND c = 1;"),
+                                row(1, 1, 1));
+    }
+
+    @Test
+    public void testExpiredLivenessLimitWithFlush() throws Throwable
+    {
+        // CASSANDRA-13883
+        testExpiredLivenessLimit(true);
+    }
+
+    @Test
+    public void testExpiredLivenessLimitWithoutFlush() throws Throwable
+    {
+        // CASSANDRA-13883
+        testExpiredLivenessLimit(false);
+    }
+
+    private void testExpiredLivenessLimit(boolean flush) throws Throwable
+    {
+        createTable("CREATE TABLE %s (k int PRIMARY KEY, a int, b int);");
+
+        execute("USE " + keyspace());
+        executeNet(version, "USE " + keyspace());
+        Keyspace ks = Keyspace.open(keyspace());
+
+        createView("mv1",
+                   "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE k IS NOT NULL AND a IS NOT NULL PRIMARY KEY (k, a);",
+                   version,
+                   this,
+                   views);
+        createView("mv2",
+                   "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE k IS NOT NULL AND a IS NOT NULL PRIMARY KEY (a, k);",
+                   version,
+                   this,
+                   views);
+        ks.getColumnFamilyStore("mv1").disableAutoCompaction();
+        ks.getColumnFamilyStore("mv2").disableAutoCompaction();
+
+        for (int i = 1; i <= 100; i++)
+            updateView("INSERT INTO %s(k, a, b) VALUES (?, ?, ?);", version, this, i, i, i);
+        for (int i = 1; i <= 100; i++)
+        {
+            if (i % 50 == 0)
+                continue;
+            // create expired liveness
+            updateView("DELETE a FROM %s WHERE k = ?;", version, this, i);
+        }
+        if (flush)
+        {
+            ks.getColumnFamilyStore("mv1").forceBlockingFlush();
+            ks.getColumnFamilyStore("mv2").forceBlockingFlush();
+        }
+
+        for (String view : Arrays.asList("mv1", "mv2"))
+        {
+            // paging
+            assertEquals(1, executeNetWithPaging(version, String.format("SELECT k,a,b FROM %s limit 1", view), 1).all().size());
+            assertEquals(2, executeNetWithPaging(version, String.format("SELECT k,a,b FROM %s limit 2", view), 1).all().size());
+            assertEquals(2, executeNetWithPaging(version, String.format("SELECT k,a,b FROM %s", view), 1).all().size());
+            assertRowsNet(version, executeNetWithPaging(version, String.format("SELECT k,a,b FROM %s ", view), 1),
+                          row(50, 50, 50),
+                          row(100, 100, 100));
+            // limit
+            assertEquals(1, execute(String.format("SELECT k,a,b FROM %s limit 1", view)).size());
+            assertRowsIgnoringOrder(execute(String.format("SELECT k,a,b FROM %s limit 2", view)),
+                                    row(50, 50, 50),
+                                    row(100, 100, 100));
+        }
+    }
+
+    @Test
+    public void testNonBaseColumnInViewPkWithFlush() throws Throwable
+    {
+        testNonBaseColumnInViewPk(true);
+    }
+
+    @Test
+    public void testNonBaseColumnInViewPkWithoutFlush() throws Throwable
+    {
+        testNonBaseColumnInViewPk(true);
+    }
+
+    public void testNonBaseColumnInViewPk(boolean flush) throws Throwable
+    {
+        createTable("create table %s (p1 int, p2 int, v1 int, v2 int, primary key (p1,p2))");
+
+        execute("USE " + keyspace());
+        executeNet(version, "USE " + keyspace());
+        Keyspace ks = Keyspace.open(keyspace());
+
+        createView("mv",
+                   "create materialized view %s as select * from %%s where p1 is not null and p2 is not null primary key (p2, p1)"
+                           + " with gc_grace_seconds=5;",
+                   version,
+                   this,
+                   views);
+        ColumnFamilyStore cfs = ks.getColumnFamilyStore("mv");
+        cfs.disableAutoCompaction();
+
+        updateView("UPDATE %s USING TIMESTAMP 1 set v1 =1 where p1 = 1 AND p2 = 1;", version, this);
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+        assertRowsIgnoringOrder(execute("SELECT p1, p2, v1, v2 from %s"), row(1, 1, 1, null));
+        assertRowsIgnoringOrder(execute("SELECT p1, p2, v1, v2 from mv"), row(1, 1, 1, null));
+
+        updateView("UPDATE %s USING TIMESTAMP 2 set v1 = null, v2 = 1 where p1 = 1 AND p2 = 1;", version, this);
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+        assertRowsIgnoringOrder(execute("SELECT p1, p2, v1, v2 from %s"), row(1, 1, null, 1));
+        assertRowsIgnoringOrder(execute("SELECT p1, p2, v1, v2 from mv"), row(1, 1, null, 1));
+
+        updateView("UPDATE %s USING TIMESTAMP 2 set v2 = null where p1 = 1 AND p2 = 1;", version, this);
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+        assertRowsIgnoringOrder(execute("SELECT p1, p2, v1, v2 from %s"));
+        assertRowsIgnoringOrder(execute("SELECT p1, p2, v1, v2 from mv"));
+
+        updateView("INSERT INTO %s (p1,p2) VALUES(1,1) USING TIMESTAMP 3;", version, this);
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+        assertRowsIgnoringOrder(execute("SELECT p1, p2, v1, v2 from %s"), row(1, 1, null, null));
+        assertRowsIgnoringOrder(execute("SELECT p1, p2, v1, v2 from mv"), row(1, 1, null, null));
+
+        updateView("DELETE FROM %s USING TIMESTAMP 4 WHERE p1 =1 AND p2 = 1;", version, this);
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+        assertRowsIgnoringOrder(execute("SELECT p1, p2, v1, v2 from %s"));
+        assertRowsIgnoringOrder(execute("SELECT p1, p2, v1, v2 from mv"));
+
+        updateView("UPDATE %s USING TIMESTAMP 5 set v2 = 1 where p1 = 1 AND p2 = 1;", version, this);
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+        assertRowsIgnoringOrder(execute("SELECT p1, p2, v1, v2 from %s"), row(1, 1, null, 1));
+        assertRowsIgnoringOrder(execute("SELECT p1, p2, v1, v2 from mv"), row(1, 1, null, 1));
+    }
+
+    @Test
+    public void testStrictLivenessTombstone() throws Throwable
+    {
+        createTable("create table %s (p int primary key, v1 int, v2 int)");
+
+        execute("USE " + keyspace());
+        executeNet(version, "USE " + keyspace());
+        Keyspace ks = Keyspace.open(keyspace());
+
+        createView("mv",
+                   "create materialized view %s as select * from %%s where p is not null and v1 is not null primary key (v1, p)"
+                           + " with gc_grace_seconds=5;",
+                   version,
+                   this,
+                   views);
+        ColumnFamilyStore cfs = ks.getColumnFamilyStore("mv");
+        cfs.disableAutoCompaction();
+
+        updateView("Insert into %s (p, v1, v2) values (1, 1, 1) ;", version, this);
+        assertRowsIgnoringOrder(execute("SELECT p, v1, v2 from mv"), row(1, 1, 1));
+
+        updateView("Update %s set v1 = null WHERE p = 1", version, this);
+        FBUtilities.waitOnFutures(ks.flush());
+        assertRowsIgnoringOrder(execute("SELECT p, v1, v2 from mv"));
+
+        cfs.forceMajorCompaction(); // before gc grace second, strict-liveness tombstoned dead row remains
+        assertEquals(1, cfs.getLiveSSTables().size());
+
+        Thread.sleep(6000);
+        assertEquals(1, cfs.getLiveSSTables().size()); // no auto compaction.
+
+        cfs.forceMajorCompaction(); // after gc grace second, no data left
+        assertEquals(0, cfs.getLiveSSTables().size());
+
+        updateView("Update %s using ttl 5 set v1 = 1 WHERE p = 1", version, this);
+        FBUtilities.waitOnFutures(ks.flush());
+        assertRowsIgnoringOrder(execute("SELECT p, v1, v2 from mv"), row(1, 1, 1));
+
+        cfs.forceMajorCompaction(); // before ttl+gc_grace_second, strict-liveness ttled dead row remains
+        assertEquals(1, cfs.getLiveSSTables().size());
+        assertRowsIgnoringOrder(execute("SELECT p, v1, v2 from mv"), row(1, 1, 1));
+
+        Thread.sleep(5500); // after expired, before gc_grace_second
+        cfs.forceMajorCompaction();// before ttl+gc_grace_second, strict-liveness ttled dead row remains
+        assertEquals(1, cfs.getLiveSSTables().size());
+        assertRowsIgnoringOrder(execute("SELECT p, v1, v2 from mv"));
+
+        Thread.sleep(5500); // after expired + gc_grace_second
+        assertEquals(1, cfs.getLiveSSTables().size()); // no auto compaction.
+
+        cfs.forceMajorCompaction(); // after gc grace second, no data left
+        assertEquals(0, cfs.getLiveSSTables().size());
+    }
+
+    @Test
+    public void testCellTombstoneAndShadowableTombstonesWithFlush() throws Throwable
+    {
+        testCellTombstoneAndShadowableTombstones(true);
+    }
+
+    @Test
+    public void testCellTombstoneAndShadowableTombstonesWithoutFlush() throws Throwable
+    {
+        testCellTombstoneAndShadowableTombstones(false);
+    }
+
+    private void testCellTombstoneAndShadowableTombstones(boolean flush) throws Throwable
+    {
+        createTable("create table %s (p int primary key, v1 int, v2 int)");
+
+        execute("USE " + keyspace());
+        executeNet(version, "USE " + keyspace());
+        Keyspace ks = Keyspace.open(keyspace());
+
+        createView("mv",
+                   "create materialized view %s as select * from %%s where p is not null and v1 is not null primary key (v1, p);",
+                   version,
+                   this,
+                   views);
+        ks.getColumnFamilyStore("mv").disableAutoCompaction();
+
+        // sstable 1, Set initial values TS=1
+        updateView("Insert into %s (p, v1, v2) values (3, 1, 3) using timestamp 1;", version, this);
+
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+
+        assertRowsIgnoringOrder(execute("SELECT v2, WRITETIME(v2) from mv WHERE v1 = ? AND p = ?", 1, 3), row(3, 1L));
+        // sstable 2
+        updateView("UPdate %s using timestamp 2 set v2 = null where p = 3", version, this);
+
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+
+        assertRowsIgnoringOrder(execute("SELECT v2, WRITETIME(v2) from mv WHERE v1 = ? AND p = ?", 1, 3),
+                                row(null, null));
+        // sstable 3
+        updateView("UPdate %s using timestamp 3 set v1 = 2 where p = 3", version, this);
+
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+
+        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from mv"), row(2, 3, null, null));
+        // sstable 4
+        updateView("UPdate %s using timestamp 4 set v1 = 1 where p = 3", version, this);
+
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+
+        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from mv"), row(1, 3, null, null));
+
+        if (flush)
+        {
+            // compact sstable 2 and 3;
+            ColumnFamilyStore cfs = ks.getColumnFamilyStore("mv");
+            List<String> sstables = cfs.getLiveSSTables()
+                                       .stream()
+                                       .sorted(Comparator.comparingInt(s -> s.descriptor.generation))
+                                       .map(s -> s.getFilename())
+                                       .collect(Collectors.toList());
+            String dataFiles = String.join(",", Arrays.asList(sstables.get(1), sstables.get(2)));
+            CompactionManager.instance.forceUserDefinedCompaction(dataFiles);
+        }
+        // cell-tombstone in sstable 4 is not compacted away, because the shadowable tombstone is shadowed by new row.
+        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from mv"), row(1, 3, null, null));
+        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from mv limit 1"), row(1, 3, null, null));
+    }
+
+    @Test
+    public void testMVWithDifferentColumnsWithFlush() throws Throwable
+    {
+        testMVWithDifferentColumns(true);
+    }
+
+    @Test
+    public void testMVWithDifferentColumnsWithoutFlush() throws Throwable
+    {
+        testMVWithDifferentColumns(false);
+    }
+
+    private void testMVWithDifferentColumns(boolean flush) throws Throwable
+    {
+        createTable("CREATE TABLE %s (a int, b int, c int, d int, e int, f int, PRIMARY KEY(a, b))");
+
+        execute("USE " + keyspace());
+        executeNet(version, "USE " + keyspace());
+        List<String> viewNames = new ArrayList<>();
+        List<String> mvStatements = Arrays.asList(
+                                                  // all selected
+                                                  "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a IS NOT NULL AND b IS NOT NULL PRIMARY KEY (a,b)",
+                                                  // unselected e,f
+                                                  "CREATE MATERIALIZED VIEW %s AS SELECT a,b,c,d FROM %%s WHERE a IS NOT NULL AND b IS NOT NULL PRIMARY KEY (a,b)",
+                                                  // no selected
+                                                  "CREATE MATERIALIZED VIEW %s AS SELECT a,b FROM %%s WHERE a IS NOT NULL AND b IS NOT NULL PRIMARY KEY (a,b)",
+                                                  // all selected, re-order keys
+                                                  "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a IS NOT NULL AND b IS NOT NULL PRIMARY KEY (b,a)",
+                                                  // unselected e,f, re-order keys
+                                                  "CREATE MATERIALIZED VIEW %s AS SELECT a,b,c,d FROM %%s WHERE a IS NOT NULL AND b IS NOT NULL PRIMARY KEY (b,a)",
+                                                  // no selected, re-order keys
+                                                  "CREATE MATERIALIZED VIEW %s AS SELECT a,b FROM %%s WHERE a IS NOT NULL AND b IS NOT NULL PRIMARY KEY (b,a)");
+
+        Keyspace ks = Keyspace.open(keyspace());
+
+        for (int i = 0; i < mvStatements.size(); i++)
+        {
+            String name = "mv" + i;
+            viewNames.add(name);
+            createView(name, mvStatements.get(i), version, this, views);
+            ks.getColumnFamilyStore(name).disableAutoCompaction();
+        }
+
+        // insert
+        updateViewWithFlush("INSERT INTO %s (a,b,c,d,e,f) VALUES(1,1,1,1,1,1) using timestamp 1", flush, version, this);
+        assertBaseViews(row(1, 1, 1, 1, 1, 1), viewNames);
+
+        updateViewWithFlush("UPDATE %s using timestamp 2 SET c=0, d=0 WHERE a=1 AND b=1", flush, version, this);
+        assertBaseViews(row(1, 1, 0, 0, 1, 1), viewNames);
+
+        updateViewWithFlush("UPDATE %s using timestamp 2 SET e=0, f=0 WHERE a=1 AND b=1", flush, version, this);
+        assertBaseViews(row(1, 1, 0, 0, 0, 0), viewNames);
+
+        updateViewWithFlush("DELETE FROM %s using timestamp 2 WHERE a=1 AND b=1", flush, version, this);
+        assertBaseViews(null, viewNames);
+
+        // partial update unselected, selected
+        updateViewWithFlush("UPDATE %s using timestamp 3 SET f=1 WHERE a=1 AND b=1", flush, version, this);
+        assertBaseViews(row(1, 1, null, null, null, 1), viewNames);
+
+        updateViewWithFlush("UPDATE %s using timestamp 4 SET e = 1, f=null WHERE a=1 AND b=1", flush, version, this);
+        assertBaseViews(row(1, 1, null, null, 1, null), viewNames);
+
+        updateViewWithFlush("UPDATE %s using timestamp 4 SET e = null WHERE a=1 AND b=1", flush, version, this);
+        assertBaseViews(null, viewNames);
+
+        updateViewWithFlush("UPDATE %s using timestamp 5 SET c = 1 WHERE a=1 AND b=1", flush, version, this);
+        assertBaseViews(row(1, 1, 1, null, null, null), viewNames);
+
+        updateViewWithFlush("UPDATE %s using timestamp 5 SET c = null WHERE a=1 AND b=1", flush, version, this);
+        assertBaseViews(null, viewNames);
+
+        updateViewWithFlush("UPDATE %s using timestamp 6 SET d = 1 WHERE a=1 AND b=1", flush, version, this);
+        assertBaseViews(row(1, 1, null, 1, null, null), viewNames);
+
+        updateViewWithFlush("UPDATE %s using timestamp 7 SET d = null WHERE a=1 AND b=1", flush, version, this);
+        assertBaseViews(null, viewNames);
+
+        updateViewWithFlush("UPDATE %s using timestamp 8 SET f = 1 WHERE a=1 AND b=1", flush, version, this);
+        assertBaseViews(row(1, 1, null, null, null, 1), viewNames);
+
+        updateViewWithFlush("UPDATE %s using timestamp 6 SET c = 1 WHERE a=1 AND b=1", flush, version, this);
+        assertBaseViews(row(1, 1, 1, null, null, 1), viewNames);
+
+        // view row still alive due to c=1@6
+        updateViewWithFlush("UPDATE %s using timestamp 8 SET f = null WHERE a=1 AND b=1", flush, version, this);
+        assertBaseViews(row(1, 1, 1, null, null, null), viewNames);
+
+        updateViewWithFlush("UPDATE %s using timestamp 6 SET c = null WHERE a=1 AND b=1", flush, version, this);
+        assertBaseViews(null, viewNames);
+    }
+
+    private void assertBaseViews(Object[] row, List<String> viewNames) throws Throwable
+    {
+        UntypedResultSet result = execute("SELECT * FROM %s");
+        if (row == null)
+            assertRowsIgnoringOrder(result);
+        else
+            assertRowsIgnoringOrder(result, row);
+        for (int i = 0; i < viewNames.size(); i++)
+            assertBaseView(result, execute(String.format("SELECT * FROM %s", viewNames.get(i))), viewNames.get(i));
+    }
+
+    private void assertBaseView(UntypedResultSet base, UntypedResultSet view, String mv)
+    {
+        List<ColumnSpecification> baseMeta = base.metadata();
+        List<ColumnSpecification> viewMeta = view.metadata();
+
+        Iterator<UntypedResultSet.Row> iter = base.iterator();
+        Iterator<UntypedResultSet.Row> viewIter = view.iterator();
+
+        List<UntypedResultSet.Row> baseData = com.google.common.collect.Lists.newArrayList(iter);
+        List<UntypedResultSet.Row> viewData = com.google.common.collect.Lists.newArrayList(viewIter);
+
+        if (baseData.size() != viewData.size())
+            fail(String.format("Mismatch number of rows in view %s: <%s>, in base <%s>",
+                               mv,
+                               makeRowStrings(view),
+                               makeRowStrings(base)));
+        if (baseData.size() == 0)
+            return;
+        if (viewData.size() != 1)
+            fail(String.format("Expect only one row in view %s, but got <%s>",
+                               mv,
+                               makeRowStrings(view)));
+
+        UntypedResultSet.Row row = baseData.get(0);
+        UntypedResultSet.Row viewRow = viewData.get(0);
+
+        Map<String, ByteBuffer> baseValues = new HashMap<>();
+        for (int j = 0; j < baseMeta.size(); j++)
+        {
+            ColumnSpecification column = baseMeta.get(j);
+            ByteBuffer actualValue = row.getBytes(column.name.toString());
+            baseValues.put(column.name.toString(), actualValue);
+        }
+        for (int j = 0; j < viewMeta.size(); j++)
+        {
+            ColumnSpecification column = viewMeta.get(j);
+            String name = column.name.toString();
+            ByteBuffer viewValue = viewRow.getBytes(name);
+            if (!baseValues.containsKey(name))
+            {
+                fail(String.format("Extra column: %s with value %s in view", name, column.type.compose(viewValue)));
+            }
+            else if (!Objects.equal(baseValues.get(name), viewValue))
+            {
+                fail(String.format("Non equal column: %s, expected <%s> but got <%s>",
+                                   name,
+                                   column.type.compose(baseValues.get(name)),
+                                   column.type.compose(viewValue)));
+            }
+        }
+    }
+}
diff --git a/test/unit/org/apache/cassandra/cql3/ViewComplexUpdatesTest.java b/test/unit/org/apache/cassandra/cql3/ViewComplexUpdatesTest.java
new file mode 100644
index 0000000000..bcd11d1605
--- /dev/null
+++ b/test/unit/org/apache/cassandra/cql3/ViewComplexUpdatesTest.java
@@ -0,0 +1,372 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.cassandra.cql3;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import org.apache.cassandra.db.Keyspace;
+import org.apache.cassandra.transport.ProtocolVersion;
+import org.apache.cassandra.utils.FBUtilities;
+
+import static org.apache.cassandra.cql3.ViewComplexTest.createView;
+import static org.apache.cassandra.cql3.ViewComplexTest.updateView;
+
+/* This class been split into multiple ones bc of timeout issues CASSANDRA-16670
+ * Any changes here check if they apply to the other classes:
+ * - ViewComplexUpdatesTest
+ * - ViewComplexDeletionsTest
+ * - ViewComplexTTLTest
+ * - ViewComplexTest
+ */
+@RunWith(Parameterized.class)
+public class ViewComplexUpdatesTest extends CQLTester
+{
+    @Parameterized.Parameter
+    public ProtocolVersion version;
+
+    @Parameterized.Parameters()
+    public static Collection<Object[]> versions()
+    {
+        return ViewComplexTest.versions();
+    }
+
+    private final List<String> views = new ArrayList<>();
+
+    @BeforeClass
+    public static void startup()
+    {
+        ViewComplexTest.startup();
+    }
+
+    @Before
+    public void begin()
+    {
+        ViewComplexTest.beginSetup(views);
+    }
+
+    @After
+    public void end() throws Throwable
+    {
+        ViewComplexTest.endTearDown(views, version, this);
+    }
+
+    @Test
+    public void testUpdateColumnNotInViewWithFlush() throws Throwable
+    {
+        testUpdateColumnNotInView(true);
+    }
+
+    @Test
+    public void testUpdateColumnNotInViewWithoutFlush() throws Throwable
+    {
+        // CASSANDRA-13127
+        testUpdateColumnNotInView(false);
+    }
+
+    private void testUpdateColumnNotInView(boolean flush) throws Throwable
+    {
+        // CASSANDRA-13127: if base column not selected in view are alive, then pk of view row should be alive
+        String baseTable = createTable("create table %s (p int, c int, v1 int, v2 int, primary key(p, c))");
+
+        execute("USE " + keyspace());
+        executeNet(version, "USE " + keyspace());
+        Keyspace ks = Keyspace.open(keyspace());
+
+        createView("mv",
+                   "CREATE MATERIALIZED VIEW %s AS SELECT p, c FROM %%s WHERE p IS NOT NULL AND c IS NOT NULL PRIMARY KEY (c, p);",
+                   version,
+                   this,
+                   views);
+        ks.getColumnFamilyStore("mv").disableAutoCompaction();
+
+        updateView("UPDATE %s USING TIMESTAMP 0 SET v1 = 1 WHERE p = 0 AND c = 0", version, this);
+
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+
+        assertRowsIgnoringOrder(execute("SELECT * from %s WHERE c = ? AND p = ?", 0, 0), row(0, 0, 1, null));
+        assertRowsIgnoringOrder(execute("SELECT * from mv WHERE c = ? AND p = ?", 0, 0), row(0, 0));
+
+        updateView("DELETE v1 FROM %s USING TIMESTAMP 1 WHERE p = 0 AND c = 0", version, this);
+
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+
+        assertEmpty(execute("SELECT * from %s WHERE c = ? AND p = ?", 0, 0));
+        assertEmpty(execute("SELECT * from mv WHERE c = ? AND p = ?", 0, 0));
+
+        // shadowed by tombstone
+        updateView("UPDATE %s USING TIMESTAMP 1 SET v1 = 1 WHERE p = 0 AND c = 0", version, this);
+
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+
+        assertEmpty(execute("SELECT * from %s WHERE c = ? AND p = ?", 0, 0));
+        assertEmpty(execute("SELECT * from mv WHERE c = ? AND p = ?", 0, 0));
+
+        updateView("UPDATE %s USING TIMESTAMP 2 SET v2 = 1 WHERE p = 0 AND c = 0", version, this);
+
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+
+        assertRowsIgnoringOrder(execute("SELECT * from %s WHERE c = ? AND p = ?", 0, 0), row(0, 0, null, 1));
+        assertRowsIgnoringOrder(execute("SELECT * from mv WHERE c = ? AND p = ?", 0, 0), row(0, 0));
+
+        updateView("DELETE v1 FROM %s USING TIMESTAMP 3 WHERE p = 0 AND c = 0", version, this);
+
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+
+        assertRowsIgnoringOrder(execute("SELECT * from %s WHERE c = ? AND p = ?", 0, 0), row(0, 0, null, 1));
+        assertRowsIgnoringOrder(execute("SELECT * from mv WHERE c = ? AND p = ?", 0, 0), row(0, 0));
+
+        updateView("DELETE v2 FROM %s USING TIMESTAMP 4 WHERE p = 0 AND c = 0", version, this);
+
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+
+        assertEmpty(execute("SELECT * from %s WHERE c = ? AND p = ?", 0, 0));
+        assertEmpty(execute("SELECT * from mv WHERE c = ? AND p = ?", 0, 0));
+
+        updateView("UPDATE %s USING TTL 3 SET v2 = 1 WHERE p = 0 AND c = 0", version, this);
+
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+
+        assertRowsIgnoringOrder(execute("SELECT * from %s WHERE c = ? AND p = ?", 0, 0), row(0, 0, null, 1));
+        assertRowsIgnoringOrder(execute("SELECT * from mv WHERE c = ? AND p = ?", 0, 0), row(0, 0));
+
+        Thread.sleep(TimeUnit.SECONDS.toMillis(3));
+
+        assertRowsIgnoringOrder(execute("SELECT * from %s WHERE c = ? AND p = ?", 0, 0));
+        assertRowsIgnoringOrder(execute("SELECT * from mv WHERE c = ? AND p = ?", 0, 0));
+
+        updateView("UPDATE %s SET v2 = 1 WHERE p = 0 AND c = 0", version, this);
+
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+
+        assertRowsIgnoringOrder(execute("SELECT * from %s WHERE c = ? AND p = ?", 0, 0), row(0, 0, null, 1));
+        assertRowsIgnoringOrder(execute("SELECT * from mv WHERE c = ? AND p = ?", 0, 0), row(0, 0));
+
+        assertInvalidMessage(String.format("Cannot drop column v2 on base table %s with materialized views", baseTable), "ALTER TABLE %s DROP v2");
+        // // drop unselected base column, unselected metadata should be removed, thus view row is dead
+        // updateView("ALTER TABLE %s DROP v2");
+        // assertRowsIgnoringOrder(execute("SELECT * from %s WHERE c = ? AND p = ?", 0, 0));
+        // assertRowsIgnoringOrder(execute("SELECT * from mv WHERE c = ? AND p = ?", 0, 0));
+        // assertRowsIgnoringOrder(execute("SELECT * from %s"));
+        // assertRowsIgnoringOrder(execute("SELECT * from mv"));
+    }
+
+    @Test
+    public void testPartialUpdateWithUnselectedCollectionsWithFlush() throws Throwable
+    {
+        testPartialUpdateWithUnselectedCollections(true);
+    }
+
+    @Test
+    public void testPartialUpdateWithUnselectedCollectionsWithoutFlush() throws Throwable
+    {
+        testPartialUpdateWithUnselectedCollections(false);
+    }
+
+    public void testPartialUpdateWithUnselectedCollections(boolean flush) throws Throwable
+    {
+        execute("USE " + keyspace());
+        executeNet(version, "USE " + keyspace());
+        String baseTable = createTable("CREATE TABLE %s (k int, c int, a int, b int, l list<int>, s set<int>, m map<int,int>, PRIMARY KEY (k, c))");
+        createView("mv",
+                   "CREATE MATERIALIZED VIEW %s AS SELECT a, b, c, k FROM %%s WHERE k IS NOT NULL AND c IS NOT NULL PRIMARY KEY (c, k)",
+                   version,
+                   this,
+                   views);
+        Keyspace ks = Keyspace.open(keyspace());
+        ks.getColumnFamilyStore("mv").disableAutoCompaction();
+
+        updateView("UPDATE %s SET l=l+[1,2,3] WHERE k = 1 AND c = 1", version, this);
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+        assertRows(execute("SELECT * from mv"), row(1, 1, null, null));
+
+        updateView("UPDATE %s SET l=l-[1,2] WHERE k = 1 AND c = 1", version, this);
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+        assertRows(execute("SELECT * from mv"), row(1, 1, null, null));
+
+        updateView("UPDATE %s SET b=3 WHERE k=1 AND c=1", version, this);
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+        assertRows(execute("SELECT * from mv"), row(1, 1, null, 3));
+
+        updateView("UPDATE %s SET b=null, l=l-[3], s=s-{3} WHERE k = 1 AND c = 1", version, this);
+        if (flush)
+        {
+            FBUtilities.waitOnFutures(ks.flush());
+            ks.getColumnFamilyStore("mv").forceMajorCompaction();
+        }
+        assertRowsIgnoringOrder(execute("SELECT k,c,a,b from %s"));
+        assertRowsIgnoringOrder(execute("SELECT * from mv"));
+
+        updateView("UPDATE %s SET m=m+{3:3}, l=l-[1], s=s-{2} WHERE k = 1 AND c = 1", version, this);
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+        assertRowsIgnoringOrder(execute("SELECT k,c,a,b from %s"), row(1, 1, null, null));
+        assertRowsIgnoringOrder(execute("SELECT * from mv"), row(1, 1, null, null));
+
+        assertInvalidMessage(String.format("Cannot drop column m on base table %s with materialized views", baseTable), "ALTER TABLE %s DROP m");
+        // executeNet(version, "ALTER TABLE %s DROP m");
+        // ks.getColumnFamilyStore("mv").forceMajorCompaction();
+        // assertRowsIgnoringOrder(execute("SELECT k,c,a,b from %s WHERE k = 1 AND c = 1"));
+        // assertRowsIgnoringOrder(execute("SELECT * from mv WHERE k = 1 AND c = 1"));
+        // assertRowsIgnoringOrder(execute("SELECT k,c,a,b from %s"));
+        // assertRowsIgnoringOrder(execute("SELECT * from mv"));
+    }
+
+    @Test
+    public void testUpdateWithColumnTimestampSmallerThanPkWithFlush() throws Throwable
+    {
+        testUpdateWithColumnTimestampSmallerThanPk(true);
+    }
+
+    @Test
+    public void testUpdateWithColumnTimestampSmallerThanPkWithoutFlush() throws Throwable
+    {
+        testUpdateWithColumnTimestampSmallerThanPk(false);
+    }
+
+    public void testUpdateWithColumnTimestampSmallerThanPk(boolean flush) throws Throwable
+    {
+        createTable("create table %s (p int primary key, v1 int, v2 int)");
+
+        execute("USE " + keyspace());
+        executeNet(version, "USE " + keyspace());
+        Keyspace ks = Keyspace.open(keyspace());
+
+        createView("mv",
+                   "create materialized view %s as select * from %%s where p is not null and v1 is not null primary key (v1, p);",
+                   version,
+                   this,
+                   views);
+        ks.getColumnFamilyStore("mv").disableAutoCompaction();
+
+        // reset value
+        updateView("Insert into %s (p, v1, v2) values (3, 1, 3) using timestamp 6;", version, this);
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from mv"), row(1, 3, 3, 6L));
+        // increase pk's timestamp to 20
+        updateView("Insert into %s (p) values (3) using timestamp 20;", version, this);
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from mv"), row(1, 3, 3, 6L));
+        // change v1's to 2 and remove existing view row with ts7
+        updateView("UPdate %s using timestamp 7 set v1 = 2 where p = 3;", version, this);
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from mv"), row(2, 3, 3, 6L));
+        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from mv limit 1"), row(2, 3, 3, 6L));
+        // change v1's to 1 and remove existing view row with ts8
+        updateView("UPdate %s using timestamp 8 set v1 = 1 where p = 3;", version, this);
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from mv"), row(1, 3, 3, 6L));
+    }
+
+    @Test
+    public void testUpdateWithColumnTimestampBiggerThanPkWithFlush() throws Throwable
+    {
+        // CASSANDRA-11500
+        testUpdateWithColumnTimestampBiggerThanPk(true);
+    }
+
+    @Test
+    public void testUpdateWithColumnTimestampBiggerThanPkWithoutFlush() throws Throwable
+    {
+        // CASSANDRA-11500
+        testUpdateWithColumnTimestampBiggerThanPk(false);
+    }
+
+    public void testUpdateWithColumnTimestampBiggerThanPk(boolean flush) throws Throwable
+    {
+        // CASSANDRA-11500 able to shadow old view row with column ts greater tahn pk's ts and re-insert the view row
+        String baseTable = createTable("CREATE TABLE %s (k int PRIMARY KEY, a int, b int);");
+
+        execute("USE " + keyspace());
+        executeNet(version, "USE " + keyspace());
+        Keyspace ks = Keyspace.open(keyspace());
+
+        createView("mv",
+                   "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE k IS NOT NULL AND a IS NOT NULL PRIMARY KEY (k, a);",
+                   version,
+                   this,
+                   views);
+        ks.getColumnFamilyStore("mv").disableAutoCompaction();
+        updateView("DELETE FROM %s USING TIMESTAMP 0 WHERE k = 1;", version, this);
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+        // sstable-1, Set initial values TS=1
+        updateView("INSERT INTO %s(k, a, b) VALUES (1, 1, 1) USING TIMESTAMP 1;", version, this);
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+        assertRowsIgnoringOrder(execute("SELECT k,a,b from mv"), row(1, 1, 1));
+        updateView("UPDATE %s USING TIMESTAMP 10 SET b = 2 WHERE k = 1;", version, this);
+        assertRowsIgnoringOrder(execute("SELECT k,a,b from mv"), row(1, 1, 2));
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+        assertRowsIgnoringOrder(execute("SELECT k,a,b from mv"), row(1, 1, 2));
+        updateView("UPDATE %s USING TIMESTAMP 2 SET a = 2 WHERE k = 1;", version, this);
+        assertRowsIgnoringOrder(execute("SELECT k,a,b from mv"), row(1, 2, 2));
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+        ks.getColumnFamilyStore("mv").forceMajorCompaction();
+        assertRowsIgnoringOrder(execute("SELECT k,a,b from mv"), row(1, 2, 2));
+        assertRowsIgnoringOrder(execute("SELECT k,a,b from mv limit 1"), row(1, 2, 2));
+        updateView("UPDATE %s USING TIMESTAMP 11 SET a = 1 WHERE k = 1;", version, this);
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+        assertRowsIgnoringOrder(execute("SELECT k,a,b from mv"), row(1, 1, 2));
+        assertRowsIgnoringOrder(execute("SELECT k,a,b from %s"), row(1, 1, 2));
+
+        // set non-key base column as tombstone, view row is removed with shadowable
+        updateView("UPDATE %s USING TIMESTAMP 12 SET a = null WHERE k = 1;", version, this);
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+        assertRowsIgnoringOrder(execute("SELECT k,a,b from mv"));
+        assertRowsIgnoringOrder(execute("SELECT k,a,b from %s"), row(1, null, 2));
+
+        // column b should be alive
+        updateView("UPDATE %s USING TIMESTAMP 13 SET a = 1 WHERE k = 1;", version, this);
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+        assertRowsIgnoringOrder(execute("SELECT k,a,b from mv"), row(1, 1, 2));
+        assertRowsIgnoringOrder(execute("SELECT k,a,b from %s"), row(1, 1, 2));
+
+        assertInvalidMessage(String.format("Cannot drop column a on base table %s with materialized views", baseTable), "ALTER TABLE %s DROP a");
+    }
+}
diff --git a/test/unit/org/apache/cassandra/cql3/ViewFilteringClusteringTest.java b/test/unit/org/apache/cassandra/cql3/ViewFilteringClusteringTest.java
new file mode 100644
index 0000000000..ec213ea101
--- /dev/null
+++ b/test/unit/org/apache/cassandra/cql3/ViewFilteringClusteringTest.java
@@ -0,0 +1,662 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.cassandra.cql3;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.List;
+
+import org.junit.After;
+import org.junit.AfterClass;
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import org.apache.cassandra.db.SystemKeyspace;
+import org.apache.cassandra.transport.ProtocolVersion;
+
+/* This class been split into multiple ones bc of timeout issues CASSANDRA-16670
+ * Any changes here check if they apply to the other classes
+ * - ViewFilteringPKTest
+ * - ViewFilteringClusteringTest
+ * - ViewFilteringTest
+ */
+@RunWith(Parameterized.class)
+public class ViewFilteringClusteringTest extends CQLTester
+{
+    @Parameterized.Parameter
+    public ProtocolVersion version;
+
+    @Parameterized.Parameters()
+    public static Collection<Object[]> versions()
+    {
+        return ViewFilteringTest.versions();
+    }
+
+    private final List<String> views = new ArrayList<>();
+
+    @BeforeClass
+    public static void startup()
+    {
+        ViewFilteringTest.startup();
+    }
+
+    @AfterClass
+    public static void tearDown()
+    {
+        ViewFilteringTest.tearDown();
+    }
+
+    @Before
+    public void begin()
+    {
+        ViewFilteringTest.beginSetup(views);
+    }
+
+    @After
+    public void end() throws Throwable
+    {
+        ViewFilteringTest.endSetup(views, version, this);
+    }
+
+    private void createView(String name, String query) throws Throwable
+    {
+        ViewFilteringTest.createView(name, query, views, version, this);
+    }
+
+    private void dropView(String name) throws Throwable
+    {
+        ViewFilteringTest.dropView(name, views, version, this);
+    }
+
+    @Test
+    public void testClusteringKeyEQRestrictions() throws Throwable
+    {
+        List<String> mvPrimaryKeys = Arrays.asList("((a, b), c)", "((b, a), c)", "(a, b, c)", "(c, b, a)", "((c, a), b)");
+        for (int i = 0; i < mvPrimaryKeys.size(); i++)
+        {
+            createTable("CREATE TABLE %s (a int, b int, c int, d int, PRIMARY KEY (a, b, c))");
+
+            execute("USE " + keyspace());
+            executeNet(version, "USE " + keyspace());
+
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 0, 0, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 0, 1, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 1, 0, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 1, 1, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 0, 0, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 0, 1, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 0, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 1, 0);
+
+            logger.info("Testing MV primary key: {}", mvPrimaryKeys.get(i));
+
+            // only accept rows where b = 1
+            createView("mv_test" + i, "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a IS NOT NULL AND b = 1 AND c IS NOT NULL PRIMARY KEY " + mvPrimaryKeys.get(i));
+
+            while (!SystemKeyspace.isViewBuilt(keyspace(), "mv_test" + i))
+                Thread.sleep(10);
+
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(0, 1, 0, 0),
+                                    row(0, 1, 1, 0),
+                                    row(1, 1, 0, 0),
+                                    row(1, 1, 1, 0)
+            );
+
+            // insert new rows that do not match the filter
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 2, 0, 0, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 2, 2, 0, 0);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(0, 1, 0, 0),
+                                    row(0, 1, 1, 0),
+                                    row(1, 1, 0, 0),
+                                    row(1, 1, 1, 0)
+            );
+
+            // insert new row that does match the filter
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 2, 0);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(0, 1, 0, 0),
+                                    row(0, 1, 1, 0),
+                                    row(1, 1, 0, 0),
+                                    row(1, 1, 1, 0),
+                                    row(1, 1, 2, 0)
+            );
+
+            // update rows that don't match the filter
+            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 2, 0, 0);
+            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 2, 2, 0);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(0, 1, 0, 0),
+                                    row(0, 1, 1, 0),
+                                    row(1, 1, 0, 0),
+                                    row(1, 1, 1, 0),
+                                    row(1, 1, 2, 0)
+            );
+
+            // update a row that does match the filter
+            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 1, 1, 0);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(0, 1, 0, 0),
+                                    row(0, 1, 1, 0),
+                                    row(1, 1, 0, 1),
+                                    row(1, 1, 1, 0),
+                                    row(1, 1, 2, 0)
+            );
+
+            // delete rows that don't match the filter
+            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 2, 0, 0);
+            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 2, 2, 0);
+            execute("DELETE FROM %s WHERE a = ? AND b = ?", 0, 0);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(0, 1, 0, 0),
+                                    row(0, 1, 1, 0),
+                                    row(1, 1, 0, 1),
+                                    row(1, 1, 1, 0),
+                                    row(1, 1, 2, 0)
+            );
+
+            // delete a row that does match the filter
+            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 1, 1, 0);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(0, 1, 0, 0),
+                                    row(0, 1, 1, 0),
+                                    row(1, 1, 1, 0),
+                                    row(1, 1, 2, 0)
+            );
+
+            // delete a partition that matches the filter
+            execute("DELETE FROM %s WHERE a = ?", 1);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(0, 1, 0, 0),
+                                    row(0, 1, 1, 0)
+            );
+
+            dropView("mv_test" + i);
+            dropTable("DROP TABLE %s");
+        }
+    }
+
+    @Test
+    public void testClusteringKeySliceRestrictions() throws Throwable
+    {
+        List<String> mvPrimaryKeys = Arrays.asList("((a, b), c)", "((b, a), c)", "(a, b, c)", "(c, b, a)", "((c, a), b)");
+        for (int i = 0; i < mvPrimaryKeys.size(); i++)
+        {
+            createTable("CREATE TABLE %s (a int, b int, c int, d int, PRIMARY KEY (a, b, c))");
+
+            execute("USE " + keyspace());
+            executeNet(version, "USE " + keyspace());
+
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 0, 0, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 0, 1, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 1, 0, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 1, 1, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 0, 0, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 0, 1, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 0, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 1, 0);
+
+            logger.info("Testing MV primary key: {}", mvPrimaryKeys.get(i));
+
+            createView("mv_test" + i, "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a IS NOT NULL AND b >= 1 AND c IS NOT NULL PRIMARY KEY " + mvPrimaryKeys.get(i));
+
+            while (!SystemKeyspace.isViewBuilt(keyspace(), "mv_test" + i))
+                Thread.sleep(10);
+
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(0, 1, 0, 0),
+                                    row(0, 1, 1, 0),
+                                    row(1, 1, 0, 0),
+                                    row(1, 1, 1, 0)
+            );
+
+            // insert new rows that do not match the filter
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 2, -1, 0, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 2, 0, 0, 0);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(0, 1, 0, 0),
+                                    row(0, 1, 1, 0),
+                                    row(1, 1, 0, 0),
+                                    row(1, 1, 1, 0)
+            );
+
+            // insert new row that does match the filter
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 2, 0);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(0, 1, 0, 0),
+                                    row(0, 1, 1, 0),
+                                    row(1, 1, 0, 0),
+                                    row(1, 1, 1, 0),
+                                    row(1, 1, 2, 0)
+            );
+
+            // update rows that don't match the filter
+            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 2, -1, 0);
+            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 2, 0, 0);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(0, 1, 0, 0),
+                                    row(0, 1, 1, 0),
+                                    row(1, 1, 0, 0),
+                                    row(1, 1, 1, 0),
+                                    row(1, 1, 2, 0)
+            );
+
+            // update a row that does match the filter
+            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 1, 1, 0);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(0, 1, 0, 0),
+                                    row(0, 1, 1, 0),
+                                    row(1, 1, 0, 1),
+                                    row(1, 1, 1, 0),
+                                    row(1, 1, 2, 0)
+            );
+
+            // delete rows that don't match the filter
+            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 2, -1, 0);
+            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 2, 0, 0);
+            execute("DELETE FROM %s WHERE a = ? AND b = ?", 0, 0);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(0, 1, 0, 0),
+                                    row(0, 1, 1, 0),
+                                    row(1, 1, 0, 1),
+                                    row(1, 1, 1, 0),
+                                    row(1, 1, 2, 0)
+            );
+
+            // delete a row that does match the filter
+            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 1, 1, 0);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(0, 1, 0, 0),
+                                    row(0, 1, 1, 0),
+                                    row(1, 1, 1, 0),
+                                    row(1, 1, 2, 0)
+            );
+
+            // delete a partition that matches the filter
+            execute("DELETE FROM %s WHERE a = ?", 1);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(0, 1, 0, 0),
+                                    row(0, 1, 1, 0)
+            );
+
+            dropView("mv_test" + i);
+            dropTable("DROP TABLE %s");
+        }
+    }
+
+    @Test
+    public void testClusteringKeyINRestrictions() throws Throwable
+    {
+        List<String> mvPrimaryKeys = Arrays.asList("((a, b), c)", "((b, a), c)", "(a, b, c)", "(c, b, a)", "((c, a), b)");
+        for (int i = 0; i < mvPrimaryKeys.size(); i++)
+        {
+            createTable("CREATE TABLE %s (a int, b int, c int, d int, PRIMARY KEY (a, b, c))");
+
+            execute("USE " + keyspace());
+            executeNet(version, "USE " + keyspace());
+
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 0, 0, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 0, 1, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 1, 0, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 1, 1, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 0, 0, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 0, 1, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 0, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 1, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 2, 1, 0);
+
+            logger.info("Testing MV primary key: {}", mvPrimaryKeys.get(i));
+
+            // only accept rows where b = 1
+            createView("mv_test" + i, "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a IS NOT NULL AND b IN (1, 2) AND c IS NOT NULL PRIMARY KEY " + mvPrimaryKeys.get(i));
+
+            while (!SystemKeyspace.isViewBuilt(keyspace(), "mv_test" + i))
+                Thread.sleep(10);
+
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(0, 1, 0, 0),
+                                    row(0, 1, 1, 0),
+                                    row(1, 1, 0, 0),
+                                    row(1, 1, 1, 0),
+                                    row(1, 2, 1, 0)
+            );
+
+            // insert new rows that do not match the filter
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 2, -1, 0, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 2, 0, 0, 0);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(0, 1, 0, 0),
+                                    row(0, 1, 1, 0),
+                                    row(1, 1, 0, 0),
+                                    row(1, 1, 1, 0),
+                                    row(1, 2, 1, 0)
+            );
+
+            // insert new row that does match the filter
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 2, 0);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(0, 1, 0, 0),
+                                    row(0, 1, 1, 0),
+                                    row(1, 1, 0, 0),
+                                    row(1, 1, 1, 0),
+                                    row(1, 1, 2, 0),
+                                    row(1, 2, 1, 0)
+            );
+
+            // update rows that don't match the filter
+            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 2, -1, 0);
+            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 2, 0, 0);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(0, 1, 0, 0),
+                                    row(0, 1, 1, 0),
+                                    row(1, 1, 0, 0),
+                                    row(1, 1, 1, 0),
+                                    row(1, 1, 2, 0),
+                                    row(1, 2, 1, 0)
+            );
+
+            // update a row that does match the filter
+            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 1, 1, 0);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(0, 1, 0, 0),
+                                    row(0, 1, 1, 0),
+                                    row(1, 1, 0, 1),
+                                    row(1, 1, 1, 0),
+                                    row(1, 1, 2, 0),
+                                    row(1, 2, 1, 0)
+            );
+
+            // delete rows that don't match the filter
+            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 2, -1, 0);
+            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 2, 0, 0);
+            execute("DELETE FROM %s WHERE a = ? AND b = ?", 0, 0);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(0, 1, 0, 0),
+                                    row(0, 1, 1, 0),
+                                    row(1, 1, 0, 1),
+                                    row(1, 1, 1, 0),
+                                    row(1, 1, 2, 0),
+                                    row(1, 2, 1, 0)
+            );
+
+            // delete a row that does match the filter
+            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 1, 1, 0);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(0, 1, 0, 0),
+                                    row(0, 1, 1, 0),
+                                    row(1, 1, 1, 0),
+                                    row(1, 1, 2, 0),
+                                    row(1, 2, 1, 0)
+            );
+
+            // delete a partition that matches the filter
+            execute("DELETE FROM %s WHERE a = ?", 1);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(0, 1, 0, 0),
+                                    row(0, 1, 1, 0)
+            );
+
+            dropView("mv_test" + i);
+            dropTable("DROP TABLE %s");
+        }
+    }
+
+    @Test
+    public void testClusteringKeyMultiColumnRestrictions() throws Throwable
+    {
+        List<String> mvPrimaryKeys = Arrays.asList("((a, b), c)", "((b, a), c)", "(a, b, c)", "(c, b, a)", "((c, a), b)");
+        for (int i = 0; i < mvPrimaryKeys.size(); i++)
+        {
+            createTable("CREATE TABLE %s (a int, b int, c int, d int, PRIMARY KEY (a, b, c))");
+
+            execute("USE " + keyspace());
+            executeNet(version, "USE " + keyspace());
+
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 0, 0, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 0, 1, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 1, 0, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 1, 1, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 0, 0, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 0, 1, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, -1, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 0, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 1, 0);
+
+            logger.info("Testing MV primary key: {}", mvPrimaryKeys.get(i));
+
+            // only accept rows where b = 1
+            createView("mv_test" + i, "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a IS NOT NULL AND (b, c) >= (1, 0) PRIMARY KEY " + mvPrimaryKeys.get(i));
+
+            while (!SystemKeyspace.isViewBuilt(keyspace(), "mv_test" + i))
+                Thread.sleep(10);
+
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(0, 1, 0, 0),
+                                    row(0, 1, 1, 0),
+                                    row(1, 1, 0, 0),
+                                    row(1, 1, 1, 0)
+            );
+
+            // insert new rows that do not match the filter
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 2, -1, 0, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 2, 0, 0, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 2, 1, -1, 0);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(0, 1, 0, 0),
+                                    row(0, 1, 1, 0),
+                                    row(1, 1, 0, 0),
+                                    row(1, 1, 1, 0)
+            );
+
+            // insert new row that does match the filter
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 2, 0);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(0, 1, 0, 0),
+                                    row(0, 1, 1, 0),
+                                    row(1, 1, 0, 0),
+                                    row(1, 1, 1, 0),
+                                    row(1, 1, 2, 0)
+            );
+
+            // update rows that don't match the filter
+            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 1, -1, 0);
+            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 2, -1, 0);
+            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 2, 0, 0);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(0, 1, 0, 0),
+                                    row(0, 1, 1, 0),
+                                    row(1, 1, 0, 0),
+                                    row(1, 1, 1, 0),
+                                    row(1, 1, 2, 0)
+            );
+
+            // update a row that does match the filter
+            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 1, 1, 0);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(0, 1, 0, 0),
+                                    row(0, 1, 1, 0),
+                                    row(1, 1, 0, 1),
+                                    row(1, 1, 1, 0),
+                                    row(1, 1, 2, 0)
+            );
+
+            // delete rows that don't match the filter
+            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 1, 1, -1);
+            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 2, -1, 0);
+            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 2, 0, 0);
+            execute("DELETE FROM %s WHERE a = ? AND b = ?", 0, 0);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(0, 1, 0, 0),
+                                    row(0, 1, 1, 0),
+                                    row(1, 1, 0, 1),
+                                    row(1, 1, 1, 0),
+                                    row(1, 1, 2, 0)
+            );
+
+            // delete a row that does match the filter
+            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 1, 1, 0);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(0, 1, 0, 0),
+                                    row(0, 1, 1, 0),
+                                    row(1, 1, 1, 0),
+                                    row(1, 1, 2, 0)
+            );
+
+            // delete a partition that matches the filter
+            execute("DELETE FROM %s WHERE a = ?", 1);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(0, 1, 0, 0),
+                                    row(0, 1, 1, 0)
+            );
+
+            dropView("mv_test" + i);
+            dropTable("DROP TABLE %s");
+        }
+    }
+
+    @Test
+    public void testClusteringKeyFilteringRestrictions() throws Throwable
+    {
+        List<String> mvPrimaryKeys = Arrays.asList("((a, b), c)", "((b, a), c)", "(a, b, c)", "(c, b, a)", "((c, a), b)");
+        for (int i = 0; i < mvPrimaryKeys.size(); i++)
+        {
+            createTable("CREATE TABLE %s (a int, b int, c int, d int, PRIMARY KEY (a, b, c))");
+
+            execute("USE " + keyspace());
+            executeNet(version, "USE " + keyspace());
+
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 0, 0, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 0, 1, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 1, 0, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 1, 1, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 0, 0, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 0, 1, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, -1, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 0, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 1, 0);
+
+            logger.info("Testing MV primary key: {}", mvPrimaryKeys.get(i));
+
+            // only accept rows where b = 1
+            createView("mv_test" + i, "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a IS NOT NULL AND b IS NOT NULL AND c = 1 PRIMARY KEY " + mvPrimaryKeys.get(i));
+
+            while (!SystemKeyspace.isViewBuilt(keyspace(), "mv_test" + i))
+                Thread.sleep(10);
+
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(0, 0, 1, 0),
+                                    row(0, 1, 1, 0),
+                                    row(1, 0, 1, 0),
+                                    row(1, 1, 1, 0)
+            );
+
+            // insert new rows that do not match the filter
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 2, 0, 0, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 2, 1, -1, 0);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(0, 0, 1, 0),
+                                    row(0, 1, 1, 0),
+                                    row(1, 0, 1, 0),
+                                    row(1, 1, 1, 0)
+            );
+
+            // insert new row that does match the filter
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 2, 1, 0);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(0, 0, 1, 0),
+                                    row(0, 1, 1, 0),
+                                    row(1, 0, 1, 0),
+                                    row(1, 1, 1, 0),
+                                    row(1, 2, 1, 0)
+            );
+
+            // update rows that don't match the filter
+            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 1, -1, 0);
+            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 2, 0, 0);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(0, 0, 1, 0),
+                                    row(0, 1, 1, 0),
+                                    row(1, 0, 1, 0),
+                                    row(1, 1, 1, 0),
+                                    row(1, 2, 1, 0)
+            );
+
+            // update a row that does match the filter
+            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 2, 1, 1, 1);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(0, 0, 1, 0),
+                                    row(0, 1, 1, 0),
+                                    row(1, 0, 1, 0),
+                                    row(1, 1, 1, 2),
+                                    row(1, 2, 1, 0)
+            );
+
+            // delete rows that don't match the filter
+            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 1, 1, -1);
+            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 2, -1, 0);
+            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 2, 0, 0);
+            execute("DELETE FROM %s WHERE a = ? AND b = ?", 0, -1);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(0, 0, 1, 0),
+                                    row(0, 1, 1, 0),
+                                    row(1, 0, 1, 0),
+                                    row(1, 1, 1, 2),
+                                    row(1, 2, 1, 0)
+            );
+
+            // delete a row that does match the filter
+            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 1, 1, 1);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(0, 0, 1, 0),
+                                    row(0, 1, 1, 0),
+                                    row(1, 0, 1, 0),
+                                    row(1, 2, 1, 0)
+            );
+
+            // delete a partition that matches the filter
+            execute("DELETE FROM %s WHERE a = ?", 1);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(0, 0, 1, 0),
+                                    row(0, 1, 1, 0)
+            );
+
+            // insert a partition with one matching and one non-matching row using a batch (CASSANDRA-10614)
+            String tableName = KEYSPACE + "." + currentTable();
+            execute("BEGIN BATCH " +
+                    "INSERT INTO " + tableName + " (a, b, c, d) VALUES (?, ?, ?, ?); " +
+                    "INSERT INTO " + tableName + " (a, b, c, d) VALUES (?, ?, ?, ?); " +
+                    "APPLY BATCH",
+                    4, 4, 0, 0,
+                    4, 4, 1, 1);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(0, 0, 1, 0),
+                                    row(0, 1, 1, 0),
+                                    row(4, 4, 1, 1)
+            );
+
+            dropView("mv_test" + i);
+            dropTable("DROP TABLE %s");
+        }
+    }
+}
diff --git a/test/unit/org/apache/cassandra/cql3/ViewFilteringPKTest.java b/test/unit/org/apache/cassandra/cql3/ViewFilteringPKTest.java
new file mode 100644
index 0000000000..3c88dc3549
--- /dev/null
+++ b/test/unit/org/apache/cassandra/cql3/ViewFilteringPKTest.java
@@ -0,0 +1,656 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.cassandra.cql3;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.List;
+
+import org.junit.After;
+import org.junit.AfterClass;
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import org.apache.cassandra.db.SystemKeyspace;
+import org.apache.cassandra.transport.ProtocolVersion;
+
+/* This class been split into multiple ones bc of timeout issues CASSANDRA-16670
+ * Any changes here check if they apply to the other classes
+ * - ViewFilteringPKTest
+ * - ViewFilteringClusteringTest
+ * - ViewFilteringTest
+ */
+@RunWith(Parameterized.class)
+public class ViewFilteringPKTest extends CQLTester
+{
+    @Parameterized.Parameter
+    public ProtocolVersion version;
+
+    @Parameterized.Parameters()
+    public static Collection<Object[]> versions()
+    {
+        return ViewFilteringTest.versions();
+    }
+
+    private final List<String> views = new ArrayList<>();
+
+    @BeforeClass
+    public static void startup()
+    {
+        ViewFilteringTest.startup();
+    }
+
+    @AfterClass
+    public static void tearDown()
+    {
+        ViewFilteringTest.tearDown();
+    }
+
+    @Before
+    public void begin()
+    {
+        ViewFilteringTest.beginSetup(views);
+    }
+
+    @After
+    public void end() throws Throwable
+    {
+        ViewFilteringTest.endSetup(views, version, this);
+    }
+
+    private void createView(String name, String query) throws Throwable
+    {
+        ViewFilteringTest.createView(name, query, views, version, this);
+    }
+
+    private void dropView(String name) throws Throwable
+    {
+        ViewFilteringTest.dropView(name, views, version, this);
+    }
+
+    @Test
+    public void testPartitionKeyFilteringUnrestrictedPart() throws Throwable
+    {
+        List<String> mvPrimaryKeys = Arrays.asList("((a, b), c)", "((b, a), c)", "(a, b, c)", "(c, b, a)", "((c, a), b)");
+        for (int i = 0; i < mvPrimaryKeys.size(); i++)
+        {
+            createTable("CREATE TABLE %s (a int, b int, c int, d int, PRIMARY KEY ((a, b), c))");
+
+            execute("USE " + keyspace());
+            executeNet(version, "USE " + keyspace());
+
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 0, 0, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 1, 0, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 0, 0, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 0, 1, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 0, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 1, 0);
+
+            logger.info("Testing MV primary key: {}", mvPrimaryKeys.get(i));
+
+            // only accept rows where a = 1
+            String viewName= "mv_test" + i;
+            createView(viewName, "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a = 1 AND b IS NOT NULL AND c IS NOT NULL PRIMARY KEY " + mvPrimaryKeys.get(i));
+
+            ViewFilteringTest.waitForView(keyspace(), viewName);
+
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(1, 0, 0, 0),
+                                    row(1, 0, 1, 0),
+                                    row(1, 1, 0, 0),
+                                    row(1, 1, 1, 0)
+            );
+
+            // insert new rows that do not match the filter
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 2, 0, 0, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 2, 1, 0, 0);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(1, 0, 0, 0),
+                                    row(1, 0, 1, 0),
+                                    row(1, 1, 0, 0),
+                                    row(1, 1, 1, 0)
+            );
+
+            // insert new row that does match the filter
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 2, 0);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(1, 0, 0, 0),
+                                    row(1, 0, 1, 0),
+                                    row(1, 1, 0, 0),
+                                    row(1, 1, 1, 0),
+                                    row(1, 1, 2, 0)
+            );
+
+            // update rows that don't match the filter
+            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 0, 0, 0);
+            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 0, 1, 0);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(1, 0, 0, 0),
+                                    row(1, 0, 1, 0),
+                                    row(1, 1, 0, 0),
+                                    row(1, 1, 1, 0),
+                                    row(1, 1, 2, 0)
+            );
+
+            // update a row that does match the filter
+            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 1, 1, 0);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(1, 0, 0, 0),
+                                    row(1, 0, 1, 0),
+                                    row(1, 1, 0, 1),
+                                    row(1, 1, 1, 0),
+                                    row(1, 1, 2, 0)
+            );
+
+            // delete rows that don't match the filter
+            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 0, 0, 0);
+            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 0, 1, 0);
+            execute("DELETE FROM %s WHERE a = ? AND b = ?", 0, 0);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(1, 0, 0, 0),
+                                    row(1, 0, 1, 0),
+                                    row(1, 1, 0, 1),
+                                    row(1, 1, 1, 0),
+                                    row(1, 1, 2, 0)
+            );
+
+            // delete a row that does match the filter
+            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 1, 1, 0);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(1, 0, 0, 0),
+                                    row(1, 0, 1, 0),
+                                    row(1, 1, 1, 0),
+                                    row(1, 1, 2, 0)
+            );
+
+            // delete a partition that matches the filter
+            execute("DELETE FROM %s WHERE a = ? AND b = ?", 1, 0);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(1, 1, 1, 0),
+                                    row(1, 1, 2, 0));
+            execute("DELETE FROM %s WHERE a = ? AND b = ?", 1, 1);
+            assertEmpty(execute("SELECT * FROM mv_test" + i));
+        }
+    }
+
+    @Test
+    public void testPartitionKeyFilteringWithSlice() throws Throwable
+    {
+        List<String> mvPrimaryKeys = Arrays.asList("((a, b), c)", "((b, a), c)", "(a, b, c)", "(c, b, a)", "((c, a), b)");
+        for (int i = 0; i < mvPrimaryKeys.size(); i++)
+        {
+            createTable("CREATE TABLE %s (a int, b int, c int, d int, PRIMARY KEY ((a, b), c))");
+
+            execute("USE " + keyspace());
+            executeNet(version, "USE " + keyspace());
+
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 0,  1, 1);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 10, 1, 2);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 0,  2, 1);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 10, 2, 2);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 2, 1,  3, 1);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 2, 10, 3, 2);
+
+            logger.info("Testing MV primary key: {}", mvPrimaryKeys.get(i));
+
+            // only accept rows where a = 1
+            String viewName= "mv_test" + i;
+            createView(viewName, "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a > 0 AND b > 5 AND c IS NOT NULL PRIMARY KEY " + mvPrimaryKeys.get(i));
+
+            ViewFilteringTest.waitForView(keyspace(), viewName);
+
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(1, 10, 2, 2),
+                                    row(2, 10, 3, 2)
+            );
+
+            // insert new rows that do not match the filter
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 2, 0, 0, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 2, 1, 0, 0);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(1, 10, 2, 2),
+                                    row(2, 10, 3, 2)
+            );
+
+            // insert new row that does match the filter
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 3, 10, 4, 2);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(1, 10, 2, 2),
+                                    row(2, 10, 3, 2),
+                                    row(3, 10, 4, 2)
+            );
+
+            // update rows that don't match the filter
+            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 0, 0, 0);
+            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 0, 1, 0);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(1, 10, 2, 2),
+                                    row(2, 10, 3, 2),
+                                    row(3, 10, 4, 2)
+            );
+
+            // update a row that does match the filter
+            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 100, 3, 10, 4);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(1, 10, 2, 2),
+                                    row(2, 10, 3, 2),
+                                    row(3, 10, 4, 100)
+            );
+
+            // delete rows that don't match the filter
+            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 0, 0, 0);
+            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 0, 1, 0);
+            execute("DELETE FROM %s WHERE a = ? AND b = ?", 0, 0);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(1, 10, 2, 2),
+                                    row(2, 10, 3, 2),
+                                    row(3, 10, 4, 100)
+            );
+
+            // delete a row that does match the filter
+            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 1, 1, 0);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(1, 10, 2, 2),
+                                    row(2, 10, 3, 2),
+                                    row(3, 10, 4, 100)
+            );
+
+            // delete a partition that matches the filter
+            execute("DELETE FROM %s WHERE a = ? AND b = ?", 1, 10);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(2, 10, 3, 2),
+                                    row(3, 10, 4, 100));
+        }
+    }
+
+    @Test
+    public void testPartitionKeyRestrictions() throws Throwable
+    {
+        List<String> mvPrimaryKeys = Arrays.asList("((a, b), c)", "((b, a), c)", "(a, b, c)", "(c, b, a)", "((c, a), b)");
+        for (int i = 0; i < mvPrimaryKeys.size(); i++)
+        {
+            createTable("CREATE TABLE %s (a int, b int, c int, d int, PRIMARY KEY (a, b, c))");
+
+            execute("USE " + keyspace());
+            executeNet(version, "USE " + keyspace());
+
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 0, 0, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 1, 0, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 0, 0, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 0, 1, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 0, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 1, 0);
+
+            logger.info("Testing MV primary key: {}", mvPrimaryKeys.get(i));
+
+            // only accept rows where a = 1
+            createView("mv_test" + i, "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a = 1 AND b IS NOT NULL AND c IS NOT NULL PRIMARY KEY " + mvPrimaryKeys.get(i));
+
+            while (!SystemKeyspace.isViewBuilt(keyspace(), "mv_test" + i))
+                Thread.sleep(10);
+
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(1, 0, 0, 0),
+                                    row(1, 0, 1, 0),
+                                    row(1, 1, 0, 0),
+                                    row(1, 1, 1, 0)
+            );
+
+            // insert new rows that do not match the filter
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 2, 0, 0, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 2, 1, 0, 0);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(1, 0, 0, 0),
+                                    row(1, 0, 1, 0),
+                                    row(1, 1, 0, 0),
+                                    row(1, 1, 1, 0)
+            );
+
+            // insert new row that does match the filter
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 2, 0);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(1, 0, 0, 0),
+                                    row(1, 0, 1, 0),
+                                    row(1, 1, 0, 0),
+                                    row(1, 1, 1, 0),
+                                    row(1, 1, 2, 0)
+            );
+
+            // update rows that don't match the filter
+            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 0, 0, 0);
+            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 0, 1, 0);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(1, 0, 0, 0),
+                                    row(1, 0, 1, 0),
+                                    row(1, 1, 0, 0),
+                                    row(1, 1, 1, 0),
+                                    row(1, 1, 2, 0)
+            );
+
+            // update a row that does match the filter
+            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 1, 1, 0);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(1, 0, 0, 0),
+                                    row(1, 0, 1, 0),
+                                    row(1, 1, 0, 1),
+                                    row(1, 1, 1, 0),
+                                    row(1, 1, 2, 0)
+            );
+
+            // delete rows that don't match the filter
+            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 0, 0, 0);
+            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 0, 1, 0);
+            execute("DELETE FROM %s WHERE a = ? AND b = ?", 0, 0);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(1, 0, 0, 0),
+                                    row(1, 0, 1, 0),
+                                    row(1, 1, 0, 1),
+                                    row(1, 1, 1, 0),
+                                    row(1, 1, 2, 0)
+            );
+
+            // delete a row that does match the filter
+            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 1, 1, 0);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(1, 0, 0, 0),
+                                    row(1, 0, 1, 0),
+                                    row(1, 1, 1, 0),
+                                    row(1, 1, 2, 0)
+            );
+
+            // delete a partition that matches the filter
+            execute("DELETE FROM %s WHERE a = ?", 1);
+            assertEmpty(execute("SELECT * FROM mv_test" + i));
+        }
+    }
+
+    @Test
+    public void testCompoundPartitionKeyRestrictions() throws Throwable
+    {
+        List<String> mvPrimaryKeys = Arrays.asList("((a, b), c)", "((b, a), c)", "(a, b, c)", "(c, b, a)", "((c, a), b)");
+        for (int i = 0; i < mvPrimaryKeys.size(); i++)
+        {
+            createTable("CREATE TABLE %s (a int, b int, c int, d int, PRIMARY KEY ((a, b), c))");
+
+            execute("USE " + keyspace());
+            executeNet(version, "USE " + keyspace());
+
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 0, 0, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 0, 1, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 1, 0, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 1, 1, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 0, 0, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 0, 1, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 0, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 1, 0);
+
+            logger.info("Testing MV primary key: {}", mvPrimaryKeys.get(i));
+
+            // only accept rows where a = 1 and b = 1
+            createView("mv_test" + i, "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a = 1 AND b = 1 AND c IS NOT NULL PRIMARY KEY " + mvPrimaryKeys.get(i));
+
+            while (!SystemKeyspace.isViewBuilt(keyspace(), "mv_test" + i))
+                Thread.sleep(10);
+
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(1, 1, 0, 0),
+                                    row(1, 1, 1, 0)
+            );
+
+            // insert new rows that do not match the filter
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 2, 0, 0, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 2, 1, 0, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 2, 0, 0);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(1, 1, 0, 0),
+                                    row(1, 1, 1, 0)
+            );
+
+            // insert new row that does match the filter
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 2, 0);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(1, 1, 0, 0),
+                                    row(1, 1, 1, 0),
+                                    row(1, 1, 2, 0)
+            );
+
+            // update rows that don't match the filter
+            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 0, 0, 0);
+            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 1, 0, 0);
+            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 0, 1, 0);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(1, 1, 0, 0),
+                                    row(1, 1, 1, 0),
+                                    row(1, 1, 2, 0)
+            );
+
+            // update a row that does match the filter
+            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 1, 1, 0);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(1, 1, 0, 1),
+                                    row(1, 1, 1, 0),
+                                    row(1, 1, 2, 0)
+            );
+
+            // delete rows that don't match the filter
+            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 0, 0, 0);
+            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 1, 0, 0);
+            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 0, 1, 0);
+            execute("DELETE FROM %s WHERE a = ? AND b = ?", 0, 0);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(1, 1, 0, 1),
+                                    row(1, 1, 1, 0),
+                                    row(1, 1, 2, 0)
+            );
+
+            // delete a row that does match the filter
+            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 1, 1, 0);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(1, 1, 1, 0),
+                                    row(1, 1, 2, 0)
+            );
+
+            // delete a partition that matches the filter
+            execute("DELETE FROM %s WHERE a = ? AND b = ?", 1, 1);
+            assertEmpty(execute("SELECT * FROM mv_test" + i));
+        }
+    }
+
+    @Test
+    public void testCompoundPartitionKeyRestrictionsNotIncludeAll() throws Throwable
+    {
+        createTable("CREATE TABLE %s (a int, b int, c int, d int, PRIMARY KEY ((a, b), c))");
+        execute("USE " + keyspace());
+        executeNet(version, "USE " + keyspace());
+
+        execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 0, 0, 0);
+        execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 0, 1, 0);
+        execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 1, 0, 0);
+        execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 1, 1, 0);
+        execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 0, 0, 0);
+        execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 0, 1, 0);
+        execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 0, 0);
+        execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 1, 0);
+
+        // only accept rows where a = 1 and b = 1, don't include column d in the selection
+        createView("mv_test", "CREATE MATERIALIZED VIEW %s AS SELECT a, b, c FROM %%s WHERE a = 1 AND b = 1 AND c IS NOT NULL PRIMARY KEY ((a, b), c)");
+
+        while (!SystemKeyspace.isViewBuilt(keyspace(), "mv_test"))
+            Thread.sleep(10);
+
+        assertRows(execute("SELECT * FROM mv_test"),
+                   row(1, 1, 0),
+                   row(1, 1, 1)
+        );
+
+        // insert new rows that do not match the filter
+        execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 2, 0, 0, 0);
+        execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 2, 1, 0, 0);
+        execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 2, 0, 0);
+        assertRows(execute("SELECT * FROM mv_test"),
+                   row(1, 1, 0),
+                   row(1, 1, 1)
+        );
+
+        // insert new row that does match the filter
+        execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 2, 0);
+        assertRows(execute("SELECT * FROM mv_test"),
+                   row(1, 1, 0),
+                   row(1, 1, 1),
+                   row(1, 1, 2)
+        );
+
+        // update rows that don't match the filter
+        execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 0, 0, 0);
+        execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 1, 0, 0);
+        execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 0, 1, 0);
+        assertRows(execute("SELECT * FROM mv_test"),
+                   row(1, 1, 0),
+                   row(1, 1, 1),
+                   row(1, 1, 2)
+        );
+
+        // update a row that does match the filter
+        execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 1, 1, 0);
+        assertRows(execute("SELECT * FROM mv_test"),
+                   row(1, 1, 0),
+                   row(1, 1, 1),
+                   row(1, 1, 2)
+        );
+
+        // delete rows that don't match the filter
+        execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 0, 0, 0);
+        execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 1, 0, 0);
+        execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 0, 1, 0);
+        execute("DELETE FROM %s WHERE a = ? AND b = ?", 0, 0);
+        assertRows(execute("SELECT * FROM mv_test"),
+                   row(1, 1, 0),
+                   row(1, 1, 1),
+                   row(1, 1, 2)
+        );
+
+        // delete a row that does match the filter
+        execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 1, 1, 0);
+        assertRows(execute("SELECT * FROM mv_test"),
+                   row(1, 1, 1),
+                   row(1, 1, 2)
+        );
+
+        // delete a partition that matches the filter
+        execute("DELETE FROM %s WHERE a = ? AND b = ?", 1, 1);
+        assertEmpty(execute("SELECT * FROM mv_test"));
+    }
+
+    @Test
+    public void testPartitionKeyAndClusteringKeyFilteringRestrictions() throws Throwable
+    {
+        List<String> mvPrimaryKeys = Arrays.asList("((a, b), c)", "((b, a), c)", "(a, b, c)", "(c, b, a)", "((c, a), b)");
+        for (int i = 0; i < mvPrimaryKeys.size(); i++)
+        {
+            createTable("CREATE TABLE %s (a int, b int, c int, d int, PRIMARY KEY (a, b, c))");
+
+            execute("USE " + keyspace());
+            executeNet(version, "USE " + keyspace());
+
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 0, 0, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 0, 1, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 1, 0, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 1, 1, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 0, 0, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 0, 1, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, -1, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 0, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 1, 0);
+
+            logger.info("Testing MV primary key: {}", mvPrimaryKeys.get(i));
+
+            // only accept rows where b = 1
+            createView("mv_test" + i, "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a = 1 AND b IS NOT NULL AND c = 1 PRIMARY KEY " + mvPrimaryKeys.get(i));
+
+            while (!SystemKeyspace.isViewBuilt(keyspace(), "mv_test" + i))
+                Thread.sleep(10);
+
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(1, 0, 1, 0),
+                                    row(1, 1, 1, 0)
+            );
+
+            // insert new rows that do not match the filter
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 0, 1, 0);
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 0, 0);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(1, 0, 1, 0),
+                                    row(1, 1, 1, 0)
+            );
+
+            // insert new row that does match the filter
+            execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 2, 1, 0);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(1, 0, 1, 0),
+                                    row(1, 1, 1, 0),
+                                    row(1, 2, 1, 0)
+            );
+
+            // update rows that don't match the filter
+            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 1, 1, -1, 0);
+            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 0, 1, 1, 0);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(1, 0, 1, 0),
+                                    row(1, 1, 1, 0),
+                                    row(1, 2, 1, 0)
+            );
+
+            // update a row that does match the filter
+            execute("UPDATE %s SET d = ? WHERE a = ? AND b = ? AND c = ?", 2, 1, 1, 1);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(1, 0, 1, 0),
+                                    row(1, 1, 1, 2),
+                                    row(1, 2, 1, 0)
+            );
+
+            // delete rows that don't match the filter
+            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 1, 1, -1);
+            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 2, 0, 1);
+            execute("DELETE FROM %s WHERE a = ?", 0);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(1, 0, 1, 0),
+                                    row(1, 1, 1, 2),
+                                    row(1, 2, 1, 0)
+            );
+
+            // delete a row that does match the filter
+            execute("DELETE FROM %s WHERE a = ? AND b = ? AND c = ?", 1, 1, 1);
+            assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test" + i),
+                                    row(1, 0, 1, 0),
+                                    row(1, 2, 1, 0)
+            );
+
+            // delete a partition that matches the filter
+            execute("DELETE FROM %s WHERE a = ?", 1);
+            assertEmpty(execute("SELECT a, b, c, d FROM mv_test" + i));
+
+            dropView("mv_test" + i);
+            dropTable("DROP TABLE %s");
+        }
+    }
+}
diff --git a/test/unit/org/apache/cassandra/cql3/ViewFilteringTest.java b/test/unit/org/apache/cassandra/cql3/ViewFilteringTest.java
new file mode 100644
index 0000000000..9588db0edd
--- /dev/null
+++ b/test/unit/org/apache/cassandra/cql3/ViewFilteringTest.java
@@ -0,0 +1,1044 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.cassandra.cql3;
+
+import java.util.*;
+import java.util.stream.Collectors;
+
+import org.junit.After;
+import org.junit.AfterClass;
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.Ignore;
+import org.junit.Test;
+
+import com.datastax.driver.core.exceptions.InvalidQueryException;
+import org.junit.Assert;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import com.datastax.driver.core.exceptions.OperationTimedOutException;
+import org.apache.cassandra.concurrent.SEPExecutor;
+import org.apache.cassandra.concurrent.Stage;
+import org.apache.cassandra.db.Keyspace;
+import org.apache.cassandra.db.SystemKeyspace;
+import org.apache.cassandra.transport.ProtocolVersion;
+import org.apache.cassandra.utils.FBUtilities;
+
+/* This class been split into multiple ones bc of timeout issues CASSANDRA-16670
+ * Any changes here check if they apply to the other classes
+ * - ViewFilteringPKTest
+ * - ViewFilteringClusteringTest
+ * - ViewFilteringTest
+ */
+@RunWith(Parameterized.class)
+public class ViewFilteringTest extends CQLTester
+{
+    @Parameterized.Parameter
+    public ProtocolVersion version;
+
+    @Parameterized.Parameters()
+    public static Collection<Object[]> versions()
+    {
+        return ProtocolVersion.SUPPORTED.stream()
+                                        .map(v -> new Object[]{v})
+                                        .collect(Collectors.toList());
+    }
+
+    private final List<String> views = new ArrayList<>();
+
+    @BeforeClass
+    public static void startup()
+    {
+        requireNetwork();
+        System.setProperty("cassandra.mv.allow_filtering_nonkey_columns_unsafe", "true");
+    }
+
+    @AfterClass
+    public static void tearDown()
+    {
+        System.setProperty("cassandra.mv.allow_filtering_nonkey_columns_unsafe", "false");
+    }
+
+    @Before
+    public void begin()
+    {
+        beginSetup(views);
+    }
+
+    public static void beginSetup(List<String> views)
+    {
+        views.clear();
+    }
+
+    @After
+    public void end() throws Throwable
+    {
+        endSetup(views, version, this);
+    }
+
+    public static void endSetup(List<String> views, ProtocolVersion version, CQLTester tester) throws Throwable
+    {
+        for (String viewName : views)
+            tester.executeNet(version, "DROP MATERIALIZED VIEW " + viewName);
+    }
+
+    private void createView(String name, String query) throws Throwable
+    {
+        createView(name, query, views, version, this);
+    }
+
+    public static void createView(String name, String query, List<String> views, ProtocolVersion version, CQLTester tester) throws Throwable
+    {
+        try
+        {
+            tester.executeNet(version, String.format(query, name));
+            // If exception is thrown, the view will not be added to the list; since it shouldn't have been created, this is
+            // the desired behavior
+            views.add(name);
+        }
+        catch (OperationTimedOutException ex)
+        {
+            // ... except for timeout, when we actually do not know whether the view was created or not
+            views.add(name);
+            throw ex;
+        }
+    }
+
+    private void updateView(String query, Object... params) throws Throwable
+    {
+        executeNet(version, query, params);
+        while (!(((SEPExecutor) Stage.VIEW_MUTATION.executor()).getPendingTaskCount() == 0
+                 && ((SEPExecutor) Stage.VIEW_MUTATION.executor()).getActiveTaskCount() == 0))
+        {
+            Thread.sleep(1);
+        }
+    }
+
+    private void dropView(String name) throws Throwable
+    {
+        dropView(name, views, version, this);
+    }
+
+    public static void dropView(String name, List<String> views, ProtocolVersion version, CQLTester tester) throws Throwable
+    {
+        tester.executeNet(version, "DROP MATERIALIZED VIEW " + name);
+        views.remove(name);
+    }
+
+    public static void waitForView(String keyspace, String view) throws InterruptedException
+    {
+        while (!SystemKeyspace.isViewBuilt(keyspace, view))
+            Thread.sleep(10);
+    }
+
+    // TODO will revise the non-pk filter condition in MV, see CASSANDRA-11500
+    @Ignore
+    @Test
+    public void testViewFilteringWithFlush() throws Throwable
+    {
+        testViewFiltering(true);
+    }
+
+    // TODO will revise the non-pk filter condition in MV, see CASSANDRA-11500
+    @Ignore
+    @Test
+    public void testViewFilteringWithoutFlush() throws Throwable
+    {
+        testViewFiltering(false);
+    }
+
+    public void testViewFiltering(boolean flush) throws Throwable
+    {
+        // CASSANDRA-13547: able to shadow entire view row if base column used in filter condition is modified
+        createTable("CREATE TABLE %s (a int, b int, c int, d int, PRIMARY KEY (a))");
+
+        execute("USE " + keyspace());
+        executeNet(version, "USE " + keyspace());
+
+        createView("mv_test1",
+                   "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a IS NOT NULL AND b IS NOT NULL and c = 1  PRIMARY KEY (a, b)");
+        createView("mv_test2",
+                   "CREATE MATERIALIZED VIEW %s AS SELECT c, d FROM %%s WHERE a IS NOT NULL AND b IS NOT NULL and c = 1 and d = 1 PRIMARY KEY (a, b)");
+        createView("mv_test3",
+                   "CREATE MATERIALIZED VIEW %s AS SELECT a, b, c, d FROM %%s WHERE a IS NOT NULL AND b IS NOT NULL PRIMARY KEY (a, b)");
+        createView("mv_test4",
+                   "CREATE MATERIALIZED VIEW %s AS SELECT c FROM %%s WHERE a IS NOT NULL AND b IS NOT NULL and c = 1 PRIMARY KEY (a, b)");
+        createView("mv_test5",
+                   "CREATE MATERIALIZED VIEW %s AS SELECT c FROM %%s WHERE a IS NOT NULL and d = 1 PRIMARY KEY (a, d)");
+        createView("mv_test6",
+                   "CREATE MATERIALIZED VIEW %s AS SELECT c FROM %%s WHERE a = 1 and d IS NOT NULL PRIMARY KEY (a, d)");
+
+        waitForView(keyspace(), "mv_test1");
+        waitForView(keyspace(), "mv_test2");
+        waitForView(keyspace(), "mv_test3");
+        waitForView(keyspace(), "mv_test4");
+        waitForView(keyspace(), "mv_test5");
+        waitForView(keyspace(), "mv_test6");
+
+        Keyspace ks = Keyspace.open(keyspace());
+        ks.getColumnFamilyStore("mv_test1").disableAutoCompaction();
+        ks.getColumnFamilyStore("mv_test2").disableAutoCompaction();
+        ks.getColumnFamilyStore("mv_test3").disableAutoCompaction();
+        ks.getColumnFamilyStore("mv_test4").disableAutoCompaction();
+        ks.getColumnFamilyStore("mv_test5").disableAutoCompaction();
+        ks.getColumnFamilyStore("mv_test6").disableAutoCompaction();
+
+        execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?) using timestamp 0", 1, 1, 1, 1);
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+
+        // views should be updated.
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test1"), row(1, 1, 1, 1));
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test2"), row(1, 1, 1, 1));
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test3"), row(1, 1, 1, 1));
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test4"), row(1, 1, 1));
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test5"), row(1, 1, 1));
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test6"), row(1, 1, 1));
+
+        updateView("UPDATE %s using timestamp 1 set c = ? WHERE a=?", 0, 1);
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+
+        assertRowCount(execute("SELECT * FROM mv_test1"), 0);
+        assertRowCount(execute("SELECT * FROM mv_test2"), 0);
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test3"), row(1, 1, 0, 1));
+        assertRowCount(execute("SELECT * FROM mv_test4"), 0);
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test5"), row(1, 1, 0));
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test6"), row(1, 1, 0));
+
+        updateView("UPDATE %s using timestamp 2 set c = ? WHERE a=?", 1, 1);
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+
+        // row should be back in views.
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test1"), row(1, 1, 1, 1));
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test2"), row(1, 1, 1, 1));
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test3"), row(1, 1, 1, 1));
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test4"), row(1, 1, 1));
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test5"), row(1, 1, 1));
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test6"), row(1, 1, 1));
+
+        updateView("UPDATE %s using timestamp 3 set d = ? WHERE a=?", 0, 1);
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test1"), row(1, 1, 1, 0));
+        assertRowCount(execute("SELECT * FROM mv_test2"), 0);
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test3"), row(1, 1, 1, 0));
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test4"), row(1, 1, 1));
+        assertRowCount(execute("SELECT * FROM mv_test5"), 0);
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test6"), row(1, 0, 1));
+
+        updateView("UPDATE %s using timestamp 4 set c = ? WHERE a=?", 0, 1);
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+
+        assertRowCount(execute("SELECT * FROM mv_test1"), 0);
+        assertRowCount(execute("SELECT * FROM mv_test2"), 0);
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test3"), row(1, 1, 0, 0));
+        assertRowCount(execute("SELECT * FROM mv_test4"), 0);
+        assertRowCount(execute("SELECT * FROM mv_test5"), 0);
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test6"), row(1, 0, 0));
+
+        updateView("UPDATE %s using timestamp 5 set d = ? WHERE a=?", 1, 1);
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+
+        // should not update as c=0
+        assertRowCount(execute("SELECT * FROM mv_test1"), 0);
+        assertRowCount(execute("SELECT * FROM mv_test2"), 0);
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test3"), row(1, 1, 0, 1));
+        assertRowCount(execute("SELECT * FROM mv_test4"), 0);
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test5"), row(1, 1, 0));
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test6"), row(1, 1, 0));
+
+        updateView("UPDATE %s using timestamp 6 set c = ? WHERE a=?", 1, 1);
+
+        // row should be back in views.
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test1"), row(1, 1, 1, 1));
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test2"), row(1, 1, 1, 1));
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test3"), row(1, 1, 1, 1));
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test4"), row(1, 1, 1));
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test5"), row(1, 1, 1));
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test6"), row(1, 1, 1));
+
+        updateView("UPDATE %s using timestamp 7 set b = ? WHERE a=?", 2, 1);
+        if (flush)
+        {
+            FBUtilities.waitOnFutures(ks.flush());
+            for (String view : views)
+                ks.getColumnFamilyStore(view).forceMajorCompaction();
+        }
+        // row should be back in views.
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test1"), row(1, 2, 1, 1));
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test2"), row(1, 2, 1, 1));
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test3"), row(1, 2, 1, 1));
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test4"), row(1, 2, 1));
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test5"), row(1, 1, 1));
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test6"), row(1, 1, 1));
+
+        updateView("DELETE b, c FROM %s using timestamp 6 WHERE a=?", 1);
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+
+        assertRowsIgnoringOrder(execute("SELECT * FROM %s"), row(1, 2, null, 1));
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test1"));
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test2"));
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test3"), row(1, 2, null, 1));
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test4"));
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test5"), row(1, 1, null));
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test6"), row(1, 1, null));
+
+        updateView("DELETE FROM %s using timestamp 8 where a=?", 1);
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+
+        assertRowCount(execute("SELECT * FROM mv_test1"), 0);
+        assertRowCount(execute("SELECT * FROM mv_test2"), 0);
+        assertRowCount(execute("SELECT * FROM mv_test3"), 0);
+        assertRowCount(execute("SELECT * FROM mv_test4"), 0);
+        assertRowCount(execute("SELECT * FROM mv_test5"), 0);
+        assertRowCount(execute("SELECT * FROM mv_test6"), 0);
+
+        updateView("UPDATE %s using timestamp 9 set b = ?,c = ? where a=?", 1, 1, 1); // upsert
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test1"), row(1, 1, 1, null));
+        assertRows(execute("SELECT * FROM mv_test2"));
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test3"), row(1, 1, 1, null));
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test4"), row(1, 1, 1));
+        assertRows(execute("SELECT * FROM mv_test5"));
+        assertRows(execute("SELECT * FROM mv_test6"));
+
+        updateView("DELETE FROM %s using timestamp 10 where a=?", 1);
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+
+        assertRowCount(execute("SELECT * FROM mv_test1"), 0);
+        assertRowCount(execute("SELECT * FROM mv_test2"), 0);
+        assertRowCount(execute("SELECT * FROM mv_test3"), 0);
+        assertRowCount(execute("SELECT * FROM mv_test4"), 0);
+        assertRowCount(execute("SELECT * FROM mv_test5"), 0);
+        assertRowCount(execute("SELECT * FROM mv_test6"), 0);
+
+        execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?) using timestamp 11", 1, 1, 1, 1);
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+
+        // row should be back in views.
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test1"), row(1, 1, 1, 1));
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test2"), row(1, 1, 1, 1));
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test3"), row(1, 1, 1, 1));
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test4"), row(1, 1, 1));
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test5"), row(1, 1, 1));
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test6"), row(1, 1, 1));
+
+        updateView("DELETE FROM %s using timestamp 12 where a=?", 1);
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+
+        assertRowCount(execute("SELECT * FROM mv_test1"), 0);
+        assertRowCount(execute("SELECT * FROM mv_test2"), 0);
+        assertRowCount(execute("SELECT * FROM mv_test3"), 0);
+        assertRowCount(execute("SELECT * FROM mv_test4"), 0);
+        assertRowCount(execute("SELECT * FROM mv_test5"), 0);
+        assertRowCount(execute("SELECT * FROM mv_test6"), 0);
+
+        dropView("mv_test1");
+        dropView("mv_test2");
+        dropView("mv_test3");
+        dropView("mv_test4");
+        dropView("mv_test5");
+        dropView("mv_test6");
+        dropTable("DROP TABLE %s");
+    }
+
+    // TODO will revise the non-pk filter condition in MV, see CASSANDRA-11500
+    @Ignore
+    @Test
+    public void testMVFilteringWithComplexColumn() throws Throwable
+    {
+        createTable("CREATE TABLE %s (a int, b int, c int, l list<int>, s set<int>, m map<int,int>, PRIMARY KEY (a, b))");
+
+        execute("USE " + keyspace());
+        executeNet(version, "USE " + keyspace());
+
+        createView("mv_test1",
+                   "CREATE MATERIALIZED VIEW %s AS SELECT a,b,c FROM %%s WHERE a IS NOT NULL AND b IS NOT NULL AND c IS NOT NULL "
+                   + "and l contains (1) AND s contains (1) AND m contains key (1) PRIMARY KEY (a, b, c)");
+        createView("mv_test2",
+                   "CREATE MATERIALIZED VIEW %s AS SELECT a,b FROM %%s WHERE a IS NOT NULL and b IS NOT NULL AND l contains (1) PRIMARY KEY (a, b)");
+        createView("mv_test3",
+                   "CREATE MATERIALIZED VIEW %s AS SELECT a,b FROM %%s WHERE a IS NOT NULL AND b IS NOT NULL AND s contains (1) PRIMARY KEY (a, b)");
+        createView("mv_test4",
+                   "CREATE MATERIALIZED VIEW %s AS SELECT a,b FROM %%s WHERE a IS NOT NULL AND b IS NOT NULL AND m contains key (1) PRIMARY KEY (a, b)");
+
+        waitForView(keyspace(), "mv_test1");
+        waitForView(keyspace(), "mv_test2");
+        waitForView(keyspace(), "mv_test3");
+        waitForView(keyspace(), "mv_test4");
+
+        // not able to drop base column filtered in view
+        assertInvalidMessage("Cannot drop column l, depended on by materialized views", "ALTER TABLE %s DROP l");
+        assertInvalidMessage("Cannot drop column s, depended on by materialized views", "ALTER TABLE %S DROP s");
+        assertInvalidMessage("Cannot drop column m, depended on by materialized views", "ALTER TABLE %s DROP m");
+
+        Keyspace ks = Keyspace.open(keyspace());
+        ks.getColumnFamilyStore("mv_test1").disableAutoCompaction();
+        ks.getColumnFamilyStore("mv_test2").disableAutoCompaction();
+        ks.getColumnFamilyStore("mv_test3").disableAutoCompaction();
+        ks.getColumnFamilyStore("mv_test4").disableAutoCompaction();
+
+        execute("INSERT INTO %s (a, b, c, l, s, m) VALUES (?, ?, ?, ?, ?, ?) ",
+                1,
+                1,
+                1,
+                list(1, 1, 2),
+                set(1, 2),
+                map(1, 1, 2, 2));
+        FBUtilities.waitOnFutures(ks.flush());
+
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test1"), row(1, 1, 1));
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test2"), row(1, 1));
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test3"), row(1, 1));
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test4"), row(1, 1));
+
+        execute("UPDATE %s SET l=l-[1] WHERE a = 1 AND b = 1" );
+        FBUtilities.waitOnFutures(ks.flush());
+
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test1"));
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test2"));
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test3"), row(1, 1));
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test4"), row(1, 1));
+
+        execute("UPDATE %s SET s=s-{2}, m=m-{2} WHERE a = 1 AND b = 1");
+        FBUtilities.waitOnFutures(ks.flush());
+
+        assertRowsIgnoringOrder(execute("SELECT a,b,c FROM %s"), row(1, 1, 1));
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test1"));
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test2"));
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test3"), row(1, 1));
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test4"), row(1, 1));
+
+        execute("UPDATE %s SET  m=m-{1} WHERE a = 1 AND b = 1");
+        FBUtilities.waitOnFutures(ks.flush());
+
+        assertRowsIgnoringOrder(execute("SELECT a,b,c FROM %s"), row(1, 1, 1));
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test1"));
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test2"));
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test3"), row(1, 1));
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test4"));
+
+        // filter conditions result not changed
+        execute("UPDATE %s SET  l=l+[2], s=s-{0}, m=m+{3:3} WHERE a = 1 AND b = 1");
+        FBUtilities.waitOnFutures(ks.flush());
+
+        assertRowsIgnoringOrder(execute("SELECT a,b,c FROM %s"), row(1, 1, 1));
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test1"));
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test2"));
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test3"), row(1, 1));
+        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test4"));
+    }
+
+    @Test
+    public void testMVCreationSelectRestrictions() throws Throwable
+    {
+        createTable("CREATE TABLE %s (a int, b int, c int, d int, e int, PRIMARY KEY((a, b), c, d))");
+
+        execute("USE " + keyspace());
+        executeNet(version, "USE " + keyspace());
+
+        // IS NOT NULL is required on all PK statements that are not otherwise restricted
+        List<String> badStatements = Arrays.asList(
+        "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE b IS NOT NULL AND c IS NOT NULL AND d is NOT NULL PRIMARY KEY ((a, b), c, d)",
+        "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a IS NOT NULL AND c IS NOT NULL AND d is NOT NULL PRIMARY KEY ((a, b), c, d)",
+        "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a IS NOT NULL AND b IS NOT NULL AND d is NOT NULL PRIMARY KEY ((a, b), c, d)",
+        "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a IS NOT NULL AND b IS NOT NULL AND c is NOT NULL PRIMARY KEY ((a, b), c, d)",
+        "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a = ? AND b IS NOT NULL AND c is NOT NULL PRIMARY KEY ((a, b), c, d)",
+        "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a = blobAsInt(?) AND b IS NOT NULL AND c is NOT NULL PRIMARY KEY ((a, b), c, d)",
+        "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s PRIMARY KEY (a, b, c, d)"
+        );
+
+        for (String badStatement : badStatements)
+        {
+            try
+            {
+                createView("mv1_test", badStatement);
+                Assert.fail("Create MV statement should have failed due to missing IS NOT NULL restriction: " + badStatement);
+            }
+            catch (InvalidQueryException exc) {}
+        }
+
+        List<String> goodStatements = Arrays.asList(
+        "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a = 1 AND b = 1 AND c IS NOT NULL AND d is NOT NULL PRIMARY KEY ((a, b), c, d)",
+        "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a IS NOT NULL AND b IS NOT NULL AND c = 1 AND d IS NOT NULL PRIMARY KEY ((a, b), c, d)",
+        "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a IS NOT NULL AND b IS NOT NULL AND c = 1 AND d = 1 PRIMARY KEY ((a, b), c, d)",
+        "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a = 1 AND b = 1 AND c = 1 AND d = 1 PRIMARY KEY ((a, b), c, d)",
+        "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a = 1 AND b = 1 AND c > 1 AND d IS NOT NULL PRIMARY KEY ((a, b), c, d)",
+        "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a = 1 AND b = 1 AND c = 1 AND d IN (1, 2, 3) PRIMARY KEY ((a, b), c, d)",
+        "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a = 1 AND b = 1 AND (c, d) = (1, 1) PRIMARY KEY ((a, b), c, d)",
+        "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a = 1 AND b = 1 AND (c, d) > (1, 1) PRIMARY KEY ((a, b), c, d)",
+        "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a = 1 AND b = 1 AND (c, d) IN ((1, 1), (2, 2)) PRIMARY KEY ((a, b), c, d)",
+        "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a = (int) 1 AND b = 1 AND c = 1 AND d = 1 PRIMARY KEY ((a, b), c, d)",
+        "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a = blobAsInt(intAsBlob(1)) AND b = 1 AND c = 1 AND d = 1 PRIMARY KEY ((a, b), c, d)"
+        );
+
+        for (int i = 0; i < goodStatements.size(); i++)
+        {
+            try
+            {
+                createView("mv" + i + "_test", goodStatements.get(i));
+            }
+            catch (Exception e)
+            {
+                throw new RuntimeException("MV creation failed: " + goodStatements.get(i), e);
+            }
+
+            try
+            {
+                executeNet(version, "ALTER MATERIALIZED VIEW mv" + i + "_test WITH compaction = { 'class' : 'LeveledCompactionStrategy' }");
+            }
+            catch (Exception e)
+            {
+                throw new RuntimeException("MV alter failed: " + goodStatements.get(i), e);
+            }
+        }
+    }
+
+    @Test
+    public void testCaseSensitivity() throws Throwable
+    {
+        createTable("CREATE TABLE %s (\"theKey\" int, \"theClustering\" int, \"the\"\"Value\" int, PRIMARY KEY (\"theKey\", \"theClustering\"))");
+
+        execute("USE " + keyspace());
+        executeNet(version, "USE " + keyspace());
+
+        execute("INSERT INTO %s (\"theKey\", \"theClustering\", \"the\"\"Value\") VALUES (?, ?, ?)", 0, 0, 0);
+        execute("INSERT INTO %s (\"theKey\", \"theClustering\", \"the\"\"Value\") VALUES (?, ?, ?)", 0, 1, 0);
+        execute("INSERT INTO %s (\"theKey\", \"theClustering\", \"the\"\"Value\") VALUES (?, ?, ?)", 1, 0, 0);
+        execute("INSERT INTO %s (\"theKey\", \"theClustering\", \"the\"\"Value\") VALUES (?, ?, ?)", 1, 1, 0);
+
+        createView("mv_test", "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s " +
+                              "WHERE \"theKey\" = 1 AND \"theClustering\" = 1 AND \"the\"\"Value\" IS NOT NULL " +
+                              "PRIMARY KEY (\"theKey\", \"theClustering\")");
+
+        while (!SystemKeyspace.isViewBuilt(keyspace(), "mv_test"))
+            Thread.sleep(10);
+        createView("mv_test2", "CREATE MATERIALIZED VIEW %s AS SELECT \"theKey\", \"theClustering\", \"the\"\"Value\" FROM %%s " +
+                               "WHERE \"theKey\" = 1 AND \"theClustering\" = 1 AND \"the\"\"Value\" IS NOT NULL " +
+                               "PRIMARY KEY (\"theKey\", \"theClustering\")");
+        while (!SystemKeyspace.isViewBuilt(keyspace(), "mv_test2"))
+            Thread.sleep(10);
+
+        for (String mvname : Arrays.asList("mv_test", "mv_test2"))
+        {
+            assertRowsIgnoringOrder(execute("SELECT \"theKey\", \"theClustering\", \"the\"\"Value\" FROM " + mvname),
+                                    row(1, 1, 0)
+            );
+        }
+
+        executeNet(version, "ALTER TABLE %s RENAME \"theClustering\" TO \"Col\"");
+
+        for (String mvname : Arrays.asList("mv_test", "mv_test2"))
+        {
+            assertRowsIgnoringOrder(execute("SELECT \"theKey\", \"Col\", \"the\"\"Value\" FROM " + mvname),
+                                    row(1, 1, 0)
+            );
+        }
+    }
+
+    @Test
+    public void testFilterWithFunction() throws Throwable
+    {
+        createTable("CREATE TABLE %s (a int, b int, c int, PRIMARY KEY (a, b))");
+
+        execute("USE " + keyspace());
+        executeNet(version, "USE " + keyspace());
+
+        execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?)", 0, 0, 0);
+        execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?)", 0, 1, 1);
+        execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?)", 1, 0, 2);
+        execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?)", 1, 1, 3);
+
+        createView("mv_test", "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s " +
+                              "WHERE a = blobAsInt(intAsBlob(1)) AND b IS NOT NULL " +
+                              "PRIMARY KEY (a, b)");
+
+        while (!SystemKeyspace.isViewBuilt(keyspace(), "mv_test"))
+            Thread.sleep(10);
+
+        assertRows(execute("SELECT a, b, c FROM mv_test"),
+                   row(1, 0, 2),
+                   row(1, 1, 3)
+        );
+
+        executeNet(version, "ALTER TABLE %s RENAME a TO foo");
+
+        assertRows(execute("SELECT foo, b, c FROM mv_test"),
+                   row(1, 0, 2),
+                   row(1, 1, 3)
+        );
+    }
+
+    @Test
+    public void testFilterWithTypecast() throws Throwable
+    {
+        createTable("CREATE TABLE %s (a int, b int, c int, PRIMARY KEY (a, b))");
+
+        execute("USE " + keyspace());
+        executeNet(version, "USE " + keyspace());
+
+        execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?)", 0, 0, 0);
+        execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?)", 0, 1, 1);
+        execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?)", 1, 0, 2);
+        execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?)", 1, 1, 3);
+
+        createView("mv_test", "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s " +
+                              "WHERE a = (int) 1 AND b IS NOT NULL " +
+                              "PRIMARY KEY (a, b)");
+
+        while (!SystemKeyspace.isViewBuilt(keyspace(), "mv_test"))
+            Thread.sleep(10);
+
+        assertRows(execute("SELECT a, b, c FROM mv_test"),
+                   row(1, 0, 2),
+                   row(1, 1, 3)
+        );
+
+        executeNet(version, "ALTER TABLE %s RENAME a TO foo");
+
+        assertRows(execute("SELECT foo, b, c FROM mv_test"),
+                   row(1, 0, 2),
+                   row(1, 1, 3)
+        );
+    } 
+
+    @Test
+    public void testAllTypes() throws Throwable
+    {
+        String myType = createType("CREATE TYPE %s (a int, b uuid, c set<text>)");
+        String columnNames = "asciival, " +
+                             "bigintval, " +
+                             "blobval, " +
+                             "booleanval, " +
+                             "dateval, " +
+                             "decimalval, " +
+                             "doubleval, " +
+                             "floatval, " +
+                             "inetval, " +
+                             "intval, " +
+                             "textval, " +
+                             "timeval, " +
+                             "timestampval, " +
+                             "timeuuidval, " +
+                             "uuidval," +
+                             "varcharval, " +
+                             "varintval, " +
+                             "frozenlistval, " +
+                             "frozensetval, " +
+                             "frozenmapval, " +
+                             "tupleval, " +
+                             "udtval";
+
+        createTable(
+        "CREATE TABLE %s (" +
+        "asciival ascii, " +
+        "bigintval bigint, " +
+        "blobval blob, " +
+        "booleanval boolean, " +
+        "dateval date, " +
+        "decimalval decimal, " +
+        "doubleval double, " +
+        "floatval float, " +
+        "inetval inet, " +
+        "intval int, " +
+        "textval text, " +
+        "timeval time, " +
+        "timestampval timestamp, " +
+        "timeuuidval timeuuid, " +
+        "uuidval uuid," +
+        "varcharval varchar, " +
+        "varintval varint, " +
+        "frozenlistval frozen<list<int>>, " +
+        "frozensetval frozen<set<uuid>>, " +
+        "frozenmapval frozen<map<ascii, int>>," +
+        "tupleval frozen<tuple<int, ascii, uuid>>," +
+        "udtval frozen<" + myType + ">, " +
+        "PRIMARY KEY (" + columnNames + "))");
+
+        execute("USE " + keyspace());
+        executeNet(version, "USE " + keyspace());
+
+        createView(
+        "mv_test",
+        "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE " +
+        "asciival = 'abc' AND " +
+        "bigintval = 123 AND " +
+        "blobval = 0xfeed AND " +
+        "booleanval = true AND " +
+        "dateval = '1987-03-23' AND " +
+        "decimalval = 123.123 AND " +
+        "doubleval = 123.123 AND " +
+        "floatval = 123.123 AND " +
+        "inetval = '127.0.0.1' AND " +
+        "intval = 123 AND " +
+        "textval = 'abc' AND " +
+        "timeval = '07:35:07.000111222' AND " +
+        "timestampval = 123123123 AND " +
+        "timeuuidval = 6BDDC89A-5644-11E4-97FC-56847AFE9799 AND " +
+        "uuidval = 6BDDC89A-5644-11E4-97FC-56847AFE9799 AND " +
+        "varcharval = 'abc' AND " +
+        "varintval = 123123123 AND " +
+        "frozenlistval = [1, 2, 3] AND " +
+        "frozensetval = {6BDDC89A-5644-11E4-97FC-56847AFE9799} AND " +
+        "frozenmapval = {'a': 1, 'b': 2} AND " +
+        "tupleval = (1, 'foobar', 6BDDC89A-5644-11E4-97FC-56847AFE9799) AND " +
+        "udtval = {a: 1, b: 6BDDC89A-5644-11E4-97FC-56847AFE9799, c: {'foo', 'bar'}} " +
+        "PRIMARY KEY (" + columnNames + ")");
+
+        execute("INSERT INTO %s (" + columnNames + ") VALUES (" +
+                "'abc'," +
+                "123," +
+                "0xfeed," +
+                "true," +
+                "'1987-03-23'," +
+                "123.123," +
+                "123.123," +
+                "123.123," +
+                "'127.0.0.1'," +
+                "123," +
+                "'abc'," +
+                "'07:35:07.000111222'," +
+                "123123123," +
+                "6BDDC89A-5644-11E4-97FC-56847AFE9799," +
+                "6BDDC89A-5644-11E4-97FC-56847AFE9799," +
+                "'abc'," +
+                "123123123," +
+                "[1, 2, 3]," +
+                "{6BDDC89A-5644-11E4-97FC-56847AFE9799}," +
+                "{'a': 1, 'b': 2}," +
+                "(1, 'foobar', 6BDDC89A-5644-11E4-97FC-56847AFE9799)," +
+                "{a: 1, b: 6BDDC89A-5644-11E4-97FC-56847AFE9799, c: {'foo', 'bar'}})");
+
+        assert !execute("SELECT * FROM mv_test").isEmpty();
+
+        executeNet(version, "ALTER TABLE %s RENAME inetval TO foo");
+        assert !execute("SELECT * FROM mv_test").isEmpty();
+    }
+
+    @Test
+    public void testMVCreationWithNonPrimaryRestrictions() throws Throwable
+    {
+        createTable("CREATE TABLE %s (a int, b int, c int, d int, PRIMARY KEY (a, b))");
+
+        execute("USE " + keyspace());
+        executeNet(version, "USE " + keyspace());
+
+        try {
+            createView("mv_test", "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a IS NOT NULL AND b IS NOT NULL AND c IS NOT NULL AND d = 1 PRIMARY KEY (a, b, c)");
+            dropView("mv_test");
+        } catch(Exception e) {
+            throw new RuntimeException("MV creation with non primary column restrictions failed.", e);
+        }
+
+        dropTable("DROP TABLE %s");
+    }
+
+    @Test
+    public void testNonPrimaryRestrictions() throws Throwable
+    {
+        createTable("CREATE TABLE %s (a int, b int, c int, d int, PRIMARY KEY (a, b))");
+
+        execute("USE " + keyspace());
+        executeNet(version, "USE " + keyspace());
+
+        execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 0, 0, 0);
+        execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 0, 1, 0);
+        execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 1, 0, 0);
+        execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 1, 1, 0);
+        execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 0, 0, 0);
+        execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 0, 1, 0);
+        execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 0, 0);
+        execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 1, 1, 0);
+
+        // only accept rows where c = 1
+        createView("mv_test", "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a IS NOT NULL AND b IS NOT NULL AND c IS NOT NULL AND c = 1 PRIMARY KEY (a, b, c)");
+
+        while (!SystemKeyspace.isViewBuilt(keyspace(), "mv_test"))
+            Thread.sleep(10);
+
+        assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test"),
+                                row(0, 0, 1, 0),
+                                row(0, 1, 1, 0),
+                                row(1, 0, 1, 0),
+                                row(1, 1, 1, 0)
+        );
+
+        // insert new rows that do not match the filter
+        execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 2, 0, 0, 0);
+        execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 2, 1, 2, 0);
+        assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test"),
+                                row(0, 0, 1, 0),
+                                row(0, 1, 1, 0),
+                                row(1, 0, 1, 0),
+                                row(1, 1, 1, 0)
+        );
+
+        // insert new row that does match the filter
+        execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 1, 2, 1, 0);
+        assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test"),
+                                row(0, 0, 1, 0),
+                                row(0, 1, 1, 0),
+                                row(1, 0, 1, 0),
+                                row(1, 1, 1, 0),
+                                row(1, 2, 1, 0)
+        );
+
+        // update rows that don't match the filter
+        execute("UPDATE %s SET d = ? WHERE a = ? AND b = ?", 2, 2, 0);
+        execute("UPDATE %s SET d = ? WHERE a = ? AND b = ?", 1, 2, 1);
+        assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test"),
+                                row(0, 0, 1, 0),
+                                row(0, 1, 1, 0),
+                                row(1, 0, 1, 0),
+                                row(1, 1, 1, 0),
+                                row(1, 2, 1, 0)
+        );
+
+        // update a row that does match the filter
+        execute("UPDATE %s SET d = ? WHERE a = ? AND b = ?", 1, 1, 0);
+        assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test"),
+                                row(0, 0, 1, 0),
+                                row(0, 1, 1, 0),
+                                row(1, 0, 1, 1),
+                                row(1, 1, 1, 0),
+                                row(1, 2, 1, 0)
+        );
+
+        // delete rows that don't match the filter
+        execute("DELETE FROM %s WHERE a = ? AND b = ?", 2, 0);
+        assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test"),
+                                row(0, 0, 1, 0),
+                                row(0, 1, 1, 0),
+                                row(1, 0, 1, 1),
+                                row(1, 1, 1, 0),
+                                row(1, 2, 1, 0)
+        );
+
+        // delete a row that does match the filter
+        execute("DELETE FROM %s WHERE a = ? AND b = ?", 1, 2);
+        assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test"),
+                                row(0, 0, 1, 0),
+                                row(0, 1, 1, 0),
+                                row(1, 0, 1, 1),
+                                row(1, 1, 1, 0)
+        );
+
+        // delete a partition that matches the filter
+        execute("DELETE FROM %s WHERE a = ?", 1);
+        assertRowsIgnoringOrder(execute("SELECT a, b, c, d FROM mv_test"),
+                                row(0, 0, 1, 0),
+                                row(0, 1, 1, 0)
+        );
+
+        dropView("mv_test");
+        dropTable("DROP TABLE %s");
+    }
+
+    @Test
+    public void complexRestrictedTimestampUpdateTestWithFlush() throws Throwable
+    {
+        complexRestrictedTimestampUpdateTest(true);
+    }
+
+    @Test
+    public void complexRestrictedTimestampUpdateTestWithoutFlush() throws Throwable
+    {
+        complexRestrictedTimestampUpdateTest(false);
+    }
+
+    public void complexRestrictedTimestampUpdateTest(boolean flush) throws Throwable
+    {
+        createTable("CREATE TABLE %s (a int, b int, c int, d int, e int, PRIMARY KEY (a, b))");
+
+        execute("USE " + keyspace());
+        executeNet(version, "USE " + keyspace());
+        Keyspace ks = Keyspace.open(keyspace());
+
+        createView("mv", "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a IS NOT NULL AND b IS NOT NULL AND c IS NOT NULL AND c = 1 PRIMARY KEY (c, a, b)");
+        ks.getColumnFamilyStore("mv").disableAutoCompaction();
+
+        //Set initial values TS=0, matching the restriction and verify view
+        executeNet(version, "INSERT INTO %s (a, b, c, d) VALUES (0, 0, 1, 0) USING TIMESTAMP 0");
+        assertRows(execute("SELECT d from mv WHERE c = ? and a = ? and b = ?", 1, 0, 0), row(0));
+
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+
+        //update c's timestamp TS=2
+        executeNet(version, "UPDATE %s USING TIMESTAMP 2 SET c = ? WHERE a = ? and b = ? ", 1, 0, 0);
+        assertRows(execute("SELECT d from mv WHERE c = ? and a = ? and b = ?", 1, 0, 0), row(0));
+
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+
+        //change c's value and TS=3, tombstones c=1 and adds c=0 record
+        executeNet(version, "UPDATE %s USING TIMESTAMP 3 SET c = ? WHERE a = ? and b = ? ", 0, 0, 0);
+        assertRows(execute("SELECT d from mv WHERE c = ? and a = ? and b = ?", 0, 0, 0));
+
+        if(flush)
+        {
+            ks.getColumnFamilyStore("mv").forceMajorCompaction();
+            FBUtilities.waitOnFutures(ks.flush());
+        }
+
+        //change c's value back to 1 with TS=4, check we can see d
+        executeNet(version, "UPDATE %s USING TIMESTAMP 4 SET c = ? WHERE a = ? and b = ? ", 1, 0, 0);
+        if (flush)
+        {
+            ks.getColumnFamilyStore("mv").forceMajorCompaction();
+            FBUtilities.waitOnFutures(ks.flush());
+        }
+
+        assertRows(execute("SELECT d, e from mv WHERE c = ? and a = ? and b = ?", 1, 0, 0), row(0, null));
+
+        //Add e value @ TS=1
+        executeNet(version, "UPDATE %s USING TIMESTAMP 1 SET e = ? WHERE a = ? and b = ? ", 1, 0, 0);
+        assertRows(execute("SELECT d, e from mv WHERE c = ? and a = ? and b = ?", 1, 0, 0), row(0, 1));
+
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+
+        //Change d value @ TS=2
+        executeNet(version, "UPDATE %s USING TIMESTAMP 2 SET d = ? WHERE a = ? and b = ? ", 2, 0, 0);
+        assertRows(execute("SELECT d from mv WHERE c = ? and a = ? and b = ?", 1, 0, 0), row(2));
+
+        if (flush)
+            FBUtilities.waitOnFutures(ks.flush());
+
+        //Change d value @ TS=3
+        executeNet(version, "UPDATE %s USING TIMESTAMP 3 SET d = ? WHERE a = ? and b = ? ", 1, 0, 0);
+        assertRows(execute("SELECT d from mv WHERE c = ? and a = ? and b = ?", 1, 0, 0), row(1));
+
+        //Tombstone c
+        executeNet(version, "DELETE FROM %s WHERE a = ? and b = ?", 0, 0);
+        assertRowsIgnoringOrder(execute("SELECT d from mv"));
+        assertRows(execute("SELECT d from mv"));
+
+        //Add back without D
+        executeNet(version, "INSERT INTO %s (a, b, c) VALUES (0, 0, 1)");
+
+        //Make sure D doesn't pop back in.
+        assertRows(execute("SELECT d from mv WHERE c = ? and a = ? and b = ?", 1, 0, 0), row((Object) null));
+
+        //New partition
+        // insert a row with timestamp 0
+        executeNet(version, "INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?) USING TIMESTAMP 0", 1, 0, 1, 0, 0);
+
+        // overwrite pk and e with timestamp 1, but don't overwrite d
+        executeNet(version, "INSERT INTO %s (a, b, c, e) VALUES (?, ?, ?, ?) USING TIMESTAMP 1", 1, 0, 1, 0);
+
+        // delete with timestamp 0 (which should only delete d)
+        executeNet(version, "DELETE FROM %s USING TIMESTAMP 0 WHERE a = ? AND b = ?", 1, 0);
+        assertRows(execute("SELECT a, b, c, d, e from mv WHERE c = ? and a = ? and b = ?", 1, 1, 0),
+                   row(1, 0, 1, null, 0)
+        );
+
+        executeNet(version, "UPDATE %s USING TIMESTAMP 2 SET c = ? WHERE a = ? AND b = ?", 1, 1, 1);
+        executeNet(version, "UPDATE %s USING TIMESTAMP 3 SET c = ? WHERE a = ? AND b = ?", 1, 1, 0);
+        assertRows(execute("SELECT a, b, c, d, e from mv WHERE c = ? and a = ? and b = ?", 1, 1, 0),
+                   row(1, 0, 1, null, 0)
+        );
+
+        executeNet(version, "UPDATE %s USING TIMESTAMP 3 SET d = ? WHERE a = ? AND b = ?", 0, 1, 0);
+        assertRows(execute("SELECT a, b, c, d, e from mv WHERE c = ? and a = ? and b = ?", 1, 1, 0),
+                   row(1, 0, 1, 0, 0)
+        );
+    }
+
+    @Test
+    public void testRestrictedRegularColumnTimestampUpdates() throws Throwable
+    {
+        // Regression test for CASSANDRA-10910
+
+        createTable("CREATE TABLE %s (" +
+                    "k int PRIMARY KEY, " +
+                    "c int, " +
+                    "val int)");
+
+        execute("USE " + keyspace());
+        executeNet(version, "USE " + keyspace());
+
+        createView("mv_rctstest", "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE k IS NOT NULL AND c IS NOT NULL AND c = 1 PRIMARY KEY (k,c)");
+
+        updateView("UPDATE %s SET c = ?, val = ? WHERE k = ?", 0, 0, 0);
+        updateView("UPDATE %s SET val = ? WHERE k = ?", 1, 0);
+        updateView("UPDATE %s SET c = ? WHERE k = ?", 1, 0);
+        assertRows(execute("SELECT c, k, val FROM mv_rctstest"), row(1, 0, 1));
+
+        updateView("TRUNCATE %s");
+
+        updateView("UPDATE %s USING TIMESTAMP 1 SET c = ?, val = ? WHERE k = ?", 0, 0, 0);
+        updateView("UPDATE %s USING TIMESTAMP 3 SET c = ? WHERE k = ?", 1, 0);
+        updateView("UPDATE %s USING TIMESTAMP 2 SET val = ? WHERE k = ?", 1, 0);
+        updateView("UPDATE %s USING TIMESTAMP 4 SET c = ? WHERE k = ?", 1, 0);
+        updateView("UPDATE %s USING TIMESTAMP 3 SET val = ? WHERE k = ?", 2, 0);
+        assertRows(execute("SELECT c, k, val FROM mv_rctstest"), row(1, 0, 2));
+    }
+
+    @Test
+    public void testOldTimestampsWithRestrictions() throws Throwable
+    {
+        createTable("CREATE TABLE %s (" +
+                    "k int, " +
+                    "c int, " +
+                    "val text, " + "" +
+                    "PRIMARY KEY(k, c))");
+
+        execute("USE " + keyspace());
+        executeNet(version, "USE " + keyspace());
+
+        createView("mv_tstest", "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE val IS NOT NULL AND k IS NOT NULL AND c IS NOT NULL AND val = 'baz' PRIMARY KEY (val,k,c)");
+
+        for (int i = 0; i < 100; i++)
+            updateView("INSERT into %s (k,c,val)VALUES(?,?,?)", 0, i % 2, "baz");
+
+        Keyspace.open(keyspace()).getColumnFamilyStore(currentTable()).forceBlockingFlush();
+
+        Assert.assertEquals(2, execute("select * from %s").size());
+        Assert.assertEquals(2, execute("select * from mv_tstest").size());
+
+        assertRows(execute("SELECT val from %s where k = 0 and c = 0"), row("baz"));
+        assertRows(execute("SELECT c from mv_tstest where k = 0 and val = ?", "baz"), row(0), row(1));
+
+        //Make sure an old TS does nothing
+        updateView("UPDATE %s USING TIMESTAMP 100 SET val = ? where k = ? AND c = ?", "bar", 0, 1);
+        assertRows(execute("SELECT val from %s where k = 0 and c = 1"), row("baz"));
+        assertRows(execute("SELECT c from mv_tstest where k = 0 and val = ?", "baz"), row(0), row(1));
+        assertRows(execute("SELECT c from mv_tstest where k = 0 and val = ?", "bar"));
+
+        //Latest TS
+        updateView("UPDATE %s SET val = ? where k = ? AND c = ?", "bar", 0, 1);
+        assertRows(execute("SELECT val from %s where k = 0 and c = 1"), row("bar"));
+        assertRows(execute("SELECT c from mv_tstest where k = 0 and val = ?", "bar"));
+        assertRows(execute("SELECT c from mv_tstest where k = 0 and val = ?", "baz"), row(0));
+    }
+}
diff --git a/test/unit/org/apache/cassandra/cql3/validation/operations/InsertUpdateIfConditionCollectionsTest.java b/test/unit/org/apache/cassandra/cql3/validation/operations/InsertUpdateIfConditionCollectionsTest.java
new file mode 100644
index 0000000000..673c17df88
--- /dev/null
+++ b/test/unit/org/apache/cassandra/cql3/validation/operations/InsertUpdateIfConditionCollectionsTest.java
@@ -0,0 +1,921 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.cassandra.cql3.validation.operations;
+
+import java.nio.ByteBuffer;
+import java.util.Collection;
+import java.util.List;
+
+import org.junit.AfterClass;
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import org.apache.cassandra.cql3.CQLTester;
+import org.apache.cassandra.exceptions.InvalidRequestException;
+import org.apache.cassandra.exceptions.SyntaxException;
+
+/* This class been split into multiple ones bc of timeout issues CASSANDRA-16670
+ * Any changes here check if they apply to the other classes
+ * - InsertUpdateIfConditionStaticsTest
+ * - InsertUpdateIfConditionCollectionsTest
+ * - InsertUpdateIfConditionTest
+ */
+@RunWith(Parameterized.class)
+public class InsertUpdateIfConditionCollectionsTest extends CQLTester
+{
+    @Parameterized.Parameter(0)
+    public String clusterMinVersion;
+
+    @Parameterized.Parameter(1)
+    public Runnable assertion;
+
+    @Parameterized.Parameters(name = "{index}: clusterMinVersion={0}")
+    public static Collection<Object[]> data()
+    {
+        return InsertUpdateIfConditionTest.data();
+    }
+
+    @BeforeClass
+    public static void beforeClass()
+    {
+        InsertUpdateIfConditionTest.beforeClass();
+    }
+
+    @Before
+    public void before()
+    {
+        InsertUpdateIfConditionTest.beforeSetup(clusterMinVersion, assertion);
+    }
+
+    @AfterClass
+    public static void afterClass()
+    {
+        InsertUpdateIfConditionTest.afterClass();
+    }
+
+    /**
+     * Migrated from cql_tests.py:TestCQL.bug_6069_test()
+     */
+    @Test
+    public void testInsertSetIfNotExists() throws Throwable
+    {
+        createTable("CREATE TABLE %s (k int PRIMARY KEY, s set<int>)");
+
+        assertRows(execute("INSERT INTO %s (k, s) VALUES (0, {1, 2, 3}) IF NOT EXISTS"),
+                   row(true));
+        assertRows(execute("SELECT * FROM %s "), row(0, set(1, 2, 3)));
+    }
+
+    @Test
+    public void testWholeUDT() throws Throwable
+    {
+        String typename = createType("CREATE TYPE %s (a int, b text)");
+        String myType = KEYSPACE + '.' + typename;
+
+        for (boolean frozen : new boolean[] {false, true})
+        {
+            createTable(String.format("CREATE TABLE %%s (k int PRIMARY KEY, v %s)",
+                                      frozen
+                                      ? "frozen<" + myType + ">"
+                                      : myType));
+
+            Object v = userType("a", 0, "b", "abc");
+            execute("INSERT INTO %s (k, v) VALUES (0, ?)", v);
+
+            checkAppliesUDT("v = {a: 0, b: 'abc'}", v);
+            checkAppliesUDT("v != null", v);
+            checkAppliesUDT("v != {a: 1, b: 'abc'}", v);
+            checkAppliesUDT("v != {a: 0, b: 'def'}", v);
+            checkAppliesUDT("v > {a: -1, b: 'abc'}", v);
+            checkAppliesUDT("v > {a: 0, b: 'aaa'}", v);
+            checkAppliesUDT("v > {a: 0}", v);
+            checkAppliesUDT("v >= {a: 0, b: 'aaa'}", v);
+            checkAppliesUDT("v >= {a: 0, b: 'abc'}", v);
+            checkAppliesUDT("v < {a: 0, b: 'zzz'}", v);
+            checkAppliesUDT("v < {a: 1, b: 'abc'}", v);
+            checkAppliesUDT("v < {a: 1}", v);
+            checkAppliesUDT("v <= {a: 0, b: 'zzz'}", v);
+            checkAppliesUDT("v <= {a: 0, b: 'abc'}", v);
+            checkAppliesUDT("v IN (null, {a: 0, b: 'abc'}, {a: 1})", v);
+
+            // multiple conditions
+            checkAppliesUDT("v > {a: -1, b: 'abc'} AND v > {a: 0}", v);
+            checkAppliesUDT("v != null AND v IN ({a: 0, b: 'abc'})", v);
+
+            // should not apply
+            checkDoesNotApplyUDT("v = {a: 0, b: 'def'}", v);
+            checkDoesNotApplyUDT("v = {a: 1, b: 'abc'}", v);
+            checkDoesNotApplyUDT("v = null", v);
+            checkDoesNotApplyUDT("v != {a: 0, b: 'abc'}", v);
+            checkDoesNotApplyUDT("v > {a: 1, b: 'abc'}", v);
+            checkDoesNotApplyUDT("v > {a: 0, b: 'zzz'}", v);
+            checkDoesNotApplyUDT("v >= {a: 1, b: 'abc'}", v);
+            checkDoesNotApplyUDT("v >= {a: 0, b: 'zzz'}", v);
+            checkDoesNotApplyUDT("v < {a: -1, b: 'abc'}", v);
+            checkDoesNotApplyUDT("v < {a: 0, b: 'aaa'}", v);
+            checkDoesNotApplyUDT("v <= {a: -1, b: 'abc'}", v);
+            checkDoesNotApplyUDT("v <= {a: 0, b: 'aaa'}", v);
+            checkDoesNotApplyUDT("v IN ({a: 0}, {b: 'abc'}, {a: 0, b: 'def'}, null)", v);
+            checkDoesNotApplyUDT("v IN ()", v);
+
+            // multiple conditions
+            checkDoesNotApplyUDT("v IN () AND v IN ({a: 0, b: 'abc'})", v);
+            checkDoesNotApplyUDT("v > {a: 0, b: 'aaa'} AND v < {a: 0, b: 'aaa'}", v);
+
+            // invalid conditions
+            checkInvalidUDT("v = {a: 1, b: 'abc', c: 'foo'}", v, InvalidRequestException.class);
+            checkInvalidUDT("v = {foo: 'foo'}", v, InvalidRequestException.class);
+            checkInvalidUDT("v < {a: 1, b: 'abc', c: 'foo'}", v, InvalidRequestException.class);
+            checkInvalidUDT("v < null", v, InvalidRequestException.class);
+            checkInvalidUDT("v <= {a: 1, b: 'abc', c: 'foo'}", v, InvalidRequestException.class);
+            checkInvalidUDT("v <= null", v, InvalidRequestException.class);
+            checkInvalidUDT("v > {a: 1, b: 'abc', c: 'foo'}", v, InvalidRequestException.class);
+            checkInvalidUDT("v > null", v, InvalidRequestException.class);
+            checkInvalidUDT("v >= {a: 1, b: 'abc', c: 'foo'}", v, InvalidRequestException.class);
+            checkInvalidUDT("v >= null", v, InvalidRequestException.class);
+            checkInvalidUDT("v IN null", v, SyntaxException.class);
+            checkInvalidUDT("v IN 367", v, SyntaxException.class);
+            checkInvalidUDT("v CONTAINS KEY 123", v, SyntaxException.class);
+            checkInvalidUDT("v CONTAINS 'bar'", v, SyntaxException.class);
+
+            /////////////////// null suffix on stored udt ////////////////////
+            v = userType("a", 0, "b", null);
+            execute("INSERT INTO %s (k, v) VALUES (0, ?)", v);
+
+            checkAppliesUDT("v = {a: 0}", v);
+            checkAppliesUDT("v = {a: 0, b: null}", v);
+            checkAppliesUDT("v != null", v);
+            checkAppliesUDT("v != {a: 1, b: null}", v);
+            checkAppliesUDT("v != {a: 1}", v);
+            checkAppliesUDT("v != {a: 0, b: 'def'}", v);
+            checkAppliesUDT("v > {a: -1, b: 'abc'}", v);
+            checkAppliesUDT("v > {a: -1}", v);
+            checkAppliesUDT("v >= {a: 0}", v);
+            checkAppliesUDT("v >= {a: -1, b: 'abc'}", v);
+            checkAppliesUDT("v < {a: 0, b: 'zzz'}", v);
+            checkAppliesUDT("v < {a: 1, b: 'abc'}", v);
+            checkAppliesUDT("v < {a: 1}", v);
+            checkAppliesUDT("v <= {a: 0, b: 'zzz'}", v);
+            checkAppliesUDT("v <= {a: 0}", v);
+            checkAppliesUDT("v IN (null, {a: 0, b: 'abc'}, {a: 0})", v);
+
+            // multiple conditions
+            checkAppliesUDT("v > {a: -1, b: 'abc'} AND v >= {a: 0}", v);
+            checkAppliesUDT("v != null AND v IN ({a: 0}, {a: 0, b: null})", v);
+
+            // should not apply
+            checkDoesNotApplyUDT("v = {a: 0, b: 'def'}", v);
+            checkDoesNotApplyUDT("v = {a: 1}", v);
+            checkDoesNotApplyUDT("v = {b: 'abc'}", v);
+            checkDoesNotApplyUDT("v = null", v);
+            checkDoesNotApplyUDT("v != {a: 0}", v);
+            checkDoesNotApplyUDT("v != {a: 0, b: null}", v);
+            checkDoesNotApplyUDT("v > {a: 1, b: 'abc'}", v);
+            checkDoesNotApplyUDT("v > {a: 0}", v);
+            checkDoesNotApplyUDT("v >= {a: 1, b: 'abc'}", v);
+            checkDoesNotApplyUDT("v >= {a: 1}", v);
+            checkDoesNotApplyUDT("v < {a: -1, b: 'abc'}", v);
+            checkDoesNotApplyUDT("v < {a: -1}", v);
+            checkDoesNotApplyUDT("v < {a: 0}", v);
+            checkDoesNotApplyUDT("v <= {a: -1, b: 'abc'}", v);
+            checkDoesNotApplyUDT("v <= {a: -1}", v);
+            checkDoesNotApplyUDT("v IN ({a: 1}, {b: 'abc'}, {a: 0, b: 'def'}, null)", v);
+            checkDoesNotApplyUDT("v IN ()", v);
+
+            // multiple conditions
+            checkDoesNotApplyUDT("v IN () AND v IN ({a: 0})", v);
+            checkDoesNotApplyUDT("v > {a: -1} AND v < {a: 0}", v);
+
+            /////////////////// null prefix on stored udt ////////////////////
+            v = userType("a", null, "b", "abc");
+            execute("INSERT INTO %s (k, v) VALUES (0, ?)", v);
+
+            checkAppliesUDT("v = {a: null, b: 'abc'}", v);
+            checkAppliesUDT("v = {b: 'abc'}", v);
+            checkAppliesUDT("v != null", v);
+            checkAppliesUDT("v != {a: 0, b: 'abc'}", v);
+            checkAppliesUDT("v != {a: 0}", v);
+            checkAppliesUDT("v != {b: 'def'}", v);
+            checkAppliesUDT("v > {a: null, b: 'aaa'}", v);
+            checkAppliesUDT("v > {b: 'aaa'}", v);
+            checkAppliesUDT("v >= {a: null, b: 'aaa'}", v);
+            checkAppliesUDT("v >= {b: 'abc'}", v);
+            checkAppliesUDT("v < {a: null, b: 'zzz'}", v);
+            checkAppliesUDT("v < {a: 0, b: 'abc'}", v);
+            checkAppliesUDT("v < {a: 0}", v);
+            checkAppliesUDT("v < {b: 'zzz'}", v);
+            checkAppliesUDT("v <= {a: null, b: 'zzz'}", v);
+            checkAppliesUDT("v <= {a: 0}", v);
+            checkAppliesUDT("v <= {b: 'abc'}", v);
+            checkAppliesUDT("v IN (null, {a: null, b: 'abc'}, {a: 0})", v);
+            checkAppliesUDT("v IN (null, {a: 0, b: 'abc'}, {b: 'abc'})", v);
+
+            // multiple conditions
+            checkAppliesUDT("v > {b: 'aaa'} AND v >= {b: 'abc'}", v);
+            checkAppliesUDT("v != null AND v IN ({a: 0}, {a: null, b: 'abc'})", v);
+
+            // should not apply
+            checkDoesNotApplyUDT("v = {a: 0, b: 'def'}", v);
+            checkDoesNotApplyUDT("v = {a: 1}", v);
+            checkDoesNotApplyUDT("v = {b: 'def'}", v);
+            checkDoesNotApplyUDT("v = null", v);
+            checkDoesNotApplyUDT("v != {b: 'abc'}", v);
+            checkDoesNotApplyUDT("v != {a: null, b: 'abc'}", v);
+            checkDoesNotApplyUDT("v > {a: 1, b: 'abc'}", v);
+            checkDoesNotApplyUDT("v > {a: null, b: 'zzz'}", v);
+            checkDoesNotApplyUDT("v > {b: 'zzz'}", v);
+            checkDoesNotApplyUDT("v >= {a: null, b: 'zzz'}", v);
+            checkDoesNotApplyUDT("v >= {a: 1}", v);
+            checkDoesNotApplyUDT("v >= {b: 'zzz'}", v);
+            checkDoesNotApplyUDT("v < {a: null, b: 'aaa'}", v);
+            checkDoesNotApplyUDT("v < {b: 'aaa'}", v);
+            checkDoesNotApplyUDT("v <= {a: null, b: 'aaa'}", v);
+            checkDoesNotApplyUDT("v <= {b: 'aaa'}", v);
+            checkDoesNotApplyUDT("v IN ({a: 1}, {a: 1, b: 'abc'}, {a: null, b: 'def'}, null)", v);
+            checkDoesNotApplyUDT("v IN ()", v);
+
+            // multiple conditions
+            checkDoesNotApplyUDT("v IN () AND v IN ({b: 'abc'})", v);
+            checkDoesNotApplyUDT("v IN () AND v IN ({a: null, b: 'abc'})", v);
+            checkDoesNotApplyUDT("v > {a: -1} AND v < {a: 0}", v);
+
+            /////////////////// null udt ////////////////////
+            v = null;
+            execute("INSERT INTO %s (k, v) VALUES (0, ?)", v);
+
+            checkAppliesUDT("v = null", v);
+            checkAppliesUDT("v IN (null, {a: null, b: 'abc'}, {a: 0})", v);
+            checkAppliesUDT("v IN (null, {a: 0, b: 'abc'}, {b: 'abc'})", v);
+
+            // multiple conditions
+            checkAppliesUDT("v = null AND v IN (null, {a: 0}, {a: null, b: 'abc'})", v);
+
+            // should not apply
+            checkDoesNotApplyUDT("v = {a: 0, b: 'def'}", v);
+            checkDoesNotApplyUDT("v = {a: 1}", v);
+            checkDoesNotApplyUDT("v = {b: 'def'}", v);
+            checkDoesNotApplyUDT("v != null", v);
+            checkDoesNotApplyUDT("v > {a: 1, b: 'abc'}", v);
+            checkDoesNotApplyUDT("v > {a: null, b: 'zzz'}", v);
+            checkDoesNotApplyUDT("v > {b: 'zzz'}", v);
+            checkDoesNotApplyUDT("v >= {a: null, b: 'zzz'}", v);
+            checkDoesNotApplyUDT("v >= {a: 1}", v);
+            checkDoesNotApplyUDT("v >= {b: 'zzz'}", v);
+            checkDoesNotApplyUDT("v < {a: null, b: 'aaa'}", v);
+            checkDoesNotApplyUDT("v < {b: 'aaa'}", v);
+            checkDoesNotApplyUDT("v <= {a: null, b: 'aaa'}", v);
+            checkDoesNotApplyUDT("v <= {b: 'aaa'}", v);
+            checkDoesNotApplyUDT("v IN ({a: 1}, {a: 1, b: 'abc'}, {a: null, b: 'def'})", v);
+            checkDoesNotApplyUDT("v IN ()", v);
+
+            // multiple conditions
+            checkDoesNotApplyUDT("v IN () AND v IN ({b: 'abc'})", v);
+            checkDoesNotApplyUDT("v > {a: -1} AND v < {a: 0}", v);
+
+        }
+    }
+
+    @Test
+    public void testUDTField() throws Throwable
+    {
+        String typename = createType("CREATE TYPE %s (a int, b text)");
+        String myType = KEYSPACE + '.' + typename;
+
+        for (boolean frozen : new boolean[] {false, true})
+        {
+            createTable(String.format("CREATE TABLE %%s (k int PRIMARY KEY, v %s)",
+                                      frozen
+                                      ? "frozen<" + myType + ">"
+                                      : myType));
+
+            Object v = userType("a", 0, "b", "abc");
+            execute("INSERT INTO %s (k, v) VALUES (0, ?)", v);
+
+            checkAppliesUDT("v.a = 0", v);
+            checkAppliesUDT("v.b = 'abc'", v);
+            checkAppliesUDT("v.a < 1", v);
+            checkAppliesUDT("v.b < 'zzz'", v);
+            checkAppliesUDT("v.b <= 'bar'", v);
+            checkAppliesUDT("v.b > 'aaa'", v);
+            checkAppliesUDT("v.b >= 'abc'", v);
+            checkAppliesUDT("v.a != -1", v);
+            checkAppliesUDT("v.b != 'xxx'", v);
+            checkAppliesUDT("v.a != null", v);
+            checkAppliesUDT("v.b != null", v);
+            checkAppliesUDT("v.a IN (null, 0, 1)", v);
+            checkAppliesUDT("v.b IN (null, 'xxx', 'abc')", v);
+            checkAppliesUDT("v.b > 'aaa' AND v.b < 'zzz'", v);
+            checkAppliesUDT("v.a = 0 AND v.b > 'aaa'", v);
+
+            // do not apply
+            checkDoesNotApplyUDT("v.a = -1", v);
+            checkDoesNotApplyUDT("v.b = 'xxx'", v);
+            checkDoesNotApplyUDT("v.a < -1", v);
+            checkDoesNotApplyUDT("v.b < 'aaa'", v);
+            checkDoesNotApplyUDT("v.b <= 'aaa'", v);
+            checkDoesNotApplyUDT("v.b > 'zzz'", v);
+            checkDoesNotApplyUDT("v.b >= 'zzz'", v);
+            checkDoesNotApplyUDT("v.a != 0", v);
+            checkDoesNotApplyUDT("v.b != 'abc'", v);
+            checkDoesNotApplyUDT("v.a IN (null, -1)", v);
+            checkDoesNotApplyUDT("v.b IN (null, 'xxx')", v);
+            checkDoesNotApplyUDT("v.a IN ()", v);
+            checkDoesNotApplyUDT("v.b IN ()", v);
+            checkDoesNotApplyUDT("v.b != null AND v.b IN ()", v);
+
+            // invalid
+            checkInvalidUDT("v.c = null", v, InvalidRequestException.class);
+            checkInvalidUDT("v.a < null", v, InvalidRequestException.class);
+            checkInvalidUDT("v.a <= null", v, InvalidRequestException.class);
+            checkInvalidUDT("v.a > null", v, InvalidRequestException.class);
+            checkInvalidUDT("v.a >= null", v, InvalidRequestException.class);
+            checkInvalidUDT("v.a IN null", v, SyntaxException.class);
+            checkInvalidUDT("v.a IN 367", v, SyntaxException.class);
+            checkInvalidUDT("v.b IN (1, 2, 3)", v, InvalidRequestException.class);
+            checkInvalidUDT("v.a CONTAINS 367", v, SyntaxException.class);
+            checkInvalidUDT("v.a CONTAINS KEY 367", v, SyntaxException.class);
+
+            /////////////// null suffix on udt ////////////////
+            v = userType("a", 0, "b", null);
+            execute("INSERT INTO %s (k, v) VALUES (0, ?)", v);
+
+            checkAppliesUDT("v.a = 0", v);
+            checkAppliesUDT("v.b = null", v);
+            checkAppliesUDT("v.b != 'xxx'", v);
+            checkAppliesUDT("v.a != null", v);
+            checkAppliesUDT("v.a IN (null, 0, 1)", v);
+            checkAppliesUDT("v.b IN (null, 'xxx', 'abc')", v);
+            checkAppliesUDT("v.a = 0 AND v.b = null", v);
+
+            // do not apply
+            checkDoesNotApplyUDT("v.b = 'abc'", v);
+            checkDoesNotApplyUDT("v.a < -1", v);
+            checkDoesNotApplyUDT("v.b < 'aaa'", v);
+            checkDoesNotApplyUDT("v.b <= 'aaa'", v);
+            checkDoesNotApplyUDT("v.b > 'zzz'", v);
+            checkDoesNotApplyUDT("v.b >= 'zzz'", v);
+            checkDoesNotApplyUDT("v.a != 0", v);
+            checkDoesNotApplyUDT("v.b != null", v);
+            checkDoesNotApplyUDT("v.a IN (null, -1)", v);
+            checkDoesNotApplyUDT("v.b IN ('xxx', 'abc')", v);
+            checkDoesNotApplyUDT("v.a IN ()", v);
+            checkDoesNotApplyUDT("v.b IN ()", v);
+            checkDoesNotApplyUDT("v.b != null AND v.b IN ()", v);
+
+            /////////////// null prefix on udt ////////////////
+            v = userType("a", null, "b", "abc");
+            execute("INSERT INTO %s (k, v) VALUES (0, ?)", v);
+
+            checkAppliesUDT("v.a = null", v);
+            checkAppliesUDT("v.b = 'abc'", v);
+            checkAppliesUDT("v.a != 0", v);
+            checkAppliesUDT("v.b != null", v);
+            checkAppliesUDT("v.a IN (null, 0, 1)", v);
+            checkAppliesUDT("v.b IN (null, 'xxx', 'abc')", v);
+            checkAppliesUDT("v.a = null AND v.b = 'abc'", v);
+
+            // do not apply
+            checkDoesNotApplyUDT("v.a = 0", v);
+            checkDoesNotApplyUDT("v.a < -1", v);
+            checkDoesNotApplyUDT("v.b >= 'zzz'", v);
+            checkDoesNotApplyUDT("v.a != null", v);
+            checkDoesNotApplyUDT("v.b != 'abc'", v);
+            checkDoesNotApplyUDT("v.a IN (-1, 0)", v);
+            checkDoesNotApplyUDT("v.b IN (null, 'xxx')", v);
+            checkDoesNotApplyUDT("v.a IN ()", v);
+            checkDoesNotApplyUDT("v.b IN ()", v);
+            checkDoesNotApplyUDT("v.b != null AND v.b IN ()", v);
+
+            /////////////// null udt ////////////////
+            v = null;
+            execute("INSERT INTO %s (k, v) VALUES (0, ?)", v);
+
+            checkAppliesUDT("v.a = null", v);
+            checkAppliesUDT("v.b = null", v);
+            checkAppliesUDT("v.a != 0", v);
+            checkAppliesUDT("v.b != 'abc'", v);
+            checkAppliesUDT("v.a IN (null, 0, 1)", v);
+            checkAppliesUDT("v.b IN (null, 'xxx', 'abc')", v);
+            checkAppliesUDT("v.a = null AND v.b = null", v);
+
+            // do not apply
+            checkDoesNotApplyUDT("v.a = 0", v);
+            checkDoesNotApplyUDT("v.a < -1", v);
+            checkDoesNotApplyUDT("v.b >= 'zzz'", v);
+            checkDoesNotApplyUDT("v.a != null", v);
+            checkDoesNotApplyUDT("v.b != null", v);
+            checkDoesNotApplyUDT("v.a IN (-1, 0)", v);
+            checkDoesNotApplyUDT("v.b IN ('xxx', 'abc')", v);
+            checkDoesNotApplyUDT("v.a IN ()", v);
+            checkDoesNotApplyUDT("v.b IN ()", v);
+            checkDoesNotApplyUDT("v.b != null AND v.b IN ()", v);
+        }
+    }
+
+    void checkAppliesUDT(String condition, Object value) throws Throwable
+    {
+        assertRows(execute("UPDATE %s SET v = ? WHERE k = 0 IF " + condition, value), row(true));
+        assertRows(execute("SELECT * FROM %s"), row(0, value));
+    }
+
+    void checkDoesNotApplyUDT(String condition, Object value) throws Throwable
+    {
+        assertRows(execute("UPDATE %s SET v = ? WHERE k = 0 IF " + condition, value),
+                   row(false, value));
+        assertRows(execute("SELECT * FROM %s"), row(0, value));
+    }
+
+    void checkInvalidUDT(String condition, Object value, Class<? extends Throwable> expected) throws Throwable
+    {
+        assertInvalidThrow(expected, "UPDATE %s SET v = ?  WHERE k = 0 IF " + condition, value);
+        assertRows(execute("SELECT * FROM %s"), row(0, value));
+    }
+
+    /**
+     * Migrated from cql_tests.py:TestCQL.whole_list_conditional_test()
+     */
+    @Test
+    public void testWholeList() throws Throwable
+    {
+        for (boolean frozen : new boolean[] {false, true})
+        {
+            createTable(String.format("CREATE TABLE %%s (k int PRIMARY KEY, l %s)",
+                                      frozen
+                                      ? "frozen<list<text>>"
+                                      : "list<text>"));
+
+            execute("INSERT INTO %s(k, l) VALUES (0, ['foo', 'bar', 'foobar'])");
+
+            check_applies_list("l = ['foo', 'bar', 'foobar']");
+            check_applies_list("l != ['baz']");
+            check_applies_list("l > ['a']");
+            check_applies_list("l >= ['a']");
+            check_applies_list("l < ['z']");
+            check_applies_list("l <= ['z']");
+            check_applies_list("l IN (null, ['foo', 'bar', 'foobar'], ['a'])");
+
+            // multiple conditions
+            check_applies_list("l > ['aaa', 'bbb'] AND l > ['aaa']");
+            check_applies_list("l != null AND l IN (['foo', 'bar', 'foobar'])");
+
+            // should not apply
+            check_does_not_apply_list("l = ['baz']");
+            check_does_not_apply_list("l != ['foo', 'bar', 'foobar']");
+            check_does_not_apply_list("l > ['z']");
+            check_does_not_apply_list("l >= ['z']");
+            check_does_not_apply_list("l < ['a']");
+            check_does_not_apply_list("l <= ['a']");
+            check_does_not_apply_list("l IN (['a'], null)");
+            check_does_not_apply_list("l IN ()");
+
+            // multiple conditions
+            check_does_not_apply_list("l IN () AND l IN (['foo', 'bar', 'foobar'])");
+            check_does_not_apply_list("l > ['zzz'] AND l < ['zzz']");
+
+            check_invalid_list("l = [null]", InvalidRequestException.class);
+            check_invalid_list("l < null", InvalidRequestException.class);
+            check_invalid_list("l <= null", InvalidRequestException.class);
+            check_invalid_list("l > null", InvalidRequestException.class);
+            check_invalid_list("l >= null", InvalidRequestException.class);
+            check_invalid_list("l IN null", SyntaxException.class);
+            check_invalid_list("l IN 367", SyntaxException.class);
+            check_invalid_list("l CONTAINS KEY 123", SyntaxException.class);
+
+            // not supported yet
+            check_invalid_list("m CONTAINS 'bar'", SyntaxException.class);
+        }
+    }
+
+    void check_applies_list(String condition) throws Throwable
+    {
+        assertRows(execute("UPDATE %s SET l = ['foo', 'bar', 'foobar'] WHERE k=0 IF " + condition), row(true));
+        assertRows(execute("SELECT * FROM %s"), row(0, list("foo", "bar", "foobar")));
+    }
+
+    void check_does_not_apply_list(String condition) throws Throwable
+    {
+        assertRows(execute("UPDATE %s SET l = ['foo', 'bar', 'foobar'] WHERE k=0 IF " + condition),
+                   row(false, list("foo", "bar", "foobar")));
+        assertRows(execute("SELECT * FROM %s"), row(0, list("foo", "bar", "foobar")));
+    }
+
+    void check_invalid_list(String condition, Class<? extends Throwable> expected) throws Throwable
+    {
+        assertInvalidThrow(expected, "UPDATE %s SET l = ['foo', 'bar', 'foobar'] WHERE k=0 IF " + condition);
+        assertRows(execute("SELECT * FROM %s"), row(0, list("foo", "bar", "foobar")));
+    }
+
+    /**
+     * Migrated from cql_tests.py:TestCQL.list_item_conditional_test()
+     */
+    @Test
+    public void testListItem() throws Throwable
+    {
+        for (boolean frozen : new boolean[]{ false, true })
+        {
+            createTable(String.format("CREATE TABLE %%s (k int PRIMARY KEY, l %s)",
+                                      frozen
+                                      ? "frozen<list<text>>"
+                                      : "list<text>"));
+
+            execute("INSERT INTO %s(k, l) VALUES (0, ['foo', 'bar', 'foobar'])");
+
+            assertInvalidMessage("Invalid null value for list element access",
+                                 "DELETE FROM %s WHERE k=0 IF l[?] = ?", null, "foobar");
+            assertInvalidMessage("Invalid negative list index -2",
+                                 "DELETE FROM %s WHERE k=0 IF l[?] = ?", -2, "foobar");
+
+            assertRows(execute("DELETE FROM %s WHERE k=0 IF l[?] = ?", 1, null), row(false, list("foo", "bar", "foobar")));
+            assertRows(execute("DELETE FROM %s WHERE k=0 IF l[?] = ?", 1, "foobar"), row(false, list("foo", "bar", "foobar")));
+            assertRows(execute("SELECT * FROM %s"), row(0, list("foo", "bar", "foobar")));
+
+            assertRows(execute("DELETE FROM %s WHERE k=0 IF l[?] = ?", 1, "bar"), row(true));
+            assertEmpty(execute("SELECT * FROM %s"));
+        }
+    }
+
+    /**
+     * Test expanded functionality from CASSANDRA-6839,
+     * migrated from cql_tests.py:TestCQL.expanded_list_item_conditional_test()
+     */
+    @Test
+    public void testExpandedListItem() throws Throwable
+    {
+        for (boolean frozen : new boolean[] {false, true})
+        {
+            createTable(String.format("CREATE TABLE %%s (k int PRIMARY KEY, l %s)",
+                                      frozen
+                                      ? "frozen<list<text>>"
+                                      : "list<text>"));
+
+            execute("INSERT INTO %s (k, l) VALUES (0, ['foo', 'bar', 'foobar'])");
+
+            check_applies_list("l[1] < 'zzz'");
+            check_applies_list("l[1] <= 'bar'");
+            check_applies_list("l[1] > 'aaa'");
+            check_applies_list("l[1] >= 'bar'");
+            check_applies_list("l[1] != 'xxx'");
+            check_applies_list("l[1] != null");
+            check_applies_list("l[1] IN (null, 'xxx', 'bar')");
+            check_applies_list("l[1] > 'aaa' AND l[1] < 'zzz'");
+
+            // check beyond end of list
+            check_applies_list("l[3] = null");
+            check_applies_list("l[3] IN (null, 'xxx', 'bar')");
+
+            check_does_not_apply_list("l[1] < 'aaa'");
+            check_does_not_apply_list("l[1] <= 'aaa'");
+            check_does_not_apply_list("l[1] > 'zzz'");
+            check_does_not_apply_list("l[1] >= 'zzz'");
+            check_does_not_apply_list("l[1] != 'bar'");
+            check_does_not_apply_list("l[1] IN (null, 'xxx')");
+            check_does_not_apply_list("l[1] IN ()");
+            check_does_not_apply_list("l[1] != null AND l[1] IN ()");
+
+            // check beyond end of list
+            check_does_not_apply_list("l[3] != null");
+            check_does_not_apply_list("l[3] = 'xxx'");
+
+            check_invalid_list("l[1] < null", InvalidRequestException.class);
+            check_invalid_list("l[1] <= null", InvalidRequestException.class);
+            check_invalid_list("l[1] > null", InvalidRequestException.class);
+            check_invalid_list("l[1] >= null", InvalidRequestException.class);
+            check_invalid_list("l[1] IN null", SyntaxException.class);
+            check_invalid_list("l[1] IN 367", SyntaxException.class);
+            check_invalid_list("l[1] IN (1, 2, 3)", InvalidRequestException.class);
+            check_invalid_list("l[1] CONTAINS 367", SyntaxException.class);
+            check_invalid_list("l[1] CONTAINS KEY 367", SyntaxException.class);
+            check_invalid_list("l[null] = null", InvalidRequestException.class);
+        }
+    }
+
+    /**
+     * Migrated from cql_tests.py:TestCQL.whole_set_conditional_test()
+     */
+    @Test
+    public void testWholeSet() throws Throwable
+    {
+        for (boolean frozen : new boolean[] {false, true})
+        {
+            createTable(String.format("CREATE TABLE %%s (k int PRIMARY KEY, s %s)",
+                                      frozen
+                                      ? "frozen<set<text>>"
+                                      : "set<text>"));
+
+            execute("INSERT INTO %s (k, s) VALUES (0, {'bar', 'foo'})");
+
+            check_applies_set("s = {'bar', 'foo'}");
+            check_applies_set("s = {'foo', 'bar'}");
+            check_applies_set("s != {'baz'}");
+            check_applies_set("s > {'a'}");
+            check_applies_set("s >= {'a'}");
+            check_applies_set("s < {'z'}");
+            check_applies_set("s <= {'z'}");
+            check_applies_set("s IN (null, {'bar', 'foo'}, {'a'})");
+
+            // multiple conditions
+            check_applies_set("s > {'a'} AND s < {'z'}");
+            check_applies_set("s IN (null, {'bar', 'foo'}, {'a'}) AND s IN ({'a'}, {'bar', 'foo'}, null)");
+
+            // should not apply
+            check_does_not_apply_set("s = {'baz'}");
+            check_does_not_apply_set("s != {'bar', 'foo'}");
+            check_does_not_apply_set("s > {'z'}");
+            check_does_not_apply_set("s >= {'z'}");
+            check_does_not_apply_set("s < {'a'}");
+            check_does_not_apply_set("s <= {'a'}");
+            check_does_not_apply_set("s IN ({'a'}, null)");
+            check_does_not_apply_set("s IN ()");
+            check_does_not_apply_set("s != null AND s IN ()");
+
+            check_invalid_set("s = {null}", InvalidRequestException.class);
+            check_invalid_set("s < null", InvalidRequestException.class);
+            check_invalid_set("s <= null", InvalidRequestException.class);
+            check_invalid_set("s > null", InvalidRequestException.class);
+            check_invalid_set("s >= null", InvalidRequestException.class);
+            check_invalid_set("s IN null", SyntaxException.class);
+            check_invalid_set("s IN 367", SyntaxException.class);
+            check_invalid_set("s CONTAINS KEY 123", SyntaxException.class);
+
+            // element access is not allow for sets
+            check_invalid_set("s['foo'] = 'foobar'", InvalidRequestException.class);
+
+            // not supported yet
+            check_invalid_set("m CONTAINS 'bar'", SyntaxException.class);
+        }
+    }
+
+    void check_applies_set(String condition) throws Throwable
+    {
+        assertRows(execute("UPDATE %s SET s = {'bar', 'foo'} WHERE k=0 IF " + condition), row(true));
+        assertRows(execute("SELECT * FROM %s"), row(0, set("bar", "foo")));
+    }
+
+    void check_does_not_apply_set(String condition) throws Throwable
+    {
+        assertRows(execute("UPDATE %s SET s = {'bar', 'foo'} WHERE k=0 IF " + condition), row(false, set("bar", "foo")));
+        assertRows(execute("SELECT * FROM %s"), row(0, set("bar", "foo")));
+    }
+
+    void check_invalid_set(String condition, Class<? extends Throwable> expected) throws Throwable
+    {
+        assertInvalidThrow(expected, "UPDATE %s SET s = {'bar', 'foo'} WHERE k=0 IF " + condition);
+        assertRows(execute("SELECT * FROM %s"), row(0, set("bar", "foo")));
+    }
+
+    /**
+     * Migrated from cql_tests.py:TestCQL.whole_map_conditional_test()
+     */
+    @Test
+    public void testWholeMap() throws Throwable
+    {
+        for (boolean frozen : new boolean[] {false, true})
+        {
+            createTable(String.format("CREATE TABLE %%s (k int PRIMARY KEY, m %s)",
+                                      frozen
+                                      ? "frozen<map<text, text>>"
+                                      : "map<text, text>"));
+
+            execute("INSERT INTO %s (k, m) VALUES (0, {'foo' : 'bar'})");
+
+            check_applies_map("m = {'foo': 'bar'}");
+            check_applies_map("m > {'a': 'a'}");
+            check_applies_map("m >= {'a': 'a'}");
+            check_applies_map("m < {'z': 'z'}");
+            check_applies_map("m <= {'z': 'z'}");
+            check_applies_map("m != {'a': 'a'}");
+            check_applies_map("m IN (null, {'a': 'a'}, {'foo': 'bar'})");
+
+            // multiple conditions
+            check_applies_map("m > {'a': 'a'} AND m < {'z': 'z'}");
+            check_applies_map("m != null AND m IN (null, {'a': 'a'}, {'foo': 'bar'})");
+
+            // should not apply
+            check_does_not_apply_map("m = {'a': 'a'}");
+            check_does_not_apply_map("m > {'z': 'z'}");
+            check_does_not_apply_map("m >= {'z': 'z'}");
+            check_does_not_apply_map("m < {'a': 'a'}");
+            check_does_not_apply_map("m <= {'a': 'a'}");
+            check_does_not_apply_map("m != {'foo': 'bar'}");
+            check_does_not_apply_map("m IN ({'a': 'a'}, null)");
+            check_does_not_apply_map("m IN ()");
+            check_does_not_apply_map("m = null AND m != null");
+
+            check_invalid_map("m = {null: null}", InvalidRequestException.class);
+            check_invalid_map("m = {'a': null}", InvalidRequestException.class);
+            check_invalid_map("m = {null: 'a'}", InvalidRequestException.class);
+            check_invalid_map("m < null", InvalidRequestException.class);
+            check_invalid_map("m IN null", SyntaxException.class);
+
+            // not supported yet
+            check_invalid_map("m CONTAINS 'bar'", SyntaxException.class);
+            check_invalid_map("m CONTAINS KEY 'foo'", SyntaxException.class);
+            check_invalid_map("m CONTAINS null", SyntaxException.class);
+            check_invalid_map("m CONTAINS KEY null", SyntaxException.class);
+        }
+    }
+
+    /**
+     * Migrated from cql_tests.py:TestCQL.map_item_conditional_test()
+     */
+    @Test
+    public void testMapItem() throws Throwable
+    {
+        for (boolean frozen : new boolean[]{ false, true })
+        {
+            createTable(String.format("CREATE TABLE %%s (k int PRIMARY KEY, m %s)",
+                                      frozen
+                                      ? "frozen<map<text, text>>"
+                                      : "map<text, text>"));
+
+            execute("INSERT INTO %s (k, m) VALUES (0, {'foo' : 'bar'})");
+            assertInvalidMessage("Invalid null value for map element access",
+                                 "DELETE FROM %s WHERE k=0 IF m[?] = ?", null, "foo");
+            assertRows(execute("DELETE FROM %s WHERE k=0 IF m[?] = ?", "foo", "foo"), row(false, map("foo", "bar")));
+            assertRows(execute("DELETE FROM %s WHERE k=0 IF m[?] = ?", "foo", null), row(false, map("foo", "bar")));
+            assertRows(execute("SELECT * FROM %s"), row(0, map("foo", "bar")));
+
+            assertRows(execute("DELETE FROM %s WHERE k=0 IF m[?] = ?", "foo", "bar"), row(true));
+            assertEmpty(execute("SELECT * FROM %s"));
+
+            execute("INSERT INTO %s(k, m) VALUES (1, null)");
+            if (frozen)
+                assertInvalidMessage("Invalid operation (m['foo'] = 'bar') for frozen collection column m",
+                                     "UPDATE %s set m['foo'] = 'bar', m['bar'] = 'foo' WHERE k = 1 IF m[?] IN (?, ?)", "foo", "blah", null);
+            else
+                assertRows(execute("UPDATE %s set m['foo'] = 'bar', m['bar'] = 'foo' WHERE k = 1 IF m[?] IN (?, ?)", "foo", "blah", null), row(true));
+        }
+    }
+
+    @Test
+    public void testFrozenWithNullValues() throws Throwable
+    {
+        createTable(String.format("CREATE TABLE %%s (k int PRIMARY KEY, m %s)", "frozen<list<text>>"));
+        execute("INSERT INTO %s (k, m) VALUES (0, null)");
+
+        assertRows(execute("UPDATE %s SET m = ? WHERE k = 0 IF m = ?", list("test"), list("comparison")), row(false, null));
+
+        createTable(String.format("CREATE TABLE %%s (k int PRIMARY KEY, m %s)", "frozen<map<text,int>>"));
+        execute("INSERT INTO %s (k, m) VALUES (0, null)");
+
+        assertRows(execute("UPDATE %s SET m = ? WHERE k = 0 IF m = ?", map("test", 3), map("comparison", 2)), row(false, null));
+
+        createTable(String.format("CREATE TABLE %%s (k int PRIMARY KEY, m %s)", "frozen<set<text>>"));
+        execute("INSERT INTO %s (k, m) VALUES (0, null)");
+
+        assertRows(execute("UPDATE %s SET m = ? WHERE k = 0 IF m = ?", set("test"), set("comparison")), row(false, null));
+    }
+    /**
+     * Test expanded functionality from CASSANDRA-6839,
+     * migrated from cql_tests.py:TestCQL.expanded_map_item_conditional_test()
+     */
+    @Test
+    public void testExpandedMapItem() throws Throwable
+    {
+        for (boolean frozen : new boolean[]{ false, true })
+        {
+            createTable(String.format("CREATE TABLE %%s (k int PRIMARY KEY, m %s)",
+                                      frozen
+                                      ? "frozen<map<text, text>>"
+                                      : "map<text, text>"));
+
+            execute("INSERT INTO %s (k, m) VALUES (0, {'foo' : 'bar'})");
+
+            check_applies_map("m['xxx'] = null");
+            check_applies_map("m['foo'] < 'zzz'");
+            check_applies_map("m['foo'] <= 'bar'");
+            check_applies_map("m['foo'] > 'aaa'");
+            check_applies_map("m['foo'] >= 'bar'");
+            check_applies_map("m['foo'] != 'xxx'");
+            check_applies_map("m['foo'] != null");
+            check_applies_map("m['foo'] IN (null, 'xxx', 'bar')");
+            check_applies_map("m['xxx'] IN (null, 'xxx', 'bar')"); // m['xxx'] is not set
+
+            // multiple conditions
+            check_applies_map("m['foo'] < 'zzz' AND m['foo'] > 'aaa'");
+
+            check_does_not_apply_map("m['foo'] < 'aaa'");
+            check_does_not_apply_map("m['foo'] <= 'aaa'");
+            check_does_not_apply_map("m['foo'] > 'zzz'");
+            check_does_not_apply_map("m['foo'] >= 'zzz'");
+            check_does_not_apply_map("m['foo'] != 'bar'");
+            check_does_not_apply_map("m['xxx'] != null");  // m['xxx'] is not set
+            check_does_not_apply_map("m['foo'] IN (null, 'xxx')");
+            check_does_not_apply_map("m['foo'] IN ()");
+            check_does_not_apply_map("m['foo'] != null AND m['foo'] = null");
+
+            check_invalid_map("m['foo'] < null", InvalidRequestException.class);
+            check_invalid_map("m['foo'] <= null", InvalidRequestException.class);
+            check_invalid_map("m['foo'] > null", InvalidRequestException.class);
+            check_invalid_map("m['foo'] >= null", InvalidRequestException.class);
+            check_invalid_map("m['foo'] IN null", SyntaxException.class);
+            check_invalid_map("m['foo'] IN 367", SyntaxException.class);
+            check_invalid_map("m['foo'] IN (1, 2, 3)", InvalidRequestException.class);
+            check_invalid_map("m['foo'] CONTAINS 367", SyntaxException.class);
+            check_invalid_map("m['foo'] CONTAINS KEY 367", SyntaxException.class);
+            check_invalid_map("m[null] = null", InvalidRequestException.class);
+        }
+    }
+
+    void check_applies_map(String condition) throws Throwable
+    {
+        assertRows(execute("UPDATE %s SET m = {'foo': 'bar'} WHERE k=0 IF " + condition), row(true));
+        assertRows(execute("SELECT * FROM %s"), row(0, map("foo", "bar")));
+    }
+
+    void check_does_not_apply_map(String condition) throws Throwable
+    {
+        assertRows(execute("UPDATE %s SET m = {'foo': 'bar'} WHERE k=0 IF " + condition), row(false, map("foo", "bar")));
+        assertRows(execute("SELECT * FROM %s"), row(0, map("foo", "bar")));
+    }
+
+    void check_invalid_map(String condition, Class<? extends Throwable> expected) throws Throwable
+    {
+        assertInvalidThrow(expected, "UPDATE %s SET m = {'foo': 'bar'} WHERE k=0 IF " + condition);
+        assertRows(execute("SELECT * FROM %s"), row(0, map("foo", "bar")));
+    }
+
+    @Test
+    public void testInMarkerWithUDTs() throws Throwable
+    {
+        String typename = createType("CREATE TYPE %s (a int, b text)");
+        String myType = KEYSPACE + '.' + typename;
+
+        for (boolean frozen : new boolean[] {false, true})
+        {
+            createTable(String.format("CREATE TABLE %%s (k int PRIMARY KEY, v %s)",
+                                      frozen
+                                      ? "frozen<" + myType + ">"
+                                      : myType));
+
+            Object v = userType("a", 0, "b", "abc");
+            execute("INSERT INTO %s (k, v) VALUES (0, ?)", v);
+
+            // Does not apply
+            assertRows(execute("UPDATE %s SET v = {a: 0, b: 'bc'} WHERE k = 0 IF v IN (?, ?)", userType("a", 1, "b", "abc"), userType("a", 0, "b", "ac")),
+                       row(false, v));
+            assertRows(execute("UPDATE %s SET v = {a: 0, b: 'bc'} WHERE k = 0 IF v IN (?, ?)", userType("a", 1, "b", "abc"), null),
+                       row(false, v));
+            assertRows(execute("UPDATE %s SET v = {a: 0, b: 'bc'} WHERE k = 0 IF v IN (?, ?)", null, null),
+                       row(false, v));
+            assertRows(execute("UPDATE %s SET v = {a: 0, b: 'bc'} WHERE k = 0 IF v IN (?, ?)", userType("a", 1, "b", "abc"), unset()),
+                       row(false, v));
+            assertRows(execute("UPDATE %s SET v = {a: 0, b: 'bc'} WHERE k = 0 IF v IN (?, ?)", unset(), unset()),
+                       row(false, v));
+            assertRows(execute("UPDATE %s SET v = {a: 0, b: 'bc'} WHERE k = 0 IF v IN ?", list(userType("a", 1, "b", "abc"), userType("a", 0, "b", "ac"))),
+                       row(false, v));
+            assertRows(execute("UPDATE %s SET v = {a: 0, b: 'bc'} WHERE k = 0 IF v.a IN (?, ?)", 1, 2),
+                       row(false, v));
+            assertRows(execute("UPDATE %s SET v = {a: 0, b: 'bc'} WHERE k = 0 IF v.a IN (?, ?)", 1, null),
+                       row(false, v));
+            assertRows(execute("UPDATE %s SET v = {a: 0, b: 'bc'} WHERE k = 0 IF v.a IN ?", list(1, 2)),
+                       row(false, v));
+            assertRows(execute("UPDATE %s SET v = {a: 0, b: 'bc'} WHERE k = 0 IF v.a IN (?, ?)", 1, unset()),
+                       row(false, v));
+
+            // Does apply
+            assertRows(execute("UPDATE %s SET v = {a: 0, b: 'bc'} WHERE k = 0 IF v IN (?, ?)", userType("a", 0, "b", "abc"), userType("a", 0, "b", "ac")),
+                       row(true));
+            assertRows(execute("UPDATE %s SET v = {a: 1, b: 'bc'} WHERE k = 0 IF v IN (?, ?)", userType("a", 0, "b", "bc"), null),
+                       row(true));
+            assertRows(execute("UPDATE %s SET v = {a: 0, b: 'abc'} WHERE k = 0 IF v IN ?", list(userType("a", 1, "b", "bc"), userType("a", 0, "b", "ac"))),
+                       row(true));
+            assertRows(execute("UPDATE %s SET v = {a: 1, b: 'bc'} WHERE k = 0 IF v IN (?, ?, ?)", userType("a", 1, "b", "bc"), unset(), userType("a", 0, "b", "abc")),
+                       row(true));
+            assertRows(execute("UPDATE %s SET v = {a: 0, b: 'bc'} WHERE k = 0 IF v.a IN (?, ?)", 1, 0),
+                       row(true));
+            assertRows(execute("UPDATE %s SET v = {a: 0, b: 'abc'} WHERE k = 0 IF v.a IN (?, ?)", 0, null),
+                       row(true));
+            assertRows(execute("UPDATE %s SET v = {a: 0, b: 'bc'} WHERE k = 0 IF v.a IN ?", list(0, 1)),
+                       row(true));
+            assertRows(execute("UPDATE %s SET v = {a: 0, b: 'abc'} WHERE k = 0 IF v.a IN (?, ?, ?)", 1, unset(), 0),
+                       row(true));
+
+            assertInvalidMessage("Invalid null list in IN condition",
+                                 "UPDATE %s SET v = {a: 0, b: 'bc'} WHERE k = 0 IF v IN ?", (List<ByteBuffer>) null);
+            assertInvalidMessage("Invalid 'unset' value in condition",
+                                 "UPDATE %s SET v = {a: 0, b: 'bc'} WHERE k = 0 IF v IN ?", unset());
+            assertInvalidMessage("Invalid 'unset' value in condition",
+                                 "UPDATE %s SET v = {a: 0, b: 'bc'} WHERE k = 0 IF v.a IN ?", unset());
+        }
+    }
+}
diff --git a/test/unit/org/apache/cassandra/cql3/validation/operations/InsertUpdateIfConditionStaticsTest.java b/test/unit/org/apache/cassandra/cql3/validation/operations/InsertUpdateIfConditionStaticsTest.java
new file mode 100644
index 0000000000..25ab256a9f
--- /dev/null
+++ b/test/unit/org/apache/cassandra/cql3/validation/operations/InsertUpdateIfConditionStaticsTest.java
@@ -0,0 +1,379 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.cassandra.cql3.validation.operations;
+
+import java.util.Collection;
+
+import org.junit.AfterClass;
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import org.apache.cassandra.cql3.CQLTester;
+
+/* This class been split into multiple ones bc of timeout issues CASSANDRA-16670
+ * Any changes here check if they apply to the other classes
+ * - InsertUpdateIfConditionStaticsTest
+ * - InsertUpdateIfConditionCollectionsTest
+ * - InsertUpdateIfConditionTest
+ */
+@RunWith(Parameterized.class)
+public class InsertUpdateIfConditionStaticsTest extends CQLTester
+{
+    @Parameterized.Parameter(0)
+    public String clusterMinVersion;
+
+    @Parameterized.Parameter(1)
+    public Runnable assertion;
+
+    @Parameterized.Parameters(name = "{index}: clusterMinVersion={0}")
+    public static Collection<Object[]> data()
+    {
+        return InsertUpdateIfConditionTest.data();
+    }
+
+    @BeforeClass
+    public static void beforeClass()
+    {
+        InsertUpdateIfConditionTest.beforeClass();
+    }
+
+    @Before
+    public void before()
+    {
+        InsertUpdateIfConditionTest.beforeSetup(clusterMinVersion, assertion);
+    }
+
+    @AfterClass
+    public static void afterClass()
+    {
+        InsertUpdateIfConditionTest.afterClass();
+    }
+
+    /**
+     * Migrated from cql_tests.py:TestCQL.static_columns_cas_test()
+     */
+    @Test
+    public void testStaticColumnsCas() throws Throwable
+    {
+        createTable("CREATE TABLE %s (id int, k text, version int static, v text, PRIMARY KEY (id, k))");
+
+        // Test that INSERT IF NOT EXISTS concerns only the static column if no clustering nor regular columns
+        // is provided, but concerns the CQL3 row targetted by the clustering columns otherwise
+        execute("INSERT INTO %s (id, k, v) VALUES (1, 'foo', 'foo')");
+        assertRows(execute("INSERT INTO %s (id, k, version) VALUES (1, 'foo', 1) IF NOT EXISTS"), row(false, 1, "foo", null, "foo"));
+        assertRows(execute("INSERT INTO %s (id, version) VALUES (1, 1) IF NOT EXISTS"), row(true));
+        assertRows(execute("SELECT * FROM %s"), row(1, "foo", 1, "foo"));
+        execute("DELETE FROM %s WHERE id = 1");
+
+        execute("INSERT INTO %s(id, version) VALUES (0, 0)");
+
+        assertRows(execute("UPDATE %s SET v='foo', version=1 WHERE id=0 AND k='k1' IF version = ?", 0), row(true));
+        assertRows(execute("SELECT * FROM %s"), row(0, "k1", 1, "foo"));
+
+        assertRows(execute("UPDATE %s SET v='bar', version=1 WHERE id=0 AND k='k2' IF version = ?", 0), row(false, 1));
+        assertRows(execute("SELECT * FROM %s"), row(0, "k1", 1, "foo"));
+
+        assertRows(execute("UPDATE %s SET v='bar', version=2 WHERE id=0 AND k='k2' IF version = ?", 1), row(true));
+        assertRows(execute("SELECT * FROM %s"), row(0, "k1", 2, "foo"), row(0, "k2", 2, "bar"));
+
+        // Batch output is slightly different from non-batch CAS, since a full PK is included to disambiguate
+        // cases when conditions span across multiple rows.
+        assertRows(execute("UPDATE %1$s SET version=3 WHERE id=0 IF version=1; "),
+                   row(false, 2));
+        // Testing batches
+        assertRows(execute("BEGIN BATCH " +
+                           "UPDATE %1$s SET v='foobar' WHERE id=0 AND k='k1'; " +
+                           "UPDATE %1$s SET v='barfoo' WHERE id=0 AND k='k2'; " +
+                           "UPDATE %1$s SET version=3 WHERE id=0 IF version=1; " +
+                           "APPLY BATCH "),
+                   row(false, 0, "k1", 2));
+
+        assertRows(execute("BEGIN BATCH " +
+                           "UPDATE %1$s SET v = 'foobar' WHERE id = 0 AND k = 'k1'; " +
+                           "UPDATE %1$s SET v = 'barfoo' WHERE id = 0 AND k = 'k2'; " +
+                           "UPDATE %1$s SET version = 3 WHERE id = 0 IF version = 2; " +
+                           "APPLY BATCH "),
+                   row(true));
+
+        assertRows(execute("SELECT * FROM %s"),
+                   row(0, "k1", 3, "foobar"),
+                   row(0, "k2", 3, "barfoo"));
+
+        assertRows(execute("BEGIN BATCH " +
+                           "UPDATE %1$s SET version = 4 WHERE id = 0 IF version = 3; " +
+                           "UPDATE %1$s SET v='row1' WHERE id=0 AND k='k1' IF v='foo'; " +
+                           "UPDATE %1$s SET v='row2' WHERE id=0 AND k='k2' IF v='bar'; " +
+                           "APPLY BATCH "),
+                   row(false, 0, "k1", 3, "foobar"),
+                   row(false, 0, "k2", 3, "barfoo"));
+
+        assertRows(execute("BEGIN BATCH " +
+                           "UPDATE %1$s SET version = 4 WHERE id = 0 IF version = 3; " +
+                           "UPDATE %1$s SET v='row1' WHERE id = 0 AND k='k1' IF v='foobar'; " +
+                           "UPDATE %1$s SET v='row2' WHERE id = 0 AND k='k2' IF v='barfoo'; " +
+                           "APPLY BATCH "),
+                   row(true));
+
+        assertRows(execute("SELECT * FROM %s"),
+                   row(0, "k1", 4, "row1"),
+                   row(0, "k2", 4, "row2"));
+
+        assertInvalid("BEGIN BATCH " +
+                      "UPDATE %1$s SET version=5 WHERE id=0 IF version=4; " +
+                      "UPDATE %1$s SET v='row1' WHERE id=0 AND k='k1'; " +
+                      "UPDATE %1$s SET v='row2' WHERE id=1 AND k='k2'; " +
+                      "APPLY BATCH ");
+
+        assertRows(execute("BEGIN BATCH " +
+                           "INSERT INTO %1$s (id, k, v) VALUES (1, 'k1', 'val1') IF NOT EXISTS; " +
+                           "INSERT INTO %1$s (id, k, v) VALUES (1, 'k2', 'val2') IF NOT EXISTS; " +
+                           "APPLY BATCH "),
+                   row(true));
+
+        assertRows(execute("SELECT * FROM %s WHERE id=1"),
+                   row(1, "k1", null, "val1"),
+                   row(1, "k2", null, "val2"));
+
+        assertRows(execute("INSERT INTO %s (id, k, v) VALUES (1, 'k2', 'val2') IF NOT EXISTS"), row(false, 1, "k2", null, "val2"));
+
+        assertRows(execute("BEGIN BATCH " +
+                           "INSERT INTO %1$s (id, k, v) VALUES (1, 'k2', 'val2') IF NOT EXISTS; " +
+                           "INSERT INTO %1$s (id, k, v) VALUES (1, 'k3', 'val3') IF NOT EXISTS; " +
+                           "APPLY BATCH"),
+                   row(false, 1, "k2", null, "val2"));
+
+        assertRows(execute("BEGIN BATCH " +
+                           "UPDATE %1$s SET v = 'newVal' WHERE id = 1 AND k = 'k2' IF v = 'val0'; " +
+                           "INSERT INTO %1$s (id, k, v) VALUES (1, 'k3', 'val3') IF NOT EXISTS; " +
+                           "APPLY BATCH"),
+                   row(false, 1, "k2", null, "val2"));
+
+        assertRows(execute("SELECT * FROM %s WHERE id=1"),
+                   row(1, "k1", null, "val1"),
+                   row(1, "k2", null, "val2"));
+
+        assertRows(execute("BEGIN BATCH " +
+                           "UPDATE %1$s SET v = 'newVal' WHERE id = 1 AND k = 'k2' IF v = 'val2'; " +
+                           "INSERT INTO %1$s (id, k, v, version) VALUES(1, 'k3', 'val3', 1) IF NOT EXISTS; " +
+                           "APPLY BATCH"),
+                   row(true));
+
+        assertRows(execute("SELECT * FROM %s WHERE id=1"),
+                   row(1, "k1", 1, "val1"),
+                   row(1, "k2", 1, "newVal"),
+                   row(1, "k3", 1, "val3"));
+
+        assertRows(execute("BEGIN BATCH " +
+                           "UPDATE %1$s SET v = 'newVal1' WHERE id = 1 AND k = 'k2' IF v = 'val2'; " +
+                           "UPDATE %1$s SET v = 'newVal2' WHERE id = 1 AND k = 'k2' IF v = 'val3'; " +
+                           "APPLY BATCH"),
+                   row(false, 1, "k2", "newVal"));
+    }
+
+    /**
+     * Test CASSANDRA-10532
+     */
+    @Test
+    public void testStaticColumnsCasDelete() throws Throwable
+    {
+        createTable("CREATE TABLE %s (pk int, ck int, static_col int static, value int, PRIMARY KEY (pk, ck))");
+        execute("INSERT INTO %s (pk, ck, value) VALUES (?, ?, ?)", 1, 1, 2);
+        execute("INSERT INTO %s (pk, ck, value) VALUES (?, ?, ?)", 1, 3, 4);
+        execute("INSERT INTO %s (pk, ck, value) VALUES (?, ?, ?)", 1, 5, 6);
+        execute("INSERT INTO %s (pk, ck, value) VALUES (?, ?, ?)", 1, 7, 8);
+        execute("INSERT INTO %s (pk, ck, value) VALUES (?, ?, ?)", 2, 1, 2);
+        execute("INSERT INTO %s (pk, static_col) VALUES (?, ?)", 1, 1);
+
+        assertRows(execute("DELETE static_col FROM %s WHERE pk = ? IF static_col = ?", 1, 2), row(false, 1));
+        assertRows(execute("DELETE static_col FROM %s WHERE pk = ? IF static_col = ?", 1, 1), row(true));
+
+        assertRows(execute("SELECT pk, ck, static_col, value FROM %s WHERE pk = 1"),
+                   row(1, 1, null, 2),
+                   row(1, 3, null, 4),
+                   row(1, 5, null, 6),
+                   row(1, 7, null, 8));
+        execute("INSERT INTO %s (pk, static_col) VALUES (?, ?)", 1, 1);
+
+        assertInvalidMessage("Some partition key parts are missing: pk",
+                             "DELETE static_col FROM %s WHERE ck = ? IF static_col = ?", 1, 1);
+
+        assertInvalidMessage("Invalid restrictions on clustering columns since the DELETE statement modifies only static columns",
+                             "DELETE static_col FROM %s WHERE pk = ? AND ck = ? IF static_col = ?", 1, 1, 1);
+
+        assertInvalidMessage("DELETE statements must restrict all PRIMARY KEY columns with equality relations in order to delete non static columns",
+                             "DELETE static_col, value FROM %s WHERE pk = ? IF static_col = ?", 1, 1);
+
+        // Same query but with an invalid condition
+        assertInvalidMessage("DELETE statements must restrict all PRIMARY KEY columns with equality relations in order to delete non static columns",
+                             "DELETE static_col, value FROM %s WHERE pk = ? IF static_col = ?", 1, 2);
+
+        // DELETE of an underspecified PRIMARY KEY should not succeed if static is not only restriction
+        assertInvalidMessage("DELETE statements must restrict all PRIMARY KEY columns with equality relations" +
+                             " in order to use IF condition on non static columns",
+                             "DELETE static_col FROM %s WHERE pk = ? IF value = ? AND static_col = ?", 1, 2, 1);
+
+        assertRows(execute("DELETE value FROM %s WHERE pk = ? AND ck = ? IF value = ? AND static_col = ?", 1, 1, 2, 2), row(false, 2, 1));
+        assertRows(execute("DELETE value FROM %s WHERE pk = ? AND ck = ? IF value = ? AND static_col = ?", 1, 1, 2, 1), row(true));
+        assertRows(execute("SELECT pk, ck, static_col, value FROM %s WHERE pk = 1"),
+                   row(1, 1, 1, null),
+                   row(1, 3, 1, 4),
+                   row(1, 5, 1, 6),
+                   row(1, 7, 1, 8));
+
+        assertRows(execute("DELETE static_col FROM %s WHERE pk = ? AND ck = ? IF value = ?", 1, 5, 10), row(false, 6));
+        assertRows(execute("DELETE static_col FROM %s WHERE pk = ? AND ck = ? IF value = ?", 1, 5, 6), row(true));
+        assertRows(execute("SELECT pk, ck, static_col, value FROM %s WHERE pk = 1"),
+                   row(1, 1, null, null),
+                   row(1, 3, null, 4),
+                   row(1, 5, null, 6),
+                   row(1, 7, null, 8));
+    }
+
+    @Test
+    public void testStaticColumnsCasUpdate() throws Throwable
+    {
+        createTable("CREATE TABLE %s (pk int, ck int, static_col int static, value int, PRIMARY KEY (pk, ck))");
+        execute("INSERT INTO %s (pk, ck, value) VALUES (?, ?, ?)", 1, 1, 2);
+        execute("INSERT INTO %s (pk, ck, value) VALUES (?, ?, ?)", 1, 3, 4);
+        execute("INSERT INTO %s (pk, ck, value) VALUES (?, ?, ?)", 1, 5, 6);
+        execute("INSERT INTO %s (pk, ck, value) VALUES (?, ?, ?)", 1, 7, 8);
+        execute("INSERT INTO %s (pk, ck, value) VALUES (?, ?, ?)", 2, 1, 2);
+        execute("INSERT INTO %s (pk, static_col) VALUES (?, ?)", 1, 1);
+
+        assertRows(execute("UPDATE %s SET static_col = ? WHERE pk = ? IF static_col = ?", 3, 1, 2), row(false, 1));
+        assertRows(execute("UPDATE %s SET static_col = ? WHERE pk = ? IF static_col = ?", 2, 1, 1), row(true));
+
+        assertRows(execute("SELECT pk, ck, static_col, value FROM %s WHERE pk = 1"),
+                   row(1, 1, 2, 2),
+                   row(1, 3, 2, 4),
+                   row(1, 5, 2, 6),
+                   row(1, 7, 2, 8));
+
+        assertInvalidMessage("Some partition key parts are missing: pk",
+                             "UPDATE %s SET static_col = ? WHERE ck = ? IF static_col = ?", 3, 1, 1);
+
+        assertInvalidMessage("Invalid restrictions on clustering columns since the UPDATE statement modifies only static columns",
+                             "UPDATE %s SET static_col = ? WHERE pk = ? AND ck = ? IF static_col = ?", 3, 1, 1, 1);
+
+        assertInvalidMessage("Some clustering keys are missing: ck",
+                             "UPDATE %s SET static_col = ?, value = ? WHERE pk = ? IF static_col = ?", 3, 1, 1, 2);
+
+        // Same query but with an invalid condition
+        assertInvalidMessage("Some clustering keys are missing: ck",
+                             "UPDATE %s SET static_col = ?, value = ? WHERE pk = ? IF static_col = ?", 3, 1, 1, 1);
+
+        assertInvalidMessage("Some clustering keys are missing: ck",
+                             "UPDATE %s SET static_col = ? WHERE pk = ? IF value = ? AND static_col = ?", 3, 1, 4, 2);
+
+        assertRows(execute("UPDATE %s SET value = ? WHERE pk = ? AND ck = ? IF value = ? AND static_col = ?", 3, 1, 1, 3, 2), row(false, 2, 2));
+        assertRows(execute("UPDATE %s SET value = ? WHERE pk = ? AND ck = ? IF value = ? AND static_col = ?", 1, 1, 1, 2, 2), row(true));
+        assertRows(execute("SELECT pk, ck, static_col, value FROM %s WHERE pk = 1"),
+                   row(1, 1, 2, 1),
+                   row(1, 3, 2, 4),
+                   row(1, 5, 2, 6),
+                   row(1, 7, 2, 8));
+
+        assertRows(execute("UPDATE %s SET static_col = ? WHERE pk = ? AND ck = ? IF value = ?", 3, 1, 1, 2), row(false, 1));
+        assertRows(execute("UPDATE %s SET static_col = ? WHERE pk = ? AND ck = ? IF value = ?", 1, 1, 1, 1), row(true));
+        assertRows(execute("SELECT pk, ck, static_col, value FROM %s WHERE pk = 1"),
+                   row(1, 1, 1, 1),
+                   row(1, 3, 1, 4),
+                   row(1, 5, 1, 6),
+                   row(1, 7, 1, 8));
+    }
+
+    @Test
+    public void testConditionalUpdatesOnStaticColumns() throws Throwable
+    {
+        createTable("CREATE TABLE %s (a int, b int, s int static, d text, PRIMARY KEY (a, b))");
+
+        assertInvalidMessage("Invalid 'unset' value in condition", "UPDATE %s SET s = 6 WHERE a = 6 IF s = ?", unset());
+
+        // pre-existing row
+        execute("INSERT INTO %s (a, b, s, d) values (6, 6, 100, 'a')");
+        assertRows(execute("UPDATE %s SET s = 6 WHERE a = 6 IF s = 100"),
+                   row(true));
+        assertRows(execute("SELECT * FROM %s WHERE a = 6"),
+                   row(6, 6, 6, "a"));
+
+        execute("INSERT INTO %s (a, b, s, d) values (7, 7, 100, 'a')");
+        assertRows(execute("UPDATE %s SET s = 7 WHERE a = 7 IF s = 101"),
+                   row(false, 100));
+        assertRows(execute("SELECT * FROM %s WHERE a = 7"),
+                   row(7, 7, 100, "a"));
+
+        // pre-existing row with null in the static column
+        execute("INSERT INTO %s (a, b, d) values (7, 7, 'a')");
+        assertRows(execute("UPDATE %s SET s = 7 WHERE a = 7 IF s = NULL"),
+                   row(false, 100));
+        assertRows(execute("SELECT * FROM %s WHERE a = 7"),
+                   row(7, 7, 100, "a"));
+
+        // deleting row before CAS makes it effectively non-existing
+        execute("DELETE FROM %s WHERE a = 8;");
+        assertRows(execute("UPDATE %s SET s = 8 WHERE a = 8 IF s = NULL"),
+                   row(true));
+        assertRows(execute("SELECT * FROM %s WHERE a = 8"),
+                   row(8, null, 8, null));
+    }
+
+    @Test
+    public void testStaticsWithMultipleConditions() throws Throwable
+    {
+        createTable("CREATE TABLE %s (a int, b int, s1 int static, s2 int static, d int, PRIMARY KEY (a, b))");
+
+        for (int i = 1; i <= 5; i++)
+        {
+            execute("INSERT INTO %s (a, b, d) VALUES (?, ?, ?)", i, 1, 5);
+            execute("INSERT INTO %s (a, b, d) VALUES (?, ?, ?)", i, 2, 6);
+        }
+
+        assertRows(execute("BEGIN BATCH\n"
+                           + "UPDATE %1$s SET s2 = 102 WHERE a = 1 IF s1 = null;\n"
+                           + "UPDATE %1$s SET s1 = 101 WHERE a = 1 IF s2 = null;\n"
+                           + "APPLY BATCH"),
+                   row(true));
+        assertRows(execute("SELECT * FROM %s WHERE a = 1"),
+                   row(1, 1, 101, 102, 5),
+                   row(1, 2, 101, 102, 6));
+
+        assertRows(execute("BEGIN BATCH\n"
+                           + "UPDATE %1$s SET s2 = 202 WHERE a = 2 IF s1 = null;\n"
+                           + "UPDATE %1$s SET s1 = 201 WHERE a = 2 IF s2 = null;\n"
+                           + "UPDATE %1$s SET d = 203 WHERE a = 2 AND b = 1 IF d = 5;\n"
+                           + "UPDATE %1$s SET d = 204 WHERE a = 2 AND b = 2 IF d = 6;\n"
+                           + "APPLY BATCH"),
+                   row(true));
+
+        assertRows(execute("SELECT * FROM %s WHERE a = 2"),
+                   row(2, 1, 201, 202, 203),
+                   row(2, 2, 201, 202, 204));
+
+        assertRows(execute("BEGIN BATCH\n"
+                           + "UPDATE %1$s SET s2 = 202 WHERE a = 20 IF s1 = null;\n"
+                           + "UPDATE %1$s SET s1 = 201 WHERE a = 20 IF s2 = null;\n"
+                           + "UPDATE %1$s SET d = 203 WHERE a = 20 AND b = 1 IF d = 5;\n"
+                           + "UPDATE %1$s SET d = 204 WHERE a = 20 AND b = 2 IF d = 6;\n"
+                           + "APPLY BATCH"),
+                   row(false));
+    }
+}
diff --git a/test/unit/org/apache/cassandra/cql3/validation/operations/InsertUpdateIfConditionTest.java b/test/unit/org/apache/cassandra/cql3/validation/operations/InsertUpdateIfConditionTest.java
index 4db1ef5bfe..4213cc920f 100644
--- a/test/unit/org/apache/cassandra/cql3/validation/operations/InsertUpdateIfConditionTest.java
+++ b/test/unit/org/apache/cassandra/cql3/validation/operations/InsertUpdateIfConditionTest.java
@@ -18,10 +18,8 @@
 
 package org.apache.cassandra.cql3.validation.operations;
 
-import java.nio.ByteBuffer;
 import java.util.Arrays;
 import java.util.Collection;
-import java.util.List;
 
 import org.junit.AfterClass;
 import org.junit.Before;
@@ -34,8 +32,6 @@ import org.apache.cassandra.Util;
 import org.apache.cassandra.cql3.CQLTester;
 import org.apache.cassandra.cql3.Duration;
 import org.apache.cassandra.db.SystemKeyspace;
-import org.apache.cassandra.exceptions.InvalidRequestException;
-import org.apache.cassandra.exceptions.SyntaxException;
 import org.apache.cassandra.gms.Gossiper;
 import org.apache.cassandra.schema.SchemaConstants;
 import org.apache.cassandra.schema.SchemaKeyspace;
@@ -46,6 +42,12 @@ import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 
+/* This class been split into multiple ones bc of timeout issues CASSANDRA-16670
+ * Any changes here check if they apply to the other classes
+ * - InsertUpdateIfConditionStaticsTest
+ * - InsertUpdateIfConditionCollectionsTest
+ * - InsertUpdateIfConditionTest
+ */
 @RunWith(Parameterized.class)
 public class InsertUpdateIfConditionTest extends CQLTester
 {
@@ -78,6 +80,11 @@ public class InsertUpdateIfConditionTest extends CQLTester
 
     @Before
     public void before()
+    {
+        beforeSetup(clusterMinVersion, assertion);
+    }
+    
+    public static void beforeSetup(String clusterMinVersion, Runnable assertion)
     {
         Util.setUpgradeFromVersion(clusterMinVersion);
         assertion.run();
@@ -336,252 +343,6 @@ public class InsertUpdateIfConditionTest extends CQLTester
                    row(true));
     }
 
-    /**
-     * Migrated from cql_tests.py:TestCQL.static_columns_cas_test()
-     */
-    @Test
-    public void testStaticColumnsCas() throws Throwable
-    {
-        createTable("CREATE TABLE %s (id int, k text, version int static, v text, PRIMARY KEY (id, k))");
-
-        // Test that INSERT IF NOT EXISTS concerns only the static column if no clustering nor regular columns
-        // is provided, but concerns the CQL3 row targetted by the clustering columns otherwise
-        execute("INSERT INTO %s (id, k, v) VALUES (1, 'foo', 'foo')");
-        assertRows(execute("INSERT INTO %s (id, k, version) VALUES (1, 'foo', 1) IF NOT EXISTS"), row(false, 1, "foo", null, "foo"));
-        assertRows(execute("INSERT INTO %s (id, version) VALUES (1, 1) IF NOT EXISTS"), row(true));
-        assertRows(execute("SELECT * FROM %s"), row(1, "foo", 1, "foo"));
-        execute("DELETE FROM %s WHERE id = 1");
-
-        execute("INSERT INTO %s(id, version) VALUES (0, 0)");
-
-        assertRows(execute("UPDATE %s SET v='foo', version=1 WHERE id=0 AND k='k1' IF version = ?", 0), row(true));
-        assertRows(execute("SELECT * FROM %s"), row(0, "k1", 1, "foo"));
-
-        assertRows(execute("UPDATE %s SET v='bar', version=1 WHERE id=0 AND k='k2' IF version = ?", 0), row(false, 1));
-        assertRows(execute("SELECT * FROM %s"), row(0, "k1", 1, "foo"));
-
-        assertRows(execute("UPDATE %s SET v='bar', version=2 WHERE id=0 AND k='k2' IF version = ?", 1), row(true));
-        assertRows(execute("SELECT * FROM %s"), row(0, "k1", 2, "foo"), row(0, "k2", 2, "bar"));
-
-        // Batch output is slightly different from non-batch CAS, since a full PK is included to disambiguate
-        // cases when conditions span across multiple rows.
-        assertRows(execute("UPDATE %1$s SET version=3 WHERE id=0 IF version=1; "),
-                   row(false, 2));
-        // Testing batches
-        assertRows(execute("BEGIN BATCH " +
-                           "UPDATE %1$s SET v='foobar' WHERE id=0 AND k='k1'; " +
-                           "UPDATE %1$s SET v='barfoo' WHERE id=0 AND k='k2'; " +
-                           "UPDATE %1$s SET version=3 WHERE id=0 IF version=1; " +
-                           "APPLY BATCH "),
-                   row(false, 0, "k1", 2));
-
-        assertRows(execute("BEGIN BATCH " +
-                           "UPDATE %1$s SET v = 'foobar' WHERE id = 0 AND k = 'k1'; " +
-                           "UPDATE %1$s SET v = 'barfoo' WHERE id = 0 AND k = 'k2'; " +
-                           "UPDATE %1$s SET version = 3 WHERE id = 0 IF version = 2; " +
-                           "APPLY BATCH "),
-                   row(true));
-
-        assertRows(execute("SELECT * FROM %s"),
-                   row(0, "k1", 3, "foobar"),
-                   row(0, "k2", 3, "barfoo"));
-
-        assertRows(execute("BEGIN BATCH " +
-                           "UPDATE %1$s SET version = 4 WHERE id = 0 IF version = 3; " +
-                           "UPDATE %1$s SET v='row1' WHERE id=0 AND k='k1' IF v='foo'; " +
-                           "UPDATE %1$s SET v='row2' WHERE id=0 AND k='k2' IF v='bar'; " +
-                           "APPLY BATCH "),
-                   row(false, 0, "k1", 3, "foobar"),
-                   row(false, 0, "k2", 3, "barfoo"));
-
-        assertRows(execute("BEGIN BATCH " +
-                           "UPDATE %1$s SET version = 4 WHERE id = 0 IF version = 3; " +
-                           "UPDATE %1$s SET v='row1' WHERE id = 0 AND k='k1' IF v='foobar'; " +
-                           "UPDATE %1$s SET v='row2' WHERE id = 0 AND k='k2' IF v='barfoo'; " +
-                           "APPLY BATCH "),
-                   row(true));
-
-        assertRows(execute("SELECT * FROM %s"),
-                   row(0, "k1", 4, "row1"),
-                   row(0, "k2", 4, "row2"));
-
-        assertInvalid("BEGIN BATCH " +
-                      "UPDATE %1$s SET version=5 WHERE id=0 IF version=4; " +
-                      "UPDATE %1$s SET v='row1' WHERE id=0 AND k='k1'; " +
-                      "UPDATE %1$s SET v='row2' WHERE id=1 AND k='k2'; " +
-                      "APPLY BATCH ");
-
-        assertRows(execute("BEGIN BATCH " +
-                           "INSERT INTO %1$s (id, k, v) VALUES (1, 'k1', 'val1') IF NOT EXISTS; " +
-                           "INSERT INTO %1$s (id, k, v) VALUES (1, 'k2', 'val2') IF NOT EXISTS; " +
-                           "APPLY BATCH "),
-                   row(true));
-
-        assertRows(execute("SELECT * FROM %s WHERE id=1"),
-                   row(1, "k1", null, "val1"),
-                   row(1, "k2", null, "val2"));
-
-        assertRows(execute("INSERT INTO %s (id, k, v) VALUES (1, 'k2', 'val2') IF NOT EXISTS"), row(false, 1, "k2", null, "val2"));
-
-        assertRows(execute("BEGIN BATCH " +
-                           "INSERT INTO %1$s (id, k, v) VALUES (1, 'k2', 'val2') IF NOT EXISTS; " +
-                           "INSERT INTO %1$s (id, k, v) VALUES (1, 'k3', 'val3') IF NOT EXISTS; " +
-                           "APPLY BATCH"),
-                   row(false, 1, "k2", null, "val2"));
-
-        assertRows(execute("BEGIN BATCH " +
-                           "UPDATE %1$s SET v = 'newVal' WHERE id = 1 AND k = 'k2' IF v = 'val0'; " +
-                           "INSERT INTO %1$s (id, k, v) VALUES (1, 'k3', 'val3') IF NOT EXISTS; " +
-                           "APPLY BATCH"),
-                   row(false, 1, "k2", null, "val2"));
-
-        assertRows(execute("SELECT * FROM %s WHERE id=1"),
-                   row(1, "k1", null, "val1"),
-                   row(1, "k2", null, "val2"));
-
-        assertRows(execute("BEGIN BATCH " +
-                           "UPDATE %1$s SET v = 'newVal' WHERE id = 1 AND k = 'k2' IF v = 'val2'; " +
-                           "INSERT INTO %1$s (id, k, v, version) VALUES(1, 'k3', 'val3', 1) IF NOT EXISTS; " +
-                           "APPLY BATCH"),
-                   row(true));
-
-        assertRows(execute("SELECT * FROM %s WHERE id=1"),
-                   row(1, "k1", 1, "val1"),
-                   row(1, "k2", 1, "newVal"),
-                   row(1, "k3", 1, "val3"));
-
-        assertRows(execute("BEGIN BATCH " +
-                           "UPDATE %1$s SET v = 'newVal1' WHERE id = 1 AND k = 'k2' IF v = 'val2'; " +
-                           "UPDATE %1$s SET v = 'newVal2' WHERE id = 1 AND k = 'k2' IF v = 'val3'; " +
-                           "APPLY BATCH"),
-                   row(false, 1, "k2", "newVal"));
-    }
-
-    /**
-     * Test CASSANDRA-10532
-     */
-    @Test
-    public void testStaticColumnsCasDelete() throws Throwable
-    {
-        createTable("CREATE TABLE %s (pk int, ck int, static_col int static, value int, PRIMARY KEY (pk, ck))");
-        execute("INSERT INTO %s (pk, ck, value) VALUES (?, ?, ?)", 1, 1, 2);
-        execute("INSERT INTO %s (pk, ck, value) VALUES (?, ?, ?)", 1, 3, 4);
-        execute("INSERT INTO %s (pk, ck, value) VALUES (?, ?, ?)", 1, 5, 6);
-        execute("INSERT INTO %s (pk, ck, value) VALUES (?, ?, ?)", 1, 7, 8);
-        execute("INSERT INTO %s (pk, ck, value) VALUES (?, ?, ?)", 2, 1, 2);
-        execute("INSERT INTO %s (pk, static_col) VALUES (?, ?)", 1, 1);
-
-        assertRows(execute("DELETE static_col FROM %s WHERE pk = ? IF static_col = ?", 1, 2), row(false, 1));
-        assertRows(execute("DELETE static_col FROM %s WHERE pk = ? IF static_col = ?", 1, 1), row(true));
-
-        assertRows(execute("SELECT pk, ck, static_col, value FROM %s WHERE pk = 1"),
-                   row(1, 1, null, 2),
-                   row(1, 3, null, 4),
-                   row(1, 5, null, 6),
-                   row(1, 7, null, 8));
-        execute("INSERT INTO %s (pk, static_col) VALUES (?, ?)", 1, 1);
-
-        assertInvalidMessage("Some partition key parts are missing: pk",
-                             "DELETE static_col FROM %s WHERE ck = ? IF static_col = ?", 1, 1);
-
-        assertInvalidMessage("Invalid restrictions on clustering columns since the DELETE statement modifies only static columns",
-                             "DELETE static_col FROM %s WHERE pk = ? AND ck = ? IF static_col = ?", 1, 1, 1);
-
-        assertInvalidMessage("DELETE statements must restrict all PRIMARY KEY columns with equality relations in order to delete non static columns",
-                             "DELETE static_col, value FROM %s WHERE pk = ? IF static_col = ?", 1, 1);
-
-        // Same query but with an invalid condition
-        assertInvalidMessage("DELETE statements must restrict all PRIMARY KEY columns with equality relations in order to delete non static columns",
-                             "DELETE static_col, value FROM %s WHERE pk = ? IF static_col = ?", 1, 2);
-
-        // DELETE of an underspecified PRIMARY KEY should not succeed if static is not only restriction
-        assertInvalidMessage("DELETE statements must restrict all PRIMARY KEY columns with equality relations" +
-                             " in order to use IF condition on non static columns",
-                             "DELETE static_col FROM %s WHERE pk = ? IF value = ? AND static_col = ?", 1, 2, 1);
-
-        assertRows(execute("DELETE value FROM %s WHERE pk = ? AND ck = ? IF value = ? AND static_col = ?", 1, 1, 2, 2), row(false, 2, 1));
-        assertRows(execute("DELETE value FROM %s WHERE pk = ? AND ck = ? IF value = ? AND static_col = ?", 1, 1, 2, 1), row(true));
-        assertRows(execute("SELECT pk, ck, static_col, value FROM %s WHERE pk = 1"),
-                   row(1, 1, 1, null),
-                   row(1, 3, 1, 4),
-                   row(1, 5, 1, 6),
-                   row(1, 7, 1, 8));
-
-        assertRows(execute("DELETE static_col FROM %s WHERE pk = ? AND ck = ? IF value = ?", 1, 5, 10), row(false, 6));
-        assertRows(execute("DELETE static_col FROM %s WHERE pk = ? AND ck = ? IF value = ?", 1, 5, 6), row(true));
-        assertRows(execute("SELECT pk, ck, static_col, value FROM %s WHERE pk = 1"),
-                   row(1, 1, null, null),
-                   row(1, 3, null, 4),
-                   row(1, 5, null, 6),
-                   row(1, 7, null, 8));
-    }
-
-    @Test
-    public void testStaticColumnsCasUpdate() throws Throwable
-    {
-        createTable("CREATE TABLE %s (pk int, ck int, static_col int static, value int, PRIMARY KEY (pk, ck))");
-        execute("INSERT INTO %s (pk, ck, value) VALUES (?, ?, ?)", 1, 1, 2);
-        execute("INSERT INTO %s (pk, ck, value) VALUES (?, ?, ?)", 1, 3, 4);
-        execute("INSERT INTO %s (pk, ck, value) VALUES (?, ?, ?)", 1, 5, 6);
-        execute("INSERT INTO %s (pk, ck, value) VALUES (?, ?, ?)", 1, 7, 8);
-        execute("INSERT INTO %s (pk, ck, value) VALUES (?, ?, ?)", 2, 1, 2);
-        execute("INSERT INTO %s (pk, static_col) VALUES (?, ?)", 1, 1);
-
-        assertRows(execute("UPDATE %s SET static_col = ? WHERE pk = ? IF static_col = ?", 3, 1, 2), row(false, 1));
-        assertRows(execute("UPDATE %s SET static_col = ? WHERE pk = ? IF static_col = ?", 2, 1, 1), row(true));
-
-        assertRows(execute("SELECT pk, ck, static_col, value FROM %s WHERE pk = 1"),
-                   row(1, 1, 2, 2),
-                   row(1, 3, 2, 4),
-                   row(1, 5, 2, 6),
-                   row(1, 7, 2, 8));
-
-        assertInvalidMessage("Some partition key parts are missing: pk",
-                             "UPDATE %s SET static_col = ? WHERE ck = ? IF static_col = ?", 3, 1, 1);
-
-        assertInvalidMessage("Invalid restrictions on clustering columns since the UPDATE statement modifies only static columns",
-                             "UPDATE %s SET static_col = ? WHERE pk = ? AND ck = ? IF static_col = ?", 3, 1, 1, 1);
-
-        assertInvalidMessage("Some clustering keys are missing: ck",
-                             "UPDATE %s SET static_col = ?, value = ? WHERE pk = ? IF static_col = ?", 3, 1, 1, 2);
-
-        // Same query but with an invalid condition
-        assertInvalidMessage("Some clustering keys are missing: ck",
-                             "UPDATE %s SET static_col = ?, value = ? WHERE pk = ? IF static_col = ?", 3, 1, 1, 1);
-
-        assertInvalidMessage("Some clustering keys are missing: ck",
-                             "UPDATE %s SET static_col = ? WHERE pk = ? IF value = ? AND static_col = ?", 3, 1, 4, 2);
-
-        assertRows(execute("UPDATE %s SET value = ? WHERE pk = ? AND ck = ? IF value = ? AND static_col = ?", 3, 1, 1, 3, 2), row(false, 2, 2));
-        assertRows(execute("UPDATE %s SET value = ? WHERE pk = ? AND ck = ? IF value = ? AND static_col = ?", 1, 1, 1, 2, 2), row(true));
-        assertRows(execute("SELECT pk, ck, static_col, value FROM %s WHERE pk = 1"),
-                   row(1, 1, 2, 1),
-                   row(1, 3, 2, 4),
-                   row(1, 5, 2, 6),
-                   row(1, 7, 2, 8));
-
-        assertRows(execute("UPDATE %s SET static_col = ? WHERE pk = ? AND ck = ? IF value = ?", 3, 1, 1, 2), row(false, 1));
-        assertRows(execute("UPDATE %s SET static_col = ? WHERE pk = ? AND ck = ? IF value = ?", 1, 1, 1, 1), row(true));
-        assertRows(execute("SELECT pk, ck, static_col, value FROM %s WHERE pk = 1"),
-                   row(1, 1, 1, 1),
-                   row(1, 3, 1, 4),
-                   row(1, 5, 1, 6),
-                   row(1, 7, 1, 8));
-    }
-
-    /**
-     * Migrated from cql_tests.py:TestCQL.bug_6069_test()
-     */
-    @Test
-    public void testInsertSetIfNotExists() throws Throwable
-    {
-        createTable("CREATE TABLE %s (k int PRIMARY KEY, s set<int>)");
-
-        assertRows(execute("INSERT INTO %s (k, s) VALUES (0, {1, 2, 3}) IF NOT EXISTS"),
-                   row(true));
-        assertRows(execute("SELECT * FROM %s "), row(0, set(1, 2, 3)));
-    }
-
     /**
      * Migrated from cql_tests.py:TestCQL.cas_and_ttl_test()
      */
@@ -596,782 +357,7 @@ public class InsertUpdateIfConditionTest extends CQLTester
         Thread.sleep(1001);
         assertRows(execute("UPDATE %s SET v = 1 WHERE k = 0 IF lock = null"),
                    row(true));
-    }
-
-    @Test
-    public void testWholeUDT() throws Throwable
-    {
-        String typename = createType("CREATE TYPE %s (a int, b text)");
-        String myType = KEYSPACE + '.' + typename;
-
-        for (boolean frozen : new boolean[] {false, true})
-        {
-            createTable(String.format("CREATE TABLE %%s (k int PRIMARY KEY, v %s)",
-                                      frozen
-                                      ? "frozen<" + myType + ">"
-                                      : myType));
-
-            Object v = userType("a", 0, "b", "abc");
-            execute("INSERT INTO %s (k, v) VALUES (0, ?)", v);
-
-            checkAppliesUDT("v = {a: 0, b: 'abc'}", v);
-            checkAppliesUDT("v != null", v);
-            checkAppliesUDT("v != {a: 1, b: 'abc'}", v);
-            checkAppliesUDT("v != {a: 0, b: 'def'}", v);
-            checkAppliesUDT("v > {a: -1, b: 'abc'}", v);
-            checkAppliesUDT("v > {a: 0, b: 'aaa'}", v);
-            checkAppliesUDT("v > {a: 0}", v);
-            checkAppliesUDT("v >= {a: 0, b: 'aaa'}", v);
-            checkAppliesUDT("v >= {a: 0, b: 'abc'}", v);
-            checkAppliesUDT("v < {a: 0, b: 'zzz'}", v);
-            checkAppliesUDT("v < {a: 1, b: 'abc'}", v);
-            checkAppliesUDT("v < {a: 1}", v);
-            checkAppliesUDT("v <= {a: 0, b: 'zzz'}", v);
-            checkAppliesUDT("v <= {a: 0, b: 'abc'}", v);
-            checkAppliesUDT("v IN (null, {a: 0, b: 'abc'}, {a: 1})", v);
-
-            // multiple conditions
-            checkAppliesUDT("v > {a: -1, b: 'abc'} AND v > {a: 0}", v);
-            checkAppliesUDT("v != null AND v IN ({a: 0, b: 'abc'})", v);
-
-            // should not apply
-            checkDoesNotApplyUDT("v = {a: 0, b: 'def'}", v);
-            checkDoesNotApplyUDT("v = {a: 1, b: 'abc'}", v);
-            checkDoesNotApplyUDT("v = null", v);
-            checkDoesNotApplyUDT("v != {a: 0, b: 'abc'}", v);
-            checkDoesNotApplyUDT("v > {a: 1, b: 'abc'}", v);
-            checkDoesNotApplyUDT("v > {a: 0, b: 'zzz'}", v);
-            checkDoesNotApplyUDT("v >= {a: 1, b: 'abc'}", v);
-            checkDoesNotApplyUDT("v >= {a: 0, b: 'zzz'}", v);
-            checkDoesNotApplyUDT("v < {a: -1, b: 'abc'}", v);
-            checkDoesNotApplyUDT("v < {a: 0, b: 'aaa'}", v);
-            checkDoesNotApplyUDT("v <= {a: -1, b: 'abc'}", v);
-            checkDoesNotApplyUDT("v <= {a: 0, b: 'aaa'}", v);
-            checkDoesNotApplyUDT("v IN ({a: 0}, {b: 'abc'}, {a: 0, b: 'def'}, null)", v);
-            checkDoesNotApplyUDT("v IN ()", v);
-
-            // multiple conditions
-            checkDoesNotApplyUDT("v IN () AND v IN ({a: 0, b: 'abc'})", v);
-            checkDoesNotApplyUDT("v > {a: 0, b: 'aaa'} AND v < {a: 0, b: 'aaa'}", v);
-
-            // invalid conditions
-            checkInvalidUDT("v = {a: 1, b: 'abc', c: 'foo'}", v, InvalidRequestException.class);
-            checkInvalidUDT("v = {foo: 'foo'}", v, InvalidRequestException.class);
-            checkInvalidUDT("v < {a: 1, b: 'abc', c: 'foo'}", v, InvalidRequestException.class);
-            checkInvalidUDT("v < null", v, InvalidRequestException.class);
-            checkInvalidUDT("v <= {a: 1, b: 'abc', c: 'foo'}", v, InvalidRequestException.class);
-            checkInvalidUDT("v <= null", v, InvalidRequestException.class);
-            checkInvalidUDT("v > {a: 1, b: 'abc', c: 'foo'}", v, InvalidRequestException.class);
-            checkInvalidUDT("v > null", v, InvalidRequestException.class);
-            checkInvalidUDT("v >= {a: 1, b: 'abc', c: 'foo'}", v, InvalidRequestException.class);
-            checkInvalidUDT("v >= null", v, InvalidRequestException.class);
-            checkInvalidUDT("v IN null", v, SyntaxException.class);
-            checkInvalidUDT("v IN 367", v, SyntaxException.class);
-            checkInvalidUDT("v CONTAINS KEY 123", v, SyntaxException.class);
-            checkInvalidUDT("v CONTAINS 'bar'", v, SyntaxException.class);
-
-
-            /////////////////// null suffix on stored udt ////////////////////
-            v = userType("a", 0, "b", null);
-            execute("INSERT INTO %s (k, v) VALUES (0, ?)", v);
-
-            checkAppliesUDT("v = {a: 0}", v);
-            checkAppliesUDT("v = {a: 0, b: null}", v);
-            checkAppliesUDT("v != null", v);
-            checkAppliesUDT("v != {a: 1, b: null}", v);
-            checkAppliesUDT("v != {a: 1}", v);
-            checkAppliesUDT("v != {a: 0, b: 'def'}", v);
-            checkAppliesUDT("v > {a: -1, b: 'abc'}", v);
-            checkAppliesUDT("v > {a: -1}", v);
-            checkAppliesUDT("v >= {a: 0}", v);
-            checkAppliesUDT("v >= {a: -1, b: 'abc'}", v);
-            checkAppliesUDT("v < {a: 0, b: 'zzz'}", v);
-            checkAppliesUDT("v < {a: 1, b: 'abc'}", v);
-            checkAppliesUDT("v < {a: 1}", v);
-            checkAppliesUDT("v <= {a: 0, b: 'zzz'}", v);
-            checkAppliesUDT("v <= {a: 0}", v);
-            checkAppliesUDT("v IN (null, {a: 0, b: 'abc'}, {a: 0})", v);
-
-            // multiple conditions
-            checkAppliesUDT("v > {a: -1, b: 'abc'} AND v >= {a: 0}", v);
-            checkAppliesUDT("v != null AND v IN ({a: 0}, {a: 0, b: null})", v);
-
-            // should not apply
-            checkDoesNotApplyUDT("v = {a: 0, b: 'def'}", v);
-            checkDoesNotApplyUDT("v = {a: 1}", v);
-            checkDoesNotApplyUDT("v = {b: 'abc'}", v);
-            checkDoesNotApplyUDT("v = null", v);
-            checkDoesNotApplyUDT("v != {a: 0}", v);
-            checkDoesNotApplyUDT("v != {a: 0, b: null}", v);
-            checkDoesNotApplyUDT("v > {a: 1, b: 'abc'}", v);
-            checkDoesNotApplyUDT("v > {a: 0}", v);
-            checkDoesNotApplyUDT("v >= {a: 1, b: 'abc'}", v);
-            checkDoesNotApplyUDT("v >= {a: 1}", v);
-            checkDoesNotApplyUDT("v < {a: -1, b: 'abc'}", v);
-            checkDoesNotApplyUDT("v < {a: -1}", v);
-            checkDoesNotApplyUDT("v < {a: 0}", v);
-            checkDoesNotApplyUDT("v <= {a: -1, b: 'abc'}", v);
-            checkDoesNotApplyUDT("v <= {a: -1}", v);
-            checkDoesNotApplyUDT("v IN ({a: 1}, {b: 'abc'}, {a: 0, b: 'def'}, null)", v);
-            checkDoesNotApplyUDT("v IN ()", v);
-
-            // multiple conditions
-            checkDoesNotApplyUDT("v IN () AND v IN ({a: 0})", v);
-            checkDoesNotApplyUDT("v > {a: -1} AND v < {a: 0}", v);
-
-
-            /////////////////// null prefix on stored udt ////////////////////
-            v = userType("a", null, "b", "abc");
-            execute("INSERT INTO %s (k, v) VALUES (0, ?)", v);
-
-            checkAppliesUDT("v = {a: null, b: 'abc'}", v);
-            checkAppliesUDT("v = {b: 'abc'}", v);
-            checkAppliesUDT("v != null", v);
-            checkAppliesUDT("v != {a: 0, b: 'abc'}", v);
-            checkAppliesUDT("v != {a: 0}", v);
-            checkAppliesUDT("v != {b: 'def'}", v);
-            checkAppliesUDT("v > {a: null, b: 'aaa'}", v);
-            checkAppliesUDT("v > {b: 'aaa'}", v);
-            checkAppliesUDT("v >= {a: null, b: 'aaa'}", v);
-            checkAppliesUDT("v >= {b: 'abc'}", v);
-            checkAppliesUDT("v < {a: null, b: 'zzz'}", v);
-            checkAppliesUDT("v < {a: 0, b: 'abc'}", v);
-            checkAppliesUDT("v < {a: 0}", v);
-            checkAppliesUDT("v < {b: 'zzz'}", v);
-            checkAppliesUDT("v <= {a: null, b: 'zzz'}", v);
-            checkAppliesUDT("v <= {a: 0}", v);
-            checkAppliesUDT("v <= {b: 'abc'}", v);
-            checkAppliesUDT("v IN (null, {a: null, b: 'abc'}, {a: 0})", v);
-            checkAppliesUDT("v IN (null, {a: 0, b: 'abc'}, {b: 'abc'})", v);
-
-            // multiple conditions
-            checkAppliesUDT("v > {b: 'aaa'} AND v >= {b: 'abc'}", v);
-            checkAppliesUDT("v != null AND v IN ({a: 0}, {a: null, b: 'abc'})", v);
-
-            // should not apply
-            checkDoesNotApplyUDT("v = {a: 0, b: 'def'}", v);
-            checkDoesNotApplyUDT("v = {a: 1}", v);
-            checkDoesNotApplyUDT("v = {b: 'def'}", v);
-            checkDoesNotApplyUDT("v = null", v);
-            checkDoesNotApplyUDT("v != {b: 'abc'}", v);
-            checkDoesNotApplyUDT("v != {a: null, b: 'abc'}", v);
-            checkDoesNotApplyUDT("v > {a: 1, b: 'abc'}", v);
-            checkDoesNotApplyUDT("v > {a: null, b: 'zzz'}", v);
-            checkDoesNotApplyUDT("v > {b: 'zzz'}", v);
-            checkDoesNotApplyUDT("v >= {a: null, b: 'zzz'}", v);
-            checkDoesNotApplyUDT("v >= {a: 1}", v);
-            checkDoesNotApplyUDT("v >= {b: 'zzz'}", v);
-            checkDoesNotApplyUDT("v < {a: null, b: 'aaa'}", v);
-            checkDoesNotApplyUDT("v < {b: 'aaa'}", v);
-            checkDoesNotApplyUDT("v <= {a: null, b: 'aaa'}", v);
-            checkDoesNotApplyUDT("v <= {b: 'aaa'}", v);
-            checkDoesNotApplyUDT("v IN ({a: 1}, {a: 1, b: 'abc'}, {a: null, b: 'def'}, null)", v);
-            checkDoesNotApplyUDT("v IN ()", v);
-
-            // multiple conditions
-            checkDoesNotApplyUDT("v IN () AND v IN ({b: 'abc'})", v);
-            checkDoesNotApplyUDT("v IN () AND v IN ({a: null, b: 'abc'})", v);
-            checkDoesNotApplyUDT("v > {a: -1} AND v < {a: 0}", v);
-
-
-            /////////////////// null udt ////////////////////
-            v = null;
-            execute("INSERT INTO %s (k, v) VALUES (0, ?)", v);
-
-            checkAppliesUDT("v = null", v);
-            checkAppliesUDT("v IN (null, {a: null, b: 'abc'}, {a: 0})", v);
-            checkAppliesUDT("v IN (null, {a: 0, b: 'abc'}, {b: 'abc'})", v);
-
-            // multiple conditions
-            checkAppliesUDT("v = null AND v IN (null, {a: 0}, {a: null, b: 'abc'})", v);
-
-            // should not apply
-            checkDoesNotApplyUDT("v = {a: 0, b: 'def'}", v);
-            checkDoesNotApplyUDT("v = {a: 1}", v);
-            checkDoesNotApplyUDT("v = {b: 'def'}", v);
-            checkDoesNotApplyUDT("v != null", v);
-            checkDoesNotApplyUDT("v > {a: 1, b: 'abc'}", v);
-            checkDoesNotApplyUDT("v > {a: null, b: 'zzz'}", v);
-            checkDoesNotApplyUDT("v > {b: 'zzz'}", v);
-            checkDoesNotApplyUDT("v >= {a: null, b: 'zzz'}", v);
-            checkDoesNotApplyUDT("v >= {a: 1}", v);
-            checkDoesNotApplyUDT("v >= {b: 'zzz'}", v);
-            checkDoesNotApplyUDT("v < {a: null, b: 'aaa'}", v);
-            checkDoesNotApplyUDT("v < {b: 'aaa'}", v);
-            checkDoesNotApplyUDT("v <= {a: null, b: 'aaa'}", v);
-            checkDoesNotApplyUDT("v <= {b: 'aaa'}", v);
-            checkDoesNotApplyUDT("v IN ({a: 1}, {a: 1, b: 'abc'}, {a: null, b: 'def'})", v);
-            checkDoesNotApplyUDT("v IN ()", v);
-
-            // multiple conditions
-            checkDoesNotApplyUDT("v IN () AND v IN ({b: 'abc'})", v);
-            checkDoesNotApplyUDT("v > {a: -1} AND v < {a: 0}", v);
-
-        }
-    }
-
-    @Test
-    public void testUDTField() throws Throwable
-    {
-        String typename = createType("CREATE TYPE %s (a int, b text)");
-        String myType = KEYSPACE + '.' + typename;
-
-        for (boolean frozen : new boolean[] {false, true})
-        {
-            createTable(String.format("CREATE TABLE %%s (k int PRIMARY KEY, v %s)",
-                                      frozen
-                                      ? "frozen<" + myType + ">"
-                                      : myType));
-
-            Object v = userType("a", 0, "b", "abc");
-            execute("INSERT INTO %s (k, v) VALUES (0, ?)", v);
-
-            checkAppliesUDT("v.a = 0", v);
-            checkAppliesUDT("v.b = 'abc'", v);
-            checkAppliesUDT("v.a < 1", v);
-            checkAppliesUDT("v.b < 'zzz'", v);
-            checkAppliesUDT("v.b <= 'bar'", v);
-            checkAppliesUDT("v.b > 'aaa'", v);
-            checkAppliesUDT("v.b >= 'abc'", v);
-            checkAppliesUDT("v.a != -1", v);
-            checkAppliesUDT("v.b != 'xxx'", v);
-            checkAppliesUDT("v.a != null", v);
-            checkAppliesUDT("v.b != null", v);
-            checkAppliesUDT("v.a IN (null, 0, 1)", v);
-            checkAppliesUDT("v.b IN (null, 'xxx', 'abc')", v);
-            checkAppliesUDT("v.b > 'aaa' AND v.b < 'zzz'", v);
-            checkAppliesUDT("v.a = 0 AND v.b > 'aaa'", v);
-
-            // do not apply
-            checkDoesNotApplyUDT("v.a = -1", v);
-            checkDoesNotApplyUDT("v.b = 'xxx'", v);
-            checkDoesNotApplyUDT("v.a < -1", v);
-            checkDoesNotApplyUDT("v.b < 'aaa'", v);
-            checkDoesNotApplyUDT("v.b <= 'aaa'", v);
-            checkDoesNotApplyUDT("v.b > 'zzz'", v);
-            checkDoesNotApplyUDT("v.b >= 'zzz'", v);
-            checkDoesNotApplyUDT("v.a != 0", v);
-            checkDoesNotApplyUDT("v.b != 'abc'", v);
-            checkDoesNotApplyUDT("v.a IN (null, -1)", v);
-            checkDoesNotApplyUDT("v.b IN (null, 'xxx')", v);
-            checkDoesNotApplyUDT("v.a IN ()", v);
-            checkDoesNotApplyUDT("v.b IN ()", v);
-            checkDoesNotApplyUDT("v.b != null AND v.b IN ()", v);
-
-            // invalid
-            checkInvalidUDT("v.c = null", v, InvalidRequestException.class);
-            checkInvalidUDT("v.a < null", v, InvalidRequestException.class);
-            checkInvalidUDT("v.a <= null", v, InvalidRequestException.class);
-            checkInvalidUDT("v.a > null", v, InvalidRequestException.class);
-            checkInvalidUDT("v.a >= null", v, InvalidRequestException.class);
-            checkInvalidUDT("v.a IN null", v, SyntaxException.class);
-            checkInvalidUDT("v.a IN 367", v, SyntaxException.class);
-            checkInvalidUDT("v.b IN (1, 2, 3)", v, InvalidRequestException.class);
-            checkInvalidUDT("v.a CONTAINS 367", v, SyntaxException.class);
-            checkInvalidUDT("v.a CONTAINS KEY 367", v, SyntaxException.class);
-
-
-            /////////////// null suffix on udt ////////////////
-            v = userType("a", 0, "b", null);
-            execute("INSERT INTO %s (k, v) VALUES (0, ?)", v);
-
-            checkAppliesUDT("v.a = 0", v);
-            checkAppliesUDT("v.b = null", v);
-            checkAppliesUDT("v.b != 'xxx'", v);
-            checkAppliesUDT("v.a != null", v);
-            checkAppliesUDT("v.a IN (null, 0, 1)", v);
-            checkAppliesUDT("v.b IN (null, 'xxx', 'abc')", v);
-            checkAppliesUDT("v.a = 0 AND v.b = null", v);
-
-            // do not apply
-            checkDoesNotApplyUDT("v.b = 'abc'", v);
-            checkDoesNotApplyUDT("v.a < -1", v);
-            checkDoesNotApplyUDT("v.b < 'aaa'", v);
-            checkDoesNotApplyUDT("v.b <= 'aaa'", v);
-            checkDoesNotApplyUDT("v.b > 'zzz'", v);
-            checkDoesNotApplyUDT("v.b >= 'zzz'", v);
-            checkDoesNotApplyUDT("v.a != 0", v);
-            checkDoesNotApplyUDT("v.b != null", v);
-            checkDoesNotApplyUDT("v.a IN (null, -1)", v);
-            checkDoesNotApplyUDT("v.b IN ('xxx', 'abc')", v);
-            checkDoesNotApplyUDT("v.a IN ()", v);
-            checkDoesNotApplyUDT("v.b IN ()", v);
-            checkDoesNotApplyUDT("v.b != null AND v.b IN ()", v);
-
-
-            /////////////// null prefix on udt ////////////////
-            v = userType("a", null, "b", "abc");
-            execute("INSERT INTO %s (k, v) VALUES (0, ?)", v);
-
-            checkAppliesUDT("v.a = null", v);
-            checkAppliesUDT("v.b = 'abc'", v);
-            checkAppliesUDT("v.a != 0", v);
-            checkAppliesUDT("v.b != null", v);
-            checkAppliesUDT("v.a IN (null, 0, 1)", v);
-            checkAppliesUDT("v.b IN (null, 'xxx', 'abc')", v);
-            checkAppliesUDT("v.a = null AND v.b = 'abc'", v);
-
-            // do not apply
-            checkDoesNotApplyUDT("v.a = 0", v);
-            checkDoesNotApplyUDT("v.a < -1", v);
-            checkDoesNotApplyUDT("v.b >= 'zzz'", v);
-            checkDoesNotApplyUDT("v.a != null", v);
-            checkDoesNotApplyUDT("v.b != 'abc'", v);
-            checkDoesNotApplyUDT("v.a IN (-1, 0)", v);
-            checkDoesNotApplyUDT("v.b IN (null, 'xxx')", v);
-            checkDoesNotApplyUDT("v.a IN ()", v);
-            checkDoesNotApplyUDT("v.b IN ()", v);
-            checkDoesNotApplyUDT("v.b != null AND v.b IN ()", v);
-
-
-            /////////////// null udt ////////////////
-            v = null;
-            execute("INSERT INTO %s (k, v) VALUES (0, ?)", v);
-
-            checkAppliesUDT("v.a = null", v);
-            checkAppliesUDT("v.b = null", v);
-            checkAppliesUDT("v.a != 0", v);
-            checkAppliesUDT("v.b != 'abc'", v);
-            checkAppliesUDT("v.a IN (null, 0, 1)", v);
-            checkAppliesUDT("v.b IN (null, 'xxx', 'abc')", v);
-            checkAppliesUDT("v.a = null AND v.b = null", v);
-
-            // do not apply
-            checkDoesNotApplyUDT("v.a = 0", v);
-            checkDoesNotApplyUDT("v.a < -1", v);
-            checkDoesNotApplyUDT("v.b >= 'zzz'", v);
-            checkDoesNotApplyUDT("v.a != null", v);
-            checkDoesNotApplyUDT("v.b != null", v);
-            checkDoesNotApplyUDT("v.a IN (-1, 0)", v);
-            checkDoesNotApplyUDT("v.b IN ('xxx', 'abc')", v);
-            checkDoesNotApplyUDT("v.a IN ()", v);
-            checkDoesNotApplyUDT("v.b IN ()", v);
-            checkDoesNotApplyUDT("v.b != null AND v.b IN ()", v);
-        }
-    }
-
-    void checkAppliesUDT(String condition, Object value) throws Throwable
-    {
-        assertRows(execute("UPDATE %s SET v = ? WHERE k = 0 IF " + condition, value), row(true));
-        assertRows(execute("SELECT * FROM %s"), row(0, value));
-    }
-
-    void checkDoesNotApplyUDT(String condition, Object value) throws Throwable
-    {
-        assertRows(execute("UPDATE %s SET v = ? WHERE k = 0 IF " + condition, value),
-                   row(false, value));
-        assertRows(execute("SELECT * FROM %s"), row(0, value));
-    }
-
-    void checkInvalidUDT(String condition, Object value, Class<? extends Throwable> expected) throws Throwable
-    {
-        assertInvalidThrow(expected, "UPDATE %s SET v = ?  WHERE k = 0 IF " + condition, value);
-        assertRows(execute("SELECT * FROM %s"), row(0, value));
-    }
-
-    /**
-     * Migrated from cql_tests.py:TestCQL.whole_list_conditional_test()
-     */
-    @Test
-    public void testWholeList() throws Throwable
-    {
-        for (boolean frozen : new boolean[] {false, true})
-        {
-            createTable(String.format("CREATE TABLE %%s (k int PRIMARY KEY, l %s)",
-                                      frozen
-                                      ? "frozen<list<text>>"
-                                      : "list<text>"));
-
-            execute("INSERT INTO %s(k, l) VALUES (0, ['foo', 'bar', 'foobar'])");
-
-            check_applies_list("l = ['foo', 'bar', 'foobar']");
-            check_applies_list("l != ['baz']");
-            check_applies_list("l > ['a']");
-            check_applies_list("l >= ['a']");
-            check_applies_list("l < ['z']");
-            check_applies_list("l <= ['z']");
-            check_applies_list("l IN (null, ['foo', 'bar', 'foobar'], ['a'])");
-
-            // multiple conditions
-            check_applies_list("l > ['aaa', 'bbb'] AND l > ['aaa']");
-            check_applies_list("l != null AND l IN (['foo', 'bar', 'foobar'])");
-
-            // should not apply
-            check_does_not_apply_list("l = ['baz']");
-            check_does_not_apply_list("l != ['foo', 'bar', 'foobar']");
-            check_does_not_apply_list("l > ['z']");
-            check_does_not_apply_list("l >= ['z']");
-            check_does_not_apply_list("l < ['a']");
-            check_does_not_apply_list("l <= ['a']");
-            check_does_not_apply_list("l IN (['a'], null)");
-            check_does_not_apply_list("l IN ()");
-
-            // multiple conditions
-            check_does_not_apply_list("l IN () AND l IN (['foo', 'bar', 'foobar'])");
-            check_does_not_apply_list("l > ['zzz'] AND l < ['zzz']");
-
-            check_invalid_list("l = [null]", InvalidRequestException.class);
-            check_invalid_list("l < null", InvalidRequestException.class);
-            check_invalid_list("l <= null", InvalidRequestException.class);
-            check_invalid_list("l > null", InvalidRequestException.class);
-            check_invalid_list("l >= null", InvalidRequestException.class);
-            check_invalid_list("l IN null", SyntaxException.class);
-            check_invalid_list("l IN 367", SyntaxException.class);
-            check_invalid_list("l CONTAINS KEY 123", SyntaxException.class);
-
-            // not supported yet
-            check_invalid_list("m CONTAINS 'bar'", SyntaxException.class);
-        }
-    }
-
-    void check_applies_list(String condition) throws Throwable
-    {
-        assertRows(execute("UPDATE %s SET l = ['foo', 'bar', 'foobar'] WHERE k=0 IF " + condition), row(true));
-        assertRows(execute("SELECT * FROM %s"), row(0, list("foo", "bar", "foobar")));
-    }
-
-    void check_does_not_apply_list(String condition) throws Throwable
-    {
-        assertRows(execute("UPDATE %s SET l = ['foo', 'bar', 'foobar'] WHERE k=0 IF " + condition),
-                   row(false, list("foo", "bar", "foobar")));
-        assertRows(execute("SELECT * FROM %s"), row(0, list("foo", "bar", "foobar")));
-    }
-
-    void check_invalid_list(String condition, Class<? extends Throwable> expected) throws Throwable
-    {
-        assertInvalidThrow(expected, "UPDATE %s SET l = ['foo', 'bar', 'foobar'] WHERE k=0 IF " + condition);
-        assertRows(execute("SELECT * FROM %s"), row(0, list("foo", "bar", "foobar")));
-    }
-
-    /**
-     * Migrated from cql_tests.py:TestCQL.list_item_conditional_test()
-     */
-    @Test
-    public void testListItem() throws Throwable
-    {
-        for (boolean frozen : new boolean[]{ false, true })
-        {
-            createTable(String.format("CREATE TABLE %%s (k int PRIMARY KEY, l %s)",
-                                      frozen
-                                      ? "frozen<list<text>>"
-                                      : "list<text>"));
-
-            execute("INSERT INTO %s(k, l) VALUES (0, ['foo', 'bar', 'foobar'])");
-
-            assertInvalidMessage("Invalid null value for list element access",
-                                 "DELETE FROM %s WHERE k=0 IF l[?] = ?", null, "foobar");
-            assertInvalidMessage("Invalid negative list index -2",
-                                 "DELETE FROM %s WHERE k=0 IF l[?] = ?", -2, "foobar");
-
-            assertRows(execute("DELETE FROM %s WHERE k=0 IF l[?] = ?", 1, null), row(false, list("foo", "bar", "foobar")));
-            assertRows(execute("DELETE FROM %s WHERE k=0 IF l[?] = ?", 1, "foobar"), row(false, list("foo", "bar", "foobar")));
-            assertRows(execute("SELECT * FROM %s"), row(0, list("foo", "bar", "foobar")));
-
-            assertRows(execute("DELETE FROM %s WHERE k=0 IF l[?] = ?", 1, "bar"), row(true));
-            assertEmpty(execute("SELECT * FROM %s"));
-        }
-    }
-
-    /**
-     * Test expanded functionality from CASSANDRA-6839,
-     * migrated from cql_tests.py:TestCQL.expanded_list_item_conditional_test()
-     */
-    @Test
-    public void testExpandedListItem() throws Throwable
-    {
-        for (boolean frozen : new boolean[] {false, true})
-        {
-            createTable(String.format("CREATE TABLE %%s (k int PRIMARY KEY, l %s)",
-                                      frozen
-                                      ? "frozen<list<text>>"
-                                      : "list<text>"));
-
-            execute("INSERT INTO %s (k, l) VALUES (0, ['foo', 'bar', 'foobar'])");
-
-            check_applies_list("l[1] < 'zzz'");
-            check_applies_list("l[1] <= 'bar'");
-            check_applies_list("l[1] > 'aaa'");
-            check_applies_list("l[1] >= 'bar'");
-            check_applies_list("l[1] != 'xxx'");
-            check_applies_list("l[1] != null");
-            check_applies_list("l[1] IN (null, 'xxx', 'bar')");
-            check_applies_list("l[1] > 'aaa' AND l[1] < 'zzz'");
-
-            // check beyond end of list
-            check_applies_list("l[3] = null");
-            check_applies_list("l[3] IN (null, 'xxx', 'bar')");
-
-            check_does_not_apply_list("l[1] < 'aaa'");
-            check_does_not_apply_list("l[1] <= 'aaa'");
-            check_does_not_apply_list("l[1] > 'zzz'");
-            check_does_not_apply_list("l[1] >= 'zzz'");
-            check_does_not_apply_list("l[1] != 'bar'");
-            check_does_not_apply_list("l[1] IN (null, 'xxx')");
-            check_does_not_apply_list("l[1] IN ()");
-            check_does_not_apply_list("l[1] != null AND l[1] IN ()");
-
-            // check beyond end of list
-            check_does_not_apply_list("l[3] != null");
-            check_does_not_apply_list("l[3] = 'xxx'");
-
-            check_invalid_list("l[1] < null", InvalidRequestException.class);
-            check_invalid_list("l[1] <= null", InvalidRequestException.class);
-            check_invalid_list("l[1] > null", InvalidRequestException.class);
-            check_invalid_list("l[1] >= null", InvalidRequestException.class);
-            check_invalid_list("l[1] IN null", SyntaxException.class);
-            check_invalid_list("l[1] IN 367", SyntaxException.class);
-            check_invalid_list("l[1] IN (1, 2, 3)", InvalidRequestException.class);
-            check_invalid_list("l[1] CONTAINS 367", SyntaxException.class);
-            check_invalid_list("l[1] CONTAINS KEY 367", SyntaxException.class);
-            check_invalid_list("l[null] = null", InvalidRequestException.class);
-        }
-    }
-
-    /**
-     * Migrated from cql_tests.py:TestCQL.whole_set_conditional_test()
-     */
-    @Test
-    public void testWholeSet() throws Throwable
-    {
-        for (boolean frozen : new boolean[] {false, true})
-        {
-            createTable(String.format("CREATE TABLE %%s (k int PRIMARY KEY, s %s)",
-                                      frozen
-                                      ? "frozen<set<text>>"
-                                      : "set<text>"));
-
-            execute("INSERT INTO %s (k, s) VALUES (0, {'bar', 'foo'})");
-
-            check_applies_set("s = {'bar', 'foo'}");
-            check_applies_set("s = {'foo', 'bar'}");
-            check_applies_set("s != {'baz'}");
-            check_applies_set("s > {'a'}");
-            check_applies_set("s >= {'a'}");
-            check_applies_set("s < {'z'}");
-            check_applies_set("s <= {'z'}");
-            check_applies_set("s IN (null, {'bar', 'foo'}, {'a'})");
-
-            // multiple conditions
-            check_applies_set("s > {'a'} AND s < {'z'}");
-            check_applies_set("s IN (null, {'bar', 'foo'}, {'a'}) AND s IN ({'a'}, {'bar', 'foo'}, null)");
-
-            // should not apply
-            check_does_not_apply_set("s = {'baz'}");
-            check_does_not_apply_set("s != {'bar', 'foo'}");
-            check_does_not_apply_set("s > {'z'}");
-            check_does_not_apply_set("s >= {'z'}");
-            check_does_not_apply_set("s < {'a'}");
-            check_does_not_apply_set("s <= {'a'}");
-            check_does_not_apply_set("s IN ({'a'}, null)");
-            check_does_not_apply_set("s IN ()");
-            check_does_not_apply_set("s != null AND s IN ()");
-
-            check_invalid_set("s = {null}", InvalidRequestException.class);
-            check_invalid_set("s < null", InvalidRequestException.class);
-            check_invalid_set("s <= null", InvalidRequestException.class);
-            check_invalid_set("s > null", InvalidRequestException.class);
-            check_invalid_set("s >= null", InvalidRequestException.class);
-            check_invalid_set("s IN null", SyntaxException.class);
-            check_invalid_set("s IN 367", SyntaxException.class);
-            check_invalid_set("s CONTAINS KEY 123", SyntaxException.class);
-
-            // element access is not allow for sets
-            check_invalid_set("s['foo'] = 'foobar'", InvalidRequestException.class);
-
-            // not supported yet
-            check_invalid_set("m CONTAINS 'bar'", SyntaxException.class);
-        }
-    }
-
-    void check_applies_set(String condition) throws Throwable
-    {
-        assertRows(execute("UPDATE %s SET s = {'bar', 'foo'} WHERE k=0 IF " + condition), row(true));
-        assertRows(execute("SELECT * FROM %s"), row(0, set("bar", "foo")));
-    }
-
-    void check_does_not_apply_set(String condition) throws Throwable
-    {
-        assertRows(execute("UPDATE %s SET s = {'bar', 'foo'} WHERE k=0 IF " + condition), row(false, set("bar", "foo")));
-        assertRows(execute("SELECT * FROM %s"), row(0, set("bar", "foo")));
-    }
-
-    void check_invalid_set(String condition, Class<? extends Throwable> expected) throws Throwable
-    {
-        assertInvalidThrow(expected, "UPDATE %s SET s = {'bar', 'foo'} WHERE k=0 IF " + condition);
-        assertRows(execute("SELECT * FROM %s"), row(0, set("bar", "foo")));
-    }
-
-    /**
-     * Migrated from cql_tests.py:TestCQL.whole_map_conditional_test()
-     */
-    @Test
-    public void testWholeMap() throws Throwable
-    {
-        for (boolean frozen : new boolean[] {false, true})
-        {
-            createTable(String.format("CREATE TABLE %%s (k int PRIMARY KEY, m %s)",
-                                      frozen
-                                      ? "frozen<map<text, text>>"
-                                      : "map<text, text>"));
-
-            execute("INSERT INTO %s (k, m) VALUES (0, {'foo' : 'bar'})");
-
-            check_applies_map("m = {'foo': 'bar'}");
-            check_applies_map("m > {'a': 'a'}");
-            check_applies_map("m >= {'a': 'a'}");
-            check_applies_map("m < {'z': 'z'}");
-            check_applies_map("m <= {'z': 'z'}");
-            check_applies_map("m != {'a': 'a'}");
-            check_applies_map("m IN (null, {'a': 'a'}, {'foo': 'bar'})");
-
-            // multiple conditions
-            check_applies_map("m > {'a': 'a'} AND m < {'z': 'z'}");
-            check_applies_map("m != null AND m IN (null, {'a': 'a'}, {'foo': 'bar'})");
-
-            // should not apply
-            check_does_not_apply_map("m = {'a': 'a'}");
-            check_does_not_apply_map("m > {'z': 'z'}");
-            check_does_not_apply_map("m >= {'z': 'z'}");
-            check_does_not_apply_map("m < {'a': 'a'}");
-            check_does_not_apply_map("m <= {'a': 'a'}");
-            check_does_not_apply_map("m != {'foo': 'bar'}");
-            check_does_not_apply_map("m IN ({'a': 'a'}, null)");
-            check_does_not_apply_map("m IN ()");
-            check_does_not_apply_map("m = null AND m != null");
-
-            check_invalid_map("m = {null: null}", InvalidRequestException.class);
-            check_invalid_map("m = {'a': null}", InvalidRequestException.class);
-            check_invalid_map("m = {null: 'a'}", InvalidRequestException.class);
-            check_invalid_map("m < null", InvalidRequestException.class);
-            check_invalid_map("m IN null", SyntaxException.class);
-
-            // not supported yet
-            check_invalid_map("m CONTAINS 'bar'", SyntaxException.class);
-            check_invalid_map("m CONTAINS KEY 'foo'", SyntaxException.class);
-            check_invalid_map("m CONTAINS null", SyntaxException.class);
-            check_invalid_map("m CONTAINS KEY null", SyntaxException.class);
-        }
-    }
-
-    /**
-     * Migrated from cql_tests.py:TestCQL.map_item_conditional_test()
-     */
-    @Test
-    public void testMapItem() throws Throwable
-    {
-        for (boolean frozen : new boolean[]{ false, true })
-        {
-            createTable(String.format("CREATE TABLE %%s (k int PRIMARY KEY, m %s)",
-                                      frozen
-                                      ? "frozen<map<text, text>>"
-                                      : "map<text, text>"));
-
-            execute("INSERT INTO %s (k, m) VALUES (0, {'foo' : 'bar'})");
-            assertInvalidMessage("Invalid null value for map element access",
-                                 "DELETE FROM %s WHERE k=0 IF m[?] = ?", null, "foo");
-            assertRows(execute("DELETE FROM %s WHERE k=0 IF m[?] = ?", "foo", "foo"), row(false, map("foo", "bar")));
-            assertRows(execute("DELETE FROM %s WHERE k=0 IF m[?] = ?", "foo", null), row(false, map("foo", "bar")));
-            assertRows(execute("SELECT * FROM %s"), row(0, map("foo", "bar")));
-
-            assertRows(execute("DELETE FROM %s WHERE k=0 IF m[?] = ?", "foo", "bar"), row(true));
-            assertEmpty(execute("SELECT * FROM %s"));
-
-            execute("INSERT INTO %s(k, m) VALUES (1, null)");
-            if (frozen)
-                assertInvalidMessage("Invalid operation (m['foo'] = 'bar') for frozen collection column m",
-                                     "UPDATE %s set m['foo'] = 'bar', m['bar'] = 'foo' WHERE k = 1 IF m[?] IN (?, ?)", "foo", "blah", null);
-            else
-                assertRows(execute("UPDATE %s set m['foo'] = 'bar', m['bar'] = 'foo' WHERE k = 1 IF m[?] IN (?, ?)", "foo", "blah", null), row(true));
-        }
-    }
-
-    @Test
-    public void testFrozenWithNullValues() throws Throwable
-    {
-        createTable(String.format("CREATE TABLE %%s (k int PRIMARY KEY, m %s)", "frozen<list<text>>"));
-        execute("INSERT INTO %s (k, m) VALUES (0, null)");
-
-        assertRows(execute("UPDATE %s SET m = ? WHERE k = 0 IF m = ?", list("test"), list("comparison")), row(false, null));
-
-        createTable(String.format("CREATE TABLE %%s (k int PRIMARY KEY, m %s)", "frozen<map<text,int>>"));
-        execute("INSERT INTO %s (k, m) VALUES (0, null)");
-
-        assertRows(execute("UPDATE %s SET m = ? WHERE k = 0 IF m = ?", map("test", 3), map("comparison", 2)), row(false, null));
-
-        createTable(String.format("CREATE TABLE %%s (k int PRIMARY KEY, m %s)", "frozen<set<text>>"));
-        execute("INSERT INTO %s (k, m) VALUES (0, null)");
-
-        assertRows(execute("UPDATE %s SET m = ? WHERE k = 0 IF m = ?", set("test"), set("comparison")), row(false, null));
-    }
-    /**
-     * Test expanded functionality from CASSANDRA-6839,
-     * migrated from cql_tests.py:TestCQL.expanded_map_item_conditional_test()
-     */
-    @Test
-    public void testExpandedMapItem() throws Throwable
-    {
-        for (boolean frozen : new boolean[]{ false, true })
-        {
-            createTable(String.format("CREATE TABLE %%s (k int PRIMARY KEY, m %s)",
-                                      frozen
-                                      ? "frozen<map<text, text>>"
-                                      : "map<text, text>"));
-
-            execute("INSERT INTO %s (k, m) VALUES (0, {'foo' : 'bar'})");
-
-            check_applies_map("m['xxx'] = null");
-            check_applies_map("m['foo'] < 'zzz'");
-            check_applies_map("m['foo'] <= 'bar'");
-            check_applies_map("m['foo'] > 'aaa'");
-            check_applies_map("m['foo'] >= 'bar'");
-            check_applies_map("m['foo'] != 'xxx'");
-            check_applies_map("m['foo'] != null");
-            check_applies_map("m['foo'] IN (null, 'xxx', 'bar')");
-            check_applies_map("m['xxx'] IN (null, 'xxx', 'bar')"); // m['xxx'] is not set
-
-            // multiple conditions
-            check_applies_map("m['foo'] < 'zzz' AND m['foo'] > 'aaa'");
-
-            check_does_not_apply_map("m['foo'] < 'aaa'");
-            check_does_not_apply_map("m['foo'] <= 'aaa'");
-            check_does_not_apply_map("m['foo'] > 'zzz'");
-            check_does_not_apply_map("m['foo'] >= 'zzz'");
-            check_does_not_apply_map("m['foo'] != 'bar'");
-            check_does_not_apply_map("m['xxx'] != null");  // m['xxx'] is not set
-            check_does_not_apply_map("m['foo'] IN (null, 'xxx')");
-            check_does_not_apply_map("m['foo'] IN ()");
-            check_does_not_apply_map("m['foo'] != null AND m['foo'] = null");
-
-            check_invalid_map("m['foo'] < null", InvalidRequestException.class);
-            check_invalid_map("m['foo'] <= null", InvalidRequestException.class);
-            check_invalid_map("m['foo'] > null", InvalidRequestException.class);
-            check_invalid_map("m['foo'] >= null", InvalidRequestException.class);
-            check_invalid_map("m['foo'] IN null", SyntaxException.class);
-            check_invalid_map("m['foo'] IN 367", SyntaxException.class);
-            check_invalid_map("m['foo'] IN (1, 2, 3)", InvalidRequestException.class);
-            check_invalid_map("m['foo'] CONTAINS 367", SyntaxException.class);
-            check_invalid_map("m['foo'] CONTAINS KEY 367", SyntaxException.class);
-            check_invalid_map("m[null] = null", InvalidRequestException.class);
-        }
-    }
-
-    void check_applies_map(String condition) throws Throwable
-    {
-        assertRows(execute("UPDATE %s SET m = {'foo': 'bar'} WHERE k=0 IF " + condition), row(true));
-        assertRows(execute("SELECT * FROM %s"), row(0, map("foo", "bar")));
-    }
-
-    void check_does_not_apply_map(String condition) throws Throwable
-    {
-        assertRows(execute("UPDATE %s SET m = {'foo': 'bar'} WHERE k=0 IF " + condition), row(false, map("foo", "bar")));
-        assertRows(execute("SELECT * FROM %s"), row(0, map("foo", "bar")));
-    }
-
-    void check_invalid_map(String condition, Class<? extends Throwable> expected) throws Throwable
-    {
-        assertInvalidThrow(expected, "UPDATE %s SET m = {'foo': 'bar'} WHERE k=0 IF " + condition);
-        assertRows(execute("SELECT * FROM %s"), row(0, map("foo", "bar")));
-    }
+    } 
 
     /**
      * Test for 7499,
@@ -1428,7 +414,6 @@ public class InsertUpdateIfConditionTest extends CQLTester
                             keyspace));
     }
 
-
     /**
      * Migrated from cql_tests.py:TestCQL.conditional_ddl_table_test()
      */
@@ -1518,41 +503,6 @@ public class InsertUpdateIfConditionTest extends CQLTester
                             "mytype"));
     }
 
-    @Test
-    public void testConditionalUpdatesOnStaticColumns() throws Throwable
-    {
-        createTable("CREATE TABLE %s (a int, b int, s int static, d text, PRIMARY KEY (a, b))");
-
-        assertInvalidMessage("Invalid 'unset' value in condition", "UPDATE %s SET s = 6 WHERE a = 6 IF s = ?", unset());
-
-        // pre-existing row
-        execute("INSERT INTO %s (a, b, s, d) values (6, 6, 100, 'a')");
-        assertRows(execute("UPDATE %s SET s = 6 WHERE a = 6 IF s = 100"),
-                   row(true));
-        assertRows(execute("SELECT * FROM %s WHERE a = 6"),
-                   row(6, 6, 6, "a"));
-
-        execute("INSERT INTO %s (a, b, s, d) values (7, 7, 100, 'a')");
-        assertRows(execute("UPDATE %s SET s = 7 WHERE a = 7 IF s = 101"),
-                   row(false, 100));
-        assertRows(execute("SELECT * FROM %s WHERE a = 7"),
-                   row(7, 7, 100, "a"));
-
-        // pre-existing row with null in the static column
-        execute("INSERT INTO %s (a, b, d) values (7, 7, 'a')");
-        assertRows(execute("UPDATE %s SET s = 7 WHERE a = 7 IF s = NULL"),
-                   row(false, 100));
-        assertRows(execute("SELECT * FROM %s WHERE a = 7"),
-                   row(7, 7, 100, "a"));
-
-        // deleting row before CAS makes it effectively non-existing
-        execute("DELETE FROM %s WHERE a = 8;");
-        assertRows(execute("UPDATE %s SET s = 8 WHERE a = 8 IF s = NULL"),
-                   row(true));
-        assertRows(execute("SELECT * FROM %s WHERE a = 8"),
-                   row(8, null, 8, null));
-    }
-
     @Test
     public void testConditionalUpdatesWithNonExistingValues() throws Throwable
     {
@@ -1659,48 +609,6 @@ public class InsertUpdateIfConditionTest extends CQLTester
                    row(true));
     }
 
-    @Test
-    public void testStaticsWithMultipleConditions() throws Throwable
-    {
-        createTable("CREATE TABLE %s (a int, b int, s1 int static, s2 int static, d int, PRIMARY KEY (a, b))");
-
-        for (int i = 1; i <= 5; i++)
-        {
-            execute("INSERT INTO %s (a, b, d) VALUES (?, ?, ?)", i, 1, 5);
-            execute("INSERT INTO %s (a, b, d) VALUES (?, ?, ?)", i, 2, 6);
-        }
-
-        assertRows(execute("BEGIN BATCH\n"
-                           + "UPDATE %1$s SET s2 = 102 WHERE a = 1 IF s1 = null;\n"
-                           + "UPDATE %1$s SET s1 = 101 WHERE a = 1 IF s2 = null;\n"
-                           + "APPLY BATCH"),
-                   row(true));
-        assertRows(execute("SELECT * FROM %s WHERE a = 1"),
-                   row(1, 1, 101, 102, 5),
-                   row(1, 2, 101, 102, 6));
-
-
-        assertRows(execute("BEGIN BATCH\n"
-                           + "UPDATE %1$s SET s2 = 202 WHERE a = 2 IF s1 = null;\n"
-                           + "UPDATE %1$s SET s1 = 201 WHERE a = 2 IF s2 = null;\n"
-                           + "UPDATE %1$s SET d = 203 WHERE a = 2 AND b = 1 IF d = 5;\n"
-                           + "UPDATE %1$s SET d = 204 WHERE a = 2 AND b = 2 IF d = 6;\n"
-                           + "APPLY BATCH"),
-                   row(true));
-
-        assertRows(execute("SELECT * FROM %s WHERE a = 2"),
-                   row(2, 1, 201, 202, 203),
-                   row(2, 2, 201, 202, 204));
-
-        assertRows(execute("BEGIN BATCH\n"
-                           + "UPDATE %1$s SET s2 = 202 WHERE a = 20 IF s1 = null;\n"
-                           + "UPDATE %1$s SET s1 = 201 WHERE a = 20 IF s2 = null;\n"
-                           + "UPDATE %1$s SET d = 203 WHERE a = 20 AND b = 1 IF d = 5;\n"
-                           + "UPDATE %1$s SET d = 204 WHERE a = 20 AND b = 2 IF d = 6;\n"
-                           + "APPLY BATCH"),
-                   row(false));
-    }
-
     @Test
     public void testConditionalUpdatesWithNullValuesWithBatch() throws Throwable
     {
@@ -2019,71 +927,6 @@ public class InsertUpdateIfConditionTest extends CQLTester
                              + "APPLY BATCH");
     }
 
-    @Test
-    public void testInMarkerWithUDTs() throws Throwable
-    {
-        String typename = createType("CREATE TYPE %s (a int, b text)");
-        String myType = KEYSPACE + '.' + typename;
-
-        for (boolean frozen : new boolean[] {false, true})
-        {
-            createTable(String.format("CREATE TABLE %%s (k int PRIMARY KEY, v %s)",
-                                      frozen
-                                      ? "frozen<" + myType + ">"
-                                      : myType));
-
-            Object v = userType("a", 0, "b", "abc");
-            execute("INSERT INTO %s (k, v) VALUES (0, ?)", v);
-
-            // Does not apply
-            assertRows(execute("UPDATE %s SET v = {a: 0, b: 'bc'} WHERE k = 0 IF v IN (?, ?)", userType("a", 1, "b", "abc"), userType("a", 0, "b", "ac")),
-                       row(false, v));
-            assertRows(execute("UPDATE %s SET v = {a: 0, b: 'bc'} WHERE k = 0 IF v IN (?, ?)", userType("a", 1, "b", "abc"), null),
-                       row(false, v));
-            assertRows(execute("UPDATE %s SET v = {a: 0, b: 'bc'} WHERE k = 0 IF v IN (?, ?)", null, null),
-                       row(false, v));
-            assertRows(execute("UPDATE %s SET v = {a: 0, b: 'bc'} WHERE k = 0 IF v IN (?, ?)", userType("a", 1, "b", "abc"), unset()),
-                       row(false, v));
-            assertRows(execute("UPDATE %s SET v = {a: 0, b: 'bc'} WHERE k = 0 IF v IN (?, ?)", unset(), unset()),
-                       row(false, v));
-            assertRows(execute("UPDATE %s SET v = {a: 0, b: 'bc'} WHERE k = 0 IF v IN ?", list(userType("a", 1, "b", "abc"), userType("a", 0, "b", "ac"))),
-                       row(false, v));
-            assertRows(execute("UPDATE %s SET v = {a: 0, b: 'bc'} WHERE k = 0 IF v.a IN (?, ?)", 1, 2),
-                       row(false, v));
-            assertRows(execute("UPDATE %s SET v = {a: 0, b: 'bc'} WHERE k = 0 IF v.a IN (?, ?)", 1, null),
-                       row(false, v));
-            assertRows(execute("UPDATE %s SET v = {a: 0, b: 'bc'} WHERE k = 0 IF v.a IN ?", list(1, 2)),
-                       row(false, v));
-            assertRows(execute("UPDATE %s SET v = {a: 0, b: 'bc'} WHERE k = 0 IF v.a IN (?, ?)", 1, unset()),
-                       row(false, v));
-
-            // Does apply
-            assertRows(execute("UPDATE %s SET v = {a: 0, b: 'bc'} WHERE k = 0 IF v IN (?, ?)", userType("a", 0, "b", "abc"), userType("a", 0, "b", "ac")),
-                       row(true));
-            assertRows(execute("UPDATE %s SET v = {a: 1, b: 'bc'} WHERE k = 0 IF v IN (?, ?)", userType("a", 0, "b", "bc"), null),
-                       row(true));
-            assertRows(execute("UPDATE %s SET v = {a: 0, b: 'abc'} WHERE k = 0 IF v IN ?", list(userType("a", 1, "b", "bc"), userType("a", 0, "b", "ac"))),
-                       row(true));
-            assertRows(execute("UPDATE %s SET v = {a: 1, b: 'bc'} WHERE k = 0 IF v IN (?, ?, ?)", userType("a", 1, "b", "bc"), unset(), userType("a", 0, "b", "abc")),
-                       row(true));
-            assertRows(execute("UPDATE %s SET v = {a: 0, b: 'bc'} WHERE k = 0 IF v.a IN (?, ?)", 1, 0),
-                       row(true));
-            assertRows(execute("UPDATE %s SET v = {a: 0, b: 'abc'} WHERE k = 0 IF v.a IN (?, ?)", 0, null),
-                       row(true));
-            assertRows(execute("UPDATE %s SET v = {a: 0, b: 'bc'} WHERE k = 0 IF v.a IN ?", list(0, 1)),
-                       row(true));
-            assertRows(execute("UPDATE %s SET v = {a: 0, b: 'abc'} WHERE k = 0 IF v.a IN (?, ?, ?)", 1, unset(), 0),
-                       row(true));
-
-            assertInvalidMessage("Invalid null list in IN condition",
-                                 "UPDATE %s SET v = {a: 0, b: 'bc'} WHERE k = 0 IF v IN ?", (List<ByteBuffer>) null);
-            assertInvalidMessage("Invalid 'unset' value in condition",
-                                 "UPDATE %s SET v = {a: 0, b: 'bc'} WHERE k = 0 IF v IN ?", unset());
-            assertInvalidMessage("Invalid 'unset' value in condition",
-                                 "UPDATE %s SET v = {a: 0, b: 'bc'} WHERE k = 0 IF v.a IN ?", unset());
-        }
-    }
-
     @Test
     public void testConditionalOnDurationColumns() throws Throwable
     {
@@ -2115,335 +958,4 @@ public class InsertUpdateIfConditionTest extends CQLTester
 
         assertRows(execute("SELECT * FROM %s WHERE k = 1"), row(1, Duration.from("10s"), 6));
     }
-
-    @Test
-    public void testConditionalOnDurationWithinLists() throws Throwable
-    {
-        for (Boolean frozen : new Boolean[]{Boolean.FALSE, Boolean.TRUE})
-        {
-            String listType = String.format(frozen ? "frozen<%s>" : "%s", "list<duration>");
-
-            createTable("CREATE TABLE %s (k int PRIMARY KEY, v int, l " + listType + " )");
-
-            assertInvalidMessage("Slice conditions are not supported on collections containing durations",
-                                 "UPDATE %s SET v = 3 WHERE k = 0 IF l > [1s, 2s]");
-            assertInvalidMessage("Slice conditions are not supported on collections containing durations",
-                                 "UPDATE %s SET v = 3 WHERE k = 0 IF l >= [1s, 2s]");
-            assertInvalidMessage("Slice conditions are not supported on collections containing durations",
-                                 "UPDATE %s SET v = 3 WHERE k = 0 IF l <= [1s, 2s]");
-            assertInvalidMessage("Slice conditions are not supported on collections containing durations",
-                                 "UPDATE %s SET v = 3 WHERE k = 0 IF l < [1s, 2s]");
-
-            execute("INSERT INTO %s (k, v, l) VALUES (1, 1, [1s, 2s])");
-
-            assertRows(execute("UPDATE %s SET v = 4 WHERE k = 1 IF l = [2s]"), row(false, list(Duration.from("1000ms"), Duration.from("2s"))));
-            assertRows(execute("UPDATE %s SET v = 3 WHERE k = 1 IF l = [1s, 2s]"), row(true));
-
-            assertRows(execute("SELECT * FROM %s WHERE k = 1"), row(1, list(Duration.from("1000ms"), Duration.from("2s")), 3));
-
-            assertRows(execute("UPDATE %s SET l = [10s] WHERE k = 1 IF l != [1s, 2s]"), row(false, list(Duration.from("1000ms"), Duration.from("2s"))));
-            assertRows(execute("UPDATE %s SET v = 6 WHERE k = 1 IF l != [1s]"), row(true));
-
-            assertRows(execute("SELECT * FROM %s WHERE k = 1"), row(1, list(Duration.from("1000ms"), Duration.from("2s")), 6));
-
-            assertRows(execute("UPDATE %s SET v = 5 WHERE k = 1 IF l IN ([1s], [1s, 5s])"), row(false, list(Duration.from("1000ms"), Duration.from("2s"))));
-            assertRows(execute("UPDATE %s SET l = [5s, 10s] WHERE k = 1 IF l IN ([1s], [1s, 2s])"), row(true));
-
-            assertRows(execute("SELECT * FROM %s WHERE k = 1"), row(1, list(Duration.from("5s"), Duration.from("10s")), 6));
-
-            assertInvalidMessage("Slice conditions ( > ) are not supported on durations",
-                                 "UPDATE %s SET v = 3 WHERE k = 0 IF l[0] > 1s");
-            assertInvalidMessage("Slice conditions ( >= ) are not supported on durations",
-                                 "UPDATE %s SET v = 3 WHERE k = 0 IF l[0] >= 1s");
-            assertInvalidMessage("Slice conditions ( <= ) are not supported on durations",
-                                 "UPDATE %s SET v = 3 WHERE k = 0 IF l[0] <= 1s");
-            assertInvalidMessage("Slice conditions ( < ) are not supported on durations",
-                                 "UPDATE %s SET v = 3 WHERE k = 0 IF l[0] < 1s");
-
-            assertRows(execute("UPDATE %s SET v = 4 WHERE k = 1 IF l[0] = 2s"), row(false, list(Duration.from("5s"), Duration.from("10s"))));
-            assertRows(execute("UPDATE %s SET v = 3 WHERE k = 1 IF l[0] = 5s"), row(true));
-
-            assertRows(execute("SELECT * FROM %s WHERE k = 1"), row(1, list(Duration.from("5s"), Duration.from("10s")), 3));
-
-            assertRows(execute("UPDATE %s SET l = [10s] WHERE k = 1 IF l[1] != 10s"), row(false, list(Duration.from("5s"), Duration.from("10s"))));
-            assertRows(execute("UPDATE %s SET v = 6 WHERE k = 1 IF l[1] != 1s"), row(true));
-
-            assertRows(execute("SELECT * FROM %s WHERE k = 1"), row(1, list(Duration.from("5s"), Duration.from("10s")), 6));
-
-            assertRows(execute("UPDATE %s SET v = 5 WHERE k = 1 IF l[0] IN (2s, 10s)"), row(false, list(Duration.from("5s"), Duration.from("10s"))));
-            assertRows(execute("UPDATE %s SET l = [6s, 12s] WHERE k = 1 IF l[0] IN (5s, 10s)"), row(true));
-
-            assertRows(execute("SELECT * FROM %s WHERE k = 1"), row(1, list(Duration.from("6s"), Duration.from("12s")), 6));
-        }
-    }
-
-    @Test
-    public void testInMarkerWithLists() throws Throwable
-    {
-        for (boolean frozen : new boolean[]{false, true})
-        {
-            createTable(String.format("CREATE TABLE %%s (k int PRIMARY KEY, l %s)",
-                                      frozen
-                                      ? "frozen<list<text>>"
-                                      : "list<text>"));
-
-            execute("INSERT INTO %s(k, l) VALUES (0, ['foo', 'bar', 'foobar'])");
-
-            // Does not apply
-            assertRows(execute("UPDATE %s SET l = ['foo', 'bar'] WHERE k = 0 IF l IN (?, ?)", list("foo", "foobar"), list("bar", "foobar")),
-                       row(false, list("foo", "bar", "foobar")));
-            assertRows(execute("UPDATE %s SET l = ['foo', 'bar'] WHERE k = 0 IF l IN (?, ?)", list("foo", "foobar"), null),
-                       row(false, list("foo", "bar", "foobar")));
-            assertRows(execute("UPDATE %s SET l = ['foo', 'bar'] WHERE k = 0 IF l IN (?, ?)", list("foo", "foobar"), unset()),
-                       row(false, list("foo", "bar", "foobar")));
-            assertRows(execute("UPDATE %s SET l = ['foo', 'bar'] WHERE k = 0 IF l IN (?, ?)", null, null),
-                       row(false, list("foo", "bar", "foobar")));
-            assertRows(execute("UPDATE %s SET l = ['foo', 'bar'] WHERE k = 0 IF l IN ?", list(list("foo", "foobar"), list("bar", "foobar"))),
-                       row(false, list("foo", "bar", "foobar")));
-            assertRows(execute("UPDATE %s SET l = ['foo', 'bar'] WHERE k = 0 IF l[?] IN ?", 1, list("foo", "foobar")),
-                       row(false, list("foo", "bar", "foobar")));
-            assertRows(execute("UPDATE %s SET l = ['foo', 'bar'] WHERE k = 0 IF l[?] IN (?, ?)", 1, "foo", "foobar"),
-                       row(false, list("foo", "bar", "foobar")));
-            assertRows(execute("UPDATE %s SET l = ['foo', 'bar'] WHERE k = 0 IF l[?] IN (?, ?)", 1, "foo", null),
-                       row(false, list("foo", "bar", "foobar")));
-            assertRows(execute("UPDATE %s SET l = ['foo', 'bar'] WHERE k = 0 IF l[?] IN (?, ?)", 1, "foo", unset()),
-                       row(false, list("foo", "bar", "foobar")));
-
-            // Does apply
-            assertRows(execute("UPDATE %s SET l = ['foo', 'bar'] WHERE k = 0 IF l IN (?, ?)", list("foo", "bar", "foobar"), list("bar", "foobar")),
-                       row(true));
-            assertRows(execute("UPDATE %s SET l = ['foo', 'foobar'] WHERE k = 0 IF l IN (?, ?, ?)", list("foo", "bar", "foobar"), null, list("foo", "bar")),
-                       row(true));
-            assertRows(execute("UPDATE %s SET l = ['foo', 'bar'] WHERE k = 0 IF l IN (?, ?, ?)", list("foo", "bar", "foobar"), unset(), list("foo", "foobar")),
-                       row(true));
-            assertRows(execute("UPDATE %s SET l = ['foo', 'foobar'] WHERE k = 0 IF l IN (?, ?)", list("bar", "foobar"), list("foo", "bar")),
-                       row(true));
-            assertRows(execute("UPDATE %s SET l = ['foo', 'bar'] WHERE k = 0 IF l[?] IN ?", 1, list("bar", "foobar")),
-                       row(true));
-            assertRows(execute("UPDATE %s SET l = ['foo', 'foobar'] WHERE k = 0 IF l[?] IN (?, ?, ?)", 1, "bar", null, "foobar"),
-                       row(true));
-            assertRows(execute("UPDATE %s SET l = ['foo', 'foobar'] WHERE k = 0 IF l[?] IN (?, ?, ?)", 1, "bar", unset(), "foobar"),
-                       row(true));
-
-            assertInvalidMessage("Invalid null list in IN condition",
-                                 "UPDATE %s SET l = ['foo', 'bar'] WHERE k = 0 IF l IN ?", (List<ByteBuffer>) null);
-            assertInvalidMessage("Invalid 'unset' value in condition",
-                                 "UPDATE %s SET l = ['foo', 'bar'] WHERE k = 0 IF l IN ?", unset());
-            assertInvalidMessage("Invalid 'unset' value in condition",
-                                 "UPDATE %s SET l = ['foo', 'bar'] WHERE k = 0 IF l[?] IN ?", 1, unset());
-        }
-    }
-
-    @Test
-    public void testConditionalOnDurationWithinMaps() throws Throwable
-    {
-        for (Boolean frozen : new Boolean[]{Boolean.FALSE, Boolean.TRUE})
-        {
-            String mapType = String.format(frozen ? "frozen<%s>" : "%s", "map<int, duration>");
-
-            createTable("CREATE TABLE %s (k int PRIMARY KEY, v int, m " + mapType + " )");
-
-            assertInvalidMessage("Slice conditions are not supported on collections containing durations",
-                                 "UPDATE %s SET v = 3 WHERE k = 0 IF m > {1: 1s, 2: 2s}");
-            assertInvalidMessage("Slice conditions are not supported on collections containing durations",
-                                 "UPDATE %s SET v = 3 WHERE k = 0 IF m >= {1: 1s, 2: 2s}");
-            assertInvalidMessage("Slice conditions are not supported on collections containing durations",
-                                 "UPDATE %s SET v = 3 WHERE k = 0 IF m <= {1: 1s, 2: 2s}");
-            assertInvalidMessage("Slice conditions are not supported on collections containing durations",
-                                 "UPDATE %s SET v = 3 WHERE k = 0 IF m < {1: 1s, 2: 2s}");
-
-            execute("INSERT INTO %s (k, v, m) VALUES (1, 1, {1: 1s, 2: 2s})");
-
-            assertRows(execute("UPDATE %s SET v = 4 WHERE k = 1 IF m = {2: 2s}"), row(false, map(1, Duration.from("1000ms"), 2, Duration.from("2s"))));
-            assertRows(execute("UPDATE %s SET v = 3 WHERE k = 1 IF m = {1: 1s, 2: 2s}"), row(true));
-
-            assertRows(execute("SELECT * FROM %s WHERE k = 1"), row(1, map(1, Duration.from("1000ms"), 2, Duration.from("2s")), 3));
-
-            assertRows(execute("UPDATE %s SET m = {1 :10s} WHERE k = 1 IF m != {1: 1s, 2: 2s}"), row(false, map(1, Duration.from("1000ms"), 2, Duration.from("2s"))));
-            assertRows(execute("UPDATE %s SET v = 6 WHERE k = 1 IF m != {1: 1s}"), row(true));
-
-            assertRows(execute("SELECT * FROM %s WHERE k = 1"), row(1, map(1, Duration.from("1000ms"), 2, Duration.from("2s")), 6));
-
-            assertRows(execute("UPDATE %s SET v = 5 WHERE k = 1 IF m IN ({1: 1s}, {1: 5s})"), row(false, map(1, Duration.from("1000ms"), 2, Duration.from("2s"))));
-            assertRows(execute("UPDATE %s SET m = {1: 5s, 2: 10s} WHERE k = 1 IF m IN ({1: 1s}, {1: 1s, 2: 2s})"), row(true));
-
-            assertRows(execute("SELECT * FROM %s WHERE k = 1"), row(1, map(1, Duration.from("5s"), 2, Duration.from("10s")), 6));
-
-            assertInvalidMessage("Slice conditions ( > ) are not supported on durations",
-                                 "UPDATE %s SET v = 3 WHERE k = 0 IF m[1] > 1s");
-            assertInvalidMessage("Slice conditions ( >= ) are not supported on durations",
-                                 "UPDATE %s SET v = 3 WHERE k = 0 IF m[1] >= 1s");
-            assertInvalidMessage("Slice conditions ( <= ) are not supported on durations",
-                                 "UPDATE %s SET v = 3 WHERE k = 0 IF m[1] <= 1s");
-            assertInvalidMessage("Slice conditions ( < ) are not supported on durations",
-                                 "UPDATE %s SET v = 3 WHERE k = 0 IF m[1] < 1s");
-
-            assertRows(execute("UPDATE %s SET v = 4 WHERE k = 1 IF m[1] = 2s"), row(false, map(1, Duration.from("5s"), 2, Duration.from("10s"))));
-            assertRows(execute("UPDATE %s SET v = 3 WHERE k = 1 IF m[1] = 5s"), row(true));
-
-            assertRows(execute("SELECT * FROM %s WHERE k = 1"), row(1, map(1, Duration.from("5s"), 2, Duration.from("10s")), 3));
-
-            assertRows(execute("UPDATE %s SET m = {1: 10s} WHERE k = 1 IF m[2] != 10s"), row(false, map(1, Duration.from("5s"), 2, Duration.from("10s"))));
-            assertRows(execute("UPDATE %s SET v = 6 WHERE k = 1 IF m[2] != 1s"), row(true));
-
-            assertRows(execute("SELECT * FROM %s WHERE k = 1"), row(1, map(1, Duration.from("5s"), 2, Duration.from("10s")), 6));
-
-            assertRows(execute("UPDATE %s SET v = 5 WHERE k = 1 IF m[1] IN (2s, 10s)"), row(false, map(1, Duration.from("5s"), 2, Duration.from("10s"))));
-            assertRows(execute("UPDATE %s SET m = {1: 6s, 2: 12s} WHERE k = 1 IF m[1] IN (5s, 10s)"), row(true));
-
-            assertRows(execute("SELECT * FROM %s WHERE k = 1"), row(1, map(1, Duration.from("6s"), 2, Duration.from("12s")), 6));
-        }
-    }
-
-    @Test
-    public void testInMarkerWithMaps() throws Throwable
-    {
-        for (boolean frozen : new boolean[] {false, true})
-        {
-            createTable(String.format("CREATE TABLE %%s (k int PRIMARY KEY, m %s)",
-                                      frozen
-                                      ? "frozen<map<text, text>>"
-                                      : "map<text, text>"));
-
-            execute("INSERT INTO %s (k, m) VALUES (0, {'foo' : 'bar'})");
-
-            // Does not apply
-            assertRows(execute("UPDATE %s SET m = {'foo' : 'foobar'} WHERE k = 0 IF m IN (?, ?)", map("foo", "foobar"), map("bar", "foobar")),
-                       row(false, map("foo", "bar")));
-            assertRows(execute("UPDATE %s SET  m = {'foo' : 'foobar'} WHERE k = 0 IF m IN (?, ?)", map("foo", "foobar"), null),
-                       row(false, map("foo", "bar")));
-            assertRows(execute("UPDATE %s SET  m = {'foo' : 'foobar'} WHERE k = 0 IF m IN (?, ?)", map("foo", "foobar"), unset()),
-                       row(false, map("foo", "bar")));
-            assertRows(execute("UPDATE %s SET  m = {'foo' : 'foobar'} WHERE k = 0 IF m IN (?, ?)", null, null),
-                       row(false, map("foo", "bar")));
-            assertRows(execute("UPDATE %s SET  m = {'foo' : 'foobar'} WHERE k = 0 IF m IN ?", list(map("foo", "foobar"), map("bar", "foobar"))),
-                       row(false, map("foo", "bar")));
-            assertRows(execute("UPDATE %s SET  m = {'foo' : 'foobar'} WHERE k = 0 IF m[?] IN ?", "foo", list("foo", "foobar")),
-                       row(false, map("foo", "bar")));
-            assertRows(execute("UPDATE %s SET  m = {'foo' : 'foobar'} WHERE k = 0 IF m[?] IN (?, ?)", "foo", "foo", "foobar"),
-                       row(false, map("foo", "bar")));
-            assertRows(execute("UPDATE %s SET  m = {'foo' : 'foobar'} WHERE k = 0 IF m[?] IN (?, ?)", "foo", "foo", null),
-                       row(false, map("foo", "bar")));
-            assertRows(execute("UPDATE %s SET  m = {'foo' : 'foobar'} WHERE k = 0 IF m[?] IN (?, ?)", "foo", "foo", unset()),
-                       row(false, map("foo", "bar")));
-
-            // Does apply
-            assertRows(execute("UPDATE %s SET m = {'foo' : 'foobar'} WHERE k = 0 IF m IN (?, ?)", map("foo", "foobar"), map("foo", "bar")),
-                       row(true));
-            assertRows(execute("UPDATE %s SET m = {'foo' : 'bar'} WHERE k = 0 IF m IN (?, ?, ?)", map("bar", "foobar"), null, map("foo", "foobar")),
-                       row(true));
-            assertRows(execute("UPDATE %s SET m = {'foo' : 'bar'} WHERE k = 0 IF m IN (?, ?, ?)", map("bar", "foobar"), unset(), map("foo", "bar")),
-                       row(true));
-            assertRows(execute("UPDATE %s SET m = {'foo' : 'foobar'} WHERE k = 0 IF m IN ?", list(map("foo", "bar"), map("bar", "foobar"))),
-                       row(true));
-            assertRows(execute("UPDATE %s SET m = {'foo' : 'bar'} WHERE k = 0 IF m[?] IN ?", "foo", list("bar", "foobar")),
-                       row(true));
-            assertRows(execute("UPDATE %s SET m = {'foo' : 'foobar'} WHERE k = 0 IF m[?] IN (?, ?, ?)", "foo", "bar", null, "foobar"),
-                       row(true));
-            assertRows(execute("UPDATE %s SET m = {'foo' : 'foobar'} WHERE k = 0 IF m[?] IN (?, ?, ?)", "foo", "bar", unset(), "foobar"),
-                       row(true));
-
-            assertInvalidMessage("Invalid null list in IN condition",
-                                 "UPDATE %s SET  m = {'foo' : 'foobar'} WHERE k = 0 IF m IN ?", (List<ByteBuffer>) null);
-            assertInvalidMessage("Invalid 'unset' value in condition",
-                                 "UPDATE %s SET  m = {'foo' : 'foobar'} WHERE k = 0 IF m IN ?", unset());
-            assertInvalidMessage("Invalid 'unset' value in condition",
-                                 "UPDATE %s SET  m = {'foo' : 'foobar'} WHERE k = 0 IF m[?] IN ?", "foo", unset());
-        }
-    }
-
-    @Test
-    public void testConditionalOnDurationWithinUdts() throws Throwable
-    {
-        String udt = createType("CREATE TYPE %s (i int, d duration)");
-
-        for (Boolean frozen : new Boolean[]{Boolean.FALSE, Boolean.TRUE})
-        {
-            udt = String.format(frozen ? "frozen<%s>" : "%s", udt);
-
-            createTable("CREATE TABLE %s (k int PRIMARY KEY, v int, u " + udt + " )");
-
-            assertInvalidMessage("Slice conditions are not supported on UDTs containing durations",
-                                 "UPDATE %s SET v = 3 WHERE k = 0 IF u > {i: 1, d: 2s}");
-            assertInvalidMessage("Slice conditions are not supported on UDTs containing durations",
-                                 "UPDATE %s SET v = 3 WHERE k = 0 IF u >= {i: 1, d: 2s}");
-            assertInvalidMessage("Slice conditions are not supported on UDTs containing durations",
-                                 "UPDATE %s SET v = 3 WHERE k = 0 IF u <= {i: 1, d: 2s}");
-            assertInvalidMessage("Slice conditions are not supported on UDTs containing durations",
-                                 "UPDATE %s SET v = 3 WHERE k = 0 IF u < {i: 1, d: 2s}");
-
-            execute("INSERT INTO %s (k, v, u) VALUES (1, 1, {i:1, d:2s})");
-
-            assertRows(execute("UPDATE %s SET v = 4 WHERE k = 1 IF u = {i: 2, d: 2s}"), row(false, userType("i", 1, "d", Duration.from("2s"))));
-            assertRows(execute("UPDATE %s SET v = 3 WHERE k = 1 IF u = {i: 1, d: 2s}"), row(true));
-
-            assertRows(execute("SELECT * FROM %s WHERE k = 1"), row(1, userType("i", 1, "d", Duration.from("2s")), 3));
-
-            assertRows(execute("UPDATE %s SET u = {i: 1, d: 10s} WHERE k = 1 IF u != {i: 1, d: 2s}"), row(false, userType("i", 1, "d", Duration.from("2s"))));
-            assertRows(execute("UPDATE %s SET v = 6 WHERE k = 1 IF u != {i: 1, d: 1s}"), row(true));
-
-            assertRows(execute("SELECT * FROM %s WHERE k = 1"), row(1, userType("i", 1, "d", Duration.from("2s")), 6));
-
-            assertRows(execute("UPDATE %s SET v = 5 WHERE k = 1 IF u IN ({i: 1, d: 1s}, {i: 1, d: 5s})"), row(false, userType("i", 1, "d", Duration.from("2s"))));
-            assertRows(execute("UPDATE %s SET u = {i: 1, d: 10s} WHERE k = 1 IF u IN ({i: 1, d: 1s}, {i: 1, d: 2s})"), row(true));
-
-            assertRows(execute("SELECT * FROM %s WHERE k = 1"), row(1, userType("i", 1, "d", Duration.from("10s")), 6));
-
-            assertInvalidMessage("Slice conditions ( > ) are not supported on durations",
-                                 "UPDATE %s SET v = 3 WHERE k = 0 IF u.d > 1s");
-            assertInvalidMessage("Slice conditions ( >= ) are not supported on durations",
-                                 "UPDATE %s SET v = 3 WHERE k = 0 IF u.d >= 1s");
-            assertInvalidMessage("Slice conditions ( <= ) are not supported on durations",
-                                 "UPDATE %s SET v = 3 WHERE k = 0 IF u.d <= 1s");
-            assertInvalidMessage("Slice conditions ( < ) are not supported on durations",
-                                 "UPDATE %s SET v = 3 WHERE k = 0 IF u.d < 1s");
-
-            assertRows(execute("UPDATE %s SET v = 4 WHERE k = 1 IF u.d = 2s"), row(false, userType("i", 1, "d", Duration.from("10s"))));
-            assertRows(execute("UPDATE %s SET v = 3 WHERE k = 1 IF u.d = 10s"), row(true));
-
-            assertRows(execute("SELECT * FROM %s WHERE k = 1"), row(1, userType("i", 1, "d", Duration.from("10s")), 3));
-
-            assertRows(execute("UPDATE %s SET u = {i: 1, d: 10s} WHERE k = 1 IF u.d != 10s"), row(false, userType("i", 1, "d", Duration.from("10s"))));
-            assertRows(execute("UPDATE %s SET v = 6 WHERE k = 1 IF u.d != 1s"), row(true));
-
-            assertRows(execute("SELECT * FROM %s WHERE k = 1"), row(1, userType("i", 1, "d", Duration.from("10s")), 6));
-
-            assertRows(execute("UPDATE %s SET v = 5 WHERE k = 1 IF u.d IN (2s, 5s)"), row(false, userType("i", 1, "d", Duration.from("10s"))));
-            assertRows(execute("UPDATE %s SET u = {i: 6, d: 12s} WHERE k = 1 IF u.d IN (5s, 10s)"), row(true));
-
-            assertRows(execute("SELECT * FROM %s WHERE k = 1"), row(1, userType("i", 6, "d", Duration.from("12s")), 6));
-        }
-    }
-
-    @Test
-    public void testConditionalOnDurationWithinTuples() throws Throwable
-    {
-        createTable("CREATE TABLE %s (k int PRIMARY KEY, v int, u tuple<int, duration> )");
-
-        assertInvalidMessage("Slice conditions are not supported on tuples containing durations",
-                             "UPDATE %s SET v = 3 WHERE k = 0 IF u > (1, 2s)");
-        assertInvalidMessage("Slice conditions are not supported on tuples containing durations",
-                             "UPDATE %s SET v = 3 WHERE k = 0 IF u >= (1, 2s)");
-        assertInvalidMessage("Slice conditions are not supported on tuples containing durations",
-                             "UPDATE %s SET v = 3 WHERE k = 0 IF u <= (1, 2s)");
-        assertInvalidMessage("Slice conditions are not supported on tuples containing durations",
-                             "UPDATE %s SET v = 3 WHERE k = 0 IF u < (1, 2s)");
-
-        execute("INSERT INTO %s (k, v, u) VALUES (1, 1, (1, 2s))");
-
-        assertRows(execute("UPDATE %s SET v = 4 WHERE k = 1 IF u = (2, 2s)"), row(false, tuple(1, Duration.from("2s"))));
-        assertRows(execute("UPDATE %s SET v = 3 WHERE k = 1 IF u = (1, 2s)"), row(true));
-
-        assertRows(execute("SELECT * FROM %s WHERE k = 1"), row(1, tuple(1, Duration.from("2s")), 3));
-
-        assertRows(execute("UPDATE %s SET u = (1, 10s) WHERE k = 1 IF u != (1, 2s)"), row(false, tuple(1, Duration.from("2s"))));
-        assertRows(execute("UPDATE %s SET v = 6 WHERE k = 1 IF u != (1, 1s)"), row(true));
-
-        assertRows(execute("SELECT * FROM %s WHERE k = 1"), row(1, tuple(1, Duration.from("2s")), 6));
-
-        assertRows(execute("UPDATE %s SET v = 5 WHERE k = 1 IF u IN ((1, 1s), (1, 5s))"), row(false, tuple(1, Duration.from("2s"))));
-        assertRows(execute("UPDATE %s SET u = (1, 10s) WHERE k = 1 IF u IN ((1, 1s), (1, 2s))"), row(true));
-
-        assertRows(execute("SELECT * FROM %s WHERE k = 1"), row(1, tuple(1, Duration.from("10s")), 6));
-    }
 }
