diff --git a/CHANGES.txt b/CHANGES.txt
index ddf46277cb..fc3242620b 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 2.0.10
+ * Do not flush on truncate if durable_writes is false (CASSANDRA-7750)
  * Give CRR a default input_cql Statement (CASSANDRA-7226)
  * Better error message when adding a collection with the same name
    than a previously dropped one (CASSANDRA-6276)
diff --git a/src/java/org/apache/cassandra/db/ColumnFamilyStore.java b/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
index a3c080aca7..3da44de1c6 100644
--- a/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
+++ b/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
@@ -2002,12 +2002,31 @@ public class ColumnFamilyStore implements ColumnFamilyStoreMBean
         // position in the System keyspace.
         logger.debug("truncating {}", name);
 
-        // flush the CF being truncated before forcing the new segment
-        forceBlockingFlush();
+        if (keyspace.metadata.durableWrites || DatabaseDescriptor.isAutoSnapshot())
+        {
+            // flush the CF being truncated before forcing the new segment
+            forceBlockingFlush();
 
-        // sleep a little to make sure that our truncatedAt comes after any sstable
-        // that was part of the flushed we forced; otherwise on a tie, it won't get deleted.
-        Uninterruptibles.sleepUninterruptibly(1, TimeUnit.MILLISECONDS);
+            // sleep a little to make sure that our truncatedAt comes after any sstable
+            // that was part of the flushed we forced; otherwise on a tie, it won't get deleted.
+            Uninterruptibles.sleepUninterruptibly(1, TimeUnit.MILLISECONDS);
+        }
+        else
+        {
+            Keyspace.switchLock.writeLock().lock();
+            try
+            {
+                for (ColumnFamilyStore cfs : concatWithIndexes())
+                {
+                    Memtable mt = cfs.getMemtableThreadSafe();
+                    if (!mt.isClean())
+                        mt.cfs.data.renewMemtable();
+                }
+            } finally
+            {
+                Keyspace.switchLock.writeLock().unlock();
+            }
+        }
 
         Runnable truncateRunnable = new Runnable()
         {
diff --git a/src/java/org/apache/cassandra/db/DataTracker.java b/src/java/org/apache/cassandra/db/DataTracker.java
index a0f880a10f..a9eef980f7 100644
--- a/src/java/org/apache/cassandra/db/DataTracker.java
+++ b/src/java/org/apache/cassandra/db/DataTracker.java
@@ -123,6 +123,24 @@ public class DataTracker
         return toFlushMemtable;
     }
 
+    /**
+     * Renew the current memtable without putting the old one for a flush.
+     * Used when we flush but a memtable is clean (in which case we must
+     * change it because it was frozen).
+     */
+    public void renewMemtable()
+    {
+        Memtable newMemtable = new Memtable(cfstore, view.get().memtable);
+        View currentView, newView;
+        do
+        {
+            currentView = view.get();
+            newView = currentView.renewMemtable(newMemtable);
+        }
+        while (!view.compareAndSet(currentView, newView));
+        notifyRenewed(currentView.memtable);
+    }
+
     public void replaceFlushed(Memtable memtable, SSTableReader sstable)
     {
         // sstable may be null if we flushed batchlog and nothing needed to be retained
diff --git a/test/unit/org/apache/cassandra/db/CommitLogTest.java b/test/unit/org/apache/cassandra/db/CommitLogTest.java
index a7df87190a..1be29a659c 100644
--- a/test/unit/org/apache/cassandra/db/CommitLogTest.java
+++ b/test/unit/org/apache/cassandra/db/CommitLogTest.java
@@ -32,13 +32,16 @@ import org.junit.Assert;
 import org.junit.Test;
 
 import org.apache.cassandra.SchemaLoader;
+import org.apache.cassandra.Util;
 import org.apache.cassandra.config.Config;
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.db.commitlog.CommitLog;
 import org.apache.cassandra.db.commitlog.CommitLogDescriptor;
 import org.apache.cassandra.db.commitlog.ReplayPosition;
+import org.apache.cassandra.db.filter.NamesQueryFilter;
 import org.apache.cassandra.net.MessagingService;
 import org.apache.cassandra.service.StorageService;
+import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.cassandra.utils.FBUtilities;
 
 import static org.apache.cassandra.utils.ByteBufferUtil.bytes;
@@ -289,4 +292,30 @@ public class CommitLogTest extends SchemaLoader
         Assert.assertEquals(1, CommitLog.instance.activeSegments());
     }
 
+    @Test
+    public void testTruncateWithoutSnapshotNonDurable()  throws ExecutionException, InterruptedException
+    {
+        CommitLog.instance.resetUnsafe();
+        boolean prevAutoSnapshot = DatabaseDescriptor.isAutoSnapshot();
+        DatabaseDescriptor.setAutoSnapshot(false);
+        Keyspace notDurableKs = Keyspace.open("NoCommitlogSpace");
+        Assert.assertFalse(notDurableKs.metadata.durableWrites);
+        ColumnFamilyStore cfs = notDurableKs.getColumnFamilyStore("Standard1");
+        RowMutation rm;
+        DecoratedKey dk = Util.dk("key1");
+
+        // add data
+        rm = new RowMutation("NoCommitlogSpace", dk.key);
+        rm.add("Standard1", ByteBufferUtil.bytes("Column1"), ByteBufferUtil.bytes("abcd"), 0);
+        rm.apply();
+
+        ReadCommand command = new SliceByNamesReadCommand("Keyspace1", dk.key, "Standard1", System.currentTimeMillis(), new NamesQueryFilter(FBUtilities.singleton(ByteBufferUtil.bytes("Column1"), cfs.getComparator())));
+        Row row = command.getRow(notDurableKs);
+        Column col = row.cf.getColumn(ByteBufferUtil.bytes("Column1"));
+        Assert.assertEquals(col.value(), ByteBuffer.wrap("abcd".getBytes()));
+        cfs.truncateBlocking();
+        DatabaseDescriptor.setAutoSnapshot(prevAutoSnapshot);
+        row = command.getRow(notDurableKs);
+        Assert.assertEquals(null, row.cf);
+    }
 }
