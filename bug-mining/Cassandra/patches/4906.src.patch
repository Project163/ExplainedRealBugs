diff --git a/CHANGES.txt b/CHANGES.txt
index ea73fcdd85..99b5a595bf 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 4.0
+ * Correctly close netty channels when a stream session ends (CASSANDRA-13905)
  * Update lz4 to 1.4.0 (CASSANDRA-13741)
  * Optimize Paxos prepare and propose stage for local requests (CASSANDRA-13862)
  * Throttle base partitions during MV repair streaming to prevent OOM (CASSANDRA-13299)
diff --git a/src/java/org/apache/cassandra/streaming/async/NettyStreamingMessageSender.java b/src/java/org/apache/cassandra/streaming/async/NettyStreamingMessageSender.java
index f8720051b0..0b3876019e 100644
--- a/src/java/org/apache/cassandra/streaming/async/NettyStreamingMessageSender.java
+++ b/src/java/org/apache/cassandra/streaming/async/NettyStreamingMessageSender.java
@@ -21,7 +21,9 @@ package org.apache.cassandra.streaming.async;
 import java.io.IOError;
 import java.io.IOException;
 import java.nio.ByteBuffer;
+import java.util.ArrayList;
 import java.util.Collection;
+import java.util.List;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.LinkedBlockingQueue;
@@ -106,10 +108,9 @@ public class NettyStreamingMessageSender implements StreamingMessageSender
     private final ThreadPoolExecutor fileTransferExecutor;
 
     /**
-     * A {@link ThreadLocal} used by the threads in {@link #fileTransferExecutor} to stash references to constructed
-     * and connected {@link Channel}s.
+     * A mapping of each {@link #fileTransferExecutor} thread to a channel that can be written to (on that thread).
      */
-    private final ConcurrentMap<Thread, Channel> threadLocalChannel = new ConcurrentHashMap<>();
+    private final ConcurrentMap<Thread, Channel> threadToChannelMap = new ConcurrentHashMap<>();
 
     /**
      * A netty channel attribute used to indicate if a channel is currently transferring a file. This is primarily used
@@ -373,12 +374,12 @@ public class NettyStreamingMessageSender implements StreamingMessageSender
             Thread currentThread = Thread.currentThread();
             try
             {
-                Channel channel = threadLocalChannel.get(currentThread);
+                Channel channel = threadToChannelMap.get(currentThread);
                 if (channel != null)
                     return channel;
 
                 channel = createChannel();
-                threadLocalChannel.put(currentThread, channel);
+                threadToChannelMap.put(currentThread, channel);
                 return channel;
             }
             catch (Exception e)
@@ -393,10 +394,10 @@ public class NettyStreamingMessageSender implements StreamingMessageSender
         void injectChannel(Channel channel)
         {
             Thread currentThread = Thread.currentThread();
-            if (threadLocalChannel.get(currentThread) != null)
+            if (threadToChannelMap.get(currentThread) != null)
                 throw new IllegalStateException("previous channel already set");
 
-            threadLocalChannel.put(currentThread, channel);
+            threadToChannelMap.put(currentThread, channel);
         }
 
         /**
@@ -404,7 +405,7 @@ public class NettyStreamingMessageSender implements StreamingMessageSender
          */
         void unsetChannel()
         {
-            threadLocalChannel.remove(Thread.currentThread());
+            threadToChannelMap.remove(Thread.currentThread());
         }
     }
 
@@ -498,8 +499,11 @@ public class NettyStreamingMessageSender implements StreamingMessageSender
         channelKeepAlives.stream().map(scheduledFuture -> scheduledFuture.cancel(false));
         channelKeepAlives.clear();
 
-        threadLocalChannel.values().stream().map(channel -> channel.close());
-        threadLocalChannel.clear();
+        List<Future<Void>> futures = new ArrayList<>(threadToChannelMap.size());
+        for (Channel channel : threadToChannelMap.values())
+            futures.add(channel.close());
+        FBUtilities.waitOnFutures(futures, 10 * 1000);
+        threadToChannelMap.clear();
         fileTransferExecutor.shutdownNow();
 
         if (controlMessageChannel != null)
diff --git a/src/java/org/apache/cassandra/utils/FBUtilities.java b/src/java/org/apache/cassandra/utils/FBUtilities.java
index 319512df20..f45a1abcb5 100644
--- a/src/java/org/apache/cassandra/utils/FBUtilities.java
+++ b/src/java/org/apache/cassandra/utils/FBUtilities.java
@@ -382,6 +382,18 @@ public class FBUtilities
     }
 
     public static <T> List<T> waitOnFutures(Iterable<? extends Future<? extends T>> futures)
+    {
+        return waitOnFutures(futures, -1);
+    }
+
+    /**
+     * Block for a collection of futures, with an optional timeout for each future.
+     *
+     * @param futures
+     * @param ms The number of milliseconds to wait on each future. If this value is less than or equal to zero,
+     *           no tiemout value will be passed to {@link Future#get()}.
+     */
+    public static <T> List<T> waitOnFutures(Iterable<? extends Future<? extends T>> futures, long ms)
     {
         List<T> results = new ArrayList<>();
         Throwable fail = null;
@@ -389,7 +401,10 @@ public class FBUtilities
         {
             try
             {
-                results.add(f.get());
+                if (ms <= 0)
+                    results.add(f.get());
+                else
+                    results.add(f.get(ms, TimeUnit.MILLISECONDS));
             }
             catch (Throwable t)
             {
