diff --git a/CHANGES.txt b/CHANGES.txt
index b2a9fafd1c..08853872d3 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -15,6 +15,7 @@
  * add a token generation tool (CASSANDRA-3709)
  * Fix LCS bug with sstable containing only 1 row (CASSANDRA-4411)
  * fix "Can't Modify Index Name" problem on CF update (CASSANDRA-4439)
+ * Fix assertion error in getOverlappingSSTables during repair (CASSANDRA-4456)
 Merged from 1.0:
  * allow dropping columns shadowed by not-yet-expired supercolumn or row
    tombstones in PrecompactedRow (CASSANDRA-4396)
diff --git a/src/java/org/apache/cassandra/db/compaction/CompactionManager.java b/src/java/org/apache/cassandra/db/compaction/CompactionManager.java
index 3c50a09fc0..4b3928041f 100644
--- a/src/java/org/apache/cassandra/db/compaction/CompactionManager.java
+++ b/src/java/org/apache/cassandra/db/compaction/CompactionManager.java
@@ -55,6 +55,7 @@ import org.slf4j.LoggerFactory;
 
 import com.google.common.base.Predicates;
 import com.google.common.collect.Iterators;
+import com.google.common.collect.ImmutableSet;
 
 /**
  * A singleton which manages a private executor of ongoing compactions. A readwrite lock
@@ -833,7 +834,31 @@ public class CompactionManager implements CompactionManagerMBean
         {
             super(OperationType.VALIDATION,
                   cfs.getCompactionStrategy().getScanners(sstables, range),
-                  new CompactionController(cfs, sstables, getDefaultGcBefore(cfs), true));
+                  new ValidationCompactionController(cfs, sstables));
+        }
+    }
+
+    /*
+     * Controller for validation compaction that never purges.
+     * Note that we should not call cfs.getOverlappingSSTables on the provided
+     * sstables because those sstables are not guaranteed to be active sstables
+     * (since we can run repair on a snapshot).
+     */
+    private static class ValidationCompactionController extends CompactionController
+    {
+        public ValidationCompactionController(ColumnFamilyStore cfs, Collection<SSTableReader> sstables)
+        {
+            super(cfs,
+                  Integer.MAX_VALUE,
+                  true,
+                  null,
+                  cfs.getCompactionStrategy().isKeyExistenceExpensive(ImmutableSet.copyOf(sstables)));
+        }
+
+        @Override
+        public boolean shouldPurge(DecoratedKey key)
+        {
+            return false;
         }
     }
 
