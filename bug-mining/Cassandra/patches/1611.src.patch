diff --git a/CHANGES.txt b/CHANGES.txt
index 70d9bbec0b..46646bf440 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -48,6 +48,7 @@
  * fix SecondaryIndex LelevedManifest save upon snapshot (CASSANDRA-4230)
  * fix missing arrayOffset in FBUtilities.hash (CASSANDRA-4250)
  * (cql3) Add name of parameters in CqlResultSet (CASSANDRA-4242)
+ * (cql3) Correctly validat order by queries (CASSANDRA-4246)
 Merged from 1.0:
  * Fix super columns bug where cache is not updated (CASSANDRA-4190)
  * fix maxTimestamp to include row tombstones (CASSANDRA-4116)
diff --git a/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java b/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
index d3fb50a0cc..35cb943733 100644
--- a/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
+++ b/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
@@ -757,7 +757,8 @@ public class SelectStatement implements CQLStatement
                 cqlRows.add(new CqlRow(row.key.key, thriftColumns));
             }
         }
-        // We don't allow reversed on range scan, but we do on multiget (IN (...)), so let's reverse the rows there too.
+
+        // Internal calls always return columns in the comparator order, even when reverse was set
         if (isReversed)
             Collections.reverse(cqlRows);
 
@@ -1013,14 +1014,13 @@ public class SelectStatement implements CQLStatement
                 }
                 assert isReversed != null;
                 stmt.isReversed = isReversed;
-            }
 
-            // Only allow reversed if the row key restriction is an equality,
-            // since we don't know how to reverse otherwise
-            if (stmt.isReversed)
-            {
-                if (stmt.keyRestriction == null || !stmt.keyRestriction.isEquality())
-                    throw new InvalidRequestException("Descending order is only supported is the first part of the PRIMARY KEY is restricted by an Equal or a IN");
+                // Only allow ordering if the row key restriction is an equality,
+                // since otherwise the order will be primarily on the row key.
+                // TODO: we could allow ordering for IN queries, as we can do the
+                // sorting post-query easily, but we will have to add it
+                if (stmt.keyRestriction == null || !stmt.keyRestriction.isEquality() || stmt.keyRestriction.eqValues.size() != 1)
+                    throw new InvalidRequestException("Ordering is only supported is the first part of the PRIMARY KEY is restricted by an Equal or a IN");
             }
 
             // If this is a query on tokens, it's necessary a range query (there can be more than one key per token), so reject IN queries (as we don't know how to do them)
