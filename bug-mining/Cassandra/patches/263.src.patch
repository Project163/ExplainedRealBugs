diff --git a/src/java/org/apache/cassandra/db/ColumnFamilyStore.java b/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
index 36d618fa33..c0e27dd249 100644
--- a/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
+++ b/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
@@ -30,7 +30,6 @@ import java.util.concurrent.locks.Condition;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
 
-import com.reardencommerce.kernel.collections.shared.evictable.ConcurrentLinkedHashMap;
 import org.apache.cassandra.service.SliceRange;
 import org.apache.log4j.Logger;
 
@@ -752,15 +751,15 @@ public final class ColumnFamilyStore implements ColumnFamilyStoreMBean
         return getColumnFamily(filter, CompactionManager.getDefaultGCBefore());
     }
 
-    private ColumnFamily getCachedRow(QueryFilter filter) throws IOException
+    private ColumnFamily cacheRow(String key) throws IOException
     {
         ColumnFamily cached;
-        if ((cached = rowCache.get(filter.key)) == null)
+        if ((cached = rowCache.get(key)) == null)
         {
-            cached = getTopLevelColumns(new IdentityQueryFilter(filter.key, new QueryPath(columnFamily_)), Integer.MIN_VALUE);
+            cached = getTopLevelColumns(new IdentityQueryFilter(key, new QueryPath(columnFamily_)), Integer.MIN_VALUE);
             if (cached == null)
                 return null;
-            rowCache.put(filter.key, cached);
+            rowCache.put(key, cached);
         }
         return cached;
     }
@@ -782,11 +781,11 @@ public final class ColumnFamilyStore implements ColumnFamilyStoreMBean
                 if (rowCache == null)
                     return removeDeleted(getTopLevelColumns(filter, gcBefore), gcBefore);
 
-                ColumnFamily cached = getCachedRow(filter);
+                ColumnFamily cached = cacheRow(filter.key);
                 ColumnIterator ci = filter.getMemColumnIterator(memtable_, cached, getComparator()); // TODO passing memtable here is confusing since it's almost entirely unused
                 ColumnFamily returnCF = ci.getColumnFamily();
                 filter.collectCollatedColumns(returnCF, ci, gcBefore);
-                return removeDeleted(returnCF);
+                return removeDeleted(returnCF, gcBefore);
             }
 
             // we are querying subcolumns of a supercolumn: fetch the supercolumn with NQF, then filter in-memory.
@@ -804,12 +803,13 @@ public final class ColumnFamilyStore implements ColumnFamilyStoreMBean
             }
             else
             {
-                cf = getCachedRow(filter);
+                cf = cacheRow(filter.key);
                 if (cf == null)
                     return null;
                 sc = (SuperColumn)cf.getColumn(filter.path.superColumnName);
                 if (sc == null)
                     return null;
+                sc = (SuperColumn)sc.cloneMe();
             }
             
             SuperColumn scFiltered = filter.filterSuperColumn(sc, gcBefore);
@@ -1229,7 +1229,8 @@ public final class ColumnFamilyStore implements ColumnFamilyStoreMBean
         return ssTables_.size();
     }
 
-    public ColumnFamily getCachedRow(String key)
+    /** raw cached row -- does not fetch the row if it is not present */
+    public ColumnFamily getRawCachedRow(String key)
     {
         return rowCache == null ? null : rowCache.get(key);
     }
diff --git a/src/java/org/apache/cassandra/db/Table.java b/src/java/org/apache/cassandra/db/Table.java
index cc9ee5d2b6..1220b7ef70 100644
--- a/src/java/org/apache/cassandra/db/Table.java
+++ b/src/java/org/apache/cassandra/db/Table.java
@@ -33,7 +33,6 @@ import org.apache.cassandra.io.util.FileUtils;
 
 import java.net.InetAddress;
 
-import org.apache.cassandra.service.StorageService;
 import org.apache.cassandra.utils.*;
 import org.apache.cassandra.db.filter.*;
 
@@ -422,7 +421,7 @@ public class Table
                 if ((memtableToFlush=cfs.apply(mutation.key(), columnFamily)) != null)
                     memtablesToFlush.put(cfs, memtableToFlush);
 
-                ColumnFamily cachedRow = cfs.getCachedRow(mutation.key());
+                ColumnFamily cachedRow = cfs.getRawCachedRow(mutation.key());
                 if (cachedRow != null)
                     cachedRow.addAll(columnFamily);
             }
diff --git a/test/system/test_server.py b/test/system/test_server.py
index 887ac7a207..f41f31ad59 100644
--- a/test/system/test_server.py
+++ b/test/system/test_server.py
@@ -183,6 +183,8 @@ class TestMutations(CassandraTester):
 
     def test_missing_super(self):
         _expect_missing(lambda: client.get('Keyspace1', 'key1', ColumnPath('Super1', 'sc1', _i64(1)), ConsistencyLevel.ONE))
+        _insert_super()
+        _expect_missing(lambda: client.get('Keyspace1', 'key1', ColumnPath('Super1', 'sc1', _i64(1)), ConsistencyLevel.ONE))
 
     def test_count(self):
         _insert_simple()
@@ -585,8 +587,8 @@ class TestMutations(CassandraTester):
         assert _big_slice('Keyspace1', 'key1', ColumnParent('Standard1')) == []
         # Next, w/ a newer timestamp; it should come back:
         client.insert('Keyspace1', 'key1', ColumnPath('Standard1', column='c1'), 'value1', 4, ConsistencyLevel.ONE)
-        assert _big_slice('Keyspace1', 'key1', ColumnParent('Standard1')) == \
-            [ColumnOrSuperColumn(column=Column('c1', 'value1', 4))]
+        result = _big_slice('Keyspace1', 'key1', ColumnParent('Standard1'))
+        assert result == [ColumnOrSuperColumn(column=Column('c1', 'value1', 4))], result
 
         # check removing the entire super cf, too.
         client.remove('Keyspace1', 'key1', ColumnPath('Super1'), 3, ConsistencyLevel.ONE)
