diff --git a/src/java/org/apache/cassandra/db/LoadVerbHandler.java b/src/java/org/apache/cassandra/db/LoadVerbHandler.java
index 682a92c917..20f0c86a00 100644
--- a/src/java/org/apache/cassandra/db/LoadVerbHandler.java
+++ b/src/java/org/apache/cassandra/db/LoadVerbHandler.java
@@ -44,7 +44,7 @@ public class LoadVerbHandler implements IVerbHandler
             buffer.reset(body, body.length);
 	        RowMutationMessage rmMsg = RowMutationMessage.serializer().deserialize(buffer);
 
-            EndPoint[] endpoints = StorageService.instance().getNStorageEndPoint(rmMsg.getRowMutation().key());
+            EndPoint[] endpoints = StorageService.instance().getNStorageEndPoint(rmMsg.getRowMutation().key(), 0);
 
 			Message messageInternal = new Message(StorageService.getLocalStorageEndPoint(), 
 	                StorageService.mutationStage_,
@@ -68,4 +68,4 @@ public class LoadVerbHandler implements IVerbHandler
         }        
     }
 
-}
+}
\ No newline at end of file
diff --git a/src/java/org/apache/cassandra/db/RangeReply.java b/src/java/org/apache/cassandra/db/RangeReply.java
index 50f4bb4ec7..f69dfab717 100644
--- a/src/java/org/apache/cassandra/db/RangeReply.java
+++ b/src/java/org/apache/cassandra/db/RangeReply.java
@@ -29,25 +29,22 @@ import org.apache.cassandra.service.StorageService;
 public class RangeReply
 {
     public final List<String> keys;
+    public final boolean rangeCompletedLocally;
 
-    public RangeReply(List<String> keys)
+    public RangeReply(List<String> keys, boolean rangeCompletedLocally)
     {
         this.keys = Collections.unmodifiableList(keys);
+        this.rangeCompletedLocally = rangeCompletedLocally;
     }
 
-    public Message getReply(Message originalMessage)
+    public Message getReply(Message originalMessage) throws IOException
     {
         DataOutputBuffer dob = new DataOutputBuffer();
+        dob.writeBoolean(rangeCompletedLocally);
+
         for (String key : keys)
         {
-            try
-            {
-                dob.writeUTF(key);
-            }
-            catch (IOException e)
-            {
-                throw new RuntimeException(e);
-            }
+            dob.writeUTF(key);
         }
         byte[] data = Arrays.copyOf(dob.getData(), dob.getLength());
         return originalMessage.getReply(StorageService.getLocalStorageEndPoint(), data);
@@ -56,7 +53,9 @@ public class RangeReply
     public static RangeReply read(byte[] body) throws IOException
     {
         DataInputBuffer bufIn = new DataInputBuffer();
+        boolean rangeCompletedLocally;        
         bufIn.reset(body, body.length);
+        rangeCompletedLocally = bufIn.readBoolean();
 
         List<String> keys = new ArrayList<String>();
         while (bufIn.getPosition() < body.length)
@@ -64,6 +63,6 @@ public class RangeReply
             keys.add(bufIn.readUTF());
         }
         
-        return new RangeReply(keys);
+        return new RangeReply(keys, rangeCompletedLocally);
     }
 }
diff --git a/src/java/org/apache/cassandra/db/Table.java b/src/java/org/apache/cassandra/db/Table.java
index 52ac459783..9bf93a0a66 100644
--- a/src/java/org/apache/cassandra/db/Table.java
+++ b/src/java/org/apache/cassandra/db/Table.java
@@ -656,7 +656,7 @@ public class Table
      * @param maxResults
      * @return list of keys between startWith and stopAt
      */
-    public List<String> getKeyRange(String columnFamily, final String startWith, final String stopAt, int maxResults)
+    public RangeReply getKeyRange(String columnFamily, final String startWith, final String stopAt, int maxResults)
     throws IOException, ExecutionException, InterruptedException
     {
         assert getColumnFamilyStore(columnFamily) != null : columnFamily;
@@ -672,7 +672,7 @@ public class Table
         }
     }
 
-    private List<String> getKeyRangeUnsafe(final String cfName, final String startWith, final String stopAt, int maxResults) throws IOException, ExecutionException, InterruptedException
+    private RangeReply getKeyRangeUnsafe(final String cfName, final String startWith, final String stopAt, int maxResults) throws IOException, ExecutionException, InterruptedException
     {
         // (OPP key decoration is a no-op so using the "decorated" comparator against raw keys is fine)
         final Comparator<String> comparator = StorageService.getPartitioner().getDecoratedKeyComparator();
@@ -729,10 +729,12 @@ public class Table
             // pull keys out of the CollatedIterator.  checking tombstone status is expensive,
             // so we set an arbitrary limit on how many we'll do at once.
             List<String> keys = new ArrayList<String>();
+            boolean rangeCompletedLocally = false;
             for (String current : reduced)
             {
                 if (!stopAt.isEmpty() && comparator.compare(stopAt, current) < 0)
                 {
+                    rangeCompletedLocally = true;
                     break;
                 }
                 // make sure there is actually non-tombstone content associated w/ this key
@@ -744,10 +746,11 @@ public class Table
                 }
                 if (keys.size() >= maxResults)
                 {
+                    rangeCompletedLocally = true;
                     break;
                 }
             }
-            return keys;
+            return new RangeReply(keys, rangeCompletedLocally);
         }
         finally
         {
@@ -765,4 +768,4 @@ public class Table
     {
         return dataDirPath + File.separator + tableName + File.separator + SNAPSHOT_SUBDIR_NAME + File.separator + snapshotName;
     }
-}
+}
\ No newline at end of file
diff --git a/src/java/org/apache/cassandra/locator/AbstractStrategy.java b/src/java/org/apache/cassandra/locator/AbstractStrategy.java
index 1d2979c17d..3d2219e15b 100644
--- a/src/java/org/apache/cassandra/locator/AbstractStrategy.java
+++ b/src/java/org/apache/cassandra/locator/AbstractStrategy.java
@@ -104,7 +104,7 @@ public abstract class AbstractStrategy implements IReplicaPlacementStrategy
     {
         List<EndPoint> liveList = new ArrayList<EndPoint>();
         Map<EndPoint, EndPoint> map = new HashMap<EndPoint, EndPoint>();
-        EndPoint[] topN = getStorageEndPoints( token );
+        EndPoint[] topN = getStorageEndPoints( token, 0);
 
         for( int i = 0 ; i < topN.length ; i++)
         {
@@ -131,5 +131,5 @@ public abstract class AbstractStrategy implements IReplicaPlacementStrategy
         return map;
     }
 
-    public abstract EndPoint[] getStorageEndPoints(Token token);
-}
+    public abstract EndPoint[] getStorageEndPoints(Token token, int offset);
+}
\ No newline at end of file
diff --git a/src/java/org/apache/cassandra/locator/IReplicaPlacementStrategy.java b/src/java/org/apache/cassandra/locator/IReplicaPlacementStrategy.java
index 3cd1bd50ba..4f77dc94ad 100644
--- a/src/java/org/apache/cassandra/locator/IReplicaPlacementStrategy.java
+++ b/src/java/org/apache/cassandra/locator/IReplicaPlacementStrategy.java
@@ -33,8 +33,8 @@ import org.apache.cassandra.net.EndPoint;
  */
 public interface IReplicaPlacementStrategy
 {
-	public EndPoint[] getStorageEndPoints(Token token);
-    public Map<String, EndPoint[]> getStorageEndPoints(String[] keys);
-    public EndPoint[] getStorageEndPoints(Token token, Map<Token, EndPoint> tokenToEndPointMap);
+	public EndPoint[] getStorageEndPoints(Token token, int offset);
+    public Map<String, EndPoint[]> getStorageEndPoints(String[] keys, int offset);
+    public EndPoint[] getStorageEndPoints(Token token, Map<Token, EndPoint> tokenToEndPointMap, int offset);
     public Map<EndPoint, EndPoint> getHintedStorageEndPoints(Token token);
-}
+}
\ No newline at end of file
diff --git a/src/java/org/apache/cassandra/locator/RackAwareStrategy.java b/src/java/org/apache/cassandra/locator/RackAwareStrategy.java
index 19dd986613..26770933d6 100644
--- a/src/java/org/apache/cassandra/locator/RackAwareStrategy.java
+++ b/src/java/org/apache/cassandra/locator/RackAwareStrategy.java
@@ -45,7 +45,7 @@ public class RackAwareStrategy extends AbstractStrategy
         super(tokenMetadata, partitioner, replicas, storagePort);
     }
 
-    public EndPoint[] getStorageEndPoints(Token token)
+    public EndPoint[] getStorageEndPoints(Token token,  int offset)
     {
         int startIndex;
         List<EndPoint> list = new ArrayList<EndPoint>();
@@ -123,19 +123,19 @@ public class RackAwareStrategy extends AbstractStrategy
         return list.toArray(new EndPoint[list.size()]);
     }
     
-    public Map<String, EndPoint[]> getStorageEndPoints(String[] keys)
+    public Map<String, EndPoint[]> getStorageEndPoints(String[] keys, int offset)
     {
     	Map<String, EndPoint[]> results = new HashMap<String, EndPoint[]>();
 
         for ( String key : keys )
         {
-            results.put(key, getStorageEndPoints(partitioner_.getInitialToken(key)));
+            results.put(key, getStorageEndPoints(partitioner_.getInitialToken(key), offset));
         }
 
         return results;
     }
 
-    public EndPoint[] getStorageEndPoints(Token token, Map<Token, EndPoint> tokenToEndPointMap)
+    public EndPoint[] getStorageEndPoints(Token token, Map<Token, EndPoint> tokenToEndPointMap, int offset)
     {
         throw new UnsupportedOperationException("This operation is not currently supported");
     }
diff --git a/src/java/org/apache/cassandra/locator/RackUnawareStrategy.java b/src/java/org/apache/cassandra/locator/RackUnawareStrategy.java
index cdcd3116aa..750703f596 100644
--- a/src/java/org/apache/cassandra/locator/RackUnawareStrategy.java
+++ b/src/java/org/apache/cassandra/locator/RackUnawareStrategy.java
@@ -41,12 +41,12 @@ public class RackUnawareStrategy extends AbstractStrategy
         super(tokenMetadata, partitioner, replicas, storagePort);
     }
 
-    public EndPoint[] getStorageEndPoints(Token token)
+    public EndPoint[] getStorageEndPoints(Token token, int offset)
     {
-        return getStorageEndPoints(token, tokenMetadata_.cloneTokenEndPointMap());            
+        return getStorageEndPoints(token, tokenMetadata_.cloneTokenEndPointMap(), offset);            
     }
     
-    public EndPoint[] getStorageEndPoints(Token token, Map<Token, EndPoint> tokenToEndPointMap)
+    public EndPoint[] getStorageEndPoints(Token token, Map<Token, EndPoint> tokenToEndPointMap, int offset)
     {
         int startIndex;
         List<EndPoint> list = new ArrayList<EndPoint>();
@@ -61,8 +61,9 @@ public class RackUnawareStrategy extends AbstractStrategy
                 index = 0;
         }
         int totalNodes = tokens.size();
+        int realIndex = (index + offset) % totalNodes;
         // Add the node at the index by default
-        list.add(tokenToEndPointMap.get(tokens.get(index)));
+        list.add(tokenToEndPointMap.get(tokens.get(realIndex)));
         foundCount++;
         startIndex = (index + 1)%totalNodes;
         // If we found N number of nodes we are good. This loop will just exit. Otherwise just
@@ -79,15 +80,15 @@ public class RackUnawareStrategy extends AbstractStrategy
         return list.toArray(new EndPoint[list.size()]);
     }
             
-    public Map<String, EndPoint[]> getStorageEndPoints(String[] keys)
+    public Map<String, EndPoint[]> getStorageEndPoints(String[] keys, int offset)
     {
     	Map<String, EndPoint[]> results = new HashMap<String, EndPoint[]>();
 
         for ( String key : keys )
         {
-            results.put(key, getStorageEndPoints(partitioner_.getInitialToken(key)));
+            results.put(key, getStorageEndPoints(partitioner_.getInitialToken(key), offset));
         }
 
         return results;
     }
-}
+}
\ No newline at end of file
diff --git a/src/java/org/apache/cassandra/service/RangeVerbHandler.java b/src/java/org/apache/cassandra/service/RangeVerbHandler.java
index a12b3b1da0..283c136e38 100644
--- a/src/java/org/apache/cassandra/service/RangeVerbHandler.java
+++ b/src/java/org/apache/cassandra/service/RangeVerbHandler.java
@@ -18,8 +18,6 @@
 */
 package org.apache.cassandra.service;
 
-import java.util.List;
-
 import org.apache.cassandra.db.RangeCommand;
 import org.apache.cassandra.db.RangeReply;
 import org.apache.cassandra.db.Table;
@@ -31,19 +29,19 @@ public class RangeVerbHandler implements IVerbHandler
 {
     public void doVerb(Message message)
     {
-        List<String> keys;
+        RangeReply rangeReply;
         try
         {
             RangeCommand command = RangeCommand.read(message);
             Table table = Table.open(command.table);
-            keys = table.getKeyRange(command.columnFamily, command.startWith, command.stopAt, command.maxResults);
+
+            rangeReply = table.getKeyRange(command.columnFamily, command.startWith, command.stopAt, command.maxResults);
+            Message response = rangeReply.getReply(message);
+            MessagingService.getMessagingInstance().sendOneWay(response, message.getFrom());
         }
         catch (Exception e)
         {
             throw new RuntimeException(e);
         }
-
-        Message response = new RangeReply(keys).getReply(message);
-        MessagingService.getMessagingInstance().sendOneWay(response, message.getFrom());
     }
 }
diff --git a/src/java/org/apache/cassandra/service/StorageProxy.java b/src/java/org/apache/cassandra/service/StorageProxy.java
index 4663f45c95..571b44f3a2 100644
--- a/src/java/org/apache/cassandra/service/StorageProxy.java
+++ b/src/java/org/apache/cassandra/service/StorageProxy.java
@@ -164,7 +164,7 @@ public class StorageProxy implements StorageProxyMBean
         }
         try
         {
-            EndPoint[] endpoints = StorageService.instance().getNStorageEndPoint(rm.key());
+            EndPoint[] endpoints = StorageService.instance().getNStorageEndPoint(rm.key(), 0);
             if (endpoints.length < (DatabaseDescriptor.getReplicationFactor() / 2) + 1)
             {
                 throw new UnavailableException();
@@ -312,7 +312,7 @@ public class StorageProxy implements StorageProxyMBean
         long startTime = System.currentTimeMillis();
 
         Row row;
-        EndPoint[] endpoints = StorageService.instance().getNStorageEndPoint(command.key);
+        EndPoint[] endpoints = StorageService.instance().getNStorageEndPoint(command.key, 0);
 
         if (consistency_level == ConsistencyLevel.ONE)
         {
@@ -413,7 +413,7 @@ public class StorageProxy implements StorageProxyMBean
                 DatabaseDescriptor.getQuorum(),
                 readResponseResolver);
         EndPoint dataPoint = StorageService.instance().findSuitableEndPoint(command.key);
-        List<EndPoint> endpointList = new ArrayList<EndPoint>(Arrays.asList(StorageService.instance().getNStorageEndPoint(command.key)));
+        List<EndPoint> endpointList = new ArrayList<EndPoint>(Arrays.asList(StorageService.instance().getNStorageEndPoint(command.key, 0)));
         /* Remove the local storage endpoint from the list. */
         endpointList.remove(dataPoint);
         EndPoint[] endPoints = new EndPoint[endpointList.size() + 1];
@@ -634,15 +634,52 @@ public class StorageProxy implements StorageProxyMBean
     static List<String> getKeyRange(RangeCommand command)
     {
         long startTime = System.currentTimeMillis();
+        int endpointOffset = 0;
+        List<String> allKeys = new ArrayList<String>();
+        int maxResults = command.maxResults;
+
         try
         {
-            EndPoint endPoint = StorageService.instance().findSuitableEndPoint(command.startWith);
-            IAsyncResult iar = MessagingService.getMessagingInstance().sendRR(command.getMessage(), endPoint);
+            EndPoint endPoint = StorageService.instance().findSuitableEndPoint(command.startWith, endpointOffset);
+            String firstEndpoint = endPoint.toString();
+
+            do
+            {
+                IAsyncResult iar = MessagingService.getMessagingInstance().sendRR(command.getMessage(), endPoint);
+
+                // read response
+                byte[] responseBody = iar.get(DatabaseDescriptor.getRpcTimeout(), TimeUnit.MILLISECONDS);
+                RangeReply rangeReply = RangeReply.read(responseBody);
+                List<String> rangeKeys = rangeReply.keys;
+
+                // deal with key overlaps
+                if (allKeys.size() > 0 && rangeKeys != null && rangeKeys.size() > 0 && allKeys.get(allKeys.size() - 1).equals(rangeKeys.get(0)))
+                {
+                    allKeys.remove(allKeys.size() - 1);
+                    allKeys.addAll(rangeKeys);
+                }
+                else if (rangeKeys.size() > 0)
+                {
+                    allKeys.addAll(rangeKeys);
+                }
+
+                if (allKeys.size() >= maxResults || rangeReply.rangeCompletedLocally)
+                {
+                    break;
+                }
+
+                String newStartAt = (allKeys.size() > 0) ? allKeys.get(allKeys.size() - 1) : command.stopAt;
+
+                command = new RangeCommand(command.table, command.columnFamily,
+                                           newStartAt, command.stopAt,
+                                           command.maxResults - rangeKeys.size());
+
+                endPoint = StorageService.instance().findSuitableEndPoint(command.startWith, ++endpointOffset);
+            } while (!endPoint.toString().equals(firstEndpoint));
 
-            // read response
-            // TODO send more requests if we need to span multiple nodes
-            byte[] responseBody = iar.get(DatabaseDescriptor.getRpcTimeout(), TimeUnit.MILLISECONDS);
-            return RangeReply.read(responseBody).keys;
+            return (allKeys.size() > maxResults)
+                   ? allKeys.subList(0, maxResults)
+                   : allKeys;
         }
         catch (Exception e)
         {
@@ -683,4 +720,4 @@ public class StorageProxy implements StorageProxyMBean
     {
         return writeStats.size();
     }
-}
+}
\ No newline at end of file
diff --git a/src/java/org/apache/cassandra/service/StorageService.java b/src/java/org/apache/cassandra/service/StorageService.java
index 577c6c84ac..dc69b6700f 100644
--- a/src/java/org/apache/cassandra/service/StorageService.java
+++ b/src/java/org/apache/cassandra/service/StorageService.java
@@ -931,16 +931,20 @@ public final class StorageService implements IEndPointStateChangeSubscriber, Sto
      * @param key - key for which we need to find the endpoint return value -
      * the endpoint responsible for this key
      */
-    public EndPoint[] getNStorageEndPoint(String key)
+    public EndPoint[] getNStorageEndPoint(String key, int offset)
     {
-        return nodePicker_.getStorageEndPoints(partitioner_.getInitialToken(key));
+        return nodePicker_.getStorageEndPoints(partitioner_.getInitialToken(key), offset);
     }
     
-    private Map<String, EndPoint[]> getNStorageEndPoints(String[] keys)
+    private Map<String, EndPoint[]> getNStorageEndPoints(String[] keys,  int offset)
     {
-    	return nodePicker_.getStorageEndPoints(keys);
+    	return nodePicker_.getStorageEndPoints(keys, offset);
     }
     
+    private Map<String, EndPoint[]> getNStorageEndPoints(String[] keys)
+    {
+    	return getNStorageEndPoints(keys, 0);
+    }
     
     /**
      * This method attempts to return N endpoints that are responsible for storing the
@@ -952,7 +956,7 @@ public final class StorageService implements IEndPointStateChangeSubscriber, Sto
     public List<EndPoint> getNLiveStorageEndPoint(String key)
     {
     	List<EndPoint> liveEps = new ArrayList<EndPoint>();
-    	EndPoint[] endpoints = getNStorageEndPoint(key);
+    	EndPoint[] endpoints = getNStorageEndPoint(key, 0);
     	
     	for ( EndPoint endpoint : endpoints )
     	{
@@ -983,7 +987,7 @@ public final class StorageService implements IEndPointStateChangeSubscriber, Sto
      */
     public EndPoint[] getNStorageEndPoint(Token token)
     {
-        return nodePicker_.getStorageEndPoints(token);
+        return nodePicker_.getStorageEndPoints(token, 0);
     }
     
     /**
@@ -996,16 +1000,21 @@ public final class StorageService implements IEndPointStateChangeSubscriber, Sto
      */
     protected EndPoint[] getNStorageEndPoint(Token token, Map<Token, EndPoint> tokenToEndPointMap)
     {
-        return nodePicker_.getStorageEndPoints(token, tokenToEndPointMap);
+        return nodePicker_.getStorageEndPoints(token, tokenToEndPointMap, 0);
+    }
+
+    public EndPoint findSuitableEndPoint(String key) throws IOException
+    {
+        return findSuitableEndPoint(key, 0);
     }
 
     /**
      * This function finds the most suitable endpoint given a key.
      * It checks for locality and alive test.
      */
-	public EndPoint findSuitableEndPoint(String key) throws IOException
+	public EndPoint findSuitableEndPoint(String key, int offset) throws IOException
 	{
-		EndPoint[] endpoints = getNStorageEndPoint(key);
+		EndPoint[] endpoints = getNStorageEndPoint(key, offset);
 		for(EndPoint endPoint: endpoints)
 		{
 			if(endPoint.equals(StorageService.getLocalStorageEndPoint()))
diff --git a/src/java/org/apache/cassandra/tools/KeyChecker.java b/src/java/org/apache/cassandra/tools/KeyChecker.java
index d844561f74..8cf4c92082 100644
--- a/src/java/org/apache/cassandra/tools/KeyChecker.java
+++ b/src/java/org/apache/cassandra/tools/KeyChecker.java
@@ -40,7 +40,7 @@ public class KeyChecker
      */
     private static boolean checkIfProcessKey(String key)
     {
-        EndPoint[] endPoints = StorageService.instance().getNStorageEndPoint(key);
+        EndPoint[] endPoints = StorageService.instance().getNStorageEndPoint(key, 0);
         EndPoint localEndPoint = StorageService.getLocalStorageEndPoint();
         for(EndPoint endPoint : endPoints)
         {
@@ -96,4 +96,4 @@ public class KeyChecker
         System.out.println("DONE checking keys ...");
         raf.close();
     }
-}
+}
\ No newline at end of file
diff --git a/test/unit/org/apache/cassandra/db/CompactionsTest.java b/test/unit/org/apache/cassandra/db/CompactionsTest.java
index 873d7aff93..5e478c011a 100644
--- a/test/unit/org/apache/cassandra/db/CompactionsTest.java
+++ b/test/unit/org/apache/cassandra/db/CompactionsTest.java
@@ -52,7 +52,7 @@ public class CompactionsTest extends CleanupHelper
                 inserted.add(key);
             }
             store.forceBlockingFlush();
-            assertEquals(table.getKeyRange("Standard1", "", "", 10000).size(), inserted.size());
+            assertEquals(table.getKeyRange("Standard1", "", "", 10000).keys.size(), inserted.size());
         }
         while (true)
         {
@@ -64,6 +64,6 @@ public class CompactionsTest extends CleanupHelper
         {
             store.doCompaction(store.getSSTables().size());
         }
-        assertEquals(table.getKeyRange("Standard1", "", "", 10000).size(), inserted.size());
+        assertEquals(table.getKeyRange("Standard1", "", "", 10000).keys.size(), inserted.size());
     }
 }
diff --git a/test/unit/org/apache/cassandra/db/OneCompactionTest.java b/test/unit/org/apache/cassandra/db/OneCompactionTest.java
index 2cc74b7716..1866d343e4 100644
--- a/test/unit/org/apache/cassandra/db/OneCompactionTest.java
+++ b/test/unit/org/apache/cassandra/db/OneCompactionTest.java
@@ -45,12 +45,12 @@ public class OneCompactionTest
             rm.apply();
             inserted.add(key);
             store.forceBlockingFlush();
-            assertEquals(table.getKeyRange(columnFamilyName, "", "", 10000).size(), inserted.size());
+            assertEquals(table.getKeyRange(columnFamilyName, "", "", 10000).keys.size(), inserted.size());
         }
         Future<Integer> ft = MinorCompactionManager.instance().submit(store, 2);
         ft.get();
         assertEquals(1, store.getSSTables().size());
-        assertEquals(table.getKeyRange(columnFamilyName, "", "", 10000).size(), inserted.size());
+        assertEquals(table.getKeyRange(columnFamilyName, "", "", 10000).keys.size(), inserted.size());
     }
 
     @Test
diff --git a/test/unit/org/apache/cassandra/db/RecoveryManager2Test.java b/test/unit/org/apache/cassandra/db/RecoveryManager2Test.java
index d57d979d98..fc2c744b57 100644
--- a/test/unit/org/apache/cassandra/db/RecoveryManager2Test.java
+++ b/test/unit/org/apache/cassandra/db/RecoveryManager2Test.java
@@ -34,7 +34,7 @@ public class RecoveryManager2Test extends CleanupHelper
         table1.getColumnFamilyStore("Standard1").clearUnsafe();
         RecoveryManager.doRecovery();
 
-        Set<String> foundKeys = new HashSet<String>(table1.getKeyRange("Standard1", "", "", 1000));
+        Set<String> foundKeys = new HashSet<String>(table1.getKeyRange("Standard1", "", "", 1000).keys);
         assert keys.equals(foundKeys);
     }
 }
diff --git a/test/unit/org/apache/cassandra/locator/RackUnawareStrategyTest.java b/test/unit/org/apache/cassandra/locator/RackUnawareStrategyTest.java
index 520d65567a..2bf071c3b3 100644
--- a/test/unit/org/apache/cassandra/locator/RackUnawareStrategyTest.java
+++ b/test/unit/org/apache/cassandra/locator/RackUnawareStrategyTest.java
@@ -78,7 +78,7 @@ public class RackUnawareStrategyTest
 
         for (int i = 0; i < keyTokens.length; i++)
         {
-            EndPoint[] endPoints = strategy.getStorageEndPoints(keyTokens[i]);
+            EndPoint[] endPoints = strategy.getStorageEndPoints(keyTokens[i], 0);
             assert endPoints.length == 3;
             for (int j = 0; j < endPoints.length; j++)
             {
