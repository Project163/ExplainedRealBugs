diff --git a/CHANGES.txt b/CHANGES.txt
index a729d350b4..532c958a33 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 3.11.2
+ * Round buffer size to powers of 2 for the chunk cache (CASSANDRA-13897)
  * Update jackson JSON jars (CASSANDRA-13949)
  * Avoid locks when checking LCS fanout and if we should defrag (CASSANDRA-13930)
 Merged from 3.0:
diff --git a/src/java/org/apache/cassandra/cache/ChunkCache.java b/src/java/org/apache/cassandra/cache/ChunkCache.java
index 15cf2ce913..4e7f848443 100644
--- a/src/java/org/apache/cassandra/cache/ChunkCache.java
+++ b/src/java/org/apache/cassandra/cache/ChunkCache.java
@@ -41,6 +41,7 @@ public class ChunkCache
 {
     public static final int RESERVED_POOL_SPACE_IN_MB = 32;
     public static final long cacheSize = 1024L * 1024L * Math.max(0, DatabaseDescriptor.getFileCacheSizeInMB() - RESERVED_POOL_SPACE_IN_MB);
+    public static final boolean roundUp = DatabaseDescriptor.getFileCacheRoundUp();
 
     private static boolean enabled = cacheSize > 0;
     public static final ChunkCache instance = enabled ? new ChunkCache() : null;
@@ -219,7 +220,7 @@ public class ChunkCache
         {
             source = file;
             int chunkSize = file.chunkSize();
-            assert Integer.bitCount(chunkSize) == 1;    // Must be power of two
+            assert Integer.bitCount(chunkSize) == 1 : String.format("%d must be a power of two", chunkSize);
             alignmentMask = -chunkSize;
         }
 
diff --git a/src/java/org/apache/cassandra/config/Config.java b/src/java/org/apache/cassandra/config/Config.java
index 8fde816191..9489af93ad 100644
--- a/src/java/org/apache/cassandra/config/Config.java
+++ b/src/java/org/apache/cassandra/config/Config.java
@@ -265,6 +265,17 @@ public class Config
 
     public Integer file_cache_size_in_mb;
 
+    /**
+     * Because of the current {@link org.apache.cassandra.utils.memory.BufferPool} slab sizes of 64 kb, we
+     * store in the file cache buffers that divide 64 kb, so we need to round the buffer sizes to powers of two.
+     * This boolean controls weather they are rounded up or down. Set it to true to round up to the
+     * next power of two, set it to false to round down to the previous power of two. Note that buffer sizes are
+     * already rounded to 4 kb and capped between 4 kb minimum and 64 kb maximum by the {@link DiskOptimizationStrategy}.
+     * By default, this boolean is set to round down when {@link #disk_optimization_strategy} is {@code ssd},
+     * and to round up when it is {@code spinning}.
+     */
+    public Boolean file_cache_round_up;
+
     public boolean buffer_pool_use_heap_if_exhausted = true;
 
     public DiskOptimizationStrategy disk_optimization_strategy = DiskOptimizationStrategy.ssd;
diff --git a/src/java/org/apache/cassandra/config/DatabaseDescriptor.java b/src/java/org/apache/cassandra/config/DatabaseDescriptor.java
index 4ce2728b4b..27b8b95b5b 100644
--- a/src/java/org/apache/cassandra/config/DatabaseDescriptor.java
+++ b/src/java/org/apache/cassandra/config/DatabaseDescriptor.java
@@ -409,6 +409,10 @@ public class DatabaseDescriptor
         if (conf.file_cache_size_in_mb == null)
             conf.file_cache_size_in_mb = Math.min(512, (int) (Runtime.getRuntime().maxMemory() / (4 * 1048576)));
 
+        // round down for SSDs and round up for spinning disks
+        if (conf.file_cache_round_up == null)
+            conf.file_cache_round_up = conf.disk_optimization_strategy == Config.DiskOptimizationStrategy.spinning;
+
         if (conf.memtable_offheap_space_in_mb == null)
             conf.memtable_offheap_space_in_mb = (int) (Runtime.getRuntime().maxMemory() / (4 * 1048576));
         if (conf.memtable_offheap_space_in_mb < 0)
@@ -2060,6 +2064,18 @@ public class DatabaseDescriptor
         return conf.file_cache_size_in_mb;
     }
 
+    public static boolean getFileCacheRoundUp()
+    {
+        if (conf.file_cache_round_up == null)
+        {
+            // In client mode the value is not set.
+            assert DatabaseDescriptor.isClientInitialized();
+            return false;
+        }
+
+        return conf.file_cache_round_up;
+    }
+
     public static boolean getBufferPoolUseHeapIfExhausted()
     {
         return conf.buffer_pool_use_heap_if_exhausted;
diff --git a/src/java/org/apache/cassandra/io/util/DiskOptimizationStrategy.java b/src/java/org/apache/cassandra/io/util/DiskOptimizationStrategy.java
index e10342d895..272291ea80 100644
--- a/src/java/org/apache/cassandra/io/util/DiskOptimizationStrategy.java
+++ b/src/java/org/apache/cassandra/io/util/DiskOptimizationStrategy.java
@@ -20,6 +20,9 @@ package org.apache.cassandra.io.util;
 
 public interface DiskOptimizationStrategy
 {
+    int MIN_BUFFER_SIZE = 1 << 12; // 4096, the typical size of a page in the OS cache
+    int MIN_BUFFER_SIZE_MASK = MIN_BUFFER_SIZE - 1;
+
     // The maximum buffer size, we will never buffer more than this size. Further,
     // when the limiter is not null, i.e. when throttling is enabled, we read exactly
     // this size, since when throttling the intention is to eventually read everything,
@@ -40,9 +43,32 @@ public interface DiskOptimizationStrategy
     default int roundBufferSize(long size)
     {
         if (size <= 0)
-            return 4096;
+            return MIN_BUFFER_SIZE;
 
-        size = (size + 4095) & ~4095;
+        size = (size + MIN_BUFFER_SIZE_MASK) & ~MIN_BUFFER_SIZE_MASK;
         return (int)Math.min(size, MAX_BUFFER_SIZE);
     }
+
+    /**
+     * Round either up or down to the next power of two, which is required by the
+     * {@link org.apache.cassandra.cache.ChunkCache.CachingRebufferer}, but capping between {@link #MIN_BUFFER_SIZE}
+     * and {@link #MAX_BUFFER_SIZE}.
+     *
+     * @param size - the size to round to a power of two, normally this is a buffer size that was previously
+     *             returned by a {@link #bufferSize(long)}.
+     * @param roundUp - whether to round up or down
+     *
+     * @return a value rounded to a power of two but never bigger than {@link #MAX_BUFFER_SIZE} or smaller than {@link #MIN_BUFFER_SIZE}.
+     */
+    static int roundForCaching(int size, boolean roundUp)
+    {
+        if (size <= MIN_BUFFER_SIZE)
+            return MIN_BUFFER_SIZE;
+
+        int ret = roundUp
+                  ? 1 << (32 - Integer.numberOfLeadingZeros(size - 1))
+                  : Integer.highestOneBit(size);
+
+        return Math.min(MAX_BUFFER_SIZE, ret);
+    }
 }
diff --git a/src/java/org/apache/cassandra/io/util/FileHandle.java b/src/java/org/apache/cassandra/io/util/FileHandle.java
index 9e03d3b052..a3afc2f931 100644
--- a/src/java/org/apache/cassandra/io/util/FileHandle.java
+++ b/src/java/org/apache/cassandra/io/util/FileHandle.java
@@ -378,7 +378,8 @@ public class FileHandle extends SharedCloseableImpl
                     }
                     else
                     {
-                        rebuffererFactory = maybeCached(new SimpleChunkReader(channelCopy, length, bufferType, bufferSize));
+                        int chunkSize = DiskOptimizationStrategy.roundForCaching(bufferSize, ChunkCache.roundUp);
+                        rebuffererFactory = maybeCached(new SimpleChunkReader(channelCopy, length, bufferType, chunkSize));
                     }
                 }
                 Cleanup cleanup = new Cleanup(channelCopy, rebuffererFactory, compressionMetadata, chunkCache);
diff --git a/test/unit/org/apache/cassandra/io/util/DiskOptimizationStrategyTest.java b/test/unit/org/apache/cassandra/io/util/DiskOptimizationStrategyTest.java
index 986df960e8..ed1f9488d3 100644
--- a/test/unit/org/apache/cassandra/io/util/DiskOptimizationStrategyTest.java
+++ b/test/unit/org/apache/cassandra/io/util/DiskOptimizationStrategyTest.java
@@ -82,4 +82,58 @@ public class DiskOptimizationStrategyTest
         assertEquals(8192, strategy.bufferSize(4096));
         assertEquals(12288, strategy.bufferSize(4097));
     }
+
+    @Test
+    public void testRoundUpForCaching()
+    {
+        assertEquals(4096, DiskOptimizationStrategy.roundForCaching(-1, true));
+        assertEquals(4096, DiskOptimizationStrategy.roundForCaching(0, true));
+        assertEquals(4096, DiskOptimizationStrategy.roundForCaching(1, true));
+        assertEquals(4096, DiskOptimizationStrategy.roundForCaching(4095, true));
+        assertEquals(4096, DiskOptimizationStrategy.roundForCaching(4096, true));
+        assertEquals(8192, DiskOptimizationStrategy.roundForCaching(4097, true));
+        assertEquals(8192, DiskOptimizationStrategy.roundForCaching(4098, true));
+        assertEquals(8192, DiskOptimizationStrategy.roundForCaching(8192, true));
+        assertEquals(16384, DiskOptimizationStrategy.roundForCaching(8193, true));
+        assertEquals(16384, DiskOptimizationStrategy.roundForCaching(12288, true));
+        assertEquals(16384, DiskOptimizationStrategy.roundForCaching(16384, true));
+        assertEquals(65536, DiskOptimizationStrategy.roundForCaching(65536, true));
+        assertEquals(65536, DiskOptimizationStrategy.roundForCaching(65537, true));
+        assertEquals(65536, DiskOptimizationStrategy.roundForCaching(131072, true));
+
+        for (int cs = 4096; cs < 65536; cs <<= 1) // 4096, 8192, 12288, ..., 65536
+        {
+            for (int i = (cs - 4095); i <= cs; i++) // 1 -> 4096, 4097 -> 8192, ...
+            {
+                assertEquals(cs, DiskOptimizationStrategy.roundForCaching(i, true));
+            }
+        }
+    }
+
+    @Test
+    public void testRoundDownForCaching()
+    {
+        assertEquals(4096, DiskOptimizationStrategy.roundForCaching(-1, false));
+        assertEquals(4096, DiskOptimizationStrategy.roundForCaching(0, false));
+        assertEquals(4096, DiskOptimizationStrategy.roundForCaching(1, false));
+        assertEquals(4096, DiskOptimizationStrategy.roundForCaching(4095, false));
+        assertEquals(4096, DiskOptimizationStrategy.roundForCaching(4096, false));
+        assertEquals(4096, DiskOptimizationStrategy.roundForCaching(4097, false));
+        assertEquals(4096, DiskOptimizationStrategy.roundForCaching(4098, false));
+        assertEquals(8192, DiskOptimizationStrategy.roundForCaching(8192, false));
+        assertEquals(8192, DiskOptimizationStrategy.roundForCaching(8193, false));
+        assertEquals(8192, DiskOptimizationStrategy.roundForCaching(12288, false));
+        assertEquals(16384, DiskOptimizationStrategy.roundForCaching(16384, false));
+        assertEquals(65536, DiskOptimizationStrategy.roundForCaching(65536, false));
+        assertEquals(65536, DiskOptimizationStrategy.roundForCaching(65537, false));
+        assertEquals(65536, DiskOptimizationStrategy.roundForCaching(131072, false));
+
+        for (int cs = 4096; cs < 65536; cs <<= 1) // 4096, 8192, 12288, ..., 65536
+        {
+            for (int i = cs; i < cs * 2 - 1; i++) // 4096 -> 8191, 8192 -> 12287, ...
+            {
+                assertEquals(cs, DiskOptimizationStrategy.roundForCaching(i, false));
+            }
+        }
+    }
 }
