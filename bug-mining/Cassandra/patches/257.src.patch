diff --git a/src/java/org/apache/cassandra/db/ColumnFamily.java b/src/java/org/apache/cassandra/db/ColumnFamily.java
index 0369725153..817257f3c5 100644
--- a/src/java/org/apache/cassandra/db/ColumnFamily.java
+++ b/src/java/org/apache/cassandra/db/ColumnFamily.java
@@ -20,14 +20,14 @@ package org.apache.cassandra.db;
 
 import java.util.Collection;
 import java.util.HashMap;
-import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.SortedSet;
-import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.ConcurrentSkipListMap;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicLong;
 
 import org.apache.log4j.Logger;
 
@@ -35,6 +35,7 @@ import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.io.ICompactSerializer2;
 import org.apache.cassandra.db.filter.QueryPath;
 import org.apache.cassandra.db.marshal.AbstractType;
+import org.apache.cassandra.utils.FBUtilities;
 
 
 public final class ColumnFamily implements IColumnContainer
@@ -78,8 +79,8 @@ public final class ColumnFamily implements IColumnContainer
     private String name_;
 
     private transient ICompactSerializer2<IColumn> columnSerializer_;
-    long markedForDeleteAt = Long.MIN_VALUE;
-    int localDeletionTime = Integer.MIN_VALUE;
+    AtomicLong markedForDeleteAt = new AtomicLong(Long.MIN_VALUE);
+    AtomicInteger localDeletionTime = new AtomicInteger(Integer.MIN_VALUE);
     private ConcurrentSkipListMap<byte[], IColumn> columns_;
 
     public ColumnFamily(String cfName, String columnType, AbstractType comparator, AbstractType subcolumnComparator)
@@ -190,26 +191,23 @@ public final class ColumnFamily implements IColumnContainer
     public void addColumn(IColumn column)
     {
         byte[] name = column.name();
-        IColumn oldColumn = columns_.get(name);
+        IColumn oldColumn = columns_.putIfAbsent(name, column);
         if (oldColumn != null)
         {
             if (oldColumn instanceof SuperColumn)
             {
-                int oldSize = oldColumn.size();
                 ((SuperColumn) oldColumn).putColumn(column);
             }
             else
             {
-                if (((Column)oldColumn).comparePriority((Column)column) <= 0)
+                while (((Column) oldColumn).comparePriority((Column)column) <= 0)
                 {
-                    columns_.put(name, column);
+                    if (columns_.replace(name, oldColumn, column))
+                        break;
+                    oldColumn = columns_.get(name);
                 }
             }
         }
-        else
-        {
-            columns_.put(name, column);
-        }
     }
 
     public IColumn getColumn(byte[] name)
@@ -237,21 +235,22 @@ public final class ColumnFamily implements IColumnContainer
     	columns_.remove(columnName);
     }
 
+    @Deprecated // TODO this is a hack to set initial value outside constructor
     public void delete(int localtime, long timestamp)
     {
-        localDeletionTime = localtime;
-        markedForDeleteAt = timestamp;
+        localDeletionTime.set(localtime);
+        markedForDeleteAt.set(timestamp);
     }
 
     public void delete(ColumnFamily cf2)
     {
-        delete(Math.max(getLocalDeletionTime(), cf2.getLocalDeletionTime()),
-               Math.max(getMarkedForDeleteAt(), cf2.getMarkedForDeleteAt()));
+        FBUtilities.atomicSetMax(localDeletionTime, cf2.getLocalDeletionTime());
+        FBUtilities.atomicSetMax(markedForDeleteAt, cf2.getMarkedForDeleteAt());
     }
 
     public boolean isMarkedForDelete()
     {
-        return markedForDeleteAt > Long.MIN_VALUE;
+        return markedForDeleteAt.get() > Long.MIN_VALUE;
     }
 
     /*
@@ -367,12 +366,12 @@ public final class ColumnFamily implements IColumnContainer
 
     public long getMarkedForDeleteAt()
     {
-        return markedForDeleteAt;
+        return markedForDeleteAt.get();
     }
 
     public int getLocalDeletionTime()
     {
-        return localDeletionTime;
+        return localDeletionTime.get();
     }
 
     public String type()
diff --git a/src/java/org/apache/cassandra/db/ColumnFamilySerializer.java b/src/java/org/apache/cassandra/db/ColumnFamilySerializer.java
index 065e2275e3..7ee1adf2a6 100644
--- a/src/java/org/apache/cassandra/db/ColumnFamilySerializer.java
+++ b/src/java/org/apache/cassandra/db/ColumnFamilySerializer.java
@@ -77,8 +77,8 @@ public class ColumnFamilySerializer implements ICompactSerializer2<ColumnFamily>
     {
         try
         {
-            dos.writeInt(columnFamily.localDeletionTime);
-            dos.writeLong(columnFamily.markedForDeleteAt);
+            dos.writeInt(columnFamily.localDeletionTime.get());
+            dos.writeLong(columnFamily.markedForDeleteAt.get());
 
             Collection<IColumn> columns = columnFamily.getSortedColumns();
             dos.writeInt(columns.size());
diff --git a/src/java/org/apache/cassandra/db/Memtable.java b/src/java/org/apache/cassandra/db/Memtable.java
index 32be895760..8386adde69 100644
--- a/src/java/org/apache/cassandra/db/Memtable.java
+++ b/src/java/org/apache/cassandra/db/Memtable.java
@@ -53,9 +53,7 @@ public class Memtable implements Comparable<Memtable>, IFlushable<DecoratedKey>
     private final String table_;
     private final String cfName_;
     private final long creationTime_;
-    // we use NBHM with manual locking, so reads are automatically threadsafe but write merging is serialized per key
     private final NonBlockingHashMap<DecoratedKey, ColumnFamily> columnFamilies_ = new NonBlockingHashMap<DecoratedKey, ColumnFamily>();
-    private final Object[] keyLocks;
     private final IPartitioner partitioner_ = StorageService.getPartitioner();
 
     Memtable(String table, String cfName)
@@ -63,11 +61,6 @@ public class Memtable implements Comparable<Memtable>, IFlushable<DecoratedKey>
         table_ = table;
         cfName_ = cfName;
         creationTime_ = System.currentTimeMillis();
-        keyLocks = new Object[Runtime.getRuntime().availableProcessors() * 8];
-        for (int i = 0; i < keyLocks.length; i++)
-        {
-            keyLocks[i] = new Object();
-        }
     }
 
     public boolean isFlushed()
@@ -135,17 +128,15 @@ public class Memtable implements Comparable<Memtable>, IFlushable<DecoratedKey>
 
     private void resolve(String key, ColumnFamily cf)
     {
-        DecoratedKey decoratedKey = partitioner_.decorateKey(key);
         currentThroughput_.addAndGet(cf.size());
         currentOperations.addAndGet(cf.getColumnCount());
+
+        DecoratedKey decoratedKey = partitioner_.decorateKey(key);
         ColumnFamily oldCf = columnFamilies_.putIfAbsent(decoratedKey, cf);
         if (oldCf == null)
             return;
 
-        synchronized (keyLocks[Math.abs(key.hashCode() % keyLocks.length)])
-        {
-            oldCf.resolve(cf);
-        }
+        oldCf.resolve(cf);
     }
 
     // for debugging
diff --git a/src/java/org/apache/cassandra/db/SuperColumn.java b/src/java/org/apache/cassandra/db/SuperColumn.java
index 03e9292e5c..6ac5715ec9 100644
--- a/src/java/org/apache/cassandra/db/SuperColumn.java
+++ b/src/java/org/apache/cassandra/db/SuperColumn.java
@@ -20,15 +20,17 @@ package org.apache.cassandra.db;
 
 import java.io.*;
 import java.util.Collection;
-import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.ConcurrentSkipListMap;
 import java.security.MessageDigest;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicLong;
 
 import org.apache.log4j.Logger;
 
 import org.apache.cassandra.io.ICompactSerializer2;
 import org.apache.cassandra.io.util.DataOutputBuffer;
 import org.apache.cassandra.db.marshal.AbstractType;
+import org.apache.cassandra.utils.FBUtilities;
 
 
 public final class SuperColumn implements IColumn, IColumnContainer
@@ -42,9 +44,8 @@ public final class SuperColumn implements IColumn, IColumnContainer
 
     private byte[] name_;
     private ConcurrentSkipListMap<byte[], IColumn> columns_;
-    private int localDeletionTime = Integer.MIN_VALUE;
-	private long markedForDeleteAt = Long.MIN_VALUE;
-    private AtomicInteger size_ = new AtomicInteger(0);
+    private AtomicInteger localDeletionTime = new AtomicInteger(Integer.MIN_VALUE);
+	private AtomicLong markedForDeleteAt = new AtomicLong(Long.MIN_VALUE);
 
     SuperColumn(byte[] name, AbstractType comparator)
     {
@@ -67,21 +68,20 @@ public final class SuperColumn implements IColumn, IColumnContainer
     public SuperColumn cloneMeShallow()
     {
         SuperColumn sc = new SuperColumn(name_, getComparator());
-        sc.markForDeleteAt(localDeletionTime, markedForDeleteAt);
+        sc.markForDeleteAt(localDeletionTime.get(), markedForDeleteAt.get());
         return sc;
     }
 
-
     public IColumn cloneMe()
     {
         SuperColumn sc = new SuperColumn(name_, new ConcurrentSkipListMap<byte[], IColumn>(columns_));
-        sc.markForDeleteAt(localDeletionTime, markedForDeleteAt);
+        sc.markForDeleteAt(localDeletionTime.get(), markedForDeleteAt.get());
         return sc;
     }
 
 	public boolean isMarkedForDelete()
 	{
-		return markedForDeleteAt > Long.MIN_VALUE;
+		return markedForDeleteAt.get() > Long.MIN_VALUE;
 	}
 
     public byte[] name()
@@ -101,15 +101,17 @@ public final class SuperColumn implements IColumn, IColumnContainer
         return column;
     }
 
+    /**
+     * This calculates the exact size of the sub columns on the fly
+     */
     public int size()
     {
-        /*
-         * return the size of the individual columns
-         * that make up the super column. This is an
-         * APPROXIMATION of the size used only from the
-         * Memtable.
-        */
-        return size_.get();
+        int size = 0;
+        for (IColumn subColumn : getSubColumns())
+        {
+            size += subColumn.serializedSize();
+        }
+        return size;
     }
 
     /**
@@ -122,20 +124,7 @@ public final class SuperColumn implements IColumn, IColumnContainer
     	 * We need to keep the way we are calculating the column size in sync with the
     	 * way we are calculating the size for the column family serializer.
     	 */
-    	return IColumn.UtfPrefix_ + name_.length + DBConstants.intSize_ + DBConstants.longSize_ + DBConstants.intSize_ + getSizeOfAllColumns();
-    }
-
-    /**
-     * This calculates the exact size of the sub columns on the fly
-     */
-    int getSizeOfAllColumns()
-    {
-        int size = 0;
-        for (IColumn subColumn : getSubColumns())
-        {
-            size += subColumn.serializedSize();
-        }
-        return size;
+    	return IColumn.UtfPrefix_ + name_.length + DBConstants.intSize_ + DBConstants.longSize_ + DBConstants.intSize_ + size();
     }
 
     public void remove(byte[] columnName)
@@ -152,9 +141,9 @@ public final class SuperColumn implements IColumn, IColumnContainer
     {
     	IColumn column = columns_.get(columnName);
     	assert column instanceof Column;
-    	if ( column != null )
-    		return column.timestamp();
-    	throw new IllegalArgumentException("Timestamp was requested for a column that does not exist.");
+        if ( column != null )
+            return column.timestamp();
+        throw new IllegalArgumentException("Timestamp was requested for a column that does not exist.");
     }
 
     public long mostRecentLiveChangeAt()
@@ -187,22 +176,15 @@ public final class SuperColumn implements IColumn, IColumnContainer
     {
     	if (!(column instanceof Column))
     		throw new UnsupportedOperationException("A super column can only contain simple columns.");
-    	IColumn oldColumn = columns_.get(column.name());
-    	if ( oldColumn == null )
+        byte[] name = column.name();
+        IColumn oldColumn = columns_.putIfAbsent(name, column);
+    	if (oldColumn != null)
         {
-    		columns_.put(column.name(), column);
-            size_.addAndGet(column.size());
-        }
-    	else
-    	{
-    		if (((Column)oldColumn).comparePriority((Column)column) <= 0)
+    		while (((Column)oldColumn).comparePriority((Column)column) <= 0)
             {
-    			columns_.put(column.name(), column);
-                int delta = (-1)*oldColumn.size();
-                /* subtract the size of the oldColumn */
-                size_.addAndGet(delta);
-                /* add the size of the new column */
-                size_.addAndGet(column.size());
+    			if (columns_.replace(name, oldColumn, column))
+                    break;
+                oldColumn = columns_.get(name);
             }
     	}
     }
@@ -219,10 +201,7 @@ public final class SuperColumn implements IColumn, IColumnContainer
         {
         	addColumn(subColumn);
         }
-        if (column.getMarkedForDeleteAt() > markedForDeleteAt)
-        {
-            markForDeleteAt(column.getLocalDeletionTime(),  column.getMarkedForDeleteAt());
-        }
+        FBUtilities.atomicSetMax(markedForDeleteAt, column.getMarkedForDeleteAt());
     }
 
     public int getObjectCount()
@@ -230,13 +209,9 @@ public final class SuperColumn implements IColumn, IColumnContainer
     	return 1 + columns_.size();
     }
 
-    public long getMarkedForDeleteAt() {
-        return markedForDeleteAt;
-    }
-
-    int getColumnCount()
+    public long getMarkedForDeleteAt()
     {
-    	return columns_.size();
+        return markedForDeleteAt.get();
     }
 
     public IColumn diff(IColumn columnNew)
@@ -280,7 +255,7 @@ public final class SuperColumn implements IColumn, IColumnContainer
         DataOutputBuffer buffer = new DataOutputBuffer();
         try
         {
-            buffer.writeLong(markedForDeleteAt);
+            buffer.writeLong(markedForDeleteAt.get());
         }
         catch (IOException e)
         {
@@ -312,13 +287,14 @@ public final class SuperColumn implements IColumn, IColumnContainer
 
     public int getLocalDeletionTime()
     {
-        return localDeletionTime;
+        return localDeletionTime.get();
     }
 
+    @Deprecated // TODO this is a hack to set initial value outside constructor
     public void markForDeleteAt(int localDeleteTime, long timestamp)
     {
-        this.localDeletionTime = localDeleteTime;
-        this.markedForDeleteAt = timestamp;
+        this.localDeletionTime.set(localDeleteTime);
+        this.markedForDeleteAt.set(timestamp);
     }
 }
 
diff --git a/src/java/org/apache/cassandra/utils/FBUtilities.java b/src/java/org/apache/cassandra/utils/FBUtilities.java
index c57a7acdeb..9e48e1f546 100644
--- a/src/java/org/apache/cassandra/utils/FBUtilities.java
+++ b/src/java/org/apache/cassandra/utils/FBUtilities.java
@@ -24,6 +24,8 @@ import java.net.InetAddress;
 import java.net.UnknownHostException;
 import java.security.MessageDigest;
 import java.util.*;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicLong;
 import java.util.zip.DataFormatException;
 import java.util.zip.Deflater;
 import java.util.zip.Inflater;
@@ -318,4 +320,26 @@ public class FBUtilities
             }
         });
     }
+
+    public static void atomicSetMax(AtomicInteger atomic, int i)
+    {
+        int j;
+        while (true)
+        {
+            if ((j = atomic.getAndSet(i)) <= i)
+                break;
+            i = j;
+        }
+    }
+
+    public static void atomicSetMax(AtomicLong atomic, long i)
+    {
+        long j;
+        while (true)
+        {
+            if ((j = atomic.getAndSet(i)) <= i)
+                break;
+            i = j;
+        }
+    }
 }
