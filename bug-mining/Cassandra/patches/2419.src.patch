diff --git a/CHANGES.txt b/CHANGES.txt
index 2dbadc498e..d6ecac13e2 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,5 +1,7 @@
 1.2.12
  * Add ability to list specific KS/CF combinations in nodetool cfstats (CASSANDRA-4191)
+ * Mark CF clean if a mutation raced the drop and got it marked dirty 
+
 
 1.2.11
  * Limit CQL prepared statement cache by size instead of count (CASSANDRA-6107)
diff --git a/src/java/org/apache/cassandra/db/commitlog/CommitLogAllocator.java b/src/java/org/apache/cassandra/db/commitlog/CommitLogAllocator.java
index 2855979c0e..d62d7caa54 100644
--- a/src/java/org/apache/cassandra/db/commitlog/CommitLogAllocator.java
+++ b/src/java/org/apache/cassandra/db/commitlog/CommitLogAllocator.java
@@ -39,6 +39,7 @@ import org.apache.cassandra.db.Table;
 import org.apache.cassandra.io.util.FileUtils;
 import org.apache.cassandra.net.MessagingService;
 import org.apache.cassandra.service.StorageService;
+import org.apache.cassandra.utils.Pair;
 import org.apache.cassandra.utils.WrappedRunnable;
 
 /**
@@ -296,19 +297,30 @@ public class CommitLogAllocator
         {
             for (UUID dirtyCFId : oldestSegment.getDirtyCFIDs())
             {
-                String keypace = Schema.instance.getCF(dirtyCFId).left;
-                final ColumnFamilyStore cfs = Table.open(keypace).getColumnFamilyStore(dirtyCFId);
-                // flush shouldn't run on the commitlog executor, since it acquires Table.switchLock,
-                // which may already be held by a thread waiting for the CL executor (via getContext),
-                // causing deadlock
-                Runnable runnable = new Runnable()
+                Pair<String,String> pair = Schema.instance.getCF(dirtyCFId);
+                if (pair == null)
                 {
-                    public void run()
+                    // even though we remove the schema entry before a final flush when dropping a CF,
+                    // it's still possible for a writer to race and finish his append after the flush.
+                    logger.debug("Marking clean CF {} that doesn't exist anymore", dirtyCFId);
+                    oldestSegment.markClean(dirtyCFId, oldestSegment.getContext());
+                }
+                else
+                {
+                    String keypace = pair.left;
+                    final ColumnFamilyStore cfs = Table.open(keypace).getColumnFamilyStore(dirtyCFId);
+                    // flush shouldn't run on the commitlog executor, since it acquires Table.switchLock,
+                    // which may already be held by a thread waiting for the CL executor (via getContext),
+                    // causing deadlock
+                    Runnable runnable = new Runnable()
                     {
-                        cfs.forceFlush();
-                    }
-                };
-                StorageService.optionalTasks.execute(runnable);
+                        public void run()
+                        {
+                            cfs.forceFlush();
+                        }
+                    };
+                    StorageService.optionalTasks.execute(runnable);
+                }
             }
         }
     }
