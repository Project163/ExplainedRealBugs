diff --git a/src/java/org/apache/cassandra/audit/AuditLogManager.java b/src/java/org/apache/cassandra/audit/AuditLogManager.java
index bc2126ca7a..c21274e4a4 100644
--- a/src/java/org/apache/cassandra/audit/AuditLogManager.java
+++ b/src/java/org/apache/cassandra/audit/AuditLogManager.java
@@ -19,75 +19,65 @@
 package org.apache.cassandra.audit;
 
 import java.nio.ByteBuffer;
-import java.nio.file.Path;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.UUID;
 
+import javax.annotation.Nullable;
+
 import com.google.common.annotations.VisibleForTesting;
-import com.google.common.collect.ImmutableSet;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import org.apache.cassandra.auth.AuthEvents;
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.cql3.CQLStatement;
-import org.apache.cassandra.cql3.QueryHandler;
+import org.apache.cassandra.cql3.QueryEvents;
 import org.apache.cassandra.cql3.QueryOptions;
 import org.apache.cassandra.cql3.statements.BatchStatement;
 import org.apache.cassandra.exceptions.AuthenticationException;
 import org.apache.cassandra.exceptions.ConfigurationException;
+import org.apache.cassandra.exceptions.PreparedQueryNotFoundException;
 import org.apache.cassandra.exceptions.UnauthorizedException;
 import org.apache.cassandra.service.QueryState;
+import org.apache.cassandra.transport.Message;
+import org.apache.cassandra.transport.messages.ResultMessage;
 import org.apache.cassandra.utils.FBUtilities;
 
 /**
  * Central location for managing the logging of client/user-initated actions (like queries, log in commands, and so on).
  *
- * We can run multiple {@link IAuditLogger}s at the same time, including the standard audit logger ({@link #auditLogger}
- * and the full query logger ({@link #fullQueryLogger}.
  */
-public class AuditLogManager
+public class AuditLogManager implements QueryEvents.Listener, AuthEvents.Listener
 {
     private static final Logger logger = LoggerFactory.getLogger(AuditLogManager.class);
-    private static final AuditLogManager instance = new AuditLogManager();
-
-    // FQL always writes to a BinLog, but it is a type of IAuditLogger
-    private final FullQueryLogger fullQueryLogger;
-    private final ImmutableSet<AuditLogEntryCategory> fqlIncludeFilter = ImmutableSet.of(AuditLogEntryCategory.OTHER,
-                                                                                         AuditLogEntryCategory.QUERY,
-                                                                                         AuditLogEntryCategory.DCL,
-                                                                                         AuditLogEntryCategory.DML,
-                                                                                         AuditLogEntryCategory.DDL);
+    public static final AuditLogManager instance = new AuditLogManager();
 
     // auditLogger can write anywhere, as it's pluggable (logback, BinLog, DiagnosticEvents, etc ...)
     private volatile IAuditLogger auditLogger;
 
     private volatile AuditLogFilter filter;
-    private volatile boolean isAuditLogEnabled;
 
     private AuditLogManager()
     {
-        fullQueryLogger = new FullQueryLogger();
-
         if (DatabaseDescriptor.getAuditLoggingOptions().enabled)
         {
             logger.info("Audit logging is enabled.");
             auditLogger = getAuditLogger(DatabaseDescriptor.getAuditLoggingOptions().logger);
-            isAuditLogEnabled = true;
         }
         else
         {
             logger.debug("Audit logging is disabled.");
-            isAuditLogEnabled = false;
             auditLogger = new NoOpAuditLogger();
         }
 
         filter = AuditLogFilter.create(DatabaseDescriptor.getAuditLoggingOptions());
     }
 
-    public static AuditLogManager getInstance()
+    public void initialize()
     {
-        return instance;
+        if (DatabaseDescriptor.getAuditLoggingOptions().enabled)
+            registerAsListener();
     }
 
     private IAuditLogger getAuditLogger(String loggerClassName) throws ConfigurationException
@@ -106,26 +96,16 @@ public class AuditLogManager
         return auditLogger;
     }
 
-    public boolean isAuditingEnabled()
-    {
-        return isAuditLogEnabled;
-    }
-
-    public boolean isLoggingEnabled()
+    public boolean isEnabled()
     {
-        return isAuditingEnabled() || isFQLEnabled();
-    }
-
-    private boolean isFQLEnabled()
-    {
-        return fullQueryLogger.enabled();
+        return auditLogger.isEnabled();
     }
 
     /**
-     * Logs AuditLogEntry to standard audit logger
+     * Logs AudigLogEntry to standard audit logger
      * @param logEntry AuditLogEntry to be logged
      */
-    private void logAuditLoggerEntry(AuditLogEntry logEntry)
+    private void log(AuditLogEntry logEntry)
     {
         if (!filter.isFiltered(logEntry))
         {
@@ -133,87 +113,155 @@ public class AuditLogManager
         }
     }
 
-    /**
-     * Logs AudigLogEntry to both FQL and standard audit logger
-     * @param logEntry AuditLogEntry to be logged
-     */
-    public void log(AuditLogEntry logEntry)
+    private void log(AuditLogEntry logEntry, Exception e)
     {
-        if (logEntry == null)
-            return;
+        AuditLogEntry.Builder builder = new AuditLogEntry.Builder(logEntry);
 
-        if (isAuditingEnabled())
+        if (e instanceof UnauthorizedException)
         {
-            logAuditLoggerEntry(logEntry);
+            builder.setType(AuditLogEntryType.UNAUTHORIZED_ATTEMPT);
         }
-
-        if (isFQLEnabled() && fqlIncludeFilter.contains(logEntry.getType().getCategory()))
+        else if (e instanceof AuthenticationException)
+        {
+            builder.setType(AuditLogEntryType.LOGIN_ERROR);
+        }
+        else
         {
-            fullQueryLogger.log(logEntry);
+            builder.setType(AuditLogEntryType.REQUEST_FAILURE);
         }
+
+        builder.appendToOperation(e.getMessage());
+
+        log(builder.build());
     }
 
-    public void log(AuditLogEntry logEntry, Exception e)
+    /**
+     * Disables AuditLog, designed to be invoked only via JMX/ Nodetool, not from anywhere else in the codepath.
+     */
+    public synchronized void disableAuditLog()
     {
-        if ((logEntry != null) && (isAuditingEnabled()))
-        {
-            AuditLogEntry.Builder builder = new AuditLogEntry.Builder(logEntry);
-
-            if (e instanceof UnauthorizedException)
-            {
-                builder.setType(AuditLogEntryType.UNAUTHORIZED_ATTEMPT);
-            }
-            else if (e instanceof AuthenticationException)
-            {
-                builder.setType(AuditLogEntryType.LOGIN_ERROR);
-            }
-            else
-            {
-                builder.setType(AuditLogEntryType.REQUEST_FAILURE);
-            }
-
-            builder.appendToOperation(e.getMessage());
-
-            log(builder.build());
-        }
+        unregisterAsListener();
+        IAuditLogger oldLogger = auditLogger;
+        auditLogger = new NoOpAuditLogger();
+        oldLogger.stop();
     }
 
     /**
-     * Logs Batch queries to both FQL and standard audit logger.
+     * Enables AuditLog, designed to be invoked only via JMX/ Nodetool, not from anywhere else in the codepath.
+     * @param auditLogOptions AuditLogOptions to be used for enabling AuditLog
+     * @throws ConfigurationException It can throw configuration exception when provided logger class does not exist in the classpath
      */
-    public void logBatch(BatchStatement.Type type,
-                         List<Object> queryOrIdList,
-                         List<List<ByteBuffer>> values,
-                         List<QueryHandler.Prepared> prepared,
-                         QueryOptions options,
-                         QueryState state,
-                         long queryStartTimeMillis)
+    public synchronized void enable(AuditLogOptions auditLogOptions) throws ConfigurationException
     {
-        if (isAuditingEnabled())
+        // always reload the filters
+        filter = AuditLogFilter.create(auditLogOptions);
+
+        // next, check to see if we're changing the logging implementation; if not, keep the same instance and bail.
+        // note: auditLogger should never be null
+        IAuditLogger oldLogger = auditLogger;
+        if (oldLogger.getClass().getSimpleName().equals(auditLogOptions.logger))
+            return;
+
+        auditLogger = getAuditLogger(auditLogOptions.logger);
+
+        // note that we might already be registered here and we rely on the fact that Query/AuthEvents have a Set of listeners
+        registerAsListener();
+
+        // ensure oldLogger's stop() is called after we swap it with new logger,
+        // otherwise, we might be calling log() on the stopped logger.
+        oldLogger.stop();
+    }
+
+    private void registerAsListener()
+    {
+        QueryEvents.instance.registerListener(this);
+        AuthEvents.instance.registerListener(this);
+    }
+
+    private void unregisterAsListener()
+    {
+        QueryEvents.instance.unregisterListener(this);
+        AuthEvents.instance.unregisterListener(this);
+    }
+
+    public void querySuccess(CQLStatement statement, String query, QueryOptions options, QueryState state, long queryTime, Message.Response response)
+    {
+        AuditLogEntry entry = new AuditLogEntry.Builder(state).setType(statement.getAuditLogContext().auditLogEntryType)
+                                                              .setOperation(query)
+                                                              .setTimestamp(queryTime)
+                                                              .setScope(statement)
+                                                              .setKeyspace(state, statement)
+                                                              .setOptions(options)
+                                                              .build();
+        log(entry);
+    }
+
+    public void queryFailure(CQLStatement stmt, String query, QueryOptions options, QueryState state, Exception cause)
+    {
+        AuditLogEntry entry = new AuditLogEntry.Builder(state).setOperation(query)
+                                                              .setOptions(options)
+                                                              .build();
+        log(entry, cause);
+    }
+
+    public void executeSuccess(CQLStatement statement, String query, QueryOptions options, QueryState state, long queryTime, Message.Response response)
+    {
+        AuditLogEntry entry = new AuditLogEntry.Builder(state).setType(statement.getAuditLogContext().auditLogEntryType)
+                                                              .setOperation(query)
+                                                              .setTimestamp(queryTime)
+                                                              .setScope(statement)
+                                                              .setKeyspace(state, statement)
+                                                              .setOptions(options)
+                                                              .build();
+        log(entry);
+    }
+
+    public void executeFailure(CQLStatement statement, String query, QueryOptions options, QueryState state, Exception cause)
+    {
+        AuditLogEntry entry = null;
+        if (cause instanceof PreparedQueryNotFoundException)
         {
-            List<AuditLogEntry> entries = buildEntriesForBatch(queryOrIdList, prepared, state, options, queryStartTimeMillis);
-            for (AuditLogEntry auditLogEntry : entries)
-            {
-                logAuditLoggerEntry(auditLogEntry);
-            }
+            entry = new AuditLogEntry.Builder(state).setOperation(query == null ? "null" : query)
+                                                                  .setOptions(options)
+                                                                  .build();
         }
+        else if (statement != null)
+        {
+            entry = new AuditLogEntry.Builder(state).setOperation(query == null ? statement.toString() : query)
+                                                                  .setType(statement.getAuditLogContext().auditLogEntryType)
+                                                                  .setScope(statement)
+                                                                  .setKeyspace(state, statement)
+                                                                  .setOptions(options)
+                                                                  .build();
+        }
+        if (entry != null)
+            log(entry, cause);
+    }
 
-        if (isFQLEnabled())
+    public void batchSuccess(BatchStatement.Type batchType, List<? extends CQLStatement> statements, List<String> queries, List<List<ByteBuffer>> values, QueryOptions options, QueryState state, long queryTime, Message.Response response)
+    {
+        List<AuditLogEntry> entries = buildEntriesForBatch(statements, queries, state, options, queryTime);
+        for (AuditLogEntry auditLogEntry : entries)
         {
-            List<String> queryStrings = new ArrayList<>(queryOrIdList.size());
-            for (QueryHandler.Prepared prepStatment : prepared)
-            {
-                queryStrings.add(prepStatment.rawCQLStatement);
-            }
-            fullQueryLogger.logBatch(type, queryStrings, values, options, state, queryStartTimeMillis);
+            log(auditLogEntry);
         }
     }
 
-    private static List<AuditLogEntry> buildEntriesForBatch(List<Object> queryOrIdList, List<QueryHandler.Prepared> prepared, QueryState state, QueryOptions options, long queryStartTimeMillis)
+    public void batchFailure(BatchStatement.Type batchType, List<? extends CQLStatement> statements, List<String> queries, List<List<ByteBuffer>> values, QueryOptions options, QueryState state, Exception cause)
     {
-        List<AuditLogEntry> auditLogEntries = new ArrayList<>(queryOrIdList.size() + 1);
+        String auditMessage = String.format("BATCH of %d statements at consistency %s", statements.size(), options.getConsistency());
+        AuditLogEntry entry = new AuditLogEntry.Builder(state).setOperation(auditMessage)
+                                                              .setOptions(options)
+                                                              .setType(AuditLogEntryType.BATCH)
+                                                              .build();
+        log(entry, cause);
+    }
+
+    private static List<AuditLogEntry> buildEntriesForBatch(List<? extends CQLStatement> statements, List<String> queries, QueryState state, QueryOptions options, long queryStartTimeMillis)
+    {
+        List<AuditLogEntry> auditLogEntries = new ArrayList<>(statements.size() + 1);
         UUID batchId = UUID.randomUUID();
-        String queryString = String.format("BatchId:[%s] - BATCH of [%d] statements", batchId, queryOrIdList.size());
+        String queryString = String.format("BatchId:[%s] - BATCH of [%d] statements", batchId, statements.size());
         AuditLogEntry entry = new AuditLogEntry.Builder(state)
                               .setOperation(queryString)
                               .setOptions(options)
@@ -223,12 +271,12 @@ public class AuditLogManager
                               .build();
         auditLogEntries.add(entry);
 
-        for (int i = 0; i < queryOrIdList.size(); i++)
+        for (int i = 0; i < statements.size(); i++)
         {
-            CQLStatement statement = prepared.get(i).statement;
+            CQLStatement statement = statements.get(i);
             entry = new AuditLogEntry.Builder(state)
                     .setType(statement.getAuditLogContext().auditLogEntryType)
-                    .setOperation(prepared.get(i).rawCQLStatement)
+                    .setOperation(queries.get(i))
                     .setTimestamp(queryStartTimeMillis)
                     .setScope(statement)
                     .setKeyspace(state, statement)
@@ -241,77 +289,38 @@ public class AuditLogManager
         return auditLogEntries;
     }
 
-    /**
-     * Disables AuditLog, designed to be invoked only via JMX/ Nodetool, not from anywhere else in the codepath.
-     */
-    public synchronized void disableAuditLog()
+    public void prepareSuccess(CQLStatement statement, String query, QueryState state, long queryTime, ResultMessage.Prepared response)
     {
-        if (isAuditLogEnabled)
-        {
-            // Disable isAuditLogEnabled before attempting to cleanup/ stop AuditLogger so that any incoming log() requests will be dropped.
-            isAuditLogEnabled = false;
-            IAuditLogger oldLogger = auditLogger;
-            auditLogger = new NoOpAuditLogger();
-            oldLogger.stop();
-        }
+        AuditLogEntry entry = new AuditLogEntry.Builder(state).setOperation(query)
+                                                              .setType(AuditLogEntryType.PREPARE_STATEMENT)
+                                                              .setScope(statement)
+                                                              .setKeyspace(statement)
+                                                              .build();
+        log(entry);
     }
 
-    /**
-     * Enables AuditLog, designed to be invoked only via JMX/ Nodetool, not from anywhere else in the codepath.
-     * @param auditLogOptions AuditLogOptions to be used for enabling AuditLog
-     * @throws ConfigurationException It can throw configuration exception when provided logger class does not exist in the classpath
-     */
-    public synchronized void enableAuditLog(AuditLogOptions auditLogOptions) throws ConfigurationException
-    {
-        if (isFQLEnabled() && fullQueryLogger.path().toString().equals(auditLogOptions.audit_logs_dir))
-            throw new IllegalArgumentException(String.format("audit log path (%s) cannot be the same as the " +
-                                                             "running full query logger (%s)",
-                                                             auditLogOptions.audit_logs_dir,
-                                                             fullQueryLogger.path()));
-
-        // always reload the filters
-        filter = AuditLogFilter.create(auditLogOptions);
-
-        // next, check to see if we're changing the logging implementation; if not, keep the same instance and bail.
-        // note: auditLogger should never be null
-        IAuditLogger oldLogger = auditLogger;
-        if (oldLogger.getClass().getSimpleName().equals(auditLogOptions.logger))
-            return;
-
-        auditLogger = getAuditLogger(auditLogOptions.logger);
-        isAuditLogEnabled = true;
-
-        // ensure oldLogger's stop() is called after we swap it with new logger,
-        // otherwise, we might be calling log() on the stopped logger.
-        oldLogger.stop();
-    }
-
-    public void configureFQL(Path path, String rollCycle, boolean blocking, int maxQueueWeight, long maxLogSize, String archiveCommand, int maxArchiveRetries)
+    public void prepareFailure(@Nullable CQLStatement stmt, @Nullable String query, QueryState state, Exception cause)
     {
-        if (path.equals(auditLogger.path()))
-            throw new IllegalArgumentException(String.format("fullquerylogger path (%s) cannot be the same as the " +
-                                                             "running audit logger (%s)",
-                                                             path,
-                                                             auditLogger.path()));
-
-        fullQueryLogger.configure(path, rollCycle, blocking, maxQueueWeight, maxLogSize, archiveCommand, maxArchiveRetries);
-    }
-
-    public void resetFQL(String fullQueryLogPath)
-    {
-        fullQueryLogger.reset(fullQueryLogPath);
+        AuditLogEntry entry = new AuditLogEntry.Builder(state).setOperation(query)
+//                                                              .setKeyspace(keyspace) // todo: do we need this? very much special case compared to the others
+                                                              .setType(AuditLogEntryType.PREPARE_STATEMENT)
+                                                              .build();
+        log(entry, cause);
     }
 
-    public void disableFQL()
+    public void authSuccess(QueryState state)
     {
-        fullQueryLogger.stop();
+        AuditLogEntry entry = new AuditLogEntry.Builder(state).setOperation("LOGIN SUCCESSFUL")
+                                                              .setType(AuditLogEntryType.LOGIN_SUCCESS)
+                                                              .build();
+        log(entry);
     }
 
-    /**
-     * ONLY FOR TESTING
-     */
-    FullQueryLogger getFullQueryLogger()
+    public void authFailure(QueryState state, Exception cause)
     {
-        return fullQueryLogger;
+        AuditLogEntry entry = new AuditLogEntry.Builder(state).setOperation("LOGIN FAILURE")
+                                                              .setType(AuditLogEntryType.LOGIN_ERROR)
+                                                              .build();
+        log(entry, cause);
     }
 }
diff --git a/src/java/org/apache/cassandra/audit/BinAuditLogger.java b/src/java/org/apache/cassandra/audit/BinAuditLogger.java
index 83ed3dea28..ac846a616b 100644
--- a/src/java/org/apache/cassandra/audit/BinAuditLogger.java
+++ b/src/java/org/apache/cassandra/audit/BinAuditLogger.java
@@ -22,31 +22,62 @@ import java.nio.file.Paths;
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.primitives.Ints;
 
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
 import net.openhft.chronicle.wire.WireOut;
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.utils.ObjectSizes;
 import org.apache.cassandra.utils.binlog.BinLog;
 import org.apache.cassandra.utils.concurrent.WeightedQueue;
 
-public class BinAuditLogger extends BinLogAuditLogger implements IAuditLogger
+public class BinAuditLogger implements IAuditLogger
 {
     public static final long CURRENT_VERSION = 0;
     public static final String AUDITLOG_TYPE = "audit";
     public static final String AUDITLOG_MESSAGE = "message";
+    private static final Logger logger = LoggerFactory.getLogger(BinAuditLogger.class);
+
+    private volatile BinLog binLog;
 
     public BinAuditLogger()
     {
-        // due to the way that IAuditLogger instance are created in AuditLogManager, via reflection, we can't assume
-        // the manager will call configure() (it won't). thus, we have to call it here from the constructor.
         AuditLogOptions auditLoggingOptions = DatabaseDescriptor.getAuditLoggingOptions();
-        configure(Paths.get(auditLoggingOptions.audit_logs_dir),
-                  auditLoggingOptions.roll_cycle,
-                  auditLoggingOptions.block,
-                  auditLoggingOptions.max_queue_weight,
-                  auditLoggingOptions.max_log_size,
-                  false,
-                  auditLoggingOptions.archive_command,
-                  auditLoggingOptions.max_archive_retries);
+
+        this.binLog = new BinLog.Builder().path(Paths.get(auditLoggingOptions.audit_logs_dir))
+                                          .rollCycle(auditLoggingOptions.roll_cycle)
+                                          .blocking(auditLoggingOptions.block)
+                                          .maxQueueWeight(auditLoggingOptions.max_queue_weight)
+                                          .maxLogSize(auditLoggingOptions.max_log_size)
+                                          .archiveCommand(auditLoggingOptions.archive_command)
+                                          .maxArchiveRetries(auditLoggingOptions.max_archive_retries)
+                                          .build(false);
+    }
+
+    /**
+     * Stop the audit log leaving behind any generated files.
+     */
+    public synchronized void stop()
+    {
+        try
+        {
+            logger.info("Deactivation of audit log requested.");
+            if (binLog != null)
+            {
+                logger.info("Stopping audit logger");
+                binLog.stop();
+                binLog = null;
+            }
+        }
+        catch (Exception e)
+        {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public boolean isEnabled()
+    {
+        return binLog != null;
     }
 
     @Override
@@ -57,10 +88,10 @@ public class BinAuditLogger extends BinLogAuditLogger implements IAuditLogger
         {
             return;
         }
-
-        super.logRecord(new Message(auditLogEntry.getLogString()), binLog);
+        binLog.logRecord(new Message(auditLogEntry.getLogString()));
     }
 
+
     @VisibleForTesting
     public static class Message extends BinLog.ReleaseableWriteMarshallable implements WeightedQueue.Weighable
     {
diff --git a/src/java/org/apache/cassandra/audit/BinLogAuditLogger.java b/src/java/org/apache/cassandra/audit/BinLogAuditLogger.java
deleted file mode 100644
index 94067fbe61..0000000000
--- a/src/java/org/apache/cassandra/audit/BinLogAuditLogger.java
+++ /dev/null
@@ -1,303 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.cassandra.audit;
-
-import java.io.File;
-import java.nio.file.Path;
-import java.util.Set;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicLong;
-
-import com.google.common.base.Preconditions;
-import com.google.common.base.Strings;
-import com.google.common.collect.Sets;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import net.openhft.chronicle.queue.RollCycles;
-import org.apache.cassandra.io.FSError;
-import org.apache.cassandra.io.util.FileUtils;
-import org.apache.cassandra.utils.NoSpamLogger;
-import org.apache.cassandra.utils.Throwables;
-import org.apache.cassandra.utils.binlog.BinLog;
-import org.apache.cassandra.utils.binlog.BinLogArchiver;
-import org.apache.cassandra.utils.binlog.DeletingArchiver;
-import org.apache.cassandra.utils.binlog.ExternalArchiver;
-
-abstract class BinLogAuditLogger implements IAuditLogger
-{
-    protected static final Logger logger = LoggerFactory.getLogger(BinLogAuditLogger.class);
-    private static final NoSpamLogger noSpamLogger = NoSpamLogger.getLogger(logger, 1, TimeUnit.MINUTES);
-    private static final NoSpamLogger.NoSpamLogStatement droppedSamplesStatement = noSpamLogger.getStatement("Dropped {} binary log samples", 1, TimeUnit.MINUTES);
-
-    volatile BinLog binLog;
-    protected volatile boolean blocking;
-    protected Path path;
-
-    private final AtomicLong droppedSamplesSinceLastLog = new AtomicLong();
-
-    /**
-     * Configure the global instance of the FullQueryLogger. Clean the provided directory before starting
-     * @param path Dedicated path where the FQL can store it's files.
-     * @param rollCycle How often to roll FQL log segments so they can potentially be reclaimed
-     * @param blocking Whether the FQL should block if the FQL falls behind or should drop log records
-     * @param maxQueueWeight Maximum weight of in memory queue for records waiting to be written to the file before blocking or dropping
-     * @param maxLogSize Maximum size of the rolled files to retain on disk before deleting the oldest file
-     * @param archiveCommand the archive command to execute on rolled log files
-     * @param maxArchiveRetries max number of retries of failed archive commands
-     */
-    public synchronized void configure(Path path, String rollCycle, boolean blocking, int maxQueueWeight, long maxLogSize, String archiveCommand, int maxArchiveRetries)
-    {
-        this.configure(path, rollCycle, blocking, maxQueueWeight, maxLogSize, true, archiveCommand, maxArchiveRetries);
-    }
-
-    /**
-     * Configure the global instance of the FullQueryLogger
-     * @param path Dedicated path where the FQL can store it's files.
-     * @param rollCycle How often to roll FQL log segments so they can potentially be reclaimed
-     * @param blocking Whether the FQL should block if the FQL falls behind or should drop log records
-     * @param maxQueueWeight Maximum weight of in memory queue for records waiting to be written to the file before blocking or dropping
-     * @param maxLogSize Maximum size of the rolled files to retain on disk before deleting the oldest file
-     * @param cleanDirectory Indicates to clean the directory before starting FullQueryLogger or not
-     * @param archiveCommand the archive command to execute on rolled log files
-     * @param maxArchiveRetries max number of retries of failed archive commands
-     */
-    public synchronized void configure(Path path, String rollCycle, boolean blocking, int maxQueueWeight, long maxLogSize, boolean cleanDirectory, String archiveCommand, int maxArchiveRetries)
-    {
-        Preconditions.checkNotNull(path, "path was null");
-        File pathAsFile = path.toFile();
-        Preconditions.checkNotNull(rollCycle, "rollCycle was null");
-        rollCycle = rollCycle.toUpperCase();
-
-        //Exists and is a directory or can be created
-        Preconditions.checkArgument((pathAsFile.exists() && pathAsFile.isDirectory()) || (!pathAsFile.exists() && pathAsFile.mkdirs()), "path exists and is not a directory or couldn't be created");
-        Preconditions.checkArgument(pathAsFile.canRead() && pathAsFile.canWrite() && pathAsFile.canExecute(), "path is not readable, writable, and executable");
-        Preconditions.checkNotNull(RollCycles.valueOf(rollCycle), "unrecognized roll cycle");
-        Preconditions.checkArgument(maxQueueWeight > 0, "maxQueueWeight must be > 0");
-        Preconditions.checkArgument(maxLogSize > 0, "maxLogSize must be > 0");
-        logger.info("Attempting to configure full query logger path: {} Roll cycle: {} Blocking: {} Max queue weight: {} Max log size:{}, archive command: {}", path, rollCycle, blocking, maxQueueWeight, maxLogSize, archiveCommand);
-
-        if (binLog != null)
-        {
-            logger.warn("Full query logger already configured. Ignoring requested configuration.");
-            throw new IllegalStateException("Already configured");
-        }
-
-        // create the archiver before cleaning directories - ExternalArchiver will try to archive any existing file.
-        BinLogArchiver archiver = Strings.isNullOrEmpty(archiveCommand) ? new DeletingArchiver(maxLogSize) : new ExternalArchiver(archiveCommand, path, maxArchiveRetries);
-        if (cleanDirectory)
-        {
-            logger.info("Cleaning directory: {} as requested",path);
-            if (path.toFile().exists())
-            {
-                Throwable error = cleanDirectory(path.toFile(), null);
-                if (error != null)
-                {
-                    throw new RuntimeException(error);
-                }
-            }
-        }
-        this.path = path;
-        this.blocking = blocking;
-        binLog = new BinLog(path, RollCycles.valueOf(rollCycle), maxQueueWeight, archiver);
-        binLog.start();
-    }
-
-    public Path path()
-    {
-        return path;
-    }
-
-    /**
-     * Need the path as a parameter as well because if the process is restarted the config file might be the only
-     * location for retrieving the path to the full query log files, but JMX also allows you to specify a path
-     * that isn't persisted anywhere so we have to clean that one a well.
-     */
-    public synchronized void reset(String fullQueryLogPath)
-    {
-        try
-        {
-            Set<File> pathsToClean = Sets.newHashSet();
-
-            //First decide whether to clean the path configured in the YAML
-            if (fullQueryLogPath != null)
-            {
-                File fullQueryLogPathFile = new File(fullQueryLogPath);
-                if (fullQueryLogPathFile.exists())
-                {
-                    pathsToClean.add(fullQueryLogPathFile);
-                }
-            }
-
-            //Then decide whether to clean the last used path, possibly configured by JMX
-            if (path != null)
-            {
-                File pathFile = path.toFile();
-                if (pathFile.exists())
-                {
-                    pathsToClean.add(pathFile);
-                }
-            }
-
-            logger.info("Reset (and deactivation) of full query log requested.");
-            if (binLog != null)
-            {
-                logger.info("Stopping full query log. Cleaning {}.", pathsToClean);
-                binLog.stop();
-                binLog = null;
-            }
-            else
-            {
-                logger.info("Full query log already deactivated. Cleaning {}.", pathsToClean);
-            }
-
-            Throwable accumulate = null;
-            for (File f : pathsToClean)
-            {
-                accumulate = cleanDirectory(f, accumulate);
-            }
-            if (accumulate != null)
-            {
-                throw new RuntimeException(accumulate);
-            }
-        }
-        catch (Exception e)
-        {
-            if (e instanceof RuntimeException)
-            {
-                throw (RuntimeException)e;
-            }
-            throw new RuntimeException(e);
-        }
-    }
-
-    /**
-     * Stop the full query log leaving behind any generated files.
-     */
-    public synchronized void stop()
-    {
-        try
-        {
-            logger.info("Deactivation of full query log requested.");
-            if (binLog != null)
-            {
-                logger.info("Stopping full query log");
-                binLog.stop();
-                binLog = null;
-            }
-        }
-        catch (Exception e)
-        {
-            throw new RuntimeException(e);
-        }
-    }
-
-    /**
-     * Check whether the full query log is enabled.
-     * @return true if records are recorded and false otherwise.
-     */
-    public boolean enabled()
-    {
-        return binLog != null;
-    }
-
-    void logRecord(BinLog.ReleaseableWriteMarshallable record, BinLog binLog)
-    {
-        boolean putInQueue = false;
-        try
-        {
-            if (blocking)
-            {
-                try
-                {
-                    binLog.put(record);
-                    putInQueue = true;
-                }
-                catch (InterruptedException e)
-                {
-                    throw new RuntimeException(e);
-                }
-            }
-            else
-            {
-                if (!binLog.offer(record))
-                {
-                    logDroppedSample();
-                }
-                else
-                {
-                    putInQueue = true;
-                }
-            }
-        }
-        finally
-        {
-            if (!putInQueue)
-            {
-                record.release();
-            }
-        }
-    }
-
-    /**
-     * This is potentially lossy, but it's not super critical as we will always generally know
-     * when this is happening and roughly how bad it is.
-     */
-    private void logDroppedSample()
-    {
-        droppedSamplesSinceLastLog.incrementAndGet();
-        if (droppedSamplesStatement.warn(new Object[] {droppedSamplesSinceLastLog.get()}))
-        {
-            droppedSamplesSinceLastLog.set(0);
-        }
-    }
-
-    private static Throwable cleanDirectory(File directory, Throwable accumulate)
-    {
-        if (!directory.exists())
-        {
-            return Throwables.merge(accumulate, new RuntimeException(String.format("%s does not exists", directory)));
-        }
-        if (!directory.isDirectory())
-        {
-            return Throwables.merge(accumulate, new RuntimeException(String.format("%s is not a directory", directory)));
-        }
-        for (File f : directory.listFiles())
-        {
-            accumulate = deleteRecursively(f, accumulate);
-        }
-        if (accumulate instanceof FSError)
-        {
-            FileUtils.handleFSError((FSError)accumulate);
-        }
-        return accumulate;
-    }
-
-    private static Throwable deleteRecursively(File fileOrDirectory, Throwable accumulate)
-    {
-        if (fileOrDirectory.isDirectory())
-        {
-            for (File f : fileOrDirectory.listFiles())
-            {
-                accumulate = FileUtils.deleteWithConfirm(f, accumulate);
-            }
-        }
-        return FileUtils.deleteWithConfirm(fileOrDirectory, accumulate);
-    }
-}
diff --git a/src/java/org/apache/cassandra/audit/DiagnosticEventAuditLogger.java b/src/java/org/apache/cassandra/audit/DiagnosticEventAuditLogger.java
index 9d586bac3d..1a0b6cfcb1 100644
--- a/src/java/org/apache/cassandra/audit/DiagnosticEventAuditLogger.java
+++ b/src/java/org/apache/cassandra/audit/DiagnosticEventAuditLogger.java
@@ -27,7 +27,7 @@ public class DiagnosticEventAuditLogger implements IAuditLogger
         AuditEvent.create(logMessage);
     }
 
-    public boolean enabled()
+    public boolean isEnabled()
     {
         return DiagnosticEventService.instance().isDiagnosticsEnabled();
     }
diff --git a/src/java/org/apache/cassandra/audit/FileAuditLogger.java b/src/java/org/apache/cassandra/audit/FileAuditLogger.java
index 9490bdd54b..b872c8fbea 100644
--- a/src/java/org/apache/cassandra/audit/FileAuditLogger.java
+++ b/src/java/org/apache/cassandra/audit/FileAuditLogger.java
@@ -36,7 +36,7 @@ public class FileAuditLogger implements IAuditLogger
     }
 
     @Override
-    public boolean enabled()
+    public boolean isEnabled()
     {
         return enabled;
     }
diff --git a/src/java/org/apache/cassandra/audit/IAuditLogger.java b/src/java/org/apache/cassandra/audit/IAuditLogger.java
index b72a256e97..9ab4c08ee6 100644
--- a/src/java/org/apache/cassandra/audit/IAuditLogger.java
+++ b/src/java/org/apache/cassandra/audit/IAuditLogger.java
@@ -18,11 +18,9 @@
 
 package org.apache.cassandra.audit;
 
-import java.nio.file.Path;
-
 public interface IAuditLogger
 {
-    boolean enabled();
+    boolean isEnabled();
 
     /**
      * Logs AuditLogEntry. This method might be called after {@link #stop()},
@@ -35,13 +33,4 @@ public interface IAuditLogger
      * {@link #log(AuditLogEntry)} might be called after being stopped.
      */
     void stop();
-
-    /**
-     * @return the path to the logging files/directory if the implemenation writes out to the local filesystem,
-     * or null if the implementation doesn't log locally.
-     */
-    default Path path()
-    {
-        return null;
-    }
 }
diff --git a/src/java/org/apache/cassandra/audit/NoOpAuditLogger.java b/src/java/org/apache/cassandra/audit/NoOpAuditLogger.java
index 8d3dd7dcfa..876b645618 100644
--- a/src/java/org/apache/cassandra/audit/NoOpAuditLogger.java
+++ b/src/java/org/apache/cassandra/audit/NoOpAuditLogger.java
@@ -23,7 +23,7 @@ package org.apache.cassandra.audit;
 public class NoOpAuditLogger implements IAuditLogger
 {
     @Override
-    public boolean enabled()
+    public boolean isEnabled()
     {
         return false;
     }
diff --git a/src/java/org/apache/cassandra/auth/AuthEvents.java b/src/java/org/apache/cassandra/auth/AuthEvents.java
new file mode 100644
index 0000000000..e4b60489c0
--- /dev/null
+++ b/src/java/org/apache/cassandra/auth/AuthEvents.java
@@ -0,0 +1,86 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.cassandra.auth;
+
+import java.util.Set;
+import java.util.concurrent.CopyOnWriteArraySet;
+
+import com.google.common.annotations.VisibleForTesting;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import org.apache.cassandra.cql3.QueryEvents;
+import org.apache.cassandra.service.QueryState;
+
+public class AuthEvents
+{
+    private static final Logger logger = LoggerFactory.getLogger(QueryEvents.class);
+
+    public static final AuthEvents instance = new AuthEvents();
+
+    private final Set<Listener> listeners = new CopyOnWriteArraySet<>();
+
+    @VisibleForTesting
+    public int listenerCount()
+    {
+        return listeners.size();
+    }
+
+    public void registerListener(Listener listener)
+    {
+        listeners.add(listener);
+    }
+
+    public void unregisterListener(Listener listener)
+    {
+        listeners.remove(listener);
+    }
+
+    public void notifyAuthSuccess(QueryState state)
+    {
+        try
+        {
+            for (Listener listener : listeners)
+                listener.authSuccess(state);
+        }
+        catch (Exception e)
+        {
+            logger.error("Failed notifying listeners", e);
+        }
+    }
+
+    public void notifyAuthFailure(QueryState state, Exception cause)
+    {
+        try
+        {
+            for (Listener listener : listeners)
+                listener.authFailure(state, cause);
+        }
+        catch (Exception e)
+        {
+            logger.error("Failed notifying listeners", e);
+        }
+    }
+
+    public static interface Listener
+    {
+        void authSuccess(QueryState state);
+        void authFailure(QueryState state, Exception cause);
+    }
+}
diff --git a/src/java/org/apache/cassandra/config/Config.java b/src/java/org/apache/cassandra/config/Config.java
index b26b253546..279269461b 100644
--- a/src/java/org/apache/cassandra/config/Config.java
+++ b/src/java/org/apache/cassandra/config/Config.java
@@ -34,7 +34,7 @@ import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import org.apache.cassandra.audit.AuditLogOptions;
-import org.apache.cassandra.audit.FullQueryLoggerOptions;
+import org.apache.cassandra.fql.FullQueryLoggerOptions;
 import org.apache.cassandra.db.ConsistencyLevel;
 
 /**
diff --git a/src/java/org/apache/cassandra/config/DatabaseDescriptor.java b/src/java/org/apache/cassandra/config/DatabaseDescriptor.java
index d5794ae7d0..4821653de1 100644
--- a/src/java/org/apache/cassandra/config/DatabaseDescriptor.java
+++ b/src/java/org/apache/cassandra/config/DatabaseDescriptor.java
@@ -40,7 +40,7 @@ import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import org.apache.cassandra.audit.AuditLogOptions;
-import org.apache.cassandra.audit.FullQueryLoggerOptions;
+import org.apache.cassandra.fql.FullQueryLoggerOptions;
 import org.apache.cassandra.auth.AllowAllInternodeAuthenticator;
 import org.apache.cassandra.auth.AuthConfig;
 import org.apache.cassandra.auth.IAuthenticator;
diff --git a/src/java/org/apache/cassandra/cql3/CustomPayloadMirroringQueryHandler.java b/src/java/org/apache/cassandra/cql3/CustomPayloadMirroringQueryHandler.java
index 0906d2ab6b..13aa7f5149 100644
--- a/src/java/org/apache/cassandra/cql3/CustomPayloadMirroringQueryHandler.java
+++ b/src/java/org/apache/cassandra/cql3/CustomPayloadMirroringQueryHandler.java
@@ -35,13 +35,18 @@ public class CustomPayloadMirroringQueryHandler implements QueryHandler
 {
     static QueryProcessor queryProcessor = QueryProcessor.instance;
 
-    public ResultMessage process(String query,
+    public CQLStatement parse(String query, QueryState state, QueryOptions options)
+    {
+        return queryProcessor.parse(query, state, options);
+    }
+
+    public ResultMessage process(CQLStatement statement,
                                  QueryState state,
                                  QueryOptions options,
                                  Map<String, ByteBuffer> customPayload,
                                  long queryStartNanoTime)
     {
-        ResultMessage result = queryProcessor.process(query, state, options, customPayload, queryStartNanoTime);
+        ResultMessage result = queryProcessor.process(statement, state, options, customPayload, queryStartNanoTime);
         result.setCustomPayload(customPayload);
         return result;
     }
diff --git a/src/java/org/apache/cassandra/cql3/QueryEvents.java b/src/java/org/apache/cassandra/cql3/QueryEvents.java
new file mode 100644
index 0000000000..86ef8a56ec
--- /dev/null
+++ b/src/java/org/apache/cassandra/cql3/QueryEvents.java
@@ -0,0 +1,295 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.cassandra.cql3;
+
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.CopyOnWriteArraySet;
+import java.util.concurrent.TimeUnit;
+import java.util.function.Supplier;
+
+import javax.annotation.Nullable;
+
+import com.google.common.annotations.VisibleForTesting;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import org.apache.cassandra.cql3.statements.BatchStatement;
+import org.apache.cassandra.service.QueryState;
+import org.apache.cassandra.transport.Message;
+import org.apache.cassandra.transport.messages.ResultMessage;
+import org.apache.cassandra.utils.JVMStabilityInspector;
+import org.apache.cassandra.utils.NoSpamLogger;
+
+public class QueryEvents
+{
+    private static final Logger logger = LoggerFactory.getLogger(QueryEvents.class);
+    private static final NoSpamLogger noSpam1m = NoSpamLogger.getLogger(logger, 1, TimeUnit.MINUTES);
+    public static final QueryEvents instance = new QueryEvents();
+
+    private final Set<Listener> listeners = new CopyOnWriteArraySet<>();
+
+    @VisibleForTesting
+    public int listenerCount()
+    {
+        return listeners.size();
+    }
+
+    public void registerListener(Listener listener)
+    {
+        listeners.add(listener);
+    }
+
+    public void unregisterListener(Listener listener)
+    {
+        listeners.remove(listener);
+    }
+
+    public void notifyQuerySuccess(CQLStatement statement,
+                                   String query,
+                                   QueryOptions options,
+                                   QueryState state,
+                                   long queryTime,
+                                   Message.Response response)
+    {
+        try
+        {
+            for (Listener listener : listeners)
+                listener.querySuccess(statement, query, options, state, queryTime, response);
+        }
+        catch (Throwable t)
+        {
+            noSpam1m.error("Failed notifying listeners", t);
+            JVMStabilityInspector.inspectThrowable(t);
+        }
+    }
+
+    public void notifyQueryFailure(CQLStatement statement,
+                                   String query,
+                                   QueryOptions options,
+                                   QueryState state,
+                                   Exception cause)
+    {
+        try
+        {
+            for (Listener listener : listeners)
+                listener.queryFailure(statement, query, options, state, cause);
+        }
+        catch (Throwable t)
+        {
+            noSpam1m.error("Failed notifying listeners", t);
+            JVMStabilityInspector.inspectThrowable(t);
+        }
+    }
+
+    public void notifyExecuteSuccess(CQLStatement statement,
+                                     String query,
+                                     QueryOptions options,
+                                     QueryState state,
+                                     long queryTime,
+                                     Message.Response response)
+    {
+        try
+        {
+            for (Listener listener : listeners)
+                listener.executeSuccess(statement, query, options, state, queryTime, response);
+        }
+        catch (Throwable t)
+        {
+            noSpam1m.error("Failed notifying listeners", t);
+            JVMStabilityInspector.inspectThrowable(t);
+        }
+    }
+
+    public void notifyExecuteFailure(QueryHandler.Prepared prepared,
+                                     QueryOptions options,
+                                     QueryState state,
+                                     Exception cause)
+    {
+        CQLStatement statement = prepared != null ? prepared.statement : null;
+        String query = prepared != null ? prepared.rawCQLStatement : null;
+        try
+        {
+            for (Listener listener : listeners)
+                listener.executeFailure(statement, query, options, state, cause);
+        }
+        catch (Throwable t)
+        {
+            noSpam1m.error("Failed notifying listeners", t);
+            JVMStabilityInspector.inspectThrowable(t);
+        }
+    }
+
+    public void notifyBatchSuccess(BatchStatement.Type batchType,
+                                   List<? extends CQLStatement> statements,
+                                   List<String> queries,
+                                   List<List<ByteBuffer>> values,
+                                   QueryOptions options,
+                                   QueryState state,
+                                   long queryTime,
+                                   Message.Response response)
+    {
+        try
+        {
+            for (Listener listener : listeners)
+                listener.batchSuccess(batchType, statements, queries, values, options, state, queryTime, response);
+        }
+        catch (Throwable t)
+        {
+            noSpam1m.error("Failed notifying listeners", t);
+            JVMStabilityInspector.inspectThrowable(t);
+        }
+    }
+
+    public void notifyBatchFailure(List<QueryHandler.Prepared> prepared,
+                                   BatchStatement.Type batchType,
+                                   List<Object> queryOrIdList,
+                                   List<List<ByteBuffer>> values,
+                                   QueryOptions options,
+                                   QueryState state,
+                                   Exception cause)
+    {
+        if (hasListeners())
+        {
+            List<CQLStatement> statements = new ArrayList<>(queryOrIdList.size());
+            List<String> queries = new ArrayList<>(queryOrIdList.size());
+            if (prepared != null)
+            {
+                prepared.forEach(p -> {
+                    statements.add(p.statement);
+                    queries.add(p.rawCQLStatement);
+                });
+            }
+            try
+            {
+                for (Listener listener : listeners)
+                    listener.batchFailure(batchType, statements, queries, values, options, state, cause);
+            }
+            catch (Throwable t)
+            {
+                noSpam1m.error("Failed notifying listeners", t);
+                JVMStabilityInspector.inspectThrowable(t);
+            }
+        }
+    }
+
+    public void notifyPrepareSuccess(Supplier<QueryHandler.Prepared> preparedProvider,
+                                     String query,
+                                     QueryState state,
+                                     long queryTime,
+                                     ResultMessage.Prepared response)
+    {
+        if (hasListeners())
+        {
+            QueryHandler.Prepared prepared = preparedProvider.get();
+            if (prepared != null)
+            {
+                try
+                {
+                    for (Listener listener : listeners)
+                        listener.prepareSuccess(prepared.statement, query, state, queryTime, response);
+                }
+                catch (Throwable t)
+                {
+                    noSpam1m.error("Failed notifying listeners", t);
+                    JVMStabilityInspector.inspectThrowable(t);
+                }
+            }
+            else
+            {
+                // this means that queryHandler.prepare was successful, but then immediately after we can't find the prepared query in the cache, should be very rare
+                notifyPrepareFailure(null, query, state, new RuntimeException("Successfully prepared, but could not find prepared statement for " + response.statementId));
+            }
+        }
+    }
+
+    public void notifyPrepareFailure(@Nullable CQLStatement statement, String query, QueryState state, Exception cause)
+    {
+        try
+        {
+            for (Listener listener : listeners)
+                listener.prepareFailure(statement, query, state, cause);
+        }
+        catch (Throwable t)
+        {
+            noSpam1m.error("Failed notifying listeners", t);
+            JVMStabilityInspector.inspectThrowable(t);
+        }
+    }
+
+    public boolean hasListeners()
+    {
+        return !listeners.isEmpty();
+    }
+
+    public static interface Listener
+    {
+        default void querySuccess(CQLStatement statement,
+                                  String query,
+                                  QueryOptions options,
+                                  QueryState state,
+                                  long queryTime,
+                                  Message.Response response) {}
+        default void queryFailure(@Nullable CQLStatement statement,
+                                  String query,
+                                  QueryOptions options,
+                                  QueryState state,
+                                  Exception cause) {}
+
+        default void executeSuccess(CQLStatement statement,
+                                    String query,
+                                    QueryOptions options,
+                                    QueryState state,
+                                    long queryTime,
+                                    Message.Response response) {}
+        default void executeFailure(@Nullable CQLStatement statement,
+                                    @Nullable String query,
+                                    QueryOptions options,
+                                    QueryState state,
+                                    Exception cause) {}
+
+        default void batchSuccess(BatchStatement.Type batchType,
+                                  List<? extends CQLStatement> statements,
+                                  List<String> queries,
+                                  List<List<ByteBuffer>> values,
+                                  QueryOptions options,
+                                  QueryState state,
+                                  long queryTime,
+                                  Message.Response response) {}
+        default void batchFailure(BatchStatement.Type batchType,
+                                  List<? extends CQLStatement> statements,
+                                  List<String> queries,
+                                  List<List<ByteBuffer>> values,
+                                  QueryOptions options,
+                                  QueryState state,
+                                  Exception cause) {}
+
+        default void prepareSuccess(CQLStatement statement,
+                                    String query,
+                                    QueryState state,
+                                    long queryTime,
+                                    ResultMessage.Prepared response) {}
+        default void prepareFailure(@Nullable CQLStatement statement,
+                                    String query,
+                                    QueryState state,
+                                    Exception cause) {}
+    }
+}
diff --git a/src/java/org/apache/cassandra/cql3/QueryHandler.java b/src/java/org/apache/cassandra/cql3/QueryHandler.java
index b21f9e3f78..22314847d0 100644
--- a/src/java/org/apache/cassandra/cql3/QueryHandler.java
+++ b/src/java/org/apache/cassandra/cql3/QueryHandler.java
@@ -30,7 +30,9 @@ import org.apache.cassandra.utils.MD5Digest;
 
 public interface QueryHandler
 {
-    ResultMessage process(String query,
+    CQLStatement parse(String queryString, QueryState queryState, QueryOptions options);
+
+    ResultMessage process(CQLStatement statement,
                           QueryState state,
                           QueryOptions options,
                           Map<String, ByteBuffer> customPayload,
diff --git a/src/java/org/apache/cassandra/cql3/QueryProcessor.java b/src/java/org/apache/cassandra/cql3/QueryProcessor.java
index b8ec648a6c..0b94ec0cf7 100644
--- a/src/java/org/apache/cassandra/cql3/QueryProcessor.java
+++ b/src/java/org/apache/cassandra/cql3/QueryProcessor.java
@@ -221,22 +221,28 @@ public class QueryProcessor implements QueryHandler
     public static ResultMessage process(String queryString, ConsistencyLevel cl, QueryState queryState, long queryStartNanoTime)
     throws RequestExecutionException, RequestValidationException
     {
-        return instance.process(queryString, queryState, QueryOptions.forInternalCalls(cl, Collections.<ByteBuffer>emptyList()), queryStartNanoTime);
+        QueryOptions options = QueryOptions.forInternalCalls(cl, Collections.<ByteBuffer>emptyList());
+        CQLStatement statement = instance.parse(queryString, queryState, options);
+        return instance.process(statement, queryState, options, queryStartNanoTime);
     }
 
-    public ResultMessage process(String query,
+    public CQLStatement parse(String queryString, QueryState queryState, QueryOptions options)
+    {
+        return getStatement(queryString, queryState.getClientState().cloneWithKeyspaceIfSet(options.getKeyspace()));
+    }
+
+    public ResultMessage process(CQLStatement statement,
                                  QueryState state,
                                  QueryOptions options,
                                  Map<String, ByteBuffer> customPayload,
                                  long queryStartNanoTime) throws RequestExecutionException, RequestValidationException
     {
-        return process(query, state, options, queryStartNanoTime);
+        return process(statement, state, options, queryStartNanoTime);
     }
 
-    public ResultMessage process(String queryString, QueryState queryState, QueryOptions options, long queryStartNanoTime)
+    public ResultMessage process(CQLStatement prepared, QueryState queryState, QueryOptions options, long queryStartNanoTime)
     throws RequestExecutionException, RequestValidationException
     {
-        CQLStatement prepared = getStatement(queryString, queryState.getClientState().cloneWithKeyspaceIfSet(options.getKeyspace()));
         options.prepare(prepared.getBindVariables());
         if (prepared.getBindVariables().size() != options.getValues().size())
             throw new InvalidRequestException("Invalid amount of bind variables");
@@ -259,7 +265,10 @@ public class QueryProcessor implements QueryHandler
 
     public static UntypedResultSet process(String query, ConsistencyLevel cl, List<ByteBuffer> values) throws RequestExecutionException
     {
-        ResultMessage result = instance.process(query, QueryState.forInternalCalls(), QueryOptions.forInternalCalls(cl, values), System.nanoTime());
+        QueryState queryState = QueryState.forInternalCalls();
+        QueryOptions options = QueryOptions.forInternalCalls(cl, values);
+        CQLStatement statement = instance.parse(query, queryState, options);
+        ResultMessage result = instance.process(statement, queryState, options, System.nanoTime());
         if (result instanceof ResultMessage.Rows)
             return UntypedResultSet.create(((ResultMessage.Rows)result).result);
         else
diff --git a/src/java/org/apache/cassandra/audit/FullQueryLogger.java b/src/java/org/apache/cassandra/fql/FullQueryLogger.java
similarity index 67%
rename from src/java/org/apache/cassandra/audit/FullQueryLogger.java
rename to src/java/org/apache/cassandra/fql/FullQueryLogger.java
index 79829408e9..6c38166d3c 100644
--- a/src/java/org/apache/cassandra/audit/FullQueryLogger.java
+++ b/src/java/org/apache/cassandra/fql/FullQueryLogger.java
@@ -15,25 +15,35 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.apache.cassandra.audit;
+package org.apache.cassandra.fql;
 
+import java.io.File;
 import java.nio.ByteBuffer;
+import java.nio.file.Path;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Set;
 
 import javax.annotation.Nullable;
 
 import com.google.common.base.Preconditions;
+import com.google.common.collect.Sets;
 import com.google.common.primitives.Ints;
 
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
 import io.netty.buffer.ByteBuf;
 import net.openhft.chronicle.bytes.BytesStore;
 import net.openhft.chronicle.wire.ValueOut;
 import net.openhft.chronicle.wire.WireOut;
+import org.apache.cassandra.cql3.CQLStatement;
+import org.apache.cassandra.cql3.QueryEvents;
 import org.apache.cassandra.cql3.QueryOptions;
 import org.apache.cassandra.cql3.statements.BatchStatement;
 import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.transport.CBUtil;
+import org.apache.cassandra.transport.Message;
 import org.apache.cassandra.utils.ObjectSizes;
 import org.apache.cassandra.utils.binlog.BinLog;
 import org.apache.cassandra.utils.concurrent.WeightedQueue;
@@ -42,9 +52,14 @@ import org.github.jamm.MemoryLayoutSpecification;
 /**
  * A logger that logs entire query contents after the query finishes (or times out).
  */
-public class FullQueryLogger extends BinLogAuditLogger implements IAuditLogger
+public class FullQueryLogger implements QueryEvents.Listener
 {
-    public static final long CURRENT_VERSION = 0;
+    protected static final Logger logger = LoggerFactory.getLogger(FullQueryLogger.class);
+
+    public static final long CURRENT_VERSION = 0; // encode a dummy version, to prevent pain in decoding in the future
+
+    public static final String VERSION = "version";
+    public static final String TYPE = "type";
 
     public static final String PROTOCOL_VERSION = "protocol-version";
     public static final String QUERY_OPTIONS = "query-options";
@@ -70,6 +85,25 @@ public class FullQueryLogger extends BinLogAuditLogger implements IAuditLogger
     private static final int OBJECT_HEADER_SIZE = MemoryLayoutSpecification.SPEC.getObjectHeaderSize();
     private static final int OBJECT_REFERENCE_SIZE = MemoryLayoutSpecification.SPEC.getReferenceSize();
 
+    public static final FullQueryLogger instance = new FullQueryLogger();
+
+    volatile BinLog binLog;
+
+    public synchronized void enable(Path path, String rollCycle, boolean blocking, int maxQueueWeight, long maxLogSize, String archiveCommand, int maxArchiveRetries)
+    {
+        if (this.binLog != null)
+            throw new IllegalStateException("Binlog is already configured");
+        this.binLog = new BinLog.Builder().path(path)
+                                          .rollCycle(rollCycle)
+                                          .blocking(blocking)
+                                          .maxQueueWeight(maxQueueWeight)
+                                          .maxLogSize(maxLogSize)
+                                          .archiveCommand(archiveCommand)
+                                          .maxArchiveRetries(maxArchiveRetries)
+                                          .build(true);
+        QueryEvents.instance.registerListener(this);
+    }
+
     static
     {
         ByteBuf buf = CBUtil.allocator.buffer(0, 0);
@@ -83,27 +117,123 @@ public class FullQueryLogger extends BinLogAuditLogger implements IAuditLogger
         }
     }
 
-    @Override
-    public void log(AuditLogEntry entry)
+    public synchronized void stop()
     {
-        logQuery(entry.getOperation(), entry.getOptions(), entry.getState(), entry.getTimestamp());
+        try
+        {
+            BinLog binLog = this.binLog;
+            if (binLog != null)
+            {
+                logger.info("Stopping full query logging to {}", binLog.path);
+                binLog.stop();
+            }
+            else
+            {
+                logger.info("Full query log already stopped");
+            }
+        }
+        catch (InterruptedException e)
+        {
+            throw new RuntimeException(e);
+        }
+        finally
+        {
+            QueryEvents.instance.unregisterListener(this);
+            this.binLog = null;
+        }
+    }
+
+    /**
+     * Need the path as a parameter as well because if the process is restarted the config file might be the only
+     * location for retrieving the path to the full query log files, but JMX also allows you to specify a path
+     * that isn't persisted anywhere so we have to clean that one as well.
+     */
+    public synchronized void reset(String fullQueryLogPath)
+    {
+        try
+        {
+            Set<File> pathsToClean = Sets.newHashSet();
+
+            //First decide whether to clean the path configured in the YAML
+            if (fullQueryLogPath != null)
+            {
+                File fullQueryLogPathFile = new File(fullQueryLogPath);
+                if (fullQueryLogPathFile.exists())
+                {
+                    pathsToClean.add(fullQueryLogPathFile);
+                }
+            }
+
+            //Then decide whether to clean the last used path, possibly configured by JMX
+            if (binLog != null && binLog.path != null)
+            {
+                File pathFile = binLog.path.toFile();
+                if (pathFile.exists())
+                {
+                    pathsToClean.add(pathFile);
+                }
+            }
+
+            logger.info("Reset (and deactivation) of full query log requested.");
+            if (binLog != null)
+            {
+                logger.info("Stopping full query log. Cleaning {}.", pathsToClean);
+                binLog.stop();
+                binLog = null;
+            }
+            else
+            {
+                logger.info("Full query log already deactivated. Cleaning {}.", pathsToClean);
+            }
+
+            Throwable accumulate = null;
+            for (File f : pathsToClean)
+            {
+                accumulate = BinLog.cleanDirectory(f, accumulate);
+            }
+            if (accumulate != null)
+            {
+                throw new RuntimeException(accumulate);
+            }
+        }
+        catch (Exception e)
+        {
+            if (e instanceof RuntimeException)
+            {
+                throw (RuntimeException)e;
+            }
+            throw new RuntimeException(e);
+        }
+        finally
+        {
+            QueryEvents.instance.unregisterListener(this);
+        }
+    }
+
+    public boolean isEnabled()
+    {
+        return this.binLog != null;
     }
 
     /**
      * Log an invocation of a batch of queries
      * @param type The type of the batch
+     * @param statements the prepared cql statements (unused here)
      * @param queries CQL text of the queries
      * @param values Values to bind to as parameters for the queries
      * @param queryOptions Options associated with the query invocation
      * @param queryState Timestamp state associated with the query invocation
      * @param batchTimeMillis Approximate time in milliseconds since the epoch since the batch was invoked
+     * @param response the response from the batch query
      */
-    void logBatch(BatchStatement.Type type,
-                  List<String> queries,
-                  List<List<ByteBuffer>> values,
-                  QueryOptions queryOptions,
-                  QueryState queryState,
-                  long batchTimeMillis)
+    public void batchSuccess(BatchStatement.Type type,
+                             List<? extends CQLStatement> statements,
+                             List<String> queries,
+                             List<List<ByteBuffer>> values,
+                             QueryOptions queryOptions,
+                             QueryState queryState,
+                             long batchTimeMillis,
+                             Message.Response response)
     {
         Preconditions.checkNotNull(type, "type was null");
         Preconditions.checkNotNull(queries, "queries was null");
@@ -120,7 +250,7 @@ public class FullQueryLogger extends BinLogAuditLogger implements IAuditLogger
         }
 
         Batch wrappedBatch = new Batch(type, queries, values, queryOptions, queryState, batchTimeMillis);
-        logRecord(wrappedBatch, binLog);
+        binLog.logRecord(wrappedBatch);
     }
 
     /**
@@ -129,8 +259,14 @@ public class FullQueryLogger extends BinLogAuditLogger implements IAuditLogger
      * @param queryOptions Options associated with the query invocation
      * @param queryState Timestamp state associated with the query invocation
      * @param queryTimeMillis Approximate time in milliseconds since the epoch since the batch was invoked
+     * @param response the response from this query
      */
-    void logQuery(String query, QueryOptions queryOptions, QueryState queryState, long queryTimeMillis)
+    public void querySuccess(CQLStatement statement,
+                             String query,
+                             QueryOptions queryOptions,
+                             QueryState queryState,
+                             long queryTimeMillis,
+                             Message.Response response)
     {
         Preconditions.checkNotNull(query, "query was null");
         Preconditions.checkNotNull(queryOptions, "queryOptions was null");
@@ -140,12 +276,15 @@ public class FullQueryLogger extends BinLogAuditLogger implements IAuditLogger
         //Don't construct the wrapper if the log is disabled
         BinLog binLog = this.binLog;
         if (binLog == null)
-        {
             return;
-        }
 
         Query wrappedQuery = new Query(query, queryOptions, queryState, queryTimeMillis);
-        logRecord(wrappedQuery, binLog);
+        binLog.logRecord(wrappedQuery);
+    }
+
+    public void executeSuccess(CQLStatement statement, String query, QueryOptions options, QueryState state, long queryTime, Message.Response response)
+    {
+        querySuccess(statement, query, options, state, queryTime, response);
     }
 
     public static class Query extends AbstractLogEntry
diff --git a/src/java/org/apache/cassandra/audit/FullQueryLoggerOptions.java b/src/java/org/apache/cassandra/fql/FullQueryLoggerOptions.java
similarity index 97%
rename from src/java/org/apache/cassandra/audit/FullQueryLoggerOptions.java
rename to src/java/org/apache/cassandra/fql/FullQueryLoggerOptions.java
index 825a8b8b25..c54169cc30 100644
--- a/src/java/org/apache/cassandra/audit/FullQueryLoggerOptions.java
+++ b/src/java/org/apache/cassandra/fql/FullQueryLoggerOptions.java
@@ -16,7 +16,7 @@
  * limitations under the License.
  */
 
-package org.apache.cassandra.audit;
+package org.apache.cassandra.fql;
 
 import org.apache.commons.lang3.StringUtils;
 
diff --git a/src/java/org/apache/cassandra/service/CassandraDaemon.java b/src/java/org/apache/cassandra/service/CassandraDaemon.java
index 7465bb3fb9..2dbe2179a0 100644
--- a/src/java/org/apache/cassandra/service/CassandraDaemon.java
+++ b/src/java/org/apache/cassandra/service/CassandraDaemon.java
@@ -44,6 +44,7 @@ import com.google.common.util.concurrent.ListenableFuture;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import org.apache.cassandra.audit.AuditLogManager;
 import org.apache.cassandra.concurrent.ScheduledExecutors;
 import org.apache.cassandra.db.virtual.SystemViewsKeyspace;
 import org.apache.cassandra.db.virtual.VirtualKeyspaceRegistry;
@@ -409,6 +410,8 @@ public class CassandraDaemon
             }
         }
 
+        AuditLogManager.instance.initialize();
+
         // schedule periodic background compaction task submission. this is simply a backstop against compactions stalling
         // due to scheduling errors or race conditions
         ScheduledExecutors.optionalTasks.scheduleWithFixedDelay(ColumnFamilyStore.getBackgroundCompactionTaskSubmitter(), 5, 1, TimeUnit.MINUTES);
diff --git a/src/java/org/apache/cassandra/service/StorageProxy.java b/src/java/org/apache/cassandra/service/StorageProxy.java
index 0caee86138..59e6de7980 100644
--- a/src/java/org/apache/cassandra/service/StorageProxy.java
+++ b/src/java/org/apache/cassandra/service/StorageProxy.java
@@ -53,8 +53,6 @@ import org.apache.commons.lang3.StringUtils;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import org.apache.cassandra.audit.AuditLogManager;
-import org.apache.cassandra.audit.FullQueryLoggerOptions;
 import org.apache.cassandra.batchlog.Batch;
 import org.apache.cassandra.batchlog.BatchlogManager;
 import org.apache.cassandra.concurrent.Stage;
@@ -2779,34 +2777,6 @@ public class StorageProxy implements StorageProxyMBean
         return String.format("Updating ideal consistency level new value: %s old value %s", newCL, original.toString());
     }
 
-    @Override
-    public void configureFullQueryLogger(String path, String rollCycle, Boolean blocking, int maxQueueWeight, long maxLogSize, String archiveCommand, int maxArchiveRetries)
-    {
-        FullQueryLoggerOptions fqlOptions = DatabaseDescriptor.getFullQueryLogOptions();
-        path = path != null ? path : fqlOptions.log_dir;
-        rollCycle = rollCycle != null ? rollCycle : fqlOptions.roll_cycle;
-        blocking = blocking != null ? blocking : fqlOptions.block;
-        maxQueueWeight = maxQueueWeight != Integer.MIN_VALUE ? maxQueueWeight : fqlOptions.max_queue_weight;
-        maxLogSize = maxLogSize != Long.MIN_VALUE ? maxLogSize : fqlOptions.max_log_size;
-        archiveCommand = archiveCommand != null ? archiveCommand : fqlOptions.archive_command;
-        maxArchiveRetries = maxArchiveRetries != Integer.MIN_VALUE ? maxArchiveRetries : fqlOptions.max_archive_retries;
-
-        Preconditions.checkNotNull(path, "cassandra.yaml did not set log_dir and not set as parameter");
-        AuditLogManager.getInstance().configureFQL(Paths.get(path), rollCycle, blocking, maxQueueWeight, maxLogSize, archiveCommand, maxArchiveRetries);
-    }
-
-    @Override
-    public void resetFullQueryLogger()
-    {
-        AuditLogManager.getInstance().resetFQL(DatabaseDescriptor.getFullQueryLogOptions().log_dir);
-    }
-
-    @Override
-    public void stopFullQueryLogger()
-    {
-        AuditLogManager.getInstance().disableFQL();
-    }
-
     @Deprecated
     public int getOtcBacklogExpirationInterval() {
         return 0;
diff --git a/src/java/org/apache/cassandra/service/StorageProxyMBean.java b/src/java/org/apache/cassandra/service/StorageProxyMBean.java
index 08b5cbd3b4..514feb198e 100644
--- a/src/java/org/apache/cassandra/service/StorageProxyMBean.java
+++ b/src/java/org/apache/cassandra/service/StorageProxyMBean.java
@@ -21,9 +21,6 @@ import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
-import javax.annotation.Nullable;
-
-import org.apache.cassandra.db.ConsistencyLevel;
 
 public interface StorageProxyMBean
 {
@@ -77,30 +74,6 @@ public interface StorageProxyMBean
     public String getIdealConsistencyLevel();
     public String setIdealConsistencyLevel(String cl);
 
-    /**
-     * Start the fully query logger.
-     * @param path Path where the full query log will be stored. If null cassandra.yaml value is used.
-     * @param rollCycle How often to create a new file for query data (MINUTELY, DAILY, HOURLY)
-     * @param blocking Whether threads submitting queries to the query log should block if they can't be drained to the filesystem or alternatively drops samples and log
-     * @param maxQueueWeight How many bytes of query data to queue before blocking or dropping samples
-     * @param maxLogSize How many bytes of log data to store before dropping segments. Might not be respected if a log file hasn't rolled so it can be deleted.
-     * @param archiveCommand executable archiving the rolled log files,
-     * @param maxArchiveRetries max number of times to retry a failing archive command
-     *
-     */
-    public void configureFullQueryLogger(String path, String rollCycle, Boolean blocking, int maxQueueWeight, long maxLogSize, @Nullable String archiveCommand, int maxArchiveRetries);
-
-    /**
-     * Disable the full query logger if it is enabled.
-     * Also delete any generated files in the last used full query log path as well as the one configure in cassandra.yaml
-     */
-    public void resetFullQueryLogger();
-
-    /**
-     * Stop logging queries but leave any generated files on disk.
-     */
-    public void stopFullQueryLogger();
-
     /**
      * Tracking and reporting of variances in the repaired data set across replicas at read time
      */
diff --git a/src/java/org/apache/cassandra/service/StorageService.java b/src/java/org/apache/cassandra/service/StorageService.java
index aa03aea44e..fd350bfac4 100644
--- a/src/java/org/apache/cassandra/service/StorageService.java
+++ b/src/java/org/apache/cassandra/service/StorageService.java
@@ -21,6 +21,7 @@ import java.io.*;
 import java.net.InetAddress;
 import java.net.UnknownHostException;
 import java.nio.ByteBuffer;
+import java.nio.file.Paths;
 import java.util.*;
 import java.util.Map.Entry;
 import java.util.concurrent.*;
@@ -47,6 +48,8 @@ import com.google.common.collect.*;
 import com.google.common.util.concurrent.*;
 
 import org.apache.cassandra.dht.RangeStreamer.FetchReplica;
+import org.apache.cassandra.fql.FullQueryLogger;
+import org.apache.cassandra.fql.FullQueryLoggerOptions;
 import org.apache.cassandra.locator.ReplicaCollection.Builder.Conflict;
 import org.apache.commons.lang3.StringUtils;
 
@@ -5400,7 +5403,7 @@ public class StorageService extends NotificationBroadcasterSupport implements IE
     }
     public void disableAuditLog()
     {
-        AuditLogManager.getInstance().disableAuditLog();
+        AuditLogManager.instance.disableAuditLog();
         logger.info("Auditlog is disabled");
     }
 
@@ -5422,7 +5425,7 @@ public class StorageService extends NotificationBroadcasterSupport implements IE
         auditLogOptions.included_users = includedUsers != null ? includedUsers : DatabaseDescriptor.getAuditLoggingOptions().included_users;
         auditLogOptions.excluded_users = excludedUsers != null ? excludedUsers : DatabaseDescriptor.getAuditLoggingOptions().excluded_users;
 
-        AuditLogManager.getInstance().enableAuditLog(auditLogOptions);
+        AuditLogManager.instance.enable(auditLogOptions);
 
         logger.info("AuditLog is enabled with logger: [{}], included_keyspaces: [{}], excluded_keyspaces: [{}], " +
                     "included_categories: [{}], excluded_categories: [{}], included_users: [{}], "
@@ -5434,7 +5437,7 @@ public class StorageService extends NotificationBroadcasterSupport implements IE
 
     public boolean isAuditLogEnabled()
     {
-        return AuditLogManager.getInstance().isAuditingEnabled();
+        return AuditLogManager.instance.isEnabled();
     }
 
     public String getCorruptedTombstoneStrategy()
@@ -5480,4 +5483,32 @@ public class StorageService extends NotificationBroadcasterSupport implements IE
             Runtime.getRuntime().removeShutdownHook(drainOnShutdown);
         }
     }
+
+    @Override
+    public void enableFullQueryLogger(String path, String rollCycle, Boolean blocking, int maxQueueWeight, long maxLogSize, String archiveCommand, int maxArchiveRetries)
+    {
+        FullQueryLoggerOptions fqlOptions = DatabaseDescriptor.getFullQueryLogOptions();
+        path = path != null ? path : fqlOptions.log_dir;
+        rollCycle = rollCycle != null ? rollCycle : fqlOptions.roll_cycle;
+        blocking = blocking != null ? blocking : fqlOptions.block;
+        maxQueueWeight = maxQueueWeight != Integer.MIN_VALUE ? maxQueueWeight : fqlOptions.max_queue_weight;
+        maxLogSize = maxLogSize != Long.MIN_VALUE ? maxLogSize : fqlOptions.max_log_size;
+        archiveCommand = archiveCommand != null ? archiveCommand : fqlOptions.archive_command;
+        maxArchiveRetries = maxArchiveRetries != Integer.MIN_VALUE ? maxArchiveRetries : fqlOptions.max_archive_retries;
+
+        Preconditions.checkNotNull(path, "cassandra.yaml did not set log_dir and not set as parameter");
+        FullQueryLogger.instance.enable(Paths.get(path), rollCycle, blocking, maxQueueWeight, maxLogSize, archiveCommand, maxArchiveRetries);
+    }
+
+    @Override
+    public void resetFullQueryLogger()
+    {
+        FullQueryLogger.instance.reset(DatabaseDescriptor.getFullQueryLogOptions().log_dir);
+    }
+
+    @Override
+    public void stopFullQueryLogger()
+    {
+        FullQueryLogger.instance.stop();
+    }
 }
diff --git a/src/java/org/apache/cassandra/service/StorageServiceMBean.java b/src/java/org/apache/cassandra/service/StorageServiceMBean.java
index dea25b4054..74307fc0be 100644
--- a/src/java/org/apache/cassandra/service/StorageServiceMBean.java
+++ b/src/java/org/apache/cassandra/service/StorageServiceMBean.java
@@ -746,4 +746,29 @@ public interface StorageServiceMBean extends NotificationEmitter
     public boolean isAuditLogEnabled();
     public String getCorruptedTombstoneStrategy();
     public void setCorruptedTombstoneStrategy(String strategy);
+
+    /**
+     * Start the fully query logger.
+     * @param path Path where the full query log will be stored. If null cassandra.yaml value is used.
+     * @param rollCycle How often to create a new file for query data (MINUTELY, DAILY, HOURLY)
+     * @param blocking Whether threads submitting queries to the query log should block if they can't be drained to the filesystem or alternatively drops samples and log
+     * @param maxQueueWeight How many bytes of query data to queue before blocking or dropping samples
+     * @param maxLogSize How many bytes of log data to store before dropping segments. Might not be respected if a log file hasn't rolled so it can be deleted.
+     * @param archiveCommand executable archiving the rolled log files,
+     * @param maxArchiveRetries max number of times to retry a failing archive command
+     *
+     */
+    public void enableFullQueryLogger(String path, String rollCycle, Boolean blocking, int maxQueueWeight, long maxLogSize, @Nullable String archiveCommand, int maxArchiveRetries);
+
+    /**
+     * Disable the full query logger if it is enabled.
+     * Also delete any generated files in the last used full query log path as well as the one configure in cassandra.yaml
+     */
+    public void resetFullQueryLogger();
+
+    /**
+     * Stop logging queries but leave any generated files on disk.
+     */
+    public void stopFullQueryLogger();
+
 }
diff --git a/src/java/org/apache/cassandra/tools/NodeProbe.java b/src/java/org/apache/cassandra/tools/NodeProbe.java
index f9f2c1aed4..92772780e6 100644
--- a/src/java/org/apache/cassandra/tools/NodeProbe.java
+++ b/src/java/org/apache/cassandra/tools/NodeProbe.java
@@ -42,6 +42,7 @@ import java.util.concurrent.ExecutionException;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 
+import javax.annotation.Nullable;
 import javax.management.JMX;
 import javax.management.MBeanServerConnection;
 import javax.management.MalformedObjectNameException;
@@ -195,7 +196,7 @@ public class NodeProbe implements AutoCloseable
     protected void connect() throws IOException
     {
         JMXServiceURL jmxUrl = new JMXServiceURL(String.format(fmtUrl, host, port));
-        Map<String,Object> env = new HashMap<String,Object>();
+        Map<String, Object> env = new HashMap<String, Object>();
         if (username != null)
         {
             String[] creds = { username, password };
@@ -1683,7 +1684,7 @@ public class NodeProbe implements AutoCloseable
         }
         catch (Exception e)
         {
-          throw new RuntimeException("Error setting log for " + classQualifier +" on level " + level +". Please check logback configuration and ensure to have <jmxConfigurator /> set", e);
+            throw new RuntimeException("Error setting log for " + classQualifier + " on level " + level + ". Please check logback configuration and ensure to have <jmxConfigurator /> set", e);
         }
     }
 
@@ -1807,6 +1808,21 @@ public class NodeProbe implements AutoCloseable
     {
         return msProxy;
     }
+
+    public void enableFullQueryLogger(String path, String rollCycle, Boolean blocking, int maxQueueWeight, long maxLogSize, @Nullable String archiveCommand, int maxArchiveRetries)
+    {
+        ssProxy.enableFullQueryLogger(path, rollCycle, blocking, maxQueueWeight, maxLogSize, archiveCommand, maxArchiveRetries);
+    }
+
+    public void stopFullQueryLogger()
+    {
+        ssProxy.stopFullQueryLogger();
+    }
+
+    public void resetFullQueryLogger()
+    {
+        ssProxy.resetFullQueryLogger();
+    }
 }
 
 class ColumnFamilyStoreMBeanIterator implements Iterator<Map.Entry<String, ColumnFamilyStoreMBean>>
diff --git a/src/java/org/apache/cassandra/tools/nodetool/DisableFullQueryLog.java b/src/java/org/apache/cassandra/tools/nodetool/DisableFullQueryLog.java
index 802e85419d..8820e5f0cb 100644
--- a/src/java/org/apache/cassandra/tools/nodetool/DisableFullQueryLog.java
+++ b/src/java/org/apache/cassandra/tools/nodetool/DisableFullQueryLog.java
@@ -28,6 +28,6 @@ public class DisableFullQueryLog extends NodeToolCmd
     @Override
     public void execute(NodeProbe probe)
     {
-        probe.getSpProxy().stopFullQueryLogger();
+        probe.stopFullQueryLogger();
     }
 }
\ No newline at end of file
diff --git a/src/java/org/apache/cassandra/tools/nodetool/EnableFullQueryLog.java b/src/java/org/apache/cassandra/tools/nodetool/EnableFullQueryLog.java
index 1d35e66d26..8ab642a9dc 100644
--- a/src/java/org/apache/cassandra/tools/nodetool/EnableFullQueryLog.java
+++ b/src/java/org/apache/cassandra/tools/nodetool/EnableFullQueryLog.java
@@ -51,6 +51,6 @@ public class EnableFullQueryLog extends NodeToolCmd
     @Override
     public void execute(NodeProbe probe)
     {
-        probe.getSpProxy().configureFullQueryLogger(path, rollCycle, blocking, maxQueueWeight, maxLogSize, archiveCommand, archiveRetries);
+        probe.enableFullQueryLogger(path, rollCycle, blocking, maxQueueWeight, maxLogSize, archiveCommand, archiveRetries);
     }
 }
\ No newline at end of file
diff --git a/src/java/org/apache/cassandra/tools/nodetool/ResetFullQueryLog.java b/src/java/org/apache/cassandra/tools/nodetool/ResetFullQueryLog.java
index cfc20ab16c..786852d96f 100644
--- a/src/java/org/apache/cassandra/tools/nodetool/ResetFullQueryLog.java
+++ b/src/java/org/apache/cassandra/tools/nodetool/ResetFullQueryLog.java
@@ -28,6 +28,6 @@ public class ResetFullQueryLog extends NodeToolCmd
     @Override
     public void execute(NodeProbe probe)
     {
-        probe.getSpProxy().resetFullQueryLogger();
+        probe.resetFullQueryLogger();
     }
 }
\ No newline at end of file
diff --git a/src/java/org/apache/cassandra/transport/messages/AuthResponse.java b/src/java/org/apache/cassandra/transport/messages/AuthResponse.java
index d101681881..81002c8281 100644
--- a/src/java/org/apache/cassandra/transport/messages/AuthResponse.java
+++ b/src/java/org/apache/cassandra/transport/messages/AuthResponse.java
@@ -20,9 +20,7 @@ package org.apache.cassandra.transport.messages;
 import java.nio.ByteBuffer;
 
 import io.netty.buffer.ByteBuf;
-import org.apache.cassandra.audit.AuditLogEntry;
-import org.apache.cassandra.audit.AuditLogEntryType;
-import org.apache.cassandra.audit.AuditLogManager;
+import org.apache.cassandra.auth.AuthEvents;
 import org.apache.cassandra.auth.AuthenticatedUser;
 import org.apache.cassandra.auth.IAuthenticator;
 import org.apache.cassandra.exceptions.AuthenticationException;
@@ -73,8 +71,6 @@ public class AuthResponse extends Message.Request
     @Override
     protected Response execute(QueryState queryState, long queryStartNanoTime, boolean traceRequest)
     {
-        AuditLogManager auditLogManager = AuditLogManager.getInstance();
-
         try
         {
             IAuthenticator.SaslNegotiator negotiator = ((ServerConnection) connection).getSaslNegotiator(queryState);
@@ -84,8 +80,7 @@ public class AuthResponse extends Message.Request
                 AuthenticatedUser user = negotiator.getAuthenticatedUser();
                 queryState.getClientState().login(user);
                 ClientMetrics.instance.markAuthSuccess();
-                if (auditLogManager.isAuditingEnabled())
-                    logSuccess(queryState);
+                AuthEvents.instance.notifyAuthSuccess(queryState);
                 // authentication is complete, send a ready message to the client
                 return new AuthSuccess(challenge);
             }
@@ -97,29 +92,8 @@ public class AuthResponse extends Message.Request
         catch (AuthenticationException e)
         {
             ClientMetrics.instance.markAuthFailure();
-            if (auditLogManager.isAuditingEnabled())
-                logException(queryState, e);
+            AuthEvents.instance.notifyAuthFailure(queryState, e);
             return ErrorMessage.fromException(e);
         }
     }
-
-    private void logSuccess(QueryState state)
-    {
-        AuditLogEntry entry =
-            new AuditLogEntry.Builder(state)
-                             .setOperation("LOGIN SUCCESSFUL")
-                             .setType(AuditLogEntryType.LOGIN_SUCCESS)
-                             .build();
-        AuditLogManager.getInstance().log(entry);
-    }
-
-    private void logException(QueryState state, AuthenticationException e)
-    {
-        AuditLogEntry entry =
-            new AuditLogEntry.Builder(state)
-                             .setOperation("LOGIN FAILURE")
-                             .setType(AuditLogEntryType.LOGIN_ERROR)
-                             .build();
-        AuditLogManager.getInstance().log(entry, e);
-    }
 }
diff --git a/src/java/org/apache/cassandra/transport/messages/BatchMessage.java b/src/java/org/apache/cassandra/transport/messages/BatchMessage.java
index a85bec0994..e760960137 100644
--- a/src/java/org/apache/cassandra/transport/messages/BatchMessage.java
+++ b/src/java/org/apache/cassandra/transport/messages/BatchMessage.java
@@ -24,12 +24,10 @@ import java.util.List;
 import com.google.common.collect.ImmutableMap;
 
 import io.netty.buffer.ByteBuf;
-import org.apache.cassandra.audit.AuditLogEntry;
-import org.apache.cassandra.audit.AuditLogEntryType;
-import org.apache.cassandra.audit.AuditLogManager;
 import org.apache.cassandra.cql3.Attributes;
 import org.apache.cassandra.cql3.BatchQueryOptions;
 import org.apache.cassandra.cql3.CQLStatement;
+import org.apache.cassandra.cql3.QueryEvents;
 import org.apache.cassandra.cql3.QueryHandler;
 import org.apache.cassandra.cql3.QueryOptions;
 import org.apache.cassandra.cql3.QueryProcessor;
@@ -165,15 +163,14 @@ public class BatchMessage extends Message.Request
     @Override
     protected Message.Response execute(QueryState state, long queryStartNanoTime, boolean traceRequest)
     {
-        AuditLogManager auditLogManager = AuditLogManager.getInstance();
-
+        List<QueryHandler.Prepared> prepared = null;
         try
         {
             if (traceRequest)
                 traceQuery(state);
 
             QueryHandler handler = ClientState.getCQLQueryHandler();
-            List<QueryHandler.Prepared> prepared = new ArrayList<>(queryOrIdList.size());
+            prepared = new ArrayList<>(queryOrIdList.size());
             for (int i = 0; i < queryOrIdList.size(); i++)
             {
                 Object query = queryOrIdList.get(i);
@@ -202,9 +199,12 @@ public class BatchMessage extends Message.Request
 
             BatchQueryOptions batchOptions = BatchQueryOptions.withPerStatementVariables(options, values, queryOrIdList);
             List<ModificationStatement> statements = new ArrayList<>(prepared.size());
+            List<String> queries = QueryEvents.instance.hasListeners() ? new ArrayList<>(prepared.size()) : null;
             for (int i = 0; i < prepared.size(); i++)
             {
                 CQLStatement statement = prepared.get(i).statement;
+                if (queries != null)
+                    queries.add(prepared.get(i).rawCQLStatement);
                 batchOptions.prepareStatement(i, statement.getBindVariables());
 
                 if (!(statement instanceof ModificationStatement))
@@ -217,18 +217,15 @@ public class BatchMessage extends Message.Request
             // (and no value would be really correct, so we prefer passing a clearly wrong one).
             BatchStatement batch = new BatchStatement(batchType, VariableSpecifications.empty(), statements, Attributes.none());
 
-            long fqlTime = auditLogManager.isLoggingEnabled() ? System.currentTimeMillis() : 0;
+            long queryTime = System.currentTimeMillis();
             Message.Response response = handler.processBatch(batch, state, batchOptions, getCustomPayload(), queryStartNanoTime);
-
-            if (auditLogManager.isLoggingEnabled())
-                auditLogManager.logBatch(batchType, queryOrIdList, values, prepared, options, state, fqlTime);
-
+            if (queries != null)
+                QueryEvents.instance.notifyBatchSuccess(batchType, statements, queries, values, options, state, queryTime, response);
             return response;
         }
         catch (Exception e)
         {
-            if (auditLogManager.isAuditingEnabled())
-                logException(state, e);
+            QueryEvents.instance.notifyBatchFailure(prepared, batchType, queryOrIdList, values, options, state, e);
             JVMStabilityInspector.inspectThrowable(e);
             return ErrorMessage.fromException(e);
         }
@@ -246,17 +243,6 @@ public class BatchMessage extends Message.Request
         Tracing.instance.begin("Execute batch of CQL3 queries", state.getClientAddress(), builder.build());
     }
 
-    private void logException(QueryState state, Exception e)
-    {
-        AuditLogEntry entry =
-            new AuditLogEntry.Builder(state)
-                             .setOperation(getAuditString())
-                             .setOptions(options)
-                             .setType(AuditLogEntryType.BATCH)
-                             .build();
-        AuditLogManager.getInstance().log(entry, e);
-    }
-
     @Override
     public String toString()
     {
@@ -270,9 +256,4 @@ public class BatchMessage extends Message.Request
         sb.append("] at consistency ").append(options.getConsistency());
         return sb.toString();
     }
-
-    private String getAuditString()
-    {
-        return String.format("BATCH of %d statements at consistency %s", queryOrIdList.size(), options.getConsistency());
-    }
 }
diff --git a/src/java/org/apache/cassandra/transport/messages/ExecuteMessage.java b/src/java/org/apache/cassandra/transport/messages/ExecuteMessage.java
index ff888f276f..3b9899621c 100644
--- a/src/java/org/apache/cassandra/transport/messages/ExecuteMessage.java
+++ b/src/java/org/apache/cassandra/transport/messages/ExecuteMessage.java
@@ -20,10 +20,9 @@ package org.apache.cassandra.transport.messages;
 import com.google.common.collect.ImmutableMap;
 
 import io.netty.buffer.ByteBuf;
-import org.apache.cassandra.audit.AuditLogEntry;
-import org.apache.cassandra.audit.AuditLogManager;
 import org.apache.cassandra.cql3.CQLStatement;
 import org.apache.cassandra.cql3.ColumnSpecification;
+import org.apache.cassandra.cql3.QueryEvents;
 import org.apache.cassandra.cql3.QueryHandler;
 import org.apache.cassandra.cql3.QueryOptions;
 import org.apache.cassandra.cql3.ResultSet;
@@ -113,12 +112,11 @@ public class ExecuteMessage extends Message.Request
     @Override
     protected Message.Response execute(QueryState state, long queryStartNanoTime, boolean traceRequest)
     {
-        AuditLogManager auditLogManager = AuditLogManager.getInstance();
-
+        QueryHandler.Prepared prepared = null;
         try
         {
             QueryHandler handler = ClientState.getCQLQueryHandler();
-            QueryHandler.Prepared prepared = handler.getPrepared(statementId);
+            prepared = handler.getPrepared(statementId);
             if (prepared == null)
                 throw new PreparedQueryNotFoundException(statementId);
 
@@ -135,12 +133,11 @@ public class ExecuteMessage extends Message.Request
             // by wrapping the QueryOptions.
             QueryOptions queryOptions = QueryOptions.addColumnSpecifications(options, prepared.statement.getBindVariables());
 
-            long requestStartTime = auditLogManager.isLoggingEnabled() ? System.currentTimeMillis() : 0L;
+            long requestStartTime = System.currentTimeMillis();
 
             Message.Response response = handler.processPrepared(statement, state, queryOptions, getCustomPayload(), queryStartNanoTime);
 
-            if (auditLogManager.isLoggingEnabled())
-                logSuccess(state, prepared, requestStartTime);
+            QueryEvents.instance.notifyExecuteSuccess(prepared.statement, prepared.rawCQLStatement, options, state, requestStartTime, response);
 
             if (response instanceof ResultMessage.Rows)
             {
@@ -176,8 +173,7 @@ public class ExecuteMessage extends Message.Request
         }
         catch (Exception e)
         {
-            if (auditLogManager.isAuditingEnabled())
-                logException(state, e);
+            QueryEvents.instance.notifyExecuteFailure(prepared, options, state, e);
             JVMStabilityInspector.inspectThrowable(e);
             return ErrorMessage.fromException(e);
         }
@@ -211,48 +207,6 @@ public class ExecuteMessage extends Message.Request
         Tracing.instance.begin("Execute CQL3 prepared query", state.getClientAddress(), builder.build());
     }
 
-    private void logSuccess(QueryState state, QueryHandler.Prepared prepared, long requestStartTime)
-    {
-        AuditLogEntry entry =
-            new AuditLogEntry.Builder(state)
-                             .setType(prepared.statement.getAuditLogContext().auditLogEntryType)
-                             .setOperation(prepared.rawCQLStatement)
-                             .setTimestamp(requestStartTime)
-                             .setScope(prepared.statement)
-                             .setKeyspace(state, prepared.statement)
-                             .setOptions(options)
-                             .build();
-        AuditLogManager.getInstance().log(entry);
-    }
-
-    private void logException(QueryState state, Exception e)
-    {
-        if (e instanceof PreparedQueryNotFoundException)
-        {
-            AuditLogEntry entry =
-                new AuditLogEntry.Builder(state)
-                                 .setOperation(toString())
-                                 .setOptions(options)
-                                 .build();
-            AuditLogManager.getInstance().log(entry, e);
-            return;
-        }
-
-        QueryHandler.Prepared prepared = ClientState.getCQLQueryHandler().getPrepared(statementId);
-        if (prepared != null)
-        {
-            AuditLogEntry entry =
-                new AuditLogEntry.Builder(state)
-                                 .setOperation(toString())
-                                 .setType(prepared.statement.getAuditLogContext().auditLogEntryType)
-                                 .setScope(prepared.statement)
-                                 .setKeyspace(state, prepared.statement)
-                                 .setOptions(options)
-                                 .build();
-            AuditLogManager.getInstance().log(entry, e);
-        }
-    }
-
     @Override
     public String toString()
     {
diff --git a/src/java/org/apache/cassandra/transport/messages/PrepareMessage.java b/src/java/org/apache/cassandra/transport/messages/PrepareMessage.java
index ca7e0d4e15..fa77c6829a 100644
--- a/src/java/org/apache/cassandra/transport/messages/PrepareMessage.java
+++ b/src/java/org/apache/cassandra/transport/messages/PrepareMessage.java
@@ -17,14 +17,13 @@
  */
 package org.apache.cassandra.transport.messages;
 
+import java.util.function.Supplier;
+
 import com.google.common.collect.ImmutableMap;
 
 import io.netty.buffer.ByteBuf;
-import org.apache.cassandra.audit.AuditLogEntry;
-import org.apache.cassandra.audit.AuditLogEntryType;
-import org.apache.cassandra.audit.AuditLogManager;
-import org.apache.cassandra.cql3.CQLStatement;
-import org.apache.cassandra.cql3.QueryProcessor;
+import org.apache.cassandra.cql3.QueryEvents;
+import org.apache.cassandra.cql3.QueryHandler;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.tracing.Tracing;
@@ -104,55 +103,26 @@ public class PrepareMessage extends Message.Request
     @Override
     protected Message.Response execute(QueryState state, long queryStartNanoTime, boolean traceRequest)
     {
-        AuditLogManager auditLogManager = AuditLogManager.getInstance();
-
         try
         {
             if (traceRequest)
                 Tracing.instance.begin("Preparing CQL3 query", state.getClientAddress(), ImmutableMap.of("query", query));
 
             ClientState clientState = state.getClientState().cloneWithKeyspaceIfSet(keyspace);
-            Message.Response response = ClientState.getCQLQueryHandler().prepare(query, clientState, getCustomPayload());
-
-            if (auditLogManager.isAuditingEnabled())
-                logSuccess(state);
-
+            QueryHandler queryHandler = ClientState.getCQLQueryHandler();
+            long queryTime = System.currentTimeMillis();
+            ResultMessage.Prepared response = queryHandler.prepare(query, clientState, getCustomPayload());
+            QueryEvents.instance.notifyPrepareSuccess(() -> queryHandler.getPrepared(response.statementId), query, state, queryTime, response);
             return response;
         }
         catch (Exception e)
         {
-            if (auditLogManager.isAuditingEnabled())
-                logException(state, e);
+            QueryEvents.instance.notifyPrepareFailure(null, query, state, e);
             JVMStabilityInspector.inspectThrowable(e);
             return ErrorMessage.fromException(e);
         }
     }
 
-    private void logSuccess(QueryState state)
-    {
-        // The statement gets parsed twice. Not a big deal given that this is PREPARE, but still, why?
-        CQLStatement statement = QueryProcessor.parseStatement(query, state.getClientState());
-        AuditLogEntry entry =
-            new AuditLogEntry.Builder(state)
-                             .setOperation(query)
-                             .setType(AuditLogEntryType.PREPARE_STATEMENT)
-                             .setScope(statement)
-                             .setKeyspace(statement)
-                             .build();
-        AuditLogManager.getInstance().log(entry);
-    }
-
-    private void logException(QueryState state, Exception e)
-    {
-        AuditLogEntry entry =
-            new AuditLogEntry.Builder(state)
-                             .setOperation(query)
-                             .setKeyspace(keyspace)
-                             .setType(AuditLogEntryType.PREPARE_STATEMENT)
-                             .build();
-        AuditLogManager.getInstance().log(entry, e);
-    }
-
     @Override
     public String toString()
     {
diff --git a/src/java/org/apache/cassandra/transport/messages/QueryMessage.java b/src/java/org/apache/cassandra/transport/messages/QueryMessage.java
index 7b80200a51..71d7c731ec 100644
--- a/src/java/org/apache/cassandra/transport/messages/QueryMessage.java
+++ b/src/java/org/apache/cassandra/transport/messages/QueryMessage.java
@@ -20,11 +20,10 @@ package org.apache.cassandra.transport.messages;
 import com.google.common.collect.ImmutableMap;
 
 import io.netty.buffer.ByteBuf;
-import org.apache.cassandra.audit.AuditLogEntry;
-import org.apache.cassandra.audit.AuditLogManager;
 import org.apache.cassandra.cql3.CQLStatement;
+import org.apache.cassandra.cql3.QueryEvents;
+import org.apache.cassandra.cql3.QueryHandler;
 import org.apache.cassandra.cql3.QueryOptions;
-import org.apache.cassandra.cql3.QueryProcessor;
 import org.apache.cassandra.exceptions.RequestExecutionException;
 import org.apache.cassandra.exceptions.RequestValidationException;
 import org.apache.cassandra.service.ClientState;
@@ -93,8 +92,7 @@ public class QueryMessage extends Message.Request
     @Override
     protected Message.Response execute(QueryState state, long queryStartNanoTime, boolean traceRequest)
     {
-        AuditLogManager auditLogManager = AuditLogManager.getInstance();
-
+        CQLStatement statement = null;
         try
         {
             if (options.getPageSize() == 0)
@@ -103,12 +101,12 @@ public class QueryMessage extends Message.Request
             if (traceRequest)
                 traceQuery(state);
 
-            long queryStartTime = auditLogManager.isLoggingEnabled() ? System.currentTimeMillis() : 0L;
-
-            Message.Response response = ClientState.getCQLQueryHandler().process(query, state, options, getCustomPayload(), queryStartNanoTime);
+            long queryStartTime = System.currentTimeMillis();
 
-            if (auditLogManager.isLoggingEnabled())
-                logSuccess(state, queryStartTime);
+            QueryHandler queryHandler = ClientState.getCQLQueryHandler();
+            statement = queryHandler.parse(query, state, options);
+            Message.Response response = queryHandler.process(statement, state, options, getCustomPayload(), queryStartNanoTime);
+            QueryEvents.instance.notifyQuerySuccess(statement, query, options, state, queryStartTime, response);
 
             if (options.skipMetadata() && response instanceof ResultMessage.Rows)
                 ((ResultMessage.Rows)response).result.metadata.setSkipMetadata();
@@ -117,8 +115,7 @@ public class QueryMessage extends Message.Request
         }
         catch (Exception e)
         {
-            if (auditLogManager.isLoggingEnabled())
-                logException(state, e);
+            QueryEvents.instance.notifyQueryFailure(statement, query, options, state, e);
             JVMStabilityInspector.inspectThrowable(e);
             if (!((e instanceof RequestValidationException) || (e instanceof RequestExecutionException)))
                 logger.error("Unexpected error during query", e);
@@ -140,32 +137,6 @@ public class QueryMessage extends Message.Request
         Tracing.instance.begin("Execute CQL3 query", state.getClientAddress(), builder.build());
     }
 
-    private void logSuccess(QueryState state, long queryStartTime)
-    {
-        // FIXME: we are parsing the statement twice if audit logging is enabled. Why?
-        CQLStatement statement = QueryProcessor.parseStatement(query, state.getClientState());
-        AuditLogEntry entry =
-            new AuditLogEntry.Builder(state)
-                             .setType(statement.getAuditLogContext().auditLogEntryType)
-                             .setOperation(query)
-                             .setTimestamp(queryStartTime)
-                             .setScope(statement)
-                             .setKeyspace(state, statement)
-                             .setOptions(options)
-                             .build();
-        AuditLogManager.getInstance().log(entry);
-    }
-
-    private void logException(QueryState state, Exception e)
-    {
-        AuditLogEntry entry =
-            new AuditLogEntry.Builder(state)
-                             .setOperation(query)
-                             .setOptions(options)
-                             .build();
-        AuditLogManager.getInstance().log(entry, e);
-    }
-
     @Override
     public String toString()
     {
diff --git a/src/java/org/apache/cassandra/utils/binlog/BinLog.java b/src/java/org/apache/cassandra/utils/binlog/BinLog.java
index 0fce6eec37..7f91761b2e 100644
--- a/src/java/org/apache/cassandra/utils/binlog/BinLog.java
+++ b/src/java/org/apache/cassandra/utils/binlog/BinLog.java
@@ -18,13 +18,20 @@
 
 package org.apache.cassandra.utils.binlog;
 
+import java.io.File;
 import java.nio.file.Path;
+import java.nio.file.Paths;
 import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashSet;
 import java.util.List;
+import java.util.Set;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicLong;
 
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Preconditions;
+import com.google.common.base.Strings;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -32,9 +39,14 @@ import net.openhft.chronicle.queue.ChronicleQueue;
 import net.openhft.chronicle.queue.ChronicleQueueBuilder;
 import net.openhft.chronicle.queue.ExcerptAppender;
 import net.openhft.chronicle.queue.RollCycle;
+import net.openhft.chronicle.queue.RollCycles;
 import net.openhft.chronicle.wire.WireOut;
 import net.openhft.chronicle.wire.WriteMarshallable;
 import org.apache.cassandra.concurrent.NamedThreadFactory;
+import org.apache.cassandra.io.FSError;
+import org.apache.cassandra.io.util.FileUtils;
+import org.apache.cassandra.utils.NoSpamLogger;
+import org.apache.cassandra.utils.Throwables;
 import org.apache.cassandra.utils.concurrent.WeightedQueue;
 
 /**
@@ -52,6 +64,10 @@ import org.apache.cassandra.utils.concurrent.WeightedQueue;
 public class BinLog implements Runnable
 {
     private static final Logger logger = LoggerFactory.getLogger(BinLog.class);
+    private static final NoSpamLogger noSpamLogger = NoSpamLogger.getLogger(logger, 1, TimeUnit.MINUTES);
+    private static final NoSpamLogger.NoSpamLogStatement droppedSamplesStatement = noSpamLogger.getStatement("Dropped {} binary log samples", 1, TimeUnit.MINUTES);
+
+    public final Path path;
 
     public static final String VERSION = "version";
     public static final String TYPE = "type";
@@ -62,6 +78,15 @@ public class BinLog implements Runnable
     Thread binLogThread = new NamedThreadFactory("Binary Log thread").newThread(this);
     final WeightedQueue<ReleaseableWriteMarshallable> sampleQueue;
     private final BinLogArchiver archiver;
+    private final boolean blocking;
+
+    private final AtomicLong droppedSamplesSinceLastLog = new AtomicLong();
+
+    /*
+    This set contains all the paths we are currently logging to, it is used to make sure
+    we don't start writing audit and full query logs to the same path.
+    */
+    private static final Set<Path> currentPaths = Collections.synchronizedSet(new HashSet<>());
 
     private static final ReleaseableWriteMarshallable NO_OP = new ReleaseableWriteMarshallable()
     {
@@ -95,7 +120,7 @@ public class BinLog implements Runnable
      * @param rollCycle      How often to roll the log file so it can potentially be deleted
      * @param maxQueueWeight Maximum weight of in memory queue for records waiting to be written to the file before blocking or dropping
      */
-    public BinLog(Path path, RollCycle rollCycle, int maxQueueWeight, BinLogArchiver archiver)
+    private BinLog(Path path, RollCycle rollCycle, int maxQueueWeight, BinLogArchiver archiver, boolean blocking)
     {
         Preconditions.checkNotNull(path, "path was null");
         Preconditions.checkNotNull(rollCycle, "rollCycle was null");
@@ -108,12 +133,15 @@ public class BinLog implements Runnable
         builder.storeFileListener(this.archiver);
         queue = builder.build();
         appender = queue.acquireAppender();
+        this.blocking = blocking;
+        this.path = path;
     }
 
     /**
      * Start the consumer thread that writes log records. Can only be done once.
      */
-    public void start()
+    @VisibleForTesting
+    void start()
     {
         if (!shouldContinue)
         {
@@ -139,6 +167,7 @@ public class BinLog implements Runnable
         appender = null;
         queue = null;
         archiver.stop();
+        currentPaths.remove(path);
     }
 
     /**
@@ -242,6 +271,59 @@ public class BinLog implements Runnable
         }
     }
 
+    // todo: refactor to helper class?
+    public void logRecord(ReleaseableWriteMarshallable record)
+    {
+        boolean putInQueue = false;
+        try
+        {
+            if (blocking)
+            {
+                try
+                {
+                    put(record);
+                    putInQueue = true;
+                }
+                catch (InterruptedException e)
+                {
+                    throw new RuntimeException(e);
+                }
+            }
+            else
+            {
+                if (!offer(record))
+                {
+                    logDroppedSample();
+                }
+                else
+                {
+                    putInQueue = true;
+                }
+            }
+        }
+        finally
+        {
+            if (!putInQueue)
+            {
+                record.release();
+            }
+        }
+    }
+
+    /**
+     * This is potentially lossy, but it's not super critical as we will always generally know
+     * when this is happening and roughly how bad it is.
+     */
+    private void logDroppedSample()
+    {
+        droppedSamplesSinceLastLog.incrementAndGet();
+        if (droppedSamplesStatement.warn(new Object[] {droppedSamplesSinceLastLog.get()}))
+        {
+            droppedSamplesSinceLastLog.set(0);
+        }
+    }
+
+
     public abstract static class ReleaseableWriteMarshallable implements WriteMarshallable
     {
         @Override
@@ -261,4 +343,137 @@ public class BinLog implements Runnable
 
         public abstract void release();
     }
+
+    public static class Builder
+    {
+        private Path path;
+        private String rollCycle;
+        private int maxQueueWeight;
+        private long maxLogSize;
+        private String archiveCommand;
+        private int maxArchiveRetries;
+        private boolean blocking;
+
+        public Builder path(Path path)
+        {
+            Preconditions.checkNotNull(path, "path was null");
+            File pathAsFile = path.toFile();
+            //Exists and is a directory or can be created
+            Preconditions.checkArgument((pathAsFile.exists() && pathAsFile.isDirectory()) || (!pathAsFile.exists() && pathAsFile.mkdirs()), "path exists and is not a directory or couldn't be created");
+            Preconditions.checkArgument(pathAsFile.canRead() && pathAsFile.canWrite() && pathAsFile.canExecute(), "path is not readable, writable, and executable");
+            this.path = path;
+            return this;
+        }
+
+        public Builder rollCycle(String rollCycle)
+        {
+            Preconditions.checkNotNull(rollCycle, "rollCycle was null");
+            rollCycle = rollCycle.toUpperCase();
+            Preconditions.checkNotNull(RollCycles.valueOf(rollCycle), "unrecognized roll cycle");
+            this.rollCycle = rollCycle;
+            return this;
+        }
+
+        public Builder maxQueueWeight(int maxQueueWeight)
+        {
+            Preconditions.checkArgument(maxQueueWeight > 0, "maxQueueWeight must be > 0");
+            this.maxQueueWeight = maxQueueWeight;
+            return this;
+        }
+
+        public Builder maxLogSize(long maxLogSize)
+        {
+            Preconditions.checkArgument(maxLogSize > 0, "maxLogSize must be > 0");
+            this.maxLogSize = maxLogSize;
+            return this;
+        }
+
+        public Builder archiveCommand(String archiveCommand)
+        {
+            this.archiveCommand = archiveCommand;
+            return this;
+        }
+
+        public Builder maxArchiveRetries(int maxArchiveRetries)
+        {
+            this.maxArchiveRetries = maxArchiveRetries;
+            return this;
+        }
+
+        public Builder blocking(boolean blocking)
+        {
+            this.blocking = blocking;
+            return this;
+        }
+
+
+        public BinLog build(boolean cleanDirectory)
+        {
+            logger.info("Attempting to configure bin log: Path: {} Roll cycle: {} Blocking: {} Max queue weight: {} Max log size:{} Archive command: {}", path, rollCycle, blocking, maxQueueWeight, maxLogSize, archiveCommand);
+            synchronized (currentPaths)
+            {
+                if (currentPaths.contains(path))
+                    throw new IllegalStateException("Already logging to " + path);
+                currentPaths.add(path);
+            }
+            try
+            {
+                // create the archiver before cleaning directories - ExternalArchiver will try to archive any existing file.
+                BinLogArchiver archiver = Strings.isNullOrEmpty(archiveCommand) ? new DeletingArchiver(maxLogSize) : new ExternalArchiver(archiveCommand, path, maxArchiveRetries);
+                if (cleanDirectory)
+                {
+                    logger.info("Cleaning directory: {} as requested", path);
+                    if (path.toFile().exists())
+                    {
+                        Throwable error = cleanDirectory(path.toFile(), null);
+                        if (error != null)
+                        {
+                            throw new RuntimeException(error);
+                        }
+                    }
+                }
+                BinLog binlog = new BinLog(path, RollCycles.valueOf(rollCycle), maxQueueWeight, archiver, blocking);
+                binlog.start();
+                return binlog;
+            }
+            catch (Exception e)
+            {
+                currentPaths.remove(path);
+                throw e;
+            }
+        }
+    }
+
+    public static Throwable cleanDirectory(File directory, Throwable accumulate)
+    {
+        if (!directory.exists())
+        {
+            return Throwables.merge(accumulate, new RuntimeException(String.format("%s does not exists", directory)));
+        }
+        if (!directory.isDirectory())
+        {
+            return Throwables.merge(accumulate, new RuntimeException(String.format("%s is not a directory", directory)));
+        }
+        for (File f : directory.listFiles())
+        {
+            accumulate = deleteRecursively(f, accumulate);
+        }
+        if (accumulate instanceof FSError)
+        {
+            FileUtils.handleFSError((FSError)accumulate);
+        }
+        return accumulate;
+    }
+
+    private static Throwable deleteRecursively(File fileOrDirectory, Throwable accumulate)
+    {
+        if (fileOrDirectory.isDirectory())
+        {
+            for (File f : fileOrDirectory.listFiles())
+            {
+                accumulate = FileUtils.deleteWithConfirm(f, accumulate);
+            }
+        }
+        return FileUtils.deleteWithConfirm(fileOrDirectory, accumulate);
+    }
 }
diff --git a/test/unit/org/apache/cassandra/audit/AuditLoggerAuthTest.java b/test/unit/org/apache/cassandra/audit/AuditLoggerAuthTest.java
index 1105770842..66d8295503 100644
--- a/test/unit/org/apache/cassandra/audit/AuditLoggerAuthTest.java
+++ b/test/unit/org/apache/cassandra/audit/AuditLoggerAuthTest.java
@@ -251,7 +251,7 @@ public class AuditLoggerAuthTest
 
     private static Queue<AuditLogEntry> getInMemAuditLogger()
     {
-        return ((InMemoryAuditLogger) AuditLogManager.getInstance().getLogger()).inMemQueue;
+        return ((InMemoryAuditLogger) AuditLogManager.instance.getLogger()).inMemQueue;
     }
 
     private static void assertLogEntry(AuditLogEntry logEntry, AuditLogEntryType type, String cql, String username)
diff --git a/test/unit/org/apache/cassandra/audit/AuditLoggerTest.java b/test/unit/org/apache/cassandra/audit/AuditLoggerTest.java
index a44554729e..e3b93ecaaf 100644
--- a/test/unit/org/apache/cassandra/audit/AuditLoggerTest.java
+++ b/test/unit/org/apache/cassandra/audit/AuditLoggerTest.java
@@ -18,6 +18,10 @@
 package org.apache.cassandra.audit;
 
 import org.junit.After;
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+
 import org.junit.Assert;
 import org.junit.Before;
 import org.junit.BeforeClass;
@@ -29,8 +33,12 @@ import com.datastax.driver.core.ResultSet;
 import com.datastax.driver.core.Session;
 import com.datastax.driver.core.exceptions.NoHostAvailableException;
 import com.datastax.driver.core.exceptions.SyntaxError;
+import net.openhft.chronicle.queue.RollCycles;
+import org.apache.cassandra.auth.AuthEvents;
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.cql3.CQLTester;
+import org.apache.cassandra.cql3.QueryEvents;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.service.StorageService;
 
 import static org.hamcrest.CoreMatchers.containsString;
@@ -40,6 +48,7 @@ import static org.junit.Assert.assertNotEquals;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertThat;
 import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 /**
  * AuditLoggerTest is responsible for covering the test cases for Audit Logging CASSANDRA-12151 functionality.
@@ -142,8 +151,11 @@ public class AuditLoggerTest extends CQLTester
         String cql = "SELECT id, v1, v2 FROM " + KEYSPACE + '.' + currentTable() + " WHERE id = ?";
         ResultSet rs = executeAndAssertNoAuditLog(cql, 1);
         assertEquals(1, rs.all().size());
-
+        assertEquals(1, QueryEvents.instance.listenerCount());
+        assertEquals(1, AuthEvents.instance.listenerCount());
         disableAuditLogOptions();
+        assertEquals(0, QueryEvents.instance.listenerCount());
+        assertEquals(0, AuthEvents.instance.listenerCount());
 
         cql = "SELECT id, v1, v2 FROM " + KEYSPACE + '.' + currentTable() + " WHERE id = ?";
         rs = executeAndAssertDisableAuditLog(cql, 1);
@@ -171,7 +183,7 @@ public class AuditLoggerTest extends CQLTester
         AuditLogOptions options = new AuditLogOptions();
         options.excluded_keyspaces += ',' + KEYSPACE;
         enableAuditLogOptions(options);
-        Assert.assertTrue(AuditLogManager.getInstance().isAuditingEnabled());
+        Assert.assertTrue(AuditLogManager.instance.isEnabled());
     }
 
     @Test
@@ -192,7 +204,7 @@ public class AuditLoggerTest extends CQLTester
         Session session = sessionNet();
         ResultSet rs = session.execute(cql);
 
-        assertEquals(0, ((InMemoryAuditLogger) AuditLogManager.getInstance().getLogger()).inMemQueue.size());
+        assertEquals(0, ((InMemoryAuditLogger) AuditLogManager.instance.getLogger()).inMemQueue.size());
         assertEquals(1, rs.all().size());
 
         //DML - Should not be filtered, part of included categories
@@ -203,7 +215,7 @@ public class AuditLoggerTest extends CQLTester
         cql = "ALTER TABLE  " + KEYSPACE + '.' + currentTable() + " ADD v3 text";
         session = sessionNet();
         rs = session.execute(cql);
-        assertEquals(0, ((InMemoryAuditLogger) AuditLogManager.getInstance().getLogger()).inMemQueue.size());
+        assertEquals(0, ((InMemoryAuditLogger) AuditLogManager.instance.getLogger()).inMemQueue.size());
     }
 
     @Test
@@ -275,7 +287,7 @@ public class AuditLoggerTest extends CQLTester
 
         String cqlInsert = "INSERT INTO " + KEYSPACE + "." + currentTable() + " (id, v1, v2) VALUES (?, ?, ?)";
         PreparedStatement prep = session.prepare(cqlInsert);
-        AuditLogEntry logEntry = ((InMemoryAuditLogger) AuditLogManager.getInstance().getLogger()).inMemQueue.poll();
+        AuditLogEntry logEntry = ((InMemoryAuditLogger) AuditLogManager.instance.getLogger()).inMemQueue.poll();
         assertLogEntry(cqlInsert, AuditLogEntryType.PREPARE_STATEMENT, logEntry, false);
 
         batchStatement.add(prep.bind(1, "Apapche", "Cassandra"));
@@ -283,37 +295,37 @@ public class AuditLoggerTest extends CQLTester
 
         String cqlUpdate = "UPDATE " + KEYSPACE + "." + currentTable() + " SET v1 = ? WHERE id = ?";
         prep = session.prepare(cqlUpdate);
-        logEntry = ((InMemoryAuditLogger) AuditLogManager.getInstance().getLogger()).inMemQueue.poll();
+        logEntry = ((InMemoryAuditLogger) AuditLogManager.instance.getLogger()).inMemQueue.poll();
         assertLogEntry(cqlUpdate, AuditLogEntryType.PREPARE_STATEMENT, logEntry, false);
 
         batchStatement.add(prep.bind("Apache Cassandra", 1));
 
         String cqlDelete = "DELETE FROM " + KEYSPACE + "." + currentTable() + " WHERE id = ?";
         prep = session.prepare(cqlDelete);
-        logEntry = ((InMemoryAuditLogger) AuditLogManager.getInstance().getLogger()).inMemQueue.poll();
+        logEntry = ((InMemoryAuditLogger) AuditLogManager.instance.getLogger()).inMemQueue.poll();
         assertLogEntry(cqlDelete, AuditLogEntryType.PREPARE_STATEMENT, logEntry, false);
 
         batchStatement.add(prep.bind(1));
 
         ResultSet rs = session.execute(batchStatement);
 
-        assertEquals(5, ((InMemoryAuditLogger) AuditLogManager.getInstance().getLogger()).inMemQueue.size());
-        logEntry = ((InMemoryAuditLogger) AuditLogManager.getInstance().getLogger()).inMemQueue.poll();
+        assertEquals(5, ((InMemoryAuditLogger) AuditLogManager.instance.getLogger()).inMemQueue.size());
+        logEntry = ((InMemoryAuditLogger) AuditLogManager.instance.getLogger()).inMemQueue.poll();
 
         assertEquals(AuditLogEntryType.BATCH, logEntry.getType());
         assertTrue(logEntry.getOperation().contains("BatchId"));
         assertNotEquals(0, logEntry.getTimestamp());
 
-        logEntry = ((InMemoryAuditLogger) AuditLogManager.getInstance().getLogger()).inMemQueue.poll();
+        logEntry = ((InMemoryAuditLogger) AuditLogManager.instance.getLogger()).inMemQueue.poll();
         assertLogEntry(cqlInsert, AuditLogEntryType.UPDATE, logEntry, false);
 
-        logEntry = ((InMemoryAuditLogger) AuditLogManager.getInstance().getLogger()).inMemQueue.poll();
+        logEntry = ((InMemoryAuditLogger) AuditLogManager.instance.getLogger()).inMemQueue.poll();
         assertLogEntry(cqlInsert, AuditLogEntryType.UPDATE, logEntry, false);
 
-        logEntry = ((InMemoryAuditLogger) AuditLogManager.getInstance().getLogger()).inMemQueue.poll();
+        logEntry = ((InMemoryAuditLogger) AuditLogManager.instance.getLogger()).inMemQueue.poll();
         assertLogEntry(cqlUpdate, AuditLogEntryType.UPDATE, logEntry, false);
 
-        logEntry = ((InMemoryAuditLogger) AuditLogManager.getInstance().getLogger()).inMemQueue.poll();
+        logEntry = ((InMemoryAuditLogger) AuditLogManager.instance.getLogger()).inMemQueue.poll();
         assertLogEntry(cqlDelete, AuditLogEntryType.DELETE, logEntry, false);
 
         int size = rs.all().size();
@@ -333,7 +345,7 @@ public class AuditLoggerTest extends CQLTester
 
         String cqlInsert1 = "INSERT INTO " + KEYSPACE + "." + table1 + " (id, v1, v2) VALUES (?, ?, ?)";
         PreparedStatement prep = session.prepare(cqlInsert1);
-        AuditLogEntry logEntry = ((InMemoryAuditLogger) AuditLogManager.getInstance().getLogger()).inMemQueue.poll();
+        AuditLogEntry logEntry = ((InMemoryAuditLogger) AuditLogManager.instance.getLogger()).inMemQueue.poll();
         assertLogEntry(cqlInsert1, AuditLogEntryType.PREPARE_STATEMENT, logEntry, false);
 
         batchStatement.add(prep.bind(1, "Apapche", "Cassandra"));
@@ -343,7 +355,7 @@ public class AuditLoggerTest extends CQLTester
 
         String cqlInsert2 = "INSERT INTO " + KEYSPACE + "." + table2 + " (id, v1, v2) VALUES (?, ?, ?)";
         prep = session.prepare(cqlInsert2);
-        logEntry = ((InMemoryAuditLogger) AuditLogManager.getInstance().getLogger()).inMemQueue.poll();
+        logEntry = ((InMemoryAuditLogger) AuditLogManager.instance.getLogger()).inMemQueue.poll();
         assertLogEntry(cqlInsert2, AuditLogEntryType.PREPARE_STATEMENT, logEntry, false);
 
         batchStatement.add(prep.bind(1, "Apapche", "Cassandra"));
@@ -356,23 +368,23 @@ public class AuditLoggerTest extends CQLTester
 
         String cqlInsert3 = "INSERT INTO " + ks2 + "." + table3 + " (id, v1, v2) VALUES (?, ?, ?)";
         prep = session.prepare(cqlInsert3);
-        logEntry = ((InMemoryAuditLogger) AuditLogManager.getInstance().getLogger()).inMemQueue.poll();
+        logEntry = ((InMemoryAuditLogger) AuditLogManager.instance.getLogger()).inMemQueue.poll();
         assertLogEntry(cqlInsert3, AuditLogEntryType.PREPARE_STATEMENT, logEntry, false, ks2);
 
         batchStatement.add(prep.bind(1, "Apapche", "Cassandra"));
 
         ResultSet rs = session.execute(batchStatement);
 
-        assertEquals(4, ((InMemoryAuditLogger) AuditLogManager.getInstance().getLogger()).inMemQueue.size());
-        logEntry = ((InMemoryAuditLogger) AuditLogManager.getInstance().getLogger()).inMemQueue.poll();
+        assertEquals(4, ((InMemoryAuditLogger) AuditLogManager.instance.getLogger()).inMemQueue.size());
+        logEntry = ((InMemoryAuditLogger) AuditLogManager.instance.getLogger()).inMemQueue.poll();
 
-        logEntry = ((InMemoryAuditLogger) AuditLogManager.getInstance().getLogger()).inMemQueue.poll();
+        logEntry = ((InMemoryAuditLogger) AuditLogManager.instance.getLogger()).inMemQueue.poll();
         assertLogEntry(cqlInsert1, table1, AuditLogEntryType.UPDATE, logEntry, false, KEYSPACE);
 
-        logEntry = ((InMemoryAuditLogger) AuditLogManager.getInstance().getLogger()).inMemQueue.poll();
+        logEntry = ((InMemoryAuditLogger) AuditLogManager.instance.getLogger()).inMemQueue.poll();
         assertLogEntry(cqlInsert2, table2, AuditLogEntryType.UPDATE, logEntry, false, KEYSPACE);
 
-        logEntry = ((InMemoryAuditLogger) AuditLogManager.getInstance().getLogger()).inMemQueue.poll();
+        logEntry = ((InMemoryAuditLogger) AuditLogManager.instance.getLogger()).inMemQueue.poll();
         assertLogEntry(cqlInsert3, table3, AuditLogEntryType.UPDATE, logEntry, false, ks2);
 
         int size = rs.all().size();
@@ -525,9 +537,9 @@ public class AuditLoggerTest extends CQLTester
             // nop
         }
 
-        AuditLogEntry logEntry = ((InMemoryAuditLogger) AuditLogManager.getInstance().getLogger()).inMemQueue.poll();
+        AuditLogEntry logEntry = ((InMemoryAuditLogger) AuditLogManager.instance.getLogger()).inMemQueue.poll();
         assertLogEntry(logEntry, cql);
-        assertEquals(0, ((InMemoryAuditLogger) AuditLogManager.getInstance().getLogger()).inMemQueue.size());
+        assertEquals(0, ((InMemoryAuditLogger) AuditLogManager.instance.getLogger()).inMemQueue.size());
     }
 
     @Test
@@ -547,9 +559,9 @@ public class AuditLoggerTest extends CQLTester
             // nop
         }
 
-        AuditLogEntry logEntry = ((InMemoryAuditLogger) AuditLogManager.getInstance().getLogger()).inMemQueue.poll();
+        AuditLogEntry logEntry = ((InMemoryAuditLogger) AuditLogManager.instance.getLogger()).inMemQueue.poll();
         assertLogEntry(logEntry, cql);
-        assertEquals(0, ((InMemoryAuditLogger) AuditLogManager.getInstance().getLogger()).inMemQueue.size());
+        assertEquals(0, ((InMemoryAuditLogger) AuditLogManager.instance.getLogger()).inMemQueue.size());
     }
 
     @Test
@@ -562,7 +574,7 @@ public class AuditLoggerTest extends CQLTester
             Session session = sessionNet();
 
             PreparedStatement pstmt = session.prepare(cql);
-            AuditLogEntry logEntry = ((InMemoryAuditLogger) AuditLogManager.getInstance().getLogger()).inMemQueue.poll();
+            AuditLogEntry logEntry = ((InMemoryAuditLogger) AuditLogManager.instance.getLogger()).inMemQueue.poll();
             assertLogEntry(cql, AuditLogEntryType.PREPARE_STATEMENT, logEntry, false);
 
             dropTable("DROP TABLE %s");
@@ -574,11 +586,11 @@ public class AuditLoggerTest extends CQLTester
             // nop
         }
 
-        AuditLogEntry logEntry = ((InMemoryAuditLogger) AuditLogManager.getInstance().getLogger()).inMemQueue.poll();
+        AuditLogEntry logEntry = ((InMemoryAuditLogger) AuditLogManager.instance.getLogger()).inMemQueue.poll();
         assertLogEntry(logEntry, null);
-        logEntry = ((InMemoryAuditLogger) AuditLogManager.getInstance().getLogger()).inMemQueue.poll();
+        logEntry = ((InMemoryAuditLogger) AuditLogManager.instance.getLogger()).inMemQueue.poll();
         assertLogEntry(logEntry, cql);
-        assertEquals(0, ((InMemoryAuditLogger) AuditLogManager.getInstance().getLogger()).inMemQueue.size());
+        assertEquals(0, ((InMemoryAuditLogger) AuditLogManager.instance.getLogger()).inMemQueue.size());
     }
 
     @Test
@@ -597,9 +609,9 @@ public class AuditLoggerTest extends CQLTester
         {
             // nop
         }
-        AuditLogEntry logEntry = ((InMemoryAuditLogger) AuditLogManager.getInstance().getLogger()).inMemQueue.poll();
+        AuditLogEntry logEntry = ((InMemoryAuditLogger) AuditLogManager.instance.getLogger()).inMemQueue.poll();
         assertLogEntry(logEntry, cql);
-        assertEquals(0, ((InMemoryAuditLogger) AuditLogManager.getInstance().getLogger()).inMemQueue.size());
+        assertEquals(0, ((InMemoryAuditLogger) AuditLogManager.instance.getLogger()).inMemQueue.size());
     }
 
     @Test
@@ -614,10 +626,10 @@ public class AuditLoggerTest extends CQLTester
         String cql = "SELECT * FROM system.local limit 2";
         ResultSet rs = session.execute(cql);
 
-        assertEquals (1,((InMemoryAuditLogger) AuditLogManager.getInstance().getLogger()).inMemQueue.size());
-        AuditLogEntry logEntry = ((InMemoryAuditLogger) AuditLogManager.getInstance().getLogger()).inMemQueue.poll();
+        assertEquals (1,((InMemoryAuditLogger) AuditLogManager.instance.getLogger()).inMemQueue.size());
+        AuditLogEntry logEntry = ((InMemoryAuditLogger) AuditLogManager.instance.getLogger()).inMemQueue.poll();
         assertLogEntry(cql, "local",AuditLogEntryType.SELECT,logEntry,false, "system");
-        assertEquals (0,((InMemoryAuditLogger) AuditLogManager.getInstance().getLogger()).inMemQueue.size());
+        assertEquals (0,((InMemoryAuditLogger) AuditLogManager.instance.getLogger()).inMemQueue.size());
     }
 
     @Test
@@ -632,7 +644,75 @@ public class AuditLoggerTest extends CQLTester
         String cql = "SELECT * FROM system.local limit 2";
         ResultSet rs = session.execute(cql);
 
-        assertEquals (0,((InMemoryAuditLogger) AuditLogManager.getInstance().getLogger()).inMemQueue.size());
+        assertEquals (0,((InMemoryAuditLogger) AuditLogManager.instance.getLogger()).inMemQueue.size());
+    }
+
+    @Test
+    public void testEnableDisable() throws IOException
+    {
+        disableAuditLogOptions();
+        assertEquals(0, QueryEvents.instance.listenerCount());
+        assertEquals(0, AuthEvents.instance.listenerCount());
+        enableAuditLogOptions(new AuditLogOptions());
+        assertEquals(1, QueryEvents.instance.listenerCount());
+        assertEquals(1, AuthEvents.instance.listenerCount());
+
+        Path p = Files.createTempDirectory("fql");
+        StorageService.instance.enableFullQueryLogger(p.toString(), RollCycles.HOURLY.toString(), false, 1000, 1000, null, 0);
+        assertEquals(2, QueryEvents.instance.listenerCount());
+        assertEquals(1, AuthEvents.instance.listenerCount()); // fql not listening to auth events
+        StorageService.instance.resetFullQueryLogger();
+        assertEquals(1, QueryEvents.instance.listenerCount());
+        assertEquals(1, AuthEvents.instance.listenerCount());
+        disableAuditLogOptions();
+
+        assertEquals(0, QueryEvents.instance.listenerCount());
+        assertEquals(0, AuthEvents.instance.listenerCount());
+    }
+
+    @Test
+    public void testConflictingPaths()
+    {
+        disableAuditLogOptions();
+        AuditLogOptions options = new AuditLogOptions();
+        DatabaseDescriptor.setAuditLoggingOptions(options);
+        StorageService.instance.enableAuditLog(null, options.included_keyspaces, options.excluded_keyspaces, options.included_categories, options.excluded_categories, options.included_users, options.excluded_users);
+        try
+        {
+            assertEquals(1, QueryEvents.instance.listenerCount());
+            assertEquals(1, AuthEvents.instance.listenerCount());
+            StorageService.instance.enableFullQueryLogger(options.audit_logs_dir, RollCycles.HOURLY.toString(), false, 1000, 1000, null, 0);
+            fail("Conflicting directories - should throw exception");
+        }
+        catch (IllegalStateException e)
+        {
+            // ok
+        }
+        assertEquals(1, QueryEvents.instance.listenerCount());
+        assertEquals(1, AuthEvents.instance.listenerCount());
+    }
+
+
+    @Test
+    public void testConflictingPathsFQLFirst()
+    {
+        disableAuditLogOptions();
+        AuditLogOptions options = new AuditLogOptions();
+        DatabaseDescriptor.setAuditLoggingOptions(options);
+        StorageService.instance.enableFullQueryLogger(options.audit_logs_dir, RollCycles.HOURLY.toString(), false, 1000, 1000, null, 0);
+        try
+        {
+            assertEquals(1, QueryEvents.instance.listenerCount());
+            assertEquals(0, AuthEvents.instance.listenerCount());
+            StorageService.instance.enableAuditLog(null, options.included_keyspaces, options.excluded_keyspaces, options.included_categories, options.excluded_categories, options.included_users, options.excluded_users);
+            fail("Conflicting directories - should throw exception");
+        }
+        catch (ConfigurationException e)
+        {
+            // ok
+        }
+        assertEquals(1, QueryEvents.instance.listenerCount());
+        assertEquals(0, AuthEvents.instance.listenerCount());
     }
 
     /**
@@ -650,10 +730,10 @@ public class AuditLoggerTest extends CQLTester
 
         ResultSet rs = session.execute(cql);
 
-        AuditLogEntry logEntry1 = ((InMemoryAuditLogger) AuditLogManager.getInstance().getLogger()).inMemQueue.poll();
+        AuditLogEntry logEntry1 = ((InMemoryAuditLogger) AuditLogManager.instance.getLogger()).inMemQueue.poll();
         assertLogEntry(cql, type, logEntry1, isTableNull, keyspace);
 
-        assertEquals(0, ((InMemoryAuditLogger) AuditLogManager.getInstance().getLogger()).inMemQueue.size());
+        assertEquals(0, ((InMemoryAuditLogger) AuditLogManager.instance.getLogger()).inMemQueue.size());
         return rs;
     }
 
@@ -669,13 +749,13 @@ public class AuditLoggerTest extends CQLTester
         PreparedStatement pstmt = session.prepare(cql);
         ResultSet rs = session.execute(pstmt.bind(bindValues));
 
-        AuditLogEntry logEntry1 = ((InMemoryAuditLogger) AuditLogManager.getInstance().getLogger()).inMemQueue.poll();
+        AuditLogEntry logEntry1 = ((InMemoryAuditLogger) AuditLogManager.instance.getLogger()).inMemQueue.poll();
         assertLogEntry(cql, AuditLogEntryType.PREPARE_STATEMENT, logEntry1, isTableNull);
 
-        AuditLogEntry logEntry2 = ((InMemoryAuditLogger) AuditLogManager.getInstance().getLogger()).inMemQueue.poll();
+        AuditLogEntry logEntry2 = ((InMemoryAuditLogger) AuditLogManager.instance.getLogger()).inMemQueue.poll();
         assertLogEntry(cql, executeType, logEntry2, isTableNull);
 
-        assertEquals(0, ((InMemoryAuditLogger) AuditLogManager.getInstance().getLogger()).inMemQueue.size());
+        assertEquals(0, ((InMemoryAuditLogger) AuditLogManager.instance.getLogger()).inMemQueue.size());
         return rs;
     }
 
@@ -686,7 +766,7 @@ public class AuditLoggerTest extends CQLTester
         PreparedStatement pstmt = session.prepare(cql);
         ResultSet rs = session.execute(pstmt.bind(bindValues));
 
-        assertEquals(0, ((InMemoryAuditLogger) AuditLogManager.getInstance().getLogger()).inMemQueue.size());
+        assertEquals(0, ((InMemoryAuditLogger) AuditLogManager.instance.getLogger()).inMemQueue.size());
         return rs;
     }
 
@@ -697,7 +777,7 @@ public class AuditLoggerTest extends CQLTester
         PreparedStatement pstmt = session.prepare(cql);
         ResultSet rs = session.execute(pstmt.bind(bindValues));
 
-        assertThat(AuditLogManager.getInstance().getLogger(),instanceOf(NoOpAuditLogger.class));
+        assertThat(AuditLogManager.instance.getLogger(),instanceOf(NoOpAuditLogger.class));
         return rs;
     }
 
diff --git a/test/unit/org/apache/cassandra/audit/BinAuditLoggerTest.java b/test/unit/org/apache/cassandra/audit/BinAuditLoggerTest.java
index 90c93250e4..e93ac150a2 100644
--- a/test/unit/org/apache/cassandra/audit/BinAuditLoggerTest.java
+++ b/test/unit/org/apache/cassandra/audit/BinAuditLoggerTest.java
@@ -33,7 +33,7 @@ import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.cql3.CQLTester;
 import org.apache.cassandra.utils.binlog.BinLogTest;
 
-import static org.hamcrest.CoreMatchers.containsString;
+import static org.hamcrest.core.StringContains.containsString;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertThat;
@@ -54,6 +54,7 @@ public class BinAuditLoggerTest extends CQLTester
         options.roll_cycle = "TEST_SECONDLY";
         options.audit_logs_dir = tempDir.toString();
         DatabaseDescriptor.setAuditLoggingOptions(options);
+        AuditLogManager.instance.enable(DatabaseDescriptor.getAuditLoggingOptions());
         requireNetwork();
     }
 
diff --git a/test/unit/org/apache/cassandra/audit/InMemoryAuditLogger.java b/test/unit/org/apache/cassandra/audit/InMemoryAuditLogger.java
index 7052d76d1f..c9e4990526 100644
--- a/test/unit/org/apache/cassandra/audit/InMemoryAuditLogger.java
+++ b/test/unit/org/apache/cassandra/audit/InMemoryAuditLogger.java
@@ -27,7 +27,7 @@ public class InMemoryAuditLogger implements IAuditLogger
     private boolean enabled = true;
 
     @Override
-    public boolean enabled()
+    public boolean isEnabled()
     {
         return enabled;
     }
diff --git a/test/unit/org/apache/cassandra/config/DatabaseDescriptorRefTest.java b/test/unit/org/apache/cassandra/config/DatabaseDescriptorRefTest.java
index e7870823e7..e19ec5337a 100644
--- a/test/unit/org/apache/cassandra/config/DatabaseDescriptorRefTest.java
+++ b/test/unit/org/apache/cassandra/config/DatabaseDescriptorRefTest.java
@@ -54,6 +54,10 @@ import static org.junit.Assert.fail;
 public class DatabaseDescriptorRefTest
 {
     static final String[] validClasses = {
+    "org.apache.cassandra.audit.AuditLogOptions",
+    "org.apache.cassandra.audit.BinAuditLogger",
+    "org.apache.cassandra.audit.BinLogAuditLogger",
+    "org.apache.cassandra.audit.IAuditLogger",
     "org.apache.cassandra.auth.AllowAllInternodeAuthenticator",
     "org.apache.cassandra.auth.IInternodeAuthenticator",
     "org.apache.cassandra.auth.IAuthenticator",
@@ -116,6 +120,8 @@ public class DatabaseDescriptorRefTest
     "org.apache.cassandra.exceptions.RequestValidationException",
     "org.apache.cassandra.exceptions.CassandraException",
     "org.apache.cassandra.exceptions.TransportException",
+    "org.apache.cassandra.fql.FullQueryLogger",
+    "org.apache.cassandra.fql.FullQueryLoggerOptions",
     "org.apache.cassandra.locator.IEndpointSnitch",
     "org.apache.cassandra.io.FSWriteError",
     "org.apache.cassandra.io.FSError",
@@ -135,6 +141,7 @@ public class DatabaseDescriptorRefTest
     "org.apache.cassandra.net.BackPressureStrategy",
     "org.apache.cassandra.security.EncryptionContext",
     "org.apache.cassandra.service.CacheService$CacheType",
+    "org.apache.cassandra.utils.binlog.BinLogOptions",
     "org.apache.cassandra.utils.FBUtilities",
     "org.apache.cassandra.utils.FBUtilities$1",
     "org.apache.cassandra.utils.CloseableIterator",
@@ -146,13 +153,6 @@ public class DatabaseDescriptorRefTest
     "org.apache.cassandra.LogbackStatusListener$ToLoggerOutputStream",
     "org.apache.cassandra.LogbackStatusListener$WrappedPrintStream",
     "org.apache.cassandra.TeeingAppender",
-    "org.apache.cassandra.audit.IAuditLogger",
-    "org.apache.cassandra.audit.BinAuditLogger",
-    "org.apache.cassandra.audit.BinLogAuditLogger",
-    "org.apache.cassandra.audit.FullQueryLogger",
-    "org.apache.cassandra.audit.AuditLogOptions",
-    "org.apache.cassandra.utils.binlog.BinLogOptions",
-    "org.apache.cassandra.audit.FullQueryLoggerOptions",
     // generated classes
     "org.apache.cassandra.config.ConfigBeanInfo",
     "org.apache.cassandra.config.ConfigCustomizer",
diff --git a/test/unit/org/apache/cassandra/cql3/CQLTester.java b/test/unit/org/apache/cassandra/cql3/CQLTester.java
index 2381c52825..d58092330a 100644
--- a/test/unit/org/apache/cassandra/cql3/CQLTester.java
+++ b/test/unit/org/apache/cassandra/cql3/CQLTester.java
@@ -46,6 +46,7 @@ import com.datastax.driver.core.DataType;
 import com.datastax.driver.core.ResultSet;
 
 import org.apache.cassandra.SchemaLoader;
+import org.apache.cassandra.audit.AuditLogManager;
 import org.apache.cassandra.concurrent.ScheduledExecutors;
 import org.apache.cassandra.db.virtual.VirtualKeyspaceRegistry;
 import org.apache.cassandra.db.virtual.VirtualSchemaKeyspace;
@@ -236,6 +237,7 @@ public abstract class CQLTester
 
         Keyspace.setInitialized();
         SystemKeyspace.persistLocalMetadata();
+        AuditLogManager.instance.initialize();
         isServerPrepared = true;
     }
 
diff --git a/test/unit/org/apache/cassandra/cql3/CustomNowInSecondsTest.java b/test/unit/org/apache/cassandra/cql3/CustomNowInSecondsTest.java
index 8bb0bf4aeb..f013fc0dea 100644
--- a/test/unit/org/apache/cassandra/cql3/CustomNowInSecondsTest.java
+++ b/test/unit/org/apache/cassandra/cql3/CustomNowInSecondsTest.java
@@ -186,7 +186,8 @@ public class CustomNowInSecondsTest extends CQLTester
         }
         else
         {
-            return QueryProcessor.instance.process(query, qs, queryOptions(nowInSeconds), Collections.emptyMap(), System.nanoTime());
+            CQLStatement statement = QueryProcessor.instance.parse(query, qs, queryOptions(nowInSeconds));
+            return QueryProcessor.instance.process(statement, qs, queryOptions(nowInSeconds), Collections.emptyMap(), System.nanoTime());
         }
     }
 
diff --git a/test/unit/org/apache/cassandra/cql3/QueryEventsTest.java b/test/unit/org/apache/cassandra/cql3/QueryEventsTest.java
new file mode 100644
index 0000000000..dd1cb45760
--- /dev/null
+++ b/test/unit/org/apache/cassandra/cql3/QueryEventsTest.java
@@ -0,0 +1,352 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.cassandra.cql3;
+
+import java.nio.ByteBuffer;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import javax.annotation.Nullable;
+
+import org.junit.Test;
+
+import com.datastax.driver.core.PreparedStatement;
+import com.datastax.driver.core.ResultSet;
+import com.datastax.driver.core.Session;
+import com.datastax.driver.core.SimpleStatement;
+import com.datastax.driver.core.Statement;
+import org.apache.cassandra.cql3.statements.BatchStatement;
+import org.apache.cassandra.cql3.statements.ModificationStatement;
+import org.apache.cassandra.cql3.statements.SelectStatement;
+import org.apache.cassandra.db.ColumnFamilyStore;
+import org.apache.cassandra.service.QueryState;
+import org.apache.cassandra.transport.Message;
+import org.apache.cassandra.transport.messages.ResultMessage;
+import org.apache.cassandra.utils.ByteBufferUtil;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+import static com.google.common.collect.Lists.newArrayList;
+
+public class QueryEventsTest extends CQLTester
+{
+    @Test
+    public void queryTest() throws Throwable
+    {
+        createTable("create table %s (id int primary key, v int)");
+        MockListener listener = new MockListener(getCurrentColumnFamilyStore());
+        QueryEvents.instance.registerListener(listener);
+        String query = formatQuery("insert into %s (id, v) values (1, 1)");
+        executeNet(query);
+        listener.verify("querySuccess", 1);
+        assertEquals(query, listener.query);
+        assertTrue(listener.statement instanceof ModificationStatement);
+
+        query = formatQuery("select * from %s where id=1");
+        executeNet(query);
+        listener.verify("querySuccess", 2);
+        assertEquals(query, listener.query);
+        assertTrue(listener.statement instanceof SelectStatement);
+
+        query = formatQuery("select xyz from %s where id=1");
+        Exception expectedException = null;
+        try
+        {
+            executeNet(query);
+            fail("Query should fail");
+        }
+        catch (Exception e)
+        {
+            expectedException = e;
+        }
+        listener.verify(newArrayList("querySuccess", "queryFailure"), newArrayList(2, 1));
+        assertEquals(query, listener.query);
+        assertNotNull(listener.e);
+        assertNotNull(expectedException);
+    }
+
+    @Test
+    public void prepareExecuteTest()
+    {
+        createTable("create table %s (id int primary key, v int)");
+        MockListener listener = new MockListener(getCurrentColumnFamilyStore());
+        QueryEvents.instance.registerListener(listener);
+        Session session = sessionNet();
+        String query = formatQuery("select * from %s where id = 1");
+        PreparedStatement ps = session.prepare(query);
+        listener.verify("prepareSuccess", 1);
+        assertEquals(query, listener.query);
+        assertTrue(listener.statement instanceof SelectStatement);
+        Statement s = ps.bind();
+        session.execute(s);
+        listener.verify(newArrayList("prepareSuccess", "executeSuccess"), newArrayList(1, 1));
+
+        QueryProcessor.clearPreparedStatements(false);
+        s = ps.bind();
+        session.execute(s); // this re-prepares the query!!
+        listener.verify(newArrayList("prepareSuccess", "executeSuccess", "executeFailure"), newArrayList(2, 2, 1));
+
+        query = formatQuery("select abcdef from %s where id = 1");
+        Exception expectedException = null;
+        try
+        {
+            session.prepare(query);
+            fail("should fail");
+        }
+        catch (Exception e)
+        {
+            expectedException = e;
+        }
+        listener.verify(newArrayList("prepareSuccess", "prepareFailure", "executeSuccess", "executeFailure"), newArrayList(2, 1, 2, 1));
+        assertNotNull(listener.e);
+        assertNotNull(expectedException);
+    }
+
+    @Test
+    public void batchTest()
+    {
+        createTable("create table %s (id int primary key, v int)");
+        BatchMockListener listener = new BatchMockListener(getCurrentColumnFamilyStore());
+        QueryEvents.instance.registerListener(listener);
+        Session session = sessionNet();
+        com.datastax.driver.core.BatchStatement batch = new com.datastax.driver.core.BatchStatement(com.datastax.driver.core.BatchStatement.Type.UNLOGGED);
+        String q1 = formatQuery("insert into %s (id, v) values (?, ?)");
+        PreparedStatement ps = session.prepare(q1);
+        batch.add(ps.bind(1,1));
+        batch.add(ps.bind(2,2));
+        String q2 = formatQuery("insert into %s (id, v) values (1,1)");
+        batch.add(new SimpleStatement(formatQuery("insert into %s (id, v) values (1,1)")));
+        session.execute(batch);
+
+        listener.verify(newArrayList("prepareSuccess", "batchSuccess"), newArrayList(1, 1));
+        assertEquals(3, listener.queries.size());
+        assertEquals(BatchStatement.Type.UNLOGGED, listener.batchType);
+        assertEquals(newArrayList(q1, q1, q2), listener.queries);
+        assertEquals(newArrayList(newArrayList(ByteBufferUtil.bytes(1), ByteBufferUtil.bytes(1)),
+                                  newArrayList(ByteBufferUtil.bytes(2), ByteBufferUtil.bytes(2)),
+                                  newArrayList(newArrayList())), listener.values);
+
+        batch.add(new SimpleStatement("insert into abc.def (id, v) values (1,1)"));
+        try
+        {
+            session.execute(batch);
+            fail("Batch should fail");
+        }
+        catch (Exception e)
+        {
+            // ok
+        }
+        listener.verify(newArrayList("prepareSuccess", "batchSuccess", "batchFailure"), newArrayList(1, 1, 1));
+        assertEquals(3, listener.queries.size());
+        assertEquals(BatchStatement.Type.UNLOGGED, listener.batchType);
+        assertEquals(newArrayList(q1, q1, q2), listener.queries);
+        assertEquals(newArrayList(newArrayList(ByteBufferUtil.bytes(1), ByteBufferUtil.bytes(1)),
+                                  newArrayList(ByteBufferUtil.bytes(2), ByteBufferUtil.bytes(2)),
+                                  newArrayList(newArrayList()),
+                                  newArrayList(newArrayList())), listener.values);
+    }
+
+    @Test
+    public void errorInListenerTest() throws Throwable
+    {
+        createTable("create table %s (id int primary key, v int)");
+        QueryEvents.Listener listener = new QueryEvents.Listener()
+        {
+            @Override
+            public void querySuccess(CQLStatement statement, String query, QueryOptions options, QueryState state, long queryTime, Message.Response response)
+            {
+                throw new AssertionError("whoo");
+            }
+
+            @Override
+            public void queryFailure(@Nullable CQLStatement statement, String query, QueryOptions options, QueryState state, Exception cause)
+            {
+                throw new AssertionError("whee");
+            }
+        };
+
+        QueryEvents.instance.registerListener(listener);
+
+        executeNet("insert into %s (id, v) values (2,2)");
+        ResultSet rs = executeNet("select * from %s");
+        assertEquals(2, rs.one().getInt("id"));
+
+        // record the exception without the throwing listener:
+        QueryEvents.instance.unregisterListener(listener);
+        Exception expected = null;
+        try
+        {
+            executeNet("select blabla from %s");
+            fail("Query should throw");
+        }
+        catch (Exception e)
+        {
+            expected = e;
+        }
+
+        QueryEvents.instance.registerListener(listener);
+        // and with the listener:
+        try
+        {
+            executeNet("select blabla from %s");
+            fail("Query should throw");
+        }
+        catch (Exception e)
+        {
+            // make sure we throw the same exception even if the listener throws;
+            assertSame(expected.getClass(), e.getClass());
+            assertEquals(expected.getMessage(), e.getMessage());
+        }
+
+
+    }
+
+    private static class MockListener implements QueryEvents.Listener
+    {
+        private final String tableName;
+        private Map<String, Integer> callCounts = new HashMap<>();
+        private String query;
+        private CQLStatement statement;
+        private long start = System.currentTimeMillis();
+        long queryTime;
+        private Exception e;
+
+
+        MockListener(ColumnFamilyStore currentColumnFamilyStore)
+        {
+            tableName = currentColumnFamilyStore.getTableName();
+        }
+
+        public void querySuccess(CQLStatement statement, String query, QueryOptions options, QueryState state, long queryTime, Message.Response response)
+        {
+            if (query.contains(tableName))
+            {
+                inc("querySuccess");
+                assertNotNull(query);
+                this.query = query;
+                assertNotNull(statement);
+                this.statement = statement;
+                this.queryTime = queryTime;
+            }
+        }
+
+        public void queryFailure(@Nullable CQLStatement statement, String query, QueryOptions options, QueryState state, Exception cause)
+        {
+
+            if (query.contains(tableName))
+            {
+                inc("queryFailure");
+                assertNotNull(query);
+                this.query = query;
+                this.statement = statement;
+                e = cause;
+            }
+        }
+
+        public void executeSuccess(CQLStatement statement, String query, QueryOptions options, QueryState state, long queryTime, Message.Response response)
+        {
+            if (query.contains(tableName))
+                inc("executeSuccess");
+        }
+        public void executeFailure(@Nullable CQLStatement statement, @Nullable String query, QueryOptions options, QueryState state, Exception cause)
+        {
+            inc("executeFailure");
+            e = cause;
+        }
+
+
+        public void prepareSuccess(CQLStatement statement, String query, QueryState state, long queryTime, ResultMessage.Prepared response)
+        {
+            if (query.contains(tableName))
+            {
+                inc("prepareSuccess");
+                assertNotNull(query);
+                this.query = query;
+                this.statement = statement;
+                this.queryTime = queryTime;
+            }
+        }
+        public void prepareFailure(@Nullable CQLStatement statement, String query, QueryState state, Exception cause)
+        {
+            if (query.contains(tableName))
+            {
+                inc("prepareFailure");
+                assertNotNull(query);
+                assertNull(statement);
+                this.query = query;
+            }
+        }
+
+        void inc(String key)
+        {
+            callCounts.compute(key, (k, v) -> v == null ? 1 : v + 1);
+        }
+
+        private void verify(String key, int expected)
+        {
+            verify(Collections.singletonList(key), Collections.singletonList(expected));
+        }
+
+        void verify(List<String> keys, List<Integer> expected)
+        {
+            assertEquals("key count not equal: "+keys+" : "+callCounts, keys.size(), callCounts.size());
+            assertTrue(queryTime >= start && queryTime <= System.currentTimeMillis());
+            for (int i = 0; i < keys.size(); i++)
+            {
+                assertEquals("expected count mismatch for "+keys.get(i), (int)expected.get(i), (int) callCounts.get(keys.get(i)));
+            }
+        }
+    }
+
+    private static class BatchMockListener extends MockListener
+    {
+        private List<String> queries;
+        private List<List<ByteBuffer>> values;
+        private BatchStatement.Type batchType;
+
+        BatchMockListener(ColumnFamilyStore currentColumnFamilyStore)
+        {
+            super(currentColumnFamilyStore);
+        }
+
+        public void batchSuccess(BatchStatement.Type batchType, List<? extends CQLStatement> statements, List<String> queries, List<List<ByteBuffer>> values, QueryOptions options, QueryState state, long queryTime, Message.Response response)
+        {
+            inc("batchSuccess");
+            this.queries = queries;
+            this.values = values;
+            this.batchType = batchType;
+            this.queryTime = queryTime;
+        }
+
+        public void batchFailure(BatchStatement.Type batchType, List<? extends CQLStatement> statements, List<String> queries, List<List<ByteBuffer>> values, QueryOptions options, QueryState state, Exception cause)
+        {
+            inc("batchFailure");
+            this.queries = queries;
+            this.values = values;
+            this.batchType = batchType;
+        }
+
+    }
+}
diff --git a/test/unit/org/apache/cassandra/audit/FullQueryLoggerTest.java b/test/unit/org/apache/cassandra/fql/FullQueryLoggerTest.java
similarity index 78%
rename from test/unit/org/apache/cassandra/audit/FullQueryLoggerTest.java
rename to test/unit/org/apache/cassandra/fql/FullQueryLoggerTest.java
index 62e5a50a1d..04baa09718 100644
--- a/test/unit/org/apache/cassandra/audit/FullQueryLoggerTest.java
+++ b/test/unit/org/apache/cassandra/fql/FullQueryLoggerTest.java
@@ -15,7 +15,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.apache.cassandra.audit;
+package org.apache.cassandra.fql;
 
 import java.io.File;
 import java.nio.ByteBuffer;
@@ -46,8 +46,9 @@ import net.openhft.chronicle.wire.WireOut;
 import org.apache.cassandra.Util;
 import org.apache.cassandra.cql3.CQLTester;
 import org.apache.cassandra.cql3.QueryOptions;
-import org.apache.cassandra.audit.FullQueryLogger.Query;
-import org.apache.cassandra.audit.FullQueryLogger.Batch;
+import org.apache.cassandra.cql3.statements.BatchStatement;
+import org.apache.cassandra.fql.FullQueryLogger.Query;
+import org.apache.cassandra.fql.FullQueryLogger.Batch;
 import org.apache.cassandra.cql3.statements.BatchStatement.Type;
 import org.apache.cassandra.io.util.FileUtils;
 import org.apache.cassandra.service.ClientState;
@@ -60,20 +61,19 @@ import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 
-import static org.apache.cassandra.audit.FullQueryLogger.BATCH;
-import static org.apache.cassandra.audit.FullQueryLogger.BATCH_TYPE;
-import static org.apache.cassandra.audit.FullQueryLogger.GENERATED_NOW_IN_SECONDS;
-import static org.apache.cassandra.audit.FullQueryLogger.GENERATED_TIMESTAMP;
-import static org.apache.cassandra.audit.FullQueryLogger.PROTOCOL_VERSION;
-import static org.apache.cassandra.audit.FullQueryLogger.QUERIES;
-import static org.apache.cassandra.audit.FullQueryLogger.QUERY;
-import static org.apache.cassandra.audit.FullQueryLogger.QUERY_OPTIONS;
-import static org.apache.cassandra.audit.FullQueryLogger.QUERY_START_TIME;
-import static org.apache.cassandra.audit.FullQueryLogger.SINGLE_QUERY;
-import static org.apache.cassandra.audit.FullQueryLogger.VALUES;
-
-import static org.apache.cassandra.utils.binlog.BinLog.TYPE;
-import static org.apache.cassandra.utils.binlog.BinLog.VERSION;
+import static org.apache.cassandra.fql.FullQueryLogger.BATCH;
+import static org.apache.cassandra.fql.FullQueryLogger.BATCH_TYPE;
+import static org.apache.cassandra.fql.FullQueryLogger.GENERATED_NOW_IN_SECONDS;
+import static org.apache.cassandra.fql.FullQueryLogger.GENERATED_TIMESTAMP;
+import static org.apache.cassandra.fql.FullQueryLogger.PROTOCOL_VERSION;
+import static org.apache.cassandra.fql.FullQueryLogger.QUERIES;
+import static org.apache.cassandra.fql.FullQueryLogger.QUERY;
+import static org.apache.cassandra.fql.FullQueryLogger.QUERY_OPTIONS;
+import static org.apache.cassandra.fql.FullQueryLogger.QUERY_START_TIME;
+import static org.apache.cassandra.fql.FullQueryLogger.SINGLE_QUERY;
+import static org.apache.cassandra.fql.FullQueryLogger.TYPE;
+import static org.apache.cassandra.fql.FullQueryLogger.VALUES;
+import static org.apache.cassandra.fql.FullQueryLogger.VERSION;
 
 public class FullQueryLoggerTest extends CQLTester
 {
@@ -85,48 +85,41 @@ public class FullQueryLoggerTest extends CQLTester
         tempDir = BinLogTest.tempDir();
     }
 
-    private FullQueryLogger instance;
-    
-    @Before
-    public void setUp()
-    {
-        instance = AuditLogManager.getInstance().getFullQueryLogger();
-    }
-    
     @After
     public void tearDown()
     {
-        instance.reset(tempDir.toString());
+        FullQueryLogger.instance.stop();
+        FullQueryLogger.instance.reset(tempDir.toString());
     }
 
     @Test(expected = NullPointerException.class)
     public void testConfigureNullPath() throws Exception
     {
-        instance.configure(null, "", true, 1, 1, StringUtils.EMPTY, 10);
+        FullQueryLogger.instance.enable(null, "", true, 1, 1, StringUtils.EMPTY, 10);
     }
 
     @Test(expected = NullPointerException.class)
     public void testConfigureNullRollCycle() throws Exception
     {
-        instance.configure(BinLogTest.tempDir(), null, true, 1, 1, StringUtils.EMPTY, 10);
+        FullQueryLogger.instance.enable(BinLogTest.tempDir(), null, true, 1, 1, StringUtils.EMPTY, 10);
     }
 
     @Test(expected = IllegalArgumentException.class)
     public void testConfigureInvalidRollCycle() throws Exception
     {
-        instance.configure(BinLogTest.tempDir(), "foobar", true, 1, 1, StringUtils.EMPTY, 10);
+        FullQueryLogger.instance.enable(BinLogTest.tempDir(), "foobar", true, 1, 1, StringUtils.EMPTY, 10);
     }
 
     @Test(expected = IllegalArgumentException.class)
     public void testConfigureInvalidMaxQueueWeight() throws Exception
     {
-        instance.configure(BinLogTest.tempDir(), "DAILY", true, 0, 1, StringUtils.EMPTY, 10);
+        FullQueryLogger.instance.enable(BinLogTest.tempDir(), "DAILY", true, 0, 1, StringUtils.EMPTY, 10);
     }
 
     @Test(expected = IllegalArgumentException.class)
     public void testConfigureInvalidMaxQueueLogSize() throws Exception
     {
-        instance.configure(BinLogTest.tempDir(), "DAILY", true, 1, 0, StringUtils.EMPTY, 10);
+        FullQueryLogger.instance.enable(BinLogTest.tempDir(), "DAILY", true, 1, 0, StringUtils.EMPTY, 10);
     }
 
     @Test(expected = IllegalArgumentException.class)
@@ -134,7 +127,7 @@ public class FullQueryLoggerTest extends CQLTester
     {
         File f = FileUtils.createTempFile("foo", "bar");
         f.deleteOnExit();
-        instance.configure(f.toPath(), "TEST_SECONDLY", true, 1, 1, StringUtils.EMPTY, 10);
+        FullQueryLogger.instance.enable(f.toPath(), "TEST_SECONDLY", true, 1, 1, StringUtils.EMPTY, 10);
     }
 
     @Test(expected = IllegalArgumentException.class)
@@ -182,15 +175,15 @@ public class FullQueryLoggerTest extends CQLTester
     @Test
     public void testResetWithoutConfigure() throws Exception
     {
-        instance.reset(tempDir.toString());
-        instance.reset(tempDir.toString());
+        FullQueryLogger.instance.reset(tempDir.toString());
+        FullQueryLogger.instance.reset(tempDir.toString());
     }
 
     @Test
     public void stopWithoutConfigure() throws Exception
     {
-        instance.stop();
-        instance.stop();
+        FullQueryLogger.instance.stop();
+        FullQueryLogger.instance.stop();
     }
 
     /**
@@ -203,7 +196,7 @@ public class FullQueryLoggerTest extends CQLTester
         File tempA = File.createTempFile("foo", "bar", tempDir.toFile());
         assertTrue(tempA.exists());
         File tempB = File.createTempFile("foo", "bar", BinLogTest.tempDir().toFile());
-        instance.reset(tempB.getParent());
+        FullQueryLogger.instance.reset(tempB.getParent());
         assertFalse(tempA.exists());
         assertFalse(tempB.exists());
     }
@@ -217,7 +210,7 @@ public class FullQueryLoggerTest extends CQLTester
         configureFQL();
         File tempA = File.createTempFile("foo", "bar", tempDir.toFile());
         assertTrue(tempA.exists());
-        instance.reset(tempA.getParent());
+        FullQueryLogger.instance.reset(tempA.getParent());
         assertFalse(tempA.exists());
     }
 
@@ -240,21 +233,21 @@ public class FullQueryLoggerTest extends CQLTester
     @Test
     public void testEnabledReset() throws Exception
     {
-        assertFalse(instance.enabled());
+        assertFalse(FullQueryLogger.instance.isEnabled());
         configureFQL();
-        assertTrue(instance.enabled());
-        instance.reset(tempDir.toString());
-        assertFalse(instance.enabled());
+        assertTrue(FullQueryLogger.instance.isEnabled());
+        FullQueryLogger.instance.reset(tempDir.toString());
+        assertFalse(FullQueryLogger.instance.isEnabled());
     }
 
     @Test
     public void testEnabledStop() throws Exception
     {
-        assertFalse(instance.enabled());
+        assertFalse(FullQueryLogger.instance.isEnabled());
         configureFQL();
-        assertTrue(instance.enabled());
-        instance.stop();
-        assertFalse(instance.enabled());
+        assertTrue(FullQueryLogger.instance.isEnabled());
+        FullQueryLogger.instance.stop();
+        assertFalse(FullQueryLogger.instance.isEnabled());
     }
 
     /**
@@ -270,7 +263,7 @@ public class FullQueryLoggerTest extends CQLTester
         {
             //Find out when the bin log thread has been blocked, necessary to not run into batch task drain behavior
             Semaphore binLogBlocked = new Semaphore(0);
-            instance.binLog.put(new Query("foo1", QueryOptions.DEFAULT, queryState(), 1)
+            FullQueryLogger.instance.binLog.put(new Query("foo1", QueryOptions.DEFAULT, queryState(), 1)
             {
 
                 public void writeMarshallablePayload(WireOut wire)
@@ -345,14 +338,14 @@ public class FullQueryLoggerTest extends CQLTester
     @Test
     public void testNonBlocking() throws Exception
     {
-        instance.configure(tempDir, "TEST_SECONDLY", false, 1, 1024 * 1024 * 256, StringUtils.EMPTY, 10);
+        FullQueryLogger.instance.enable(tempDir, "TEST_SECONDLY", false, 1, 1024 * 1024 * 256, StringUtils.EMPTY, 10);
         //Prevent the bin log thread from making progress, causing the task queue to refuse tasks
         Semaphore blockBinLog = new Semaphore(0);
         try
         {
             //Find out when the bin log thread has been blocked, necessary to not run into batch task drain behavior
             Semaphore binLogBlocked = new Semaphore(0);
-            instance.binLog.put(new Query("foo1", QueryOptions.DEFAULT, queryState(), 1)
+            FullQueryLogger.instance.binLog.put(new Query("foo1", QueryOptions.DEFAULT, queryState(), 1)
             {
 
                 public void writeMarshallablePayload(WireOut wire)
@@ -386,7 +379,7 @@ public class FullQueryLoggerTest extends CQLTester
             //This sample should get dropped AKA released without being written
             AtomicInteger releasedCount = new AtomicInteger(0);
             AtomicInteger writtenCount = new AtomicInteger(0);
-            instance.logRecord(new Query("foo3", QueryOptions.DEFAULT, queryState(), 1) {
+            FullQueryLogger.instance.binLog.logRecord(new Query("foo3", QueryOptions.DEFAULT, queryState(), 1) {
                 public void writeMarshallablePayload(WireOut wire)
                 {
                     writtenCount.incrementAndGet();
@@ -398,7 +391,7 @@ public class FullQueryLoggerTest extends CQLTester
                     releasedCount.incrementAndGet();
                     super.release();
                 }
-            }, instance.binLog);
+            });
 
             Util.spinAssertEquals(1, releasedCount::get, 60);
             assertEquals(0, writtenCount.get());
@@ -462,14 +455,14 @@ public class FullQueryLoggerTest extends CQLTester
     public void testRoundTripBatchWithKeyspace() throws Exception
     {
         configureFQL();
-        instance.logBatch(Type.UNLOGGED,
-                          Arrays.asList("foo1", "foo2"),
-                          Arrays.asList(Arrays.asList(ByteBuffer.allocate(1),
-                                                      ByteBuffer.allocateDirect(2)),
-                                        Collections.emptyList()),
-                          QueryOptions.DEFAULT,
-                          queryState("abcdefgh"),
-                          1);
+        logBatch(Type.UNLOGGED,
+                 Arrays.asList("foo1", "foo2"),
+                 Arrays.asList(Arrays.asList(ByteBuffer.allocate(1),
+                                             ByteBuffer.allocateDirect(2)),
+                               Collections.emptyList()),
+                 QueryOptions.DEFAULT,
+                 queryState("abcdefgh"),
+                 1);
 
         Util.spinAssertEquals(true, () ->
         {
@@ -486,14 +479,14 @@ public class FullQueryLoggerTest extends CQLTester
     public void testRoundTripBatchWithKeyspaceNull() throws Exception
     {
         configureFQL();
-        instance.logBatch(Type.UNLOGGED,
-                          Arrays.asList("foo1", "foo2"),
-                          Arrays.asList(Arrays.asList(ByteBuffer.allocate(1),
-                                                      ByteBuffer.allocateDirect(2)),
-                                        Collections.emptyList()),
-                          QueryOptions.DEFAULT,
-                          queryState(),
-                          1);
+        logBatch(Type.UNLOGGED,
+                 Arrays.asList("foo1", "foo2"),
+                 Arrays.asList(Arrays.asList(ByteBuffer.allocate(1),
+                                             ByteBuffer.allocateDirect(2)),
+                               Collections.emptyList()),
+                 QueryOptions.DEFAULT,
+                 queryState(),
+                 1);
 
         Util.spinAssertEquals(true, () ->
         {
@@ -619,62 +612,62 @@ public class FullQueryLoggerTest extends CQLTester
     @Test(expected = NullPointerException.class)
     public void testLogBatchNullType() throws Exception
     {
-        instance.logBatch(null, new ArrayList<>(), new ArrayList<>(), QueryOptions.DEFAULT, queryState(), 1);
+        logBatch(null, new ArrayList<>(), new ArrayList<>(), QueryOptions.DEFAULT, queryState(), 1);
     }
 
     @Test(expected = NullPointerException.class)
     public void testLogBatchNullQueries() throws Exception
     {
-        instance.logBatch(Type.UNLOGGED, null, new ArrayList<>(), QueryOptions.DEFAULT, queryState(), 1);
+        logBatch(Type.UNLOGGED, null, new ArrayList<>(), QueryOptions.DEFAULT, queryState(), 1);
     }
 
     @Test(expected = NullPointerException.class)
     public void testLogBatchNullQueriesQuery() throws Exception
     {
         configureFQL();
-        instance.logBatch(Type.UNLOGGED, Arrays.asList((String)null), new ArrayList<>(), QueryOptions.DEFAULT, queryState(), 1);
+        logBatch(Type.UNLOGGED, Arrays.asList((String)null), new ArrayList<>(), QueryOptions.DEFAULT, queryState(), 1);
     }
 
     @Test(expected = NullPointerException.class)
     public void testLogBatchNullValues() throws Exception
     {
-        instance.logBatch(Type.UNLOGGED, new ArrayList<>(), null, QueryOptions.DEFAULT, queryState(), 1);
+        logBatch(Type.UNLOGGED, new ArrayList<>(), null, QueryOptions.DEFAULT, queryState(), 1);
     }
 
     @Test(expected = NullPointerException.class)
     public void testLogBatchNullValuesValue() throws Exception
     {
-        instance.logBatch(Type.UNLOGGED, new ArrayList<>(), Arrays.asList((List<ByteBuffer>)null), null, queryState(), 1);
+        logBatch(Type.UNLOGGED, new ArrayList<>(), Arrays.asList((List<ByteBuffer>)null), null, queryState(), 1);
     }
 
     @Test(expected = NullPointerException.class)
     public void testLogBatchNullQueryOptions() throws Exception
     {
-        instance.logBatch(Type.UNLOGGED, new ArrayList<>(), new ArrayList<>(), null, queryState(), 1);
+        logBatch(Type.UNLOGGED, new ArrayList<>(), new ArrayList<>(), null, queryState(), 1);
     }
 
     @Test(expected = IllegalArgumentException.class)
     public void testLogBatchNegativeTime() throws Exception
     {
-        instance.logBatch(Type.UNLOGGED, new ArrayList<>(), new ArrayList<>(), QueryOptions.DEFAULT, queryState(), -1);
+        logBatch(Type.UNLOGGED, new ArrayList<>(), new ArrayList<>(), QueryOptions.DEFAULT, queryState(), -1);
     }
 
     @Test(expected = NullPointerException.class)
     public void testLogQueryNullQuery() throws Exception
     {
-        instance.logQuery(null, QueryOptions.DEFAULT, queryState(), 1);
+        logQuery(null, QueryOptions.DEFAULT, queryState(), 1);
     }
 
     @Test(expected = NullPointerException.class)
     public void testLogQueryNullQueryOptions() throws Exception
     {
-        instance.logQuery("", null, queryState(), 1);
+        logQuery("", null, queryState(), 1);
     }
 
     @Test(expected = IllegalArgumentException.class)
     public void testLogQueryNegativeTime() throws Exception
     {
-        instance.logQuery("", QueryOptions.DEFAULT, queryState(), -1);
+        logQuery("", QueryOptions.DEFAULT, queryState(), -1);
     }
 
     private static void compareQueryOptions(QueryOptions a, QueryOptions b)
@@ -690,17 +683,42 @@ public class FullQueryLoggerTest extends CQLTester
 
     private void configureFQL() throws Exception
     {
-        instance.configure(tempDir, "TEST_SECONDLY", true, 1, 1024 * 1024 * 256, StringUtils.EMPTY, 10);
+        FullQueryLogger.instance.enable(tempDir, "TEST_SECONDLY", true, 1, 1024 * 1024 * 256, StringUtils.EMPTY, 10);
     }
 
     private void logQuery(String query)
     {
-        instance.logQuery(query, QueryOptions.DEFAULT, queryState(), 1);
+        FullQueryLogger.instance.querySuccess(null, query, QueryOptions.DEFAULT, queryState(), 1, null);
     }
 
     private void logQuery(String query, String keyspace)
     {
-        instance.logQuery(query, QueryOptions.DEFAULT, queryState(keyspace), 1);
+        logQuery(query, keyspace, 1);
+    }
+    private void logQuery(String query, String keyspace, long time)
+    {
+        FullQueryLogger.instance.querySuccess(null, query, QueryOptions.DEFAULT, queryState(keyspace), time, null);
+    }
+    private void logQuery(String query, QueryOptions options, QueryState state, long time)
+    {
+        FullQueryLogger.instance.querySuccess(null, query, options, state, time, null);
+    }
+
+    private void logBatch(BatchStatement.Type type,
+                          List<String> queries,
+                          List<List<ByteBuffer>> values,
+                          QueryOptions options,
+                          QueryState queryState,
+                          long time)
+    {
+        FullQueryLogger.instance.batchSuccess(type,
+                              Collections.emptyList(),
+                              queries,
+                              values,
+                              options,
+                              queryState,
+                              time,
+                              null);
     }
 
     private QueryState queryState(String keyspace)
diff --git a/test/unit/org/apache/cassandra/service/StorageServiceServerTest.java b/test/unit/org/apache/cassandra/service/StorageServiceServerTest.java
index 6111339f5e..8e913421bb 100644
--- a/test/unit/org/apache/cassandra/service/StorageServiceServerTest.java
+++ b/test/unit/org/apache/cassandra/service/StorageServiceServerTest.java
@@ -628,7 +628,7 @@ public class StorageServiceServerTest
     public void testAuditLogEnableLoggerNotFound() throws Exception
     {
         StorageService.instance.enableAuditLog(null, null, null, null, null, null, null);
-        assertTrue(AuditLogManager.getInstance().isAuditingEnabled());
+        assertTrue(AuditLogManager.instance.isEnabled());
         try
         {
             StorageService.instance.enableAuditLog("foobar", null, null, null, null, null, null);
@@ -644,7 +644,7 @@ public class StorageServiceServerTest
     public void testAuditLogEnableLoggerTransitions() throws Exception
     {
         StorageService.instance.enableAuditLog(null, null, null, null, null, null, null);
-        assertTrue(AuditLogManager.getInstance().isAuditingEnabled());
+        assertTrue(AuditLogManager.instance.isEnabled());
 
         try
         {
@@ -656,8 +656,7 @@ public class StorageServiceServerTest
         }
 
         StorageService.instance.enableAuditLog(null, null, null, null, null, null, null);
-        assertTrue(AuditLogManager.getInstance().isAuditingEnabled());
-
+        assertTrue(AuditLogManager.instance.isEnabled());
         StorageService.instance.disableAuditLog();
     }
 }
diff --git a/test/unit/org/apache/cassandra/transport/CQLUserAuditTest.java b/test/unit/org/apache/cassandra/transport/CQLUserAuditTest.java
index 82becc7b46..c11b06f1c4 100644
--- a/test/unit/org/apache/cassandra/transport/CQLUserAuditTest.java
+++ b/test/unit/org/apache/cassandra/transport/CQLUserAuditTest.java
@@ -43,6 +43,7 @@ import com.datastax.driver.core.exceptions.AuthenticationException;
 import org.apache.cassandra.OrderedJUnit4ClassRunner;
 import org.apache.cassandra.audit.AuditEvent;
 import org.apache.cassandra.audit.AuditLogEntryType;
+import org.apache.cassandra.audit.AuditLogManager;
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.config.OverrideConfigurationLoader;
 import org.apache.cassandra.cql3.CQLTester;
@@ -84,6 +85,7 @@ public class CQLUserAuditTest
                   "cassandra", "cassandra", null);
 
         DiagnosticEventService.instance().subscribe(AuditEvent.class, auditEvents::add);
+        AuditLogManager.instance.initialize();
     }
 
     @AfterClass
diff --git a/test/unit/org/apache/cassandra/transport/MessagePayloadTest.java b/test/unit/org/apache/cassandra/transport/MessagePayloadTest.java
index a2ee6fb3a0..ef09c90a2b 100644
--- a/test/unit/org/apache/cassandra/transport/MessagePayloadTest.java
+++ b/test/unit/org/apache/cassandra/transport/MessagePayloadTest.java
@@ -372,6 +372,11 @@ public class MessagePayloadTest extends CQLTester
             return QueryProcessor.instance.getPrepared(id);
         }
 
+        public CQLStatement parse(String query, QueryState state, QueryOptions options)
+        {
+            return QueryProcessor.instance.parse(query, state, options);
+        }
+
         public ResultMessage.Prepared prepare(String query,
                                               ClientState clientState,
                                               Map<String, ByteBuffer> customPayload)
@@ -388,7 +393,7 @@ public class MessagePayloadTest extends CQLTester
             return result;
         }
 
-        public ResultMessage process(String query,
+        public ResultMessage process(CQLStatement statement,
                                      QueryState state,
                                      QueryOptions options,
                                      Map<String, ByteBuffer> customPayload,
@@ -397,7 +402,7 @@ public class MessagePayloadTest extends CQLTester
         {
             if (customPayload != null)
                 requestPayload = customPayload;
-            ResultMessage result = QueryProcessor.instance.process(query, state, options, customPayload, queryStartNanoTime);
+            ResultMessage result = QueryProcessor.instance.process(statement, state, options, customPayload, queryStartNanoTime);
             if (customPayload != null)
             {
                 result.setCustomPayload(responsePayload);
diff --git a/test/unit/org/apache/cassandra/utils/binlog/BinLogTest.java b/test/unit/org/apache/cassandra/utils/binlog/BinLogTest.java
index 81f1ea0e42..9919af3fb4 100644
--- a/test/unit/org/apache/cassandra/utils/binlog/BinLogTest.java
+++ b/test/unit/org/apache/cassandra/utils/binlog/BinLogTest.java
@@ -63,8 +63,12 @@ public class BinLogTest
     public void setUp() throws Exception
     {
         path = tempDir();
-        binLog = new BinLog(path, RollCycles.TEST_SECONDLY, 10, new DeletingArchiver(1024 * 1024 * 128));
-        binLog.start();
+        binLog = new BinLog.Builder().path(path)
+                                     .rollCycle(RollCycles.TEST_SECONDLY.toString())
+                                     .maxQueueWeight(10)
+                                     .maxLogSize(1024 * 1024 * 128)
+                                     .blocking(false)
+                                     .build(false);
     }
 
     @After
@@ -83,25 +87,25 @@ public class BinLogTest
     @Test(expected = NullPointerException.class)
     public void testConstructorNullPath() throws Exception
     {
-        new BinLog(null, RollCycles.TEST_SECONDLY, 1, new DeletingArchiver(1));
+        new BinLog.Builder().path(null).build(false);
     }
 
     @Test(expected = NullPointerException.class)
     public void testConstructorNullRollCycle() throws Exception
     {
-        new BinLog(tempDir(), null, 1, new DeletingArchiver(1));
+        new BinLog.Builder().path(tempDir()).rollCycle(null).build(false);
     }
 
     @Test(expected = IllegalArgumentException.class)
     public void testConstructorZeroWeight() throws Exception
     {
-        new BinLog(tempDir(), RollCycles.TEST_SECONDLY, 0, new DeletingArchiver(1));
+        new BinLog.Builder().path(tempDir()).rollCycle(RollCycles.TEST_SECONDLY.toString()).maxQueueWeight(0).build(false);
     }
 
     @Test(expected = IllegalArgumentException.class)
     public void testConstructorLogSize() throws Exception
     {
-        new BinLog(tempDir(), RollCycles.TEST_SECONDLY, 0, new DeletingArchiver(1));
+        new BinLog.Builder().path(tempDir()).rollCycle(RollCycles.TEST_SECONDLY.toString()).maxLogSize(0).build(false);
     }
 
     /**
@@ -394,8 +398,7 @@ public class BinLogTest
     public void testCleanupOnOversize() throws Exception
     {
         tearDown();
-        binLog = new BinLog(path, RollCycles.TEST_SECONDLY, 1, new DeletingArchiver(10000));
-        binLog.start();
+        binLog = new BinLog.Builder().path(path).rollCycle(RollCycles.TEST_SECONDLY.toString()).maxQueueWeight(1).maxLogSize(10000).blocking(false).build(false);
         for (int ii = 0; ii < 5; ii++)
         {
             binLog.put(record(String.valueOf(ii)));
diff --git a/tools/fqltool/src/org/apache/cassandra/fqltool/FQLQuery.java b/tools/fqltool/src/org/apache/cassandra/fqltool/FQLQuery.java
index 8683d15cb2..c3c6c89e1a 100644
--- a/tools/fqltool/src/org/apache/cassandra/fqltool/FQLQuery.java
+++ b/tools/fqltool/src/org/apache/cassandra/fqltool/FQLQuery.java
@@ -28,7 +28,7 @@ import com.datastax.driver.core.BatchStatement;
 import com.datastax.driver.core.ConsistencyLevel;
 import com.datastax.driver.core.SimpleStatement;
 import com.datastax.driver.core.Statement;
-import org.apache.cassandra.audit.FullQueryLogger;
+import org.apache.cassandra.fql.FullQueryLogger;
 import org.apache.cassandra.cql3.QueryOptions;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.QueryState;
diff --git a/tools/fqltool/src/org/apache/cassandra/fqltool/FQLQueryReader.java b/tools/fqltool/src/org/apache/cassandra/fqltool/FQLQueryReader.java
index 164b077faa..20f362b2a6 100644
--- a/tools/fqltool/src/org/apache/cassandra/fqltool/FQLQueryReader.java
+++ b/tools/fqltool/src/org/apache/cassandra/fqltool/FQLQueryReader.java
@@ -32,22 +32,21 @@ import net.openhft.chronicle.wire.WireIn;
 import org.apache.cassandra.cql3.QueryOptions;
 import org.apache.cassandra.transport.ProtocolVersion;
 
-import static org.apache.cassandra.audit.FullQueryLogger.CURRENT_VERSION;
-import static org.apache.cassandra.audit.FullQueryLogger.GENERATED_NOW_IN_SECONDS;
-import static org.apache.cassandra.audit.FullQueryLogger.GENERATED_TIMESTAMP;
-import static org.apache.cassandra.audit.FullQueryLogger.KEYSPACE;
-import static org.apache.cassandra.audit.FullQueryLogger.PROTOCOL_VERSION;
-import static org.apache.cassandra.audit.FullQueryLogger.QUERY_OPTIONS;
-import static org.apache.cassandra.audit.FullQueryLogger.QUERY_START_TIME;
-import static org.apache.cassandra.audit.FullQueryLogger.BATCH;
-import static org.apache.cassandra.audit.FullQueryLogger.BATCH_TYPE;
-import static org.apache.cassandra.audit.FullQueryLogger.QUERIES;
-import static org.apache.cassandra.audit.FullQueryLogger.QUERY;
-import static org.apache.cassandra.audit.FullQueryLogger.SINGLE_QUERY;
-import static org.apache.cassandra.audit.FullQueryLogger.VALUES;
-
-import static org.apache.cassandra.utils.binlog.BinLog.TYPE;
-import static org.apache.cassandra.utils.binlog.BinLog.VERSION;
+import static org.apache.cassandra.fql.FullQueryLogger.CURRENT_VERSION;
+import static org.apache.cassandra.fql.FullQueryLogger.GENERATED_NOW_IN_SECONDS;
+import static org.apache.cassandra.fql.FullQueryLogger.GENERATED_TIMESTAMP;
+import static org.apache.cassandra.fql.FullQueryLogger.KEYSPACE;
+import static org.apache.cassandra.fql.FullQueryLogger.PROTOCOL_VERSION;
+import static org.apache.cassandra.fql.FullQueryLogger.QUERY_OPTIONS;
+import static org.apache.cassandra.fql.FullQueryLogger.QUERY_START_TIME;
+import static org.apache.cassandra.fql.FullQueryLogger.TYPE;
+import static org.apache.cassandra.fql.FullQueryLogger.VERSION;
+import static org.apache.cassandra.fql.FullQueryLogger.BATCH;
+import static org.apache.cassandra.fql.FullQueryLogger.BATCH_TYPE;
+import static org.apache.cassandra.fql.FullQueryLogger.QUERIES;
+import static org.apache.cassandra.fql.FullQueryLogger.QUERY;
+import static org.apache.cassandra.fql.FullQueryLogger.SINGLE_QUERY;
+import static org.apache.cassandra.fql.FullQueryLogger.VALUES;
 
 public class FQLQueryReader implements ReadMarshallable
 {
diff --git a/tools/fqltool/src/org/apache/cassandra/fqltool/commands/Dump.java b/tools/fqltool/src/org/apache/cassandra/fqltool/commands/Dump.java
index 46c731f943..dfc3b0944b 100644
--- a/tools/fqltool/src/org/apache/cassandra/fqltool/commands/Dump.java
+++ b/tools/fqltool/src/org/apache/cassandra/fqltool/commands/Dump.java
@@ -40,7 +40,7 @@ import net.openhft.chronicle.threads.Pauser;
 import net.openhft.chronicle.wire.ReadMarshallable;
 import net.openhft.chronicle.wire.ValueIn;
 import net.openhft.chronicle.wire.WireIn;
-import org.apache.cassandra.audit.FullQueryLogger;
+import org.apache.cassandra.fql.FullQueryLogger;
 import org.apache.cassandra.cql3.QueryOptions;
 import org.apache.cassandra.transport.ProtocolVersion;
 import org.apache.cassandra.utils.binlog.BinLog;
diff --git a/tools/fqltool/test/unit/org/apache/cassandra/fqltool/FQLReplayTest.java b/tools/fqltool/test/unit/org/apache/cassandra/fqltool/FQLReplayTest.java
index 9220c2ed07..7fb39af3a1 100644
--- a/tools/fqltool/test/unit/org/apache/cassandra/fqltool/FQLReplayTest.java
+++ b/tools/fqltool/test/unit/org/apache/cassandra/fqltool/FQLReplayTest.java
@@ -42,7 +42,7 @@ import net.openhft.chronicle.queue.ChronicleQueueBuilder;
 import net.openhft.chronicle.queue.ExcerptAppender;
 import net.openhft.chronicle.queue.ExcerptTailer;
 import net.openhft.chronicle.wire.WireOut;
-import org.apache.cassandra.audit.FullQueryLogger;
+import org.apache.cassandra.fql.FullQueryLogger;
 import org.apache.cassandra.cql3.QueryOptions;
 import org.apache.cassandra.cql3.statements.BatchStatement;
 import org.apache.cassandra.fqltool.commands.Compare;
