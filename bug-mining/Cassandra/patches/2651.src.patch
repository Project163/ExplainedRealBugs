diff --git a/CHANGES.txt b/CHANGES.txt
index d697e3f305..6ef9025c52 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -34,6 +34,7 @@
  * Fix IllegalArgumentException when updating from 1.2 with SuperColumns
    (CASSANDRA-6733)
  * FBUtilities.singleton() should use the CF comparator (CASSANDRA-6778)
+ * Fix CQLSStableWriter.addRow(Map<String, Object>) (CASSANDRA-6526)
 Merged from 1.2:
  * Add CMSClassUnloadingEnabled JVM option (CASSANDRA-6541)
  * Catch memtable flush exceptions during shutdown (CASSANDRA-6735)
diff --git a/src/java/org/apache/cassandra/io/sstable/CQLSSTableWriter.java b/src/java/org/apache/cassandra/io/sstable/CQLSSTableWriter.java
index 86348aabaf..a7ece70ec3 100644
--- a/src/java/org/apache/cassandra/io/sstable/CQLSSTableWriter.java
+++ b/src/java/org/apache/cassandra/io/sstable/CQLSSTableWriter.java
@@ -141,6 +141,11 @@ public class CQLSSTableWriter
      * keys are the names of the columns to add instead of taking a list of the
      * values in the order of the insert statement used during construction of
      * this write.
+     * <p>
+     * Please note that the column names in the map keys must be in lowercase unless
+     * the declared column name is a
+     * <a href="http://cassandra.apache.org/doc/cql3/CQL.html#identifiers">case-sensitive quoted identifier</a>
+     * (in which case the map key must use the exact case of the column).
      *
      * @param values a map of colum name to column values representing the new
      * row to add. Note that if a column is not part of the map, it's value will
@@ -152,11 +157,12 @@ public class CQLSSTableWriter
     public CQLSSTableWriter addRow(Map<String, Object> values)
     throws InvalidRequestException, IOException
     {
-        int size = Math.min(values.size(), boundNames.size());
+        int size = boundNames.size();
         List<ByteBuffer> rawValues = new ArrayList<>(size);
         for (int i = 0; i < size; i++) {
             ColumnSpecification spec = boundNames.get(i);
-            rawValues.add(((AbstractType)spec.type).decompose(values.get(spec.name.toString())));
+            Object value = values.get(spec.name.toString());
+            rawValues.add(value == null ? null : ((AbstractType)spec.type).decompose(value));
         }
         return rawAddRow(rawValues);
     }
diff --git a/test/unit/org/apache/cassandra/io/sstable/CQLSSTableWriterTest.java b/test/unit/org/apache/cassandra/io/sstable/CQLSSTableWriterTest.java
index 0e38e164cd..bdc4b9443c 100644
--- a/test/unit/org/apache/cassandra/io/sstable/CQLSSTableWriterTest.java
+++ b/test/unit/org/apache/cassandra/io/sstable/CQLSSTableWriterTest.java
@@ -20,6 +20,7 @@ package org.apache.cassandra.io.sstable;
 import java.io.File;
 import java.util.Iterator;
 
+import com.google.common.collect.ImmutableMap;
 import com.google.common.io.Files;
 import org.junit.BeforeClass;
 import org.junit.Test;
@@ -72,6 +73,7 @@ public class CQLSSTableWriterTest
         writer.addRow(0, "test1", 24);
         writer.addRow(1, "test2", null);
         writer.addRow(2, "test3", 42);
+        writer.addRow(ImmutableMap.<String, Object>of("k", 3, "v2", 12));
         writer.close();
 
         SSTableLoader loader = new SSTableLoader(dataDir, new SSTableLoader.Client()
@@ -92,7 +94,7 @@ public class CQLSSTableWriterTest
         loader.stream().get();
 
         UntypedResultSet rs = QueryProcessor.processInternal("SELECT * FROM cql_keyspace.table1;");
-        assertEquals(3, rs.size());
+        assertEquals(4, rs.size());
 
         Iterator<UntypedResultSet.Row> iter = rs.iterator();
         UntypedResultSet.Row row;
@@ -111,5 +113,10 @@ public class CQLSSTableWriterTest
         assertEquals(2, row.getInt("k"));
         assertEquals("test3", row.getString("v1"));
         assertEquals(42, row.getInt("v2"));
+
+        row = iter.next();
+        assertEquals(3, row.getInt("k"));
+        assertEquals(null, row.getBytes("v1")); // Using getBytes because we know it won't NPE
+        assertEquals(12, row.getInt("v2"));
     }
 }
