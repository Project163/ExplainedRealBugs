diff --git a/CHANGES.txt b/CHANGES.txt
index 93d9d4ea12..6aa63437ef 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -25,6 +25,7 @@
  * Bring back the accepted encryption protocols list as configurable option (CASSANDRA-13325)
  * DigestResolver.getData throws AssertionError since dataResponse is null (CASSANDRA-16097)
  * Cannot replace_address /X because it doesn't exist in gossip (CASSANDRA-16213)
+ * cqlsh row_id resets on page boundaries (CASSANDRA-16160)
 Merged from 3.11:
  * SASI's `max_compaction_flush_memory_in_mb` settings over 100GB revert to default of 1GB (CASSANDRA-16071)
 Merged from 3.0:
diff --git a/bin/cqlsh.py b/bin/cqlsh.py
index 003515dba5..5162a00ae4 100644
--- a/bin/cqlsh.py
+++ b/bin/cqlsh.py
@@ -1131,9 +1131,9 @@ class Shell(cmd.Cmd):
             while True:
                 # Always print for the first page even it is empty
                 if result.current_rows or isFirst:
-                    num_rows += len(result.current_rows)
                     with_header = isFirst or tty
-                    self.print_static_result(result, table_meta, with_header, tty)
+                    self.print_static_result(result, table_meta, with_header, tty, num_rows)
+                    num_rows += len(result.current_rows)
                 if result.has_more_pages:
                     if self.shunted_query_out is None and tty:
                         # Only pause when not capturing.
@@ -1156,7 +1156,7 @@ class Shell(cmd.Cmd):
                 self.writeresult('%d more decoding errors suppressed.'
                                  % (len(self.decoding_errors) - 2), color=RED)
 
-    def print_static_result(self, result, table_meta, with_header, tty):
+    def print_static_result(self, result, table_meta, with_header, tty, row_count_offset=0):
         if not result.column_names and not table_meta:
             return
 
@@ -1176,7 +1176,7 @@ class Shell(cmd.Cmd):
         formatted_values = [list(map(self.myformat_value, [row[c] for c in column_names], cql_types)) for row in result.current_rows]
 
         if self.expand_enabled:
-            self.print_formatted_result_vertically(formatted_names, formatted_values)
+            self.print_formatted_result_vertically(formatted_names, formatted_values, row_count_offset)
         else:
             self.print_formatted_result(formatted_names, formatted_values, with_header, tty)
 
@@ -1207,13 +1207,13 @@ class Shell(cmd.Cmd):
         if tty:
             self.writeresult("")
 
-    def print_formatted_result_vertically(self, formatted_names, formatted_values):
+    def print_formatted_result_vertically(self, formatted_names, formatted_values, row_count_offset):
         max_col_width = max([n.displaywidth for n in formatted_names])
         max_val_width = max([n.displaywidth for row in formatted_values for n in row])
 
         # for each row returned, list all the column-value pairs
-        for row_id, row in enumerate(formatted_values):
-            self.writeresult("@ Row %d" % (row_id + 1))
+        for i, row in enumerate(formatted_values):
+            self.writeresult("@ Row %d" % (row_count_offset + i + 1))
             self.writeresult('-%s-' % '-+-'.join(['-' * max_col_width, '-' * max_val_width]))
             for field_id, field in enumerate(row):
                 column = formatted_names[field_id].ljust(max_col_width, color=self.color)
diff --git a/pylib/cqlshlib/test/test_cqlsh_output.py b/pylib/cqlshlib/test/test_cqlsh_output.py
index 304050dc2d..496216726a 100644
--- a/pylib/cqlshlib/test/test_cqlsh_output.py
+++ b/pylib/cqlshlib/test/test_cqlsh_output.py
@@ -910,3 +910,13 @@ class TestCqlshOutput(BaseTestCase):
             nnnnnnnn
             """),
         ))
+
+    def test_expanded_output_counts_past_page(self):
+        query = "PAGING 5; EXPAND ON; SELECT * FROM twenty_rows_table;"
+        output, result = testcall_cqlsh(prompt=None, env=self.default_env,
+                                        tty=False, input=query)
+        self.assertEqual(0, result)
+        # format is "@ Row 1"
+        row_headers = [s for s in output.splitlines() if "@ Row" in s]
+        row_ids = [int(s.split(' ')[2]) for s in row_headers]
+        self.assertEqual([i for i in range(1, 21)], row_ids)
