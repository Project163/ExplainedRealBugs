diff --git a/CHANGES.txt b/CHANGES.txt
index 9a0569f880..a655645abf 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -27,6 +27,7 @@
  * (cql3) Add ReversedType support (CASSANDRA-4004)
  * (cql3) Add timeuuid type (CASSANDRA-4194)
  * (cql3) Minor fixes (CASSANDRA-4185)
+ * (cql3) Fix prepared statement in BATCH (CASSANDRA-4202)
 Merged from 1.0:
  * Fix super columns bug where cache is not updated (CASSANDRA-4190)
  * fix maxTimestamp to include row tombstones (CASSANDRA-4116)
diff --git a/src/java/org/apache/cassandra/cql3/statements/BatchStatement.java b/src/java/org/apache/cassandra/cql3/statements/BatchStatement.java
index 8fc5f07b52..0f06a66b43 100644
--- a/src/java/org/apache/cassandra/cql3/statements/BatchStatement.java
+++ b/src/java/org/apache/cassandra/cql3/statements/BatchStatement.java
@@ -147,16 +147,20 @@ public class BatchStatement extends ModificationStatement
         return batch;
     }
 
-    public ParsedStatement.Prepared prepare() throws InvalidRequestException
+    public ParsedStatement.Prepared prepare(AbstractType[] boundTypes) throws InvalidRequestException
     {
-        List<AbstractType<?>> boundTypes = new ArrayList<AbstractType<?>>(statements.size());
-        // XXX: we use our knowledge that Modification don't create new
-        // statement upon call to prepare()
+        // XXX: we use our knowledge that Modification don't create new statement upon call to prepare()
         for (ModificationStatement statement : statements)
         {
-            boundTypes.addAll(statement.prepare().boundTypes);
+            statement.prepare(boundTypes);
         }
-        return new ParsedStatement.Prepared(this, boundTypes);
+        return new ParsedStatement.Prepared(this, Arrays.<AbstractType<?>>asList(boundTypes));
+    }
+
+    public ParsedStatement.Prepared prepare() throws InvalidRequestException
+    {
+        AbstractType[] boundTypes = new AbstractType[getBoundsTerms()];
+        return prepare(boundTypes);
     }
 
     public String toString()
diff --git a/src/java/org/apache/cassandra/cql3/statements/DeleteStatement.java b/src/java/org/apache/cassandra/cql3/statements/DeleteStatement.java
index b82e066005..f9f6c4f46a 100644
--- a/src/java/org/apache/cassandra/cql3/statements/DeleteStatement.java
+++ b/src/java/org/apache/cassandra/cql3/statements/DeleteStatement.java
@@ -145,13 +145,18 @@ public class DeleteStatement extends ModificationStatement
         return rm;
     }
 
-    public ParsedStatement.Prepared prepare() throws InvalidRequestException
+    public ParsedStatement.Prepared prepare(AbstractType[] boundTypes) throws InvalidRequestException
     {
         CFMetaData metadata = ThriftValidation.validateColumnFamily(keyspace(), columnFamily());
         cfDef = metadata.getCfDef();
-        AbstractType[] types = new AbstractType[getBoundsTerms()];
-        UpdateStatement.processKeys(cfDef, whereClause, processedKeys, types);
-        return new ParsedStatement.Prepared(this, Arrays.<AbstractType<?>>asList(types));
+        UpdateStatement.processKeys(cfDef, whereClause, processedKeys, boundTypes);
+        return new ParsedStatement.Prepared(this, Arrays.<AbstractType<?>>asList(boundTypes));
+    }
+
+    public ParsedStatement.Prepared prepare() throws InvalidRequestException
+    {
+        AbstractType[] boundTypes = new AbstractType[getBoundsTerms()];
+        return prepare(boundTypes);
     }
 
     public String toString()
diff --git a/src/java/org/apache/cassandra/cql3/statements/ModificationStatement.java b/src/java/org/apache/cassandra/cql3/statements/ModificationStatement.java
index 88415700dc..e5a9ffdb69 100644
--- a/src/java/org/apache/cassandra/cql3/statements/ModificationStatement.java
+++ b/src/java/org/apache/cassandra/cql3/statements/ModificationStatement.java
@@ -25,6 +25,7 @@ import java.util.concurrent.TimeoutException;
 import org.apache.cassandra.auth.Permission;
 import org.apache.cassandra.cql3.*;
 import org.apache.cassandra.db.IMutation;
+import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.StorageProxy;
 import org.apache.cassandra.thrift.ConsistencyLevel;
@@ -125,4 +126,6 @@ public abstract class ModificationStatement extends CFStatement implements CQLSt
      * @throws InvalidRequestException on invalid requests
      */
     public abstract List<IMutation> getMutations(ClientState clientState, List<ByteBuffer> variables) throws InvalidRequestException;
+
+    public abstract ParsedStatement.Prepared prepare(AbstractType[] boundTypes) throws InvalidRequestException;
 }
diff --git a/src/java/org/apache/cassandra/cql3/statements/UpdateStatement.java b/src/java/org/apache/cassandra/cql3/statements/UpdateStatement.java
index 186ee80907..e05a8234f1 100644
--- a/src/java/org/apache/cassandra/cql3/statements/UpdateStatement.java
+++ b/src/java/org/apache/cassandra/cql3/statements/UpdateStatement.java
@@ -234,10 +234,9 @@ public class UpdateStatement extends ModificationStatement
         }
     }
 
-    public ParsedStatement.Prepared prepare() throws InvalidRequestException
+    public ParsedStatement.Prepared prepare(AbstractType[] boundTypes) throws InvalidRequestException
     {
         boolean hasCommutativeOperation = false;
-        AbstractType[] types = new AbstractType[getBoundsTerms()];
 
         if (columns != null)
         {
@@ -275,7 +274,7 @@ public class UpdateStatement extends ModificationStatement
 
                 Term value = columnValues.get(i);
                 if (value.isBindMarker())
-                    types[value.bindIndex] = name.type;
+                    boundTypes[value.bindIndex] = name.type;
 
                 switch (name.kind)
                 {
@@ -314,15 +313,21 @@ public class UpdateStatement extends ModificationStatement
                             throw new InvalidRequestException(String.format("Multiple definition found for column %s", name));
                         Operation op = entry.getValue();
                         if (op.value.isBindMarker())
-                            types[op.value.bindIndex] = name.type;
+                            boundTypes[op.value.bindIndex] = name.type;
                         processedColumns.put(name.name, op);
                         break;
                 }
             }
-            processKeys(cfDef, whereClause, processedKeys, types);
+            processKeys(cfDef, whereClause, processedKeys, boundTypes);
         }
 
-        return new ParsedStatement.Prepared(this, Arrays.<AbstractType<?>>asList(types));
+        return new ParsedStatement.Prepared(this, Arrays.<AbstractType<?>>asList(boundTypes));
+    }
+
+    public ParsedStatement.Prepared prepare() throws InvalidRequestException
+    {
+        AbstractType[] types = new AbstractType[getBoundsTerms()];
+        return prepare(types);
     }
 
     // Reused by DeleteStatement
