diff --git a/build.xml b/build.xml
index 74f5a7bb44..86178c35c5 100644
--- a/build.xml
+++ b/build.xml
@@ -25,7 +25,7 @@
     <property name="debuglevel" value="source,lines,vars"/>
 
     <!-- default version and SCM information -->
-    <property name="base.version" value="1.2.3"/>
+    <property name="base.version" value="2.0"/>
     <property name="scm.connection" value="scm:git://git.apache.org/cassandra.git"/>
     <property name="scm.developerConnection" value="scm:git://git.apache.org/cassandra.git"/>
     <property name="scm.url" value="http://git-wip-us.apache.org/repos/asf?p=cassandra.git;a=tree"/>
diff --git a/src/java/org/apache/cassandra/cache/AutoSavingCache.java b/src/java/org/apache/cassandra/cache/AutoSavingCache.java
index 072385e7a5..6a7e17dfaa 100644
--- a/src/java/org/apache/cassandra/cache/AutoSavingCache.java
+++ b/src/java/org/apache/cassandra/cache/AutoSavingCache.java
@@ -30,10 +30,12 @@ import org.slf4j.LoggerFactory;
 
 import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.config.DatabaseDescriptor;
+import org.apache.cassandra.db.ColumnFamilyType;
 import org.apache.cassandra.db.Table;
 import org.apache.cassandra.db.compaction.CompactionInfo;
 import org.apache.cassandra.db.compaction.CompactionManager;
 import org.apache.cassandra.db.compaction.OperationType;
+import org.apache.cassandra.db.marshal.BytesType;
 import org.apache.cassandra.db.ColumnFamilyStore;
 import org.apache.cassandra.io.FSWriteError;
 import org.apache.cassandra.io.util.FileUtils;
@@ -197,7 +199,7 @@ public class AutoSavingCache<K extends CacheKey, V> extends InstrumentingCache<K
             else
                 type = OperationType.UNKNOWN;
 
-            info = new CompactionInfo(new CFMetaData(Table.SYSTEM_KS, cacheType.toString(), null, null, null),
+            info = new CompactionInfo(new CFMetaData(Table.SYSTEM_KS, cacheType.toString(), ColumnFamilyType.Standard, BytesType.instance, null),
                                       type,
                                       0,
                                       keys.size(),
diff --git a/src/java/org/apache/cassandra/config/Avro.java b/src/java/org/apache/cassandra/config/Avro.java
index a7498d3d05..bbdca816db 100644
--- a/src/java/org/apache/cassandra/config/Avro.java
+++ b/src/java/org/apache/cassandra/config/Avro.java
@@ -24,6 +24,7 @@ import java.util.*;
 import org.apache.cassandra.db.ColumnFamilyType;
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.db.marshal.BytesType;
+import org.apache.cassandra.db.marshal.CompositeType;
 import org.apache.cassandra.db.marshal.TypeParser;
 import org.apache.cassandra.db.migration.avro.CfDef;
 import org.apache.cassandra.exceptions.ConfigurationException;
@@ -145,10 +146,28 @@ public class Avro
         //  Isn't AVRO supposed to handle stuff like this?
         if (cf.min_compaction_threshold != null) { newCFMD.minCompactionThreshold(cf.min_compaction_threshold); }
         if (cf.max_compaction_threshold != null) { newCFMD.maxCompactionThreshold(cf.max_compaction_threshold); }
-        if (cf.key_alias != null) { newCFMD.keyAliases(Collections.<ByteBuffer>singletonList(cf.key_alias)); }
+
+        if (cf.key_alias != null)
+            newCFMD.addOrReplaceColumnDefinition(ColumnDefinition.partitionKeyDef(cf.key_alias, keyValidator, null));
         if (cf.column_aliases != null)
-            newCFMD.columnAliases(new ArrayList<ByteBuffer>(cf.column_aliases)); // fix avro stupidity
-        if (cf.value_alias != null) { newCFMD.valueAlias(cf.value_alias); }
+        {
+            if (comparator instanceof CompositeType)
+            {
+                List<AbstractType<?>> components = ((CompositeType)comparator).types;
+                for (int i = 0; i < cf.column_aliases.size(); ++i)
+                    if (cf.column_aliases.get(i) != null)
+                        newCFMD.addOrReplaceColumnDefinition(ColumnDefinition.clusteringKeyDef(cf.column_aliases.get(i), components.get(i), i));
+            }
+            else
+            {
+                assert cf.column_aliases.size() <= 1;
+                if (cf.column_aliases.get(0) != null)
+                    newCFMD.addOrReplaceColumnDefinition(ColumnDefinition.clusteringKeyDef(cf.column_aliases.get(0), comparator, null));
+            }
+        }
+        if (cf.value_alias != null)
+            newCFMD.addOrReplaceColumnDefinition(ColumnDefinition.compactValueDef(cf.value_alias, validator));
+
         if (cf.compaction_strategy != null)
         {
             try
@@ -211,11 +230,28 @@ public class Avro
         try
         {
             AbstractType<?> validatorType = TypeParser.parse(cd.validation_class);
-            return new ColumnDefinition(ByteBufferUtil.clone(cd.name), validatorType, index_type, ColumnDefinition.getStringMap(cd.index_options), index_name, null);
+            ColumnDefinition def = ColumnDefinition.regularDef(ByteBufferUtil.clone(cd.name), validatorType, null);
+            def.setIndexName(index_name);
+            def.setIndexType(index_type, getStringMap(cd.index_options));
+            return def;
         }
         catch (RequestValidationException e)
         {
             throw new RuntimeException(e);
         }
     }
+
+    public static Map<String,String> getStringMap(Map<CharSequence, CharSequence> charMap)
+    {
+        if (charMap == null)
+            return null;
+
+        Map<String,String> stringMap = new HashMap<String, String>();
+
+        for (Map.Entry<CharSequence, CharSequence> entry : charMap.entrySet())
+            stringMap.put(entry.getKey().toString(), entry.getValue().toString());
+
+
+        return stringMap;
+    }
 }
diff --git a/src/java/org/apache/cassandra/config/CFMetaData.java b/src/java/org/apache/cassandra/config/CFMetaData.java
index 74228a1e5d..417929a777 100644
--- a/src/java/org/apache/cassandra/config/CFMetaData.java
+++ b/src/java/org/apache/cassandra/config/CFMetaData.java
@@ -26,6 +26,7 @@ import java.util.*;
 
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Objects;
+import com.google.common.collect.AbstractIterator;
 import com.google.common.collect.MapDifference;
 import com.google.common.collect.Maps;
 import org.apache.commons.lang.ArrayUtils;
@@ -158,6 +159,7 @@ public final class CFMetaData
                                                                + "index_options text,"
                                                                + "index_name text,"
                                                                + "component_index int,"
+                                                               + "type text,"
                                                                + "PRIMARY KEY(keyspace_name, columnfamily_name, column_name)"
                                                                + ") WITH COMMENT='ColumnFamily column attributes' AND gc_grace_seconds=8640");
 
@@ -346,10 +348,6 @@ public final class CFMetaData
     private volatile AbstractType<?> keyValidator = BytesType.instance;
     private volatile int minCompactionThreshold = DEFAULT_MIN_COMPACTION_THRESHOLD;
     private volatile int maxCompactionThreshold = DEFAULT_MAX_COMPACTION_THRESHOLD;
-    // Both those aliases list can be null padded if only some of the position have been given an alias through ALTER TABLE .. RENAME
-    private volatile List<ByteBuffer> keyAliases = new ArrayList<ByteBuffer>();
-    private volatile List<ByteBuffer> columnAliases = new ArrayList<ByteBuffer>();
-    private volatile ByteBuffer valueAlias = null;
     private volatile Double bloomFilterFpChance = null;
     private volatile Caching caching = DEFAULT_CACHING_STRATEGY;
     private volatile int indexInterval = DEFAULT_INDEX_INTERVAL;
@@ -358,7 +356,19 @@ public final class CFMetaData
     private volatile SpeculativeRetry speculativeRetry = DEFAULT_SPECULATIVE_RETRY;
     private volatile boolean populateIoCacheOnFlush = DEFAULT_POPULATE_IO_CACHE_ON_FLUSH;
 
-    volatile Map<ByteBuffer, ColumnDefinition> column_metadata = new HashMap<ByteBuffer,ColumnDefinition>();
+    /*
+     * All CQL3 columns definition are stored in the column_metadata map.
+     * On top of that, we keep separated collection of each kind of definition, to
+     * 1) allow easy access to each kind and 2) for the partition key and
+     * clustering key ones, those list are ordered by the "component index" of the
+     * elements.
+     */
+    private volatile Map<ByteBuffer, ColumnDefinition> column_metadata = new HashMap<ByteBuffer,ColumnDefinition>();
+    private volatile List<ColumnDefinition> partitionKeyColumns;  // Always of size keyValidator.componentsCount, null padded if necessary
+    private volatile List<ColumnDefinition> clusteringKeyColumns; // Of size comparator.componentsCount or comparator.componentsCount -1, null padded if necessary
+    private volatile Set<ColumnDefinition> regularColumns;
+    private volatile ColumnDefinition compactValueColumn;
+
     public volatile Class<? extends AbstractCompactionStrategy> compactionStrategyClass = DEFAULT_COMPACTION_STRATEGY_CLASS;
     public volatile Map<String, String> compactionStrategyOptions = new HashMap<String, String>();
 
@@ -378,9 +388,6 @@ public final class CFMetaData
     public CFMetaData keyValidator(AbstractType<?> prop) {keyValidator = prop; updateCfDef(); return this;}
     public CFMetaData minCompactionThreshold(int prop) {minCompactionThreshold = prop; return this;}
     public CFMetaData maxCompactionThreshold(int prop) {maxCompactionThreshold = prop; return this;}
-    public CFMetaData keyAliases(List<ByteBuffer> prop) {keyAliases = prop; updateCfDef(); return this;}
-    public CFMetaData columnAliases(List<ByteBuffer> prop) {columnAliases = prop; updateCfDef(); return this;}
-    public CFMetaData valueAlias(ByteBuffer prop) {valueAlias = prop; updateCfDef(); return this;}
     public CFMetaData columnMetadata(Map<ByteBuffer,ColumnDefinition> prop) {column_metadata = prop; updateCfDef(); return this;}
     public CFMetaData compactionStrategyClass(Class<? extends AbstractCompactionStrategy> prop) {compactionStrategyClass = prop; return this;}
     public CFMetaData compactionStrategyOptions(Map<String, String> prop) {compactionStrategyOptions = prop; return this;}
@@ -530,9 +537,6 @@ public final class CFMetaData
                       .keyValidator(oldCFMD.keyValidator)
                       .minCompactionThreshold(oldCFMD.minCompactionThreshold)
                       .maxCompactionThreshold(oldCFMD.maxCompactionThreshold)
-                      .keyAliases(new ArrayList<ByteBuffer>(oldCFMD.keyAliases))
-                      .columnAliases(new ArrayList<ByteBuffer>(oldCFMD.columnAliases))
-                      .valueAlias(oldCFMD.valueAlias)
                       .columnMetadata(clonedColumns)
                       .compactionStrategyClass(oldCFMD.compactionStrategyClass)
                       .compactionStrategyOptions(oldCFMD.compactionStrategyOptions)
@@ -630,35 +634,40 @@ public final class CFMetaData
     // Used by CQL2 only.
     public ByteBuffer getKeyName()
     {
-        if (keyAliases.size() > 1)
+        if (partitionKeyColumns.size() > 1)
             throw new IllegalStateException("Cannot acces column family with composite key from CQL < 3.0.0");
 
-        return keyAliases.isEmpty() ? DEFAULT_KEY_NAME : keyAliases.get(0);
+        return partitionKeyColumns.get(0) == null ? DEFAULT_KEY_NAME : partitionKeyColumns.get(0).name;
     }
 
-    public List<ByteBuffer> getKeyAliases()
+    public CompressionParameters compressionParameters()
     {
-        return keyAliases;
+        return compressionParameters;
     }
 
-    public List<ByteBuffer> getColumnAliases()
+    public Collection<ColumnDefinition> allColumns()
     {
-        return columnAliases;
+        return column_metadata.values();
     }
 
-    public ByteBuffer getValueAlias()
+    public List<ColumnDefinition> partitionKeyColumns()
     {
-        return valueAlias;
+        return partitionKeyColumns;
     }
 
-    public CompressionParameters compressionParameters()
+    public List<ColumnDefinition> clusteringKeyColumns()
     {
-        return compressionParameters;
+        return clusteringKeyColumns;
+    }
+
+    public Set<ColumnDefinition> regularColumns()
+    {
+        return regularColumns;
     }
 
-    public Map<ByteBuffer, ColumnDefinition> getColumn_metadata()
+    public ColumnDefinition compactValueColumn()
     {
-        return Collections.unmodifiableMap(column_metadata);
+        return compactValueColumn;
     }
 
     public double getBloomFilterFpChance()
@@ -722,9 +731,6 @@ public final class CFMetaData
             .append(maxCompactionThreshold, rhs.maxCompactionThreshold)
             .append(cfId, rhs.cfId)
             .append(column_metadata, rhs.column_metadata)
-            .append(keyAliases, rhs.keyAliases)
-            .append(columnAliases, rhs.columnAliases)
-            .append(valueAlias, rhs.valueAlias)
             .append(compactionStrategyClass, rhs.compactionStrategyClass)
             .append(compactionStrategyOptions, rhs.compactionStrategyOptions)
             .append(compressionParameters, rhs.compressionParameters)
@@ -756,9 +762,6 @@ public final class CFMetaData
             .append(maxCompactionThreshold)
             .append(cfId)
             .append(column_metadata)
-            .append(keyAliases)
-            .append(columnAliases)
-            .append(valueAlias)
             .append(compactionStrategyClass)
             .append(compactionStrategyOptions)
             .append(compressionParameters)
@@ -836,8 +839,6 @@ public final class CFMetaData
             if (cf_def.isSetGc_grace_seconds()) { newCFMD.gcGraceSeconds(cf_def.gc_grace_seconds); }
             if (cf_def.isSetMin_compaction_threshold()) { newCFMD.minCompactionThreshold(cf_def.min_compaction_threshold); }
             if (cf_def.isSetMax_compaction_threshold()) { newCFMD.maxCompactionThreshold(cf_def.max_compaction_threshold); }
-            if (cf_def.isSetKey_alias()) { newCFMD.keyAliases(Collections.<ByteBuffer>singletonList(cf_def.key_alias)); }
-            if (cf_def.isSetKey_validation_class()) { newCFMD.keyValidator(TypeParser.parse(cf_def.key_validation_class)); }
             if (cf_def.isSetCompaction_strategy())
                 newCFMD.compactionStrategyClass = createCompactionStrategy(cf_def.compaction_strategy);
             if (cf_def.isSetCompaction_strategy_options())
@@ -863,12 +864,18 @@ public final class CFMetaData
 
             CompressionParameters cp = CompressionParameters.create(cf_def.compression_options);
 
+            if (cf_def.isSetKey_validation_class()) { newCFMD.keyValidator(TypeParser.parse(cf_def.key_validation_class)); }
+            if (cf_def.isSetKey_alias() && !(newCFMD.keyValidator instanceof CompositeType))
+            {
+                newCFMD.column_metadata.put(cf_def.key_alias, ColumnDefinition.partitionKeyDef(cf_def.key_alias, newCFMD.keyValidator, null));
+            }
+
             return newCFMD.comment(cf_def.comment)
                           .replicateOnWrite(cf_def.replicate_on_write)
                           .defaultValidator(TypeParser.parse(cf_def.default_validation_class))
-                          .keyValidator(TypeParser.parse(cf_def.key_validation_class))
                           .columnMetadata(ColumnDefinition.fromThrift(cf_def.column_metadata, newCFMD.isSuper()))
-                          .compressionParameters(cp);
+                          .compressionParameters(cp)
+                          .updateCfDef();
         }
         catch (SyntaxException e)
         {
@@ -928,17 +935,6 @@ public final class CFMetaData
         minCompactionThreshold = cfm.minCompactionThreshold;
         maxCompactionThreshold = cfm.maxCompactionThreshold;
 
-        /*
-         * Because thrift updates don't know about aliases, we should ignore
-         * the case where the new aliases are empty.
-         */
-        if (!cfm.keyAliases.isEmpty())
-            keyAliases = cfm.keyAliases;
-        if (!cfm.columnAliases.isEmpty())
-            columnAliases = cfm.columnAliases;
-        if (cfm.valueAlias != null)
-            valueAlias = cfm.valueAlias;
-
         bloomFilterFpChance = cfm.bloomFilterFpChance;
         memtableFlushPeriod = cfm.memtableFlushPeriod;
         caching = cfm.caching;
@@ -1084,11 +1080,14 @@ public final class CFMetaData
         def.setMin_compaction_threshold(minCompactionThreshold);
         def.setMax_compaction_threshold(maxCompactionThreshold);
         // We only return the alias if only one is set since thrift don't know about multiple key aliases
-        if (keyAliases.size() == 1)
-            def.setKey_alias(keyAliases.get(0));
+        if (partitionKeyColumns.size() == 1 && partitionKeyColumns.get(0) != null)
+            def.setKey_alias(partitionKeyColumns.get(0).name);
         List<org.apache.cassandra.thrift.ColumnDef> column_meta = new ArrayList<org.apache.cassandra.thrift.ColumnDef>(column_metadata.size());
         for (ColumnDefinition cd : column_metadata.values())
+        {
+            if (cd.type == ColumnDefinition.Type.REGULAR)
                 column_meta.add(cd.toThrift());
+        }
         def.setColumn_metadata(column_meta);
         def.setCompaction_strategy(compactionStrategyClass.getName());
         def.setCompaction_strategy_options(new HashMap<String, String>(compactionStrategyOptions));
@@ -1231,7 +1230,6 @@ public final class CFMetaData
         if (cfType == null)
             throw new ConfigurationException(String.format("Invalid column family type for %s", cfName));
 
-
         if (comparator instanceof CounterColumnType)
             throw new ConfigurationException("CounterColumnType is not a valid comparator");
         if (keyValidator instanceof CounterColumnType)
@@ -1240,7 +1238,7 @@ public final class CFMetaData
         // Mixing counter with non counter columns is not supported (#2614)
         if (defaultValidator instanceof CounterColumnType)
         {
-            for (ColumnDefinition def : column_metadata.values())
+            for (ColumnDefinition def : regularColumns)
                 if (!(def.getValidator() instanceof CounterColumnType))
                     throw new ConfigurationException("Cannot add a non counter column (" + getColumnDefinitionComparator(def).getString(def.name) + ") in a counter column family");
         }
@@ -1251,26 +1249,12 @@ public final class CFMetaData
                     throw new ConfigurationException("Cannot add a counter column (" + getColumnDefinitionComparator(def).getString(def.name) + ") in a non counter column family");
         }
 
-        // check if any of the columns has name equal to the cf.key_alias
-        for (ColumnDefinition columndef : column_metadata.values())
-        {
-            for (ByteBuffer alias : keyAliases)
-                if (alias.equals(columndef.name))
-                    throw new ConfigurationException("Cannot have key alias equals to a column name: " + UTF8Type.instance.compose(alias));
-
-            for (ByteBuffer alias : columnAliases)
-                if (alias.equals(columndef.name))
-                    throw new ConfigurationException("Cannot have column alias equals to a column name: " + UTF8Type.instance.compose(alias));
-
-            if (valueAlias != null && valueAlias.equals(columndef.name))
-                throw new ConfigurationException("Cannot have value alias equals to a column name: " + UTF8Type.instance.compose(valueAlias));
-        }
-
-        for (ByteBuffer alias : keyAliases)
-            validateAlias(alias, "Key");
-        for (ByteBuffer alias : columnAliases)
-            validateAlias(alias, "Column");
-        validateAlias(valueAlias, "Value");
+        for (ColumnDefinition def : partitionKeyColumns)
+            validateAlias(def, "Key");
+        for (ColumnDefinition def : clusteringKeyColumns)
+            validateAlias(def, "Column");
+        if (compactValueColumn != null)
+            validateAlias(compactValueColumn, "Value");
 
         // initialize a set of names NOT in the CF under consideration
         Set<String> indexNames = existingIndexNames(cfName);
@@ -1329,19 +1313,19 @@ public final class CFMetaData
         for (ColumnFamilyStore cfs : ColumnFamilyStore.all())
         {
             if (cfToExclude == null || !cfs.name.equals(cfToExclude))
-                for (ColumnDefinition cd : cfs.metadata.getColumn_metadata().values())
+                for (ColumnDefinition cd : cfs.metadata.allColumns())
                     indexNames.add(cd.getIndexName());
         }
         return indexNames;
     }
 
-    private static void validateAlias(ByteBuffer alias, String msg) throws ConfigurationException
+    private static void validateAlias(ColumnDefinition alias, String msg) throws ConfigurationException
     {
         if (alias != null)
         {
             try
             {
-                UTF8Type.instance.validate(alias);
+                UTF8Type.instance.validate(alias.name);
             }
             catch (MarshalException e)
             {
@@ -1368,10 +1352,11 @@ public final class CFMetaData
      *
      * @param newState The new metadata (for the same CF)
      * @param modificationTimestamp Timestamp to use for mutation
+     * @param fromThrift whether the newState comes from thrift
      *
      * @return Difference between attributes in form of schema mutation
      */
-    public RowMutation toSchemaUpdate(CFMetaData newState, long modificationTimestamp)
+    public RowMutation toSchemaUpdate(CFMetaData newState, long modificationTimestamp, boolean fromThrift)
     {
         RowMutation rm = new RowMutation(Table.SYSTEM_KS, SystemTable.getSchemaKSKey(ksName));
 
@@ -1381,7 +1366,14 @@ public final class CFMetaData
 
         // columns that are no longer needed
         for (ColumnDefinition cd : columnDiff.entriesOnlyOnLeft().values())
+        {
+            // Thrift only knows about the REGULAR ColumnDefinition type, so don't consider other type
+            // are being deleted just because they are not here.
+            if (fromThrift && cd.type != ColumnDefinition.Type.REGULAR)
+                continue;
+
             cd.deleteFromSchema(rm, cfName, getColumnDefinitionComparator(cd), modificationTimestamp);
+        }
 
         // newly added columns
         for (ColumnDefinition cd : columnDiff.entriesOnlyOnRight().values())
@@ -1491,7 +1483,6 @@ public final class CFMetaData
         cf.addColumn(Column.create(keyValidator.toString(), timestamp, cfName, "key_validator"));
         cf.addColumn(Column.create(minCompactionThreshold, timestamp, cfName, "min_compaction_threshold"));
         cf.addColumn(Column.create(maxCompactionThreshold, timestamp, cfName, "max_compaction_threshold"));
-        cf.addColumn(Column.create(json(aliasesAsStrings(keyAliases)), timestamp, cfName, "key_aliases"));
         cf.addColumn(bloomFilterFpChance == null ? DeletedColumn.create(ldt, timestamp, cfName, "bloomFilterFpChance")
                                                  : Column.create(bloomFilterFpChance, timestamp, cfName, "bloom_filter_fp_chance"));
         cf.addColumn(Column.create(memtableFlushPeriod, timestamp, cfName, "memtable_flush_period_in_ms"));
@@ -1499,12 +1490,15 @@ public final class CFMetaData
         cf.addColumn(Column.create(defaultTimeToLive, timestamp, cfName, "default_time_to_live"));
         cf.addColumn(Column.create(compactionStrategyClass.getName(), timestamp, cfName, "compaction_strategy_class"));
         cf.addColumn(Column.create(json(compressionParameters.asThriftOptions()), timestamp, cfName, "compression_parameters"));
-        cf.addColumn(valueAlias == null ? DeletedColumn.create(ldt, timestamp, cfName, "value_alias")
-                                        : Column.create(valueAlias, timestamp, cfName, "value_alias"));
-        cf.addColumn(Column.create(json(aliasesAsStrings(columnAliases)), timestamp, cfName, "column_aliases"));
         cf.addColumn(Column.create(json(compactionStrategyOptions), timestamp, cfName, "compaction_strategy_options"));
         cf.addColumn(Column.create(indexInterval, timestamp, cfName, "index_interval"));
         cf.addColumn(Column.create(speculativeRetry.toString(), timestamp, cfName, "speculative_retry"));
+
+        // Save the CQL3 metadata "the old way" for compatibility sake
+        cf.addColumn(Column.create(aliasesToJson(partitionKeyColumns), timestamp, cfName, "key_aliases"));
+        cf.addColumn(Column.create(aliasesToJson(clusteringKeyColumns), timestamp, cfName, "column_aliases"));
+        cf.addColumn(compactValueColumn == null ? DeletedColumn.create(ldt, timestamp, cfName, "value_alias")
+                                                : Column.create(compactValueColumn.name, timestamp, cfName, "value_alias"));
     }
 
     // Package protected for use by tests
@@ -1532,14 +1526,6 @@ public final class CFMetaData
             if (result.has("comment"))
                 cfm.comment(result.getString("comment"));
             // We need support the old key_alias for compatibility sake
-            if (result.has("key_aliases"))
-            {
-                cfm.keyAliases(aliasesFromStrings(fromJsonList(result.getString("key_aliases"))));
-            }
-            else if (result.has("key_alias"))
-            {
-                cfm.keyAliases(Collections.<ByteBuffer>singletonList(result.getBytes("key_alias")));
-            }
             if (result.has("bloom_filter_fp_chance"))
                 cfm.bloomFilterFpChance(result.getDouble("bloom_filter_fp_chance"));
             if (result.has("memtable_flush_period_in_ms"))
@@ -1551,14 +1537,31 @@ public final class CFMetaData
                 cfm.speculativeRetry(SpeculativeRetry.fromString(result.getString("speculative_retry")));
             cfm.compactionStrategyClass(createCompactionStrategy(result.getString("compaction_strategy_class")));
             cfm.compressionParameters(CompressionParameters.create(fromJsonMap(result.getString("compression_parameters"))));
-            cfm.columnAliases(aliasesFromStrings(fromJsonList(result.getString("column_aliases"))));
-            if (result.has("value_alias"))
-                cfm.valueAlias(result.getBytes("value_alias"));
             cfm.compactionStrategyOptions(fromJsonMap(result.getString("compaction_strategy_options")));
             if (result.has("index_interval"))
                 cfm.indexInterval(result.getInt("index_interval"));
             if (result.has("populate_io_cache_on_flush"))
                 cfm.populateIoCacheOnFlush(result.getBoolean("populate_io_cache_on_flush"));
+
+            /*
+             * The info previously hold by key_alias(es), column_alias and value_alias is now stored in column_metadata (because 1) this
+             * make more sense and 2) this allow to store indexing information).
+             * However, for upgrade sake we need to still be able to read those old values. Moreover, we cannot easily
+             * remove those old columns once "converted" to column_metadata because that would screw up nodes that may
+             * not have upgraded. So for now we keep the both info and in sync, even though its redundant.
+             * In other words, the ColumnDefinition the following lines add may be replaced later when ColumnDefinition.fromSchema
+             * is called but that's ok.
+             */
+            if (result.has("key_aliases"))
+                cfm.addColumnMetadataFromAliases(aliasesFromStrings(fromJsonList(result.getString("key_aliases"))), cfm.keyValidator, ColumnDefinition.Type.PARTITION_KEY);
+            else if (result.has("key_alias"))
+                cfm.addColumnMetadataFromAliases(Collections.<ByteBuffer>singletonList(result.getBytes("key_alias")), cfm.keyValidator, ColumnDefinition.Type.PARTITION_KEY);
+
+            cfm.addColumnMetadataFromAliases(aliasesFromStrings(fromJsonList(result.getString("column_aliases"))), cfm.comparator, ColumnDefinition.Type.CLUSTERING_KEY);
+
+            if (result.has("value_alias"))
+                cfm.addColumnMetadataFromAliases(Collections.<ByteBuffer>singletonList(result.getBytes("value_alias")), cfm.defaultValidator, ColumnDefinition.Type.COMPACT_VALUE);
+
             return cfm;
         }
         catch (SyntaxException e)
@@ -1571,6 +1574,26 @@ public final class CFMetaData
         }
     }
 
+    public void addColumnMetadataFromAliases(List<ByteBuffer> aliases, AbstractType<?> comparator, ColumnDefinition.Type type)
+    {
+        if (comparator instanceof CompositeType)
+        {
+            CompositeType ct = (CompositeType)comparator;
+            for (int i = 0; i < aliases.size(); ++i)
+            {
+                if (aliases.get(i) != null)
+                    column_metadata.put(aliases.get(i), new ColumnDefinition(aliases.get(i), ct.types.get(i), i, type));
+            }
+        }
+        else
+        {
+            assert aliases.size() <= 1;
+            if (!aliases.isEmpty() && aliases.get(0) != null)
+                column_metadata.put(aliases.get(0), new ColumnDefinition(aliases.get(0), comparator, null, type));
+        }
+        updateCfDef();
+    }
+
     /**
      * Deserialize CF metadata from low-level representation
      *
@@ -1581,7 +1604,7 @@ public final class CFMetaData
         CFMetaData cfDef = fromSchemaNoColumns(result);
 
         Row serializedColumnDefinitions = ColumnDefinition.readSchema(cfDef.ksName, cfDef.cfName);
-        return addColumnDefinitionSchema(cfDef, serializedColumnDefinitions).updateCfDef();
+        return addColumnDefinitionSchema(cfDef, serializedColumnDefinitions);
     }
 
     private static CFMetaData fromSchema(Row row)
@@ -1590,19 +1613,19 @@ public final class CFMetaData
         return fromSchema(result);
     }
 
-    private List<String> aliasesAsStrings(List<ByteBuffer> rawAliases)
+    private String aliasesToJson(List<ColumnDefinition> rawAliases)
     {
         List<String> aliases = new ArrayList<String>(rawAliases.size());
-        for (ByteBuffer rawAlias : rawAliases)
-            aliases.add(UTF8Type.instance.compose(rawAlias));
-        return aliases;
+        for (ColumnDefinition rawAlias : rawAliases)
+            aliases.add(rawAlias == null ? null : UTF8Type.instance.compose(rawAlias.name));
+        return json(aliases);
     }
 
     private static List<ByteBuffer> aliasesFromStrings(List<String> aliases)
     {
         List<ByteBuffer> rawAliases = new ArrayList<ByteBuffer>(aliases.size());
         for (String alias : aliases)
-            rawAliases.add(UTF8Type.instance.decompose(alias));
+            rawAliases.add(alias == null ? null : UTF8Type.instance.decompose(alias));
         return rawAliases;
     }
 
@@ -1622,27 +1645,36 @@ public final class CFMetaData
         return rm;
     }
 
+    // The comparator to validate the definition name.
+
     public AbstractType<?> getColumnDefinitionComparator(ColumnDefinition def)
     {
-        return getColumnDefinitionComparator(def.componentIndex);
+        return getComponentComparator(def.componentIndex, def.type);
     }
 
-    public AbstractType<?> getColumnDefinitionComparator(Integer componentIndex)
+    public AbstractType<?> getComponentComparator(Integer componentIndex, ColumnDefinition.Type type)
     {
-        AbstractType<?> cfComparator = cfType == ColumnFamilyType.Super ? ((CompositeType)comparator).types.get(1) : comparator;
-        if (cfComparator instanceof CompositeType)
+        switch (type)
         {
-            if (componentIndex == null)
-                return cfComparator;
+            case REGULAR:
+                AbstractType<?> cfComparator = cfType == ColumnFamilyType.Super ? ((CompositeType)comparator).types.get(1) : comparator;
+                if (cfComparator instanceof CompositeType)
+                {
+                    if (componentIndex == null)
+                        return cfComparator;
 
-            List<AbstractType<?>> types = ((CompositeType)cfComparator).types;
-            AbstractType<?> t = types.get(componentIndex);
-            assert t != null : "Non-sensical component index";
-            return t;
-        }
-        else
-        {
-            return cfComparator;
+                    List<AbstractType<?>> types = ((CompositeType)cfComparator).types;
+                    AbstractType<?> t = types.get(componentIndex);
+                    assert t != null : "Non-sensical component index";
+                    return t;
+                }
+                else
+                {
+                    return cfComparator;
+                }
+            default:
+                // CQL3 column names are UTF8
+                return UTF8Type.instance;
         }
     }
 
@@ -1651,21 +1683,60 @@ public final class CFMetaData
     {
         for (ColumnDefinition cd : ColumnDefinition.fromSchema(serializedColumnDefinitions, cfDef))
             cfDef.column_metadata.put(cd.name, cd);
-        return cfDef;
+        return cfDef.updateCfDef();
+    }
+
+    public void addColumnDefinition(ColumnDefinition def) throws ConfigurationException
+    {
+        if (column_metadata.containsKey(def.name))
+            throw new ConfigurationException(String.format("Cannot add column %s, a column with the same name already exists", getColumnDefinitionComparator(def).getString(def.name)));
+
+        addOrReplaceColumnDefinition(def);
     }
 
-    public void addColumnDefinition(ColumnDefinition def)
+    // This method doesn't check if a def of the same name already exist and should only be used when we
+    // know this cannot happen.
+    public void addOrReplaceColumnDefinition(ColumnDefinition def)
     {
         column_metadata.put(def.name, def);
+        updateCfDef();
     }
 
     public boolean removeColumnDefinition(ColumnDefinition def)
     {
-        return column_metadata.remove(def.name) != null;
+        boolean removed = column_metadata.remove(def.name) != null;
+        updateCfDef();
+        return removed;
+    }
+
+    public void renameColumn(ByteBuffer from, String strFrom, ByteBuffer to, String strTo) throws InvalidRequestException
+    {
+        ColumnDefinition def = column_metadata.get(from);
+        if (def == null)
+            throw new InvalidRequestException(String.format("Cannot rename unknown column %s in table %s", strFrom, cfName));
+
+        if (column_metadata.get(to) != null)
+            throw new InvalidRequestException(String.format("Cannot rename column %s to %s in table %s; another column of that name already exist", strFrom, strTo, cfName));
+
+        if (def.type == ColumnDefinition.Type.REGULAR)
+            throw new InvalidRequestException(String.format("Cannot rename non PRIMARY KEY part %s", strFrom));
+
+        ColumnDefinition newDef = def.cloneWithNewName(to);
+        // don't call addColumnDefinition/removeColumnDefition because we want to avoid recomputing
+        // the CQL3 cfDef between those two operation
+        column_metadata.put(newDef.name, newDef);
+        column_metadata.remove(def.name);
     }
 
     private CFMetaData updateCfDef()
     {
+        /*
+         * TODO: There is definitively some repetition between the CQL3  metadata stored in this
+         * object (partitionKeyColumns, ...) and the one stored in CFDefinition.
+         * Ultimately, we should probably merge both. However, there is enough details to fix that
+         * it's worth doing that in a separate issue.
+         */
+        rebuildCQL3Metadata();
         cqlCfDef = new CFDefinition(this);
         return this;
     }
@@ -1676,21 +1747,160 @@ public final class CFMetaData
         return cqlCfDef;
     }
 
+    private void rebuildCQL3Metadata()
+    {
+        List<ColumnDefinition> pkCols = nullInitializedList(keyValidator.componentsCount());
+        int nbCkCols = isDense(comparator, column_metadata.values())
+                     ? comparator.componentsCount()
+                     : comparator.componentsCount() - (hasCollection() ? 2 : 1);
+        List<ColumnDefinition> ckCols = nullInitializedList(nbCkCols);
+        Set<ColumnDefinition> regCols = new HashSet<ColumnDefinition>();
+        ColumnDefinition compactCol = null;
+
+        for (ColumnDefinition def : column_metadata.values())
+        {
+            switch (def.type)
+            {
+                case PARTITION_KEY:
+                    assert !(def.componentIndex == null && keyValidator instanceof CompositeType);
+                    pkCols.set(def.componentIndex == null ? 0 : def.componentIndex, def);
+                    break;
+                case CLUSTERING_KEY:
+                    assert !(def.componentIndex == null && comparator instanceof CompositeType);
+                    ckCols.set(def.componentIndex == null ? 0 : def.componentIndex, def);
+                    break;
+                case REGULAR:
+                    regCols.add(def);
+                    break;
+                case COMPACT_VALUE:
+                    assert compactCol == null : "There shouldn't be more than one compact value defined";
+                    compactCol = def;
+                    break;
+            }
+        }
+
+        // Now actually assign the correct value. This is not atomic, but then again, updating CFMetaData is never atomic anyway.
+        partitionKeyColumns = pkCols;
+        clusteringKeyColumns = ckCols;
+        regularColumns = regCols;
+        compactValueColumn = compactCol;
+    }
+
+    private boolean hasCollection()
+    {
+        if (isSuper() || !(comparator instanceof CompositeType))
+            return false;
+
+        List<AbstractType<?>> types = ((CompositeType)comparator).types;
+        return types.get(types.size() - 1) instanceof ColumnToCollectionType;
+    }
+
+    /*
+     * We call dense a CF for which each component of the comparator is a clustering column, i.e. no
+     * component is used to store a regular column names. In other words, non-composite static "thrift"
+     * and CQL3 CF are *not* dense.
+     * Note that his method is only used by rebuildCQL3Metadata. Once said metadata are built, finding
+     * if a CF is dense amounts more simply to check if clusteringKeyColumns.size() == comparator.componentsCount().
+     */
+    private static boolean isDense(AbstractType<?> comparator, Collection<ColumnDefinition> defs)
+    {
+        /*
+         * This is a bit subtle to compute because of thrift upgrades. A CQL3
+         * CF will have all it's column metadata set up from creation, so
+         * checking isDense should just be looking the ColumnDefinition of
+         * type CLUSTERING_KEY having the biggest componentIndex and comparing that
+         * to comparator.componentsCount.
+         * However, thrift CF will have no or only some (through ALTER RENAME)
+         * metadata set and we still need to make our best effort at finding whether
+         * it is intended as a dense CF or not.
+         */
+
+        // First, we compute the number of clustering columns metadata actually defined (and 
+        // whether there is some "hole" in the metadata)
+        boolean[] definedClusteringKeys = new boolean[comparator.componentsCount()];
+        boolean hasRegular = false;
+        for (ColumnDefinition def : defs)
+        {
+            switch (def.type)
+            {
+                case CLUSTERING_KEY:
+                    definedClusteringKeys[def.componentIndex == null ? 0 : def.componentIndex] = true;
+                    break;
+                case REGULAR:
+                    hasRegular = true;
+                    break;
+            }
+        }
+        boolean hasNulls = false;
+        int maxIdx = -1;
+        for (int i = definedClusteringKeys.length - 1; i >= 0; i--)
+        {
+            if (maxIdx == -1)
+            {
+                if (definedClusteringKeys[i])
+                    maxIdx = i;
+            }
+            else
+            {
+                if (!definedClusteringKeys[i])
+                    hasNulls = true;
+            }
+        }
+
+        if (comparator instanceof CompositeType)
+        {
+            List<AbstractType<?>> types = ((CompositeType)comparator).types;
+            /*
+             * There was no real way to define a non-dense composite CF in thrift (the ColumnDefinition.componentIndex
+             * is not exposed), so consider dense anything that don't look like a CQL3 created CF.
+             *
+             * Note that this is not perfect: if someone upgrading from thrift "renames" all but
+             * the last column alias, the cf will be considered "sparse" and he will be stuck with
+             * that even though that might not be what he wants. But the simple workaround is
+             * for that user to rename all the aliases at the same time in the first place.
+             */
+            AbstractType<?> lastType = types.get(types.size() - 1);
+            if (lastType instanceof ColumnToCollectionType)
+                return false;
+
+            return !(maxIdx == types.size() - 2 && lastType instanceof UTF8Type && !hasNulls);
+        }
+        else
+        {
+            /*
+             * For non-composite, we only need to "detect" case where the CF is clearly used as static.
+             * For that, just check if we have regular columns metadata sets up and no defined clustering key.
+             */
+            return !(hasRegular && maxIdx == -1);
+        }
+    }
+
+    private static <T> List<T> nullInitializedList(int size)
+    {
+        List<T> l = new ArrayList(size);
+        for (int i = 0; i < size; ++i)
+            l.add(null);
+        return l;
+    }
+
     /**
-     * Returns whether this CFMetaData has information non exposed on thrift so
-     * that it cannot be correctly handled automatically by thrift clients.
+     * Returns whether this CFMetaData can be fully translated to a thrift
+     * definition, i.e. if it doesn't store information that have an equivalent
+     * in thrift CfDef.
      */
-    public boolean isThriftIncompatible()
+    public boolean isThriftCompatible()
     {
-        if (isSuper() || !cqlCfDef.isComposite)
-            return false;
+        // Super CF are always "thrift compatible". But since they may have defs with a componentIndex != null,
+        // we have to special case here.
+        if (isSuper())
+            return true;
 
-        for (ColumnDefinition columnDef : column_metadata.values())
+        for (ColumnDefinition def : column_metadata.values())
         {
-            if (columnDef.componentIndex != null)
-                return true;
+            if (!def.isThriftCompatible())
+                return false;
         }
-        return false;
+        return true;
     }
 
     public void validateColumns(Iterable<Column> columns)
@@ -1717,9 +1927,6 @@ public final class CFMetaData
             .append("keyValidator", keyValidator)
             .append("minCompactionThreshold", minCompactionThreshold)
             .append("maxCompactionThreshold", maxCompactionThreshold)
-            .append("keyAliases", keyAliases)
-            .append("columnAliases", columnAliases)
-            .append("valueAlias", valueAlias)
             .append("column_metadata", column_metadata)
             .append("compactionStrategyClass", compactionStrategyClass)
             .append("compactionStrategyOptions", compactionStrategyOptions)
diff --git a/src/java/org/apache/cassandra/config/ColumnDefinition.java b/src/java/org/apache/cassandra/config/ColumnDefinition.java
index 81fce0b882..fed095dbd0 100644
--- a/src/java/org/apache/cassandra/config/ColumnDefinition.java
+++ b/src/java/org/apache/cassandra/config/ColumnDefinition.java
@@ -20,6 +20,7 @@ package org.apache.cassandra.config;
 import java.nio.ByteBuffer;
 import java.util.*;
 
+import com.google.common.base.Objects;
 import com.google.common.collect.Maps;
 
 import org.apache.cassandra.cql3.QueryProcessor;
@@ -37,11 +38,32 @@ import static org.apache.cassandra.utils.FBUtilities.json;
 
 public class ColumnDefinition
 {
+    /*
+     * The type of CQL3 column this definition represents.
+     * There is 3 main type of CQL3 columns: those parts of the partition key,
+     * those parts of the clustering key and the other, regular ones.
+     * But when COMPACT STORAGE is used, there is by design only one regular
+     * column, whose name is not stored in the data contrarily to the column of
+     * type REGULAR. Hence the COMPACT_VALUE type to distinguish it below.
+     *
+     * Note that thrift/CQL2 only know about definitions of type REGULAR (and
+     * the ones whose componentIndex == null).
+     */
+
+    public enum Type
+    {
+        PARTITION_KEY,
+        CLUSTERING_KEY,
+        REGULAR,
+        COMPACT_VALUE;
+    }
+
     public final ByteBuffer name;
     private AbstractType<?> validator;
     private IndexType index_type;
     private Map<String,String> index_options;
     private String index_name;
+    public final Type type;
 
     /*
      * If the column comparator is a composite type, indicates to which
@@ -50,7 +72,32 @@ public class ColumnDefinition
      */
     public final Integer componentIndex;
 
-    public ColumnDefinition(ByteBuffer name, AbstractType<?> validator, IndexType index_type, Map<String, String> index_options, String index_name, Integer componentIndex)
+    public static ColumnDefinition partitionKeyDef(ByteBuffer name, AbstractType<?> validator, Integer componentIndex)
+    {
+        return new ColumnDefinition(name, validator, componentIndex, Type.PARTITION_KEY);
+    }
+
+    public static ColumnDefinition clusteringKeyDef(ByteBuffer name, AbstractType<?> validator, Integer componentIndex)
+    {
+        return new ColumnDefinition(name, validator, componentIndex, Type.CLUSTERING_KEY);
+    }
+
+    public static ColumnDefinition regularDef(ByteBuffer name, AbstractType<?> validator, Integer componentIndex)
+    {
+        return new ColumnDefinition(name, validator, componentIndex, Type.REGULAR);
+    }
+
+    public static ColumnDefinition compactValueDef(ByteBuffer name, AbstractType<?> validator)
+    {
+        return new ColumnDefinition(name, validator, null, Type.COMPACT_VALUE);
+    }
+
+    public ColumnDefinition(ByteBuffer name, AbstractType<?> validator, Integer componentIndex, Type type)
+    {
+        this(name, validator, null, null, null, componentIndex, type);
+    }
+
+    private ColumnDefinition(ByteBuffer name, AbstractType<?> validator, IndexType index_type, Map<String, String> index_options, String index_name, Integer componentIndex, Type type)
     {
         assert name != null && validator != null;
         this.name = name;
@@ -58,11 +105,17 @@ public class ColumnDefinition
         this.validator = validator;
         this.componentIndex = componentIndex;
         this.setIndexType(index_type, index_options);
+        this.type = type;
     }
 
     public ColumnDefinition clone()
     {
-        return new ColumnDefinition(name, validator, index_type, index_options, index_name, componentIndex);
+        return new ColumnDefinition(name, validator, index_type, index_options, index_name, componentIndex, type);
+    }
+
+    public ColumnDefinition cloneWithNewName(ByteBuffer newName)
+    {
+        return new ColumnDefinition(newName, validator, index_type, index_options, index_name, componentIndex, type);
     }
 
     @Override
@@ -74,29 +127,23 @@ public class ColumnDefinition
             return false;
 
         ColumnDefinition that = (ColumnDefinition) o;
-        if (index_name != null ? !index_name.equals(that.index_name) : that.index_name != null)
-            return false;
-        if (index_type != that.index_type)
-            return false;
-        if (index_options != null ? !index_options.equals(that.index_options) : that.index_options != null)
-            return false;
-        if (!name.equals(that.name))
-            return false;
-        if (componentIndex != null ? !componentIndex.equals(that.componentIndex) : that.componentIndex != null)
-            return false;
-        return !(validator != null ? !validator.equals(that.validator) : that.validator != null);
+        return Objects.equal(name, that.name)
+            && Objects.equal(validator, that.validator)
+            && Objects.equal(componentIndex, that.componentIndex)
+            && Objects.equal(index_name, that.index_name)
+            && Objects.equal(index_type, that.index_type)
+            && Objects.equal(index_options, that.index_options);
     }
 
     @Override
     public int hashCode()
     {
-        int result = name != null ? name.hashCode() : 0;
-        result = 31 * result + (validator != null ? validator.hashCode() : 0);
-        result = 31 * result + (index_type != null ? index_type.hashCode() : 0);
-        result = 31 * result + (index_options != null ? index_options.hashCode() : 0);
-        result = 31 * result + (index_name != null ? index_name.hashCode() : 0);
-        result = 31 * result + (componentIndex != null ? componentIndex.hashCode() : 0);
-        return result;
+        return Objects.hashCode(name, validator, componentIndex, index_name, index_type, index_options);
+    }
+
+    public boolean isThriftCompatible()
+    {
+        return type == ColumnDefinition.Type.REGULAR && componentIndex == null;
     }
 
     public ColumnDef toThrift()
@@ -123,7 +170,8 @@ public class ColumnDefinition
                                     thriftColumnDef.index_type,
                                     thriftColumnDef.index_options,
                                     thriftColumnDef.index_name,
-                                    isSuper ? 1 : null);
+                                    isSuper ? 1 : null,
+                                    Type.REGULAR);
     }
 
     public static Map<ByteBuffer, ColumnDefinition> fromThrift(List<ColumnDef> thriftDefs, boolean isSuper) throws SyntaxException, ConfigurationException
@@ -155,6 +203,7 @@ public class ColumnDefinition
         cf.addColumn(DeletedColumn.create(ldt, timestamp, cfName, comparator.getString(name), "index_options"));
         cf.addColumn(DeletedColumn.create(ldt, timestamp, cfName, comparator.getString(name), "index_name"));
         cf.addColumn(DeletedColumn.create(ldt, timestamp, cfName, comparator.getString(name), "component_index"));
+        cf.addColumn(DeletedColumn.create(ldt, timestamp, cfName, comparator.getString(name), "type"));
     }
 
     public void toSchema(RowMutation rm, String cfName, AbstractType<?> comparator, long timestamp)
@@ -171,10 +220,13 @@ public class ColumnDefinition
                                         : Column.create(index_name, timestamp, cfName, comparator.getString(name), "index_name"));
         cf.addColumn(componentIndex == null ? DeletedColumn.create(ldt, timestamp, cfName, comparator.getString(name), "component_index")
                                             : Column.create(componentIndex, timestamp, cfName, comparator.getString(name), "component_index"));
+        cf.addColumn(Column.create(type.toString().toLowerCase(), timestamp, cfName, comparator.getString(name), "type"));
     }
 
     public void apply(ColumnDefinition def, AbstractType<?> comparator)  throws ConfigurationException
     {
+        assert type == def.type && Objects.equal(componentIndex, def.componentIndex);
+
         if (getIndexType() != null && def.getIndexType() != null)
         {
             // If an index is set (and not drop by this update), the validator shouldn't be change to a non-compatible one
@@ -186,10 +238,6 @@ public class ColumnDefinition
                 throw new ConfigurationException("Cannot modify index name");
         }
 
-        if ((componentIndex != null && !componentIndex.equals(def.componentIndex))
-         || (componentIndex == null && def.componentIndex != null))
-            throw new ConfigurationException(String.format("Cannot modify component index for column %s", comparator.getString(name)));
-
         setValidator(def.getValidator());
         setIndexType(def.getIndexType(), def.getIndexOptions());
         setIndexName(def.getIndexName());
@@ -228,12 +276,17 @@ public class ColumnDefinition
                 else if (cfm.isSuper())
                     componentIndex = 1;
 
-                cds.add(new ColumnDefinition(cfm.getColumnDefinitionComparator(componentIndex).fromString(result.getString("column_name")),
+                Type type = result.has("type")
+                          ? Enum.valueOf(Type.class, result.getString("type").toUpperCase())
+                          : Type.REGULAR;
+
+                cds.add(new ColumnDefinition(cfm.getComponentComparator(componentIndex, type).fromString(result.getString("column_name")),
                                              TypeParser.parse(result.getString("validator")),
                                              index_type,
                                              index_options,
                                              index_name,
-                                             componentIndex));
+                                             componentIndex,
+                                             type));
             }
             catch (RequestValidationException e)
             {
@@ -265,6 +318,7 @@ public class ColumnDefinition
                ", index_type=" + index_type +
                ", index_name='" + index_name + '\'' +
                (componentIndex != null ? ", component_index=" + componentIndex : "") +
+               ", type=" + type +
                '}';
     }
 
@@ -273,15 +327,27 @@ public class ColumnDefinition
         return index_name;
     }
 
-    public void setIndexName(String s)
+    public ColumnDefinition setIndexName(String s)
     {
-        index_name = s;
+        this.index_name = s;
+        return this;
     }
 
-    public void setIndexType(IndexType index_type, Map<String,String> index_options)
+    public ColumnDefinition setIndexType(IndexType index_type, Map<String,String> index_options)
     {
         this.index_type = index_type;
         this.index_options = index_options;
+        return this;
+    }
+
+    public ColumnDefinition setIndex(String s, IndexType index_type, Map<String,String> index_options)
+    {
+        return setIndexName(s).setIndexType(index_type, index_options);
+    }
+
+    public boolean isIndexed()
+    {
+        return index_type != null;
     }
 
     public IndexType getIndexType()
@@ -303,18 +369,4 @@ public class ColumnDefinition
     {
         this.validator = validator;
     }
-
-    public static Map<String,String> getStringMap(Map<CharSequence, CharSequence> charMap)
-    {
-        if (charMap == null)
-            return null;
-
-        Map<String,String> stringMap = new HashMap<String, String>();
-
-        for (Map.Entry<CharSequence, CharSequence> entry : charMap.entrySet())
-            stringMap.put(entry.getKey().toString(), entry.getValue().toString());
-
-
-        return stringMap;
-    }
 }
diff --git a/src/java/org/apache/cassandra/config/KSMetaData.java b/src/java/org/apache/cassandra/config/KSMetaData.java
index 1e58864c24..e8b9e0629b 100644
--- a/src/java/org/apache/cassandra/config/KSMetaData.java
+++ b/src/java/org/apache/cassandra/config/KSMetaData.java
@@ -183,7 +183,7 @@ public final class KSMetaData
         for (CFMetaData cfm : cfMetaData().values())
         {
             // Don't expose CF that cannot be correctly handle by thrift; see CASSANDRA-4377 for further details
-            if (!cfm.isThriftIncompatible())
+            if (cfm.isThriftCompatible())
                 cfDefs.add(cfm.toThrift());
         }
         KsDef ksdef = new KsDef(name, strategyClass.getName(), cfDefs);
@@ -311,7 +311,11 @@ public final class KSMetaData
         {
             Row columnRow = ColumnDefinition.readSchema(cfm.ksName, cfm.cfName);
             for (ColumnDefinition cd : ColumnDefinition.fromSchema(columnRow, cfm))
-                cfm.column_metadata.put(cd.name, cd);
+            {
+                // This may replace some existing definition coming from the old key, column and
+                // value aliases. But that's what we want (see CFMetaData.fromSchemaNoColumns).
+                cfm.addOrReplaceColumnDefinition(cd);
+            }
         }
 
         return cfms;
diff --git a/src/java/org/apache/cassandra/cql/AlterTableStatement.java b/src/java/org/apache/cassandra/cql/AlterTableStatement.java
index a70638ea91..1f48c1ef21 100644
--- a/src/java/org/apache/cassandra/cql/AlterTableStatement.java
+++ b/src/java/org/apache/cassandra/cql/AlterTableStatement.java
@@ -74,22 +74,13 @@ public class AlterTableStatement
         switch (oType)
         {
             case ADD:
-                if (!cfm.getKeyAliases().isEmpty() && cfm.getKeyAliases().contains(columnName))
-                    throw new InvalidRequestException("Invalid column name: "
-                                                      + this.columnName
-                                                      + ", because it equals to a key alias.");
-
-                cfm.addColumnDefinition(new ColumnDefinition(columnName,
-                                                             TypeParser.parse(validator),
-                                                             null,
-                                                             null,
-                                                             null,
-                                                             null));
+                cfm.addColumnDefinition(ColumnDefinition.regularDef(columnName, TypeParser.parse(validator), null));
                 break;
 
             case ALTER:
                 // We only look for the first key alias which is ok for CQL2
-                if (!cfm.getKeyAliases().isEmpty() && cfm.getKeyAliases().get(0).equals(columnName))
+                ColumnDefinition partionKeyDef = cfm.partitionKeyColumns().get(0);
+                if (partionKeyDef != null && partionKeyDef.name.equals(columnName))
                 {
                     cfm.keyValidator(TypeParser.parse(validator));
                 }
@@ -97,7 +88,7 @@ public class AlterTableStatement
                 {
                     ColumnDefinition toUpdate = null;
 
-                    for (ColumnDefinition columnDef : cfm.getColumn_metadata().values())
+                    for (ColumnDefinition columnDef : cfm.regularColumns())
                     {
                         if (columnDef.name.equals(columnName))
                         {
@@ -118,7 +109,7 @@ public class AlterTableStatement
             case DROP:
                 ColumnDefinition toDelete = null;
 
-                for (ColumnDefinition columnDef : cfm.getColumn_metadata().values())
+                for (ColumnDefinition columnDef : cfm.regularColumns())
                 {
                     if (columnDef.name.equals(columnName))
                     {
diff --git a/src/java/org/apache/cassandra/cql/CreateColumnFamilyStatement.java b/src/java/org/apache/cassandra/cql/CreateColumnFamilyStatement.java
index 1dee739fd8..00d8352c0a 100644
--- a/src/java/org/apache/cassandra/cql/CreateColumnFamilyStatement.java
+++ b/src/java/org/apache/cassandra/cql/CreateColumnFamilyStatement.java
@@ -135,7 +135,7 @@ public class CreateColumnFamilyStatement
                                           ? CFPropDefs.comparators.get(col.getValue())
                                           : col.getValue();
                 AbstractType<?> validator = TypeParser.parse(validatorClassName);
-                columnDefs.put(columnName, new ColumnDefinition(columnName, validator, null, null, null, null));
+                columnDefs.put(columnName, ColumnDefinition.regularDef(columnName, validator, null));
             }
             catch (ConfigurationException e)
             {
@@ -202,7 +202,7 @@ public class CreateColumnFamilyStatement
 
             // CQL2 can have null keyAliases
             if (keyAlias != null)
-                newCFMD.keyAliases(Collections.<ByteBuffer>singletonList(keyAlias));
+                newCFMD.addColumnDefinition(ColumnDefinition.partitionKeyDef(keyAlias, newCFMD.getKeyValidator(), null));
         }
         catch (ConfigurationException e)
         {
diff --git a/src/java/org/apache/cassandra/cql/DropIndexStatement.java b/src/java/org/apache/cassandra/cql/DropIndexStatement.java
index 502bdb038e..b9f4e5e7a7 100644
--- a/src/java/org/apache/cassandra/cql/DropIndexStatement.java
+++ b/src/java/org/apache/cassandra/cql/DropIndexStatement.java
@@ -50,7 +50,7 @@ public class DropIndexStatement
         ColumnDefinition column = findIndexedColumn(cfm);
         assert column != null;
         CFMetaData cloned = cfm.clone();
-        ColumnDefinition toChange = cloned.getColumn_metadata().get(column.name);
+        ColumnDefinition toChange = cloned.getColumnDefinition(column.name);
         assert toChange.getIndexName() != null && toChange.getIndexName().equals(indexName);
         toChange.setIndexName(null);
         toChange.setIndexType(null, null);
@@ -70,7 +70,7 @@ public class DropIndexStatement
 
     private ColumnDefinition findIndexedColumn(CFMetaData cfm)
     {
-        for (ColumnDefinition column : cfm.getColumn_metadata().values())
+        for (ColumnDefinition column : cfm.regularColumns())
         {
             if (column.getIndexType() != null && column.getIndexName() != null && column.getIndexName().equals(indexName))
                 return column;
diff --git a/src/java/org/apache/cassandra/cql/QueryProcessor.java b/src/java/org/apache/cassandra/cql/QueryProcessor.java
index b36564469b..cf2231b016 100644
--- a/src/java/org/apache/cassandra/cql/QueryProcessor.java
+++ b/src/java/org/apache/cassandra/cql/QueryProcessor.java
@@ -650,7 +650,7 @@ public class QueryProcessor
                 ByteBuffer columnName = createIdx.getColumnName().getByteBuffer();
                 // mutating oldCfm directly would be bad, but mutating a copy is fine.
                 CFMetaData cfm = oldCfm.clone();
-                for (ColumnDefinition cd : cfm.getColumn_metadata().values())
+                for (ColumnDefinition cd : cfm.regularColumns())
                 {
                     if (cd.name.equals(columnName))
                     {
@@ -670,7 +670,7 @@ public class QueryProcessor
                 try
                 {
                     cfm.addDefaultIndexNames();
-                    MigrationManager.announceColumnFamilyUpdate(cfm);
+                    MigrationManager.announceColumnFamilyUpdate(cfm, true); // As far as metadata are concerned, CQL2 == thrift
                 }
                 catch (ConfigurationException e)
                 {
@@ -691,7 +691,7 @@ public class QueryProcessor
                 try
                 {
                     CFMetaData updatedCF = dropIdx.generateCFMetadataUpdate();
-                    MigrationManager.announceColumnFamilyUpdate(updatedCF);
+                    MigrationManager.announceColumnFamilyUpdate(updatedCF, true); // As far as metadata are concerned, CQL2 == thrift
                 }
                 catch (ConfigurationException e)
                 {
@@ -748,7 +748,7 @@ public class QueryProcessor
 
                 try
                 {
-                    MigrationManager.announceColumnFamilyUpdate(alterTable.getCFMetaData(keyspace));
+                    MigrationManager.announceColumnFamilyUpdate(alterTable.getCFMetaData(keyspace), true); // As far as metadata are concerned, CQL2 == thrift
                 }
                 catch (ConfigurationException e)
                 {
diff --git a/src/java/org/apache/cassandra/cql3/CFDefinition.java b/src/java/org/apache/cassandra/cql3/CFDefinition.java
index e0e5aef9e6..ebb4e2c10a 100644
--- a/src/java/org/apache/cassandra/cql3/CFDefinition.java
+++ b/src/java/org/apache/cassandra/cql3/CFDefinition.java
@@ -65,137 +65,59 @@ public class CFDefinition implements Iterable<CFDefinition.Name>
     {
         this.cfm = cfm;
 
-        if (cfm.getKeyValidator() instanceof CompositeType)
+        this.hasCompositeKey = cfm.getKeyValidator() instanceof CompositeType;
+        for (int i = 0; i < cfm.partitionKeyColumns().size(); ++i)
         {
-            this.hasCompositeKey = true;
-            CompositeType keyComposite = (CompositeType)cfm.getKeyValidator();
-            assert keyComposite.types.size() > 1;
-            for (int i = 0; i < keyComposite.types.size(); i++)
-            {
-                ColumnIdentifier id = getKeyId(cfm, i);
-                this.keys.put(id, new Name(cfm.ksName, cfm.cfName, id, Name.Kind.KEY_ALIAS, i, keyComposite.types.get(i)));
-            }
+            ColumnIdentifier id = getKeyId(cfm, i);
+            this.keys.put(id, new Name(cfm.ksName, cfm.cfName, id, Name.Kind.KEY_ALIAS, i, cfm.getKeyValidator().getComponents().get(i)));
         }
-        else
+
+        this.isComposite = cfm.comparator instanceof CompositeType;
+        this.hasCollections = cfm.comparator.getComponents().get(cfm.comparator.componentsCount() - 1) instanceof ColumnToCollectionType;
+        this.isCompact = cfm.clusteringKeyColumns().size() == cfm.comparator.componentsCount();
+        for (int i = 0; i < cfm.clusteringKeyColumns().size(); ++i)
         {
-            this.hasCompositeKey = false;
-            ColumnIdentifier id = getKeyId(cfm, 0);
-            this.keys.put(id, new Name(cfm.ksName, cfm.cfName, id, Name.Kind.KEY_ALIAS, 0, cfm.getKeyValidator()));
+            ColumnIdentifier id = getColumnId(cfm, i);
+            this.columns.put(id, new Name(cfm.ksName, cfm.cfName, id, Name.Kind.COLUMN_ALIAS, i, cfm.comparator.getComponents().get(i)));
         }
 
-        if (cfm.comparator instanceof CompositeType)
+        if (isCompact)
         {
-            this.isComposite = true;
-            CompositeType composite = (CompositeType)cfm.comparator;
-            /*
-             * We are a "sparse" composite, i.e. a non-compact one, if either:
-             *   - the last type of the composite is a ColumnToCollectionType
-             *   - or we have one less alias than of composite types and the last type is UTF8Type.
-             *   - some metadata are defined
-             *
-             * Note that this is not perfect: if someone upgrading from thrift "renames" all but
-             * the last column alias, the cf will be considered "sparse" and he will be stuck with
-             * that even though that might not be what he wants. But the simple workaround is
-             * for that user to rename all the aliases at the same time in the first place.
-             */
-            int last = composite.types.size() - 1;
-            AbstractType<?> lastType = composite.types.get(last);
-            if (!cfm.getColumn_metadata().isEmpty()
-                || lastType instanceof ColumnToCollectionType
-                || (cfm.getColumnAliases().size() == last && lastType instanceof UTF8Type))
-            {
-                // "sparse" composite
-                this.isCompact = false;
-                this.value = null;
-                assert cfm.getValueAlias() == null;
-                // check for collection type
-                if (lastType instanceof ColumnToCollectionType)
-                {
-                    --last;
-                    this.hasCollections = true;
-                }
-                else
-                {
-                    this.hasCollections = false;
-                }
-
-                for (int i = 0; i < last; i++)
-                {
-                    ColumnIdentifier id = getColumnId(cfm, i);
-                    this.columns.put(id, new Name(cfm.ksName, cfm.cfName, id, Name.Kind.COLUMN_ALIAS, i, composite.types.get(i)));
-                }
-
-                for (Map.Entry<ByteBuffer, ColumnDefinition> def : cfm.getColumn_metadata().entrySet())
-                {
-                    ColumnIdentifier id = new ColumnIdentifier(def.getKey(), cfm.getColumnDefinitionComparator(def.getValue()));
-                    this.metadata.put(id, new Name(cfm.ksName, cfm.cfName, id, Name.Kind.COLUMN_METADATA, def.getValue().getValidator()));
-                }
-            }
-            else
-            {
-                // "dense" composite
-                this.isCompact = true;
-                this.hasCollections = false;
-                for (int i = 0; i < composite.types.size(); i++)
-                {
-                    ColumnIdentifier id = getColumnId(cfm, i);
-                    this.columns.put(id, new Name(cfm.ksName, cfm.cfName, id, Name.Kind.COLUMN_ALIAS, i, composite.types.get(i)));
-                }
-                this.value = createValue(cfm);
-            }
+            this.value = createValue(cfm);
         }
         else
         {
-            this.isComposite = false;
-            this.hasCollections = false;
-            if (!cfm.getColumnAliases().isEmpty() || cfm.getColumn_metadata().isEmpty())
+            this.value = null;
+            for (ColumnDefinition def : cfm.regularColumns())
             {
-                // dynamic CF
-                this.isCompact = true;
-                ColumnIdentifier id = getColumnId(cfm, 0);
-                Name name = new Name(cfm.ksName, cfm.cfName, id, Name.Kind.COLUMN_ALIAS, 0, cfm.comparator);
-                this.columns.put(id, name);
-                this.value = createValue(cfm);
-            }
-            else
-            {
-                // static CF
-                this.isCompact = false;
-                this.value = null;
-                assert cfm.getValueAlias() == null;
-                assert cfm.getColumnAliases() == null || cfm.getColumnAliases().isEmpty();
-                for (Map.Entry<ByteBuffer, ColumnDefinition> def : cfm.getColumn_metadata().entrySet())
-                {
-                    ColumnIdentifier id = new ColumnIdentifier(def.getKey(), cfm.getColumnDefinitionComparator(def.getValue()));
-                    this.metadata.put(id, new Name(cfm.ksName, cfm.cfName, id, Name.Kind.COLUMN_METADATA, def.getValue().getValidator()));
-                }
+                ColumnIdentifier id = new ColumnIdentifier(def.name, cfm.getColumnDefinitionComparator(def));
+                this.metadata.put(id, new Name(cfm.ksName, cfm.cfName, id, Name.Kind.COLUMN_METADATA, def.getValidator()));
             }
         }
-        assert value == null || metadata.isEmpty();
     }
 
     private static ColumnIdentifier getKeyId(CFMetaData cfm, int i)
     {
-        List<ByteBuffer> definedNames = cfm.getKeyAliases();
+        List<ColumnDefinition> definedNames = cfm.partitionKeyColumns();
         // For compatibility sake, non-composite key default alias is 'key', not 'key1'.
-        return definedNames == null || i >= definedNames.size() || cfm.getKeyAliases().get(i) == null
+        return definedNames == null || i >= definedNames.size() || definedNames.get(i) == null
              ? new ColumnIdentifier(i == 0 ? DEFAULT_KEY_ALIAS : DEFAULT_KEY_ALIAS + (i + 1), false)
-             : new ColumnIdentifier(cfm.getKeyAliases().get(i), definitionType);
+             : new ColumnIdentifier(definedNames.get(i).name, definitionType);
     }
 
     private static ColumnIdentifier getColumnId(CFMetaData cfm, int i)
     {
-        List<ByteBuffer> definedNames = cfm.getColumnAliases();
-        return definedNames == null || i >= definedNames.size() || cfm.getColumnAliases().get(i) == null
+        List<ColumnDefinition> definedNames = cfm.clusteringKeyColumns();
+        return definedNames == null || i >= definedNames.size() || definedNames.get(i) == null
              ? new ColumnIdentifier(DEFAULT_COLUMN_ALIAS + (i + 1), false)
-             : new ColumnIdentifier(cfm.getColumnAliases().get(i), definitionType);
+             : new ColumnIdentifier(definedNames.get(i).name, definitionType);
     }
 
     private static ColumnIdentifier getValueId(CFMetaData cfm)
     {
-        return cfm.getValueAlias() == null
+        return cfm.compactValueColumn() == null
              ? new ColumnIdentifier(DEFAULT_VALUE_ALIAS, false)
-             : new ColumnIdentifier(cfm.getValueAlias(), definitionType);
+             : new ColumnIdentifier(cfm.compactValueColumn().name, definitionType);
     }
 
     public ColumnToCollectionType getCollectionType()
@@ -367,6 +289,14 @@ public class CFDefinition implements Iterable<CFDefinition.Name>
             return columnName == null ? 1 : 0;
         }
 
+        public ByteBuffer get(int i)
+        {
+            if (i < 0 || i >= (columnName == null ? 0 : 1))
+                throw new IllegalArgumentException();
+
+            return columnName;
+        }
+
         public ByteBuffer build()
         {
             return columnName == null ? ByteBufferUtil.EMPTY_BYTE_BUFFER : columnName;
@@ -383,5 +313,13 @@ public class CFDefinition implements Iterable<CFDefinition.Name>
             newBuilder.columnName = columnName;
             return newBuilder;
         }
+
+        public ByteBuffer getComponent(int i)
+        {
+            if (i != 0 || columnName == null)
+                throw new IllegalArgumentException();
+
+            return columnName;
+        }
     }
 }
diff --git a/src/java/org/apache/cassandra/cql3/ColumnNameBuilder.java b/src/java/org/apache/cassandra/cql3/ColumnNameBuilder.java
index f7a67de41c..7f14c7af5a 100644
--- a/src/java/org/apache/cassandra/cql3/ColumnNameBuilder.java
+++ b/src/java/org/apache/cassandra/cql3/ColumnNameBuilder.java
@@ -55,6 +55,11 @@ public interface ColumnNameBuilder
      */
     public int remainingCount();
 
+    /**
+     * @return the ith component in this builder.
+     */
+    public ByteBuffer get(int idx);
+
     /**
      * Build the column name.
      * @return the built column name
@@ -73,4 +78,14 @@ public interface ColumnNameBuilder
      * @return the cloned builder.
      */
     public ColumnNameBuilder copy();
+
+    /**
+     * Returns the ith component added to this builder.
+     *
+     * @param i the component to return
+     * @return the ith component added to this builder.
+     * @throws IllegalArgumentException if i >= componentCount().
+     */
+    public ByteBuffer getComponent(int i);
+
 }
diff --git a/src/java/org/apache/cassandra/cql3/statements/AlterTableStatement.java b/src/java/org/apache/cassandra/cql3/statements/AlterTableStatement.java
index 51b9896a0f..ef15691916 100644
--- a/src/java/org/apache/cassandra/cql3/statements/AlterTableStatement.java
+++ b/src/java/org/apache/cassandra/cql3/statements/AlterTableStatement.java
@@ -112,12 +112,7 @@ public class AlterTableStatement extends SchemaAlteringStatement
                 Integer componentIndex = cfDef.isComposite
                                        ? ((CompositeType)meta.comparator).types.size() - (cfDef.hasCollections ? 2 : 1)
                                        : null;
-                cfm.addColumnDefinition(new ColumnDefinition(columnName.key,
-                                                             type,
-                                                             null,
-                                                             null,
-                                                             null,
-                                                             componentIndex));
+                cfm.addColumnDefinition(ColumnDefinition.regularDef(columnName.key, type, componentIndex));
                 break;
 
             case ALTER:
@@ -153,7 +148,6 @@ public class AlterTableStatement extends SchemaAlteringStatement
                     case COLUMN_METADATA:
                         ColumnDefinition column = cfm.getColumnDefinition(columnName.key);
                         column.setValidator(validator.getType());
-                        cfm.addColumnDefinition(column);
                         break;
                 }
                 break;
@@ -171,7 +165,7 @@ public class AlterTableStatement extends SchemaAlteringStatement
                         throw new InvalidRequestException(String.format("Cannot drop PRIMARY KEY part %s", columnName));
                     case COLUMN_METADATA:
                         ColumnDefinition toDelete = null;
-                        for (ColumnDefinition columnDef : cfm.getColumn_metadata().values())
+                        for (ColumnDefinition columnDef : cfm.regularColumns())
                         {
                             if (columnDef.name.equals(columnName.key))
                                 toDelete = columnDef;
@@ -191,52 +185,14 @@ public class AlterTableStatement extends SchemaAlteringStatement
             case RENAME:
                 for (Map.Entry<ColumnIdentifier, ColumnIdentifier> entry : renames.entrySet())
                 {
-                    CFDefinition.Name from = cfDef.get(entry.getKey());
+                    ColumnIdentifier from = entry.getKey();
                     ColumnIdentifier to = entry.getValue();
-                    if (from == null)
-                        throw new InvalidRequestException(String.format("Column %s was not found in table %s", entry.getKey(), columnFamily()));
-
-                    CFDefinition.Name exists = cfDef.get(to);
-                    if (exists != null)
-                        throw new InvalidRequestException(String.format("Cannot rename column %s in table %s to %s; another column of that name already exist", from, columnFamily(), to));
-
-                    switch (from.kind)
-                    {
-                        case KEY_ALIAS:
-                            cfm.keyAliases(rename(from.position, to, cfm.getKeyAliases()));
-                            break;
-                        case COLUMN_ALIAS:
-                            cfm.columnAliases(rename(from.position, to, cfm.getColumnAliases()));
-                            break;
-                        case VALUE_ALIAS:
-                            cfm.valueAlias(to.key);
-                            break;
-                        case COLUMN_METADATA:
-                            throw new InvalidRequestException(String.format("Cannot rename non PRIMARY KEY part %s", from));
-                    }
+                    cfm.renameColumn(from.key, from.toString(), to.key, to.toString());
                 }
                 break;
         }
 
-        MigrationManager.announceColumnFamilyUpdate(cfm);
-    }
-
-    private static List<ByteBuffer> rename(int pos, ColumnIdentifier newName, List<ByteBuffer> aliases)
-    {
-        if (pos < aliases.size())
-        {
-            List<ByteBuffer> newList = new ArrayList<ByteBuffer>(aliases);
-            newList.set(pos, newName.key);
-            return newList;
-        }
-        else
-        {
-            List<ByteBuffer> newList = new ArrayList<ByteBuffer>(pos + 1);
-            for (int i = 0; i < pos; ++i)
-                newList.add(i < aliases.size() ? aliases.get(i) : null);
-            newList.add(newName.key);
-            return newList;
-        }
+        MigrationManager.announceColumnFamilyUpdate(cfm, false);
     }
 
     public String toString()
diff --git a/src/java/org/apache/cassandra/cql3/statements/CreateColumnFamilyStatement.java b/src/java/org/apache/cassandra/cql3/statements/CreateColumnFamilyStatement.java
index f2c3d6abf3..1648fcb2bb 100644
--- a/src/java/org/apache/cassandra/cql3/statements/CreateColumnFamilyStatement.java
+++ b/src/java/org/apache/cassandra/cql3/statements/CreateColumnFamilyStatement.java
@@ -93,7 +93,7 @@ public class CreateColumnFamilyStatement extends SchemaAlteringStatement
 
         for (Map.Entry<ColumnIdentifier, AbstractType> col : columns.entrySet())
         {
-            columnDefs.put(col.getKey().key, new ColumnDefinition(col.getKey().key, col.getValue(), null, null, null, componentIndex));
+            columnDefs.put(col.getKey().key, ColumnDefinition.regularDef(col.getKey().key, col.getValue(), componentIndex));
         }
 
         return columnDefs;
@@ -131,11 +131,13 @@ public class CreateColumnFamilyStatement extends SchemaAlteringStatement
     public void applyPropertiesTo(CFMetaData cfmd) throws RequestValidationException
     {
         cfmd.defaultValidator(defaultValidator)
-            .columnMetadata(getColumns())
             .keyValidator(keyValidator)
-            .keyAliases(keyAliases)
-            .columnAliases(columnAliases)
-            .valueAlias(valueAlias);
+            .columnMetadata(getColumns());
+
+        cfmd.addColumnMetadataFromAliases(keyAliases, keyValidator, ColumnDefinition.Type.PARTITION_KEY);
+        cfmd.addColumnMetadataFromAliases(columnAliases, comparator, ColumnDefinition.Type.CLUSTERING_KEY);
+        if (valueAlias != null)
+            cfmd.addColumnMetadataFromAliases(Collections.<ByteBuffer>singletonList(valueAlias), defaultValidator, ColumnDefinition.Type.COMPACT_VALUE);
 
         properties.applyToCFMetadata(cfmd);
     }
diff --git a/src/java/org/apache/cassandra/cql3/statements/CreateIndexStatement.java b/src/java/org/apache/cassandra/cql3/statements/CreateIndexStatement.java
index 4e0f536782..1acd475efb 100644
--- a/src/java/org/apache/cassandra/cql3/statements/CreateIndexStatement.java
+++ b/src/java/org/apache/cassandra/cql3/statements/CreateIndexStatement.java
@@ -67,24 +67,29 @@ public class CreateIndexStatement extends SchemaAlteringStatement
         CFMetaData cfm = oldCfm.clone();
         CFDefinition cfDef = oldCfm.getCfDef();
 
-        for (ColumnDefinition cd : cfm.getColumn_metadata().values())
+        for (ColumnDefinition cd : cfm.allColumns())
         {
             if (cd.name.equals(columnName.key))
             {
                 if (cd.getIndexType() != null)
                     throw new InvalidRequestException("Index already exists");
-                if (logger.isDebugEnabled())
-                    logger.debug("Updating column {} definition for index {}", columnName, indexName);
+
+                if (cd.type == ColumnDefinition.Type.PARTITION_KEY && (cd.componentIndex == null || cd.componentIndex == 0))
+                    throw new InvalidRequestException(String.format("Cannot add secondary index to already primarily indexed column %s", columnName));
+
+                // TODO: we could lift that limitation
+                if (cfDef.isCompact && cd.type != ColumnDefinition.Type.REGULAR)
+                    throw new InvalidRequestException(String.format("Secondary index on %s column %s is not yet supported for compact table", cd.type, columnName));
 
                 if (cd.getValidator().isCollection())
                     throw new InvalidRequestException("Indexes on collections are no yet supported");
 
+                if (logger.isDebugEnabled())
+                    logger.debug("Updating column {} definition for index {}", columnName, indexName);
+
                 if (cfDef.isComposite)
                 {
-                    CompositeType composite = (CompositeType)cfm.comparator;
-                    Map<String, String> opts = new HashMap<String, String>();
-                    opts.put(CompositesIndex.PREFIX_SIZE_OPTION, String.valueOf(composite.types.size() - (cfDef.hasCollections ? 2 : 1)));
-                    cd.setIndexType(IndexType.COMPOSITES, opts);
+                    cd.setIndexType(IndexType.COMPOSITES, Collections.<String, String>emptyMap());
                 }
                 else
                 {
@@ -113,7 +118,7 @@ public class CreateIndexStatement extends SchemaAlteringStatement
         }
 
         cfm.addDefaultIndexNames();
-        MigrationManager.announceColumnFamilyUpdate(cfm);
+        MigrationManager.announceColumnFamilyUpdate(cfm, false);
     }
 
     public ResultMessage.SchemaChange.Change changeType()
diff --git a/src/java/org/apache/cassandra/cql3/statements/DropIndexStatement.java b/src/java/org/apache/cassandra/cql3/statements/DropIndexStatement.java
index 6edb551163..c8c34e02c1 100644
--- a/src/java/org/apache/cassandra/cql3/statements/DropIndexStatement.java
+++ b/src/java/org/apache/cassandra/cql3/statements/DropIndexStatement.java
@@ -52,7 +52,7 @@ public class DropIndexStatement extends SchemaAlteringStatement
     public void announceMigration() throws InvalidRequestException, ConfigurationException
     {
         CFMetaData updatedCfm = updateCFMetadata(findIndexedCF());
-        MigrationManager.announceColumnFamilyUpdate(updatedCfm);
+        MigrationManager.announceColumnFamilyUpdate(updatedCfm, false);
     }
 
     private CFMetaData updateCFMetadata(CFMetaData cfm) throws InvalidRequestException
@@ -60,7 +60,7 @@ public class DropIndexStatement extends SchemaAlteringStatement
         ColumnDefinition column = findIndexedColumn(cfm);
         assert column != null;
         CFMetaData cloned = cfm.clone();
-        ColumnDefinition toChange = cloned.getColumn_metadata().get(column.name);
+        ColumnDefinition toChange = cloned.getColumnDefinition(column.name);
         assert toChange.getIndexName() != null && toChange.getIndexName().equals(indexName);
         toChange.setIndexName(null);
         toChange.setIndexType(null, null);
@@ -80,7 +80,7 @@ public class DropIndexStatement extends SchemaAlteringStatement
 
     private ColumnDefinition findIndexedColumn(CFMetaData cfm)
     {
-        for (ColumnDefinition column : cfm.getColumn_metadata().values())
+        for (ColumnDefinition column : cfm.allColumns())
         {
             if (column.getIndexType() != null && column.getIndexName() != null && column.getIndexName().equals(indexName))
                 return column;
diff --git a/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java b/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
index f05e6f5ff4..d2c35e93ee 100644
--- a/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
+++ b/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
@@ -67,12 +67,16 @@ public class SelectStatement implements CQLStatement
     private final Restriction[] keyRestrictions;
     private final Restriction[] columnRestrictions;
     private final Map<CFDefinition.Name, Restriction> metadataRestrictions = new HashMap<CFDefinition.Name, Restriction>();
+
+    // The name of all restricted names not covered by the key or index filter
+    private final Set<CFDefinition.Name> restrictedNames = new HashSet<CFDefinition.Name>();
     private Restriction sliceRestriction;
 
     private boolean isReversed;
     private boolean onToken;
     private boolean isKeyRange;
     private boolean keyIsInRelation;
+    private boolean usesSecondaryIndexing;
 
     private static enum Bound
     {
@@ -123,7 +127,7 @@ public class SelectStatement implements CQLStatement
 
         cl.validateForRead(keyspace());
 
-        List<Row> rows = isKeyRange
+        List<Row> rows = isKeyRange || usesSecondaryIndexing
                        ? StorageProxy.getRangeSlice(getRangeCommand(variables), cl)
                        : StorageProxy.read(getSliceCommands(variables), cl);
 
@@ -151,7 +155,7 @@ public class SelectStatement implements CQLStatement
     {
         try
         {
-            List<Row> rows = isKeyRange
+            List<Row> rows = isKeyRange || usesSecondaryIndexing
                            ? RangeSliceVerbHandler.executeLocally(getRangeCommand(Collections.<ByteBuffer>emptyList()))
                            : readLocally(keyspace(), getSliceCommands(Collections.<ByteBuffer>emptyList()));
 
@@ -552,14 +556,28 @@ public class SelectStatement implements CQLStatement
 
     private List<IndexExpression> getIndexExpressions(List<ByteBuffer> variables) throws InvalidRequestException
     {
-        if (metadataRestrictions.isEmpty())
+        if (!usesSecondaryIndexing || restrictedNames.isEmpty())
             return Collections.<IndexExpression>emptyList();
 
         List<IndexExpression> expressions = new ArrayList<IndexExpression>();
-        for (Map.Entry<CFDefinition.Name, Restriction> entry : metadataRestrictions.entrySet())
+        for (CFDefinition.Name name : restrictedNames)
         {
-            CFDefinition.Name name = entry.getKey();
-            Restriction restriction = entry.getValue();
+            Restriction restriction;
+            switch (name.kind)
+            {
+                case KEY_ALIAS:
+                    restriction = keyRestrictions[name.position];
+                    break;
+                case COLUMN_ALIAS:
+                    restriction = columnRestrictions[name.position];
+                    break;
+                case COLUMN_METADATA:
+                    restriction = metadataRestrictions.get(name);
+                    break;
+                default:
+                    // We don't allow restricting a VALUE_ALIAS for now in prepare.
+                    throw new AssertionError();
+            }
             if (restriction.isEquality())
             {
                 for (Term t : restriction.eqValues)
@@ -871,6 +889,22 @@ public class SelectStatement implements CQLStatement
         return true;
     }
 
+    private boolean hasIndexedColumnRestricted(List<ColumnDefinition> columns, Restriction[] restrictions)
+    {
+        assert columns.size() == restrictions.length;
+        for (int i = 0; i < columns.size(); ++i)
+        {
+            Restriction restriction = restrictions[i];
+            if (restriction == null)
+                continue;
+
+            ColumnDefinition def = columns.get(i);
+            if (def != null && def.isIndexed())
+                return true;
+        }
+        return false;
+    }
+
     public static class RawStatement extends CFStatement
     {
         private final Parameters parameters;
@@ -915,12 +949,21 @@ public class SelectStatement implements CQLStatement
              *     (we could allow two IN for the same entity but that doesn't seem very useful)
              *   - The value_alias cannot be restricted in any way (we don't support wide rows with indexed value in CQL so far)
              */
+            boolean hasQueriableIndex = false;
             for (Relation rel : whereClause)
             {
                 CFDefinition.Name name = cfDef.get(rel.getEntity());
                 if (name == null)
                     throw new InvalidRequestException(String.format("Undefined name %s in where clause ('%s')", rel.getEntity(), rel));
 
+                ColumnDefinition def = cfDef.cfm.getColumnDefinition(name.name.key);
+                stmt.restrictedNames.add(name);
+                if (def.isIndexed())
+                {
+                    if (rel.operator() == Relation.Type.EQ)
+                        hasQueriableIndex = true;
+                }
+
                 switch (name.kind)
                 {
                     case KEY_ALIAS:
@@ -941,50 +984,18 @@ public class SelectStatement implements CQLStatement
              * At this point, the select statement if fully constructed, but we still have a few things to validate
              */
 
-            // If a component of the PRIMARY KEY is restricted by a non-EQ relation, all preceding
-            // components must have a EQ, and all following must have no restriction
-            boolean shouldBeDone = false;
-            CFDefinition.Name previous = null;
-            Iterator<CFDefinition.Name> iter = cfDef.columns.values().iterator();
-            for (int i = 0; i < stmt.columnRestrictions.length; i++)
-            {
-                CFDefinition.Name cname = iter.next();
-                Restriction restriction = stmt.columnRestrictions[i];
-                if (restriction == null)
-                {
-                    shouldBeDone = true;
-                }
-                else if (shouldBeDone)
-                {
-                    throw new InvalidRequestException(String.format("PRIMARY KEY part %s cannot be restricted (preceding part %s is either not restricted or by a non-EQ relation)", cname, previous));
-                }
-                else if (!restriction.isEquality())
-                {
-                    shouldBeDone = true;
-                    // For non-composite slices, we don't support internally the difference between exclusive and
-                    // inclusive bounds, so we deal with it manually.
-                    if (!cfDef.isComposite && (!restriction.isInclusive(Bound.START) || !restriction.isInclusive(Bound.END)))
-                        stmt.sliceRestriction = restriction;
-                }
-                // We only support IN for the last name so far
-                // TODO: #3885 allows us to extend to other parts (cf. #4762)
-                else if (restriction.eqValues.size() > 1)
-                {
-                    if (i != stmt.columnRestrictions.length - 1)
-                        throw new InvalidRequestException(String.format("PRIMARY KEY part %s cannot be restricted by IN relation", cname));
-                    else if (stmt.selectACollection())
-                        throw new InvalidRequestException(String.format("Cannot restrict PRIMARY KEY part %s by IN relation as a collection is selected by the query", cname));
-                }
-
-                previous = cname;
-            }
+            // If there is a queriable index, no special condition are required on the other restrictions.
+            // But we still need to know 2 things:
+            //   - If we don't have a queriable index, is the query ok
+            //   - Is it queriable without 2ndary index, which is always more efficient
 
             // If a component of the partition key is restricted by a non-EQ relation, all preceding
             // components must have a EQ, and all following must have no restriction
-            shouldBeDone = false;
-            previous = null;
+            boolean shouldBeDone = false;
+            CFDefinition.Name previous = null;
             stmt.keyIsInRelation = false;
-            iter = cfDef.keys.values().iterator();
+            Iterator<CFDefinition.Name> iter = cfDef.keys.values().iterator();
+            int lastRestrictedPartitionKey = stmt.keyRestrictions.length - 1;
             for (int i = 0; i < stmt.keyRestrictions.length; i++)
             {
                 CFDefinition.Name cname = iter.next();
@@ -992,18 +1003,33 @@ public class SelectStatement implements CQLStatement
 
                 if (restriction == null)
                 {
+                    if (!shouldBeDone)
+                        lastRestrictedPartitionKey = i - 1;
+
                     if (stmt.onToken)
                         throw new InvalidRequestException("The token() function must be applied to all partition key components or none of them");
 
                     // Under a non order perserving partitioner, the only time not restricting a key part is allowed is if none are restricted
                     if (!partitioner.preservesOrder() && i > 0 && stmt.keyRestrictions[i-1] != null)
+                    {
+                        if (hasQueriableIndex)
+                        {
+                            stmt.usesSecondaryIndexing = true;
+                            break;
+                        }
                         throw new InvalidRequestException(String.format("Partition key part %s must be restricted since preceding part is", cname));
+                    }
 
                     stmt.isKeyRange = true;
                     shouldBeDone = true;
                 }
                 else if (shouldBeDone)
                 {
+                    if (hasQueriableIndex)
+                    {
+                        stmt.usesSecondaryIndexing = true;
+                        break;
+                    }
                     throw new InvalidRequestException(String.format("partition key part %s cannot be restricted (preceding part %s is either not restricted or by a non-EQ relation)", cname, previous));
                 }
                 else if (restriction.onToken)
@@ -1032,58 +1058,101 @@ public class SelectStatement implements CQLStatement
                 else
                 {
                     if (!partitioner.preservesOrder())
+                    {
+                        if (hasQueriableIndex)
+                        {
+                            stmt.usesSecondaryIndexing = true;
+                            break;
+                        }
                         throw new InvalidRequestException("Only EQ and IN relation are supported on the partition key for random partitioners (unless you use the token() function)");
+                    }
 
                     stmt.isKeyRange = true;
+                    lastRestrictedPartitionKey = i;
                     shouldBeDone = true;
                 }
                 previous = cname;
             }
 
-            // Deal with indexed columns
-            if (!stmt.metadataRestrictions.isEmpty())
+            // If a cluster key column is restricted by a non-EQ relation, all preceding
+            // columns must have a EQ, and all following must have no restriction. Unless
+            // the column is indexed that is.
+            shouldBeDone = false;
+            previous = null;
+            iter = cfDef.columns.values().iterator();
+            int lastRestrictedClusteringKey = stmt.columnRestrictions.length - 1;
+            for (int i = 0; i < stmt.columnRestrictions.length; i++)
             {
-                stmt.isKeyRange = true;
-                boolean hasEq = false;
-                Set<ByteBuffer> indexedNames = new HashSet<ByteBuffer>();
-                indexedNames.add(cfm.getKeyName());
-                for (ColumnDefinition cfdef : cfm.getColumn_metadata().values())
+                CFDefinition.Name cname = iter.next();
+                Restriction restriction = stmt.columnRestrictions[i];
+
+                if (restriction == null)
                 {
-                    if (cfdef.getIndexType() != null)
-                    {
-                        indexedNames.add(cfdef.name);
-                    }
+                    if (!shouldBeDone)
+                        lastRestrictedClusteringKey = i - 1;
+                    shouldBeDone = true;
                 }
-
-                // Note: we cannot use idxManager.indexes() methods because we don't have a complete column name at this point, we only
-                // have the indexed component.
-                for (Map.Entry<CFDefinition.Name, Restriction> entry : stmt.metadataRestrictions.entrySet())
+                else
                 {
-                    Restriction restriction = entry.getValue();
-                    if (!restriction.isEquality())
-                        continue;
-
-                    // We don't support IN for indexed values (basically this would require supporting a form of OR)
-                    if (restriction.eqValues.size() > 1)
-                        throw new InvalidRequestException("Cannot use IN operator on column not part of the PRIMARY KEY");
-
-                    if (indexedNames.contains(entry.getKey().name.key))
+                    if (shouldBeDone)
                     {
-                        hasEq = true;
-                        break;
+                        if (hasQueriableIndex)
+                        {
+                            stmt.usesSecondaryIndexing = true;
+                            break;
+                        }
+                        throw new InvalidRequestException(String.format("PRIMARY KEY part %s cannot be restricted (preceding part %s is either not restricted or by a non-EQ relation)", cname, previous));
+                    }
+                    else if (!restriction.isEquality())
+                    {
+                        lastRestrictedClusteringKey = i;
+                        shouldBeDone = true;
+                        // For non-composite slices, we don't support internally the difference between exclusive and
+                        // inclusive bounds, so we deal with it manually.
+                        if (!cfDef.isComposite && (!restriction.isInclusive(Bound.START) || !restriction.isInclusive(Bound.END)))
+                            stmt.sliceRestriction = restriction;
+                    }
+                    // We only support IN for the last name and for compact storage so far
+                    // TODO: #3885 allows us to extend to non compact as well, but that remains to be done
+                    else if (restriction.eqValues.size() > 1)
+                    {
+                        if (i != stmt.columnRestrictions.length - 1)
+                            throw new InvalidRequestException(String.format("PRIMARY KEY part %s cannot be restricted by IN relation", cname));
+                        else if (stmt.selectACollection())
+                            throw new InvalidRequestException(String.format("Cannot restrict PRIMARY KEY part %s by IN relation as a collection is selected by the query", cname));
                     }
                 }
-                if (!hasEq)
+
+                previous = cname;
+            }
+
+            // Even if usesSecondaryIndexing is false at this point, we'll still have to use one if
+            // there is restrictions not covered by the PK.
+            if (!stmt.metadataRestrictions.isEmpty())
+            {
+                if (!hasQueriableIndex)
                     throw new InvalidRequestException("No indexed columns present in by-columns clause with Equal operator");
 
-                // If we have indexed columns and the key = X clause, we will do a range query, but if it's a IN relation, we don't know how to handle it.
+                stmt.usesSecondaryIndexing = true;
+            }
+
+            if (stmt.usesSecondaryIndexing)
+            {
                 if (stmt.keyIsInRelation)
                     throw new InvalidRequestException("Select on indexed columns and with IN clause for the PRIMARY KEY are not supported");
             }
 
+            iter = cfDef.keys.values().iterator();
+            for (int i = 0; i < lastRestrictedPartitionKey + 1; i++)
+                stmt.restrictedNames.remove(iter.next());
+
+            iter = cfDef.columns.values().iterator();
+            for (int i = 0; i < lastRestrictedClusteringKey + 1; i++)
+                stmt.restrictedNames.remove(iter.next());
+
             if (!stmt.parameters.orderings.isEmpty())
             {
-                if (!stmt.metadataRestrictions.isEmpty())
+                if (stmt.usesSecondaryIndexing)
                     throw new InvalidRequestException("ORDER BY with 2ndary indexes is not supported.");
 
                 if (stmt.isKeyRange)
@@ -1153,13 +1222,13 @@ public class SelectStatement implements CQLStatement
                 stmt.isReversed = isReversed;
             }
 
-            // Make sure this queries is allowed (note: only key range can involve filtering underneath)
-            if (!parameters.allowFiltering && stmt.isKeyRange)
+            // Make sure this queries is allowed (note: non key range non indexed cannot involve filtering underneath)
+            if (!parameters.allowFiltering && (stmt.isKeyRange || stmt.usesSecondaryIndexing))
             {
                 // We will potentially filter data if either:
                 //  - Have more than one IndexExpression
                 //  - Have no index expression and the column filter is not the identity
-                if (stmt.metadataRestrictions.size() > 1 || (stmt.metadataRestrictions.isEmpty() && !stmt.columnFilterIsIdentity()))
+                if (stmt.restrictedNames.size() > 1 || (stmt.restrictedNames.isEmpty() && !stmt.columnFilterIsIdentity()))
                     throw new InvalidRequestException("Cannot execute this query as it might involve data filtering and thus may have unpredictable performance. "
                                                     + "If you want to execute this query despite the performance unpredictability, use ALLOW FILTERING");
             }
diff --git a/src/java/org/apache/cassandra/db/ColumnFamilyStore.java b/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
index 972784acbf..0c4a4ea57b 100644
--- a/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
+++ b/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
@@ -269,7 +269,7 @@ public class ColumnFamilyStore implements ColumnFamilyStoreMBean
         this.compactionStrategy = metadata.createCompactionStrategyInstance(this);
 
         // create the private ColumnFamilyStores for the secondary column indexes
-        for (ColumnDefinition info : metadata.getColumn_metadata().values())
+        for (ColumnDefinition info : metadata.allColumns())
         {
             if (info.getIndexType() != null)
                 indexManager.addIndexedColumn(info);
@@ -452,7 +452,7 @@ public class ColumnFamilyStore implements ColumnFamilyStoreMBean
         CFMetaData cfm = Schema.instance.getCFMetaData(table, columnFamily);
         if (cfm != null) // secondary indexes aren't stored in DD.
         {
-            for (ColumnDefinition def : cfm.getColumn_metadata().values())
+            for (ColumnDefinition def : cfm.allColumns())
                 scrubDataDirectories(table, cfm.indexColumnFamilyName(def));
         }
     }
@@ -1535,7 +1535,7 @@ public class ColumnFamilyStore implements ColumnFamilyStoreMBean
                             data.addAll(cf, HeapAllocator.instance);
                     }
 
-                    if (!filter.isSatisfiedBy(data, null))
+                    if (!filter.isSatisfiedBy(rawRow.key.key, data, null))
                         continue;
 
                     logger.trace("{} satisfies all filter expressions", data);
diff --git a/src/java/org/apache/cassandra/db/EmptyColumns.java b/src/java/org/apache/cassandra/db/EmptyColumns.java
index af64628031..6df7a68027 100644
--- a/src/java/org/apache/cassandra/db/EmptyColumns.java
+++ b/src/java/org/apache/cassandra/db/EmptyColumns.java
@@ -33,7 +33,8 @@ public class EmptyColumns extends AbstractThreadUnsafeSortedColumns
         return new EmptyColumns(metadata, deletionInfo);
     }
 
-    public void clear() {
+    public void clear()
+    {
     }
 
     public Factory<EmptyColumns> getFactory()
diff --git a/src/java/org/apache/cassandra/db/filter/ExtendedFilter.java b/src/java/org/apache/cassandra/db/filter/ExtendedFilter.java
index 41f9d289f7..064cc6e3a8 100644
--- a/src/java/org/apache/cassandra/db/filter/ExtendedFilter.java
+++ b/src/java/org/apache/cassandra/db/filter/ExtendedFilter.java
@@ -26,8 +26,10 @@ import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import org.apache.cassandra.config.DatabaseDescriptor;
+import org.apache.cassandra.config.ColumnDefinition;
 import org.apache.cassandra.cql3.ColumnNameBuilder;
 import org.apache.cassandra.db.*;
+import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.db.marshal.CompositeType;
 import org.apache.cassandra.db.columniterator.OnDiskAtomIterator;
 import org.apache.cassandra.thrift.IndexExpression;
@@ -139,7 +141,7 @@ public abstract class ExtendedFilter
      * @return true if the provided data satisfies all the expressions from
      * the clause of this filter.
      */
-    public abstract boolean isSatisfiedBy(ColumnFamily data, ColumnNameBuilder builder);
+    public abstract boolean isSatisfiedBy(ByteBuffer rowKey, ColumnFamily data, ColumnNameBuilder builder);
 
     public static boolean satisfies(int comparison, IndexOperator op)
     {
@@ -273,23 +275,62 @@ public abstract class ExtendedFilter
             return pruned;
         }
 
-        public boolean isSatisfiedBy(ColumnFamily data, ColumnNameBuilder builder)
+        public boolean isSatisfiedBy(ByteBuffer rowKey, ColumnFamily data, ColumnNameBuilder builder)
         {
             // We enforces even the primary clause because reads are not synchronized with writes and it is thus possible to have a race
             // where the index returned a row which doesn't have the primary column when we actually read it
             for (IndexExpression expression : clause)
             {
-                // check column data vs expression
-                ByteBuffer colName = builder == null ? expression.column_name : builder.copy().add(expression.column_name).build();
-                Column column = data.getColumn(colName);
-                if (column == null)
+                ColumnDefinition def = data.metadata().getColumnDefinition(expression.column_name);
+                ByteBuffer dataValue = null;
+                AbstractType<?> validator = null;
+                if (def == null)
+                {
+                    // This can't happen with CQL3 as this should be rejected upfront. For thrift however,
+                    // column name are not predefined. But that means the column name correspond to an internal one.
+                    Column column = data.getColumn(expression.column_name);
+                    if (column != null)
+                    {
+                        dataValue = column.value();
+                        validator = data.metadata().getDefaultValidator();
+                    }
+                }
+                else
+                {
+                    dataValue = extractDataValue(def, rowKey, data, builder);
+                    validator = def.getValidator();
+                }
+
+                if (dataValue == null)
                     return false;
-                int v = data.metadata().getValueValidator(expression.column_name).compare(column.value(), expression.value);
+
+                int v = validator.compare(dataValue, expression.value);
                 if (!satisfies(v, expression.op))
                     return false;
             }
             return true;
         }
+
+        private ByteBuffer extractDataValue(ColumnDefinition def, ByteBuffer rowKey, ColumnFamily data, ColumnNameBuilder builder)
+        {
+            switch (def.type)
+            {
+                case PARTITION_KEY:
+                    return def.componentIndex == null
+                         ? rowKey
+                         : ((CompositeType)data.metadata().getKeyValidator()).split(rowKey)[def.componentIndex];
+                case CLUSTERING_KEY:
+                    return builder.get(def.componentIndex);
+                case REGULAR:
+                    ByteBuffer colName = builder == null ? def.name : builder.copy().add(def.name).build();
+                    Column column = data.getColumn(colName);
+                    return column == null ? null : column.value();
+                case COMPACT_VALUE:
+                    assert data.getColumnCount() == 1;
+                    return data.getSortedColumns().iterator().next().value();
+            }
+            throw new AssertionError();
+        }
     }
 
     private static class FilterWithCompositeClauses extends FilterWithClauses
@@ -343,7 +384,7 @@ public abstract class ExtendedFilter
             return data;
         }
 
-        public boolean isSatisfiedBy(ColumnFamily data, ColumnNameBuilder builder)
+        public boolean isSatisfiedBy(ByteBuffer rowKey, ColumnFamily data, ColumnNameBuilder builder)
         {
             return true;
         }
diff --git a/src/java/org/apache/cassandra/db/filter/IDiskAtomFilter.java b/src/java/org/apache/cassandra/db/filter/IDiskAtomFilter.java
index 30ebef81c7..e9d368211d 100644
--- a/src/java/org/apache/cassandra/db/filter/IDiskAtomFilter.java
+++ b/src/java/org/apache/cassandra/db/filter/IDiskAtomFilter.java
@@ -22,6 +22,7 @@ import java.io.DataOutput;
 import java.io.IOException;
 import java.util.Comparator;
 import java.util.Iterator;
+import java.nio.ByteBuffer;
 
 import org.apache.cassandra.db.*;
 import org.apache.cassandra.db.columniterator.ISSTableColumnIterator;
@@ -76,6 +77,7 @@ public interface IDiskAtomFilter
     public int getLiveCount(ColumnFamily cf);
 
     public IDiskAtomFilter cloneShallow();
+    public boolean maySelectPrefix(Comparator<ByteBuffer> cmp, ByteBuffer prefix);
 
     public static class Serializer implements IVersionedSerializer<IDiskAtomFilter>
     {
diff --git a/src/java/org/apache/cassandra/db/filter/NamesQueryFilter.java b/src/java/org/apache/cassandra/db/filter/NamesQueryFilter.java
index 6ef43d5ba8..bc2f71c35b 100644
--- a/src/java/org/apache/cassandra/db/filter/NamesQueryFilter.java
+++ b/src/java/org/apache/cassandra/db/filter/NamesQueryFilter.java
@@ -138,6 +138,16 @@ public class NamesQueryFilter implements IDiskAtomFilter
         return count;
     }
 
+    public boolean maySelectPrefix(Comparator<ByteBuffer> cmp, ByteBuffer prefix)
+    {
+        for (ByteBuffer column : columns)
+        {
+            if (ByteBufferUtil.isPrefix(prefix, column))
+                return true;
+        }
+        return false;
+    }
+
     public static class Serializer implements IVersionedSerializer<NamesQueryFilter>
     {
         public void serialize(NamesQueryFilter f, DataOutput out, int version) throws IOException
diff --git a/src/java/org/apache/cassandra/db/filter/SliceQueryFilter.java b/src/java/org/apache/cassandra/db/filter/SliceQueryFilter.java
index 01db13cbcc..d428883d40 100644
--- a/src/java/org/apache/cassandra/db/filter/SliceQueryFilter.java
+++ b/src/java/org/apache/cassandra/db/filter/SliceQueryFilter.java
@@ -226,10 +226,10 @@ public class SliceQueryFilter implements IDiskAtomFilter
         count = newLimit;
     }
 
-    public boolean includes(Comparator<ByteBuffer> cmp, ByteBuffer name)
+    public boolean maySelectPrefix(Comparator<ByteBuffer> cmp, ByteBuffer prefix)
     {
         for (ColumnSlice slice : slices)
-            if (slice.includes(cmp, name))
+            if (slice.includes(cmp, prefix))
                 return true;
         return false;
     }
diff --git a/src/java/org/apache/cassandra/db/index/AbstractSimplePerColumnSecondaryIndex.java b/src/java/org/apache/cassandra/db/index/AbstractSimplePerColumnSecondaryIndex.java
index dabba957d8..f12acdce54 100644
--- a/src/java/org/apache/cassandra/db/index/AbstractSimplePerColumnSecondaryIndex.java
+++ b/src/java/org/apache/cassandra/db/index/AbstractSimplePerColumnSecondaryIndex.java
@@ -33,14 +33,19 @@ import org.apache.cassandra.utils.ByteBufferUtil;
  */
 public abstract class AbstractSimplePerColumnSecondaryIndex extends PerColumnSecondaryIndex
 {
-    private ColumnFamilyStore indexCfs;
+    protected ColumnFamilyStore indexCfs;
+
+    // SecondaryIndex "forces" a set of ColumnDefinition. However this class (and thus it's subclass)
+    // only support one def per index. So inline it in a field for 1) convenience and 2) avoid creating
+    // an iterator each time we need to access it.
+    // TODO: we should fix SecondaryIndex API
+    protected ColumnDefinition columnDef;
 
     public void init()
     {
         assert baseCfs != null && columnDefs != null && columnDefs.size() == 1;
 
-        ColumnDefinition columnDef = columnDefs.iterator().next();
-        init(columnDef);
+        columnDef = columnDefs.iterator().next();
 
         AbstractType indexComparator = SecondaryIndex.getIndexComparator(baseCfs.metadata, columnDef);
         CFMetaData indexedCfMetadata = CFMetaData.newIndexMetadata(baseCfs.metadata, columnDef, indexComparator);
@@ -69,10 +74,10 @@ public abstract class AbstractSimplePerColumnSecondaryIndex extends PerColumnSec
         }
     }
 
-    protected abstract void init(ColumnDefinition columnDef);
-
     protected abstract ByteBuffer makeIndexColumnName(ByteBuffer rowKey, Column column);
 
+    protected abstract ByteBuffer getIndexedValue(ByteBuffer rowKey, Column column);
+
     protected abstract AbstractType getExpressionComparator();
 
     public String expressionString(IndexExpression expr)
@@ -81,16 +86,15 @@ public abstract class AbstractSimplePerColumnSecondaryIndex extends PerColumnSec
                              baseCfs.name,
                              getExpressionComparator().getString(expr.column_name),
                              expr.op,
-                             baseCfs.metadata.getColumn_metadata().get(expr.column_name).getValidator().getString(expr.value));
+                             baseCfs.metadata.getColumnDefinition(expr.column_name).getValidator().getString(expr.value));
     }
 
-
     public void delete(ByteBuffer rowKey, Column column)
     {
         if (column.isMarkedForDelete())
             return;
 
-        DecoratedKey valueKey = getIndexKeyFor(column.value());
+        DecoratedKey valueKey = getIndexKeyFor(getIndexedValue(rowKey, column));
         int localDeletionTime = (int) (System.currentTimeMillis() / 1000);
         ColumnFamily cfi = ArrayBackedSortedColumns.factory.create(indexCfs.metadata);
         cfi.addTombstone(makeIndexColumnName(rowKey, column), localDeletionTime, column.timestamp());
@@ -101,7 +105,7 @@ public abstract class AbstractSimplePerColumnSecondaryIndex extends PerColumnSec
 
     public void insert(ByteBuffer rowKey, Column column)
     {
-        DecoratedKey valueKey = getIndexKeyFor(column.value());
+        DecoratedKey valueKey = getIndexKeyFor(getIndexedValue(rowKey, column));
         ColumnFamily cfi = ArrayBackedSortedColumns.factory.create(indexCfs.metadata);
         ByteBuffer name = makeIndexColumnName(rowKey, column);
         if (column instanceof ExpiringColumn)
diff --git a/src/java/org/apache/cassandra/db/index/SecondaryIndex.java b/src/java/org/apache/cassandra/db/index/SecondaryIndex.java
index 11e026d598..2153ff962e 100644
--- a/src/java/org/apache/cassandra/db/index/SecondaryIndex.java
+++ b/src/java/org/apache/cassandra/db/index/SecondaryIndex.java
@@ -55,6 +55,10 @@ public abstract class SecondaryIndex
 
     public static final String CUSTOM_INDEX_OPTION_NAME = "class_name";
 
+    public static final AbstractType<?> keyComparator = StorageService.getPartitioner().preservesOrder()
+                                                      ? BytesType.instance
+                                                      : new LocalByPartionerType(StorageService.getPartitioner());
+
     /**
      * Base CF that has many indexes
      */
@@ -319,7 +323,7 @@ public abstract class SecondaryIndex
             index = new KeysIndex();
             break;
         case COMPOSITES:
-            index = new CompositesIndex();
+            index = CompositesIndex.create(cdef);
             break;
         case CUSTOM:
             assert cdef.getIndexOptions() != null;
@@ -355,32 +359,12 @@ public abstract class SecondaryIndex
      */
     public static AbstractType<?> getIndexComparator(CFMetaData baseMetadata, ColumnDefinition cdef)
     {
-        IPartitioner rowPartitioner = StorageService.getPartitioner();
-        AbstractType<?> keyComparator = (rowPartitioner instanceof OrderPreservingPartitioner || rowPartitioner instanceof ByteOrderedPartitioner)
-                                      ? BytesType.instance
-                                      : new LocalByPartionerType(rowPartitioner);
-
         switch (cdef.getIndexType())
         {
             case KEYS:
                 return keyComparator;
             case COMPOSITES:
-                assert baseMetadata.comparator instanceof CompositeType;
-                int prefixSize;
-                try
-                {
-                    prefixSize = Integer.parseInt(cdef.getIndexOptions().get(CompositesIndex.PREFIX_SIZE_OPTION));
-                }
-                catch (NumberFormatException e)
-                {
-                    // This shouldn't happen if validation has been done correctly
-                    throw new RuntimeException(e);
-                }
-                List<AbstractType<?>> types = new ArrayList<AbstractType<?>>(prefixSize + 1);
-                types.add(keyComparator);
-                for (int i = 0; i < prefixSize; i++)
-                    types.add(((CompositeType)baseMetadata.comparator).types.get(i));
-                return CompositeType.getInstance(types);
+                return CompositesIndex.getIndexComparator(baseMetadata, cdef);
             case CUSTOM:
                 return null;
         }
diff --git a/src/java/org/apache/cassandra/db/index/SecondaryIndexManager.java b/src/java/org/apache/cassandra/db/index/SecondaryIndexManager.java
index 4111093283..b98e1843e8 100644
--- a/src/java/org/apache/cassandra/db/index/SecondaryIndexManager.java
+++ b/src/java/org/apache/cassandra/db/index/SecondaryIndexManager.java
@@ -37,6 +37,7 @@ import org.apache.cassandra.dht.AbstractBounds;
 import org.apache.cassandra.io.sstable.ReducingKeyIterator;
 import org.apache.cassandra.io.sstable.SSTableReader;
 import org.apache.cassandra.thrift.IndexExpression;
+import org.apache.cassandra.thrift.IndexType;
 
 /**
  * Manages all the indexes associated with a given CFS
@@ -94,12 +95,13 @@ public class SecondaryIndexManager
         Collection<ByteBuffer> indexedColumnNames = indexesByColumn.keySet();
         for (ByteBuffer indexedColumn : indexedColumnNames)
         {
-            ColumnDefinition def = baseCfs.metadata.getColumn_metadata().get(indexedColumn);
+            ColumnDefinition def = baseCfs.metadata.getColumnDefinition(indexedColumn);
             if (def == null || def.getIndexType() == null)
                 removeIndexedColumn(indexedColumn);
         }
 
-        for (ColumnDefinition cdef : baseCfs.metadata.getColumn_metadata().values())
+        // TODO: allow all ColumnDefinition type
+        for (ColumnDefinition cdef : baseCfs.metadata.allColumns())
             if (cdef.getIndexType() != null && !indexedColumnNames.contains(cdef.name))
                 addIndexedColumn(cdef);
 
@@ -158,17 +160,22 @@ public class SecondaryIndexManager
 
     public boolean indexes(ByteBuffer name, Collection<SecondaryIndex> indexes)
     {
-        return indexFor(name, indexes) != null;
+        return !indexFor(name, indexes).isEmpty();
     }
 
-    public SecondaryIndex indexFor(ByteBuffer name, Collection<SecondaryIndex> indexes)
+    public List<SecondaryIndex> indexFor(ByteBuffer name, Collection<SecondaryIndex> indexes)
     {
+        List<SecondaryIndex> matching = null;
         for (SecondaryIndex index : indexes)
         {
             if (index.indexes(name))
-                return index;
+            {
+                if (matching == null)
+                    matching = new ArrayList<SecondaryIndex>();
+                matching.add(index);
+            }
         }
-        return null;
+        return matching == null ? Collections.<SecondaryIndex>emptyList() : matching;
     }
 
     public boolean indexes(Column column)
@@ -181,7 +188,7 @@ public class SecondaryIndexManager
         return indexes(name, indexesByColumn.values());
     }
 
-    public SecondaryIndex indexFor(ByteBuffer name)
+    public List<SecondaryIndex> indexFor(ByteBuffer name)
     {
         return indexFor(name, indexesByColumn.values());
     }
@@ -274,6 +281,9 @@ public class SecondaryIndexManager
         }
         else
         {
+            // TODO: We sould do better than throw a RuntimeException
+            if (cdef.getIndexType() == IndexType.CUSTOM && index instanceof AbstractSimplePerColumnSecondaryIndex)
+                throw new RuntimeException("Cannot use a subclass of AbstractSimplePerColumnSecondaryIndex as a CUSTOM index, as they assume they are CFS backed");
             index.init();
         }
 
@@ -600,22 +610,18 @@ public class SecondaryIndexManager
             if (column.isMarkedForDelete())
                 return;
 
-            SecondaryIndex index = indexFor(column.name());
-            if (index == null)
-                return;
-
-            ((PerColumnSecondaryIndex) index).insert(key.key, column);
+            for (SecondaryIndex index : indexFor(column.name()))
+                ((PerColumnSecondaryIndex) index).insert(key.key, column);
         }
 
         public void update(Column oldColumn, Column column)
         {
-            SecondaryIndex index = indexFor(column.name());
-            if (index == null)
-                return;
-
-            ((PerColumnSecondaryIndex) index).delete(key.key, oldColumn);
-            if (!column.isMarkedForDelete())
-                ((PerColumnSecondaryIndex) index).insert(key.key, column);
+            for (SecondaryIndex index : indexFor(column.name()))
+            {
+                ((PerColumnSecondaryIndex) index).delete(key.key, oldColumn);
+                if (!column.isMarkedForDelete())
+                    ((PerColumnSecondaryIndex) index).insert(key.key, column);
+            }
         }
 
         public void remove(Column column)
@@ -623,11 +629,8 @@ public class SecondaryIndexManager
             if (column.isMarkedForDelete())
                 return;
 
-            SecondaryIndex index = indexFor(column.name());
-            if (index == null)
-                return;
-
-            ((PerColumnSecondaryIndex) index).delete(key.key, column);
+            for (SecondaryIndex index : indexFor(column.name()))
+                ((PerColumnSecondaryIndex) index).delete(key.key, column);
         }
     }
 
@@ -646,37 +649,35 @@ public class SecondaryIndexManager
             if (column.isMarkedForDelete())
                 return;
 
-            SecondaryIndex index = indexFor(column.name());
-            if (index == null)
-                return;
-
-            if (index instanceof  PerColumnSecondaryIndex)
+            for (SecondaryIndex index : indexFor(column.name()))
             {
-                ((PerColumnSecondaryIndex) index).insert(key.key, column);
-            }
-            else
-            {
-                if (appliedRowLevelIndexes.add(index.getClass()))
-                    ((PerRowSecondaryIndex) index).index(key.key);
+                if (index instanceof  PerColumnSecondaryIndex)
+                {
+                    ((PerColumnSecondaryIndex) index).insert(key.key, column);
+                }
+                else
+                {
+                    if (appliedRowLevelIndexes.add(index.getClass()))
+                        ((PerRowSecondaryIndex) index).index(key.key);
+                }
             }
         }
 
         public void update(Column oldColumn, Column column)
         {
-            SecondaryIndex index = indexFor(column.name());
-            if (index == null)
-                return;
-
-            if (index instanceof  PerColumnSecondaryIndex)
+            for (SecondaryIndex index : indexFor(column.name()))
             {
-                ((PerColumnSecondaryIndex) index).delete(key.key, oldColumn);
-                if (!column.isMarkedForDelete())
-                    ((PerColumnSecondaryIndex) index).insert(key.key, column);
-            }
-            else
-            {
-                if (appliedRowLevelIndexes.add(index.getClass()))
-                    ((PerRowSecondaryIndex) index).index(key.key);
+                if (index instanceof  PerColumnSecondaryIndex)
+                {
+                    ((PerColumnSecondaryIndex) index).delete(key.key, oldColumn);
+                    if (!column.isMarkedForDelete())
+                        ((PerColumnSecondaryIndex) index).insert(key.key, column);
+                }
+                else
+                {
+                    if (appliedRowLevelIndexes.add(index.getClass()))
+                        ((PerRowSecondaryIndex) index).index(key.key);
+                }
             }
         }
 
@@ -685,18 +686,17 @@ public class SecondaryIndexManager
             if (column.isMarkedForDelete())
                 return;
 
-            SecondaryIndex index = indexFor(column.name());
-            if (index == null)
-                return;
-
-            if (index instanceof  PerColumnSecondaryIndex)
+            for (SecondaryIndex index : indexFor(column.name()))
             {
-                ((PerColumnSecondaryIndex) index).delete(key.key, column);
-            }
-            else
-            {
-                if (appliedRowLevelIndexes.add(index.getClass()))
-                    ((PerRowSecondaryIndex) index).index(key.key);
+                if (index instanceof  PerColumnSecondaryIndex)
+                {
+                    ((PerColumnSecondaryIndex) index).delete(key.key, column);
+                }
+                else
+                {
+                    if (appliedRowLevelIndexes.add(index.getClass()))
+                        ((PerRowSecondaryIndex) index).index(key.key);
+                }
             }
         }
     }
diff --git a/src/java/org/apache/cassandra/db/index/SecondaryIndexSearcher.java b/src/java/org/apache/cassandra/db/index/SecondaryIndexSearcher.java
index 3085f48a1e..16ac09129a 100644
--- a/src/java/org/apache/cassandra/db/index/SecondaryIndexSearcher.java
+++ b/src/java/org/apache/cassandra/db/index/SecondaryIndexSearcher.java
@@ -24,6 +24,7 @@ import org.apache.cassandra.db.*;
 import org.apache.cassandra.db.filter.IDiskAtomFilter;
 import org.apache.cassandra.dht.AbstractBounds;
 import org.apache.cassandra.thrift.IndexExpression;
+import org.apache.cassandra.thrift.IndexOperator;
 
 public abstract class SecondaryIndexSearcher
 {
@@ -43,8 +44,11 @@ public abstract class SecondaryIndexSearcher
     /**
      * @return true this index is able to handle given clauses.
      */
-    public abstract boolean isIndexing(List<IndexExpression> clause);
-    
+    public boolean isIndexing(List<IndexExpression> clause)
+    {
+        return highestSelectivityPredicate(clause) != null;
+    }
+
     protected boolean isIndexValueStale(ColumnFamily liveData, ByteBuffer indexedColumnName, ByteBuffer indexedValue)
     {
         Column liveColumn = liveData.getColumn(indexedColumnName);
@@ -54,4 +58,27 @@ public abstract class SecondaryIndexSearcher
         ByteBuffer liveValue = liveColumn.value();
         return 0 != liveData.metadata().getValueValidator(indexedColumnName).compare(indexedValue, liveValue);
     }
+
+    protected IndexExpression highestSelectivityPredicate(List<IndexExpression> clause)
+    {
+        IndexExpression best = null;
+        int bestMeanCount = Integer.MAX_VALUE;
+        for (IndexExpression expression : clause)
+        {
+            //skip columns belonging to a different index type
+            if(!columns.contains(expression.column_name))
+                continue;
+
+            SecondaryIndex index = indexManager.getIndexForColumn(expression.column_name);
+            if (index == null || (expression.op != IndexOperator.EQ))
+                continue;
+            int columns = index.getIndexCfs().getMeanColumns();
+            if (columns < bestMeanCount)
+            {
+                best = expression;
+                bestMeanCount = columns;
+            }
+        }
+        return best;
+    }
 }
diff --git a/src/java/org/apache/cassandra/db/index/composites/CompositesIndex.java b/src/java/org/apache/cassandra/db/index/composites/CompositesIndex.java
index 3d10ec585a..d7302f7143 100644
--- a/src/java/org/apache/cassandra/db/index/composites/CompositesIndex.java
+++ b/src/java/org/apache/cassandra/db/index/composites/CompositesIndex.java
@@ -18,92 +18,150 @@
 package org.apache.cassandra.db.index.composites;
 
 import java.nio.ByteBuffer;
+import java.util.HashMap;
+import java.util.Map;
 import java.util.Set;
 
+import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.config.ColumnDefinition;
+import org.apache.cassandra.cql3.ColumnNameBuilder;
 import org.apache.cassandra.db.*;
 import org.apache.cassandra.db.index.AbstractSimplePerColumnSecondaryIndex;
 import org.apache.cassandra.db.index.SecondaryIndex;
+import org.apache.cassandra.db.index.SecondaryIndexManager;
 import org.apache.cassandra.db.index.SecondaryIndexSearcher;
 import org.apache.cassandra.db.marshal.*;
 import org.apache.cassandra.exceptions.ConfigurationException;
 
 /**
- * Implements a secondary index for a column family using a second column family
- * in which the row keys are indexed values, and column names are base row keys.
+ * Base class for secondary indexes where composites are involved.
  */
-public class CompositesIndex extends AbstractSimplePerColumnSecondaryIndex
+public abstract class CompositesIndex extends AbstractSimplePerColumnSecondaryIndex
 {
-    public static final String PREFIX_SIZE_OPTION = "prefix_size";
+    private volatile CompositeType indexComparator;
 
-    private CompositeType indexComparator;
-    private int prefixSize;
-
-    public void init(ColumnDefinition columnDef)
+    protected CompositeType getIndexComparator()
     {
-        assert baseCfs.getComparator() instanceof CompositeType;
-
-        try
+        // Yes, this is racy, but doing this more than once is not a big deal, we just want to avoid doing it every time
+        // More seriously, we should fix that whole SecondaryIndex API so this can be a final and avoid all that non-sense.
+        if (indexComparator == null)
         {
-            prefixSize = Integer.parseInt(columnDef.getIndexOptions().get(PREFIX_SIZE_OPTION));
+            assert columnDef != null;
+            indexComparator = getIndexComparator(baseCfs.metadata, columnDef);
         }
-        catch (NumberFormatException e)
+        return indexComparator;
+    }
+
+    public static CompositesIndex create(ColumnDefinition cfDef)
+    {
+        switch (cfDef.type)
         {
-            // Shouldn't happen since validateOptions must have been called
-            throw new AssertionError(e);
+            case CLUSTERING_KEY:
+                return new CompositesIndexOnClusteringKey();
+            case REGULAR:
+                return new CompositesIndexOnRegular();
+            case PARTITION_KEY:
+                return new CompositesIndexOnPartitionKey();
+            //case COMPACT_VALUE:
+            //    return new CompositesIndexOnCompactValue();
         }
+        throw new AssertionError();
+    }
 
-        indexComparator = (CompositeType)SecondaryIndex.getIndexComparator(baseCfs.metadata, columnDef);
+    // Check SecondaryIndex.getIndexComparator if you want to know why this is static
+    public static CompositeType getIndexComparator(CFMetaData baseMetadata, ColumnDefinition cfDef)
+    {
+        switch (cfDef.type)
+        {
+            case CLUSTERING_KEY:
+                return CompositesIndexOnClusteringKey.buildIndexComparator(baseMetadata, cfDef);
+            case REGULAR:
+                return CompositesIndexOnRegular.buildIndexComparator(baseMetadata, cfDef);
+            case PARTITION_KEY:
+                return CompositesIndexOnPartitionKey.buildIndexComparator(baseMetadata, cfDef);
+            //case COMPACT_VALUE:
+            //    return CompositesIndexOnCompactValue.buildIndexComparator(baseMetadata, cfDef);
+        }
+        throw new AssertionError();
     }
 
     protected ByteBuffer makeIndexColumnName(ByteBuffer rowKey, Column column)
     {
-        CompositeType baseComparator = (CompositeType)baseCfs.getComparator();
-        ByteBuffer[] components = baseComparator.split(column.name());
-        CompositeType.Builder builder = new CompositeType.Builder(indexComparator);
-        builder.add(rowKey);
-        for (int i = 0; i < Math.min(prefixSize, components.length); i++)
-            builder.add(components[i]);
-        return builder.build();
+        return makeIndexColumnNameBuilder(rowKey, column.name()).build();
+    }
+
+    protected abstract ColumnNameBuilder makeIndexColumnNameBuilder(ByteBuffer rowKey, ByteBuffer columnName);
+
+    public abstract IndexedEntry decodeEntry(DecoratedKey indexedValue, Column indexEntry);
+
+    public abstract boolean isStale(IndexedEntry entry, ColumnFamily data);
+
+    public void delete(IndexedEntry entry)
+    {
+        int localDeletionTime = (int) (System.currentTimeMillis() / 1000);
+        ColumnFamily cfi = ArrayBackedSortedColumns.factory.create(indexCfs.metadata);
+        cfi.addTombstone(entry.indexEntry, (int) (System.currentTimeMillis() / 1000), entry.timestamp);
+        indexCfs.apply(entry.indexValue, cfi, SecondaryIndexManager.nullUpdater);
+        if (logger.isDebugEnabled())
+            logger.debug("removed index entry for cleaned-up value {}:{}", entry.indexValue, cfi);
+
     }
 
     protected AbstractType getExpressionComparator()
     {
-        CompositeType baseComparator = (CompositeType)baseCfs.getComparator();
-        return baseComparator.types.get(prefixSize);
+        return baseCfs.metadata.getColumnDefinitionComparator(columnDef);
     }
 
-    @Override
-    public boolean indexes(ByteBuffer name)
+    protected CompositeType getBaseComparator()
     {
-        ColumnDefinition columnDef = columnDefs.iterator().next();
-        CompositeType baseComparator = (CompositeType)baseCfs.getComparator();
-        ByteBuffer[] components = baseComparator.split(name);
-        AbstractType<?> comp = baseCfs.metadata.getColumnDefinitionComparator(columnDef);
-        return components.length > columnDef.componentIndex
-            && comp.compare(components[columnDef.componentIndex], columnDef.name) == 0;
+        assert baseCfs.getComparator() instanceof CompositeType;
+        return (CompositeType)baseCfs.getComparator();
     }
 
     public SecondaryIndexSearcher createSecondaryIndexSearcher(Set<ByteBuffer> columns)
     {
-        return new CompositesSearcher(baseCfs.indexManager, columns, prefixSize);
+        return new CompositesSearcher(baseCfs.indexManager, columns);
     }
 
     public void validateOptions() throws ConfigurationException
     {
         ColumnDefinition columnDef = columnDefs.iterator().next();
-        String option = columnDef.getIndexOptions().get(PREFIX_SIZE_OPTION);
+        Map<String, String> options = new HashMap<String, String>(columnDef.getIndexOptions());
+
+        // We take no options though we used to have one called "prefix_size",
+        // so skip it silently for backward compatibility sake.
+        options.remove("prefix_size");
+
+        if (!options.isEmpty())
+            throw new ConfigurationException("Unknown options provided for COMPOSITES index: " + options.keySet());
+    }
+
+    public class IndexedEntry
+    {
+        public final DecoratedKey indexValue;
+        public final ByteBuffer indexEntry;
+        public final long timestamp;
 
-        if (option == null)
-            throw new ConfigurationException("Missing option " + PREFIX_SIZE_OPTION);
+        public final ByteBuffer indexedKey;
+        public final ColumnNameBuilder indexedEntryNameBuilder;
 
-        try
+        public IndexedEntry(DecoratedKey indexValue, ByteBuffer indexEntry, long timestamp, ByteBuffer indexedKey, ColumnNameBuilder indexedEntryNameBuilder)
         {
-            Integer.parseInt(option);
+            this.indexValue = indexValue;
+            this.indexEntry = indexEntry;
+            this.timestamp = timestamp;
+            this.indexedKey = indexedKey;
+            this.indexedEntryNameBuilder = indexedEntryNameBuilder;
         }
-        catch (NumberFormatException e)
+
+        public ByteBuffer indexedEntryStart()
+        {
+            return indexedEntryNameBuilder.build();
+        }
+
+        public ByteBuffer indexedEntryEnd()
         {
-            throw new ConfigurationException(String.format("Invalid non integer value for option %s (got '%s')", PREFIX_SIZE_OPTION, option));
+            return indexedEntryNameBuilder.buildAsEndOfRange();
         }
     }
 }
diff --git a/src/java/org/apache/cassandra/db/index/composites/CompositesIndexOnClusteringKey.java b/src/java/org/apache/cassandra/db/index/composites/CompositesIndexOnClusteringKey.java
new file mode 100644
index 0000000000..f1df078eca
--- /dev/null
+++ b/src/java/org/apache/cassandra/db/index/composites/CompositesIndexOnClusteringKey.java
@@ -0,0 +1,116 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.cassandra.db.index.composites;
+
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.cassandra.config.CFMetaData;
+import org.apache.cassandra.config.ColumnDefinition;
+import org.apache.cassandra.cql3.ColumnNameBuilder;
+import org.apache.cassandra.db.*;
+import org.apache.cassandra.db.index.SecondaryIndex;
+import org.apache.cassandra.db.index.SecondaryIndexSearcher;
+import org.apache.cassandra.db.marshal.*;
+
+/**
+ * Index on a CLUSTERING_KEY column definition.
+ *
+ * A cell indexed by this index will have the general form:
+ *   ck_0 ... ck_n c_name : v
+ * where ck_i are the cluster keys, c_name the last component of the cell
+ * composite name (or second to last if collections are in use, but this
+ * has no impact) and v the cell value.
+ *
+ * Such a cell is always indexed by this index (or rather, it is indexed if
+ * n >= columnDef.componentIndex, which will always be the case in practice)
+ * and it will generate (makeIndexColumnName()) an index entry whose:
+ *   - row key will be ck_i (getIndexedValue()) where i == columnDef.componentIndex.
+ *   - cell name will
+ *       rk ck_0 ... ck_{i-1} ck_{i+1} ck_n
+ *     where rk is the row key of the initial cell and i == columnDef.componentIndex.
+ */
+public class CompositesIndexOnClusteringKey extends CompositesIndex
+{
+    public static CompositeType buildIndexComparator(CFMetaData baseMetadata, ColumnDefinition columnDef)
+    {
+        // Index cell names are rk ck_0 ... ck_{i-1} ck_{i+1} ck_n, so n
+        // components total (where n is the number of clustering keys)
+        int ckCount = baseMetadata.clusteringKeyColumns().size();
+        List<AbstractType<?>> types = new ArrayList<AbstractType<?>>(ckCount);
+        List<AbstractType<?>> ckTypes = baseMetadata.comparator.getComponents();
+        types.add(SecondaryIndex.keyComparator);
+        for (int i = 0; i < columnDef.componentIndex; i++)
+            types.add(ckTypes.get(i));
+        for (int i = columnDef.componentIndex + 1; i < ckCount; i++)
+            types.add(ckTypes.get(i));
+        return CompositeType.getInstance(types);
+    }
+
+    protected ByteBuffer getIndexedValue(ByteBuffer rowKey, Column column)
+    {
+        CompositeType baseComparator = (CompositeType)baseCfs.getComparator();
+        ByteBuffer[] components = baseComparator.split(column.name());
+        return components[columnDef.componentIndex];
+    }
+
+    protected ColumnNameBuilder makeIndexColumnNameBuilder(ByteBuffer rowKey, ByteBuffer columnName)
+    {
+        int ckCount = baseCfs.metadata.clusteringKeyColumns().size();
+        CompositeType baseComparator = (CompositeType)baseCfs.getComparator();
+        ByteBuffer[] components = baseComparator.split(columnName);
+        CompositeType.Builder builder = getIndexComparator().builder();
+        builder.add(rowKey);
+        for (int i = 0; i < columnDef.componentIndex; i++)
+            builder.add(components[i]);
+        for (int i = columnDef.componentIndex + 1; i < ckCount; i++)
+            builder.add(components[i]);
+        return builder;
+    }
+
+    public IndexedEntry decodeEntry(DecoratedKey indexedValue, Column indexEntry)
+    {
+        int ckCount = baseCfs.metadata.clusteringKeyColumns().size();
+        ByteBuffer[] components = getIndexComparator().split(indexEntry.name());
+
+        ColumnNameBuilder builder = getBaseComparator().builder();
+        for (int i = 0; i < columnDef.componentIndex; i++)
+            builder.add(components[i + 1]);
+
+        builder.add(indexedValue.key);
+
+        for (int i = columnDef.componentIndex + 1; i < ckCount; i++)
+            builder.add(components[i]);
+
+        return new IndexedEntry(indexedValue, indexEntry.name(), indexEntry.timestamp(), components[0], builder);
+    }
+
+    @Override
+    public boolean indexes(ByteBuffer name)
+    {
+        // For now, assume this is only used in CQL3 when we know name has enough component.
+        return true;
+    }
+
+    public boolean isStale(IndexedEntry entry, ColumnFamily data)
+    {
+        return data == null || data.hasOnlyTombstones();
+    }
+}
+
diff --git a/src/java/org/apache/cassandra/db/index/composites/CompositesIndexOnPartitionKey.java b/src/java/org/apache/cassandra/db/index/composites/CompositesIndexOnPartitionKey.java
new file mode 100644
index 0000000000..fce7700772
--- /dev/null
+++ b/src/java/org/apache/cassandra/db/index/composites/CompositesIndexOnPartitionKey.java
@@ -0,0 +1,105 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.cassandra.db.index.composites;
+
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.cassandra.config.CFMetaData;
+import org.apache.cassandra.config.ColumnDefinition;
+import org.apache.cassandra.cql3.ColumnNameBuilder;
+import org.apache.cassandra.db.*;
+import org.apache.cassandra.db.index.SecondaryIndex;
+import org.apache.cassandra.db.index.SecondaryIndexSearcher;
+import org.apache.cassandra.db.marshal.*;
+
+/**
+ * Index on a PARTITION_KEY column definition.
+ *
+ * This suppose a composite row key:
+ *   rk = rk_0 ... rk_n
+ *
+ * The corresponding index entry will be:
+ *   - index row key will be rk_i (where i == columnDef.componentIndex)
+ *   - cell name will be: rk ck
+ *     where rk is the fully partition key and ck the clustering keys of the
+ *     original cell names (thus excluding the last column name as we want to refer to
+ *     the whole CQL3 row, not just the cell itself)
+ *
+ * Note that contrarily to other type of index, we repeat the indexed value in
+ * the index cell name (we use the whole partition key). The reason is that we
+ * want to order the index cell name by partitioner first, and skipping a part
+ * of the row key would change the order.
+ */
+public class CompositesIndexOnPartitionKey extends CompositesIndex
+{
+    public static CompositeType buildIndexComparator(CFMetaData baseMetadata, ColumnDefinition columnDef)
+    {
+        int ckCount = baseMetadata.clusteringKeyColumns().size();
+        List<AbstractType<?>> types = new ArrayList<AbstractType<?>>(ckCount + 1);
+        types.add(SecondaryIndex.keyComparator);
+        types.addAll(baseMetadata.comparator.getComponents());
+        return CompositeType.getInstance(types);
+    }
+
+    protected ByteBuffer getIndexedValue(ByteBuffer rowKey, Column column)
+    {
+        CompositeType keyComparator = (CompositeType)baseCfs.metadata.getKeyValidator();
+        ByteBuffer[] components = keyComparator.split(rowKey);
+        return components[columnDef.componentIndex];
+    }
+
+    protected ColumnNameBuilder makeIndexColumnNameBuilder(ByteBuffer rowKey, ByteBuffer columnName)
+    {
+        int ckCount = baseCfs.metadata.clusteringKeyColumns().size();
+        CompositeType baseComparator = (CompositeType)baseCfs.getComparator();
+        ByteBuffer[] components = baseComparator.split(columnName);
+        CompositeType.Builder builder = getIndexComparator().builder();
+        builder.add(rowKey);
+        for (int i = 0; i < ckCount; i++)
+            builder.add(components[i]);
+        return builder;
+    }
+
+    public IndexedEntry decodeEntry(DecoratedKey indexedValue, Column indexEntry)
+    {
+        int ckCount = baseCfs.metadata.clusteringKeyColumns().size();
+        ByteBuffer[] components = getIndexComparator().split(indexEntry.name());
+
+        ColumnNameBuilder builder = getBaseComparator().builder();
+        for (int i = 0; i < ckCount; i++)
+            builder.add(components[i + 1]);
+
+        return new IndexedEntry(indexedValue, indexEntry.name(), indexEntry.timestamp(), components[0], builder);
+    }
+
+    @Override
+    public boolean indexes(ByteBuffer name)
+    {
+        // Since a partition key is always full, we always index it
+        return true;
+    }
+
+    public boolean isStale(IndexedEntry entry, ColumnFamily data)
+    {
+        return data == null || data.hasOnlyTombstones();
+    }
+}
+
+
diff --git a/src/java/org/apache/cassandra/db/index/composites/CompositesIndexOnRegular.java b/src/java/org/apache/cassandra/db/index/composites/CompositesIndexOnRegular.java
new file mode 100644
index 0000000000..03649c0add
--- /dev/null
+++ b/src/java/org/apache/cassandra/db/index/composites/CompositesIndexOnRegular.java
@@ -0,0 +1,105 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.cassandra.db.index.composites;
+
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.cassandra.config.CFMetaData;
+import org.apache.cassandra.config.ColumnDefinition;
+import org.apache.cassandra.cql3.ColumnNameBuilder;
+import org.apache.cassandra.db.*;
+import org.apache.cassandra.db.index.SecondaryIndex;
+import org.apache.cassandra.db.index.SecondaryIndexSearcher;
+import org.apache.cassandra.db.marshal.*;
+
+/**
+ * Index on a REGULAR column definition on a composite type.
+ *
+ * A cell indexed by this index will have the general form:
+ *   ck_0 ... ck_n c_name : v
+ * where ck_i are the cluster keys, c_name the last component of the cell
+ * composite name (or second to last if collections are in use, but this
+ * has no impact) and v the cell value.
+ *
+ * Such a cell is indexed if c_name == columnDef.name, and it will generate
+ * (makeIndexColumnName()) an index entry whose:
+ *   - row key will be the value v (getIndexedValue()).
+ *   - cell name will
+ *       rk ck_0 ... ck_n
+ *     where rk is the row key of the initial cell. I.e. the index entry store
+ *     all the information require to locate back the indexed cell.
+ */
+public class CompositesIndexOnRegular extends CompositesIndex
+{
+    public static CompositeType buildIndexComparator(CFMetaData baseMetadata, ColumnDefinition columnDef)
+    {
+        int prefixSize = columnDef.componentIndex;
+        List<AbstractType<?>> types = new ArrayList<AbstractType<?>>(prefixSize + 1);
+        types.add(SecondaryIndex.keyComparator);
+        for (int i = 0; i < prefixSize; i++)
+            types.add(((CompositeType)baseMetadata.comparator).types.get(i));
+        return CompositeType.getInstance(types);
+    }
+
+    protected ByteBuffer getIndexedValue(ByteBuffer rowKey, Column column)
+    {
+        return column.value();
+    }
+
+    protected ColumnNameBuilder makeIndexColumnNameBuilder(ByteBuffer rowKey, ByteBuffer columnName)
+    {
+        CompositeType baseComparator = (CompositeType)baseCfs.getComparator();
+        ByteBuffer[] components = baseComparator.split(columnName);
+        CompositeType.Builder builder = getIndexComparator().builder();
+        builder.add(rowKey);
+        for (int i = 0; i < Math.min(columnDef.componentIndex, components.length); i++)
+            builder.add(components[i]);
+        return builder;
+    }
+
+    public IndexedEntry decodeEntry(DecoratedKey indexedValue, Column indexEntry)
+    {
+        ByteBuffer[] components = getIndexComparator().split(indexEntry.name());
+        CompositeType.Builder builder = getBaseComparator().builder();
+        for (int i = 0; i < columnDef.componentIndex; i++)
+            builder.add(components[i + 1]);
+        return new IndexedEntry(indexedValue, indexEntry.name(), indexEntry.timestamp(), components[0], builder);
+    }
+
+    @Override
+    public boolean indexes(ByteBuffer name)
+    {
+        ByteBuffer[] components = getBaseComparator().split(name);
+        AbstractType<?> comp = baseCfs.metadata.getColumnDefinitionComparator(columnDef);
+        return components.length > columnDef.componentIndex
+            && comp.compare(components[columnDef.componentIndex], columnDef.name) == 0;
+    }
+
+    public boolean isStale(IndexedEntry entry, ColumnFamily data)
+    {
+        ByteBuffer bb = entry.indexedEntryNameBuilder.copy().add(columnDef.name).build();
+        Column liveColumn = data.getColumn(bb);
+        if (liveColumn == null || liveColumn.isMarkedForDelete())
+            return true;
+
+        ByteBuffer liveValue = liveColumn.value();
+        return columnDef.getValidator().compare(entry.indexValue.key, liveValue) != 0;
+    }
+}
diff --git a/src/java/org/apache/cassandra/db/index/composites/CompositesSearcher.java b/src/java/org/apache/cassandra/db/index/composites/CompositesSearcher.java
index 09747c0fbc..0d8cdb9dc8 100644
--- a/src/java/org/apache/cassandra/db/index/composites/CompositesSearcher.java
+++ b/src/java/org/apache/cassandra/db/index/composites/CompositesSearcher.java
@@ -21,6 +21,7 @@ import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.util.*;
 
+import org.apache.cassandra.cql3.ColumnNameBuilder;
 import org.apache.cassandra.db.*;
 import org.apache.cassandra.db.filter.*;
 import org.apache.cassandra.db.index.AbstractSimplePerColumnSecondaryIndex;
@@ -41,40 +42,9 @@ public class CompositesSearcher extends SecondaryIndexSearcher
 {
     private static final Logger logger = LoggerFactory.getLogger(CompositesSearcher.class);
 
-    private final int prefixSize;
-
-    public CompositesSearcher(SecondaryIndexManager indexManager, Set<ByteBuffer> columns, int prefixSize)
+    public CompositesSearcher(SecondaryIndexManager indexManager, Set<ByteBuffer> columns)
     {
         super(indexManager, columns);
-        this.prefixSize = prefixSize;
-    }
-
-    private IndexExpression highestSelectivityPredicate(List<IndexExpression> clause)
-    {
-        IndexExpression best = null;
-        int bestMeanCount = Integer.MAX_VALUE;
-        for (IndexExpression expression : clause)
-        {
-            //skip columns belonging to a different index type
-            if(!columns.contains(expression.column_name))
-                continue;
-
-            SecondaryIndex index = indexManager.getIndexForColumn(expression.column_name);
-            if (index == null || (expression.op != IndexOperator.EQ))
-                continue;
-            int columns = index.getIndexCfs().getMeanColumns();
-            if (columns < bestMeanCount)
-            {
-                best = expression;
-                bestMeanCount = columns;
-            }
-        }
-        return best;
-    }
-
-    public boolean isIndexing(List<IndexExpression> clause)
-    {
-        return highestSelectivityPredicate(clause) != null;
     }
 
     @Override
@@ -85,13 +55,31 @@ public class CompositesSearcher extends SecondaryIndexSearcher
         return baseCfs.filter(getIndexedIterator(range, filter), filter);
     }
 
+    private ByteBuffer makePrefix(CompositesIndex index, ByteBuffer key, ExtendedFilter filter, boolean isStart)
+    {
+        if (key.remaining() == 0)
+            return ByteBufferUtil.EMPTY_BYTE_BUFFER;
+
+        ColumnNameBuilder builder;
+        if (filter.originalFilter() instanceof SliceQueryFilter)
+        {
+            SliceQueryFilter originalFilter = (SliceQueryFilter)filter.originalFilter();
+            builder = index.makeIndexColumnNameBuilder(key, isStart ? originalFilter.start() : originalFilter.finish());
+        }
+        else
+        {
+            builder = index.getIndexComparator().builder().add(key);
+        }
+        return isStart ? builder.build() : builder.buildAsEndOfRange();
+    }
+
     public ColumnFamilyStore.AbstractScanIterator getIndexedIterator(final AbstractBounds<RowPosition> range, final ExtendedFilter filter)
     {
         // Start with the most-restrictive indexed clause, then apply remaining clauses
         // to each row matching that clause.
         // TODO: allow merge join instead of just one index + loop
         final IndexExpression primary = highestSelectivityPredicate(filter.getClause());
-        final SecondaryIndex index = indexManager.getIndexForColumn(primary.column_name);
+        final CompositesIndex index = (CompositesIndex)indexManager.getIndexForColumn(primary.column_name);
         assert index != null;
         final DecoratedKey indexKey = index.getIndexKeyFor(primary.value);
 
@@ -101,7 +89,7 @@ public class CompositesSearcher extends SecondaryIndexSearcher
 
         /*
          * XXX: If the range requested is a token range, we'll have to start at the beginning (and stop at the end) of
-         * the indexed row unfortunately (which will be inefficient), because we have not way to intuit the small
+         * the indexed row unfortunately (which will be inefficient), because we have not way to intuit the smallest
          * possible key having a given token. A fix would be to actually store the token along the key in the
          * indexed row.
          */
@@ -112,50 +100,8 @@ public class CompositesSearcher extends SecondaryIndexSearcher
         final CompositeType indexComparator = (CompositeType)index.getIndexCfs().getComparator();
 
         CompositeType.Builder builder = null;
-        if (startKey.remaining() > 0)
-        {
-            builder = indexComparator.builder().add(startKey);
-            // For names filter, we have no choice but to query from the beginning of the key. This can be highly inefficient however.
-            if (filter.originalFilter() instanceof SliceQueryFilter)
-            {
-                ByteBuffer[] components = baseComparator.split(((SliceQueryFilter)filter.originalFilter()).start());
-                for (int i = 0; i < Math.min(prefixSize, components.length); ++i)
-                    builder.add(components[i]);
-            }
-        }
-        final ByteBuffer startPrefix = startKey.remaining() == 0 ? ByteBufferUtil.EMPTY_BYTE_BUFFER : builder.build();
-
-        if (endKey.remaining() > 0)
-        {
-            builder = indexComparator.builder().add(endKey);
-            // For names filter, we have no choice but to query until the end of the key. This can be highly inefficient however.
-            if (filter.originalFilter() instanceof SliceQueryFilter)
-            {
-                ByteBuffer[] components = baseComparator.split(((SliceQueryFilter)filter.originalFilter()).finish());
-                for (int i = 0; i < Math.min(prefixSize, components.length); ++i)
-                    builder.add(components[i]);
-            }
-        }
-        final ByteBuffer endPrefix = endKey.remaining() == 0 ? ByteBufferUtil.EMPTY_BYTE_BUFFER : builder.buildAsEndOfRange();
-
-        // We will need to filter clustering keys based on the user filter. If
-        // it is a names filter, we are really interested on the clustering
-        // part, not the actual column name (NOTE: this is a hack that assumes CQL3).
-        final SliceQueryFilter originalFilter;
-        if (filter.originalFilter() instanceof SliceQueryFilter)
-        {
-            originalFilter = (SliceQueryFilter)filter.originalFilter();
-        }
-        else
-        {
-            ByteBuffer first = ((NamesQueryFilter)filter.originalFilter()).columns.iterator().next();
-            ByteBuffer[] components = baseComparator.split(first);
-            builder = baseComparator.builder();
-            // All all except the last component, since it's the column name
-            for (int i = 0; i < components.length - 1; i++)
-                builder.add(components[i]);
-            originalFilter = new SliceQueryFilter(builder.copy().build(), builder.copy().buildAsEndOfRange(), false, Integer.MAX_VALUE);
-        }
+        final ByteBuffer startPrefix = makePrefix(index, startKey, filter, true);
+        final ByteBuffer endPrefix = makePrefix(index, endKey, filter, false);
 
         return new ColumnFamilyStore.AbstractScanIterator()
         {
@@ -223,7 +169,7 @@ public class CompositesSearcher extends SecondaryIndexSearcher
                                                                              false,
                                                                              rowsPerQuery);
                         ColumnFamily indexRow = index.getIndexCfs().getColumnFamily(indexFilter);
-                        if (indexRow == null)
+                        if (indexRow == null || indexRow.isEmpty())
                             return makeReturn(currentKey, data);
 
                         Collection<Column> sortedColumns = indexRow.getSortedColumns();
@@ -238,12 +184,6 @@ public class CompositesSearcher extends SecondaryIndexSearcher
                             indexColumns.poll();
                             logger.trace("Skipping {}", indexComparator.getString(firstColumn.name()));
                         }
-                        else if (range instanceof Range && !indexColumns.isEmpty() && firstColumn.name().equals(startPrefix))
-                        {
-                            // skip key excluded by range
-                            indexColumns.poll();
-                            logger.trace("Skipping first key as range excludes it");
-                        }
                     }
 
                     while (!indexColumns.isEmpty() && columnsCount <= limit)
@@ -256,8 +196,8 @@ public class CompositesSearcher extends SecondaryIndexSearcher
                             continue;
                         }
 
-                        ByteBuffer[] components = indexComparator.split(lastSeenPrefix);
-                        DecoratedKey dk = baseCfs.partitioner.decorateKey(components[0]);
+                        CompositesIndex.IndexedEntry entry = index.decodeEntry(indexKey, column);
+                        DecoratedKey dk = baseCfs.partitioner.decorateKey(entry.indexedKey);
 
                         // Are we done for this row?
                         if (currentKey == null)
@@ -277,52 +217,52 @@ public class CompositesSearcher extends SecondaryIndexSearcher
                                 return makeReturn(previousKey, data);
                         }
 
-                        if (!range.right.isMinimum(baseCfs.partitioner) && range.right.compareTo(dk) < 0)
-                        {
-                            logger.trace("Reached end of assigned scan range");
-                            return endOfData();
-                        }
                         if (!range.contains(dk))
                         {
-                            logger.debug("Skipping entry {} outside of assigned scan range", dk.token);
-                            continue;
+                            // Either we're not yet in the range cause the range is start excluding, or we're
+                            // past it.
+                            if (!range.right.isMinimum(baseCfs.partitioner) && range.right.compareTo(dk) < 0)
+                            {
+                                logger.trace("Reached end of assigned scan range");
+                                return endOfData();
+                            }
+                            else
+                            {
+                                logger.debug("Skipping entry {} before assigned scan range", dk.token);
+                                continue;
+                            }
                         }
 
-                        logger.trace("Adding index hit to current row for {}", indexComparator.getString(lastSeenPrefix));
-                        // For sparse composites, we're good querying the whole logical row
-                        // Obviously if this index is used for other usage, that might be inefficient
-                        CompositeType.Builder builder = baseComparator.builder();
-                        for (int i = 0; i < prefixSize; i++)
-                            builder.add(components[i + 1]);
-
-                        // Does this "row" match the user original filter
-                        ByteBuffer start = builder.copy().build();
-                        if (!originalFilter.includes(baseComparator, start))
+                        // Check if this entry cannot be a hit due to the original column filter
+                        ByteBuffer start = entry.indexedEntryStart();
+                        if (!filter.originalFilter().maySelectPrefix(baseComparator, start))
                             continue;
 
-                        SliceQueryFilter dataFilter = new SliceQueryFilter(start, builder.copy().buildAsEndOfRange(), false, Integer.MAX_VALUE, prefixSize);
+                        logger.trace("Adding index hit to current row for {}", indexComparator.getString(column.name()));
+
+                        // We always query the whole CQL3 row. In the case where the original filter was a name filter this might be
+                        // slightly wasteful, but this probably doesn't matter in practice and it simplify things.
+                        SliceQueryFilter dataFilter = new SliceQueryFilter(start,
+                                                                           entry.indexedEntryEnd(),
+                                                                           false,
+                                                                           Integer.MAX_VALUE,
+                                                                           baseCfs.metadata.clusteringKeyColumns().size());
                         ColumnFamily newData = baseCfs.getColumnFamily(new QueryFilter(dk, baseCfs.name, dataFilter));
-                        if (newData != null)
+                        if (index.isStale(entry, newData))
                         {
-                            ByteBuffer baseColumnName = builder.copy().add(primary.column_name).build();
-                            ByteBuffer indexedValue = indexKey.key;
+                            index.delete(entry);
+                            continue;
+                        }
 
-                            if (isIndexValueStale(newData, baseColumnName, indexedValue))
-                            {
-                                // delete the index entry w/ its own timestamp
-                                Column dummyColumn = new Column(baseColumnName, indexedValue, column.timestamp());
-                                ((PerColumnSecondaryIndex) index).delete(dk.key, dummyColumn);
-                                continue;
-                            }
+                        assert newData != null : "An entry with not data should have been considered stale";
 
-                            if (!filter.isSatisfiedBy(newData, builder))
-                                continue;
+                        if (!filter.isSatisfiedBy(dk.key, newData, entry.indexedEntryNameBuilder))
+                            continue;
 
-                            if (data == null)
-                                data = TreeMapBackedSortedColumns.factory.create(baseCfs.metadata);
-                            data.resolve(newData);
-                            columnsCount += dataFilter.lastCounted();
-                        }
+                        if (data == null)
+                            data = TreeMapBackedSortedColumns.factory.create(baseCfs.metadata);
+                        data.resolve(newData);
+                        columnsCount += dataFilter.lastCounted();
                     }
                  }
              }
diff --git a/src/java/org/apache/cassandra/db/index/keys/KeysIndex.java b/src/java/org/apache/cassandra/db/index/keys/KeysIndex.java
index 8d065ab6ae..190afc1394 100644
--- a/src/java/org/apache/cassandra/db/index/keys/KeysIndex.java
+++ b/src/java/org/apache/cassandra/db/index/keys/KeysIndex.java
@@ -21,6 +21,7 @@ import java.nio.ByteBuffer;
 import java.util.Set;
 
 import org.apache.cassandra.config.ColumnDefinition;
+import org.apache.cassandra.db.ColumnFamily;
 import org.apache.cassandra.db.Column;
 import org.apache.cassandra.db.index.AbstractSimplePerColumnSecondaryIndex;
 import org.apache.cassandra.db.index.SecondaryIndexSearcher;
@@ -33,9 +34,9 @@ import org.apache.cassandra.exceptions.ConfigurationException;
  */
 public class KeysIndex extends AbstractSimplePerColumnSecondaryIndex
 {
-    public void init(ColumnDefinition columnDef)
+    protected ByteBuffer getIndexedValue(ByteBuffer rowKey, Column column)
     {
-        // Nothing specific
+        return column.value();
     }
 
     protected ByteBuffer makeIndexColumnName(ByteBuffer rowKey, Column column)
@@ -48,6 +49,16 @@ public class KeysIndex extends AbstractSimplePerColumnSecondaryIndex
         return new KeysSearcher(baseCfs.indexManager, columns);
     }
 
+    public boolean isIndexEntryStale(ByteBuffer indexedValue, ColumnFamily data)
+    {
+        Column liveColumn = data.getColumn(columnDef.name);
+        if (liveColumn == null || liveColumn.isMarkedForDelete())
+            return true;
+
+        ByteBuffer liveValue = liveColumn.value();
+        return columnDef.getValidator().compare(indexedValue, liveValue) != 0;
+    }
+
     public void validateOptions() throws ConfigurationException
     {
         // no options used
diff --git a/src/java/org/apache/cassandra/db/index/keys/KeysSearcher.java b/src/java/org/apache/cassandra/db/index/keys/KeysSearcher.java
index d5ea5535c8..9f5c594741 100644
--- a/src/java/org/apache/cassandra/db/index/keys/KeysSearcher.java
+++ b/src/java/org/apache/cassandra/db/index/keys/KeysSearcher.java
@@ -46,34 +46,6 @@ public class KeysSearcher extends SecondaryIndexSearcher
         super(indexManager, columns);
     }
 
-    private IndexExpression highestSelectivityPredicate(List<IndexExpression> clause)
-    {
-        IndexExpression best = null;
-        int bestMeanCount = Integer.MAX_VALUE;
-        for (IndexExpression expression : clause)
-        {
-            //skip columns belonging to a different index type
-            if(!columns.contains(expression.column_name))
-                continue;
-
-            SecondaryIndex index = indexManager.getIndexForColumn(expression.column_name);
-            if (index == null || (expression.op != IndexOperator.EQ))
-                continue;
-            int columns = index.getIndexCfs().getMeanColumns();
-            if (columns < bestMeanCount)
-            {
-                best = expression;
-                bestMeanCount = columns;
-            }
-        }
-        return best;
-    }
-
-    public boolean isIndexing(List<IndexExpression> clause)
-    {
-        return highestSelectivityPredicate(clause) != null;
-    }
-
     @Override
     public List<Row> search(List<IndexExpression> clause, AbstractBounds<RowPosition> range, int maxResults, IDiskAtomFilter dataFilter, boolean countCQL3Rows)
     {
@@ -201,8 +173,8 @@ public class KeysSearcher extends SecondaryIndexSearcher
                             if (cf != null)
                                 data.addAll(cf, HeapAllocator.instance);
                         }
-                        
-                        if (isIndexValueStale(data, primary.column_name, indexKey.key))
+
+                        if (((KeysIndex)index).isIndexEntryStale(indexKey.key, data))
                         {
                             // delete the index entry w/ its own timestamp
                             Column dummyColumn = new Column(primary.column_name, indexKey.key, column.timestamp());
diff --git a/src/java/org/apache/cassandra/db/marshal/AbstractType.java b/src/java/org/apache/cassandra/db/marshal/AbstractType.java
index e261e9d0c4..6804034ccd 100644
--- a/src/java/org/apache/cassandra/db/marshal/AbstractType.java
+++ b/src/java/org/apache/cassandra/db/marshal/AbstractType.java
@@ -19,7 +19,9 @@ package org.apache.cassandra.db.marshal;
 
 import java.nio.ByteBuffer;
 import java.util.Collection;
+import java.util.Collections;
 import java.util.Comparator;
+import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
@@ -245,6 +247,24 @@ public abstract class AbstractType<T> implements Comparator<ByteBuffer>
         return false;
     }
 
+    /**
+     * The number of subcomponents this type has.
+     * This is always 1, i.e. the type has only itself as "subcomponents", except for CompositeType.
+     */
+    public int componentsCount()
+    {
+        return 1;
+    }
+
+    /**
+     * Return a list of the "subcomponents" this type has.
+     * This always return a singleton list with the type itself except for CompositeType.
+     */
+    public List<AbstractType<?>> getComponents()
+    {
+        return Collections.<AbstractType<?>>singletonList(this);
+    }
+
     /**
      * This must be overriden by subclasses if necessary so that for any
      * AbstractType, this == TypeParser.parse(toString()).
diff --git a/src/java/org/apache/cassandra/db/marshal/CompositeType.java b/src/java/org/apache/cassandra/db/marshal/CompositeType.java
index c33903ea87..0db63683a6 100644
--- a/src/java/org/apache/cassandra/db/marshal/CompositeType.java
+++ b/src/java/org/apache/cassandra/db/marshal/CompositeType.java
@@ -148,6 +148,18 @@ public class CompositeType extends AbstractCompositeType
         return null;
     }
 
+    @Override
+    public int componentsCount()
+    {
+        return types.size();
+    }
+
+    @Override
+    public List<AbstractType<?>> getComponents()
+    {
+        return types;
+    }
+
     @Override
     public boolean isCompatibleWith(AbstractType<?> previous)
     {
@@ -305,6 +317,11 @@ public class CompositeType extends AbstractCompositeType
             return composite.types.size() - components.size();
         }
 
+        public ByteBuffer get(int i)
+        {
+            return components.get(i);
+        }
+
         public ByteBuffer build()
         {
             DataOutputBuffer out = new DataOutputBuffer(serializedSize);
@@ -337,5 +354,13 @@ public class CompositeType extends AbstractCompositeType
         {
             return new Builder(this);
         }
+
+        public ByteBuffer getComponent(int i)
+        {
+            if (i >= components.size())
+                throw new IllegalArgumentException();
+
+            return components.get(i);
+        }
     }
 }
diff --git a/src/java/org/apache/cassandra/service/MigrationManager.java b/src/java/org/apache/cassandra/service/MigrationManager.java
index 3d742a8b94..b9fcddb2c8 100644
--- a/src/java/org/apache/cassandra/service/MigrationManager.java
+++ b/src/java/org/apache/cassandra/service/MigrationManager.java
@@ -241,7 +241,7 @@ public class MigrationManager implements IEndpointStateChangeSubscriber
         announce(oldKsm.toSchemaUpdate(ksm, FBUtilities.timestampMicros()));
     }
 
-    public static void announceColumnFamilyUpdate(CFMetaData cfm) throws ConfigurationException
+    public static void announceColumnFamilyUpdate(CFMetaData cfm, boolean fromThrift) throws ConfigurationException
     {
         cfm.validate();
 
@@ -252,7 +252,7 @@ public class MigrationManager implements IEndpointStateChangeSubscriber
         oldCfm.validateCompatility(cfm);
 
         logger.info(String.format("Update ColumnFamily '%s/%s' From %s To %s", cfm.ksName, cfm.cfName, oldCfm, cfm));
-        announce(oldCfm.toSchemaUpdate(cfm, FBUtilities.timestampMicros()));
+        announce(oldCfm.toSchemaUpdate(cfm, FBUtilities.timestampMicros(), fromThrift));
     }
 
     public static void announceKeyspaceDrop(String ksName) throws ConfigurationException
diff --git a/src/java/org/apache/cassandra/thrift/CassandraServer.java b/src/java/org/apache/cassandra/thrift/CassandraServer.java
index 372267099b..b9d3901333 100644
--- a/src/java/org/apache/cassandra/thrift/CassandraServer.java
+++ b/src/java/org/apache/cassandra/thrift/CassandraServer.java
@@ -1536,7 +1536,7 @@ public class CassandraServer implements Cassandra.Iface
             CFMetaData cfm = CFMetaData.fromThrift(cf_def);
             CFMetaData.validateCompactionOptions(cfm.compactionStrategyClass, cfm.compactionStrategyOptions);
             cfm.addDefaultIndexNames();
-            MigrationManager.announceColumnFamilyUpdate(cfm);
+            MigrationManager.announceColumnFamilyUpdate(cfm, true);
             return Schema.instance.getVersion().toString();
         }
         catch (RequestValidationException e)
diff --git a/src/java/org/apache/cassandra/utils/ByteBufferUtil.java b/src/java/org/apache/cassandra/utils/ByteBufferUtil.java
index 0b27d03c4c..1ff2fc9422 100644
--- a/src/java/org/apache/cassandra/utils/ByteBufferUtil.java
+++ b/src/java/org/apache/cassandra/utils/ByteBufferUtil.java
@@ -534,4 +534,14 @@ public class ByteBufferUtil
     {
         return ByteBuffer.wrap(UUIDGen.decompose(uuid));
     }
+
+    // Returns whether {@code prefix} is a prefix of {@code value}.
+    public static boolean isPrefix(ByteBuffer prefix, ByteBuffer value)
+    {
+        if (prefix.remaining() > value.remaining())
+            return false;
+
+        int diff = value.remaining() - prefix.remaining();
+        return prefix.equals(value.duplicate().limit(value.remaining() - diff));
+    }
 }
diff --git a/test/unit/org/apache/cassandra/SchemaLoader.java b/test/unit/org/apache/cassandra/SchemaLoader.java
index b7abacb1c9..e3ef01a2c5 100644
--- a/test/unit/org/apache/cassandra/SchemaLoader.java
+++ b/test/unit/org/apache/cassandra/SchemaLoader.java
@@ -133,21 +133,9 @@ public class SchemaLoader
 
         // these column definitions will will be applied to the jdbc utf and integer column familes respectively.
         Map<ByteBuffer, ColumnDefinition> integerColumn = new HashMap<ByteBuffer, ColumnDefinition>();
-        integerColumn.put(IntegerType.instance.fromString("42"), new ColumnDefinition(
-            IntegerType.instance.fromString("42"),
-            UTF8Type.instance,
-            null,
-            null,
-            null,
-            null));
+        integerColumn.put(IntegerType.instance.fromString("42"), ColumnDefinition.regularDef(IntegerType.instance.fromString("42"), UTF8Type.instance, null));
         Map<ByteBuffer, ColumnDefinition> utf8Column = new HashMap<ByteBuffer, ColumnDefinition>();
-        utf8Column.put(UTF8Type.instance.fromString("fortytwo"), new ColumnDefinition(
-            UTF8Type.instance.fromString("fortytwo"),
-            IntegerType.instance,
-            null,
-            null,
-            null,
-            null));
+        utf8Column.put(UTF8Type.instance.fromString("fortytwo"), ColumnDefinition.regularDef(UTF8Type.instance.fromString("fortytwo"), IntegerType.instance, null));
 
         // Make it easy to test compaction
         Map<String, String> compactionOptions = new HashMap<String, String>();
@@ -338,12 +326,11 @@ public class SchemaLoader
                    {{
                         ByteBuffer cName = ByteBuffer.wrap("birthdate".getBytes(Charsets.UTF_8));
                         IndexType keys = withIdxType ? IndexType.KEYS : null;
-                        put(cName, new ColumnDefinition(cName, LongType.instance, keys, null, withIdxType ? ByteBufferUtil.bytesToHex(cName) : null, null));
+                        put(cName, ColumnDefinition.regularDef(cName, LongType.instance, null).setIndex(withIdxType ? ByteBufferUtil.bytesToHex(cName) : null, keys, null));
                     }});
     }
     private static CFMetaData compositeIndexCFMD(String ksName, String cfName, final Boolean withIdxType, boolean withOldCfIds) throws ConfigurationException
     {
-        final Map<String, String> idxOpts = Collections.singletonMap(CompositesIndex.PREFIX_SIZE_OPTION, "1");
         final CompositeType composite = CompositeType.getInstance(Arrays.asList(new AbstractType<?>[]{UTF8Type.instance, UTF8Type.instance})); 
         return new CFMetaData(ksName,
                 cfName,
@@ -354,7 +341,8 @@ public class SchemaLoader
                 {{
                    ByteBuffer cName = ByteBuffer.wrap("col1".getBytes(Charsets.UTF_8));
                    IndexType idxType = withIdxType ? IndexType.COMPOSITES : null;
-                   put(cName, new ColumnDefinition(cName, UTF8Type.instance, idxType, idxOpts, withIdxType ? "col1_idx" : null, 1));
+                   put(cName, ColumnDefinition.regularDef(cName, UTF8Type.instance, 1)
+                                              .setIndex(withIdxType ? "col1_idx" : null, idxType, Collections.<String, String>emptyMap()));
                 }});
     }
     
diff --git a/test/unit/org/apache/cassandra/cli/CliTest.java b/test/unit/org/apache/cassandra/cli/CliTest.java
index 0a3497b6bb..886eb71cc4 100644
--- a/test/unit/org/apache/cassandra/cli/CliTest.java
+++ b/test/unit/org/apache/cassandra/cli/CliTest.java
@@ -50,7 +50,6 @@ public class CliTest extends SchemaLoader
         "create column family 123 with comparator=UTF8Type and column_metadata=[{ column_name:world, validation_class:IntegerType, index_type:0, index_name:IdxName }, " +
                                                                                "{ column_name:world2, validation_class:LongType, index_type:KEYS, index_name:LongIdxName}, " +
                                                                                "{ column_name:617070, validation_class:UTF8Type, index_type:KEYS }, " +
-                                                                               "{ column_name:28292, validation_class:UTF8Type, index_type:CUSTOM, index_options:{class_name:'org.apache.cassandra.db.index.keys.KeysIndex', foo:bar}}," +
                                                                                "{ column_name:'-617071', validation_class:UTF8Type, index_type:KEYS }," +
                                                                                "{ column_name:time_spent_uuid, validation_class:TimeUUIDType}] and default_validation_class=UTF8Type;",
         "assume 123 keys as utf8;",
diff --git a/test/unit/org/apache/cassandra/config/CFMetaDataTest.java b/test/unit/org/apache/cassandra/config/CFMetaDataTest.java
index 8ca83ce0ab..d6670ede44 100644
--- a/test/unit/org/apache/cassandra/config/CFMetaDataTest.java
+++ b/test/unit/org/apache/cassandra/config/CFMetaDataTest.java
@@ -129,12 +129,11 @@ public class CFMetaDataTest extends SchemaLoader
         // are only used by CQL (so far) so we don't expose them through thrift
         // There is a CFM with componentIndex defined in Keyspace2 which is used by 
         // ColumnFamilyStoreTest to verify index repair (CASSANDRA-2897)
-        for (Map.Entry<ByteBuffer, ColumnDefinition> cMeta: cfm.column_metadata.entrySet())
+        for (ColumnDefinition def: cfm.allColumns())
         {
-            // Non-null componentIndex are only used by CQL (so far) so we don't expose
-            // them through thrift
-            if (cMeta.getValue().componentIndex != null)
-                cfm.column_metadata.remove(cMeta.getKey());
+            // Remove what we know is not thrift compatible
+            if (!def.isThriftCompatible())
+                cfm.removeColumnDefinition(def);
         }
 
         // Test thrift conversion
diff --git a/test/unit/org/apache/cassandra/config/ColumnDefinitionTest.java b/test/unit/org/apache/cassandra/config/ColumnDefinitionTest.java
index 1e2ef9cb90..fa7343c2df 100644
--- a/test/unit/org/apache/cassandra/config/ColumnDefinitionTest.java
+++ b/test/unit/org/apache/cassandra/config/ColumnDefinitionTest.java
@@ -33,19 +33,10 @@ public class ColumnDefinitionTest
     @Test
     public void testSerializeDeserialize() throws Exception
     {
-        ColumnDefinition cd0 = new ColumnDefinition(ByteBufferUtil.bytes("TestColumnDefinitionName0"),
-                                                    BytesType.instance,
-                                                    IndexType.KEYS,
-                                                    null,
-                                                    "random index name 0",
-                                                    null);
+        ColumnDefinition cd0 = ColumnDefinition.regularDef(ByteBufferUtil.bytes("TestColumnDefinitionName0"), BytesType.instance, null)
+                                               .setIndex("random index name 0", IndexType.KEYS, null);
 
-        ColumnDefinition cd1 = new ColumnDefinition(ByteBufferUtil.bytes("TestColumnDefinition1"),
-                                                    LongType.instance,
-                                                    null,
-                                                    null,
-                                                    null,
-                                                    null);
+        ColumnDefinition cd1 = ColumnDefinition.regularDef(ByteBufferUtil.bytes("TestColumnDefinition1"), LongType.instance, null);
 
         testSerializeDeserialize(cd0);
         testSerializeDeserialize(cd1);
diff --git a/test/unit/org/apache/cassandra/config/DefsTest.java b/test/unit/org/apache/cassandra/config/DefsTest.java
index 76cab94354..66d5f81f2d 100644
--- a/test/unit/org/apache/cassandra/config/DefsTest.java
+++ b/test/unit/org/apache/cassandra/config/DefsTest.java
@@ -63,7 +63,7 @@ public class DefsTest extends SchemaLoader
         for (int i = 0; i < 5; i++)
         {
             ByteBuffer name = ByteBuffer.wrap(new byte[] { (byte)i });
-            indexes.put(name, new ColumnDefinition(name, BytesType.instance, IndexType.KEYS, null, Integer.toString(i), null));
+            indexes.put(name, ColumnDefinition.regularDef(name, BytesType.instance, null).setIndex(Integer.toString(i), IndexType.KEYS, null));
         }
         CFMetaData cfm = new CFMetaData("Keyspace1",
                                         "TestApplyCFM_CF",
@@ -80,34 +80,26 @@ public class DefsTest extends SchemaLoader
            .columnMetadata(indexes);
 
         // we'll be adding this one later. make sure it's not already there.
-        assert cfm.getColumn_metadata().get(ByteBuffer.wrap(new byte[] { 5 })) == null;
+        assert cfm.getColumnDefinition(ByteBuffer.wrap(new byte[] { 5 })) == null;
 
         CFMetaData cfNew = cfm.clone();
 
         // add one.
-        ColumnDefinition addIndexDef = new ColumnDefinition(ByteBuffer.wrap(new byte[] { 5 }),
-                                                            BytesType.instance,
-                                                            IndexType.KEYS,
-                                                            null,
-                                                            "5",
-                                                            null);
+        ColumnDefinition addIndexDef = ColumnDefinition.regularDef(ByteBuffer.wrap(new byte[] { 5 }), BytesType.instance, null)
+                                                       .setIndex("5", IndexType.KEYS, null);
         cfNew.addColumnDefinition(addIndexDef);
 
         // remove one.
-        ColumnDefinition removeIndexDef = new ColumnDefinition(ByteBuffer.wrap(new byte[] { 0 }),
-                                                               BytesType.instance,
-                                                               IndexType.KEYS,
-                                                               null,
-                                                               "0",
-                                                               null);
+        ColumnDefinition removeIndexDef = ColumnDefinition.regularDef(ByteBuffer.wrap(new byte[] { 0 }), BytesType.instance, null)
+                                                          .setIndex("0", IndexType.KEYS, null);
         assert cfNew.removeColumnDefinition(removeIndexDef);
 
         cfm.apply(cfNew);
 
         for (int i = 1; i < indexes.size(); i++)
-            assert cfm.getColumn_metadata().get(ByteBuffer.wrap(new byte[] { 1 })) != null;
-        assert cfm.getColumn_metadata().get(ByteBuffer.wrap(new byte[] { 0 })) == null;
-        assert cfm.getColumn_metadata().get(ByteBuffer.wrap(new byte[] { 5 })) != null;
+            assert cfm.getColumnDefinition(ByteBuffer.wrap(new byte[] { 1 })) != null;
+        assert cfm.getColumnDefinition(ByteBuffer.wrap(new byte[] { 0 })) == null;
+        assert cfm.getColumnDefinition(ByteBuffer.wrap(new byte[] { 5 })) != null;
     }
 
     @Test
@@ -435,22 +427,22 @@ public class DefsTest extends SchemaLoader
 
         // test valid operations.
         newCfm.comment("Modified comment");
-        MigrationManager.announceColumnFamilyUpdate(newCfm); // doesn't get set back here.
+        MigrationManager.announceColumnFamilyUpdate(newCfm, false); // doesn't get set back here.
 
         newCfm.readRepairChance(0.23);
-        MigrationManager.announceColumnFamilyUpdate(newCfm);
+        MigrationManager.announceColumnFamilyUpdate(newCfm, false);
 
         newCfm.gcGraceSeconds(12);
-        MigrationManager.announceColumnFamilyUpdate(newCfm);
+        MigrationManager.announceColumnFamilyUpdate(newCfm, false);
 
         newCfm.defaultValidator(UTF8Type.instance);
-        MigrationManager.announceColumnFamilyUpdate(newCfm);
+        MigrationManager.announceColumnFamilyUpdate(newCfm, false);
 
         newCfm.minCompactionThreshold(3);
-        MigrationManager.announceColumnFamilyUpdate(newCfm);
+        MigrationManager.announceColumnFamilyUpdate(newCfm, false);
 
         newCfm.maxCompactionThreshold(33);
-        MigrationManager.announceColumnFamilyUpdate(newCfm);
+        MigrationManager.announceColumnFamilyUpdate(newCfm, false);
 
         // can't test changing the reconciler because there is only one impl.
 
@@ -529,10 +521,10 @@ public class DefsTest extends SchemaLoader
 
         // drop the index
         CFMetaData meta = cfs.metadata.clone();
-        ColumnDefinition cdOld = meta.getColumn_metadata().values().iterator().next();
-        ColumnDefinition cdNew = new ColumnDefinition(cdOld.name, cdOld.getValidator(), null, null, null, null);
+        ColumnDefinition cdOld = meta.regularColumns().iterator().next();
+        ColumnDefinition cdNew = ColumnDefinition.regularDef(cdOld.name, cdOld.getValidator(), null);
         meta.columnMetadata(Collections.singletonMap(cdOld.name, cdNew));
-        MigrationManager.announceColumnFamilyUpdate(meta);
+        MigrationManager.announceColumnFamilyUpdate(meta, false);
 
         // check
         assert cfs.indexManager.getIndexes().isEmpty();
diff --git a/test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java b/test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java
index fc744b88f0..8ac0baef63 100644
--- a/test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java
+++ b/test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java
@@ -597,8 +597,8 @@ public class ColumnFamilyStoreTest extends SchemaLoader
         rm.apply();
 
         ColumnFamilyStore cfs = table.getColumnFamilyStore("Indexed2");
-        ColumnDefinition old = cfs.metadata.getColumn_metadata().get(ByteBufferUtil.bytes("birthdate"));
-        ColumnDefinition cd = new ColumnDefinition(old.name, old.getValidator(), IndexType.KEYS, null, "birthdate_index", null);
+        ColumnDefinition old = cfs.metadata.getColumnDefinition(ByteBufferUtil.bytes("birthdate"));
+        ColumnDefinition cd = ColumnDefinition.regularDef(old.name, old.getValidator(), null).setIndex("birthdate_index", IndexType.KEYS, null);
         Future<?> future = cfs.indexManager.addIndexedColumn(cd);
         future.get();
         // we had a bug (CASSANDRA-2244) where index would get created but not flushed -- check for that
diff --git a/test/unit/org/apache/cassandra/thrift/ThriftValidationTest.java b/test/unit/org/apache/cassandra/thrift/ThriftValidationTest.java
index 45ab7485ce..e4f058c004 100644
--- a/test/unit/org/apache/cassandra/thrift/ThriftValidationTest.java
+++ b/test/unit/org/apache/cassandra/thrift/ThriftValidationTest.java
@@ -56,11 +56,10 @@ public class ThriftValidationTest extends SchemaLoader
         boolean gotException = false;
 
         // add a key_alias = "id"
-        newMetadata.keyAliases(Collections.singletonList(AsciiType.instance.decompose("id")));
-
         // should not throw IRE here
         try
         {
+            newMetadata.addColumnDefinition(ColumnDefinition.partitionKeyDef(AsciiType.instance.decompose("id"), UTF8Type.instance, null));
             newMetadata.validate();
         }
         catch (ConfigurationException e)
@@ -70,13 +69,13 @@ public class ThriftValidationTest extends SchemaLoader
 
         assert !gotException : "got unexpected ConfigurationException";
 
-        // add a column with name = "id"
-        newMetadata.addColumnDefinition(new ColumnDefinition(ByteBufferUtil.bytes("id"), UTF8Type.instance, null, null, null, null));
 
         gotException = false;
 
+        // add a column with name = "id"
         try
         {
+            newMetadata.addColumnDefinition(ColumnDefinition.regularDef(ByteBufferUtil.bytes("id"), UTF8Type.instance, null));
             newMetadata.validate();
         }
         catch (ConfigurationException e)
