diff --git a/src/java/org/apache/cassandra/db/AbstractColumnContainer.java b/src/java/org/apache/cassandra/db/AbstractColumnContainer.java
index c10bf0c964..79e62b6956 100644
--- a/src/java/org/apache/cassandra/db/AbstractColumnContainer.java
+++ b/src/java/org/apache/cassandra/db/AbstractColumnContainer.java
@@ -244,4 +244,16 @@ public abstract class AbstractColumnContainer implements IColumnContainer, IIter
             this.localDeletionTime = localDeletionTime;
         }
     }
+
+    public boolean hasExpiredTombstones(int gcBefore)
+    {
+        if (isMarkedForDelete() && getLocalDeletionTime() < gcBefore)
+            return true;
+
+        for (IColumn column : columns)
+            if (column.hasExpiredTombstones(gcBefore))
+                return true;
+
+        return false;
+    }
 }
diff --git a/src/java/org/apache/cassandra/db/Column.java b/src/java/org/apache/cassandra/db/Column.java
index 04c3372aa7..2af5396465 100644
--- a/src/java/org/apache/cassandra/db/Column.java
+++ b/src/java/org/apache/cassandra/db/Column.java
@@ -280,5 +280,10 @@ public class Column implements IColumn
         if (valueValidator != null)
             valueValidator.validate(value());
     }
+
+    public boolean hasExpiredTombstones(int gcBefore)
+    {
+        return isMarkedForDelete() && getLocalDeletionTime() < gcBefore;
+    }
 }
 
diff --git a/src/java/org/apache/cassandra/db/IColumn.java b/src/java/org/apache/cassandra/db/IColumn.java
index cfe504f0d9..40b99e4f91 100644
--- a/src/java/org/apache/cassandra/db/IColumn.java
+++ b/src/java/org/apache/cassandra/db/IColumn.java
@@ -71,6 +71,11 @@ public interface IColumn
      */
     boolean isLive();
 
+    /**
+     * @return true if the column or any its subcolumns expired before @param gcBefore
+     */
+    public boolean hasExpiredTombstones(int gcBefore);
+
     /**
      * For a standard column, this is the same as timestamp().
      * For a super column, this is the max column timestamp of the sub columns.
diff --git a/src/java/org/apache/cassandra/db/IColumnContainer.java b/src/java/org/apache/cassandra/db/IColumnContainer.java
index 1e6b42d9fb..b300706aec 100644
--- a/src/java/org/apache/cassandra/db/IColumnContainer.java
+++ b/src/java/org/apache/cassandra/db/IColumnContainer.java
@@ -44,7 +44,7 @@ public interface IColumnContainer
 
     public boolean isMarkedForDelete();
     public long getMarkedForDeleteAt();
-    public int getLocalDeletionTime();
+    public boolean hasExpiredTombstones(int gcBefore);
 
     public AbstractType getComparator();
 
diff --git a/src/java/org/apache/cassandra/db/compaction/PrecompactedRow.java b/src/java/org/apache/cassandra/db/compaction/PrecompactedRow.java
index 1248c10c26..e1e6590b82 100644
--- a/src/java/org/apache/cassandra/db/compaction/PrecompactedRow.java
+++ b/src/java/org/apache/cassandra/db/compaction/PrecompactedRow.java
@@ -66,7 +66,27 @@ public class PrecompactedRow extends AbstractCompactedRow
 
     public static ColumnFamily removeDeletedAndOldShards(DecoratedKey<?> key, CompactionController controller, ColumnFamily cf)
     {
-        return removeDeletedAndOldShards(controller.shouldPurge(key), controller, cf);
+        // avoid calling shouldPurge unless we actually need to: it can be very expensive if LCS
+        // gets behind and has hundreds of overlapping L0 sstables.  Essentially, this method is an
+        // ugly refactor of removeDeletedAndOldShards(controller.shouldPurge(key), controller, cf),
+        // taking this into account.
+        Boolean shouldPurge = null;
+
+        if (cf.hasExpiredTombstones(controller.gcBefore))
+            shouldPurge = controller.shouldPurge(key);
+        ColumnFamily compacted = shouldPurge != null && shouldPurge
+                               ? ColumnFamilyStore.removeDeleted(cf, controller.gcBefore)
+                               : cf;
+
+        if (compacted != null && compacted.metadata().getDefaultValidator().isCommutative())
+        {
+            if (shouldPurge == null)
+                shouldPurge = controller.shouldPurge(key);
+            if (shouldPurge)
+                CounterColumn.removeOldShards(compacted, controller.gcBefore);
+        }
+
+        return compacted;
     }
 
     public static ColumnFamily removeDeletedAndOldShards(boolean shouldPurge, CompactionController controller, ColumnFamily cf)
