diff --git a/src/java/org/apache/cassandra/journal/Journal.java b/src/java/org/apache/cassandra/journal/Journal.java
index 5ff826f69d..68b13d0dc1 100644
--- a/src/java/org/apache/cassandra/journal/Journal.java
+++ b/src/java/org/apache/cassandra/journal/Journal.java
@@ -52,10 +52,10 @@ import org.apache.cassandra.io.util.File;
 import org.apache.cassandra.io.util.PathUtils;
 import org.apache.cassandra.journal.Segments.ReferencedSegments;
 import org.apache.cassandra.service.StorageService;
+import org.apache.cassandra.utils.AbstractIterator;
 import org.apache.cassandra.utils.CloseableIterator;
 import org.apache.cassandra.utils.Crc;
 import org.apache.cassandra.utils.JVMStabilityInspector;
-import org.apache.cassandra.utils.LazyToString;
 import org.apache.cassandra.utils.MergeIterator;
 import org.apache.cassandra.utils.Simulate;
 import org.apache.cassandra.utils.concurrent.OpOrder;
@@ -966,15 +966,16 @@ public class Journal<K, V> implements Shutdownable
             return key;
         }
 
+        public void ensureSorted()
+        {
+            Arrays.sort(segments);
+        }
+
         private void add(K key, long segment)
         {
+            Invariants.require(this.key == null || key.equals(this.key));
             this.key = key;
-            if (size == 0 || segments[size - 1] < segment)
-                segments[size++] = segment;
-            else
-                Invariants.require(segments[size - 1] == segment,
-                                   "Tried to add an out-of-order segment: %d, %s", segment,
-                                   LazyToString.lazy(() -> Arrays.toString(Arrays.copyOf(segments, size))));
+            segments[size++] = segment;
         }
 
         private void reset()
@@ -983,6 +984,16 @@ public class Journal<K, V> implements Shutdownable
             size = 0;
             Arrays.fill(segments, 0);
         }
+
+        @Override
+        public String toString()
+        {
+            return "KeyRefs{" +
+                   "segments=" + Arrays.toString(segments) +
+                   ", key=" + key +
+                   ", size=" + size +
+                   '}';
+        }
     }
 
     public class StaticSegmentKeyIterator implements CloseableIterator<KeyRefs<K>>
@@ -998,31 +1009,37 @@ public class Journal<K, V> implements Shutdownable
             for (Segment<K, V> segment : segments.allSorted(true))
             {
                 StaticSegment<K, V> staticSegment = (StaticSegment<K, V>) segment;
-                Iterator<K> iter = staticSegment.index().reader();
-                Head head = new Head(staticSegment.descriptor.timestamp);
-                iterators.add(new Iterator<>()
+                iterators.add(new AbstractIterator<>()
                 {
-                    public boolean hasNext()
-                    {
-                        return iter.hasNext();
-                    }
+                    final Iterator<K> iter = staticSegment.index().reader();
+                    final Head head = new Head(staticSegment.descriptor.timestamp);
 
-                    public Head next()
+                    @Override
+                    protected Head computeNext()
                     {
-                        head.key = iter.next();
+                        if (!iter.hasNext())
+                            return endOfData();
+
+                        K next = iter.next();
+                        while (next.equals(head.key))
+                        {
+                            if (!iter.hasNext())
+                                return endOfData();
+
+                            next = iter.next();
+                        }
+
+                        Invariants.require(!next.equals(head.key),
+                                           "%s == %s", next, head.key);
+                        head.key = next;
                         return head;
                     }
                 });
             }
 
             this.iterator = MergeIterator.get(iterators,
-                                              (r1, r2) -> {
-                                                  int keyCmp = keySupport.compare(r1.key, r2.key);
-                                                  if (keyCmp != 0)
-                                                      return keyCmp;
-                                                  return Long.compare(r1.segment, r2.segment);
-                                              },
-                                              new MergeIterator.Reducer<Head, KeyRefs<K>>()
+                                              (r1, r2) -> keySupport.compare(r1.key, r2.key),
+                                              new MergeIterator.Reducer<>()
                                               {
                                                   final KeyRefs<K> ret = new KeyRefs<>(segments.count());
 
@@ -1035,6 +1052,7 @@ public class Journal<K, V> implements Shutdownable
                                                   @Override
                                                   protected KeyRefs<K> getReduced()
                                                   {
+                                                      ret.ensureSorted();
                                                       return ret;
                                                   }
 
diff --git a/src/java/org/apache/cassandra/service/accord/AbstractAccordSegmentCompactor.java b/src/java/org/apache/cassandra/service/accord/AbstractAccordSegmentCompactor.java
index 18f3de0633..954ae2a46c 100644
--- a/src/java/org/apache/cassandra/service/accord/AbstractAccordSegmentCompactor.java
+++ b/src/java/org/apache/cassandra/service/accord/AbstractAccordSegmentCompactor.java
@@ -89,6 +89,10 @@ public abstract class AbstractAccordSegmentCompactor<V> implements SegmentCompac
     abstract void finishAndAddWriter();
     abstract Throwable cleanupWriter(Throwable t);
 
+    // Only valid in the scope of a single `compact` call
+    private JournalKey prevKey;
+    private DecoratedKey prevDecoratedKey;
+
     @Override
     public Collection<StaticSegment<JournalKey, V>> compact(Collection<StaticSegment<JournalKey, V>> segments)
     {
@@ -191,20 +195,22 @@ public abstract class AbstractAccordSegmentCompactor<V> implements SegmentCompac
             t = cleanupWriter(t);
             throw new RuntimeException(String.format("Caught exception while serializing. Last seen key: %s", key), t);
         }
+        finally
+        {
+            prevKey = null;
+            prevDecoratedKey = null;
+        }
 
         finishAndAddWriter();
         return Collections.emptyList();
     }
 
-    private JournalKey prevKey;
-    private DecoratedKey prevDecoratedKey;
-
     private void maybeWritePartition(JournalKey key, FlyweightImage builder, FlyweightSerializer<Object, FlyweightImage> serializer, long descriptor, int offset) throws IOException
     {
         if (builder != null)
         {
             DecoratedKey decoratedKey = AccordKeyspace.JournalColumns.decorate(key);
-            Invariants.requireArgument(prevKey == null || ((decoratedKey.compareTo(prevDecoratedKey) >= 0 ? 1 : -1) == (JournalKey.SUPPORT.compare(key, prevKey) >= 0 ? 1 : -1)),
+            Invariants.requireArgument(prevKey == null || normalize(decoratedKey.compareTo(prevDecoratedKey)) == normalize(JournalKey.SUPPORT.compare(key, prevKey)),
                                        "Partition key and JournalKey didn't have matching order, which may imply a serialization issue.\n%s (%s)\n%s (%s)",
                                        key, decoratedKey, prevKey, prevDecoratedKey);
             prevKey = key;
@@ -222,5 +228,14 @@ public abstract class AbstractAccordSegmentCompactor<V> implements SegmentCompac
             writer().append(update.unfilteredIterator());
         }
     }
+
+    private static int normalize(int cmp)
+    {
+        if (cmp == 0)
+            return 0;
+        if (cmp < 0)
+            return -1;
+        return 1;
+    }
 }
 
diff --git a/src/java/org/apache/cassandra/service/accord/AccordCommandStores.java b/src/java/org/apache/cassandra/service/accord/AccordCommandStores.java
index 4cec60f50c..6fa8fa6224 100644
--- a/src/java/org/apache/cassandra/service/accord/AccordCommandStores.java
+++ b/src/java/org/apache/cassandra/service/accord/AccordCommandStores.java
@@ -219,23 +219,29 @@ public class AccordCommandStores extends CommandStores implements CacheSize
 
     public void waitForQuiescense()
     {
-        boolean hadPending;
+        boolean runAgain = true;
         try
         {
-            do
+            while (true)
             {
-                hadPending = false;
+                boolean hasTasks = false;
                 List<Future<?>> futures = new ArrayList<>();
                 for (AccordExecutor executor : this.executors)
                 {
-                    hadPending |= executor.hasTasks();
+                    hasTasks |= executor.hasTasks();
+                    hasTasks |= Stage.MUTATION.executor().getPendingTaskCount() > 0;
+                    hasTasks |= Stage.MUTATION.executor().getActiveTaskCount() > 0;
                     futures.add(executor.submit(() -> {}));
                 }
                 for (Future<?> future : futures)
                     future.get();
                 futures.clear();
+
+                if (!runAgain)
+                    return;
+                
+                runAgain = hasTasks;
             }
-            while (hadPending);
         }
         catch (ExecutionException e)
         {
diff --git a/src/java/org/apache/cassandra/service/accord/AccordJournal.java b/src/java/org/apache/cassandra/service/accord/AccordJournal.java
index cdd8b45f5d..9730fe84d4 100644
--- a/src/java/org/apache/cassandra/service/accord/AccordJournal.java
+++ b/src/java/org/apache/cassandra/service/accord/AccordJournal.java
@@ -439,6 +439,7 @@ public class AccordJournal implements accord.api.Journal, RangeSearcher.Supplier
     {
         try (CloseableIterator<Journal.KeyRefs<JournalKey>> iter = journalTable.keyIterator())
         {
+            TxnId prev = null;
             while (iter.hasNext())
             {
                 Journal.KeyRefs<JournalKey> ref = iter.next();
@@ -448,16 +449,20 @@ public class AccordJournal implements accord.api.Journal, RangeSearcher.Supplier
 
                 CommandStore commandStore = commandStores.forId(ref.key().commandStoreId);
                 Loader loader = commandStore.loader();
+                TxnId txnId = ref.key().id;
+                Invariants.require(prev == null || txnId.compareTo(prev) != 0,
+                                   "duplicate key detected %s == %s", txnId, prev);
+                prev = txnId;
                 try
                 {
-                    AsyncChains.getUnchecked(loader.load(ref.key().id)
+                    AsyncChains.getUnchecked(loader.load(txnId)
                                                    .map(command -> {
                                                        if (journalTable.shouldIndex(ref.key())
                                                            && command.participants() != null
                                                            && command.participants().route() != null)
                                                        {
                                                            ref.segments(segment -> {
-                                                               journalTable.safeNotify(index -> index.update(segment, ref.key().commandStoreId, ref.key().id, command.participants().route()));
+                                                               journalTable.safeNotify(index -> index.update(segment, ref.key().commandStoreId, txnId, command.participants().route()));
                                                            });
                                                        }
                                                        return command;
diff --git a/src/java/org/apache/cassandra/service/accord/AccordJournalTable.java b/src/java/org/apache/cassandra/service/accord/AccordJournalTable.java
index c244bb6216..0404ea5ad3 100644
--- a/src/java/org/apache/cassandra/service/accord/AccordJournalTable.java
+++ b/src/java/org/apache/cassandra/service/accord/AccordJournalTable.java
@@ -485,13 +485,19 @@ public class AccordJournalTable<K extends JournalKey, V> implements RangeSearche
         @CheckForNull
         protected K computeNext()
         {
+            K ret = null;
             if (mergeIterator.hasNext())
             {
                 try (UnfilteredRowIterator partition = mergeIterator.next())
                 {
-                    return (K) AccordKeyspace.JournalColumns.getJournalKey(partition.partitionKey());
+                    ret = (K) AccordKeyspace.JournalColumns.getJournalKey(partition.partitionKey());
+                    while (partition.hasNext())
+                        partition.next();
                 }
             }
+
+            if (ret != null)
+                return ret;
             else
                 return endOfData();
         }
@@ -515,10 +521,36 @@ public class AccordJournalTable<K extends JournalKey, V> implements RangeSearche
             this.journalIterator = journal.staticSegmentKeyIterator();
         }
 
+        K prevFromTable = null;
+        K prevFromJournal = null;
+
+        @Override
         protected Journal.KeyRefs<K> computeNext()
         {
             K tableKey = tableIterator.hasNext() ? tableIterator.peek() : null;
-            Journal.KeyRefs<K> journalKey = journalIterator.hasNext() ? journalIterator.peek() : null;
+            K journalKey = journalIterator.hasNext() ? journalIterator.peek().key() : null;
+
+            if (journalKey != null)
+            {
+                Invariants.require(prevFromJournal == null || keySupport.compare(journalKey, prevFromJournal) >= 0, // == for case where we have not consumed previous on prev iteration
+                                   "Incorrect sort order in journal segments: %s should strictrly follow %s " + this, journalKey, prevFromJournal);
+                prevFromJournal = journalKey;
+            }
+            else
+            {
+                prevFromJournal = null;
+            }
+
+            if (tableKey != null)
+            {
+                Invariants.require(prevFromTable == null || keySupport.compare(tableKey, prevFromTable) >= 0, // == for case where we have not consumed previous on prev iteration
+                                   "Incorrect sort order in journal table: %s should strictrly follow %s " + this, tableKey, prevFromTable);
+                prevFromTable = tableKey;
+            }
+            else
+            {
+                prevFromTable = null;
+            }
 
             if (tableKey == null)
                 return journalKey == null ? endOfData() : journalIterator.next();
@@ -526,7 +558,7 @@ public class AccordJournalTable<K extends JournalKey, V> implements RangeSearche
             if (journalKey == null)
                 return new Journal.KeyRefs<>(tableIterator.next());
 
-            int cmp = keySupport.compare(tableKey, journalKey.key());
+            int cmp = keySupport.compare(tableKey, journalKey);
             if (cmp == 0)
             {
                 tableIterator.next();
