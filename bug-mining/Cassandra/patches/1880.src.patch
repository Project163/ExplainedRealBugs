diff --git a/CHANGES.txt b/CHANGES.txt
index 12cc92aea0..48cb94557f 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -43,6 +43,7 @@
  * Fix binary protocol NEW_NODE event (CASSANDRA-4679)
  * Fix potential infinite loop in tombstone compaction (CASSANDRA-4781)
  * Remove system tables accounting from schema (CASSANDRA-4850)
+ * Force provided columns in clustering key order in 'CLUSTERING ORDER BY' (CASSANDRA-4881)
 Merged from 1.1:
  * add get[Row|Key]CacheEntries to CacheServiceMBean (CASSANDRA-4859)
  * fix get_paged_slice to wrap to next row correctly (CASSANDRA-4816)
diff --git a/src/java/org/apache/cassandra/cql3/statements/CreateColumnFamilyStatement.java b/src/java/org/apache/cassandra/cql3/statements/CreateColumnFamilyStatement.java
index 1775398343..b8ea73299c 100644
--- a/src/java/org/apache/cassandra/cql3/statements/CreateColumnFamilyStatement.java
+++ b/src/java/org/apache/cassandra/cql3/statements/CreateColumnFamilyStatement.java
@@ -20,6 +20,7 @@ package org.apache.cassandra.cql3.statements;
 import java.nio.ByteBuffer;
 import java.util.ArrayList;
 import java.util.HashMap;
+import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 
@@ -144,7 +145,7 @@ public class CreateColumnFamilyStatement extends SchemaAlteringStatement
 
         private final List<List<ColumnIdentifier>> keyAliases = new ArrayList<List<ColumnIdentifier>>();
         private final List<ColumnIdentifier> columnAliases = new ArrayList<ColumnIdentifier>();
-        private final Map<ColumnIdentifier, Boolean> definedOrdering = new HashMap<ColumnIdentifier, Boolean>();
+        private final Map<ColumnIdentifier, Boolean> definedOrdering = new LinkedHashMap<ColumnIdentifier, Boolean>(); // Insertion ordering is important
 
         private boolean useCompactStorage;
         private final Multiset<ColumnIdentifier> definedNames = HashMultiset.create(1);
@@ -305,6 +306,28 @@ public class CreateColumnFamilyStatement extends SchemaAlteringStatement
                     : CFDefinition.definitionType;
             }
 
+
+            // If we give a clustering order, we must explicitely do so for all aliases and in the order of the PK
+            if (!definedOrdering.isEmpty())
+            {
+                if (definedOrdering.size() > columnAliases.size())
+                    throw new InvalidRequestException("Too much columns provided for CLUSTERING ORDER");
+
+                int i = 0;
+                for (ColumnIdentifier id : definedOrdering.keySet())
+                {
+                    ColumnIdentifier c = columnAliases.get(i);
+                    if (!id.equals(c))
+                    {
+                        if (definedOrdering.containsKey(c))
+                            throw new InvalidRequestException(String.format("The order of columns in the CLUSTERING ORDER directive must be the one of the clustering key (%s must appear before %s)", c, id));
+                        else
+                            throw new InvalidRequestException(String.format("Missing CLUSTERING ORDER for column %s", c));
+                    }
+                    ++i;
+                }
+            }
+
             return new ParsedStatement.Prepared(stmt);
         }
 
