diff --git a/test/unit/org/apache/cassandra/gms/ShadowRoundTest.java b/test/unit/org/apache/cassandra/gms/ShadowRoundTest.java
index f8cc49cd64..bc188135ef 100644
--- a/test/unit/org/apache/cassandra/gms/ShadowRoundTest.java
+++ b/test/unit/org/apache/cassandra/gms/ShadowRoundTest.java
@@ -107,10 +107,10 @@ public class ShadowRoundTest
         }
 
         // we expect one SYN for each seed during shadow round + additional SYNs after gossiper has been enabled
-        assertTrue(spySyn.messagesIntercepted > noOfSeeds);
+        assertTrue(spySyn.messagesIntercepted() > noOfSeeds);
 
         // we don't expect to emit any GOSSIP_DIGEST_ACK2 or MIGRATION_REQUEST messages
-        assertEquals(0, spyAck2.messagesIntercepted);
-        assertEquals(0, spyMigrationReq.messagesIntercepted);
+        assertEquals(0, spyAck2.messagesIntercepted());
+        assertEquals(0, spyMigrationReq.messagesIntercepted());
     }
 }
diff --git a/test/unit/org/apache/cassandra/net/MockMessagingServiceTest.java b/test/unit/org/apache/cassandra/net/MockMessagingServiceTest.java
index 3f6564e092..ab97aaa891 100644
--- a/test/unit/org/apache/cassandra/net/MockMessagingServiceTest.java
+++ b/test/unit/org/apache/cassandra/net/MockMessagingServiceTest.java
@@ -25,6 +25,7 @@ import org.junit.BeforeClass;
 import org.junit.Test;
 
 import org.apache.cassandra.SchemaLoader;
+import org.apache.cassandra.Util;
 import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.gms.EchoMessage;
 import org.apache.cassandra.service.StorageService;
@@ -86,10 +87,10 @@ public class MockMessagingServiceTest
 
         // we must have intercepted the outgoing message at this point
         MessageOut<?> msg = spy.captureMessageOut().get();
-        assertEquals(1, spy.messagesIntercepted);
+        assertEquals(1, spy.messagesIntercepted());
         assertTrue(msg == echoMessageOut);
 
         // and return a mocked response
-        assertEquals(1, spy.mockedMessageResponses);
+        Util.spinAssertEquals(1, spy::mockedMessageResponses, 60);
     }
 }
diff --git a/test/unit/org/apache/cassandra/net/MockMessagingSpy.java b/test/unit/org/apache/cassandra/net/MockMessagingSpy.java
index 80bdb39a0f..2219c5ac76 100644
--- a/test/unit/org/apache/cassandra/net/MockMessagingSpy.java
+++ b/test/unit/org/apache/cassandra/net/MockMessagingSpy.java
@@ -24,6 +24,7 @@ import java.util.concurrent.Executor;
 import java.util.concurrent.Executors;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
 
 import com.google.common.util.concurrent.AbstractFuture;
 import com.google.common.util.concurrent.Futures;
@@ -40,8 +41,8 @@ public class MockMessagingSpy
 {
     private static final Logger logger = LoggerFactory.getLogger(MockMessagingSpy.class);
 
-    public int messagesIntercepted = 0;
-    public int mockedMessageResponses = 0;
+    private final AtomicInteger messagesIntercepted = new AtomicInteger();
+    private final AtomicInteger mockedMessageResponses = new AtomicInteger();
 
     private final BlockingQueue<MessageOut<?>> interceptedMessages = new LinkedBlockingQueue<>();
     private final BlockingQueue<MessageIn<?>> deliveredResponses = new LinkedBlockingQueue<>();
@@ -130,21 +131,30 @@ public class MockMessagingSpy
         return ret;
     }
 
+    public int messagesIntercepted()
+    {
+        return messagesIntercepted.get();
+    }
+
+    public int mockedMessageResponses()
+    {
+        return mockedMessageResponses.get();
+    }
+
     void matchingMessage(MessageOut<?> message)
     {
-        messagesIntercepted++;
+        messagesIntercepted.incrementAndGet();
         logger.trace("Received matching message: {}", message);
         interceptedMessages.add(message);
     }
 
     void matchingResponse(MessageIn<?> response)
     {
-        mockedMessageResponses++;
+        mockedMessageResponses.incrementAndGet();
         logger.trace("Responding to intercepted message: {}", response);
         deliveredResponses.add(response);
     }
 
-
     private static class CapturedResultsFuture<T> extends AbstractFuture<List<T>> implements Runnable
     {
         private final int waitForResults;
