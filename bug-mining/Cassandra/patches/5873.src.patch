diff --git a/src/java/org/apache/cassandra/gms/VersionedValue.java b/src/java/org/apache/cassandra/gms/VersionedValue.java
index 2d345b9cfa..4323e0fcea 100644
--- a/src/java/org/apache/cassandra/gms/VersionedValue.java
+++ b/src/java/org/apache/cassandra/gms/VersionedValue.java
@@ -26,6 +26,7 @@ import java.util.stream.Collectors;
 
 import static java.nio.charset.StandardCharsets.ISO_8859_1;
 
+import com.google.common.annotations.VisibleForTesting;
 import com.google.common.collect.Iterables;
 
 import org.apache.cassandra.db.TypeSizes;
@@ -97,6 +98,12 @@ public class VersionedValue implements Comparable<VersionedValue>
         this.version = version;
     }
 
+    @VisibleForTesting
+    public static VersionedValue unsafeMakeVersionedValue(String value, int version)
+    {
+        return new VersionedValue(value, version);
+    }
+
     private VersionedValue(String value)
     {
         this(value, VersionGenerator.getNextVersion());
diff --git a/src/java/org/apache/cassandra/schema/SchemaKeyspace.java b/src/java/org/apache/cassandra/schema/SchemaKeyspace.java
index 695fb4fb48..3c49327623 100644
--- a/src/java/org/apache/cassandra/schema/SchemaKeyspace.java
+++ b/src/java/org/apache/cassandra/schema/SchemaKeyspace.java
@@ -44,6 +44,8 @@ import org.apache.cassandra.db.rows.*;
 import org.apache.cassandra.db.view.View;
 import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.exceptions.InvalidRequestException;
+import org.apache.cassandra.locator.LocalStrategy;
+import org.apache.cassandra.service.PendingRangeCalculatorService;
 import org.apache.cassandra.transport.Server;
 import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.cassandra.utils.FBUtilities;
@@ -1382,6 +1384,13 @@ public final class SchemaKeyspace
             keyspace.views.forEach(Schema.instance::addView);
             keyspace.functions.udfs().forEach(Schema.instance::addFunction);
             keyspace.functions.udas().forEach(Schema.instance::addAggregate);
+
+            // If keyspace has been added, we need to recalculate pending ranges to make sure
+            // we send mutations to the correct set of bootstrapping nodes. Refer CASSANDRA-15433.
+            if (keyspace.params.replication.klass != LocalStrategy.class)
+            {
+                PendingRangeCalculatorService.calculatePendingRanges(Keyspace.open(keyspace.name).getReplicationStrategy(), keyspace.name);
+            }
         }
 
         // updated keyspaces
diff --git a/test/distributed/org/apache/cassandra/distributed/action/GossipHelper.java b/test/distributed/org/apache/cassandra/distributed/action/GossipHelper.java
new file mode 100644
index 0000000000..75eb5d4186
--- /dev/null
+++ b/test/distributed/org/apache/cassandra/distributed/action/GossipHelper.java
@@ -0,0 +1,142 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.cassandra.distributed.action;
+
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+import java.util.UUID;
+
+import org.apache.cassandra.dht.IPartitioner;
+import org.apache.cassandra.dht.Token;
+import org.apache.cassandra.distributed.shared.VersionedApplicationState;
+import org.apache.cassandra.distributed.api.IInstance;
+import org.apache.cassandra.distributed.api.IInvokableInstance;
+import org.apache.cassandra.distributed.api.IIsolatedExecutor;
+import org.apache.cassandra.gms.ApplicationState;
+import org.apache.cassandra.gms.EndpointState;
+import org.apache.cassandra.gms.Gossiper;
+import org.apache.cassandra.gms.VersionedValue;
+import org.apache.cassandra.service.StorageService;
+import org.apache.cassandra.utils.FBUtilities;
+
+public class GossipHelper
+{
+    public static InstanceAction statusToBootstrap(IInvokableInstance newNode)
+    {
+        return (instance) ->
+        {
+            changeGossipState(instance,
+                              newNode,
+                              Arrays.asList(tokens(newNode),
+                                            statusBootstrapping(newNode)));
+        };
+    }
+
+    public static void withProperty(String prop, String value, Runnable r)
+    {
+        String before = System.getProperty(prop);
+        try
+        {
+            System.setProperty(prop, value);
+            r.run();
+        }
+        finally
+        {
+            if (before == null)
+                System.clearProperty(prop);
+            else
+                System.setProperty(prop, before);
+        }
+    }
+
+    private static VersionedApplicationState unsafeVersionedValue(IInvokableInstance instance,
+                                                                  ApplicationState applicationState,
+                                                                  IIsolatedExecutor.SerializableBiFunction<IPartitioner, Collection<Token>, VersionedValue> supplier,
+                                                                  String partitionerStr, String initialTokenStr)
+    {
+        return instance.appliesOnInstance((String partitionerString, String tokenString) -> {
+            IPartitioner partitioner = FBUtilities.newPartitioner(partitionerString);
+            Token token = partitioner.getTokenFactory().fromString(tokenString);
+
+            VersionedValue versionedValue = supplier.apply(partitioner, Collections.singleton(token));
+            return new VersionedApplicationState(applicationState.ordinal(), versionedValue.value, versionedValue.version);
+        }).apply(partitionerStr, initialTokenStr);
+    }
+
+    /**
+     * Changes gossip state of the `peer` on `target`
+     */
+    public static void changeGossipState(IInvokableInstance target, IInstance peer, List<VersionedApplicationState> newState)
+    {
+        InetSocketAddress addr = peer.broadcastAddress();
+        UUID hostId = peer.config().hostId();
+        target.runOnInstance(() -> {
+            InetAddress endpoint = addr.getAddress();
+            StorageService storageService = StorageService.instance;
+
+            Gossiper.runInGossipStageBlocking(() -> {
+                EndpointState state = Gossiper.instance.getEndpointStateForEndpoint(endpoint);
+                if (state == null)
+                {
+                    Gossiper.instance.initializeNodeUnsafe(endpoint, hostId, 1);
+                    state = Gossiper.instance.getEndpointStateForEndpoint(endpoint);
+                    if (state.isAlive() && !Gossiper.instance.isDeadState(state))
+                        Gossiper.instance.realMarkAlive(endpoint, state);
+                }
+
+                for (VersionedApplicationState value : newState)
+                {
+                    ApplicationState as = toApplicationState(value);
+                    VersionedValue vv = toVersionedValue(value);
+                    state.addApplicationState(as, vv);
+                    storageService.onChange(endpoint, as, vv);
+                }
+            });
+        });
+    }
+
+    public static VersionedValue toVersionedValue(VersionedApplicationState vv)
+    {
+        return VersionedValue.unsafeMakeVersionedValue(vv.value, vv.version);
+    }
+
+    public static VersionedApplicationState tokens(IInvokableInstance instance)
+    {
+        return versionedToken(instance, ApplicationState.TOKENS, (partitioner, tokens) -> new VersionedValue.VersionedValueFactory(partitioner).tokens(tokens));
+    }
+
+    public static ApplicationState toApplicationState(VersionedApplicationState vv)
+    {
+        return ApplicationState.values()[vv.applicationState];
+    }
+
+    public static VersionedApplicationState versionedToken(IInvokableInstance instance, ApplicationState applicationState, IIsolatedExecutor.SerializableBiFunction<IPartitioner, Collection<Token>, VersionedValue> supplier)
+    {
+        return unsafeVersionedValue(instance, applicationState, supplier, instance.config().getString("partitioner"), instance.config().getString("initial_token"));
+    }
+
+    public static VersionedApplicationState statusBootstrapping(IInvokableInstance instance)
+    {
+        return versionedToken(instance, ApplicationState.STATUS, (partitioner, tokens) -> new VersionedValue.VersionedValueFactory(partitioner).bootstrapping(tokens));
+    }
+}
\ No newline at end of file
diff --git a/test/distributed/org/apache/cassandra/distributed/action/InstanceAction.java b/test/distributed/org/apache/cassandra/distributed/action/InstanceAction.java
new file mode 100644
index 0000000000..ce14dbcafd
--- /dev/null
+++ b/test/distributed/org/apache/cassandra/distributed/action/InstanceAction.java
@@ -0,0 +1,27 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.cassandra.distributed.action;
+
+import java.util.function.Consumer;
+
+import org.apache.cassandra.distributed.api.IInvokableInstance;
+
+public interface InstanceAction extends Consumer<IInvokableInstance>
+{
+}
diff --git a/test/distributed/org/apache/cassandra/distributed/shared/VersionedApplicationState.java b/test/distributed/org/apache/cassandra/distributed/shared/VersionedApplicationState.java
new file mode 100644
index 0000000000..789cce8d12
--- /dev/null
+++ b/test/distributed/org/apache/cassandra/distributed/shared/VersionedApplicationState.java
@@ -0,0 +1,35 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.cassandra.distributed.shared;
+
+import java.io.Serializable;
+
+public class VersionedApplicationState implements Serializable
+{
+    public final int applicationState;
+    public final String value;
+    public final int version;
+
+    public VersionedApplicationState(int applicationState, String value, int version)
+    {
+        this.applicationState = applicationState;
+        this.value = value;
+        this.version = version;
+    }
+}
\ No newline at end of file
diff --git a/test/distributed/org/apache/cassandra/distributed/test/BootstrapTest.java b/test/distributed/org/apache/cassandra/distributed/test/BootstrapTest.java
index 934ad65acc..d14400f31c 100644
--- a/test/distributed/org/apache/cassandra/distributed/test/BootstrapTest.java
+++ b/test/distributed/org/apache/cassandra/distributed/test/BootstrapTest.java
@@ -25,10 +25,14 @@ import java.util.stream.IntStream;
 import org.junit.Assert;
 import org.junit.Test;
 
+import static org.apache.cassandra.distributed.action.GossipHelper.statusToBootstrap;
+import static org.apache.cassandra.distributed.action.GossipHelper.withProperty;
+
 import org.apache.cassandra.distributed.Cluster;
 import org.apache.cassandra.distributed.api.ConsistencyLevel;
 import org.apache.cassandra.distributed.api.ICluster;
 import org.apache.cassandra.distributed.api.IInstanceConfig;
+import org.apache.cassandra.distributed.api.IInvokableInstance;
 import org.apache.cassandra.distributed.api.TokenSupplier;
 import org.apache.cassandra.distributed.shared.NetworkTopology;
 
@@ -38,7 +42,6 @@ import static org.apache.cassandra.distributed.api.Feature.NETWORK;
 // TODO: this test should be removed after running in-jvm dtests is set up via the shared API repository
 public class BootstrapTest extends TestBaseImpl
 {
-
     @Test
     public void bootstrapTest() throws Throwable
     {
@@ -53,7 +56,7 @@ public class BootstrapTest extends TestBaseImpl
         Map<Integer, Long> naturally = null;
         try (Cluster cluster = builder.withNodes(originalNodeCount).start())
         {
-            populate(cluster);
+            populate(cluster, 0, 1000);
 
             IInstanceConfig config = cluster.newInstanceConfig();
             config.set("auto_bootstrap", true);
@@ -73,7 +76,7 @@ public class BootstrapTest extends TestBaseImpl
 
         try (ICluster cluster = builder.start())
         {
-            populate(cluster);
+            populate(cluster, 0, 1000);
             naturally = count(cluster);
         }
 
@@ -81,12 +84,37 @@ public class BootstrapTest extends TestBaseImpl
             Assert.assertTrue(e.getValue() >= naturally.get(e.getKey()));
     }
 
-    public void populate(ICluster cluster)
+    @Test
+    public void readWriteDuringBootstrapTest() throws Throwable
+    {
+        int originalNodeCount = 2;
+        int expandedNodeCount = originalNodeCount + 1;
+
+        try (Cluster cluster = builder().withNodes(originalNodeCount)
+                                        .withTokenSupplier(TokenSupplier.evenlyDistributedTokens(expandedNodeCount))
+                                        .withNodeIdTopology(NetworkTopology.singleDcNetworkTopology(expandedNodeCount, "dc0", "rack0"))
+                                        .withConfig(config -> config.with(NETWORK, GOSSIP))
+                                        .start())
+        {
+            IInstanceConfig config = cluster.newInstanceConfig();
+            IInvokableInstance newInstance = cluster.bootstrap(config);
+            withProperty("cassandra.join_ring", Boolean.toString(false),
+                         () -> newInstance.startup(cluster));
+
+            cluster.forEach(statusToBootstrap(newInstance));
+
+            populate(cluster,0, 100);
+
+            Assert.assertEquals(100, newInstance.executeInternal("SELECT *FROM " + KEYSPACE + ".tbl").length);
+        }
+    }
+
+    public void populate(ICluster cluster, int from, int to)
     {
         cluster.schemaChange("CREATE KEYSPACE " + KEYSPACE + " WITH replication = {'class': 'SimpleStrategy', 'replication_factor': " + 3 + "};");
         cluster.schemaChange("CREATE TABLE " + KEYSPACE + ".tbl (pk int, ck int, v int, PRIMARY KEY (pk, ck))");
 
-        for (int i = 0; i < 1000; i++)
+        for (int i = from; i < to; i++)
             cluster.coordinator(1).execute("INSERT INTO " + KEYSPACE + ".tbl (pk, ck, v) VALUES (?, ?, ?)",
                                            ConsistencyLevel.QUORUM,
                                            i, i, i);
