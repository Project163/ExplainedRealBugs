diff --git a/CHANGES.txt b/CHANGES.txt
index cda1b8b0d7..888e159b4c 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 4.0
+ * Make protocol checksum type option case insensitive (CASSANDRA-14716)
  * Forbid re-adding static columns as regular and vice versa (CASSANDRA-14913)
  * Audit log allows system keyspaces to be audited via configuration options (CASSANDRA-14498)
  * Lower default chunk_length_in_kb from 64kb to 16kb (CASSANDRA-13241)
diff --git a/src/java/org/apache/cassandra/transport/Client.java b/src/java/org/apache/cassandra/transport/Client.java
index eacd5a9e9c..ec86579f59 100644
--- a/src/java/org/apache/cassandra/transport/Client.java
+++ b/src/java/org/apache/cassandra/transport/Client.java
@@ -142,8 +142,8 @@ public class Client extends SimpleClient
                    case "adler32": {
                        if (options.containsKey(StartupMessage.CHECKSUM))
                            throw new RuntimeException("Multiple checksum types supplied");
-                       options.put(StartupMessage.CHECKSUM, ChecksumType.Adler32.name());
-                       checksumType = ChecksumType.Adler32;
+                       options.put(StartupMessage.CHECKSUM, ChecksumType.ADLER32.name());
+                       checksumType = ChecksumType.ADLER32;
                        break;
                    }
                }
diff --git a/src/java/org/apache/cassandra/transport/frame/checksum/ChecksummingTransformer.java b/src/java/org/apache/cassandra/transport/frame/checksum/ChecksummingTransformer.java
index 3b15cee928..b2aeac9025 100644
--- a/src/java/org/apache/cassandra/transport/frame/checksum/ChecksummingTransformer.java
+++ b/src/java/org/apache/cassandra/transport/frame/checksum/ChecksummingTransformer.java
@@ -106,15 +106,15 @@ public class ChecksummingTransformer implements FrameBodyTransformer
     private static final int CHUNK_HEADER_OVERHEAD = Integer.BYTES + Integer.BYTES + Integer.BYTES + Integer.BYTES;
 
     private static final ChecksummingTransformer CRC32_NO_COMPRESSION = new ChecksummingTransformer(ChecksumType.CRC32, null);
-    private static final ChecksummingTransformer ADLER32_NO_COMPRESSION = new ChecksummingTransformer(ChecksumType.Adler32, null);
+    private static final ChecksummingTransformer ADLER32_NO_COMPRESSION = new ChecksummingTransformer(ChecksumType.ADLER32, null);
     private static final ImmutableTable<ChecksumType, Compressor, ChecksummingTransformer> transformers;
     static
     {
         ImmutableTable.Builder<ChecksumType, Compressor, ChecksummingTransformer> builder = ImmutableTable.builder();
         builder.put(ChecksumType.CRC32, LZ4Compressor.INSTANCE, new ChecksummingTransformer(ChecksumType.CRC32, LZ4Compressor.INSTANCE));
         builder.put(ChecksumType.CRC32, SnappyCompressor.INSTANCE, new ChecksummingTransformer(ChecksumType.CRC32, SnappyCompressor.INSTANCE));
-        builder.put(ChecksumType.Adler32, LZ4Compressor.INSTANCE, new ChecksummingTransformer(ChecksumType.Adler32, LZ4Compressor.INSTANCE));
-        builder.put(ChecksumType.Adler32, SnappyCompressor.INSTANCE, new ChecksummingTransformer(ChecksumType.Adler32, SnappyCompressor.INSTANCE));
+        builder.put(ChecksumType.ADLER32, LZ4Compressor.INSTANCE, new ChecksummingTransformer(ChecksumType.ADLER32, LZ4Compressor.INSTANCE));
+        builder.put(ChecksumType.ADLER32, SnappyCompressor.INSTANCE, new ChecksummingTransformer(ChecksumType.ADLER32, SnappyCompressor.INSTANCE));
         transformers = builder.build();
     }
 
diff --git a/src/java/org/apache/cassandra/transport/messages/StartupMessage.java b/src/java/org/apache/cassandra/transport/messages/StartupMessage.java
index 92c9764861..ef846c1f9a 100644
--- a/src/java/org/apache/cassandra/transport/messages/StartupMessage.java
+++ b/src/java/org/apache/cassandra/transport/messages/StartupMessage.java
@@ -131,7 +131,7 @@ public class StartupMessage extends Message.Request
         String name = options.get(CHECKSUM);
         try
         {
-            return name != null ? ChecksumType.valueOf(name) : null;
+            return name != null ? ChecksumType.valueOf(name.toUpperCase()) : null;
         }
         catch (IllegalArgumentException e)
         {
diff --git a/src/java/org/apache/cassandra/utils/ChecksumType.java b/src/java/org/apache/cassandra/utils/ChecksumType.java
index 413a171f4c..fa920aaca8 100644
--- a/src/java/org/apache/cassandra/utils/ChecksumType.java
+++ b/src/java/org/apache/cassandra/utils/ChecksumType.java
@@ -26,7 +26,7 @@ import io.netty.util.concurrent.FastThreadLocal;
 
 public enum ChecksumType
 {
-    Adler32
+    ADLER32
     {
 
         @Override
diff --git a/test/unit/org/apache/cassandra/transport/StartupMessageTest.java b/test/unit/org/apache/cassandra/transport/StartupMessageTest.java
new file mode 100644
index 0000000000..f69ad66c6f
--- /dev/null
+++ b/test/unit/org/apache/cassandra/transport/StartupMessageTest.java
@@ -0,0 +1,102 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.cassandra.transport;
+
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Map;
+
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+import org.apache.cassandra.config.EncryptionOptions;
+import org.apache.cassandra.cql3.CQLTester;
+import org.apache.cassandra.cql3.QueryProcessor;
+import org.apache.cassandra.transport.messages.StartupMessage;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public class StartupMessageTest extends CQLTester
+{
+
+    @BeforeClass
+    public static void setUp()
+    {
+        requireNetwork();
+    }
+
+    @Test
+    public void checksumOptionValidation()
+    {
+        testConnection("crc32", false);
+        testConnection("CRC32", false);
+        testConnection("cRc32", false);
+        testConnection("adler32", false);
+        testConnection("ADLER32", false);
+        testConnection("aDlEr32", false);
+        testConnection("nonesuchtype", true);
+        testConnection("", true);
+        // special case of no option supplied
+        testConnection(null, false);
+    }
+
+    private void testConnection(String checksumType, boolean expectProtocolError)
+    {
+        try (TestClient client = new TestClient(checksumType))
+        {
+            client.connect();
+            if (expectProtocolError)
+                fail("Expected a protocol exception");
+        }
+        catch (Exception e)
+        {
+            if (!expectProtocolError)
+                fail("Did not expect any exception");
+
+            // This is a bit ugly, but SimpleClient::execute throws RuntimeException if it receives any ErrorMessage
+            String expected = String.format("org.apache.cassandra.transport.ProtocolException: " +
+                                            "Requested checksum type %s is not known or supported " +
+                                            "by this version of Cassandra", checksumType);
+            assertEquals(expected, e.getMessage());
+        }
+    }
+
+    static class TestClient extends SimpleClient
+    {
+        private final String checksumType;
+        TestClient(String checksumType)
+        {
+            super(nativeAddr.getHostAddress(), nativePort, ProtocolVersion.V5, true, new EncryptionOptions());
+            this.checksumType = checksumType;
+        }
+
+        void connect() throws IOException
+        {
+            establishConnection();
+            Map<String, String> options = new HashMap<>();
+            options.put(StartupMessage.CQL_VERSION, QueryProcessor.CQL_VERSION.toString());
+
+            if (checksumType != null)
+                options.put(StartupMessage.CHECKSUM, checksumType);
+
+            execute(new StartupMessage(options));
+        }
+    }
+}
