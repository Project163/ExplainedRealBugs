diff --git a/CHANGES.txt b/CHANGES.txt
index e4f186243c..159e8de6dd 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -20,6 +20,7 @@
  * Fix serialization bug in PagedRange with 2ndary indexes (CASSANDRA-6299)
  * Fix CQL3 table validation in Thrift (CASSANDRA-6140)
  * Fix bug missing results with IN clauses (CASSANDRA-6327)
+ * Fix paging with reversed slices (CASSANDRA-6343)
 Merged from 1.2:
  * add non-jamm path for cached statements (CASSANDRA-6293)
  * (Hadoop) Require CFRR batchSize to be at least 2 (CASSANDRA-6114)
diff --git a/src/java/org/apache/cassandra/db/ColumnFamily.java b/src/java/org/apache/cassandra/db/ColumnFamily.java
index b2c5ac4e20..47b14b9c57 100644
--- a/src/java/org/apache/cassandra/db/ColumnFamily.java
+++ b/src/java/org/apache/cassandra/db/ColumnFamily.java
@@ -451,6 +451,11 @@ public abstract class ColumnFamily implements Iterable<Column>, IRowCacheEntry
         return getSortedColumns().iterator();
     }
 
+    public Iterator<Column> reverseIterator()
+    {
+        return getReverseSortedColumns().iterator();
+    }
+
     public boolean hasIrrelevantData(int gcBefore)
     {
         // Do we have gcable deletion infos?
diff --git a/src/java/org/apache/cassandra/service/pager/AbstractQueryPager.java b/src/java/org/apache/cassandra/service/pager/AbstractQueryPager.java
index 62cd45450e..d040203427 100644
--- a/src/java/org/apache/cassandra/service/pager/AbstractQueryPager.java
+++ b/src/java/org/apache/cassandra/service/pager/AbstractQueryPager.java
@@ -93,7 +93,7 @@ abstract class AbstractQueryPager implements QueryPager
             remaining++;
         }
         // Otherwise, if 'lastWasRecorded', we queried for one more than the page size,
-        // so if the page was is full, trim the last entry
+        // so if the page is full, trim the last entry
         else if (lastWasRecorded && !exhausted)
         {
             // We've asked for one more than necessary
@@ -161,11 +161,14 @@ abstract class AbstractQueryPager implements QueryPager
     protected abstract List<Row> queryNextPage(int pageSize, ConsistencyLevel consistency, boolean localQuery) throws RequestValidationException, RequestExecutionException;
     protected abstract boolean containsPreviousLast(Row first);
     protected abstract boolean recordLast(Row last);
+    protected abstract boolean isReversed();
 
     private List<Row> discardFirst(List<Row> rows)
     {
         Row first = rows.get(0);
-        ColumnFamily newCf = discardFirst(first.cf);
+        ColumnFamily newCf = isReversed()
+                           ? discardLast(first.cf)
+                           : discardFirst(first.cf);
 
         int count = newCf.getColumnCount();
         List<Row> newRows = new ArrayList<Row>(count == 0 ? rows.size() - 1 : rows.size());
@@ -179,7 +182,9 @@ abstract class AbstractQueryPager implements QueryPager
     private List<Row> discardLast(List<Row> rows)
     {
         Row last = rows.get(rows.size() - 1);
-        ColumnFamily newCf = discardLast(last.cf);
+        ColumnFamily newCf = isReversed()
+                           ? discardFirst(last.cf)
+                           : discardLast(last.cf);
 
         int count = newCf.getColumnCount();
         List<Row> newRows = new ArrayList<Row>(count == 0 ? rows.size() - 1 : rows.size());
@@ -199,12 +204,28 @@ abstract class AbstractQueryPager implements QueryPager
     }
 
     private ColumnFamily discardFirst(ColumnFamily cf)
+    {
+        boolean isReversed = isReversed();
+        DeletionInfo.InOrderTester tester = cf.deletionInfo().inOrderTester(isReversed);
+        return isReversed
+             ? discardTail(cf, cf.reverseIterator(), tester)
+             : discardHead(cf, cf.iterator(), tester);
+    }
+
+    private ColumnFamily discardLast(ColumnFamily cf)
+    {
+        boolean isReversed = isReversed();
+        DeletionInfo.InOrderTester tester = cf.deletionInfo().inOrderTester(isReversed);
+        return isReversed
+             ? discardHead(cf, cf.reverseIterator(), tester)
+             : discardTail(cf, cf.iterator(), tester);
+    }
+
+    private ColumnFamily discardHead(ColumnFamily cf, Iterator<Column> iter, DeletionInfo.InOrderTester tester)
     {
         ColumnFamily copy = cf.cloneMeShallow();
         ColumnCounter counter = columnCounter();
 
-        Iterator<Column> iter = cf.iterator();
-        DeletionInfo.InOrderTester tester = cf.inOrderDeletionTester();
         // Discard the first live
         while (iter.hasNext())
         {
@@ -220,22 +241,24 @@ abstract class AbstractQueryPager implements QueryPager
         return copy;
     }
 
-    private ColumnFamily discardLast(ColumnFamily cf)
+    private ColumnFamily discardTail(ColumnFamily cf, Iterator<Column> iter, DeletionInfo.InOrderTester tester)
     {
         ColumnFamily copy = cf.cloneMeShallow();
-        // Redoing the counting like that is not extremely efficient, but
-        // discardLast is only called in case of a race between paging and
-        // a deletion, which is pretty unlikely, so probably not a big deal
+        // Redoing the counting like that is not extremely efficient.
+        // This is called only for reversed slices or in the case of a race between
+        // paging and a deletion (pretty unlikely), so this is probably acceptable.
         int liveCount = columnCounter().countAll(cf).live();
 
         ColumnCounter counter = columnCounter();
-        DeletionInfo.InOrderTester tester = cf.inOrderDeletionTester();
         // Discard the first live
-        for (Column c : cf)
+        while (iter.hasNext())
         {
+            Column c = iter.next();
             counter.count(c, tester);
-            if (counter.live() < liveCount)
-                copy.addColumn(c);
+            if (counter.live() >= liveCount)
+                break;
+
+            copy.addColumn(c);
         }
         return copy;
     }
diff --git a/src/java/org/apache/cassandra/service/pager/RangeNamesQueryPager.java b/src/java/org/apache/cassandra/service/pager/RangeNamesQueryPager.java
index 57fb05b747..e3b0cf8d33 100644
--- a/src/java/org/apache/cassandra/service/pager/RangeNamesQueryPager.java
+++ b/src/java/org/apache/cassandra/service/pager/RangeNamesQueryPager.java
@@ -91,6 +91,11 @@ public class RangeNamesQueryPager extends AbstractQueryPager
         return false;
     }
 
+    protected boolean isReversed()
+    {
+        return false;
+    }
+
     private AbstractBounds<RowPosition> makeExcludingKeyBounds(RowPosition lastReturnedKey)
     {
         // We return a range that always exclude lastReturnedKey, since we've already
diff --git a/src/java/org/apache/cassandra/service/pager/RangeSliceQueryPager.java b/src/java/org/apache/cassandra/service/pager/RangeSliceQueryPager.java
index 42a958555a..1f4ba78489 100644
--- a/src/java/org/apache/cassandra/service/pager/RangeSliceQueryPager.java
+++ b/src/java/org/apache/cassandra/service/pager/RangeSliceQueryPager.java
@@ -91,16 +91,21 @@ public class RangeSliceQueryPager extends AbstractQueryPager
     {
         return lastReturnedKey != null
             && lastReturnedKey.equals(first.key)
-            && lastReturnedName.equals(firstName(first.cf));
+            && lastReturnedName.equals(isReversed() ? lastName(first.cf) : firstName(first.cf));
     }
 
     protected boolean recordLast(Row last)
     {
         lastReturnedKey = last.key;
-        lastReturnedName = lastName(last.cf);
+        lastReturnedName = isReversed() ? firstName(last.cf) : lastName(last.cf);
         return true;
     }
 
+    protected boolean isReversed()
+    {
+        return ((SliceQueryFilter)command.predicate).reversed;
+    }
+
     private AbstractBounds<RowPosition> makeIncludingKeyBounds(RowPosition lastReturnedKey)
     {
         // We always include lastReturnedKey since we may still be paging within a row,
diff --git a/src/java/org/apache/cassandra/service/pager/SliceQueryPager.java b/src/java/org/apache/cassandra/service/pager/SliceQueryPager.java
index 1d7714487a..e3825a9ac4 100644
--- a/src/java/org/apache/cassandra/service/pager/SliceQueryPager.java
+++ b/src/java/org/apache/cassandra/service/pager/SliceQueryPager.java
@@ -76,12 +76,17 @@ public class SliceQueryPager extends AbstractQueryPager implements SinglePartiti
 
     protected boolean containsPreviousLast(Row first)
     {
-        return lastReturned != null && lastReturned.equals(firstName(first.cf));
+        return lastReturned != null && lastReturned.equals(isReversed() ? lastName(first.cf) : firstName(first.cf));
     }
 
     protected boolean recordLast(Row last)
     {
-        lastReturned = lastName(last.cf);
+        lastReturned = isReversed() ? firstName(last.cf) : lastName(last.cf);
         return true;
     }
+
+    protected boolean isReversed()
+    {
+        return command.filter.reversed;
+    }
 }
diff --git a/test/unit/org/apache/cassandra/service/QueryPagerTest.java b/test/unit/org/apache/cassandra/service/QueryPagerTest.java
index 3fc2ac26e5..f395cf4230 100644
--- a/test/unit/org/apache/cassandra/service/QueryPagerTest.java
+++ b/test/unit/org/apache/cassandra/service/QueryPagerTest.java
@@ -117,7 +117,12 @@ public class QueryPagerTest extends SchemaLoader
 
     private static ReadCommand sliceQuery(String key, String start, String end, int count)
     {
-        SliceQueryFilter filter = new SliceQueryFilter(bytes(start), bytes(end), false, count);
+        return sliceQuery(key, start, end, false, count);
+    }
+
+    private static ReadCommand sliceQuery(String key, String start, String end, boolean reversed, int count)
+    {
+        SliceQueryFilter filter = new SliceQueryFilter(bytes(start), bytes(end), reversed, count);
         // Note: for MultiQueryTest, we need the same timestamp/expireBefore for all queries, so we just use 0 as it doesn't matter here.
         return new SliceFromReadCommand(KS, bytes(key), CF, 0, filter);
     }
@@ -187,6 +192,31 @@ public class QueryPagerTest extends SchemaLoader
         assertTrue(pager.isExhausted());
     }
 
+    @Test
+    public void reversedSliceQueryTest() throws Exception
+    {
+        QueryPager pager = QueryPagers.localPager(sliceQuery("k0", "c8", "c1", true, 10));
+
+        List<Row> page;
+
+        assertFalse(pager.isExhausted());
+        page = pager.fetchPage(3);
+        assertEquals(toString(page), 1, page.size());
+        assertRow(page.get(0), "k0", "c6", "c7", "c8");
+
+        assertFalse(pager.isExhausted());
+        page = pager.fetchPage(3);
+        assertEquals(toString(page), 1, page.size());
+        assertRow(page.get(0), "k0", "c3", "c4", "c5");
+
+        assertFalse(pager.isExhausted());
+        page = pager.fetchPage(3);
+        assertEquals(toString(page), 1, page.size());
+        assertRow(page.get(0), "k0", "c1", "c2");
+
+        assertTrue(pager.isExhausted());
+    }
+
     @Test
     public void MultiQueryTest() throws Exception
     {
