diff --git a/src/java/org/apache/cassandra/tcm/sequences/ProgressBarrier.java b/src/java/org/apache/cassandra/tcm/sequences/ProgressBarrier.java
index 3bc5db2782..28f94cacf8 100644
--- a/src/java/org/apache/cassandra/tcm/sequences/ProgressBarrier.java
+++ b/src/java/org/apache/cassandra/tcm/sequences/ProgressBarrier.java
@@ -194,6 +194,7 @@ public class ProgressBarrier
         for (InetAddressAndPort peer : superset)
             requests.add(new WatermarkRequest(peer, messagingService, waitFor));
 
+        long start = Clock.Global.nanoTime();
         Retry.Deadline deadline = Retry.Deadline.after(TimeUnit.MILLISECONDS.toNanos(TIMEOUT_MILLIS),
                                                       new Retry.Backoff(DatabaseDescriptor.getCmsDefaultRetryMaxTries(),
                                                                         (int) BACKOFF_MILLIS,
@@ -241,8 +242,8 @@ public class ProgressBarrier
 
         Set<InetAddressAndPort> remaining = new HashSet<>(superset);
         remaining.removeAll(collected);
-        logger.warn("Could not collect {} of nodes for a progress barrier for epoch {} to finish within {}ms. Nodes that have not responded: {}",
-                    cl, waitFor, TimeUnit.NANOSECONDS.toMillis(Clock.Global.nanoTime() - deadline.deadlineNanos), remaining);
+        logger.warn("Could not collect {} of nodes for a progress barrier for epoch {} to finish within {}ms. Nodes that have not responded: {}. {}",
+                    cl, waitFor, TimeUnit.NANOSECONDS.toMillis(deadline.deadlineNanos - start), remaining, deadline);
         return false;
     }
 
@@ -555,6 +556,17 @@ public class ProgressBarrier
             condition = new AsyncPromise<>();
             messagingService.sendWithCallback(Message.out(Verb.TCM_CURRENT_EPOCH_REQ, ClusterMetadata.current().epoch), to, this);
         }
+
+        @Override
+        public String toString()
+        {
+            return "WatermarkRequest{" +
+                   "condition=" + condition +
+                   ", to=" + to +
+                   ", messagingService=" + messagingService +
+                   ", waitFor=" + waitFor +
+                   '}';
+        }
     }
 
     @Override
diff --git a/test/simulator/asm/org/apache/cassandra/simulator/asm/GlobalMethodTransformer.java b/test/simulator/asm/org/apache/cassandra/simulator/asm/GlobalMethodTransformer.java
index 67650639e0..883b7a66a3 100644
--- a/test/simulator/asm/org/apache/cassandra/simulator/asm/GlobalMethodTransformer.java
+++ b/test/simulator/asm/org/apache/cassandra/simulator/asm/GlobalMethodTransformer.java
@@ -92,7 +92,8 @@ class GlobalMethodTransformer extends MethodVisitor
             super.visitMethodInsn(Opcodes.INVOKESTATIC, "org/apache/cassandra/simulator/systems/InterceptorOfSystemMethods$Global", name, descriptor, false);
         }
         else if ((globalMethods || deterministic) && opcode == Opcodes.INVOKESTATIC &&
-            owner.equals("java/util/concurrent/ThreadLocalRandom") && (name.equals("getProbe") || name.equals("advanceProbe") || name.equals("localInit"))
+                 ((owner.equals("java/util/concurrent/ThreadLocalRandom") && (name.equals("getProbe") || name.equals("advanceProbe") || name.equals("localInit")))
+                  || (owner.equals("java/util/concurrent/atomic/Striped64") && (name.equals("getProbe") || name.equals("advanceProbe"))))
         )
         {
             transformer.witness(GLOBAL_METHOD);
diff --git a/test/simulator/main/org/apache/cassandra/simulator/ClusterSimulation.java b/test/simulator/main/org/apache/cassandra/simulator/ClusterSimulation.java
index cbb83ceafc..7eb5618ba7 100644
--- a/test/simulator/main/org/apache/cassandra/simulator/ClusterSimulation.java
+++ b/test/simulator/main/org/apache/cassandra/simulator/ClusterSimulation.java
@@ -22,7 +22,6 @@ import java.io.IOException;
 import java.lang.reflect.Field;
 import java.lang.reflect.Modifier;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collections;
 import java.util.EnumMap;
 import java.util.List;
@@ -53,8 +52,10 @@ import org.apache.cassandra.distributed.api.IIsolatedExecutor.SerializableBiCons
 import org.apache.cassandra.distributed.api.IIsolatedExecutor.SerializableConsumer;
 import org.apache.cassandra.distributed.api.IIsolatedExecutor.SerializableRunnable;
 import org.apache.cassandra.distributed.impl.DirectStreamingConnectionFactory;
+import org.apache.cassandra.distributed.impl.InstanceIDDefiner;
 import org.apache.cassandra.distributed.impl.IsolatedExecutor;
 import org.apache.cassandra.io.compress.LZ4Compressor;
+import org.apache.cassandra.io.filesystem.ListenableFileSystem;
 import org.apache.cassandra.io.util.FileSystems;
 import org.apache.cassandra.net.Verb;
 import org.apache.cassandra.service.paxos.BallotGenerator;
@@ -64,25 +65,24 @@ import org.apache.cassandra.simulator.asm.InterceptAsClassTransformer;
 import org.apache.cassandra.simulator.asm.NemesisFieldSelectors;
 import org.apache.cassandra.simulator.cluster.ClusterActions;
 import org.apache.cassandra.simulator.cluster.ClusterActions.TopologyChange;
-import org.apache.cassandra.io.filesystem.ListenableFileSystem;
 import org.apache.cassandra.simulator.systems.Failures;
 import org.apache.cassandra.simulator.systems.InterceptedWait.CaptureSites.Capture;
 import org.apache.cassandra.simulator.systems.InterceptibleThread;
+import org.apache.cassandra.simulator.systems.InterceptingExecutorFactory;
 import org.apache.cassandra.simulator.systems.InterceptingGlobalMethods;
 import org.apache.cassandra.simulator.systems.InterceptingGlobalMethods.ThreadLocalRandomCheck;
 import org.apache.cassandra.simulator.systems.InterceptorOfGlobalMethods;
-import org.apache.cassandra.simulator.systems.InterceptingExecutorFactory;
 import org.apache.cassandra.simulator.systems.InterceptorOfGlobalMethods.IfInterceptibleThread;
 import org.apache.cassandra.simulator.systems.NetworkConfig;
 import org.apache.cassandra.simulator.systems.NetworkConfig.PhaseConfig;
 import org.apache.cassandra.simulator.systems.SchedulerConfig;
-import org.apache.cassandra.simulator.systems.SimulatedFutureActionScheduler;
-import org.apache.cassandra.simulator.systems.SimulatedSystems;
 import org.apache.cassandra.simulator.systems.SimulatedBallots;
 import org.apache.cassandra.simulator.systems.SimulatedExecution;
 import org.apache.cassandra.simulator.systems.SimulatedFailureDetector;
+import org.apache.cassandra.simulator.systems.SimulatedFutureActionScheduler;
 import org.apache.cassandra.simulator.systems.SimulatedMessageDelivery;
 import org.apache.cassandra.simulator.systems.SimulatedSnitch;
+import org.apache.cassandra.simulator.systems.SimulatedSystems;
 import org.apache.cassandra.simulator.systems.SimulatedTime;
 import org.apache.cassandra.simulator.utils.ChanceRange;
 import org.apache.cassandra.simulator.utils.IntRange;
@@ -640,12 +640,15 @@ public class ClusterSimulation<S extends Simulation> implements AutoCloseable
     public final RandomSource random;
     public final SimulatedSystems simulated;
     public final Cluster cluster;
-    public final S simulation;
     private final ListenableFileSystem fs;
     protected final Map<Integer, List<Closeable>> onUnexpectedShutdown = new TreeMap<>();
     protected final List<Callable<Void>> onShutdown = new CopyOnWriteArrayList<>();
     protected final ThreadLocalRandomCheck threadLocalRandomCheck;
 
+    private final RunnableActionScheduler scheduler;
+    private final ClusterActions.Options options;
+    private final SimulationFactory<S> factory;
+
     public ClusterSimulation(RandomSource random, long seed, int uniqueNum,
                              Builder<?> builder,
                              Consumer<IInstanceConfig> configUpdater,
@@ -702,9 +705,7 @@ public class ClusterSimulation<S extends Simulation> implements AutoCloseable
 
         Failures failures = builder.failures;
         ThreadAllocator threadAllocator = new ThreadAllocator(random, builder.threadCount, numOfNodes);
-        List<String> allowedDiskAccessModes = Arrays.asList("mmap", "mmap_index_only", "standard");
-        String disk_access_mode = allowedDiskAccessModes.get(random.uniform(0, allowedDiskAccessModes.size() - 1));
-        boolean commitlogCompressed = random.decide(.5f);
+
         cluster = snitch.setup(Cluster.build(numOfNodes)
                          .withRoot(fs.getPath("/cassandra"))
                          .withSharedClasses(sharedClassPredicate)
@@ -729,6 +730,8 @@ public class ClusterSimulation<S extends Simulation> implements AutoCloseable
                              public void initialise(ClassLoader classLoader, ThreadGroup threadGroup, int num, int generation)
                              {
                                  List<Closeable> onShutdown = new ArrayList<>();
+                                 IsolatedExecutor.transferAdhoc((SerializableConsumer<Integer>) InstanceIDDefiner::setInstanceId, classLoader)
+                                                 .accept(num);
                                  InterceptorOfGlobalMethods interceptorOfGlobalMethods = IsolatedExecutor.transferAdhoc((IIsolatedExecutor.SerializableQuadFunction<Capture, LongConsumer, Consumer<Throwable>, RandomSource, InterceptorOfGlobalMethods>) InterceptingGlobalMethods::new, classLoader)
                                                                                                          .apply(builder.capture, builder.onThreadLocalRandomCheck, failures, random);
                                  onShutdown.add(interceptorOfGlobalMethods);
@@ -801,11 +804,16 @@ public class ClusterSimulation<S extends Simulation> implements AutoCloseable
         if (futureActionScheduler instanceof SimulatedFutureActionScheduler)
             simulated.register((SimulatedFutureActionScheduler) futureActionScheduler);
 
-        RunnableActionScheduler scheduler = builder.schedulerFactory.create(random);
-        ClusterActions.Options options = new ClusterActions.Options(builder.topologyChangeLimit, Choices.uniform(KindOfSequence.values()).choose(random).period(builder.topologyChangeIntervalNanos, random),
-                                                                    Choices.random(random, builder.topologyChanges),
-                                                                    minRf, initialRf, maxRf, null);
-        simulation = factory.create(simulated, scheduler, cluster, options);
+        scheduler = builder.schedulerFactory.create(random);
+        options = new ClusterActions.Options(builder.topologyChangeLimit, Choices.uniform(KindOfSequence.values()).choose(random).period(builder.topologyChangeIntervalNanos, random),
+                                             Choices.random(random, builder.topologyChanges),
+                                             minRf, initialRf, maxRf, null);
+        this.factory = factory;
+    }
+
+    public S simulation()
+    {
+        return factory.create(simulated, scheduler, cluster, options);
     }
 
     public synchronized void close() throws IOException
@@ -840,15 +848,6 @@ public class ClusterSimulation<S extends Simulation> implements AutoCloseable
             }
         }
 
-        try
-        {
-            simulation.close();
-        }
-        catch (Throwable t)
-        {
-            fail = t;
-        }
-
         try
         {
             cluster.close();
diff --git a/test/simulator/main/org/apache/cassandra/simulator/SimulationRunner.java b/test/simulator/main/org/apache/cassandra/simulator/SimulationRunner.java
index 07adf60572..71acd6d95d 100644
--- a/test/simulator/main/org/apache/cassandra/simulator/SimulationRunner.java
+++ b/test/simulator/main/org/apache/cassandra/simulator/SimulationRunner.java
@@ -360,9 +360,9 @@ public class SimulationRunner
 
             try (ClusterSimulation<?> cluster = builder.create(seed))
             {
-                try
+                try (Simulation simulation = cluster.simulation())
                 {
-                    cluster.simulation.run();
+                    simulation.run();
                 }
                 catch (Throwable t)
                 {
diff --git a/test/simulator/main/org/apache/cassandra/simulator/SimulatorUtils.java b/test/simulator/main/org/apache/cassandra/simulator/SimulatorUtils.java
index 1cffb55a0b..5be3384eeb 100644
--- a/test/simulator/main/org/apache/cassandra/simulator/SimulatorUtils.java
+++ b/test/simulator/main/org/apache/cassandra/simulator/SimulatorUtils.java
@@ -34,15 +34,6 @@ public class SimulatorUtils
         List<long[]> oom = new ArrayList<>();
         for (int i = 0 ; i < 1024 ; ++i)
             oom.add(new long[0x7fffffff]);
-        try
-        {
-            Thread.sleep(1_000);
-        }
-        catch (InterruptedException e)
-        {
-            throw new RuntimeException(e);
-        }
-        System.exit(1);
         throw new AssertionError();
     }
 
diff --git a/test/simulator/main/org/apache/cassandra/simulator/cluster/KeyspaceActions.java b/test/simulator/main/org/apache/cassandra/simulator/cluster/KeyspaceActions.java
index 17edb9661b..7d5699d5d3 100644
--- a/test/simulator/main/org/apache/cassandra/simulator/cluster/KeyspaceActions.java
+++ b/test/simulator/main/org/apache/cassandra/simulator/cluster/KeyspaceActions.java
@@ -202,6 +202,7 @@ public class KeyspaceActions extends ClusterActions
         for (int i = 0; i < rfs.length; i++)
             rf.put(factory.lookup().dc(i + 1), rfs[i]);
 
+        nodes.sort(PlacementSimulator.Node::compareTo);
         return new PlacementSimulator.NtsReplicationFactor(rfs).replicate(nodes);
     }
 
@@ -285,9 +286,7 @@ public class KeyspaceActions extends ClusterActions
                     Topology during = recomputeTopology(placementsBefore, placementsAfter);
                     updateTopology(during);
                     Topology after = recomputeTopology(placementsAfter, placementsAfter);
-                    Action action = null;
-                    //TODO p
-                    //new OnClusterReplace(KeyspaceActions.this, before, during, after, leave, join);
+                    Action action = new OnClusterReplace(KeyspaceActions.this, before, during, after, leave, join);
                     return scheduleAndUpdateTopologyOnCompletion(action, after);
                     // if replication factor is 2, cannot perform safe replacements
                     // however can have operations that began earlier during RF=2
diff --git a/test/simulator/main/org/apache/cassandra/simulator/cluster/OnClusterLeave.java b/test/simulator/main/org/apache/cassandra/simulator/cluster/OnClusterLeave.java
index d3d4ea6405..9e77b55815 100644
--- a/test/simulator/main/org/apache/cassandra/simulator/cluster/OnClusterLeave.java
+++ b/test/simulator/main/org/apache/cassandra/simulator/cluster/OnClusterLeave.java
@@ -109,7 +109,8 @@ class OnClusterLeave extends OnClusterChangeTopology
 
                 UnbootstrapAndLeave unbootstrapAndLeave = ((UnbootstrapAndLeave) sequence);
                 assert unbootstrapAndLeave.next.ordinal() == kind : String.format("Expected next step to be %s, but got %s", Transformation.Kind.values()[kind], unbootstrapAndLeave.next);
-                assert unbootstrapAndLeave.executeNext().isContinuable();
+                boolean res = unbootstrapAndLeave.executeNext().isContinuable();
+                assert res;
             });
         }
     }
diff --git a/test/simulator/main/org/apache/cassandra/simulator/cluster/OnClusterReplace.java b/test/simulator/main/org/apache/cassandra/simulator/cluster/OnClusterReplace.java
index 8d93367c5f..d3f5d86720 100644
--- a/test/simulator/main/org/apache/cassandra/simulator/cluster/OnClusterReplace.java
+++ b/test/simulator/main/org/apache/cassandra/simulator/cluster/OnClusterReplace.java
@@ -159,7 +159,8 @@ class OnClusterReplace extends OnClusterChangeTopology
 
                 BootstrapAndReplace bootstrapAndReplace = ((BootstrapAndReplace) sequence);
                 assert bootstrapAndReplace.next.ordinal() == kind : String.format("Expected next step to be %s, but got %s", Transformation.Kind.values()[kind], bootstrapAndReplace.next);
-                assert bootstrapAndReplace.executeNext().isContinuable();
+                boolean res = bootstrapAndReplace.executeNext().isContinuable();
+                assert res;
             });
         }
     }
diff --git a/test/simulator/main/org/apache/cassandra/simulator/debug/Reconcile.java b/test/simulator/main/org/apache/cassandra/simulator/debug/Reconcile.java
index 8d0ed46e5a..5face389ac 100644
--- a/test/simulator/main/org/apache/cassandra/simulator/debug/Reconcile.java
+++ b/test/simulator/main/org/apache/cassandra/simulator/debug/Reconcile.java
@@ -41,6 +41,7 @@ import org.apache.cassandra.io.util.DataInputPlus.DataInputStreamPlus;
 import org.apache.cassandra.io.util.File;
 import org.apache.cassandra.simulator.ClusterSimulation;
 import org.apache.cassandra.simulator.RandomSource;
+import org.apache.cassandra.simulator.Simulation;
 import org.apache.cassandra.simulator.SimulationRunner.RecordOption;
 import org.apache.cassandra.simulator.systems.InterceptedWait.CaptureSites.Capture;
 import org.apache.cassandra.simulator.systems.SimulatedTime;
@@ -491,7 +492,8 @@ public class Reconcile
 
             class Line { int line = 1; } Line line = new Line(); // box for heap dump analysis
             try (ClusterSimulation<?> cluster = builder.create(seed);
-                 CloseableIterator<?> iter = cluster.simulation.iterator())
+                 Simulation simulation = cluster.simulation();
+                 CloseableIterator<?> iter = simulation.iterator())
             {
                 try
                 {
diff --git a/test/simulator/main/org/apache/cassandra/simulator/debug/Record.java b/test/simulator/main/org/apache/cassandra/simulator/debug/Record.java
index 42c7b082fe..8f449f18ca 100644
--- a/test/simulator/main/org/apache/cassandra/simulator/debug/Record.java
+++ b/test/simulator/main/org/apache/cassandra/simulator/debug/Record.java
@@ -18,32 +18,40 @@
 
 package org.apache.cassandra.simulator.debug;
 
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.nio.channels.Channels;
+import java.util.Arrays;
+import java.util.IdentityHashMap;
+import java.util.LinkedHashSet;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
+import java.util.function.Supplier;
+import java.util.regex.Pattern;
+import java.util.stream.Stream;
+import java.util.zip.GZIPOutputStream;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
 import org.apache.cassandra.io.util.BufferedDataOutputStreamPlus;
 import org.apache.cassandra.io.util.DataOutputStreamPlus;
 import org.apache.cassandra.io.util.File;
 import org.apache.cassandra.simulator.ClusterSimulation;
 import org.apache.cassandra.simulator.RandomSource;
+import org.apache.cassandra.simulator.Simulation;
 import org.apache.cassandra.simulator.SimulationRunner.RecordOption;
 import org.apache.cassandra.simulator.systems.SimulatedTime;
 import org.apache.cassandra.utils.Closeable;
 import org.apache.cassandra.utils.CloseableIterator;
 import org.apache.cassandra.utils.concurrent.Threads;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.PrintWriter;
-import java.nio.channels.Channels;
-import java.util.*;
-import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
-import java.util.function.Supplier;
-import java.util.regex.Pattern;
-import java.util.stream.Stream;
-import java.util.zip.GZIPOutputStream;
 
 import static org.apache.cassandra.io.util.File.WriteMode.OVERWRITE;
-import static org.apache.cassandra.simulator.SimulationRunner.RecordOption.*;
+import static org.apache.cassandra.simulator.SimulationRunner.RecordOption.NONE;
+import static org.apache.cassandra.simulator.SimulationRunner.RecordOption.VALUE;
+import static org.apache.cassandra.simulator.SimulationRunner.RecordOption.WITH_CALLSITES;
 import static org.apache.cassandra.simulator.SimulatorUtils.failWithOOM;
 
 public class Record
@@ -149,9 +157,10 @@ public class Record
             flusher.setDaemon(true);
             flusher.start();
 
-            try (ClusterSimulation<?> cluster = builder.create(seed))
+            try (ClusterSimulation<?> clusterSimulation = builder.create(seed))
             {
-                try (CloseableIterator<?> iter = cluster.simulation.iterator();)
+                try (Simulation simulation = clusterSimulation.simulation();
+                     CloseableIterator<?> iter = simulation.iterator())
                 {
                     while (iter.hasNext())
                         eventOut.println(normaliseRecordingOut(iter.next().toString()));
diff --git a/test/simulator/main/org/apache/cassandra/simulator/debug/SelfReconcile.java b/test/simulator/main/org/apache/cassandra/simulator/debug/SelfReconcile.java
index be8c05a959..390bb82a9a 100644
--- a/test/simulator/main/org/apache/cassandra/simulator/debug/SelfReconcile.java
+++ b/test/simulator/main/org/apache/cassandra/simulator/debug/SelfReconcile.java
@@ -34,6 +34,7 @@ import org.apache.cassandra.distributed.api.IMessage;
 import org.apache.cassandra.simulator.ClusterSimulation;
 import org.apache.cassandra.simulator.OrderOn;
 import org.apache.cassandra.simulator.RandomSource;
+import org.apache.cassandra.simulator.Simulation;
 import org.apache.cassandra.simulator.SimulationRunner.RecordOption;
 import org.apache.cassandra.simulator.systems.InterceptedExecution;
 import org.apache.cassandra.simulator.systems.InterceptedWait;
@@ -256,7 +257,8 @@ public class SelfReconcile
                 reconciler.verifyUninterceptedRng = true;
 
                 Future<?> f1 = executor.submit(() -> {
-                    try (CloseableIterator<?> iter = cluster1.simulation.iterator())
+                    try (Simulation simulation = cluster1.simulation();
+                         CloseableIterator<?> iter = simulation.iterator())
                     {
                         while (iter.hasNext())
                         {
@@ -264,10 +266,15 @@ public class SelfReconcile
                             reconciler.verify(Pair.create(normalise(o.toString()), o));
                         }
                     }
+                    catch (Exception e)
+                    {
+                        throw new RuntimeException(e);
+                    }
                     reconciler.verify("done");
                 });
                 Future<?> f2 = executor.submit(() -> {
-                    try (CloseableIterator<?> iter = cluster2.simulation.iterator())
+                    try (Simulation simulation = cluster2.simulation();
+                         CloseableIterator<?> iter = simulation.iterator())
                     {
                         while (iter.hasNext())
                         {
@@ -275,6 +282,10 @@ public class SelfReconcile
                             reconciler.verify(Pair.create(normalise(o.toString()), o));
                         }
                     }
+                    catch (Exception e)
+                    {
+                        throw new RuntimeException(e);
+                    }
                     reconciler.verify("done");
                 });
                 f1.get();
diff --git a/test/simulator/main/org/apache/cassandra/simulator/harry/HarryValidatingQuery.java b/test/simulator/main/org/apache/cassandra/simulator/harry/HarryValidatingQuery.java
index b3a3afc271..871f58d429 100644
--- a/test/simulator/main/org/apache/cassandra/simulator/harry/HarryValidatingQuery.java
+++ b/test/simulator/main/org/apache/cassandra/simulator/harry/HarryValidatingQuery.java
@@ -34,7 +34,6 @@ import harry.operations.CompiledStatement;
 import harry.operations.Query;
 import org.apache.cassandra.distributed.Cluster;
 import org.apache.cassandra.distributed.api.IInstance;
-import org.apache.cassandra.simulator.SimulatorUtils;
 import org.apache.cassandra.simulator.systems.InterceptedExecution;
 import org.apache.cassandra.simulator.systems.InterceptingExecutor;
 import org.apache.cassandra.simulator.systems.SimulatedAction;
@@ -115,7 +114,7 @@ public class HarryValidatingQuery extends SimulatedAction
                             if (!throwables.isEmpty())
                             {
                                 logger.error(String.format("Could not validate %d out of %d replicas %s", throwables.size(), replicas.size(), replicas), throwables.get(0));
-                                SimulatorUtils.failWithOOM();
+                                System.exit(0);
                             }
                         }
 
diff --git a/test/simulator/test/org/apache/cassandra/simulator/test/HarrySimulatorTest.java b/test/simulator/test/org/apache/cassandra/simulator/test/HarrySimulatorTest.java
index 31c8dae69d..80d39a51a6 100644
--- a/test/simulator/test/org/apache/cassandra/simulator/test/HarrySimulatorTest.java
+++ b/test/simulator/test/org/apache/cassandra/simulator/test/HarrySimulatorTest.java
@@ -33,6 +33,7 @@ import java.util.concurrent.atomic.AtomicInteger;
 import java.util.function.Consumer;
 import java.util.function.Function;
 import java.util.function.Supplier;
+import javax.inject.Inject;
 
 import org.junit.Test;
 import org.slf4j.Logger;
@@ -50,6 +51,10 @@ import harry.model.sut.TokenPlacementModel;
 import harry.operations.Query;
 import harry.runner.DefaultDataTracker;
 import harry.visitors.GeneratingVisitor;
+import io.airlift.airline.Command;
+import io.airlift.airline.HelpOption;
+import io.airlift.airline.Option;
+import io.airlift.airline.SingleCommand;
 import org.apache.cassandra.dht.Murmur3Partitioner;
 import org.apache.cassandra.distributed.Cluster;
 import org.apache.cassandra.distributed.api.ConsistencyLevel;
@@ -73,6 +78,7 @@ import org.apache.cassandra.simulator.OrderOn;
 import org.apache.cassandra.simulator.RandomSource;
 import org.apache.cassandra.simulator.RunnableActionScheduler;
 import org.apache.cassandra.simulator.Simulation;
+import org.apache.cassandra.simulator.SimulationRunner;
 import org.apache.cassandra.simulator.SimulatorUtils;
 import org.apache.cassandra.simulator.cluster.ClusterActionListener.NoOpListener;
 import org.apache.cassandra.simulator.cluster.ClusterActions;
@@ -95,28 +101,112 @@ import org.apache.cassandra.utils.CloseableIterator;
 
 import static java.util.concurrent.TimeUnit.SECONDS;
 import static org.apache.cassandra.distributed.api.ConsistencyLevel.ALL;
-import static org.apache.cassandra.simulator.ActionSchedule.Mode.TIME_LIMITED;
 import static org.apache.cassandra.simulator.ActionSchedule.Mode.UNLIMITED;
 import static org.apache.cassandra.simulator.cluster.ClusterActions.Options.noActions;
 
+
+/**
+ * In order to run these tests in your IDE, you need to first build a simulator jara
+ *
+ *    ant simulator-jars
+ *
+ * And then run your test using the following settings (omit add-* if you are running on jdk8):
+ *
+        -Dstorage-config=$MODULE_DIR$/test/conf
+        -Djava.awt.headless=true
+        -javaagent:$MODULE_DIR$/lib/jamm-0.4.0.jar
+        -ea
+        -Dcassandra.debugrefcount=true
+        -Xss384k
+        -XX:SoftRefLRUPolicyMSPerMB=0
+        -XX:ActiveProcessorCount=2
+        -XX:HeapDumpPath=build/test
+        -Dcassandra.test.driver.connection_timeout_ms=10000
+        -Dcassandra.test.driver.read_timeout_ms=24000
+        -Dcassandra.memtable_row_overhead_computation_step=100
+        -Dcassandra.test.use_prepared=true
+        -Dcassandra.test.sstableformatdevelopment=true
+        -Djava.security.egd=file:/dev/urandom
+        -Dcassandra.testtag=.jdk11
+        -Dcassandra.keepBriefBrief=true
+        -Dcassandra.allow_simplestrategy=true
+        -Dcassandra.strict.runtime.checks=true
+        -Dcassandra.reads.thresholds.coordinator.defensive_checks_enabled=true
+        -Dcassandra.test.flush_local_schema_changes=false
+        -Dcassandra.test.messagingService.nonGracefulShutdown=true
+        -Dcassandra.use_nix_recursive_delete=true
+        -Dcie-cassandra.disable_schema_drop_log=true
+        -Dlogback.configurationFile=file://$MODULE_DIR$/test/conf/logback-simulator.xml
+        -Dcassandra.ring_delay_ms=10000
+        -Dcassandra.tolerate_sstable_size=true
+        -Dcassandra.skip_sync=true
+        -Dcassandra.debugrefcount=false
+        -Dcassandra.test.simulator.determinismcheck=strict
+        -Dcassandra.test.simulator.print_asm=none
+        -javaagent:$MODULE_DIR$/build/test/lib/jars/simulator-asm.jar
+        -Xbootclasspath/a:$MODULE_DIR$/build/test/lib/jars/simulator-bootstrap.jar
+        -XX:ActiveProcessorCount=4
+        -XX:-TieredCompilation
+        -XX:-BackgroundCompilation
+        -XX:CICompilerCount=1
+        -XX:Tier4CompileThreshold=1000
+        -XX:ReservedCodeCacheSize=256M
+        -Xmx16G
+        -Xmx4G
+        --add-exports java.base/jdk.internal.misc=ALL-UNNAMED
+        --add-exports java.base/jdk.internal.ref=ALL-UNNAMED
+        --add-exports java.base/sun.nio.ch=ALL-UNNAMED
+        --add-exports java.management.rmi/com.sun.jmx.remote.internal.rmi=ALL-UNNAMED
+        --add-exports java.rmi/sun.rmi.registry=ALL-UNNAMED
+        --add-exports java.rmi/sun.rmi.server=ALL-UNNAMED
+        --add-exports java.sql/java.sql=ALL-UNNAMED
+        --add-exports java.rmi/sun.rmi.registry=ALL-UNNAMED
+        --add-opens java.base/java.lang.module=ALL-UNNAMED
+        --add-opens java.base/java.net=ALL-UNNAMED
+        --add-opens java.base/jdk.internal.loader=ALL-UNNAMED
+        --add-opens java.base/jdk.internal.ref=ALL-UNNAMED
+        --add-opens java.base/jdk.internal.reflect=ALL-UNNAMED
+        --add-opens java.base/jdk.internal.math=ALL-UNNAMED
+        --add-opens java.base/jdk.internal.module=ALL-UNNAMED
+        --add-opens java.base/jdk.internal.util.jar=ALL-UNNAMED
+        --add-opens jdk.management/com.sun.management.internal=ALL-UNNAMED
+        --add-opens jdk.management.jfr/jdk.management.jfr=ALL-UNNAMED
+        --add-opens java.desktop/com.sun.beans.introspect=ALL-UNNAMED
+ */
+@Command(name = "harry", description = "Harry simulation test")
 public class HarrySimulatorTest
 {
     private static final Logger logger = LoggerFactory.getLogger(HarrySimulatorTest.class);
 
+    @Inject
+    public HelpOption helpOption;
+    @Option(name = { "-r", "--rows-per-phase"}, description = "Number of rows to check at each phase of the test")
+    public int rowsPerPhase = 10;
+    @Option(name = {"--nodes-per-dc"}, description = "How many nodes per dc for replication")
+    public int nodesPerDc = 3;
+
     public static void main(String... args) throws Throwable
     {
-        new HarrySimulatorTest().harryTest();
-        System.exit(0);
+        HarrySimulatorTest test = SingleCommand.singleCommand(HarrySimulatorTest.class).parse(args);
+        if (test.helpOption.showHelpIfRequested())
+            return;
+        test.harryTest();
+        System.exit(1);
     }
 
     @Test
-    public void harryTest() throws Exception
+    public void test() throws Exception
+    {
+        rowsPerPhase = 1;
+        harryTest();
+    }
+
+    private void harryTest() throws Exception
     {
         int bootstrapNode1 = 4;
         int bootstrapNode2 = 8;
         int bootstrapNode3 = 12;
-        int rowsPerPhase = 1000;
-        int nodesPerDc = 3;
+
         StringBuilder rfString = new StringBuilder();
         Map<String, Integer> rfMap = new HashMap<>();
         for (int i = 0; i < 3; i++)
@@ -132,7 +222,23 @@ public class HarrySimulatorTest
 
         ConsistencyLevel cl = ALL;
 
-        simulate(HarryHelper.defaultConfiguration()
+        simulate((config) -> config
+                             .failures(new HaltOnError())
+                             .threadCount(1000)
+                             .readTimeoutNanos(SECONDS.toNanos(5))
+                             .writeTimeoutNanos(SECONDS.toNanos(5))
+                             .readTimeoutNanos(SECONDS.toNanos(10))
+                             .nodes(12, 12)
+                             .dcs(3, 3),
+                 (config) -> config.set("cms_default_max_retries", 100)
+                                   .set("request_timeout", "10000ms")
+                                   .set("progress_barrier_min_consistency_level", ALL)
+                                   .set("progress_barrier_default_consistency_level", ALL)
+                                   .set("progress_barrier_timeout", "600000ms")
+                                   // Backoff should be larger than read timeout, since otherwise we will simply saturate the stage with retries
+                                   .set("progress_barrier_backoff", "1000ms")
+                                   .set("cms_await_timeout", "600000ms"),
+                 HarryHelper.defaultConfiguration()
                             .setSchemaProvider(new Configuration.SchemaProviderConfiguration()
                             {
                                 private final Surjections.Surjection<SchemaSpec> schema = schemaSpecGen("harry", "tbl");
@@ -141,16 +247,16 @@ public class HarrySimulatorTest
                                     return schema.inflate(l);
                                 }
                             })
-
                             .setPartitionDescriptorSelector(new Configuration.DefaultPDSelectorConfiguration(2, 1))
                             .setClusteringDescriptorSelector(HarryHelper.singleRowPerModification().setMaxPartitionSize(100).build()),
+                 arr(),
                  (simulation) -> {
                      simulation.cluster.stream().forEach((IInvokableInstance i) -> {
                          simulation.simulated.failureDetector.markUp(i.config().broadcastAddress());
                      });
 
                      List<ActionSchedule.Work> work = new ArrayList<>();
-                     work.add(work(run(() -> {
+                     work.add(work("Set up", run(() -> {
                          for (Map.Entry<String, List<TokenPlacementModel.Node>> e : simulation.nodeState.nodesByDc.entrySet())
                          {
                              List<TokenPlacementModel.Node> nodesInDc = e.getValue();
@@ -161,21 +267,31 @@ public class HarrySimulatorTest
                              }
                          }
                      })));
-                     work.add(work(lazy(() -> simulation.clusterActions.initializeCluster(new ClusterActions.InitialConfiguration(simulation.nodeState.joined(), new int[0])))));
-                     work.add(work(reconfigureCMS(simulation.simulated, simulation.cluster, 2, true)));
-                     work.add(work(simulation.clusterActions.schemaChange(1,
+                     work.add(work("Initial configuration",
+                                   lazy(() -> simulation.clusterActions.initializeCluster(new ClusterActions.InitialConfiguration(simulation.nodeState.joined(), new int[0])))));
+
+                     work.add(work("Reconfigure CMS",
+                                   reconfigureCMS(simulation.simulated, simulation.cluster, 2, true)));
+                     work.add(work("Create Keyspace",
+                                   simulation.clusterActions.schemaChange(1,
                                                                           String.format("CREATE KEYSPACE %s WITH replication = {'class': 'NetworkTopologyStrategy', " + rfString + "};",
                                                                                         simulation.harryRun.schemaSpec.keyspace))));
-                     work.add(work(simulation.clusterActions.schemaChange(1,
+                     work.add(work("Create table",
+                                   simulation.clusterActions.schemaChange(1,
                                                                           simulation.harryRun.schemaSpec.compile().cql())));
-                     work.add(work(HarrySimulatorTest.generate(rowsPerPhase, simulation, cl)));
-
-
                      simulation.cluster.stream().forEach(i -> {
-                         work.add(work(lazy(simulation.simulated, i, () -> logger.info(ClusterMetadata.current().epoch.toString()))));
+                         work.add(work("Output epoch",
+                                       lazy(simulation.simulated, i, () -> logger.warn(ClusterMetadata.current().epoch.toString()))));
                      });
-                     work.add(work(lazy(() -> validateAllLocal(simulation, simulation.nodeState.ring, rf))));
 
+                     work.add(interleave("Start generating", HarrySimulatorTest.generate(rowsPerPhase, simulation, cl)));
+                     work.add(work("Validate all data locally",
+                                   lazy(() -> validateAllLocal(simulation, simulation.nodeState.ring, rf))));
+
+                     return arr(work.toArray(new ActionSchedule.Work[0]));
+                 },
+                 (simulation) -> {
+                     List<ActionSchedule.Work> work = new ArrayList<>();
                      List<Integer> registeredNodes = new ArrayList<>(Arrays.asList(bootstrapNode1, bootstrapNode2, bootstrapNode3));
                      List<Integer> bootstrappedNodes = new ArrayList<>();
                      while (!registeredNodes.isEmpty() || !bootstrappedNodes.isEmpty())
@@ -191,53 +307,47 @@ public class HarrySimulatorTest
                          {
                              node = registeredNodes.remove(0);
                              long token = simulation.simulated.random.uniform(Long.MIN_VALUE, Long.MAX_VALUE);
-                             work.add(work(ActionList.of(bootstrap(simulation.simulated, simulation.cluster, token, node)),
-                                           generate(rowsPerPhase, simulation, cl)
+                             work.add(interleave("Bootstrap and generate data",
+                                                 ActionList.of(bootstrap(simulation.simulated, simulation.cluster, token, node)),
+                                                 generate(rowsPerPhase, simulation, cl)
                              ));
                              simulation.cluster.stream().forEach(i -> {
-                                 work.add(work(lazy(simulation.simulated, i, () -> logger.info(ClusterMetadata.current().epoch.toString()))));
+                                 work.add(work("Output epoch",
+                                               lazy(simulation.simulated, i, () -> logger.warn(ClusterMetadata.current().epoch.toString()))));
                              });
-                             work.add(work(run(() -> simulation.nodeState.bootstrap(node, token))));
-                             work.add(work(assertNodeState(simulation.simulated, simulation.cluster, node,NodeState.JOINED)));
+                             work.add(work("Bootstrap",
+                                           run(() -> simulation.nodeState.bootstrap(node, token))));
+                             work.add(work("Check node state",
+                                           assertNodeState(simulation.simulated, simulation.cluster, node, NodeState.JOINED)));
                              bootstrappedNodes.add(node);
                          }
                          else
                          {
                              assert !bootstrappedNodes.isEmpty();
                              node = bootstrappedNodes.remove(0);
-                             work.add(work(ActionList.of(decommission(simulation.simulated, simulation.cluster, node)),
-                                           generate(rowsPerPhase, simulation, cl)
+                             work.add(interleave("Decommission and generate data",
+                                                 ActionList.of(decommission(simulation.simulated, simulation.cluster, node)),
+                                                 generate(rowsPerPhase, simulation, cl)
                              ));
                              simulation.cluster.stream().forEach(i -> {
-                                 work.add(work(lazy(simulation.simulated, i, () -> logger.info(ClusterMetadata.current().epoch.toString()))));
+                                 work.add(work("Output epoch",
+                                               lazy(simulation.simulated, i, () -> logger.warn(ClusterMetadata.current().epoch.toString()))));
                              });
-                             work.add(work(run(() -> simulation.nodeState.decommission(node))));
-                             work.add(work(assertNodeState(simulation.simulated, simulation.cluster, node,NodeState.LEFT)));
+                             work.add(work("Decommission",
+                                           run(() -> simulation.nodeState.decommission(node))));
+                             work.add(work("Check node state", assertNodeState(simulation.simulated, simulation.cluster, node, NodeState.LEFT)));
                          }
-                         work.add(work(lazy(() -> validateAllLocal(simulation, simulation.nodeState.ring, rf))));
+                         work.add(work("Validate data locally",
+                                       lazy(() -> validateAllLocal(simulation, simulation.nodeState.ring, rf))));
                          boolean tmp = shouldBootstrap;
-                         work.add(work(run(() -> System.out.printf("Finished %s of %d and data validation!\n", tmp ? "bootstrap" : "decommission", node))));
+                         work.add(work("Output message",
+                                       run(() -> logger.warn("Finished {} of {} and data validation!\n", tmp ? "bootstrap" : "decommission", node))));
                      }
-                     work.add(work(run(() -> System.out.println("Finished!"))));
+                     work.add(work("Output message",
+                                   run(() -> logger.warn("Finished!"))));
 
                      return arr(work.toArray(new ActionSchedule.Work[0]));
-                 },
-                 (config) -> config.set("cms_default_max_retries", 10)
-                                   .set("progress_barrier_min_consistency_level", ALL)
-                                   .set("progress_barrier_default_consistency_level", ALL)
-                                   .set("progress_barrier_timeout", "600000ms")
-                                   // Backoff should be larger than read timeout, since otherwise we will simply saturate the stage with retries
-                                   .set("progress_barrier_backoff", "11000ms")
-                                   .set("cms_await_timeout", "20000ms"),
-                 arr(),
-                 (config) -> config
-                             .failures(new HaltOnError())
-                             .threadCount(1000)
-                             .readTimeoutNanos(SECONDS.toNanos(5))
-                             .writeTimeoutNanos(SECONDS.toNanos(5))
-                             .readTimeoutNanos(SECONDS.toNanos(10))
-                             .nodes(12, 12)
-                             .dcs(3, 3)
+                 }
         );
     }
 
@@ -248,9 +358,8 @@ public class HarrySimulatorTest
      * we are testing to both reduce the noise and the surface for potential investigations. This also
      * has a nice side effect of making simulations slightly faster.
      */
-    static abstract class HarrySimulation implements Simulation
+    static class HarrySimulation implements Simulation
     {
-        protected final Configuration.ConfigurationBuilder harryConfig;
         protected final ClusterActions clusterActions;
         protected final SimulatedNodeState nodeState;
         protected final Run harryRun;
@@ -258,32 +367,62 @@ public class HarrySimulatorTest
         protected final SimulatedSystems simulated;
         protected final RunnableActionScheduler scheduler;
         protected final Cluster cluster;
+        protected final Function<HarrySimulation, ActionSchedule.Work[]> schedule;
 
-        public HarrySimulation(SimulatedSystems simulated, RunnableActionScheduler scheduler, Cluster cluster, Configuration.ConfigurationBuilder harryConfig)
+        public HarrySimulation(SimulatedSystems simulated, RunnableActionScheduler scheduler, Cluster cluster, Run run, Function<HarrySimulation, ActionSchedule.Work[]> schedule)
+        {
+            this(simulated, scheduler, cluster, run, SimulatedNodeState::new, schedule);
+        }
+
+        protected HarrySimulation(SimulatedSystems simulated,
+                                  RunnableActionScheduler scheduler,
+                                  Cluster cluster,
+                                  Run run,
+                                  Function<HarrySimulation, SimulatedNodeState> nodeState,
+                                  Function<HarrySimulation, ActionSchedule.Work[]> schedule)
         {
             this.simulated = simulated;
             this.scheduler = scheduler;
             this.cluster = cluster;
 
-            this.harryConfig = harryConfig;
+            this.harryRun = run;
             Options options = noActions(cluster.size());
             this.clusterActions = new ClusterActions(simulated, cluster,
                                                      options, new NoOpListener(), new Debug(new EnumMap<>(Debug.Info.class), new int[0]));
 
-            InJvmSut sut = new InJvmSut(cluster) {
-                public void shutdown()
-                {
-                    // Let simulation shut down the cluster, as it uses `nanoTime`
-                }
-            };
+            this.nodeState = nodeState.apply(this);
+            this.schedule = schedule;
+        }
+
+        public HarrySimulation withSchedulers(Function<HarrySimulation, Map<Verb, FutureActionScheduler>> schedulers)
+        {
+            Map<Verb, FutureActionScheduler> perVerbFutureActionScheduler = schedulers.apply(this);
+            SimulatedSystems simulated = new SimulatedSystems(this.simulated.random,
+                                                              this.simulated.time,
+                                                              this.simulated.delivery,
+                                                              this.simulated.execution,
+                                                              this.simulated.ballots,
+                                                              this.simulated.failureDetector,
+                                                              this.simulated.snitch,
+                                                              this.simulated.futureScheduler,
+                                                              perVerbFutureActionScheduler,
+                                                              this.simulated.debug,
+                                                              this.simulated.failures);
+            return new HarrySimulation(simulated, scheduler, cluster, harryRun, (ignore) -> nodeState, schedule);
+        }
+
+        public HarrySimulation withSchedule(Function<HarrySimulation, ActionSchedule.Work[]> schedule)
+        {
+            return new HarrySimulation(simulated, scheduler, cluster, harryRun, (ignore) -> nodeState, schedule);
+        }
 
-            Configuration configuration = harryConfig.setClock(() -> new OffsetClock(1000)) // todo: potentially integrate approximate clock with Simulator
-                                                     .setSUT(() -> sut)
-                                                     .build();
-            this.harryRun = configuration.createRun();
-            this.nodeState = new SimulatedNodeState(this);
+        @Override
+        public CloseableIterator<?> iterator()
+        {
+            return new ActionSchedule(simulated.time, simulated.futureScheduler, () -> 0L, scheduler, schedule.apply(this));
         }
 
+        @Override
         public void run()
         {
             try (CloseableIterator<?> iter = iterator())
@@ -303,23 +442,20 @@ public class HarrySimulatorTest
         protected final Configuration.ConfigurationBuilder harryConfig;
         protected final Consumer<IInstanceConfig> configUpdater;
 
-        protected final Function<HarrySimulation, ActionSchedule.Work[]> work;
-
         HarrySimulationBuilder(Configuration.ConfigurationBuilder harryConfig,
-                               Consumer<IInstanceConfig> configUpdater,
-                               Function<HarrySimulation, ActionSchedule.Work[]> work
-        )
+                               Consumer<IInstanceConfig> configUpdater)
         {
             this.harryConfig = harryConfig;
             this.configUpdater = configUpdater;
-            this.work = work;
         }
 
+        @Override
         public Map<Verb, FutureActionScheduler> perVerbFutureActionSchedulers(int nodeCount, SimulatedTime time, RandomSource random)
         {
             return HarrySimulatorTest.networkSchedulers(nodeCount, time, random);
         }
 
+        @Override
         public FutureActionScheduler futureActionScheduler(int nodeCount, SimulatedTime time, RandomSource random)
         {
             return new AlwaysDeliverNetworkScheduler(time, random);
@@ -332,17 +468,27 @@ public class HarrySimulatorTest
             random.reset(seed);
             this.harryConfig.setSeed(seed);
 
-            return new ClusterSimulation<>(random, seed, 1, this,
-                                           configUpdater,
-                                           (simulated, scheduler, cluster, options) -> new HarrySimulation(simulated, scheduler, cluster, harryConfig)
-                                           {
 
-                                               @Override
-                                               public CloseableIterator<?> iterator()
+            return new ClusterSimulation<>(random, seed, 1, this, configUpdater,
+                                           (simulated, scheduler, cluster, options) -> {
+
+                                               InJvmSut sut = new InJvmSut(cluster)
                                                {
-                                                   // ok; and scheduler jitter is here
-                                                   return new ActionSchedule(simulated.time, simulated.futureScheduler, () -> 0L, scheduler, work.apply(this));
-                                               }
+                                                   public void shutdown()
+                                                   {
+                                                       // Let simulation shut down the cluster, as it uses `nanoTime`
+                                                   }
+                                               };
+
+                                               Configuration configuration = harryConfig.setClock(() -> new OffsetClock(1000))
+                                                                                        .setSUT(() -> sut)
+                                                                                        .build();
+                                               return new HarrySimulation(simulated,
+                                                                          scheduler,
+                                                                          cluster,
+                                                                          configuration.createRun(),
+                                                                          // No work initially
+                                                                          (sim) -> new ActionSchedule.Work[0]);
                                            });
         }
     }
@@ -350,17 +496,45 @@ public class HarrySimulatorTest
     /**
      * Simulation entrypoint; syntax sugar for creating a simulation.
      */
-    public static void simulate(Configuration.ConfigurationBuilder harryConfig,
-                                Function<HarrySimulation, ActionSchedule.Work[]> work,
-                                Consumer<IInstanceConfig> instanceConfigUpdater,
-                                String[] properties,
-                                Consumer<ClusterSimulation.Builder<HarrySimulation>> configure) throws IOException
+    static void simulate(Consumer<ClusterSimulation.Builder<HarrySimulation>> configure,
+                         Consumer<IInstanceConfig> instanceConfigUpdater,
+                         Configuration.ConfigurationBuilder harryConfig,
+                         String[] properties,
+                         Function<HarrySimulation, ActionSchedule.Work[]>... phases) throws IOException
     {
         try (WithProperties p = new WithProperties().with(properties))
         {
-            SimulationTestBase.simulate(new HarrySimulationBuilder(harryConfig, instanceConfigUpdater, work),
-                                        configure);
-        };
+            HarrySimulationBuilder factory = new HarrySimulationBuilder(harryConfig, instanceConfigUpdater);
+
+            SimulationRunner.beforeAll();
+            long seed = System.currentTimeMillis();
+            // Development seed:
+            //long seed = 1687184561194L;
+            System.out.println("Simulation seed: " + seed + "L");
+            configure.accept(factory);
+            try (ClusterSimulation<HarrySimulation> clusterSimulation = factory.create(seed))
+            {
+                try
+                {
+                    HarrySimulation simulation = clusterSimulation.simulation();
+
+                    // For better determinism during startup, we allow instances to fully start (including daemon work)
+                    for (int i = 0; i < phases.length; i++)
+                    {
+                        HarrySimulation current = simulation;
+                        if (i == 0)
+                            current = current.withSchedulers((s) -> Collections.emptyMap());
+                        current.withSchedule(phases[i]).run();
+                    }
+                }
+                catch (Throwable t)
+                {
+                    throw new AssertionError(String.format("Failed on seed %s", Long.toHexString(seed)),
+                                             t);
+                }
+            }
+        }
+        ;
     }
 
     /**
@@ -390,7 +564,7 @@ public class HarrySimulatorTest
         for (Verb verb : Verb.values())
         {
             if (extremelyLossy.contains(verb))
-                schedulers.put(verb, new FixedLossNetworkScheduler(nodes, random, time, KindOfSequence.UNIFORM, .2f, .3f));
+                schedulers.put(verb, new FixedLossNetworkScheduler(nodes, random, time, KindOfSequence.UNIFORM, .15f, .20f));
             else if (somewhatLossy.contains(verb))
                 schedulers.put(verb, new FixedLossNetworkScheduler(nodes, random, time, KindOfSequence.UNIFORM, .1f, .15f));
             else if (somewhatSlow.contains(verb))
@@ -505,7 +679,7 @@ public class HarrySimulatorTest
                         NodeState actual = ClusterMetadata.current().myNodeState();
                         if (!actual.toString().equals(expected.toString()))
                         {
-                            logger.info("Node {} state ({}) is not as expected {}", i, actual, expected);
+                            logger.error("Node {} state ({}) is not as expected {}", i, actual, expected);
                             SimulatorUtils.failWithOOM();
                         }
                     });
@@ -597,7 +771,7 @@ public class HarrySimulatorTest
                                             List<Action> actions = new ArrayList<>();
                                             long maxLts = simulation.harryRun.tracker.maxStarted();
                                             long maxPosition = simulation.harryRun.pdSelector.maxPosition(maxLts);
-                                            logger.info("Starting validation of {} written partitions. Highest LTS is {}. Ring view: {}", maxPosition, maxLts, simulation.nodeState);
+                                            logger.warn("Starting validation of {} written partitions. Highest LTS is {}. Ring view: {}", maxPosition, maxLts, simulation.nodeState);
                                             for (int position = 0; position < maxPosition; position++)
                                             {
                                                 long minLts = simulation.harryRun.pdSelector.minLtsAt(position);
@@ -610,28 +784,28 @@ public class HarrySimulatorTest
                                         });
     }
 
-    // todo rename
-    private static ActionSchedule.Work work(Action... actions)
+    private static ActionSchedule.Work work(String toString, Action... actions)
     {
-        return new ActionSchedule.Work(UNLIMITED, Collections.singletonList(ActionList.of(actions).setStrictlySequential()));
-    }
-
-    private static ActionSchedule.Work work(ActionList... actions)
-    {
-        return new ActionSchedule.Work(UNLIMITED, Arrays.asList(actions));
-    }
-
-    private static ActionSchedule.Work interleave(long nanos, Action... actions)
-    {
-        return new ActionSchedule.Work(TIME_LIMITED, nanos, Collections.singletonList(ActionList.of(actions)));
+        return new ActionSchedule.Work(UNLIMITED, Collections.singletonList(ActionList.of(actions).setStrictlySequential())) {
+            @Override
+            public String toString()
+            {
+                return toString;
+            }
+        };
     }
 
-    private static ActionSchedule.Work interleave(Action... actions)
+    private static ActionSchedule.Work interleave(String toString, ActionList... actions)
     {
-        return new ActionSchedule.Work(UNLIMITED, Collections.singletonList(ActionList.of(actions)));
+        return new ActionSchedule.Work(UNLIMITED, Arrays.asList(actions)) {
+            @Override
+            public String toString()
+            {
+                return toString;
+            }
+        };
     }
 
-
     /**
      * Simple simulated node state. Used to closely track what is going on in the cluster and
      * model placements for node-local validation.
diff --git a/test/simulator/test/org/apache/cassandra/simulator/test/ShortPaxosSimulationTest.java b/test/simulator/test/org/apache/cassandra/simulator/test/ShortPaxosSimulationTest.java
index c1f25b7d67..7eee1a69c8 100644
--- a/test/simulator/test/org/apache/cassandra/simulator/test/ShortPaxosSimulationTest.java
+++ b/test/simulator/test/org/apache/cassandra/simulator/test/ShortPaxosSimulationTest.java
@@ -34,7 +34,7 @@ import org.apache.cassandra.simulator.paxos.PaxosSimulationRunner;
  *
           -Dstorage-config=$MODULE_DIR$/test/conf
           -Djava.awt.headless=true
-          -javaagent:$MODULE_DIR$/lib/jamm-0.3.2.jar
+          -javaagent:$MODULE_DIR$/lib/jamm-0.4.0.jar
           -ea
           -Dcassandra.debugrefcount=true
           -Xss384k
@@ -56,7 +56,7 @@ import org.apache.cassandra.simulator.paxos.PaxosSimulationRunner;
           -Dcassandra.test.messagingService.nonGracefulShutdown=true
           -Dcassandra.use_nix_recursive_delete=true
           -Dcie-cassandra.disable_schema_drop_log=true
-          -Dlog4j2.configurationFile=$MODULE_DIR$/test/conf/log4j2-simulator.xml
+          -Dlogback.configurationFile=file://$MODULE_DIR$/test/conf/logback-simulator.xml
           -Dcassandra.ring_delay_ms=10000
           -Dcassandra.tolerate_sstable_size=true
           -Dcassandra.skip_sync=true
diff --git a/test/simulator/test/org/apache/cassandra/simulator/test/SimulationTestBase.java b/test/simulator/test/org/apache/cassandra/simulator/test/SimulationTestBase.java
index 93bda815b7..925f6637d8 100644
--- a/test/simulator/test/org/apache/cassandra/simulator/test/SimulationTestBase.java
+++ b/test/simulator/test/org/apache/cassandra/simulator/test/SimulationTestBase.java
@@ -194,9 +194,9 @@ public class SimulationTestBase
         configure.accept(factory);
         try (ClusterSimulation<?> cluster = factory.create(seed))
         {
-            try
+            try (Simulation simulation = cluster.simulation())
             {
-                cluster.simulation.run();
+                simulation.run();
             }
             catch (Throwable t)
             {
