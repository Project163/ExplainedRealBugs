diff --git a/src/java/org/apache/cassandra/db/ColumnFamily.java b/src/java/org/apache/cassandra/db/ColumnFamily.java
index 1f810554c0..039f67518c 100644
--- a/src/java/org/apache/cassandra/db/ColumnFamily.java
+++ b/src/java/org/apache/cassandra/db/ColumnFamily.java
@@ -262,7 +262,7 @@ public final class ColumnFamily implements IColumnContainer
      * This function will calculate the difference between 2 column families.
      * The external input is assumed to be a superset of internal.
      */
-    ColumnFamily diff(ColumnFamily cfComposite)
+    public ColumnFamily diff(ColumnFamily cfComposite)
     {
     	ColumnFamily cfDiff = new ColumnFamily(cfComposite.name(), cfComposite.type_, getComparator(), getSubComparator());
         if (cfComposite.getMarkedForDeleteAt() > getMarkedForDeleteAt())
@@ -390,30 +390,16 @@ public final class ColumnFamily implements IColumnContainer
         return subtotal;
     }
 
-    /** merge all columnFamilies into a single instance, with only the newest versions of columns preserved. */
-    static ColumnFamily resolve(List<ColumnFamily> columnFamilies)
-    {
-        int size = columnFamilies.size();
-        if (size == 0)
-            return null;
-
-        // start from nothing so that we don't include potential deleted columns from the first instance
-        ColumnFamily cf0 = columnFamilies.get(0);
-        ColumnFamily cf = cf0.cloneMeShallow();
-
-        // merge
-        for (ColumnFamily cf2 : columnFamilies)
-        {
-            assert cf.name().equals(cf2.name());
-            cf.addAll(cf2);
-        }
-        return cf;
-    }
-
     public static AbstractType getComparatorFor(String table, String columnFamilyName, byte[] superColumnName)
     {
         return superColumnName == null
                ? DatabaseDescriptor.getComparator(table, columnFamilyName)
                : DatabaseDescriptor.getSubComparator(table, columnFamilyName);
     }
+
+    public void resolve(ColumnFamily cf)
+    {
+        delete(cf);
+        addAll(cf);
+    }
 }
diff --git a/src/java/org/apache/cassandra/db/ColumnFamilyStore.java b/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
index ca6d13f5b4..ff172b1475 100644
--- a/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
+++ b/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
@@ -1464,10 +1464,8 @@ public final class ColumnFamilyStore implements ColumnFamilyStoreMBean
             columnNameSet.addAll(columnNames);
         for (String key : rr.keys)
         {
-            Row row = new Row(key);
             QueryFilter filter = sliceRange == null ? new NamesQueryFilter(key, queryPath, columnNameSet) : new SliceQueryFilter(key, queryPath, sliceRange.start, sliceRange.finish, sliceRange.reversed, sliceRange.count);
-            row.addColumnFamily(getColumnFamily(filter));
-            rows.add(row);
+            rows.add(new Row(key, getColumnFamily(filter)));
         }
 
         return new RangeSliceReply(rows, rr.rangeCompletedLocally);
diff --git a/src/java/org/apache/cassandra/db/HintedHandOffManager.java b/src/java/org/apache/cassandra/db/HintedHandOffManager.java
index 28a40f1506..43fb958992 100644
--- a/src/java/org/apache/cassandra/db/HintedHandOffManager.java
+++ b/src/java/org/apache/cassandra/db/HintedHandOffManager.java
@@ -109,8 +109,11 @@ public class HintedHandOffManager
         }
 
         Table table = Table.open(tableName);
-        Row row = table.get(key);
-        RowMutation rm = new RowMutation(tableName, row);
+        RowMutation rm = new RowMutation(tableName, key);
+        for (ColumnFamilyStore cfstore : table.getColumnFamilyStores().values())
+        {
+            rm.add(cfstore.getColumnFamily(new IdentityQueryFilter(key, new QueryPath(cfstore.getColumnFamilyName()))));
+        }
         Message message = rm.makeRowMutationMessage();
         WriteResponseHandler responseHandler = new WriteResponseHandler(1);
         MessagingService.instance().sendRR(message, new InetAddress[] { endPoint }, responseHandler);
diff --git a/src/java/org/apache/cassandra/db/Row.java b/src/java/org/apache/cassandra/db/Row.java
index c039468db2..2fc4edd17a 100644
--- a/src/java/org/apache/cassandra/db/Row.java
+++ b/src/java/org/apache/cassandra/db/Row.java
@@ -22,18 +22,12 @@ import java.io.DataInputStream;
 import java.io.DataOutputStream;
 import java.io.IOException;
 import java.util.Collection;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Set;
-import java.util.Arrays;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 
-import org.apache.commons.lang.StringUtils;
 import org.apache.log4j.Logger;
 
 import org.apache.cassandra.io.ICompactSerializer;
-import org.apache.cassandra.io.DataOutputBuffer;
 
 public class Row
 {
@@ -45,97 +39,23 @@ public class Row
         return serializer;
     }
 
-    public Row(String key)
-    {
-        this.key_ = key;
-    }
-
-    private String key_;
-
-    private Map<String, ColumnFamily> columnFamilies_ = new HashMap<String, ColumnFamily>();
-
-    public String key()
-    {
-        return key_;
-    }
-
-    public Collection<ColumnFamily> getColumnFamilies()
-    {
-        return columnFamilies_.values();
-    }
+    public final String key;
+    public final ColumnFamily cf;
 
-    public ColumnFamily getColumnFamily(String cfName)
+    public Row(String key, ColumnFamily cf)
     {
-        return columnFamilies_.get(cfName);
+        this.key = key;
+        this.cf = cf;
     }
 
-    void addColumnFamily(ColumnFamily columnFamily)
-    {
-        columnFamilies_.put(columnFamily.name(), columnFamily);
-    }
-
-    public boolean isEmpty()
-    {
-        return (columnFamilies_.size() == 0);
-    }
-
-    /*
+    /**
      * This function will repair the current row with the input row
      * what that means is that if there are any differences between the 2 rows then
      * this function will make the current row take the latest changes.
      */
-    public void repair(Row rowOther)
+    public void resolve(Row other)
     {
-        for (ColumnFamily cfOld : rowOther.getColumnFamilies())
-        {
-            ColumnFamily cf = columnFamilies_.get(cfOld.name());
-            if (cf == null)
-            {
-                addColumnFamily(cfOld);
-            }
-            else
-            {
-                columnFamilies_.remove(cf.name());
-                addColumnFamily(ColumnFamily.resolve(Arrays.asList(cfOld, cf)));
-            }
-        }
-    }
-
-    /*
-     * This function will calculate the difference between 2 rows
-     * and return the resultant row. This assumes that the row that
-     * is being submitted is a super set of the current row so
-     * it only calculates additional
-     * difference and does not take care of what needs to be removed from the current row to make
-     * it same as the input row.
-     */
-    public Row diff(Row rowComposite)
-    {
-        Row rowDiff = new Row(key_);
-
-        for (ColumnFamily cfComposite : rowComposite.getColumnFamilies())
-        {
-            ColumnFamily cf = columnFamilies_.get(cfComposite.name());
-            if (cf == null)
-                rowDiff.addColumnFamily(cfComposite);
-            else
-            {
-                ColumnFamily cfDiff = cf.diff(cfComposite);
-                if (cfDiff != null)
-                    rowDiff.addColumnFamily(cfDiff);
-            }
-        }
-        if (rowDiff.getColumnFamilies().isEmpty())
-            return null;
-        else
-            return rowDiff;
-    }
-
-    public Row cloneMe()
-    {
-        Row row = new Row(key_);
-        row.columnFamilies_ = new HashMap<String, ColumnFamily>(columnFamilies_);
-        return row;
+        cf.resolve(other.cf);
     }
 
     public byte[] digest()
@@ -149,18 +69,18 @@ public class Row
         {
             throw new AssertionError(e);
         }
-
-        for (String cFamily : columnFamilies_.keySet())
-        {
-            columnFamilies_.get(cFamily).updateDigest(digest);
-        }
+        cf.updateDigest(digest);
 
         return digest.digest();
     }
 
+    @Override
     public String toString()
     {
-        return "Row(" + key_ + " [" + StringUtils.join(columnFamilies_.values(), ", ") + "])";
+        return "Row(" +
+               "key='" + key + '\'' +
+               ", cf=" + cf +
+               ')';
     }
 }
 
@@ -168,28 +88,12 @@ class RowSerializer implements ICompactSerializer<Row>
 {
     public void serialize(Row row, DataOutputStream dos) throws IOException
     {
-        dos.writeUTF(row.key());
-        Collection<ColumnFamily> columnFamilies = row.getColumnFamilies();
-        int size = columnFamilies.size();
-        dos.writeInt(size);
-
-        for (ColumnFamily cf : columnFamilies)
-        {
-            ColumnFamily.serializer().serialize(cf, dos);
-        }
+        dos.writeUTF(row.key);
+        ColumnFamily.serializer().serialize(row.cf, dos);
     }
 
     public Row deserialize(DataInputStream dis) throws IOException
     {
-        String key = dis.readUTF();
-        Row row = new Row(key);
-        int size = dis.readInt();
-
-        for (int i = 0; i < size; ++i)
-        {
-            ColumnFamily cf = ColumnFamily.serializer().deserialize(dis);
-            row.addColumnFamily(cf);
-        }
-        return row;
+        return new Row(dis.readUTF(), ColumnFamily.serializer().deserialize(dis));
     }
 }
diff --git a/src/java/org/apache/cassandra/db/RowMutation.java b/src/java/org/apache/cassandra/db/RowMutation.java
index 8a97e80bec..7724bf1c75 100644
--- a/src/java/org/apache/cassandra/db/RowMutation.java
+++ b/src/java/org/apache/cassandra/db/RowMutation.java
@@ -71,11 +71,8 @@ public class RowMutation implements Serializable
     public RowMutation(String table, Row row)
     {
         table_ = table;
-        key_ = row.key();
-        for (ColumnFamily cf : row.getColumnFamilies())
-        {
-            add(cf);
-        }
+        key_ = row.key;
+        add(row.cf);
     }
 
     protected RowMutation(String table, String key, Map<String, ColumnFamily> modifications)
diff --git a/src/java/org/apache/cassandra/db/Table.java b/src/java/org/apache/cassandra/db/Table.java
index 2cd1a0eb9c..7eada62f8b 100644
--- a/src/java/org/apache/cassandra/db/Table.java
+++ b/src/java/org/apache/cassandra/db/Table.java
@@ -393,25 +393,6 @@ public class Table
         return tableMetadata_.isValidColumnFamily(columnFamily);
     }
 
-    /**
-     * Selects the row associated with the given key.
-    */
-    @Deprecated // CF should be our atom of work, not Row
-    public Row get(String key) throws IOException
-    {
-        Row row = new Row(key);
-        for (String columnFamily : getColumnFamilies())
-        {
-            ColumnFamily cf = get(key, columnFamily);
-            if (cf != null)
-            {
-                row.addColumnFamily(cf);
-            }
-        }
-        return row;
-    }
-
-
     /**
      * Selects the specified column family for the specified key.
     */
@@ -423,27 +404,11 @@ public class Table
         return cfStore.getColumnFamily(new IdentityQueryFilter(key, new QueryPath(cfName)));
     }
 
-    /**
-     * Selects only the specified column family for the specified key.
-    */
-    @Deprecated
-    public Row getRow(String key, String cfName) throws IOException
-    {
-        Row row = new Row(key);
-        ColumnFamily columnFamily = get(key, cfName);
-        if ( columnFamily != null )
-        	row.addColumnFamily(columnFamily);
-        return row;
-    }
-    
     public Row getRow(QueryFilter filter) throws IOException
     {
         ColumnFamilyStore cfStore = columnFamilyStores_.get(filter.getColumnFamilyName());
-        Row row = new Row(filter.key);
         ColumnFamily columnFamily = cfStore.getColumnFamily(filter);
-        if (columnFamily != null)
-            row.addColumnFamily(columnFamily);
-        return row;
+        return new Row(filter.key, columnFamily);
     }
 
     /**
diff --git a/src/java/org/apache/cassandra/service/CassandraServer.java b/src/java/org/apache/cassandra/service/CassandraServer.java
index 7206a71bd4..2cd3e5aaaf 100644
--- a/src/java/org/apache/cassandra/service/CassandraServer.java
+++ b/src/java/org/apache/cassandra/service/CassandraServer.java
@@ -22,7 +22,6 @@ import java.io.BufferedInputStream;
 import java.io.FileInputStream;
 import java.io.IOException;
 import java.util.*;
-import java.util.concurrent.TimeoutException;
 
 import org.apache.log4j.Logger;
 
@@ -99,7 +98,7 @@ public class CassandraServer implements Cassandra.Iface
 
         for (Row row: rows)
         {
-            columnFamilyKeyMap.put(row.key(), row.getColumnFamily(cfName));
+            columnFamilyKeyMap.put(row.key, row.cf);
         }
         return columnFamilyKeyMap;
 	}
diff --git a/src/java/org/apache/cassandra/service/ReadResponseResolver.java b/src/java/org/apache/cassandra/service/ReadResponseResolver.java
index 4c36d39665..8e3286d348 100644
--- a/src/java/org/apache/cassandra/service/ReadResponseResolver.java
+++ b/src/java/org/apache/cassandra/service/ReadResponseResolver.java
@@ -22,8 +22,6 @@ import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
-import java.util.Map;
-import java.util.Set;
 
 import org.apache.cassandra.db.ColumnFamily;
 import org.apache.cassandra.db.ReadResponse;
@@ -65,7 +63,7 @@ public class ReadResponseResolver implements IResponseResolver<Row>
 	public Row resolve(List<Message> responses) throws DigestMismatchException, IOException
     {
         long startTime = System.currentTimeMillis();
-		Row retRow = null;
+		Row resolved = null;
 		List<Row> rowList = new ArrayList<Row>();
 		List<InetAddress> endPoints = new ArrayList<InetAddress>();
 		String key = null;
@@ -93,7 +91,7 @@ public class ReadResponseResolver implements IResponseResolver<Row>
             {
                 rowList.add(result.row());
                 endPoints.add(response.getFrom());
-                key = result.row().key();
+                key = result.row().key;
             }
         }
 		// If there was a digest query compare it with all the data digests 
@@ -105,7 +103,7 @@ public class ReadResponseResolver implements IResponseResolver<Row>
                 if (!Arrays.equals(row.digest(), digest))
                 {
                     /* Wrap the key as the context in this exception */
-                    String s = String.format("Mismatch for key %s (%s vs %s)", row.key(), FBUtilities.bytesToHex(row.digest()), FBUtilities.bytesToHex(digest));
+                    String s = String.format("Mismatch for key %s (%s vs %s)", row.key, FBUtilities.bytesToHex(row.digest()), FBUtilities.bytesToHex(digest));
                     throw new DigestMismatchException(s);
                 }
             }
@@ -114,37 +112,33 @@ public class ReadResponseResolver implements IResponseResolver<Row>
         /* If the rowList is empty then we had some exception above. */
         if (rowList.size() == 0)
         {
-            return retRow;
+            return resolved;
         }
 
         /* Now calculate the resolved row */
-        retRow = new Row(key);
-        for (int i = 0; i < rowList.size(); i++)
+        resolved = new Row(key, rowList.get(0).cf);
+        for (Row other : rowList.subList(1, rowList.size()))
         {
-            retRow.repair(rowList.get(i));
+            resolved.resolve(other);
         }
 
-        // At  this point  we have the return row .
-        // Now we need to calculate the difference
-        // so that we can schedule read repairs
+        // At this point we have the return row;
+        // Now we need to calculate the difference so that we can schedule read repairs
         for (int i = 0; i < rowList.size(); i++)
         {
             // since retRow is the resolved row it can be used as the super set
-            Row diffRow = rowList.get(i).diff(retRow);
-            if (diffRow == null) // no repair needs to happen
+            ColumnFamily diffCf = rowList.get(i).cf.diff(resolved.cf);
+            if (diffCf == null) // no repair needs to happen
                 continue;
             // create the row mutation message based on the diff and schedule a read repair
             RowMutation rowMutation = new RowMutation(table, key);
-            for (ColumnFamily cf : diffRow.getColumnFamilies())
-            {
-                rowMutation.add(cf);
-            }
+            rowMutation.add(diffCf);
             RowMutationMessage rowMutationMessage = new RowMutationMessage(rowMutation);
             ReadRepairManager.instance().schedule(endPoints.get(i), rowMutationMessage);
         }
         if (logger_.isDebugEnabled())
             logger_.debug("resolve: " + (System.currentTimeMillis() - startTime) + " ms.");
-		return retRow;
+		return resolved;
 	}
 
 	public boolean isDataPresent(List<Message> responses)
diff --git a/src/java/org/apache/cassandra/service/StorageProxy.java b/src/java/org/apache/cassandra/service/StorageProxy.java
index 1707d32a93..d65cabbb0b 100644
--- a/src/java/org/apache/cassandra/service/StorageProxy.java
+++ b/src/java/org/apache/cassandra/service/StorageProxy.java
@@ -84,7 +84,7 @@ public class StorageProxy implements StorageProxyMBean
     {
         public int compare(Row r1, Row r2)
         {
-            return keyComparator.compare(r1.key(), r2.key());
+            return keyComparator.compare(r1.key, r2.key);
         }
     };
 
@@ -562,22 +562,22 @@ public class StorageProxy implements StorageProxyMBean
             {
                 if (allRows.size() > 0)
                 {
-                    if (keyComparator.compare(rangeRows.get(rangeRows.size() - 1).key(), allRows.first().key()) <= 0)
+                    if (keyComparator.compare(rangeRows.get(rangeRows.size() - 1).key, allRows.first().key) <= 0)
                     {
                         // unlikely, but possible
-                        if (rangeRows.get(rangeRows.size() - 1).equals(allRows.first().key()))
+                        if (rangeRows.get(rangeRows.size() - 1).equals(allRows.first().key))
                         {
                             rangeRows.remove(rangeRows.size() - 1);
                         }
                         // put all from rangeRows into allRows.
                         allRows.addAll(rangeRows);
                     }
-                    else if (keyComparator.compare(allRows.last().key(), rangeRows.get(0).key()) <= 0)
+                    else if (keyComparator.compare(allRows.last().key, rangeRows.get(0).key) <= 0)
                     {
                         // common case. deal with simple start/end key overlaps
-                        if (allRows.last().key().equals(rangeRows.get(0)))
+                        if (allRows.last().key.equals(rangeRows.get(0)))
                         {
-                            allRows.remove(allRows.last().key());
+                            allRows.remove(allRows.last().key);
                         }
                         allRows.addAll(rangeRows); // todo: check logic.
                     }
@@ -609,8 +609,7 @@ public class StorageProxy implements StorageProxyMBean
         for (Row row : allRows)
         {
             // for now, assume only one cf per row, since that is all we can specify in the Command.
-            ColumnFamily cf = row.getColumnFamilies().iterator().next();
-            results.put(row.key(),cf.getSortedColumns());
+            results.put(row.key, row.cf.getSortedColumns());
         }
         rangeStats.add(System.currentTimeMillis() - startTime);
         return results;
diff --git a/src/java/org/apache/cassandra/service/StorageService.java b/src/java/org/apache/cassandra/service/StorageService.java
index 8d072831c4..445e8a7744 100644
--- a/src/java/org/apache/cassandra/service/StorageService.java
+++ b/src/java/org/apache/cassandra/service/StorageService.java
@@ -353,8 +353,7 @@ public final class StorageService implements IEndPointStateChangeSubscriber, Sto
      */
     public void doConsistencyCheck(Row row, List<InetAddress> endpoints, ReadCommand command)
     {
-        Runnable consistencySentinel = new ConsistencyManager(command.table, row.cloneMe(), endpoints, command);
-        consistencyManager_.submit(consistencySentinel);
+        consistencyManager_.submit(new ConsistencyManager(command.table, row, endpoints, command));
     }
 
     public Map<Range, List<String>> getRangeToEndPointMap()
diff --git a/src/java/org/apache/cassandra/tools/KeyChecker.java b/src/java/org/apache/cassandra/tools/KeyChecker.java
deleted file mode 100644
index 0fbec6bf03..0000000000
--- a/src/java/org/apache/cassandra/tools/KeyChecker.java
+++ /dev/null
@@ -1,101 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.cassandra.tools;
-
-import java.io.BufferedReader;
-import java.io.FileInputStream;
-import java.io.InputStreamReader;
-import java.io.RandomAccessFile;
-
-import org.apache.cassandra.db.Row;
-import org.apache.cassandra.db.Table;
-import java.net.InetAddress;
-import java.util.List;
-
-import org.apache.cassandra.service.StorageService;
-import org.apache.cassandra.utils.FBUtilities;
-import org.apache.cassandra.utils.LogUtil;
-
-
-public class KeyChecker
-{
-    private static final int bufSize_ = 128*1024*1024;
-    /*
-     * This function checks if the local storage endpoint 
-     * is responsible for storing this key .
-     */
-    private static boolean checkIfProcessKey(String key)
-    {
-        List<InetAddress> endPoints = StorageService.instance().getNaturalEndpoints(key);
-        InetAddress localEndPoint = FBUtilities.getLocalAddress();
-        for(InetAddress endPoint : endPoints)
-        {
-            if(endPoint.equals(localEndPoint))
-                return true;
-        }
-        return false;
-    }
-    
-    public static void main(String[] args) throws Throwable
-    {
-        if ( args.length != 1 )
-        {
-            System.out.println("Usage : java com.facebook.infrastructure.tools.KeyChecker <file containing all keys>");
-            System.exit(1);
-        }
-        
-        LogUtil.init();
-        StorageService s = StorageService.instance();
-        s.start();
-        
-        /* Sleep for proper discovery */
-        Thread.sleep(240000);
-        /* Create the file for the missing keys */
-        RandomAccessFile raf = new RandomAccessFile( "Missing-" + FBUtilities.getLocalAddress() + ".dat", "rw");
-        
-        /* Start reading the file that contains the keys */
-        BufferedReader bufReader = new BufferedReader( new InputStreamReader( new FileInputStream(args[0]) ), KeyChecker.bufSize_ );
-        String key = null;
-        boolean bStarted = false;
-        
-        while ( ( key = bufReader.readLine() ) != null )
-        {            
-            if ( !bStarted )
-            {
-                bStarted = true;
-                System.out.println("Started the processing of the file ...");
-            }
-            
-            key = key.trim();
-            if ( StorageService.instance().isPrimary(key) )
-            {
-                System.out.println("Processing key " + key);
-                Row row = Table.open("Mailbox").getRow(key, "MailboxMailList0");
-                if ( row.isEmpty() )
-                {
-                    System.out.println("MISSING KEY : " + key);
-                    raf.write(key.getBytes());
-                    raf.write(System.getProperty("line.separator").getBytes());
-                }
-            }
-        }
-        System.out.println("DONE checking keys ...");
-        raf.close();
-    }
-}
diff --git a/test/unit/org/apache/cassandra/db/ReadMessageTest.java b/test/unit/org/apache/cassandra/db/ReadMessageTest.java
index 0602973134..9d63a2388d 100644
--- a/test/unit/org/apache/cassandra/db/ReadMessageTest.java
+++ b/test/unit/org/apache/cassandra/db/ReadMessageTest.java
@@ -81,8 +81,7 @@ public class ReadMessageTest
 
         ReadCommand command = new SliceByNamesReadCommand("Keyspace1", "key1", new QueryPath("Standard1"), Arrays.asList("Column1".getBytes()));
         Row row = command.getRow(table);
-        ColumnFamily cf = row.getColumnFamily("Standard1");
-        IColumn col = cf.getColumn("Column1".getBytes());
+        IColumn col = row.cf.getColumn("Column1".getBytes());
         assert Arrays.equals(col.value(), "abcd".getBytes());  
     }
 }
diff --git a/test/unit/org/apache/cassandra/db/RowTest.java b/test/unit/org/apache/cassandra/db/RowTest.java
index ac3f4e0520..1483f33909 100644
--- a/test/unit/org/apache/cassandra/db/RowTest.java
+++ b/test/unit/org/apache/cassandra/db/RowTest.java
@@ -23,7 +23,6 @@ import java.util.Arrays;
 import org.junit.Test;
 
 import static junit.framework.Assert.assertEquals;
-import org.apache.cassandra.db.filter.QueryPath;
 import org.apache.cassandra.db.marshal.AsciiType;
 import static org.apache.cassandra.Util.column;
 
@@ -58,26 +57,20 @@ public class RowTest
     }
 
     @Test
-    public void testRepair()
+    public void testResolve()
     {
-        Row row1 = new Row("");
         ColumnFamily cf1 = ColumnFamily.create("Keyspace1", "Standard1");
         cf1.addColumn(column("one", "A", 0));
-        row1.addColumnFamily(cf1);
+        Row row1 = new Row("", cf1);
 
-        Row row2 = new Row("");
         ColumnFamily cf2 = ColumnFamily.create("Keyspace1", "Standard1");
         cf2.addColumn(column("one", "B", 1));
         cf2.addColumn(column("two", "C", 1));
-        ColumnFamily cf3 = ColumnFamily.create("Keyspace2", "Standard3");
-        cf3.addColumn(column("three", "D", 1));
-        row2.addColumnFamily(cf2);
-        row2.addColumnFamily(cf3);
+        Row row2 = new Row("", cf2);
 
-        row1.repair(row2);
-        cf1 = row1.getColumnFamily("Standard1");
+        row1.resolve(row2);
+        cf1 = row1.cf;
         assert Arrays.equals(cf1.getColumn("one".getBytes()).value(), "B".getBytes());
-        assert Arrays.equals(cf2.getColumn("two".getBytes()).value(), "C".getBytes());
-        assert row1.getColumnFamily("Standard3") != null;
+        assert Arrays.equals(cf1.getColumn("two".getBytes()).value(), "C".getBytes());
     }
 }
diff --git a/test/unit/org/apache/cassandra/db/TableTest.java b/test/unit/org/apache/cassandra/db/TableTest.java
index 7cac72432d..316375dbf2 100644
--- a/test/unit/org/apache/cassandra/db/TableTest.java
+++ b/test/unit/org/apache/cassandra/db/TableTest.java
@@ -57,13 +57,6 @@ public class TableTest extends CleanupHelper
         verify.run();
     }
 
-    @Test
-    public void testOpen() throws Throwable {
-        Table table = Table.open("Mailbox");
-        Row row = table.get("35300190:1");
-        assertNotNull(row);
-    }
-
     @Test
     public void testGetRowNoColumns() throws Throwable
     {
