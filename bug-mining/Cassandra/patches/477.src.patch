diff --git a/CHANGES.txt b/CHANGES.txt
index 85256bb712..f73d99955d 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -87,6 +87,7 @@
  * Close intra-node sockets when connection is broken (CASSANDRA-1528)
  * RPM packaging spec file (CASSANDRA-786)
  * weighted request scheduler (CASSANDRA-1485)
+ * treat expired columns as deleted (CASSANDRA-1539)
 
 
 0.7-beta1
diff --git a/src/java/org/apache/cassandra/db/ExpiringColumn.java b/src/java/org/apache/cassandra/db/ExpiringColumn.java
index 12f7801a21..d9813ff646 100644
--- a/src/java/org/apache/cassandra/db/ExpiringColumn.java
+++ b/src/java/org/apache/cassandra/db/ExpiringColumn.java
@@ -113,4 +113,17 @@ public class ExpiringColumn extends Column
         sb.append(timeToLive);
         return sb.toString();
     }
+
+    @Override
+    public IClock getMarkedForDeleteAt()
+    {
+        if (isMarkedForDelete())
+        {
+            return clock;
+        }
+        else
+        {
+            throw new IllegalStateException("column is not marked for delete");
+        }
+    }
 }
diff --git a/test/unit/org/apache/cassandra/db/RowTest.java b/test/unit/org/apache/cassandra/db/RowTest.java
index 2e028d17f1..f23c68d9e6 100644
--- a/test/unit/org/apache/cassandra/db/RowTest.java
+++ b/test/unit/org/apache/cassandra/db/RowTest.java
@@ -24,6 +24,7 @@ import org.apache.cassandra.SchemaLoader;
 import org.junit.Test;
 
 import static junit.framework.Assert.assertEquals;
+import static junit.framework.Assert.fail;
 import org.apache.cassandra.db.marshal.AsciiType;
 import static org.apache.cassandra.Util.column;
 
@@ -71,4 +72,24 @@ public class RowTest extends SchemaLoader
         assert Arrays.equals(cf1.getColumn("one".getBytes()).value(), "B".getBytes());
         assert Arrays.equals(cf1.getColumn("two".getBytes()).value(), "C".getBytes());
     }
+
+    @Test
+    public void testExpiringColumnExpiration()
+    {
+        Column c = new ExpiringColumn("one".getBytes(), "A".getBytes(), new TimestampClock(0), 1);
+        assert !c.isMarkedForDelete();
+
+        try
+        {
+            // Because we keep the local deletion time with a precision of a
+            // second, we could have to wait 2 seconds in worst case scenario.
+            Thread.sleep(2000);
+        }
+        catch (InterruptedException e)
+        {
+            fail("Cannot test column expiration if you wake me up too early");
+        }
+
+        assert c.isMarkedForDelete() && c.getMarkedForDeleteAt().equals(new TimestampClock(0));
+    }
 }
