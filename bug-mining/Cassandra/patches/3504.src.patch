diff --git a/CHANGES.txt b/CHANGES.txt
index e3428a7a85..ff25db6d45 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,6 @@
 2.1.5
+ * Update collection types that use a user-defined type when that UDT is
+   modified (CASSANDRA-9148)
  * Re-add deprecated cold_reads_to_omit param for backwards compat (CASSANDRA-9203)
  * Make anticompaction visible in compactionstats (CASSANDRA-9098)
  * Improve nodetool getendpoints documentation about the partition
diff --git a/src/java/org/apache/cassandra/cql3/statements/AlterTypeStatement.java b/src/java/org/apache/cassandra/cql3/statements/AlterTypeStatement.java
index 64e7627b86..2dcf8dcf6b 100644
--- a/src/java/org/apache/cassandra/cql3/statements/AlterTypeStatement.java
+++ b/src/java/org/apache/cassandra/cql3/statements/AlterTypeStatement.java
@@ -163,7 +163,14 @@ public abstract class AlterTypeStatement extends SchemaAlteringStatement
             default:
                 // If it's a collection, we still want to modify the comparator because the collection is aliased in it
                 if (def.type instanceof CollectionType)
-                    cfm.comparator = CellNames.fromAbstractType(updateWith(cfm.comparator.asAbstractType(), keyspace, toReplace, updated), cfm.comparator.isDense());
+                {
+                    t = updateWith(cfm.comparator.asAbstractType(), keyspace, toReplace, updated);
+                    // If t == null, all relevant comparators were updated via updateWith, which reaches into types and
+                    // collections
+                    if (t != null)
+                        cfm.comparator = CellNames.fromAbstractType(t, cfm.comparator.isDense());
+                }
+                break;
         }
         return true;
     }
diff --git a/src/java/org/apache/cassandra/db/composites/CellNames.java b/src/java/org/apache/cassandra/db/composites/CellNames.java
index b94116666f..f73f7a7e5f 100644
--- a/src/java/org/apache/cassandra/db/composites/CellNames.java
+++ b/src/java/org/apache/cassandra/db/composites/CellNames.java
@@ -63,6 +63,7 @@ public abstract class CellNames
             }
             else
             {
+                assert type != null;
                 return new SimpleSparseCellNameType(type);
             }
         }
diff --git a/test/unit/org/apache/cassandra/cql3/CQLTester.java b/test/unit/org/apache/cassandra/cql3/CQLTester.java
index e994f014b7..8b24e69b4c 100644
--- a/test/unit/org/apache/cassandra/cql3/CQLTester.java
+++ b/test/unit/org/apache/cassandra/cql3/CQLTester.java
@@ -675,6 +675,11 @@ public abstract class CQLTester
         return new TupleValue(values);
     }
 
+    protected Object userType(Object... values)
+    {
+        return new TupleValue(values).toByteBuffer();
+    }
+
     protected Object list(Object...values)
     {
         return Arrays.asList(values);
diff --git a/test/unit/org/apache/cassandra/cql3/UserTypesTest.java b/test/unit/org/apache/cassandra/cql3/UserTypesTest.java
index 76315cf264..1d71fe8d94 100644
--- a/test/unit/org/apache/cassandra/cql3/UserTypesTest.java
+++ b/test/unit/org/apache/cassandra/cql3/UserTypesTest.java
@@ -111,4 +111,115 @@ public class UserTypesTest extends CQLTester
                    row(1, null),
                    row(2, 2));
     }
+
+    @Test
+    public void testAlteringUserTypeNestedWithinMap() throws Throwable
+    {
+        // test frozen and non-frozen collections
+        String[] columnTypePrefixes = {"frozen<map<text, ", "map<text, frozen<"};
+        for (String columnTypePrefix : columnTypePrefixes)
+        {
+            String ut1 = createType("CREATE TYPE %s (a int)");
+            String columnType = columnTypePrefix + KEYSPACE + "." + ut1 + ">>";
+
+            createTable("CREATE TABLE %s (x int PRIMARY KEY, y " + columnType + ")");
+
+            execute("INSERT INTO %s (x, y) VALUES(1, {'firstValue':{a:1}})");
+            assertRows(execute("SELECT * FROM %s"), row(1, map("firstValue", userType(1))));
+            flush();
+
+            execute("ALTER TYPE " + KEYSPACE + "." + ut1 + " ADD b int");
+            execute("INSERT INTO %s (x, y) VALUES(2, {'secondValue':{a:2, b:2}})");
+            execute("INSERT INTO %s (x, y) VALUES(3, {'thirdValue':{a:3}})");
+            execute("INSERT INTO %s (x, y) VALUES(4, {'fourthValue':{b:4}})");
+
+            assertRows(execute("SELECT * FROM %s"),
+                    row(1, map("firstValue", userType(1))),
+                    row(2, map("secondValue", userType(2, 2))),
+                    row(3, map("thirdValue", userType(3, null))),
+                    row(4, map("fourthValue", userType(null, 4))));
+
+            flush();
+
+            assertRows(execute("SELECT * FROM %s"),
+                    row(1, map("firstValue", userType(1))),
+                    row(2, map("secondValue", userType(2, 2))),
+                    row(3, map("thirdValue", userType(3, null))),
+                    row(4, map("fourthValue", userType(null, 4))));
+        }
+    }
+
+    @Test
+    public void testAlteringUserTypeNestedWithinSet() throws Throwable
+    {
+        // test frozen and non-frozen collections
+        String[] columnTypePrefixes = {"frozen<set<", "set<frozen<"};
+        for (String columnTypePrefix : columnTypePrefixes)
+        {
+            String ut1 = createType("CREATE TYPE %s (a int)");
+            String columnType = columnTypePrefix + KEYSPACE + "." + ut1 + ">>";
+
+            createTable("CREATE TABLE %s (x int PRIMARY KEY, y " + columnType + ")");
+
+            execute("INSERT INTO %s (x, y) VALUES(1, {1} )");
+            assertRows(execute("SELECT * FROM %s"), row(1, set(userType(1))));
+            flush();
+
+            execute("ALTER TYPE " + KEYSPACE + "." + ut1 + " ADD b int");
+            execute("INSERT INTO %s (x, y) VALUES(2, {{a:2, b:2}})");
+            execute("INSERT INTO %s (x, y) VALUES(3, {{a:3}})");
+            execute("INSERT INTO %s (x, y) VALUES(4, {{b:4}})");
+
+            assertRows(execute("SELECT * FROM %s"),
+                    row(1, set(userType(1))),
+                    row(2, set(userType(2, 2))),
+                    row(3, set(userType(3, null))),
+                    row(4, set(userType(null, 4))));
+
+            flush();
+
+            assertRows(execute("SELECT * FROM %s"),
+                    row(1, set(userType(1))),
+                    row(2, set(userType(2, 2))),
+                    row(3, set(userType(3, null))),
+                    row(4, set(userType(null, 4))));
+        }
+    }
+
+    @Test
+    public void testAlteringUserTypeNestedWithinList() throws Throwable
+    {
+        // test frozen and non-frozen collections
+        String[] columnTypePrefixes = {"frozen<list<", "list<frozen<"};
+        for (String columnTypePrefix : columnTypePrefixes)
+        {
+            String ut1 = createType("CREATE TYPE %s (a int)");
+            String columnType = columnTypePrefix + KEYSPACE + "." + ut1 + ">>";
+
+            createTable("CREATE TABLE %s (x int PRIMARY KEY, y " + columnType + ")");
+
+            execute("INSERT INTO %s (x, y) VALUES(1, [1] )");
+            assertRows(execute("SELECT * FROM %s"), row(1, list(userType(1))));
+            flush();
+
+            execute("ALTER TYPE " + KEYSPACE + "." + ut1 + " ADD b int");
+            execute("INSERT INTO %s (x, y) VALUES(2, [{a:2, b:2}])");
+            execute("INSERT INTO %s (x, y) VALUES(3, [{a:3}])");
+            execute("INSERT INTO %s (x, y) VALUES(4, [{b:4}])");
+
+            assertRows(execute("SELECT * FROM %s"),
+                    row(1, list(userType(1))),
+                    row(2, list(userType(2, 2))),
+                    row(3, list(userType(3, null))),
+                    row(4, list(userType(null, 4))));
+
+            flush();
+
+            assertRows(execute("SELECT * FROM %s"),
+                    row(1, list(userType(1))),
+                    row(2, list(userType(2, 2))),
+                    row(3, list(userType(3, null))),
+                    row(4, list(userType(null, 4))));
+        }
+    }
 }
