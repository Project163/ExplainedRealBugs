diff --git a/CHANGES.txt b/CHANGES.txt
index ae9ef7a9ab..682f12bfd0 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 2.2.9
+ * Limit colUpdateTimeDelta histogram updates to reasonable deltas (CASSANDRA-11117)
  * Fix leak errors and execution rejected exceptions when draining (CASSANDRA-12457)
  * Fix merkle tree depth calculation (CASSANDRA-12580)
  * Make Collections deserialization more robust (CASSANDRA-12618)
diff --git a/src/java/org/apache/cassandra/db/ColumnFamilyStore.java b/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
index 644d1f5043..c6b69dc850 100644
--- a/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
+++ b/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
@@ -1347,8 +1347,13 @@ public class ColumnFamilyStore implements ColumnFamilyStoreMBean
         maybeUpdateRowCache(key);
         metric.samplers.get(Sampler.WRITES).addSample(key.getKey(), key.hashCode(), 1);
         metric.writeLatency.addNano(System.nanoTime() - start);
+        // CASSANDRA-11117 - certain resolution paths on memtable put can result in very
+        // large time deltas, either through a variety of sentinel timestamps (used for empty values, ensuring
+        // a minimal write, etc). This limits the time delta to the max value the histogram
+        // can bucket correctly. This also filters the Long.MAX_VALUE case where there was no previous value
+        // to update.
         if(timeDelta < Long.MAX_VALUE)
-            metric.colUpdateTimeDeltaHistogram.update(timeDelta);
+            metric.colUpdateTimeDeltaHistogram.update(Math.min(18165375903306L, timeDelta));
     }
 
     /**
diff --git a/test/unit/org/apache/cassandra/db/ColumnFamilyMetricTest.java b/test/unit/org/apache/cassandra/db/ColumnFamilyMetricTest.java
index 1337564317..2d89e09528 100644
--- a/test/unit/org/apache/cassandra/db/ColumnFamilyMetricTest.java
+++ b/test/unit/org/apache/cassandra/db/ColumnFamilyMetricTest.java
@@ -103,4 +103,30 @@ public class ColumnFamilyMetricTest
 
         store.enableAutoCompaction();
     }
+
+    @Test
+    public void testColUpdateTimeDeltaFiltering()
+    {
+        Keyspace keyspace = Keyspace.open("Keyspace1");
+        ColumnFamilyStore store = keyspace.getColumnFamilyStore("Standard2");
+
+        // This confirms another test/set up did not overflow the histogram
+        store.metric.colUpdateTimeDeltaHistogram.cf.getSnapshot().get999thPercentile();
+
+        ByteBuffer key = ByteBufferUtil.bytes(4242);
+        Mutation m = new Mutation("Keyspace1", key);
+        m.add("Standard2", cellname("0"), ByteBufferUtil.bytes("0"), 0);
+        m.apply();
+
+        // The histogram should not have overflowed on the first write
+        store.metric.colUpdateTimeDeltaHistogram.cf.getSnapshot().get999thPercentile();
+
+        m = new Mutation("Keyspace1", key);
+        // smallest time delta that would overflow the histogram if unfiltered
+        m.add("Standard2", cellname("0"), ByteBufferUtil.bytes("1"), 18165375903307L);
+        m.apply();
+
+        // CASSANDRA-11117 - update with large timestamp delta should not overflow the histogram
+        store.metric.colUpdateTimeDeltaHistogram.cf.getSnapshot().get999thPercentile();
+    }
 }
