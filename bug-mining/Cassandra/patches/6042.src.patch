diff --git a/test/distributed/org/apache/cassandra/distributed/upgrade/BatchUpgradeTest.java b/test/distributed/org/apache/cassandra/distributed/upgrade/BatchUpgradeTest.java
index fb442331bf..3eb72f3add 100644
--- a/test/distributed/org/apache/cassandra/distributed/upgrade/BatchUpgradeTest.java
+++ b/test/distributed/org/apache/cassandra/distributed/upgrade/BatchUpgradeTest.java
@@ -33,7 +33,7 @@ public class BatchUpgradeTest extends UpgradeTestBase
         .nodes(2)
 
         .nodesToUpgrade(2)
-        .upgradesFrom(v40).setup((cluster) -> {
+        .upgradesToCurrentFrom(v40).setup((cluster) -> {
             cluster.schemaChange("CREATE TABLE "+KEYSPACE+".users (" +
                                  "userid uuid PRIMARY KEY," +
                                  "firstname ascii," +
diff --git a/test/distributed/org/apache/cassandra/distributed/upgrade/CompactStorageColumnDeleteTest.java b/test/distributed/org/apache/cassandra/distributed/upgrade/CompactStorageColumnDeleteTest.java
index 720a1b5db0..920c8508a9 100644
--- a/test/distributed/org/apache/cassandra/distributed/upgrade/CompactStorageColumnDeleteTest.java
+++ b/test/distributed/org/apache/cassandra/distributed/upgrade/CompactStorageColumnDeleteTest.java
@@ -33,7 +33,7 @@ public class CompactStorageColumnDeleteTest extends UpgradeTestBase
         new TestCase()
         .nodes(2)
         .nodesToUpgrade(2)
-        .upgradesFrom(v30)
+        .upgradesToCurrentFrom(v30)
         .setup((cluster) -> {
             cluster.schemaChange("CREATE TABLE " + KEYSPACE + ".tbl (pk int, ck int, v int, PRIMARY KEY (pk, ck)) WITH COMPACT STORAGE");
         })
diff --git a/test/distributed/org/apache/cassandra/distributed/upgrade/CompactStorageHiddenColumnTest.java b/test/distributed/org/apache/cassandra/distributed/upgrade/CompactStorageHiddenColumnTest.java
index 4e5236c4a8..178d32800b 100644
--- a/test/distributed/org/apache/cassandra/distributed/upgrade/CompactStorageHiddenColumnTest.java
+++ b/test/distributed/org/apache/cassandra/distributed/upgrade/CompactStorageHiddenColumnTest.java
@@ -33,7 +33,7 @@ public class CompactStorageHiddenColumnTest extends UpgradeTestBase
         new TestCase()
         .nodes(2)
         .nodesToUpgrade(2)
-        .upgradesFrom(v30)
+        .upgradesToCurrentFrom(v30)
         .setup((cluster) -> {
             cluster.schemaChange("CREATE TABLE " + KEYSPACE + ".tbl (pk int, ck int, PRIMARY KEY (pk, ck)) WITH COMPACT STORAGE");
         })
diff --git a/test/distributed/org/apache/cassandra/distributed/upgrade/CompactStorageImplicitNullInClusteringTest.java b/test/distributed/org/apache/cassandra/distributed/upgrade/CompactStorageImplicitNullInClusteringTest.java
index 9d4824ae5b..b59fda3151 100644
--- a/test/distributed/org/apache/cassandra/distributed/upgrade/CompactStorageImplicitNullInClusteringTest.java
+++ b/test/distributed/org/apache/cassandra/distributed/upgrade/CompactStorageImplicitNullInClusteringTest.java
@@ -33,7 +33,7 @@ public class CompactStorageImplicitNullInClusteringTest extends UpgradeTestBase
         new TestCase()
         .nodes(2)
         .nodesToUpgrade(2)
-        .upgradesFrom(v30)
+        .upgradesToCurrentFrom(v30)
         .setup((cluster) -> {
             cluster.schemaChange("CREATE TABLE " + KEYSPACE + ".tbl (pk int, ck1 int, ck2 int, v int, PRIMARY KEY (pk, ck1, ck2)) WITH COMPACT STORAGE");
         })
diff --git a/test/distributed/org/apache/cassandra/distributed/upgrade/CompactStoragePagingTest.java b/test/distributed/org/apache/cassandra/distributed/upgrade/CompactStoragePagingTest.java
index 307d6dd7fe..62d6ea04e5 100644
--- a/test/distributed/org/apache/cassandra/distributed/upgrade/CompactStoragePagingTest.java
+++ b/test/distributed/org/apache/cassandra/distributed/upgrade/CompactStoragePagingTest.java
@@ -33,7 +33,7 @@ public class CompactStoragePagingTest extends UpgradeTestBase
         new TestCase()
         .nodes(2)
         .nodesToUpgrade(2)
-        .upgradesFrom(v30)
+        .upgradesToCurrentFrom(v30)
         .setup((cluster) -> {
             cluster.schemaChange("CREATE TABLE " + KEYSPACE + ".tbl (pk int, ck int, v int, PRIMARY KEY (pk, ck)) WITH COMPACT STORAGE");
             for (int i = 1; i < 10; i++)
diff --git a/test/distributed/org/apache/cassandra/distributed/upgrade/DropCompactStorageNullClusteringValuesTest.java b/test/distributed/org/apache/cassandra/distributed/upgrade/DropCompactStorageNullClusteringValuesTest.java
index 1657765b06..2e5578d2c2 100644
--- a/test/distributed/org/apache/cassandra/distributed/upgrade/DropCompactStorageNullClusteringValuesTest.java
+++ b/test/distributed/org/apache/cassandra/distributed/upgrade/DropCompactStorageNullClusteringValuesTest.java
@@ -33,7 +33,7 @@ public class DropCompactStorageNullClusteringValuesTest extends UpgradeTestBase
     public void testNullClusteringValues() throws Throwable
     {
         new TestCase().nodes(1)
-                      .upgradesFrom(v30)
+                      .upgradesToCurrentFrom(v30)
                       .withConfig(config -> config.with(GOSSIP, NETWORK, NATIVE_PROTOCOL).set("enable_drop_compact_storage", true))
                       .setup(cluster -> {
                           String create = "CREATE TABLE %s.%s(k int, c1 int, c2 int, v int, PRIMARY KEY (k, c1, c2)) " +
diff --git a/test/distributed/org/apache/cassandra/distributed/upgrade/DropCompactStorageTest.java b/test/distributed/org/apache/cassandra/distributed/upgrade/DropCompactStorageTest.java
index c645085bd0..9846264e56 100644
--- a/test/distributed/org/apache/cassandra/distributed/upgrade/DropCompactStorageTest.java
+++ b/test/distributed/org/apache/cassandra/distributed/upgrade/DropCompactStorageTest.java
@@ -35,7 +35,7 @@ public class DropCompactStorageTest extends UpgradeTestBase
         new TestCase()
         .nodes(2)
         .nodesToUpgrade(1, 2)
-        .upgradesFrom(v30)
+        .upgradesToCurrentFrom(v30)
         .withConfig(config -> config.with(GOSSIP, NETWORK).set("enable_drop_compact_storage", true))
         .setup((cluster) -> {
             cluster.schemaChange("CREATE TABLE " + KEYSPACE + ".tbl (pk int, ck int, PRIMARY KEY (pk, ck)) WITH COMPACT STORAGE");
diff --git a/test/distributed/org/apache/cassandra/distributed/upgrade/GroupByTest.java b/test/distributed/org/apache/cassandra/distributed/upgrade/GroupByTest.java
index 634c886f13..b2971cd15f 100644
--- a/test/distributed/org/apache/cassandra/distributed/upgrade/GroupByTest.java
+++ b/test/distributed/org/apache/cassandra/distributed/upgrade/GroupByTest.java
@@ -21,7 +21,6 @@ package org.apache.cassandra.distributed.upgrade;
 import org.junit.Test;
 
 import org.apache.cassandra.distributed.api.ConsistencyLevel;
-import org.apache.cassandra.distributed.shared.Versions;
 
 import static org.apache.cassandra.distributed.api.Feature.GOSSIP;
 import static org.apache.cassandra.distributed.api.Feature.NETWORK;
@@ -36,7 +35,7 @@ public class GroupByTest extends UpgradeTestBase
         // CASSANDRA-16582: group-by across mixed version cluster would fail with ArrayIndexOutOfBoundException
         new UpgradeTestBase.TestCase()
         .nodes(2)
-        .upgradesFrom(v3X)
+        .upgradesToCurrentFrom(v3X)
         .nodesToUpgrade(1)
         .withConfig(config -> config.with(GOSSIP, NETWORK))
         .setup(cluster -> {
diff --git a/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeAvailabilityTestBase.java b/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeAvailabilityTestBase.java
index c1ae153525..3c15032e19 100644
--- a/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeAvailabilityTestBase.java
+++ b/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeAvailabilityTestBase.java
@@ -22,14 +22,16 @@ import java.util.Arrays;
 import java.util.List;
 import java.util.UUID;
 
-import com.vdurmont.semver4j.Semver;
+import org.junit.Test;
 
+import com.vdurmont.semver4j.Semver;
 import org.apache.cassandra.distributed.api.ConsistencyLevel;
 import org.apache.cassandra.distributed.api.ICoordinator;
 import org.apache.cassandra.exceptions.ReadTimeoutException;
 import org.apache.cassandra.exceptions.WriteTimeoutException;
 import org.apache.cassandra.net.Verb;
 
+import static java.lang.String.format;
 import static java.util.concurrent.TimeUnit.SECONDS;
 import static org.apache.cassandra.distributed.api.ConsistencyLevel.ALL;
 import static org.apache.cassandra.distributed.api.ConsistencyLevel.ONE;
@@ -39,10 +41,9 @@ import static org.apache.cassandra.distributed.shared.AssertUtils.row;
 import static org.apache.cassandra.net.Verb.READ_REQ;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
-import static java.lang.String.format;
 
 
-public class MixedModeAvailabilityTestBase extends UpgradeTestBase
+public abstract class MixedModeAvailabilityTestBase extends UpgradeTestBase
 {
     private static final int NUM_NODES = 3;
     private static final int COORDINATOR = 1;
@@ -50,29 +51,40 @@ public class MixedModeAvailabilityTestBase extends UpgradeTestBase
                                                               new Tester(QUORUM, QUORUM),
                                                               new Tester(ALL, ONE));
 
+    private final Semver initial;
+
+    protected MixedModeAvailabilityTestBase(Semver initial)
+    {
+        this.initial = initial;
+    }
 
-    protected static void testAvailability(Semver initial) throws Throwable
+    @Test
+    public void testAvailabilityCoordinatorNotUpgraded() throws Throwable
     {
-        testAvailability(initial, UpgradeTestBase.CURRENT);
+        testAvailability(false, initial);
     }
 
-    protected static void testAvailability(Semver initial, Semver upgrade) throws Throwable
+    @Test
+    public void testAvailabilityCoordinatorUpgraded() throws Throwable
     {
-        testAvailability(true, initial, upgrade);
-        testAvailability(false, initial, upgrade);
+        testAvailability(true, initial);
     }
 
     private static void testAvailability(boolean upgradedCoordinator,
-                                         Semver initial,
-                                         Semver upgrade) throws Throwable
+                                         Semver initial) throws Throwable
     {
         new TestCase()
         .nodes(NUM_NODES)
         .nodesToUpgrade(upgradedCoordinator ? 1 : 2)
-        .upgrades(initial, upgrade)
+        .upgradesToCurrentFrom(initial)
         .withConfig(config -> config.set("read_request_timeout_in_ms", SECONDS.toMillis(2))
                                     .set("write_request_timeout_in_ms", SECONDS.toMillis(2)))
-        .setup(c -> c.schemaChange(withKeyspace("CREATE TABLE %s.t (k uuid, c int, v int, PRIMARY KEY (k, c))")))
+        // use retry of 10ms so that each check is consistent
+        // At the start of the world cfs.sampleLatencyNanos == 0, which means speculation acts as if ALWAYS is done,
+        // but after the first refresh this gets set high enough that we don't trigger speculation for the rest of the test!
+        // To be consistent set retry to 10ms so cfs.sampleLatencyNanos stays consistent for the duration of the test.
+        .setup(c -> c.schemaChange(withKeyspace("CREATE TABLE %s.t (k uuid, c int, v int, PRIMARY KEY (k, c)) WITH speculative_retry = '10ms'")))
+        .runBeforeClusterUpgrade(cluster -> cluster.filters().reset())
         .runAfterNodeUpgrade((cluster, n) -> {
 
             // using 0 to 2 down nodes...
diff --git a/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeAvailabilityV30Test.java b/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeAvailabilityV30Test.java
index 984df3ba9f..d656958fcd 100644
--- a/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeAvailabilityV30Test.java
+++ b/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeAvailabilityV30Test.java
@@ -18,18 +18,13 @@
 
 package org.apache.cassandra.distributed.upgrade;
 
-import org.junit.Test;
-
-import org.apache.cassandra.distributed.shared.Versions;
-
 /**
  * {@link MixedModeAvailabilityTestBase} for upgrades from v30.
  */
 public class MixedModeAvailabilityV30Test extends MixedModeAvailabilityTestBase
 {
-    @Test
-    public void testAvailability() throws Throwable
+    public MixedModeAvailabilityV30Test()
     {
-        testAvailability(v30);
+        super(v30);
     }
 }
diff --git a/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeAvailabilityV3XTest.java b/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeAvailabilityV3XTest.java
index 70230f5f0a..16d17655c3 100644
--- a/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeAvailabilityV3XTest.java
+++ b/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeAvailabilityV3XTest.java
@@ -18,18 +18,13 @@
 
 package org.apache.cassandra.distributed.upgrade;
 
-import org.junit.Test;
-
-import org.apache.cassandra.distributed.shared.Versions;
-
 /**
  * {@link MixedModeAvailabilityTestBase} for upgrades from v3X.
  */
 public class MixedModeAvailabilityV3XTest extends MixedModeAvailabilityTestBase
 {
-    @Test
-    public void testAvailability() throws Throwable
+    public MixedModeAvailabilityV3XTest()
     {
-        testAvailability(v3X);
+        super(v3X);
     }
 }
diff --git a/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeConsistencyTestBase.java b/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeConsistencyTestBase.java
index f98fc8a71b..519625e761 100644
--- a/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeConsistencyTestBase.java
+++ b/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeConsistencyTestBase.java
@@ -41,11 +41,6 @@ import static org.apache.cassandra.distributed.shared.AssertUtils.row;
 public class MixedModeConsistencyTestBase extends UpgradeTestBase
 {
     protected static void testConsistency(Semver initial) throws Throwable
-    {
-        testConsistency(initial, UpgradeTestBase.CURRENT);
-    }
-
-    protected static void testConsistency(Semver initial, Semver upgrade) throws Throwable
     {
         List<Tester> testers = new ArrayList<>();
         testers.addAll(Tester.create(1, ALL));
@@ -55,7 +50,7 @@ public class MixedModeConsistencyTestBase extends UpgradeTestBase
         new TestCase()
         .nodes(3)
         .nodesToUpgrade(1)
-        .upgrades(initial, upgrade)
+        .upgradesToCurrentFrom(initial)
         .withConfig(config -> config.set("read_request_timeout_in_ms", SECONDS.toMillis(30))
                                     .set("write_request_timeout_in_ms", SECONDS.toMillis(30)))
         .setup(cluster -> {
diff --git a/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeFrom3ReplicationTest.java b/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeFrom3ReplicationTest.java
index a38e25d4b5..69d3dbec71 100644
--- a/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeFrom3ReplicationTest.java
+++ b/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeFrom3ReplicationTest.java
@@ -18,21 +18,65 @@
 
 package org.apache.cassandra.distributed.upgrade;
 
+import java.util.ArrayList;
+import java.util.List;
+
 import org.junit.Test;
 
-import org.apache.cassandra.distributed.shared.Versions;
+import org.apache.cassandra.distributed.api.ConsistencyLevel;
 
-public class MixedModeFrom3ReplicationTest extends MixedModeReplicationTestBase
-{
-    @Test
-    public void testSimpleStrategy30to3X() throws Throwable
-    {
-        testSimpleStrategy(v30, v3X);
-    }
+import static org.apache.cassandra.distributed.shared.AssertUtils.assertRows;
+import static org.apache.cassandra.distributed.shared.AssertUtils.row;
 
+public class MixedModeFrom3ReplicationTest extends UpgradeTestBase
+{
     @Test
     public void testSimpleStrategy() throws Throwable
     {
-        testSimpleStrategy(v30);
+        String insert = "INSERT INTO test_simple.names (key, name) VALUES (?, ?)";
+        String select = "SELECT * FROM test_simple.names WHERE key = ?";
+
+        new TestCase()
+        .nodes(3)
+        .nodesToUpgrade(1, 2)
+        .upgradesToCurrentFrom(v30)
+        .setup(cluster -> {
+            cluster.schemaChange("CREATE KEYSPACE test_simple WITH replication = {'class': 'SimpleStrategy', 'replication_factor': 2};");
+            cluster.schemaChange("CREATE TABLE test_simple.names (key int PRIMARY KEY, name text)");
+        })
+        .runAfterNodeUpgrade((cluster, upgraded) -> {
+            List<Long> initialTokens = new ArrayList<>(cluster.size() + 1);
+            initialTokens.add(null); // The first valid token is at 1 to avoid offset math below.
+
+            for (int i = 1; i <= cluster.size(); i++)
+                initialTokens.add(Long.valueOf(cluster.get(i).config().get("initial_token").toString()));
+
+            List<Long> validTokens = initialTokens.subList(1, cluster.size() + 1);
+
+            // Exercise all the coordinators...
+            for (int i = 1; i <= cluster.size(); i++)
+            {
+                // ...and sample enough keys that we cover the ring.
+                for (int j = 0; j < 10; j++)
+                {
+                    int key = j + (i * 10);
+                    Object[] row = row(key, "Nero");
+                    Long token = tokenFrom(key);
+
+                    cluster.coordinator(i).execute(insert, ConsistencyLevel.ALL, row);
+
+                    int node = primaryReplica(validTokens, token);
+                    assertRows(cluster.get(node).executeInternal(select, key), row);
+
+                    node = nextNode(node, cluster.size());
+                    assertRows(cluster.get(node).executeInternal(select, key), row);
+
+                    // At RF=2, this node should not have received the write.
+                    node = nextNode(node, cluster.size());
+                    assertRows(cluster.get(node).executeInternal(select, key));
+                }
+            }
+        })
+        .run();
     }
 }
diff --git a/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeGossipTest.java b/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeGossipTest.java
index 35c4fb3815..e1a96ac88c 100644
--- a/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeGossipTest.java
+++ b/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeGossipTest.java
@@ -33,7 +33,6 @@ import org.junit.Test;
 import org.apache.cassandra.distributed.UpgradeableCluster;
 import org.apache.cassandra.distributed.api.Feature;
 import org.apache.cassandra.distributed.api.IMessageFilters;
-import org.apache.cassandra.distributed.shared.Versions;
 import org.apache.cassandra.net.Verb;
 import org.assertj.core.api.Assertions;
 
@@ -51,8 +50,8 @@ public class MixedModeGossipTest extends UpgradeTestBase
         .nodes(3)
         .nodesToUpgradeOrdered(1, 2, 3)
         // all upgrades from v30 up, excluding v30->v3X and from v40
-        .singleUpgrade(v30)
-        .singleUpgrade(v3X)
+        .singleUpgradeToCurrentFrom(v30)
+        .singleUpgradeToCurrentFrom(v3X)
         .setup(c -> {})
         .runAfterNodeUpgrade((cluster, node) -> {
             if (node == 1) {
@@ -87,8 +86,8 @@ public class MixedModeGossipTest extends UpgradeTestBase
         .nodes(3)
         .nodesToUpgradeOrdered(1, 2, 3)
         // all upgrades from v30 up, excluding v30->v3X and from v40
-        .singleUpgrade(v30)
-        .singleUpgrade(v3X)
+        .singleUpgradeToCurrentFrom(v30)
+        .singleUpgradeToCurrentFrom(v3X)
         .setup(cluster -> {
             // node2 and node3 gossiper cannot talk with each other
             cluster.filters().verbs(Verb.GOSSIP_DIGEST_SYN.id).from(2).to(3).drop();
diff --git a/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeMessageForwardTest.java b/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeMessageForwardTest.java
index 935cc8e0b6..c2c4b88ba0 100644
--- a/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeMessageForwardTest.java
+++ b/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeMessageForwardTest.java
@@ -82,7 +82,7 @@ public class MixedModeMessageForwardTest extends UpgradeTestBase
         .withConfig(c -> c.with(Feature.GOSSIP, Feature.NETWORK).set("request_timeout_in_ms", 30000))
         .withBuilder(b -> b.withRacks(numDCs, 1, nodesPerDc))
         .nodes(numDCs * nodesPerDc)
-        .singleUpgrade(v30)
+        .singleUpgradeToCurrentFrom(v30)
         .setup(cluster -> {
             cluster.schemaChange("ALTER KEYSPACE " + KEYSPACE +
                 " WITH replication = {'class': 'NetworkTopologyStrategy', " + ntsArgs + " };");
diff --git a/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeReadRepairDeleteTest.java b/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeReadRepairDeleteTest.java
index 01955c5672..e60377853c 100644
--- a/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeReadRepairDeleteTest.java
+++ b/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeReadRepairDeleteTest.java
@@ -46,7 +46,8 @@ public class MixedModeReadRepairDeleteTest extends UpgradeTestBase
         allUpgrades(2, 1)
         .setup(cluster -> {
             cluster.schemaChange(withKeyspace("CREATE TABLE %s.t (k int, c int, v int, s int static, PRIMARY KEY (k, c))"));
-
+        })
+        .runBeforeClusterUpgrade(cluster -> {
             // insert the rows in all the nodes
             String insert = withKeyspace("INSERT INTO %s.t (k, c, v, s) VALUES (?, ?, ?, ?)");
             cluster.coordinator(1).execute(insert, ConsistencyLevel.ALL, row1);
@@ -85,7 +86,8 @@ public class MixedModeReadRepairDeleteTest extends UpgradeTestBase
         allUpgrades(2, 1)
         .setup(cluster -> {
             cluster.schemaChange(withKeyspace("CREATE TABLE %s.t (k int, c int, v int, s int static, PRIMARY KEY (k, c))"));
-
+        })
+        .runBeforeClusterUpgrade(cluster -> {
             // insert half partition in each node
             String insert = withKeyspace("INSERT INTO %s.t (k, c, v, s) VALUES (?, ?, ?, ?)");
             cluster.coordinator(1).execute(insert, ConsistencyLevel.ALL, partition1[0]);
diff --git a/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeReadRepairWriteTest.java b/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeReadRepairWriteTest.java
index fcb04824c2..4966e5c1a4 100644
--- a/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeReadRepairWriteTest.java
+++ b/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeReadRepairWriteTest.java
@@ -45,6 +45,7 @@ public class MixedModeReadRepairWriteTest extends UpgradeTestBase
 
         allUpgrades(2, 1)
         .setup(c -> c.schemaChange(withKeyspace("CREATE TABLE %s.t (k int, c int, v int, PRIMARY KEY (k, c))")))
+        .runBeforeClusterUpgrade(cluster -> cluster.coordinator(1).execute(withKeyspace("TRUNCATE %s.t"), ConsistencyLevel.ALL))
         .runAfterClusterUpgrade(cluster -> {
 
             // insert rows internally in each node
@@ -77,7 +78,8 @@ public class MixedModeReadRepairWriteTest extends UpgradeTestBase
         allUpgrades(2, 1)
         .setup(cluster -> {
             cluster.schemaChange(withKeyspace("CREATE TABLE %s.t (k int, c int, v int, PRIMARY KEY (k, c))"));
-
+        })
+        .runBeforeClusterUpgrade(cluster -> {
             // insert the initial version of the rows in all the nodes
             String insert = withKeyspace("INSERT INTO %s.t (k, c, v) VALUES (?, ?, ?)");
             cluster.coordinator(1).execute(insert, ConsistencyLevel.ALL, row1);
diff --git a/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeReadTest.java b/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeReadTest.java
index b11678dc55..a039678293 100644
--- a/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeReadTest.java
+++ b/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeReadTest.java
@@ -22,7 +22,6 @@ import org.junit.Test;
 
 import org.apache.cassandra.distributed.api.Feature;
 import org.apache.cassandra.distributed.api.IInvokableInstance;
-import org.apache.cassandra.distributed.shared.Versions;
 import org.apache.cassandra.gms.Gossiper;
 import org.apache.cassandra.utils.CassandraVersion;
 
@@ -40,8 +39,8 @@ public class MixedModeReadTest extends UpgradeTestBase
         .nodes(2)
         .nodesToUpgrade(1)
         // all upgrades from v30 up, excluding v30->v3X and from v40
-        .singleUpgrade(v30)
-        .singleUpgrade(v3X)
+        .singleUpgradeToCurrentFrom(v30)
+        .singleUpgradeToCurrentFrom(v3X)
         .setup(cluster -> {
             cluster.schemaChange(CREATE_TABLE);
             insertData(cluster.coordinator(1));
diff --git a/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeRepairTest.java b/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeRepairTest.java
index 813d9f20b5..6606bcde7e 100644
--- a/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeRepairTest.java
+++ b/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeRepairTest.java
@@ -54,7 +54,7 @@ public class MixedModeRepairTest extends UpgradeTestBase
         new UpgradeTestBase.TestCase()
         .nodes(2)
         .nodesToUpgrade(UPGRADED_NODE)
-        .singleUpgrade(v3X)
+        .singleUpgradeToCurrentFrom(v3X)
         .withConfig(config -> config.with(NETWORK, GOSSIP))
         .setup(cluster -> {
             cluster.schemaChange(CREATE_TABLE);
diff --git a/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeReplicationTestBase.java b/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeReplicationTestBase.java
deleted file mode 100644
index 3f2da7aab5..0000000000
--- a/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeReplicationTestBase.java
+++ /dev/null
@@ -1,89 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.cassandra.distributed.upgrade;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import com.vdurmont.semver4j.Semver;
-
-import org.apache.cassandra.distributed.api.ConsistencyLevel;
-
-import static org.apache.cassandra.distributed.shared.AssertUtils.assertRows;
-import static org.apache.cassandra.distributed.shared.AssertUtils.row;
-
-/**
- * A base class for testing basic replication on mixed-version clusters.
- */
-public class MixedModeReplicationTestBase extends UpgradeTestBase
-{
-    protected void testSimpleStrategy(Semver from) throws Throwable
-    {
-        testSimpleStrategy(from, UpgradeTestBase.CURRENT);
-    }
-
-    protected void testSimpleStrategy(Semver from, Semver to) throws Throwable
-    {
-        String insert = "INSERT INTO test_simple.names (key, name) VALUES (?, ?)";
-        String select = "SELECT * FROM test_simple.names WHERE key = ?";
-
-        new TestCase()
-        .nodes(3)
-        .nodesToUpgrade(1, 2)
-        .upgrades(from, to)
-        .setup(cluster -> {
-            cluster.schemaChange("CREATE KEYSPACE test_simple WITH replication = {'class': 'SimpleStrategy', 'replication_factor': 2};");
-            cluster.schemaChange("CREATE TABLE test_simple.names (key int PRIMARY KEY, name text)");
-        })
-        .runAfterNodeUpgrade((cluster, upgraded) -> {
-            List<Long> initialTokens = new ArrayList<>(cluster.size() + 1);
-            initialTokens.add(null); // The first valid token is at 1 to avoid offset math below.
-
-            for (int i = 1; i <= cluster.size(); i++)
-                initialTokens.add(Long.valueOf(cluster.get(i).config().get("initial_token").toString()));
-
-            List<Long> validTokens = initialTokens.subList(1, cluster.size() + 1);
-
-            // Exercise all the coordinators...
-            for (int i = 1; i <= cluster.size(); i++)
-            {
-                // ...and sample enough keys that we cover the ring.
-                for (int j = 0; j < 10; j++)
-                {
-                    int key = j + (i * 10);
-                    Object[] row = row(key, "Nero");
-                    Long token = tokenFrom(key);
-
-                    cluster.coordinator(i).execute(insert, ConsistencyLevel.ALL, row);
-
-                    int node = primaryReplica(validTokens, token);
-                    assertRows(cluster.get(node).executeInternal(select, key), row);
-
-                    node = nextNode(node, cluster.size());
-                    assertRows(cluster.get(node).executeInternal(select, key), row);
-
-                    // At RF=2, this node should not have received the write.
-                    node = nextNode(node, cluster.size());
-                    assertRows(cluster.get(node).executeInternal(select, key));
-                }
-            }
-        })
-        .run();
-    }
-}
diff --git a/test/distributed/org/apache/cassandra/distributed/upgrade/Pre40MessageFilterTest.java b/test/distributed/org/apache/cassandra/distributed/upgrade/Pre40MessageFilterTest.java
index 4cca7b9aba..59e624ddb3 100644
--- a/test/distributed/org/apache/cassandra/distributed/upgrade/Pre40MessageFilterTest.java
+++ b/test/distributed/org/apache/cassandra/distributed/upgrade/Pre40MessageFilterTest.java
@@ -35,8 +35,8 @@ public class Pre40MessageFilterTest extends UpgradeTestBase
         .withConfig(configConsumer)
         .nodesToUpgrade(1)
         // all upgrades from v30 up, excluding v30->v3X
-        .singleUpgrade(v30)
-        .upgradesFrom(v3X)
+        .singleUpgradeToCurrentFrom(v30)
+        .upgradesToCurrentFrom(v3X)
         .setup((cluster) -> {
             cluster.filters().outbound().allVerbs().messagesMatching((f,t,m) -> false).drop();
             cluster.schemaChange("CREATE TABLE " + KEYSPACE + ".tbl (pk int, ck int, v int, PRIMARY KEY (pk, ck))");
diff --git a/test/distributed/org/apache/cassandra/distributed/upgrade/UpgradeTest.java b/test/distributed/org/apache/cassandra/distributed/upgrade/UpgradeTest.java
index 691d8af94f..55e1f1ea94 100644
--- a/test/distributed/org/apache/cassandra/distributed/upgrade/UpgradeTest.java
+++ b/test/distributed/org/apache/cassandra/distributed/upgrade/UpgradeTest.java
@@ -22,7 +22,7 @@ import org.junit.Test;
 
 import org.apache.cassandra.distributed.api.ConsistencyLevel;
 import org.apache.cassandra.distributed.api.Feature;
-import org.apache.cassandra.distributed.shared.Versions;
+
 import static org.apache.cassandra.distributed.shared.AssertUtils.*;
 
 public class UpgradeTest extends UpgradeTestBase
@@ -34,7 +34,7 @@ public class UpgradeTest extends UpgradeTestBase
         .nodes(2)
         .nodesToUpgrade(1)
         .withConfig((cfg) -> cfg.with(Feature.NETWORK, Feature.GOSSIP))
-        .upgradesFrom(v3X)
+        .upgradesToCurrentFrom(v3X)
         .setup((cluster) -> {
             cluster.schemaChange("CREATE TABLE " + KEYSPACE + ".tbl (pk int, ck int, v int, PRIMARY KEY (pk, ck))");
             cluster.coordinator(1).execute("INSERT INTO " + KEYSPACE + ".tbl (pk, ck, v) VALUES (1, 1, 1)", ConsistencyLevel.ALL);
diff --git a/test/distributed/org/apache/cassandra/distributed/upgrade/UpgradeTestBase.java b/test/distributed/org/apache/cassandra/distributed/upgrade/UpgradeTestBase.java
index e530dbdc45..e41444fe52 100644
--- a/test/distributed/org/apache/cassandra/distributed/upgrade/UpgradeTestBase.java
+++ b/test/distributed/org/apache/cassandra/distributed/upgrade/UpgradeTestBase.java
@@ -19,17 +19,22 @@
 package org.apache.cassandra.distributed.upgrade;
 
 import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
 import java.util.HashSet;
 import java.util.LinkedHashSet;
 import java.util.List;
+import java.util.NavigableSet;
+import java.util.Objects;
 import java.util.Set;
 import java.util.function.Consumer;
+import java.util.stream.Collectors;
 
-import com.google.common.collect.ImmutableList;
 import com.vdurmont.semver4j.Semver;
 import com.vdurmont.semver4j.Semver.SemverType;
 
 import org.junit.After;
+import org.junit.Assume;
 import org.junit.BeforeClass;
 
 import org.slf4j.Logger;
@@ -44,10 +49,11 @@ import org.apache.cassandra.distributed.shared.DistributedTestBase;
 import org.apache.cassandra.distributed.shared.ThrowingRunnable;
 import org.apache.cassandra.distributed.shared.Versions;
 import org.apache.cassandra.utils.ByteBufferUtil;
-import org.apache.cassandra.utils.Pair;
+import org.apache.cassandra.utils.SimpleGraph;
 
 import static org.apache.cassandra.distributed.shared.Versions.Version;
 import static org.apache.cassandra.distributed.shared.Versions.find;
+import static org.apache.cassandra.utils.SimpleGraph.sortedVertices;
 
 public class UpgradeTestBase extends DistributedTestBase
 {
@@ -56,8 +62,7 @@ public class UpgradeTestBase extends DistributedTestBase
     @After
     public void afterEach()
     {
-        System.runFinalization();
-        System.gc();
+        triggerGC();
     }
 
     @BeforeClass
@@ -88,30 +93,58 @@ public class UpgradeTestBase extends DistributedTestBase
     public static final Semver v41 = new Semver("4.1-alpha1", SemverType.LOOSE);
     public static final Semver v42 = new Semver("4.2-alpha1", SemverType.LOOSE);
 
-    protected static final List<Pair<Semver,Semver>> SUPPORTED_UPGRADE_PATHS = ImmutableList.of(
-        Pair.create(v30, v3X),
-        Pair.create(v30, v40),
-        Pair.create(v30, v41),
-        Pair.create(v30, v42),
-        Pair.create(v3X, v40),
-        Pair.create(v3X, v41),
-        Pair.create(v3X, v42),
-        Pair.create(v40, v41),
-        Pair.create(v40, v42),
-        Pair.create(v41, v42));
+    protected static final SimpleGraph<Semver> SUPPORTED_UPGRADE_PATHS = new SimpleGraph.Builder<Semver>()
+                                                                         .addEdge(v30, v3X)
+                                                                         .addEdge(v30, v40)
+                                                                         .addEdge(v30, v41)
+                                                                         .addEdge(v30, v42)
+                                                                         .addEdge(v3X, v40)
+                                                                         .addEdge(v3X, v41)
+                                                                         .addEdge(v3X, v42)
+                                                                         .addEdge(v40, v41)
+                                                                         .addEdge(v40, v42)
+                                                                         .addEdge(v41, v42)
+                                                                         .build();
 
     // the last is always the current
-    public static final Semver CURRENT = SUPPORTED_UPGRADE_PATHS.get(SUPPORTED_UPGRADE_PATHS.size() - 1).right;
+    public static final Semver CURRENT = SimpleGraph.max(SUPPORTED_UPGRADE_PATHS);
+    public static final Semver OLDEST = SimpleGraph.min(SUPPORTED_UPGRADE_PATHS);
 
     public static class TestVersions
     {
         final Version initial;
-        final Version upgrade;
+        final List<Version> upgrade;
+        final List<Semver> upgradeVersions;
 
-        public TestVersions(Version initial, Version upgrade)
+        public TestVersions(Version initial, List<Version> upgrade)
         {
             this.initial = initial;
             this.upgrade = upgrade;
+            this.upgradeVersions = upgrade.stream().map(v -> v.version).collect(Collectors.toList());
+        }
+
+        @Override
+        public boolean equals(Object o)
+        {
+            if (this == o) return true;
+            if (o == null || getClass() != o.getClass()) return false;
+            TestVersions that = (TestVersions) o;
+            return Objects.equals(initial.version, that.initial.version) && Objects.equals(upgradeVersions, that.upgradeVersions);
+        }
+
+        @Override
+        public int hashCode()
+        {
+            return Objects.hash(initial.version, upgradeVersions);
+        }
+
+        @Override
+        public String toString()
+        {
+            StringBuilder sb = new StringBuilder();
+            sb.append(initial.version).append(" -> ");
+            sb.append(upgradeVersions);
+            return sb.toString();
         }
     }
 
@@ -123,6 +156,7 @@ public class UpgradeTestBase extends DistributedTestBase
         private RunOnCluster setup;
         private RunOnClusterAndNode runBeforeNodeRestart;
         private RunOnClusterAndNode runAfterNodeUpgrade;
+        private RunOnCluster runBeforeClusterUpgrade;
         private RunOnCluster runAfterClusterUpgrade;
         private final Set<Integer> nodesToUpgrade = new LinkedHashSet<>();
         private Consumer<IInstanceConfig> configConsumer;
@@ -145,28 +179,77 @@ public class UpgradeTestBase extends DistributedTestBase
         }
 
         /** performs all supported upgrade paths that exist in between from and CURRENT (inclusive) **/
-        public TestCase upgradesFrom(Semver from)
+        public TestCase upgradesToCurrentFrom(Semver from)
+        {
+            return upgradesTo(from, CURRENT);
+        }
+
+        /**
+         * performs all supported upgrade paths to the "to" target; example
+         * {@code upgradesTo(3.0, 4.0); // produces: 3.0 -> 4.0, 3.11 -> 4.0}
+         */
+        public TestCase upgradesTo(Semver from, Semver to)
+        {
+            List<TestVersions> upgrade = new ArrayList<>();
+            NavigableSet<Semver> vertices = sortedVertices(SUPPORTED_UPGRADE_PATHS);
+            for (Semver start : vertices.subSet(from, true, to, false))
+            {
+                // only include pairs that are allowed
+                if (SUPPORTED_UPGRADE_PATHS.hasEdge(start, to))
+                    upgrade.add(new TestVersions(versions.getLatest(start), Collections.singletonList(versions.getLatest(to))));
+            }
+            logger.info("Adding upgrades of\n{}", upgrade.stream().map(TestVersions::toString).collect(Collectors.joining("\n")));
+            this.upgrade.addAll(upgrade);
+            return this;
+        }
+
+        /**
+         * performs all supported upgrade paths from the "from" target; example
+         * {@code upgradesFrom(4.0, 4.2); // produces: 4.0 -> 4.1, 4.0 -> 4.2}
+         */
+        public TestCase upgradesFrom(Semver from, Semver to)
         {
-            return upgrades(from, CURRENT);
+            List<TestVersions> upgrade = new ArrayList<>();
+            NavigableSet<Semver> vertices = sortedVertices(SUPPORTED_UPGRADE_PATHS);
+            for (Semver end : vertices.subSet(from, false, to, true))
+            {
+                // only include pairs that are allowed
+                if (SUPPORTED_UPGRADE_PATHS.hasEdge(from, end))
+                    upgrade.add(new TestVersions(versions.getLatest(from), Collections.singletonList(versions.getLatest(end))));
+            }
+            logger.info("Adding upgrades of\n{}", upgrade.stream().map(TestVersions::toString).collect(Collectors.joining("\n")));
+            this.upgrade.addAll(upgrade);
+            return this;
         }
 
-        /** performs all supported upgrade paths that exist in between from and to (inclusive) **/
+        /**
+         * performs all supported upgrade paths that exist in between from and to that include the current version.
+         * This call is equivilent to calling {@code upgradesTo(from, CURRENT).upgradesFrom(CURRENT, to)}.
+         **/
         public TestCase upgrades(Semver from, Semver to)
         {
-            SUPPORTED_UPGRADE_PATHS.stream()
-                .filter(upgradePath -> (upgradePath.left.compareTo(from) >= 0 && upgradePath.right.compareTo(to) <= 0))
-                .forEachOrdered(upgradePath ->
-                {
-                    this.upgrade.add(
-                            new TestVersions(versions.getLatest(upgradePath.left), versions.getLatest(upgradePath.right)));
-                });
+            Assume.assumeTrue("Unable to do upgrades(" + from + ", " + to + "); does not contain CURRENT=" + CURRENT, contains(from, to, CURRENT));
+            if (from.compareTo(CURRENT) < 0)
+                upgradesTo(from, CURRENT);
+            if (CURRENT.compareTo(to) < 0)
+                upgradesFrom(CURRENT, to);
             return this;
         }
 
+        private static boolean contains(Semver from, Semver to, Semver target)
+        {
+            // target >= from && target <= to
+            return target.compareTo(from) >= 0 && target.compareTo(to) <= 0;
+        }
+
         /** Will test this specific upgrade path **/
-        public TestCase singleUpgrade(Semver from)
+        public TestCase singleUpgradeToCurrentFrom(Semver from)
         {
-            this.upgrade.add(new TestVersions(versions.getLatest(from), versions.getLatest(CURRENT)));
+            if (!SUPPORTED_UPGRADE_PATHS.hasEdge(from, CURRENT))
+                throw new AssertionError("Upgrading from " + from + " to " + CURRENT + " isn't directly supported and must go through other versions first; supported paths: " + SUPPORTED_UPGRADE_PATHS.findPaths(from, CURRENT));
+            TestVersions tests = new TestVersions(this.versions.getLatest(from), Arrays.asList(this.versions.getLatest(CURRENT)));
+            logger.info("Adding upgrade of {}", tests);
+            this.upgrade.add(tests);
             return this;
         }
 
@@ -188,6 +271,12 @@ public class UpgradeTestBase extends DistributedTestBase
             return this;
         }
 
+        public TestCase runBeforeClusterUpgrade(RunOnCluster runBeforeClusterUpgrade)
+        {
+            this.runBeforeClusterUpgrade = runBeforeClusterUpgrade;
+            return this;
+        }
+
         public TestCase runAfterClusterUpgrade(RunOnCluster runAfterClusterUpgrade)
         {
             this.runAfterClusterUpgrade = runAfterClusterUpgrade;
@@ -216,6 +305,8 @@ public class UpgradeTestBase extends DistributedTestBase
                 throw new AssertionError();
             if (runBeforeNodeRestart == null)
                 runBeforeNodeRestart = (c, n) -> {};
+            if (runBeforeClusterUpgrade == null)
+                runBeforeClusterUpgrade = (c) -> {};
             if (runAfterClusterUpgrade == null)
                 runAfterClusterUpgrade = (c) -> {};
             if (runAfterNodeUpgrade == null)
@@ -224,26 +315,44 @@ public class UpgradeTestBase extends DistributedTestBase
                 for (int n = 1; n <= nodeCount; n++)
                     nodesToUpgrade.add(n);
 
+            int offset = 0;
             for (TestVersions upgrade : this.upgrade)
             {
-                logger.info("testing upgrade from {} to {}", upgrade.initial.version, upgrade.upgrade.version);
+                logger.info("testing upgrade from {} to {}", upgrade.initial.version, upgrade.upgradeVersions);
                 try (UpgradeableCluster cluster = init(UpgradeableCluster.create(nodeCount, upgrade.initial, configConsumer, builderConsumer)))
                 {
                     setup.run(cluster);
 
-                    for (int n : nodesToUpgrade)
+                    for (Version nextVersion : upgrade.upgrade)
                     {
-                        cluster.get(n).shutdown().get();
-                        cluster.get(n).setVersion(upgrade.upgrade);
-                        runBeforeNodeRestart.run(cluster, n);
-                        cluster.get(n).startup();
-                        runAfterNodeUpgrade.run(cluster, n);
+                        try
+                        {
+                            runBeforeClusterUpgrade.run(cluster);
+
+                            for (int n : nodesToUpgrade)
+                            {
+                                cluster.get(n).shutdown().get();
+                                triggerGC();
+                                cluster.get(n).setVersion(nextVersion);
+                                runBeforeNodeRestart.run(cluster, n);
+                                cluster.get(n).startup();
+                                runAfterNodeUpgrade.run(cluster, n);
+                            }
+
+                            runAfterClusterUpgrade.run(cluster);
+
+                            cluster.checkAndResetUncaughtExceptions();
+                        }
+                        catch (Throwable t)
+                        {
+                            throw new AssertionError(String.format("Error in test '%s' while upgrading to '%s'; successful upgrades %s", upgrade, nextVersion.version, this.upgrade.stream().limit(offset).collect(Collectors.toList())), t);
+                        }
                     }
-
-                    runAfterClusterUpgrade.run(cluster);
                 }
+                offset++;
             }
         }
+
         public TestCase nodesToUpgrade(int ... nodes)
         {
             Set<Integer> set = new HashSet<>(nodes.length);
@@ -265,10 +374,16 @@ public class UpgradeTestBase extends DistributedTestBase
         }
      }
 
+    private static void triggerGC()
+    {
+        System.runFinalization();
+        System.gc();
+    }
+
     protected TestCase allUpgrades(int nodes, int... toUpgrade)
     {
         return new TestCase().nodes(nodes)
-                             .upgradesFrom(v30)
+                             .upgradesToCurrentFrom(v30)
                              .nodesToUpgrade(toUpgrade);
     }
 
diff --git a/test/unit/org/apache/cassandra/utils/SimpleGraph.java b/test/unit/org/apache/cassandra/utils/SimpleGraph.java
new file mode 100644
index 0000000000..71b1fb2515
--- /dev/null
+++ b/test/unit/org/apache/cassandra/utils/SimpleGraph.java
@@ -0,0 +1,126 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.cassandra.utils;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.NavigableSet;
+import java.util.Set;
+import java.util.TreeSet;
+import java.util.function.Consumer;
+
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Ordering;
+
+/**
+ * A directed graph. Main usage is the {@link #findPaths(Object, Object)} method which is used to find all paths between
+ * 2 vertices.
+ */
+public class SimpleGraph<V>
+{
+    private final ImmutableMap<V, ImmutableSet<V>> edges;
+
+    private SimpleGraph(ImmutableMap<V, ImmutableSet<V>> edges)
+    {
+        if (edges == null || edges.isEmpty())
+            throw new AssertionError("Edges empty");
+        this.edges = edges;
+    }
+
+    public static <T extends Comparable<T>> NavigableSet<T> sortedVertices(SimpleGraph<T> graph)
+    {
+        return new TreeSet<>(graph.vertices());
+    }
+
+    public static <T extends Comparable<T>> T min(SimpleGraph<T> graph)
+    {
+        return Ordering.natural().min(graph.vertices());
+    }
+
+    public static <T extends Comparable<T>> T max(SimpleGraph<T> graph)
+    {
+        return Ordering.natural().max(graph.vertices());
+    }
+
+    public boolean hasEdge(V a, V b)
+    {
+        ImmutableSet<V> matches = edges.get(a);
+        return matches != null && matches.contains(b);
+    }
+
+    public ImmutableSet<V> vertices()
+    {
+        ImmutableSet.Builder<V> b = ImmutableSet.builder();
+        b.addAll(edges.keySet());
+        edges.values().forEach(b::addAll);
+        return b.build();
+    }
+
+    public List<List<V>> findPaths(V from, V to)
+    {
+        List<List<V>> matches = new ArrayList<>();
+        findPaths0(Collections.singletonList(from), from, to, matches::add);
+        return matches;
+    }
+
+    private void findPaths0(List<V> accum, V from, V to, Consumer<List<V>> onMatch)
+    {
+        ImmutableSet<V> check = edges.get(from);
+        if (check == null)
+            return; // no matches
+        for (V next : check)
+        {
+            if (accum.contains(next))
+                return; // ignore walking recursive
+            List<V> nextAccum = new ArrayList<>(accum);
+            nextAccum.add(next);
+            if (next.equals(to))
+            {
+                onMatch.accept(nextAccum);
+            }
+            else
+            {
+                findPaths0(nextAccum, next, to, onMatch);
+            }
+        }
+    }
+
+    public static class Builder<V>
+    {
+        private final Map<V, Set<V>> edges = new HashMap<>();
+
+        public Builder<V> addEdge(V from, V to)
+        {
+            edges.computeIfAbsent(from, ignore -> new HashSet<>()).add(to);
+            return this;
+        }
+
+        public SimpleGraph<V> build()
+        {
+            ImmutableMap.Builder<V, ImmutableSet<V>> builder = ImmutableMap.builder();
+            for (Map.Entry<V, Set<V>> e : edges.entrySet())
+                builder.put(e.getKey(), ImmutableSet.copyOf(e.getValue()));
+            return new SimpleGraph(builder.build());
+        }
+    }
+}
diff --git a/test/unit/org/apache/cassandra/utils/SimpleGraphTest.java b/test/unit/org/apache/cassandra/utils/SimpleGraphTest.java
new file mode 100644
index 0000000000..6adee36889
--- /dev/null
+++ b/test/unit/org/apache/cassandra/utils/SimpleGraphTest.java
@@ -0,0 +1,108 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.cassandra.utils;
+
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.junit.Test;
+
+import org.assertj.core.api.Assertions;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public class SimpleGraphTest
+{
+    @Test
+    public void empty()
+    {
+        Assertions.assertThatThrownBy(() -> new SimpleGraph.Builder<String>().build())
+                  .isInstanceOf(AssertionError.class)
+                  .hasMessage("Edges empty");
+    }
+
+    /**
+     * If vertices have edges that form a circle this should not cause {@link SimpleGraph#findPaths(Object, Object)} to
+     * hang.
+     */
+    @Test
+    public void recursive()
+    {
+        SimpleGraph<String> graph = of("A", "B",
+                                       "B", "C",
+                                       "C", "A");
+        // no paths to identity
+        assertThat(graph.findPaths("A", "A")).isEmpty();
+        assertThat(graph.findPaths("B", "B")).isEmpty();
+        assertThat(graph.findPaths("C", "C")).isEmpty();
+
+        assertThat(graph.findPaths("C", "B")).isEqualTo(Collections.singletonList(Arrays.asList("C", "A", "B")));
+
+        // all options return and don't have duplicate keys
+        for (String i : graph.vertices())
+        {
+            for (String j : graph.vertices())
+            {
+                List<List<String>> paths = graph.findPaths(i, j);
+                for (List<String> path : paths)
+                {
+                    Map<String, Integer> distinct = countDistinct(path);
+                    for (Map.Entry<String, Integer> e : distinct.entrySet())
+                        assertThat(e.getValue()).describedAs("Duplicate vertex %s found; %s", e.getKey(), path).isEqualTo(1);
+                }
+            }
+        }
+    }
+
+    @Test
+    public void simple()
+    {
+        SimpleGraph<String> graph = of("A", "B",
+                                       "B", "C",
+                                       "C", "D");
+
+        assertThat(graph.findPaths("A", "B")).isEqualTo(Collections.singletonList(Arrays.asList("A", "B")));
+        assertThat(graph.findPaths("A", "C")).isEqualTo(Collections.singletonList(Arrays.asList("A", "B", "C")));
+        assertThat(graph.findPaths("B", "D")).isEqualTo(Collections.singletonList(Arrays.asList("B", "C", "D")));
+
+        assertThat(graph.hasEdge("A", "B")).isTrue();
+        assertThat(graph.hasEdge("C", "D")).isTrue();
+        assertThat(graph.hasEdge("B", "A")).isFalse();
+        assertThat(graph.hasEdge("C", "B")).isFalse();
+    }
+
+    private static <T> Map<T, Integer> countDistinct(List<T> list)
+    {
+        Map<T, Integer> map = new HashMap<>();
+        for (T t : list)
+            map.compute(t, (ignore, accum) -> accum == null ? 1 : accum + 1);
+        return map;
+    }
+
+    static <T> SimpleGraph<T> of(T... values)
+    {
+        assert values.length % 2 == 0: "graph requires even number of values, but given " + values.length;
+        SimpleGraph.Builder<T> builder = new SimpleGraph.Builder<>();
+        for (int i = 0; i < values.length; i = i + 2)
+            builder.addEdge(values[i], values[i + 1]);
+        return builder.build();
+    }
+}
\ No newline at end of file
