diff --git a/src/java/org/apache/cassandra/config/CFMetaData.java b/src/java/org/apache/cassandra/config/CFMetaData.java
index ab6026a04b..5d6fb6e1eb 100644
--- a/src/java/org/apache/cassandra/config/CFMetaData.java
+++ b/src/java/org/apache/cassandra/config/CFMetaData.java
@@ -468,6 +468,11 @@ public final class CFMetaData
     {
         return Collections.unmodifiableMap(column_metadata);
     }
+
+    public AbstractType getComparatorFor(ByteBuffer superColumnName)
+    {
+        return superColumnName == null ? comparator : subcolumnComparator;
+    }
     
     public boolean equals(Object obj) 
     {
diff --git a/src/java/org/apache/cassandra/cql/QueryProcessor.java b/src/java/org/apache/cassandra/cql/QueryProcessor.java
index 26c7fa4a42..3920c44d40 100644
--- a/src/java/org/apache/cassandra/cql/QueryProcessor.java
+++ b/src/java/org/apache/cassandra/cql/QueryProcessor.java
@@ -236,7 +236,7 @@ public class QueryProcessor
             // FIXME: keys as ascii is not a Real Solution
             ByteBuffer key = update.getKey().getByteBuffer(AsciiType.instance);
             validateKey(key);
-            validateColumnFamily(keyspace, cfname);
+            validateColumnFamily(keyspace, update.getColumnFamily(), false);
             validateKeyType(key, keyspace, cfname);
             AbstractType<?> comparator = update.getComparator(keyspace);
             
@@ -460,7 +460,7 @@ public class QueryProcessor
             case SELECT:
                 SelectStatement select = (SelectStatement)statement.statement;
                 clientState.hasColumnFamilyAccess(select.getColumnFamily(), Permission.READ);
-                validateColumnFamily(keyspace, select.getColumnFamily());
+                validateColumnFamily(keyspace, select.getColumnFamily(), false);
                 validateSelect(keyspace, select);
                 
                 List<org.apache.cassandra.db.Row> rows = null;
diff --git a/src/java/org/apache/cassandra/thrift/CassandraServer.java b/src/java/org/apache/cassandra/thrift/CassandraServer.java
index 1c5eb9d72b..a7678699d6 100644
--- a/src/java/org/apache/cassandra/thrift/CassandraServer.java
+++ b/src/java/org/apache/cassandra/thrift/CassandraServer.java
@@ -241,7 +241,7 @@ public class CassandraServer implements Cassandra.Iface
         logger.debug("get_slice");
         
         state().hasColumnFamilyAccess(column_parent.column_family, Permission.READ);
-        return multigetSliceInternal(state().getKeyspace(), Collections.singletonList(key), column_parent, predicate, consistency_level).get(key);
+        return multigetSliceInternal(state().getKeyspace(), Collections.singletonList(key), column_parent, predicate, consistency_level, false).get(key);
     }
     
     public Map<ByteBuffer, List<ColumnOrSuperColumn>> multiget_slice(List<ByteBuffer> keys, ColumnParent column_parent, SlicePredicate predicate, ConsistencyLevel consistency_level)
@@ -250,14 +250,15 @@ public class CassandraServer implements Cassandra.Iface
         logger.debug("multiget_slice");
 
         state().hasColumnFamilyAccess(column_parent.column_family, Permission.READ);
-        return multigetSliceInternal(state().getKeyspace(), keys, column_parent, predicate, consistency_level);
+        return multigetSliceInternal(state().getKeyspace(), keys, column_parent, predicate, consistency_level, false);
     }
 
-    private Map<ByteBuffer, List<ColumnOrSuperColumn>> multigetSliceInternal(String keyspace, List<ByteBuffer> keys, ColumnParent column_parent, SlicePredicate predicate, ConsistencyLevel consistency_level)
+    private Map<ByteBuffer, List<ColumnOrSuperColumn>> multigetSliceInternal(String keyspace, List<ByteBuffer> keys, ColumnParent column_parent, SlicePredicate predicate, ConsistencyLevel consistency_level, boolean isCommutativeOp)
     throws InvalidRequestException, UnavailableException, TimedOutException
     {
-        ThriftValidation.validateColumnParent(keyspace, column_parent);
-        ThriftValidation.validatePredicate(keyspace, column_parent, predicate);
+        CFMetaData metadata = ThriftValidation.validateColumnFamily(keyspace, column_parent.column_family, isCommutativeOp);
+        ThriftValidation.validateColumnParent(metadata, column_parent);
+        ThriftValidation.validatePredicate(metadata, column_parent, predicate);
 
         List<ReadCommand> commands = new ArrayList<ReadCommand>();
         if (predicate.column_names != null)
@@ -281,13 +282,14 @@ public class CassandraServer implements Cassandra.Iface
         return getSlice(commands, consistency_level);
     }
 
-    private ColumnOrSuperColumn internal_get(ByteBuffer key, ColumnPath column_path, ConsistencyLevel consistency_level)
+    private ColumnOrSuperColumn internal_get(ByteBuffer key, ColumnPath column_path, ConsistencyLevel consistency_level, boolean isCommutativeOp)
     throws InvalidRequestException, NotFoundException, UnavailableException, TimedOutException
     {
         state().hasColumnFamilyAccess(column_path.column_family, Permission.READ);
         String keyspace = state().getKeyspace();
 
-        ThriftValidation.validateColumnPath(keyspace, column_path);
+        CFMetaData metadata = ThriftValidation.validateColumnFamily(keyspace, column_path.column_family, isCommutativeOp);
+        ThriftValidation.validateColumnPath(metadata, column_path);
 
         QueryPath path = new QueryPath(column_path.column_family, column_path.column == null ? null : column_path.super_column);
         List<ByteBuffer> nameAsList = Arrays.asList(column_path.column == null ? column_path.super_column : column_path.column);
@@ -312,7 +314,7 @@ public class CassandraServer implements Cassandra.Iface
     {
         logger.debug("get");
 
-        return internal_get(key, column_path, consistency_level);
+        return internal_get(key, column_path, consistency_level, false);
     }
 
     public int get_count(ByteBuffer key, ColumnParent column_parent, SlicePredicate predicate, ConsistencyLevel consistency_level)
@@ -334,7 +336,7 @@ public class CassandraServer implements Cassandra.Iface
         String keyspace = state().getKeyspace();
 
         Map<ByteBuffer, Integer> counts = new HashMap<ByteBuffer, Integer>();
-        Map<ByteBuffer, List<ColumnOrSuperColumn>> columnFamiliesMap = multigetSliceInternal(keyspace, keys, column_parent, predicate, consistency_level);
+        Map<ByteBuffer, List<ColumnOrSuperColumn>> columnFamiliesMap = multigetSliceInternal(keyspace, keys, column_parent, predicate, consistency_level, false);
 
         for (Map.Entry<ByteBuffer, List<ColumnOrSuperColumn>> cf : columnFamiliesMap.entrySet()) {
           counts.put(cf.getKey(), cf.getValue().size());
@@ -342,16 +344,18 @@ public class CassandraServer implements Cassandra.Iface
         return counts;
     }
 
-    private void internal_insert(ByteBuffer key, ColumnParent column_parent, Column column, ConsistencyLevel consistency_level)
+    private void internal_insert(ByteBuffer key, ColumnParent column_parent, Column column, ConsistencyLevel consistency_level, boolean isCommutativeOp)
     throws InvalidRequestException, UnavailableException, TimedOutException
     {
         state().hasColumnFamilyAccess(column_parent.column_family, Permission.WRITE);
 
         ThriftValidation.validateKey(key);
-        ThriftValidation.validateColumnParent(state().getKeyspace(), column_parent);
+        CFMetaData metadata = ThriftValidation.validateColumnFamily(state().getKeyspace(), column_parent.column_family, isCommutativeOp);
+        if (isCommutativeOp)
+            ThriftValidation.validateCommutativeForWrite(metadata, consistency_level);
         ThriftValidation.validateKeyType(key, state().getKeyspace(), column_parent.column_family);
-        ThriftValidation.validateColumnNames(state().getKeyspace(), column_parent, Arrays.asList(column.name));
-        ThriftValidation.validateColumnData(state().getKeyspace(), column_parent.column_family, column);
+        ThriftValidation.validateColumnNames(metadata, column_parent, Arrays.asList(column.name));
+        ThriftValidation.validateColumnData(metadata, column);
 
         RowMutation rm = new RowMutation(state().getKeyspace(), key);
         try
@@ -370,10 +374,10 @@ public class CassandraServer implements Cassandra.Iface
     {
         logger.debug("insert");
 
-        internal_insert(key, column_parent, column, consistency_level);
+        internal_insert(key, column_parent, column, consistency_level, false);
     }
 
-    private void internal_batch_mutate(Map<ByteBuffer,Map<String,List<Mutation>>> mutation_map, ConsistencyLevel consistency_level)
+    private void internal_batch_mutate(Map<ByteBuffer,Map<String,List<Mutation>>> mutation_map, ConsistencyLevel consistency_level, boolean isCommutativeOp)
     throws InvalidRequestException, UnavailableException, TimedOutException
     {
         List<String> cfamsSeen = new ArrayList<String>();
@@ -397,9 +401,13 @@ public class CassandraServer implements Cassandra.Iface
                     cfamsSeen.add(cfName);
                 }
 
+                CFMetaData metadata = ThriftValidation.validateColumnFamily(state().getKeyspace(), cfName, isCommutativeOp);
+                if (isCommutativeOp)
+                    ThriftValidation.validateCommutativeForWrite(metadata, consistency_level);
+
                 for (Mutation mutation : columnFamilyMutations.getValue())
                 {
-                    ThriftValidation.validateMutation(state().getKeyspace(), cfName, mutation);
+                    ThriftValidation.validateMutation(metadata, mutation);
                 }
             }
             RowMutation rm = RowMutation.getRowMutationFromMutations(state().getKeyspace(), key, columnFamilyToMutations);
@@ -415,16 +423,18 @@ public class CassandraServer implements Cassandra.Iface
     {
         logger.debug("batch_mutate");
 
-        internal_batch_mutate(mutation_map, consistency_level);
+        internal_batch_mutate(mutation_map, consistency_level, false);
     }
 
-    private void internal_remove(ByteBuffer key, ColumnPath column_path, long timestamp, ConsistencyLevel consistency_level)
+    private void internal_remove(ByteBuffer key, ColumnPath column_path, long timestamp, ConsistencyLevel consistency_level, boolean isCommutativeOp)
     throws InvalidRequestException, UnavailableException, TimedOutException
     {
         state().hasColumnFamilyAccess(column_path.column_family, Permission.WRITE);
 
         ThriftValidation.validateKey(key);
-        ThriftValidation.validateColumnPathOrParent(state().getKeyspace(), column_path);
+        CFMetaData metadata = ThriftValidation.validateColumnFamily(state().getKeyspace(), column_path.column_family, isCommutativeOp);
+        if (isCommutativeOp)
+            ThriftValidation.validateCommutativeForWrite(metadata, consistency_level);
         ThriftValidation.validateKeyType(key, state().getKeyspace(), column_path.column_family);
 
         RowMutation rm = new RowMutation(state().getKeyspace(), key);
@@ -438,7 +448,7 @@ public class CassandraServer implements Cassandra.Iface
     {
         logger.debug("remove");
 
-        internal_remove(key, column_path, timestamp, consistency_level);
+        internal_remove(key, column_path, timestamp, consistency_level, false);
     }
 
     private void doInsert(ConsistencyLevel consistency_level, List<RowMutation> mutations) throws UnavailableException, TimedOutException
@@ -503,8 +513,9 @@ public class CassandraServer implements Cassandra.Iface
         String keyspace = state().getKeyspace();
         state().hasColumnFamilyAccess(column_parent.column_family, Permission.READ);
 
-        ThriftValidation.validateColumnParent(keyspace, column_parent);
-        ThriftValidation.validatePredicate(keyspace, column_parent, predicate);
+        CFMetaData metadata = ThriftValidation.validateColumnFamily(keyspace, column_parent.column_family, false);
+        ThriftValidation.validateColumnParent(metadata, column_parent);
+        ThriftValidation.validatePredicate(metadata, column_parent, predicate);
         ThriftValidation.validateKeyRange(range);
 
         List<Row> rows;
@@ -566,9 +577,10 @@ public class CassandraServer implements Cassandra.Iface
 
         state().hasColumnFamilyAccess(column_parent.column_family, Permission.READ);
         String keyspace = state().getKeyspace();
-        ThriftValidation.validateColumnParent(keyspace, column_parent);
-        ThriftValidation.validatePredicate(keyspace, column_parent, column_predicate);
-        ThriftValidation.validateIndexClauses(keyspace, column_parent.column_family, index_clause);
+        CFMetaData metadata = ThriftValidation.validateColumnFamily(keyspace, column_parent.column_family, false);
+        ThriftValidation.validateColumnParent(metadata, column_parent);
+        ThriftValidation.validatePredicate(metadata, column_parent, column_predicate);
+        ThriftValidation.validateIndexClauses(metadata, index_clause);
 
         List<Row> rows;
         try
@@ -998,10 +1010,7 @@ public class CassandraServer implements Cassandra.Iface
     {
         logger.debug("add");
 
-        String keyspace = state().getKeyspace();
-        ThriftValidation.validateCommutativeForWrite(keyspace, column_parent.column_family, consistency_level);
-
-        internal_insert(key, column_parent, getCounterColumn(column), consistency_level);
+        internal_insert(key, column_parent, getCounterColumn(column), consistency_level, true);
     }
 
     private Mutation getMutation(CounterMutation counterMutation)
@@ -1059,8 +1068,6 @@ public class CassandraServer implements Cassandra.Iface
             
             for (Entry<String, List<CounterMutation>> innerEntry : entry.getValue().entrySet())
             {
-                ThriftValidation.validateCommutativeForWrite(keyspace, innerEntry.getKey(), consistency_level);
-                
                 List<Mutation> mutations = new ArrayList<Mutation>(innerEntry.getValue().size());
                 for (CounterMutation cm : innerEntry.getValue())
                 {
@@ -1072,7 +1079,7 @@ public class CassandraServer implements Cassandra.Iface
             mutation_map.put(entry.getKey(), valueMap);
         }
         
-        internal_batch_mutate(mutation_map, consistency_level);
+        internal_batch_mutate(mutation_map, consistency_level, true);
     }
 
     private Counter getCounter(ColumnOrSuperColumn cosc)
@@ -1096,9 +1103,8 @@ public class CassandraServer implements Cassandra.Iface
         logger.debug("get_counter");
 
         String keyspace = state().getKeyspace();
-        ThriftValidation.validateCommutative(keyspace, path.column_family);
 
-        return getCounter(internal_get(key, path, consistency_level));
+        return getCounter(internal_get(key, path, consistency_level, true));
     }
     
     private List<Counter> getCounters(List<ColumnOrSuperColumn> cosc)
@@ -1121,11 +1127,8 @@ public class CassandraServer implements Cassandra.Iface
         if (logger.isDebugEnabled())
             logger.debug("get_counter_slice");
 
-        String keyspace = state().getKeyspace();
-        ThriftValidation.validateCommutative(keyspace, column_parent.column_family);
-
         state().hasColumnFamilyAccess(column_parent.column_family, Permission.READ);
-        List<ColumnOrSuperColumn> cosc = multigetSliceInternal(state().getKeyspace(), Collections.singletonList(key), column_parent, predicate, consistency_level).get(key);
+        List<ColumnOrSuperColumn> cosc = multigetSliceInternal(state().getKeyspace(), Collections.singletonList(key), column_parent, predicate, consistency_level, true).get(key);
         return getCounters(cosc);
     }
 
@@ -1136,11 +1139,8 @@ public class CassandraServer implements Cassandra.Iface
         if (logger.isDebugEnabled())
             logger.debug("multiget_counter_slice");
 
-        String keyspace = state().getKeyspace();
-        ThriftValidation.validateCommutative(keyspace, column_parent.column_family);
-
         state().hasColumnFamilyAccess(column_parent.column_family, Permission.READ);
-        Map<ByteBuffer, List<ColumnOrSuperColumn>> slices = multigetSliceInternal(state().getKeyspace(), keys, column_parent, predicate, consistency_level);
+        Map<ByteBuffer, List<ColumnOrSuperColumn>> slices = multigetSliceInternal(state().getKeyspace(), keys, column_parent, predicate, consistency_level, true);
         Map<ByteBuffer, List<Counter>> rv = new HashMap<ByteBuffer, List<Counter>>(slices.size());
         for (Entry<ByteBuffer, List<ColumnOrSuperColumn>> entry : slices.entrySet())
         {
@@ -1156,9 +1156,8 @@ public class CassandraServer implements Cassandra.Iface
             logger.debug("remove_counter");
 
         String keyspace = state().getKeyspace();
-        ThriftValidation.validateCommutative(keyspace, path.column_family);
 
-        internal_remove(key, path, System.currentTimeMillis(), consistency_level);
+        internal_remove(key, path, System.currentTimeMillis(), consistency_level, true);
     }
 
     public CqlResult execute_cql_query(ByteBuffer query, Compression compression)
diff --git a/src/java/org/apache/cassandra/thrift/ThriftValidation.java b/src/java/org/apache/cassandra/thrift/ThriftValidation.java
index fdf6a96ea9..21ad7d59b9 100644
--- a/src/java/org/apache/cassandra/thrift/ThriftValidation.java
+++ b/src/java/org/apache/cassandra/thrift/ThriftValidation.java
@@ -82,103 +82,106 @@ public class ThriftValidation
         }
     }
 
-    public static ColumnFamilyType validateColumnFamily(String tablename, String cfName) throws InvalidRequestException
+    public static CFMetaData validateColumnFamily(String tablename, String cfName, boolean isCommutativeOp) throws InvalidRequestException
     {
+        validateTable(tablename);
         if (cfName.isEmpty())
-        {
             throw new InvalidRequestException("non-empty columnfamily is required");
+
+        CFMetaData metadata = DatabaseDescriptor.getCFMetaData(tablename, cfName);
+        if (metadata == null)
+            throw new InvalidRequestException("unconfigured columnfamily " + cfName);
+
+        if (isCommutativeOp)
+        {
+            if (!metadata.getDefaultValidator().isCommutative())
+                throw new InvalidRequestException("invalid operation for non commutative columnfamily " + cfName);
         }
-        ColumnFamilyType cfType = DatabaseDescriptor.getColumnFamilyType(tablename, cfName);
-        if (cfType == null)
+        else
         {
-            throw new InvalidRequestException("unconfigured columnfamily " + cfName);
+            if (metadata.getDefaultValidator().isCommutative())
+                throw new InvalidRequestException("invalid operation for commutative columnfamily " + cfName);
         }
-        return cfType;
+        return metadata;
     }
 
     /**
-     * validates the tablename and all parts of the path to the column, including the column name
+     * validates all parts of the path to the column, including the column name
      */
-    static void validateColumnPath(String tablename, ColumnPath column_path) throws InvalidRequestException
+    public static void validateColumnPath(CFMetaData metadata, ColumnPath column_path) throws InvalidRequestException
     {
-        validateTable(tablename);
-        ColumnFamilyType cfType = validateColumnFamily(tablename, column_path.column_family);
-        if (cfType == ColumnFamilyType.Standard)
+        if (metadata.cfType == ColumnFamilyType.Standard)
         {
             if (column_path.super_column != null)
             {
-                throw new InvalidRequestException("supercolumn parameter is invalid for standard CF " + column_path.column_family);
+                throw new InvalidRequestException("supercolumn parameter is invalid for standard CF " + metadata.cfName);
             }
             if (column_path.column == null)
             {
-                throw new InvalidRequestException("column parameter is not optional for standard CF " + column_path.column_family);
+                throw new InvalidRequestException("column parameter is not optional for standard CF " + metadata.cfName);
             }
         }
         else
         {
             if (column_path.super_column == null)
-                throw new InvalidRequestException("supercolumn parameter is not optional for super CF " + column_path.column_family);
+                throw new InvalidRequestException("supercolumn parameter is not optional for super CF " + metadata.cfName);
         }
         if (column_path.column != null)
         {
-            validateColumnNames(tablename, column_path.column_family, column_path.super_column, Arrays.asList(column_path.column));
+            validateColumnNames(metadata, column_path.super_column, Arrays.asList(column_path.column));
         }
         if (column_path.super_column != null)
         {
-            validateColumnNames(tablename, column_path.column_family, null, Arrays.asList(column_path.super_column));
+            validateColumnNames(metadata, (ByteBuffer)null, Arrays.asList(column_path.super_column));
         }
     }
 
-    static void validateColumnParent(String tablename, ColumnParent column_parent) throws InvalidRequestException
+    public static void validateColumnParent(CFMetaData metadata, ColumnParent column_parent) throws InvalidRequestException
     {
-        validateTable(tablename);
-        ColumnFamilyType cfType = validateColumnFamily(tablename, column_parent.column_family);
-        if (cfType == ColumnFamilyType.Standard)
+        if (metadata.cfType == ColumnFamilyType.Standard)
         {
             if (column_parent.super_column != null)
             {
-                throw new InvalidRequestException("columnfamily alone is required for standard CF " + column_parent.column_family);
+                throw new InvalidRequestException("columnfamily alone is required for standard CF " + metadata.cfName);
             }
         }
         if (column_parent.super_column != null)
         {
-            validateColumnNames(tablename, column_parent.column_family, null, Arrays.asList(column_parent.super_column));
+            validateColumnNames(metadata, (ByteBuffer)null, Arrays.asList(column_parent.super_column));
         }
     }
 
     // column_path_or_parent is a ColumnPath for remove, where the "column" is optional even for a standard CF
-    static void validateColumnPathOrParent(String tablename, ColumnPath column_path_or_parent) throws InvalidRequestException
+    static void validateColumnPathOrParent(CFMetaData metadata, ColumnPath column_path_or_parent) throws InvalidRequestException
     {
-        validateTable(tablename);
-        ColumnFamilyType cfType = validateColumnFamily(tablename, column_path_or_parent.column_family);
-        if (cfType == ColumnFamilyType.Standard)
+        if (metadata.cfType == ColumnFamilyType.Standard)
         {
             if (column_path_or_parent.super_column != null)
             {
-                throw new InvalidRequestException("supercolumn may not be specified for standard CF " + column_path_or_parent.column_family);
+                throw new InvalidRequestException("supercolumn may not be specified for standard CF " + metadata.cfName);
             }
         }
-        if (cfType == ColumnFamilyType.Super)
+        if (metadata.cfType == ColumnFamilyType.Super)
         {
             if (column_path_or_parent.super_column == null && column_path_or_parent.column != null)
             {
-                throw new InvalidRequestException("A column cannot be specified without specifying a super column for removal on super CF " + column_path_or_parent.column_family);
+                throw new InvalidRequestException("A column cannot be specified without specifying a super column for removal on super CF " + metadata.cfName);
             }
         }
         if (column_path_or_parent.column != null)
         {
-            validateColumnNames(tablename, column_path_or_parent.column_family, column_path_or_parent.super_column, Arrays.asList(column_path_or_parent.column));
+            validateColumnNames(metadata, column_path_or_parent.super_column, Arrays.asList(column_path_or_parent.column));
         }
         if (column_path_or_parent.super_column != null)
         {
-            validateColumnNames(tablename, column_path_or_parent.column_family, null, Arrays.asList(column_path_or_parent.super_column));
+            validateColumnNames(metadata, (ByteBuffer)null, Arrays.asList(column_path_or_parent.super_column));
         }
     }
 
     /**
      * Validates the column names but not the parent path or data
      */
-    private static void validateColumnNames(String keyspace, String columnFamilyName, ByteBuffer superColumnName, Iterable<ByteBuffer> column_names)
+    private static void validateColumnNames(CFMetaData metadata, ByteBuffer superColumnName, Iterable<ByteBuffer> column_names)
             throws InvalidRequestException
     {
         if (superColumnName != null)
@@ -187,10 +190,10 @@ public class ThriftValidation
                 throw new InvalidRequestException("supercolumn name length must not be greater than " + IColumn.MAX_NAME_LENGTH);
             if (superColumnName.remaining() == 0)
                 throw new InvalidRequestException("supercolumn name must not be empty");
-            if (DatabaseDescriptor.getColumnFamilyType(keyspace, columnFamilyName) == ColumnFamilyType.Standard)
-                throw new InvalidRequestException("supercolumn specified to ColumnFamily " + columnFamilyName + " containing normal columns");
+            if (metadata.cfType == ColumnFamilyType.Standard)
+                throw new InvalidRequestException("supercolumn specified to ColumnFamily " + metadata.cfName + " containing normal columns");
         }
-        AbstractType comparator = ColumnFamily.getComparatorFor(keyspace, columnFamilyName, superColumnName);
+        AbstractType comparator = metadata.getComparatorFor(superColumnName);
         for (ByteBuffer name : column_names)
         {
             if (name.remaining() > IColumn.MAX_NAME_LENGTH)
@@ -208,14 +211,14 @@ public class ThriftValidation
         }
     }
 
-    public static void validateColumnNames(String keyspace, ColumnParent column_parent, Iterable<ByteBuffer> column_names) throws InvalidRequestException
+    public static void validateColumnNames(CFMetaData metadata, ColumnParent column_parent, Iterable<ByteBuffer> column_names) throws InvalidRequestException
     {
-        validateColumnNames(keyspace, column_parent.column_family, column_parent.super_column, column_names);
+        validateColumnNames(metadata, column_parent.super_column, column_names);
     }
 
-    public static void validateRange(String keyspace, ColumnParent column_parent, SliceRange range) throws InvalidRequestException
+    public static void validateRange(CFMetaData metadata, ColumnParent column_parent, SliceRange range) throws InvalidRequestException
     {
-        AbstractType comparator = ColumnFamily.getComparatorFor(keyspace, column_parent.column_family, column_parent.super_column);
+        AbstractType comparator = metadata.getComparatorFor(column_parent.super_column);
         try
         {
             comparator.validate(range.start);
@@ -238,23 +241,22 @@ public class ThriftValidation
         }
     }
 
-    public static void validateColumnOrSuperColumn(String keyspace, String cfName, ColumnOrSuperColumn cosc)
+    public static void validateColumnOrSuperColumn(CFMetaData metadata, ColumnOrSuperColumn cosc)
             throws InvalidRequestException
     {
         if (cosc.column != null)
         {
             validateTtl(cosc.column);
-            ThriftValidation.validateColumnPath(keyspace, new ColumnPath(cfName).setSuper_column((ByteBuffer)null).setColumn(cosc.column.name));
-            validateColumnData(keyspace, cfName, cosc.column);
+            validateColumnPath(metadata, new ColumnPath(metadata.cfName).setSuper_column((ByteBuffer)null).setColumn(cosc.column.name));
+            validateColumnData(metadata, cosc.column);
         }
 
         if (cosc.super_column != null)
         {
-            ColumnParent cp = new ColumnParent(cfName).setSuper_column(cosc.super_column.name);
             for (Column c : cosc.super_column.columns)
             {
-                ThriftValidation.validateColumnPath(keyspace, new ColumnPath(cfName).setSuper_column(cosc.super_column.name).setColumn(c.name));
-                validateColumnData(keyspace, cp.column_family, c);
+                validateColumnPath(metadata, new ColumnPath(metadata.cfName).setSuper_column(cosc.super_column.name).setColumn(c.name));
+                validateColumnData(metadata, c);
             }
         }
 
@@ -272,7 +274,7 @@ public class ThriftValidation
         assert column.isSetTtl() || column.ttl == 0;
     }
 
-    public static void validateMutation(String keyspace, String cfName, Mutation mut)
+    public static void validateMutation(CFMetaData metadata, Mutation mut)
             throws InvalidRequestException
     {
         ColumnOrSuperColumn cosc = mut.column_or_supercolumn;
@@ -283,11 +285,11 @@ public class ThriftValidation
 
         if (cosc != null)
         {
-            validateColumnOrSuperColumn(keyspace, cfName, cosc);
+            validateColumnOrSuperColumn(metadata, cosc);
         }
         else if (del != null)
         {
-            validateDeletion(keyspace, cfName, del);
+            validateDeletion(metadata, del);
         }
         else
         {
@@ -295,59 +297,58 @@ public class ThriftValidation
         }
     }
 
-    public static void validateDeletion(String keyspace, String cfName, Deletion del) throws InvalidRequestException
+    public static void validateDeletion(CFMetaData metadata, Deletion del) throws InvalidRequestException
     {
-        validateColumnFamily(keyspace, cfName);
         if (del.predicate != null)
         {
-            validateSlicePredicate(keyspace, cfName, del.super_column, del.predicate);
+            validateSlicePredicate(metadata, del.super_column, del.predicate);
             if (del.predicate.slice_range != null)
                 throw new InvalidRequestException("Deletion does not yet support SliceRange predicates.");
         }
 
-        if (ColumnFamilyType.Standard == DatabaseDescriptor.getColumnFamilyType(keyspace, cfName) && del.super_column != null)
+        if (metadata.cfType == ColumnFamilyType.Standard && del.super_column != null)
         {
-            String msg = String.format("deletion of super_column is not possible on a standard ColumnFamily (KeySpace=%s ColumnFamily=%s Deletion=%s)", keyspace, cfName, del);
+            String msg = String.format("deletion of super_column is not possible on a standard ColumnFamily (KeySpace=%s ColumnFamily=%s Deletion=%s)", metadata.ksName, metadata.cfName, del);
             throw new InvalidRequestException(msg);
         }
     }
 
-    public static void validateSlicePredicate(String keyspace, String cfName, ByteBuffer scName, SlicePredicate predicate) throws InvalidRequestException
+    public static void validateSlicePredicate(CFMetaData metadata, ByteBuffer scName, SlicePredicate predicate) throws InvalidRequestException
     {
         if (predicate.column_names == null && predicate.slice_range == null)
             throw new InvalidRequestException("A SlicePredicate must be given a list of Columns, a SliceRange, or both");
 
         if (predicate.slice_range != null)
-            validateRange(keyspace, new ColumnParent(cfName).setSuper_column(scName), predicate.slice_range);
+            validateRange(metadata, new ColumnParent(metadata.cfName).setSuper_column(scName), predicate.slice_range);
 
         if (predicate.column_names != null)
-            validateColumnNames(keyspace, cfName, scName, predicate.column_names);
+            validateColumnNames(metadata, scName, predicate.column_names);
     }
 
     /**
      * Validates the data part of the column (everything in the Column object but the name)
      */
-    public static void validateColumnData(String keyspace, String column_family, Column column) throws InvalidRequestException
+    public static void validateColumnData(CFMetaData metadata, Column column) throws InvalidRequestException
     {
         validateTtl(column);
         try
         {
-            AbstractType validator = DatabaseDescriptor.getValueValidator(keyspace, column_family, column.name);
+            AbstractType validator = metadata.getValueValidator(column.name);
             if (validator != null)
                 validator.validate(column.value);
         }
         catch (MarshalException me)
         {
             throw new InvalidRequestException(String.format("[%s][%s][%s] = [%s] failed validation (%s)",
-                                                            keyspace,
-                                                            column_family,
+                                                            metadata.ksName,
+                                                            metadata.cfName,
                                                             ByteBufferUtil.bytesToHex(column.name),
                                                             ByteBufferUtil.bytesToHex(column.value),
                                                             me.getMessage()));
         }
     }
 
-    public static void validatePredicate(String keyspace, ColumnParent column_parent, SlicePredicate predicate)
+    public static void validatePredicate(CFMetaData metadata, ColumnParent column_parent, SlicePredicate predicate)
             throws InvalidRequestException
     {
         if (predicate.column_names == null && predicate.slice_range == null)
@@ -356,9 +357,9 @@ public class ThriftValidation
             throw new InvalidRequestException("predicate column_names and slice_range may not both be present");
 
         if (predicate.getSlice_range() != null)
-            validateRange(keyspace, column_parent, predicate.slice_range);
+            validateRange(metadata, column_parent, predicate.slice_range);
         else
-            validateColumnNames(keyspace, column_parent, predicate.column_names);
+            validateColumnNames(metadata, column_parent, predicate.column_names);
     }
 
     public static void validateKeyRange(KeyRange range) throws InvalidRequestException
@@ -396,13 +397,13 @@ public class ThriftValidation
         }
     }
 
-    public static void validateIndexClauses(String keyspace, String columnFamily, IndexClause index_clause)
+    public static void validateIndexClauses(CFMetaData metadata, IndexClause index_clause)
     throws InvalidRequestException
     {
         if (index_clause.expressions.isEmpty())
             throw new InvalidRequestException("index clause list may not be empty");
-        Set<ByteBuffer> indexedColumns = Table.open(keyspace).getColumnFamilyStore(columnFamily).getIndexedColumns();
-        AbstractType nameValidator =  ColumnFamily.getComparatorFor(keyspace, columnFamily, null);
+        Set<ByteBuffer> indexedColumns = Table.open(metadata.ksName).getColumnFamilyStore(metadata.cfName).getIndexedColumns();
+        AbstractType nameValidator =  ColumnFamily.getComparatorFor(metadata.ksName, metadata.cfName, null);
 
         boolean isIndexed = false;
         for (IndexExpression expression : index_clause.expressions)
@@ -419,7 +420,7 @@ public class ThriftValidation
                                                                 me.getMessage()));
             }
 
-            AbstractType valueValidator = DatabaseDescriptor.getValueValidator(keyspace, columnFamily, expression.column_name);
+            AbstractType valueValidator = DatabaseDescriptor.getValueValidator(metadata.ksName, metadata.cfName, expression.column_name);
             try
             {
                 valueValidator.validate(expression.value);
@@ -494,37 +495,11 @@ public class ThriftValidation
         }
     }
 
-    public static CFMetaData validateCFMetaData(String tablename, String cfName) throws InvalidRequestException
-    {
-        if (cfName.isEmpty())
-        {
-            throw new InvalidRequestException("non-empty columnfamily is required");
-        }
-        CFMetaData metadata = DatabaseDescriptor.getCFMetaData(tablename, cfName);
-        if (metadata == null)
-        {
-            throw new InvalidRequestException("unconfigured columnfamily " + cfName);
-        }
-        return metadata;
-    }
-
-    public static CFMetaData validateCommutative(String tablename, String cfName) throws InvalidRequestException
-    {
-        validateTable(tablename);
-        CFMetaData metadata = validateCFMetaData(tablename, cfName);
-        if (!metadata.getDefaultValidator().isCommutative())
-        {
-            throw new InvalidRequestException("not commutative columnfamily " + cfName);
-        }
-        return metadata;
-    }
-
-    public static void validateCommutativeForWrite(String tablename, String cfName, ConsistencyLevel consistency) throws InvalidRequestException
+    public static void validateCommutativeForWrite(CFMetaData metadata, ConsistencyLevel consistency) throws InvalidRequestException
     {
-        CFMetaData metadata = validateCommutative(tablename, cfName);
         if (!metadata.getReplicateOnWrite() && consistency != ConsistencyLevel.ONE)
         {
-            throw new InvalidRequestException("cannot achieve CL > CL.ONE without replicate_on_write on columnfamily " + cfName);
+            throw new InvalidRequestException("cannot achieve CL > CL.ONE without replicate_on_write on columnfamily " + metadata.cfName);
         }
     }
 }
diff --git a/test/system/test_thrift_server.py b/test/system/test_thrift_server.py
index e795cb6a35..38959b041c 100644
--- a/test/system/test_thrift_server.py
+++ b/test/system/test_thrift_server.py
@@ -55,6 +55,13 @@ def _assert_no_columnpath(key, column_path):
     except NotFoundException:
         assert True, 'column did not exist'
 
+def _assert_no_columnpath_counter(key, column_path):
+    try:
+        client.get_counter(key, column_path, ConsistencyLevel.ONE)
+        assert False, ('columnpath %s existed in %s when it should not' % (column_path, key))
+    except NotFoundException:
+        assert True, 'column did not exist'
+
 def _insert_simple(block=True):
    return _insert_multi(['key1'])
 
@@ -1548,7 +1555,7 @@ class TestMutations(ThriftTester):
         # remove the previous column and check that it is gone
         client.remove_counter('key1', ColumnPath(column_family='Counter1', column='c1'), ConsistencyLevel.ONE)
         time.sleep(5)
-        _assert_no_columnpath('key1', ColumnPath(column_family='Counter1', column='c1'))
+        _assert_no_columnpath_counter('key1', ColumnPath(column_family='Counter1', column='c1'))
 
         # insert again and this time delete the whole row, check that it is gone
         client.add('key1', ColumnParent(column_family='Counter1'), CounterColumn('c1', d1), ConsistencyLevel.ONE)
@@ -1557,7 +1564,7 @@ class TestMutations(ThriftTester):
         assert rv2.column.value == d1
         client.remove_counter('key1', ColumnPath(column_family='Counter1'), ConsistencyLevel.ONE)
         time.sleep(5)
-        _assert_no_columnpath('key1', ColumnPath(column_family='Counter1', column='c1'))
+        _assert_no_columnpath_counter('key1', ColumnPath(column_family='Counter1', column='c1'))
 
     def test_incr_super_remove(self):
         _set_keyspace('Keyspace1')
@@ -1573,7 +1580,7 @@ class TestMutations(ThriftTester):
         # remove the previous column and check that it is gone
         client.remove_counter('key1', ColumnPath(column_family='SuperCounter1', super_column='sc1', column='c1'), ConsistencyLevel.ONE)
         time.sleep(5)
-        _assert_no_columnpath('key1', ColumnPath(column_family='SuperCounter1', super_column='sc1', column='c1'))
+        _assert_no_columnpath_counter('key1', ColumnPath(column_family='SuperCounter1', super_column='sc1', column='c1'))
 
         # insert again and this time delete the whole row, check that it is gone
         client.add('key1', ColumnParent(column_family='SuperCounter1', super_column='sc1'), CounterColumn('c1', d1), ConsistencyLevel.ONE)
@@ -1582,7 +1589,7 @@ class TestMutations(ThriftTester):
         assert rv2.column.value == d1
         client.remove_counter('key1', ColumnPath(column_family='SuperCounter1', super_column='sc1'), ConsistencyLevel.ONE)
         time.sleep(5)
-        _assert_no_columnpath('key1', ColumnPath(column_family='SuperCounter1', super_column='sc1', column='c1'))
+        _assert_no_columnpath_counter('key1', ColumnPath(column_family='SuperCounter1', super_column='sc1', column='c1'))
 
     def test_incr_decr_standard_remove(self):
         _set_keyspace('Keyspace1')
@@ -1598,7 +1605,7 @@ class TestMutations(ThriftTester):
         # remove the previous column and check that it is gone
         client.remove_counter('key1', ColumnPath(column_family='Counter1', column='c1'), ConsistencyLevel.ONE)
         time.sleep(5)
-        _assert_no_columnpath('key1', ColumnPath(column_family='Counter1', column='c1'))
+        _assert_no_columnpath_counter('key1', ColumnPath(column_family='Counter1', column='c1'))
 
         # insert again and this time delete the whole row, check that it is gone
         client.add('key1', ColumnParent(column_family='Counter1'), CounterColumn('c1', d1), ConsistencyLevel.ONE)
@@ -1607,7 +1614,7 @@ class TestMutations(ThriftTester):
         assert rv2.column.value == d1
         client.remove_counter('key1', ColumnPath(column_family='Counter1'), ConsistencyLevel.ONE)
         time.sleep(5)
-        _assert_no_columnpath('key1', ColumnPath(column_family='Counter1', column='c1'))
+        _assert_no_columnpath_counter('key1', ColumnPath(column_family='Counter1', column='c1'))
 
     def test_incr_decr_super_remove(self):
         _set_keyspace('Keyspace1')
@@ -1623,7 +1630,7 @@ class TestMutations(ThriftTester):
         # remove the previous column and check that it is gone
         client.remove_counter('key1', ColumnPath(column_family='SuperCounter1', super_column='sc1', column='c1'), ConsistencyLevel.ONE)
         time.sleep(5)
-        _assert_no_columnpath('key1', ColumnPath(column_family='SuperCounter1', super_column='sc1', column='c1'))
+        _assert_no_columnpath_counter('key1', ColumnPath(column_family='SuperCounter1', super_column='sc1', column='c1'))
 
         # insert again and this time delete the whole row, check that it is gone
         client.add('key1', ColumnParent(column_family='SuperCounter1', super_column='sc1'), CounterColumn('c1', d1), ConsistencyLevel.ONE)
@@ -1632,7 +1639,7 @@ class TestMutations(ThriftTester):
         assert rv2.column.value == d1
         client.remove_counter('key1', ColumnPath(column_family='SuperCounter1', super_column='sc1'), ConsistencyLevel.ONE)
         time.sleep(5)
-        _assert_no_columnpath('key1', ColumnPath(column_family='SuperCounter1', super_column='sc1', column='c1'))
+        _assert_no_columnpath_counter('key1', ColumnPath(column_family='SuperCounter1', super_column='sc1', column='c1'))
         
     def test_incr_decr_standard_batch_add(self):
         _set_keyspace('Keyspace1')
@@ -1672,7 +1679,7 @@ class TestMutations(ThriftTester):
             ]}}
         client.batch_add(update_map, ConsistencyLevel.ONE)
         time.sleep(5)
-        _assert_no_columnpath('key1', ColumnPath(column_family='Counter1', column='c1'))
+        _assert_no_columnpath_counter('key1', ColumnPath(column_family='Counter1', column='c1'))
 
         # insert again and this time delete the whole row, check that it is gone
         update_map = {'key1': {'Counter1': [
@@ -1689,7 +1696,7 @@ class TestMutations(ThriftTester):
             ]}}
         client.batch_add(update_map, ConsistencyLevel.ONE)
         time.sleep(5)
-        _assert_no_columnpath('key1', ColumnPath(column_family='Counter1', column='c1'))
+        _assert_no_columnpath_counter('key1', ColumnPath(column_family='Counter1', column='c1'))
         
     def test_incr_decr_standard_slice(self):
         _set_keyspace('Keyspace1')
diff --git a/test/unit/org/apache/cassandra/thrift/ThriftValidationTest.java b/test/unit/org/apache/cassandra/thrift/ThriftValidationTest.java
index b1bab5f4c1..c5017a7fbf 100644
--- a/test/unit/org/apache/cassandra/thrift/ThriftValidationTest.java
+++ b/test/unit/org/apache/cassandra/thrift/ThriftValidationTest.java
@@ -30,12 +30,12 @@ public class ThriftValidationTest extends CleanupHelper
     @Test(expected=InvalidRequestException.class)
     public void testValidateCommutativeWithStandard() throws InvalidRequestException
     {
-        ThriftValidation.validateCommutative("Keyspace1", "Standard1");
+        ThriftValidation.validateColumnFamily("Keyspace1", "Standard1", true);
     }
 
     @Test
     public void testValidateCommutativeWithCounter() throws InvalidRequestException
     {
-        ThriftValidation.validateCommutative("Keyspace1", "Counter1");
+        ThriftValidation.validateColumnFamily("Keyspace1", "Counter1", true);
     }
 }
