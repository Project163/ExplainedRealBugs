diff --git a/CHANGES.txt b/CHANGES.txt
index e956796347..3f2b4d0a0d 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 3.0.19
+ * Fix LegacyLayout RangeTombstoneList IndexOutOfBoundsException when upgrading and RangeTombstone bounds are asymmetric (CASSANDRA-15172)
  * Fix NPE when using allocate_tokens_for_keyspace on new DC/rack (CASSANDRA-14952)
  * Filter sstables earlier when running cleanup (CASSANDRA-15100)
  * Use mean row count instead of mean column count for index selectivity calculation (CASSANDRA-15259)
diff --git a/src/java/org/apache/cassandra/db/LegacyLayout.java b/src/java/org/apache/cassandra/db/LegacyLayout.java
index a46aa91f8f..1a03c91371 100644
--- a/src/java/org/apache/cassandra/db/LegacyLayout.java
+++ b/src/java/org/apache/cassandra/db/LegacyLayout.java
@@ -2598,11 +2598,10 @@ public abstract class LegacyLayout
 
                 CompositeType.Builder startBuilder = type.builder();
                 CompositeType.Builder endBuilder = type.builder();
-                for (int j = 0; j < start.bound.clustering().size(); j++)
-                {
+                for (int j = 0; j < start.bound.size(); j++)
                     startBuilder.add(start.bound.get(j));
+                for (int j = 0; j < end.bound.size(); j++)
                     endBuilder.add(end.bound.get(j));
-                }
 
                 if (start.collectionName != null)
                     startBuilder.add(start.collectionName.name.bytes);
diff --git a/test/unit/org/apache/cassandra/db/LegacyLayoutTest.java b/test/unit/org/apache/cassandra/db/LegacyLayoutTest.java
index 580a0e70d6..77197d3b47 100644
--- a/test/unit/org/apache/cassandra/db/LegacyLayoutTest.java
+++ b/test/unit/org/apache/cassandra/db/LegacyLayoutTest.java
@@ -25,12 +25,15 @@ import java.nio.file.Path;
 import java.nio.file.Paths;
 
 import org.apache.cassandra.db.filter.ColumnFilter;
+import org.apache.cassandra.db.partitions.ImmutableBTreePartition;
 import org.apache.cassandra.db.rows.BufferCell;
 import org.apache.cassandra.db.rows.Cell;
 import org.apache.cassandra.db.rows.RowIterator;
+import org.apache.cassandra.db.rows.Rows;
 import org.apache.cassandra.db.rows.SerializationHelper;
 import org.apache.cassandra.db.rows.UnfilteredRowIterator;
 import org.apache.cassandra.db.rows.UnfilteredRowIteratorSerializer;
+import org.apache.cassandra.db.rows.UnfilteredRowIterators;
 import org.apache.cassandra.db.transform.FilteredRows;
 import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.io.util.DataInputBuffer;
@@ -60,6 +63,7 @@ import org.apache.cassandra.schema.KeyspaceParams;
 import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.cassandra.utils.Hex;
 
+import static org.apache.cassandra.net.MessagingService.VERSION_21;
 import static org.junit.Assert.*;
 
 public class LegacyLayoutTest
@@ -181,10 +185,10 @@ public class LegacyLayoutTest
     {
         try (DataOutputBuffer out = new DataOutputBuffer())
         {
-            LegacyLayout.serializeAsLegacyPartition(null, partition, out, MessagingService.VERSION_21);
+            LegacyLayout.serializeAsLegacyPartition(null, partition, out, VERSION_21);
             try (DataInputBuffer in = new DataInputBuffer(out.buffer(), false))
             {
-                return LegacyLayout.deserializeLegacyPartition(in, MessagingService.VERSION_21, SerializationHelper.Flag.LOCAL, partition.partitionKey().getKey());
+                return LegacyLayout.deserializeLegacyPartition(in, VERSION_21, SerializationHelper.Flag.LOCAL, partition.partitionKey().getKey());
             }
         }
     }
@@ -278,11 +282,11 @@ public class LegacyLayoutTest
         try (RowIterator before = FilteredRows.filter(upd.unfilteredIterator(), FBUtilities.nowInSeconds());
              DataOutputBuffer serialized21 = new DataOutputBuffer())
         {
-            LegacyLayout.serializeAsLegacyPartition(null, upd.unfilteredIterator(), serialized21, MessagingService.VERSION_21);
+            LegacyLayout.serializeAsLegacyPartition(null, upd.unfilteredIterator(), serialized21, VERSION_21);
             QueryProcessor.executeInternal(String.format("ALTER TABLE \"%s\".legacy_rt_rt_dc DROP s", KEYSPACE));
             try (DataInputBuffer in = new DataInputBuffer(serialized21.buffer(), false))
             {
-                try (UnfilteredRowIterator deser21 = LegacyLayout.deserializeLegacyPartition(in, MessagingService.VERSION_21, SerializationHelper.Flag.LOCAL, upd.partitionKey().getKey());
+                try (UnfilteredRowIterator deser21 = LegacyLayout.deserializeLegacyPartition(in, VERSION_21, SerializationHelper.Flag.LOCAL, upd.partitionKey().getKey());
                     RowIterator after = FilteredRows.filter(deser21, FBUtilities.nowInSeconds());)
                 {
                     while (before.hasNext() || after.hasNext())
@@ -328,7 +332,7 @@ public class LegacyLayoutTest
         MigrationManager.announceNewColumnFamily(table);
 
         byte[] bytes = Hex.hexToBytes("00026b73000263660000000000000001fffffffe01000000088000000000000000010000000880000000000000000000000100000000007fffffffffffffff000b00017600000400000001000000000000000000000101");
-        ReadCommand.legacyPagedRangeCommandSerializer.deserialize(new DataInputBuffer(bytes), MessagingService.VERSION_21);
+        ReadCommand.legacyPagedRangeCommandSerializer.deserialize(new DataInputBuffer(bytes), VERSION_21);
     }
 
     @Test
@@ -345,4 +349,26 @@ public class LegacyLayoutTest
         LegacyLayout.decodeSliceBound(table, bound, true);
     }
 
+    @Test
+    public void testAsymmetricRTBoundSerializedSize()
+    {
+        CFMetaData table = CFMetaData.Builder.create("ks", "cf")
+                                             .addPartitionKey("k", Int32Type.instance)
+                                             .addClusteringColumn("c1", Int32Type.instance)
+                                             .addClusteringColumn("c2", Int32Type.instance)
+                                             .addRegularColumn("v", Int32Type.instance)
+                                             .build();
+
+        ByteBuffer one = Int32Type.instance.decompose(1);
+        ByteBuffer two = Int32Type.instance.decompose(2);
+        PartitionUpdate p = new PartitionUpdate(table, table.decorateKey(one), table.partitionColumns(), 0);
+        p.add(new RangeTombstone(Slice.make(new Slice.Bound(ClusteringPrefix.Kind.EXCL_START_BOUND, new ByteBuffer[] { one, one }),
+                                            new Slice.Bound(ClusteringPrefix.Kind.INCL_END_BOUND, new ByteBuffer[] { two })),
+                                 new DeletionTime(1, 1)
+        ));
+
+        LegacyLayout.fromUnfilteredRowIterator(null, p.unfilteredIterator());
+        LegacyLayout.serializedSizeAsLegacyPartition(null, p.unfilteredIterator(), VERSION_21);
+    }
+
 }
\ No newline at end of file
