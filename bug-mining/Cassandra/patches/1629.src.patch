diff --git a/CHANGES.txt b/CHANGES.txt
index bc2bf6688f..c7e3207946 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,6 @@
 1.1.1-dev
+ * preserve commitlog size cap when recycling segments at startup
+   (CASSANDRA-4201)
  * (Hadoop) fix split generation regression (CASSANDRA-4259)
  * ignore min/max compactions settings in LCS, while preserving
    behavior that min=max=0 disables autocompaction (CASSANDRA-4233)
diff --git a/src/java/org/apache/cassandra/db/commitlog/CommitLogAllocator.java b/src/java/org/apache/cassandra/db/commitlog/CommitLogAllocator.java
index 153140ba06..5d8636dd3f 100644
--- a/src/java/org/apache/cassandra/db/commitlog/CommitLogAllocator.java
+++ b/src/java/org/apache/cassandra/db/commitlog/CommitLogAllocator.java
@@ -180,8 +180,10 @@ public class CommitLogAllocator
         // check against SEGMENT_SIZE avoids recycling odd-sized or empty segments from old C* versions and unit tests
         if (isCapExceeded() || file.length() != DatabaseDescriptor.getCommitLogSegmentSize())
         {
+            // (don't decrease managed size, since this was never a "live" segment)
             try
             {
+                logger.debug("(Unopened) segment {} is no longer needed and will be deleted now", file);
                 FileUtils.deleteWithConfirm(file);
             }
             catch (IOException e)
@@ -191,6 +193,9 @@ public class CommitLogAllocator
             return;
         }
 
+        logger.debug("Recycling {}", file);
+        // this wasn't previously a live segment, so add it to the managed size when we make it live
+        size.addAndGet(DatabaseDescriptor.getCommitLogSegmentSize());
         queue.add(new Runnable()
         {
             public void run()
