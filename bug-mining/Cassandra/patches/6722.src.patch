diff --git a/modules/accord b/modules/accord
index 9c9d6b2f75..f543851dff 160000
--- a/modules/accord
+++ b/modules/accord
@@ -1 +1 @@
-Subproject commit 9c9d6b2f75b99351a3019381a166ed596f6ddc99
+Subproject commit f543851dffbf2907580f91608be3c1aadc4ccb95
diff --git a/src/java/org/apache/cassandra/dht/AccordSplitter.java b/src/java/org/apache/cassandra/dht/AccordSplitter.java
index 916e479679..f36decfc82 100644
--- a/src/java/org/apache/cassandra/dht/AccordSplitter.java
+++ b/src/java/org/apache/cassandra/dht/AccordSplitter.java
@@ -57,8 +57,8 @@ public abstract class AccordSplitter implements ShardDistributor.EvenSplit.Split
         BigInteger sizeOfRange = end.subtract(start);
 
         TableId tableId = startBound.table();
-        return new TokenRange(startOffset.equals(ZERO) ? startBound : new TokenKey(tableId, tokenForValue(start.add(startOffset))),
-                              endOffset.compareTo(sizeOfRange) >= 0 ? endBound : new TokenKey(tableId, tokenForValue(start.add(endOffset))));
+        return TokenRange.create(startOffset.equals(ZERO) ? startBound : new TokenKey(tableId, tokenForValue(start.add(startOffset))),
+                                 endOffset.compareTo(sizeOfRange) >= 0 ? endBound : new TokenKey(tableId, tokenForValue(start.add(endOffset))));
     }
 
     @Override
diff --git a/src/java/org/apache/cassandra/net/Verb.java b/src/java/org/apache/cassandra/net/Verb.java
index bb1c3b61ee..fb2271dd1b 100644
--- a/src/java/org/apache/cassandra/net/Verb.java
+++ b/src/java/org/apache/cassandra/net/Verb.java
@@ -97,6 +97,7 @@ import org.apache.cassandra.service.accord.serializers.CalculateDepsSerializers;
 import org.apache.cassandra.service.accord.serializers.GetEphmrlReadDepsSerializers;
 import org.apache.cassandra.service.accord.serializers.GetMaxConflictSerializers;
 import org.apache.cassandra.service.accord.serializers.InformDurableSerializers;
+import org.apache.cassandra.service.accord.serializers.LatestDepsSerializers;
 import org.apache.cassandra.service.accord.serializers.PreacceptSerializers;
 import org.apache.cassandra.service.accord.serializers.QueryDurableBeforeSerializers;
 import org.apache.cassandra.service.accord.serializers.ReadDataSerializers;
@@ -334,6 +335,8 @@ public enum Verb
     ACCORD_CHECK_STATUS_REQ         (142, P2, writeTimeout, IMMEDIATE,          () -> CheckStatusSerializers.request,       AccordService::requestHandlerOrNoop, ACCORD_CHECK_STATUS_RSP                   ),
     ACCORD_CALCULATE_DEPS_RSP       (143, P2, writeTimeout, IMMEDIATE,          () -> CalculateDepsSerializers.reply,       AccordService::responseHandlerOrNoop                                           ),
     ACCORD_CALCULATE_DEPS_REQ       (144, P2, longTimeout,  IMMEDIATE,          () -> CalculateDepsSerializers.request,     AccordService::requestHandlerOrNoop, ACCORD_CALCULATE_DEPS_RSP),
+    ACCORD_GET_LATEST_DEPS_RSP      (167, P2, writeTimeout, IMMEDIATE,          () -> LatestDepsSerializers.reply,          AccordService::responseHandlerOrNoop                                           ),
+    ACCORD_GET_LATEST_DEPS_REQ      (168, P2, writeTimeout, IMMEDIATE,          () -> LatestDepsSerializers.request,        AccordService::requestHandlerOrNoop, ACCORD_GET_LATEST_DEPS_RSP),
     ACCORD_GET_EPHMRL_READ_DEPS_RSP (161, P2, writeTimeout, IMMEDIATE,          () -> GetEphmrlReadDepsSerializers.reply,   AccordService::responseHandlerOrNoop                                           ),
     ACCORD_GET_EPHMRL_READ_DEPS_REQ (162, P2, writeTimeout, IMMEDIATE,          () -> GetEphmrlReadDepsSerializers.request, AccordService::requestHandlerOrNoop, ACCORD_GET_EPHMRL_READ_DEPS_RSP),
     ACCORD_GET_MAX_CONFLICT_RSP     (163, P2, writeTimeout, IMMEDIATE,          () -> GetMaxConflictSerializers.reply,      AccordService::responseHandlerOrNoop                                           ),
diff --git a/src/java/org/apache/cassandra/service/accord/AccordCache.java b/src/java/org/apache/cassandra/service/accord/AccordCache.java
index 614054c031..180b827531 100644
--- a/src/java/org/apache/cassandra/service/accord/AccordCache.java
+++ b/src/java/org/apache/cassandra/service/accord/AccordCache.java
@@ -43,6 +43,7 @@ import org.slf4j.LoggerFactory;
 import accord.api.RoutingKey;
 import accord.local.Command;
 import accord.local.cfk.CommandsForKey;
+import accord.local.cfk.Serialize;
 import accord.primitives.Routable;
 import accord.primitives.SaveStatus;
 import accord.primitives.Txn;
@@ -61,7 +62,6 @@ import org.apache.cassandra.metrics.AccordCacheMetrics;
 import org.apache.cassandra.metrics.CacheAccessMetrics;
 import org.apache.cassandra.service.accord.AccordCacheEntry.Status;
 import org.apache.cassandra.service.accord.events.CacheEvents;
-import org.apache.cassandra.service.accord.serializers.CommandsForKeySerializer;
 import org.apache.cassandra.utils.NoSpamLogger;
 import org.apache.cassandra.utils.NoSpamLogger.NoSpamLogStatement;
 import org.apache.cassandra.utils.ObjectSizes;
@@ -199,6 +199,7 @@ public class AccordCache implements CacheSize
             if (age >= entry.noEvictMaxAge())
             {
                 evictNoEvict.warn(entry, age, entry.noEvictMaxAge());
+                entry.unlink();
                 evict(entry, true);
             }
             else
@@ -1131,13 +1132,13 @@ public class AccordCache implements CacheSize
             if (value.isEmpty())
                 return null;
 
-            return CommandsForKeySerializer.toBytesWithoutKey(value.maximalPrune());
+            return Serialize.toBytesWithoutKey(value.maximalPrune());
         }
 
         @Override
         public CommandsForKey inflate(RoutingKey key, Object shrunk)
         {
-            return CommandsForKeySerializer.fromBytes(key, (ByteBuffer)shrunk);
+            return Serialize.fromBytes(key, (ByteBuffer)shrunk);
         }
 
         @Override
diff --git a/src/java/org/apache/cassandra/service/accord/AccordCacheEntry.java b/src/java/org/apache/cassandra/service/accord/AccordCacheEntry.java
index 011c1a37ba..4bfa4be308 100644
--- a/src/java/org/apache/cassandra/service/accord/AccordCacheEntry.java
+++ b/src/java/org/apache/cassandra/service/accord/AccordCacheEntry.java
@@ -246,9 +246,13 @@ public class AccordCacheEntry<K, V> extends IntrusiveLinkedListNode
     private void setStatus(Status newStatus)
     {
         Invariants.checkState((newStatus.permittedFrom & (1 << (status & STATUS_MASK))) != 0, "%s not permitted from %s", newStatus, status());
+        setStatusUnsafe(newStatus);
+    }
+
+    private void setStatusUnsafe(Status newStatus)
+    {
         status &= ~STATUS_MASK;
         status |= newStatus.ordinal();
-        Invariants.checkState(status() == newStatus);
     }
 
     public void initialize(V value)
@@ -507,7 +511,9 @@ public class AccordCacheEntry<K, V> extends IntrusiveLinkedListNode
 
     public AccordCacheEntry<K, V> evicted()
     {
-        setStatus(EVICTED);
+        if (isNoEvict())
+            setStatusUnsafe(EVICTED);
+        else setStatus(EVICTED);
         state = null;
         return this;
     }
diff --git a/src/java/org/apache/cassandra/service/accord/AccordCommandStore.java b/src/java/org/apache/cassandra/service/accord/AccordCommandStore.java
index 58a7af0f7a..b0185ad4ae 100644
--- a/src/java/org/apache/cassandra/service/accord/AccordCommandStore.java
+++ b/src/java/org/apache/cassandra/service/accord/AccordCommandStore.java
@@ -485,7 +485,7 @@ public class AccordCommandStore extends CommandStore
                     coordinateRanges = ranges.allAt(txnId.epoch());
                 }
                 if (addRanges.intersects(coordinateRanges)) continue;
-                addRanges = redundantBefore.removeShardRedundant(txnId, txnId, addRanges);
+                addRanges = redundantBefore.removeGcBefore(txnId, txnId, addRanges);
                 if (addRanges.isEmpty()) continue;
                 diskCommandsForRanges().mergeTransitive(txnId, addRanges, Ranges::with);
             }
@@ -576,7 +576,7 @@ public class AccordCommandStore extends CommandStore
             PreLoadContext context = context(command, KeyHistory.TIMESTAMPS);
             store.execute(context,
                           safeStore -> {
-                              applyWrites(command, safeStore, (safeCommand, cmd) -> {
+                              applyWrites(command.txnId(), safeStore, (safeCommand, cmd) -> {
                                   Commands.applyWrites(safeStore, context, cmd).begin(store.agent);
                               });
                           })
diff --git a/src/java/org/apache/cassandra/service/accord/AccordExecutor.java b/src/java/org/apache/cassandra/service/accord/AccordExecutor.java
index cc6e96364d..73962c3a9e 100644
--- a/src/java/org/apache/cassandra/service/accord/AccordExecutor.java
+++ b/src/java/org/apache/cassandra/service/accord/AccordExecutor.java
@@ -499,10 +499,10 @@ public abstract class AccordExecutor implements CacheSize, AccordCacheEntry.OnLo
                 task.cancelExclusive();
                 break;
 
+            case SCANNING_RANGES:
             case LOADING:
             case WAITING_TO_LOAD:
             case WAITING_TO_SCAN_RANGES:
-            case SCANNING_RANGES:
             case WAITING_TO_RUN:
                 --tasks;
                 task.unqueueIfQueued();
diff --git a/src/java/org/apache/cassandra/service/accord/AccordExecutorAbstractLockLoop.java b/src/java/org/apache/cassandra/service/accord/AccordExecutorAbstractLockLoop.java
index 176470f113..323929e2c1 100644
--- a/src/java/org/apache/cassandra/service/accord/AccordExecutorAbstractLockLoop.java
+++ b/src/java/org/apache/cassandra/service/accord/AccordExecutorAbstractLockLoop.java
@@ -114,17 +114,18 @@ abstract class AccordExecutorAbstractLockLoop extends AccordExecutor
 
     private void exitLockExclusive()
     {
-        isHeldByExecutor = false;
         notifyIfMoreWorkExclusive();
     }
 
     private void pauseExclusive()
     {
+        isHeldByExecutor = false;
         --running;
     }
 
     private void resumeExclusive()
     {
+        isHeldByExecutor = true;
         ++running;
     }
 
diff --git a/src/java/org/apache/cassandra/service/accord/AccordKeyspace.java b/src/java/org/apache/cassandra/service/accord/AccordKeyspace.java
index c6a396e052..d7587c462f 100644
--- a/src/java/org/apache/cassandra/service/accord/AccordKeyspace.java
+++ b/src/java/org/apache/cassandra/service/accord/AccordKeyspace.java
@@ -49,6 +49,7 @@ import accord.local.Node;
 import accord.local.RedundantBefore;
 import accord.local.StoreParticipants;
 import accord.local.cfk.CommandsForKey;
+import accord.local.cfk.Serialize;
 import accord.primitives.Ranges;
 import accord.primitives.Route;
 import accord.primitives.SaveStatus;
@@ -137,7 +138,6 @@ import org.apache.cassandra.service.accord.api.AccordRoutingKey;
 import org.apache.cassandra.service.accord.api.AccordRoutingKey.TokenKey;
 import org.apache.cassandra.service.accord.serializers.AccordRoutingKeyByteSource;
 import org.apache.cassandra.service.accord.serializers.CommandSerializers;
-import org.apache.cassandra.service.accord.serializers.CommandsForKeySerializer;
 import org.apache.cassandra.service.accord.serializers.KeySerializers;
 import org.apache.cassandra.tcm.ClusterMetadata;
 import org.apache.cassandra.utils.Clock.Global;
@@ -677,7 +677,7 @@ public class AccordKeyspace
             if (cell == null)
                 return null;
 
-            return CommandsForKeySerializer.fromBytes(key, cell.buffer());
+            return Serialize.fromBytes(key, cell.buffer());
         }
 
         @VisibleForTesting
@@ -695,7 +695,7 @@ public class AccordKeyspace
             if (cell == null)
                 return row;
 
-            CommandsForKey current = CommandsForKeySerializer.fromBytes(key, cell.buffer());
+            CommandsForKey current = Serialize.fromBytes(key, cell.buffer());
             if (current == null)
                 return null;
 
@@ -706,7 +706,7 @@ public class AccordKeyspace
             if (updated.size() == 0)
                 return null;
 
-            ByteBuffer buffer = CommandsForKeySerializer.toBytesWithoutKey(updated);
+            ByteBuffer buffer = Serialize.toBytesWithoutKey(updated);
             return BTreeRow.singleCellRow(Clustering.EMPTY, BufferCell.live(data, cell.timestamp(), buffer));
         }
 
@@ -1244,7 +1244,7 @@ public class AccordKeyspace
     {
         ByteBuffer bytes;
         if (serialized instanceof ByteBuffer) bytes = (ByteBuffer) serialized;
-        else bytes = CommandsForKeySerializer.toBytesWithoutKey(commandsForKey);
+        else bytes = Serialize.toBytesWithoutKey(commandsForKey);
         return getCommandsForKeyPartitionUpdate(storeId, key, timestampMicros, bytes);
     }
 
@@ -1318,7 +1318,7 @@ public class AccordKeyspace
                 Invariants.checkState(partition.hasNext());
                 Row row = partition.next();
                 ByteBuffer data = cellValue(row, accessor.data);
-                return CommandsForKeySerializer.fromBytes(key, data);
+                return Serialize.fromBytes(key, data);
             }
         }
         catch (Throwable t)
diff --git a/src/java/org/apache/cassandra/service/accord/AccordMessageSink.java b/src/java/org/apache/cassandra/service/accord/AccordMessageSink.java
index 8ffbb3ccb3..cff8ca2d96 100644
--- a/src/java/org/apache/cassandra/service/accord/AccordMessageSink.java
+++ b/src/java/org/apache/cassandra/service/accord/AccordMessageSink.java
@@ -137,6 +137,8 @@ public class AccordMessageSink implements MessageSink
             builder.put(MessageType.ACCEPT_INVALIDATE_REQ,                    Verb.ACCORD_ACCEPT_INVALIDATE_REQ);
             builder.put(MessageType.CALCULATE_DEPS_REQ,                       Verb.ACCORD_CALCULATE_DEPS_REQ);
             builder.put(MessageType.CALCULATE_DEPS_RSP,                       Verb.ACCORD_CALCULATE_DEPS_RSP);
+            builder.put(MessageType.GET_LATEST_DEPS_REQ,                      Verb.ACCORD_GET_LATEST_DEPS_REQ);
+            builder.put(MessageType.GET_LATEST_DEPS_RSP,                      Verb.ACCORD_GET_LATEST_DEPS_RSP);
             builder.put(MessageType.GET_EPHEMERAL_READ_DEPS_REQ,              Verb.ACCORD_GET_EPHMRL_READ_DEPS_REQ);
             builder.put(MessageType.GET_EPHEMERAL_READ_DEPS_RSP,              Verb.ACCORD_GET_EPHMRL_READ_DEPS_RSP);
             builder.put(MessageType.GET_MAX_CONFLICT_REQ,                     Verb.ACCORD_GET_MAX_CONFLICT_REQ);
diff --git a/src/java/org/apache/cassandra/service/accord/AccordObjectSizes.java b/src/java/org/apache/cassandra/service/accord/AccordObjectSizes.java
index e8c697fbe8..280ba08036 100644
--- a/src/java/org/apache/cassandra/service/accord/AccordObjectSizes.java
+++ b/src/java/org/apache/cassandra/service/accord/AccordObjectSizes.java
@@ -274,11 +274,11 @@ public class AccordObjectSizes
         private final static TokenKey EMPTY_KEY = new TokenKey(EMPTY_ID, null);
         private final static TxnId EMPTY_TXNID = new TxnId(42, 42, Kind.Read, Domain.Key, new Node.Id(42));
 
-        private static CommonAttributes attrs(boolean hasDeps, boolean hasTxn)
+        private static CommonAttributes attrs(boolean hasDeps, boolean hasTxn, boolean executes)
         {
             FullKeyRoute route = new FullKeyRoute(EMPTY_KEY, new RoutingKey[]{ EMPTY_KEY });
             CommonAttributes.Mutable attrs = new CommonAttributes.Mutable(EMPTY_TXNID)
-                                             .setParticipants(StoreParticipants.empty(EMPTY_TXNID, route));
+                                             .setParticipants(StoreParticipants.empty(EMPTY_TXNID, route, !executes));
             attrs.durability(Status.Durability.NotDurable);
             if (hasDeps)
                 attrs.partialDeps(PartialDeps.NONE);
@@ -292,12 +292,12 @@ public class AccordObjectSizes
         private static final Writes EMPTY_WRITES = new Writes(EMPTY_TXNID, EMPTY_TXNID, Keys.EMPTY, (key, safeStore, txnId, executeAt, store, txn) -> null);
         private static final Result EMPTY_RESULT = new Result() {};
 
-        final static long NOT_DEFINED = measure(Command.SerializerSupport.notDefined(attrs(false, false), Ballot.ZERO));
-        final static long PREACCEPTED = measure(Command.SerializerSupport.preaccepted(attrs(false, true), EMPTY_TXNID, Ballot.ZERO));;
-        final static long ACCEPTED = measure(Command.SerializerSupport.accepted(attrs(true, false), SaveStatus.Accepted, EMPTY_TXNID, Ballot.ZERO, Ballot.ZERO));
-        final static long COMMITTED = measure(Command.SerializerSupport.committed(attrs(true, true), SaveStatus.Committed, EMPTY_TXNID, Ballot.ZERO, Ballot.ZERO, null));
-        final static long EXECUTED = measure(Command.SerializerSupport.executed(attrs(true, true), SaveStatus.Applied, EMPTY_TXNID, Ballot.ZERO, Ballot.ZERO, WaitingOn.empty(Domain.Key), EMPTY_WRITES, ResultSerializers.APPLIED));
-        final static long TRUNCATED = measure(Command.SerializerSupport.truncatedApply(attrs(false, false), SaveStatus.TruncatedApply,  EMPTY_TXNID, null, null));
+        final static long NOT_DEFINED = measure(Command.SerializerSupport.notDefined(attrs(false, false, false), Ballot.ZERO));
+        final static long PREACCEPTED = measure(Command.SerializerSupport.preaccepted(attrs(false, true, false), EMPTY_TXNID, Ballot.ZERO));;
+        final static long ACCEPTED = measure(Command.SerializerSupport.accepted(attrs(true, false, false), SaveStatus.Accepted, EMPTY_TXNID, Ballot.ZERO, Ballot.ZERO));
+        final static long COMMITTED = measure(Command.SerializerSupport.committed(attrs(true, true, false), SaveStatus.Committed, EMPTY_TXNID, Ballot.ZERO, Ballot.ZERO, null));
+        final static long EXECUTED = measure(Command.SerializerSupport.executed(attrs(true, true, true), SaveStatus.Applied, EMPTY_TXNID, Ballot.ZERO, Ballot.ZERO, WaitingOn.empty(Domain.Key), EMPTY_WRITES, ResultSerializers.APPLIED));
+        final static long TRUNCATED = measure(Command.SerializerSupport.truncatedApply(attrs(false, false, false), SaveStatus.TruncatedApply,  EMPTY_TXNID, null, null));
         final static long INVALIDATED = measure(Command.SerializerSupport.invalidated(EMPTY_TXNID));
 
         private static long emptySize(Command command)
@@ -370,7 +370,7 @@ public class AccordObjectSizes
 
     private static long EMPTY_CFK_SIZE = measure(new CommandsForKey(null));
     private static long EMPTY_INFO_SIZE = measure(CommandsForKey.NO_INFO);
-    private static long EMPTY_INFO_EXTRA_ADDITIONAL_SIZE = measure(TxnInfo.create(TxnId.NONE, ACCEPTED, false, TxnId.NONE, NO_TXNIDS, Ballot.MAX)) - EMPTY_INFO_SIZE;
+    private static long EMPTY_INFO_EXTRA_ADDITIONAL_SIZE = measure(TxnInfo.create(TxnId.NONE, ACCEPTED, false, false, TxnId.NONE, NO_TXNIDS, Ballot.MAX)) - EMPTY_INFO_SIZE;
     public static long commandsForKey(CommandsForKey cfk)
     {
         long size = EMPTY_CFK_SIZE;
diff --git a/src/java/org/apache/cassandra/service/accord/AccordSafeCommandStore.java b/src/java/org/apache/cassandra/service/accord/AccordSafeCommandStore.java
index a05a3c7929..ddaacc4241 100644
--- a/src/java/org/apache/cassandra/service/accord/AccordSafeCommandStore.java
+++ b/src/java/org/apache/cassandra/service/accord/AccordSafeCommandStore.java
@@ -21,7 +21,7 @@ package org.apache.cassandra.service.accord;
 import java.util.Collections;
 import java.util.Map;
 import java.util.Set;
-import java.util.function.BiFunction;
+import java.util.function.Predicate;
 import javax.annotation.Nullable;
 
 import com.google.common.annotations.VisibleForTesting;
@@ -31,17 +31,14 @@ import accord.api.DataStore;
 import accord.api.ProgressLog;
 import accord.api.RoutingKey;
 import accord.impl.AbstractSafeCommandStore;
-import accord.impl.CommandsSummary;
 import accord.local.CommandStores;
 import accord.local.NodeCommandStoreService;
 import accord.local.cfk.CommandsForKey;
-import accord.primitives.AbstractKeys;
-import accord.primitives.Routables;
+import accord.local.cfk.SafeCommandsForKey;
 import accord.primitives.Timestamp;
 import accord.primitives.Txn;
 import accord.primitives.TxnId;
 import accord.primitives.Unseekables;
-import accord.utils.Invariants;
 import org.apache.cassandra.service.accord.AccordCommandStore.ExclusiveCaches;
 
 import static accord.utils.Invariants.illegalState;
@@ -197,75 +194,38 @@ public class AccordSafeCommandStore extends AbstractSafeCommandStore<AccordSafeC
         return commandStore.node();
     }
 
-    private <O> O mapReduce(Routables<?> keysOrRanges, BiFunction<CommandsSummary, O, O> map, O accumulate)
+    private boolean visitForKey(Unseekables<?> keysOrRanges, Predicate<CommandsForKey> forEach)
     {
-        Invariants.checkState(context.keys().containsAll(keysOrRanges), "Attempted to access keysOrRanges outside of what was asked for; asked for %s, accessed %s", context.keys(), keysOrRanges);
-        accumulate = mapReduceForRange(keysOrRanges, map, accumulate);
-        return mapReduceForKey(keysOrRanges, map, accumulate);
-    }
-
-    private <O> O mapReduceForRange(Routables<?> keysOrRanges, BiFunction<CommandsSummary, O, O> map, O accumulate)
-    {
-        if (commandsForRanges == null)
-            return accumulate;
-
-        return map.apply(commandsForRanges, accumulate);
-    }
+        Map<RoutingKey, AccordSafeCommandsForKey> commandsForKey = task.commandsForKey;
+        if (commandsForKey == null)
+            return true;
 
-    private <O> O mapReduceForKey(Routables<?> keysOrRanges, BiFunction<CommandsSummary, O, O> map, O accumulate)
-    {
-        switch (keysOrRanges.domain())
+        Unseekables<?> skip = context.keys().without(keysOrRanges);
+        for (SafeCommandsForKey safeCfk : commandsForKey.values())
         {
-            default:
-                throw new AssertionError("Unknown domain: " + keysOrRanges.domain());
-            case Key:
-            {
-                // TODO: efficiency
-                AbstractKeys<RoutingKey> keys = (AbstractKeys<RoutingKey>) keysOrRanges;
-                for (RoutingKey key : keys)
-                {
-                    CommandsForKey commands = get(key).current();
-                    accumulate = map.apply(commands, accumulate);
-                }
-            }
-            break;
-            case Range:
-            {
-                // Assuming the range provided is in the PreLoadContext, then AsyncLoader has populated commandsForKeys with keys that
-                // are contained within the ranges... so walk all keys found in commandsForKeys
-                if (!context.keys().containsAll(keysOrRanges))
-                    throw new AssertionError("Range(s) detected not present in the PreLoadContext: expected " + context.keys() + " but given " + keysOrRanges);
-
-                Map<RoutingKey, AccordSafeCommandsForKey> commandsForKey = task.commandsForKey();
-                if (commandsForKey == null)
-                    break;
+            if (skip.contains(safeCfk.key()))
+                continue;
 
-                for (RoutingKey key : commandsForKey.keySet())
-                {
-                    //TODO (duplicate code): this is a repeat of Key... only change is checking contains in range
-                    CommandsForKey commands = get(key).current();
-                    accumulate = map.apply(commands, accumulate);
-                }
-            }
-            break;
+            if (!forEach.test(safeCfk.current()))
+                return false;
         }
-        return accumulate;
+        return true;
     }
 
     @Override
-    public <P1, T> T mapReduceActive(Unseekables<?> keysOrRanges, @Nullable Timestamp withLowerTxnId, Txn.Kind.Kinds testKind, CommandFunction<P1, T, T> map, P1 p1, T accumulate)
+    public <P1, P2> void visit(Unseekables<?> keysOrRanges, Timestamp startedBefore, Txn.Kind.Kinds testKind, ActiveCommandVisitor<P1, P2> visitor, P1 p1, P2 p2)
     {
-        return mapReduce(keysOrRanges, (summary, in) -> {
-            return summary.mapReduceActive(keysOrRanges, withLowerTxnId, testKind, map, p1, in);
-        }, accumulate);
+        visitForKey(keysOrRanges, cfk -> { cfk.visit(startedBefore, testKind, visitor, p1, p2); return true; });
+        if (commandsForRanges != null)
+            commandsForRanges.visit(keysOrRanges, startedBefore, testKind, visitor, p1, p2);
     }
 
+    // TODO (expected): instead of accepting a slice, accept the min/max epoch and let implementation handle it
     @Override
-    public <P1, T> T mapReduceFull(Unseekables<?> keysOrRanges, TxnId testTxnId, Txn.Kind.Kinds testKind, TestStartedAt testStartedAt, TestDep testDep, TestStatus testStatus, CommandFunction<P1, T, T> map, P1 p1, T accumulate)
+    public boolean visit(Unseekables<?> keysOrRanges, TxnId testTxnId, Txn.Kind.Kinds testKind, TestStartedAt testStartedAt, Timestamp testStartedAtTimestamp, ComputeIsDep computeIsDep, AllCommandVisitor visit)
     {
-        return mapReduce(keysOrRanges, (summary, in) -> {
-            return summary.mapReduceFull(keysOrRanges, testTxnId, testKind, testStartedAt, testDep, testStatus, map, p1, in);
-        }, accumulate);
+        return visitForKey(keysOrRanges, cfk -> cfk.visit(testTxnId, testKind, testStartedAt, testStartedAtTimestamp, computeIsDep, null, visit))
+               && (commandsForRanges == null || commandsForRanges.visit(keysOrRanges, testTxnId, testKind, testStartedAt, testStartedAtTimestamp, computeIsDep, visit));
     }
 
     @Override
diff --git a/src/java/org/apache/cassandra/service/accord/AccordService.java b/src/java/org/apache/cassandra/service/accord/AccordService.java
index 4252c8b3cf..63fe397cc4 100644
--- a/src/java/org/apache/cassandra/service/accord/AccordService.java
+++ b/src/java/org/apache/cassandra/service/accord/AccordService.java
@@ -1390,9 +1390,7 @@ public class AccordService implements IAccordService, Shutdownable
         return RetryDecission.FAIL;
     }
 
-    // TODO (duplication): this is 95% of accord.coordinate.CoordinateShardDurable
-    //   we already report all this information to EpochState; would be better to use that
-    //   Taken from ListStore...
+    // TODO (required): this should use ExecuteSyncPoint.ExecuteExclusive, or perhaps should not exist at all (should have some mechanism to request and await durability)
     private static class Await extends AsyncResults.SettableResult<SyncPoint<?>> implements Callback<ReadData.ReadReply>
     {
         private final Node node;
@@ -1401,7 +1399,7 @@ public class AccordService implements IAccordService, Shutdownable
 
         private Await(Node node, SyncPoint<?> exclusiveSyncPoint)
         {
-            Topologies topologies = node.topology().forEpoch(exclusiveSyncPoint.route, exclusiveSyncPoint.sourceEpoch());
+            Topologies topologies = node.topology().forEpoch(exclusiveSyncPoint.route, exclusiveSyncPoint.syncId.epoch());
             this.node = node;
             this.tracker = new AllTracker(topologies);
             this.exclusiveSyncPoint = exclusiveSyncPoint;
@@ -1409,7 +1407,7 @@ public class AccordService implements IAccordService, Shutdownable
 
         public static AsyncChain<Void> coordinate(Node node, SyncPoint<?> sp)
         {
-            return node.withEpoch(sp.sourceEpoch(), () -> {
+            return node.withEpoch(sp.syncId.epoch(), () -> {
                 Await coordinate = new Await(node, sp);
                 coordinate.start();
                 AsyncChain<Void> chain = coordinate.map(i -> null);
diff --git a/src/java/org/apache/cassandra/service/accord/AccordTask.java b/src/java/org/apache/cassandra/service/accord/AccordTask.java
index c3969bdc19..d9632efd2d 100644
--- a/src/java/org/apache/cassandra/service/accord/AccordTask.java
+++ b/src/java/org/apache/cassandra/service/accord/AccordTask.java
@@ -1086,7 +1086,7 @@ public abstract class AccordTask<R> extends Task implements Runnable, Function<S
             @Override
             public void onUpdate(AccordCacheEntry<TxnId, Command> state)
             {
-                CommandsForRanges.Summary summary = summaryLoader.from(state);
+                CommandsForRanges.Summary summary = summaryLoader.ifRelevant(state);
                 if (summary != null)
                     summaries.put(summary.txnId, summary);
             }
diff --git a/src/java/org/apache/cassandra/service/accord/AccordTopology.java b/src/java/org/apache/cassandra/service/accord/AccordTopology.java
index d9ebc6db17..db89c4fda7 100644
--- a/src/java/org/apache/cassandra/service/accord/AccordTopology.java
+++ b/src/java/org/apache/cassandra/service/accord/AccordTopology.java
@@ -206,24 +206,24 @@ public class AccordTopology
 
     static TokenRange minRange(TableId table, Token token)
     {
-        return new TokenRange(SentinelKey.min(table), new TokenKey(table, token));
+        return TokenRange.create(SentinelKey.min(table), new TokenKey(table, token));
     }
 
     static TokenRange maxRange(TableId table, Token token)
     {
-        return new TokenRange(new TokenKey(table, token), SentinelKey.max(table));
+        return TokenRange.create(new TokenKey(table, token), SentinelKey.max(table));
     }
 
     static TokenRange fullRange(TableId table)
     {
-        return new TokenRange(SentinelKey.min(table), SentinelKey.max(table));
+        return TokenRange.create(SentinelKey.min(table), SentinelKey.max(table));
     }
 
     static TokenRange range(TableId table, Range<Token> range)
     {
         Token minToken = range.left.minValue();
-        return new TokenRange(range.left.equals(minToken) ? SentinelKey.min(table) : new TokenKey(table, range.left),
-                              range.right.equals(minToken) ? SentinelKey.max(table) : new TokenKey(table, range.right));
+        return TokenRange.create(range.left.equals(minToken) ? SentinelKey.min(table) : new TokenKey(table, range.left),
+                                 range.right.equals(minToken) ? SentinelKey.max(table) : new TokenKey(table, range.right));
     }
 
     public static accord.primitives.Ranges toAccordRanges(TableId tableId, Collection<Range<Token>> ranges)
diff --git a/src/java/org/apache/cassandra/service/accord/CommandsForRanges.java b/src/java/org/apache/cassandra/service/accord/CommandsForRanges.java
index 2bae3b6c94..6cb31f9895 100644
--- a/src/java/org/apache/cassandra/service/accord/CommandsForRanges.java
+++ b/src/java/org/apache/cassandra/service/accord/CommandsForRanges.java
@@ -18,36 +18,23 @@
 
 package org.apache.cassandra.service.accord;
 
-import java.util.ArrayList;
 import java.util.Iterator;
-import java.util.List;
 import java.util.Map;
 import java.util.NavigableMap;
 import java.util.TreeMap;
 import java.util.function.BiFunction;
 import java.util.function.Consumer;
-import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
 
-import com.google.common.annotations.VisibleForTesting;
-
-import accord.impl.CommandsSummary;
 import accord.local.Command;
+import accord.local.CommandSummaries;
+import accord.local.CommandSummaries.Summary;
 import accord.local.KeyHistory;
 import accord.local.RedundantBefore;
-import accord.local.SafeCommandStore.CommandFunction;
-import accord.local.SafeCommandStore.TestDep;
-import accord.local.SafeCommandStore.TestStartedAt;
-import accord.local.SafeCommandStore.TestStatus;
-import accord.local.StoreParticipants;
-import accord.primitives.PartialDeps;
-import accord.primitives.Range;
 import accord.primitives.Ranges;
 import accord.primitives.Routable;
-import accord.primitives.Routables;
-import accord.primitives.SaveStatus;
 import accord.primitives.Timestamp;
-import accord.primitives.Txn;
+import accord.primitives.Txn.Kind.Kinds;
 import accord.primitives.TxnId;
 import accord.primitives.Unseekable;
 import accord.primitives.Unseekables;
@@ -56,16 +43,10 @@ import org.agrona.collections.ObjectHashSet;
 import org.apache.cassandra.index.accord.RoutesSearcher;
 import org.apache.cassandra.service.accord.api.AccordRoutingKey;
 
-import static accord.local.SafeCommandStore.TestDep.ANY_DEPS;
-import static accord.local.SafeCommandStore.TestDep.WITH_OR_INVALIDATED;
-import static accord.local.SafeCommandStore.TestStartedAt.STARTED_BEFORE;
-import static accord.local.SafeCommandStore.TestStatus.ANY_STATUS;
-import static accord.primitives.Routables.Slice.Minimal;
-import static accord.primitives.Status.Stable;
-import static accord.primitives.Status.Truncated;
-import static accord.primitives.Txn.Kind.ExclusiveSyncPoint;
+import static accord.local.CommandSummaries.SummaryStatus.NOT_ACCEPTED;
 
-public class CommandsForRanges extends TreeMap<Timestamp, CommandsForRanges.Summary> implements CommandsSummary
+// TODO (required): move to accord-core, merge with existing logic there
+public class CommandsForRanges extends TreeMap<Timestamp, Summary> implements CommandSummaries.Snapshot
 {
     public CommandsForRanges(Map<? extends Timestamp, ? extends Summary> m)
     {
@@ -73,148 +54,9 @@ public class CommandsForRanges extends TreeMap<Timestamp, CommandsForRanges.Summ
     }
 
     @Override
-    public <P1, T> T mapReduceFull(Routables<?> keysOrRanges, TxnId testTxnId, Txn.Kind.Kinds testKind, TestStartedAt testStartedAt, TestDep testDep, TestStatus testStatus, CommandFunction<P1, T, T> map, P1 p1, T accumulate)
-    {
-        return mapReduce(keysOrRanges, testTxnId, testTxnId, testKind, testStartedAt, testDep, testStatus, map, p1, accumulate);
-    }
-
-    @Override
-    public <P1, T> T mapReduceActive(Routables<?> keysOrRanges, Timestamp startedBefore, Txn.Kind.Kinds testKind, CommandFunction<P1, T, T> map, P1 p1, T accumulate)
-    {
-        return mapReduce(keysOrRanges, startedBefore, null, testKind, STARTED_BEFORE, ANY_DEPS, ANY_STATUS, map, p1, accumulate);
-    }
-
-    private <P1, T> T mapReduce(Routables<?> keysOrRanges, @Nonnull Timestamp testTimestamp, @Nullable TxnId testTxnId, Txn.Kind.Kinds testKind, TestStartedAt testStartedAt, TestDep testDep, TestStatus testStatus, CommandFunction<P1, T, T> map, P1 p1, T accumulate)
-    {
-        Map<Range, List<Summary>> collect = new TreeMap<>(Range::compare);
-        NavigableMap<Timestamp, Summary> submap;
-        switch (testStartedAt)
-        {
-            case STARTED_AFTER:
-                submap = tailMap(testTimestamp, false);
-                break;
-            case STARTED_BEFORE:
-                submap = headMap(testTimestamp, false);
-                break;
-            case ANY:
-                submap = this;
-                break;
-            default:
-                throw new AssertionError("Unknown started at: " + testStartedAt);
-        }
-        submap.values().forEach((summary -> {
-            if (!testKind.test(summary.txnId.kind()))
-                return;
-
-            // range specific logic... ranges don't update CommandsForRange based off the life cycle and instead
-            // merge the cache with the disk state; so exclude states that should get removed from CommandsFor*
-            if (summary.saveStatus != null && summary.saveStatus.compareTo(SaveStatus.Erased) >= 0)
-                return;
-
-            // TODO (expected): share this logic with InMemoryCommandsStore for improved BurnTest coverage
-            switch (testStatus)
-            {
-                default: throw new AssertionError("Unhandled TestStatus: " + testStatus);
-                case ANY_STATUS:
-                    break;
-                case IS_PROPOSED:
-                    switch (summary.saveStatus.status)
-                    {
-                        default: return;
-                        case PreCommitted:
-                        case Committed:
-                        case Accepted:
-                    }
-                    break;
-                case IS_STABLE:
-                    if (!summary.saveStatus.hasBeen(Stable) || summary.saveStatus.hasBeen(Truncated))
-                        return;
-                case IS_STABLE_OR_INVALIDATED:
-                    if (!summary.saveStatus.hasBeen(Stable) || summary.saveStatus.status == Truncated)
-                        return;
-            }
-
-            if (testDep != ANY_DEPS)
-            {
-                // ! status.hasInfo
-                //TODO (now, reuse): should this just check if known?
-                if (!(summary.saveStatus.compareTo(SaveStatus.Accepted) >= 0))
-                    return;
-
-                Timestamp executeAt = summary.executeAt;
-                if (executeAt.compareTo(testTxnId) <= 0)
-                    return;
-
-                // We are looking for transactions A that have (or have not) B as a dependency.
-                // If B covers ranges [1..3] and A covers [2..3], but the command store only covers ranges [1..2],
-                // we could have A adopt B as a dependency on [3..3] only, and have that A intersects B on this
-                // command store, but also that there is no dependency relation between them on the overlapping
-                // key range [2..2].
-
-                // This can lead to problems on recovery, where we believe a transaction is a dependency
-                // and so it is safe to execute, when in fact it is only a dependency on a different shard
-                // (and that other shard, perhaps, does not know that it is a dependency - and so it is not durably known)
-                // TODO (required): consider this some more
-                if ((testDep == WITH_OR_INVALIDATED) == (!summary.hasAsDep || summary.saveStatus == SaveStatus.Invalidated))
-                    return;
-
-                Invariants.checkState(testTxnId.equals(summary.findAsDep));
-            }
-
-            for (Range range : summary.ranges)
-            {
-                if (keysOrRanges.intersects(range))
-                    collect.computeIfAbsent(range, ignore -> new ArrayList<>()).add(summary);
-            }
-        }));
-
-        for (Map.Entry<Range, List<Summary>> e : collect.entrySet())
-        {
-            for (Summary command : e.getValue())
-                accumulate = map.apply(p1, e.getKey(), command.txnId, command.executeAt, accumulate);
-        }
-
-        return accumulate;
-    }
-
-    public static class Summary
+    public NavigableMap<Timestamp, CommandSummaries.Summary> byTxnId()
     {
-        public final @Nonnull TxnId txnId;
-        public final @Nonnull Timestamp executeAt;
-        public final @Nonnull SaveStatus saveStatus;
-        public final @Nonnull Ranges ranges;
-
-        public final TxnId findAsDep;
-        public final boolean hasAsDep;
-
-        @VisibleForTesting
-        Summary(@Nonnull TxnId txnId, @Nonnull Timestamp executeAt, @Nonnull SaveStatus saveStatus, @Nonnull Ranges ranges, TxnId findAsDep, boolean hasAsDep)
-        {
-            this.txnId = txnId;
-            this.executeAt = executeAt;
-            this.saveStatus = saveStatus;
-            this.ranges = ranges;
-            this.findAsDep = findAsDep;
-            this.hasAsDep = hasAsDep;
-        }
-
-        public Summary slice(Ranges slice)
-        {
-            return new Summary(txnId, executeAt, saveStatus, ranges.slice(slice, Minimal), findAsDep, hasAsDep);
-        }
-
-        @Override
-        public String toString()
-        {
-            return "Summary{" +
-                   "txnId=" + txnId +
-                   ", executeAt=" + executeAt +
-                   ", saveStatus=" + saveStatus +
-                   ", ranges=" + ranges +
-                   ", findAsDep=" + findAsDep +
-                   ", hasAsDep=" + hasAsDep +
-                   '}';
-        }
+        return this;
     }
 
     public static class Manager implements AccordCache.Listener<TxnId, Command>
@@ -252,10 +94,12 @@ public class CommandsForRanges extends TreeMap<Timestamp, CommandsForRanges.Summ
         public CommandsForRanges.Loader loader(@Nullable TxnId primaryTxnId, KeyHistory keyHistory, Unseekables<?> keysOrRanges)
         {
             RedundantBefore redundantBefore = commandStore.unsafeGetRedundantBefore();
-            TxnId minTxnId = redundantBefore.min(keysOrRanges, e -> e.gcBefore);
-            Timestamp maxTxnId = primaryTxnId == null || keyHistory == KeyHistory.RECOVER || !primaryTxnId.is(ExclusiveSyncPoint) ? Timestamp.MAX : primaryTxnId;
-            TxnId findAsDep = primaryTxnId != null && keyHistory == KeyHistory.RECOVER ? primaryTxnId : null;
-            return new CommandsForRanges.Loader(this, keysOrRanges, redundantBefore, minTxnId, maxTxnId, findAsDep);
+            return Loader.loader(redundantBefore, primaryTxnId, keyHistory, keysOrRanges, this::newLoader);
+        }
+
+        private Loader newLoader(Unseekables<?> searchKeysOrRanges, RedundantBefore redundantBefore, Kinds testKind, TxnId minTxnId, Timestamp maxTxnId, @Nullable TxnId findAsDep)
+        {
+            return new Loader(this, searchKeysOrRanges, redundantBefore, testKind, minTxnId, maxTxnId, findAsDep);
         }
 
         public void mergeTransitive(TxnId txnId, Ranges ranges, BiFunction<? super Ranges, ? super Ranges, ? extends Ranges> remappingFunction)
@@ -277,23 +121,14 @@ public class CommandsForRanges extends TreeMap<Timestamp, CommandsForRanges.Summ
         }
     }
 
-    public static class Loader
+    public static class Loader extends Summary.Loader
     {
         private final Manager manager;
-        final Unseekables<?> searchKeysOrRanges;
-        final RedundantBefore redundantBefore;
-        final TxnId minTxnId;
-        final Timestamp maxTxnId;
-        @Nullable final TxnId findAsDep;
 
-        public Loader(Manager manager, Unseekables<?> searchKeysOrRanges, RedundantBefore redundantBefore, TxnId minTxnId, Timestamp maxTxnId, @Nullable TxnId findAsDep)
+        public Loader(Manager manager, Unseekables<?> searchKeysOrRanges, RedundantBefore redundantBefore, Kinds testKinds, TxnId minTxnId, Timestamp maxTxnId, @Nullable TxnId findAsDep)
         {
+            super(searchKeysOrRanges, redundantBefore, testKinds, minTxnId, maxTxnId, findAsDep);
             this.manager = manager;
-            this.searchKeysOrRanges = searchKeysOrRanges;
-            this.redundantBefore = redundantBefore;
-            this.minTxnId = minTxnId;
-            this.maxTxnId = maxTxnId;
-            this.findAsDep = findAsDep;
         }
 
         public void intersects(Consumer<TxnId> forEach)
@@ -324,7 +159,7 @@ public class CommandsForRanges extends TreeMap<Timestamp, CommandsForRanges.Summ
             for (TxnId txnId : manager.cachedRangeTxns)
             {
                 AccordCacheEntry<TxnId, Command> state = caches.commands().getUnsafe(txnId);
-                Summary summary = from(state);
+                Summary summary = ifRelevant(state);
                 if (summary != null)
                     forEach.accept(summary);
             }
@@ -336,13 +171,13 @@ public class CommandsForRanges extends TreeMap<Timestamp, CommandsForRanges.Summ
             {
                 SavedCommand.MinimalCommand cmd = manager.commandStore.loadMinimal(txnId);
                 if (cmd != null)
-                    return from(cmd);
+                    return ifRelevant(cmd);
             }
             else
             {
                 Command cmd = manager.commandStore.loadCommand(txnId);
                 if (cmd != null)
-                    return from(cmd);
+                    return ifRelevant(cmd);
             }
 
             Ranges ranges = manager.transitive.get(txnId);
@@ -353,10 +188,10 @@ public class CommandsForRanges extends TreeMap<Timestamp, CommandsForRanges.Summ
             if (ranges.isEmpty())
                 return null;
 
-            return new Summary(txnId, txnId, SaveStatus.NotDefined, ranges, null, false);
+            return new Summary(txnId, txnId, NOT_ACCEPTED, ranges, null, null);
         }
 
-        public Summary from(AccordCacheEntry<TxnId, Command> state)
+        public Summary ifRelevant(AccordCacheEntry<TxnId, Command> state)
         {
             if (state.key().domain() != Routable.Domain.Range)
                 return null;
@@ -382,58 +217,18 @@ public class CommandsForRanges extends TreeMap<Timestamp, CommandsForRanges.Summ
             Command command = state.getExclusive();
             if (command == null)
                 return null;
-            return from(command);
+            return ifRelevant(command);
         }
 
-        public Summary from(Command cmd)
+        public Summary ifRelevant(Command cmd)
         {
-            return from(cmd.txnId(), cmd.executeAt(), cmd.saveStatus(), cmd.participants(), cmd.partialDeps());
+            return ifRelevant(cmd.txnId(), cmd.executeAt(), cmd.saveStatus(), cmd.participants(), cmd.partialDeps());
         }
 
-        public Summary from(SavedCommand.MinimalCommand cmd)
+        public Summary ifRelevant(SavedCommand.MinimalCommand cmd)
         {
             Invariants.checkState(findAsDep == null);
-            return from(cmd.txnId, cmd.executeAt, cmd.saveStatus, cmd.participants, null);
-        }
-
-        private Summary from(TxnId txnId, Timestamp executeAt, SaveStatus saveStatus, StoreParticipants participants, @Nullable PartialDeps partialDeps)
-        {
-            if (participants == null)
-                return null;
-
-            Ranges keysOrRanges = participants.touches().toRanges();
-            if (keysOrRanges.domain() != Routable.Domain.Range)
-                throw new AssertionError(String.format("Txn keys are not range for %s", participants));
-            Ranges ranges = keysOrRanges;
-
-            ranges = ranges.intersecting(searchKeysOrRanges, Minimal);
-            if (ranges.isEmpty())
-                return null;
-
-            if (redundantBefore != null)
-            {
-                Ranges newRanges = redundantBefore.foldlWithBounds(ranges, (e, accum, start, end) -> {
-                    if (e.shardAppliedOrInvalidatedBefore.compareTo(txnId) < 0)
-                        return accum;
-                    return accum.without(Ranges.of(new TokenRange((AccordRoutingKey) start, (AccordRoutingKey) end)));
-                }, ranges, ignore -> false);
-
-                if (newRanges.isEmpty())
-                    return null;
-
-                ranges = newRanges;
-            }
-
-            Invariants.checkState(partialDeps != null || findAsDep == null || !saveStatus.known.deps.hasProposedOrDecidedDeps());
-            boolean hasAsDep = false;
-            if (partialDeps != null)
-            {
-                Ranges depRanges = partialDeps.rangeDeps.ranges(txnId);
-                if (depRanges != null && depRanges.containsAll(ranges))
-                    hasAsDep = true;
-            }
-
-            return new Summary(txnId, executeAt, saveStatus, ranges, findAsDep, hasAsDep);
+            return ifRelevant(cmd.txnId, cmd.executeAt, cmd.saveStatus, cmd.participants, null);
         }
     }
 }
diff --git a/src/java/org/apache/cassandra/service/accord/SavedCommand.java b/src/java/org/apache/cassandra/service/accord/SavedCommand.java
index 24c50e573c..9e38e5158c 100644
--- a/src/java/org/apache/cassandra/service/accord/SavedCommand.java
+++ b/src/java/org/apache/cassandra/service/accord/SavedCommand.java
@@ -947,7 +947,7 @@ public class SavedCommand
                         return Command.Truncated.truncatedApply(attrs, status, executeAt, writes, result, executesAtLeast);
                     return Command.Truncated.truncatedApply(attrs, status, executeAt, writes, result, null);
                 case ErasedOrVestigial:
-                    return Command.Truncated.erasedOrInvalidOrVestigial(attrs.txnId(), attrs.durability(), attrs.participants());
+                    return Command.Truncated.erasedOrVestigial(attrs.txnId(), attrs.participants());
                 case Erased:
                     return Command.Truncated.erased(attrs.txnId(), attrs.durability(), attrs.participants());
                 case Invalidated:
diff --git a/src/java/org/apache/cassandra/service/accord/TokenRange.java b/src/java/org/apache/cassandra/service/accord/TokenRange.java
index afd6a22613..6db7696330 100644
--- a/src/java/org/apache/cassandra/service/accord/TokenRange.java
+++ b/src/java/org/apache/cassandra/service/accord/TokenRange.java
@@ -40,9 +40,19 @@ public class TokenRange extends Range.EndInclusive
     public TokenRange(AccordRoutingKey start, AccordRoutingKey end)
     {
         super(start, end);
+    }
+
+    public static TokenRange create(AccordRoutingKey start, AccordRoutingKey end)
+    {
         Invariants.checkArgument(start.table().equals(end.table()),
                                  "Token ranges cannot cover more than one keyspace start:%s, end:%s",
                                  start, end);
+        return new TokenRange(start, end);
+    }
+
+    public static TokenRange createUnsafe(AccordRoutingKey start, AccordRoutingKey end)
+    {
+        return new TokenRange(start, end);
     }
 
     public TableId table()
@@ -115,8 +125,8 @@ public class TokenRange extends Range.EndInclusive
         @Override
         public TokenRange deserialize(DataInputPlus in, int version) throws IOException
         {
-            return new TokenRange(AccordRoutingKey.serializer.deserialize(in, version),
-                                  AccordRoutingKey.serializer.deserialize(in, version));
+            return TokenRange.create(AccordRoutingKey.serializer.deserialize(in, version),
+                                     AccordRoutingKey.serializer.deserialize(in, version));
         }
 
         @Override
diff --git a/src/java/org/apache/cassandra/service/accord/api/AccordRoutingKey.java b/src/java/org/apache/cassandra/service/accord/api/AccordRoutingKey.java
index 6b542a8c49..ec89d77058 100644
--- a/src/java/org/apache/cassandra/service/accord/api/AccordRoutingKey.java
+++ b/src/java/org/apache/cassandra/service/accord/api/AccordRoutingKey.java
@@ -48,7 +48,7 @@ import org.apache.cassandra.utils.ObjectSizes;
 import static com.google.common.base.Preconditions.checkState;
 import static org.apache.cassandra.config.DatabaseDescriptor.getPartitioner;
 
-public abstract class AccordRoutingKey extends AccordRoutableKey implements RoutingKey
+public abstract class AccordRoutingKey extends AccordRoutableKey implements RoutingKey, RangeFactory
 {
     public enum RoutingKeyKind
     {
@@ -67,9 +67,22 @@ public abstract class AccordRoutingKey extends AccordRoutableKey implements Rout
     @Override
     public RangeFactory rangeFactory()
     {
-        return (s, e) -> new TokenRange((AccordRoutingKey) s, (AccordRoutingKey) e);
+        return this;
+    }
+
+    @Override
+    public Range newRange(RoutingKey start, RoutingKey end)
+    {
+        return TokenRange.create((AccordRoutingKey) start, (AccordRoutingKey) end);
     }
 
+    @Override
+    public Range newAntiRange(RoutingKey start, RoutingKey end)
+    {
+        return TokenRange.createUnsafe((AccordRoutingKey) start, (AccordRoutingKey) end);
+    }
+
+
     public SentinelKey asSentinelKey()
     {
         return (SentinelKey) this;
@@ -301,7 +314,7 @@ public abstract class AccordRoutingKey extends AccordRoutableKey implements Rout
                                       ? new SentinelKey(table, true, false)
                                       : new MinTokenKey(table, token);
 
-            return new TokenRange(before, this);
+            return TokenRange.create(before, this);
         }
 
         final Token token;
diff --git a/src/java/org/apache/cassandra/service/accord/interop/AccordInteropAdapter.java b/src/java/org/apache/cassandra/service/accord/interop/AccordInteropAdapter.java
index 14633cc4ae..574d962a96 100644
--- a/src/java/org/apache/cassandra/service/accord/interop/AccordInteropAdapter.java
+++ b/src/java/org/apache/cassandra/service/accord/interop/AccordInteropAdapter.java
@@ -64,9 +64,9 @@ public class AccordInteropAdapter extends AbstractTxnAdapter
         }
 
         @Override
-        public <R> CoordinationAdapter<R> get(TxnId txnId, Step step)
+        public <R> CoordinationAdapter<R> get(TxnId txnId, Kind step)
         {
-            return (CoordinationAdapter<R>) (step == Step.InitiateRecovery ? recovery : standard);
+            return (CoordinationAdapter<R>) (step == Kind.Recovery ? recovery : standard);
         }
     };
 
diff --git a/src/java/org/apache/cassandra/service/accord/interop/AccordInteropApply.java b/src/java/org/apache/cassandra/service/accord/interop/AccordInteropApply.java
index 44f54ab51d..6acf5cfc18 100644
--- a/src/java/org/apache/cassandra/service/accord/interop/AccordInteropApply.java
+++ b/src/java/org/apache/cassandra/service/accord/interop/AccordInteropApply.java
@@ -76,9 +76,9 @@ public class AccordInteropApply extends Apply implements LocalListeners.ComplexL
     public static final IVersionedSerializer<AccordInteropApply> serializer = new ApplySerializer<AccordInteropApply>()
     {
         @Override
-        protected AccordInteropApply deserializeApply(TxnId txnId, Route<?> scope, long waitForEpoch, Apply.Kind kind, Timestamp executeAt, PartialDeps deps, PartialTxn txn, @Nullable FullRoute<?> fullRoute, Writes writes, Result result)
+        protected AccordInteropApply deserializeApply(TxnId txnId, Route<?> scope, long minEpoch, long waitForEpoch, Apply.Kind kind, Timestamp executeAt, PartialDeps deps, PartialTxn txn, @Nullable FullRoute<?> fullRoute, Writes writes, Result result)
         {
-            return new AccordInteropApply(kind, txnId, scope, waitForEpoch, executeAt, deps, txn, fullRoute, writes, result);
+            return new AccordInteropApply(kind, txnId, scope, minEpoch, waitForEpoch, executeAt, deps, txn, fullRoute, writes, result);
         }
     };
 
@@ -86,9 +86,9 @@ public class AccordInteropApply extends Apply implements LocalListeners.ComplexL
     transient Int2ObjectHashMap<LocalListeners.Registered> listeners;
     boolean failed;
 
-    private AccordInteropApply(Kind kind, TxnId txnId, Route<?> route, long waitForEpoch, Timestamp executeAt, PartialDeps deps, @Nullable PartialTxn txn, @Nullable FullRoute<?> fullRoute, Writes writes, Result result)
+    private AccordInteropApply(Kind kind, TxnId txnId, Route<?> route, long minEpoch, long waitForEpoch, Timestamp executeAt, PartialDeps deps, @Nullable PartialTxn txn, @Nullable FullRoute<?> fullRoute, Writes writes, Result result)
     {
-        super(kind, txnId, route, waitForEpoch, executeAt, deps, txn, fullRoute, writes, result);
+        super(kind, txnId, route, minEpoch, waitForEpoch, executeAt, deps, txn, fullRoute, writes, result);
     }
 
     private AccordInteropApply(Kind kind, Id to, Topologies participates, TxnId txnId, Route<?> route, Txn txn, Timestamp executeAt, Deps deps, Writes writes, Result result, FullRoute<?> fullRoute)
diff --git a/src/java/org/apache/cassandra/service/accord/interop/AccordInteropExecution.java b/src/java/org/apache/cassandra/service/accord/interop/AccordInteropExecution.java
index 00bd8114d6..cf1a91e8be 100644
--- a/src/java/org/apache/cassandra/service/accord/interop/AccordInteropExecution.java
+++ b/src/java/org/apache/cassandra/service/accord/interop/AccordInteropExecution.java
@@ -98,7 +98,7 @@ import org.apache.cassandra.service.reads.ReadCoordinator;
 import org.apache.cassandra.tcm.ClusterMetadata;
 import org.apache.cassandra.transport.Dispatcher;
 
-import static accord.coordinate.CoordinationAdapter.Factory.Step.Continue;
+import static accord.coordinate.CoordinationAdapter.Factory.Kind.Standard;
 import static accord.utils.Invariants.checkArgument;
 import static org.apache.cassandra.metrics.ClientRequestsMetricsHolder.accordReadMetrics;
 import static org.apache.cassandra.metrics.ClientRequestsMetricsHolder.accordWriteMetrics;
@@ -191,8 +191,8 @@ public class AccordInteropExecution implements ReadCoordinator, MaximalCommitSen
         this.allTopologies = txnId.epoch() != executeAt.epoch()
                              ? node.topology().preciseEpochs(route, txnId.epoch(), executeAt.epoch())
                              : executes;
-        this.executeTopology = executes.forEpoch(executeAt.epoch());
-        this.coordinateTopology = allTopologies.forEpoch(txnId.epoch());
+        this.executeTopology = executes.getEpoch(executeAt.epoch());
+        this.coordinateTopology = allTopologies.getEpoch(txnId.epoch());
         if (consistencyLevel != ConsistencyLevel.ALL)
         {
             readsCurrentlyUnderConstruction = new AtomicInteger(txn.read().keys().size());
@@ -406,7 +406,7 @@ public class AccordInteropExecution implements ReadCoordinator, MaximalCommitSen
         CommandStore cs = node.commandStores().select(route.homeKey());
         result.beginAsResult().withExecutor(cs).begin((data, failure) -> {
             if (failure == null)
-                ((CoordinationAdapter)node.coordinationAdapter(txnId, Continue)).persist(node, executes, route, txnId, txn, executeAt, deps, txn.execute(txnId, executeAt, data), txn.result(txnId, executeAt, data), callback);
+                ((CoordinationAdapter)node.coordinationAdapter(txnId, Standard)).persist(node, executes, route, txnId, txn, executeAt, deps, txn.execute(txnId, executeAt, data), txn.result(txnId, executeAt, data), callback);
             else
                 callback.accept(null, failure);
         });
diff --git a/src/java/org/apache/cassandra/service/accord/repair/RepairSyncPointAdapter.java b/src/java/org/apache/cassandra/service/accord/repair/RepairSyncPointAdapter.java
index c13a3c7f81..c0b1938fd3 100644
--- a/src/java/org/apache/cassandra/service/accord/repair/RepairSyncPointAdapter.java
+++ b/src/java/org/apache/cassandra/service/accord/repair/RepairSyncPointAdapter.java
@@ -48,7 +48,7 @@ import accord.topology.Topologies;
  * adapter requires responses from all of the supplied endpoints before completing. Note that shards only block on the
  * intersection of the provided replicas and their own endpoints.
  */
-public class RepairSyncPointAdapter<U extends Unseekable> extends CoordinationAdapter.Adapters.AbstractInclusiveSyncPointAdapter<U>
+public class RepairSyncPointAdapter<U extends Unseekable> extends CoordinationAdapter.Adapters.AsyncInclusiveSyncPointAdapter<U>
 {
     private final ImmutableSet<Node.Id> requiredResponses;
 
@@ -61,7 +61,7 @@ public class RepairSyncPointAdapter<U extends Unseekable> extends CoordinationAd
     public void execute(Node node, Topologies all, FullRoute<?> route, ExecutePath path, TxnId txnId, Txn txn, Timestamp executeAt, Deps deps, BiConsumer<? super SyncPoint<U>, Throwable> callback)
     {
         RequiredResponseTracker tracker = new RequiredResponseTracker(requiredResponses, all);
-        ExecuteSyncPoint.ExecuteInclusive<U> execute = new ExecuteSyncPoint.ExecuteInclusive<>(node, new SyncPoint<>(txnId, deps, (FullRoute<U>) route), tracker, executeAt);
+        ExecuteSyncPoint.ExecuteInclusive<U> execute = new ExecuteSyncPoint.ExecuteInclusive<>(node, new SyncPoint<>(txnId, executeAt, deps, (FullRoute<U>) route), tracker, executeAt);
         execute.addCallback(callback);
         execute.start();
     }
diff --git a/src/java/org/apache/cassandra/service/accord/serializers/AcceptSerializers.java b/src/java/org/apache/cassandra/service/accord/serializers/AcceptSerializers.java
index 14836f98a7..05c027e80f 100644
--- a/src/java/org/apache/cassandra/service/accord/serializers/AcceptSerializers.java
+++ b/src/java/org/apache/cassandra/service/accord/serializers/AcceptSerializers.java
@@ -33,6 +33,7 @@ import org.apache.cassandra.io.util.DataInputPlus;
 import org.apache.cassandra.io.util.DataOutputPlus;
 
 import static accord.messages.Accept.SerializerSupport.create;
+import static accord.utils.Invariants.illegalState;
 
 public class AcceptSerializers
 {
@@ -101,6 +102,9 @@ public class AcceptSerializers
             switch (reply.outcome())
             {
                 default: throw new AssertionError();
+                case Retired:
+                case Truncated:
+                    throw illegalState("AcceptReply with invalid AcceptOutcome: " + reply.outcome);
                 case Success:
                     if (reply.deps != null)
                     {
@@ -113,15 +117,12 @@ public class AcceptSerializers
                         out.writeByte(2);
                     }
                     break;
-                case Truncated:
-                    out.writeByte(3);
-                    break;
                 case RejectedBallot:
-                    out.writeByte(4);
+                    out.writeByte(3);
                     CommandSerializers.ballot.serialize(reply.supersededBy, out, version);
                     break;
                 case Redundant:
-                    int flags = 5 | (reply.supersededBy != null ? 0x8 : 0) | (reply.committedExecuteAt != null ? 0x10 : 0);
+                    int flags = 4 | (reply.supersededBy != null ? 0x8 : 0) | (reply.committedExecuteAt != null ? 0x10 : 0);
                     out.writeByte(flags);
                     if (reply.supersededBy != null)
                         CommandSerializers.ballot.serialize(reply.supersededBy, out, version);
@@ -142,10 +143,8 @@ public class AcceptSerializers
                 case 2:
                     return AcceptReply.ACCEPT_INVALIDATE;
                 case 3:
-                    return AcceptReply.TRUNCATED;
-                case 4:
                     return new AcceptReply(CommandSerializers.ballot.deserialize(in, version));
-                case 5:
+                case 4:
                     Ballot supersededBy = (flags & 0x8) == 0 ? null : CommandSerializers.ballot.deserialize(in, version);
                     Timestamp committedExecuteAt = (flags & 0x10) == 0 ? null : CommandSerializers.timestamp.deserialize(in, version);
                     return new AcceptReply(supersededBy, committedExecuteAt);
@@ -159,12 +158,13 @@ public class AcceptSerializers
             switch (reply.outcome())
             {
                 default: throw new AssertionError();
+                case Retired:
+                case Truncated:
+                    throw illegalState("AcceptReply with invalid AcceptOutcome: " + reply.outcome);
                 case Success:
                     if (reply.deps != null)
                         size += DepsSerializers.deps.serializedSize(reply.deps, version);
                     break;
-                case Truncated:
-                    break;
                 case RejectedBallot:
                     size += CommandSerializers.ballot.serializedSize(reply.supersededBy, version);
                     break;
diff --git a/src/java/org/apache/cassandra/service/accord/serializers/ApplySerializers.java b/src/java/org/apache/cassandra/service/accord/serializers/ApplySerializers.java
index dde7faa536..839d2e4d72 100644
--- a/src/java/org/apache/cassandra/service/accord/serializers/ApplySerializers.java
+++ b/src/java/org/apache/cassandra/service/accord/serializers/ApplySerializers.java
@@ -62,6 +62,7 @@ public class ApplySerializers
         @Override
         public void serializeBody(A apply, DataOutputPlus out, int version) throws IOException
         {
+            out.writeVInt(apply.minEpoch - apply.waitForEpoch);
             kind.serialize(apply.kind, out, version);
             CommandSerializers.timestamp.serialize(apply.executeAt, out, version);
             DepsSerializers.partialDeps.serialize(apply.deps, out, version);
@@ -70,13 +71,13 @@ public class ApplySerializers
             CommandSerializers.writes.serialize(apply.writes, out, version);
         }
 
-        protected abstract A deserializeApply(TxnId txnId, Route<?> scope, long waitForEpoch, Apply.Kind kind,
+        protected abstract A deserializeApply(TxnId txnId, Route<?> scope, long minEpoch, long waitForEpoch, Apply.Kind kind,
                                               Timestamp executeAt, PartialDeps deps, PartialTxn txn, FullRoute<?> fullRoute, Writes writes, Result result);
 
         @Override
         public A deserializeBody(DataInputPlus in, int version, TxnId txnId, Route<?> scope, long waitForEpoch) throws IOException
         {
-            return deserializeApply(txnId, scope, waitForEpoch,
+            return deserializeApply(txnId, scope, waitForEpoch + in.readVInt(), waitForEpoch,
                                     kind.deserialize(in, version),
                                     CommandSerializers.timestamp.deserialize(in, version),
                                     DepsSerializers.partialDeps.deserialize(in, version),
@@ -89,7 +90,8 @@ public class ApplySerializers
         @Override
         public long serializedBodySize(A apply, int version)
         {
-            return kind.serializedSize(apply.kind, version)
+            return TypeSizes.sizeofVInt(apply.minEpoch - apply.waitForEpoch)
+                   + kind.serializedSize(apply.kind, version)
                    + CommandSerializers.timestamp.serializedSize(apply.executeAt, version)
                    + DepsSerializers.partialDeps.serializedSize(apply.deps, version)
                    + CommandSerializers.nullablePartialTxn.serializedSize(apply.txn, version)
@@ -101,10 +103,10 @@ public class ApplySerializers
     public static final IVersionedSerializer<Apply> request = new ApplySerializer<>()
     {
         @Override
-        protected Apply deserializeApply(TxnId txnId, Route<?> scope, long waitForEpoch, Apply.Kind kind,
+        protected Apply deserializeApply(TxnId txnId, Route<?> scope, long minEpoch, long waitForEpoch, Apply.Kind kind,
                                Timestamp executeAt, PartialDeps deps, PartialTxn txn, FullRoute<?> fullRoute, Writes writes, Result result)
         {
-            return Apply.SerializationSupport.create(txnId, scope, waitForEpoch, kind, executeAt, deps, txn, fullRoute, writes, result);
+            return Apply.SerializationSupport.create(txnId, scope, minEpoch, waitForEpoch, kind, executeAt, deps, txn, fullRoute, writes, result);
         }
     };
 
diff --git a/src/java/org/apache/cassandra/service/accord/serializers/CheckStatusSerializers.java b/src/java/org/apache/cassandra/service/accord/serializers/CheckStatusSerializers.java
index c955cb6908..dd56dd28f9 100644
--- a/src/java/org/apache/cassandra/service/accord/serializers/CheckStatusSerializers.java
+++ b/src/java/org/apache/cassandra/service/accord/serializers/CheckStatusSerializers.java
@@ -46,7 +46,7 @@ import org.apache.cassandra.io.util.DataInputPlus;
 import org.apache.cassandra.io.util.DataOutputPlus;
 
 import static accord.messages.CheckStatus.SerializationSupport.createOk;
-import static org.apache.cassandra.service.accord.serializers.CommandSerializers.nullableKnown;
+import static org.apache.cassandra.service.accord.serializers.CommandSerializers.known;
 
 public class CheckStatusSerializers
 {
@@ -60,7 +60,19 @@ public class CheckStatusSerializers
             for (int i = 0 ; i <= size ; ++i)
                 KeySerializers.routingKey.serialize(knownMap.startAt(i), out, version);
             for (int i = 0 ; i < size ; ++i)
-                nullableKnown.serialize(knownMap.valueAt(i), out, version);
+            {
+                KnownMap.MinMax minMax = knownMap.valueAt(i);
+                if (minMax == null)
+                {
+                    out.writeByte(0);
+                    continue;
+                }
+                boolean equal = minMax.min.equals(minMax);
+                out.writeByte(equal ? 1 : 2);
+                known.serialize(minMax.min, out, version);
+                if (!equal)
+                    known.serialize(minMax, out, version);
+            }
         }
 
         @Override
@@ -70,9 +82,16 @@ public class CheckStatusSerializers
             RoutingKey[] starts = new RoutingKey[size + 1];
             for (int i = 0 ; i <= size ; ++i)
                 starts[i] = KeySerializers.routingKey.deserialize(in, version);
-            Known[] values = new Known[size];
+            KnownMap.MinMax[] values = new KnownMap.MinMax[size];
             for (int i = 0 ; i < size ; ++i)
-                values[i] = nullableKnown.deserialize(in, version);
+            {
+                int kind = in.readByte();
+                if (kind == 0)
+                    continue;
+                Known min = known.deserialize(in, version);
+                Known max = kind == 1 ? min : known.deserialize(in, version);
+                values[i] = new KnownMap.MinMax(min, max);
+            }
             return KnownMap.SerializerSupport.create(true, starts, values);
         }
 
@@ -84,7 +103,16 @@ public class CheckStatusSerializers
             for (int i = 0 ; i <= size ; ++i)
                 result += KeySerializers.routingKey.serializedSize(knownMap.startAt(i), version);
             for (int i = 0 ; i < size ; ++i)
-                result += nullableKnown.serializedSize(knownMap.valueAt(i), version);
+            {
+                KnownMap.MinMax minMax = knownMap.valueAt(i);
+                result += TypeSizes.BYTE_SIZE;
+                if (minMax == null)
+                    continue;
+                boolean equal = minMax.min.equals(minMax);
+                result += known.serializedSize(minMax.min, version);
+                if (!equal)
+                    result += known.serializedSize(minMax, version);
+            }
             return result;
         }
     };
diff --git a/src/java/org/apache/cassandra/service/accord/serializers/CommandSerializers.java b/src/java/org/apache/cassandra/service/accord/serializers/CommandSerializers.java
index 91203512e3..46348a2a8b 100644
--- a/src/java/org/apache/cassandra/service/accord/serializers/CommandSerializers.java
+++ b/src/java/org/apache/cassandra/service/accord/serializers/CommandSerializers.java
@@ -78,13 +78,15 @@ public class CommandSerializers
     public static final EnumSerializer<Txn.Kind> kind = new EnumSerializer<>(Txn.Kind.class);
     public static final StoreParticipantsSerializer participants = new StoreParticipantsSerializer();
 
-    // TODO (expected): optimise using subset serializers (but be careful for range txns, e.g. some collections have differently sliced sub ranges)
+    // TODO (expected): optimise using subset serializers, or perhaps simply with some deduping key serializer
     public static class StoreParticipantsSerializer implements IVersionedSerializer<StoreParticipants>
     {
         static final int HAS_ROUTE = 0x1;
         static final int HAS_TOUCHED_EQUALS_ROUTE = 0x2;
         static final int TOUCHES_EQUALS_HAS_TOUCHED = 0x4;
         static final int OWNS_EQUALS_TOUCHES = 0x8;
+        static final int EXECUTES_IS_NULL = 0x10;
+        static final int EXECUTES_IS_OWNS = 0x20;
 
         @Override
         public void serialize(StoreParticipants t, DataOutputPlus out, int version) throws IOException
@@ -93,15 +95,20 @@ public class CommandSerializers
             boolean hasTouchedEqualsRoute = t.route() == t.hasTouched();
             boolean touchesEqualsHasTouched = t.touches() == t.hasTouched();
             boolean ownsEqualsTouches = t.owns() == t.touches();
+            boolean executesIsNull = t.executes() == null;
+            boolean executesIsOwns = !executesIsNull && t.executes() == t.owns();
             out.writeByte((hasRoute ? HAS_ROUTE : 0)
                           | (hasTouchedEqualsRoute ? HAS_TOUCHED_EQUALS_ROUTE : 0)
                           | (touchesEqualsHasTouched ? TOUCHES_EQUALS_HAS_TOUCHED : 0)
                           | (ownsEqualsTouches ? OWNS_EQUALS_TOUCHES : 0)
+                          | (executesIsNull ? EXECUTES_IS_NULL : 0)
+                          | (executesIsOwns ? EXECUTES_IS_OWNS : 0)
             );
             if (hasRoute) KeySerializers.route.serialize(t.route(), out, version);
             if (!hasTouchedEqualsRoute) KeySerializers.participants.serialize(t.hasTouched(), out, version);
             if (!touchesEqualsHasTouched) KeySerializers.participants.serialize(t.touches(), out, version);
             if (!ownsEqualsTouches) KeySerializers.participants.serialize(t.owns(), out, version);
+            if (!executesIsNull && !executesIsOwns) KeySerializers.participants.serialize(t.executes(), out, version);
         }
 
         public void skip(DataInputPlus in, int version) throws IOException
@@ -119,7 +126,8 @@ public class CommandSerializers
             Participants<?> hasTouched = 0 != (flags & HAS_TOUCHED_EQUALS_ROUTE) ? route : KeySerializers.participants.deserialize(in, version);
             Participants<?> touches = 0 != (flags & TOUCHES_EQUALS_HAS_TOUCHED) ? hasTouched : KeySerializers.participants.deserialize(in, version);
             Participants<?> owns = 0 != (flags & OWNS_EQUALS_TOUCHES) ? touches : KeySerializers.participants.deserialize(in, version);
-            return StoreParticipants.SerializationSupport.create(route, owns, touches, hasTouched);
+            Participants<?> executes = 0 != (flags & EXECUTES_IS_NULL) ? null : 0 != (flags & EXECUTES_IS_OWNS) ? owns : KeySerializers.participants.deserialize(in, version);
+            return StoreParticipants.create(route, owns, executes, touches, hasTouched);
         }
 
         public Route<?> deserializeRouteOnly(DataInputPlus in, int version) throws IOException
@@ -138,11 +146,13 @@ public class CommandSerializers
             boolean hasTouchedEqualsRoute = t.route() == t.hasTouched();
             boolean touchesEqualsHasTouched = t.touches() == t.hasTouched();
             boolean ownsEqualsTouches = t.owns() == t.touches();
+            boolean executesIsNotNullAndNotOwns = t.executes() != null && t.owns() != t.executes();
             long size = 1;
             if (hasRoute) size += KeySerializers.route.serializedSize(t.route(), version);
             if (!hasTouchedEqualsRoute) size += KeySerializers.participants.serializedSize(t.hasTouched(), version);
             if (!touchesEqualsHasTouched) size += KeySerializers.participants.serializedSize(t.touches(), version);
             if (!ownsEqualsTouches) size += KeySerializers.participants.serializedSize(t.owns(), version);
+            if (executesIsNotNullAndNotOwns) size += KeySerializers.participants.serializedSize(t.executes(), version);
             return size;
         }
     }
diff --git a/src/java/org/apache/cassandra/service/accord/serializers/CommandsForKeySerializer.java b/src/java/org/apache/cassandra/service/accord/serializers/CommandsForKeySerializer.java
deleted file mode 100644
index c5ce8054f7..0000000000
--- a/src/java/org/apache/cassandra/service/accord/serializers/CommandsForKeySerializer.java
+++ /dev/null
@@ -1,1100 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.cassandra.service.accord.serializers;
-
-import java.nio.ByteBuffer;
-import java.util.Arrays;
-
-import javax.annotation.Nonnull;
-
-import com.google.common.primitives.Ints;
-
-import accord.api.RoutingKey;
-import accord.local.RedundantBefore;
-import accord.local.cfk.CommandsForKey;
-import accord.local.cfk.CommandsForKey.TxnInfo;
-import accord.local.cfk.CommandsForKey.InternalStatus;
-import accord.local.cfk.CommandsForKey.TxnInfoExtra;
-import accord.local.cfk.CommandsForKey.Unmanaged;
-import accord.local.Node;
-import accord.primitives.Ballot;
-import accord.primitives.Routable.Domain;
-import accord.primitives.Timestamp;
-import accord.primitives.Txn;
-import accord.primitives.TxnId;
-import accord.utils.Invariants;
-import org.apache.cassandra.db.TypeSizes;
-import org.apache.cassandra.db.marshal.ByteBufferAccessor;
-import org.apache.cassandra.utils.vint.VIntCoding;
-
-import static accord.local.cfk.CommandsForKey.NO_BOUNDS_INFO;
-import static accord.local.cfk.CommandsForKey.NO_PENDING_UNMANAGED;
-import static accord.primitives.Txn.Kind.ExclusiveSyncPoint;
-import static accord.primitives.TxnId.NO_TXNIDS;
-import static accord.primitives.Txn.Kind.Read;
-import static accord.primitives.Txn.Kind.SyncPoint;
-import static accord.primitives.Txn.Kind.Write;
-import static accord.utils.ArrayBuffers.cachedInts;
-import static accord.utils.ArrayBuffers.cachedTxnIds;
-import static org.apache.cassandra.service.accord.serializers.CommandsForKeySerializer.TxnIdFlags.RAW_BITS;
-import static org.apache.cassandra.utils.ByteBufferUtil.readLeastSignificantBytes;
-import static org.apache.cassandra.utils.ByteBufferUtil.writeLeastSignificantBytes;
-import static org.apache.cassandra.utils.ByteBufferUtil.writeMostSignificantBytes;
-import static org.apache.cassandra.utils.vint.VIntCoding.decodeZigZag64;
-import static org.apache.cassandra.utils.vint.VIntCoding.encodeZigZag64;
-
-public class CommandsForKeySerializer
-{
-    private static final int HAS_MISSING_DEPS_HEADER_BIT = 0x1;
-    private static final int HAS_EXECUTE_AT_HEADER_BIT = 0x2;
-    private static final int HAS_BALLOT_HEADER_BIT = 0x4;
-    private static final int HAS_STATUS_OVERRIDES = 0x8;
-    private static final int HAS_NON_STANDARD_FLAGS = 0x10;
-
-    /**
-     * We read/write a fixed number of intial bytes for each command, with an initial flexible number of flag bits
-     * and the remainder interpreted as the HLC/epoch/node.
-     *
-     * The preamble encodes:
-     *  vint32: number of commands
-     *  vint32: number of unique node Ids
-     *  [unique node ids]
-     *  two flag bytes:
-     *   bit 0 is set if there are any missing ids;
-     *   bit 1 is set if there are any executeAt specified
-     *   bit 2 is set if there are any ballots specified
-     *   bit 3 is set if there are any non-standard TxnId.Kind present
-     *   bit 4 is set if there are any queries with override flags
-     *   bits 6-7 number of header bytes to read for each command
-     *   bits 8-9: level 0 extra hlc bytes to read
-     *   bits 10-11: level 1 extra hlc bytes to read (+ 1 + level 0)
-     *   bits 12-13: level 2 extra hlc bytes to read (+ 1 + level 1)
-     *   bits 14-15: level 3 extra hlc bytes to read (+ 1 + level 2)
-     *
-     * In order, for each command, we consume:
-     * 3 bits for the InternalStatus of the command
-     * 1 optional bit: if any command has override flags; 2 bits more to read if this bit is set
-     * 1 optional bit: if the status encodes an executeAt, indicating if the executeAt is not the TxnId
-     * 1 optional bit: if the status encodes any dependencies and there are non-zero missing ids, indicating if there are any missing for this command
-     * 2 or 3 bits for the kind of the TxnId
-     * 1 bit encoding if the epoch has changed
-     * 2 optional bits: if the prior bit is set, indicating how many bits should be read for the epoch increment: 0=none (increment by 1); 1=4, 2=8, 3=32
-     * 4 option bits: if prior bits=01, epoch delta
-     * N node id bits (where 2^N unique node ids in the CFK)
-     * 2 bits indicating how many more payload bytes should be read, with mapping written in header
-     * all remaining bits are interpreted as a delta from the prior HLC
-     *
-     * if txnId kind flag is 3, read an additional 2 bytes for TxnId flag
-     * if epoch increment flag is 2 or 3, read additional 1 or 4 bytes for epoch delta
-     * if executeAt is expected, read vint32 for epoch, vint32 for delta from txnId hlc, and ceil(N/8) bytes for node id
-     *
-     * After writing all transactions, we then write out the missing txnid collections. This is written at the end
-     * so that on deserialization we have already read all of the TxnId. This also permits more efficient serialization,
-     * as we can encode a single bit stream with the optimal number of bits.
-     * TODO (desired): we could prefix this collection with the subset of TxnId that are actually missing from any other
-     *   deps, so as to shrink this collection much further.
-     */
-    // TODO (expected): offer filtering option that does not need to reconstruct objects/info, reusing prior encoding decisions
-    // TODO (expected): accept new redundantBefore on load to avoid deserializing stale data
-    // TODO (desired): determine timestamp resolution as a factor of 10
-    public static ByteBuffer toBytesWithoutKey(CommandsForKey cfk)
-    {
-        Invariants.checkArgument(!cfk.isLoadingPruned());
-
-        int commandCount = cfk.size();
-        if (commandCount == 0)
-            return ByteBuffer.allocate(1);
-
-        int[] nodeIds = cachedInts().getInts(Math.min(64, Math.max(4, commandCount)));
-        try
-        {
-            // first compute the unique Node Ids and some basic characteristics of the data, such as
-            // whether we have any missing transactions to encode, any executeAt that are not equal to their TxnId
-            // and whether there are any non-standard flag bits to encode
-            boolean hasNonStandardFlags = false;
-            int nodeIdCount, missingIdCount = 0, executeAtCount = 0, ballotCount = 0, overrideCount = 0;
-            int bitsPerExecuteAtEpoch = 0, bitsPerExecuteAtFlags = 0, bitsPerExecuteAtHlc = 1; // to permit us to use full 64 bits and encode in 5 bits we force at least one hlc bit
-            {
-                nodeIds[0] = cfk.redundantBefore().node.id;
-                nodeIdCount = 1;
-                for (int i = 0 ; i < commandCount ; ++i)
-                {
-                    if (nodeIdCount + 3 >= nodeIds.length)
-                    {
-                        nodeIdCount = compact(nodeIds, nodeIdCount);
-                        if (nodeIdCount > nodeIds.length/2 || nodeIdCount + 2 >= nodeIds.length)
-                            nodeIds = cachedInts().resize(nodeIds, nodeIds.length, nodeIds.length * 2);
-                    }
-
-                    TxnInfo txn = cfk.get(i);
-                    overrideCount += txn.statusOverrides() > 0 ? 1 : 0;
-                    hasNonStandardFlags |= hasNonStandardFlags(txn);
-                    nodeIds[nodeIdCount++] = txn.node.id;
-
-                    if (txn.executeAt != txn)
-                    {
-                        Invariants.checkState(txn.status().hasExecuteAtOrDeps);
-                        nodeIds[nodeIdCount++] = txn.executeAt.node.id;
-                        bitsPerExecuteAtEpoch = Math.max(bitsPerExecuteAtEpoch, numberOfBitsToRepresent(txn.executeAt.epoch() - txn.epoch()));
-                        bitsPerExecuteAtHlc = Math.max(bitsPerExecuteAtHlc, numberOfBitsToRepresent(txn.executeAt.hlc() - txn.hlc()));
-                        bitsPerExecuteAtFlags = Math.max(bitsPerExecuteAtFlags, numberOfBitsToRepresent(txn.executeAt.flags()));
-                        executeAtCount += 1;
-                    }
-
-                    if (txn.getClass() == TxnInfoExtra.class)
-                    {
-                        TxnInfoExtra extra = (TxnInfoExtra) txn;
-                        missingIdCount += extra.missing.length;
-                        if (extra.ballot != Ballot.ZERO)
-                        {
-                            Invariants.checkArgument(txn.status().hasBallot);
-                            nodeIds[nodeIdCount++] = extra.ballot.node.id;
-                            ballotCount += 1;
-                        }
-                    }
-                }
-                nodeIdCount = compact(nodeIds, nodeIdCount);
-                Invariants.checkState(nodeIdCount > 0);
-            }
-
-            // We can now use this information to calculate the fixed header size, compute the amount
-            // of additional space we'll need to store the TxnId and its basic info
-            int bitsPerNodeId = numberOfBitsToRepresent(nodeIdCount);
-            int minHeaderBits = 8 + bitsPerNodeId + (hasNonStandardFlags ? 1 : 0) + (overrideCount > 0 ? 1 : 0);
-            int infoHeaderBits = (executeAtCount > 0 ? 1 : 0) + (missingIdCount > 0 ? 1 : 0);
-            int ballotHeaderBits = (ballotCount > 0 ? 1 : 0);
-            int maxHeaderBits = minHeaderBits;
-            int totalBytes = 0;
-
-            int prunedBeforeIndex = cfk.prunedBefore().equals(TxnId.NONE) ? -1 : cfk.indexOf(cfk.prunedBefore());
-
-            long prevEpoch = cfk.redundantBefore().epoch();
-            long prevHlc = cfk.redundantBefore().hlc();
-            int[] bytesHistogram = cachedInts().getInts(12);
-            Arrays.fill(bytesHistogram, 0);
-            for (int i = 0 ; i < commandCount ; ++i)
-            {
-                int headerBits = minHeaderBits;
-                int payloadBits = 0;
-
-                TxnId txnId = cfk.txnId(i);
-                {
-                    long epoch = txnId.epoch();
-                    Invariants.checkState(epoch >= prevEpoch);
-                    long epochDelta = epoch - prevEpoch;
-                    long hlc = txnId.hlc();
-                    long hlcDelta = hlc - prevHlc;
-
-                    if (epochDelta > 0)
-                    {
-                        if (hlcDelta < 0)
-                            hlcDelta = -1 - hlcDelta;
-
-                        headerBits += 3;
-                        if (epochDelta > 1)
-                        {
-                            if (epochDelta <= 0xf) headerBits += 4;
-                            else if (epochDelta <= 0xff) totalBytes += 1;
-                            else { totalBytes += 4; Invariants.checkState(epochDelta <= 0xffffffffL); }
-                        }
-                    }
-
-                    payloadBits += numberOfBitsToRepresent(hlcDelta);
-                    prevEpoch = epoch;
-                    prevHlc = hlc;
-                }
-
-                if (txnIdFlagsBits(txnId, hasNonStandardFlags) == RAW_BITS)
-                    totalBytes += 2;
-
-                TxnInfo info = cfk.get(i);
-                if (info.status().hasExecuteAtOrDeps)
-                    headerBits += infoHeaderBits;
-                if (info.status().hasBallot)
-                    headerBits += ballotHeaderBits;
-                if (info.statusOverrides() != 0)
-                    headerBits += 2;
-                maxHeaderBits = Math.max(headerBits, maxHeaderBits);
-                int basicBytes = (headerBits + payloadBits + 7)/8;
-                bytesHistogram[basicBytes]++;
-            }
-
-            int minBasicBytes = -1, maxBasicBytes = 0;
-            for (int i = 0 ; i < bytesHistogram.length ; ++i)
-            {
-                if (bytesHistogram[i] == 0) continue;
-                if (minBasicBytes == -1) minBasicBytes = i;
-                maxBasicBytes = i;
-            }
-            for (int i = minBasicBytes + 1 ; i <= maxBasicBytes ; ++i)
-                bytesHistogram[i] += bytesHistogram[i-1];
-
-            int flags = (missingIdCount > 0 ? HAS_MISSING_DEPS_HEADER_BIT : 0)
-                        | (executeAtCount > 0 ? HAS_EXECUTE_AT_HEADER_BIT : 0)
-                        | (ballotCount > 0 ? HAS_BALLOT_HEADER_BIT : 0)
-                        | (hasNonStandardFlags ? HAS_NON_STANDARD_FLAGS : 0)
-                        | (overrideCount > 0 ? HAS_STATUS_OVERRIDES : 0);
-
-            int headerBytes = (maxHeaderBits+7)/8;
-            flags |= Invariants.checkArgument(headerBytes - 1, headerBytes <= 4) << 6;
-
-            int hlcBytesLookup;
-            {   // 2bits per size, first value may be zero and remainder may be increments of 1-4;
-                // only need to be able to encode a distribution of approx. 8 bytes at most, so
-                // pick lowest number we need first, then next lowest as 25th %ile while ensuring value of 1-4;
-                // then pick highest number we need, ensuring at least 2 greater than second (leaving room for third)
-                // then pick third number as 75th %ile, but at least 1 less than highest, and one more than second
-                // finally, ensure third then second are distributed so that there is no more than a gap of 4 between them and the next
-                int l0 = Math.max(0, Math.min(3, minBasicBytes - headerBytes));
-                int l1 = Arrays.binarySearch(bytesHistogram, minBasicBytes, maxBasicBytes, commandCount/4);
-                l1 = Math.max(l0+1, Math.min(l0+4, (l1 < 0 ? -1 - l1 : l1) - headerBytes));
-                int l3 = Math.max(l1+2, maxBasicBytes - headerBytes);
-                int l2 = Arrays.binarySearch(bytesHistogram, minBasicBytes, maxBasicBytes,(3*commandCount)/4);
-                l2 = Math.max(l1+1, Math.min(l3-1, (l2 < 0 ? -1 -l2 : l2) - headerBytes));
-                while (l3-l2 > 4) ++l2;
-                while (l2-l1 > 4) ++l1;
-                hlcBytesLookup = setHlcBytes(l0, l1, l2, l3);
-                flags |= (l0 | ((l1-(1+l0))<<2) | ((l2-(1+l1))<<4) | ((l3-(1+l2))<<6)) << 8;
-            }
-            int hlcFlagLookup = hlcBytesLookupToHlcFlagLookup(hlcBytesLookup);
-
-            totalBytes += bytesHistogram[minBasicBytes] * (headerBytes + getHlcBytes(hlcBytesLookup, getHlcFlag(hlcFlagLookup, minBasicBytes - headerBytes)));
-            for (int i = minBasicBytes + 1 ; i <= maxBasicBytes ; ++i)
-                totalBytes += (bytesHistogram[i] - bytesHistogram[i-1]) * (headerBytes + getHlcBytes(hlcBytesLookup, getHlcFlag(hlcFlagLookup, i - headerBytes)));
-            totalBytes += TypeSizes.sizeofUnsignedVInt(commandCount);
-            totalBytes += TypeSizes.sizeofUnsignedVInt(nodeIdCount);
-            totalBytes += TypeSizes.sizeofUnsignedVInt(nodeIds[0]);
-            for (int i = 1 ; i < nodeIdCount ; ++i)
-                totalBytes += TypeSizes.sizeofUnsignedVInt(nodeIds[i] - nodeIds[i-1]);
-            totalBytes += 2;
-
-            cachedInts().forceDiscard(bytesHistogram);
-
-            prevEpoch = cfk.redundantBefore().epoch();
-            prevHlc = cfk.redundantBefore().hlc();
-            {
-                RedundantBefore.Entry boundsInfo = cfk.boundsInfo();
-                long start = boundsInfo.startOwnershipEpoch;
-                long end = boundsInfo.endOwnershipEpoch;
-                totalBytes += VIntCoding.computeUnsignedVIntSize(start);
-                totalBytes += VIntCoding.computeUnsignedVIntSize(end == Long.MAX_VALUE ? 0 : (1 + end - start));
-                totalBytes += VIntCoding.computeVIntSize(prevEpoch - start);
-            }
-            totalBytes += TypeSizes.sizeofUnsignedVInt(prevHlc);
-            totalBytes += TypeSizes.sizeofUnsignedVInt(cfk.redundantBefore().flags());
-            totalBytes += TypeSizes.sizeofUnsignedVInt(Arrays.binarySearch(nodeIds, 0, nodeIdCount, cfk.redundantBefore().node.id));
-            totalBytes += TypeSizes.sizeofUnsignedVInt(prunedBeforeIndex + 1);
-
-            int bitsPerBallotEpoch = 0, bitsPerBallotHlc = 1, bitsPerBallotFlags = 0;
-            if ((missingIdCount | executeAtCount | ballotCount) > 0)
-            {
-                if (ballotCount > 0)
-                {
-                    Ballot prevBallot = null;
-                    for (int i = 0 ; i < commandCount ; ++i)
-                    {
-                        TxnInfo txn = cfk.get(i);
-                        if (txn.getClass() != TxnInfoExtra.class) continue;
-                        if (!txn.status().hasBallot) continue;
-                        TxnInfoExtra extra = (TxnInfoExtra) txn;
-                        if (extra.ballot == Ballot.ZERO) continue;
-                        if (prevBallot != null)
-                        {
-                            bitsPerBallotEpoch = Math.max(bitsPerBallotEpoch, numberOfBitsToRepresent(encodeZigZag64(extra.ballot.epoch() - prevBallot.epoch())));
-                            bitsPerBallotHlc = Math.max(bitsPerBallotHlc, numberOfBitsToRepresent(encodeZigZag64(extra.ballot.hlc() - prevBallot.hlc())));
-                            bitsPerBallotFlags = Math.max(bitsPerBallotFlags, numberOfBitsToRepresent(extra.ballot.flags()));
-                        }
-                        prevBallot = extra.ballot;
-                    }
-                    totalBytes += 2; // encode bit widths
-                }
-
-                if (executeAtCount > 0)
-                    totalBytes += 2; // encode bit widths
-
-                // account for encoding missing id stream
-                int missingIdBits = 1 + numberOfBitsToRepresent(commandCount);
-                int executeAtBits = bitsPerNodeId
-                                    + bitsPerExecuteAtEpoch
-                                    + bitsPerExecuteAtHlc
-                                    + bitsPerExecuteAtFlags;
-                int ballotBits = bitsPerNodeId
-                                 + bitsPerBallotEpoch
-                                 + bitsPerBallotHlc
-                                 + bitsPerBallotFlags;
-                totalBytes += (missingIdBits * missingIdCount
-                               + executeAtBits * executeAtCount
-                               + (ballotCount > 0 ? ballotBits * (ballotCount - 1) + bitsPerNodeId + 128 : 0)
-                               + 7)/8;
-            }
-
-            // count unmanaged bytes
-            int unmanagedPendingCommitCount = 0;
-            for (int i = 0 ; i < cfk.unmanagedCount() ; ++i)
-            {
-                Unmanaged unmanaged = cfk.getUnmanaged(i);
-                if (unmanaged.pending == Unmanaged.Pending.COMMIT)
-                    ++unmanagedPendingCommitCount;
-                totalBytes += CommandSerializers.txnId.serializedSize();
-                // TODO (desired): this could be more efficient, e.g. referencing one of the TxnInfo indexes for timestamp
-                totalBytes += CommandSerializers.timestamp.serializedSize();
-            }
-            totalBytes += TypeSizes.sizeofUnsignedVInt(unmanagedPendingCommitCount);
-            totalBytes += TypeSizes.sizeofUnsignedVInt(cfk.unmanagedCount() - unmanagedPendingCommitCount);
-
-            ByteBuffer out = ByteBuffer.allocate(totalBytes);
-            VIntCoding.writeUnsignedVInt32(commandCount, out);
-            VIntCoding.writeUnsignedVInt32(nodeIdCount, out);
-            VIntCoding.writeUnsignedVInt32(nodeIds[0], out);
-            for (int i = 1 ; i < nodeIdCount ; ++i) // TODO (desired): can encode more efficiently as a stream of N bit integers
-                VIntCoding.writeUnsignedVInt32(nodeIds[i] - nodeIds[i-1], out);
-            out.putShort((short)flags);
-
-
-            {
-                RedundantBefore.Entry boundsInfo = cfk.boundsInfo();
-                long start = boundsInfo.startOwnershipEpoch;
-                long end = boundsInfo.endOwnershipEpoch;
-                VIntCoding.writeUnsignedVInt(start, out);
-                VIntCoding.writeUnsignedVInt(end == Long.MAX_VALUE ? 0 : (1 + end - start), out);
-                VIntCoding.writeVInt(prevEpoch - start, out);
-            }
-            VIntCoding.writeUnsignedVInt(prevHlc, out);
-            VIntCoding.writeUnsignedVInt32(cfk.redundantBefore().flags(), out);
-            VIntCoding.writeUnsignedVInt32(Arrays.binarySearch(nodeIds, 0, nodeIdCount, cfk.redundantBefore().node.id), out);
-            VIntCoding.writeUnsignedVInt32(prunedBeforeIndex + 1, out);
-
-            int executeAtMask = executeAtCount > 0 ? 1 : 0;
-            int missingDepsMask = missingIdCount > 0 ? 1 : 0;
-            int ballotMask = ballotCount > 0 ? 1 : 0;
-            int noOverrideIncrement = overrideCount > 0 ? 1 : 0;
-            int flagsIncrement = hasNonStandardFlags ? 3 : 2;
-            // TODO (desired): check this loop compiles correctly to only branch on epoch case, for binarySearch and flushing
-            for (int i = 0 ; i < commandCount ; ++i)
-            {
-                TxnInfo txn = cfk.get(i);
-                InternalStatus status = txn.status();
-
-                long bits = status.ordinal();
-                int bitIndex = 3;
-
-                int statusHasInfo = status.hasExecuteAtOrDeps ? 1 : 0;
-                int statusHasBallot = status.hasBallot ? 1 : 0;
-                long hasExecuteAt = txn.executeAt != txn ? 1 : 0;
-                bits |= hasExecuteAt << bitIndex;
-                bitIndex += statusHasInfo & executeAtMask;
-
-                long hasMissingIds = txn.getClass() == TxnInfoExtra.class && ((TxnInfoExtra)txn).missing != NO_TXNIDS ? 1 : 0;
-                bits |= hasMissingIds << bitIndex;
-                bitIndex += statusHasInfo & missingDepsMask;
-
-                long hasBallot = txn.getClass() == TxnInfoExtra.class && ((TxnInfoExtra)txn).ballot != Ballot.ZERO ? 1 : 0;
-                bits |= hasBallot << bitIndex;
-                bitIndex += statusHasBallot & ballotMask;
-
-                long statusOverrides = (long) txn.statusOverrides() << 1;
-                statusOverrides |= statusOverrides != 0 ? 1 : 0;
-                bits |= statusOverrides << bitIndex;
-                bitIndex += statusOverrides != 0 ? 3 : noOverrideIncrement;
-
-                long flagBits = txnIdFlagsBits(txn, hasNonStandardFlags);
-                boolean writeFullFlags = flagBits == RAW_BITS;
-                bits |= flagBits << bitIndex;
-                bitIndex += flagsIncrement;
-
-                long hlcBits;
-                int extraEpochDeltaBytes = 0;
-                {
-                    long epoch = txn.epoch();
-                    long delta = epoch - prevEpoch;
-                    long hlc = txn.hlc();
-                    hlcBits = hlc - prevHlc;
-                    if (delta == 0)
-                    {
-                        bitIndex++;
-                    }
-                    else
-                    {
-                        bits |= 1L << bitIndex++;
-                        if (hlcBits < 0)
-                        {
-                            hlcBits = -1 - hlcBits;
-                            bits |= 1L << bitIndex;
-                        }
-                        bitIndex++;
-                        if (delta > 1)
-                        {
-                            if (delta <= 0xf)
-                            {
-                                bits |= 1L << bitIndex;
-                                bits |= delta << (bitIndex + 2);
-                                bitIndex += 4;
-                            }
-                            else
-                            {
-                                bits |= (delta <= 0xff ? 2L : 3L) << bitIndex;
-                                extraEpochDeltaBytes = Ints.checkedCast(delta);
-                            }
-                        }
-                        bitIndex += 2;
-                    }
-                    prevEpoch = epoch;
-                    prevHlc = hlc;
-                }
-
-                bits |= ((long)Arrays.binarySearch(nodeIds, 0, nodeIdCount, txn.node.id)) << bitIndex;
-                bitIndex += bitsPerNodeId;
-
-                bits |= hlcBits << (bitIndex + 2);
-                hlcBits >>>= 8*headerBytes - (bitIndex + 2);
-                int hlcFlag = getHlcFlag(hlcFlagLookup, (7 + numberOfBitsToRepresent(hlcBits))/8);
-                bits |= ((long)hlcFlag) << bitIndex;
-
-                writeLeastSignificantBytes(bits, headerBytes, out);
-                writeLeastSignificantBytes(hlcBits, getHlcBytes(hlcBytesLookup, hlcFlag), out);
-
-                if (writeFullFlags)
-                    out.putShort((short)txn.flags());
-
-                if (extraEpochDeltaBytes > 0)
-                {
-                    if (extraEpochDeltaBytes <= 0xff) out.put((byte)extraEpochDeltaBytes);
-                    else out.putInt(extraEpochDeltaBytes);
-                }
-            }
-
-            VIntCoding.writeUnsignedVInt32(unmanagedPendingCommitCount, out);
-            VIntCoding.writeUnsignedVInt32(cfk.unmanagedCount() - unmanagedPendingCommitCount, out);
-            Unmanaged.Pending pending = unmanagedPendingCommitCount == 0 ? Unmanaged.Pending.APPLY : Unmanaged.Pending.COMMIT;
-            {
-                int offset = 0;
-                for (int i = 0 ; i < cfk.unmanagedCount() ; ++i)
-                {
-                    Unmanaged unmanaged = cfk.getUnmanaged(i);
-                    Invariants.checkState(unmanaged.pending == pending);
-
-                    offset += CommandSerializers.txnId.serialize(unmanaged.txnId, out, ByteBufferAccessor.instance, offset);
-                    offset += CommandSerializers.timestamp.serialize(unmanaged.waitingUntil, out, ByteBufferAccessor.instance, offset);
-                    if (--unmanagedPendingCommitCount == 0) pending = Unmanaged.Pending.APPLY;
-                }
-                out.position(out.position() + offset);
-            }
-
-            if ((executeAtCount | missingIdCount | ballotCount) > 0)
-            {
-                int bitsPerCommandId =  numberOfBitsToRepresent(commandCount);
-                int bitsPerMissingId = 1 + bitsPerCommandId;
-                int bitsPerExecuteAt = bitsPerExecuteAtEpoch + bitsPerExecuteAtHlc + bitsPerExecuteAtFlags + bitsPerNodeId;
-                int bitsPerBallot = bitsPerBallotEpoch + bitsPerBallotHlc + bitsPerBallotFlags + bitsPerNodeId;
-                Invariants.checkState(bitsPerExecuteAtEpoch < 64);
-                Invariants.checkState(bitsPerExecuteAtHlc <= 64);
-                Invariants.checkState(bitsPerExecuteAtFlags <= 16);
-                if (executeAtMask > 0) // we encode both 15 and 16 bits for flag length as 15 to fit in a short
-                    out.putShort((short) ((bitsPerExecuteAtEpoch << 10) | ((bitsPerExecuteAtHlc-1) << 4) | (Math.min(15, bitsPerExecuteAtFlags))));
-                if (ballotMask > 0) // we encode both 15 and 16 bits for flag length as 15 to fit in a short
-                    out.putShort((short) ((bitsPerBallotEpoch << 10) | ((bitsPerBallotHlc-1) << 4) | (Math.min(15, bitsPerBallotFlags))));
-                long buffer = 0L;
-                int bufferCount = 0;
-
-                Ballot prevBallot = null;
-                for (int i = 0 ; i < commandCount ; ++i)
-                {
-                    TxnInfo txn = cfk.get(i);
-                    if (txn.executeAt != txn)
-                    {
-                        Timestamp executeAt = txn.executeAt;
-                        int nodeIdx = Arrays.binarySearch(nodeIds, 0, nodeIdCount, executeAt.node.id);
-                        if (bitsPerExecuteAt <= 64)
-                        {
-                            Invariants.checkState(executeAt.epoch() >= txn.epoch());
-                            long executeAtBits = executeAt.epoch() - txn.epoch();
-                            int offset = bitsPerExecuteAtEpoch;
-                            executeAtBits |= (executeAt.hlc() - txn.hlc()) << offset ;
-                            offset += bitsPerExecuteAtHlc;
-                            executeAtBits |= ((long)executeAt.flags()) << offset;
-                            offset += bitsPerExecuteAtFlags;
-                            executeAtBits |= ((long)nodeIdx) << offset;
-                            buffer = flushBits(buffer, bufferCount, executeAtBits, bitsPerExecuteAt, out);
-                            bufferCount = (bufferCount + bitsPerExecuteAt) & 63;
-                        }
-                        else
-                        {
-                            buffer = flushBits(buffer, bufferCount, executeAt.epoch() - txn.epoch(), bitsPerExecuteAtEpoch, out);
-                            bufferCount = (bufferCount + bitsPerExecuteAtEpoch) & 63;
-                            buffer = flushBits(buffer, bufferCount, executeAt.hlc() - txn.hlc(), bitsPerExecuteAtHlc, out);
-                            bufferCount = (bufferCount + bitsPerExecuteAtHlc) & 63;
-                            buffer = flushBits(buffer, bufferCount, executeAt.flags(), bitsPerExecuteAtFlags, out);
-                            bufferCount = (bufferCount + bitsPerExecuteAtFlags) & 63;
-                            buffer = flushBits(buffer, bufferCount, nodeIdx, bitsPerNodeId, out);
-                            bufferCount = (bufferCount + bitsPerNodeId) & 63;
-                        }
-                    }
-
-                    if (txn.getClass() == TxnInfoExtra.class)
-                    {
-                        TxnInfoExtra extra = (TxnInfoExtra) txn;
-
-                        TxnId[] missing = extra.missing;
-                        if (missing.length > 0)
-                        {
-                            int j = 0;
-                            while (j < missing.length - 1)
-                            {
-                                int missingId = cfk.indexOf(missing[j++]);
-                                buffer = flushBits(buffer, bufferCount, missingId, bitsPerMissingId, out);
-                                bufferCount = (bufferCount + bitsPerMissingId) & 63;
-                            }
-                            int missingId = cfk.indexOf(missing[missing.length - 1]);
-                            missingId |= 1L << bitsPerCommandId;
-                            buffer = flushBits(buffer, bufferCount, missingId, bitsPerMissingId, out);
-                            bufferCount = (bufferCount + bitsPerMissingId) & 63;
-                        }
-
-                        Ballot ballot = extra.ballot;
-                        if (ballot != Ballot.ZERO)
-                        {
-                            int nodeIdx = Arrays.binarySearch(nodeIds, 0, nodeIdCount, ballot.node.id);
-                            if (prevBallot == null)
-                            {
-                                buffer = flushBits(buffer, bufferCount, ballot.msb, 64, out);
-                                buffer = flushBits(buffer, bufferCount, ballot.lsb, 64, out);
-                                buffer = flushBits(buffer, bufferCount, nodeIdx, bitsPerNodeId, out);
-                                bufferCount = (bufferCount + bitsPerNodeId) & 63;
-                            }
-                            else if (bitsPerBallot <= 64)
-                            {
-                                long ballotBits = encodeZigZag64(ballot.epoch() - prevBallot.epoch());
-                                int offset = bitsPerBallotEpoch;
-                                ballotBits |= encodeZigZag64(ballot.hlc() - prevBallot.hlc()) << offset ;
-                                offset += bitsPerBallotHlc;
-                                ballotBits |= ((long)ballot.flags()) << offset;
-                                offset += bitsPerBallotFlags;
-                                ballotBits |= ((long)nodeIdx) << offset;
-                                buffer = flushBits(buffer, bufferCount, ballotBits, bitsPerBallot, out);
-                                bufferCount = (bufferCount + bitsPerBallot) & 63;
-                            }
-                            else
-                            {
-                                buffer = flushBits(buffer, bufferCount, encodeZigZag64(ballot.epoch() - prevBallot.epoch()), bitsPerBallotEpoch, out);
-                                bufferCount = (bufferCount + bitsPerBallotEpoch) & 63;
-                                buffer = flushBits(buffer, bufferCount, encodeZigZag64(ballot.hlc() - prevBallot.hlc()), bitsPerBallotHlc, out);
-                                bufferCount = (bufferCount + bitsPerBallotHlc) & 63;
-                                buffer = flushBits(buffer, bufferCount, ballot.flags(), bitsPerBallotFlags, out);
-                                bufferCount = (bufferCount + bitsPerBallotFlags) & 63;
-                                buffer = flushBits(buffer, bufferCount, nodeIdx, bitsPerNodeId, out);
-                                bufferCount = (bufferCount + bitsPerNodeId) & 63;
-                            }
-                            prevBallot = ballot;
-                        }
-                    }
-                }
-
-                writeMostSignificantBytes(buffer, (bufferCount + 7)/8, out);
-            }
-
-            Invariants.checkState(!out.hasRemaining());
-            out.flip();
-            return out;
-        }
-        finally
-        {
-            cachedInts().forceDiscard(nodeIds);
-        }
-    }
-
-    private static long flushBits(long buffer, int bufferCount, long add, int addCount, ByteBuffer out)
-    {
-        Invariants.checkArgument(addCount == 64 || 0 == (add & (-1L << addCount)));
-        int total = bufferCount + addCount;
-        if (total < 64)
-        {
-            return buffer | (add << 64 - total);
-        }
-        else
-        {
-            buffer |= add >>> total - 64;
-            out.putLong(buffer);
-            return total == 64 ? 0 : (add << (128 - total));
-        }
-    }
-
-    public static CommandsForKey fromBytes(RoutingKey key, ByteBuffer in)
-    {
-        if (!in.hasRemaining())
-            return null;
-
-        in = in.duplicate();
-        int commandCount = VIntCoding.readUnsignedVInt32(in);
-        if (commandCount == 0)
-            return new CommandsForKey(key);
-
-        TxnId[] txnIds = cachedTxnIds().get(commandCount);
-        int[] decodeFlags = cachedInts().getInts(commandCount);
-        TxnInfo[] txns = new TxnInfo[commandCount];
-        int nodeIdCount = VIntCoding.readUnsignedVInt32(in);
-        int bitsPerNodeId = numberOfBitsToRepresent(nodeIdCount);
-        long nodeIdMask = (1L << bitsPerNodeId) - 1;
-        Node.Id[] nodeIds = new Node.Id[nodeIdCount]; // TODO (expected): use a shared reusable scratch buffer
-        {
-            int prev = VIntCoding.readUnsignedVInt32(in);
-            nodeIds[0] = new Node.Id(prev);
-            for (int i = 1 ; i < nodeIdCount ; ++i)
-                nodeIds[i] = new Node.Id(prev += VIntCoding.readUnsignedVInt32(in));
-        }
-
-        int missingDepsMasks, executeAtMasks, ballotMasks, txnIdFlagsMask, overrideMask;
-        int headerByteCount, hlcBytesLookup;
-        {
-            int flags = in.getShort();
-            missingDepsMasks = 0 != (flags & HAS_MISSING_DEPS_HEADER_BIT) ? 1 : 0;
-            executeAtMasks = 0 != (flags & HAS_EXECUTE_AT_HEADER_BIT) ? 1 : 0;
-            ballotMasks = 0 != (flags & HAS_BALLOT_HEADER_BIT) ? 1 : 0;
-            overrideMask = 0 != (flags & HAS_STATUS_OVERRIDES) ? 1 : 0;
-            txnIdFlagsMask = 0 != (flags & HAS_NON_STANDARD_FLAGS) ? 7 : 3;
-            headerByteCount = 1 + ((flags >>> 6) & 0x3);
-            hlcBytesLookup = setHlcByteDeltas((flags >>> 8) & 0x3, (flags >>> 10) & 0x3, (flags >>> 12) & 0x3, (flags >>> 14) & 0x3);
-        }
-
-        long minEpoch = VIntCoding.readUnsignedVInt(in);
-        long maxEpoch; {
-            long offset = VIntCoding.readUnsignedVInt(in);
-            maxEpoch = offset == 0 ? Long.MAX_VALUE : minEpoch + offset - 1;
-        }
-        RedundantBefore.Entry boundsInfo = NO_BOUNDS_INFO.withEpochs(minEpoch, maxEpoch);
-        long prevEpoch = minEpoch + VIntCoding.readVInt(in);
-        long prevHlc = VIntCoding.readUnsignedVInt(in);
-        {
-            int flags = VIntCoding.readUnsignedVInt32(in);
-            Node.Id node = nodeIds[VIntCoding.readUnsignedVInt32(in)];
-            boundsInfo = boundsInfo.withGcBeforeBeforeAtLeast(TxnId.fromValues(prevEpoch, prevHlc, flags, node));
-        }
-        int prunedBeforeIndex = VIntCoding.readUnsignedVInt32(in) - 1;
-
-        for (int i = 0 ; i < commandCount ; ++i)
-        {
-            long header = readLeastSignificantBytes(headerByteCount, in);
-            header |= 1L << (8 * headerByteCount); // marker so we know where to shift-left most-significant bytes to
-            int commandDecodeFlags = (int)(header & 0x7);
-            InternalStatus status = InternalStatus.get(commandDecodeFlags);
-            header >>>= 3;
-            commandDecodeFlags <<= 6;
-
-            {
-                int infoMask = status.hasExecuteAtOrDeps ? 1 : 0;
-                int executeAtMask = infoMask & executeAtMasks;
-                int missingDepsMask = infoMask & missingDepsMasks;
-                commandDecodeFlags |= ((int)header & executeAtMask) << 1;
-                header >>>= executeAtMask;
-                commandDecodeFlags |= ((int)header & missingDepsMask);
-                header >>>= missingDepsMask;
-                int ballotMask = status.hasBallot ? ballotMasks : 0;
-                commandDecodeFlags |= ((int)header & ballotMask) << 2;
-                header >>>= ballotMask;
-                commandDecodeFlags |= (header & 0x7) << 3;
-                header >>= (header & overrideMask) == 0 ? overrideMask : 3;
-                decodeFlags[i] = commandDecodeFlags;
-            }
-
-            Txn.Kind kind; Domain domain; {
-                int flags = (int)header & txnIdFlagsMask;
-                kind = kindLookup(flags);
-                domain = domainLookup(flags);
-            }
-            header >>>= Integer.bitCount(txnIdFlagsMask);
-
-            boolean hlcIsNegative = false;
-            long epoch = prevEpoch;
-            int readEpochBytes = 0;
-            {
-                boolean hasEpochDelta = (header & 1) == 1;
-                header >>>= 1;
-                if (hasEpochDelta)
-                {
-                    hlcIsNegative = (header & 1) == 1;
-                    header >>>= 1;
-
-                    int epochFlag = ((int)header & 0x3);
-                    header >>>= 2;
-                    switch (epochFlag)
-                    {
-                        default: throw new AssertionError("Unexpected value not 0-3");
-                        case 0: ++epoch; break;
-                        case 1: epoch += (header & 0xf); header >>>= 4; break;
-                        case 2: readEpochBytes = 1; break;
-                        case 3: readEpochBytes = 4; break;
-                    }
-                }
-            }
-
-            Node.Id node = nodeIds[(int)(header & nodeIdMask)];
-            header >>>= bitsPerNodeId;
-
-            int readHlcBytes = getHlcBytes(hlcBytesLookup, (int)(header & 0x3));
-            header >>>= 2;
-
-            long hlc = header;
-            {
-                long highestBit = Long.highestOneBit(hlc);
-                hlc ^= highestBit;
-                int hlcShift = Long.numberOfTrailingZeros(highestBit);
-                hlc |= readLeastSignificantBytes(readHlcBytes, in) << hlcShift;
-            }
-            if (hlcIsNegative)
-                hlc = -1-hlc;
-            hlc += prevHlc;
-
-            int flags = kind != null ? 0 : in.getShort();
-            if (readEpochBytes > 0)
-                epoch += readEpochBytes == 1 ? (in.get() & 0xff) : in.getInt();
-
-            txnIds[i] = kind != null ? new TxnId(epoch, hlc, kind, domain, node)
-                                     : TxnId.fromValues(epoch, hlc, flags, node);
-
-            prevEpoch = epoch;
-            prevHlc = hlc;
-        }
-
-        int unmanagedPendingCommitCount = VIntCoding.readUnsignedVInt32(in);
-        int unmanagedCount = unmanagedPendingCommitCount + VIntCoding.readUnsignedVInt32(in);
-        Unmanaged[] unmanageds;
-        if (unmanagedCount == 0)
-        {
-            unmanageds = NO_PENDING_UNMANAGED;
-        }
-        else
-        {
-            unmanageds = new Unmanaged[unmanagedCount];
-            Unmanaged.Pending pending = unmanagedPendingCommitCount == 0 ? Unmanaged.Pending.APPLY : Unmanaged.Pending.COMMIT;
-            int offset = 0;
-            for (int i = 0 ; i < unmanagedCount ; ++i)
-            {
-                TxnId txnId = CommandSerializers.txnId.deserialize(in, ByteBufferAccessor.instance, offset);
-                offset += CommandSerializers.txnId.serializedSize();
-                Timestamp waitingUntil = CommandSerializers.timestamp.deserialize(in, ByteBufferAccessor.instance, offset);
-                offset += CommandSerializers.timestamp.serializedSize();
-                unmanageds[i] = new Unmanaged(pending, txnId, waitingUntil);
-                if (--unmanagedPendingCommitCount == 0) pending = Unmanaged.Pending.APPLY;
-            }
-            in.position(in.position() + offset);
-        }
-
-        if ((executeAtMasks | missingDepsMasks | ballotMasks) > 0)
-        {
-            TxnId[] missingIdBuffer = cachedTxnIds().get(8);
-            int missingIdCount = 0, maxIdBufferCount = 0;
-            int bitsPerTxnId = numberOfBitsToRepresent(commandCount);
-            int txnIdMask = (1 << bitsPerTxnId) - 1;
-            int bitsPerMissingId = bitsPerTxnId + 1;
-
-            int decodeExecuteAtBits = executeAtMasks > 0 ? in.getShort() & 0xffff : 0;
-            int bitsPerExecuteAtEpoch = decodeExecuteAtBits >>> 10;
-            int bitsPerExecuteAtHlc = 1 + ((decodeExecuteAtBits >>> 4) & 0x3f);
-            int bitsPerExecuteAtFlags = decodeExecuteAtBits & 0xf;
-            if (bitsPerExecuteAtFlags == 15) bitsPerExecuteAtFlags = 16;
-            int bitsPerExecuteAt = bitsPerExecuteAtEpoch + bitsPerExecuteAtHlc + bitsPerExecuteAtFlags + bitsPerNodeId;
-
-            long executeAtEpochMask = bitsPerExecuteAtEpoch == 0 ? 0 : (-1L >>> (64 - bitsPerExecuteAtEpoch));
-            long executeAtHlcMask = (-1L >>> (64 - bitsPerExecuteAtHlc));
-            long executeAtFlagsMask = bitsPerExecuteAtFlags == 0 ? 0 : (-1L >>> (64 - bitsPerExecuteAtFlags));
-
-            int decodeBallotBits = ballotMasks > 0 ? in.getShort() & 0xffff : 0;
-            int bitsPerBallotEpoch = decodeBallotBits >>> 10;
-            int bitsPerBallotHlc = 1 + ((decodeBallotBits >>> 4) & 0x3f);
-            int bitsPerBallotFlags = decodeBallotBits & 0xf;
-            if (bitsPerBallotFlags == 15) bitsPerBallotFlags = 16;
-            int bitsPerBallot = bitsPerBallotEpoch + bitsPerBallotHlc + bitsPerBallotFlags + bitsPerNodeId;
-
-            long ballotEpochMask = bitsPerBallotEpoch == 0 ? 0 : (-1L >>> (64 - bitsPerBallotEpoch));
-            long ballotHlcMask = (-1L >>> (64 - bitsPerBallotHlc));
-            long ballotFlagsMask = bitsPerBallotFlags == 0 ? 0 : (-1L >>> (64 - bitsPerBallotFlags));
-
-            Ballot prevBallot = null;
-            final BitReader reader = new BitReader();
-            for (int i = 0 ; i < commandCount ; ++i)
-            {
-                TxnId txnId = txnIds[i];
-                int commandDecodeFlags = decodeFlags[i];
-                Timestamp executeAt = txnId;
-                if ((commandDecodeFlags & HAS_EXECUTE_AT_HEADER_BIT) != 0)
-                {
-                    long epoch, hlc;
-                    int flags;
-                    Node.Id id;
-                    if (bitsPerExecuteAt <= 64)
-                    {
-                        long executeAtBits = reader.read(bitsPerExecuteAt, in);
-                        epoch = txnId.epoch() + (executeAtBits & executeAtEpochMask);
-                        executeAtBits >>>= bitsPerExecuteAtEpoch;
-                        hlc = txnId.hlc() + (executeAtBits & executeAtHlcMask);
-                        executeAtBits >>>= bitsPerExecuteAtHlc;
-                        flags = (int)(executeAtBits & executeAtFlagsMask);
-                        executeAtBits >>>= bitsPerExecuteAtFlags;
-                        id = nodeIds[(int)(executeAtBits & nodeIdMask)];
-                    }
-                    else
-                    {
-                        epoch = txnId.epoch() + reader.read(bitsPerExecuteAtEpoch, in);
-                        hlc = txnId.hlc() + reader.read(bitsPerExecuteAtHlc, in);
-                        flags = (int) reader.read(bitsPerExecuteAtFlags, in);
-                        id = nodeIds[(int)(reader.read(bitsPerNodeId, in))];
-                    }
-                    executeAt = Timestamp.fromValues(epoch, hlc, flags, id);
-                }
-
-                TxnId[] missing = NO_TXNIDS;
-                if ((commandDecodeFlags & HAS_MISSING_DEPS_HEADER_BIT) != 0)
-                {
-                    int prev = -1;
-                    while (true)
-                    {
-                        if (missingIdCount == missingIdBuffer.length)
-                            missingIdBuffer = cachedTxnIds().resize(missingIdBuffer, missingIdCount, missingIdCount * 2);
-
-                        int next = (int) reader.read(bitsPerMissingId, in);
-                        Invariants.checkState(next > prev);
-                        missingIdBuffer[missingIdCount++] = txnIds[next & txnIdMask];
-                        if (next >= commandCount)
-                            break; // finished this array
-                        prev = next;
-                    }
-
-                    missing = Arrays.copyOf(missingIdBuffer, missingIdCount);
-                    maxIdBufferCount = missingIdCount;
-                    missingIdCount = 0;
-                }
-
-                Ballot ballot = Ballot.ZERO;
-                if ((commandDecodeFlags & HAS_BALLOT_HEADER_BIT) != 0)
-                {
-                    if (prevBallot == null)
-                    {
-                        long msb = reader.read(64, in);
-                        long lsb = reader.read(64, in);
-                        Node.Id id = nodeIds[(int)(reader.read(bitsPerNodeId, in))];
-                        ballot = Ballot.fromBits(msb, lsb, id);
-                    }
-                    else
-                    {
-                        long epoch, hlc;
-                        int flags;
-                        Node.Id id;
-                        if (bitsPerExecuteAt <= 64)
-                        {
-                            long ballotBits = reader.read(bitsPerBallot, in);
-                            epoch = prevBallot.epoch() + decodeZigZag64(ballotBits & ballotEpochMask);
-                            ballotBits >>>= bitsPerBallotEpoch;
-                            hlc = prevBallot.hlc() + decodeZigZag64(ballotBits & ballotHlcMask);
-                            ballotBits >>>= bitsPerBallotHlc;
-                            flags = (int)(ballotBits & ballotFlagsMask);
-                            ballotBits >>>= bitsPerBallotFlags;
-                            id = nodeIds[(int)(ballotBits & nodeIdMask)];
-                        }
-                        else
-                        {
-                            epoch = prevBallot.epoch() + decodeZigZag64(reader.read(bitsPerBallotEpoch, in));
-                            hlc = prevBallot.hlc() + decodeZigZag64(reader.read(bitsPerBallotHlc, in));
-                            flags = (int) reader.read(bitsPerBallotFlags, in);
-                            id = nodeIds[(int)(reader.read(bitsPerNodeId, in))];
-                        }
-                        ballot = Ballot.fromValues(epoch, hlc, flags, id);
-                    }
-
-                    prevBallot = ballot;
-                }
-
-                InternalStatus status = InternalStatus.get(commandDecodeFlags >>> 6);
-                int statusOverrides = ((commandDecodeFlags >>> 3) & overrideMask) == 0 ? 0 : commandDecodeFlags >>> 4;
-                txns[i] = create(boundsInfo, txnId, status, statusOverrides, executeAt, missing, ballot);
-            }
-
-            cachedTxnIds().forceDiscard(missingIdBuffer, maxIdBufferCount);
-        }
-        else
-        {
-            for (int i = 0 ; i < commandCount ; ++i)
-            {
-                int commandDecodeFlags = decodeFlags[i];
-                InternalStatus status = InternalStatus.get(commandDecodeFlags >>> 6);
-                int statusOverrides = ((commandDecodeFlags >>> 3) & overrideMask) == 0 ? 0 : commandDecodeFlags >>> 4;
-                txns[i] = create(boundsInfo, txnIds[i], status, statusOverrides, txnIds[i], NO_TXNIDS, Ballot.ZERO);
-            }
-        }
-        cachedTxnIds().forceDiscard(txnIds, commandCount);
-
-        return CommandsForKey.SerializerSupport.create(key, txns, unmanageds, prunedBeforeIndex == -1 ? TxnId.NONE : txns[prunedBeforeIndex], boundsInfo);
-    }
-
-    private static TxnInfo create(RedundantBefore.Entry boundsInfo, @Nonnull TxnId txnId, InternalStatus status, int statusOverrides, @Nonnull Timestamp executeAt, @Nonnull TxnId[] missing, @Nonnull Ballot ballot)
-    {
-        boolean mayExecute = status.isCommittedToExecute() ? CommandsForKey.executes(boundsInfo, txnId, executeAt)
-                                                           : CommandsForKey.mayExecute(boundsInfo, txnId);
-        return TxnInfo.create(txnId, status, mayExecute, statusOverrides, executeAt, missing, ballot);
-    }
-
-    private static int getHlcBytes(int lookup, int index)
-    {
-        return (lookup >>> (index * 4)) & 0xf;
-    }
-
-    private static int setHlcBytes(int value1, int value2, int value3, int value4)
-    {
-        return value1 | (value2 << 4) | (value3 << 8) | (value4 << 12);
-    }
-
-    private static int setHlcByteDeltas(int value1, int value2, int value3, int value4)
-    {
-        value2 += 1 + value1;
-        value3 += 1 + value2;
-        value4 += 1 + value3;
-        return setHlcBytes(value1, value2, value3, value4);
-    }
-
-    private static int getHlcFlag(int flagsLookup, int bytes)
-    {
-        return (flagsLookup >>> (bytes * 2)) & 0x3;
-    }
-
-    private static int hlcBytesLookupToHlcFlagLookup(int bytesLookup)
-    {
-        int flagsLookup = 0;
-        int flagIndex = 0;
-        for (int bytesIndex = 0 ; bytesIndex < 4 ; bytesIndex++)
-        {
-            int flagLimit = getHlcBytes(bytesLookup, bytesIndex);
-            while (flagIndex <= flagLimit)
-                flagsLookup |= bytesIndex << (2 * flagIndex++);
-        }
-        return flagsLookup;
-    }
-
-    private static int compact(int[] buffer, int usedSize)
-    {
-        Arrays.sort(buffer, 0, usedSize);
-        int count = 0;
-        int j = 0;
-        while (j < usedSize)
-        {
-            int prev;
-            buffer[count++] = prev = buffer[j];
-            while (++j < usedSize && buffer[j] == prev) {}
-        }
-        return count;
-    }
-
-    private static int numberOfBitsToRepresent(long value)
-    {
-        return 64 - Long.numberOfLeadingZeros(value);
-    }
-
-    private static int numberOfBitsToRepresent(int value)
-    {
-        return 32 - Integer.numberOfLeadingZeros(value);
-    }
-
-    static final class BitReader
-    {
-        private long bitBuffer;
-        private int bitCount;
-
-        long read(int readCount, ByteBuffer in)
-        {
-            if (readCount == 64 && bitCount == 0)
-                return in.getLong();
-
-            long result = bitBuffer >>> (64 - readCount);
-            int remaining = bitCount - readCount;
-            if (remaining >= 0)
-            {
-                bitBuffer <<= readCount;
-                bitCount = remaining;
-            }
-            else if (in.remaining() >= 8)
-            {
-                readCount -= bitCount;
-                bitBuffer = in.getLong();
-                bitCount = 64 - readCount;
-                result |= (bitBuffer >>> bitCount);
-                bitBuffer <<= readCount;
-            }
-            else
-            {
-                readCount -= bitCount;
-                while (readCount > 8)
-                {
-                    long next = in.get() & 0xff;
-                    readCount -= 8;
-                    result |= next << readCount;
-                }
-                long next = in.get() & 0xff;
-                bitCount = 8 - readCount;
-                result |= next >>> bitCount;
-                bitBuffer = next << (64 - bitCount);
-            }
-            return result;
-        }
-    }
-
-    enum TxnIdFlags
-    {
-        STANDARD, EXTENDED, RAW;
-        static final int RAW_BITS = 0;
-    }
-
-    private static boolean hasNonStandardFlags(TxnId txnId)
-    {
-        if (txnId.flags() > Timestamp.IDENTITY_FLAGS)
-            return false;
-
-        int flagBits = txnIdFlagsBits(txnId, true);
-        return flagBits > 3;
-    }
-
-    private static int txnIdFlagsBits(TxnId txnId, boolean permitNonStandardFlags)
-    {
-        Txn.Kind kind = txnId.kind();
-        Domain domain = txnId.domain();
-        if (!permitNonStandardFlags && domain == Domain.Range)
-            return 0;
-
-        int offset = domain == Domain.Range ? 3 : 0;
-        switch (kind)
-        {
-            case Read: return offset + 1;
-            case Write: return offset + 2;
-            case SyncPoint: return offset + 3;
-            case ExclusiveSyncPoint:
-                if (domain == Domain.Range)
-                    return 7;
-            default:
-                return 0;
-        }
-    }
-
-    private static Domain domainLookup(int flags)
-    {
-        return flags <= 4 ? Domain.Key : Domain.Range;
-    }
-
-    private static Txn.Kind kindLookup(int flags)
-    {
-        return TXN_ID_FLAG_BITS_KIND_LOOKUP[flags];
-    }
-
-    private static final Txn.Kind[] TXN_ID_FLAG_BITS_KIND_LOOKUP = new Txn.Kind[] { null, Read, Write, SyncPoint, Read, Write, SyncPoint, ExclusiveSyncPoint };
-}
diff --git a/src/java/org/apache/cassandra/service/accord/serializers/InformDurableSerializers.java b/src/java/org/apache/cassandra/service/accord/serializers/InformDurableSerializers.java
index 59c2d461b6..43b693c89a 100644
--- a/src/java/org/apache/cassandra/service/accord/serializers/InformDurableSerializers.java
+++ b/src/java/org/apache/cassandra/service/accord/serializers/InformDurableSerializers.java
@@ -25,6 +25,7 @@ import accord.primitives.Route;
 import accord.primitives.Status;
 import accord.primitives.Timestamp;
 import accord.primitives.TxnId;
+import org.apache.cassandra.db.TypeSizes;
 import org.apache.cassandra.io.IVersionedSerializer;
 import org.apache.cassandra.io.util.DataInputPlus;
 import org.apache.cassandra.io.util.DataOutputPlus;
@@ -36,6 +37,8 @@ public class InformDurableSerializers
         @Override
         public void serializeBody(InformDurable msg, DataOutputPlus out, int version) throws IOException
         {
+            out.writeVInt(msg.minEpoch - msg.waitForEpoch);
+            out.writeVInt(msg.maxEpoch - msg.waitForEpoch);
             CommandSerializers.nullableTimestamp.serialize(msg.executeAt, out, version);
             CommandSerializers.durability.serialize(msg.durability, out, version);
         }
@@ -43,16 +46,20 @@ public class InformDurableSerializers
         @Override
         public InformDurable deserializeBody(DataInputPlus in, int version, TxnId txnId, Route<?> scope, long waitForEpoch) throws IOException
         {
+            long minEpoch = waitForEpoch + in.readVInt();
+            long maxEpoch = waitForEpoch + in.readVInt();
             Timestamp executeAt = CommandSerializers.nullableTimestamp.deserialize(in, version);
             Status.Durability durability = CommandSerializers.durability.deserialize(in, version);
-            return InformDurable.SerializationSupport.create(txnId, scope, waitForEpoch, executeAt, durability);
+            return InformDurable.SerializationSupport.create(txnId, scope, executeAt, minEpoch, waitForEpoch, maxEpoch, durability);
         }
 
         @Override
         public long serializedBodySize(InformDurable msg, int version)
         {
-            return CommandSerializers.nullableTimestamp.serializedSize(msg.executeAt, version)
-            + CommandSerializers.durability.serializedSize(msg.durability, version);
+            return   TypeSizes.sizeofVInt(msg.minEpoch - msg.waitForEpoch)
+                   + TypeSizes.sizeofVInt(msg.maxEpoch - msg.waitForEpoch)
+                   + CommandSerializers.nullableTimestamp.serializedSize(msg.executeAt, version)
+                   + CommandSerializers.durability.serializedSize(msg.durability, version);
         }
     };
 }
diff --git a/src/java/org/apache/cassandra/service/accord/serializers/KeySerializers.java b/src/java/org/apache/cassandra/service/accord/serializers/KeySerializers.java
index f6dc4d4aeb..f6b641f859 100644
--- a/src/java/org/apache/cassandra/service/accord/serializers/KeySerializers.java
+++ b/src/java/org/apache/cassandra/service/accord/serializers/KeySerializers.java
@@ -582,8 +582,8 @@ public class KeySerializers
         Range[] ranges = new Range[blobMap.size()];
         for (Map.Entry<ByteBuffer, ByteBuffer> e : blobMap.entrySet())
         {
-            ranges[i++] = new TokenRange(AccordRoutingKey.serializer.deserialize(e.getKey()),
-                                         AccordRoutingKey.serializer.deserialize(e.getValue()));
+            ranges[i++] = TokenRange.create(AccordRoutingKey.serializer.deserialize(e.getKey()),
+                                            AccordRoutingKey.serializer.deserialize(e.getValue()));
         }
         return Ranges.of(ranges);
     }
diff --git a/src/java/org/apache/cassandra/service/accord/serializers/LatestDepsSerializers.java b/src/java/org/apache/cassandra/service/accord/serializers/LatestDepsSerializers.java
new file mode 100644
index 0000000000..ccb89ada56
--- /dev/null
+++ b/src/java/org/apache/cassandra/service/accord/serializers/LatestDepsSerializers.java
@@ -0,0 +1,158 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.cassandra.service.accord.serializers;
+
+import java.io.IOException;
+
+import accord.api.RoutingKey;
+import accord.messages.GetLatestDeps;
+import accord.messages.GetLatestDeps.GetLatestDepsOk;
+import accord.primitives.Ballot;
+import accord.primitives.Deps;
+import accord.primitives.Known;
+import accord.primitives.LatestDeps;
+import accord.primitives.Route;
+import accord.primitives.Timestamp;
+import accord.primitives.TxnId;
+import org.apache.cassandra.db.TypeSizes;
+import org.apache.cassandra.io.IVersionedSerializer;
+import org.apache.cassandra.io.util.DataInputPlus;
+import org.apache.cassandra.io.util.DataOutputPlus;
+
+public class LatestDepsSerializers
+{
+    public static final IVersionedSerializer<LatestDeps> latestDeps = new IVersionedSerializer<LatestDeps>()
+    {
+        @Override
+        public void serialize(LatestDeps t, DataOutputPlus out, int version) throws IOException
+        {
+            out.writeUnsignedVInt32(t.size());
+            for (int i = 0 ; i < t.size() ; ++i)
+            {
+                RoutingKey start = t.startAt(i);
+                KeySerializers.routingKey.serialize(start, out, version);
+                LatestDeps.LatestEntry e = t.valueAt(i);
+                if (e == null)
+                {
+                    CommandSerializers.nullableKnownDeps.serialize(null, out, version);
+                }
+                else
+                {
+                    CommandSerializers.nullableKnownDeps.serialize(e.known, out, version);
+                    CommandSerializers.ballot.serialize(e.ballot, out, version);
+                    DepsSerializers.nullableDeps.serialize(e.coordinatedDeps, out, version);
+                    DepsSerializers.nullableDeps.serialize(e.localDeps, out, version);
+                }
+            }
+            KeySerializers.routingKey.serialize(t.startAt(t.size()), out, version);
+        }
+
+        @Override
+        public LatestDeps deserialize(DataInputPlus in, int version) throws IOException
+        {
+            int size = in.readUnsignedVInt32();
+            RoutingKey[] starts = new RoutingKey[size + 1];
+            LatestDeps.LatestEntry[] values = new LatestDeps.LatestEntry[size];
+            for (int i = 0 ; i < size ; ++i)
+            {
+                starts[i] = KeySerializers.routingKey.deserialize(in, version);
+                Known.KnownDeps knownDeps = CommandSerializers.nullableKnownDeps.deserialize(in, version);
+                if (knownDeps == null)
+                    continue;
+
+                Ballot ballot = CommandSerializers.ballot.deserialize(in, version);
+                Deps coordinatedDeps = DepsSerializers.nullableDeps.deserialize(in, version);
+                Deps localDeps = DepsSerializers.nullableDeps.deserialize(in, version);
+                values[i] = new LatestDeps.LatestEntry(knownDeps, ballot, coordinatedDeps, localDeps);
+            }
+            starts[size] = KeySerializers.routingKey.deserialize(in, version);
+
+            return LatestDeps.SerializerSupport.create(true, starts, values);
+        }
+
+        @Override
+        public long serializedSize(LatestDeps t, int version)
+        {
+            long size = 0;
+            size += TypeSizes.sizeofUnsignedVInt(t.size());
+            for (int i = 0 ; i < t.size() ; ++i)
+            {
+                RoutingKey start = t.startAt(i);
+                size += KeySerializers.routingKey.serializedSize(start, version);
+                LatestDeps.LatestEntry e = t.valueAt(i);
+                if (e == null)
+                {
+                    size += CommandSerializers.nullableKnownDeps.serializedSize(null, version);
+                }
+                else
+                {
+                    size += CommandSerializers.nullableKnownDeps.serializedSize(e.known, version);
+                    size += CommandSerializers.ballot.serializedSize(e.ballot, version);
+                    size += DepsSerializers.nullableDeps.serializedSize(e.coordinatedDeps, version);
+                    size += DepsSerializers.nullableDeps.serializedSize(e.localDeps, version);
+                }
+            }
+            size += KeySerializers.routingKey.serializedSize(t.startAt(t.size()), version);
+            return size;
+        }
+    };
+
+    public static final IVersionedSerializer<GetLatestDeps> request = new TxnRequestSerializer.WithUnsyncedSerializer<>()
+    {
+        @Override
+        public void serializeBody(GetLatestDeps msg, DataOutputPlus out, int version) throws IOException
+        {
+            CommandSerializers.timestamp.serialize(msg.executeAt, out, version);
+        }
+
+        @Override
+        public GetLatestDeps deserializeBody(DataInputPlus in, int version, TxnId txnId, Route<?> scope, long waitForEpoch, long minEpoch) throws IOException
+        {
+            Timestamp executeAt = CommandSerializers.timestamp.deserialize(in, version);
+            return GetLatestDeps.SerializationSupport.create(txnId, scope, waitForEpoch, minEpoch, executeAt);
+        }
+
+        @Override
+        public long serializedBodySize(GetLatestDeps msg, int version)
+        {
+            return CommandSerializers.timestamp.serializedSize(msg.executeAt, version);
+        }
+    };
+
+    public static final IVersionedSerializer<GetLatestDepsOk> reply = new IVersionedSerializer<>()
+    {
+        @Override
+        public void serialize(GetLatestDepsOk reply, DataOutputPlus out, int version) throws IOException
+        {
+            latestDeps.serialize(reply.deps, out, version);
+        }
+
+        @Override
+        public GetLatestDepsOk deserialize(DataInputPlus in, int version) throws IOException
+        {
+            return new GetLatestDepsOk(latestDeps.deserialize(in, version));
+        }
+
+        @Override
+        public long serializedSize(GetLatestDepsOk reply, int version)
+        {
+            return latestDeps.serializedSize(reply.deps, version);
+        }
+    };
+}
diff --git a/src/java/org/apache/cassandra/service/accord/serializers/RecoverySerializers.java b/src/java/org/apache/cassandra/service/accord/serializers/RecoverySerializers.java
index 9e0063f288..3b4a78d404 100644
--- a/src/java/org/apache/cassandra/service/accord/serializers/RecoverySerializers.java
+++ b/src/java/org/apache/cassandra/service/accord/serializers/RecoverySerializers.java
@@ -23,7 +23,6 @@ import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
 
 import accord.api.Result;
-import accord.api.RoutingKey;
 import accord.messages.BeginRecovery;
 import accord.messages.BeginRecovery.RecoverNack;
 import accord.messages.BeginRecovery.RecoverOk;
@@ -31,7 +30,6 @@ import accord.messages.BeginRecovery.RecoverReply;
 import accord.primitives.Ballot;
 import accord.primitives.Deps;
 import accord.primitives.FullRoute;
-import accord.primitives.Known.KnownDeps;
 import accord.primitives.LatestDeps;
 import accord.primitives.PartialTxn;
 import accord.primitives.Route;
@@ -45,6 +43,8 @@ import org.apache.cassandra.io.util.DataInputPlus;
 import org.apache.cassandra.io.util.DataOutputPlus;
 import org.apache.cassandra.service.accord.serializers.TxnRequestSerializer.WithUnsyncedSerializer;
 
+import static accord.messages.BeginRecovery.RecoverReply.Kind.Ok;
+import static org.apache.cassandra.service.accord.serializers.LatestDepsSerializers.latestDeps;
 import static org.apache.cassandra.utils.NullableSerializer.deserializeNullable;
 import static org.apache.cassandra.utils.NullableSerializer.serializeNullable;
 import static org.apache.cassandra.utils.NullableSerializer.serializedNullableSize;
@@ -84,6 +84,7 @@ public class RecoverySerializers
 
     public static final IVersionedSerializer<RecoverReply> reply = new IVersionedSerializer<RecoverReply>()
     {
+        final RecoverReply.Kind[] kinds = RecoverReply.Kind.values();
         void serializeNack(RecoverNack recoverNack, DataOutputPlus out, int version) throws IOException
         {
             CommandSerializers.nullableBallot.serialize(recoverNack.supersededBy, out, version);
@@ -98,24 +99,22 @@ public class RecoverySerializers
             latestDeps.serialize(recoverOk.deps, out, version);
             DepsSerializers.deps.serialize(recoverOk.earlierCommittedWitness, out, version);
             DepsSerializers.deps.serialize(recoverOk.earlierAcceptedNoWitness, out, version);
-            out.writeBoolean(recoverOk.acceptsFastPath);
-            out.writeBoolean(recoverOk.rejectsFastPath);
+            out.writeBoolean(recoverOk.selfAcceptsFastPath);
+            out.writeBoolean(recoverOk.supersedingRejects);
             CommandSerializers.nullableWrites.serialize(recoverOk.writes, out, version);
         }
 
         @Override
         public void serialize(RecoverReply reply, DataOutputPlus out, int version) throws IOException
         {
-            out.writeBoolean(reply.isOk());
-            if (!reply.isOk())
-                serializeNack((RecoverNack) reply, out, version);
-            else
-                serializeOk((RecoverOk) reply, out, version);
+            out.writeByte(reply.kind().ordinal());
+            if (reply.kind() == Ok) serializeOk((RecoverOk) reply, out, version);
+            else serializeNack((RecoverNack) reply, out, version);
         }
 
-        RecoverNack deserializeNack(Ballot supersededBy, DataInputPlus in, int version)
+        RecoverNack deserializeNack(RecoverReply.Kind kind, Ballot supersededBy, DataInputPlus in, int version)
         {
-            return new RecoverNack(supersededBy);
+            return new RecoverNack(kind, supersededBy);
         }
 
         RecoverOk deserializeOk(TxnId txnId, Status status, Ballot accepted, Timestamp executeAt, @Nonnull LatestDeps deps, Deps earlierCommittedWitness, Deps earlierAcceptedNoWitness, boolean acceptsFastPath, boolean rejectsFastPath, Writes writes, Result result, DataInputPlus in, int version)
@@ -126,9 +125,9 @@ public class RecoverySerializers
         @Override
         public RecoverReply deserialize(DataInputPlus in, int version) throws IOException
         {
-            boolean isOk = in.readBoolean();
-            if (!isOk)
-                return deserializeNack(CommandSerializers.nullableBallot.deserialize(in, version), in, version);
+            RecoverReply.Kind kind = kinds[in.readByte()];
+            if (kind != Ok)
+                return deserializeNack(kind, CommandSerializers.nullableBallot.deserialize(in, version), in, version);
 
             TxnId id = CommandSerializers.txnId.deserialize(in, version);
             Status status = CommandSerializers.status.deserialize(in, version);
@@ -166,8 +165,8 @@ public class RecoverySerializers
             size += latestDeps.serializedSize(recoverOk.deps, version);
             size += DepsSerializers.deps.serializedSize(recoverOk.earlierCommittedWitness, version);
             size += DepsSerializers.deps.serializedSize(recoverOk.earlierAcceptedNoWitness, version);
-            size += TypeSizes.sizeof(recoverOk.acceptsFastPath);
-            size += TypeSizes.sizeof(recoverOk.rejectsFastPath);
+            size += TypeSizes.sizeof(recoverOk.selfAcceptsFastPath);
+            size += TypeSizes.sizeof(recoverOk.supersedingRejects);
             size += CommandSerializers.nullableWrites.serializedSize(recoverOk.writes, version);
             return size;
         }
@@ -175,84 +174,8 @@ public class RecoverySerializers
         @Override
         public long serializedSize(RecoverReply reply, int version)
         {
-            return TypeSizes.sizeof(reply.isOk())
-                   + (reply.isOk() ? serializedOkSize((RecoverOk) reply, version) : serializedNackSize((RecoverNack) reply, version));
-        }
-    };
-
-    public static final IVersionedSerializer<LatestDeps> latestDeps = new IVersionedSerializer<LatestDeps>()
-    {
-        @Override
-        public void serialize(LatestDeps t, DataOutputPlus out, int version) throws IOException
-        {
-            out.writeUnsignedVInt32(t.size());
-            for (int i = 0 ; i < t.size() ; ++i)
-            {
-                RoutingKey start = t.startAt(i);
-                KeySerializers.routingKey.serialize(start, out, version);
-                LatestDeps.LatestEntry e = t.valueAt(i);
-                if (e == null)
-                {
-                    CommandSerializers.nullableKnownDeps.serialize(null, out, version);
-                }
-                else
-                {
-                    CommandSerializers.nullableKnownDeps.serialize(e.known, out, version);
-                    CommandSerializers.ballot.serialize(e.ballot, out, version);
-                    DepsSerializers.nullableDeps.serialize(e.coordinatedDeps, out, version);
-                    DepsSerializers.nullableDeps.serialize(e.localDeps, out, version);
-                }
-            }
-            KeySerializers.routingKey.serialize(t.startAt(t.size()), out, version);
-        }
-
-        @Override
-        public LatestDeps deserialize(DataInputPlus in, int version) throws IOException
-        {
-            int size = in.readUnsignedVInt32();
-            RoutingKey[] starts = new RoutingKey[size + 1];
-            LatestDeps.LatestEntry[] values = new LatestDeps.LatestEntry[size];
-            for (int i = 0 ; i < size ; ++i)
-            {
-                starts[i] = KeySerializers.routingKey.deserialize(in, version);
-                KnownDeps knownDeps = CommandSerializers.nullableKnownDeps.deserialize(in, version);
-                if (knownDeps == null)
-                    continue;
-
-                Ballot ballot = CommandSerializers.ballot.deserialize(in, version);
-                Deps coordinatedDeps = DepsSerializers.nullableDeps.deserialize(in, version);
-                Deps localDeps = DepsSerializers.nullableDeps.deserialize(in, version);
-                values[i] = new LatestDeps.LatestEntry(knownDeps, ballot, coordinatedDeps, localDeps);
-            }
-            starts[size] = KeySerializers.routingKey.deserialize(in, version);
-
-            return LatestDeps.SerializerSupport.create(true, starts, values);
-        }
-
-        @Override
-        public long serializedSize(LatestDeps t, int version)
-        {
-            long size = 0;
-            size += TypeSizes.sizeofUnsignedVInt(t.size());
-            for (int i = 0 ; i < t.size() ; ++i)
-            {
-                RoutingKey start = t.startAt(i);
-                size += KeySerializers.routingKey.serializedSize(start, version);
-                LatestDeps.LatestEntry e = t.valueAt(i);
-                if (e == null)
-                {
-                    size += CommandSerializers.nullableKnownDeps.serializedSize(null, version);
-                }
-                else
-                {
-                    size += CommandSerializers.nullableKnownDeps.serializedSize(e.known, version);
-                    size += CommandSerializers.ballot.serializedSize(e.ballot, version);
-                    size += DepsSerializers.nullableDeps.serializedSize(e.coordinatedDeps, version);
-                    size += DepsSerializers.nullableDeps.serializedSize(e.localDeps, version);
-                }
-            }
-            size += KeySerializers.routingKey.serializedSize(t.startAt(t.size()), version);
-            return size;
+            return TypeSizes.BYTE_SIZE
+                   + (reply.kind() == Ok ? serializedOkSize((RecoverOk) reply, version) : serializedNackSize((RecoverNack) reply, version));
         }
     };
 }
diff --git a/src/java/org/apache/cassandra/service/accord/serializers/SetDurableSerializers.java b/src/java/org/apache/cassandra/service/accord/serializers/SetDurableSerializers.java
index b607ae5c3d..dd2df26abf 100644
--- a/src/java/org/apache/cassandra/service/accord/serializers/SetDurableSerializers.java
+++ b/src/java/org/apache/cassandra/service/accord/serializers/SetDurableSerializers.java
@@ -24,6 +24,7 @@ import accord.messages.SetShardDurable;
 import accord.primitives.Deps;
 import accord.primitives.FullRoute;
 import accord.primitives.SyncPoint;
+import accord.primitives.Timestamp;
 import accord.primitives.TxnId;
 import org.apache.cassandra.io.IVersionedSerializer;
 import org.apache.cassandra.io.util.DataInputPlus;
@@ -79,6 +80,7 @@ public class SetDurableSerializers
         public void serialize(SyncPoint sp, DataOutputPlus out, int version) throws IOException
         {
             CommandSerializers.txnId.serialize(sp.syncId, out, version);
+            CommandSerializers.timestamp.serialize(sp.executeAt, out, version);
             DepsSerializers.deps.serialize(sp.waitFor, out, version);
             KeySerializers.fullRoute.serialize(sp.route, out, version);
         }
@@ -87,15 +89,17 @@ public class SetDurableSerializers
         public SyncPoint deserialize(DataInputPlus in, int version) throws IOException
         {
             TxnId syncId = CommandSerializers.txnId.deserialize(in, version);
+            Timestamp executeAt = CommandSerializers.timestamp.deserialize(in, version);
             Deps waitFor = DepsSerializers.deps.deserialize(in, version);
             FullRoute<?> route = KeySerializers.fullRoute.deserialize(in, version);
-            return SyncPoint.SerializationSupport.construct(syncId, waitFor, route);
+            return SyncPoint.SerializationSupport.construct(syncId, executeAt, waitFor, route);
         }
 
         @Override
         public long serializedSize(SyncPoint sp, int version)
         {
-            return CommandSerializers.txnId.serializedSize(sp.syncId, version)
+            return   CommandSerializers.txnId.serializedSize(sp.syncId, version)
+                   + CommandSerializers.timestamp.serializedSize(sp.executeAt, version)
                    + DepsSerializers.deps.serializedSize(sp.waitFor, version)
                    + KeySerializers.fullRoute.serializedSize(sp.route, version);
         }
diff --git a/src/java/org/apache/cassandra/service/accord/serializers/WaitingOnSerializer.java b/src/java/org/apache/cassandra/service/accord/serializers/WaitingOnSerializer.java
index 4c474d26c7..7ff8d87333 100644
--- a/src/java/org/apache/cassandra/service/accord/serializers/WaitingOnSerializer.java
+++ b/src/java/org/apache/cassandra/service/accord/serializers/WaitingOnSerializer.java
@@ -21,11 +21,13 @@ package org.apache.cassandra.service.accord.serializers;
 import java.io.IOException;
 import java.nio.ByteBuffer;
 
+import accord.local.Command;
 import accord.local.Command.WaitingOn;
 import accord.primitives.KeyDeps;
 import accord.primitives.RangeDeps;
 import accord.primitives.Routable;
 import accord.primitives.RoutingKeys;
+import accord.primitives.Timestamp;
 import accord.primitives.TxnId;
 import accord.utils.ImmutableBitSet;
 import accord.utils.Invariants;
@@ -41,7 +43,10 @@ public class WaitingOnSerializer
         int keyCount = waitingOn.keys.size();
         int txnIdCount = waitingOn.txnIdCount();
         int waitingOnLength = (txnIdCount + keyCount + 63) / 64;
-        long size = serializedSize(waitingOnLength, waitingOn.waitingOn);
+        long size = 1;
+        if (waitingOn.executeAtLeast() != null)
+            size += CommandSerializers.timestamp.serializedSize();
+        size += serializedSize(waitingOnLength, waitingOn.waitingOn);
         size += TypeSizes.sizeofUnsignedVInt(keyCount);
         size += TypeSizes.sizeofUnsignedVInt(txnIdCount);
         if (waitingOn.appliedOrInvalidated == null)
@@ -68,8 +73,17 @@ public class WaitingOnSerializer
         if (waitingOn.appliedOrInvalidated != null)
             appliedOrInvalidatedLength = (txnIdCount + 63) / 64;
 
-        ByteBuffer out = ByteBuffer.allocate(TypeSizes.sizeofUnsignedVInt(keyCount) + TypeSizes.sizeofUnsignedVInt(txnIdCount)
+        Timestamp executeAtLeast = waitingOn.executeAtLeast();
+        ByteBuffer out = ByteBuffer.allocate(1 + (executeAtLeast == null ? 0 : CommandSerializers.timestamp.serializedSize())
+                                             + TypeSizes.sizeofUnsignedVInt(keyCount) + TypeSizes.sizeofUnsignedVInt(txnIdCount)
                                              + TypeSizes.LONG_SIZE * (waitingOnLength + appliedOrInvalidatedLength));
+
+        if (executeAtLeast == null) out.put((byte)0);
+        else
+        {
+            out.put((byte) 1);
+            CommandSerializers.timestamp.serialize(executeAtLeast, out);
+        }
         VIntCoding.writeUnsignedVInt32(keyCount, out);
         VIntCoding.writeUnsignedVInt32(txnIdCount, out);
         serialize(waitingOnLength, waitingOn.waitingOn, out);
@@ -91,6 +105,13 @@ public class WaitingOnSerializer
         int txnIdCount = directRangeDeps.txnIdCount() + directKeyDeps.txnIdCount();
         int waitingOnLength = (txnIdCount + keys.size() + 63) / 64;
         int position = in.position();
+        int flags = in.get(position++);
+        Timestamp executesAtLeast = null;
+        if ((flags & 1) != 0)
+        {
+            executesAtLeast = CommandSerializers.timestamp.deserialize(in, position);
+            position += CommandSerializers.timestamp.serializedSize();
+        }
         int a = VIntCoding.readUnsignedVInt32(in, position);
         position += TypeSizes.sizeofUnsignedVInt(a);
         int b = VIntCoding.readUnsignedVInt32(in, position);
@@ -103,7 +124,11 @@ public class WaitingOnSerializer
             int appliedOrInvalidatedLength = (txnIdCount + 63) / 64;
             appliedOrInvalidated = deserialize(position, appliedOrInvalidatedLength, in);
         }
-        return new WaitingOn(keys, directRangeDeps, directKeyDeps, waitingOn, appliedOrInvalidated);
+
+        WaitingOn result = new WaitingOn(keys, directRangeDeps, directKeyDeps, waitingOn, appliedOrInvalidated);
+        if (executesAtLeast != null)
+            result = new Command.WaitingOnWithExecuteAt(result, executesAtLeast);
+        return result;
     }
 
     private static ImmutableBitSet deserialize(int position, int length, ByteBuffer in)
diff --git a/src/java/org/apache/cassandra/service/accord/txn/TxnRangeRead.java b/src/java/org/apache/cassandra/service/accord/txn/TxnRangeRead.java
index 3c94f0f8b9..1e592faed5 100644
--- a/src/java/org/apache/cassandra/service/accord/txn/TxnRangeRead.java
+++ b/src/java/org/apache/cassandra/service/accord/txn/TxnRangeRead.java
@@ -140,7 +140,7 @@ public class TxnRangeRead extends AbstractSerialized<ReadCommand> implements Txn
                 stopAccordRoutingKey = new TokenKey(tableId, stopToken);
             else
                 stopAccordRoutingKey = new MinTokenKey(tableId, stopToken);
-            accordRanges[i] = new TokenRange(startAccordRoutingKey, stopAccordRoutingKey);
+            accordRanges[i] = TokenRange.create(startAccordRoutingKey, stopAccordRoutingKey);
         }
         covering = Ranges.of(accordRanges);
     }
diff --git a/src/java/org/apache/cassandra/service/consensus/migration/TableMigrationState.java b/src/java/org/apache/cassandra/service/consensus/migration/TableMigrationState.java
index 95013b3e88..636fdcb64e 100644
--- a/src/java/org/apache/cassandra/service/consensus/migration/TableMigrationState.java
+++ b/src/java/org/apache/cassandra/service/consensus/migration/TableMigrationState.java
@@ -168,7 +168,7 @@ public class TableMigrationState
     public boolean hasMigratedFullTokenRange(IPartitioner partitioner)
     {
         // migrated ranges are normalized
-        if (!migratingRanges.isEmpty() || migratedRanges.size() > 1)
+        if (!migratingRanges.isEmpty() || migratedRanges.size() != 1)
             return false;
 
         Range<Token> fullRange = new Range<>(partitioner.getMinimumToken(), partitioner.getMinimumToken());
diff --git a/test/distributed/org/apache/cassandra/distributed/test/accord/AccordMetricsTest.java b/test/distributed/org/apache/cassandra/distributed/test/accord/AccordMetricsTest.java
index 4f87534942..0ee6f72e43 100644
--- a/test/distributed/org/apache/cassandra/distributed/test/accord/AccordMetricsTest.java
+++ b/test/distributed/org/apache/cassandra/distributed/test/accord/AccordMetricsTest.java
@@ -266,7 +266,7 @@ public class AccordMetricsTest extends AccordTestBase
         DefaultNameFactory nameFactory = new DefaultNameFactory(AccordMetrics.ACCORD_REPLICA, scope);
         Map<String, Long> metrics = diff(countingMetrics0).get(node);
         Function<String, Long> metric = n -> metrics.get(nameFactory.createMetricName(n).getMetricName());
-        assertThat(metric.apply(AccordMetrics.STABLE_LATENCY)).isEqualTo(stable);
+        assertThat(metric.apply(AccordMetrics.STABLE_LATENCY)).isLessThanOrEqualTo(stable);
         assertThat(metric.apply(AccordMetrics.EXECUTE_LATENCY)).isEqualTo(executions);
         assertThat(metric.apply(AccordMetrics.APPLY_LATENCY)).isEqualTo(applications);
         assertThat(metric.apply(AccordMetrics.APPLY_DURATION)).isEqualTo(applications);
diff --git a/test/distributed/org/apache/cassandra/distributed/test/accord/AccordTestBase.java b/test/distributed/org/apache/cassandra/distributed/test/accord/AccordTestBase.java
index 6fda5270d3..e61ff43766 100644
--- a/test/distributed/org/apache/cassandra/distributed/test/accord/AccordTestBase.java
+++ b/test/distributed/org/apache/cassandra/distributed/test/accord/AccordTestBase.java
@@ -90,7 +90,6 @@ import org.apache.cassandra.io.util.DataInputPlus;
 import org.apache.cassandra.io.util.DataOutputBuffer;
 import org.apache.cassandra.net.Message;
 import org.apache.cassandra.net.Verb;
-import org.apache.cassandra.service.accord.AccordService;
 import org.apache.cassandra.service.accord.api.AccordRoutingKey;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.accord.exceptions.ReadPreemptedException;
@@ -204,7 +203,7 @@ public abstract class AccordTestBase extends TestBaseImpl
             SHARED_CLUSTER.schemaChange(ddl);
 
         // Evict commands from the cache immediately to expose problems loading from disk.
-        SHARED_CLUSTER.forEach(node -> node.runOnInstance(() -> AccordService.instance().setCacheSize(0)));
+//        SHARED_CLUSTER.forEach(node -> node.runOnInstance(() -> AccordService.instance().setCacheSize(0)));
 
         try
         {
diff --git a/test/distributed/org/apache/cassandra/service/accord/BurnTestKeySerializers.java b/test/distributed/org/apache/cassandra/service/accord/BurnTestKeySerializers.java
index 597b369199..c19fcbd27d 100644
--- a/test/distributed/org/apache/cassandra/service/accord/BurnTestKeySerializers.java
+++ b/test/distributed/org/apache/cassandra/service/accord/BurnTestKeySerializers.java
@@ -134,7 +134,7 @@ public class BurnTestKeySerializers
         {
             RoutingKey start = routingKey.deserialize(in, version);
             RoutingKey end = routingKey.deserialize(in, version);
-            return new PrefixedIntHashKey.Range((PrefixedIntHashKey.PrefixedIntRoutingKey) start, (PrefixedIntHashKey.PrefixedIntRoutingKey) end);
+            return PrefixedIntHashKey.range((PrefixedIntHashKey.PrefixedIntRoutingKey) start, (PrefixedIntHashKey.PrefixedIntRoutingKey) end);
         }
 
         @Override
diff --git a/test/simulator/main/org/apache/cassandra/simulator/paxos/StrictSerializabilityValidator.java b/test/simulator/main/org/apache/cassandra/simulator/paxos/StrictSerializabilityValidator.java
index 7cc4104c79..332bb3d660 100644
--- a/test/simulator/main/org/apache/cassandra/simulator/paxos/StrictSerializabilityValidator.java
+++ b/test/simulator/main/org/apache/cassandra/simulator/paxos/StrictSerializabilityValidator.java
@@ -63,7 +63,7 @@ public class StrictSerializabilityValidator implements HistoryValidator
             @Override
             public void close()
             {
-                convertHistoryViolation(() -> verifier.apply(start, end));
+                convertHistoryViolation(() -> verifier.apply("", start, end));
             }
         };
     }
diff --git a/test/simulator/test/org/apache/cassandra/simulator/test/EpochStressTest.java b/test/simulator/test/org/apache/cassandra/simulator/test/EpochStressTest.java
index 1474f4da6e..2f1d635392 100644
--- a/test/simulator/test/org/apache/cassandra/simulator/test/EpochStressTest.java
+++ b/test/simulator/test/org/apache/cassandra/simulator/test/EpochStressTest.java
@@ -224,7 +224,7 @@ public class EpochStressTest extends SimulationTestBase
     private static boolean isDone(ConfigurationService.EpochReady ready)
     {
         return ready.metadata.isDone()
-               && ready.fastPath.isDone()
+               && ready.coordinate.isDone()
                && ready.data.isDone()
                && ready.reads.isDone();
     }
diff --git a/test/unit/org/apache/cassandra/db/compaction/CompactionAccordIteratorsTest.java b/test/unit/org/apache/cassandra/db/compaction/CompactionAccordIteratorsTest.java
index b6ecc52140..5e45b39251 100644
--- a/test/unit/org/apache/cassandra/db/compaction/CompactionAccordIteratorsTest.java
+++ b/test/unit/org/apache/cassandra/db/compaction/CompactionAccordIteratorsTest.java
@@ -49,6 +49,7 @@ import accord.local.DurableBefore;
 import accord.local.RedundantBefore;
 import accord.local.StoreParticipants;
 import accord.local.cfk.CommandsForKey;
+import accord.local.cfk.Serialize;
 import accord.primitives.Ballot;
 import accord.primitives.Deps;
 import accord.primitives.FullRoute;
@@ -93,7 +94,6 @@ import org.apache.cassandra.service.accord.AccordService;
 import org.apache.cassandra.service.accord.AccordTestUtils;
 import org.apache.cassandra.service.accord.IAccordService;
 import org.apache.cassandra.service.accord.api.AccordRoutingKey.TokenKey;
-import org.apache.cassandra.service.accord.serializers.CommandsForKeySerializer;
 import org.apache.cassandra.utils.FBUtilities;
 import org.apache.cassandra.utils.Pair;
 import org.assertj.core.api.Assertions;
@@ -531,7 +531,7 @@ public class CompactionAccordIteratorsTest
         UntypedResultSet commandsForKeyTable = QueryProcessor.executeInternal("SELECT * FROM " + ACCORD_KEYSPACE_NAME + "." + COMMANDS_FOR_KEY + ";");
         logger.info(commandsForKeyTable.toStringUnsafe());
         assertEquals(1, commandsForKeyTable.size());
-        CommandsForKey cfk = CommandsForKeySerializer.fromBytes(((Key) key).toUnseekable(), commandsForKeyTable.iterator().next().getBytes("data"));
+        CommandsForKey cfk = Serialize.fromBytes(((Key) key).toUnseekable(), commandsForKeyTable.iterator().next().getBytes("data"));
         assertEquals(txnIds.length, cfk.size());
         for (int i = 0; i < txnIds.length; ++i)
             assertEquals(txnIds[i], cfk.txnId(i));
diff --git a/test/unit/org/apache/cassandra/dht/PartitionerTestCase.java b/test/unit/org/apache/cassandra/dht/PartitionerTestCase.java
index 1d68475cd9..96a5b22837 100644
--- a/test/unit/org/apache/cassandra/dht/PartitionerTestCase.java
+++ b/test/unit/org/apache/cassandra/dht/PartitionerTestCase.java
@@ -289,9 +289,9 @@ public abstract class PartitionerTestCase
         if (less.equals(more) && less.isMinimum())
             ranges = Ranges.EMPTY;
         else if (less.equals(more))
-            ranges = Ranges.of(new TokenRange(new TokenKey(TABLE_ID1, partitioner.getMinimumToken()), new TokenKey(TABLE_ID1, less)));
+            ranges = Ranges.of(TokenRange.create(new TokenKey(TABLE_ID1, partitioner.getMinimumToken()), new TokenKey(TABLE_ID1, less)));
         else
-            ranges = Ranges.of(new TokenRange(new TokenKey(TABLE_ID1, less), new TokenKey(TABLE_ID1, more)));
+            ranges = Ranges.of(TokenRange.create(new TokenKey(TABLE_ID1, less), new TokenKey(TABLE_ID1, more)));
 
         AccordSplitter splitter = partitioner.accordSplitter().apply(ranges);
         BigInteger lv = splitter.valueForToken(less);
@@ -304,11 +304,11 @@ public abstract class PartitionerTestCase
 
     void testSplitter(Token start, Token end)
     {
-        accord.primitives.Range range = new TokenRange(new TokenKey(TABLE_ID1, start), new TokenKey(TABLE_ID1, end));
+        accord.primitives.Range range = TokenRange.create(new TokenKey(TABLE_ID1, start), new TokenKey(TABLE_ID1, end));
         AccordSplitter splitter = partitioner.accordSplitter().apply(Ranges.of(range));
         if (!start.isMinimum())
-            testSplitter(new TokenRange(new TokenKey(TABLE_ID1, partitioner.getMinimumToken()), new TokenKey(TABLE_ID1, start)));
-        testSplitter(new TokenRange(new TokenKey(TABLE_ID1, start), new TokenKey(TABLE_ID1, splitter.tokenForValue(splitter.maximumValue()))));
+            testSplitter(TokenRange.create(new TokenKey(TABLE_ID1, partitioner.getMinimumToken()), new TokenKey(TABLE_ID1, start)));
+        testSplitter(TokenRange.create(new TokenKey(TABLE_ID1, start), new TokenKey(TABLE_ID1, splitter.tokenForValue(splitter.maximumValue()))));
         checkRoundTrip(start, splitter.tokenForValue(splitter.valueForToken(start)));
         checkRoundTrip(end, splitter.tokenForValue(splitter.valueForToken(end)));
     }
diff --git a/test/unit/org/apache/cassandra/index/accord/AccordIndexStressTest.java b/test/unit/org/apache/cassandra/index/accord/AccordIndexStressTest.java
index f660d4e1c2..79cc0b66b0 100644
--- a/test/unit/org/apache/cassandra/index/accord/AccordIndexStressTest.java
+++ b/test/unit/org/apache/cassandra/index/accord/AccordIndexStressTest.java
@@ -512,7 +512,7 @@ public class AccordIndexStressTest extends CQLTester
                         default:
                             throw new IllegalArgumentException("Unknown pattern: " + pattern);
                     }
-                    ranges.add(new TokenRange(new TokenKey(table, new Murmur3Partitioner.LongToken(a)), new TokenKey(table, new Murmur3Partitioner.LongToken(b))));
+                    ranges.add(TokenRange.create(new TokenKey(table, new Murmur3Partitioner.LongToken(a)), new TokenKey(table, new Murmur3Partitioner.LongToken(b))));
                     if (routingKey == null)
                     {
                         routingKey = new TokenKey(table, new Murmur3Partitioner.LongToken(b));
diff --git a/test/unit/org/apache/cassandra/index/accord/RouteIndexTest.java b/test/unit/org/apache/cassandra/index/accord/RouteIndexTest.java
index 1842c189d6..4832a32306 100644
--- a/test/unit/org/apache/cassandra/index/accord/RouteIndexTest.java
+++ b/test/unit/org/apache/cassandra/index/accord/RouteIndexTest.java
@@ -145,7 +145,7 @@ public class RouteIndexTest extends CQLTester.InMemory
                         a = b;
                         b = tmp;
                     }
-                    range = new TokenRange((AccordRoutingKey) a.start(), (AccordRoutingKey) b.end());
+                    range = TokenRange.create((AccordRoutingKey) a.start(), (AccordRoutingKey) b.end());
                 }
                 break;
                 default:
@@ -191,7 +191,7 @@ public class RouteIndexTest extends CQLTester.InMemory
                         a = b;
                         b = tmp;
                     }
-                    range = new TokenRange((AccordRoutingKey) a.start(), (AccordRoutingKey) b.end());
+                    range = TokenRange.create((AccordRoutingKey) a.start(), (AccordRoutingKey) b.end());
                 }
                 break;
                 default:
@@ -254,8 +254,8 @@ public class RouteIndexTest extends CQLTester.InMemory
                         b = tmp;
                     }
                     TableId tableId = tableIdGen.next(rs);
-                    return new TokenRange(new TokenKey(tableId, new LongToken(a)),
-                                          new TokenKey(tableId, new LongToken(b)));
+                    return TokenRange.create(new TokenKey(tableId, new LongToken(a)),
+                                             new TokenKey(tableId, new LongToken(b)));
                 };
             case 1: // small range
                 Gen.IntGen rangeSizeGen = RANGE_SIZE_DISTRIBUTION.next(rand);
@@ -269,16 +269,16 @@ public class RouteIndexTest extends CQLTester.InMemory
                         a = b - rangeSize;
                     }
                     TableId tableId = tableIdGen.next(rs);
-                    return new TokenRange(new TokenKey(tableId, new LongToken(a)),
-                                          new TokenKey(tableId, new LongToken(b)));
+                    return TokenRange.create(new TokenKey(tableId, new LongToken(a)),
+                                             new TokenKey(tableId, new LongToken(b)));
                 };
             case 2: // single element
                 return rs -> {
                     int a = tokenGen.nextInt(rs);
                     int b = a + 1;
                     TableId tableId = tableIdGen.next(rs);
-                    return new TokenRange(new TokenKey(tableId, new LongToken(a)),
-                                          new TokenKey(tableId, new LongToken(b)));
+                    return TokenRange.create(new TokenKey(tableId, new LongToken(a)),
+                                             new TokenKey(tableId, new LongToken(b)));
                 };
             default:
                 throw new AssertionError();
@@ -586,13 +586,13 @@ public class RouteIndexTest extends CQLTester.InMemory
         @Override
         public boolean contains(AccordRoutingKey start, AccordRoutingKey end, AccordRoutingKey accordRoutingKey)
         {
-            return new TokenRange(start, end).contains(accordRoutingKey);
+            return TokenRange.create(start, end).contains(accordRoutingKey);
         }
 
         @Override
         public boolean intersects(TokenRange tokenRange, AccordRoutingKey start, AccordRoutingKey end)
         {
-            return tokenRange.compareIntersecting(new TokenRange(start, end)) == 0;
+            return tokenRange.compareIntersecting(TokenRange.create(start, end)) == 0;
         }
     };
 }
\ No newline at end of file
diff --git a/test/unit/org/apache/cassandra/service/accord/AccordCommandStoreTest.java b/test/unit/org/apache/cassandra/service/accord/AccordCommandStoreTest.java
index ef17b660a5..ea5f7c2b60 100644
--- a/test/unit/org/apache/cassandra/service/accord/AccordCommandStoreTest.java
+++ b/test/unit/org/apache/cassandra/service/accord/AccordCommandStoreTest.java
@@ -116,7 +116,7 @@ public class AccordCommandStoreTest
         TxnId txnId = txnId(1, clock.incrementAndGet(), 1, Txn.Kind.Write, Routable.Domain.Range);
 
         PartialDeps dependencies;
-        try (PartialDeps.Builder builder = PartialDeps.builder(Ranges.of(range)))
+        try (PartialDeps.Builder builder = PartialDeps.builder(Ranges.of(range), true))
         {
             builder.add(range, oldTxnId1);
             builder.add(range, oldTxnId2);
diff --git a/test/unit/org/apache/cassandra/service/accord/AccordCommandTest.java b/test/unit/org/apache/cassandra/service/accord/AccordCommandTest.java
index 72c5f07bc4..4084bc1594 100644
--- a/test/unit/org/apache/cassandra/service/accord/AccordCommandTest.java
+++ b/test/unit/org/apache/cassandra/service/accord/AccordCommandTest.java
@@ -136,7 +136,7 @@ public class AccordCommandTest
         TxnId txnId2 = txnId(1, clock.incrementAndGet(), 1);
         Timestamp executeAt = timestamp(1, clock.incrementAndGet(), 1);
         PartialDeps deps;
-        try (PartialDeps.Builder builder = PartialDeps.builder(route))
+        try (PartialDeps.Builder builder = PartialDeps.builder(route, true))
         {
             builder.add(key.toUnseekable(), txnId2);
             deps = builder.build();
@@ -147,7 +147,7 @@ public class AccordCommandTest
             Command before = safeStore.ifInitialised(txnId).current();
             Accept.AcceptReply reply = accept.apply(safeStore);
             Assert.assertTrue(reply.isOk());
-            Assert.assertTrue(reply.deps.isEmpty());
+            Assert.assertEquals(deps.keyDeps, reply.deps.keyDeps);
             Command after = safeStore.ifInitialised(txnId).current();
             AccordTestUtils.appendCommandsBlocking(commandStore, before, after);
         }));
diff --git a/test/unit/org/apache/cassandra/service/accord/AccordKeyspaceTest.java b/test/unit/org/apache/cassandra/service/accord/AccordKeyspaceTest.java
index f5b133a7ba..3c17fef8b4 100644
--- a/test/unit/org/apache/cassandra/service/accord/AccordKeyspaceTest.java
+++ b/test/unit/org/apache/cassandra/service/accord/AccordKeyspaceTest.java
@@ -96,7 +96,7 @@ public class AccordKeyspaceTest extends CQLTester.InMemory
 
         String tableName = createTable("CREATE TABLE %s (k int, c int, v int, PRIMARY KEY (k, c)) WITH transactional_mode = 'full'");
         TableId tableId = Schema.instance.getTableMetadata(KEYSPACE, tableName).id;
-        Ranges scope = Ranges.of(new TokenRange(AccordRoutingKey.SentinelKey.min(tableId), AccordRoutingKey.SentinelKey.max(tableId)));
+        Ranges scope = Ranges.of(TokenRange.create(AccordRoutingKey.SentinelKey.min(tableId), AccordRoutingKey.SentinelKey.max(tableId)));
 
         AccordCommandStore store = AccordTestUtils.createAccordCommandStore(now::incrementAndGet, KEYSPACE, tableName);
 
diff --git a/test/unit/org/apache/cassandra/service/accord/AccordSyncPropagatorTest.java b/test/unit/org/apache/cassandra/service/accord/AccordSyncPropagatorTest.java
index 8682d1df81..0fdd8debb2 100644
--- a/test/unit/org/apache/cassandra/service/accord/AccordSyncPropagatorTest.java
+++ b/test/unit/org/apache/cassandra/service/accord/AccordSyncPropagatorTest.java
@@ -43,6 +43,7 @@ import org.junit.Test;
 import accord.api.Agent;
 import accord.impl.AbstractConfigurationService;
 import accord.impl.TestAgent;
+import accord.impl.basic.Pending;
 import accord.impl.basic.PendingQueue;
 import accord.impl.basic.MonitoredPendingQueue;
 import accord.impl.basic.RandomDelayQueue;
@@ -113,6 +114,7 @@ public class AccordSyncPropagatorTest
             long epochOffset = rs.nextLong(1, 1024);
             int numEpochs = rs.nextInt(1, 10);
             Map<Long, Ranges> allRanges = new HashMap<>();
+            Pending.Global.setNoActiveOrigin();
             for (int i = 0; i < numEpochs; i++)
             {
                 long epoch = epochOffset + i;
@@ -136,13 +138,16 @@ public class AccordSyncPropagatorTest
                     }
                 }, rs.nextInt(30, 300), TimeUnit.SECONDS);
             }
+            Pending.Global.clearActiveOrigin();
 
             while (queue.size() > 0)
             {
                 Runnable next = (Runnable) queue.poll();
                 if (next == null)
                     break;
+                Pending.Global.setActiveOrigin((Pending)next);
                 next.run();
+                Pending.Global.clearActiveOrigin();
                 if (!failures.isEmpty())
                 {
                     RuntimeException e = new RuntimeException("Failures detected");
diff --git a/test/unit/org/apache/cassandra/service/accord/AccordTaskTest.java b/test/unit/org/apache/cassandra/service/accord/AccordTaskTest.java
index 0207b14d20..c53319101f 100644
--- a/test/unit/org/apache/cassandra/service/accord/AccordTaskTest.java
+++ b/test/unit/org/apache/cassandra/service/accord/AccordTaskTest.java
@@ -205,7 +205,7 @@ public class AccordTaskTest
         FullRoute<?> route = partialTxn.keys().toRoute(routingKey);
         Ranges ranges = AccordTestUtils.fullRange(partialTxn.keys());
         route.slice(ranges);
-        PartialDeps deps = PartialDeps.builder(ranges).build();
+        PartialDeps deps = PartialDeps.builder(ranges, true).build();
 
         try
         {
@@ -257,7 +257,7 @@ public class AccordTaskTest
         FullRoute<?> route = partialTxn.keys().toRoute(routingKey);
         Ranges ranges = AccordTestUtils.fullRange(partialTxn.keys());
         Route<?> partialRoute = route.slice(ranges);
-        PartialDeps deps = PartialDeps.builder(ranges).build();
+        PartialDeps deps = PartialDeps.builder(ranges, true).build();
 
         try
         {
diff --git a/test/unit/org/apache/cassandra/service/accord/EpochSyncTest.java b/test/unit/org/apache/cassandra/service/accord/EpochSyncTest.java
index 55e64e87a9..10a5b46334 100644
--- a/test/unit/org/apache/cassandra/service/accord/EpochSyncTest.java
+++ b/test/unit/org/apache/cassandra/service/accord/EpochSyncTest.java
@@ -685,11 +685,11 @@ public class EpochSyncTest
                         EpochReady ready = new EpochReady(topology.epoch(), metadata, coordination, data, reads);
 
                         topology().onTopologyUpdate(topology, () -> ready);
-                        ready.fastPath.addCallback(() -> topology().onEpochSyncComplete(id, topology.epoch()));
+                        ready.coordinate.addCallback(() -> topology().onEpochSyncComplete(id, topology.epoch()));
                         if (topology().minEpoch() == topology.epoch() && topology().epoch() != topology.epoch())
-                            return ready.fastPath;
+                            return ready.coordinate;
                         config.acknowledgeEpoch(ready, startSync);
-                        return ready.fastPath;
+                        return ready.coordinate;
                     }
 
                     @Override
diff --git a/test/unit/org/apache/cassandra/service/accord/SimulatedAccordCommandStore.java b/test/unit/org/apache/cassandra/service/accord/SimulatedAccordCommandStore.java
index fe82e3b009..c376c46fbf 100644
--- a/test/unit/org/apache/cassandra/service/accord/SimulatedAccordCommandStore.java
+++ b/test/unit/org/apache/cassandra/service/accord/SimulatedAccordCommandStore.java
@@ -421,7 +421,7 @@ public class SimulatedAccordCommandStore implements AutoCloseable
 
         return Pair.create(txnId, processAsync(br, safe -> {
             var reply = br.apply(safe);
-            Assertions.assertThat(reply.isOk()).isTrue();
+            Assertions.assertThat(reply.kind() == BeginRecovery.RecoverReply.Kind.Ok).isTrue();
             return (BeginRecovery.RecoverOk) reply;
         }).beginAsResult());
     }
diff --git a/test/unit/org/apache/cassandra/service/accord/SimulatedAccordCommandStoreTestBase.java b/test/unit/org/apache/cassandra/service/accord/SimulatedAccordCommandStoreTestBase.java
index 05f4dffe94..091f01dd23 100644
--- a/test/unit/org/apache/cassandra/service/accord/SimulatedAccordCommandStoreTestBase.java
+++ b/test/unit/org/apache/cassandra/service/accord/SimulatedAccordCommandStoreTestBase.java
@@ -143,12 +143,12 @@ public abstract class SimulatedAccordCommandStoreTestBase extends CQLTester
 
     protected static TokenRange fullRange(TableId id)
     {
-        return new TokenRange(AccordRoutingKey.SentinelKey.min(id), AccordRoutingKey.SentinelKey.max(id));
+        return TokenRange.create(AccordRoutingKey.SentinelKey.min(id), AccordRoutingKey.SentinelKey.max(id));
     }
 
     protected static TokenRange tokenRange(TableId id, long start, long end)
     {
-        return new TokenRange(start == Long.MIN_VALUE ? AccordRoutingKey.SentinelKey.min(id) : tokenKey(id, start), tokenKey(id, end));
+        return TokenRange.create(start == Long.MIN_VALUE ? AccordRoutingKey.SentinelKey.min(id) : tokenKey(id, start), tokenKey(id, end));
     }
 
     protected static AccordRoutingKey.TokenKey tokenKey(TableId id, long token)
@@ -290,7 +290,7 @@ public abstract class SimulatedAccordCommandStoreTestBase extends CQLTester
         }));
         var recoverAsync = delay.flatMap(br -> instance.processAsync(br, safe -> {
             var reply = br.apply(safe);
-            Assertions.assertThat(reply.isOk()).isTrue();
+            Assertions.assertThat(reply.kind() == BeginRecovery.RecoverReply.Kind.Ok).isTrue();
             BeginRecovery.RecoverOk success = (BeginRecovery.RecoverOk) reply;
             Deps proposeDeps = LatestDeps.mergeProposal(Collections.singletonList(success), ok -> ok.deps);
             assertDeps(success.txnId, proposeDeps, cloneKeyConflicts, cloneRangeConflicts);
diff --git a/test/unit/org/apache/cassandra/service/accord/SimulatedAccordTaskTest.java b/test/unit/org/apache/cassandra/service/accord/SimulatedAccordTaskTest.java
index 67a855fbae..1fd77bed77 100644
--- a/test/unit/org/apache/cassandra/service/accord/SimulatedAccordTaskTest.java
+++ b/test/unit/org/apache/cassandra/service/accord/SimulatedAccordTaskTest.java
@@ -174,7 +174,7 @@ public class SimulatedAccordTaskTest extends SimulatedAccordCommandStoreTestBase
 
     private static TokenRange range(TableId tableId, long start, long end)
     {
-        return new TokenRange(new TokenKey(tableId, new LongToken(start)), new TokenKey(tableId, new LongToken(end)));
+        return TokenRange.create(new TokenKey(tableId, new LongToken(start)), new TokenKey(tableId, new LongToken(end)));
     }
 
     private enum Action { SUCCESS, FAILURE, LOAD_FAILURE }
diff --git a/test/unit/org/apache/cassandra/service/accord/serializers/CommandsForKeySerializerTest.java b/test/unit/org/apache/cassandra/service/accord/serializers/CommandsForKeySerializerTest.java
index e863661982..190f1b1104 100644
--- a/test/unit/org/apache/cassandra/service/accord/serializers/CommandsForKeySerializerTest.java
+++ b/test/unit/org/apache/cassandra/service/accord/serializers/CommandsForKeySerializerTest.java
@@ -33,6 +33,7 @@ import java.util.function.Function;
 import java.util.function.IntSupplier;
 import java.util.function.LongUnaryOperator;
 import java.util.function.Supplier;
+import java.util.stream.Stream;
 
 import org.apache.commons.lang3.ArrayUtils;
 import org.junit.After;
@@ -52,6 +53,7 @@ import accord.local.cfk.CommandsForKey;
 import accord.local.cfk.CommandsForKey.InternalStatus;
 import accord.local.cfk.CommandsForKey.TxnInfo;
 import accord.local.cfk.CommandsForKey.Unmanaged;
+import accord.local.cfk.Serialize;
 import accord.primitives.Ballot;
 import accord.primitives.KeyDeps;
 import accord.primitives.PartialDeps;
@@ -87,6 +89,7 @@ import org.apache.cassandra.utils.CassandraGenerators;
 import static accord.local.cfk.CommandsForKey.NO_BOUNDS_INFO;
 import static accord.primitives.Known.KnownExecuteAt.ExecuteAtErased;
 import static accord.primitives.Known.KnownExecuteAt.ExecuteAtUnknown;
+import static accord.primitives.Status.Durability.Majority;
 import static accord.primitives.Status.Durability.NotDurable;
 import static accord.utils.Property.qt;
 import static accord.utils.SortedArrays.Search.FAST;
@@ -125,17 +128,19 @@ public class CommandsForKeySerializerTest
         final PartialTxn txn;
         final Timestamp executeAt;
         final Ballot ballot;
+        final boolean isDurable;
         final List<TxnId> deps = new ArrayList<>();
         final List<TxnId> missing = new ArrayList<>();
         boolean invisible;
 
-        Cmd(TxnId txnId, PartialTxn txn, SaveStatus saveStatus, Timestamp executeAt, Ballot ballot)
+        Cmd(TxnId txnId, PartialTxn txn, SaveStatus saveStatus, boolean isDurable, Timestamp executeAt, Ballot ballot)
         {
             this.txnId = txnId;
             this.saveStatus = saveStatus;
             this.txn = txn;
             this.executeAt = executeAt;
             this.ballot = ballot;
+            this.isDurable = isDurable;
         }
 
         CommonAttributes attributes()
@@ -145,7 +150,7 @@ public class CommandsForKeySerializerTest
                 mutable.partialTxn(txn);
 
             mutable.setParticipants(StoreParticipants.all(txn.keys().toRoute(txn.keys().get(0).someIntersectingRoutingKey(null))));
-            mutable.durability(NotDurable);
+            mutable.durability(isDurable ? Majority : NotDurable);
             if (saveStatus.known.deps.hasProposedOrDecidedDeps())
             {
                 try (KeyDeps.Builder builder = KeyDeps.builder();)
@@ -192,19 +197,6 @@ public class CommandsForKeySerializerTest
                 case Applied:
                     return Command.SerializerSupport.executed(attributes(), saveStatus, executeAt, ballot, ballot, Command.WaitingOn.empty(txnId.domain()), new Writes(txnId, executeAt, txn.keys(), new TxnWrite(Collections.emptyList(), true)), new TxnData());
 
-                case TruncatedApplyWithDeps:
-                case TruncatedApply:
-                    if (txnId.kind().awaitsOnlyDeps()) return Command.SerializerSupport.truncatedApply(attributes(), saveStatus, executeAt, null, null, txnId);
-                    else return Command.SerializerSupport.truncatedApply(attributes(), saveStatus, executeAt, null, null);
-
-                case TruncatedApplyWithOutcome:
-                    if (txnId.kind().awaitsOnlyDeps()) return Command.SerializerSupport.truncatedApply(attributes(), saveStatus, executeAt, new Writes(txnId, executeAt, txn.keys(), new TxnWrite(Collections.emptyList(), true)), new TxnData(), txnId);
-                    else return Command.SerializerSupport.truncatedApply(attributes(), saveStatus, executeAt, new Writes(txnId, executeAt, txn.keys(), new TxnWrite(Collections.emptyList(), true)), new TxnData());
-
-                case Erased:
-                case ErasedOrVestigial:
-                    return Command.Truncated.erased(txnId, Status.Durability.UniversalOrInvalidated, StoreParticipants.empty(txnId));
-
                 case Invalidated:
                     return Command.SerializerSupport.invalidated(txnId);
             }
@@ -253,6 +245,7 @@ public class CommandsForKeySerializerTest
             if (!txnId.kind().awaitsOnlyDeps() && saveStatus.known.executeAt != ExecuteAtErased && saveStatus.known.executeAt != ExecuteAtUnknown)
                 executeAt = timestampSupplier.apply(txnId);
 
+            boolean isDurable = false;
             Ballot ballot;
             switch (saveStatus.status)
             {
@@ -263,17 +256,18 @@ public class CommandsForKeySerializerTest
                 case Truncated:
                     ballot = Ballot.ZERO;
                     break;
+                case PreApplied:
+                case Applied:
+                    isDurable = source.nextBoolean();
                 case AcceptedInvalidate:
                 case Accepted:
                 case PreCommitted:
                 case Committed:
                 case Stable:
-                case PreApplied:
-                case Applied:
                     ballot = ballotSupplier.get();
             }
 
-            cmds[i] = new Cmd(txnId, txnSupplier.apply(txnId), saveStatus, executeAt, ballot);
+            cmds[i] = new Cmd(txnId, txnSupplier.apply(txnId), saveStatus, isDurable, executeAt, ballot);
         }
         Arrays.sort(cmds, Comparator.comparing(o -> o.txnId));
         for (int i = 0 ; i < txnIdCount ; ++i)
@@ -316,14 +310,14 @@ public class CommandsForKeySerializerTest
             for (int j = 0 ; j < i ; ++j)
             {
                 InternalStatus status = InternalStatus.from(cmds[j].saveStatus);
-                if (status == null || !status.hasExecuteAtOrDeps) continue;
+                if (status == null || !status.hasExecuteAtAndDeps) continue;
                 if (cmds[j].txnId.kind().witnesses(cmds[i].txnId) && status.depsKnownBefore(cmds[j].txnId, cmds[j].executeAt).compareTo(cmds[i].txnId) > 0 && Collections.binarySearch(cmds[j].missing, cmds[i].txnId) < 0)
                     continue outer;
             }
             for (int j = i + 1 ; j < cmds.length ; ++j)
             {
                 InternalStatus status = InternalStatus.from(cmds[j].saveStatus);
-                if (status == null || !status.hasExecuteAtOrDeps) continue;
+                if (status == null || !status.hasExecuteAtAndDeps) continue;
                 if (cmds[j].txnId.kind().witnesses(cmds[i].txnId) && Collections.binarySearch(cmds[j].missing, cmds[i].txnId) < 0)
                     continue outer;
             }
@@ -438,7 +432,7 @@ public class CommandsForKeySerializerTest
             Choices<SaveStatus> saveStatusChoices = Choices.uniform(EnumSet.complementOf(EnumSet.of(SaveStatus.TruncatedApply, SaveStatus.TruncatedApplyWithOutcome, SaveStatus.TruncatedApplyWithDeps)).toArray(SaveStatus[]::new));
             Supplier<SaveStatus> saveStatusSupplier = () -> {
                 SaveStatus result = saveStatusChoices.choose(source);
-                while (result == SaveStatus.TruncatedApplyWithDeps) // not a real save status
+                while (result.is(Status.Truncated)) // we don't currently process truncations
                     result = saveStatusChoices.choose(source);
                 return result;
             };
@@ -492,7 +486,7 @@ public class CommandsForKeySerializerTest
                 TxnInfo info = cfk.get(i);
                 InternalStatus expectStatus = InternalStatus.from(cmd.saveStatus);
                 if (expectStatus == null) expectStatus = InternalStatus.TRANSITIVE;
-                if (expectStatus.hasExecuteAtOrDeps)
+                if (expectStatus.hasExecuteAtAndDeps)
                     Assert.assertEquals(cmd.executeAt, info.executeAt);
                 Assert.assertEquals(expectStatus, info.status());
                 Assert.assertArrayEquals(cmd.missing.toArray(TxnId[]::new), info.missing());
@@ -501,8 +495,8 @@ public class CommandsForKeySerializerTest
                 ++i;
             }
 
-            ByteBuffer buffer = CommandsForKeySerializer.toBytesWithoutKey(cfk);
-            CommandsForKey roundTrip = CommandsForKeySerializer.fromBytes(key, buffer);
+            ByteBuffer buffer = Serialize.toBytesWithoutKey(cfk);
+            CommandsForKey roundTrip = Serialize.fromBytes(key, buffer);
             Assert.assertEquals(cfk, roundTrip);
         }
         catch (Throwable t)
@@ -528,10 +522,11 @@ public class CommandsForKeySerializerTest
             }).unique().ofSizeBetween(0, 10).next(rs);
             Arrays.sort(ids, Comparator.naturalOrder());
             TxnInfo[] info = new TxnInfo[ids.length];
+            InternalStatus[] statuses = Stream.of(InternalStatus.values()).filter(s -> s != InternalStatus.PRUNED).toArray(InternalStatus[]::new);
             for (int i = 0; i < info.length; i++)
             {
-                InternalStatus status = rs.pick(InternalStatus.values());
-                info[i] = TxnInfo.create(ids[i], status, true, ids[i], TxnId.NO_TXNIDS, Ballot.ZERO);
+                InternalStatus status = rs.pick(statuses);
+                info[i] = TxnInfo.create(ids[i], status, false, true, ids[i], TxnId.NO_TXNIDS, Ballot.ZERO);
             }
 
             Gen<Unmanaged.Pending> pendingGen = Gens.enums().allMixedDistribution(Unmanaged.Pending.class).next(rs);
@@ -550,7 +545,7 @@ public class CommandsForKeySerializerTest
                 {
                     int idx = Arrays.binarySearch(ids, u.txnId);
                     if (idx < 0)
-                        missing.add(TxnInfo.create(u.txnId, InternalStatus.TRANSITIVE, true, u.txnId, Ballot.ZERO));
+                        missing.add(TxnInfo.create(u.txnId, InternalStatus.TRANSITIVE, false, true, u.txnId, Ballot.ZERO));
                 }
                 if (!missing.isEmpty())
                 {
@@ -562,8 +557,8 @@ public class CommandsForKeySerializerTest
 
             CommandsForKey expected = CommandsForKey.SerializerSupport.create(pk, info, unmanaged, TxnId.NONE, NO_BOUNDS_INFO);
 
-            ByteBuffer buffer = CommandsForKeySerializer.toBytesWithoutKey(expected);
-            CommandsForKey roundTrip = CommandsForKeySerializer.fromBytes(pk, buffer);
+            ByteBuffer buffer = Serialize.toBytesWithoutKey(expected);
+            CommandsForKey roundTrip = Serialize.fromBytes(pk, buffer);
             Assert.assertEquals(expected, roundTrip);
         });
     }
@@ -576,11 +571,11 @@ public class CommandsForKeySerializerTest
         TokenKey pk = new TokenKey(TableId.fromString("1b255f4d-ef25-40a6-0000-000000000009"), token);
         TxnId txnId = TxnId.fromValues(11,34052499,2,1);
         CommandsForKey expected = CommandsForKey.SerializerSupport.create(pk,
-                                                     new TxnInfo[] { TxnInfo.create(txnId, InternalStatus.PREACCEPTED_OR_ACCEPTED_INVALIDATE, true, txnId, TxnId.NO_TXNIDS, Ballot.ZERO) },
+                                                     new TxnInfo[] { TxnInfo.create(txnId, InternalStatus.PREACCEPTED_OR_ACCEPTED_INVALIDATE, false, true, txnId, TxnId.NO_TXNIDS, Ballot.ZERO) },
                                                                           CommandsForKey.NO_PENDING_UNMANAGED, TxnId.NONE, NO_BOUNDS_INFO);
 
-        ByteBuffer buffer = CommandsForKeySerializer.toBytesWithoutKey(expected);
-        CommandsForKey roundTrip = CommandsForKeySerializer.fromBytes(pk, buffer);
+        ByteBuffer buffer = Serialize.toBytesWithoutKey(expected);
+        CommandsForKey roundTrip = Serialize.fromBytes(pk, buffer);
         Assert.assertEquals(expected, roundTrip);
     }
 }
diff --git a/test/unit/org/apache/cassandra/utils/AccordGenerators.java b/test/unit/org/apache/cassandra/utils/AccordGenerators.java
index 54893627eb..4d6326b222 100644
--- a/test/unit/org/apache/cassandra/utils/AccordGenerators.java
+++ b/test/unit/org/apache/cassandra/utils/AccordGenerators.java
@@ -349,8 +349,8 @@ public class AccordGenerators
             AccordRoutingKey b = gen.next(rs);
             while (a.equals(b))
                 b = gen.next(rs);
-            if (a.compareTo(b) < 0) return new TokenRange(a, b);
-            else                    return new TokenRange(b, a);
+            if (a.compareTo(b) < 0) return TokenRange.create(a, b);
+            else                    return TokenRange.create(b, a);
         };
     }
 
@@ -367,7 +367,7 @@ public class AccordGenerators
             IPartitioner partitioner = partitionerGen.next(rs);
             List<Range> ranges = new ArrayList<>();
             int numSplits = rs.nextInt(10, 100);
-            TokenRange range = new TokenRange(AccordRoutingKey.SentinelKey.min(TABLE_ID1), AccordRoutingKey.SentinelKey.max(TABLE_ID1));
+            TokenRange range = TokenRange.create(AccordRoutingKey.SentinelKey.min(TABLE_ID1), AccordRoutingKey.SentinelKey.max(TABLE_ID1));
             AccordSplitter splitter = partitioner.accordSplitter().apply(Ranges.of(range));
             BigInteger size = splitter.sizeOf(range);
             BigInteger update = splitter.divide(size, numSplits);
