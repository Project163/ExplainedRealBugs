diff --git a/CHANGES.txt b/CHANGES.txt
index e6477d72b6..dea2003e75 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 3.10
+ * Use non-token restrictions for bounds when token restrictions are overridden (CASSANDRA-12419)
  * Fix CQLSH auto completion for PER PARTITION LIMIT (CASSANDRA-12803)
  * Use different build directories for Eclipse and Ant (CASSANDRA-12466)
  * Avoid potential AttributeError in cqlsh due to no table metadata (CASSANDRA-12815)
diff --git a/src/java/org/apache/cassandra/cql3/restrictions/TokenFilter.java b/src/java/org/apache/cassandra/cql3/restrictions/TokenFilter.java
index 2611d198b0..400706b793 100644
--- a/src/java/org/apache/cassandra/cql3/restrictions/TokenFilter.java
+++ b/src/java/org/apache/cassandra/cql3/restrictions/TokenFilter.java
@@ -41,18 +41,21 @@ import static org.apache.cassandra.cql3.statements.Bound.START;
 
 /**
  * <code>Restriction</code> decorator used to merge non-token restriction and token restriction on partition keys.
+ *
+ * <p>If all partition key columns have non-token restrictions and do not need filtering, they take precedence
+ * when calculating bounds, incusiveness etc (see CASSANDRA-12149).</p>
  */
 final class TokenFilter implements PartitionKeyRestrictions
 {
     /**
      * The decorated restriction
      */
-    private PartitionKeyRestrictions restrictions;
+    private final PartitionKeyRestrictions restrictions;
 
     /**
      * The restriction on the token
      */
-    private TokenRestriction tokenRestriction;
+    private final TokenRestriction tokenRestriction;
 
     /**
      * Partitioner to manage tokens, extracted from tokenRestriction metadata.
@@ -81,9 +84,9 @@ final class TokenFilter implements PartitionKeyRestrictions
     @Override
     public boolean isOnToken()
     {
-        // if all partition key columns have non-token restrictions, we can simply use the token range to filter
-        // those restrictions and then ignore the token range
-        return restrictions.size() < tokenRestriction.size();
+        // if all partition key columns have non-token restrictions and do not need filtering,
+        // we can simply use the token range to filter those restrictions and then ignore the token range
+        return needFiltering(tokenRestriction.metadata) || restrictions.size() < tokenRestriction.size();
     }
 
     public TokenFilter(PartitionKeyRestrictions restrictions, TokenRestriction tokenRestriction)
@@ -111,19 +114,19 @@ final class TokenFilter implements PartitionKeyRestrictions
     @Override
     public boolean isInclusive(Bound bound)
     {
-        return tokenRestriction.isInclusive(bound);
+        return isOnToken() ? tokenRestriction.isInclusive(bound) : restrictions.isInclusive(bound);
     }
 
     @Override
-    public boolean hasBound(Bound b)
+    public boolean hasBound(Bound bound)
     {
-        return tokenRestriction.hasBound(b);
+        return isOnToken() ? tokenRestriction.hasBound(bound) : restrictions.hasBound(bound);
     }
 
     @Override
     public List<ByteBuffer> bounds(Bound bound, QueryOptions options) throws InvalidRequestException
     {
-        return tokenRestriction.bounds(bound, options);
+        return isOnToken() ? tokenRestriction.bounds(bound, options) : restrictions.bounds(bound, options);
     }
 
     /**
diff --git a/test/unit/org/apache/cassandra/cql3/validation/operations/SelectOrderedPartitionerTest.java b/test/unit/org/apache/cassandra/cql3/validation/operations/SelectOrderedPartitionerTest.java
index 0e3a342364..3957305254 100644
--- a/test/unit/org/apache/cassandra/cql3/validation/operations/SelectOrderedPartitionerTest.java
+++ b/test/unit/org/apache/cassandra/cql3/validation/operations/SelectOrderedPartitionerTest.java
@@ -45,10 +45,51 @@ public class SelectOrderedPartitionerTest extends CQLTester
         DatabaseDescriptor.setPartitionerUnsafe(ByteOrderedPartitioner.instance);
     }
 
+    @Test
+    public void testTokenAndIndex() throws Throwable
+    {
+        createTable("CREATE TABLE %s (a int, b int, c int, d int, PRIMARY KEY (a, b, c))");
+        createIndex("CREATE INDEX ON %s(c)");
+
+        for (int i = 0; i < 10; i++)
+        {
+            execute("INSERT INTO %s (a,b,c,d) VALUES (?, ?, ?, ?)", i, i, i, i);
+            execute("INSERT INTO %s (a,b,c,d) VALUES (?, ?, ?, ?)", i, i + 10, i + 10, i + 10);
+        }
+
+        beforeAndAfterFlush(() -> {
+            assertRows(execute("SELECT * FROM %s WHERE token(a) > token(8) AND a = 9 AND c = 9 ALLOW FILTERING"),
+                       row(9, 9, 9, 9));
+
+            assertRows(execute("SELECT * FROM %s WHERE token(a) > token(8) AND a > 8 AND c = 9 ALLOW FILTERING"),
+                       row(9, 9, 9, 9));
+        });
+    }
+
+
+    @Test
+    public void testFilteringOnAllPartitionKeysWithTokenRestriction() throws Throwable
+    {
+        createTable("CREATE TABLE %s (a int, b int, c int, d int, PRIMARY KEY ((a, b), c))");
+
+        for (int i = 0; i < 10; i++)
+        {
+            execute("INSERT INTO %s (a,b,c,d) VALUES (?, ?, ?, ?)", i, i, i, i);
+            execute("INSERT INTO %s (a,b,c,d) VALUES (?, ?, ?, ?)", i, i + 10, i + 10, i + 10);
+        }
+
+        assertEmpty(execute("SELECT * FROM %s WHERE token(a, b) > token(10, 10)"));
+        assertEmpty(execute("SELECT * FROM %s WHERE token(a, b) > token(10, 10) AND a < 8 AND b < 8 ALLOW FILTERING"));
+        assertRows(execute("SELECT * FROM %s WHERE token(a, b) > token(5, 5) AND a < 8 AND b < 8 ALLOW FILTERING"),
+                   row(6, 6, 6, 6),
+                   row(7, 7, 7, 7));
+    }
+
     @Test
     public void testFilteringOnPartitionKeyWithToken() throws Throwable
     {
         createTable("CREATE TABLE %s (a int, b int, c int, d int, PRIMARY KEY ((a, b), c))");
+        createIndex("CREATE INDEX ON %s(d)");
 
         for (int i = 0; i < 10; i++)
         {
@@ -65,6 +106,15 @@ public class SelectOrderedPartitionerTest extends CQLTester
                        row(9, 9, 9, 9),
                        row(9, 19, 19, 19));
 
+            assertRows(execute("SELECT * FROM %s WHERE token(a, b) > token(8, 10) AND a = 9 AND d = 9 ALLOW FILTERING"),
+                       row(9, 9, 9, 9));
+
+            assertRows(execute("SELECT * FROM %s WHERE token(a, b) > token(8, 10) AND a > 8 AND b > 8 AND d = 9 ALLOW FILTERING"),
+                       row(9, 9, 9, 9));
+
+            assertRows(execute("SELECT * FROM %s WHERE a = 9 AND b = 9  AND token(a, b) > token(8, 10) AND d = 9 ALLOW FILTERING"),
+                       row(9, 9, 9, 9));
+
             assertRows(execute("SELECT * FROM %s WHERE token(a, b) > token(8, 10) AND a = 9 AND c = 19 ALLOW FILTERING"),
                        row(9, 19, 19, 19));
 
