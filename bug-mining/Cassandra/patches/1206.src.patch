diff --git a/build.xml b/build.xml
index 23f30b2788..94aba39c08 100644
--- a/build.xml
+++ b/build.xml
@@ -777,6 +777,7 @@ url=${svn.entry.url}?pathrev=${svn.entry.commit.revision}
         <fileset dir="${build.classes.main}">
           <include name="org/apache/cassandra/cql/jdbc/*" />
           <include name="org/apache/cassandra/utils/ByteBufferUtil*.class" />
+          <include name="org/apache/cassandra/utils/Hex.class" />
           <include name="org/apache/cassandra/utils/UUIDGen*.class" />
         </fileset>
         <manifest>
diff --git a/drivers/java/test/org/apache/cassandra/cql/JdbcDriverTest.java b/drivers/java/test/org/apache/cassandra/cql/JdbcDriverTest.java
index ba9972e755..beb376ac77 100644
--- a/drivers/java/test/org/apache/cassandra/cql/JdbcDriverTest.java
+++ b/drivers/java/test/org/apache/cassandra/cql/JdbcDriverTest.java
@@ -40,7 +40,7 @@ import org.junit.AfterClass;
 import org.junit.BeforeClass;
 import org.junit.Test;
 
-import org.apache.cassandra.utils.FBUtilities;
+import org.apache.cassandra.utils.Hex;
 
 import static junit.framework.Assert.assertEquals;
 
@@ -50,11 +50,11 @@ import static junit.framework.Assert.assertEquals;
 public class JdbcDriverTest extends EmbeddedServiceBase
 {
     private static java.sql.Connection con = null;
-    private static final String first = FBUtilities.bytesToHex("first".getBytes());
-    private static final String firstrec = FBUtilities.bytesToHex("firstrec".getBytes());
-    private static final String last = FBUtilities.bytesToHex("last".getBytes());
-    private static final String lastrec = FBUtilities.bytesToHex("lastrec".getBytes());
-    private static final String jsmith = FBUtilities.bytesToHex("jsmith".getBytes());
+    private static final String first = Hex.bytesToHex("first".getBytes());
+    private static final String firstrec = Hex.bytesToHex("firstrec".getBytes());
+    private static final String last = Hex.bytesToHex("last".getBytes());
+    private static final String lastrec = Hex.bytesToHex("lastrec".getBytes());
+    private static final String jsmith = Hex.bytesToHex("jsmith".getBytes());
 
     /** SetUp */
     @BeforeClass
@@ -130,7 +130,7 @@ public class JdbcDriverTest extends EmbeddedServiceBase
     @Test
     public void testNonDefaultColumnValidators() throws SQLException
     {
-        String key = FBUtilities.bytesToHex("Integer".getBytes());
+        String key = Hex.bytesToHex("Integer".getBytes());
         Statement stmt = con.createStatement();
         stmt.executeUpdate("update JdbcInteger set 1=36893488147419103232, 42='fortytwofortytwo' where key='" + key + "'");
         ResultSet rs = stmt.executeQuery("select 1, 2, 42 from JdbcInteger where key='" + key + "'");
@@ -146,7 +146,7 @@ public class JdbcDriverTest extends EmbeddedServiceBase
         
         rs = stmt.executeQuery("select key, 1, 2, 42 from JdbcInteger where key='" + key + "'");
         assert rs.next();
-        assert Arrays.equals(rs.getBytes("key"), FBUtilities.hexToBytes(key));
+        assert Arrays.equals(rs.getBytes("key"), Hex.hexToBytes(key));
         assert rs.getObject("1").equals(new BigInteger("36893488147419103232"));
         assert rs.getString("42").equals("fortytwofortytwo") : rs.getString("42");
 
@@ -166,7 +166,7 @@ public class JdbcDriverTest extends EmbeddedServiceBase
     @Test
     public void testLongMetadata() throws SQLException
     {
-        String key = FBUtilities.bytesToHex("Long".getBytes());
+        String key = Hex.bytesToHex("Long".getBytes());
         Statement stmt = con.createStatement();
         stmt.executeUpdate("UPDATE JdbcLong SET 1=111, 2=222 WHERE KEY = '" + key + "'");
         ResultSet rs = stmt.executeQuery("SELECT 1, 2 from JdbcLong WHERE KEY = '" + key + "'");
@@ -186,8 +186,8 @@ public class JdbcDriverTest extends EmbeddedServiceBase
     @Test
     public void testStringMetadata() throws SQLException
     {
-        String aKey = FBUtilities.bytesToHex("ascii".getBytes());
-        String uKey = FBUtilities.bytesToHex("utf8".getBytes());
+        String aKey = Hex.bytesToHex("ascii".getBytes());
+        String uKey = Hex.bytesToHex("utf8".getBytes());
         Statement stmt = con.createStatement();
         stmt.executeUpdate("UPDATE JdbcAscii SET a='aa', b='bb' WHERE KEY = '" + aKey + "'");
         stmt.executeUpdate("UPDATE JdbcUtf8 SET a='aa', b='bb' WHERE KEY = '" + uKey + "'");
@@ -232,7 +232,7 @@ public class JdbcDriverTest extends EmbeddedServiceBase
     @Test
     public void testBytesMetadata() throws SQLException 
     {
-        String key = FBUtilities.bytesToHex("bytes".getBytes());
+        String key = Hex.bytesToHex("bytes".getBytes());
         Statement stmt = con.createStatement();
         byte[] a = "a_".getBytes();
         byte[] b = "b_".getBytes();
@@ -240,23 +240,23 @@ public class JdbcDriverTest extends EmbeddedServiceBase
         byte[] bb = "_bb_".getBytes();
         stmt.executeUpdate(String.format(
                 "UPDATE JdbcBytes set '%s'='%s', '%s'='%s' WHERE KEY = '" + key + "'",
-                FBUtilities.bytesToHex(a),
-                FBUtilities.bytesToHex(aa),
-                FBUtilities.bytesToHex(b),
-                FBUtilities.bytesToHex(bb)));
+                Hex.bytesToHex(a),
+                Hex.bytesToHex(aa),
+                Hex.bytesToHex(b),
+                Hex.bytesToHex(bb)));
         ResultSet rs = stmt.executeQuery(String.format(
                 "SELECT '%s', '%s' from JdbcBytes WHERE KEY = '" + key + "'",
-                FBUtilities.bytesToHex(a),
-                FBUtilities.bytesToHex(b)));
+                Hex.bytesToHex(a),
+                Hex.bytesToHex(b)));
         assert rs.next();
         assert Arrays.equals(aa, rs.getBytes(1));
         assert Arrays.equals(bb, rs.getBytes(2));
-        assert Arrays.equals(aa, rs.getBytes(FBUtilities.bytesToHex(a)));
-        assert Arrays.equals(bb, rs.getBytes(FBUtilities.bytesToHex(b)));
+        assert Arrays.equals(aa, rs.getBytes(Hex.bytesToHex(a)));
+        assert Arrays.equals(bb, rs.getBytes(Hex.bytesToHex(b)));
         ResultSetMetaData md = rs.getMetaData();
         assert md.getColumnCount() == 2;
-        expectedMetaData(md, 1, ByteBuffer.class.getName(), "JdbcBytes", "Keyspace1", FBUtilities.bytesToHex(a), Types.BINARY, JdbcBytes.class.getSimpleName(), false, false);
-        expectedMetaData(md, 2, ByteBuffer.class.getName(), "JdbcBytes", "Keyspace1", FBUtilities.bytesToHex(b), Types.BINARY, JdbcBytes.class.getSimpleName(), false, false);
+        expectedMetaData(md, 1, ByteBuffer.class.getName(), "JdbcBytes", "Keyspace1", Hex.bytesToHex(a), Types.BINARY, JdbcBytes.class.getSimpleName(), false, false);
+        expectedMetaData(md, 2, ByteBuffer.class.getName(), "JdbcBytes", "Keyspace1", Hex.bytesToHex(b), Types.BINARY, JdbcBytes.class.getSimpleName(), false, false);
         
         for (int i = 0; i < md.getColumnCount(); i++)
             expectedMetaData(md, i + 1, ByteBuffer.class.getName(), Types.BINARY, JdbcBytes.class.getSimpleName(), false, false);
@@ -301,7 +301,7 @@ public class JdbcDriverTest extends EmbeddedServiceBase
         selectQ = "SELECT 'first', last FROM JdbcUtf8 WHERE KEY='" + jsmith + "'";
         checkResultSet(stmt.executeQuery(selectQ), "String", 1, keys, "first", "last");
 
-        String badKey = FBUtilities.bytesToHex(String.format("jsmith-%s", System.currentTimeMillis()).getBytes());
+        String badKey = Hex.bytesToHex(String.format("jsmith-%s", System.currentTimeMillis()).getBytes());
         selectQ = "SELECT 1, 2 FROM JdbcInteger WHERE KEY IN ('" + badKey + "', '" + jsmith + "')";
         checkResultSet(stmt.executeQuery(selectQ), "Int", 1, keys, "1", "2");
     }
@@ -346,7 +346,7 @@ public class JdbcDriverTest extends EmbeddedServiceBase
         selectQ = "SELECT 'first', last FROM JdbcUtf8 WHERE KEY='" + jsmith + "'";
         checkResultSet(executePreparedStatementWithResults(con, selectQ), "String", 1, keys, "first", "last");
 
-        String badKey = FBUtilities.bytesToHex(String.format("jsmith-%s", System.currentTimeMillis()).getBytes());
+        String badKey = Hex.bytesToHex(String.format("jsmith-%s", System.currentTimeMillis()).getBytes());
         selectQ = "SELECT 1, 2 FROM JdbcInteger WHERE KEY IN ('" + badKey + "', '" + jsmith + "')";
         checkResultSet(executePreparedStatementWithResults(con, selectQ), "Int", 1, keys, "1", "2");
     }
@@ -359,12 +359,12 @@ public class JdbcDriverTest extends EmbeddedServiceBase
         String[] statements = 
         {
                 String.format("DELETE '%s', '%s' FROM Standard1 WHERE KEY='%s'",
-                              FBUtilities.bytesToHex("firstN".getBytes()),
-                              FBUtilities.bytesToHex("lastN".getBytes()),
+                              Hex.bytesToHex("firstN".getBytes()),
+                              Hex.bytesToHex("lastN".getBytes()),
                               jsmith),
                 String.format("SELECT '%s', '%s' FROM Standard1 WHERE KEY='%s'",
-                              FBUtilities.bytesToHex("firstN".getBytes()),
-                              FBUtilities.bytesToHex("lastN".getBytes()),
+                              Hex.bytesToHex("firstN".getBytes()),
+                              Hex.bytesToHex("lastN".getBytes()),
                               jsmith),
                 String.format("SELECT '%s' FROM Standard1 WHERE KEY='%s'",
                               first,
diff --git a/drivers/java/test/org/apache/cassandra/cql/jdbc/PreparedStatementTest.java b/drivers/java/test/org/apache/cassandra/cql/jdbc/PreparedStatementTest.java
index d0d8741a95..536dc2fbef 100644
--- a/drivers/java/test/org/apache/cassandra/cql/jdbc/PreparedStatementTest.java
+++ b/drivers/java/test/org/apache/cassandra/cql/jdbc/PreparedStatementTest.java
@@ -23,6 +23,7 @@ package org.apache.cassandra.cql.jdbc;
 
 import org.apache.cassandra.cql.EmbeddedServiceBase;
 import org.apache.cassandra.utils.FBUtilities;
+import org.apache.cassandra.utils.Hex;
 import org.junit.BeforeClass;
 import org.junit.Test;
 
@@ -30,9 +31,7 @@ import java.sql.DriverManager;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
-import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.List;
 
 
 public class PreparedStatementTest extends EmbeddedServiceBase
@@ -73,8 +72,8 @@ public class PreparedStatementTest extends EmbeddedServiceBase
             stmt.setBytes(3, key);
             ResultSet rs = stmt.executeQuery();
             assert rs.next();
-            assert Arrays.equals(rs.getBytes(FBUtilities.bytesToHex(FBUtilities.toByteArray(i))), FBUtilities.toByteArray((i+1)*10));
-            assert Arrays.equals(rs.getBytes(FBUtilities.bytesToHex(FBUtilities.toByteArray(i+100))), FBUtilities.toByteArray((i+1)*10+1));
+            assert Arrays.equals(rs.getBytes(Hex.bytesToHex(FBUtilities.toByteArray(i))), FBUtilities.toByteArray((i+1)*10));
+            assert Arrays.equals(rs.getBytes(Hex.bytesToHex(FBUtilities.toByteArray(i+100))), FBUtilities.toByteArray((i+1)*10+1));
             assert Arrays.equals(rs.getBytes(1), FBUtilities.toByteArray((i+1)*10));
             assert Arrays.equals(rs.getBytes(2), FBUtilities.toByteArray((i+1)*10+1));
             assert !rs.next();
diff --git a/examples/simple_authentication/src/org/apache/cassandra/auth/SimpleAuthenticator.java b/examples/simple_authentication/src/org/apache/cassandra/auth/SimpleAuthenticator.java
index 1e25831291..254cd5d4cf 100644
--- a/examples/simple_authentication/src/org/apache/cassandra/auth/SimpleAuthenticator.java
+++ b/examples/simple_authentication/src/org/apache/cassandra/auth/SimpleAuthenticator.java
@@ -33,6 +33,7 @@ import org.apache.cassandra.config.ConfigurationException;
 import org.apache.cassandra.io.util.FileUtils;
 import org.apache.cassandra.thrift.AuthenticationException;
 import org.apache.cassandra.utils.FBUtilities;
+import org.apache.cassandra.utils.Hex;
 
 public class SimpleAuthenticator implements IAuthenticator
 {
@@ -108,7 +109,7 @@ public class SimpleAuthenticator implements IAuthenticator
                     authenticated = password.equals(props.getProperty(username));
                     break;
                 case MD5:
-                    authenticated = MessageDigest.isEqual(FBUtilities.threadLocalMD5Digest().digest(password.getBytes()), FBUtilities.hexToBytes(props.getProperty(username)));
+                    authenticated = MessageDigest.isEqual(FBUtilities.threadLocalMD5Digest().digest(password.getBytes()), Hex.hexToBytes(props.getProperty(username)));
                     break;
                 default:
                     throw new RuntimeException("Unknown PasswordMode " + mode);
diff --git a/src/java/org/apache/cassandra/auth/Resources.java b/src/java/org/apache/cassandra/auth/Resources.java
index 6b64708c7c..06ff3bbf60 100644
--- a/src/java/org/apache/cassandra/auth/Resources.java
+++ b/src/java/org/apache/cassandra/auth/Resources.java
@@ -23,7 +23,7 @@ package org.apache.cassandra.auth;
 
 import java.util.List;
 
-import org.apache.cassandra.utils.FBUtilities;
+import org.apache.cassandra.utils.Hex;
 
 /**
  * Constants related to Cassandra's resource hierarchy.
@@ -42,7 +42,7 @@ public final class Resources
         {
             buff.append("/");
             if (component instanceof byte[])
-                buff.append(FBUtilities.bytesToHex((byte[])component));
+                buff.append(Hex.bytesToHex((byte[])component));
             else
                 buff.append(component.toString());
         }
diff --git a/src/java/org/apache/cassandra/db/marshal/BytesType.java b/src/java/org/apache/cassandra/db/marshal/BytesType.java
index 3b2bc198b5..5da76f4e19 100644
--- a/src/java/org/apache/cassandra/db/marshal/BytesType.java
+++ b/src/java/org/apache/cassandra/db/marshal/BytesType.java
@@ -25,7 +25,7 @@ import java.nio.ByteBuffer;
 
 import org.apache.cassandra.cql.jdbc.JdbcBytes;
 import org.apache.cassandra.utils.ByteBufferUtil;
-import org.apache.cassandra.utils.FBUtilities;
+import org.apache.cassandra.utils.Hex;
 
 public class BytesType extends AbstractType<ByteBuffer>
 {
@@ -67,7 +67,7 @@ public class BytesType extends AbstractType<ByteBuffer>
     {
         try
         {
-            return ByteBuffer.wrap(FBUtilities.hexToBytes(source));
+            return ByteBuffer.wrap(Hex.hexToBytes(source));
         }
         catch (NumberFormatException e)
         {
diff --git a/src/java/org/apache/cassandra/dht/AbstractByteOrderedPartitioner.java b/src/java/org/apache/cassandra/dht/AbstractByteOrderedPartitioner.java
index d6d3827d8a..f4f8ae9a49 100644
--- a/src/java/org/apache/cassandra/dht/AbstractByteOrderedPartitioner.java
+++ b/src/java/org/apache/cassandra/dht/AbstractByteOrderedPartitioner.java
@@ -29,6 +29,7 @@ import org.apache.commons.lang.ArrayUtils;
 import org.apache.cassandra.db.DecoratedKey;
 import org.apache.cassandra.service.StorageService;
 import org.apache.cassandra.utils.FBUtilities;
+import org.apache.cassandra.utils.Hex;
 import org.apache.cassandra.utils.Pair;
 
 public abstract class AbstractByteOrderedPartitioner implements IPartitioner<BytesToken>
@@ -142,14 +143,14 @@ public abstract class AbstractByteOrderedPartitioner implements IPartitioner<Byt
 
         public String toString(Token<byte[]> bytesToken)
         {
-            return FBUtilities.bytesToHex(bytesToken.token);
+            return Hex.bytesToHex(bytesToken.token);
         }
 
         public void validate(String token) throws ConfigurationException
         {
             try
             {
-                FBUtilities.hexToBytes(token);
+                Hex.hexToBytes(token);
             }
             catch (NumberFormatException e)
             {
@@ -159,7 +160,7 @@ public abstract class AbstractByteOrderedPartitioner implements IPartitioner<Byt
 
         public Token<byte[]> fromString(String string)
         {
-            return new BytesToken(FBUtilities.hexToBytes(string));
+            return new BytesToken(Hex.hexToBytes(string));
         }
     };
 
diff --git a/src/java/org/apache/cassandra/dht/BytesToken.java b/src/java/org/apache/cassandra/dht/BytesToken.java
index d13f35c22b..2026f12140 100644
--- a/src/java/org/apache/cassandra/dht/BytesToken.java
+++ b/src/java/org/apache/cassandra/dht/BytesToken.java
@@ -23,6 +23,7 @@ import java.util.Arrays;
 
 import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.cassandra.utils.FBUtilities;
+import org.apache.cassandra.utils.Hex;
 
 public class BytesToken extends Token<byte[]>
 {
@@ -41,7 +42,7 @@ public class BytesToken extends Token<byte[]>
     @Override
     public String toString()
     {
-        return "Token(bytes[" + FBUtilities.bytesToHex(token) + "])";
+        return "Token(bytes[" + Hex.bytesToHex(token) + "])";
     }
 
     public int compareTo(Token<byte[]> o)
diff --git a/src/java/org/apache/cassandra/hadoop/ConfigHelper.java b/src/java/org/apache/cassandra/hadoop/ConfigHelper.java
index 8345fb7950..0a1d2e3b44 100644
--- a/src/java/org/apache/cassandra/hadoop/ConfigHelper.java
+++ b/src/java/org/apache/cassandra/hadoop/ConfigHelper.java
@@ -26,6 +26,7 @@ import org.apache.cassandra.thrift.KeyRange;
 import org.apache.cassandra.thrift.SlicePredicate;
 import org.apache.cassandra.thrift.TBinaryProtocol;
 import org.apache.cassandra.utils.FBUtilities;
+import org.apache.cassandra.utils.Hex;
 import org.apache.hadoop.conf.Configuration;
 import org.apache.thrift.TDeserializer;
 import org.apache.thrift.TException;
@@ -173,7 +174,7 @@ public class ConfigHelper
         TSerializer serializer = new TSerializer(new TBinaryProtocol.Factory());
         try
         {
-            return FBUtilities.bytesToHex(serializer.serialize(predicate));
+            return Hex.bytesToHex(serializer.serialize(predicate));
         }
         catch (TException e)
         {
@@ -188,7 +189,7 @@ public class ConfigHelper
         SlicePredicate predicate = new SlicePredicate();
         try
         {
-            deserializer.deserialize(predicate, FBUtilities.hexToBytes(st));
+            deserializer.deserialize(predicate, Hex.hexToBytes(st));
         }
         catch (TException e)
         {
@@ -220,7 +221,7 @@ public class ConfigHelper
         TSerializer serializer = new TSerializer(new TBinaryProtocol.Factory());
         try
         {
-            return FBUtilities.bytesToHex(serializer.serialize(keyRange));
+            return Hex.bytesToHex(serializer.serialize(keyRange));
         }
         catch (TException e)
         {
@@ -235,7 +236,7 @@ public class ConfigHelper
         KeyRange keyRange = new KeyRange();
         try
         {
-            deserializer.deserialize(keyRange, FBUtilities.hexToBytes(st));
+            deserializer.deserialize(keyRange, Hex.hexToBytes(st));
         }
         catch (TException e)
         {
diff --git a/src/java/org/apache/cassandra/utils/ByteBufferUtil.java b/src/java/org/apache/cassandra/utils/ByteBufferUtil.java
index 86c00c1879..8d33155c4d 100644
--- a/src/java/org/apache/cassandra/utils/ByteBufferUtil.java
+++ b/src/java/org/apache/cassandra/utils/ByteBufferUtil.java
@@ -20,10 +20,8 @@ package org.apache.cassandra.utils;
 
 import java.io.DataInput;
 import java.io.DataOutput;
-import java.io.EOFException;
 import java.io.IOException;
 import java.io.InputStream;
-import java.io.OutputStream;
 import java.nio.ByteBuffer;
 import java.nio.charset.CharacterCodingException;
 import java.nio.charset.Charset;
@@ -483,15 +481,15 @@ public class ByteBufferUtil
         for (int i = 0; i < size; i++)
         {
             final int bint = bytes.get(i+offset);
-            c[i * 2] = FBUtilities.byteToChar[(bint & 0xf0) >> 4];
-            c[1 + i * 2] = FBUtilities.byteToChar[bint & 0x0f];
+            c[i * 2] = Hex.byteToChar[(bint & 0xf0) >> 4];
+            c[1 + i * 2] = Hex.byteToChar[bint & 0x0f];
         }
-        return FBUtilities.wrapCharArray(c);
+        return Hex.wrapCharArray(c);
     }
 
     public static ByteBuffer hexToBytes(String str)
     {
-        return ByteBuffer.wrap(FBUtilities.hexToBytes(str));
+        return ByteBuffer.wrap(Hex.hexToBytes(str));
     }
 
     /**
diff --git a/src/java/org/apache/cassandra/utils/FBUtilities.java b/src/java/org/apache/cassandra/utils/FBUtilities.java
index 652c2b85f0..ad923d6abd 100644
--- a/src/java/org/apache/cassandra/utils/FBUtilities.java
+++ b/src/java/org/apache/cassandra/utils/FBUtilities.java
@@ -19,7 +19,6 @@
 package org.apache.cassandra.utils;
 
 import java.io.*;
-import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
 import java.lang.reflect.InvocationTargetException;
 import java.math.BigInteger;
@@ -66,59 +65,6 @@ public class FBUtilities
     private static volatile InetAddress localInetAddress_;
     private static volatile InetAddress broadcastInetAddress_;
 
-    private final static byte[] charToByte = new byte[256];
-    // package protected for use by ByteBufferUtil. Do not modify this array !!
-    static final char[] byteToChar = new char[16];
-    static
-    {
-        for (char c = 0; c < charToByte.length; ++c)
-        {
-            if (c >= '0' && c <= '9')
-                charToByte[c] = (byte)(c - '0');
-            else if (c >= 'A' && c <= 'F')
-                charToByte[c] = (byte)(c - 'A' + 10);
-            else if (c >= 'a' && c <= 'f')
-                charToByte[c] = (byte)(c - 'a' + 10);
-            else
-                charToByte[c] = (byte)-1;
-        }
-
-        for (int i = 0; i < 16; ++i)
-        {
-            byteToChar[i] = Integer.toHexString(i).charAt(0);
-        }
-    }
-
-    /**
-     * This constructor enables us to construct a String directly by wrapping a char array, with zero-copy.
-     * This can save time, and a lot of memory, when converting large column values.
-     */
-    private static final Constructor<String> stringConstructor = getProtectedConstructor(String.class, int.class, int.class, char[].class);
-
-    /**
-     * Create a String from a char array with zero-copy (if available), using reflection to access a package-protected constructor of String.
-     * */
-    public static String wrapCharArray(char[] c)
-    {
-        if (c == null)
-            return null;
-
-        String s = null;
-
-        if (stringConstructor != null)
-        {
-            try
-            {
-                s = stringConstructor.newInstance(0, c.length, c);
-            }
-            catch (Exception e)
-            {
-                // Swallowing as we'll just use a copying constructor
-            }
-        }
-        return s == null ? new String(c) : s;
-    }
-
     private static final ThreadLocal<MessageDigest> localMD5Digest = new ThreadLocal<MessageDigest>()
     {
         @Override
@@ -400,35 +346,6 @@ public class FBUtilities
         return messageDigest.digest();
     }
 
-    public static byte[] hexToBytes(String str)
-    {
-        if (str.length() % 2 == 1)
-            str = "0" + str;
-        byte[] bytes = new byte[str.length() / 2];
-        for (int i = 0; i < bytes.length; i++)
-        {
-            byte halfByte1 = charToByte[str.charAt(i * 2)];
-            byte halfByte2 = charToByte[str.charAt(i * 2 + 1)];
-            if (halfByte1 == -1 || halfByte2 == -1)
-                throw new NumberFormatException("Non-hex characters in " + str);
-            bytes[i] = (byte)((halfByte1 << 4) | halfByte2);
-        }
-        return bytes;
-    }
-
-    public static String bytesToHex(byte... bytes)
-    {
-        char[] c = new char[bytes.length * 2];
-        for (int i = 0; i < bytes.length; i++)
-        {
-            int bint = bytes[i];
-            c[i * 2] = FBUtilities.byteToChar[(bint & 0xf0) >> 4];
-            c[1 + i * 2] = FBUtilities.byteToChar[bint & 0x0f];
-        }
-
-        return wrapCharArray(c);
-    }
-
     public static void renameWithConfirm(String tmpFilename, String filename) throws IOException
     {
         if (!new File(tmpFilename).renameTo(new File(filename)))
@@ -723,28 +640,6 @@ public class FBUtilities
         return field;
     }
 
-    /**
-     * Used to get access to protected/private constructor of the specified class
-     * @param klass - name of the class
-     * @param paramTypes - types of the constructor parameters
-     * @return Constructor if successful, null if the constructor cannot be
-     * accessed
-     */
-    public static Constructor getProtectedConstructor(Class klass, Class... paramTypes)
-    {
-        Constructor c;
-        try
-        {
-            c = klass.getDeclaredConstructor(paramTypes);
-            c.setAccessible(true);
-            return c;
-        }
-        catch (Exception e)
-        {
-            return null;
-        }
-    }
-
     public static IRowCacheProvider newCacheProvider(String cache_provider) throws ConfigurationException
     {
         if (!cache_provider.contains("."))
diff --git a/src/java/org/apache/cassandra/utils/Hex.java b/src/java/org/apache/cassandra/utils/Hex.java
new file mode 100644
index 0000000000..757099e5dc
--- /dev/null
+++ b/src/java/org/apache/cassandra/utils/Hex.java
@@ -0,0 +1,123 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.cassandra.utils;
+
+import java.lang.reflect.Constructor;
+
+public class Hex
+{
+    private static final Constructor<String> stringConstructor = getProtectedConstructor(String.class, int.class, int.class, char[].class);
+    private final static byte[] charToByte = new byte[256];
+    
+    // package protected for use by ByteBufferUtil. Do not modify this array !!
+    static final char[] byteToChar = new char[16];
+    static
+    {
+        for (char c = 0; c < charToByte.length; ++c)
+        {
+            if (c >= '0' && c <= '9')
+                charToByte[c] = (byte)(c - '0');
+            else if (c >= 'A' && c <= 'F')
+                charToByte[c] = (byte)(c - 'A' + 10);
+            else if (c >= 'a' && c <= 'f')
+                charToByte[c] = (byte)(c - 'a' + 10);
+            else
+                charToByte[c] = (byte)-1;
+        }
+
+        for (int i = 0; i < 16; ++i)
+        {
+            byteToChar[i] = Integer.toHexString(i).charAt(0);
+        }
+    }
+    
+    public static byte[] hexToBytes(String str)
+    {
+        if (str.length() % 2 == 1)
+            str = "0" + str;
+        byte[] bytes = new byte[str.length() / 2];
+        for (int i = 0; i < bytes.length; i++)
+        {
+            byte halfByte1 = charToByte[str.charAt(i * 2)];
+            byte halfByte2 = charToByte[str.charAt(i * 2 + 1)];
+            if (halfByte1 == -1 || halfByte2 == -1)
+                throw new NumberFormatException("Non-hex characters in " + str);
+            bytes[i] = (byte)((halfByte1 << 4) | halfByte2);
+        }
+        return bytes;
+    }
+
+    public static String bytesToHex(byte... bytes)
+    {
+        char[] c = new char[bytes.length * 2];
+        for (int i = 0; i < bytes.length; i++)
+        {
+            int bint = bytes[i];
+            c[i * 2] = byteToChar[(bint & 0xf0) >> 4];
+            c[1 + i * 2] = byteToChar[bint & 0x0f];
+        }
+
+        return wrapCharArray(c);
+    }
+    
+    /**
+     * Create a String from a char array with zero-copy (if available), using reflection to access a package-protected constructor of String.
+     * */
+    public static String wrapCharArray(char[] c)
+    {
+        if (c == null)
+            return null;
+
+        String s = null;
+
+        if (stringConstructor != null)
+        {
+            try
+            {
+                s = stringConstructor.newInstance(0, c.length, c);
+            }
+            catch (Exception e)
+            {
+                // Swallowing as we'll just use a copying constructor
+            }
+        }
+        return s == null ? new String(c) : s;
+    }
+    
+    /**
+     * Used to get access to protected/private constructor of the specified class
+     * @param klass - name of the class
+     * @param paramTypes - types of the constructor parameters
+     * @return Constructor if successful, null if the constructor cannot be
+     * accessed
+     */
+    public static Constructor getProtectedConstructor(Class klass, Class... paramTypes)
+    {
+        Constructor c;
+        try
+        {
+            c = klass.getDeclaredConstructor(paramTypes);
+            c.setAccessible(true);
+            return c;
+        }
+        catch (Exception e)
+        {
+            return null;
+        }
+    }
+}
diff --git a/src/java/org/apache/cassandra/utils/MerkleTree.java b/src/java/org/apache/cassandra/utils/MerkleTree.java
index 190b3173b8..ee051e5afc 100644
--- a/src/java/org/apache/cassandra/utils/MerkleTree.java
+++ b/src/java/org/apache/cassandra/utils/MerkleTree.java
@@ -883,7 +883,7 @@ public class MerkleTree implements Serializable
         {
             if (hash == null)
                 return "null";
-            return "[" + FBUtilities.bytesToHex(hash) + "]";
+            return "[" + Hex.bytesToHex(hash) + "]";
         }
         
         private static class HashableSerializer implements ICompactSerializer<Hashable>
diff --git a/test/unit/org/apache/cassandra/db/marshal/RoundTripTest.java b/test/unit/org/apache/cassandra/db/marshal/RoundTripTest.java
index 87664eb11b..9e561113fc 100644
--- a/test/unit/org/apache/cassandra/db/marshal/RoundTripTest.java
+++ b/test/unit/org/apache/cassandra/db/marshal/RoundTripTest.java
@@ -25,6 +25,7 @@ import com.google.common.base.Charsets;
 
 import org.apache.cassandra.cql.jdbc.*;
 import org.apache.cassandra.utils.FBUtilities;
+import org.apache.cassandra.utils.Hex;
 import org.apache.cassandra.utils.UUIDGen;
 import org.junit.Test;
 
@@ -85,12 +86,12 @@ public class RoundTripTest
     public void testBytes()
     {
         byte[] v = new byte[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
-        assert JdbcBytes.instance.toString(BytesType.instance.fromString(FBUtilities.bytesToHex(v)))
-                .equals(FBUtilities.bytesToHex(v));
+        assert JdbcBytes.instance.toString(BytesType.instance.fromString(Hex.bytesToHex(v)))
+                .equals(Hex.bytesToHex(v));
         assert BytesType.instance.fromString(JdbcBytes.instance.toString(ByteBuffer.wrap(v)))
                 .equals(ByteBuffer.wrap(v));
         assert BytesType.instance.compose(ByteBuffer.wrap(v)).equals(ByteBuffer.wrap(v));
-        assert JdbcBytes.instance.toString(ByteBuffer.wrap(v)).equals(FBUtilities.bytesToHex(v));
+        assert JdbcBytes.instance.toString(ByteBuffer.wrap(v)).equals(Hex.bytesToHex(v));
     }
     
     @Test
diff --git a/test/unit/org/apache/cassandra/utils/FBUtilitiesTest.java b/test/unit/org/apache/cassandra/utils/FBUtilitiesTest.java
index ee6c7a6bda..88a49b87f7 100644
--- a/test/unit/org/apache/cassandra/utils/FBUtilitiesTest.java
+++ b/test/unit/org/apache/cassandra/utils/FBUtilitiesTest.java
@@ -18,58 +18,18 @@
 
 package org.apache.cassandra.utils;
 
-import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.nio.charset.CharacterCodingException;
-import java.util.Arrays;
 
 import com.google.common.base.Charsets;
 import org.junit.Test;
 
 public class FBUtilitiesTest 
 {
-	@Test
-    public void testHexBytesConversion()
-    {
-        for (int i = Byte.MIN_VALUE; i <= Byte.MAX_VALUE; i++)
-        {
-            byte[] b = new byte[]{ (byte)i };
-            String s = FBUtilities.bytesToHex(b);
-            byte[] c = FBUtilities.hexToBytes(s);
-            assertArrayEquals(b, c);
-        }
-    }
-    
-    @Test
-    public void testHexToBytesStringConversion()
-    {
-        String[] values = new String[]
-        {
-            "0",
-            "10",
-            "100",
-            "101",
-            "f",
-            "ff"
-        };
-        byte[][] expected = new byte[][]
-        {
-            new byte[] { 0x00 },
-            new byte[] { 0x10 },
-            new byte[] { 0x01, 0x00 },
-            new byte[] { 0x01, 0x01 },
-            new byte[] { 0x0f },
-            new byte[] { (byte)0x000000ff }
-        };
-        
-        for (int i = 0; i < values.length; i++)
-            assert Arrays.equals(FBUtilities.hexToBytes(values[i]), expected[i]);
-    }
-
     @Test
     public void testCopyIntoBytes()
     {
diff --git a/test/unit/org/apache/cassandra/utils/HexTest.java b/test/unit/org/apache/cassandra/utils/HexTest.java
new file mode 100644
index 0000000000..34a8b306b1
--- /dev/null
+++ b/test/unit/org/apache/cassandra/utils/HexTest.java
@@ -0,0 +1,65 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.cassandra.utils;
+
+import static org.junit.Assert.assertArrayEquals;
+
+import java.util.Arrays;
+import org.junit.Test;
+
+public class HexTest
+{
+    @Test
+    public void testHexBytesConversion()
+    {
+        for (int i = Byte.MIN_VALUE; i <= Byte.MAX_VALUE; i++)
+        {
+            byte[] b = new byte[]{ (byte)i };
+            String s = Hex.bytesToHex(b);
+            byte[] c = Hex.hexToBytes(s);
+            assertArrayEquals(b, c);
+        }
+    }
+
+    @Test
+    public void testHexToBytesStringConversion()
+    {
+        String[] values = new String[]
+        {
+            "0",
+            "10",
+            "100",
+            "101",
+            "f",
+            "ff"
+        };
+        byte[][] expected = new byte[][]
+        {
+            new byte[] { 0x00 },
+            new byte[] { 0x10 },
+            new byte[] { 0x01, 0x00 },
+            new byte[] { 0x01, 0x01 },
+            new byte[] { 0x0f },
+            new byte[] { (byte)0x000000ff }
+        };
+        
+        for (int i = 0; i < values.length; i++)
+            assert Arrays.equals(Hex.hexToBytes(values[i]), expected[i]);
+    }
+}
diff --git a/test/unit/org/apache/cassandra/utils/MerkleTreeTest.java b/test/unit/org/apache/cassandra/utils/MerkleTreeTest.java
index ded9f515a9..685a191051 100644
--- a/test/unit/org/apache/cassandra/utils/MerkleTreeTest.java
+++ b/test/unit/org/apache/cassandra/utils/MerkleTreeTest.java
@@ -30,7 +30,6 @@ import java.io.ByteArrayOutputStream;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
 import java.math.BigInteger;
-import java.nio.ByteBuffer;
 import java.util.ArrayDeque;
 import java.util.Arrays;
 import java.util.Iterator;
@@ -89,8 +88,8 @@ public class MerkleTreeTest
 
     public static void assertHashEquals(String message, final byte[] left, final byte[] right)
     {
-        String lstring = left == null ? "null" : FBUtilities.bytesToHex(left);
-        String rstring = right == null ? "null" : FBUtilities.bytesToHex(right);
+        String lstring = left == null ? "null" : Hex.bytesToHex(left);
+        String rstring = right == null ? "null" : Hex.bytesToHex(right);
         assertEquals(message, lstring, rstring);
     }
 
