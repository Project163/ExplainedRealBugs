diff --git a/CHANGES.txt b/CHANGES.txt
index dbee73e353..a259545f7b 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 3.0.15
+ * Fix counter application order in short read protection (CASSANDRA-12872)
  * Don't block RepairJob execution on validation futures (CASSANDRA-13797)
  * Wait for all management tasks to complete before shutting down CLSM (CASSANDRA-13123)
  * INSERT statement fails when Tuple type is used as clustering column with default DESC order (CASSANDRA-13717)
diff --git a/src/java/org/apache/cassandra/service/DataResolver.java b/src/java/org/apache/cassandra/service/DataResolver.java
index c59d688226..580fd8bd82 100644
--- a/src/java/org/apache/cassandra/service/DataResolver.java
+++ b/src/java/org/apache/cassandra/service/DataResolver.java
@@ -473,11 +473,17 @@ public class DataResolver extends ResponseResolver
         @Override
         public UnfilteredRowIterator applyToPartition(UnfilteredRowIterator partition)
         {
-            partition = Transformation.apply(partition, counter);
-            // must apply and extend with same protection instance
             ShortReadRowProtection protection = new ShortReadRowProtection(partition.metadata(), partition.partitionKey());
-            partition = MoreRows.extend(partition, protection);
-            partition = Transformation.apply(partition, protection); // apply after, so it is retained when we extend (in case we need to reextend)
+
+            partition = MoreRows.extend(partition, protection); // enable moreContents()
+
+            /*
+             * if we don't apply these transformations *after* extending the partition with MoreRows,
+             * their applyToRow() method will not be called on the first row of the new extension iterator
+             */
+            partition = Transformation.apply(partition, protection); // track lastClustering
+            partition = Transformation.apply(partition, counter);    // do the counting
+
             return partition;
         }
 
