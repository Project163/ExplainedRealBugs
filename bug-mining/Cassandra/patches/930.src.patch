diff --git a/CHANGES.txt b/CHANGES.txt
index af30314e16..5628c9c1de 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,6 +1,8 @@
 0.7.7
  * adjust hinted handoff page size to avoid OOM with large columns 
    (CASSANDRA-2652)
+ * mark BRAF buffer invalid post-flush so we don't re-flush partial
+   buffers again, especially on CL writes (CASSANDRA-2660)
 
 
 0.7.6
diff --git a/src/java/org/apache/cassandra/io/util/BufferedRandomAccessFile.java b/src/java/org/apache/cassandra/io/util/BufferedRandomAccessFile.java
index 00aba8ddc7..439f316b81 100644
--- a/src/java/org/apache/cassandra/io/util/BufferedRandomAccessFile.java
+++ b/src/java/org/apache/cassandra/io/util/BufferedRandomAccessFile.java
@@ -128,6 +128,9 @@ public class BufferedRandomAccessFile extends RandomAccessFile implements FileDa
         fd = CLibrary.getfd(this.getFD());
     }
 
+    /**
+     * Flush (flush()) whatever writes are pending, and block until the data has been persistently committed (fsync()).
+     */
     public void sync() throws IOException
     {
         if (syncNeeded)
@@ -150,6 +153,11 @@ public class BufferedRandomAccessFile extends RandomAccessFile implements FileDa
         }
     }
 
+    /**
+     * If we are dirty, flush dirty contents to the operating system. Does not imply fsync().
+     *
+     * Currently, for implementation reasons, this also invalidates the buffer.
+     */
     public void flush() throws IOException
     {
         if (isDirty)
@@ -181,20 +189,25 @@ public class BufferedRandomAccessFile extends RandomAccessFile implements FileDa
 
             }
 
+            // Remember that we wrote, so we don't write it again on next flush().
+            resetBuffer();
+
             isDirty = false;
         }
     }
 
+    private void resetBuffer()
+    {
+        bufferOffset = current;
+        validBufferBytes = 0;
+    }
+
     private void reBuffer() throws IOException
     {
         flush(); // synchronizing buffer and file on disk
-
-        bufferOffset = current;
+        resetBuffer();
         if (bufferOffset >= channel.size())
-        {
-            validBufferBytes = 0;
             return;
-        }
 
         if (bufferOffset < minBufferOffset)
             minBufferOffset = bufferOffset;
