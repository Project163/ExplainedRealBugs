diff --git a/CHANGES.txt b/CHANGES.txt
index 2e6715f0a2..ec95e2084e 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 4.0-beta3
+ * Remove bad assert when getting active compactions for an sstable (CASSANDRA-15457)
  * Avoid failing compactions with very large partitions (CASSANDRA-15164)
  * Prevent NPE in StreamMessage in type lookup (CASSANDRA-16131)
  * Avoid invalid state transition exception during incremental repair (CASSANDRA-16067)
diff --git a/src/java/org/apache/cassandra/db/compaction/ActiveCompactions.java b/src/java/org/apache/cassandra/db/compaction/ActiveCompactions.java
index 5bcb06fb74..7b6b5bf1fe 100644
--- a/src/java/org/apache/cassandra/db/compaction/ActiveCompactions.java
+++ b/src/java/org/apache/cassandra/db/compaction/ActiveCompactions.java
@@ -19,6 +19,7 @@
 package org.apache.cassandra.db.compaction;
 
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.Collections;
 import java.util.IdentityHashMap;
 import java.util.List;
@@ -49,22 +50,23 @@ public class ActiveCompactions implements ActiveCompactionsTracker
     }
 
     /**
-     * Iterates over the active compactions and tries to find the CompactionInfo for the given sstable
+     * Iterates over the active compactions and tries to find CompactionInfos with the given compactionType for the given sstable
      *
      * Number of entries in compactions should be small (< 10) but avoid calling in any time-sensitive context
      */
-    public CompactionInfo getCompactionForSSTable(SSTableReader sstable)
+    public Collection<CompactionInfo> getCompactionsForSSTable(SSTableReader sstable, OperationType compactionType)
     {
-        CompactionInfo toReturn = null;
+        List<CompactionInfo> toReturn = null;
         synchronized (compactions)
         {
             for (CompactionInfo.Holder holder : compactions)
             {
-                if (holder.getCompactionInfo().getSSTables().contains(sstable))
+                CompactionInfo compactionInfo = holder.getCompactionInfo();
+                if (compactionInfo.getSSTables().contains(sstable) && compactionInfo.getTaskType() == compactionType)
                 {
-                    if (toReturn != null)
-                        throw new IllegalStateException("SSTable " + sstable + " involved in several compactions");
-                    toReturn = holder.getCompactionInfo();
+                    if (toReturn == null)
+                        toReturn = new ArrayList<>();
+                    toReturn.add(compactionInfo);
                 }
             }
         }
diff --git a/src/java/org/apache/cassandra/db/repair/PendingAntiCompaction.java b/src/java/org/apache/cassandra/db/repair/PendingAntiCompaction.java
index e49e76e215..e0ee68d955 100644
--- a/src/java/org/apache/cassandra/db/repair/PendingAntiCompaction.java
+++ b/src/java/org/apache/cassandra/db/repair/PendingAntiCompaction.java
@@ -145,14 +145,19 @@ public class PendingAntiCompaction
                 }
                 return false;
             }
-            CompactionInfo ci = CompactionManager.instance.active.getCompactionForSSTable(sstable);
-            if (ci != null && ci.getTaskType() == OperationType.ANTICOMPACTION)
+            Collection<CompactionInfo> cis = CompactionManager.instance.active.getCompactionsForSSTable(sstable, OperationType.ANTICOMPACTION);
+            if (cis != null && !cis.isEmpty())
             {
                 // todo: start tracking the parent repair session id that created the anticompaction to be able to give a better error messsage here:
-                String message = String.format("Prepare phase for incremental repair session %s has failed because it encountered " +
-                                               "intersecting sstables (%s) belonging to another incremental repair session. This is " +
-                                               "caused by starting multiple conflicting incremental repairs at the same time", prsid, ci.getSSTables());
-                throw new SSTableAcquisitionException(message);
+                StringBuilder sb = new StringBuilder();
+                sb.append("Prepare phase for incremental repair session ");
+                sb.append(prsid);
+                sb.append(" has failed because it encountered intersecting sstables belonging to another incremental repair session. ");
+                sb.append("This is caused by starting multiple conflicting incremental repairs at the same time. ");
+                sb.append("Conflicting anticompactions: ");
+                for (CompactionInfo ci : cis)
+                    sb.append(ci.getTaskId() == null ? "no compaction id" : ci.getTaskId()).append(':').append(ci.getSSTables()).append(',');
+                throw new SSTableAcquisitionException(sb.toString());
             }
             return true;
         }
