diff --git a/CHANGES.txt b/CHANGES.txt
index 3aadd0c78c..9c158c3f2b 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 4.0.9
+ * Fix BufferPool incorrect memoryInUse when putUnusedPortion is used (CASSANDRA-18311)
  * Improve memtable allocator accounting when updating AtomicBTreePartition (CASSANDRA-18125)
  * Update zstd-jni to version 1.5.4-1 (CASSANDRA-18259)
  * Split and order IDEA workspace template VM_PARAMETERS (CASSANDRA-18242)
diff --git a/src/java/org/apache/cassandra/utils/memory/BufferPool.java b/src/java/org/apache/cassandra/utils/memory/BufferPool.java
index 443e9d04a1..a92f63782a 100644
--- a/src/java/org/apache/cassandra/utils/memory/BufferPool.java
+++ b/src/java/org/apache/cassandra/utils/memory/BufferPool.java
@@ -860,7 +860,8 @@ public class BufferPool
         public void putUnusedPortion(ByteBuffer buffer)
         {
             Chunk chunk = Chunk.getParentChunk(buffer);
-            int size = buffer.capacity() - buffer.limit();
+            int originalCapacity = buffer.capacity();
+            int size = originalCapacity - buffer.limit();
 
             if (chunk == null)
             {
@@ -869,7 +870,8 @@ public class BufferPool
             }
 
             chunk.freeUnusedPortion(buffer);
-            memoryInUse.add(-size);
+            // Calculate the actual freed bytes which may be different from `size` when pooling is involved
+            memoryInUse.add(buffer.capacity() - originalCapacity);
         }
 
         public ByteBuffer get(int size)
diff --git a/test/unit/org/apache/cassandra/utils/memory/BufferPoolTest.java b/test/unit/org/apache/cassandra/utils/memory/BufferPoolTest.java
index 40fbb61686..2b5df298dc 100644
--- a/test/unit/org/apache/cassandra/utils/memory/BufferPoolTest.java
+++ b/test/unit/org/apache/cassandra/utils/memory/BufferPoolTest.java
@@ -1018,6 +1018,38 @@ public class BufferPoolTest
         assertEquals(0, bufferPool.usedSizeInBytes());
     }
 
+    @Test
+    public void testPuttingUnusedPortion()
+    {
+        final int expectedCapacity = BufferPool.TINY_ALLOCATION_UNIT * 4;
+        final int quarterUnit = BufferPool.TINY_ALLOCATION_UNIT / 4;
+        final int requestedCapacity = expectedCapacity - 3 * quarterUnit;
+
+        ByteBuffer buffer = bufferPool.getAtLeast(requestedCapacity, BufferType.OFF_HEAP);
+        assertNotNull(buffer);
+        assertEquals(expectedCapacity, buffer.capacity());
+        assertEquals(expectedCapacity, bufferPool.usedSizeInBytes());
+
+        buffer.limit(requestedCapacity); // 3.25 x unit
+        bufferPool.putUnusedPortion(buffer);
+
+        // the unused portion was too small to be returned, the buffer remains unchanged
+        assertEquals(expectedCapacity, buffer.capacity());
+        // used size is didn't change either
+        assertEquals(expectedCapacity, bufferPool.usedSizeInBytes());
+
+        buffer.limit(expectedCapacity - BufferPool.TINY_ALLOCATION_UNIT); // 3.0 x unit
+        bufferPool.putUnusedPortion(buffer);
+
+        // now we should notice a change
+        assertEquals(BufferPool.TINY_ALLOCATION_UNIT * 3, buffer.capacity());
+        assertEquals(BufferPool.TINY_ALLOCATION_UNIT * 3, bufferPool.usedSizeInBytes());
+
+        bufferPool.put(buffer);
+
+        assertEquals(0, bufferPool.usedSizeInBytes());
+    }
+
     private BufferPool.Chunk allocate(int num, int bufferSize, List<ByteBuffer> buffers)
     {
         for (int i = 0; i < num; i++)
