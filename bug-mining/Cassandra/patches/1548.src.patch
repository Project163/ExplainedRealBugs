diff --git a/src/java/org/apache/cassandra/io/sstable/SSTableReader.java b/src/java/org/apache/cassandra/io/sstable/SSTableReader.java
index 8c0719e253..b4fed4a8f6 100644
--- a/src/java/org/apache/cassandra/io/sstable/SSTableReader.java
+++ b/src/java/org/apache/cassandra/io/sstable/SSTableReader.java
@@ -409,6 +409,7 @@ public class SSTableReader extends SSTable
         }
         this.first = getMinimalKey(left);
         this.last = getMinimalKey(right);
+        assert this.first.compareTo(this.last) <= 0: String.format("SSTable first key %s > last key %s", this.first, this.last);
 
         // finalize the state of the reader
         ifile = ibuilder.complete(descriptor.filenameFor(Component.PRIMARY_INDEX));
diff --git a/src/java/org/apache/cassandra/io/sstable/SSTableWriter.java b/src/java/org/apache/cassandra/io/sstable/SSTableWriter.java
index 5e9924124a..b1fcc79f26 100644
--- a/src/java/org/apache/cassandra/io/sstable/SSTableWriter.java
+++ b/src/java/org/apache/cassandra/io/sstable/SSTableWriter.java
@@ -123,19 +123,14 @@ public class SSTableWriter extends SSTable
         }
     }
 
+    /**
+     * Perform sanity checks on @param decoratedKey and @return the position in the data file before any data is written
+     */
     private long beforeAppend(DecoratedKey<?> decoratedKey) throws IOException
     {
-        if (decoratedKey == null)
-        {
-            throw new IOException("Keys must not be null.");
-        }
-        if (lastWrittenKey != null && lastWrittenKey.compareTo(decoratedKey) > 0)
-        {
-            logger.info("Last written key : " + lastWrittenKey);
-            logger.info("Current key : " + decoratedKey);
-            logger.info("Writing into file " + getFilename());
-            throw new IOException("Keys must be written in ascending order.");
-        }
+        assert decoratedKey != null : "Keys must not be null";
+        assert lastWrittenKey == null || lastWrittenKey.compareTo(decoratedKey) < 0
+               : "Last written key " + lastWrittenKey + " >= current key " + decoratedKey + " writing into " + getFilename();
         return (lastWrittenKey == null) ? 0 : dataFile.getFilePointer();
     }
 
diff --git a/src/java/org/apache/cassandra/utils/IntervalTree/IntervalNode.java b/src/java/org/apache/cassandra/utils/IntervalTree/IntervalNode.java
index 38c4328ace..3b87134dfa 100644
--- a/src/java/org/apache/cassandra/utils/IntervalTree/IntervalNode.java
+++ b/src/java/org/apache/cassandra/utils/IntervalTree/IntervalNode.java
@@ -53,6 +53,11 @@ public class IntervalNode
             //if i.max < v_pt then it goes to the left subtree
             List<Interval> leftSegment = getLeftIntervals(toBisect);
             List<Interval> rightSegment = getRightIntervals(toBisect);
+            assert (intersects.size() + leftSegment.size() + rightSegment.size()) == toBisect.size() :
+                    "intersects (" + String.valueOf(intersects.size()) +
+                    ") + leftSegment (" + String.valueOf(leftSegment.size()) +
+                    ") + rightSegment (" + String.valueOf(rightSegment.size()) +
+                    ") != toBisect (" + String.valueOf(toBisect.size()) + ")";
             if (leftSegment.size() > 0)
                 this.left = new IntervalNode(leftSegment);
             if (rightSegment.size() > 0)
@@ -102,6 +107,7 @@ public class IntervalNode
 
             for (Interval interval : intervals)
             {
+                assert interval.min.compareTo(interval.max) <= 0 : "Interval min > max";
                 allEndpoints.add(interval.min);
                 allEndpoints.add(interval.max);
             }
