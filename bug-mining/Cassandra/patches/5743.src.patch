diff --git a/CHANGES.txt b/CHANGES.txt
index 784c550278..99e53e9174 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 3.0.25:
+ * Don't wait on schema versions from replacement target when replacing (CASSANDRA-16692)
  * StandaloneVerifier does not fail when unable to verify SSTables, it only fails if Corruption is thrown (CASSANDRA-16683)
  * Fix bloom filter false ratio calculation by including true negatives (CASSANDRA-15834)
  * Prevent loss of commit log data when moving sstables between nodes (CASSANDRA-16619)
diff --git a/src/java/org/apache/cassandra/service/MigrationCoordinator.java b/src/java/org/apache/cassandra/service/MigrationCoordinator.java
index 94c90ae5dd..da69a6807d 100644
--- a/src/java/org/apache/cassandra/service/MigrationCoordinator.java
+++ b/src/java/org/apache/cassandra/service/MigrationCoordinator.java
@@ -21,11 +21,13 @@ package org.apache.cassandra.service;
 import java.lang.management.ManagementFactory;
 import java.lang.management.RuntimeMXBean;
 import java.net.InetAddress;
+import java.net.UnknownHostException;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Deque;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -35,6 +37,7 @@ import java.util.concurrent.FutureTask;
 import java.util.concurrent.TimeUnit;
 
 import com.google.common.annotations.VisibleForTesting;
+import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.Futures;
@@ -45,6 +48,7 @@ import org.apache.cassandra.concurrent.LocalAwareExecutorService;
 import org.apache.cassandra.concurrent.ScheduledExecutors;
 import org.apache.cassandra.concurrent.Stage;
 import org.apache.cassandra.concurrent.StageManager;
+import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.config.Schema;
 import org.apache.cassandra.db.Mutation;
 import org.apache.cassandra.gms.ApplicationState;
@@ -71,6 +75,50 @@ public class MigrationCoordinator
 
     public static final MigrationCoordinator instance = new MigrationCoordinator();
 
+    public static final String IGNORED_VERSIONS_PROP = "cassandra.skip_schema_check_for_versions";
+    public static final String IGNORED_ENDPOINTS_PROP = "cassandra.skip_schema_check_for_endpoints";
+
+    private static ImmutableSet<UUID> getIgnoredVersions()
+    {
+        String s = System.getProperty(IGNORED_VERSIONS_PROP);
+        if (s == null || s.isEmpty())
+            return ImmutableSet.of();
+
+        ImmutableSet.Builder<UUID> versions = ImmutableSet.builder();
+        for (String version : s.split(","))
+        {
+            versions.add(UUID.fromString(version));
+        }
+
+        return versions.build();
+    }
+
+    private static final Set<UUID> IGNORED_VERSIONS = getIgnoredVersions();
+
+    private static Set<InetAddress> getIgnoredEndpoints()
+    {
+        Set<InetAddress> endpoints = new HashSet<>();
+
+        String s = System.getProperty(IGNORED_ENDPOINTS_PROP);
+        if (s == null || s.isEmpty())
+            return endpoints;
+
+        for (String endpoint : s.split(","))
+        {
+            try
+            {
+                endpoints.add(InetAddress.getByName(endpoint));
+            }
+            catch (UnknownHostException e)
+            {
+                throw new RuntimeException(e);
+            }
+        }
+
+        return endpoints;
+    }
+
+
     static class VersionInfo
     {
         final UUID version;
@@ -111,6 +159,8 @@ public class MigrationCoordinator
     private final Map<UUID, VersionInfo> versionInfo = new HashMap<>();
     private final Map<InetAddress, UUID> endpointVersions = new HashMap<>();
 
+    private final Set<InetAddress> ignoredEndpoints = getIgnoredEndpoints();
+
     public void start()
     {
         ScheduledExecutors.scheduledTasks.scheduleWithFixedDelay(this::pullUnreceivedSchemaVersions, 1, 1, TimeUnit.MINUTES);
@@ -294,6 +344,13 @@ public class MigrationCoordinator
 
     synchronized Future<Void> reportEndpointVersion(InetAddress endpoint, UUID version)
     {
+        if (ignoredEndpoints.contains(endpoint) || IGNORED_VERSIONS.contains(version))
+        {
+            endpointVersions.remove(endpoint);
+            removeEndpointFromVersion(endpoint, null);
+            return FINISHED_FUTURE;
+        }
+
         UUID current = endpointVersions.put(endpoint, version);
         if (current != null && current.equals(version))
             return FINISHED_FUTURE;
@@ -341,8 +398,10 @@ public class MigrationCoordinator
         }
     }
 
-    public synchronized void removeVersionInfoForEndpoint(InetAddress endpoint)
+    public synchronized void removeAndIgnoreEndpoint(InetAddress endpoint)
     {
+        Preconditions.checkArgument(endpoint != null);
+        ignoredEndpoints.add(endpoint);
         Set<UUID> versions = ImmutableSet.copyOf(versionInfo.keySet());
         for (UUID version : versions)
         {
diff --git a/src/java/org/apache/cassandra/service/StorageService.java b/src/java/org/apache/cassandra/service/StorageService.java
index 334f872f7c..54ea902c93 100644
--- a/src/java/org/apache/cassandra/service/StorageService.java
+++ b/src/java/org/apache/cassandra/service/StorageService.java
@@ -822,6 +822,7 @@ public class StorageService extends NotificationBroadcasterSupport implements IE
                     appStates.put(ApplicationState.TOKENS, valueFactory.tokens(bootstrapTokens));
                     appStates.put(ApplicationState.STATUS, valueFactory.hibernate(true));
                 }
+                MigrationCoordinator.instance.removeAndIgnoreEndpoint(DatabaseDescriptor.getReplaceAddress());
             }
             else if (shouldBootstrap())
             {
@@ -899,7 +900,8 @@ public class StorageService extends NotificationBroadcasterSupport implements IE
 
         logger.warn(String.format("There are nodes in the cluster with a different schema version than us we did not merged schemas from, " +
                                   "our version : (%s), outstanding versions -> endpoints : %s. Use -Dcassandra.skip_schema_check=true " +
-                                  "to ignore this.",
+                                  "to ignore this, -Dcassandra.skip_schema_check_for_endpoints=<ep1[,epN]> to skip specific endpoints," +
+                                  "or -Dcassandra.skip_schema_check_for_versions=<ver1[,verN]> to skip specific schema versions",
                                   Schema.instance.getVersion(),
                                   MigrationCoordinator.instance.outstandingVersions()));
 
@@ -2463,7 +2465,7 @@ public class StorageService extends NotificationBroadcasterSupport implements IE
     private void removeEndpoint(InetAddress endpoint)
     {
         Gossiper.runInGossipStageBlocking(() -> Gossiper.instance.removeEndpoint(endpoint));
-        MigrationCoordinator.instance.removeVersionInfoForEndpoint(endpoint);
+        MigrationCoordinator.instance.removeAndIgnoreEndpoint(endpoint);
         SystemKeyspace.removeEndpoint(endpoint);
     }
 
diff --git a/test/distributed/org/apache/cassandra/distributed/test/MigrationCoordinatorTest.java b/test/distributed/org/apache/cassandra/distributed/test/MigrationCoordinatorTest.java
new file mode 100644
index 0000000000..176652519b
--- /dev/null
+++ b/test/distributed/org/apache/cassandra/distributed/test/MigrationCoordinatorTest.java
@@ -0,0 +1,122 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.cassandra.distributed.test;
+
+import java.net.InetAddress;
+import java.util.UUID;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import org.apache.cassandra.config.Schema;
+import org.apache.cassandra.distributed.Cluster;
+import org.apache.cassandra.distributed.api.IInstanceConfig;
+import org.apache.cassandra.distributed.api.TokenSupplier;
+import org.apache.cassandra.distributed.shared.NetworkTopology;
+import org.apache.cassandra.service.MigrationCoordinator;
+
+import static org.apache.cassandra.distributed.api.Feature.GOSSIP;
+import static org.apache.cassandra.distributed.api.Feature.NETWORK;
+
+public class MigrationCoordinatorTest extends TestBaseImpl
+{
+
+    @Before
+    public void setUp()
+    {
+        System.clearProperty("cassandra.replace_address");
+        System.clearProperty("cassandra.consistent.rangemovement");
+        System.clearProperty(MigrationCoordinator.IGNORED_ENDPOINTS_PROP);
+        System.clearProperty(MigrationCoordinator.IGNORED_VERSIONS_PROP);
+    }
+    /**
+     * We shouldn't wait on versions only available from a node being replaced
+     * see CASSANDRA-
+     */
+    @Test
+    public void replaceNode() throws Throwable
+    {
+        try (Cluster cluster = Cluster.build(2)
+                                      .withTokenSupplier(TokenSupplier.evenlyDistributedTokens(3))
+                                      .withNodeIdTopology(NetworkTopology.singleDcNetworkTopology(3, "dc0", "rack0"))
+                                      .withConfig(config -> config.with(NETWORK, GOSSIP))
+                                      .start())
+        {
+            cluster.schemaChange("CREATE KEYSPACE ks with replication={'class':'SimpleStrategy', 'replication_factor':2}");
+            InetAddress replacementAddress = cluster.get(2).broadcastAddress().getAddress();
+            cluster.get(2).shutdown(false);
+            cluster.schemaChangeIgnoringStoppedInstances("CREATE TABLE ks.tbl (k int primary key, v int)");
+
+            IInstanceConfig config = cluster.newInstanceConfig();
+            config.set("auto_bootstrap", true);
+            System.setProperty("cassandra.replace_address", replacementAddress.getHostAddress());
+            cluster.bootstrap(config).startup();
+        }
+    }
+
+    @Test
+    public void explicitEndpointIgnore() throws Throwable
+    {
+        try (Cluster cluster = Cluster.build(2)
+                                      .withTokenSupplier(TokenSupplier.evenlyDistributedTokens(3))
+                                      .withNodeIdTopology(NetworkTopology.singleDcNetworkTopology(3, "dc0", "rack0"))
+                                      .withConfig(config -> config.with(NETWORK, GOSSIP))
+                                      .start())
+        {
+            cluster.schemaChange("CREATE KEYSPACE ks with replication={'class':'SimpleStrategy', 'replication_factor':2}");
+            InetAddress ignoredEndpoint = cluster.get(2).broadcastAddress().getAddress();
+            cluster.get(2).shutdown(false);
+            cluster.schemaChangeIgnoringStoppedInstances("CREATE TABLE ks.tbl (k int primary key, v int)");
+
+            IInstanceConfig config = cluster.newInstanceConfig();
+            config.set("auto_bootstrap", true);
+            System.setProperty(MigrationCoordinator.IGNORED_ENDPOINTS_PROP, ignoredEndpoint.getHostAddress());
+            System.setProperty("cassandra.consistent.rangemovement", "false");
+            cluster.bootstrap(config).startup();
+        }
+    }
+
+    @Test
+    public void explicitVersionIgnore() throws Throwable
+    {
+        try (Cluster cluster = Cluster.build(2)
+                                      .withTokenSupplier(TokenSupplier.evenlyDistributedTokens(3))
+                                      .withNodeIdTopology(NetworkTopology.singleDcNetworkTopology(3, "dc0", "rack0"))
+                                      .withConfig(config -> config.with(NETWORK, GOSSIP))
+                                      .start())
+        {
+            UUID initialVersion = cluster.get(2).callsOnInstance(() -> Schema.instance.getVersion()).call();
+            cluster.schemaChange("CREATE KEYSPACE ks with replication={'class':'SimpleStrategy', 'replication_factor':2}");
+            UUID oldVersion;
+            do
+            {
+                oldVersion = cluster.get(2).callsOnInstance(() -> Schema.instance.getVersion()).call();
+            } while (oldVersion.equals(initialVersion));
+            cluster.get(2).shutdown(false);
+            cluster.schemaChangeIgnoringStoppedInstances("CREATE TABLE ks.tbl (k int primary key, v int)");
+
+            IInstanceConfig config = cluster.newInstanceConfig();
+            config.set("auto_bootstrap", true);
+            System.setProperty(MigrationCoordinator.IGNORED_VERSIONS_PROP, initialVersion.toString() + ',' + oldVersion.toString());
+            System.setProperty("cassandra.consistent.rangemovement", "false");
+            cluster.bootstrap(config).startup();
+        }
+    }
+}
+
diff --git a/test/unit/org/apache/cassandra/service/MigrationCoordinatorTest.java b/test/unit/org/apache/cassandra/service/MigrationCoordinatorTest.java
index 3450c2c0ae..fc78d62e84 100644
--- a/test/unit/org/apache/cassandra/service/MigrationCoordinatorTest.java
+++ b/test/unit/org/apache/cassandra/service/MigrationCoordinatorTest.java
@@ -205,7 +205,7 @@ public class MigrationCoordinatorTest
 		WaitQueue.Signal signal = coordinator.getVersionInfoUnsafe(V1).register();
 		Assert.assertFalse(signal.isSignalled());
 
-		coordinator.removeVersionInfoForEndpoint(EP1);
+		coordinator.removeAndIgnoreEndpoint(EP1);
 		Assert.assertNull(coordinator.getVersionInfoUnsafe(V1));
 
 		Assert.assertTrue(signal.isSignalled());
