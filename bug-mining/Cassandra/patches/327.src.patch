diff --git a/src/java/org/apache/cassandra/streaming/IncomingStreamReader.java b/src/java/org/apache/cassandra/streaming/IncomingStreamReader.java
index 2a72c02952..b60b86fee5 100644
--- a/src/java/org/apache/cassandra/streaming/IncomingStreamReader.java
+++ b/src/java/org/apache/cassandra/streaming/IncomingStreamReader.java
@@ -49,7 +49,7 @@ public class IncomingStreamReader
 
     public void read() throws IOException
     {
-        StreamingService.instance.setStatus("Receiving stream");
+        logger.debug("Receiving stream");
         InetSocketAddress remoteAddress = (InetSocketAddress)socketChannel.socket().getRemoteSocketAddress();
         if (logger.isDebugEnabled())
           logger.debug("Creating file for " + pendingFile.getFilename());
@@ -63,7 +63,7 @@ public class IncomingStreamReader
                 bytesRead += fc.transferFrom(socketChannel, bytesRead, FileStreamTask.CHUNK_SIZE);
                 pendingFile.update(bytesRead);
             }
-            StreamingService.instance.setStatus("Receiving stream: finished reading chunk, awaiting more");
+            logger.debug("Receiving stream: finished reading chunk, awaiting more");
         }
         catch (IOException ex)
         {
@@ -73,7 +73,7 @@ public class IncomingStreamReader
             /* Delete the orphaned file. */
             File file = new File(pendingFile.getFilename());
             file.delete();
-            StreamingService.instance.setStatus("Receiving stream: recovering from IO error");
+            logger.debug("Receiving stream: recovering from IO error");
             throw ex;
         }
         finally
@@ -88,7 +88,6 @@ public class IncomingStreamReader
                 logger.debug("Removing stream context " + pendingFile);
             }
             fc.close();
-            StreamingService.instance.setStatus(StreamingService.NOTHING);
             handleStreamCompletion(remoteAddress.getAddress());
         }
     }
diff --git a/src/java/org/apache/cassandra/streaming/StreamOut.java b/src/java/org/apache/cassandra/streaming/StreamOut.java
index 673cba7057..1629a12569 100644
--- a/src/java/org/apache/cassandra/streaming/StreamOut.java
+++ b/src/java/org/apache/cassandra/streaming/StreamOut.java
@@ -57,13 +57,6 @@ public class StreamOut
     private static Logger logger = LoggerFactory.getLogger(StreamOut.class);
 
     static String TABLE_NAME = "STREAMING-TABLE-NAME";
-    
-    private static void updateStatus(String msg)
-    {
-        StreamingService.instance.setStatus(msg);
-        if (logger.isInfoEnabled() && !StreamingService.NOTHING.equals(msg))
-            logger.info(msg);
-    }
 
     /**
      * Split out files for all tables on disk locally for each range and then stream them to the target endpoint.
@@ -75,7 +68,7 @@ public class StreamOut
         // this is so that this target shows up as a destination while anticompaction is happening.
         StreamOutManager.pendingDestinations.add(target);
 
-        logger.debug("Beginning transfer process to " + target + " for ranges " + StringUtils.join(ranges, ", "));
+        logger.info("Beginning transfer process to " + target + " for ranges " + StringUtils.join(ranges, ", "));
 
         /*
          * (1) dump all the memtables to disk.
@@ -85,7 +78,7 @@ public class StreamOut
         try
         {
             Table table = Table.open(tableName);
-            updateStatus("Flushing memtables for " + tableName + "...");
+            logger.info("Flushing memtables for " + tableName + "...");
             for (Future f : table.flush())
             {
                 try
@@ -101,7 +94,7 @@ public class StreamOut
                     throw new RuntimeException(e);
                 }
             }
-            updateStatus("Performing anticompaction ...");
+            logger.info("Performing anticompaction ...");
             /* Get the list of files that need to be streamed */
             transferSSTables(target, table.forceAntiCompaction(ranges, target), tableName); // SSTR GC deletes the file when done
         }
@@ -111,7 +104,6 @@ public class StreamOut
         }
         finally
         {
-            StreamingService.instance.setStatus(StreamingService.NOTHING);
             StreamOutManager.remove(target);
         }
         if (callback != null)
@@ -135,22 +127,21 @@ public class StreamOut
                 pendingFiles[i++] = new PendingFile(desc, component, filelen);
             }
         }
-        if (logger.isDebugEnabled())
-            logger.debug("Stream context metadata " + StringUtils.join(pendingFiles, ", " + " " + sstables.size() + " sstables."));
+        logger.info("Stream context metadata " + StringUtils.join(pendingFiles, ", " + " " + sstables.size() + " sstables."));
         StreamOutManager.get(target).addFilesToStream(pendingFiles);
         StreamInitiateMessage biMessage = new StreamInitiateMessage(pendingFiles);
         Message message = StreamInitiateMessage.makeStreamInitiateMessage(biMessage);
         message.setHeader(StreamOut.TABLE_NAME, table.getBytes());
-        updateStatus("Sending a stream initiate message to " + target + " ...");
+        logger.info("Sending a stream initiate message to " + target + " ...");
         MessagingService.instance.sendOneWay(message, target);
 
         if (pendingFiles.length > 0)
         {
-            StreamingService.instance.setStatus("Waiting for transfer to " + target + " to complete");
+            logger.info("Waiting for transfer to " + target + " to complete");
             StreamOutManager.get(target).waitForStreamCompletion();
             // todo: it would be good if there were a dafe way to remove the StreamManager for target.
             // (StreamManager will delete the streamed file on completion.)
-            updateStatus("Done with transfer to " + target);
+            logger.info("Done with transfer to " + target);
         }
     }
 
diff --git a/src/java/org/apache/cassandra/streaming/StreamOutManager.java b/src/java/org/apache/cassandra/streaming/StreamOutManager.java
index e35e7292ae..556b8319cc 100644
--- a/src/java/org/apache/cassandra/streaming/StreamOutManager.java
+++ b/src/java/org/apache/cassandra/streaming/StreamOutManager.java
@@ -77,6 +77,19 @@ public class StreamOutManager
         hosts.addAll(pendingDestinations);
         return hosts;
     }
+    
+    /** 
+     * this method exists so that we don't have to call StreamOutManager.get() which has a nasty side-effect of 
+     * indicating that we are streaming to a particular host.
+     **/     
+    public static List<PendingFile> getPendingFiles(InetAddress host)
+    {
+        List<PendingFile> list = new ArrayList<PendingFile>();
+        StreamOutManager manager = streamManagers.get(host);
+        if (manager != null)
+            list.addAll(manager.getFiles());
+        return list;
+    }
 
     // we need sequential and random access to the files. hence, the map and the list.
     private final List<PendingFile> files = new ArrayList<PendingFile>();
diff --git a/src/java/org/apache/cassandra/streaming/StreamingService.java b/src/java/org/apache/cassandra/streaming/StreamingService.java
index 609119a550..7a41c97850 100644
--- a/src/java/org/apache/cassandra/streaming/StreamingService.java
+++ b/src/java/org/apache/cassandra/streaming/StreamingService.java
@@ -35,8 +35,6 @@ public class StreamingService implements StreamingServiceMBean
     private static final Logger logger = LoggerFactory.getLogger(StreamingService.class);
     public static final String MBEAN_OBJECT_NAME = "org.apache.cassandra.streaming:type=StreamingService";
     public static final StreamingService instance = new StreamingService();
-    static final String NOTHING = "Nothing is happening";
-    private String status = NOTHING;
 
     private StreamingService()
     {
@@ -50,16 +48,29 @@ public class StreamingService implements StreamingServiceMBean
             throw new RuntimeException(e);
         }
     }
-    
-    public void setStatus(String s)
-    {
-        assert s != null;
-        status = s;
-    }
 
     public String getStatus()
     {
-        return status;
+        StringBuilder sb = new StringBuilder();
+        sb.append("Receiving from:\n");
+        for (InetAddress source : StreamInManager.getSources())
+        {
+            sb.append(String.format(" %s:\n", source.getHostAddress()));
+            for (PendingFile pf : StreamInManager.getIncomingFiles(source))
+            {
+                sb.append(String.format("  %s %d/%d\n", pf.getFilename(), pf.getPtr(), pf.getExpectedBytes()));
+            }
+        }
+        sb.append("Sending to:\n");
+        for (InetAddress dest : StreamOutManager.getDestinations())
+        {
+            sb.append(String.format(" %s:\n", dest.getHostAddress()));
+            for (PendingFile pf : StreamOutManager.getPendingFiles(dest))
+            {
+                sb.append(String.format("  %s %d/%d\n", pf.getFilename(), pf.getPtr(), pf.getExpectedBytes()));
+            }
+        }
+        return sb.toString();
     }
 
     /** hosts receiving outgoing streams. */
