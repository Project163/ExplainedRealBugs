diff --git a/CHANGES.txt b/CHANGES.txt
index c2abba7375..dbfa272012 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 4.0-beta5
+ * Fix timestamp issue in SinglePartitionSliceCommandTest testPartitionDâ€¦eletionRowDeletionTie (CASSANDRA-16443)
  * Promote protocol V5 out of beta (CASSANDRA-14973)
  * Fix incorrect encoding for strings can be UTF8 (CASSANDRA-16429)
  * Fix node unable to join when RF > N in multi-DC with added warning (CASSANDRA-16296)
diff --git a/src/java/org/apache/cassandra/cql3/QueryProcessor.java b/src/java/org/apache/cassandra/cql3/QueryProcessor.java
index c92718daeb..87829ab358 100644
--- a/src/java/org/apache/cassandra/cql3/QueryProcessor.java
+++ b/src/java/org/apache/cassandra/cql3/QueryProcessor.java
@@ -368,9 +368,25 @@ public class QueryProcessor implements QueryHandler
      */
     public static UntypedResultSet executeOnceInternal(String query, Object... values)
     {
-        CQLStatement statement = parseStatement(query, internalQueryState().getClientState());
-        statement.validate(internalQueryState().getClientState());
-        ResultMessage result = statement.executeLocally(internalQueryState(), makeInternalOptions(statement, values));
+        return executeOnceInternal(internalQueryState(), query, values);
+    }
+
+    /**
+     * Execute an internal query with the provided {@code nowInSec} and {@code timestamp} for the {@code QueryState}.
+     * <p>This method ensure that the statement will not be cached in the prepared statement cache.</p>
+     */
+    @VisibleForTesting
+    public static UntypedResultSet executeOnceInternalWithNowAndTimestamp(int nowInSec, long timestamp, String query, Object... values)
+    {
+        QueryState queryState = new QueryState(InternalStateInstance.INSTANCE.clientState, timestamp, nowInSec);
+        return executeOnceInternal(queryState, query, values);
+    }
+
+    private static UntypedResultSet executeOnceInternal(QueryState queryState, String query, Object... values)
+    {
+        CQLStatement statement = parseStatement(query, queryState.getClientState());
+        statement.validate(queryState.getClientState());
+        ResultMessage result = statement.executeLocally(queryState, makeInternalOptions(statement, values));
         if (result instanceof ResultMessage.Rows)
             return UntypedResultSet.create(((ResultMessage.Rows)result).result);
         else
diff --git a/test/unit/org/apache/cassandra/db/SinglePartitionSliceCommandTest.java b/test/unit/org/apache/cassandra/db/SinglePartitionSliceCommandTest.java
index 12168ec9bb..102eb9037c 100644
--- a/test/unit/org/apache/cassandra/db/SinglePartitionSliceCommandTest.java
+++ b/test/unit/org/apache/cassandra/db/SinglePartitionSliceCommandTest.java
@@ -343,10 +343,18 @@ public class SinglePartitionSliceCommandTest
         BiFunction<Boolean, Boolean, List<Unfiltered>> tester = (flush, multiSSTable)->
         {
             cfs.truncateBlocking();
-            QueryProcessor.executeOnceInternal("DELETE FROM ks.partition_row_deletion USING TIMESTAMP 10 WHERE k=1");
+
+            final long timestamp = FBUtilities.timestampMicros();
+            final int nowInSec = FBUtilities.nowInSeconds();
+
+            QueryProcessor.executeOnceInternalWithNowAndTimestamp(nowInSec,
+                                                                  timestamp,
+                                                                  "DELETE FROM ks.partition_row_deletion USING TIMESTAMP 10 WHERE k=1");
             if (flush && multiSSTable)
                 cfs.forceBlockingFlush();
-            QueryProcessor.executeOnceInternal("DELETE FROM ks.partition_row_deletion USING TIMESTAMP 10 WHERE k=1 and c=1");
+            QueryProcessor.executeOnceInternalWithNowAndTimestamp(nowInSec,
+                                                                  timestamp,
+                                                                  "DELETE FROM ks.partition_row_deletion USING TIMESTAMP 10 WHERE k=1 and c=1");
             if (flush)
                 cfs.forceBlockingFlush();
 
