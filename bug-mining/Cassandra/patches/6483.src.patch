diff --git a/CHANGES.txt b/CHANGES.txt
index 45500b642e..8af3d01ac9 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 5.0-beta2
+ * Avoid reading of the same IndexInfo from disk many times for a large partition (CASSANDRA-19557)
  * Resolve the oldest hints just from descriptors and current writer if available (CASSANDRA-19600)
  * Optionally fail writes when SAI refuses to index a term value exceeding configured term max size (CASSANDRA-19493)
  * Vector search can restrict on clustering keys when filtering isn't required (CASSANDRA-19544)
diff --git a/src/java/org/apache/cassandra/io/sstable/format/big/IndexState.java b/src/java/org/apache/cassandra/io/sstable/format/big/IndexState.java
index f738f8ab7c..754b34b065 100644
--- a/src/java/org/apache/cassandra/io/sstable/format/big/IndexState.java
+++ b/src/java/org/apache/cassandra/io/sstable/format/big/IndexState.java
@@ -41,6 +41,9 @@ public class IndexState implements AutoCloseable
 
     private int currentIndexIdx;
 
+    private int cachedIndexIdx = Integer.MIN_VALUE;
+    private IndexInfo cachedIndexInfo;
+
     // Marks the beginning of the block corresponding to currentIndexIdx.
     private DataPosition mark;
 
@@ -139,7 +142,15 @@ public class IndexState implements AutoCloseable
 
     public IndexInfo index(int i) throws IOException
     {
-        return indexInfoRetriever.columnsIndex(i);
+        // during an iteration we retrieve the same IndexInfo many times sequentially, for each row
+        // caching of the last retreived IndexInfo can save a lot of IO in case of ShallowIndexedEntry
+        if (i == cachedIndexIdx)
+        {
+            return cachedIndexInfo;
+        }
+        cachedIndexInfo = indexInfoRetriever.columnsIndex(i);
+        cachedIndexIdx = i;
+        return cachedIndexInfo;
     }
 
     // Finds the index of the first block containing the provided bound, starting at the provided index.
