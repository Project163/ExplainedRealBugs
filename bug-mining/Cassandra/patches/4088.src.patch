diff --git a/CHANGES.txt b/CHANGES.txt
index 47d2dc1b2d..dcbce5bc05 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 3.0.3
+ * Fix deserialization of legacy read commands (CASSANDRA-11087)
  * Fix incorrect computation of deletion time in sstable metadata (CASSANDRA-11102)
  * Avoid memory leak when collecting sstable metadata (CASSANDRA-11026)
  * Mutations do not block for completion under view lock contention (CASSANDRA-10779)
diff --git a/src/java/org/apache/cassandra/db/ReadCommand.java b/src/java/org/apache/cassandra/db/ReadCommand.java
index f21d1007d5..97c3d070b1 100644
--- a/src/java/org/apache/cassandra/db/ReadCommand.java
+++ b/src/java/org/apache/cassandra/db/ReadCommand.java
@@ -1308,8 +1308,23 @@ public abstract class ReadCommand implements ReadQuery
                                     "Fill name in filter (hex): " + ByteBufferUtil.bytesToHex(buffer), metadata.cfId);
                 }
 
-                if (!cellName.clustering.equals(Clustering.STATIC_CLUSTERING))
+                // If we're querying for a static column, we may also need to read it
+                // as if it were a thrift dynamic column (because the column metadata,
+                // which makes it a static column in 3.0+, may have been added *after*
+                // some values were written). Note that all cql queries on non-compact
+                // tables used slice & not name filters prior to 3.0 so this path is
+                // not taken for non-compact tables. It is theoretically possible to
+                // get here via thrift, hence the check on metadata.isStaticCompactTable.
+                // See CASSANDRA-11087.
+                if (metadata.isStaticCompactTable() && cellName.clustering.equals(Clustering.STATIC_CLUSTERING))
+                {
+                    clusterings.add(new Clustering(cellName.column.name.bytes));
+                    selectionBuilder.add(metadata.compactValueColumn());
+                }
+                else
+                {
                     clusterings.add(cellName.clustering);
+                }
 
                 selectionBuilder.add(cellName.column);
             }
