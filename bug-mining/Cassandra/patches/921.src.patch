diff --git a/CHANGES.txt b/CHANGES.txt
index e2dcb65fe1..c753213bf5 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -21,7 +21,8 @@
  * avoid attempting to replay mutations from dropped keyspaces (CASSANDRA-2631)
  * avoid using cached position of a key when GT is requested (CASSANDRA-2633)
  * fix counting bloom filter true positives (CASSANDRA-2637)
-
+ * initialize local ep state prior to gossip startup if needed (CASSANDRA-2638)
+  
 
 0.7.5
  * improvements/fixes to PIG driver (CASSANDRA-1618, CASSANDRA-2387,
diff --git a/src/java/org/apache/cassandra/gms/Gossiper.java b/src/java/org/apache/cassandra/gms/Gossiper.java
index de9201e2a9..057b560564 100644
--- a/src/java/org/apache/cassandra/gms/Gossiper.java
+++ b/src/java/org/apache/cassandra/gms/Gossiper.java
@@ -898,15 +898,8 @@ public class Gossiper implements IFailureDetectionEventListener
         }
 
         /* initialize the heartbeat state for this localEndpoint */
+        maybeInitializeLocalState(generationNbr);
         EndpointState localState = endpointStateMap_.get(localEndpoint_);
-        if ( localState == null )
-        {
-            HeartBeatState hbState = new HeartBeatState(generationNbr);
-            localState = new EndpointState(hbState);
-            localState.isAlive(true);
-            localState.isAGossiper(true);
-            endpointStateMap_.put(localEndpoint_, localState);
-        }
 
         //notify snitches that Gossiper is about to start
         DatabaseDescriptor.getEndpointSnitch().gossiperStarting();
@@ -916,6 +909,21 @@ public class Gossiper implements IFailureDetectionEventListener
                                                               Gossiper.intervalInMillis_,
                                                               TimeUnit.MILLISECONDS);
     }
+    
+    // initialize local HB state if needed.
+    public void maybeInitializeLocalState(int generationNbr) 
+    {
+        EndpointState localState = endpointStateMap_.get(FBUtilities.getLocalAddress());
+        if ( localState == null )
+        {
+            HeartBeatState hbState = new HeartBeatState(generationNbr);
+            localState = new EndpointState(hbState);
+            localState.isAlive(true);
+            localState.isAGossiper(true);
+            endpointStateMap_.put(localEndpoint_, localState);
+        }
+    }
+    
 
     /**
      * Add an endpoint we knew about previously, but whose state is unknown
diff --git a/src/java/org/apache/cassandra/service/AbstractCassandraDaemon.java b/src/java/org/apache/cassandra/service/AbstractCassandraDaemon.java
index e36b70ba90..84f600ae87 100644
--- a/src/java/org/apache/cassandra/service/AbstractCassandraDaemon.java
+++ b/src/java/org/apache/cassandra/service/AbstractCassandraDaemon.java
@@ -29,6 +29,7 @@ import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 
+import org.apache.cassandra.gms.Gossiper;
 import org.apache.log4j.PropertyConfigurator;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -181,6 +182,7 @@ public abstract class AbstractCassandraDaemon implements CassandraDaemon
         UUID lastMigration = Migration.getLastMigrationId();
         if ((lastMigration != null) && (lastMigration.timestamp() > currentMigration.timestamp()))
         {
+            Gossiper.instance.maybeInitializeLocalState(SystemTable.incrementAndGetGeneration());
             MigrationManager.applyMigrations(currentMigration, lastMigration);
         }
         
