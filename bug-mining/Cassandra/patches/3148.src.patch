diff --git a/CHANGES.txt b/CHANGES.txt
index 5902d753db..6f59a29188 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,3 +1,7 @@
+2.0.12:
+ * Archive any commitlog segments present at startup (CASSANDRA-6904)
+
+
 2.0.11:
  * Ignore fat clients when checking for endpoint collision (CASSANDRA-7939)
  * CrcCheckChance should adjust based on live CFMetadata not 
diff --git a/src/java/org/apache/cassandra/db/commitlog/CommitLog.java b/src/java/org/apache/cassandra/db/commitlog/CommitLog.java
index 4bab83f78a..0e2f5bf4e6 100644
--- a/src/java/org/apache/cassandra/db/commitlog/CommitLog.java
+++ b/src/java/org/apache/cassandra/db/commitlog/CommitLog.java
@@ -106,9 +106,7 @@ public class CommitLog implements CommitLogMBean
      */
     public int recover() throws IOException
     {
-        archiver.maybeRestoreArchive();
-
-        File[] files = new File(DatabaseDescriptor.getCommitLogLocation()).listFiles(new FilenameFilter()
+        FilenameFilter unmanagedFilesFilter = new FilenameFilter()
         {
             public boolean accept(File dir, String name)
             {
@@ -117,8 +115,19 @@ public class CommitLog implements CommitLogMBean
                 // ahead and allow writes before recover(), and just skip active segments when we do.
                 return CommitLogDescriptor.isValid(name) && !instance.allocator.manages(name);
             }
-        });
+        };
+
+        // submit all existing files in the commit log dir for archiving prior to recovery - CASSANDRA-6904
+        for (File file : new File(DatabaseDescriptor.getCommitLogLocation()).listFiles(unmanagedFilesFilter))
+        {
+            archiver.maybeArchive(file.getPath(), file.getName());
+            archiver.maybeWaitForArchiving(file.getName());
+        }
+
+        assert archiver.archivePending.isEmpty() : "Not all commit log archive tasks were completed before restore";
+        archiver.maybeRestoreArchive();
 
+        File[] files = new File(DatabaseDescriptor.getCommitLogLocation()).listFiles(unmanagedFilesFilter);
         int replayed = 0;
         if (files.length == 0)
         {
