diff --git a/CHANGES.txt b/CHANGES.txt
index 84ef845964..74e70e12e8 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 3.0.15
+ * Fix short read protection for tables with no clustering columns (CASSANDRA-13880)
  * Make isBuilt volatile in PartitionUpdate (CASSANDRA-13619)
  * Prevent integer overflow of timestamps in CellTest and RowsTest (CASSANDRA-13866)
  * Fix counter application order in short read protection (CASSANDRA-12872)
diff --git a/src/java/org/apache/cassandra/service/DataResolver.java b/src/java/org/apache/cassandra/service/DataResolver.java
index 580fd8bd82..99399a31e6 100644
--- a/src/java/org/apache/cassandra/service/DataResolver.java
+++ b/src/java/org/apache/cassandra/service/DataResolver.java
@@ -510,6 +510,8 @@ public class DataResolver extends ResponseResolver
             @Override
             public UnfilteredRowIterator moreContents()
             {
+                assert !postReconciliationCounter.isDoneForPartition();
+
                 // We have a short read if the node this is the result of has returned the requested number of
                 // rows for that partition (i.e. it has stopped returning results due to the limit), but some of
                 // those results haven't made it in the final result post-reconciliation due to other nodes
@@ -522,9 +524,13 @@ public class DataResolver extends ResponseResolver
                 // skipped during reconciliation.
                 if (lastCount == counter.counted() || !counter.isDoneForPartition())
                     return null;
-                lastCount = counter.counted();
 
-                assert !postReconciliationCounter.isDoneForPartition();
+                // clustering of the last row returned is empty, meaning that there is only one row per partition,
+                // and we already have it.
+                if (lastClustering == Clustering.EMPTY)
+                    return null;
+
+                lastCount = counter.counted();
 
                 // We need to try to query enough additional results to fulfill our query, but because we could still
                 // get short reads on that additional query, just querying the number of results we miss may not be
