diff --git a/CHANGES.txt b/CHANGES.txt
index 80b1532510..e16f3e5cb1 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 3.11.10
+ * SASI's `max_compaction_flush_memory_in_mb` settings over 100GB revert to default of 1GB (CASSANDRA-16071)
 Merged from 3.0:
  * Improved check of num_tokens against the length of initial_token (CASSANDRA-14477)
  * Fix a race condition on ColumnFamilyStore and TableMetrics (CASSANDRA-16228)
diff --git a/NEWS.txt b/NEWS.txt
index 99d589d1b9..3af2150da9 100644
--- a/NEWS.txt
+++ b/NEWS.txt
@@ -49,6 +49,11 @@ Upgrading
     - In cassandra.yaml, when using vnodes num_tokens must be defined if initial_token is defined.
       If it is not defined, or not equal to the numbers of tokens defined in initial_tokens,
       the node will not start. See CASSANDRA-14477 for details.
+    - SASI's `max_compaction_flush_memory_in_mb` setting was previously getting interpreted in bytes. From 3.11.8
+      it is correctly interpreted in megabytes, but prior to 3.11.10 previous configurations of this setting will
+      lead to nodes OOM during compaction. From 3.11.10 previous configurations will be detected as incorrect,
+      logged, and the setting reverted to the default value of 1GB. It is up to the user to correct the setting
+      after an upgrade, via dropping and recreating the index. See CASSANDRA-16071 for details.
 
 3.11.9
 ======
@@ -66,6 +71,7 @@ Upgrading
     - Nothing specific to this release, but please see previous upgrading sections,
       especially if you are upgrading from 3.0.
 
+
 3.11.6
 ======
 
diff --git a/src/java/org/apache/cassandra/index/sasi/conf/IndexMode.java b/src/java/org/apache/cassandra/index/sasi/conf/IndexMode.java
index 8d76bb0f65..60a19a65d0 100644
--- a/src/java/org/apache/cassandra/index/sasi/conf/IndexMode.java
+++ b/src/java/org/apache/cassandra/index/sasi/conf/IndexMode.java
@@ -56,6 +56,7 @@ public class IndexMode
     private static final String INDEX_IS_LITERAL_OPTION = "is_literal";
     private static final String INDEX_MAX_FLUSH_MEMORY_OPTION = "max_compaction_flush_memory_in_mb";
     private static final double INDEX_MAX_FLUSH_DEFAULT_MULTIPLIER = 0.15;
+    private static final long DEFAULT_MAX_MEM_BYTES = (long) (1073741824 * INDEX_MAX_FLUSH_DEFAULT_MULTIPLIER); // 1G default for memtable
 
     public final Mode mode;
     public final boolean isAnalyzed, isLiteral;
@@ -187,9 +188,14 @@ public class IndexMode
         }
 
         long maxMemBytes = indexOptions.get(INDEX_MAX_FLUSH_MEMORY_OPTION) == null
-                ? (long) (1073741824 * INDEX_MAX_FLUSH_DEFAULT_MULTIPLIER) // 1G default for memtable
+                ? DEFAULT_MAX_MEM_BYTES
                 : 1048576L * Long.parseLong(indexOptions.get(INDEX_MAX_FLUSH_MEMORY_OPTION));
 
+        if (maxMemBytes > 100L * 1073741824)
+        {
+            logger.error("{} configured as {} is above 100GB, reverting to default 1GB", INDEX_MAX_FLUSH_MEMORY_OPTION, maxMemBytes);
+            maxMemBytes = DEFAULT_MAX_MEM_BYTES;
+        }
         return new IndexMode(mode, isLiteral, isAnalyzed, analyzerClass, maxMemBytes);
     }
 
