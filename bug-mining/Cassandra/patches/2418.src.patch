diff --git a/CHANGES.txt b/CHANGES.txt
index 48fcf589ea..046ecfbcd1 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -25,6 +25,7 @@
  * Fix indexed queries with row cache enabled on parent table (CASSANDRA-5732)
  * Fix compaction race during columnfamily drop (CASSANDRA-5957)
  * Fix validation of empty column names for compact tables (CASSANDRA-6152)
+ * Skip replaying mutations that pass CRC but fail to deserialize (CASSANDRA-6183)
 
 
 1.2.10
diff --git a/src/java/org/apache/cassandra/db/commitlog/CommitLogReplayer.java b/src/java/org/apache/cassandra/db/commitlog/CommitLogReplayer.java
index 796ab5b53e..934cb6ab3d 100644
--- a/src/java/org/apache/cassandra/db/commitlog/CommitLogReplayer.java
+++ b/src/java/org/apache/cassandra/db/commitlog/CommitLogReplayer.java
@@ -18,10 +18,7 @@
  */
 package org.apache.cassandra.db.commitlog;
 
-import java.io.DataInputStream;
-import java.io.EOFException;
-import java.io.File;
-import java.io.IOException;
+import java.io.*;
 import java.util.*;
 import java.util.concurrent.Future;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -200,6 +197,10 @@ public class CommitLogReplayer
                     // assuming version here. We've gone to lengths to make sure what gets written to the CL is in
                     // the current version. so do make sure the CL is drained prior to upgrading a node.
                     rm = RowMutation.serializer.deserialize(new DataInputStream(bufIn), version, IColumnSerializer.Flag.LOCAL);
+                    // doublecheck that what we read is [still] valid for the current schema
+                    for (ColumnFamily cf : rm.getColumnFamilies())
+                        for (IColumn cell : cf)
+                            cf.getComparator().validate(cell.name());
                 }
                 catch (UnknownColumnFamilyException ex)
                 {
@@ -215,6 +216,23 @@ public class CommitLogReplayer
                         i.incrementAndGet();
                     continue;
                 }
+                catch (Throwable t)
+                {
+                    File f = File.createTempFile("mutation", "dat");
+                    DataOutputStream out = new DataOutputStream(new FileOutputStream(f));
+                    try
+                    {
+                        out.write(buffer, 0, serializedSize);
+                    }
+                    finally
+                    {
+                        out.close();
+                    }
+                    String st = String.format("Unexpected error deserializing mutation; saved to %s and ignored.  This may be caused by replaying a mutation against a table with the same name but incompatible schema.  Exception follows: ",
+                                              f.getAbsolutePath());
+                    logger.error(st, t);
+                    continue;
+                }
 
                 if (logger.isDebugEnabled())
                     logger.debug(String.format("replaying mutation for %s.%s: %s", rm.getTable(), ByteBufferUtil.bytesToHex(rm.key()), "{" + StringUtils.join(rm.getColumnFamilies().iterator(), ", ")
