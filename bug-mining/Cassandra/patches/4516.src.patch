diff --git a/CHANGES.txt b/CHANGES.txt
index e922635514..792d6f887d 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 2.1.17
+ * Fix RecoveryManagerTruncateTest (CASSANDRA-12802)
  * Don't skip sstables based on maxLocalDeletionTime (CASSANDRA-12765)
 
 
diff --git a/src/java/org/apache/cassandra/db/commitlog/CommitLog.java b/src/java/org/apache/cassandra/db/commitlog/CommitLog.java
index 502e7048b0..2484e9bafb 100644
--- a/src/java/org/apache/cassandra/db/commitlog/CommitLog.java
+++ b/src/java/org/apache/cassandra/db/commitlog/CommitLog.java
@@ -35,6 +35,7 @@ import org.apache.cassandra.config.Config;
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.db.*;
 import org.apache.cassandra.io.FSWriteError;
+import org.apache.cassandra.io.sstable.SSTableDeletingTask;
 import org.apache.cassandra.io.util.DataOutputByteBuffer;
 import org.apache.cassandra.metrics.CommitLogMetrics;
 import org.apache.cassandra.net.MessagingService;
@@ -101,7 +102,7 @@ public class CommitLog implements CommitLogMBean
                 // we used to try to avoid instantiating commitlog (thus creating an empty segment ready for writes)
                 // until after recover was finished.  this turns out to be fragile; it is less error-prone to go
                 // ahead and allow writes before recover(), and just skip active segments when we do.
-                return CommitLogDescriptor.isValid(name) && !instance.allocator.manages(name);
+                return CommitLogDescriptor.isValid(name) && CommitLogSegment.shouldReplay(name);
             }
         };
 
@@ -367,11 +368,21 @@ public class CommitLog implements CommitLogMBean
 
     /**
      * FOR TESTING PURPOSES. See CommitLogAllocator.
+     *
+     * There is a race at the moment, even if this method
+     * is synchronized we can still create an allocation
+     * on a segment that will be closed in this method,
+     * therefore causing {@link Allocation#awaitDiskSync()} to hang
+     * forever. This typically happens because of the mutations created
+     * by {@link org.apache.cassandra.io.sstable.SSTableReader.GlobalTidy},
+     * that's why we wait for all deletions to complete firtst.
      */
-    public void resetUnsafe()
+    public synchronized void resetUnsafe()
     {
+        SSTableDeletingTask.waitForDeletions();
         sync(true);
         allocator.resetUnsafe();
+        CommitLogSegment.resetReplayLimit();
     }
 
     /**
diff --git a/src/java/org/apache/cassandra/db/commitlog/CommitLogSegment.java b/src/java/org/apache/cassandra/db/commitlog/CommitLogSegment.java
index 2ea8701b97..1093f876d8 100644
--- a/src/java/org/apache/cassandra/db/commitlog/CommitLogSegment.java
+++ b/src/java/org/apache/cassandra/db/commitlog/CommitLogSegment.java
@@ -61,6 +61,7 @@ public class CommitLogSegment
 
     private final static long idBase;
     private final static AtomicInteger nextId = new AtomicInteger(1);
+    private static long replayLimitId;
     static
     {
         long maxId = Long.MIN_VALUE;
@@ -69,7 +70,7 @@ public class CommitLogSegment
             if (CommitLogDescriptor.isValid(file.getName()))
                 maxId = Math.max(CommitLogDescriptor.fromFileName(file.getName()).id, maxId);
         }
-        idBase = Math.max(System.currentTimeMillis(), maxId + 1);
+        replayLimitId = idBase = Math.max(System.currentTimeMillis(), maxId + 1);
     }
 
     // The commit log entry overhead in bytes (int: length + int: head checksum + int: tail checksum)
@@ -203,6 +204,19 @@ public class CommitLogSegment
         }
     }
 
+    static boolean shouldReplay(String name)
+    {
+        return CommitLogDescriptor.fromFileName(name).id < replayLimitId;
+    }
+
+    /**
+     * FOR TESTING PURPOSES.
+     */
+    static void resetReplayLimit()
+    {
+        replayLimitId = getNextId();
+    }
+
     // allocate bytes in the segment, or return -1 if not enough space
     private int allocate(int size)
     {
