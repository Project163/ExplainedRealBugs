diff --git a/CHANGES.txt b/CHANGES.txt
index 5105707d4b..6bb59f8f58 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 4.1
+ * Incremental repair leaks SomeRepairFailedException after switch away from flatMap (CASSANDRA-17620)
  * StorageService read threshold get methods throw NullPointerException due to not handling null configs (CASSANDRA-17593)
  * Rename truncate_drop guardrail to drop_truncate_table (CASSANDRA-17592)
  * nodetool enablefullquerylog can NPE when directory has no files (CASSANDRA-17595)
diff --git a/src/java/org/apache/cassandra/repair/consistent/CoordinatorSession.java b/src/java/org/apache/cassandra/repair/consistent/CoordinatorSession.java
index 24e24faed1..b66e1e1661 100644
--- a/src/java/org/apache/cassandra/repair/consistent/CoordinatorSession.java
+++ b/src/java/org/apache/cassandra/repair/consistent/CoordinatorSession.java
@@ -47,6 +47,7 @@ import org.apache.cassandra.repair.messages.FinalizePropose;
 import org.apache.cassandra.repair.messages.PrepareConsistentRequest;
 import org.apache.cassandra.repair.messages.RepairMessage;
 import org.apache.cassandra.service.ActiveRepairService;
+import org.apache.cassandra.utils.concurrent.ImmediateFuture;
 
 import static org.apache.cassandra.utils.Clock.Global.currentTimeMillis;
 
@@ -298,15 +299,15 @@ public class CoordinatorSession extends ConsistentSession
         });
 
         // if any session failed, then fail the future
-        Future<CoordinatedRepairResult> onlySuccessSessionResults = repairSessionResults.map(result -> {
+        Future<CoordinatedRepairResult> onlySuccessSessionResults = repairSessionResults.flatMap(result -> {
             finalizeStart = currentTimeMillis();
             if (result.hasFailed())
             {
                 if (logger.isDebugEnabled())
                     logger.debug("Incremental repair {} validation/stream phase completed in {}", sessionID, formatDuration(repairStart, finalizeStart));
-                throw SomeRepairFailedException.INSTANCE;
+                return ImmediateFuture.failure(SomeRepairFailedException.INSTANCE);
             }
-            return result;
+            return ImmediateFuture.success(result);
         });
 
         // mark propose finalization and commit
diff --git a/test/distributed/org/apache/cassandra/distributed/test/RepairErrorsTest.java b/test/distributed/org/apache/cassandra/distributed/test/RepairErrorsTest.java
index e771e2eeac..c3c2b1427d 100644
--- a/test/distributed/org/apache/cassandra/distributed/test/RepairErrorsTest.java
+++ b/test/distributed/org/apache/cassandra/distributed/test/RepairErrorsTest.java
@@ -129,6 +129,10 @@ public class RepairErrorsTest extends TestBaseImpl
             assertEquals(0, parents.intValue());
             Integer sessions = cluster.get(1).callOnInstance(() -> ActiveRepairService.instance.sessionCount());
             assertEquals(0, sessions.intValue());
+
+            cluster.forEach(i -> Assertions.assertThat(i.logs().grep("SomeRepairFailedException").getResult())
+                                           .describedAs("node%d logged hidden exception org.apache.cassandra.repair.SomeRepairFailedException", i.config().num())
+                                           .isEmpty());
         }
     }
 
