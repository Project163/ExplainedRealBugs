diff --git a/CHANGES.txt b/CHANGES.txt
index d76606c272..8473777d8c 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,6 @@
 2.0.15:
+ * Log warning message when a table is queried before the schema has fully
+   propagated (CASSANDRA-9136)
  * Overload SecondaryIndex#indexes to accept the column definition (CASSANDRA-9314)
  * (cqlsh) Add SERIAL and LOCAL_SERIAL consistency levels (CASSANDRA-8051)
  * Fix index selection during rebuild with certain table layouts (CASSANDRA-9281)
diff --git a/src/java/org/apache/cassandra/db/PagedRangeCommand.java b/src/java/org/apache/cassandra/db/PagedRangeCommand.java
index a8d7f496c9..3bc6539bd0 100644
--- a/src/java/org/apache/cassandra/db/PagedRangeCommand.java
+++ b/src/java/org/apache/cassandra/db/PagedRangeCommand.java
@@ -24,6 +24,7 @@ import java.nio.ByteBuffer;
 import java.util.ArrayList;
 import java.util.List;
 
+import org.apache.cassandra.config.Schema;
 import org.apache.cassandra.db.filter.*;
 import org.apache.cassandra.dht.AbstractBounds;
 import org.apache.cassandra.io.IVersionedSerializer;
@@ -153,6 +154,15 @@ public class PagedRangeCommand extends AbstractRangeCommand
         {
             String keyspace = in.readUTF();
             String columnFamily = in.readUTF();
+
+            if (Schema.instance.getCFMetaData(keyspace, columnFamily) == null)
+            {
+                String message = String.format("Got paged range command for nonexistent table %s.%s.  If the table was just " +
+                        "created, this is likely due to the schema not being fully propagated.  Please wait for schema " +
+                        "agreement on table creation." , keyspace, columnFamily);
+                throw new UnknownColumnFamilyException(message, null);
+            }
+
             long timestamp = in.readLong();
 
             AbstractBounds<RowPosition> keyRange = AbstractBounds.serializer.deserialize(in, version).toRowBounds();
diff --git a/src/java/org/apache/cassandra/db/RangeSliceCommand.java b/src/java/org/apache/cassandra/db/RangeSliceCommand.java
index 4aa159548a..553f111221 100644
--- a/src/java/org/apache/cassandra/db/RangeSliceCommand.java
+++ b/src/java/org/apache/cassandra/db/RangeSliceCommand.java
@@ -213,6 +213,13 @@ class RangeSliceCommandSerializer implements IVersionedSerializer<RangeSliceComm
         long timestamp = version < MessagingService.VERSION_20 ? System.currentTimeMillis() : in.readLong();
 
         CFMetaData metadata = Schema.instance.getCFMetaData(keyspace, columnFamily);
+        if (metadata == null)
+        {
+            String message = String.format("Got range slice command for nonexistent table %s.%s.  If the table was just " +
+                    "created, this is likely due to the schema not being fully propagated.  Please wait for schema " +
+                    "agreement on table creation." , keyspace, columnFamily);
+            throw new UnknownColumnFamilyException(message, null);
+        }
 
         IDiskAtomFilter predicate;
         if (version < MessagingService.VERSION_20)
diff --git a/src/java/org/apache/cassandra/db/SliceByNamesReadCommand.java b/src/java/org/apache/cassandra/db/SliceByNamesReadCommand.java
index ae3db78588..ec7c439fa8 100644
--- a/src/java/org/apache/cassandra/db/SliceByNamesReadCommand.java
+++ b/src/java/org/apache/cassandra/db/SliceByNamesReadCommand.java
@@ -120,6 +120,14 @@ class SliceByNamesReadCommandSerializer implements IVersionedSerializer<ReadComm
         long timestamp = version < MessagingService.VERSION_20 ? System.currentTimeMillis() : in.readLong();
 
         CFMetaData metadata = Schema.instance.getCFMetaData(keyspaceName, cfName);
+        if (metadata == null)
+        {
+            String message = String.format("Got slice command for nonexistent table %s.%s.  If the table was just " +
+                    "created, this is likely due to the schema not being fully propagated.  Please wait for schema " +
+                    "agreement on table creation." , keyspaceName, cfName);
+            throw new UnknownColumnFamilyException(message, null);
+        }
+
         ReadCommand command;
         if (version < MessagingService.VERSION_20)
         {
diff --git a/src/java/org/apache/cassandra/db/SliceFromReadCommand.java b/src/java/org/apache/cassandra/db/SliceFromReadCommand.java
index 7526796720..afca338a7e 100644
--- a/src/java/org/apache/cassandra/db/SliceFromReadCommand.java
+++ b/src/java/org/apache/cassandra/db/SliceFromReadCommand.java
@@ -181,6 +181,14 @@ class SliceFromReadCommandSerializer implements IVersionedSerializer<ReadCommand
         long timestamp = version < MessagingService.VERSION_20 ? System.currentTimeMillis() : in.readLong();
 
         CFMetaData metadata = Schema.instance.getCFMetaData(keyspaceName, cfName);
+        if (metadata == null)
+        {
+            String message = String.format("Got slice command for nonexistent table %s.%s.  If the table was just " +
+                    "created, this is likely due to the schema not being fully propagated.  Please wait for schema " +
+                    "agreement on table creation." , keyspaceName, cfName);
+            throw new UnknownColumnFamilyException(message, null);
+        }
+
         SliceQueryFilter filter;
         if (version < MessagingService.VERSION_20)
         {
