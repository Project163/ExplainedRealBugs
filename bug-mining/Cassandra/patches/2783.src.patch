diff --git a/CHANGES.txt b/CHANGES.txt
index 827003b65f..0a43f10c4c 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -11,6 +11,7 @@
  * Fix CFMetaData#getColumnDefinitionFromColumnName() (CASSANDRA-7074)
  * Plug holes in resource release when wiring up StreamSession (CASSANDRA-7073)
  * Re-add parameter columns to tracing session (CASSANDRA-6942)
+ * Fix writetime/ttl functions for static columns (CASSANDRA-7081)
 Merged from 1.2:
  * Fix nodetool display with vnodes (CASSANDRA-7082)
  * Fix schema concurrency exceptions (CASSANDRA-6841)
diff --git a/src/java/org/apache/cassandra/cql3/statements/ColumnGroupMap.java b/src/java/org/apache/cassandra/cql3/statements/ColumnGroupMap.java
index 1c9a346910..077a034842 100644
--- a/src/java/org/apache/cassandra/cql3/statements/ColumnGroupMap.java
+++ b/src/java/org/apache/cassandra/cql3/statements/ColumnGroupMap.java
@@ -31,6 +31,8 @@ import org.apache.cassandra.utils.Pair;
 
 public class ColumnGroupMap
 {
+    public static ColumnGroupMap EMPTY = new ColumnGroupMap(null, false);
+
     private final ByteBuffer[] fullPath;
     private final Map<ByteBuffer, Value> map = new HashMap<ByteBuffer, Value>();
     public final boolean isStatic; // Whether or not the group correspond to "static" cells
@@ -66,7 +68,7 @@ public class ColumnGroupMap
 
     public ByteBuffer getKeyComponent(int pos)
     {
-        return fullPath[pos];
+        return fullPath == null ? null : fullPath[pos];
     }
 
     public Column getSimple(ByteBuffer key)
@@ -89,6 +91,11 @@ public class ColumnGroupMap
         return (List<Pair<ByteBuffer, Column>>)v;
     }
 
+    public boolean hasValueFor(ByteBuffer key)
+    {
+        return map.containsKey(key);
+    }
+
     private interface Value {};
 
     private static class Simple implements Value
diff --git a/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java b/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
index 60ed763e74..68adbbd286 100644
--- a/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
+++ b/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
@@ -1058,35 +1058,25 @@ public class SelectStatement implements CQLStatement, MeasurableForPreparedCache
                 builder.add(c);
             }
 
-            Map<CFDefinition.Name, ByteBuffer> staticValues = Collections.emptyMap();
+            ColumnGroupMap staticGroup = null;
             // Gather up static values first
             if (!builder.isEmpty() && builder.firstGroup().isStatic)
             {
-                staticValues = new HashMap<>();
-                ColumnGroupMap group = builder.firstGroup();
-                for (CFDefinition.Name name : Iterables.filter(selection.getColumnsList(), isStaticFilter))
-                    staticValues.put(name, getValue(name, group));
+                staticGroup = builder.firstGroup();
                 builder.discardFirst();
 
                 // If there was static columns but there is no actual row, then provided the select was a full
                 // partition selection (i.e. not a 2ndary index search and there was no condition on clustering columns)
                 // then we want to include the static columns in the result set.
-                if (!staticValues.isEmpty() && builder.isEmpty() && !usesSecondaryIndexing && hasNoClusteringColumnsRestriction())
+                if (builder.isEmpty() && !usesSecondaryIndexing && hasNoClusteringColumnsRestriction() && hasValueForQuery(staticGroup))
                 {
-                    result.newRow();
-                    for (CFDefinition.Name name : selection.getColumnsList())
-                    {
-                        if (name.kind == CFDefinition.Name.Kind.KEY_ALIAS)
-                            result.add(keyComponents[name.position]);
-                        else
-                            result.add(name.kind == CFDefinition.Name.Kind.STATIC ? staticValues.get(name) : null);
-                    }
+                    handleGroup(result, keyComponents, ColumnGroupMap.EMPTY, staticGroup);
                     return;
                 }
             }
 
             for (ColumnGroupMap group : builder.groups())
-                handleGroup(selection, result, keyComponents, group, staticValues);
+                handleGroup(result, keyComponents, group, staticGroup);
         }
         else
         {
@@ -1105,6 +1095,14 @@ public class SelectStatement implements CQLStatement, MeasurableForPreparedCache
         }
     }
 
+    private boolean hasValueForQuery(ColumnGroupMap staticGroup)
+    {
+        for (CFDefinition.Name name : Iterables.filter(selection.getColumnsList(), isStaticFilter))
+            if (staticGroup.hasValueFor(name.name.key))
+                return true;
+        return false;
+    }
+
     private boolean hasNoClusteringColumnsRestriction()
     {
         for (int i = 0; i < columnRestrictions.length; i++)
@@ -1155,11 +1153,10 @@ public class SelectStatement implements CQLStatement, MeasurableForPreparedCache
         Collections.sort(cqlRows.rows, new CompositeComparator(types, positions));
     }
 
-    private void handleGroup(Selection selection,
-                             Selection.ResultSetBuilder result,
+    private void handleGroup(Selection.ResultSetBuilder result,
                              ByteBuffer[] keyComponents,
                              ColumnGroupMap columns,
-                             Map<CFDefinition.Name, ByteBuffer> staticValues) throws InvalidRequestException
+                             ColumnGroupMap staticGroup) throws InvalidRequestException
     {
         // Respect requested order
         result.newRow();
@@ -1177,48 +1174,32 @@ public class SelectStatement implements CQLStatement, MeasurableForPreparedCache
                     // This should not happen for SPARSE
                     throw new AssertionError();
                 case COLUMN_METADATA:
-                    if (name.type.isCollection())
-                    {
-                        result.add(getCollectionValue(name, columns));
-                    }
-                    else
-                    {
-                        result.add(columns.getSimple(name.name.key));
-                    }
+                    addValue(result, name, columns);
                     break;
                 case STATIC:
-                    result.add(staticValues.get(name));
+                    addValue(result, name, staticGroup);
                     break;
             }
         }
     }
 
-    private static ByteBuffer getValue(CFDefinition.Name name, ColumnGroupMap columns)
+    private static void addValue(Selection.ResultSetBuilder result, CFDefinition.Name name, ColumnGroupMap group)
     {
-        if (name.type.isCollection())
-            return getCollectionValue(name, columns);
-        else if (name.type.isCommutative())
-            return getCounterValue(name, columns);
-
-        return getSimpleValue(name, columns);
-    }
-
-    private static ByteBuffer getCollectionValue(CFDefinition.Name name, ColumnGroupMap columns)
-    {
-        List<Pair<ByteBuffer, Column>> collection = columns.getCollection(name.name.key);
-        return collection == null ? null : ((CollectionType)name.type).serialize(collection);
-    }
-
-    private static ByteBuffer getSimpleValue(CFDefinition.Name name, ColumnGroupMap columns)
-    {
-        Column c = columns.getSimple(name.name.key);
-        return c == null ? null : c.value();
-    }
+        if (group == null)
+        {
+            result.add((ByteBuffer)null);
+            return;
+        }
 
-    private static ByteBuffer getCounterValue(CFDefinition.Name name, ColumnGroupMap columns)
-    {
-        Column c = columns.getSimple(name.name.key);
-        return c == null ? null : CounterColumnType.instance.decompose(CounterContext.instance().total(c.value()));
+        if (name.type.isCollection())
+        {
+            List<Pair<ByteBuffer, Column>> collection = group.getCollection(name.name.key);
+            result.add(collection == null ? null : ((CollectionType)name.type).serialize(collection));
+        }
+        else
+        {
+            result.add(group.getSimple(name.name.key));
+        }
     }
 
     private static boolean isReversedType(CFDefinition.Name name)
