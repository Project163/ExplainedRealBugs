diff --git a/CHANGES.txt b/CHANGES.txt
index 31c5213fad..084aa07679 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,3 +1,6 @@
+4.0.10
+ * Fix nested selection of reversed collections (CASSANDRA-17913)
+
 4.0.9
  * Update zstd-jni library to version 1.5.5 (CASSANDRA-18429)
  * Backport CASSANDRA-17205 to 4.0 branch - Remove self-reference in SSTableTidier (CASSANDRA-18332)
diff --git a/src/java/org/apache/cassandra/cql3/selection/ElementsSelector.java b/src/java/org/apache/cassandra/cql3/selection/ElementsSelector.java
index 9427c51d59..5eace66fbe 100644
--- a/src/java/org/apache/cassandra/cql3/selection/ElementsSelector.java
+++ b/src/java/org/apache/cassandra/cql3/selection/ElementsSelector.java
@@ -60,6 +60,17 @@ abstract class ElementsSelector extends Selector
         return type instanceof MapType ? type.valueComparator() : type.nameComparator();
     }
 
+    private static CollectionType<?> getCollectionType(Selector selected)
+    {
+        AbstractType<?> type = selected.getType();
+        if (type instanceof ReversedType)
+            type = ((ReversedType<?>) type).baseType;
+
+        assert type instanceof MapType || type instanceof SetType : "this shouldn't have passed validation in Selectable";
+
+        return (CollectionType<?>) type;
+    }
+
     private static abstract class AbstractFactory extends Factory
     {
         protected final String name;
@@ -236,8 +247,7 @@ abstract class ElementsSelector extends Selector
         private ElementSelector(Selector selected, ByteBuffer key)
         {
             super(selected);
-            assert selected.getType() instanceof MapType || selected.getType() instanceof SetType : "this shouldn't have passed validation in Selectable";
-            this.type = (CollectionType<?>) selected.getType();
+            this.type = getCollectionType(selected);
             this.key = key;
         }
 
@@ -282,9 +292,8 @@ abstract class ElementsSelector extends Selector
         private SliceSelector(Selector selected, ByteBuffer from, ByteBuffer to)
         {
             super(selected);
-            assert selected.getType() instanceof MapType || selected.getType() instanceof SetType : "this shouldn't have passed validation in Selectable";
             assert from != null && to != null : "We can have unset buffers, but not nulls";
-            this.type = (CollectionType<?>) selected.getType();
+            this.type = getCollectionType(selected);
             this.from = from;
             this.to = to;
         }
diff --git a/src/java/org/apache/cassandra/cql3/selection/Selectable.java b/src/java/org/apache/cassandra/cql3/selection/Selectable.java
index 102e2f9892..6e653ba1b9 100644
--- a/src/java/org/apache/cassandra/cql3/selection/Selectable.java
+++ b/src/java/org/apache/cassandra/cql3/selection/Selectable.java
@@ -103,9 +103,9 @@ public interface Selectable extends AssignmentTestable
         return idx;
     }
 
-    default ColumnSpecification specForElementOrSlice(Selectable selected, ColumnSpecification receiver, String selectionType)
+    default ColumnSpecification specForElementOrSlice(Selectable selected, ColumnSpecification receiver, CollectionType.Kind kind, String selectionType)
     {
-        switch (((CollectionType)receiver.type).kind)
+        switch (kind)
         {
             case LIST: throw new InvalidRequestException(String.format("%s selection is only allowed on sets and maps, but %s is a list", selectionType, selected));
             case SET: return Sets.valueSpecOf(receiver);
@@ -1262,14 +1262,19 @@ public interface Selectable extends AssignmentTestable
             Selector.Factory factory = selected.newSelectorFactory(cfm, null, defs, boundNames);
             ColumnSpecification receiver = factory.getColumnSpecification(cfm);
 
-            if (!(receiver.type instanceof CollectionType))
-                throw new InvalidRequestException(String.format("Invalid element selection: %s is of type %s is not a collection", selected, receiver.type.asCQL3Type()));
+            AbstractType<?> type = receiver.type;
+            if (receiver.isReversedType())
+            {
+                type = ((ReversedType<?>) type).baseType;
+            }
+            if (!(type instanceof CollectionType))
+                throw new InvalidRequestException(String.format("Invalid element selection: %s is of type %s is not a collection", selected, type.asCQL3Type()));
 
-            ColumnSpecification boundSpec = specForElementOrSlice(selected, receiver, "Element");
+            ColumnSpecification boundSpec = specForElementOrSlice(selected, receiver, ((CollectionType) type).kind, "Element");
 
             Term elt = element.prepare(cfm.keyspace, boundSpec);
             elt.collectMarkerSpecification(boundNames);
-            return ElementsSelector.newElementFactory(toString(), factory, (CollectionType)receiver.type, elt);
+            return ElementsSelector.newElementFactory(toString(), factory, (CollectionType)type, elt);
         }
 
         public AbstractType<?> getExactTypeIfKnown(String keyspace)
@@ -1344,10 +1349,15 @@ public interface Selectable extends AssignmentTestable
             Selector.Factory factory = selected.newSelectorFactory(cfm, expectedType, defs, boundNames);
             ColumnSpecification receiver = factory.getColumnSpecification(cfm);
 
-            if (!(receiver.type instanceof CollectionType))
-                throw new InvalidRequestException(String.format("Invalid slice selection: %s of type %s is not a collection", selected, receiver.type.asCQL3Type()));
+            AbstractType<?> type = receiver.type;
+            if (receiver.isReversedType())
+            {
+                type = ((ReversedType<?>) type).baseType;
+            }
+            if (!(type instanceof CollectionType))
+                throw new InvalidRequestException(String.format("Invalid slice selection: %s of type %s is not a collection", selected, type.asCQL3Type()));
 
-            ColumnSpecification boundSpec = specForElementOrSlice(selected, receiver, "Slice");
+            ColumnSpecification boundSpec = specForElementOrSlice(selected, receiver, ((CollectionType) type).kind, "Slice");
 
             // If from or to are null, this means the user didn't provide on in the syntax (we had c[x..] or c[..x]).
             // The equivalent of doing this when preparing values would be to use UNSET.
@@ -1355,7 +1365,7 @@ public interface Selectable extends AssignmentTestable
             Term t = to == null ? Constants.UNSET_VALUE : to.prepare(cfm.keyspace, boundSpec);
             f.collectMarkerSpecification(boundNames);
             t.collectMarkerSpecification(boundNames);
-            return ElementsSelector.newSliceFactory(toString(), factory, (CollectionType)receiver.type, f, t);
+            return ElementsSelector.newSliceFactory(toString(), factory, (CollectionType)type, f, t);
         }
 
         public AbstractType<?> getExactTypeIfKnown(String keyspace)
diff --git a/test/unit/org/apache/cassandra/cql3/validation/entities/CollectionsTest.java b/test/unit/org/apache/cassandra/cql3/validation/entities/CollectionsTest.java
index f7848a3d03..b1596e346b 100644
--- a/test/unit/org/apache/cassandra/cql3/validation/entities/CollectionsTest.java
+++ b/test/unit/org/apache/cassandra/cql3/validation/entities/CollectionsTest.java
@@ -2078,4 +2078,44 @@ public class CollectionsTest extends CQLTester
         });
     }
     // End tests for CASSANDRA-17623
+
+    @Test
+    public void testMapReversed() throws Throwable
+    {
+        createTable("CREATE TABLE %s (" +
+                    "   k int, " +
+                    "   c frozen<map<text, int>>, " +
+                    "   v int, " +
+                    "   PRIMARY KEY(k, c)" +
+                    ") WITH CLUSTERING ORDER BY (c DESC)");
+
+        execute("INSERT INTO %s(k, c, v) VALUES (1, {'t1':1,'t2':2,'t3':3,'t4':4}, 2)");
+        assertRows(execute("SELECT c['nonexisting'] FROM %s"), row((Object)null));
+        assertRows(execute("SELECT c['t1'] FROM %s"), row(1));
+        assertRows(execute("SELECT c['t1'..'t3'] FROM %s"), row(map("t1", 1, "t2", 2, "t3", 3)));
+        assertRows(execute("SELECT c['t3'..'t5'] FROM %s"), row(map("t3", 3, "t4", 4)));
+        assertRows(execute("SELECT c[..'t2'] FROM %s"), row(map("t1", 1, "t2", 2)));
+        assertRows(execute("SELECT c['t3'..] FROM %s"), row(map("t3", 3, "t4", 4)));
+        assertRows(execute("SELECT c[..'t5'] FROM %s"), row(map("t1", 1, "t2", 2, "t3", 3, "t4", 4)));
+    }
+
+    @Test
+    public void testSetReversed() throws Throwable
+    {
+        createTable("CREATE TABLE %s (" +
+                    "   k int, " +
+                    "   c frozen<set<text>>, " +
+                    "   v int, " +
+                    "   PRIMARY KEY(k, c)" +
+                    ") WITH CLUSTERING ORDER BY (c DESC)");
+
+        execute("INSERT INTO %s(k, c, v) VALUES (1, {'t1','t2','t3','t4'}, 2)");
+        assertRows(execute("SELECT c['nonexisting'] FROM %s"), row((Object)null));
+        assertRows(execute("SELECT c['t1'] FROM %s"), row("t1"));
+        assertRows(execute("SELECT c['t1'..'t3'] FROM %s"), row(set("t1", "t2", "t3")));
+        assertRows(execute("SELECT c['t3'..'t5'] FROM %s"), row(set("t3", "t4")));
+        assertRows(execute("SELECT c[..'t2'] FROM %s"), row(set("t1", "t2")));
+        assertRows(execute("SELECT c['t3'..] FROM %s"), row(set("t3", "t4")));
+        assertRows(execute("SELECT c[..'t5'] FROM %s"), row(set("t1", "t2", "t3", "t4")));
+    }
 }
