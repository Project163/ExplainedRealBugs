diff --git a/CHANGES.txt b/CHANGES.txt
index 16c6e5863d..b68e442ac4 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,5 +1,6 @@
 2.0.0
  * Fix thrift validation when inserting into CQL3 tables (CASSANDRA-5138)
+ * Fix periodic memtable flushing behavior with clean memtables (CASSANDRA-5931)
 Merged from 1.2:
  * Fix getBloomFilterDiskSpaceUsed for AlwaysPresentFilter (CASSANDRA-5900)
  * Don't announce schema version until we've loaded the changes locally
diff --git a/src/java/org/apache/cassandra/db/ColumnFamilyStore.java b/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
index b6e2f3c11d..f3acf4db24 100644
--- a/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
+++ b/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
@@ -166,11 +166,12 @@ public class ColumnFamilyStore implements ColumnFamilyStoreMBean
                 {
                     if (getMemtableThreadSafe().isExpired())
                     {
-                        Future<?> future = forceFlush();
                         // if memtable is already expired but didn't flush because it's empty,
                         // then schedule another flush.
-                        if (future == null)
+                        if (isClean())
                             scheduleFlush();
+                        else
+                            forceFlush(); // scheduleFlush() will be called by the constructor of the new memtable.
                     }
                 }
             };
@@ -777,15 +778,24 @@ public class ColumnFamilyStore implements ColumnFamilyStoreMBean
         }
     }
 
-    public Future<?> forceFlush()
+    private boolean isClean()
     {
         // during index build, 2ary index memtables can be dirty even if parent is not.  if so,
         // we want flushLargestMemtables to flush the 2ary index ones too.
-        boolean clean = true;
         for (ColumnFamilyStore cfs : concatWithIndexes())
-            clean &= cfs.getMemtableThreadSafe().isClean();
+            if (!cfs.getMemtableThreadSafe().isClean())
+                return false;
+
+        return true;
+    }
 
-        if (clean)
+    /**
+     * @return a future, with a guarantee that any data inserted prior to the forceFlush() call is fully flushed
+     *         by the time future.get() returns. Never returns null.
+     */
+    public Future<?> forceFlush()
+    {
+        if (isClean())
         {
             // We could have a memtable for this column family that is being
             // flushed. Make sure the future returned wait for that so callers can
