diff --git a/modules/accord b/modules/accord
index d77bdd1a4c..4ec8d262a7 160000
--- a/modules/accord
+++ b/modules/accord
@@ -1 +1 @@
-Subproject commit d77bdd1a4cd96120868279b665e0abe4ab509a80
+Subproject commit 4ec8d262a750a76744b7f6991b711f85fa41a89a
diff --git a/src/java/org/apache/cassandra/config/Config.java b/src/java/org/apache/cassandra/config/Config.java
index 06c9a5477f..c33c9bef24 100644
--- a/src/java/org/apache/cassandra/config/Config.java
+++ b/src/java/org/apache/cassandra/config/Config.java
@@ -180,6 +180,7 @@ public class Config
     public volatile DurationSpec.LongMillisecondsBound cms_await_timeout = new DurationSpec.LongMillisecondsBound("120000ms");
     public volatile int cms_default_max_retries = 10;
     public volatile DurationSpec.IntMillisecondsBound cms_default_retry_backoff = new DurationSpec.IntMillisecondsBound("50ms");
+    public volatile DurationSpec.IntMillisecondsBound cms_default_max_retry_backoff = new DurationSpec.IntMillisecondsBound("1s");
     public volatile int epoch_aware_debounce_inflight_tracker_max_size = 100;
     /**
      * How often we should snapshot the cluster metadata.
diff --git a/src/java/org/apache/cassandra/config/DatabaseDescriptor.java b/src/java/org/apache/cassandra/config/DatabaseDescriptor.java
index 05f15148d8..4f6cebbd52 100644
--- a/src/java/org/apache/cassandra/config/DatabaseDescriptor.java
+++ b/src/java/org/apache/cassandra/config/DatabaseDescriptor.java
@@ -3661,7 +3661,7 @@ public class DatabaseDescriptor
 
     public static AccordSpec getAccord()
     {
-        return conf.accord;
+        return conf == null ? null : conf.accord;
     }
 
     public static AccordSpec.TransactionalRangeMigration getTransactionalRangeMigration()
@@ -5730,11 +5730,16 @@ public class DatabaseDescriptor
         conf.cms_default_max_retries = value;
     }
 
-    public static DurationSpec getDefaultRetryBackoff()
+    public static DurationSpec.IntMillisecondsBound getDefaultRetryBackoff()
     {
         return conf.cms_default_retry_backoff;
     }
 
+    public static DurationSpec.IntMillisecondsBound getDefaultMaxRetryBackoff()
+    {
+        return conf.cms_default_max_retry_backoff;
+    }
+
     public static DurationSpec getCmsAwaitTimeout()
     {
         return conf.cms_await_timeout;
diff --git a/src/java/org/apache/cassandra/service/accord/AccordFastPath.java b/src/java/org/apache/cassandra/service/accord/AccordFastPath.java
index 3c45241c2f..ac04488d13 100644
--- a/src/java/org/apache/cassandra/service/accord/AccordFastPath.java
+++ b/src/java/org/apache/cassandra/service/accord/AccordFastPath.java
@@ -122,6 +122,15 @@ public class AccordFastPath implements MetadataValue<AccordFastPath>
             return Objects.hash(status, updated);
         }
 
+        @Override
+        public String toString()
+        {
+            return "NodeInfo{" +
+                   "status=" + status +
+                   ", updated=" + updated +
+                   '}';
+        }
+
         private static final MetadataSerializer<NodeInfo> serializer = new MetadataSerializer<NodeInfo>()
         {
             @Override
@@ -194,7 +203,7 @@ public class AccordFastPath implements MetadataValue<AccordFastPath>
         }
 
         if (!canUpdateNodeTo(current, status, updateTimeMillis, updateDelayMillis))
-            throw new InvalidRequestException(String.format("cannot transition %s to %s at %s", node, status, updateTimeMillis));
+            throw new InvalidRequestException(String.format("cannot transition %s to %s at %s; current %s", node, status, updateTimeMillis, current));
 
         ImmutableMap.Builder<Node.Id, NodeInfo> builder = ImmutableMap.builder();
         builder.put(node, new NodeInfo(status, updateTimeMillis));
diff --git a/src/java/org/apache/cassandra/service/accord/AccordService.java b/src/java/org/apache/cassandra/service/accord/AccordService.java
index 36710717d0..5433b09145 100644
--- a/src/java/org/apache/cassandra/service/accord/AccordService.java
+++ b/src/java/org/apache/cassandra/service/accord/AccordService.java
@@ -19,6 +19,7 @@
 package org.apache.cassandra.service.accord;
 
 import java.math.BigInteger;
+import java.time.Duration;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
@@ -165,6 +166,7 @@ import org.apache.cassandra.tcm.ownership.DataPlacement;
 import org.apache.cassandra.tracing.Tracing;
 import org.apache.cassandra.transport.Dispatcher;
 import org.apache.cassandra.utils.Blocking;
+import org.apache.cassandra.utils.Clock;
 import org.apache.cassandra.utils.ExecutorUtils;
 import org.apache.cassandra.utils.FBUtilities;
 import org.apache.cassandra.utils.concurrent.AsyncPromise;
@@ -552,11 +554,7 @@ public class AccordService implements IAccordService, Shutdownable
 
     public static List<ClusterMetadata> tcmLoadRange(long min, long max)
     {
-        List<ClusterMetadata> afterLoad = ClusterMetadataService.instance()
-                                                                .processor()
-                                                                .reconstruct(Epoch.create(min), Epoch.create(max),
-                                                                             Retry.Deadline.retryIndefinitely(DatabaseDescriptor.getCmsAwaitTimeout().to(TimeUnit.NANOSECONDS),
-                                                                                                              TCMMetrics.instance.fetchLogRetries));
+        List<ClusterMetadata> afterLoad = reconstruct(min, max);
 
         if (Invariants.isParanoid())
             Invariants.checkState(afterLoad.get(0).epoch.getEpoch() == min, "Unexpected epoch: expected %d but given %d", min, afterLoad.get(0).epoch.getEpoch());
@@ -568,6 +566,15 @@ public class AccordService implements IAccordService, Shutdownable
         return afterLoad;
     }
 
+    private static List<ClusterMetadata> reconstruct(long min, long max)
+    {
+        Epoch start = Epoch.create(min);
+        Epoch end = Epoch.create(max);
+        Retry.Deadline deadline = Retry.Deadline.wrap(new Retry.ExponentialBackoff(TCMMetrics.instance.fetchLogRetries));
+        return ClusterMetadataService.instance().processor()
+                                             .reconstruct(start, end, deadline);
+    }
+
     @VisibleForTesting
     static Long findMinEpoch(SharedContext context, Map<InetAddressAndPort, Set<TokenRange>> peers)
     {
@@ -1222,15 +1229,27 @@ public class AccordService implements IAccordService, Shutdownable
         if (node.commandStores().count() == 0) return; // when starting up stores can be empty, so ignore
         Ranges ranges = topology.rangesForNode(target);
         if (ranges.isEmpty()) return;
-        tryMarkRemoved(ranges, 0).begin(node().agent());
+        long startNanos = Clock.Global.nanoTime();
+        exclusiveSyncPointWithRetries(ranges, 0)
+        .begin((s, f) -> {
+            if (f != null)
+            {
+                logger.warn("Unable to mark the ranges for {} as durable after node left; took {}", target, Duration.ofNanos(Clock.Global.nanoTime() - startNanos), f);
+                node.agent().onUncaughtException(f);
+            }
+            else
+            {
+                logger.info("Marked {} ranges as durable after node left; took {}", target, Duration.ofNanos(Clock.Global.nanoTime() - startNanos));
+            }
+        });
     }
 
-    private AsyncChain<SyncPoint<accord.primitives.Range>> tryMarkRemoved(Ranges ranges, int attempt)
+    private AsyncChain<SyncPoint<accord.primitives.Range>> exclusiveSyncPointWithRetries(Ranges ranges, int attempt)
     {
         return CoordinateSyncPoint.exclusiveSyncPoint(node, ranges)
                                   .recover(t ->
                                            //TODO (operability): make this configurable / monitorable?
-                                           attempt <= 3 && t instanceof Invalidated || t instanceof Preempted || t instanceof Timeout ? tryMarkRemoved(ranges, attempt + 1) : null);
+                                           attempt <= 3 && t instanceof Invalidated || t instanceof Preempted || t instanceof Timeout ? exclusiveSyncPointWithRetries(ranges, attempt + 1) : null);
     }
 
     public Node node()
diff --git a/src/java/org/apache/cassandra/tcm/AtomicLongBackedProcessor.java b/src/java/org/apache/cassandra/tcm/AtomicLongBackedProcessor.java
index 55f4d96406..7c5747003a 100644
--- a/src/java/org/apache/cassandra/tcm/AtomicLongBackedProcessor.java
+++ b/src/java/org/apache/cassandra/tcm/AtomicLongBackedProcessor.java
@@ -82,13 +82,7 @@ public class AtomicLongBackedProcessor extends AbstractLocalProcessor
     }
 
     @Override
-    public LogState getLocalState(Epoch start, Epoch end, boolean includeSnapshot, Retry.Deadline retryPolicy)
-    {
-        return getLogState(start, end, includeSnapshot, retryPolicy);
-    }
-
-    @Override
-    public LogState getLogState(Epoch lowEpoch, Epoch highEpoch, boolean includeSnapshot, Retry.Deadline retryPolicy)
+    public LogState getLocalState(Epoch lowEpoch, Epoch highEpoch, boolean includeSnapshot)
     {
         try
         {
@@ -114,6 +108,12 @@ public class AtomicLongBackedProcessor extends AbstractLocalProcessor
         }
     }
 
+    @Override
+    public LogState getLogState(Epoch lowEpoch, Epoch highEpoch, boolean includeSnapshot, Retry.Deadline retryPolicy)
+    {
+        return getLocalState(lowEpoch, highEpoch, includeSnapshot);
+    }
+
     public static class InMemoryStorage implements LogStorage
     {
         private final List<Entry> entries;
diff --git a/src/java/org/apache/cassandra/tcm/ClusterMetadataService.java b/src/java/org/apache/cassandra/tcm/ClusterMetadataService.java
index 933c02bd49..a7498df1ea 100644
--- a/src/java/org/apache/cassandra/tcm/ClusterMetadataService.java
+++ b/src/java/org/apache/cassandra/tcm/ClusterMetadataService.java
@@ -904,9 +904,9 @@ public class ClusterMetadataService
         }
 
         @Override
-        public LogState getLocalState(Epoch start, Epoch end, boolean includeSnapshot, Retry.Deadline retryPolicy)
+        public LogState getLocalState(Epoch start, Epoch end, boolean includeSnapshot)
         {
-            return delegate().getLocalState(start, end, includeSnapshot, retryPolicy);
+            return delegate().getLocalState(start, end, includeSnapshot);
         }
 
         @Override
diff --git a/src/java/org/apache/cassandra/tcm/FetchCMSLog.java b/src/java/org/apache/cassandra/tcm/FetchCMSLog.java
index 3878a9c4cb..943c3b08fc 100644
--- a/src/java/org/apache/cassandra/tcm/FetchCMSLog.java
+++ b/src/java/org/apache/cassandra/tcm/FetchCMSLog.java
@@ -121,7 +121,7 @@ public class FetchCMSLog
             if (consistentFetch)
                 delta = processor.get().getLogState(message.payload.lowerBound, Epoch.MAX, false, retry);
             else
-                delta = processor.get().getLocalState(message.payload.lowerBound, Epoch.MAX, false, retry);
+                delta = processor.get().getLocalState(message.payload.lowerBound, Epoch.MAX, false);
 
             TCMMetrics.instance.cmsLogEntriesServed(message.payload.lowerBound, delta.latestEpoch());
             logger.info("Responding to {}({}) with log delta: {}", message.from(), request, delta);
diff --git a/src/java/org/apache/cassandra/tcm/FetchPeerLog.java b/src/java/org/apache/cassandra/tcm/FetchPeerLog.java
index 1e79d6cb7c..ab55dcf8f0 100644
--- a/src/java/org/apache/cassandra/tcm/FetchPeerLog.java
+++ b/src/java/org/apache/cassandra/tcm/FetchPeerLog.java
@@ -19,12 +19,10 @@
 package org.apache.cassandra.tcm;
 
 import java.io.IOException;
-import java.util.concurrent.TimeUnit;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.io.IVersionedSerializer;
 import org.apache.cassandra.io.util.DataInputPlus;
 import org.apache.cassandra.io.util.DataOutputPlus;
@@ -85,9 +83,7 @@ public class FetchPeerLog
             logger.info("Received peer log fetch request {} from {}: start = {}, current = {}", request, message.from(), message.payload.start, metadata.epoch);
             LogState delta = ClusterMetadataService.instance()
                                                    .processor()
-                                                   .getLocalState(message.payload.start, Epoch.MAX, false,
-                                                                  Retry.Deadline.after(DatabaseDescriptor.getCmsAwaitTimeout().to(TimeUnit.NANOSECONDS),
-                                                                                       new Retry.Jitter(TCMMetrics.instance.fetchLogRetries)));
+                                                   .getLocalState(message.payload.start, Epoch.MAX, false);
             TCMMetrics.instance.peerLogEntriesServed(message.payload.start, delta.latestEpoch());
             logger.info("Responding with log delta: {}", delta);
             MessagingService.instance().send(message.responseWith(delta), message.from());
diff --git a/src/java/org/apache/cassandra/tcm/PaxosBackedProcessor.java b/src/java/org/apache/cassandra/tcm/PaxosBackedProcessor.java
index dcdca627db..e7ad50d9de 100644
--- a/src/java/org/apache/cassandra/tcm/PaxosBackedProcessor.java
+++ b/src/java/org/apache/cassandra/tcm/PaxosBackedProcessor.java
@@ -136,7 +136,7 @@ public class PaxosBackedProcessor extends AbstractLocalProcessor
             while (iter.hasNext())
             {
                 FetchLogRequest request = iter.next();
-                if (request.condition.awaitUninterruptibly(Math.max(0, nextTimeout - Clock.Global.nanoTime()), TimeUnit.NANOSECONDS) &&
+                if (request.condition.awaitThrowUncheckedOnInterrupt(Math.max(0, nextTimeout - Clock.Global.nanoTime()), TimeUnit.NANOSECONDS) &&
                     request.condition.isSuccess())
                 {
                     collected.add(request.to.endpoint());
@@ -168,7 +168,7 @@ public class PaxosBackedProcessor extends AbstractLocalProcessor
     }
 
     @Override
-    public LogState getLocalState(Epoch start, Epoch end, boolean includeSnapshot, Retry.Deadline retryPolicy)
+    public LogState getLocalState(Epoch start, Epoch end, boolean includeSnapshot)
     {
         return log.storage().getLogState(start, end, includeSnapshot);
     }
@@ -176,7 +176,20 @@ public class PaxosBackedProcessor extends AbstractLocalProcessor
     @Override
     public LogState getLogState(Epoch start, Epoch end, boolean includeSnapshot, Retry.Deadline retryPolicy)
     {
-        return DistributedMetadataLogKeyspace.getLogState(start, end, includeSnapshot);
+        while (!retryPolicy.reachedMax())
+        {
+            if (Thread.currentThread().isInterrupted())
+                throw new RuntimeException("Can not reconstruct during shutdown", new InterruptedException());
+            try
+            {
+                return DistributedMetadataLogKeyspace.getLogState(start, end, includeSnapshot);
+            }
+            catch (RuntimeException e) // honestly best to only retry timeouts, but everything gets wrapped in a RuntimeException...
+            {
+                retryPolicy.maybeSleep();
+            }
+        }
+        throw new RuntimeException(String.format("Could not reconstruct range %d, %d", start.getEpoch(), end.getEpoch()), new TimeoutException());
     }
 
     private static <T> T unwrap(Promise<T> promise)
diff --git a/src/java/org/apache/cassandra/tcm/Processor.java b/src/java/org/apache/cassandra/tcm/Processor.java
index 2791e014ab..b370a7c27e 100644
--- a/src/java/org/apache/cassandra/tcm/Processor.java
+++ b/src/java/org/apache/cassandra/tcm/Processor.java
@@ -112,7 +112,7 @@ public interface Processor
     /**
      * Queries node's _local_ state. It is not guaranteed to be contiguous, but can be used for restoring CMS state/
      */
-    LogState getLocalState(Epoch start, Epoch end, boolean includeSnapshot, Retry.Deadline retryPolicy);
+    LogState getLocalState(Epoch start, Epoch end, boolean includeSnapshot);
 
     /**
      * Queries global log state.
diff --git a/src/java/org/apache/cassandra/tcm/RemoteProcessor.java b/src/java/org/apache/cassandra/tcm/RemoteProcessor.java
index e9417adfec..b0ee46b2c4 100644
--- a/src/java/org/apache/cassandra/tcm/RemoteProcessor.java
+++ b/src/java/org/apache/cassandra/tcm/RemoteProcessor.java
@@ -152,7 +152,7 @@ public final class RemoteProcessor implements Processor
     }
 
     @Override
-    public LogState getLocalState(Epoch start, Epoch end, boolean includeSnapshot, Retry.Deadline retryPolicy)
+    public LogState getLocalState(Epoch start, Epoch end, boolean includeSnapshot)
     {
         return log.getLocalEntries(start, end, includeSnapshot);
     }
@@ -177,7 +177,7 @@ public final class RemoteProcessor implements Processor
         }
         catch (ExecutionException | TimeoutException e)
         {
-            throw new RuntimeException("Could not reconstruct", e);
+            throw new RuntimeException(String.format("Could not reconstruct range %d, %d", lowEpoch.getEpoch(), highEpoch.getEpoch()), e);
         }
     }
 
diff --git a/src/java/org/apache/cassandra/tcm/Retry.java b/src/java/org/apache/cassandra/tcm/Retry.java
index bf2e0fbf2b..b0ab619195 100644
--- a/src/java/org/apache/cassandra/tcm/Retry.java
+++ b/src/java/org/apache/cassandra/tcm/Retry.java
@@ -21,17 +21,20 @@ package org.apache.cassandra.tcm;
 import java.util.Random;
 import java.util.concurrent.ThreadLocalRandom;
 import java.util.concurrent.TimeUnit;
+import java.util.function.DoubleSupplier;
 
 import com.codahale.metrics.Meter;
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.utils.Clock;
 
 import static com.google.common.util.concurrent.Uninterruptibles.sleepUninterruptibly;
-import static org.apache.cassandra.tcm.Retry.Jitter.MAX_JITTER_MS;
 
 public abstract class Retry
 {
     protected static final int MAX_TRIES = DatabaseDescriptor.getCmsDefaultRetryMaxTries();
+    private static final int DEFAULT_BACKOFF_MS = DatabaseDescriptor.getDefaultRetryBackoff().toMilliseconds();
+    private static final int DEFAULT_MAX_BACKOFF_MS = DatabaseDescriptor.getDefaultMaxRetryBackoff().toMilliseconds();
+
     protected final int maxTries;
     protected int tries;
     protected Meter retryMeter;
@@ -71,15 +74,16 @@ public abstract class Retry
 
     protected abstract long sleepFor();
 
+    protected abstract long maxWait();
+
     public static class Jitter extends Retry
     {
-        public static final int MAX_JITTER_MS = Math.toIntExact(DatabaseDescriptor.getDefaultRetryBackoff().to(TimeUnit.MILLISECONDS));
         private final Random random;
         private final int maxJitterMs;
 
         public Jitter(Meter retryMeter)
         {
-            this(MAX_TRIES, MAX_JITTER_MS, new Random(), retryMeter);
+            this(MAX_TRIES, DEFAULT_BACKOFF_MS, new Random(), retryMeter);
         }
 
         private Jitter(int maxTries, int maxJitterMs, Random random, Meter retryMeter)
@@ -95,6 +99,12 @@ public abstract class Retry
             return random.nextInt(actualBackoff);
         }
 
+        @Override
+        protected long maxWait()
+        {
+            return maxJitterMs;
+        }
+
         @Override
         public String toString()
         {
@@ -108,12 +118,11 @@ public abstract class Retry
 
     public static class Backoff extends Retry
     {
-        private static final int RETRY_BACKOFF_MS = Math.toIntExact(DatabaseDescriptor.getDefaultRetryBackoff().to(TimeUnit.MILLISECONDS));
         protected final int backoffMs;
 
         public Backoff(Meter retryMeter)
         {
-            this(MAX_TRIES, RETRY_BACKOFF_MS, retryMeter);
+            this(MAX_TRIES, DEFAULT_BACKOFF_MS, retryMeter);
         }
 
         public Backoff(int maxTries, int backoffMs, Meter retryMeter)
@@ -127,6 +136,12 @@ public abstract class Retry
             return (long) tries * backoffMs;
         }
 
+        @Override
+        protected long maxWait()
+        {
+            return backoffMs;
+        }
+
         @Override
         public String toString()
         {
@@ -138,6 +153,38 @@ public abstract class Retry
         }
     }
 
+    public static class ExponentialBackoff extends Retry
+    {
+        private final long baseSleepTimeMillis;
+        private final long maxSleepMillis;
+        private final DoubleSupplier randomSource;
+
+        public ExponentialBackoff(int maxAttempts, long baseSleepTimeMillis, long maxSleepMillis, DoubleSupplier randomSource, Meter retryMeter)
+        {
+            super(maxAttempts, retryMeter);
+            this.baseSleepTimeMillis = baseSleepTimeMillis;
+            this.maxSleepMillis = maxSleepMillis;
+            this.randomSource = randomSource;
+        }
+
+        public ExponentialBackoff(Meter retryMeter)
+        {
+            this(MAX_TRIES, DEFAULT_BACKOFF_MS, DEFAULT_MAX_BACKOFF_MS, ThreadLocalRandom.current()::nextDouble, retryMeter);
+        }
+
+        @Override
+        protected long sleepFor()
+        {
+            return org.apache.cassandra.utils.Backoff.ExponentialBackoff.computeWaitTime(tries, baseSleepTimeMillis, maxSleepMillis, randomSource);
+        }
+
+        @Override
+        protected long maxWait()
+        {
+            return maxSleepMillis;
+        }
+    }
+
     public static class Deadline extends Retry
     {
         public final long deadlineNanos;
@@ -169,7 +216,7 @@ public abstract class Retry
         public static Deadline retryIndefinitely(long timeoutNanos, Meter retryMeter)
         {
             return new Deadline(Clock.Global.nanoTime() + timeoutNanos,
-                    new Retry.Jitter(Integer.MAX_VALUE, MAX_JITTER_MS, new Random(), retryMeter))
+                                new Retry.Jitter(Integer.MAX_VALUE, DEFAULT_BACKOFF_MS, new Random(), retryMeter))
             {
                 @Override
                 public boolean reachedMax()
@@ -190,6 +237,12 @@ public abstract class Retry
             };
         }
 
+        public static Deadline wrap(Retry delegate)
+        {
+            long deadlineMillis = delegate.maxTries * delegate.maxWait();
+            return new Deadline(Clock.Global.nanoTime() + TimeUnit.MILLISECONDS.toNanos(deadlineMillis), delegate);
+        }
+
         @Override
         public boolean reachedMax()
         {
@@ -213,6 +266,12 @@ public abstract class Retry
             return delegate.sleepFor();
         }
 
+        @Override
+        protected long maxWait()
+        {
+            return deadlineNanos;
+        }
+
         public String toString()
         {
             return String.format("Deadline{remainingMs=%d, tries=%d/%d}", TimeUnit.NANOSECONDS.toMillis(remainingNanos()), currentTries(), delegate.maxTries);
diff --git a/src/java/org/apache/cassandra/tcm/StubClusterMetadataService.java b/src/java/org/apache/cassandra/tcm/StubClusterMetadataService.java
index 30e7f52e0b..ffacb78627 100644
--- a/src/java/org/apache/cassandra/tcm/StubClusterMetadataService.java
+++ b/src/java/org/apache/cassandra/tcm/StubClusterMetadataService.java
@@ -154,7 +154,7 @@ public class StubClusterMetadataService extends ClusterMetadataService
         }
 
         @Override
-        public LogState getLocalState(Epoch start, Epoch end, boolean includeSnapshot, Retry.Deadline retryPolicy)
+        public LogState getLocalState(Epoch start, Epoch end, boolean includeSnapshot)
         {
             throw new UnsupportedOperationException();
         }
diff --git a/src/java/org/apache/cassandra/tcm/log/LogReader.java b/src/java/org/apache/cassandra/tcm/log/LogReader.java
index 7f2b80602a..92b57a0575 100644
--- a/src/java/org/apache/cassandra/tcm/log/LogReader.java
+++ b/src/java/org/apache/cassandra/tcm/log/LogReader.java
@@ -148,7 +148,8 @@ public interface LogReader
             else if (closestSnapshot.epoch.isBefore(start))
             {
                 ImmutableList.Builder<Entry> entries = new ImmutableList.Builder<>();
-                EntryHolder entryHolder = getEntries(closestSnapshot.epoch.nextEpoch(), end);
+                // start is exclusive, so use the closest snapshot
+                EntryHolder entryHolder = getEntries(closestSnapshot.epoch, end);
                 for (Entry entry : entryHolder.entries)
                 {
                     if (entry.epoch.isAfter(start))
diff --git a/src/java/org/apache/cassandra/tcm/migration/GossipProcessor.java b/src/java/org/apache/cassandra/tcm/migration/GossipProcessor.java
index 36baa59eb3..be853d89e7 100644
--- a/src/java/org/apache/cassandra/tcm/migration/GossipProcessor.java
+++ b/src/java/org/apache/cassandra/tcm/migration/GossipProcessor.java
@@ -42,7 +42,7 @@ public class GossipProcessor implements Processor
     }
 
     @Override
-    public LogState getLocalState(Epoch start, Epoch end, boolean includeSnapshot, Retry.Deadline retryPolicy)
+    public LogState getLocalState(Epoch start, Epoch end, boolean includeSnapshot)
     {
         throw new IllegalStateException("Can't reconstruct log state when running in gossip mode. Enable the ClusterMetadataService with `nodetool addtocms`.");
     }
diff --git a/src/java/org/apache/cassandra/utils/Backoff.java b/src/java/org/apache/cassandra/utils/Backoff.java
index 7974dbf346..79a68fdbc1 100644
--- a/src/java/org/apache/cassandra/utils/Backoff.java
+++ b/src/java/org/apache/cassandra/utils/Backoff.java
@@ -113,6 +113,11 @@ public interface Backoff
 
         @Override
         public long computeWaitTime(int retryCount)
+        {
+            return computeWaitTime(retryCount, baseSleepTimeMillis, maxSleepMillis, randomSource);
+        }
+
+        public static long computeWaitTime(int retryCount, long baseSleepTimeMillis, long maxSleepMillis, DoubleSupplier randomSource)
         {
             long baseTimeMillis = baseSleepTimeMillis * (1L << retryCount);
             // it's possible that this overflows, so fall back to max;
diff --git a/src/java/org/apache/cassandra/utils/concurrent/Ref.java b/src/java/org/apache/cassandra/utils/concurrent/Ref.java
index 911c1db881..6f0836b3e3 100644
--- a/src/java/org/apache/cassandra/utils/concurrent/Ref.java
+++ b/src/java/org/apache/cassandra/utils/concurrent/Ref.java
@@ -601,6 +601,8 @@ public final class Ref<T> implements RefCounted<T>
             InProgressVisit inProgress = null;
             while (inProgress != null || !path.isEmpty())
             {
+                if (Thread.currentThread().isInterrupted())
+                    throw new UncheckedInterruptedException(new InterruptedException());
                 //If necessary fetch the next object to start tracing
                 if (inProgress == null)
                     inProgress = path.pollLast();
diff --git a/test/distributed/org/apache/cassandra/distributed/impl/Instance.java b/test/distributed/org/apache/cassandra/distributed/impl/Instance.java
index 59d46c52ef..281b95c0b0 100644
--- a/test/distributed/org/apache/cassandra/distributed/impl/Instance.java
+++ b/test/distributed/org/apache/cassandra/distributed/impl/Instance.java
@@ -42,6 +42,7 @@ import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.stream.Stream;
+import javax.annotation.Nullable;
 import javax.management.ListenerNotFoundException;
 import javax.management.Notification;
 import javax.management.NotificationListener;
@@ -66,6 +67,7 @@ import org.apache.cassandra.concurrent.SharedExecutorPool;
 import org.apache.cassandra.concurrent.Stage;
 import org.apache.cassandra.config.Config;
 import org.apache.cassandra.config.DatabaseDescriptor;
+import org.apache.cassandra.config.DurationSpec;
 import org.apache.cassandra.config.YamlConfigurationLoader;
 import org.apache.cassandra.cql3.CQLStatement;
 import org.apache.cassandra.cql3.QueryHandler;
@@ -162,6 +164,7 @@ import org.apache.cassandra.utils.FBUtilities;
 import org.apache.cassandra.utils.JVMStabilityInspector;
 import org.apache.cassandra.utils.Throwables;
 import org.apache.cassandra.utils.concurrent.Ref;
+import org.apache.cassandra.utils.concurrent.UncheckedInterruptedException;
 import org.apache.cassandra.utils.logging.LoggingSupportFactory;
 import org.apache.cassandra.utils.memory.BufferPools;
 import org.apache.cassandra.utils.progress.jmx.JMXBroadcastExecutor;
@@ -612,6 +615,18 @@ public class Instance extends IsolatedExecutor implements IInvokableInstance
         return Verb.fromId(verbId).stage.executor();
     }
 
+    @Nullable
+    private DurationSpec startupTimeout()
+    {
+        Object c = config.get(Constants.KEY_DTEST_STARTUP_TIMEOUT);
+        if (c == null) return null;
+        if (c instanceof String)
+            return new DurationSpec.LongNanosecondsBound((String) c);
+        if (c instanceof Number)
+            return new DurationSpec.LongNanosecondsBound(((Number) c).longValue());
+        throw new IllegalArgumentException("Key " + Constants.KEY_DTEST_STARTUP_TIMEOUT + " only allowed to have string/number values, but given " + c + ": " + c.getClass());
+    }
+
     @Override
     public void startup(ICluster cluster)
     {
@@ -621,7 +636,7 @@ public class Instance extends IsolatedExecutor implements IInvokableInstance
         // commit to extend the functionality of the @Shared annotation to app classes.
         assert startedAt.compareAndSet(0L, System.nanoTime()) : String.format("startedAt on instance %d expected to be 0, but was %d", config().num(), startedAt.get());
 
-        sync(() -> {
+        Future<?> result = async(() -> {
             inInstancelogger = LoggerFactory.getLogger(Instance.class);
             try
             {
@@ -651,7 +666,28 @@ public class Instance extends IsolatedExecutor implements IInvokableInstance
                     throw (RuntimeException) t;
                 throw new RuntimeException(t);
             }
-        }).run();
+        }).call();
+        DurationSpec timeout = startupTimeout();
+        if (timeout == null)
+        {
+            waitOn(result);
+        }
+        else
+        {
+            try
+            {
+                result.get(timeout.quantity(), timeout.unit());
+            }
+            catch (InterruptedException e)
+            {
+                Thread.currentThread().interrupt();
+                throw new UncheckedInterruptedException(e);
+            }
+            catch (TimeoutException | ExecutionException e)
+            {
+                throw new RuntimeException(e);
+            }
+        }
 
         initialized = true;
     }
diff --git a/test/distributed/org/apache/cassandra/distributed/shared/ClusterUtils.java b/test/distributed/org/apache/cassandra/distributed/shared/ClusterUtils.java
index 0cbb1f7cad..acf6112c75 100644
--- a/test/distributed/org/apache/cassandra/distributed/shared/ClusterUtils.java
+++ b/test/distributed/org/apache/cassandra/distributed/shared/ClusterUtils.java
@@ -34,6 +34,7 @@ import java.util.Set;
 import java.util.UUID;
 import java.util.concurrent.Callable;
 import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ExecutionException;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 import java.util.function.BiConsumer;
@@ -48,7 +49,6 @@ import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Strings;
 import com.google.common.collect.ImmutableList;
 import com.google.common.util.concurrent.Futures;
-import org.apache.cassandra.distributed.api.*;
 import org.assertj.core.api.Assertions;
 import org.junit.Assert;
 import org.slf4j.Logger;
@@ -65,6 +65,7 @@ import org.apache.cassandra.distributed.api.IInstanceConfig;
 import org.apache.cassandra.distributed.api.IInvokableInstance;
 import org.apache.cassandra.distributed.api.IMessageFilters;
 import org.apache.cassandra.distributed.api.NodeToolResult;
+import org.apache.cassandra.distributed.api.Row;
 import org.apache.cassandra.distributed.api.SimpleQueryResult;
 import org.apache.cassandra.distributed.impl.AbstractCluster;
 import org.apache.cassandra.distributed.impl.InstanceConfig;
@@ -82,6 +83,7 @@ import org.apache.cassandra.schema.KeyspaceMetadata;
 import org.apache.cassandra.schema.Schema;
 import org.apache.cassandra.schema.TableId;
 import org.apache.cassandra.service.StorageService;
+import org.apache.cassandra.service.accord.AccordService;
 import org.apache.cassandra.tcm.ClusterMetadata;
 import org.apache.cassandra.tcm.ClusterMetadataService;
 import org.apache.cassandra.tcm.Commit;
@@ -1615,5 +1617,21 @@ public class ClusterUtils
         String str = cluster.getFirstRunningInstance().callOnInstance(() -> Schema.instance.getKeyspaceInstance(ks).getColumnFamilyStore(table).getTableId().toString());
         return TableId.fromUUID(UUID.fromString(str));
     }
-}
 
+    public static void awaitAccordEpochReady(Cluster cluster, long epoch)
+    {
+        cluster.forEach(i -> {
+            if (i.isShutdown()) return;
+            i.runOnInstance(() -> {
+                try
+                {
+                    AccordService.instance().epochReady(Epoch.create(epoch)).get();
+                }
+                catch (InterruptedException | ExecutionException e)
+                {
+                    throw new RuntimeException(e);
+                }
+            });
+        });
+    }
+}
diff --git a/test/distributed/org/apache/cassandra/distributed/test/HungBootstrapDoesNotHangTest.java b/test/distributed/org/apache/cassandra/distributed/test/HungBootstrapDoesNotHangTest.java
new file mode 100644
index 0000000000..474c555ab4
--- /dev/null
+++ b/test/distributed/org/apache/cassandra/distributed/test/HungBootstrapDoesNotHangTest.java
@@ -0,0 +1,139 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.cassandra.distributed.test;
+
+import java.io.IOException;
+import java.util.Collection;
+import java.util.concurrent.ForkJoinPool;
+
+import org.junit.Test;
+
+import net.bytebuddy.ByteBuddy;
+import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
+import net.bytebuddy.implementation.MethodDelegation;
+import org.apache.cassandra.dht.Token;
+import org.apache.cassandra.distributed.Cluster;
+import org.apache.cassandra.distributed.Constants;
+import org.apache.cassandra.distributed.api.Feature;
+import org.apache.cassandra.distributed.api.IInvokableInstance;
+import org.apache.cassandra.distributed.api.TokenSupplier;
+import org.apache.cassandra.distributed.shared.ClusterUtils;
+import org.apache.cassandra.locator.InetAddressAndPort;
+import org.apache.cassandra.tcm.ClusterMetadata;
+import org.apache.cassandra.tcm.ownership.MovementMap;
+import org.apache.cassandra.tcm.sequences.BootstrapAndJoin;
+import org.apache.cassandra.utils.Shared;
+import org.apache.cassandra.utils.concurrent.CountDownLatch;
+import org.apache.cassandra.utils.concurrent.UncheckedInterruptedException;
+import org.assertj.core.api.Assertions;
+
+import static net.bytebuddy.matcher.ElementMatchers.named;
+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;
+
+/**
+ * When bootstrap hangs it can hang forever, but this can be a problem in CI as the test reports as "timeout" and all logs and history is lost.  This test makes sure that JVM-DTest instances do shutdown properly even in this case
+ */
+public class HungBootstrapDoesNotHangTest extends TestBaseImpl
+{
+    @Test
+    public void test() throws IOException
+    {
+        TokenSupplier tokenSupplier = TokenSupplier.evenlyDistributedTokens(2);
+        try (Cluster cluster = Cluster.build(1)
+                                      .withTokenSupplier(tokenSupplier)
+                                      .withConfig(c -> c.set("auto_bootstrap", true).with(Feature.values()))
+                                      .withInstanceInitializer(BBHelper::install)
+                                      .createWithoutStarting())
+        {
+            cluster.get(1).startup(cluster); // should work fine
+            IInvokableInstance node2 = ClusterUtils.addInstance(cluster, c -> c.set(Constants.KEY_DTEST_STARTUP_TIMEOUT, "1m")
+                                                                               .set(Constants.KEY_DTEST_API_STARTUP_FAILURE_AS_SHUTDOWN, false));
+            ForkJoinPool.commonPool().execute(() -> {
+                node2.startup(); // should hang and never reach the next line
+                State.notBlocked();
+            });
+            State.awaitBlocked();
+
+            Assertions.assertThat(State.wasBlocked()).describedAs("node2 was supposed to get blocked by ByteBuddy but didnt").isEqualTo(true);
+
+            // node1 is up, node2 is blocked in bootstrap... now let the cluster close
+        }
+    }
+
+    @Shared
+    public static class State
+    {
+        private static final CountDownLatch blocked = CountDownLatch.newCountDownLatch(1);
+        private static volatile boolean wasBlocked = true;
+
+        public static void blocked()
+        {
+            blocked.decrement();
+        }
+
+        public static void notBlocked()
+        {
+            wasBlocked = false;
+            blocked();
+        }
+
+        public static void awaitBlocked()
+        {
+            blocked.awaitThrowUncheckedOnInterrupt();
+        }
+
+        public static boolean wasBlocked()
+        {
+            return wasBlocked;
+        }
+    }
+
+    public static class BBHelper
+    {
+        public static void install(ClassLoader cl, int id)
+        {
+            if (id != 2) return;
+            new ByteBuddy().rebase(BootstrapAndJoin.class)
+                           .method(named("bootstrap").and(takesArguments(6)))
+                           .intercept(MethodDelegation.to(BBHelper.class))
+                           .make()
+                           .load(cl, ClassLoadingStrategy.Default.INJECTION);
+        }
+
+        public static boolean bootstrap(final Collection<Token> tokens,
+                                        long bootstrapTimeoutMillis,
+                                        ClusterMetadata metadata,
+                                        InetAddressAndPort beingReplaced,
+                                        MovementMap movements,
+                                        MovementMap strictMovements)
+        {
+            try
+            {
+                State.blocked();
+                Thread.currentThread().join();
+                return false;
+            }
+            catch (InterruptedException e)
+            {
+                throw new UncheckedInterruptedException(e);
+            }
+        }
+
+    }
+}
diff --git a/test/distributed/org/apache/cassandra/distributed/test/log/CoordinatorPathTestBase.java b/test/distributed/org/apache/cassandra/distributed/test/log/CoordinatorPathTestBase.java
index 42cd999eb7..9553377847 100644
--- a/test/distributed/org/apache/cassandra/distributed/test/log/CoordinatorPathTestBase.java
+++ b/test/distributed/org/apache/cassandra/distributed/test/log/CoordinatorPathTestBase.java
@@ -758,15 +758,15 @@ public abstract class CoordinatorPathTestBase extends FuzzTestBase
                                            }
 
                                            @Override
-                                           public LogState getLocalState(Epoch start, Epoch end, boolean includeSnapshot, Retry.Deadline retryPolicy)
+                                           public LogState getLocalState(Epoch start, Epoch end, boolean includeSnapshot)
                                            {
-                                               return getLogState(start, end, includeSnapshot, retryPolicy);
+                                               return log.getLocalEntries(start, end, includeSnapshot);
                                            }
 
                                            @Override
                                            public LogState getLogState(Epoch start, Epoch end, boolean includeSnapshot, Retry.Deadline retryPolicy)
                                            {
-                                               return log.getLocalEntries(start, end, includeSnapshot);
+                                               return getLocalState(start, end, includeSnapshot);
                                            }
                                        },
                                        (a,b) -> {},
diff --git a/test/distributed/org/apache/cassandra/distributed/test/log/TestProcessor.java b/test/distributed/org/apache/cassandra/distributed/test/log/TestProcessor.java
index 6ee5e975ea..2b2906bc07 100644
--- a/test/distributed/org/apache/cassandra/distributed/test/log/TestProcessor.java
+++ b/test/distributed/org/apache/cassandra/distributed/test/log/TestProcessor.java
@@ -71,9 +71,9 @@ public class TestProcessor implements Processor
     }
 
     @Override
-    public LogState getLocalState(Epoch start, Epoch end, boolean includeSnapshot, Retry.Deadline retryPolicy)
+    public LogState getLocalState(Epoch start, Epoch end, boolean includeSnapshot)
     {
-        return delegate.getLocalState(start, end, includeSnapshot, retryPolicy);
+        return delegate.getLocalState(start, end, includeSnapshot);
     }
 
     @Override
diff --git a/test/harry/main/org/apache/cassandra/harry/dsl/HistoryBuilder.java b/test/harry/main/org/apache/cassandra/harry/dsl/HistoryBuilder.java
index c4565a0a74..8766ff7fd0 100644
--- a/test/harry/main/org/apache/cassandra/harry/dsl/HistoryBuilder.java
+++ b/test/harry/main/org/apache/cassandra/harry/dsl/HistoryBuilder.java
@@ -18,13 +18,7 @@
 
 package org.apache.cassandra.harry.dsl;
 
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Comparator;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
+import java.util.*;
 import java.util.stream.Collectors;
 
 import org.apache.cassandra.harry.ColumnSpec;
diff --git a/test/unit/org/apache/cassandra/service/RetryStrategyTest.java b/test/unit/org/apache/cassandra/service/RetryStrategyTest.java
deleted file mode 100644
index e0fed7475c..0000000000
--- a/test/unit/org/apache/cassandra/service/RetryStrategyTest.java
+++ /dev/null
@@ -1,482 +0,0 @@
-///*
-// * Licensed to the Apache Software Foundation (ASF) under one
-// * or more contributor license agreements.  See the NOTICE file
-// * distributed with this work for additional information
-// * regarding copyright ownership.  The ASF licenses this file
-// * to you under the Apache License, Version 2.0 (the
-// * "License"); you may not use this file except in compliance
-// * with the License.  You may obtain a copy of the License at
-// *
-// *     http://www.apache.org/licenses/LICENSE-2.0
-// *
-// * Unless required by applicable law or agreed to in writing, software
-// * distributed under the License is distributed on an "AS IS" BASIS,
-// * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// * See the License for the specific language governing permissions and
-// * limitations under the License.
-// */
-//package org.apache.cassandra.service;
-//
-//import java.util.List;
-//import java.util.Random;
-//import java.util.concurrent.ThreadLocalRandom;
-//import java.util.concurrent.TimeUnit;
-//import java.util.concurrent.atomic.AtomicReference;
-//import java.util.function.BiFunction;
-//import java.util.function.Consumer;
-//import java.util.function.DoubleSupplier;
-//import java.util.function.LongBinaryOperator;
-//
-//import com.google.common.collect.ImmutableList;
-//import org.junit.Assert;
-//import org.junit.Test;
-//
-//import org.slf4j.Logger;
-//import org.slf4j.LoggerFactory;
-//
-//import net.nicoulaj.compilecommand.annotations.Inline;
-//import org.apache.cassandra.config.DatabaseDescriptor;
-//import org.apache.cassandra.service.TimeoutStrategy.LatencyModifier;
-//import org.apache.cassandra.service.TimeoutStrategy.LatencyModifierFactory;
-//import org.apache.cassandra.service.TimeoutStrategy.LatencySource;
-//import org.apache.cassandra.service.TimeoutStrategy.LatencySupplierFactory;
-//import org.apache.cassandra.service.TimeoutStrategy.LatencySupplier;
-//import org.apache.cassandra.service.TimeoutStrategy.Wait;
-//import org.apache.cassandra.service.paxos.ContentionStrategy;
-//
-//import static org.apache.cassandra.service.RetryStrategy.*;
-//import static org.apache.cassandra.service.RetryStrategy.WaitRandomizerFactory.*;
-//import static org.apache.cassandra.service.RetryStrategyTest.WaitRandomizerType.*;
-//import static org.apache.cassandra.service.TimeoutStrategy.modifiers;
-//import static org.apache.cassandra.service.TimeoutStrategy.parseWait;
-//import static org.apache.cassandra.service.TimeoutStrategy.selectors;
-//
-//public class RetryStrategyTest
-//{
-//    private static final Logger logger = LoggerFactory.getLogger(RetryStrategyTest.class);
-//
-//    static
-//    {
-//        DatabaseDescriptor.daemonInitialization();
-//    }
-//
-//    private static final long MAX = DatabaseDescriptor.getRpcTimeout(TimeUnit.MICROSECONDS);
-//
-//    private static final String DEFAULT_WAIT_RANDOMIZER = "qexp(1.5)"; // at least 0ms, and at least 66% of median latency
-//    private static final String DEFAULT_MIN = "0 <= p50(rw)*0.66"; // at least 0ms, and at least 66% of median latency
-//    private static final String DEFAULT_MAX = "10ms <= p95(rw)*1.8^attempts <= 100ms"; // p95 latency with exponential back-off at rate of 1.8^attempts
-//    private static final String DEFAULT_SPREAD = "5ms <= p50(rw)*0.5"; // at least 5ms, and at least 50% of median latency
-//
-//    private static final WaitRandomizerParseValidator DEFAULT_WAIT_RANDOMIZER_VALIDATOR = new WaitRandomizerParseValidator(DEFAULT_WAIT_RANDOMIZER, QEXP, 1.5);
-//    private static final WaitParseValidator DEFAULT_MIN_VALIDATOR = new WaitParseValidator(DEFAULT_MIN, true, assertWait(0, MAX, 0, selectors.maxReadWrite(0f).getClass(), 0.50, 0, modifiers.multiply(0f).getClass(), 0.66));
-//    private static final WaitParseValidator DEFAULT_MAX_VALIDATOR = new WaitParseValidator(DEFAULT_MAX, false, assertWait(10000, 100000, 100000, selectors.maxReadWrite(0f).getClass(), 0.95, 0, modifiers.multiplyByAttemptsExp(0f).getClass(), 1.8));
-//    private static final WaitParseValidator DEFAULT_MIN_DELTA_VALIDATOR = new WaitParseValidator(DEFAULT_SPREAD, true, assertWait(5000, MAX, 5000, selectors.maxReadWrite(0f).getClass(), 0.50, 0, modifiers.multiply(0f).getClass(), 0.5));
-//    private static final RetryStrategy.ParsedStrategy DEFAULT = new RetryStrategy.ParsedStrategy(DEFAULT_WAIT_RANDOMIZER, DEFAULT_MIN, DEFAULT_MAX, DEFAULT_SPREAD,
-//                                                                                                 new RetryStrategy(DEFAULT_WAIT_RANDOMIZER, DEFAULT_MIN, DEFAULT_MAX, DEFAULT_SPREAD));
-//
-//    private static List<WaitParseValidator> VALIDATE = ImmutableList.of(
-//            new WaitParseValidator("p95(rw)", false, assertWait(0, MAX, MAX, selectors.maxReadWrite(0f).getClass(), 0.95, 0, modifiers.identity().getClass(), 1)),
-//            new WaitParseValidator("5ms<=p50(rw)*0.66", false, assertWait(5000, MAX, MAX, selectors.maxReadWrite(0f).getClass(), 0.50, 0, modifiers.multiply(0).getClass(), 0.66)),
-//            new WaitParseValidator("5us <= p50(r)*1.66*attempts", true, assertWait(5, MAX, 5, selectors.read(0f).getClass(), 0.50, 0, modifiers.multiplyByAttempts(0f).getClass(), 1.66)),
-//            new WaitParseValidator("0<=p50(w)*0.66^attempts", true, assertWait(0, MAX, 0, selectors.write(0f).getClass(), 0.50, 0, modifiers.multiplyByAttemptsExp(0f).getClass(), 0.66)),
-//            new WaitParseValidator("125us", true, assertWait(125, 125, 125, selectors.constant(0).getClass(), 0.0f, 125, modifiers.identity().getClass(), 1)),
-//            new WaitParseValidator("5us <= p95(r)*1.8^attempts <= 100us", true, assertWait(5, 100, 5, selectors.read(0f).getClass(), 0.95, 0, modifiers.multiplyByAttemptsExp(0f).getClass(), 1.8)),
-//            DEFAULT_MIN_VALIDATOR, DEFAULT_MAX_VALIDATOR, DEFAULT_MIN_DELTA_VALIDATOR
-//    );
-//
-//    private static List<WaitRandomizerParseValidator> VALIDATE_RANDOMIZER = ImmutableList.of(
-//            new WaitRandomizerParseValidator("quantizedexponential(0.5)", QEXP, 0.5),
-//            new WaitRandomizerParseValidator("exponential(2.5)", EXP, 2.5),
-//            new WaitRandomizerParseValidator("exp(10)", EXP, 10),
-//            new WaitRandomizerParseValidator("uniform", UNIFORM, 0),
-//            DEFAULT_WAIT_RANDOMIZER_VALIDATOR
-//    );
-//
-//    static class WaitParseValidator
-//    {
-//        final String spec;
-//        final boolean isMin;
-//        final Consumer<Wait> validator;
-//
-//        WaitParseValidator(String spec, boolean isMin, Consumer<Wait> validator)
-//        {
-//            this.spec = spec;
-//            this.isMin = isMin;
-//            this.validator = validator;
-//        }
-//
-//        void validate(Wait Wait)
-//        {
-//            validator.accept(Wait);
-//        }
-//    }
-//
-//    enum WaitRandomizerType
-//    {
-//        UNIFORM(Uniform.class, (p, f) -> f.uniform()),
-//        EXP(Exponential.class, (p, f) -> f.exponential(p)),
-//        QEXP(QuantizedExponential.class, (p, f) -> f.quantizedExponential(p));
-//
-//        final Class<? extends WaitRandomizer> clazz;
-//        final BiFunction<Double, WaitRandomizerFactory, WaitRandomizer> getter;
-//
-//        WaitRandomizerType(Class<? extends WaitRandomizer> clazz, BiFunction<Double, WaitRandomizerFactory, WaitRandomizer> getter)
-//        {
-//            this.clazz = clazz;
-//            this.getter = getter;
-//        }
-//    }
-//
-//    static class WaitRandomizerParseValidator
-//    {
-//        final String spec;
-//        final WaitRandomizerType type;
-//        final double power;
-//
-//        WaitRandomizerParseValidator(String spec, WaitRandomizerType type, double power)
-//        {
-//            this.spec = spec;
-//            this.type = type;
-//            this.power = power;
-//        }
-//
-//        void validate(WaitRandomizer randomizer)
-//        {
-//            Assert.assertSame(type.clazz, randomizer.getClass());
-//            if (AbstractExponential.class.isAssignableFrom(type.clazz))
-//                Assert.assertEquals(power, ((AbstractExponential) randomizer).power, 0.00001);
-//        }
-//    }
-//
-//    private static class WaitRandomizerOutputValidator
-//    {
-//        static void validate(WaitRandomizerType type, long seed, int trials, int samplesPerTrial)
-//        {
-//            Random random = new Random(seed);
-//            WaitRandomizer randomizer = type.getter.apply(2d, new WaitRandomizerFactory()
-//            {
-//                @Override public LongBinaryOperator uniformLongSupplier() { return (min, max) -> min + random.nextInt((int) (max - min)); }
-//                @Override public DoubleSupplier uniformDoubleSupplier() { return random::nextDouble; }
-//            });
-//
-//            for (int i = 0 ; i < trials ; ++i)
-//            {
-//                int min = random.nextInt(1 << 20);
-//                int max = min + 1024 + random.nextInt(1 << 20);
-//                double minMean = minMean(type, min, max);
-//                double maxMean = maxMean(type, min, max);
-//                double sampleMean = sampleMean(samplesPerTrial, min, max, randomizer);
-//                Assert.assertTrue(minMean <= sampleMean);
-//                Assert.assertTrue(maxMean >= sampleMean);
-//            }
-//        }
-//
-//        private static double minMean(WaitRandomizerType type, int min, int max)
-//        {
-//            switch (type)
-//            {
-//                case UNIFORM: return min + (max - min) * (4d/10);
-//                case EXP: case QEXP: return min + (max - min) * (6d/10);
-//                default: throw new IllegalStateException();
-//            }
-//        }
-//
-//        private static double maxMean(WaitRandomizerType type, int min, int max)
-//        {
-//            switch (type)
-//            {
-//                case UNIFORM: return min + (max - min) * (6d/10);
-//                case EXP: case QEXP: return min + (max - min) * (8d/10);
-//                default: throw new IllegalStateException();
-//            }
-//        }
-//
-//        private static double sampleMean(int samples, int min, int max, WaitRandomizer randomizer)
-//        {
-//            double sum = 0;
-//            int attempts = 1;
-//            for (int i = 0 ; i < samples ; ++i)
-//            {
-//                long wait = randomizer.wait(min, max, attempts = (attempts & 15) + 1);
-//                Assert.assertTrue(wait >= min);
-//                Assert.assertTrue(wait <= max);
-//                sum += wait;
-//            }
-//            double mean = sum / samples;
-//            Assert.assertTrue(mean >= min);
-//            Assert.assertTrue(mean <= max);
-//            return mean;
-//        }
-//    }
-//
-//    private static Consumer<Wait> assertWait(
-//                             long min, long max, long onFailure,
-//                             Class<? extends LatencySupplier> selectorClass,
-//                             double selectorPercentile,
-//                             long selectorConst,
-//                             Class<? extends LatencyModifier> modifierClass,
-//                             double modifierVal
-//    )
-//    {
-//        return Wait -> {
-//            Assert.assertEquals(min, Wait.min);
-//            Assert.assertEquals(max, Wait.max);
-//            Assert.assertEquals(onFailure, Wait.onFailure);
-//            Assert.assertSame(selectorClass, Wait.selector.getClass());
-//            if (selectorClass == selectors.constant(0).getClass())
-//            {
-//                LatencySupplier fail = v -> { throw new UnsupportedOperationException(); };
-//                Assert.assertEquals(selectorConst, Wait.selector.select(fail, fail));
-//            }
-//            else
-//            {
-//                AtomicReference<Double> percentile = new AtomicReference<>();
-//                LatencySource set = v -> { percentile.set(v); return 0; };
-//                Wait.selector.select(set, set);
-//                Assert.assertNotNull(percentile.get());
-//                Assert.assertEquals(selectorPercentile, percentile.get(), 0.00001);
-//            }
-//            Assert.assertSame(modifierClass, Wait.modifier.getClass());
-//            Assert.assertEquals(1000000L * modifierVal, Wait.modifier.modify(1000000, 1), 0.00001);
-//        };
-//    }
-//
-//    private static void assertParseFailure(String spec)
-//    {
-//
-//        try
-//        {
-//            Wait Wait = parseWait(spec, 0, 0, 0);
-//            Assert.fail("expected parse failure, but got " + Wait);
-//        }
-//        catch (IllegalArgumentException e)
-//        {
-//            // expected
-//        }
-//    }
-//
-//    @Test
-//    public void strategyParseTest()
-//    {
-//        for (WaitParseValidator min : VALIDATE.stream().filter(v -> v.isMin).toArray(WaitParseValidator[]::new))
-//        {
-//            for (WaitParseValidator max : VALIDATE.stream().filter(v -> !v.isMin).toArray(WaitParseValidator[]::new))
-//            {
-//                for (WaitParseValidator minDelta : VALIDATE.stream().filter(v -> v.isMin).toArray(WaitParseValidator[]::new))
-//                {
-//                    for (WaitRandomizerParseValidator random : VALIDATE_RANDOMIZER)
-//                    {
-//                        {
-//                            ParsedStrategy parsed = parseStrategy("min=" + min.spec + ",max=" + max.spec + ",delta=" + minDelta.spec + ",random=" + random.spec, DEFAULT);
-//                            Assert.assertEquals(parsed.min, min.spec);
-//                            min.validate(parsed.strategy.min);
-//                            Assert.assertEquals(parsed.max, max.spec);
-//                            max.validate(parsed.strategy.max);
-//                            Assert.assertEquals(parsed.spread, minDelta.spec);
-//                            minDelta.validate(parsed.strategy.spread);
-//                            Assert.assertEquals(parsed.waitRandomizer, random.spec);
-//                            random.validate(parsed.strategy.waitRandomizer);
-//                        }
-//                        ParsedStrategy parsed = parseStrategy("random=" + random.spec, DEFAULT);
-//                        Assert.assertEquals(parsed.min, DEFAULT_MIN_VALIDATOR.spec);
-//                        DEFAULT_MIN_VALIDATOR.validate(parsed.strategy.min);
-//                        Assert.assertEquals(parsed.max, DEFAULT_MAX_VALIDATOR.spec);
-//                        DEFAULT_MAX_VALIDATOR.validate(parsed.strategy.max);
-//                        Assert.assertEquals(parsed.spread, DEFAULT_MIN_DELTA_VALIDATOR.spec);
-//                        DEFAULT_MIN_DELTA_VALIDATOR.validate(parsed.strategy.spread);
-//                        Assert.assertEquals(parsed.waitRandomizer, random.spec);
-//                        random.validate(parsed.strategy.waitRandomizer);
-//                    }
-//                    ParsedStrategy parsed = parseStrategy("delta=" + minDelta.spec, DEFAULT);
-//                    Assert.assertEquals(parsed.min, DEFAULT_MIN_VALIDATOR.spec);
-//                    DEFAULT_MIN_VALIDATOR.validate(parsed.strategy.min);
-//                    Assert.assertEquals(parsed.max, DEFAULT_MAX_VALIDATOR.spec);
-//                    DEFAULT_MAX_VALIDATOR.validate(parsed.strategy.max);
-//                    Assert.assertEquals(parsed.spread, minDelta.spec);
-//                    minDelta.validate(parsed.strategy.spread);
-//                }
-//                ParsedStrategy parsed = parseStrategy("max=" + max.spec, DEFAULT);
-//                Assert.assertEquals(parsed.min, DEFAULT_MIN_VALIDATOR.spec);
-//                DEFAULT_MIN_VALIDATOR.validate(parsed.strategy.min);
-//                Assert.assertEquals(parsed.max, max.spec);
-//                max.validate(parsed.strategy.max);
-//                Assert.assertEquals(parsed.spread, DEFAULT_MIN_DELTA_VALIDATOR.spec);
-//                DEFAULT_MIN_DELTA_VALIDATOR.validate(parsed.strategy.spread);
-//            }
-//            ParsedStrategy parsed = parseStrategy("min=" + min.spec, DEFAULT);
-//            Assert.assertEquals(parsed.min, min.spec);
-//            min.validate(parsed.strategy.min);
-//            Assert.assertEquals(parsed.max, DEFAULT_MAX_VALIDATOR.spec);
-//            DEFAULT_MAX_VALIDATOR.validate(parsed.strategy.max);
-//            Assert.assertEquals(parsed.spread, DEFAULT_MIN_DELTA_VALIDATOR.spec);
-//            DEFAULT_MIN_DELTA_VALIDATOR.validate(parsed.strategy.spread);
-//        }
-//    }
-//
-//    @Test
-//    public void testParseRoundTrip()
-//    {
-//        LatencySupplierFactory selectorFactory = new LatencySupplierFactory()
-//        {
-//            LatencySupplierFactory delegate = TimeoutStrategy.selectors;
-//            public LatencySelector constant(long latency) { return selector(delegate.constant(latency), String.format("%dms", latency)); }
-//            public LatencySelector read(double percentile) { return selector(delegate.read(percentile), String.format("p%d(r)", (int) (percentile * 100))); }
-//            public LatencySelector write(double percentile) { return selector(delegate.write(percentile), String.format("p%d(w)", (int) (percentile * 100))); }
-//            public LatencySelector maxReadWrite(double percentile) { return selector(delegate.maxReadWrite(percentile), String.format("p%d(rw)", (int) percentile * 100)); }
-//
-//            private LatencySelector selector(LatencySelector selector, String str) {
-//                return new LatencySelector()
-//                {
-//                    public long select(LatencySupplier read, LatencySupplier write)
-//                    {
-//                        return selector.select(read, write);
-//                    }
-//
-//                    public String toString()
-//                    {
-//                        return str;
-//                    }
-//                };
-//            }
-//        };
-//
-//        LatencyModifierFactory modifierFactory = new LatencyModifierFactory()
-//        {
-//            LatencyModifierFactory delegate = modifiers;
-//            public LatencyModifier identity() { return modifier(delegate.identity(), ""); }
-//            public LatencyModifier multiply(double constant) { return modifier(delegate.multiply(constant), String.format(" * %.2f", constant)); }
-//            public LatencyModifier multiplyByAttempts(double multiply) { return modifier(delegate.multiplyByAttempts(multiply), String.format(" * %.2f * attempts", multiply)); }
-//            public LatencyModifier multiplyByAttemptsExp(double base) { return modifier(delegate.multiplyByAttemptsExp(base), String.format(" * %.2f ^ attempts", base)); }
-//
-//            private LatencyModifier modifier(LatencyModifier modifier, String str) {
-//                return new LatencyModifier()
-//                {
-//                    @Inline
-//                    public long modify(long latency, int attempts)
-//                    {
-//                        return modifier.modify(latency, attempts);
-//                    }
-//
-//                    public String toString()
-//                    {
-//                        return str;
-//                    }
-//                };
-//            }
-//        };
-//
-//        LatencyModifier[] latencyModifiers = new LatencyModifier[]{
-//        modifierFactory.multiply(0.5),
-//        modifierFactory.multiplyByAttempts(0.5),
-//        modifierFactory.multiplyByAttemptsExp(0.5)
-//        };
-//
-//        LatencySelector[] latencySelectors = new LatencySelector[]{
-//        selectorFactory.read(0.5),
-//        selectorFactory.write(0.5),
-//        selectorFactory.maxReadWrite(0.99)
-//        };
-//
-//        for (boolean min : new boolean[] { true, false})
-//        {
-//            String left = min ? "10ms <= " : "";
-//            for (boolean max : new boolean[] { true, false})
-//            {
-//                String right = max ? " <= 10ms" : "";
-//
-//                for (LatencySelector selector : latencySelectors)
-//                {
-//                    for (LatencyModifier modifier : latencyModifiers)
-//                    {
-//                        String mid = String.format("%s%s", selector, modifier);
-//                        String input = left + mid + right;
-//                        Wait Wait = parseWait(input, 0, MAX, MAX, selectorFactory, modifierFactory);
-//                        Assert.assertTrue(String.format("Wait: %d" , Wait.min), !min || Wait.min == 10000);
-//                        Assert.assertTrue(String.format("Wait: %d" , Wait.max), !max || Wait.max == 10000);
-//                        Assert.assertEquals(selector.toString(), Wait.selector.toString());
-//                        Assert.assertEquals(modifier.toString(), Wait.modifier.toString());
-//                    }
-//                }
-//            }
-//        }
-//    }
-//
-//    @Test
-//    public void WaitParseTest()
-//    {
-//        VALIDATE.forEach(v -> v.validate(parseWait(v.spec, 0, MAX, v.isMin ? 0 : MAX)));
-//    }
-//
-//    @Test
-//    public void waitRandomizerParseTest()
-//    {
-//        VALIDATE_RANDOMIZER.forEach(v -> v.validate(parseWaitRandomizer(v.spec)));
-//    }
-//
-//    @Test
-//    public void waitRandomizerSampleTest()
-//    {
-//        waitRandomizerSampleTest(2);
-//    }
-//
-//    private void waitRandomizerSampleTest(int count)
-//    {
-//        while (count-- > 0)
-//        {
-//            long seed = ThreadLocalRandom.current().nextLong();
-//            logger.info("Seed {}", seed);
-//            for (WaitRandomizerType type : WaitRandomizerType.values())
-//            {
-//                WaitRandomizerOutputValidator.validate(type, seed, 100, 1000000);
-//            }
-//        }
-//    }
-//
-//    @Test
-//    public void WaitParseFailureTest()
-//    {
-//        assertParseFailure("10ms <= p95(r) <= 5ms");
-//        assertParseFailure("10 <= p95(r)");
-//        assertParseFailure("10 <= 20 <= 30");
-//        assertParseFailure("p95(r) < 5");
-//        assertParseFailure("p95(x)");
-//        assertParseFailure("p95()");
-//        assertParseFailure("p95");
-//        assertParseFailure("p50(rw)+0.66");
-//    }
-//
-//    @Test
-//    public void testBackoffTime()
-//    {
-//        RetryStrategy strategy = parseStrategy("min=0ms,max=100ms,random=uniform", DEFAULT).strategy;
-//        double total = 0;
-//        int count = 100000;
-//        for (int i = 0 ; i < count ; ++i)
-//        {
-//            long now = System.nanoTime();
-//            long waitUntil = strategy.computeWaitUntil(1);
-//            long waitLength = Math.max(waitUntil - now, 0);
-//            total += waitLength;
-//        }
-//        Assert.assertTrue(Math.abs(TimeUnit.MILLISECONDS.toNanos(50) - (total / count)) < TimeUnit.MILLISECONDS.toNanos(1L));
-//    }
-//
-//    @Test
-//    public void testBackoffTimeElapsed()
-//    {
-//        ContentionStrategy strategy = ContentionStrategy.parseStrategy("min=0ms,max=10ms,random=uniform").strategy;
-//        double total = 0;
-//        int count = 1000;
-//        for (int i = 0 ; i < count ; ++i)
-//        {
-//            long start = System.nanoTime();
-//            strategy.doWaitForContention(Long.MAX_VALUE, 1, null, null, null, null);
-//            long end = System.nanoTime();
-//            total += end - start;
-//        }
-//        // make sure we have slept at least 4ms on average, given a mean wait time of 5ms
-//        double avg = total / count;
-//        double nanos = avg - TimeUnit.MILLISECONDS.toNanos(4);
-//        Assert.assertTrue(nanos > 0);
-//    }
-//}
diff --git a/test/unit/org/apache/cassandra/service/accord/AccordStateCacheTest.java b/test/unit/org/apache/cassandra/service/accord/AccordStateCacheTest.java
index 6f10d977b2..50dd331e8f 100644
--- a/test/unit/org/apache/cassandra/service/accord/AccordStateCacheTest.java
+++ b/test/unit/org/apache/cassandra/service/accord/AccordStateCacheTest.java
@@ -428,7 +428,7 @@ public class AccordStateCacheTest
             instance.release(item);
         }
 
-        assertCacheState(cache, 0, 4, nodeSize(1) * 3 + nodeSize(3));
+        assertCacheState(cache, 0, 4, nodeSize(1) * 3 + nodeSize(2));
         assertCacheMetrics(cache.metrics, 0, 4, 4);
         assertCacheMetrics(instance.instanceMetrics, 0, 4, 4);
 
@@ -464,7 +464,7 @@ public class AccordStateCacheTest
 
         safeString.set("11");
         instance.release(safeString);
-        assertCacheState(cache, 0, 1, nodeSize(3));
+        assertCacheState(cache, 0, 1, nodeSize(2));
         Assert.assertSame(safeString.global, cache.head());
         Assert.assertSame(safeString.global, cache.tail());
 
diff --git a/test/unit/org/apache/cassandra/tcm/ValidatingClusterMetadataService.java b/test/unit/org/apache/cassandra/tcm/ValidatingClusterMetadataService.java
index 0d7bbf7f8e..0f9ddf0f06 100644
--- a/test/unit/org/apache/cassandra/tcm/ValidatingClusterMetadataService.java
+++ b/test/unit/org/apache/cassandra/tcm/ValidatingClusterMetadataService.java
@@ -132,13 +132,7 @@ public class ValidatingClusterMetadataService extends StubClusterMetadataService
             }
 
             @Override
-            public LogState getLocalState(Epoch lowEpoch, Epoch highEpoch, boolean includeSnapshot, Retry.Deadline retryPolicy)
-            {
-                return getLogState(lowEpoch, highEpoch, includeSnapshot, retryPolicy);
-            }
-
-            @Override
-            public LogState getLogState(Epoch lowEpoch, Epoch highEpoch, boolean includeSnapshot, Retry.Deadline retryPolicy)
+            public LogState getLocalState(Epoch lowEpoch, Epoch highEpoch, boolean includeSnapshot)
             {
                 if (!epochs.containsKey(lowEpoch))
                     throw new AssertionError("Unknown epoch: " + lowEpoch);
@@ -147,7 +141,13 @@ public class ValidatingClusterMetadataService extends StubClusterMetadataService
                 int id = 0;
                 for (ClusterMetadata cm : epochs.subMap(lowEpoch, false, highEpoch, true).values())
                     entries.add(new Entry(new Entry.Id(id++), cm.epoch, new MockTransformer(cm)));
-                return new LogState(base, entries.build());
+                return new LogState(includeSnapshot ? base : null, entries.build());
+            }
+
+            @Override
+            public LogState getLogState(Epoch lowEpoch, Epoch highEpoch, boolean includeSnapshot, Retry.Deadline retryPolicy)
+            {
+                return getLocalState(lowEpoch, highEpoch, includeSnapshot);
             }
         };
     }
diff --git a/test/unit/org/apache/cassandra/tcm/log/DistributedLogStateTest.java b/test/unit/org/apache/cassandra/tcm/log/DistributedLogStateTest.java
index 37cee72373..656ee55510 100644
--- a/test/unit/org/apache/cassandra/tcm/log/DistributedLogStateTest.java
+++ b/test/unit/org/apache/cassandra/tcm/log/DistributedLogStateTest.java
@@ -102,9 +102,9 @@ public class DistributedLogStateTest extends LogStateTestBase
             }
 
             @Override
-            public LogState getLogState(Epoch since)
+            public LogReader reader()
             {
-                return reader.getLogState(since);
+                return reader;
             }
 
             @Override
diff --git a/test/unit/org/apache/cassandra/tcm/log/LocalStorageLogStateTest.java b/test/unit/org/apache/cassandra/tcm/log/LocalStorageLogStateTest.java
index 5bc6ec0fa8..196c69ed7e 100644
--- a/test/unit/org/apache/cassandra/tcm/log/LocalStorageLogStateTest.java
+++ b/test/unit/org/apache/cassandra/tcm/log/LocalStorageLogStateTest.java
@@ -90,9 +90,9 @@ public class LocalStorageLogStateTest extends LogStateTestBase
             }
 
             @Override
-            public LogState getLogState(Epoch since)
+            public LogReader reader()
             {
-                return storage.getLogState(since);
+                return storage;
             }
 
             @Override
diff --git a/test/unit/org/apache/cassandra/tcm/log/LogStateTestBase.java b/test/unit/org/apache/cassandra/tcm/log/LogStateTestBase.java
index c7df0141fb..5342930da0 100644
--- a/test/unit/org/apache/cassandra/tcm/log/LogStateTestBase.java
+++ b/test/unit/org/apache/cassandra/tcm/log/LogStateTestBase.java
@@ -20,18 +20,25 @@ package org.apache.cassandra.tcm.log;
 
 import java.io.IOException;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.List;
+import java.util.Objects;
+import java.util.stream.Stream;
 
 import org.junit.Before;
 import org.junit.Test;
 
+import accord.utils.Gen;
+import accord.utils.Gens;
 import org.apache.cassandra.dht.Murmur3Partitioner;
 import org.apache.cassandra.distributed.test.log.ClusterMetadataTestHelper;
 import org.apache.cassandra.tcm.ClusterMetadata;
 import org.apache.cassandra.tcm.Epoch;
 import org.apache.cassandra.tcm.MetadataSnapshots;
 import org.apache.cassandra.tcm.sequences.SequencesUtils;
+import org.assertj.core.api.Assertions;
 
+import static accord.utils.Property.qt;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
@@ -44,13 +51,42 @@ public abstract class LogStateTestBase
     static int EXTRA_ENTRIES = 2;
     static Epoch CURRENT_EPOCH = Epoch.create((NUM_SNAPSHOTS * SNAPSHOT_FREQUENCY) + EXTRA_ENTRIES);
     static Epoch LATEST_SNAPSHOT_EPOCH = Epoch.create(NUM_SNAPSHOTS * SNAPSHOT_FREQUENCY);
+    private static final Gen.LongGen EPOCH_GEN = rs -> rs.nextLong(0, CURRENT_EPOCH.getEpoch()) + 1;
+    private static final Gen<Between> BETWEEN_GEN = rs -> {
+        long a = EPOCH_GEN.nextLong(rs);
+        long b = EPOCH_GEN.nextLong(rs);
+        while (b == a)
+            b = EPOCH_GEN.nextLong(rs);
+        if (b < a)
+        {
+            long tmp = a;
+            a = b;
+            b = tmp;
+        }
+        return new Between(Epoch.create(a), Epoch.create(b));
+    };
+    private static final Gen<MetadataSnapshots> SNAPSHOTS_GEN = Gens.<MetadataSnapshots>oneOf()
+                                                                    .add(i -> MetadataSnapshots.NO_OP)
+                                                                    .add(i -> throwing())
+                                                                    .add(rs -> rs.nextBoolean() ? withCorruptSnapshots(LATEST_SNAPSHOT_EPOCH) : withAvailableSnapshots(LATEST_SNAPSHOT_EPOCH))
+                                                                    .add(rs -> {
+                                                                        Epoch[] queriedEpochs = new Epoch[NUM_SNAPSHOTS];
+                                                                        for (int i = 0; i < NUM_SNAPSHOTS; i++)
+                                                                            queriedEpochs[i] = SequencesUtils.epoch((NUM_SNAPSHOTS - i) * SNAPSHOT_FREQUENCY);
+                                                                        return rs.nextBoolean() ? withCorruptSnapshots(queriedEpochs) : withAvailableSnapshots(queriedEpochs);
+                                                                    })
+                                                                    .build();
 
     interface LogStateSUT
     {
         void cleanup() throws IOException;
         void insertRegularEntry() throws IOException;
         void snapshotMetadata() throws IOException;
-        LogState getLogState(Epoch since);
+        LogReader reader();
+        default LogState getLogState(Epoch since)
+        {
+            return reader().getLogState(since);
+        }
 
         // just for manually checking the test data
         void dumpTables() throws IOException;
@@ -113,6 +149,11 @@ public abstract class LogStateTestBase
             return list;
         }
 
+        @Override
+        public String toString()
+        {
+            return (corrupt ? "Corrupted" : "") + "Snapshots{" + Arrays.toString(Stream.of(expected).mapToLong(e -> e.getEpoch()).toArray()) + '}';
+        }
     };
 
     static MetadataSnapshots withCorruptSnapshots(Epoch ... expected)
@@ -135,6 +176,12 @@ public abstract class LogStateTestBase
                 fail("Did not expect to request a snapshot");
                 return null;
             }
+
+            @Override
+            public String toString()
+            {
+                return "Throwing";
+            }
         };
     }
 
@@ -244,6 +291,47 @@ public abstract class LogStateTestBase
         assertEntries(state.entries, since.nextEpoch(), CURRENT_EPOCH);
     }
 
+    @Test
+    public void getLogStateBetween()
+    {
+        qt().forAll(SNAPSHOTS_GEN, BETWEEN_GEN).check((snapshots, between) -> {
+            LogStateSUT sut = getSystemUnderTest(snapshots);
+            LogState state = sut.reader().getLogState(between.start, between.end, true);
+            Assertions.assertThat(state.entries).describedAs("with and without snapshot should have the same entries").isEqualTo(sut.reader().getLogState(between.start, between.end, false).entries);
+            Assertions.assertThat(state.baseState.epoch).isEqualTo(between.start);
+
+            List<Entry> entries = state.entries;
+            Assertions.assertThat(entries.size()).isEqualTo(between.end.getEpoch() - between.start.getEpoch());
+
+            long expected = between.start.nextEpoch().getEpoch();
+            for (Entry e : entries)
+            {
+                long actual = e.epoch.getEpoch();
+                Assertions.assertThat(actual).describedAs("Unexpected epoch").isEqualTo(expected);
+                expected++;
+            }
+        });
+    }
+
+    @Test
+    public void getEntriesBetween()
+    {
+        qt().forAll(SNAPSHOTS_GEN, BETWEEN_GEN).check((snapshots, between) -> {
+            LogStateSUT sut = getSystemUnderTest(snapshots);
+            LogReader.EntryHolder entries = sut.reader().getEntries(between.start, between.end);
+            Assertions.assertThat(entries.since).isEqualTo(between.start);
+            Assertions.assertThat(entries.entries.size()).isEqualTo(between.end.getEpoch() - between.start.getEpoch());
+
+            long expected = between.start.nextEpoch().getEpoch();
+            for (Entry e : entries.entries)
+            {
+                long actual = e.epoch.getEpoch();
+                Assertions.assertThat(actual).describedAs("Unexpected epoch").isEqualTo(expected);
+                expected++;
+            }
+        });
+    }
+
     private void assertEntries(List<Entry> entries, Epoch min, Epoch max)
     {
         int idx = 0;
@@ -255,4 +343,39 @@ public abstract class LogStateTestBase
         }
         assertEquals(idx, entries.size());
     }
+
+    private static class Between
+    {
+        private final Epoch start, end;
+
+        private Between(Epoch start, Epoch end)
+        {
+            this.start = start;
+            this.end = end;
+        }
+
+        @Override
+        public boolean equals(Object o)
+        {
+            if (this == o) return true;
+            if (o == null || getClass() != o.getClass()) return false;
+            Between between = (Between) o;
+            return start.equals(between.start) && end.equals(between.end);
+        }
+
+        @Override
+        public int hashCode()
+        {
+            return Objects.hash(start, end);
+        }
+
+        @Override
+        public String toString()
+        {
+            return "Between{" +
+                   "start=" + start.getEpoch() +
+                   ", end=" + end.getEpoch() +
+                   '}';
+        }
+    }
 }
