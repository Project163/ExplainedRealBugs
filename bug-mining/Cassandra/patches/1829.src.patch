diff --git a/CHANGES.txt b/CHANGES.txt
index c680f03597..a40420e543 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 1.1.6
+ * LCS will merge up to 32 L0 sstables as intended (CASSANDRA-4778)
  * NTS will default unconfigured DC replicas to zero (CASSANDRA-4675)
  * use default consistency level in counter validation if none is
    explicitly provide (CASSANDRA-4700)
diff --git a/src/java/org/apache/cassandra/db/compaction/LeveledManifest.java b/src/java/org/apache/cassandra/db/compaction/LeveledManifest.java
index dcff79a9c7..fcbd5cb4a2 100644
--- a/src/java/org/apache/cassandra/db/compaction/LeveledManifest.java
+++ b/src/java/org/apache/cassandra/db/compaction/LeveledManifest.java
@@ -59,7 +59,7 @@ public class LeveledManifest
      * uses a pessimistic estimate of how many keys overlap (none), so we risk wasting memory
      * or even OOMing when compacting highly overlapping sstables
      */
-    static int MAX_COMPACTING_L0 = 32;
+    private static final int MAX_COMPACTING_L0 = 32;
 
     private final ColumnFamilyStore cfs;
     private final List<SSTableReader>[] generations;
@@ -469,22 +469,16 @@ public class LeveledManifest
                     List<SSTableReader> ageSortedCandidates = new ArrayList<SSTableReader>(candidates);
                     Collections.sort(ageSortedCandidates, SSTable.maxTimestampComparator);
                     candidates = new HashSet<SSTableReader>(ageSortedCandidates.subList(0, MAX_COMPACTING_L0));
-                    if (SSTable.getTotalBytes(candidates) > maxSSTableSizeInBytes)
-                    {
-                        // add sstables from L1 that overlap candidates
-                        candidates.addAll(overlapping(candidates, generations[1]));
-                    }
-                    return candidates;
-                }
-
-                if (SSTable.getTotalBytes(candidates) > maxSSTableSizeInBytes)
-                {
-                    // add sstables from L1 that overlap candidates
-                    candidates.addAll(overlapping(candidates, generations[1]));
                     break;
                 }
             }
 
+            if (SSTable.getTotalBytes(candidates) > maxSSTableSizeInBytes)
+            {
+                // add sstables from L1 that overlap candidates
+                candidates.addAll(overlapping(candidates, generations[1]));
+            }
+
             return candidates;
         }
 
