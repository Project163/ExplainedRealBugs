diff --git a/CHANGES.txt b/CHANGES.txt
index a053130285..b39fe03b80 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 4.0
+ * Avoid creating empty compaction tasks after truncate (CASSANDRA-14780)
  * Fail incremental repair prepare phase if it encounters sstables from un-finalized sessions (CASSANDRA-14763)
  * Add a check for receiving digest response from transient node (CASSANDRA-14750)
  * Fail query on transient replica if coordinator only expects full data (CASSANDRA-14704)
diff --git a/src/java/org/apache/cassandra/db/compaction/PendingRepairManager.java b/src/java/org/apache/cassandra/db/compaction/PendingRepairManager.java
index 6763abfb60..1aa156fa78 100644
--- a/src/java/org/apache/cassandra/db/compaction/PendingRepairManager.java
+++ b/src/java/org/apache/cassandra/db/compaction/PendingRepairManager.java
@@ -136,7 +136,7 @@ class PendingRepairManager
         return getOrCreate(sstable.getSSTableMetadata().pendingRepair);
     }
 
-    private synchronized void removeSession(UUID sessionID)
+    private synchronized void removeSessionIfEmpty(UUID sessionID)
     {
         if (!strategies.containsKey(sessionID) || !strategies.get(sessionID).getSSTables().isEmpty())
             return;
@@ -147,8 +147,11 @@ class PendingRepairManager
 
     synchronized void removeSSTable(SSTableReader sstable)
     {
-        for (AbstractCompactionStrategy strategy : strategies.values())
-            strategy.removeSSTable(sstable);
+        for (Map.Entry<UUID, AbstractCompactionStrategy> entry : strategies.entrySet())
+        {
+            entry.getValue().removeSSTable(sstable);
+            removeSessionIfEmpty(entry.getKey());
+        }
     }
 
 
@@ -207,6 +210,8 @@ class PendingRepairManager
                 strategy.replaceSSTables(groupRemoved, groupAdded);
             else
                 strategy.addSSTables(groupAdded);
+
+            removeSessionIfEmpty(entry.getKey());
         }
     }
 
@@ -464,7 +469,7 @@ class PendingRepairManager
                 }
                 if (completed)
                 {
-                    removeSession(sessionID);
+                    removeSessionIfEmpty(sessionID);
                 }
             }
         }
diff --git a/test/unit/org/apache/cassandra/db/compaction/PendingRepairManagerTest.java b/test/unit/org/apache/cassandra/db/compaction/PendingRepairManagerTest.java
index d83e0633ea..4e645fd9f8 100644
--- a/test/unit/org/apache/cassandra/db/compaction/PendingRepairManagerTest.java
+++ b/test/unit/org/apache/cassandra/db/compaction/PendingRepairManagerTest.java
@@ -27,6 +27,7 @@ import com.google.common.collect.Lists;
 import org.junit.Assert;
 import org.junit.Test;
 
+import org.apache.cassandra.db.lifecycle.SSTableSet;
 import org.apache.cassandra.io.sstable.format.SSTableReader;
 import org.apache.cassandra.repair.consistent.LocalSessionAccessor;
 import org.apache.cassandra.utils.FBUtilities;
@@ -300,4 +301,18 @@ public class PendingRepairManagerTest extends AbstractPendingRepairTest
         prm.addSSTable(sstable);
         Assert.assertTrue(prm.hasDataForSession(repairID));
     }
+
+    @Test
+    public void noEmptyCompactionTask()
+    {
+        PendingRepairManager prm = csm.getPendingRepairManagers().get(0);
+        SSTableReader sstable = makeSSTable(false);
+        UUID id = UUID.randomUUID();
+        mutateRepaired(sstable, id, false);
+        prm.getOrCreate(sstable);
+        cfs.truncateBlocking();
+        Assert.assertFalse(cfs.getSSTables(SSTableSet.LIVE).iterator().hasNext());
+        Assert.assertNull(cfs.getCompactionStrategyManager().getNextBackgroundTask(0));
+
+    }
 }
