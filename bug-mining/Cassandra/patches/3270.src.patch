diff --git a/CHANGES.txt b/CHANGES.txt
index 71a66427f6..b4cb6fbd38 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 2.1.3
+ * Make read "defrag" async to reclaim memtables (CASSANDRA-8459)
  * Remove tmplink files for offline compactions (CASSANDRA-8321)
  * Reduce maxHintsInProgress (CASSANDRA-8415)
  * BTree updates may call provided update function twice (CASSANDRA-8018)
diff --git a/src/java/org/apache/cassandra/db/CollationController.java b/src/java/org/apache/cassandra/db/CollationController.java
index 1b22e703d5..4efcd9c933 100644
--- a/src/java/org/apache/cassandra/db/CollationController.java
+++ b/src/java/org/apache/cassandra/db/CollationController.java
@@ -29,6 +29,8 @@ import com.google.common.collect.Iterables;
 import com.google.common.collect.Iterators;
 
 import net.nicoulaj.compilecommand.annotations.Inline;
+import org.apache.cassandra.concurrent.Stage;
+import org.apache.cassandra.concurrent.StageManager;
 import org.apache.cassandra.db.columniterator.OnDiskAtomIterator;
 import org.apache.cassandra.db.compaction.SizeTieredCompactionStrategy;
 import org.apache.cassandra.db.composites.CellName;
@@ -152,10 +154,18 @@ public class CollationController
                 && !cfs.isAutoCompactionDisabled()
                 && cfs.getCompactionStrategy().shouldDefragment())
             {
+                // !!WARNING!!   if we stop copying our data to a heap-managed object,
+                //               we will need to track the lifetime of this mutation as well
                 Tracing.trace("Defragmenting requested data");
-                Mutation mutation = new Mutation(cfs.keyspace.getName(), filter.key.getKey(), returnCF.cloneMe());
-                // skipping commitlog and index updates is fine since we're just de-fragmenting existing data
-                Keyspace.open(mutation.getKeyspaceName()).apply(mutation, false, false);
+                final Mutation mutation = new Mutation(cfs.keyspace.getName(), filter.key.getKey(), returnCF.cloneMe());
+                StageManager.getStage(Stage.MUTATION).execute(new Runnable()
+                {
+                    public void run()
+                    {
+                        // skipping commitlog and index updates is fine since we're just de-fragmenting existing data
+                        Keyspace.open(mutation.getKeyspaceName()).apply(mutation, false, false);
+                    }
+                });
             }
 
             // Caller is responsible for final removeDeletedCF.  This is important for cacheRow to work correctly:
