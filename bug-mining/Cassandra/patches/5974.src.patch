diff --git a/CHANGES.txt b/CHANGES.txt
index 2e3478c268..8ed2fcf54f 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 4.1
+ * Support DELETE in CQLSSTableWriter (CASSANDRA-14797)
  * Failed inbound internode authentication failures generate ugly warning with stack trace (CASSANDRA-17068)
  * Expose gossip information in system_views.gossip_info virtual table (CASSANDRA-17002)
  * Add guardrails for collection items and size (CASSANDRA-17153)
diff --git a/src/java/org/apache/cassandra/cql3/statements/ModificationStatement.java b/src/java/org/apache/cassandra/cql3/statements/ModificationStatement.java
index 7a467ce543..354f739bb1 100644
--- a/src/java/org/apache/cassandra/cql3/statements/ModificationStatement.java
+++ b/src/java/org/apache/cassandra/cql3/statements/ModificationStatement.java
@@ -790,7 +790,7 @@ public abstract class ModificationStatement implements CQLStatement.SingleKeyspa
         }
     }
 
-    Slices createSlices(QueryOptions options)
+    public Slices createSlices(QueryOptions options)
     {
         SortedSet<ClusteringBound<?>> startBounds = restrictions.getClusteringColumnsBounds(Bound.START, options);
         SortedSet<ClusteringBound<?>> endBounds = restrictions.getClusteringColumnsBounds(Bound.END, options);
diff --git a/src/java/org/apache/cassandra/io/sstable/CQLSSTableWriter.java b/src/java/org/apache/cassandra/io/sstable/CQLSSTableWriter.java
index 204bdd9ded..1500f3417c 100644
--- a/src/java/org/apache/cassandra/io/sstable/CQLSSTableWriter.java
+++ b/src/java/org/apache/cassandra/io/sstable/CQLSSTableWriter.java
@@ -25,7 +25,7 @@ import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
-import java.util.SortedSet;
+import java.util.NavigableSet;
 import java.util.concurrent.TimeUnit;
 import java.util.stream.Collectors;
 
@@ -43,8 +43,10 @@ import org.apache.cassandra.cql3.functions.UDHelper;
 import org.apache.cassandra.cql3.functions.types.TypeCodec;
 import org.apache.cassandra.cql3.functions.types.UserType;
 import org.apache.cassandra.cql3.statements.ModificationStatement;
-import org.apache.cassandra.cql3.statements.UpdateStatement;
 import org.apache.cassandra.db.Clustering;
+import org.apache.cassandra.db.Slice;
+import org.apache.cassandra.db.Slices;
+import org.apache.cassandra.db.SystemKeyspace;
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.dht.IPartitioner;
 import org.apache.cassandra.dht.Murmur3Partitioner;
@@ -74,7 +76,7 @@ import static org.apache.cassandra.utils.Clock.Global.currentTimeMillis;
  *   String insert = "INSERT INTO myKs.myTable (k, v1, v2, v3) VALUES (?, ?, ?, ?)";
  *
  *   // Creates a new writer. You need to provide at least the directory where to write the created sstable,
- *   // the schema for the sstable to write and a (prepared) insert statement to use. If you do not use the
+ *   // the schema for the sstable to write and a (prepared) modification statement to use. If you do not use the
  *   // default partitioner (Murmur3Partitioner), you will also need to provide the partitioner in use, see
  *   // CQLSSTableWriter.Builder for more details on the available options.
  *   CQLSSTableWriter writer = CQLSSTableWriter.builder()
@@ -111,14 +113,14 @@ public class CQLSSTableWriter implements Closeable
     }
 
     private final AbstractSSTableSimpleWriter writer;
-    private final UpdateStatement insert;
+    private final ModificationStatement modificationStatement;
     private final List<ColumnSpecification> boundNames;
     private final List<TypeCodec> typeCodecs;
 
-    private CQLSSTableWriter(AbstractSSTableSimpleWriter writer, UpdateStatement insert, List<ColumnSpecification> boundNames)
+    private CQLSSTableWriter(AbstractSSTableSimpleWriter writer, ModificationStatement modificationStatement, List<ColumnSpecification> boundNames)
     {
         this.writer = writer;
-        this.insert = insert;
+        this.modificationStatement = modificationStatement;
         this.boundNames = boundNames;
         this.typeCodecs = boundNames.stream().map(bn ->  UDHelper.codecFor(UDHelper.driverType(bn.type)))
                                              .collect(Collectors.toList());
@@ -140,7 +142,7 @@ public class CQLSSTableWriter implements Closeable
      * This is a shortcut for {@code addRow(Arrays.asList(values))}.
      *
      * @param values the row values (corresponding to the bind variables of the
-     * insertion statement used when creating by this writer).
+     * modification statement used when creating by this writer).
      * @return this writer.
      */
     public CQLSSTableWriter addRow(Object... values)
@@ -161,7 +163,7 @@ public class CQLSSTableWriter implements Closeable
      * {@link #rawAddRow} instead.
      *
      * @param values the row values (corresponding to the bind variables of the
-     * insertion statement used when creating by this writer).
+     * modification statement used when creating by this writer).
      * @return this writer.
      */
     public CQLSSTableWriter addRow(List<Object> values)
@@ -184,7 +186,7 @@ public class CQLSSTableWriter implements Closeable
      * <p>
      * This is equivalent to the other addRow methods, but takes a map whose
      * keys are the names of the columns to add instead of taking a list of the
-     * values in the order of the insert statement used during construction of
+     * values in the order of the modification statement used during construction of
      * this write.
      * <p>
      * Please note that the column names in the map keys must be in lowercase unless
@@ -195,7 +197,7 @@ public class CQLSSTableWriter implements Closeable
      * @param values a map of colum name to column values representing the new
      * row to add. Note that if a column is not part of the map, it's value will
      * be {@code null}. If the map contains keys that does not correspond to one
-     * of the column of the insert statement used when creating this writer, the
+     * of the column of the modification statement used when creating this writer, the
      * the corresponding value is ignored.
      * @return this writer.
      */
@@ -217,7 +219,7 @@ public class CQLSSTableWriter implements Closeable
      * Adds a new row to the writer given already serialized values.
      *
      * @param values the row values (corresponding to the bind variables of the
-     * insertion statement used when creating by this writer) as binary.
+     * modification statement used when creating by this writer) as binary.
      * @return this writer.
      */
     public CQLSSTableWriter rawAddRow(ByteBuffer... values)
@@ -232,7 +234,7 @@ public class CQLSSTableWriter implements Closeable
      * This is a shortcut for {@code rawAddRow(Arrays.asList(values))}.
      *
      * @param values the row values (corresponding to the bind variables of the
-     * insertion statement used when creating by this writer) as binary.
+     * modification statement used when creating by this writer) as binary.
      * @return this writer.
      */
     public CQLSSTableWriter rawAddRow(List<ByteBuffer> values)
@@ -243,27 +245,40 @@ public class CQLSSTableWriter implements Closeable
 
         QueryOptions options = QueryOptions.forInternalCalls(null, values);
         ClientState state = ClientState.forInternalCalls();
-        List<ByteBuffer> keys = insert.buildPartitionKeyNames(options, state);
-        SortedSet<Clustering<?>> clusterings = insert.createClustering(options, state);
+        List<ByteBuffer> keys = modificationStatement.buildPartitionKeyNames(options, state);
 
         long now = currentTimeMillis();
         // Note that we asks indexes to not validate values (the last 'false' arg below) because that triggers a 'Keyspace.open'
         // and that forces a lot of initialization that we don't want.
-        UpdateParameters params = new UpdateParameters(insert.metadata,
-                                                       insert.updatedColumns(),
+        UpdateParameters params = new UpdateParameters(modificationStatement.metadata,
+                                                       modificationStatement.updatedColumns(),
                                                        ClientState.forInternalCalls(),
                                                        options,
-                                                       insert.getTimestamp(TimeUnit.MILLISECONDS.toMicros(now), options),
+                                                       modificationStatement.getTimestamp(TimeUnit.MILLISECONDS.toMicros(now), options),
                                                        options.getNowInSec((int) TimeUnit.MILLISECONDS.toSeconds(now)),
-                                                       insert.getTimeToLive(options),
+                                                       modificationStatement.getTimeToLive(options),
                                                        Collections.emptyMap());
 
         try
         {
-            for (ByteBuffer key : keys)
+            if (modificationStatement.hasSlices()) {
+                Slices slices = modificationStatement.createSlices(options);
+
+                for (ByteBuffer key : keys)
+                {
+                    for (Slice slice : slices)
+                        modificationStatement.addUpdateForKey(writer.getUpdateFor(key), slice, params);
+                }
+            }
+            else
             {
-                for (Clustering<?> clustering : clusterings)
-                    insert.addUpdateForKey(writer.getUpdateFor(key), clustering, params);
+                NavigableSet<Clustering<?>> clusterings = modificationStatement.createClustering(options, state);
+
+                for (ByteBuffer key : keys)
+                {
+                    for (Clustering clustering : clusterings)
+                        modificationStatement.addUpdateForKey(writer.getUpdateFor(key), clustering, params);
+                }
             }
             return this;
         }
@@ -280,13 +295,13 @@ public class CQLSSTableWriter implements Closeable
      * <p>
      * This is equivalent to the other rawAddRow methods, but takes a map whose
      * keys are the names of the columns to add instead of taking a list of the
-     * values in the order of the insert statement used during construction of
+     * values in the order of the modification statement used during construction of
      * this write.
      *
      * @param values a map of colum name to column values representing the new
      * row to add. Note that if a column is not part of the map, it's value will
      * be {@code null}. If the map contains keys that does not correspond to one
-     * of the column of the insert statement used when creating this writer, the
+     * of the column of the modification statement used when creating this writer, the
      * the corresponding value is ignored.
      * @return this writer.
      */
@@ -312,7 +327,7 @@ public class CQLSSTableWriter implements Closeable
      */
     public UserType getUDType(String dataType)
     {
-        KeyspaceMetadata ksm = Schema.instance.getKeyspaceMetadata(insert.keyspace());
+        KeyspaceMetadata ksm = Schema.instance.getKeyspaceMetadata(modificationStatement.keyspace());
         org.apache.cassandra.db.marshal.UserType userType = ksm.types.getNullable(ByteBufferUtil.bytes(dataType));
         return (UserType) UDHelper.driverType(userType);
     }
@@ -355,7 +370,7 @@ public class CQLSSTableWriter implements Closeable
 
         private CreateTableStatement.Raw schemaStatement;
         private final List<CreateTypeStatement.Raw> typeStatements;
-        private ModificationStatement.Parsed insertStatement;
+        private ModificationStatement.Parsed modificationStatement;
         private IPartitioner partitioner;
 
         private boolean sorted = false;
@@ -444,24 +459,26 @@ public class CQLSSTableWriter implements Closeable
         }
 
         /**
-         * The INSERT or UPDATE statement defining the order of the values to add for a given CQL row.
+         * The INSERT, UPDATE, or DELETE statement defining the order of the values to add for a given CQL row.
          * <p>
-         * Please note that the provided INSERT statement <b>must</b> use a fully-qualified
+         * Please note that the provided statement <b>must</b> use a fully-qualified
          * table name, one that include the keyspace name. Moreover, said statement must use
          * bind variables since these variables will be bound to values by the resulting writer.
          * <p>
          * This is a mandatory option.
          *
-         * @param insert an insertion statement that defines the order
+         * @param modificationStatement an insert, update, or delete statement that defines the order
          * of column values to use.
          * @return this builder.
          *
-         * @throws IllegalArgumentException if {@code insertStatement} is not a valid insertion
+         * @throws IllegalArgumentException if {@code modificationStatement} is not a valid insert, update, or delete
          * statement, does not have a fully-qualified table name or have no bind variables.
          */
-        public Builder using(String insert)
+        public Builder using(String modificationStatement)
         {
-            this.insertStatement = QueryProcessor.parseStatement(insert, ModificationStatement.Parsed.class, "INSERT/UPDATE");
+            this.modificationStatement = QueryProcessor.parseStatement(modificationStatement,
+                                                                       ModificationStatement.Parsed.class,
+                                                                       "INSERT/UPDATE/DELETE");
             return this;
         }
 
@@ -489,7 +506,7 @@ public class CQLSSTableWriter implements Closeable
          * <p>
          * If this option is used, the resulting writer will expect rows to be
          * added in SSTable sorted order (and an exception will be thrown if that
-         * is not the case during insertion). The SSTable sorted order means that
+         * is not the case during modification). The SSTable sorted order means that
          * rows are added such that their partition key respect the partitioner
          * order.
          * <p>
@@ -514,8 +531,8 @@ public class CQLSSTableWriter implements Closeable
                 throw new IllegalStateException("No ouptut directory specified, you should provide a directory with inDirectory()");
             if (schemaStatement == null)
                 throw new IllegalStateException("Missing schema, you should provide the schema for the SSTable to create with forTable()");
-            if (insertStatement == null)
-                throw new IllegalStateException("No insert statement specified, you should provide an insert statement through using()");
+            if (modificationStatement == null)
+                throw new IllegalStateException("No modification (INSERT/UPDATE/DELETE) statement specified, you should provide a modification statement through using()");
 
             Preconditions.checkState(Sets.difference(SchemaConstants.LOCAL_SYSTEM_KEYSPACE_NAMES, Schema.instance.getKeyspaces()).isEmpty(),
                                      "Local keyspaces were not loaded. If this is running as a client, please make sure to add %s=true system property.", Schema.FORCE_LOAD_LOCAL_KEYSPACES_PROP);
@@ -542,17 +559,17 @@ public class CQLSSTableWriter implements Closeable
                     Schema.instance.transform(SchemaTransformations.addTable(tableMetadata, true));
                 }
 
-                UpdateStatement preparedInsert = prepareInsert();
+                ModificationStatement preparedModificationStatement = prepareModificationStatement();
 
                 TableMetadataRef ref = TableMetadataRef.forOfflineTools(tableMetadata);
                 AbstractSSTableSimpleWriter writer = sorted
-                                                   ? new SSTableSimpleWriter(directory, ref, preparedInsert.updatedColumns())
-                                                   : new SSTableSimpleUnsortedWriter(directory, ref, preparedInsert.updatedColumns(), bufferSizeInMiB);
+                                                     ? new SSTableSimpleWriter(directory, ref, preparedModificationStatement.updatedColumns())
+                                                     : new SSTableSimpleUnsortedWriter(directory, ref, preparedModificationStatement.updatedColumns(), bufferSizeInMiB);
 
                 if (formatType != null)
                     writer.setSSTableFormatType(formatType);
 
-                return new CQLSSTableWriter(writer, preparedInsert, preparedInsert.getBindVariables());
+                return new CQLSSTableWriter(writer, preparedModificationStatement, preparedModificationStatement.getBindVariables());
             }
         }
 
@@ -583,24 +600,24 @@ public class CQLSSTableWriter implements Closeable
         }
 
         /**
-         * Prepares insert statement for writing data to SSTable
+         * Prepares modification statement for writing data to SSTable
          *
-         * @return prepared Insert statement and it's bound names
+         * @return prepared modification statement and it's bound names
          */
-        private UpdateStatement prepareInsert()
+        private ModificationStatement prepareModificationStatement()
         {
             ClientState state = ClientState.forInternalCalls();
-            UpdateStatement insert = (UpdateStatement) insertStatement.prepare(state);
-            insert.validate(state);
+            ModificationStatement preparedModificationStatement = modificationStatement.prepare(state);
+            preparedModificationStatement.validate(state);
 
-            if (insert.hasConditions())
+            if (preparedModificationStatement.hasConditions())
                 throw new IllegalArgumentException("Conditional statements are not supported");
-            if (insert.isCounter())
-                throw new IllegalArgumentException("Counter update statements are not supported");
-            if (insert.getBindVariables().isEmpty())
-                throw new IllegalArgumentException("Provided insert statement has no bind variables");
+            if (preparedModificationStatement.isCounter())
+                throw new IllegalArgumentException("Counter modification statements are not supported");
+            if (preparedModificationStatement.getBindVariables().isEmpty())
+                throw new IllegalArgumentException("Provided preparedModificationStatement statement has no bind variables");
 
-            return insert;
+            return preparedModificationStatement;
         }
     }
 }
diff --git a/test/unit/org/apache/cassandra/io/sstable/CQLSSTableWriterTest.java b/test/unit/org/apache/cassandra/io/sstable/CQLSSTableWriterTest.java
index 92b627a228..ab3edc832c 100644
--- a/test/unit/org/apache/cassandra/io/sstable/CQLSSTableWriterTest.java
+++ b/test/unit/org/apache/cassandra/io/sstable/CQLSSTableWriterTest.java
@@ -165,7 +165,7 @@ public class CQLSSTableWriterTest
         }
         catch (IllegalArgumentException e)
         {
-            assertEquals(e.getMessage(), "Counter update statements are not supported");
+            assertEquals(e.getMessage(), "Counter modification statements are not supported");
         }
     }
 
@@ -222,7 +222,286 @@ public class CQLSSTableWriterTest
 
     }
 
+    @Test
+    public void testDeleteStatement() throws Exception
+    {
+
+        final String schema = "CREATE TABLE " + qualifiedTable + " ("
+                              + "  k int,"
+                              + "  c1 int,"
+                              + "  c2 int,"
+                              + "  v text,"
+                              + "  PRIMARY KEY (k, c1, c2)"
+                              + ")";
+
+        testUpdateStatement(); // start by adding some data
+        UntypedResultSet resultSet = QueryProcessor.executeInternal("SELECT * FROM " + qualifiedTable);
+        assertEquals(2, resultSet.size());
+
+        CQLSSTableWriter writer = CQLSSTableWriter.builder()
+                                                  .inDirectory(dataDir)
+                                                  .forTable(schema)
+                                                  .using("DELETE FROM " + qualifiedTable +
+                                                         " WHERE k = ? AND c1 = ? AND c2 = ?")
+                                                  .build();
+
+        writer.addRow(1, 2, 3);
+        writer.addRow(4, 5, 6);
+        writer.close();
+        loadSSTables(dataDir, keyspace);
+
+        resultSet = QueryProcessor.executeInternal("SELECT * FROM " + qualifiedTable);
+        assertEquals(0, resultSet.size());
+        Iterator<UntypedResultSet.Row> iter = resultSet.iterator();
+        assertFalse(iter.hasNext());
+    }
+
+    @Test
+    public void testDeletePartition() throws Exception
+    {
+
+        final String schema = "CREATE TABLE " + qualifiedTable + " ("
+                              + "  k int,"
+                              + "  c1 int,"
+                              + "  c2 int,"
+                              + "  v text,"
+                              + "  PRIMARY KEY (k, c1, c2)"
+                              + ")";
+
+        // First, write some rows
+        CQLSSTableWriter writer = CQLSSTableWriter.builder()
+                                                  .inDirectory(dataDir)
+                                                  .forTable(schema)
+                                                  .using("INSERT INTO " + qualifiedTable + " (k, c1, c2, v) " +
+                                                         "VALUES (?, ?, ?, ?)")
+                                                  .build();
+
+        writer.addRow(1, 2, 3, "a");
+        writer.addRow(1, 4, 5, "b");
+        writer.addRow(1, 6, 7, "c");
+        writer.addRow(2, 8, 9, "d");
+
+        writer.close();
+        loadSSTables(dataDir, keyspace);
+
+        UntypedResultSet resultSet = QueryProcessor.executeInternal("SELECT * FROM " + qualifiedTable);
+        assertEquals(4, resultSet.size());
+        Iterator<UntypedResultSet.Row> iter = resultSet.iterator();
+        UntypedResultSet.Row r1 = iter.next();
+        assertEquals(1, r1.getInt("k"));
+        assertEquals(2, r1.getInt("c1"));
+        assertEquals(3, r1.getInt("c2"));
+        assertEquals("a", r1.getString("v"));
+        UntypedResultSet.Row r2 = iter.next();
+        assertEquals(1, r2.getInt("k"));
+        assertEquals(4, r2.getInt("c1"));
+        assertEquals(5, r2.getInt("c2"));
+        assertEquals("b", r2.getString("v"));
+        UntypedResultSet.Row r3 = iter.next();
+        assertEquals(1, r3.getInt("k"));
+        assertEquals(6, r3.getInt("c1"));
+        assertEquals(7, r3.getInt("c2"));
+        assertEquals("c", r3.getString("v"));
+        UntypedResultSet.Row r4 = iter.next();
+        assertEquals(2, r4.getInt("k"));
+        assertEquals(8, r4.getInt("c1"));
+        assertEquals(9, r4.getInt("c2"));
+        assertEquals("d", r4.getString("v"));
+        assertFalse(iter.hasNext());
+
+        writer = CQLSSTableWriter.builder()
+                                 .inDirectory(dataDir)
+                                 .forTable(schema)
+                                 .using("DELETE FROM " + qualifiedTable +
+                                        " WHERE k = ?")
+                                 .build();
+
+        writer.addRow(1);
+        writer.close();
+        loadSSTables(dataDir, keyspace);
+
+        resultSet = QueryProcessor.executeInternal("SELECT * FROM " + qualifiedTable);
+        assertEquals(1, resultSet.size());
+        iter = resultSet.iterator();
+        UntypedResultSet.Row r5 = iter.next();
+        assertEquals(2, r5.getInt("k"));
+        assertEquals(8, r5.getInt("c1"));
+        assertEquals(9, r5.getInt("c2"));
+        assertEquals("d", r5.getString("v"));
+        assertFalse(iter.hasNext());
+    }
+
+    @Test
+    public void testDeleteRange() throws Exception
+    {
+
+        final String schema = "CREATE TABLE " + qualifiedTable + " ("
+                              + "  k text,"
+                              + "  c1 int,"
+                              + "  c2 int,"
+                              + "  v text,"
+                              + "  PRIMARY KEY (k, c1, c2)"
+                              + ")";
+
+        CQLSSTableWriter updateWriter = CQLSSTableWriter.builder()
+                                                        .inDirectory(dataDir)
+                                                        .forTable(schema)
+                                                        .using(String.format("UPDATE %s SET v=? WHERE k=? AND c1=? AND c2=?", qualifiedTable))
+                                                        .build();
+        CQLSSTableWriter deleteWriter = CQLSSTableWriter.builder()
+                                                        .inDirectory(dataDir)
+                                                        .forTable(schema)
+                                                        .using(String.format("DELETE FROM %s WHERE k=? AND c1=? and c2>=?", qualifiedTable))
+                                                        .build();
+
+        updateWriter.addRow("v0.0", "a", 0, 0);
+        updateWriter.addRow("v0.1", "a", 0, 1);
+        updateWriter.addRow("v0.2", "a", 0, 2);
+        updateWriter.addRow("v0.0", "b", 0, 0);
+        updateWriter.addRow("v0.1", "b", 0, 1);
+        updateWriter.addRow("v0.2", "b", 0, 2);
+        updateWriter.close();
+        deleteWriter.addRow("a", 0, 1);
+        deleteWriter.addRow("b", 0, 2);
+        deleteWriter.close();
+        loadSSTables(dataDir, keyspace);
+
+        UntypedResultSet resultSet = QueryProcessor.executeInternal("SELECT * FROM " + qualifiedTable);
+        assertEquals(3, resultSet.size());
+
+        Iterator<UntypedResultSet.Row> iter = resultSet.iterator();
+        UntypedResultSet.Row r1 = iter.next();
+        assertEquals("a", r1.getString("k"));
+        assertEquals(0, r1.getInt("c1"));
+        assertEquals(0, r1.getInt("c2"));
+        UntypedResultSet.Row r2 = iter.next();
+        assertEquals("b", r2.getString("k"));
+        assertEquals(0, r2.getInt("c1"));
+        assertEquals(0, r2.getInt("c2"));
+        UntypedResultSet.Row r3 = iter.next();
+        assertEquals("b", r3.getString("k"));
+        assertEquals(0, r3.getInt("c1"));
+        assertEquals(1, r3.getInt("c2"));
+    }
+
+    @Test
+    public void testDeleteRangeEmptyKeyComponent() throws Exception
+    {
+
+
+        final String schema = "CREATE TABLE " + qualifiedTable + " ("
+                              + "  k text,"
+                              + "  c1 int,"
+                              + "  c2 int,"
+                              + "  v text,"
+                              + "  PRIMARY KEY (k, c1, c2)"
+                              + ")";
+
+        CQLSSTableWriter updateWriter = CQLSSTableWriter.builder()
+                                                        .inDirectory(dataDir)
+                                                        .forTable(schema)
+                                                        .using(String.format("UPDATE %s SET v=? WHERE k=? AND c1=? AND c2=?", qualifiedTable))
+                                                        .build();
+        CQLSSTableWriter deleteWriter = CQLSSTableWriter.builder()
+                                                        .inDirectory(dataDir)
+                                                        .forTable(schema)
+                                                        .using(String.format("DELETE FROM %s WHERE k=? AND c1=?", qualifiedTable))
+                                                        .build();
+
+        updateWriter.addRow("v0.0", "a", 0, 0);
+        updateWriter.addRow("v0.1", "a", 0, 1);
+        updateWriter.addRow("v0.2", "a", 1, 2);
+        updateWriter.addRow("v0.0", "b", 0, 0);
+        updateWriter.addRow("v0.1", "b", 0, 1);
+        updateWriter.addRow("v0.2", "b", 1, 2);
+        updateWriter.close();
+        deleteWriter.addRow("a", 0);
+        deleteWriter.addRow("b", 0);
+        deleteWriter.close();
+        loadSSTables(dataDir, keyspace);
 
+        UntypedResultSet resultSet = QueryProcessor.executeInternal("SELECT * FROM " + qualifiedTable);
+        assertEquals(2, resultSet.size());
+
+        Iterator<UntypedResultSet.Row> iter = resultSet.iterator();
+        UntypedResultSet.Row r1 = iter.next();
+        assertEquals("a", r1.getString("k"));
+        assertEquals(1, r1.getInt("c1"));
+        assertEquals(2, r1.getInt("c2"));
+        UntypedResultSet.Row r2 = iter.next();
+        assertEquals("b", r2.getString("k"));
+        assertEquals(1, r2.getInt("c1"));
+        assertEquals(2, r2.getInt("c2"));
+    }
+
+    @Test
+    public void testDeleteValue() throws Exception
+    {
+        final String schema = "CREATE TABLE " + qualifiedTable + " ("
+                              + "  k text,"
+                              + "  c1 int,"
+                              + "  c2 int,"
+                              + "  v text,"
+                              + "  PRIMARY KEY (k, c1, c2)"
+                              + ")";
+
+        CQLSSTableWriter insertWriter = CQLSSTableWriter.builder()
+                                                        .inDirectory(dataDir)
+                                                        .forTable(schema)
+                                                        .using(String.format("INSERT INTO %s (v, k, c1, c2) values (?, ?, ?, ?)", qualifiedTable))
+                                                        .build();
+
+        // UPDATE does not set the row's liveness information, just the cells'. So when we delete the value from rows
+        // added with the updateWriter, the entire row will no longer exist, not just the value.
+        CQLSSTableWriter updateWriter = CQLSSTableWriter.builder()
+                                                        .inDirectory(dataDir)
+                                                        .forTable(schema)
+                                                        .using(String.format("UPDATE %s SET v=? WHERE k=? AND c1=? AND c2=?", qualifiedTable))
+                                                        .build();
+
+        CQLSSTableWriter deleteWriter = CQLSSTableWriter.builder()
+                                                  .inDirectory(dataDir)
+                                                  .forTable(schema)
+                                                  .using("DELETE v FROM " + qualifiedTable +
+                                                         " WHERE k = ? AND c1 = ? AND c2 = ?")
+                                                  .build();
+
+        insertWriter.addRow("v0.2", "a", 1, 2);
+        insertWriter.close();
+
+        updateWriter.addRow("v0.3", "b", 3, 4);
+        updateWriter.close();
+
+        loadSSTables(dataDir, keyspace);
+
+        UntypedResultSet resultSet = QueryProcessor.executeInternal("SELECT * FROM " + qualifiedTable);
+        assertEquals(2, resultSet.size());
+        Iterator<UntypedResultSet.Row> iter = resultSet.iterator();
+        UntypedResultSet.Row insertedRow = iter.next();
+        assertEquals("v0.2", insertedRow.getString("v"));
+        assertEquals("a", insertedRow.getString("k"));
+        assertEquals(1, insertedRow.getInt("c1"));
+        assertEquals(2, insertedRow.getInt("c2"));
+        UntypedResultSet.Row updatedRow = iter.next();
+        assertEquals("v0.3", updatedRow.getString("v"));
+        assertEquals("b", updatedRow.getString("k"));
+        assertEquals(3, updatedRow.getInt("c1"));
+        assertEquals(4, updatedRow.getInt("c2"));
+
+        deleteWriter.addRow("a", 1, 2);
+        deleteWriter.addRow("b", 3, 4);
+        deleteWriter.close();
+        loadSSTables(dataDir, keyspace);
+
+        resultSet = QueryProcessor.executeInternal("SELECT * FROM " + qualifiedTable);
+        assertEquals(1, resultSet.size());
+        iter = resultSet.iterator();
+        UntypedResultSet.Row modifiedRow = iter.next();
+        assertFalse(modifiedRow.has("v"));
+        assertEquals("a", modifiedRow.getString("k"));
+        assertEquals(1, modifiedRow.getInt("c1"));
+        assertEquals(2, modifiedRow.getInt("c2"));
+    }
 
     private static final int NUMBER_WRITES_IN_RUNNABLE = 10;
     private class WriterThread extends Thread
