diff --git a/CHANGES.txt b/CHANGES.txt
index da74896808..b7cc394f89 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -20,6 +20,7 @@
  * Correctly handle prepared operation on collections (CASSANDRA-4945)
  * Fix CQL3 LIMIT (CASSANDRA-4877)
  * Fix Stress for CQL3 (CASSANDRA-4979)
+ * Remove cassandra specific exceptions from JMX interface (CASSANDRA-4893)
 Merged from 1.1:
  * add basic authentication support for Pig CassandraStorage (CASSANDRA-3042)
  * fix CQL2 ALTER TABLE compaction_strategy_class altering (CASSANDRA-4965)
diff --git a/src/java/org/apache/cassandra/db/ColumnFamilyStore.java b/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
index 7e4355ab01..9cb4c66edc 100644
--- a/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
+++ b/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
@@ -206,10 +206,17 @@ public class ColumnFamilyStore implements ColumnFamilyStoreMBean
         }
     }
 
-    public void setCompactionStrategyClass(String compactionStrategyClass) throws ConfigurationException
+    public void setCompactionStrategyClass(String compactionStrategyClass)
     {
-        metadata.compactionStrategyClass = CFMetaData.createCompactionStrategy(compactionStrategyClass);
-        maybeReloadCompactionStrategy();
+        try
+        {
+            metadata.compactionStrategyClass = CFMetaData.createCompactionStrategy(compactionStrategyClass);
+            maybeReloadCompactionStrategy();
+        }
+        catch (ConfigurationException e)
+        {
+            throw new IllegalArgumentException(e.getMessage());
+        }
     }
 
     public String getCompactionStrategyClass()
@@ -222,9 +229,16 @@ public class ColumnFamilyStore implements ColumnFamilyStoreMBean
         return metadata.compressionParameters().asThriftOptions();
     }
 
-    public void setCompressionParameters(Map<String,String> opts) throws ConfigurationException
+    public void setCompressionParameters(Map<String,String> opts)
     {
-        metadata.compressionParameters = CompressionParameters.create(opts);
+        try
+        {
+            metadata.compressionParameters = CompressionParameters.create(opts);
+        }
+        catch (ConfigurationException e)
+        {
+            throw new IllegalArgumentException(e.getMessage());
+        }
     }
 
     private ColumnFamilyStore(Table table,
diff --git a/src/java/org/apache/cassandra/db/ColumnFamilyStoreMBean.java b/src/java/org/apache/cassandra/db/ColumnFamilyStoreMBean.java
index 39ed7030ac..3388b9bb23 100644
--- a/src/java/org/apache/cassandra/db/ColumnFamilyStoreMBean.java
+++ b/src/java/org/apache/cassandra/db/ColumnFamilyStoreMBean.java
@@ -21,8 +21,6 @@ import java.util.List;
 import java.util.Map;
 import java.util.concurrent.ExecutionException;
 
-import org.apache.cassandra.exceptions.ConfigurationException;
-
 /**
  * The MBean interface for ColumnFamilyStore
  */
@@ -260,7 +258,7 @@ public interface ColumnFamilyStoreMBean
      * Sets the compaction strategy by class name
      * @param className the name of the compaction strategy class
      */
-    public void setCompactionStrategyClass(String className) throws ConfigurationException;
+    public void setCompactionStrategyClass(String className);
 
     /**
      * Gets the compaction strategy class name
@@ -276,7 +274,7 @@ public interface ColumnFamilyStoreMBean
      * Set the compression parameters
      * @param opts map of string names to values
      */
-    public void setCompressionParameters(Map<String,String> opts) throws ConfigurationException;
+    public void setCompressionParameters(Map<String,String> opts);
 
     /**
      * Disable automatic compaction.
diff --git a/src/java/org/apache/cassandra/service/PBSPredictor.java b/src/java/org/apache/cassandra/service/PBSPredictor.java
index f4f3353db3..64d19de2b8 100644
--- a/src/java/org/apache/cassandra/service/PBSPredictor.java
+++ b/src/java/org/apache/cassandra/service/PBSPredictor.java
@@ -26,8 +26,6 @@ import java.util.concurrent.LinkedBlockingQueue;
 import javax.management.MBeanServer;
 import javax.management.ObjectName;
 
-import org.apache.cassandra.thrift.InvalidRequestException;
-
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -313,7 +311,7 @@ public class PBSPredictor implements PBSPredictorMBean
                                             int w,
                                             float timeSinceWrite,
                                             int numberVersionsStale,
-                                            float percentileLatency) throws Exception
+                                            float percentileLatency)
     {
         if (r > n)
             throw new IllegalArgumentException("r must be less than n");
@@ -329,7 +327,7 @@ public class PBSPredictor implements PBSPredictorMBean
             throw new IllegalArgumentException("numberVersionsStale must be positive");
 
         if (!logLatencies)
-            throw new InvalidRequestException("Latency logging is not enabled");
+            throw new IllegalStateException("Latency logging is not enabled");
 
         // get a mapping of {replica number : latency} for each of WARS
         Map<Integer, List<Long>> wLatencies = getOrderedWLatencies();
@@ -338,10 +336,10 @@ public class PBSPredictor implements PBSPredictorMBean
         Map<Integer, List<Long>> sLatencies = getOrderedSLatencies();
 
         if (wLatencies.isEmpty() || aLatencies.isEmpty())
-            throw new InvalidRequestException("No write latencies have been recorded so far. Run some (non-local) inserts.");
+            throw new IllegalStateException("No write latencies have been recorded so far. Run some (non-local) inserts.");
 
         if (rLatencies.isEmpty() || sLatencies.isEmpty())
-            throw new InvalidRequestException("No read latencies have been recorded so far. Run some (non-local) reads.");
+            throw new IllegalStateException("No read latencies have been recorded so far. Run some (non-local) reads.");
 
         // storage for simulated read and write latencies
         ArrayList<Long> readLatencies = new ArrayList<Long>();
diff --git a/src/java/org/apache/cassandra/service/PBSPredictorMBean.java b/src/java/org/apache/cassandra/service/PBSPredictorMBean.java
index 8c7773db50..1e2f31afc0 100644
--- a/src/java/org/apache/cassandra/service/PBSPredictorMBean.java
+++ b/src/java/org/apache/cassandra/service/PBSPredictorMBean.java
@@ -25,7 +25,7 @@ public interface PBSPredictorMBean
                                             int w,
                                             float timeSinceWrite, 
                                             int numberVersionsStale,
-                                            float percentileLatency) throws Exception;
+                                            float percentileLatency);
 
     public void enableConsistencyPredictionLogging();
     public void disableConsistencyPredictionLogging();
diff --git a/src/java/org/apache/cassandra/service/StorageService.java b/src/java/org/apache/cassandra/service/StorageService.java
index 567d82963c..4bf6ba70ff 100644
--- a/src/java/org/apache/cassandra/service/StorageService.java
+++ b/src/java/org/apache/cassandra/service/StorageService.java
@@ -51,6 +51,7 @@ import org.apache.cassandra.dht.*;
 import org.apache.cassandra.dht.Range;
 import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.exceptions.InvalidRequestException;
+import org.apache.cassandra.exceptions.UnavailableException;
 import org.apache.cassandra.gms.*;
 import org.apache.cassandra.io.sstable.SSTableDeletingTask;
 import org.apache.cassandra.io.sstable.SSTableLoader;
@@ -752,12 +753,19 @@ public class StorageService implements IEndpointStateChangeSubscriber, StorageSe
         Gossiper.instance.addLocalApplicationState(ApplicationState.RACK, StorageService.instance.valueFactory.rack(rack));
     }
 
-    public synchronized void joinRing() throws IOException, ConfigurationException
+    public synchronized void joinRing() throws IOException
     {
         if (!joined)
         {
             logger.info("Joining ring by operator request");
-            joinTokenRing(0);
+            try
+            {
+                joinTokenRing(0);
+            }
+            catch (ConfigurationException e)
+            {
+                throw new IOException(e.getMessage());
+            }
         }
         else if (isSurveyMode)
         {
@@ -984,12 +992,18 @@ public class StorageService implements IEndpointStateChangeSubscriber, StorageSe
      * @param keyspace The keyspace to fetch information about
      *
      * @return a List of TokenRange(s) converted to String for the given keyspace
-     *
-     * @throws InvalidRequestException if there is no ring information available about keyspace
      */
-    public List<String> describeRingJMX(String keyspace) throws InvalidRequestException
+    public List<String> describeRingJMX(String keyspace) throws IOException
     {
-        List<TokenRange> tokenRanges = describeRing(keyspace);
+        List<TokenRange> tokenRanges = null;
+        try
+        {
+            tokenRanges = describeRing(keyspace);
+        }
+        catch (InvalidRequestException e)
+        {
+            throw new IOException(e.getMessage());
+        }
         List<String> result = new ArrayList<String>(tokenRanges.size());
 
         for (TokenRange tokenRange : tokenRanges)
@@ -2641,9 +2655,16 @@ public class StorageService implements IEndpointStateChangeSubscriber, StorageSe
         onFinish.run();
     }
 
-    public void move(String newToken) throws IOException, InterruptedException, ConfigurationException
+    public void move(String newToken) throws IOException
     {
-        getPartitioner().getTokenFactory().validate(newToken);
+        try
+        {
+            getPartitioner().getTokenFactory().validate(newToken);
+        }
+        catch (ConfigurationException e)
+        {
+            throw new IOException(e.getMessage());
+        }
         move(getPartitioner().getTokenFactory().fromString(newToken));
     }
 
@@ -2830,13 +2851,20 @@ public class StorageService implements IEndpointStateChangeSubscriber, StorageSe
         }
     }
 
-    public void relocate(Collection<String> srcTokens) throws ConfigurationException
+    public void relocate(Collection<String> srcTokens) throws IOException
     {
         List<Token> tokens = new ArrayList<Token>(srcTokens.size());
-        for (String srcT : srcTokens)
+        try
+        {
+            for (String srcT : srcTokens)
+            {
+                getPartitioner().getTokenFactory().validate(srcT);
+                tokens.add(getPartitioner().getTokenFactory().fromString(srcT));
+            }
+        }
+        catch (ConfigurationException e)
         {
-            getPartitioner().getTokenFactory().validate(srcT);
-            tokens.add(getPartitioner().getTokenFactory().fromString(srcT));
+            throw new IOException(e.getMessage());
         }
         relocateTokens(tokens);
     }
@@ -3164,10 +3192,16 @@ public class StorageService implements IEndpointStateChangeSubscriber, StorageSe
         return old;
     }
 
-    public void truncate(String keyspace, String columnFamily)
-    throws org.apache.cassandra.exceptions.UnavailableException, TimeoutException, IOException
+    public void truncate(String keyspace, String columnFamily) throws TimeoutException, IOException
     {
-        StorageProxy.truncateBlocking(keyspace, columnFamily);
+        try
+        {
+            StorageProxy.truncateBlocking(keyspace, columnFamily);
+        }
+        catch (UnavailableException e)
+        {
+            throw new IOException(e.getMessage());
+        }
     }
 
     public boolean isDcAwareReplicationStrategy(String keyspace)
@@ -3193,14 +3227,14 @@ public class StorageService implements IEndpointStateChangeSubscriber, StorageSe
      * on the number of replicas within itself. For DC unaware replication strategies, ownership without replication
      * will be 100%.
      *
-     * @throws ConfigurationException
+     * @throws IllegalStateException when node is not configured properly.
      */
-    public LinkedHashMap<InetAddress, Float> effectiveOwnership(String keyspace) throws ConfigurationException
+    public LinkedHashMap<InetAddress, Float> effectiveOwnership(String keyspace) throws IllegalStateException
     {
         if (Schema.instance.getNonSystemTables().size() <= 0)
-            throw new ConfigurationException("Couldn't find any Non System Keyspaces to infer replication topology");
+            throw new IllegalStateException("Couldn't find any Non System Keyspaces to infer replication topology");
         if (keyspace == null && !hasSameReplication(Schema.instance.getNonSystemTables()))
-            throw new ConfigurationException("Non System keyspaces doesnt have the same topology");
+            throw new IllegalStateException("Non System keyspaces doesnt have the same topology");
 
         TokenMetadata metadata = tokenMetadata.cloneOnlyTokenMap();
 
@@ -3259,12 +3293,20 @@ public class StorageService implements IEndpointStateChangeSubscriber, StorageSe
         return Collections.unmodifiableList(tableslist);
     }
 
-    public void updateSnitch(String epSnitchClassName, Boolean dynamic, Integer dynamicUpdateInterval, Integer dynamicResetInterval, Double dynamicBadnessThreshold) throws ConfigurationException
+    public void updateSnitch(String epSnitchClassName, Boolean dynamic, Integer dynamicUpdateInterval, Integer dynamicResetInterval, Double dynamicBadnessThreshold) throws ClassNotFoundException
     {
         IEndpointSnitch oldSnitch = DatabaseDescriptor.getEndpointSnitch();
 
         // new snitch registers mbean during construction
-        IEndpointSnitch newSnitch = FBUtilities.construct(epSnitchClassName, "snitch");
+        IEndpointSnitch newSnitch = null;
+        try
+        {
+            newSnitch = FBUtilities.construct(epSnitchClassName, "snitch");
+        }
+        catch (ConfigurationException e)
+        {
+            throw new ClassNotFoundException(e.getMessage());
+        }
         if (dynamic)
         {
             DatabaseDescriptor.setDynamicUpdateInterval(dynamicUpdateInterval);
diff --git a/src/java/org/apache/cassandra/service/StorageServiceMBean.java b/src/java/org/apache/cassandra/service/StorageServiceMBean.java
index e51184a395..0176b1d79b 100644
--- a/src/java/org/apache/cassandra/service/StorageServiceMBean.java
+++ b/src/java/org/apache/cassandra/service/StorageServiceMBean.java
@@ -27,11 +27,6 @@ import java.util.Map;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.TimeoutException;
 
-import org.apache.cassandra.exceptions.ConfigurationException;
-import org.apache.cassandra.exceptions.InvalidRequestException;
-import org.apache.cassandra.exceptions.UnavailableException;
-
-
 public interface StorageServiceMBean
 {
     /**
@@ -139,10 +134,8 @@ public interface StorageServiceMBean
      * @param keyspace The keyspace to fetch information about
      *
      * @return a List of TokenRange(s) converted to String for the given keyspace
-     *
-     * @throws InvalidRequestException if there is no ring information available about keyspace
      */
-    public List <String> describeRingJMX(String keyspace) throws InvalidRequestException;
+    public List <String> describeRingJMX(String keyspace) throws IOException;
 
     /**
      * Returns the local node's primary range.
@@ -291,13 +284,12 @@ public interface StorageServiceMBean
      * @param newToken token to move this node to.
      * This node will unload its data onto its neighbors, and bootstrap to the new token.
      */
-    public void move(String newToken) throws IOException, InterruptedException, ConfigurationException;
+    public void move(String newToken) throws IOException;
 
     /**
      * @param srcTokens tokens to move to this node
-     * @throws ConfigurationException when passed an invalid token string
      */
-    public void relocate(Collection<String> srcTokens) throws ConfigurationException;
+    public void relocate(Collection<String> srcTokens) throws IOException;
 
     /**
      * removeToken removes token (and all data associated with
@@ -336,10 +328,8 @@ public interface StorageServiceMBean
      *
      * @param keyspace The keyspace to delete from
      * @param columnFamily The column family to delete data from.
-     *
-     * @throws UnavailableException if some of the hosts in the ring are down.
      */
-    public void truncate(String keyspace, String columnFamily) throws UnavailableException, TimeoutException, IOException;
+    public void truncate(String keyspace, String columnFamily)throws TimeoutException, IOException;
 
     /**
      * given a list of tokens (representing the nodes in the cluster), returns
@@ -354,7 +344,7 @@ public interface StorageServiceMBean
      * in the cluster have the same replication strategies and if yes then we will
      * use the first else a empty Map is returned.
      */
-    public Map<InetAddress, Float> effectiveOwnership(String keyspace) throws ConfigurationException;
+    public Map<InetAddress, Float> effectiveOwnership(String keyspace) throws IllegalStateException;
 
     public List<String> getKeyspaces();
 
@@ -365,9 +355,8 @@ public interface StorageServiceMBean
      * @param dynamicUpdateInterval    integer, in ms (default 100)
      * @param dynamicResetInterval     integer, in ms (default 600,000)
      * @param dynamicBadnessThreshold  double, (default 0.0)
-     * @throws ConfigurationException  classname not found on classpath
      */
-    public void updateSnitch(String epSnitchClassName, Boolean dynamic, Integer dynamicUpdateInterval, Integer dynamicResetInterval, Double dynamicBadnessThreshold) throws ConfigurationException;
+    public void updateSnitch(String epSnitchClassName, Boolean dynamic, Integer dynamicUpdateInterval, Integer dynamicResetInterval, Double dynamicBadnessThreshold) throws ClassNotFoundException;
 
     // allows a user to forcibly 'kill' a sick node
     public void stopGossiping();
@@ -392,7 +381,7 @@ public interface StorageServiceMBean
     public boolean isNativeTransportRunning();
 
     // allows a node that have been started without joining the ring to join it
-    public void joinRing() throws IOException, ConfigurationException;
+    public void joinRing() throws IOException;
     public boolean isJoined();
 
     public int getExceptionCount();
diff --git a/src/java/org/apache/cassandra/tools/NodeCmd.java b/src/java/org/apache/cassandra/tools/NodeCmd.java
index 11a78e211d..ecd9e3c52d 100644
--- a/src/java/org/apache/cassandra/tools/NodeCmd.java
+++ b/src/java/org/apache/cassandra/tools/NodeCmd.java
@@ -216,7 +216,7 @@ public class NodeCmd
             ownerships = probe.effectiveOwnership(keyspace);
             keyspaceSelected = true;
         }
-        catch (ConfigurationException ex)
+        catch (IllegalStateException ex)
         {
             ownerships = probe.getOwnership();
             outs.printf("Note: Ownership information does not include topology; for complete information, specify a keyspace%n");
@@ -434,7 +434,7 @@ public class NodeCmd
                 ownerships = probe.effectiveOwnership(kSpace);
                 hasEffectiveOwns = true;
             }
-            catch (ConfigurationException e)
+            catch (IllegalStateException e)
             {
                 ownerships = probe.getOwnership();
             }
@@ -1236,7 +1236,7 @@ public class NodeCmd
                 out.println("\t" + tokenRangeString);
             }
         }
-        catch (InvalidRequestException e)
+        catch (IOException e)
         {
             err(e, e.getMessage());
         }
diff --git a/src/java/org/apache/cassandra/tools/NodeProbe.java b/src/java/org/apache/cassandra/tools/NodeProbe.java
index 777412291b..34a80255bf 100644
--- a/src/java/org/apache/cassandra/tools/NodeProbe.java
+++ b/src/java/org/apache/cassandra/tools/NodeProbe.java
@@ -37,7 +37,6 @@ import javax.management.remote.JMXServiceURL;
 import com.google.common.collect.Iterables;
 
 import org.apache.cassandra.concurrent.JMXEnabledThreadPoolExecutorMBean;
-import org.apache.cassandra.exceptions.*;
 import org.apache.cassandra.db.ColumnFamilyStoreMBean;
 import org.apache.cassandra.db.compaction.CompactionManager;
 import org.apache.cassandra.db.compaction.CompactionManagerMBean;
@@ -269,7 +268,7 @@ public class NodeProbe
         return ssProxy.getOwnership();
     }
 
-    public Map<InetAddress, Float> effectiveOwnership(String keyspace) throws ConfigurationException
+    public Map<InetAddress, Float> effectiveOwnership(String keyspace) throws IllegalStateException
     {
         return ssProxy.effectiveOwnership(keyspace);
     }
@@ -395,7 +394,7 @@ public class NodeProbe
         return ssProxy.isJoined();
     }
 
-    public void joinRing() throws IOException, ConfigurationException
+    public void joinRing() throws IOException
     {
         ssProxy.joinRing();
     }
@@ -405,7 +404,7 @@ public class NodeProbe
         ssProxy.decommission();
     }
 
-    public void move(String newToken) throws IOException, InterruptedException, ConfigurationException
+    public void move(String newToken) throws IOException, InterruptedException
     {
         ssProxy.move(newToken);
     }
@@ -523,10 +522,6 @@ public class NodeProbe
         {
             ssProxy.truncate(tableName, cfName);
         }
-        catch (UnavailableException e)
-        {
-            throw new RuntimeException("Error while executing truncate", e);
-        }
         catch (TimeoutException e)
         {
             throw new RuntimeException("Error while executing truncate", e);
@@ -712,7 +707,7 @@ public class NodeProbe
         return ssProxy.getSchemaVersion();
     }
 
-    public List<String> describeRing(String keyspaceName) throws InvalidRequestException
+    public List<String> describeRing(String keyspaceName) throws IOException
     {
         return ssProxy.describeRingJMX(keyspaceName);
     }
