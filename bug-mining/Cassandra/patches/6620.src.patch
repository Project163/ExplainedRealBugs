diff --git a/CHANGES.txt b/CHANGES.txt
index 778cb533ac..04274279d7 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 5.1
+ * Invalidate relevant prepared statements on every change to TableMetadata (CASSANDRA-20318)
  * Add per type max size guardrails (CASSANDRA-19677)
  * Make it possible to abort all kinds of multi step operations (CASSANDRA-20217)
  * Do not leak non-Java exceptions when calling snapshot operations via JMX (CASSANDRA-20335)
diff --git a/src/java/org/apache/cassandra/schema/TableMetadata.java b/src/java/org/apache/cassandra/schema/TableMetadata.java
index 6e23a4bd08..4dcec20f92 100644
--- a/src/java/org/apache/cassandra/schema/TableMetadata.java
+++ b/src/java/org/apache/cassandra/schema/TableMetadata.java
@@ -691,19 +691,14 @@ public class TableMetadata implements SchemaElement
     }
 
     /**
-     * @return true if the change as made impacts queries/updates on the table,
-     *         e.g. any columns or indexes were added, removed, or altered; otherwise, false is returned.
+     * @return true if the change as made impacts queries/updates on the table, effectively this is
+     *              true if the metadata has changed in any way, as replicas compare metadata epochs
+     *              when performing reads & writes.
      *         Used to determine whether prepared statements against this table need to be re-prepared.
      */
     boolean changeAffectsPreparedStatements(TableMetadata updated)
     {
-        return !partitionKeyColumns.equals(updated.partitionKeyColumns)
-            || !clusteringColumns.equals(updated.clusteringColumns)
-            || !regularAndStaticColumns.equals(updated.regularAndStaticColumns)
-            || !indexes.equals(updated.indexes)
-            || params.defaultTimeToLive != updated.params.defaultTimeToLive
-            || params.gcGraceSeconds != updated.params.gcGraceSeconds
-            || ( !Flag.isCQLTable(flags) && Flag.isCQLTable(updated.flags) );
+        return epoch.isBefore(updated.epoch);
     }
 
     /**
diff --git a/src/java/org/apache/cassandra/schema/Views.java b/src/java/org/apache/cassandra/schema/Views.java
index 054db8bbca..dc5e7556d0 100644
--- a/src/java/org/apache/cassandra/schema/Views.java
+++ b/src/java/org/apache/cassandra/schema/Views.java
@@ -68,6 +68,11 @@ public final class Views implements Iterable<ViewMetadata>
         return NONE;
     }
 
+    public static Views of(Iterable<ViewMetadata> views)
+    {
+        return builder().put(views).build();
+    }
+
     public Iterator<ViewMetadata> iterator()
     {
         return views.values().iterator();
@@ -232,7 +237,7 @@ public final class Views implements Iterable<ViewMetadata>
         return ViewsDiff.diff(before, after);
     }
 
-    static final class ViewsDiff extends Diff<Views, ViewMetadata>
+    public static final class ViewsDiff extends Diff<Views, ViewMetadata>
     {
         private static final ViewsDiff NONE = new ViewsDiff(Views.none(), Views.none(), ImmutableList.of());
 
diff --git a/src/java/org/apache/cassandra/tcm/transformations/AlterSchema.java b/src/java/org/apache/cassandra/tcm/transformations/AlterSchema.java
index 93692f55ba..cec1d42ca8 100644
--- a/src/java/org/apache/cassandra/tcm/transformations/AlterSchema.java
+++ b/src/java/org/apache/cassandra/tcm/transformations/AlterSchema.java
@@ -43,6 +43,8 @@ import org.apache.cassandra.schema.ReplicationParams;
 import org.apache.cassandra.schema.SchemaTransformation;
 import org.apache.cassandra.schema.TableMetadata;
 import org.apache.cassandra.schema.Tables;
+import org.apache.cassandra.schema.ViewMetadata;
+import org.apache.cassandra.schema.Views;
 import org.apache.cassandra.tcm.ClusterMetadata;
 import org.apache.cassandra.tcm.ClusterMetadataService;
 import org.apache.cassandra.tcm.Epoch;
@@ -163,8 +165,9 @@ public class AlterSchema implements Transformation
             if (!keyspacesByReplication.containsKey(newKSM.params.replication))
                 affectsPlacements.add(newKSM);
 
-            Tables tables = Tables.of(normaliseEpochs(nextEpoch, newKSM.tables.stream()));
-            newKeyspaces = newKeyspaces.withAddedOrUpdated(newKSM.withSwapped(tables));
+            Tables tables = Tables.of(normaliseTableEpochs(nextEpoch, newKSM.tables.stream()));
+            Views views = Views.of(normaliseViewEpochs(nextEpoch, newKSM.views.stream()));
+            newKeyspaces = newKeyspaces.withAddedOrUpdated(newKSM.withSwapped(tables).withSwapped(views));
         }
 
         // Scan modified keyspaces to check for replication changes and to ensure that any modified table metadata
@@ -175,12 +178,20 @@ public class AlterSchema implements Transformation
                 affectsPlacements.add(alteredKSM.before);
 
             Tables tables = Tables.of(alteredKSM.after.tables);
-            for (TableMetadata created : normaliseEpochs(nextEpoch, alteredKSM.tables.created.stream()))
+            for (TableMetadata created : normaliseTableEpochs(nextEpoch, alteredKSM.tables.created.stream()))
                 tables = tables.withSwapped(created);
 
-            for (TableMetadata altered : normaliseEpochs(nextEpoch, alteredKSM.tables.altered.stream().map(altered -> altered.after)))
+            for (TableMetadata altered : normaliseTableEpochs(nextEpoch, alteredKSM.tables.altered.stream().map(altered -> altered.after)))
                 tables = tables.withSwapped(altered);
-            newKeyspaces = newKeyspaces.withAddedOrUpdated(alteredKSM.after.withSwapped(tables));
+
+            Views views = Views.of(alteredKSM.after.views);
+            for (ViewMetadata created : normaliseViewEpochs(nextEpoch, alteredKSM.views.created.stream()))
+                views = views.withSwapped(created);
+
+            for (ViewMetadata altered : normaliseViewEpochs(nextEpoch, alteredKSM.views.altered.stream().map(altered -> altered.after)))
+                views = views.withSwapped(altered);
+
+            newKeyspaces = newKeyspaces.withAddedOrUpdated(alteredKSM.after.withSwapped(tables).withSwapped(views));
         }
 
         // Changes which affect placement (i.e. new, removed or altered replication settings) are not allowed if there
@@ -236,7 +247,7 @@ public class AlterSchema implements Transformation
         return byReplication;
     }
 
-    private static Iterable<TableMetadata> normaliseEpochs(Epoch nextEpoch, Stream<TableMetadata> tables)
+    private static Iterable<TableMetadata> normaliseTableEpochs(Epoch nextEpoch, Stream<TableMetadata> tables)
     {
         return tables.map(tm -> tm.epoch.is(nextEpoch)
                                 ? tm
@@ -244,6 +255,13 @@ public class AlterSchema implements Transformation
                      .collect(Collectors.toList());
     }
 
+    private static Iterable<ViewMetadata> normaliseViewEpochs(Epoch nextEpoch, Stream<ViewMetadata> views)
+    {
+        return views.map(vm -> vm.metadata.epoch.is(nextEpoch)
+                                ? vm
+                                : vm.copy(vm.metadata.unbuild().epoch(nextEpoch).build()))
+                     .collect(Collectors.toList());
+    }
 
     static class Serializer implements AsymmetricMetadataSerializer<Transformation, AlterSchema>
     {
diff --git a/test/distributed/org/apache/cassandra/distributed/test/PreparedStatementInvalidationTest.java b/test/distributed/org/apache/cassandra/distributed/test/PreparedStatementInvalidationTest.java
new file mode 100644
index 0000000000..fe58dc91a9
--- /dev/null
+++ b/test/distributed/org/apache/cassandra/distributed/test/PreparedStatementInvalidationTest.java
@@ -0,0 +1,54 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.cassandra.distributed.test;
+
+import org.junit.Test;
+
+import com.datastax.driver.core.PreparedStatement;
+import com.datastax.driver.core.Session;
+import org.apache.cassandra.distributed.api.ICluster;
+import org.apache.cassandra.distributed.api.IInvokableInstance;
+
+import static org.apache.cassandra.distributed.api.Feature.GOSSIP;
+import static org.apache.cassandra.distributed.api.Feature.NATIVE_PROTOCOL;
+import static org.apache.cassandra.distributed.api.Feature.NETWORK;
+
+public class PreparedStatementInvalidationTest extends TestBaseImpl
+{
+    @Test
+    public void testInvalidation() throws Exception
+    {
+        try (ICluster<IInvokableInstance> c = init(builder().withNodes(2)
+                                                            .withConfig(config -> config.with(GOSSIP, NETWORK, NATIVE_PROTOCOL))
+                                                            .start()))
+        {
+            try (com.datastax.driver.core.Cluster cluster = com.datastax.driver.core.Cluster.builder()
+                                                                                            .addContactPoint("127.0.0.1")
+                                                                                            .build();
+                 Session s = cluster.connect())
+            {
+                s.execute(withKeyspace("CREATE TABLE %s.tbl (pk int primary key)"));
+                PreparedStatement prepared = s.prepare(withKeyspace("select pk from %s.tbl where pk = ?"));
+                s.execute(prepared.bind(1));
+                s.execute(withKeyspace("alter table %s.tbl with speculative_retry='none'"));
+                s.execute(prepared.bind(2));
+            }
+        }
+    }
+}
\ No newline at end of file
