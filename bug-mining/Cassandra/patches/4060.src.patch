diff --git a/CHANGES.txt b/CHANGES.txt
index 9c73adf250..74fd45b30e 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 2.1.13
+ * (cqlsh) fix cqlsh_copy_tests when vnodes are disabled (CASSANDRA-10997)
  * (cqlsh) fix formatting bytearray values (CASSANDRA-10839)
  * (cqlsh) Add request timeout option to cqlsh (CASSANDRA-10686)
  * Avoid AssertionError while submitting hint with LWT (CASSANDRA-10477)
diff --git a/pylib/cqlshlib/copyutil.py b/pylib/cqlshlib/copyutil.py
index 381701ef88..b015a770fb 100644
--- a/pylib/cqlshlib/copyutil.py
+++ b/pylib/cqlshlib/copyutil.py
@@ -492,30 +492,33 @@ class ExportTask(CopyTask):
         ring = shell.get_ring(self.ks).items()
         ring.sort()
 
-        #  If the ring is empty we get the entire ring from the host we are currently connected to
         if not ring:
+            #  If the ring is empty we get the entire ring from the host we are currently connected to
             ranges[(begin_token, end_token)] = make_range_data()
-            return ranges
-
-        first_range_data = None
-        previous = None
-        for token, replicas in ring:
-            if previous is None and token.value == min_token:
-                continue  # avoids looping entire ring
-
-            if previous is None:  # we use it at the end when wrapping around
-                first_range_data = make_range_data(replicas)
-
-            current_range = make_range(previous, token.value)
-            if not current_range:
-                continue
-
-            ranges[current_range] = make_range_data(replicas)
-            previous = token.value
-
-        #  For the last ring interval we query the same replicas that hold the first token in the ring
-        if previous is not None and (not end_token or previous < end_token):
-            ranges[(previous, end_token)] = first_range_data
+        elif len(ring) == 1:
+            #  If there is only one token we get the entire ring from the replicas for that token
+            ranges[(begin_token, end_token)] = make_range_data(ring[0][1])
+        else:
+            # else we loop on the ring
+            first_range_data = None
+            previous = None
+            for token, replicas in ring:
+                if not first_range_data:
+                    first_range_data = make_range_data(replicas)  # we use it at the end when wrapping around
+
+                if token.value == min_token:
+                    continue  # avoids looping entire ring
+
+                current_range = make_range(previous, token.value)
+                if not current_range:
+                    continue
+
+                ranges[current_range] = make_range_data(replicas)
+                previous = token.value
+
+            #  For the last ring interval we query the same replicas that hold the first token in the ring
+            if previous is not None and (not end_token or previous < end_token):
+                ranges[(previous, end_token)] = first_range_data
 
         if not ranges:
             shell.printerr('Found no ranges to query, check begin and end tokens: %s - %s' % (begin_token, end_token))
