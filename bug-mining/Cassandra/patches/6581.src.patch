diff --git a/CHANGES.txt b/CHANGES.txt
index f3b51f4972..842d8b0d94 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 5.1
+ * Check presence of a snapshot in a case-insensitive manner on macOS platform to prevent hardlinking failures (CASSANDRA-20146)
  * Enable JMX server configuration to be in cassandra.yaml (CASSANDRA-11695)
  * Parallelized UCS compactions (CASSANDRA-18802)
  * Avoid prepared statement invalidation race when committing schema changes (CASSANDRA-20116)
diff --git a/src/java/org/apache/cassandra/db/Directories.java b/src/java/org/apache/cassandra/db/Directories.java
index 12a64090f8..67b87d14e9 100644
--- a/src/java/org/apache/cassandra/db/Directories.java
+++ b/src/java/org/apache/cassandra/db/Directories.java
@@ -650,6 +650,18 @@ public class Directories
         }
     }
 
+    public static File getSnapshotDirectoryWithoutCreation(File location, String snapshotName)
+    {
+        if (isSecondaryIndexFolder(location))
+        {
+            return getWithoutCreation(location.parent(), SNAPSHOT_SUBDIR, snapshotName, location.name());
+        }
+        else
+        {
+            return getWithoutCreation(location, SNAPSHOT_SUBDIR, snapshotName);
+        }
+    }
+
     /**
      * Returns directory to write a snapshot to. If directory does not exist, then it is NOT created.
      *
@@ -683,6 +695,16 @@ public class Directories
         return snapshotDirs;
     }
 
+    public Set<File> getSnapshotDirsWithoutCreation(String tag)
+    {
+        Set<File> snapshotDirs = new HashSet<>();
+
+        for (File cfDir : getCFDirectories())
+            snapshotDirs.add(Directories.getSnapshotDirectoryWithoutCreation(cfDir, tag).toAbsolute());
+
+        return snapshotDirs;
+    }
+
     public File getSnapshotManifestFile(String snapshotName)
     {
         File snapshotDir = getSnapshotDirectory(getDirectoryForNewSSTables(), snapshotName);
@@ -1301,6 +1323,11 @@ public class Directories
         return dir.exists() ? Optional.of(dir) : Optional.empty();
     }
 
+    public static File getWithoutCreation(File base, String... subdirs)
+    {
+        return subdirs == null || subdirs.length == 0 ? base : new File(base, join(subdirs));
+    }
+
     private static String join(String... s)
     {
         return StringUtils.join(s, File.pathSeparator());
diff --git a/src/java/org/apache/cassandra/db/virtual/SnapshotsTable.java b/src/java/org/apache/cassandra/db/virtual/SnapshotsTable.java
index c757ce7c54..dada749e81 100644
--- a/src/java/org/apache/cassandra/db/virtual/SnapshotsTable.java
+++ b/src/java/org/apache/cassandra/db/virtual/SnapshotsTable.java
@@ -18,6 +18,7 @@
 
 package org.apache.cassandra.db.virtual;
 
+import java.time.Instant;
 import java.util.Date;
 
 import org.apache.cassandra.db.marshal.BooleanType;
@@ -64,12 +65,15 @@ public class SnapshotsTable extends AbstractVirtualTable
 
         for (TableSnapshot tableSnapshot : SnapshotManager.instance.getSnapshots(false, true))
         {
+            Instant snapshotCreatedAt = tableSnapshot.getCreatedAt();
+            Date createdAt = snapshotCreatedAt != null ? new Date(snapshotCreatedAt.toEpochMilli()) : null;
+
             SimpleDataSet row = result.row(tableSnapshot.getTag(),
                                            tableSnapshot.getKeyspaceName(),
                                            tableSnapshot.getTableName())
                                       .column(TRUE_SIZE, tableSnapshot.computeTrueSizeBytes())
                                       .column(SIZE_ON_DISK, tableSnapshot.computeSizeOnDiskBytes())
-                                      .column(CREATED_AT, new Date(tableSnapshot.getCreatedAt().toEpochMilli()));
+                                      .column(CREATED_AT, createdAt);
 
             if (tableSnapshot.isExpiring())
                 row.column(EXPIRES_AT, new Date(tableSnapshot.getExpiresAt().toEpochMilli()));
diff --git a/src/java/org/apache/cassandra/service/snapshot/TableSnapshot.java b/src/java/org/apache/cassandra/service/snapshot/TableSnapshot.java
index 94bcd07d9a..549dbb6db6 100644
--- a/src/java/org/apache/cassandra/service/snapshot/TableSnapshot.java
+++ b/src/java/org/apache/cassandra/service/snapshot/TableSnapshot.java
@@ -46,12 +46,16 @@ import org.apache.cassandra.io.sstable.SSTableId;
 import org.apache.cassandra.io.sstable.format.SSTableReader;
 import org.apache.cassandra.io.util.File;
 import org.apache.cassandra.io.util.FileUtils;
+import org.apache.cassandra.utils.FBUtilities;
+import org.apache.cassandra.utils.LocalizeString;
 import org.apache.cassandra.utils.Throwables;
 import org.apache.cassandra.utils.concurrent.Refs;
+import oshi.PlatformEnum;
 
 public class TableSnapshot
 {
     private static final Logger logger = LoggerFactory.getLogger(TableSnapshot.class);
+    private static final PlatformEnum PLATFORM = FBUtilities.getSystemInfo().platform();
 
     private final String keyspaceName;
     private final String tableName;
@@ -139,12 +143,14 @@ public class TableSnapshot
 
     public Instant getCreatedAt()
     {
-
         if (createdAt == null)
         {
             long minCreation = 0;
             for (File snapshotDir : snapshotDirs)
             {
+                if (!snapshotDir.exists())
+                    continue;
+
                 long lastModified = snapshotDir.lastModified();
                 if (lastModified == 0)
                     continue;
@@ -377,7 +383,27 @@ public class TableSnapshot
         return Objects.equals(keyspaceName, snapshot.keyspaceName) &&
                Objects.equals(tableName, snapshot.tableName) &&
                Objects.equals(tableId, snapshot.tableId) &&
-               Objects.equals(tag, snapshot.tag);
+               tagsEqual(tag, snapshot.tag);
+    }
+
+    private boolean tagsEqual(String tag1, String tag2)
+    {
+        if (tag1 == null && tag2 == null)
+            return true;
+
+        if (tag1 == null || tag2 == null)
+            return false;
+
+        // When hardlinks are created for a snapshot with the name "snapshot"
+        // and then we take a snapshot with the name "Snapshot", macOS platform thinks
+        // that this was already hardlinked because its hardlinking implementation
+        // does not seem to be case-sensitive. The fix consists of checking,
+        // in a case-insensitive manner, if there is already such snapshot,
+        // but only on macOS platform.
+        if (PLATFORM == PlatformEnum.MACOS)
+            return LocalizeString.toLowerCaseLocalized(tag1).equals(LocalizeString.toLowerCaseLocalized(tag2));
+
+        return Objects.equals(tag1, tag2);
     }
 
     @Override
diff --git a/src/java/org/apache/cassandra/service/snapshot/TakeSnapshotTask.java b/src/java/org/apache/cassandra/service/snapshot/TakeSnapshotTask.java
index 2b13459765..a0d81a685c 100644
--- a/src/java/org/apache/cassandra/service/snapshot/TakeSnapshotTask.java
+++ b/src/java/org/apache/cassandra/service/snapshot/TakeSnapshotTask.java
@@ -94,7 +94,7 @@ public class TakeSnapshotTask extends AbstractSnapshotTask<List<TableSnapshot>>
 
         for (ColumnFamilyStore cfs : entitiesForSnapshot)
         {
-            Set<File> snapshotDirs = cfs.getDirectories().getSnapshotDirs(snapshotName);
+            Set<File> snapshotDirs = cfs.getDirectories().getSnapshotDirsWithoutCreation(snapshotName);
 
             TableSnapshot tableSnapshot = new TableSnapshot(cfs.metadata.keyspace,
                                                             cfs.metadata.name,
diff --git a/test/distributed/org/apache/cassandra/distributed/test/SnapshotsTest.java b/test/distributed/org/apache/cassandra/distributed/test/SnapshotsTest.java
index 9ca5e05233..2c57654695 100644
--- a/test/distributed/org/apache/cassandra/distributed/test/SnapshotsTest.java
+++ b/test/distributed/org/apache/cassandra/distributed/test/SnapshotsTest.java
@@ -40,15 +40,21 @@ import org.apache.cassandra.distributed.api.IIsolatedExecutor.SerializableCallab
 import org.apache.cassandra.distributed.api.NodeToolResult;
 import org.apache.cassandra.distributed.shared.WithProperties;
 import org.apache.cassandra.utils.Clock;
+import org.apache.cassandra.utils.FBUtilities;
 
 import static java.lang.String.format;
 import static java.util.concurrent.TimeUnit.SECONDS;
 import static java.util.stream.Collectors.toList;
 import static org.apache.cassandra.distributed.shared.ClusterUtils.stopUnchecked;
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
 import static org.awaitility.Awaitility.await;
+import static org.hamcrest.CoreMatchers.is;
+import static org.hamcrest.CoreMatchers.not;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
+import static org.junit.Assume.assumeThat;
+import static oshi.PlatformEnum.MACOS;
 
 public class SnapshotsTest extends TestBaseImpl
 {
@@ -58,6 +64,9 @@ public class SnapshotsTest extends TestBaseImpl
     private static final WithProperties properties = new WithProperties();
     private static Cluster cluster;
 
+    private final String[] exoticSnapshotNamesOnMac = new String[]{ "snapshot", "snapshots", "backup", "backups",
+                                                                    "snapshot.with.dots-and-dashes" };
+
     private final String[] exoticSnapshotNames = new String[]{ "snapshot", "snapshots", "backup", "backups",
                                                                "Snapshot", "Snapshots", "Backups", "Backup",
                                                                "snapshot.with.dots-and-dashes" };
@@ -330,18 +339,24 @@ public class SnapshotsTest extends TestBaseImpl
     @Test
     public void testExoticSnapshotNames()
     {
-        IInvokableInstance instance = cluster.get(1);
-        cluster.schemaChange(withKeyspace("CREATE TABLE %s.tbl (key int, value text, PRIMARY KEY (key))"));
-        populate(cluster);
+        assumeThat(FBUtilities.getSystemInfo().platform(), not(MACOS));
+        exoticSnapshotNamesInternal(exoticSnapshotNames);
+    }
 
-        for (String tag : exoticSnapshotNames)
-        {
-            instance.nodetoolResult("snapshot",
-                                    "-t", tag,
-                                    "-kt", withKeyspace("%s.tbl")).asserts().success();
+    @Test
+    public void testExoticSnapshotNamesOnMacOS()
+    {
+        assumeThat(FBUtilities.getSystemInfo().platform(), is(MACOS));
+        exoticSnapshotNamesInternal(exoticSnapshotNamesOnMac);
+    }
 
-            waitForSnapshot(tag, true, true);
-        }
+    @Test
+    public void testDuplicateSnapshotOnMacOS()
+    {
+        assumeThat(FBUtilities.getSystemInfo().platform(), is(MACOS));
+        exoticSnapshotNamesInternal(new String[]{ "snapshot" });
+        assertThatThrownBy(() -> exoticSnapshotNamesInternal(new String[]{ "Snapshot" }))
+        .hasMessageContaining(withKeyspace("Snapshot Snapshot for %s.tbl already exists."));
     }
 
     @Test
@@ -435,4 +450,23 @@ public class SnapshotsTest extends TestBaseImpl
 
         return expectPresent == lines.stream().anyMatch(line -> line.startsWith(snapshotName));
     }
+
+    private void exoticSnapshotNamesInternal(String[] exoticSnapshotNames)
+    {
+        IInvokableInstance instance = cluster.get(1);
+        cluster.schemaChange(withKeyspace("CREATE TABLE IF NOT EXISTS %s.tbl (key int, value text, PRIMARY KEY (key))"));
+        populate(cluster);
+
+        for (String tag : exoticSnapshotNames)
+        {
+            NodeToolResult result = instance.nodetoolResult("snapshot",
+                                                            "-t", tag,
+                                                            "-kt", withKeyspace("%s.tbl"));
+
+            if (result.getRc() != 0)
+                throw new RuntimeException(result.getError());
+
+            waitForSnapshot(tag, true, true);
+        }
+    }
 }
