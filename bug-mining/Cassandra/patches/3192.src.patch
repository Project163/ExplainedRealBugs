diff --git a/CHANGES.txt b/CHANGES.txt
index 8c4fc1566d..544cf9a40b 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 2.0.11:
+ * Reject conditions on DELETE unless full PK is given (CASSANDRA-6430)
  * Properly reject the token function DELETE (CASSANDRA-7747)
  * Force batchlog replay before decommissioning a node (CASSANDRA-7446)
  * Fix hint replay with many accumulated expired hints (CASSANDRA-6998)
diff --git a/src/java/org/apache/cassandra/cql3/statements/DeleteStatement.java b/src/java/org/apache/cassandra/cql3/statements/DeleteStatement.java
index 902add42d2..6c1c6ed238 100644
--- a/src/java/org/apache/cassandra/cql3/statements/DeleteStatement.java
+++ b/src/java/org/apache/cassandra/cql3/statements/DeleteStatement.java
@@ -20,6 +20,8 @@ package org.apache.cassandra.cql3.statements;
 import java.nio.ByteBuffer;
 import java.util.*;
 
+import com.google.common.collect.Iterators;
+
 import org.apache.cassandra.cql3.*;
 import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.db.*;
@@ -92,6 +94,23 @@ public class DeleteStatement extends ModificationStatement
         }
     }
 
+    protected void validateWhereClauseForConditions() throws InvalidRequestException
+    {
+        Iterator<CFDefinition.Name> iterator = Iterators.concat(cfm.getCfDef().partitionKeys().iterator(), cfm.getCfDef().clusteringColumns().iterator());
+        while (iterator.hasNext())
+        {
+            CFDefinition.Name name = iterator.next();
+            Restriction restriction = processedKeys.get(name.name);
+            if (restriction == null || !(restriction.isEQ() || restriction.isIN()))
+            {
+                throw new InvalidRequestException(
+                        String.format("DELETE statements must restrict all PRIMARY KEY columns with equality relations in order " +
+                                      "to use IF conditions, but column '%s' is not restricted", name.name));
+            }
+        }
+
+    }
+
     public static class Parsed extends ModificationStatement.Parsed
     {
         private final List<Operation.RawDeletion> deletions;
diff --git a/src/java/org/apache/cassandra/cql3/statements/ModificationStatement.java b/src/java/org/apache/cassandra/cql3/statements/ModificationStatement.java
index 006873d56c..adb00848a2 100644
--- a/src/java/org/apache/cassandra/cql3/statements/ModificationStatement.java
+++ b/src/java/org/apache/cassandra/cql3/statements/ModificationStatement.java
@@ -62,7 +62,7 @@ public abstract class ModificationStatement implements CQLStatement, MeasurableF
     public final CFMetaData cfm;
     public final Attributes attrs;
 
-    private final Map<ColumnIdentifier, Restriction> processedKeys = new HashMap<ColumnIdentifier, Restriction>();
+    protected final Map<ColumnIdentifier, Restriction> processedKeys = new HashMap<>();
     private final List<Operation> columnOperations = new ArrayList<Operation>();
 
     private int boundTerms;
@@ -747,6 +747,16 @@ public abstract class ModificationStatement implements CQLStatement, MeasurableF
         return new UpdateParameters(cfm, variables, getTimestamp(now, variables), getTimeToLive(variables), rows);
     }
 
+    /**
+     * If there are conditions on the statement, this is called after the where clause and conditions have been
+     * processed to check that they are compatible.
+     * @throws InvalidRequestException
+     */
+    protected void validateWhereClauseForConditions() throws InvalidRequestException
+    {
+        //  no-op by default
+    }
+
     public static abstract class Parsed extends CFStatement
     {
         protected final Attributes.Raw attrs;
@@ -827,6 +837,8 @@ public abstract class ModificationStatement implements CQLStatement, MeasurableF
                         }
                     }
                 }
+
+                stmt.validateWhereClauseForConditions();
             }
 
             stmt.boundTerms = boundNames.getCollectedCount() - collected;
