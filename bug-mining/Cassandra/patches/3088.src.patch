diff --git a/CHANGES.txt b/CHANGES.txt
index 4d5d851a5e..e716cb5ebc 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,6 @@
 2.0.11:
+ * Always reject inequality on the partition key without token()
+   (CASSANDRA-7722)
  * Always send Paxos commit to all replicas (CASSANDRA-7479)
 
 2.0.10
diff --git a/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java b/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
index 814572243f..a360d495b0 100644
--- a/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
+++ b/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
@@ -1709,6 +1709,11 @@ public class SelectStatement implements CQLStatement, MeasurableForPreparedCache
                         existingRestriction = new SingleColumnRestriction.Slice(newRel.onToken);
                     else if (!existingRestriction.isSlice())
                         throw new InvalidRequestException(String.format("Column \"%s\" cannot be restricted by both an equality and an inequality relation", name));
+                    else if (existingRestriction.isOnToken() != newRel.onToken)
+                        // For partition keys, we shouldn't have slice restrictions without token(). And while this is rejected later by
+                        // processPartitionKeysRestrictions, we shouldn't update the existing restriction by the new one if the old one was using token()
+                        // and the new one isn't since that would bypass that later test.
+                        throw new InvalidRequestException("Only EQ and IN relation are supported on the partition key (unless you use the token() function)");
                     else if (existingRestriction.isMultiColumn())
                         throw new InvalidRequestException(String.format("Column \"%s\" cannot be restricted by both a tuple notation inequality and a single column inequality (%s)", name, newRel));
                     Term t = newRel.getValue().prepare(receiver);
