diff --git a/CHANGES.txt b/CHANGES.txt
index 5a73dd85ae..e849d288cb 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -34,6 +34,7 @@
  * Add repaired percentage metric (CASSANDRA-11503)
  * Add Change-Data-Capture (CASSANDRA-8844)
 Merged from 3.0:
+ * Fix paging for 2.x to 3.x upgrades (CASSANDRA-11195)
  * Fix clean interval not sent to commit log for empty memtable flush (CASSANDRA-12436)
  * Fix potential resource leak in RMIServerSocketFactoryImpl (CASSANDRA-12331)
  * Make sure compaction stats are updated when compaction is interrupted (CASSANDRA-12100)
diff --git a/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java b/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
index f2b484efd0..a8b97d1b02 100644
--- a/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
+++ b/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
@@ -21,9 +21,7 @@ import java.nio.ByteBuffer;
 import java.util.*;
 
 import com.google.common.base.MoreObjects;
-import com.google.common.base.Objects;
-import com.google.common.base.Predicate;
-import com.google.common.collect.Iterables;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -64,7 +62,6 @@ import static org.apache.cassandra.cql3.statements.RequestValidations.checkFalse
 import static org.apache.cassandra.cql3.statements.RequestValidations.checkNotNull;
 import static org.apache.cassandra.cql3.statements.RequestValidations.checkNull;
 import static org.apache.cassandra.cql3.statements.RequestValidations.checkTrue;
-import static org.apache.cassandra.cql3.statements.RequestValidations.invalidRequest;
 import static org.apache.cassandra.utils.ByteBufferUtil.UNSET_BYTE_BUFFER;
 
 /**
diff --git a/src/java/org/apache/cassandra/db/ReadCommand.java b/src/java/org/apache/cassandra/db/ReadCommand.java
index 68c9e3b0e0..9542703221 100644
--- a/src/java/org/apache/cassandra/db/ReadCommand.java
+++ b/src/java/org/apache/cassandra/db/ReadCommand.java
@@ -1075,7 +1075,7 @@ public abstract class ReadCommand extends MonitorableImpl implements ReadQuery
             // slice filter's stop.
             DataRange.Paging pagingRange = (DataRange.Paging) rangeCommand.dataRange();
             Clustering lastReturned = pagingRange.getLastReturned();
-            ClusteringBound newStart = ClusteringBound.exclusiveStartOf(lastReturned);
+            ClusteringBound newStart = ClusteringBound.inclusiveStartOf(lastReturned);
             Slice lastSlice = filter.requestedSlices().get(filter.requestedSlices().size() - 1);
             ByteBufferUtil.writeWithShortLength(LegacyLayout.encodeBound(metadata, newStart, true), out);
             ByteBufferUtil.writeWithShortLength(LegacyLayout.encodeClustering(metadata, lastSlice.end().clustering()), out);
@@ -1084,10 +1084,8 @@ public abstract class ReadCommand extends MonitorableImpl implements ReadQuery
 
             // command-level limit
             // Pre-3.0 we would always request one more row than we actually needed and the command-level "start" would
-            // be the last-returned cell name, so the response would always include it.  When dealing with compound comparators,
-            // we can pass an exclusive start and use the normal limit.  However, when dealing with non-compound comparators,
-            // pre-3.0 nodes cannot perform exclusive slices, so we need to request one extra row.
-            int maxResults = rangeCommand.limits().count() + (metadata.isCompound() ? 0 : 1);
+            // be the last-returned cell name, so the response would always include it.
+            int maxResults = rangeCommand.limits().count() + 1;
             out.writeInt(maxResults);
 
             // countCQL3Rows
diff --git a/src/java/org/apache/cassandra/db/ReadResponse.java b/src/java/org/apache/cassandra/db/ReadResponse.java
index 05ebd00c12..cca21f8ae5 100644
--- a/src/java/org/apache/cassandra/db/ReadResponse.java
+++ b/src/java/org/apache/cassandra/db/ReadResponse.java
@@ -280,13 +280,9 @@ public abstract class ReadResponse
 
                     ClusteringIndexFilter filter = command.clusteringIndexFilter(partition.partitionKey());
 
-                    // Pre-3.0, we didn't have a way to express exclusivity for non-composite comparators, so all slices were
-                    // inclusive on both ends. If we have exclusive slice ends, we need to filter the results here.
-                    UnfilteredRowIterator iterator;
-                    if (!command.metadata().isCompound())
-                        iterator = partition.unfilteredIterator(command.columnFilter(), filter.getSlices(command.metadata()), filter.isReversed());
-                    else
-                        iterator = partition.unfilteredIterator(command.columnFilter(), Slices.ALL, filter.isReversed());
+                    // Pre-3.0, we would always request one more row than we actually needed and the command-level "start" would
+                    // be the last-returned cell name, so the response would always include it.
+                    UnfilteredRowIterator iterator = partition.unfilteredIterator(command.columnFilter(), filter.getSlices(command.metadata()), filter.isReversed());
 
                     // Wrap results with a ThriftResultMerger only if they're intended for the thrift command.
                     if (command.isForThrift())
