diff --git a/CHANGES.txt b/CHANGES.txt
index 798496af33..459d5914b3 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 3.0.9
+ * Fix paging for 2.x to 3.x upgrades (CASSANDRA-11195)
  * select_distinct_with_deletions_test failing on non-vnode environments (CASSANDRA-11126)
  * Stack Overflow returned to queries while upgrading (CASSANDRA-12527)
  * Fix legacy regex for temporary files from 2.2 (CASSANDRA-12565)
diff --git a/src/java/org/apache/cassandra/db/ReadCommand.java b/src/java/org/apache/cassandra/db/ReadCommand.java
index c1762f19e2..70c770db71 100644
--- a/src/java/org/apache/cassandra/db/ReadCommand.java
+++ b/src/java/org/apache/cassandra/db/ReadCommand.java
@@ -1016,7 +1016,7 @@ public abstract class ReadCommand implements ReadQuery
             // slice filter's stop.
             DataRange.Paging pagingRange = (DataRange.Paging) rangeCommand.dataRange();
             Clustering lastReturned = pagingRange.getLastReturned();
-            Slice.Bound newStart = Slice.Bound.exclusiveStartOf(lastReturned);
+            Slice.Bound newStart = Slice.Bound.inclusiveStartOf(lastReturned);
             Slice lastSlice = filter.requestedSlices().get(filter.requestedSlices().size() - 1);
             ByteBufferUtil.writeWithShortLength(LegacyLayout.encodeBound(metadata, newStart, true), out);
             ByteBufferUtil.writeWithShortLength(LegacyLayout.encodeClustering(metadata, lastSlice.end().clustering()), out);
@@ -1025,10 +1025,8 @@ public abstract class ReadCommand implements ReadQuery
 
             // command-level limit
             // Pre-3.0 we would always request one more row than we actually needed and the command-level "start" would
-            // be the last-returned cell name, so the response would always include it.  When dealing with compound comparators,
-            // we can pass an exclusive start and use the normal limit.  However, when dealing with non-compound comparators,
-            // pre-3.0 nodes cannot perform exclusive slices, so we need to request one extra row.
-            int maxResults = rangeCommand.limits().count() + (metadata.isCompound() ? 0 : 1);
+            // be the last-returned cell name, so the response would always include it.
+            int maxResults = rangeCommand.limits().count() + 1;
             out.writeInt(maxResults);
 
             // countCQL3Rows
diff --git a/src/java/org/apache/cassandra/db/ReadResponse.java b/src/java/org/apache/cassandra/db/ReadResponse.java
index 2304cb4ab7..12f0b1566a 100644
--- a/src/java/org/apache/cassandra/db/ReadResponse.java
+++ b/src/java/org/apache/cassandra/db/ReadResponse.java
@@ -280,13 +280,10 @@ public abstract class ReadResponse
 
                     ClusteringIndexFilter filter = command.clusteringIndexFilter(partition.partitionKey());
 
-                    // Pre-3.0, we didn't have a way to express exclusivity for non-composite comparators, so all slices were
-                    // inclusive on both ends. If we have exclusive slice ends, we need to filter the results here.
-                    UnfilteredRowIterator iterator;
-                    if (!command.metadata().isCompound())
-                        iterator = filter.filter(partition.sliceableUnfilteredIterator(command.columnFilter(), filter.isReversed()));
-                    else
-                        iterator = partition.unfilteredIterator(command.columnFilter(), Slices.ALL, filter.isReversed());
+                    // Pre-3.0 we would always request one more row than we actually needed and the command-level "start" would
+                    // be the last-returned cell name, so the response would always include it. By consequence, we need to filter
+                    // the results here.
+                    UnfilteredRowIterator iterator = filter.filter(partition.sliceableUnfilteredIterator(command.columnFilter(), filter.isReversed()));
 
                     // Wrap results with a ThriftResultMerger only if they're intended for the thrift command.
                     if (command.isForThrift())
