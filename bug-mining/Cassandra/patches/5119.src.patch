diff --git a/CHANGES.txt b/CHANGES.txt
index bca036db38..b989f3cab8 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,6 @@
 2.2.14
+ * Don't skip entire sstables when reading backwards with mixed clustering column order
+   (CASSANDRA-14910)
  * Cannot perform slice reads in reverse direction against tables with clustering columns
    in mixed order (CASSANDRA-14899)
  * Fix incorrect cqlsh results when selecting same columns multiple times (CASSANDRA-13262)
diff --git a/src/java/org/apache/cassandra/db/filter/ColumnSlice.java b/src/java/org/apache/cassandra/db/filter/ColumnSlice.java
index 1cc348c8b6..316226d272 100644
--- a/src/java/org/apache/cassandra/db/filter/ColumnSlice.java
+++ b/src/java/org/apache/cassandra/db/filter/ColumnSlice.java
@@ -68,7 +68,10 @@ public class ColumnSlice
         Composite sStart = reversed ? finish : start;
         Composite sEnd = reversed ? start : finish;
 
-        if (compare(sStart, maxCellNames, comparator, true) > 0 || compare(sEnd, minCellNames, comparator, false) < 0)
+        // don't compare static slice bounds with min/max cell names to determine intersection - that can yield unexpected
+        // results, in particular with ReverseType comparators; see CASSANDRA-14910 for more context.
+        if ((!sStart.isStatic() && compare(sStart, maxCellNames, comparator, true) > 0)
+         || (!sEnd.isStatic() && compare(sEnd, minCellNames, comparator, false) < 0))
             return false;
 
         // We could safely return true here, but there's a minor optimization: if the first component is restricted
diff --git a/test/unit/org/apache/cassandra/cql3/validation/operations/SelectOrderByTest.java b/test/unit/org/apache/cassandra/cql3/validation/operations/SelectOrderByTest.java
index 32d800a33e..e21074bf09 100644
--- a/test/unit/org/apache/cassandra/cql3/validation/operations/SelectOrderByTest.java
+++ b/test/unit/org/apache/cassandra/cql3/validation/operations/SelectOrderByTest.java
@@ -732,6 +732,84 @@ public class SelectOrderByTest extends CQLTester
         }
     }
 
+    @Test
+    public void testSelectWithReversedTypeInReverseOrderWithStaticColumnsWithoutStaticRow() throws Throwable
+    {
+        createTable("CREATE TABLE %s (a int, b int, c int, d int static, PRIMARY KEY (a, b)) WITH CLUSTERING ORDER BY (b DESC);");
+
+        execute("INSERT INTO %s (a, b, c) VALUES (1, 1, 1);");
+        execute("INSERT INTO %s (a, b, c) VALUES (1, 2, 2);");
+        execute("INSERT INTO %s (a, b, c) VALUES (1, 3, 3);");
+
+        // read in comparator order
+        assertRows(execute("SELECT b, c FROM %s WHERE a = 1 ORDER BY b DESC;"),
+                   row(3, 3),
+                   row(2, 2),
+                   row(1, 1));
+
+        // read in reverse comparator order
+        assertRows(execute("SELECT b, c FROM %s WHERE a = 1 ORDER BY b ASC;"),
+                   row(1, 1),
+                   row(2, 2),
+                   row(3, 3));
+
+        /*
+         * Flush the sstable. We *should* see the same results when reading in both directions, but prior to CASSANDRA-14910
+         * fix this would now have returned an empty result set when reading in reverse comparator order.
+         */
+        flush();
+
+        // read in comparator order
+        assertRows(execute("SELECT b, c FROM %s WHERE a = 1 ORDER BY b DESC;"),
+                   row(3, 3),
+                   row(2, 2),
+                   row(1, 1));
+
+        // read in reverse comparator order
+        assertRows(execute("SELECT b, c FROM %s WHERE a = 1 ORDER BY b ASC;"),
+                   row(1, 1),
+                   row(2, 2),
+                   row(3, 3));
+    }
+
+    @Test
+    public void testSelectWithReversedTypeInReverseOrderWithStaticColumnsWithStaticRow() throws Throwable
+    {
+        createTable("CREATE TABLE %s (a int, b int, c int, d int static, PRIMARY KEY (a, b)) WITH CLUSTERING ORDER BY (b DESC)");
+
+        execute("INSERT INTO %s (a, d) VALUES (1, 0);");
+
+        execute("INSERT INTO %s (a, b, c) VALUES (1, 1, 1);");
+        execute("INSERT INTO %s (a, b, c) VALUES (1, 2, 2);");
+        execute("INSERT INTO %s (a, b, c) VALUES (1, 3, 3);");
+
+        // read in comparator order
+        assertRows(execute("SELECT b, c, d FROM %s WHERE a = 1 ORDER BY b DESC;"),
+                   row(3, 3, 0),
+                   row(2, 2, 0),
+                   row(1, 1, 0));
+
+        // read in reverse comparator order
+        assertRows(execute("SELECT b, c, d FROM %s WHERE a = 1 ORDER BY b ASC;"),
+                   row(1, 1, 0),
+                   row(2, 2, 0),
+                   row(3, 3, 0));
+
+        flush();
+
+        // read in comparator order
+        assertRows(execute("SELECT b, c, d FROM %s WHERE a = 1 ORDER BY b DESC;"),
+                   row(3, 3, 0),
+                   row(2, 2, 0),
+                   row(1, 1, 0));
+
+        // read in reverse comparator order
+        assertRows(execute("SELECT b, c, d FROM %s WHERE a = 1 ORDER BY b ASC;"),
+                   row(1, 1, 0),
+                   row(2, 2, 0),
+                   row(3, 3, 0));
+    }
+
     private boolean isFirstIntSorted(Object[][] rows)
     {
         for (int i = 1; i < rows.length; i++)
