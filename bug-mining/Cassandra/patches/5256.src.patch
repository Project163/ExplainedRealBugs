diff --git a/CHANGES.txt b/CHANGES.txt
index 297fad4380..44719b4913 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 3.0.20
+ * Fix point-in-time recoevery ignoring timestamp of updates to static columns (CASSANDRA-15292)
  * GC logs are also put under $CASSANDRA_LOG_DIR (CASSANDRA-14306)
  * Fix sstabledump's position key value when partitions have multiple rows (CASSANDRA-14721)
  * Avoid over-scanning data directories in LogFile.verify() (CASSANDRA-15364)
diff --git a/src/java/org/apache/cassandra/db/partitions/PartitionUpdate.java b/src/java/org/apache/cassandra/db/partitions/PartitionUpdate.java
index 7363c245db..5f74780c3e 100644
--- a/src/java/org/apache/cassandra/db/partitions/PartitionUpdate.java
+++ b/src/java/org/apache/cassandra/db/partitions/PartitionUpdate.java
@@ -495,6 +495,24 @@ public class PartitionUpdate extends AbstractBTreePartition
                 }
             }
         }
+
+        if (holder.staticRow != null)
+        {
+            for (ColumnData cd : holder.staticRow.columnData())
+            {
+                if (cd.column().isSimple())
+                {
+                    maxTimestamp = Math.max(maxTimestamp, ((Cell) cd).timestamp());
+                }
+                else
+                {
+                    ComplexColumnData complexData = (ComplexColumnData) cd;
+                    maxTimestamp = Math.max(maxTimestamp, complexData.complexDeletion().markedForDeleteAt());
+                    for (Cell cell : complexData)
+                        maxTimestamp = Math.max(maxTimestamp, cell.timestamp());
+                }
+            }
+        }
         return maxTimestamp;
     }
 
diff --git a/test/unit/org/apache/cassandra/SchemaLoader.java b/test/unit/org/apache/cassandra/SchemaLoader.java
index 8d61f393a7..026aba85e5 100644
--- a/test/unit/org/apache/cassandra/SchemaLoader.java
+++ b/test/unit/org/apache/cassandra/SchemaLoader.java
@@ -364,6 +364,16 @@ public class SchemaLoader
                       .compression(getCompressionParameters());
     }
 
+    public static CFMetaData staticCFMD(String ksName, String cfName)
+    {
+        return CFMetaData.Builder.create(ksName, cfName)
+                                 .addPartitionKey("key", AsciiType.instance)
+                                 .addClusteringColumn("cols", AsciiType.instance)
+                                 .addStaticColumn("val", AsciiType.instance)
+                                 .addRegularColumn("val2", AsciiType.instance)
+                                 .build();
+    }
+
 
     public static CFMetaData denseCFMD(String ksName, String cfName)
     {
diff --git a/test/unit/org/apache/cassandra/db/RecoveryManagerTest.java b/test/unit/org/apache/cassandra/db/RecoveryManagerTest.java
index 397030a4af..57bd044608 100644
--- a/test/unit/org/apache/cassandra/db/RecoveryManagerTest.java
+++ b/test/unit/org/apache/cassandra/db/RecoveryManagerTest.java
@@ -62,6 +62,7 @@ public class RecoveryManagerTest
 
     private static final String KEYSPACE1 = "RecoveryManagerTest1";
     private static final String CF_STANDARD1 = "Standard1";
+    private static final String CF_STATIC1 = "Static1";
     private static final String CF_COUNTER1 = "Counter1";
 
     private static final String KEYSPACE2 = "RecoveryManagerTest2";
@@ -74,7 +75,8 @@ public class RecoveryManagerTest
         SchemaLoader.createKeyspace(KEYSPACE1,
                                     KeyspaceParams.simple(1),
                                     SchemaLoader.standardCFMD(KEYSPACE1, CF_STANDARD1),
-                                    SchemaLoader.counterCFMD(KEYSPACE1, CF_COUNTER1));
+                                    SchemaLoader.counterCFMD(KEYSPACE1, CF_COUNTER1),
+                                    SchemaLoader.staticCFMD(KEYSPACE1, CF_STATIC1));
         SchemaLoader.createKeyspace(KEYSPACE2,
                                     KeyspaceParams.simple(1),
                                     SchemaLoader.standardCFMD(KEYSPACE2, CF_STANDARD3));
@@ -184,6 +186,34 @@ public class RecoveryManagerTest
         assertEquals(6, Util.getAll(Util.cmd(cfs).build()).size());
     }
 
+    @Test
+    public void testRecoverPITStatic() throws Exception
+    {
+        CommitLog.instance.resetUnsafe(true);
+        Keyspace keyspace1 = Keyspace.open(KEYSPACE1);
+        ColumnFamilyStore cfs = keyspace1.getColumnFamilyStore(CF_STATIC1);
+        Date date = CommitLogArchiver.format.parse("2112:12:12 12:12:12");
+        long timeMS = date.getTime() - 5000;
+
+
+        for (int i = 0; i < 10; ++i)
+        {
+            long ts = TimeUnit.MILLISECONDS.toMicros(timeMS + (i * 1000));
+            new RowUpdateBuilder(cfs.metadata, ts, "name-" + i)
+            .add("val", Integer.toString(i))
+            .build()
+            .apply();
+        }
+
+        // Sanity check row count prior to clear and replay
+        assertEquals(10, Util.getAll(Util.cmd(cfs).build()).size());
+
+        keyspace1.getColumnFamilyStore(CF_STATIC1).clearUnsafe();
+        CommitLog.instance.resetUnsafe(false);
+
+        assertEquals(6, Util.getAll(Util.cmd(cfs).build()).size());
+    }
+
     @Test
     public void testRecoverPITUnordered() throws Exception
     {
