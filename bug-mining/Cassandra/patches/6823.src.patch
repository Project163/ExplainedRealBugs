diff --git a/src/java/org/apache/cassandra/config/CassandraRelevantProperties.java b/src/java/org/apache/cassandra/config/CassandraRelevantProperties.java
index e2957ce95f..0d411d7e81 100644
--- a/src/java/org/apache/cassandra/config/CassandraRelevantProperties.java
+++ b/src/java/org/apache/cassandra/config/CassandraRelevantProperties.java
@@ -585,7 +585,7 @@ public enum CassandraRelevantProperties
     TCM_SORT_REPLICA_GROUPS("cassandra.sorted_replica_groups_enabled", "true"),
     TCM_UNSAFE_BOOT_WITH_CLUSTERMETADATA("cassandra.unsafe_boot_with_clustermetadata", null),
     TCM_USE_ATOMIC_LONG_PROCESSOR("cassandra.test.use_atomic_long_processor", "false"),
-    TCM_USE_NO_OP_REPLICATOR("cassandra.test.use_no_op_replicator", "false"),
+    TCM_USE_TEST_NO_OP_REPLICATOR("cassandra.test.use_no_op_replicator", "false"),
     TEST_ACCORD_STORE_THREAD_CHECKS_ENABLED("cassandra.test.accord.store.thread_checks_enabled", "true"),
     TEST_BBFAILHELPER_ENABLED("test.bbfailhelper.enabled"),
     TEST_BLOB_SHARED_SEED("cassandra.test.blob.shared.seed", "42"),
diff --git a/src/java/org/apache/cassandra/db/virtual/AccordDebugKeyspace.java b/src/java/org/apache/cassandra/db/virtual/AccordDebugKeyspace.java
index 4bab8d2c64..abc68385ef 100644
--- a/src/java/org/apache/cassandra/db/virtual/AccordDebugKeyspace.java
+++ b/src/java/org/apache/cassandra/db/virtual/AccordDebugKeyspace.java
@@ -156,8 +156,8 @@ public class AccordDebugKeyspace extends VirtualKeyspace
                 TableId tableId = (TableId) view.shard().range.start().prefix();
                 TableMetadata tableMetadata = tableMetadata(tableId);
                 ds.row(keyspace(tableMetadata), table(tableId, tableMetadata), sortToken(view.shard().range.start()))
-                  .column("start_token", printToken(view.shard().range.start()))
-                  .column("end_token", printToken(view.shard().range.end()))
+                  .column("token_start", printToken(view.shard().range.start()))
+                  .column("token_end", printToken(view.shard().range.end()))
                   .column("last_started_at", approxTime.translate().toMillisSinceEpoch(view.lastStartedAtMicros() * 1000))
                   .column("cycle_started_at", approxTime.translate().toMillisSinceEpoch(view.cycleStartedAtMicros() * 1000))
                   .column("active", Objects.toString(view.active()))
@@ -170,7 +170,6 @@ public class AccordDebugKeyspace extends VirtualKeyspace
                   .column("endIndex", view.cycleLength())
                   .column("current_splits", view.currentSplits())
                   .column("stopping", view.stopping())
-                  .column("stopping", view.stopping())
                 ;
             }
             return ds;
@@ -204,8 +203,8 @@ public class AccordDebugKeyspace extends VirtualKeyspace
                     TableId tableId = (TableId) start.prefix();
                     TableMetadata tableMetadata = tableMetadata(tableId);
                     ds.row(keyspace(tableMetadata), table(tableId, tableMetadata), sortToken(start))
-                      .column("start_token", printToken(start))
-                      .column("end_token", printToken(end))
+                      .column("token_start", printToken(start))
+                      .column("token_end", printToken(end))
                       .column("majority_before", entry.majorityBefore.toString())
                       .column("universal_before", entry.universalBefore.toString());
                     return ds;
@@ -292,8 +291,8 @@ public class AccordDebugKeyspace extends VirtualKeyspace
                 maxConflicts.foldlWithBounds(
                     (timestamp, ds, start, end) -> {
                         return ds.row(keyspace(tableMetadata), table(tableId, tableMetadata), sortToken(start), commandStoreId)
-                                 .column("start_token", printToken(start))
-                                 .column("end_token", printToken(end))
+                                 .column("token_start", printToken(start))
+                                 .column("token_end", printToken(end))
                                  .column("timestamp", timestamp.toString())
                         ;
                     },
@@ -508,8 +507,8 @@ public class AccordDebugKeyspace extends VirtualKeyspace
                 commandStore.unsafeGetRedundantBefore().foldl(
                     (entry, ds) -> {
                         ds.row(keyspace, table, sortToken(entry.range.start()), commandStoreId)
-                          .column("start_token", printToken(entry.range.start()))
-                          .column("end_token", printToken(entry.range.end()))
+                          .column("token_start", printToken(entry.range.start()))
+                          .column("token_end", printToken(entry.range.end()))
                           .column("start_epoch", entry.startEpoch)
                           .column("end_epoch", entry.endEpoch)
                           .column("gc_before", entry.maxBound(GC_BEFORE).toString())
diff --git a/src/java/org/apache/cassandra/index/accord/RouteIndexFormat.java b/src/java/org/apache/cassandra/index/accord/RouteIndexFormat.java
index 56be6b9eed..05d7db36a1 100644
--- a/src/java/org/apache/cassandra/index/accord/RouteIndexFormat.java
+++ b/src/java/org/apache/cassandra/index/accord/RouteIndexFormat.java
@@ -63,7 +63,7 @@ import org.apache.cassandra.utils.Throwables;
 
 import static org.apache.cassandra.utils.Clock.Global.nowInSeconds;
 
-// A route index consists of a few files: cintia_sorted_list, cintia_checkpoints, and metadata
+// A route index consists of a few files: cintia_sorted_list, cintia_checkpoints, and
 // metadata stores the segement mappings and stats needed for search selection
 public class RouteIndexFormat
 {
diff --git a/src/java/org/apache/cassandra/journal/StaticSegment.java b/src/java/org/apache/cassandra/journal/StaticSegment.java
index b943ab8104..281ed41178 100644
--- a/src/java/org/apache/cassandra/journal/StaticSegment.java
+++ b/src/java/org/apache/cassandra/journal/StaticSegment.java
@@ -22,6 +22,7 @@ import org.apache.cassandra.io.util.FileUtils;
 import org.apache.cassandra.utils.Closeable;
 import org.apache.cassandra.utils.Throwables;
 import org.apache.cassandra.utils.concurrent.Ref;
+import org.apache.cassandra.utils.memory.MemoryUtil;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
diff --git a/src/java/org/apache/cassandra/service/accord/AccordConfigurationService.java b/src/java/org/apache/cassandra/service/accord/AccordConfigurationService.java
index 3496c982b0..e1177a3d37 100644
--- a/src/java/org/apache/cassandra/service/accord/AccordConfigurationService.java
+++ b/src/java/org/apache/cassandra/service/accord/AccordConfigurationService.java
@@ -63,6 +63,8 @@ import org.apache.cassandra.utils.FBUtilities;
 import org.apache.cassandra.utils.Simulate;
 import org.apache.cassandra.utils.concurrent.AsyncPromise;
 import org.apache.cassandra.utils.concurrent.Future;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import static org.apache.cassandra.service.accord.AccordTopology.tcmIdToAccord;
 import static org.apache.cassandra.utils.Simulate.With.MONITORS;
@@ -71,6 +73,7 @@ import static org.apache.cassandra.utils.Simulate.With.MONITORS;
 @Simulate(with=MONITORS)
 public class AccordConfigurationService extends AbstractConfigurationService<AccordConfigurationService.EpochState, AccordConfigurationService.EpochHistory> implements AccordEndpointMapper, AccordSyncPropagator.Listener, Shutdownable
 {
+    public static final Logger logger = LoggerFactory.getLogger(AccordConfigurationService.class);
     private final AccordSyncPropagator syncPropagator;
     public final WatermarkCollector watermarkCollector;
 
@@ -531,6 +534,7 @@ public class AccordConfigurationService extends AbstractConfigurationService<Acc
     @Override
     public void reportEpochRemoved(long epoch)
     {
+        logger.info("Epoch removed, truncated epochs until {}", epoch);
         epochs.truncateUntil(epoch);
     }
     
diff --git a/src/java/org/apache/cassandra/service/accord/AccordJournal.java b/src/java/org/apache/cassandra/service/accord/AccordJournal.java
index efbb39a0ce..b8b6709d65 100644
--- a/src/java/org/apache/cassandra/service/accord/AccordJournal.java
+++ b/src/java/org/apache/cassandra/service/accord/AccordJournal.java
@@ -25,6 +25,7 @@ import java.util.Iterator;
 import java.util.NavigableMap;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
+import java.util.function.Consumer;
 import javax.annotation.Nullable;
 
 import com.google.common.annotations.VisibleForTesting;
@@ -434,7 +435,20 @@ public class AccordJournal implements accord.api.Journal, RangeSearcher.Supplier
         journalTable.forceCompaction();
     }
 
-    @SuppressWarnings("unchecked") @Override
+    public void forEach(Consumer<JournalKey> consumer)
+    {
+        try (CloseableIterator<Journal.KeyRefs<JournalKey>> iter = journalTable.keyIterator())
+        {
+            while (iter.hasNext())
+            {
+                Journal.KeyRefs<JournalKey> ref = iter.next();
+                consumer.accept(ref.key());
+            }
+        }
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
     public void replay(CommandStores commandStores)
     {
         try (CloseableIterator<Journal.KeyRefs<JournalKey>> iter = journalTable.keyIterator())
diff --git a/test/distributed/org/apache/cassandra/fuzz/topology/JournalGCTest.java b/test/distributed/org/apache/cassandra/fuzz/topology/JournalGCTest.java
new file mode 100644
index 0000000000..e685f3a4f9
--- /dev/null
+++ b/test/distributed/org/apache/cassandra/fuzz/topology/JournalGCTest.java
@@ -0,0 +1,117 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.cassandra.fuzz.topology;
+
+import org.apache.cassandra.db.Keyspace;
+import org.apache.cassandra.distributed.Cluster;
+import org.apache.cassandra.distributed.api.ConsistencyLevel;
+import org.apache.cassandra.distributed.test.log.FuzzTestBase;
+import org.apache.cassandra.harry.SchemaSpec;
+import org.apache.cassandra.harry.dsl.HistoryBuilder;
+import org.apache.cassandra.harry.dsl.ReplayingHistoryBuilder;
+import org.apache.cassandra.harry.execution.InJvmDTestVisitExecutor;
+import org.apache.cassandra.harry.execution.QueryBuildingVisitExecutor;
+import org.apache.cassandra.harry.gen.Generator;
+import org.apache.cassandra.harry.gen.SchemaGenerators;
+import org.apache.cassandra.schema.SchemaConstants;
+import org.apache.cassandra.service.accord.AccordKeyspace;
+import org.apache.cassandra.service.accord.AccordService;
+import org.apache.cassandra.service.accord.JournalKey;
+import org.apache.cassandra.service.consensus.TransactionalMode;
+import org.junit.Assert;
+import org.junit.Test;
+
+import java.util.concurrent.atomic.AtomicInteger;
+
+import static org.apache.cassandra.harry.checker.TestHelper.withRandom;
+
+public class JournalGCTest extends FuzzTestBase
+{
+    private static final int POPULATION = 1000;
+
+    @Test
+    public void journalGCTest() throws Throwable
+    {
+        try (Cluster cluster = init(builder().withNodes(1)
+                                            .withConfig(cfg -> cfg.set("accord.gc_delay", "1s")
+                                                    .set("accord.shard_durability_target_splits", "1")
+                                                    .set("accord.shard_durability_cycle", "1s")
+                                                    .set("accord.global_durability_cycle", "1s"))
+                                            .start()))
+        {
+            withRandom(rng -> {
+                cluster.get(1).runOnInstance(() -> {
+                    Keyspace.open(SchemaConstants.ACCORD_KEYSPACE_NAME).getColumnFamilyStore(AccordKeyspace.JOURNAL).disableAutoCompaction();
+                });
+
+                Generator<SchemaSpec> schemaGen = SchemaGenerators.trivialSchema(KEYSPACE, () -> "bootstrap_fuzz", POPULATION,
+                                                                                 SchemaSpec.optionsBuilder()
+                                                                                         .addWriteTimestamps(false)
+                                                                                         .withTransactionalMode(TransactionalMode.full));
+
+                SchemaSpec schema = schemaGen.generate(rng);
+                cluster.schemaChange(schema.compile());
+                HistoryBuilder history = new ReplayingHistoryBuilder(schema.valueGenerators,
+                                                                     hb -> InJvmDTestVisitExecutor.builder()
+                                                                             .consistencyLevel(ConsistencyLevel.QUORUM)
+                                                                             .wrapQueries(QueryBuildingVisitExecutor.WrapQueries.TRANSACTION)
+                                                                             .pageSizeSelector(p -> InJvmDTestVisitExecutor.PageSizeSelector.NO_PAGING)
+                                                                             .build(schema, hb, cluster));
+
+                for (int pk = 0; pk < 500; pk++) {
+                    for (int i = 0; i < 500; i++)
+                        history.insert(pk);
+                }
+
+                cluster.get(1).runOnInstance(() -> {
+                    ((AccordService) AccordService.instance()).journal().closeCurrentSegmentForTestingIfNonEmpty();
+                    ((AccordService) AccordService.instance()).journal().compactor().run();
+                });
+
+                int before = cluster.get(1).callOnInstance(() -> {
+                    AtomicInteger a = new AtomicInteger();
+                    ((AccordService) AccordService.instance()).journal().forEach((v) -> {
+                        if (v.type == JournalKey.Type.COMMAND_DIFF)
+                            a.incrementAndGet();
+                    });
+                    return a.get();
+                });
+
+                Thread.sleep(10_000);
+                cluster.get(1).runOnInstance(() -> {
+                    Keyspace.open(SchemaConstants.ACCORD_KEYSPACE_NAME).getColumnFamilyStore(AccordKeyspace.JOURNAL).forceMajorCompaction();
+                });
+
+                cluster.get(1).forceCompact("system_accord", "journal");
+
+                int after = cluster.get(1).callOnInstance(() -> {
+                    AtomicInteger a = new AtomicInteger();
+                    ((AccordService) AccordService.instance()).journal().forEach((v) -> {
+                        if (v.type == JournalKey.Type.COMMAND_DIFF)
+                            a.incrementAndGet();
+                    });
+                    return a.get();
+                });
+                Assert.assertTrue(String.format("%s should have been strictly smaller than %s", after, before), before > after);
+                Assert.assertEquals(0, after);
+            });
+        }
+    }
+}
+
diff --git a/test/unit/org/apache/cassandra/tcm/BootWithMetadataTest.java b/test/unit/org/apache/cassandra/tcm/BootWithMetadataTest.java
index 2f77df4f60..6b0d119448 100644
--- a/test/unit/org/apache/cassandra/tcm/BootWithMetadataTest.java
+++ b/test/unit/org/apache/cassandra/tcm/BootWithMetadataTest.java
@@ -85,7 +85,7 @@ public class BootWithMetadataTest
         // General test setup, no need to use Paxos for log commits or to replicate
         // to (non-existent) peers
         CassandraRelevantProperties.TCM_USE_ATOMIC_LONG_PROCESSOR.setBoolean(true);
-        CassandraRelevantProperties.TCM_USE_NO_OP_REPLICATOR.setBoolean(true);
+        CassandraRelevantProperties.TCM_USE_TEST_NO_OP_REPLICATOR.setBoolean(true);
 
         ServerTestUtils.daemonInitialization();
         DatabaseDescriptor.setPartitionerUnsafe(Murmur3Partitioner.instance);
