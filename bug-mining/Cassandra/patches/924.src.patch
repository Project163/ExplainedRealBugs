diff --git a/CHANGES.txt b/CHANGES.txt
index 363c1db822..997c0a576f 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -6,6 +6,7 @@
  * avoid using cached position of a key when GT is requested (CASSANDRA-2633)
  * fix counting bloom filter true positives (CASSANDRA-2637)
  * initialize local ep state prior to gossip startup if needed (CASSANDRA-2638)
+ * fix counter increment lost after restart (CASSANDRA-2642)
 
 
 0.8.0-rc1
diff --git a/src/java/org/apache/cassandra/db/RowMutation.java b/src/java/org/apache/cassandra/db/RowMutation.java
index e804ac12e0..f79ceef308 100644
--- a/src/java/org/apache/cassandra/db/RowMutation.java
+++ b/src/java/org/apache/cassandra/db/RowMutation.java
@@ -355,7 +355,7 @@ public class RowMutation implements IMutation, MessageProducer
             }
         }
 
-        public RowMutation deserialize(DataInputStream dis, int version) throws IOException
+        public RowMutation deserialize(DataInputStream dis, int version, boolean fromRemote) throws IOException
         {
             String table = dis.readUTF();
             ByteBuffer key = ByteBufferUtil.readWithShortLength(dis);
@@ -364,11 +364,15 @@ public class RowMutation implements IMutation, MessageProducer
             for (int i = 0; i < size; ++i)
             {
                 Integer cfid = Integer.valueOf(dis.readInt());
-                // This is coming from a remote host
-                ColumnFamily cf = ColumnFamily.serializer().deserialize(dis, true, true);
+                ColumnFamily cf = ColumnFamily.serializer().deserialize(dis, true, fromRemote);
                 modifications.put(cfid, cf);
             }
             return new RowMutation(table, key, modifications);
         }
+
+        public RowMutation deserialize(DataInputStream dis, int version) throws IOException
+        {
+            return deserialize(dis, version, true);
+        }
     }
 }
diff --git a/src/java/org/apache/cassandra/db/commitlog/CommitLog.java b/src/java/org/apache/cassandra/db/commitlog/CommitLog.java
index 573e3176d4..9f6077e947 100644
--- a/src/java/org/apache/cassandra/db/commitlog/CommitLog.java
+++ b/src/java/org/apache/cassandra/db/commitlog/CommitLog.java
@@ -268,7 +268,7 @@ public class CommitLog
                     {
                         // assuming version here. We've gone to lengths to make sure what gets written to the CL is in
                         // the current version.  so do make sure the CL is drained prior to upgrading a node.
-                        rm = RowMutation.serializer().deserialize(new DataInputStream(bufIn), MessagingService.version_);
+                        rm = RowMutation.serializer().deserialize(new DataInputStream(bufIn), MessagingService.version_, false);
                     }
                     catch (UnserializableColumnFamilyException ex)
                     {
diff --git a/test/unit/org/apache/cassandra/db/RecoveryManagerTest.java b/test/unit/org/apache/cassandra/db/RecoveryManagerTest.java
index 9fda65b17f..ce83024448 100644
--- a/test/unit/org/apache/cassandra/db/RecoveryManagerTest.java
+++ b/test/unit/org/apache/cassandra/db/RecoveryManagerTest.java
@@ -26,6 +26,7 @@ import org.junit.Test;
 
 import org.apache.cassandra.CleanupHelper;
 import org.apache.cassandra.db.commitlog.CommitLog;
+import org.apache.cassandra.utils.ByteBufferUtil;
 
 import org.apache.cassandra.Util;
 import static org.apache.cassandra.Util.column;
@@ -69,4 +70,36 @@ public class RecoveryManagerTest extends CleanupHelper
         assertColumns(Util.getColumnFamily(table1, dk, "Standard1"), "col1");
         assertColumns(Util.getColumnFamily(table2, dk, "Standard3"), "col2");
     }
+
+    @Test
+    public void testRecoverCounter() throws IOException, ExecutionException, InterruptedException
+    {
+        Table table1 = Table.open("Keyspace1");
+
+        RowMutation rm;
+        DecoratedKey dk = Util.dk("key");
+        ColumnFamily cf;
+
+        for (int i = 0; i < 10; ++i)
+        {
+            rm = new RowMutation("Keyspace1", dk.key);
+            cf = ColumnFamily.create("Keyspace1", "Counter1");
+            cf.addColumn(new CounterColumn(ByteBufferUtil.bytes("col"), 1L, 1L));
+            rm.add(cf);
+            rm.apply();
+        }
+
+        table1.getColumnFamilyStore("Counter1").clearUnsafe();
+
+        CommitLog.instance.resetUnsafe(); // disassociate segments from live CL
+        CommitLog.recover();
+
+        cf = Util.getColumnFamily(table1, dk, "Counter1");
+
+        assert cf.getColumnCount() == 1;
+        IColumn c = cf.getColumn(ByteBufferUtil.bytes("col"));
+
+        assert c != null;
+        assert ((CounterColumn)c).total() == 10L;
+    }
 }
