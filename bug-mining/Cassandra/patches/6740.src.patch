diff --git a/src/java/org/apache/cassandra/service/accord/txn/TxnNamedRead.java b/src/java/org/apache/cassandra/service/accord/txn/TxnNamedRead.java
index 303692bb5c..dd9486ca30 100644
--- a/src/java/org/apache/cassandra/service/accord/txn/TxnNamedRead.java
+++ b/src/java/org/apache/cassandra/service/accord/txn/TxnNamedRead.java
@@ -298,7 +298,6 @@ public class TxnNamedRead extends AbstractSerialized<ReadCommand>
         AbstractBounds<PartitionPosition> bounds = command.dataRange().keyRange();
         PartitionPosition startPP = bounds.left;
         PartitionPosition endPP = bounds.right;
-        TokenKey startTokenKey = new TokenKey(command.metadata().id, startPP.getToken());
         AccordRoutingKey startRoutingKey = ((AccordRoutingKey)r.start());
         AccordRoutingKey endRoutingKey = ((AccordRoutingKey)r.end());
         Token subRangeStartToken = startRoutingKey.getClass() == SentinelKey.class ? startPP.getToken() : ((AccordRoutingKey)r.start()).asTokenKey().token();
@@ -331,7 +330,8 @@ public class TxnNamedRead extends AbstractSerialized<ReadCommand>
         PartitionPosition subRangeEndPP = endPP.getToken().equals(subRangeEndToken) ? endPP : subRangeEndToken.maxKeyBound();
         // Need to preserve the fact it is a bounds for paging to work, a range is not left inclusive and will not start from where we left off
         AbstractBounds<PartitionPosition> subRange = isFirstSubrange ? bounds.withNewRight(subRangeEndPP) : new org.apache.cassandra.dht.Range(subRangeStartPP, subRangeEndPP);
-        return command.withTransactionalSettings(nowInSeconds, subRange, startTokenKey.equals(r.start()), readsWithoutReconciliation(consistencyLevel));
+        boolean isRangeContinuation = startPP.getToken().equals(subRangeStartToken);
+        return command.withTransactionalSettings(nowInSeconds, subRange, isRangeContinuation, readsWithoutReconciliation(consistencyLevel));
     }
 
     private AsyncChain<Data> performLocalRangeRead(PartitionRangeReadCommand command, Range r, ConsistencyLevel consistencyLevel, long nowInSeconds)
@@ -345,7 +345,7 @@ public class TxnNamedRead extends AbstractSerialized<ReadCommand>
             {
                 TxnData result = new TxnData();
                 TxnDataRangeValue value = new TxnDataRangeValue();
-                while(iterator.hasNext())
+                while (iterator.hasNext())
                 {
                     try (RowIterator rows = iterator.next())
                     {
diff --git a/src/java/org/apache/cassandra/service/consensus/migration/ConsensusRequestRouter.java b/src/java/org/apache/cassandra/service/consensus/migration/ConsensusRequestRouter.java
index 83ea27cb2a..db4d9b58e0 100644
--- a/src/java/org/apache/cassandra/service/consensus/migration/ConsensusRequestRouter.java
+++ b/src/java/org/apache/cassandra/service/consensus/migration/ConsensusRequestRouter.java
@@ -729,11 +729,13 @@ public class ConsensusRequestRouter
             {
                 if (rightCmp <= 0)
                     return ImmutableList.of(new RangeReadWithTarget(read, migrationFromTarget));
-                result = new ArrayList<>();
                 AbstractBounds<PartitionPosition> precedingRange = keyRange.withNewRight(rightCmp <= 0 ? keyRange.right : firstMigratingToken.maxKeyBound());
                 // Could be an empty bound, it's fine to let a min KeyBound and max KeyBound through as that isn't empty
                 if (!precedingRange.left.equals(precedingRange.right))
-                    result.add(new RangeReadWithTarget(read.forSubRange(precedingRange, false), migrationFromTarget));
+                {
+                    result = new ArrayList<>();
+                    result.add(new RangeReadWithTarget(read.forSubRange(precedingRange, true), migrationFromTarget));
+                }
             }
         }
 
@@ -757,9 +759,9 @@ public class ConsensusRequestRouter
         if (remainder != null)
         {
             if (result != null)
-                result.add(new RangeReadWithTarget(read.forSubRange(remainder, true), migrationFromTarget));
+                result.add(new RangeReadWithTarget(read.forSubRange(remainder, false), migrationFromTarget));
             else
-                return ImmutableList.of(new RangeReadWithTarget(read.forSubRange(remainder, false), migrationFromTarget));
+                return ImmutableList.of(new RangeReadWithTarget(read.forSubRange(remainder, true), migrationFromTarget));
         }
 
         checkState(result != null && !result.isEmpty(), "Shouldn't have null or empty result");
