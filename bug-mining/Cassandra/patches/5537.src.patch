diff --git a/CHANGES.txt b/CHANGES.txt
index 35612cf5ba..41daa6aa65 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 3.0.24:
+ * Fix a race condition on ColumnFamilyStore and TableMetrics (CASSANDRA-16228)
  * Remove the SEPExecutor blocking behavior (CASSANDRA-16186)
  * Wait for schema agreement when bootstrapping (CASSANDRA-15158)
  * Fix invalid cell value skipping when reading from disk (CASSANDRA-16223)
diff --git a/src/java/org/apache/cassandra/db/ColumnFamilyStore.java b/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
index 7de68f96ce..a9c087eaf9 100644
--- a/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
+++ b/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
@@ -81,8 +81,6 @@ import org.apache.cassandra.utils.memory.MemtableAllocator;
 import org.json.simple.JSONArray;
 import org.json.simple.JSONObject;
 
-import static org.apache.cassandra.utils.ExecutorUtils.awaitTermination;
-import static org.apache.cassandra.utils.ExecutorUtils.shutdown;
 import static org.apache.cassandra.utils.Throwables.maybeFail;
 import static org.apache.cassandra.utils.Throwables.merge;
 
@@ -392,7 +390,6 @@ public class ColumnFamilyStore implements ColumnFamilyStoreMBean
         crcCheckChance = new DefaultValue<>(metadata.params.crcCheckChance);
         indexManager = new SecondaryIndexManager(this);
         viewManager = keyspace.viewManager.forTable(metadata);
-        metric = new TableMetrics(this);
         fileIndexGenerator.set(generation);
         sampleLatencyNanos = TimeUnit.MILLISECONDS.toNanos(DatabaseDescriptor.getReadRpcTimeout() / 2);
 
@@ -404,12 +401,13 @@ public class ColumnFamilyStore implements ColumnFamilyStoreMBean
             initialMemtable = new Memtable(new AtomicReference<>(CommitLog.instance.getContext()), this);
         data = new Tracker(initialMemtable, loadSSTables);
 
+        Collection<SSTableReader> sstables = null;
         // scan for sstables corresponding to this cf and load them
         if (data.loadsstables)
         {
             Directories.SSTableLister sstableFiles = directories.sstableLister(Directories.OnTxnErr.IGNORE).skipTemporary(true);
-            Collection<SSTableReader> sstables = SSTableReader.openAll(sstableFiles.list().entrySet(), metadata);
-            data.addInitialSSTables(sstables);
+            sstables = SSTableReader.openAll(sstableFiles.list().entrySet(), metadata);
+            data.addInitialSSTablesWithoutUpdatingSize(sstables);
         }
 
         // compaction strategy should be created after the CFS has been prepared
@@ -426,6 +424,13 @@ public class ColumnFamilyStore implements ColumnFamilyStoreMBean
         for (IndexMetadata info : metadata.getIndexes())
             indexManager.addIndex(info);
 
+        metric = new TableMetrics(this);
+
+        if (data.loadsstables)
+        {
+            data.updateInitialSSTableSize(sstables);
+        }
+
         if (registerBookkeeping)
         {
             // register the mbean
diff --git a/src/java/org/apache/cassandra/db/lifecycle/Tracker.java b/src/java/org/apache/cassandra/db/lifecycle/Tracker.java
index 58c491c60c..73a3606ffd 100644
--- a/src/java/org/apache/cassandra/db/lifecycle/Tracker.java
+++ b/src/java/org/apache/cassandra/db/lifecycle/Tracker.java
@@ -184,14 +184,25 @@ public class Tracker
     // SETUP / CLEANUP
 
     public void addInitialSSTables(Iterable<SSTableReader> sstables)
+    {
+        addInitialSSTablesWithoutUpdatingSize(sstables);
+        maybeFail(updateSizeTracking(emptySet(), sstables, null));
+        // no notifications or backup necessary
+    }
+
+    public void addInitialSSTablesWithoutUpdatingSize(Iterable<SSTableReader> sstables)
     {
         if (!isDummy())
             setupOnline(sstables);
         apply(updateLiveSet(emptySet(), sstables));
-        maybeFail(updateSizeTracking(emptySet(), sstables, null));
         // no notifications or backup necessary
     }
 
+    public void updateInitialSSTableSize(Iterable<SSTableReader> sstables)
+    {
+        maybeFail(updateSizeTracking(emptySet(), sstables, null));
+    }
+
     public void addSSTables(Iterable<SSTableReader> sstables)
     {
         addInitialSSTables(sstables);
diff --git a/test/unit/org/apache/cassandra/db/ColumnFamilyMetricTest.java b/test/unit/org/apache/cassandra/db/ColumnFamilyMetricTest.java
index 2f7aaa5bf1..9bfe7a5d1d 100644
--- a/test/unit/org/apache/cassandra/db/ColumnFamilyMetricTest.java
+++ b/test/unit/org/apache/cassandra/db/ColumnFamilyMetricTest.java
@@ -19,21 +19,29 @@ package org.apache.cassandra.db;
 
 import java.util.Collection;
 
-import org.apache.cassandra.schema.KeyspaceParams;
-import org.apache.cassandra.utils.FBUtilities;
 import org.junit.BeforeClass;
 import org.junit.Test;
+
+import com.codahale.metrics.Counter;
+import com.codahale.metrics.Gauge;
+import com.codahale.metrics.Histogram;
+import com.codahale.metrics.Meter;
+import com.codahale.metrics.MetricRegistryListener;
+import com.codahale.metrics.Timer;
 import org.apache.cassandra.SchemaLoader;
 import org.apache.cassandra.Util;
 import org.apache.cassandra.io.sstable.format.SSTableReader;
+import org.apache.cassandra.metrics.CassandraMetricsRegistry;
+import org.apache.cassandra.schema.KeyspaceParams;
 import org.apache.cassandra.utils.ByteBufferUtil;
+import org.apache.cassandra.utils.FBUtilities;
 
 import static org.junit.Assert.assertEquals;
 
 public class ColumnFamilyMetricTest
 {
     @BeforeClass
-    public static void defineSchema() throws Exception
+    public static void defineSchema()
     {
         SchemaLoader.prepareServer();
         SchemaLoader.createKeyspace("Keyspace1",
@@ -76,8 +84,8 @@ public class ColumnFamilyMetricTest
         cfs.truncateBlocking();
 
         // after truncate, size metrics should be down to 0
-        Util.spinAssertEquals(0L, () -> cfs.metric.liveDiskSpaceUsed.getCount(), 30);
-        Util.spinAssertEquals(0L, () -> cfs.metric.totalDiskSpaceUsed.getCount(), 30);
+        Util.spinAssertEquals(0L, cfs.metric.liveDiskSpaceUsed::getCount, 30);
+        Util.spinAssertEquals(0L, cfs.metric.totalDiskSpaceUsed::getCount, 30);
 
         cfs.enableAutoCompaction();
     }
@@ -110,4 +118,88 @@ public class ColumnFamilyMetricTest
         // CASSANDRA-11117 - update with large timestamp delta should not overflow the histogram
         store.metric.colUpdateTimeDeltaHistogram.cf.getSnapshot().get999thPercentile();
     }
+
+    @Test
+    public void testStartupRaceConditionOnMetricListeners()
+    {
+        // CASSANDRA-16228
+        // Since the ColumnFamilyStore instance reference escapes during the construction
+        // we have a race condition and listeners can see an instance that is in an unknown state.
+        // This test just check that all callbacks can access the data without throwing any exception.
+        TestBase listener = new TestBase();
+
+        try {
+            CassandraMetricsRegistry.Metrics.addListener(listener);
+
+            SchemaLoader.createKeyspace("Keyspace2",
+                                        KeyspaceParams.simple(1),
+                                        SchemaLoader.standardCFMD("Keyspace2", "Standard2"));
+        }
+        finally {
+            CassandraMetricsRegistry.Metrics.removeListener(listener);
+        }
+    }
+
+    private static class TestBase extends MetricRegistryListener.Base
+    {
+        @Override
+        public void onGaugeAdded(String name, Gauge<?> gauge)
+        {
+            gauge.getValue();
+        }
+
+        @Override
+        public void onGaugeRemoved(String name)
+        {
+
+        }
+
+        @Override
+        public void onCounterAdded(String name, Counter counter)
+        {
+            counter.getCount();
+        }
+
+        @Override
+        public void onCounterRemoved(String name)
+        {
+
+        }
+
+        @Override
+        public void onHistogramAdded(String name, Histogram histogram)
+        {
+            histogram.getCount();
+        }
+
+        @Override
+        public void onHistogramRemoved(String name)
+        {
+
+        }
+
+        @Override
+        public void onMeterAdded(String name, Meter meter)
+        {
+            meter.getCount();
+        }
+
+        @Override
+        public void onMeterRemoved(String name)
+        {
+
+        }
+
+        @Override
+        public void onTimerAdded(String name, Timer timer)
+        {
+            timer.getCount();
+        }
+
+        @Override
+        public void onTimerRemoved(String name)
+        {
+
+        }
+    }
 }
