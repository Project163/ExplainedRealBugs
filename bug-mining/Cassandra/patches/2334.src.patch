diff --git a/CHANGES.txt b/CHANGES.txt
index 6ece609aa8..1c09589220 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -14,6 +14,7 @@
  * Pass the updated cf to the PRSI index() method (CASSANDRA-5999)
  * Allow empty CQL3 batches (as no-op) (CASSANDRA-5994)
  * Support null in CQL3 functions (CASSANDRA-5910)
+ * Replace the deprecated MapMaker with CacheLoader (CASSANDRA-6007)
 
 
 1.2.9
diff --git a/src/java/org/apache/cassandra/service/StorageProxy.java b/src/java/org/apache/cassandra/service/StorageProxy.java
index 94db26d23c..23d73ece18 100644
--- a/src/java/org/apache/cassandra/service/StorageProxy.java
+++ b/src/java/org/apache/cassandra/service/StorageProxy.java
@@ -29,7 +29,7 @@ import java.util.concurrent.atomic.AtomicLong;
 import javax.management.MBeanServer;
 import javax.management.ObjectName;
 
-import com.google.common.base.Function;
+import com.google.common.cache.CacheLoader;
 import com.google.common.collect.*;
 import org.apache.commons.lang.StringUtils;
 import org.slf4j.Logger;
@@ -83,13 +83,13 @@ public class StorageProxy implements StorageProxyMBean
 
     private static volatile int maxHintsInProgress = 1024 * FBUtilities.getAvailableProcessors();
     private static final AtomicInteger totalHintsInProgress = new AtomicInteger();
-    private static final Map<InetAddress, AtomicInteger> hintsInProgress = new MapMaker().concurrencyLevel(1).makeComputingMap(new Function<InetAddress, AtomicInteger>()
+    private static final CacheLoader<InetAddress, AtomicInteger> hintsInProgress = new CacheLoader<InetAddress, AtomicInteger>()
     {
-        public AtomicInteger apply(InetAddress inetAddress)
+        public AtomicInteger load(InetAddress inetAddress)
         {
             return new AtomicInteger(0);
         }
-    });
+    };
     private static final AtomicLong totalHints = new AtomicLong();
     private static final ClientRequestMetrics readMetrics = new ClientRequestMetrics("Read");
     private static final ClientRequestMetrics rangeMetrics = new ClientRequestMetrics("RangeSlice");
@@ -489,7 +489,7 @@ public class StorageProxy implements StorageProxyMBean
             // a small number of nodes causing problems, so we should avoid shutting down writes completely to
             // healthy nodes.  Any node with no hintsInProgress is considered healthy.
             if (totalHintsInProgress.get() > maxHintsInProgress
-                && (hintsInProgress.get(destination).get() > 0 && shouldHint(destination)))
+                && (getHintsInProgressFor(destination).get() > 0 && shouldHint(destination)))
             {
                 throw new OverloadedException("Too many in flight hints: " + totalHintsInProgress.get());
             }
@@ -538,6 +538,18 @@ public class StorageProxy implements StorageProxyMBean
         }
     }
 
+    private static AtomicInteger getHintsInProgressFor(InetAddress destination)
+    {
+        try
+        {
+            return hintsInProgress.load(destination);
+        }
+        catch (Exception e)
+        {
+            throw new AssertionError(e);
+        }
+    }
+
     public static Future<Void> submitHint(final RowMutation mutation,
                                           final InetAddress target,
                                           final AbstractWriteResponseHandler responseHandler,
@@ -572,7 +584,7 @@ public class StorageProxy implements StorageProxyMBean
     private static Future<Void> submitHint(HintRunnable runnable)
     {
         totalHintsInProgress.incrementAndGet();
-        hintsInProgress.get(runnable.target).incrementAndGet();
+        getHintsInProgressFor(runnable.target).incrementAndGet();
         return (Future<Void>) StageManager.getStage(Stage.MUTATION).submit(runnable);
     }
 
@@ -1674,7 +1686,7 @@ public class StorageProxy implements StorageProxyMBean
             finally
             {
                 totalHintsInProgress.decrementAndGet();
-                hintsInProgress.get(target).decrementAndGet();
+                getHintsInProgressFor(target).decrementAndGet();
             }
         }
 
