diff --git a/test/distributed/org/apache/cassandra/distributed/impl/Instance.java b/test/distributed/org/apache/cassandra/distributed/impl/Instance.java
index 72a38e0a80..dff47d0c9b 100644
--- a/test/distributed/org/apache/cassandra/distributed/impl/Instance.java
+++ b/test/distributed/org/apache/cassandra/distributed/impl/Instance.java
@@ -82,6 +82,7 @@ import org.apache.cassandra.distributed.shared.Metrics;
 import org.apache.cassandra.gms.ApplicationState;
 import org.apache.cassandra.gms.Gossiper;
 import org.apache.cassandra.gms.VersionedValue;
+import org.apache.cassandra.hints.DTestSerializer;
 import org.apache.cassandra.hints.HintsService;
 import org.apache.cassandra.index.SecondaryIndexManager;
 import org.apache.cassandra.io.IVersionedSerializer;
@@ -559,6 +560,8 @@ public class Instance extends IsolatedExecutor implements IInvokableInstance
                 SystemKeyspace.persistLocalMetadata();
                 LegacySchemaMigrator.migrate();
 
+                MessagingService.instance().verbSerializers.put(MessagingService.Verb.HINT,
+                                                                new DTestSerializer());
                 try
                 {
                     // load schema from disk
diff --git a/test/distributed/org/apache/cassandra/distributed/test/MessageFiltersTest.java b/test/distributed/org/apache/cassandra/distributed/test/MessageFiltersTest.java
index f4398dac81..3780fe1413 100644
--- a/test/distributed/org/apache/cassandra/distributed/test/MessageFiltersTest.java
+++ b/test/distributed/org/apache/cassandra/distributed/test/MessageFiltersTest.java
@@ -21,6 +21,8 @@ package org.apache.cassandra.distributed.test;
 import java.net.InetSocketAddress;
 import java.util.Arrays;
 import java.util.Set;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 
 import com.google.common.collect.Sets;
@@ -34,9 +36,13 @@ import org.apache.cassandra.distributed.api.IMessage;
 import org.apache.cassandra.distributed.api.IMessageFilters;
 import org.apache.cassandra.distributed.impl.Instance;
 import org.apache.cassandra.distributed.shared.MessageFilters;
+import org.apache.cassandra.hints.HintMessage;
 import org.apache.cassandra.net.MessageIn;
 import org.apache.cassandra.net.MessagingService;
 
+import static org.apache.cassandra.distributed.api.Feature.GOSSIP;
+import static org.apache.cassandra.distributed.api.Feature.NETWORK;
+
 public class MessageFiltersTest extends TestBaseImpl
 {
     @Test
@@ -210,6 +216,59 @@ public class MessageFiltersTest extends TestBaseImpl
         }
     }
 
+    @Test
+    public void hintSerializationTest() throws Exception
+    {
+        try (Cluster cluster = init(builder().withNodes(3)
+                                             .withConfig(config -> config.with(GOSSIP)
+                                                                         .with(NETWORK)
+                                                                         .set("hinted_handoff_enabled", true))
+                                             .start()))
+        {
+            cluster.schemaChange(withKeyspace("CREATE TABLE %s.tbl (k int PRIMARY KEY, v int)"));
+            executeWithWriteFailure(cluster,
+                                    withKeyspace("INSERT INTO %s.tbl (k, v) VALUES (1,1)"),
+                                    ConsistencyLevel.QUORUM,
+                                    1);
+            CountDownLatch latch = new CountDownLatch(1);
+            cluster.filters().verbs(MessagingService.Verb.HINT.ordinal()).messagesMatching((a,b,msg) -> {
+                cluster.get(1).acceptsOnInstance((IIsolatedExecutor.SerializableConsumer<IMessage>) (m) -> {
+                    HintMessage hintMessage = (HintMessage) Instance.deserializeMessage(m).left.payload;
+                    assert hintMessage != null;
+                }).accept(msg);
+
+                latch.countDown();
+                return false;
+            }).drop().on();
+            cluster.schemaChange(withKeyspace("DROP TABLE %s.tbl"));
+            latch.await();
+        }
+    }
+
+    public Object[][] executeWithWriteFailure(Cluster cluster, String statement, ConsistencyLevel cl, int coordinator, Object... bindings)
+    {
+        IMessageFilters filters = cluster.filters();
+
+        // Drop exactly one coordinated message
+        filters.verbs(MessagingService.Verb.MUTATION.ordinal()).from(coordinator).messagesMatching(new IMessageFilters.Matcher()
+        {
+            private final AtomicBoolean issued = new AtomicBoolean();
+
+            public boolean matches(int from, int to, IMessage message)
+            {
+                if (from != coordinator || message.verb() != MessagingService.Verb.MUTATION.ordinal())
+                    return false;
+
+                return !issued.getAndSet(true);
+            }
+        }).drop().on();
+        Object[][] res = cluster
+                         .coordinator(coordinator)
+                         .execute(statement, cl, bindings);
+        filters.reset();
+        return res;
+    }
+
     private static void assertTimeOut(Runnable r)
     {
         try
diff --git a/test/unit/org/apache/cassandra/hints/DTestSerializer.java b/test/unit/org/apache/cassandra/hints/DTestSerializer.java
new file mode 100644
index 0000000000..09b87d32ab
--- /dev/null
+++ b/test/unit/org/apache/cassandra/hints/DTestSerializer.java
@@ -0,0 +1,87 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.cassandra.hints;
+
+import java.io.IOException;
+import java.util.Objects;
+import java.util.UUID;
+
+import com.google.common.primitives.Ints;
+
+import org.apache.cassandra.db.TypeSizes;
+import org.apache.cassandra.db.UnknownColumnFamilyException;
+import org.apache.cassandra.io.IVersionedSerializer;
+import org.apache.cassandra.io.util.DataInputPlus;
+import org.apache.cassandra.io.util.DataOutputPlus;
+import org.apache.cassandra.io.util.TrackedDataInputPlus;
+import org.apache.cassandra.utils.UUIDSerializer;
+
+// Fake serializer for dtests. Located in hints package to avoid publishing package-private fields.
+public class DTestSerializer implements IVersionedSerializer<HintMessage>
+{
+    public long serializedSize(HintMessage message, int version)
+    {
+        if (message.hint != null)
+            return HintMessage.serializer.serializedSize(message, version);
+
+        long size = UUIDSerializer.serializer.serializedSize(message.hostId, version);
+        size += TypeSizes.sizeofUnsignedVInt(0);
+        size += UUIDSerializer.serializer.serializedSize(message.unknownTableID, version);
+        return size;
+    }
+
+    public void serialize(HintMessage message, DataOutputPlus out, int version) throws IOException
+    {
+        if (message.hint != null)
+        {
+            HintMessage.serializer.serialize(message, out, version);
+            return;
+        }
+
+        UUIDSerializer.serializer.serialize(message.hostId, out, version);
+        out.writeUnsignedVInt(0);
+        UUIDSerializer.serializer.serialize(message.unknownTableID, out, version);
+    }
+
+    /*
+     * It's not an exceptional scenario to have a hints file streamed that have partition updates for tables
+     * that don't exist anymore. We want to handle that case gracefully instead of dropping the connection for every
+     * one of them.
+     */
+    public HintMessage deserialize(DataInputPlus in, int version) throws IOException
+    {
+        UUID hostId = UUIDSerializer.serializer.deserialize(in, version);
+
+        long hintSize = in.readUnsignedVInt();
+        TrackedDataInputPlus countingIn = new TrackedDataInputPlus(in);
+
+        if (hintSize == 0)
+            return new HintMessage(hostId, UUIDSerializer.serializer.deserialize(in, version));
+
+        try
+        {
+            return new HintMessage(hostId, Hint.serializer.deserialize(countingIn, version));
+        }
+        catch (UnknownColumnFamilyException e)
+        {
+            in.skipBytes(Ints.checkedCast(hintSize - countingIn.getBytesRead()));
+            return new HintMessage(hostId, e.cfId);
+        }
+    }
+}
\ No newline at end of file
