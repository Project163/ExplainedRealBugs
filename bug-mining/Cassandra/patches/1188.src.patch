diff --git a/CHANGES.txt b/CHANGES.txt
index b6e6906cdc..96d8c22cb4 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -5,6 +5,8 @@
    (CASSANDRA-3269)
  * Evict gossip state immediately when a token is taken over by a new IP (CASSANDRA-3259)
  * tolerate whitespace in seed CDL (CASSANDRA-3263)
+ * Fix bug where the failure detector can take too long to mark a host
+   down (CASSANDRA-3273)
 
 
 1.0.0-rc2
diff --git a/src/java/org/apache/cassandra/gms/FailureDetector.java b/src/java/org/apache/cassandra/gms/FailureDetector.java
index 6cb3ae2c4b..2b57547399 100644
--- a/src/java/org/apache/cassandra/gms/FailureDetector.java
+++ b/src/java/org/apache/cassandra/gms/FailureDetector.java
@@ -149,7 +149,14 @@ public class FailureDetector implements IFailureDetector, FailureDetectorMBean
             logger_.error("unknown endpoint " + ep);
         return epState != null && epState.isAlive();
     }
-    
+
+    public void clear(InetAddress ep)
+    {
+        ArrivalWindow heartbeatWindow = arrivalSamples_.get(ep);
+        if (heartbeatWindow != null)
+            heartbeatWindow.clear();
+    }
+
     public void report(InetAddress ep)
     {
         if (logger_.isTraceEnabled())
@@ -177,7 +184,9 @@ public class FailureDetector implements IFailureDetector, FailureDetectorMBean
             logger_.trace("PHI for " + ep + " : " + phi);
         
         if ( phi > phiConvictThreshold_ )
-        {     
+        {
+            logger_.trace("notifying listeners that {} is down", ep);
+            logger_.trace("intervals: {} mean: {}", hbWnd, hbWnd.mean());
             for ( IFailureDetectionEventListener listener : fdEvntListeners_ )
             {
                 listener.convict(ep, phi);
@@ -234,6 +243,11 @@ class ArrivalWindow
     // change.
     private final double PHI_FACTOR = 1.0 / Math.log(10.0);
 
+    // in the event of a long partition, never record an interval longer than the rpc timeout,
+    // since if a host is regularly experiencing connectivity problems lasting this long we'd
+    // rather mark it down quickly instead of adapting
+    private final double MAX_INTERVAL_IN_MS = DatabaseDescriptor.getRpcTimeout();
+
     ArrivalWindow(int size)
     {
         arrivalIntervals_ = new BoundedStatsDeque(size);
@@ -244,14 +258,17 @@ class ArrivalWindow
         double interArrivalTime;
         if ( tLast_ > 0L )
         {                        
-            interArrivalTime = (value - tLast_);            
+            interArrivalTime = (value - tLast_);
         }
         else
         {
             interArrivalTime = Gossiper.intervalInMillis / 2;
         }
-        tLast_ = value;            
-        arrivalIntervals_.add(interArrivalTime);        
+        if (interArrivalTime <= MAX_INTERVAL_IN_MS)
+            arrivalIntervals_.add(interArrivalTime);
+        else
+            logger_.debug("Ignoring interval time of {}", interArrivalTime);
+        tLast_ = value;
     }
     
     synchronized double sum()
diff --git a/src/java/org/apache/cassandra/gms/Gossiper.java b/src/java/org/apache/cassandra/gms/Gossiper.java
index e0672d7714..cdc88d3371 100644
--- a/src/java/org/apache/cassandra/gms/Gossiper.java
+++ b/src/java/org/apache/cassandra/gms/Gossiper.java
@@ -685,6 +685,13 @@ public class Gossiper implements IFailureDetectionEventListener, GossiperMBean
             if ( remoteGeneration > localGeneration )
             {
                 localEndpointState.updateTimestamp();
+                // this node was dead and the generation changed, this indicates a reboot, or possibly a takeover
+                // we will clean the fd intervals for it and relearn them
+                if (!localEndpointState.isAlive())
+                {
+                    logger.debug("Clearing interval times for {} due to generation change", endpoint);
+                    fd.clear(endpoint);
+                }
                 fd.report(endpoint);
                 return;
             }
@@ -696,6 +703,7 @@ public class Gossiper implements IFailureDetectionEventListener, GossiperMBean
                 if ( remoteVersion > localVersion )
                 {
                     localEndpointState.updateTimestamp();
+                    // just a version change, report to the fd
                     fd.report(endpoint);
                 }
             }
diff --git a/src/java/org/apache/cassandra/gms/IFailureDetector.java b/src/java/org/apache/cassandra/gms/IFailureDetector.java
index 426eec8031..df12bb497a 100644
--- a/src/java/org/apache/cassandra/gms/IFailureDetector.java
+++ b/src/java/org/apache/cassandra/gms/IFailureDetector.java
@@ -37,7 +37,13 @@ public interface IFailureDetector
      * @return true if UP and false if DOWN.
      */
     public boolean isAlive(InetAddress ep);
-    
+
+    /**
+     * Clear any existing interval timings for this endpoint
+     * @param ep
+     */
+    public void clear(InetAddress ep);
+
     /**
      * This method is invoked by any entity wanting to interrogate the status of an endpoint. 
      * In our case it would be the Gossiper. The Failure Detector will then calculate Phi and
