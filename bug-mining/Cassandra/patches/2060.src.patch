diff --git a/CHANGES.txt b/CHANGES.txt
index a1352622e4..f4e854b4db 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -12,6 +12,8 @@
  * Include type arguments in Thrift CQLPreparedResult (CASSANDRA-5311)
  * Fix compaction not removing columns when bf_fp_ratio is 1 (CASSANDRA-5182)
  * cli: Warn about missing CQL3 tables in schema descriptions (CASSANDRA-5309)
+ * Re-enable unknown option in replication/compaction strategies option for
+   backward compatibility (CASSANDRA-4795)
 Merged from 1.1:
  * nodetool: ability to repair specific range (CASSANDRA-5280)
  * Fix possible assertion triggered in SliceFromReadCommand (CASSANDRA-5284)
diff --git a/src/java/org/apache/cassandra/config/CFMetaData.java b/src/java/org/apache/cassandra/config/CFMetaData.java
index ae91d23d70..18cdd93b99 100644
--- a/src/java/org/apache/cassandra/config/CFMetaData.java
+++ b/src/java/org/apache/cassandra/config/CFMetaData.java
@@ -855,7 +855,7 @@ public final class CFMetaData
             throw new ConfigurationException("subcolumncomparators do not match or are note compatible.");
     }
 
-    public static void validateCompactionOptions(Class<? extends AbstractCompactionStrategy> strategyClass, Map<String, String> options) throws ConfigurationException
+    public static void validateCompactionOptions(Class<? extends AbstractCompactionStrategy> strategyClass, Map<String, String> options, boolean checkUnexpected) throws ConfigurationException
     {
         try
         {
@@ -864,7 +864,7 @@ public final class CFMetaData
 
             Method validateMethod = strategyClass.getMethod("validateOptions", Map.class);
             Map<String, String> unknownOptions = (Map<String, String>) validateMethod.invoke(null, options);
-            if (!unknownOptions.isEmpty())
+            if (checkUnexpected && !unknownOptions.isEmpty())
                 throw new ConfigurationException(String.format("Properties specified %s are not understood by %s", unknownOptions.keySet(), strategyClass.getSimpleName()));
         }
         catch (NoSuchMethodException e)
diff --git a/src/java/org/apache/cassandra/config/KSMetaData.java b/src/java/org/apache/cassandra/config/KSMetaData.java
index 9522aa01e8..138e24b26a 100644
--- a/src/java/org/apache/cassandra/config/KSMetaData.java
+++ b/src/java/org/apache/cassandra/config/KSMetaData.java
@@ -206,7 +206,7 @@ public final class KSMetaData
         // Attempt to instantiate the ARS, which will throw a ConfigException if the strategy_options aren't fully formed
         TokenMetadata tmd = StorageService.instance.getTokenMetadata();
         IEndpointSnitch eps = DatabaseDescriptor.getEndpointSnitch();
-        AbstractReplicationStrategy.createReplicationStrategy(name, strategyClass, tmd, eps, strategyOptions);
+        AbstractReplicationStrategy.validateReplicationStrategyIgnoreUnexpected(name, strategyClass, tmd, eps, strategyOptions);
 
         for (CFMetaData cfm : cfMetaData.values())
             cfm.validate();
diff --git a/src/java/org/apache/cassandra/cql/CFPropDefs.java b/src/java/org/apache/cassandra/cql/CFPropDefs.java
index 7185b52e41..7178995a73 100644
--- a/src/java/org/apache/cassandra/cql/CFPropDefs.java
+++ b/src/java/org/apache/cassandra/cql/CFPropDefs.java
@@ -174,7 +174,7 @@ public class CFPropDefs {
                         CFMetaData.DEFAULT_MIN_COMPACTION_THRESHOLD));
         }
 
-        CFMetaData.validateCompactionOptions(compactionStrategyClass, compactionStrategyOptions);
+        CFMetaData.validateCompactionOptions(compactionStrategyClass, compactionStrategyOptions, false);
     }
 
     /** Map a keyword to the corresponding value */
diff --git a/src/java/org/apache/cassandra/cql3/CFPropDefs.java b/src/java/org/apache/cassandra/cql3/CFPropDefs.java
index ccef5f87b2..8ad29fd60b 100644
--- a/src/java/org/apache/cassandra/cql3/CFPropDefs.java
+++ b/src/java/org/apache/cassandra/cql3/CFPropDefs.java
@@ -88,7 +88,7 @@ public class CFPropDefs extends PropertyDefinitions
             compactionStrategyClass = CFMetaData.createCompactionStrategy(strategy);
             compactionOptions.remove(COMPACTION_STRATEGY_CLASS_KEY);
 
-            CFMetaData.validateCompactionOptions(compactionStrategyClass, compactionOptions);
+            CFMetaData.validateCompactionOptions(compactionStrategyClass, compactionOptions, true);
         }
     }
 
diff --git a/src/java/org/apache/cassandra/cql3/statements/AlterKeyspaceStatement.java b/src/java/org/apache/cassandra/cql3/statements/AlterKeyspaceStatement.java
index 52c422a0a0..ef96997fb5 100644
--- a/src/java/org/apache/cassandra/cql3/statements/AlterKeyspaceStatement.java
+++ b/src/java/org/apache/cassandra/cql3/statements/AlterKeyspaceStatement.java
@@ -72,12 +72,14 @@ public class AlterKeyspaceStatement extends SchemaAlteringStatement
         }
         else if (attrs.getReplicationStrategyClass() != null)
         {
-            // trial run to let ARS validate class + per-class options
-            AbstractReplicationStrategy.createReplicationStrategy(name,
-                                                                  AbstractReplicationStrategy.getClass(attrs.getReplicationStrategyClass()),
-                                                                  StorageService.instance.getTokenMetadata(),
-                                                                  DatabaseDescriptor.getEndpointSnitch(),
-                                                                  attrs.getReplicationOptions());
+            // The strategy is validated through KSMetaData.validate() in announceKeyspaceUpdate below.
+            // However, for backward compatibility with thrift, this doesn't validate unexpected options yet,
+            // so doing proper validation here.
+            AbstractReplicationStrategy.validateReplicationStrategy(name,
+                                                                    attrs.getReplicationStrategyClass(),
+                                                                    StorageService.instance.getTokenMetadata(),
+                                                                    DatabaseDescriptor.getEndpointSnitch(),
+                                                                    attrs.getReplicationOptions());
         }
     }
 
diff --git a/src/java/org/apache/cassandra/cql3/statements/CreateKeyspaceStatement.java b/src/java/org/apache/cassandra/cql3/statements/CreateKeyspaceStatement.java
index 0a12f974e2..26e255dafd 100644
--- a/src/java/org/apache/cassandra/cql3/statements/CreateKeyspaceStatement.java
+++ b/src/java/org/apache/cassandra/cql3/statements/CreateKeyspaceStatement.java
@@ -87,12 +87,14 @@ public class CreateKeyspaceStatement extends SchemaAlteringStatement
         if (attrs.getReplicationStrategyClass() == null)
             throw new ConfigurationException("Missing mandatory replication strategy class");
 
-        // trial run to let ARS validate class + per-class options
-        AbstractReplicationStrategy.createReplicationStrategy(name,
-                                                              AbstractReplicationStrategy.getClass(attrs.getReplicationStrategyClass()),
-                                                              StorageService.instance.getTokenMetadata(),
-                                                              DatabaseDescriptor.getEndpointSnitch(),
-                                                              attrs.getReplicationOptions());
+        // The strategy is validated through KSMetaData.validate() in announceNewKeyspace below.
+        // However, for backward compatibility with thrift, this doesn't validate unexpected options yet,
+        // so doing proper validation here.
+        AbstractReplicationStrategy.validateReplicationStrategy(name,
+                                                                attrs.getReplicationStrategyClass(),
+                                                                StorageService.instance.getTokenMetadata(),
+                                                                DatabaseDescriptor.getEndpointSnitch(),
+                                                                attrs.getReplicationOptions());
     }
 
     public void announceMigration() throws RequestValidationException
diff --git a/src/java/org/apache/cassandra/db/DefsTable.java b/src/java/org/apache/cassandra/db/DefsTable.java
index 30614b735c..914789b1eb 100644
--- a/src/java/org/apache/cassandra/db/DefsTable.java
+++ b/src/java/org/apache/cassandra/db/DefsTable.java
@@ -532,18 +532,10 @@ public class DefsTable
 
         Schema.instance.setTableDefinition(newKsm);
 
-        try
-        {
-            if (!StorageService.instance.isClientMode())
-            {
-                Table.open(newState.name).createReplicationStrategy(newKsm);
-                MigrationManager.instance.notifyUpdateKeyspace(newKsm);
-            }
-        }
-        catch (ConfigurationException e)
+        if (!StorageService.instance.isClientMode())
         {
-            // It's too late to throw a configuration exception, we should have catch those previously
-            throw new RuntimeException(e);
+            Table.open(newState.name).createReplicationStrategy(newKsm);
+            MigrationManager.instance.notifyUpdateKeyspace(newKsm);
         }
     }
 
diff --git a/src/java/org/apache/cassandra/db/Table.java b/src/java/org/apache/cassandra/db/Table.java
index d92308196a..3a73f43a3f 100644
--- a/src/java/org/apache/cassandra/db/Table.java
+++ b/src/java/org/apache/cassandra/db/Table.java
@@ -261,14 +261,7 @@ public class Table
         name = table;
         KSMetaData ksm = Schema.instance.getKSMetaData(table);
         assert ksm != null : "Unknown keyspace " + table;
-        try
-        {
-            createReplicationStrategy(ksm);
-        }
-        catch (ConfigurationException e)
-        {
-            throw new RuntimeException(e);
-        }
+        createReplicationStrategy(ksm);
 
         indexLocks = new Object[DatabaseDescriptor.getConcurrentWriters() * 128];
         for (int i = 0; i < indexLocks.length; i++)
@@ -281,7 +274,7 @@ public class Table
         }
     }
 
-    public void createReplicationStrategy(KSMetaData ksm) throws ConfigurationException
+    public void createReplicationStrategy(KSMetaData ksm)
     {
         if (replicationStrategy != null)
             StorageService.instance.getTokenMetadata().unregister(replicationStrategy);
diff --git a/src/java/org/apache/cassandra/locator/AbstractReplicationStrategy.java b/src/java/org/apache/cassandra/locator/AbstractReplicationStrategy.java
index 4b54d94f7c..5ebebcd474 100644
--- a/src/java/org/apache/cassandra/locator/AbstractReplicationStrategy.java
+++ b/src/java/org/apache/cassandra/locator/AbstractReplicationStrategy.java
@@ -211,12 +211,23 @@ public abstract class AbstractReplicationStrategy
 
     public abstract void validateOptions() throws ConfigurationException;
 
-    public static AbstractReplicationStrategy createReplicationStrategy(String table,
-                                                                        Class<? extends AbstractReplicationStrategy> strategyClass,
-                                                                        TokenMetadata tokenMetadata,
-                                                                        IEndpointSnitch snitch,
-                                                                        Map<String, String> strategyOptions)
-            throws ConfigurationException
+    /*
+     * The options recognized by the strategy.
+     * The empty collection means that no options are accepted, but null means
+     * that any option is accepted.
+     */
+    public Collection<String> recognizedOptions()
+    {
+        // We default to null for backward compatibility sake
+        return null;
+    }
+
+    private static AbstractReplicationStrategy createInternal(String table,
+                                                              Class<? extends AbstractReplicationStrategy> strategyClass,
+                                                              TokenMetadata tokenMetadata,
+                                                              IEndpointSnitch snitch,
+                                                              Map<String, String> strategyOptions)
+        throws ConfigurationException
     {
         AbstractReplicationStrategy strategy;
         Class [] parameterTypes = new Class[] {String.class, TokenMetadata.class, IEndpointSnitch.class, Map.class};
@@ -227,24 +238,61 @@ public abstract class AbstractReplicationStrategy
         }
         catch (Exception e)
         {
-            throw new RuntimeException(e);
+            throw new ConfigurationException("Error constructing replication strategy class", e);
         }
-
-        // Throws Config Exception if strat_opts don't contain required info
-        strategy.validateOptions();
-
         return strategy;
     }
 
     public static AbstractReplicationStrategy createReplicationStrategy(String table,
-                                                                        String strategyClassName,
+                                                                        Class<? extends AbstractReplicationStrategy> strategyClass,
                                                                         TokenMetadata tokenMetadata,
                                                                         IEndpointSnitch snitch,
                                                                         Map<String, String> strategyOptions)
-            throws ConfigurationException
     {
-        Class<AbstractReplicationStrategy> c = getClass(strategyClassName);
-        return createReplicationStrategy(table, c, tokenMetadata, snitch, strategyOptions);
+        try
+        {
+            AbstractReplicationStrategy strategy = createInternal(table, strategyClass, tokenMetadata, snitch, strategyOptions);
+
+            // Because we used to not properly validate unrecognized options, we only log a warning if we find one.
+            try
+            {
+                strategy.validateExpectedOptions();
+            }
+            catch (ConfigurationException e)
+            {
+                logger.warn("Ignoring {}", e.getMessage());
+            }
+
+            strategy.validateOptions();
+            return strategy;
+        }
+        catch (ConfigurationException e)
+        {
+            // If that happens at this point, there is nothing we can do about it.
+            throw new RuntimeException();
+        }
+    }
+
+    public static void validateReplicationStrategy(String table,
+                                                   String strategyClassName,
+                                                   TokenMetadata tokenMetadata,
+                                                   IEndpointSnitch snitch,
+                                                   Map<String, String> strategyOptions) throws ConfigurationException
+    {
+        AbstractReplicationStrategy strategy = createInternal(table, getClass(strategyClassName), tokenMetadata, snitch, strategyOptions);
+        strategy.validateExpectedOptions();
+        strategy.validateOptions();
+    }
+
+    // For backward compatibility sake on the thrift side
+    public static void validateReplicationStrategyIgnoreUnexpected(String table,
+                                                                   Class<? extends AbstractReplicationStrategy> strategyClass,
+                                                                   TokenMetadata tokenMetadata,
+                                                                   IEndpointSnitch snitch,
+                                                                   Map<String, String> strategyOptions) throws ConfigurationException
+    {
+        AbstractReplicationStrategy strategy = createInternal(table, strategyClass, tokenMetadata, snitch, strategyOptions);
+        strategy.validateOptions();
     }
 
     public static Class<AbstractReplicationStrategy> getClass(String cls) throws ConfigurationException
@@ -273,8 +321,12 @@ public abstract class AbstractReplicationStrategy
         }
     }
 
-    protected void validateExpectedOptions(Collection<String> expectedOptions) throws ConfigurationException
+    private void validateExpectedOptions() throws ConfigurationException
     {
+        Collection expectedOptions = recognizedOptions();
+        if (expectedOptions == null)
+            return;
+
         for (String key : configOptions.keySet())
         {
             if (!expectedOptions.contains(key))
diff --git a/src/java/org/apache/cassandra/locator/LocalStrategy.java b/src/java/org/apache/cassandra/locator/LocalStrategy.java
index ab580f1917..0e958200c5 100644
--- a/src/java/org/apache/cassandra/locator/LocalStrategy.java
+++ b/src/java/org/apache/cassandra/locator/LocalStrategy.java
@@ -20,6 +20,7 @@ package org.apache.cassandra.locator;
 import java.net.InetAddress;
 import java.util.ArrayList;
 import java.util.Collections;
+import java.util.Collection;
 import java.util.List;
 import java.util.Map;
 
@@ -60,8 +61,12 @@ public class LocalStrategy extends AbstractReplicationStrategy
     }
 
     public void validateOptions() throws ConfigurationException
+    {
+    }
+
+    public Collection<String> recognizedOptions()
     {
         // LocalStrategy doesn't expect any options.
-        validateExpectedOptions(Collections.<String>emptySet());
+        return Collections.<String>emptySet();
     }
 }
diff --git a/src/java/org/apache/cassandra/locator/NetworkTopologyStrategy.java b/src/java/org/apache/cassandra/locator/NetworkTopologyStrategy.java
index ad43197799..c64c792b12 100644
--- a/src/java/org/apache/cassandra/locator/NetworkTopologyStrategy.java
+++ b/src/java/org/apache/cassandra/locator/NetworkTopologyStrategy.java
@@ -188,7 +188,15 @@ public class NetworkTopologyStrategy extends AbstractReplicationStrategy
     {
         for (Entry<String, String> e : this.configOptions.entrySet())
         {
+            if (e.getKey().equalsIgnoreCase("replication_factor"))
+                throw new ConfigurationException("replication_factor is an option for SimpleStrategy, not NetworkTopologyStrategy");
             validateReplicationFactor(e.getValue());
         }
     }
+
+    public Collection<String> recognizedOptions()
+    {
+        // We explicitely allow all options
+        return null;
+    }
 }
diff --git a/src/java/org/apache/cassandra/locator/OldNetworkTopologyStrategy.java b/src/java/org/apache/cassandra/locator/OldNetworkTopologyStrategy.java
index 2e3e3e88ba..a46197e5d7 100644
--- a/src/java/org/apache/cassandra/locator/OldNetworkTopologyStrategy.java
+++ b/src/java/org/apache/cassandra/locator/OldNetworkTopologyStrategy.java
@@ -19,6 +19,8 @@ package org.apache.cassandra.locator;
 
 import java.net.InetAddress;
 import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
@@ -113,4 +115,9 @@ public class OldNetworkTopologyStrategy extends AbstractReplicationStrategy
         }
         validateReplicationFactor(configOptions.get("replication_factor"));
     }
+
+    public Collection<String> recognizedOptions()
+    {
+        return Collections.<String>singleton("replication_factor");
+    }
 }
diff --git a/src/java/org/apache/cassandra/locator/SimpleStrategy.java b/src/java/org/apache/cassandra/locator/SimpleStrategy.java
index 17d171e8f6..c310875e79 100644
--- a/src/java/org/apache/cassandra/locator/SimpleStrategy.java
+++ b/src/java/org/apache/cassandra/locator/SimpleStrategy.java
@@ -19,7 +19,8 @@ package org.apache.cassandra.locator;
 
 import java.net.InetAddress;
 import java.util.ArrayList;
-import java.util.Arrays;
+import java.util.Collections;
+import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
@@ -69,10 +70,14 @@ public class SimpleStrategy extends AbstractReplicationStrategy
 
     public void validateOptions() throws ConfigurationException
     {
-        validateExpectedOptions(Arrays.<String>asList("replication_factor"));
         String rf = configOptions.get("replication_factor");
         if (rf == null)
             throw new ConfigurationException("SimpleStrategy requires a replication_factor strategy option.");
         validateReplicationFactor(rf);
     }
+
+    public Collection<String> recognizedOptions()
+    {
+        return Collections.<String>singleton("replication_factor");
+    }
 }
diff --git a/src/java/org/apache/cassandra/thrift/CassandraServer.java b/src/java/org/apache/cassandra/thrift/CassandraServer.java
index 7edaf2bb2b..70024369fc 100644
--- a/src/java/org/apache/cassandra/thrift/CassandraServer.java
+++ b/src/java/org/apache/cassandra/thrift/CassandraServer.java
@@ -1295,7 +1295,7 @@ public class CassandraServer implements Cassandra.Iface
             cState.hasKeyspaceAccess(keyspace, Permission.CREATE);
             cf_def.unsetId(); // explicitly ignore any id set by client (Hector likes to set zero)
             CFMetaData cfm = CFMetaData.fromThrift(cf_def);
-            CFMetaData.validateCompactionOptions(cfm.compactionStrategyClass, cfm.compactionStrategyOptions);
+            CFMetaData.validateCompactionOptions(cfm.compactionStrategyClass, cfm.compactionStrategyOptions, false);
 
             cfm.addDefaultIndexNames();
             MigrationManager.announceNewColumnFamily(cfm);
@@ -1338,13 +1338,6 @@ public class CassandraServer implements Cassandra.Iface
             state().hasAllKeyspacesAccess(Permission.CREATE);
             ThriftValidation.validateKeyspaceNotYetExisting(ks_def.name);
 
-            // trial run to let ARS validate class + per-class options
-            AbstractReplicationStrategy.createReplicationStrategy(ks_def.name,
-                    AbstractReplicationStrategy.getClass(ks_def.strategy_class),
-                    StorageService.instance.getTokenMetadata(),
-                    DatabaseDescriptor.getEndpointSnitch(),
-                    ks_def.getStrategy_options());
-
             // generate a meaningful error if the user setup keyspace and/or column definition incorrectly
             for (CfDef cf : ks_def.cf_defs)
             {
@@ -1432,7 +1425,7 @@ public class CassandraServer implements Cassandra.Iface
 
             CFMetaData.applyImplicitDefaults(cf_def);
             CFMetaData cfm = CFMetaData.fromThrift(cf_def);
-            CFMetaData.validateCompactionOptions(cfm.compactionStrategyClass, cfm.compactionStrategyOptions);
+            CFMetaData.validateCompactionOptions(cfm.compactionStrategyClass, cfm.compactionStrategyOptions, false);
             cfm.addDefaultIndexNames();
             MigrationManager.announceColumnFamilyUpdate(cfm);
             return Schema.instance.getVersion().toString();
diff --git a/test/unit/org/apache/cassandra/locator/ReplicationStrategyEndpointCacheTest.java b/test/unit/org/apache/cassandra/locator/ReplicationStrategyEndpointCacheTest.java
index 8212468c53..277677faeb 100644
--- a/test/unit/org/apache/cassandra/locator/ReplicationStrategyEndpointCacheTest.java
+++ b/test/unit/org/apache/cassandra/locator/ReplicationStrategyEndpointCacheTest.java
@@ -165,7 +165,7 @@ public class ReplicationStrategyEndpointCacheTest extends SchemaLoader
     {
         return AbstractReplicationStrategy.createReplicationStrategy(
                 strategy.tableName,
-                strategy.getClass().getName(),
+                AbstractReplicationStrategy.getClass(strategy.getClass().getName()),
                 newTmd,
                 strategy.snitch,
                 strategy.configOptions);
