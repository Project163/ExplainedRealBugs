diff --git a/contrib/pig/README.txt b/contrib/pig/README.txt
index e86b701b5b..93eceb24bb 100644
--- a/contrib/pig/README.txt
+++ b/contrib/pig/README.txt
@@ -18,17 +18,22 @@ also set PIG_CONF_DIR to the location of your Hadoop config.
 
 Finally, set the following as environment variables (uppercase,
 underscored), or as Hadoop configuration variables (lowercase, dotted):
-* PIG_RPC_PORT or cassandra.thrift.port : the port thrift is listening on 
 * PIG_INITIAL_ADDRESS or cassandra.thrift.address : initial address to connect to
+* PIG_RPC_PORT or cassandra.thrift.port : the port thrift is listening on
 * PIG_PARTITIONER or cassandra.partitioner.class : cluster partitioner
 
-Run:
+For example, against a local node with the default settings, you'd use:
+export PIG_INITIAL_ADDRESS=localhost
+export PIG_RPC_PORT=9160
+export PIG_PARTITIONER=org.apache.cassandra.dht.RandomPartitioner
+
+Then you can build and run it like this:
 
 contrib/pig$ ant
 contrib/pig$ bin/pig_cassandra -x local example-script.pig
 
 This will run the test script against your Cassandra instance
-and will assume that there is a Keyspace1/Standard1 with some
+and will assume that there is a MyKeyspace/MyColumnFamily with some
 data in it. It will run in local mode (see pig docs for more info).
 
 If you'd like to get to a 'grunt>' shell prompt, run:
@@ -38,24 +43,24 @@ contrib/pig$ bin/pig_cassandra -x local
 Once the 'grunt>' shell has loaded, try a simple program like the
 following, which will determine the top 50 column names:
 
-grunt> rows = LOAD 'cassandra://Keyspace1/Standard1' USING CassandraStorage();
-grunt> cols = FOREACH rows GENERATE flatten($1);
+grunt> rows = LOAD 'cassandra://MyKeyspace/MyColumnFamily' USING CassandraStorage() AS (key, columns: bag {T: tuple(name, value)});
+grunt> cols = FOREACH rows GENERATE flatten(columns);
 grunt> colnames = FOREACH cols GENERATE $0;
-grunt> namegroups = GROUP colnames BY $0;
+grunt> namegroups = GROUP colnames BY (chararray) $0;
 grunt> namecounts = FOREACH namegroups GENERATE COUNT($1), group;
 grunt> orderednames = ORDER namecounts BY $0;
 grunt> topnames = LIMIT orderednames 50;
 grunt> dump topnames;
 
 Slices on columns can also be specified:
-grunt> rows = LOAD 'cassandra://Keyspace1/Standard1&slice_start=C2&slice_end=C4&i&limit=1&reversed=true' USING CassandraStorage();
+grunt> rows = LOAD 'cassandra://MyKeyspace/MyColumnFamily&slice_start=C2&slice_end=C4&i&limit=1&reversed=true' USING CassandraStorage() AS (key, columns: bag {T: tuple(name, value)});
 
 Binary values for slice_start and slice_end can be escaped such as '\u0255'
 
 Outputting to Cassandra requires the same format from input, so the simplest example is:
 
-grunt> rows = LOAD 'cassandra://Keyspace1/Standard1' USING CassandraStorage();
-grunt> STORE rows into 'cassandra://Keyspace1/Standard2' USING CassandraStorage();
+grunt> rows = LOAD 'cassandra://MyKeyspace/MyColumnFamily' USING CassandraStorage();
+grunt> STORE rows into 'cassandra://MyKeyspace/MyColumnFamily' USING CassandraStorage();
 
 Which will copy the ColumnFamily.  Note that the destination ColumnFamily must
 already exist for this to work.
diff --git a/contrib/pig/example-script.pig b/contrib/pig/example-script.pig
index 5b5c0329eb..f88d77365c 100644
--- a/contrib/pig/example-script.pig
+++ b/contrib/pig/example-script.pig
@@ -1,7 +1,7 @@
-rows = LOAD 'cassandra://Keyspace1/Standard1' USING CassandraStorage();
-cols = FOREACH rows GENERATE flatten($1);
+rows = LOAD 'cassandra://MyKeyspace/MyColumnFamily' USING CassandraStorage() AS (key, columns: bag {T: tuple(name, value)});
+cols = FOREACH rows GENERATE flatten(columns);
 colnames = FOREACH cols GENERATE $0;
-namegroups = GROUP colnames BY $0;
+namegroups = GROUP colnames BY (chararray) $0;
 namecounts = FOREACH namegroups GENERATE COUNT($1), group;
 orderednames = ORDER namecounts BY $0;
 topnames = LIMIT orderednames 50;
