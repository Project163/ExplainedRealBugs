diff --git a/CHANGES.txt b/CHANGES.txt
index 5e370ed7e8..bfb0d85b05 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 1.1-dev
+ * avoid returning internal Cassandra classes over JMX (CASSANDRA-2805)
  * add row-level isolation via SnapTree (CASSANDRA-2893)
  * Optimize key count estimation when opening sstable on startup
    (CASSANDRA-2988)
diff --git a/NEWS.txt b/NEWS.txt
index 02ad678633..23a0b1c270 100644
--- a/NEWS.txt
+++ b/NEWS.txt
@@ -34,6 +34,8 @@ Upgrading
     - Make sure that global settings: key_cache_{size_in_mb, save_period}
       and row_cache_{size_in_mb, save_period} in conf/cassandra.yaml are
       used instead of per-ColumnFamily options.
+    - JMX methods no longer return custom Cassandra objects.  Any such methods
+      will now return standard Maps, Lists, etc.
 
 Features
 --------
diff --git a/src/java/org/apache/cassandra/cli/CliClient.java b/src/java/org/apache/cassandra/cli/CliClient.java
index 40c9b967c3..7a39c97075 100644
--- a/src/java/org/apache/cassandra/cli/CliClient.java
+++ b/src/java/org/apache/cassandra/cli/CliClient.java
@@ -35,7 +35,6 @@ import org.antlr.runtime.tree.Tree;
 import org.apache.cassandra.auth.IAuthenticator;
 import org.apache.cassandra.config.ConfigurationException;
 import org.apache.cassandra.db.ColumnFamilyStoreMBean;
-import org.apache.cassandra.db.compaction.CompactionInfo;
 import org.apache.cassandra.db.compaction.CompactionManagerMBean;
 import org.apache.cassandra.db.compaction.OperationType;
 import org.apache.cassandra.db.marshal.*;
@@ -1914,15 +1913,15 @@ public class CliClient
             // compaction manager information
             if (compactionManagerMBean != null)
             {
-                for (CompactionInfo info : compactionManagerMBean.getCompactions())
+                for (Map<String, String> info : compactionManagerMBean.getCompactions())
                 {
                     // if ongoing compaction type is index build
-                    if (info.getTaskType() != OperationType.INDEX_BUILD)
+                    if (info.get("taskType").equals(OperationType.INDEX_BUILD.toString()))
                         continue;
                     sessionState.out.printf("%nCurrently building index %s, completed %d of %d bytes.%n",
-                                            info.getColumnFamily(),
-                                            info.getBytesComplete(),
-                                            info.getTotalBytes());
+                                            info.get("columnfamily"),
+                                            info.get("bytesComplete"),
+                                            info.get("totalBytes"));
                 }
             }
 
diff --git a/src/java/org/apache/cassandra/db/ColumnFamilyStoreMBean.java b/src/java/org/apache/cassandra/db/ColumnFamilyStoreMBean.java
index a5d880b4bf..e06ced6d82 100644
--- a/src/java/org/apache/cassandra/db/ColumnFamilyStoreMBean.java
+++ b/src/java/org/apache/cassandra/db/ColumnFamilyStoreMBean.java
@@ -33,22 +33,22 @@ public interface ColumnFamilyStoreMBean
      * @return the name of the column family
      */
     public String getColumnFamilyName();
-    
+
     /**
      * Returns the total amount of data stored in the memtable, including
      * column related overhead.
-     * 
+     *
      * @return The size in bytes.
      */
     public long getMemtableDataSize();
-    
+
     /**
      * Returns the total number of columns present in the memtable.
-     * 
+     *
      * @return The number of columns.
      */
     public long getMemtableColumnsCount();
-    
+
     /**
      * Returns the number of times that a flush has resulted in the
      * memtable being switched out.
@@ -57,11 +57,6 @@ public interface ColumnFamilyStoreMBean
      */
     public int getMemtableSwitchCount();
 
-    /**
-     * Triggers an immediate memtable flush.
-     */
-    public Object forceFlush() throws IOException;
-
     /**
      * @return a histogram of the number of sstable data files accessed per read: reading this property resets it
      */
@@ -101,7 +96,7 @@ public interface ColumnFamilyStoreMBean
      * @return the number of write operations on this column family
      */
     public long getWriteCount();
-    
+
     /**
      * @return total write latency (divide by getReadCount() for average)
      */
diff --git a/src/java/org/apache/cassandra/db/compaction/CompactionInfo.java b/src/java/org/apache/cassandra/db/compaction/CompactionInfo.java
index 40244c0376..f82e952e79 100644
--- a/src/java/org/apache/cassandra/db/compaction/CompactionInfo.java
+++ b/src/java/org/apache/cassandra/db/compaction/CompactionInfo.java
@@ -19,6 +19,8 @@
 package org.apache.cassandra.db.compaction;
 
 import java.io.Serializable;
+import java.util.HashMap;
+import java.util.Map;
 
 /** Implements serializable to allow structured info to be returned via JMX. */
 public final class CompactionInfo implements Serializable
@@ -86,6 +88,18 @@ public final class CompactionInfo implements Serializable
         return buff.append(')').toString();
     }
 
+    public Map<String, String> asMap()
+    {
+        Map<String, String> ret = new HashMap<String, String>();
+        ret.put("id", Integer.toString(id));
+        ret.put("keyspace", ksname);
+        ret.put("columnfamily", cfname);
+        ret.put("bytesComplete", Long.toString(bytesComplete));
+        ret.put("totalBytes", Long.toString(totalBytes));
+        ret.put("taskType", tasktype.toString());
+        return ret;
+    }
+
     public static abstract class Holder
     {
         private volatile boolean isStopped = false;
diff --git a/src/java/org/apache/cassandra/db/compaction/CompactionManager.java b/src/java/org/apache/cassandra/db/compaction/CompactionManager.java
index b1759c0987..95041be523 100644
--- a/src/java/org/apache/cassandra/db/compaction/CompactionManager.java
+++ b/src/java/org/apache/cassandra/db/compaction/CompactionManager.java
@@ -1047,11 +1047,11 @@ public class CompactionManager implements CompactionManagerMBean
         void finishCompaction(CompactionInfo.Holder ci);
     }
 
-    public List<CompactionInfo> getCompactions()
+    public List<Map<String, String>> getCompactions()
     {
-        List<CompactionInfo> out = new ArrayList<CompactionInfo>();
+        List<Map<String, String>> out = new ArrayList<Map<String, String>>();
         for (CompactionInfo.Holder ci : CompactionExecutor.getCompactions())
-            out.add(ci.getCompactionInfo());
+            out.add(ci.getCompactionInfo().asMap());
         return out;
     }
 
diff --git a/src/java/org/apache/cassandra/db/compaction/CompactionManagerMBean.java b/src/java/org/apache/cassandra/db/compaction/CompactionManagerMBean.java
index a94bf8f7b7..ffb19ee88f 100644
--- a/src/java/org/apache/cassandra/db/compaction/CompactionManagerMBean.java
+++ b/src/java/org/apache/cassandra/db/compaction/CompactionManagerMBean.java
@@ -18,12 +18,14 @@
 
 package org.apache.cassandra.db.compaction;
 
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 
 public interface CompactionManagerMBean
 {
     /** List of running compaction objects. */
-    public List<CompactionInfo> getCompactions();
+    public List<Map<String, String>> getCompactions();
 
     /** List of running compaction summary strings. */
     public List<String> getCompactionSummary();
diff --git a/src/java/org/apache/cassandra/dht/Range.java b/src/java/org/apache/cassandra/dht/Range.java
index e9675f44dd..3caa6d0bd6 100644
--- a/src/java/org/apache/cassandra/dht/Range.java
+++ b/src/java/org/apache/cassandra/dht/Range.java
@@ -37,7 +37,7 @@ import org.apache.cassandra.utils.FBUtilities;
 public class Range<T extends RingPosition> extends AbstractBounds<T> implements Comparable<Range<T>>, Serializable
 {
     public static final long serialVersionUID = 1L;
-    
+
     public Range(T left, T right)
     {
         this(left, right, StorageService.getPartitioner());
@@ -52,7 +52,7 @@ public class Range<T extends RingPosition> extends AbstractBounds<T> implements
     {
         if (isWrapAround(left, right))
         {
-            /* 
+            /*
              * We are wrapping around, so the interval is (a,b] where a >= b,
              * then we have 3 cases which hold for any given token k:
              * (1) a < k -- return true
@@ -67,7 +67,7 @@ public class Range<T extends RingPosition> extends AbstractBounds<T> implements
         else
         {
             /*
-             * This is the range (a, b] where a < b. 
+             * This is the range (a, b] where a < b.
              */
             return bi.compareTo(left) > 0 && right.compareTo(bi) >= 0;
         }
@@ -225,7 +225,7 @@ public class Range<T extends RingPosition> extends AbstractBounds<T> implements
 
     public int compareTo(Range<T> rhs)
     {
-        /* 
+        /*
          * If the range represented by the "this" pointer
          * is a wrap around then it is the smaller one.
          */
@@ -234,7 +234,7 @@ public class Range<T extends RingPosition> extends AbstractBounds<T> implements
 
         if ( isWrapAround(rhs.left, rhs.right) )
             return 1;
-        
+
         return right.compareTo(rhs.right);
     }
 
@@ -326,6 +326,14 @@ public class Range<T extends RingPosition> extends AbstractBounds<T> implements
         return "(" + left + "," + right + "]";
     }
 
+    public List<String> asList()
+    {
+        ArrayList<String> ret = new ArrayList<String>(2);
+        ret.add(left.toString());
+        ret.add(right.toString());
+        return ret;
+    }
+
     public boolean isWrapAround()
     {
         return isWrapAround(left, right);
diff --git a/src/java/org/apache/cassandra/service/StorageService.java b/src/java/org/apache/cassandra/service/StorageService.java
index 96bf678dd3..b2487ac7ab 100644
--- a/src/java/org/apache/cassandra/service/StorageService.java
+++ b/src/java/org/apache/cassandra/service/StorageService.java
@@ -476,7 +476,7 @@ public class StorageService implements IEndpointStateChangeSubscriber, StorageSe
                 FBUtilities.waitOnFutures(flushes);
 
                 CommitLog.instance.shutdownBlocking();
-                
+
                 // wait for miscellaneous tasks like sstable and commitlog segment deletion
                 tasks.shutdown();
                 if (!tasks.awaitTermination(1, TimeUnit.MINUTES))
@@ -659,7 +659,7 @@ public class StorageService implements IEndpointStateChangeSubscriber, StorageSe
         DatabaseDescriptor.setStreamThroughputOutboundMegabitsPerSec(value);
         logger_.info("setstreamthroughput: throttle set to {}", value);
     }
-    
+
     public int getStreamThroughputMbPerSec()
     {
         return DatabaseDescriptor.getStreamThroughputOutboundMegabitsPerSec();
@@ -742,13 +742,13 @@ public class StorageService implements IEndpointStateChangeSubscriber, StorageSe
      * @param keyspace
      * @return
      */
-    public Map<Range<Token>, List<String>> getRangeToEndpointMap(String keyspace)
+    public Map<List<String>, List<String>> getRangeToEndpointMap(String keyspace)
     {
         /* All the ranges for the tokens */
-        Map<Range<Token>, List<String>> map = new HashMap<Range<Token>, List<String>>();
+        Map<List<String>, List<String>> map = new HashMap<List<String>, List<String>>();
         for (Map.Entry<Range<Token>,List<InetAddress>> entry : getRangeToAddressMap(keyspace).entrySet())
         {
-            map.put(entry.getKey(), stringify(entry.getValue()));
+            map.put(entry.getKey().asList(), stringify(entry.getValue()));
         }
         return map;
     }
@@ -773,10 +773,10 @@ public class StorageService implements IEndpointStateChangeSubscriber, StorageSe
      * @param keyspace
      * @return
      */
-    public Map<Range<Token>, List<String>> getRangeToRpcaddressMap(String keyspace)
+    public Map<List<String>, List<String>> getRangeToRpcaddressMap(String keyspace)
     {
         /* All the ranges for the tokens */
-        Map<Range<Token>, List<String>> map = new HashMap<Range<Token>, List<String>>();
+        Map<List<String>, List<String>> map = new HashMap<List<String>, List<String>>();
         for (Map.Entry<Range<Token>, List<InetAddress>> entry : getRangeToAddressMap(keyspace).entrySet())
         {
             List<String> rpcaddrs = new ArrayList<String>();
@@ -784,23 +784,23 @@ public class StorageService implements IEndpointStateChangeSubscriber, StorageSe
             {
                 rpcaddrs.add(getRpcaddress(endpoint));
             }
-            map.put(entry.getKey(), rpcaddrs);
+            map.put(entry.getKey().asList(), rpcaddrs);
         }
         return map;
     }
 
-    public Map<Range<Token>, List<String>> getPendingRangeToEndpointMap(String keyspace)
+    public Map<List<String>, List<String>> getPendingRangeToEndpointMap(String keyspace)
     {
         // some people just want to get a visual representation of things. Allow null and set it to the first
         // non-system table.
         if (keyspace == null)
             keyspace = Schema.instance.getNonSystemTables().get(0);
 
-        Map<Range<Token>, List<String>> map = new HashMap<Range<Token>, List<String>>();
+        Map<List<String>, List<String>> map = new HashMap<List<String>, List<String>>();
         for (Map.Entry<Range<Token>, Collection<InetAddress>> entry : tokenMetadata_.getPendingRanges(keyspace).entrySet())
         {
             List<InetAddress> l = new ArrayList<InetAddress>(entry.getValue());
-            map.put(entry.getKey(), stringify(l));
+            map.put(entry.getKey().asList(), stringify(l));
         }
         return map;
     }
@@ -882,13 +882,13 @@ public class StorageService implements IEndpointStateChangeSubscriber, StorageSe
         return ranges;
     }
 
-    public Map<Token, String> getTokenToEndpointMap()
+    public Map<String, String> getTokenToEndpointMap()
     {
         Map<Token, InetAddress> mapInetAddress = tokenMetadata_.getTokenToEndpointMap();
-        Map<Token, String> mapString = new HashMap<Token, String>(mapInetAddress.size());
+        Map<String, String> mapString = new HashMap<String, String>(mapInetAddress.size());
         for (Map.Entry<Token, InetAddress> entry : mapInetAddress.entrySet())
         {
-            mapString.put(entry.getKey(), entry.getValue().getHostAddress());
+            mapString.put(entry.getKey().toString(), entry.getValue().getHostAddress());
         }
         return mapString;
     }
@@ -1188,13 +1188,13 @@ public class StorageService implements IEndpointStateChangeSubscriber, StorageSe
             SystemTable.removeToken(token);
         }
     }
-    
+
     private void excise(Token token, InetAddress endpoint, long expireTime)
     {
         addExpireTimeIfFound(endpoint, expireTime);
         excise(token, endpoint);
     }
-    
+
     protected void addExpireTimeIfFound(InetAddress endpoint, long expireTime)
     {
         if (expireTime != 0L)
@@ -1325,7 +1325,7 @@ public class StorageService implements IEndpointStateChangeSubscriber, StorageSe
      * @param ranges the ranges to find sources for
      * @return multimap of addresses to ranges the address is responsible for
      */
-    private Multimap<InetAddress, Range<Token>> getNewSourceRanges(String table, Set<Range<Token>> ranges) 
+    private Multimap<InetAddress, Range<Token>> getNewSourceRanges(String table, Set<Range<Token>> ranges)
     {
         InetAddress myAddress = FBUtilities.getBroadcastAddress();
         Multimap<Range<Token>, InetAddress> rangeAddresses = Table.open(table).getReplicationStrategy().getRangeAddresses(tokenMetadata_);
@@ -1400,7 +1400,7 @@ public class StorageService implements IEndpointStateChangeSubscriber, StorageSe
 
         for (String table : Schema.instance.getNonSystemTables())
         {
-            Multimap<Range<Token>, InetAddress> changedRanges = getChangedRangesForLeaving(table, endpoint); 
+            Multimap<Range<Token>, InetAddress> changedRanges = getChangedRangesForLeaving(table, endpoint);
             Set<Range<Token>> myNewRanges = new HashSet<Range<Token>>();
             for (Map.Entry<Range<Token>, InetAddress> entry : changedRanges.entries())
             {
@@ -1959,7 +1959,7 @@ public class StorageService implements IEndpointStateChangeSubscriber, StorageSe
      *
      * @param table keyspace name also known as table
      * @param cf Column family name
-     * @param key key for which we need to find the endpoint 
+     * @param key key for which we need to find the endpoint
      * @return the endpoint responsible for this key
      */
     public List<InetAddress> getNaturalEndpoints(String table, String cf, String key)
@@ -1978,7 +1978,7 @@ public class StorageService implements IEndpointStateChangeSubscriber, StorageSe
      * specified key i.e for replication.
      *
      * @param table keyspace name also known as table
-     * @param pos position for which we need to find the endpoint 
+     * @param pos position for which we need to find the endpoint
      * @return the endpoint responsible for this token
      */
     public List<InetAddress> getNaturalEndpoints(String table, RingPosition pos)
@@ -1991,7 +1991,7 @@ public class StorageService implements IEndpointStateChangeSubscriber, StorageSe
      * specified key i.e for replication.
      *
      * @param table keyspace name also known as table
-     * @param key key for which we need to find the endpoint 
+     * @param key key for which we need to find the endpoint
      * @return the endpoint responsible for this key
      */
     public List<InetAddress> getLiveNaturalEndpoints(String table, ByteBuffer key)
@@ -2586,11 +2586,17 @@ public class StorageService implements IEndpointStateChangeSubscriber, StorageSe
         StorageProxy.truncateBlocking(keyspace, columnFamily);
     }
 
-    public Map<Token, Float> getOwnership()
+    public Map<String, Float> getOwnership()
     {
-        List<Token> sortedTokens = new ArrayList<Token>(getTokenToEndpointMap().keySet());
+        List<Token> sortedTokens = new ArrayList<Token>(tokenMetadata_.getTokenToEndpointMap().keySet());
         Collections.sort(sortedTokens);
-        return partitioner.describeOwnership(sortedTokens);
+        Map<Token, Float> token_map = partitioner.describeOwnership(sortedTokens);
+        Map<String, Float> string_map = new HashMap<String, Float>();
+        for(Map.Entry<Token, Float> entry : token_map.entrySet())
+        {
+            string_map.put(entry.getKey().toString(), entry.getValue());
+        }
+        return string_map;
     }
 
     public List<String> getKeyspaces()
diff --git a/src/java/org/apache/cassandra/service/StorageServiceMBean.java b/src/java/org/apache/cassandra/service/StorageServiceMBean.java
index 675e307782..6b8ad1dbd2 100644
--- a/src/java/org/apache/cassandra/service/StorageServiceMBean.java
+++ b/src/java/org/apache/cassandra/service/StorageServiceMBean.java
@@ -118,7 +118,7 @@ public interface StorageServiceMBean
      *
      * @return mapping of ranges to end points
      */
-    public Map<Range<Token>, List<String>> getRangeToEndpointMap(String keyspace);
+    public Map<List<String>, List<String>> getRangeToEndpointMap(String keyspace);
 
     /**
      * Retrieve a map of range to rpc addresses that describe the ring topology
@@ -126,7 +126,7 @@ public interface StorageServiceMBean
      *
      * @return mapping of ranges to rpc addresses
      */
-    public Map<Range<Token>, List<String>> getRangeToRpcaddressMap(String keyspace);
+    public Map<List<String>, List<String>> getRangeToRpcaddressMap(String keyspace);
 
     /**
      * The same as {@code describeRing(String)} but converts TokenRange to the String for JMX compatibility
@@ -144,7 +144,7 @@ public interface StorageServiceMBean
      * @param keyspace the keyspace to get the pending range map for.
      * @return a map of pending ranges to endpoints
      */
-    public Map<Range<Token>, List<String>> getPendingRangeToEndpointMap(String keyspace);
+    public Map<List<String>, List<String>> getPendingRangeToEndpointMap(String keyspace);
 
     /**
      * Retrieve a map of tokens to endpoints, including the bootstrapping
@@ -152,7 +152,7 @@ public interface StorageServiceMBean
      *
      * @return a map of tokens to endpoints
      */
-    public Map<Token, String> getTokenToEndpointMap();
+    public Map<String, String> getTokenToEndpointMap();
 
     /**
      * Numeric load value.
@@ -304,7 +304,7 @@ public interface StorageServiceMBean
      * given a list of tokens (representing the nodes in the cluster), returns
      *   a mapping from "token -> %age of cluster owned by that token"
      */
-    public Map<Token, Float> getOwnership();
+    public Map<String, Float> getOwnership();
 
     public List<String> getKeyspaces();
 
diff --git a/src/java/org/apache/cassandra/tools/NodeCmd.java b/src/java/org/apache/cassandra/tools/NodeCmd.java
index e9a3d903d5..22939db576 100644
--- a/src/java/org/apache/cassandra/tools/NodeCmd.java
+++ b/src/java/org/apache/cassandra/tools/NodeCmd.java
@@ -197,8 +197,8 @@ public class NodeCmd
      */
     public void printRing(PrintStream outs)
     {
-        Map<Token, String> tokenToEndpoint = probe.getTokenToEndpointMap();
-        List<Token> sortedTokens = new ArrayList<Token>(tokenToEndpoint.keySet());
+        Map<String, String> tokenToEndpoint = probe.getTokenToEndpointMap();
+        List<String> sortedTokens = new ArrayList<String>(tokenToEndpoint.keySet());
         Collections.sort(sortedTokens);
 
         Collection<String> liveNodes = probe.getLiveNodes();
@@ -216,9 +216,9 @@ public class NodeCmd
             outs.printf(format, "", "", "", "", "", "", "", sortedTokens.get(sortedTokens.size() - 1));
 
         // Calculate per-token ownership of the ring
-        Map<Token, Float> ownerships = probe.getOwnership();
+        Map<String, Float> ownerships = probe.getOwnership();
 
-        for (Token token : sortedTokens)
+        for (String token : sortedTokens)
         {
             String primaryEndpoint = tokenToEndpoint.get(token);
             String dataCenter;
@@ -432,12 +432,12 @@ public class NodeCmd
         outs.println("pending tasks: " + cm.getPendingTasks());
         if (cm.getCompactions().size() > 0)
             outs.printf("%25s%16s%16s%16s%16s%10s%n", "compaction type", "keyspace", "column family", "bytes compacted", "bytes total", "progress");
-        for (CompactionInfo c : cm.getCompactions())
+        for (Map<String, String> c : cm.getCompactions())
         {
-            String percentComplete = c.getTotalBytes() == 0
+            String percentComplete = new Long(c.get("totalBytes")) == 0
                                    ? "n/a"
-                                   : new DecimalFormat("0.00").format((double) c.getBytesComplete() / c.getTotalBytes() * 100) + "%";
-            outs.printf("%25s%16s%16s%16s%16s%10s%n", c.getTaskType(), c.getKeyspace(), c.getColumnFamily(), c.getBytesComplete(), c.getTotalBytes(), percentComplete);
+                                   : new DecimalFormat("0.00").format((double) new Long(c.get("bytesComplete")) / new Long(c.get("totalBytes")) * 100) + "%";
+            outs.printf("%25s%16s%16s%16s%16s%10s%n", c.get("taskType"), c.get("keyspace"), c.get("columnfamily"), c.get("bytesComplete"), c.get("totalBytes"), percentComplete);
         }
     }
 
diff --git a/src/java/org/apache/cassandra/tools/NodeProbe.java b/src/java/org/apache/cassandra/tools/NodeProbe.java
index a982b017a7..621a9f6f76 100644
--- a/src/java/org/apache/cassandra/tools/NodeProbe.java
+++ b/src/java/org/apache/cassandra/tools/NodeProbe.java
@@ -227,7 +227,7 @@ public class NodeProbe
         ssProxy.drain();	
     }
     
-    public Map<Token, String> getTokenToEndpointMap()
+    public Map<String, String> getTokenToEndpointMap()
     {
         return ssProxy.getTokenToEndpointMap();
     }
@@ -262,7 +262,7 @@ public class NodeProbe
         return ssProxy.getLoadMap();
     }
 
-    public Map<Token, Float> getOwnership()
+    public Map<String, Float> getOwnership()
     {
         return ssProxy.getOwnership();
     }
@@ -527,9 +527,9 @@ public class NodeProbe
         // Try to find the endpoint using the local token, doing so in a crazy manner
         // to maintain backwards compatibility with the MBean interface
         String stringToken = ssProxy.getToken();
-        Map<Token, String> tokenToEndpoint = ssProxy.getTokenToEndpointMap();
+        Map<String, String> tokenToEndpoint = ssProxy.getTokenToEndpointMap();
 
-        for (Map.Entry<Token, String> pair : tokenToEndpoint.entrySet())
+        for (Map.Entry<String, String> pair : tokenToEndpoint.entrySet())
         {
             if (pair.getKey().toString().equals(stringToken))
             {
