diff --git a/CHANGES.txt b/CHANGES.txt
index 6e3c2c2ab5..85c65334a4 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 2.0.6
+ * Failure detector correctly converts initial value to nanos (CASSANDRA-6658)
  * Add nodetool taketoken to relocate vnodes (CASSANDRA-4445)
  * Fix upgradesstables NPE for non-CF-based indexes (CASSANDRA-6645)
  * Improve nodetool cfhistograms formatting (CASSANDRA-6360)
diff --git a/src/java/org/apache/cassandra/gms/FailureDetector.java b/src/java/org/apache/cassandra/gms/FailureDetector.java
index a7eb82f910..36776bcbfd 100644
--- a/src/java/org/apache/cassandra/gms/FailureDetector.java
+++ b/src/java/org/apache/cassandra/gms/FailureDetector.java
@@ -23,6 +23,7 @@ import java.net.InetAddress;
 import java.net.UnknownHostException;
 import java.util.*;
 import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.TimeUnit;
 import javax.management.MBeanServer;
 import javax.management.ObjectName;
 
@@ -45,7 +46,7 @@ public class FailureDetector implements IFailureDetector, FailureDetectorMBean
 {
     public static final String MBEAN_NAME = "org.apache.cassandra.net:type=FailureDetector";
     private static final int SAMPLE_SIZE = 1000;
-    protected static final int INITIAL_VALUE = getInitialValue();
+    protected static final long INITIAL_VALUE_NANOS = TimeUnit.NANOSECONDS.convert(getInitialValue(), TimeUnit.MILLISECONDS);
 
     public static final IFailureDetector instance = new FailureDetector();
     private static final Logger logger = LoggerFactory.getLogger(FailureDetector.class);
@@ -73,7 +74,7 @@ public class FailureDetector implements IFailureDetector, FailureDetectorMBean
         }
     }
 
-    private static int getInitialValue()
+    private static long getInitialValue()
     {
         String newvalue = System.getProperty("cassandra.fd_initial_value_ms");
         if (newvalue != null)
@@ -296,29 +297,27 @@ class ArrivalWindow
     // change.
     private final double PHI_FACTOR = 1.0 / Math.log(10.0);
 
-    private static final long MILLI_TO_NANO = 1000000L;
-
     // in the event of a long partition, never record an interval longer than the rpc timeout,
     // since if a host is regularly experiencing connectivity problems lasting this long we'd
     // rather mark it down quickly instead of adapting
     // this value defaults to the same initial value the FD is seeded with
-    private final long MAX_INTERVAL_IN_NANO = getMaxInterval() * MILLI_TO_NANO;
+    private final long MAX_INTERVAL_IN_NANO = getMaxInterval();
 
     ArrivalWindow(int size)
     {
         arrivalIntervals = new BoundedStatsDeque(size);
     }
 
-    private static int getMaxInterval()
+    private static long getMaxInterval()
     {
         String newvalue = System.getProperty("cassandra.fd_max_interval_ms");
         if (newvalue != null)
         {
             logger.info("Overriding FD MAX_INTERVAL to {}ms", newvalue);
-            return Integer.parseInt(newvalue);
+            return TimeUnit.NANOSECONDS.convert(Integer.parseInt(newvalue), TimeUnit.MILLISECONDS);
         }
         else
-            return FailureDetector.INITIAL_VALUE;
+            return FailureDetector.INITIAL_VALUE_NANOS;
     }
 
     synchronized void add(long value)
@@ -337,7 +336,7 @@ class ArrivalWindow
             // We use a very large initial interval since the "right" average depends on the cluster size
             // and it's better to err high (false negatives, which will be corrected by waiting a bit longer)
             // than low (false positives, which cause "flapping").
-            arrivalIntervals.add(FailureDetector.INITIAL_VALUE);
+            arrivalIntervals.add(FailureDetector.INITIAL_VALUE_NANOS);
         }
         tLast = value;
     }
