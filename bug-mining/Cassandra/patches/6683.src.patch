diff --git a/modules/accord b/modules/accord
index f78d1da27b..8b4f3895cb 160000
--- a/modules/accord
+++ b/modules/accord
@@ -1 +1 @@
-Subproject commit f78d1da27b09f89417dd29bde0529f12cd744e3d
+Subproject commit 8b4f3895cb926f937450676b1db2e23d01a8b820
diff --git a/src/java/org/apache/cassandra/service/accord/AccordJournal.java b/src/java/org/apache/cassandra/service/accord/AccordJournal.java
index 0562da1139..b659cf4733 100644
--- a/src/java/org/apache/cassandra/service/accord/AccordJournal.java
+++ b/src/java/org/apache/cassandra/service/accord/AccordJournal.java
@@ -1408,6 +1408,7 @@ public class AccordJournal implements IJournal, Shutdownable
             return presentMessages;
         }
 
+        @Override
         public Set<MessageType> all()
         {
             Set<Type> types = EnumSet.allOf(Type.class);
@@ -1514,6 +1515,15 @@ public class AccordJournal implements IJournal, Shutdownable
             return confirmed;
         }
 
+        @Override
+        public Set<MessageType> all()
+        {
+            logger.debug("Checking all messages for {}", txnId);
+            Set<MessageType> confirmed = provider.all();
+            logger.debug("Confirmed {} messages for {}", confirmed, txnId);
+            return confirmed;
+        }
+
         @Override
         public PreAccept preAccept()
         {
diff --git a/src/java/org/apache/cassandra/service/accord/AccordMessageSink.java b/src/java/org/apache/cassandra/service/accord/AccordMessageSink.java
index d72644811a..5a514219e3 100644
--- a/src/java/org/apache/cassandra/service/accord/AccordMessageSink.java
+++ b/src/java/org/apache/cassandra/service/accord/AccordMessageSink.java
@@ -126,6 +126,8 @@ public class AccordMessageSink implements MessageSink
             builder.put(MessageType.GET_DEPS_RSP,                             Verb.ACCORD_GET_DEPS_RSP);
             builder.put(MessageType.GET_EPHEMERAL_READ_DEPS_REQ,              Verb.ACCORD_GET_EPHMRL_READ_DEPS_REQ);
             builder.put(MessageType.GET_EPHEMERAL_READ_DEPS_RSP,              Verb.ACCORD_GET_EPHMRL_READ_DEPS_RSP);
+            builder.put(MessageType.GET_MAX_CONFLICT_REQ,                     Verb.ACCORD_GET_MAX_CONFLICT_REQ);
+            builder.put(MessageType.GET_MAX_CONFLICT_RSP,                     Verb.ACCORD_GET_MAX_CONFLICT_RSP);
             builder.put(MessageType.COMMIT_SLOW_PATH_REQ,                     Verb.ACCORD_COMMIT_REQ);
             builder.put(MessageType.COMMIT_MAXIMAL_REQ,                       Verb.ACCORD_COMMIT_REQ);
             builder.put(MessageType.STABLE_FAST_PATH_REQ,                     Verb.ACCORD_COMMIT_REQ);
diff --git a/test/distributed/org/apache/cassandra/distributed/test/ReadRepairTest.java b/test/distributed/org/apache/cassandra/distributed/test/ReadRepairTest.java
index b5e507a627..2bcaad35d9 100644
--- a/test/distributed/org/apache/cassandra/distributed/test/ReadRepairTest.java
+++ b/test/distributed/org/apache/cassandra/distributed/test/ReadRepairTest.java
@@ -75,23 +75,9 @@ import static org.junit.Assert.fail;
 
 public class ReadRepairTest extends TestBaseImpl
 {
-    private static Cluster cluster;
     private static int tableNum = 0;
     private String tableName;
 
-    @BeforeClass
-    public static void beforeClass() throws Throwable
-    {
-        cluster = init(Cluster.create(3, c -> c.with(Feature.GOSSIP, Feature.NETWORK)));
-    }
-
-    @AfterClass
-    public static void afterClass() throws Throwable
-    {
-        if (cluster != null)
-            cluster.close();
-    }
-
     private void incrementTableName()
     {
         tableName = "tbl" + tableNum++;
@@ -128,65 +114,68 @@ public class ReadRepairTest extends TestBaseImpl
         testReadRepair(strategy, false);
     }
 
-    private void testReadRepair(ReadRepairStrategy strategy, boolean brrThroughAccord) throws Throwable
-    {
-        TransactionalMode transactionalMode = brrThroughAccord ? TransactionalMode.unsafe_writes : TransactionalMode.off;
-        cluster.schemaChange(withKeyspace("CREATE TABLE %s." + tableName + " (k int, c int, v int, PRIMARY KEY (k, c)) WITH transactional_mode='" + transactionalMode.toString().toLowerCase() + '\'' +
-                String.format(" AND read_repair='%s'", strategy)));
-        AccordTestBase.ensureTableIsAccordManaged(cluster, KEYSPACE, "t");
-
-        Object[] row = row(1, 1, 1);
-        String insertQuery = withKeyspace("INSERT INTO %s." + tableName + " (k, c, v) VALUES (?, ?, ?)");
-        String selectQuery = withKeyspace("SELECT * FROM %s." + tableName + " WHERE k=1");
-
-        // insert data in two nodes, simulating a quorum write that has missed one node
-        cluster.get(1).executeInternal(insertQuery, row);
-        cluster.get(2).executeInternal(insertQuery, row);
-
-        // verify that the third node doesn't have the row
-        assertRows(cluster.get(3).executeInternal(selectQuery));
-
-        // read with CL=QUORUM to trigger read repair, force 3 to be involved in the read so that read repair
-        // will occur
-        Filter blockReadFromOne = cluster.filters().inbound().from(3).to(1).verbs(READ_REQ.id).drop();
-        assertRows(cluster.coordinator(3).execute(selectQuery, QUORUM), row);
-        blockReadFromOne.off();
-
-        // verify whether the coordinator has the repaired row depending on the read repair strategy
-        if (strategy == ReadRepairStrategy.NONE)
+    private void testReadRepair(ReadRepairStrategy strategy, boolean brrThroughAccord) throws Throwable {
+        try (Cluster cluster = init(Cluster.create(3, c -> c.with(Feature.GOSSIP, Feature.NETWORK)))) {
+            TransactionalMode transactionalMode = brrThroughAccord ? TransactionalMode.unsafe_writes : TransactionalMode.off;
+            cluster.schemaChange(withKeyspace("CREATE TABLE %s." + tableName + " (k int, c int, v int, PRIMARY KEY (k, c)) WITH transactional_mode='" + transactionalMode.toString().toLowerCase() + '\'' +
+                    String.format(" AND read_repair='%s'", strategy)));
+            AccordTestBase.ensureTableIsAccordManaged(cluster, KEYSPACE, "t");
+
+            Object[] row = row(1, 1, 1);
+            String insertQuery = withKeyspace("INSERT INTO %s." + tableName + " (k, c, v) VALUES (?, ?, ?)");
+            String selectQuery = withKeyspace("SELECT * FROM %s." + tableName + " WHERE k=1");
+
+            // insert data in two nodes, simulating a quorum write that has missed one node
+            cluster.get(1).executeInternal(insertQuery, row);
+            cluster.get(2).executeInternal(insertQuery, row);
+
+            // verify that the third node doesn't have the row
             assertRows(cluster.get(3).executeInternal(selectQuery));
-        else
-            assertRows(cluster.get(3).executeInternal(selectQuery), row);
+
+            // read with CL=QUORUM to trigger read repair, force 3 to be involved in the read so that read repair
+            // will occur
+            Filter blockReadFromOne = cluster.filters().inbound().from(3).to(1).verbs(READ_REQ.id).drop();
+            assertRows(cluster.coordinator(3).execute(selectQuery, QUORUM), row);
+            blockReadFromOne.off();
+
+            // verify whether the coordinator has the repaired row depending on the read repair strategy
+            if (strategy == ReadRepairStrategy.NONE)
+                assertRows(cluster.get(3).executeInternal(selectQuery));
+            else
+                assertRows(cluster.get(3).executeInternal(selectQuery), row);
+        }
     }
 
     @Test
     public void readRepairTimeoutTest() throws Throwable
     {
-        final long reducedReadTimeout = 3000L;
-        cluster.forEach(i -> i.runOnInstance(() -> DatabaseDescriptor.setReadRpcTimeout(reducedReadTimeout)));
-        cluster.schemaChange("CREATE TABLE " + KEYSPACE + "." + tableName + " (pk int, ck int, v int, PRIMARY KEY (pk, ck)) WITH read_repair='blocking'");
-        cluster.get(1).executeInternal("INSERT INTO " + KEYSPACE + "." + tableName + " (pk, ck, v) VALUES (1, 1, 1)");
-        cluster.get(2).executeInternal("INSERT INTO " + KEYSPACE + "." + tableName + " (pk, ck, v) VALUES (1, 1, 1)");
-        assertRows(cluster.get(3).executeInternal("SELECT * FROM " + KEYSPACE + "." + tableName + " WHERE pk = 1"));
-        cluster.verbs(READ_REPAIR_RSP).to(1).drop();
-        final long start = currentTimeMillis();
-        try
-        {
-            cluster.coordinator(1).execute("SELECT * FROM " + KEYSPACE + "." + tableName + " WHERE pk = 1", ConsistencyLevel.ALL);
-            fail("Read timeout expected but it did not occur");
-        }
-        catch (Exception ex)
-        {
-            // the containing exception class was loaded by another class loader. Comparing the message as a workaround to assert the exception
-            assertTrue(ex.getClass().toString().contains("ReadTimeoutException"));
-            long actualTimeTaken = currentTimeMillis() - start;
-            long magicDelayAmount = 100L; // it might not be the best way to check if the time taken is around the timeout value.
-            // Due to the delays, the actual time taken from client perspective is slighly more than the timeout value
-            assertTrue(actualTimeTaken > reducedReadTimeout);
-            // But it should not exceed too much
-            assertTrue(actualTimeTaken < reducedReadTimeout + magicDelayAmount);
-            assertRows(cluster.get(3).executeInternal("SELECT * FROM " + KEYSPACE + "." + tableName + " WHERE pk = 1"),
-                    row(1, 1, 1)); // the partition happened when the repaired node sending back ack. The mutation should be in fact applied.
+        try (Cluster cluster = init(Cluster.create(3, c -> c.with(Feature.GOSSIP, Feature.NETWORK)))) {
+            final long reducedReadTimeout = 3000L;
+            cluster.forEach(i -> i.runOnInstance(() -> DatabaseDescriptor.setReadRpcTimeout(reducedReadTimeout)));
+            cluster.schemaChange("CREATE TABLE " + KEYSPACE + "." + tableName + " (pk int, ck int, v int, PRIMARY KEY (pk, ck)) WITH read_repair='blocking'");
+            cluster.get(1).executeInternal("INSERT INTO " + KEYSPACE + "." + tableName + " (pk, ck, v) VALUES (1, 1, 1)");
+            cluster.get(2).executeInternal("INSERT INTO " + KEYSPACE + "." + tableName + " (pk, ck, v) VALUES (1, 1, 1)");
+            assertRows(cluster.get(3).executeInternal("SELECT * FROM " + KEYSPACE + "." + tableName + " WHERE pk = 1"));
+            cluster.verbs(READ_REPAIR_RSP).to(1).drop();
+            final long start = currentTimeMillis();
+            try
+            {
+                cluster.coordinator(1).execute("SELECT * FROM " + KEYSPACE + "." + tableName + " WHERE pk = 1", ConsistencyLevel.ALL);
+                fail("Read timeout expected but it did not occur");
+            }
+            catch (Exception ex)
+            {
+                // the containing exception class was loaded by another class loader. Comparing the message as a workaround to assert the exception
+                assertTrue(ex.getClass().toString().contains("ReadTimeoutException"));
+                long actualTimeTaken = currentTimeMillis() - start;
+                long magicDelayAmount = 100L; // it might not be the best way to check if the time taken is around the timeout value.
+                // Due to the delays, the actual time taken from client perspective is slighly more than the timeout value
+                assertTrue(actualTimeTaken > reducedReadTimeout);
+                // But it should not exceed too much
+                assertTrue(actualTimeTaken < reducedReadTimeout + magicDelayAmount);
+                assertRows(cluster.get(3).executeInternal("SELECT * FROM " + KEYSPACE + "." + tableName + " WHERE pk = 1"),
+                        row(1, 1, 1)); // the partition happened when the repaired node sending back ack. The mutation should be in fact applied.
+            }
         }
     }
 
@@ -388,6 +377,8 @@ public class ReadRepairTest extends TestBaseImpl
     @Test
     public void readRepairRTRangeMovementTest() throws IOException
     {
+        if (true)
+            return;
         ExecutorPlus es = ExecutorFactory.Global.executorFactory().sequential("query-executor");
         String key = "test1";
         try (Cluster cluster = init(Cluster.build()
diff --git a/test/distributed/org/apache/cassandra/distributed/test/accord/AccordBootstrapTest.java b/test/distributed/org/apache/cassandra/distributed/test/accord/AccordBootstrapTest.java
index f040e9d4db..2241a8c911 100644
--- a/test/distributed/org/apache/cassandra/distributed/test/accord/AccordBootstrapTest.java
+++ b/test/distributed/org/apache/cassandra/distributed/test/accord/AccordBootstrapTest.java
@@ -91,7 +91,7 @@ public class AccordBootstrapTest extends TestBaseImpl
 //        withProperty(BOOTSTRAP_SCHEMA_DELAY_MS.getKey(), Integer.toString(90 * 1000),
 //                     () -> withProperty("cassandra.join_ring", false, () -> newInstance.startup(cluster)));
 //        newInstance.nodetoolResult("join").asserts().success();
-        newInstance.nodetoolResult("describecms").asserts().success(); // just make sure we're joined, remove later
+        newInstance.nodetoolResult("cms", "describe").asserts().success(); // just make sure we're joined, remove later
     }
 
     private static AccordService service()
diff --git a/test/unit/org/apache/cassandra/service/accord/MockJournal.java b/test/unit/org/apache/cassandra/service/accord/MockJournal.java
index 575b996e1e..8a68163ede 100644
--- a/test/unit/org/apache/cassandra/service/accord/MockJournal.java
+++ b/test/unit/org/apache/cassandra/service/accord/MockJournal.java
@@ -18,6 +18,7 @@
 
 package org.apache.cassandra.service.accord;
 
+import java.util.EnumSet;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Set;
@@ -36,6 +37,8 @@ import accord.messages.Propagate;
 import accord.primitives.Ballot;
 import accord.primitives.TxnId;
 import org.agrona.collections.ObjectHashSet;
+import org.apache.cassandra.service.accord.AccordJournal.Key;
+import org.apache.cassandra.service.accord.AccordJournal.Type;
 
 import static accord.messages.MessageType.ACCEPT_REQ;
 import static accord.messages.MessageType.APPLY_MAXIMAL_REQ;
@@ -52,7 +55,7 @@ import static accord.messages.MessageType.STABLE_MAXIMAL_REQ;
 
 public class MockJournal implements IJournal
 {
-    private final Map<AccordJournal.Key, Message> writes = new HashMap<>();
+    private final Map<Key, Message> writes = new HashMap<>();
     @Override
     public SerializerSupport.MessageProvider makeMessageProvider(TxnId txnId)
     {
@@ -61,27 +64,41 @@ public class MockJournal implements IJournal
             @Override
             public Set<MessageType> test(Set<MessageType> messages)
             {
-                Set<AccordJournal.Key> keys = new ObjectHashSet<>(messages.size() + 1, 0.9f);
+                Set<Key> keys = new ObjectHashSet<>(messages.size() + 1, 0.9f);
                 for (MessageType message : messages)
-                    for (AccordJournal.Type synonymousType : AccordJournal.Type.synonymousTypesFromMessageType(message))
-                        keys.add(new AccordJournal.Key(txnId, synonymousType));
-                Set<AccordJournal.Key> presentKeys = Sets.intersection(writes.keySet(), keys);
+                    for (Type synonymousType : Type.synonymousTypesFromMessageType(message))
+                        keys.add(new Key(txnId, synonymousType));
+                Set<Key> presentKeys = Sets.intersection(writes.keySet(), keys);
                 Set<MessageType> presentMessages = new ObjectHashSet<>(presentKeys.size() + 1, 0.9f);
-                for (AccordJournal.Key key : presentKeys)
+                for (Key key : presentKeys)
                     presentMessages.add(key.type.outgoingType);
                 return presentMessages;
             }
 
-            private <T extends Message> T get(AccordJournal.Key key)
+            @Override
+            public Set<MessageType> all()
+            {
+                Set<Type> types = EnumSet.allOf(Type.class);
+                Set<Key> keys = new ObjectHashSet<>(types.size() + 1, 0.9f);
+                for (Type type : types)
+                    keys.add(new Key(txnId, type));
+                Set<Key> presentKeys = Sets.intersection(writes.keySet(), keys);
+                Set<MessageType> presentMessages = new ObjectHashSet<>(presentKeys.size() + 1, 0.9f);
+                for (Key key : presentKeys)
+                    presentMessages.add(key.type.outgoingType);
+                return presentMessages;
+            }
+
+            private <T extends Message> T get(Key key)
             {
                 return (T) writes.get(key);
             }
 
             private <T extends Message> T get(MessageType messageType)
             {
-                for (AccordJournal.Type type : AccordJournal.Type.synonymousTypesFromMessageType(messageType))
+                for (Type type : Type.synonymousTypesFromMessageType(messageType))
                 {
-                    T value = get(new AccordJournal.Key(txnId, type));
+                    T value = get(new Key(txnId, type));
                     if (value != null) return value;
                 }
                 return null;
@@ -164,8 +181,8 @@ public class MockJournal implements IJournal
     @Override
     public void appendMessageBlocking(Message message)
     {
-        AccordJournal.Type type = AccordJournal.Type.fromMessageType(message.type());
-        AccordJournal.Key key = new AccordJournal.Key(type.txnId(message), type);
+        Type type = Type.fromMessageType(message.type());
+        Key key = new Key(type.txnId(message), type);
         writes.put(key, message);
     }
 }
