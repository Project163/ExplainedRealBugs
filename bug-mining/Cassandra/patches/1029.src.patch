diff --git a/CHANGES.txt b/CHANGES.txt
index d2c759bb53..2aada83807 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -22,6 +22,8 @@
  * check column family validity in nodetool repair (CASSANDRA-2933)
  * use lazy initialization instead of class initialization in NodeId
    (CASSANDRA-2953)
+ * fix potential use of free'd native memory in SerializingCache 
+   (CASSANDRA-1951)
 
 
 0.8.2
diff --git a/src/java/org/apache/cassandra/cache/FreeableMemory.java b/src/java/org/apache/cassandra/cache/FreeableMemory.java
index d662075597..945f7b93a6 100644
--- a/src/java/org/apache/cassandra/cache/FreeableMemory.java
+++ b/src/java/org/apache/cassandra/cache/FreeableMemory.java
@@ -22,19 +22,40 @@ package org.apache.cassandra.cache;
 
 
 import java.io.IOException;
+import java.util.concurrent.atomic.AtomicInteger;
 
 import com.sun.jna.Memory;
 
 public class FreeableMemory extends Memory
 {
-	protected volatile boolean valid = true;
-	
+    AtomicInteger references = new AtomicInteger(0);
+
     public FreeableMemory(long size)
     {
         super(size);
     }
 
-    public void free()
+    /** @return true if we succeed in referencing before the reference count reaches zero */
+    public boolean reference()
+    {
+        while (true)
+        {
+            int n = references.get();
+            if (n <= 0)
+                return false;
+            if (references.compareAndSet(n, n + 1))
+                return true;
+        }
+    }
+
+    /** decrement reference count.  if count reaches zero, the object is freed. */
+    public void unreference()
+    {
+        if (references.decrementAndGet() == 0)
+            free();
+    }
+
+    private void free()
     {
         assert peer != 0;
         super.finalize(); // calls free and sets peer to zero
@@ -46,8 +67,8 @@ public class FreeableMemory extends Memory
     @Override
     protected void finalize()
     {
-        if (peer != 0)
-            super.finalize();
+        assert references.get() == 0;
+        assert peer == 0;
     }
     
     public byte getValidByte(long offset)
diff --git a/src/java/org/apache/cassandra/cache/SerializingCache.java b/src/java/org/apache/cassandra/cache/SerializingCache.java
index a505480775..c31536c5db 100644
--- a/src/java/org/apache/cassandra/cache/SerializingCache.java
+++ b/src/java/org/apache/cassandra/cache/SerializingCache.java
@@ -55,7 +55,7 @@ public class SerializingCache<K, V> implements ICache<K, V>
         {
             public void onEviction(K k, FreeableMemory mem)
             {
-                mem.free();
+                mem.unreference();
             }
         };
         this.map = new ConcurrentLinkedHashMap.Builder<K, FreeableMemory>()
@@ -137,7 +137,16 @@ public class SerializingCache<K, V> implements ICache<K, V>
         FreeableMemory mem = map.get(key);
         if (mem == null)
             return null;
-        return deserialize(mem);
+        if (!mem.reference())
+            return null;
+        try
+        {
+            return deserialize(mem);
+        }
+        finally
+        {
+            mem.unreference();
+        }
     }
 
     public void put(K key, V value)
@@ -146,16 +155,17 @@ public class SerializingCache<K, V> implements ICache<K, V>
         if (mem == null)
             return; // out of memory.  never mind.
 
+        mem.reference();
         FreeableMemory old = map.put(key, mem);
         if (old != null)
-            old.free();
+            old.unreference();
     }
 
     public void remove(K key)
     {
         FreeableMemory mem = map.remove(key);
         if (mem != null)
-            mem.free();
+            mem.unreference();
     }
 
     public Set<K> keySet()
