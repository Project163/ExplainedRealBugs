diff --git a/CHANGES.txt b/CHANGES.txt
index 2ffaee5c7c..d3e04a7c5b 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -5,6 +5,7 @@
  * Fix preparing queries with counter increment (CASSANDRA-5022)
  * Fix preparing updates with collections (CASSANDRA-5017)
  * Don't generate UUID based on other node address (CASSANDRA-5002)
+ * Fix message when trying to alter a clustering key type (CASSANDRA-5012)
 Merged from 1.1
  * Improve schema propagation performance (CASSANDRA-5025)
 
diff --git a/src/java/org/apache/cassandra/config/CFMetaData.java b/src/java/org/apache/cassandra/config/CFMetaData.java
index 986e95d628..7ad2dc4f38 100644
--- a/src/java/org/apache/cassandra/config/CFMetaData.java
+++ b/src/java/org/apache/cassandra/config/CFMetaData.java
@@ -731,30 +731,8 @@ public final class CFMetaData
     public void apply(CFMetaData cfm) throws ConfigurationException
     {
         logger.debug("applying {} to {}", cfm, this);
-        // validate
-        if (!cfm.ksName.equals(ksName))
-            throw new ConfigurationException(String.format("Keyspace mismatch (found %s; expected %s)",
-                                                           cfm.ksName, ksName));
-        if (!cfm.cfName.equals(cfName))
-            throw new ConfigurationException(String.format("Column family mismatch (found %s; expected %s)",
-                                                           cfm.cfName, cfName));
-        if (!cfm.cfId.equals(cfId))
-            throw new ConfigurationException(String.format("Column family ID mismatch (found %s; expected %s)",
-                                                           cfm.cfId, cfId));
 
-        if (!cfm.cfType.equals(cfType))
-            throw new ConfigurationException("types do not match.");
-
-        if (!cfm.comparator.isCompatibleWith(comparator))
-            throw new ConfigurationException("comparators do not match or are not compatible.");
-        if (cfm.subcolumnComparator == null)
-        {
-            if (subcolumnComparator != null)
-                throw new ConfigurationException("subcolumncomparators do not match.");
-            // else, it's null and we're good.
-        }
-        else if (!cfm.subcolumnComparator.isCompatibleWith(subcolumnComparator))
-            throw new ConfigurationException("subcolumncomparators do not match or are note compatible.");
+        validateCompatility(cfm);
 
         // TODO: this method should probably return a new CFMetaData so that
         // 1) we can keep comparator and subcolumnComparator final
@@ -813,6 +791,34 @@ public final class CFMetaData
         logger.debug("application result is {}", this);
     }
 
+    public void validateCompatility(CFMetaData cfm) throws ConfigurationException
+    {
+        // validate
+        if (!cfm.ksName.equals(ksName))
+            throw new ConfigurationException(String.format("Keyspace mismatch (found %s; expected %s)",
+                                                           cfm.ksName, ksName));
+        if (!cfm.cfName.equals(cfName))
+            throw new ConfigurationException(String.format("Column family mismatch (found %s; expected %s)",
+                                                           cfm.cfName, cfName));
+        if (!cfm.cfId.equals(cfId))
+            throw new ConfigurationException(String.format("Column family ID mismatch (found %s; expected %s)",
+                                                           cfm.cfId, cfId));
+
+        if (!cfm.cfType.equals(cfType))
+            throw new ConfigurationException("types do not match.");
+
+        if (!cfm.comparator.isCompatibleWith(comparator))
+            throw new ConfigurationException("comparators do not match or are not compatible.");
+        if (cfm.subcolumnComparator == null)
+        {
+            if (subcolumnComparator != null)
+                throw new ConfigurationException("subcolumncomparators do not match.");
+            // else, it's null and we're good.
+        }
+        else if (!cfm.subcolumnComparator.isCompatibleWith(subcolumnComparator))
+            throw new ConfigurationException("subcolumncomparators do not match or are note compatible.");
+    }
+
     public static Class<? extends AbstractCompactionStrategy> createCompactionStrategy(String className) throws ConfigurationException
     {
         className = className.contains(".") ? className : "org.apache.cassandra.db.compaction." + className;
diff --git a/src/java/org/apache/cassandra/service/MigrationManager.java b/src/java/org/apache/cassandra/service/MigrationManager.java
index 9b9fed1122..7fbcfffa68 100644
--- a/src/java/org/apache/cassandra/service/MigrationManager.java
+++ b/src/java/org/apache/cassandra/service/MigrationManager.java
@@ -220,6 +220,8 @@ public class MigrationManager implements IEndpointStateChangeSubscriber
         if (oldCfm == null)
             throw new ConfigurationException(String.format("Cannot update non existing column family '%s' in keyspace '%s'.", cfm.cfName, cfm.ksName));
 
+        oldCfm.validateCompatility(cfm);
+
         logger.info(String.format("Update ColumnFamily '%s/%s' From %s To %s", cfm.ksName, cfm.cfName, oldCfm, cfm));
         announce(oldCfm.toSchemaUpdate(cfm, FBUtilities.timestampMicros()));
     }
