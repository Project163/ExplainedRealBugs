diff --git a/CHANGES.txt b/CHANGES.txt
index a4dc8fd4ac..9509a76318 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,3 +1,4 @@
+2.0.6
  * Add compatibility for Hadoop 0.2.x (CASSANDRA-5201)
  * Fix EstimatedHistogram races (CASSANDRA-6682)
  * Failure detector correctly converts initial value to nanos (CASSANDRA-6658)
@@ -10,6 +11,7 @@
    time histogram (CASSANDRA-6522)
  * Stop CommitLogSegment.close() from calling sync() (CASSANDRA-6652)
  * Make commitlog failure handling configurable (CASSANDRA-6364)
+ * Avoid overlaps in LCS (CASSANDRA-6688)
 Merged from 1.2:
  * Fix broken streams when replacing with same IP (CASSANDRA-6622)
  * Fix upgradesstables NPE for non-CF-based indexes (CASSANDRA-6645)
diff --git a/src/java/org/apache/cassandra/db/compaction/LeveledManifest.java b/src/java/org/apache/cassandra/db/compaction/LeveledManifest.java
index 4347ad522a..a78a8675e7 100644
--- a/src/java/org/apache/cassandra/db/compaction/LeveledManifest.java
+++ b/src/java/org/apache/cassandra/db/compaction/LeveledManifest.java
@@ -113,23 +113,6 @@ public class LeveledManifest
         generations[level].add(reader);
     }
 
-    /**
-     * if the number of SSTables in the current compacted set *by itself* exceeds the target level's
-     * (regardless of the level's current contents), find an empty level instead
-     */
-    private int skipLevels(int newLevel, Iterable<SSTableReader> added)
-    {
-        // Note that we now check if the sstables included in the compaction, *before* the compaction, fit in the next level.
-        // This is needed since we need to decide before the actual compaction what level they will be in.
-        // This should be safe, we might skip levels where the compacted data could have fit but that should be ok.
-        while (maxBytesForLevel(newLevel) < SSTableReader.getTotalBytes(added)
-               && generations[(newLevel + 1)].isEmpty())
-        {
-            newLevel++;
-        }
-        return newLevel;
-    }
-
     public synchronized void replace(Collection<SSTableReader> removed, Collection<SSTableReader> added)
     {
         assert !removed.isEmpty(); // use add() instead of promote when adding new sstables
@@ -449,7 +432,10 @@ public class LeveledManifest
 
                 for (SSTableReader newCandidate : overlappedL0)
                 {
-                    candidates.add(newCandidate);
+                    // overlappedL0 could contain sstables that are not in compactingL0, but do overlap
+                    // other sstables that are
+                    if (overlapping(newCandidate, compactingL0).isEmpty())
+                        candidates.add(newCandidate);
                     remaining.remove(newCandidate);
                 }
 
@@ -572,7 +558,6 @@ public class LeveledManifest
         else
         {
             newLevel = minimumLevel == maximumLevel ? maximumLevel + 1 : maximumLevel;
-            newLevel = skipLevels(newLevel, sstables);
             assert newLevel > 0;
         }
         return newLevel;
