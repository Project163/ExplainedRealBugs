diff --git a/CHANGES.txt b/CHANGES.txt
index 94dc22d699..66013a9939 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -37,9 +37,9 @@
  * CFMetaData.convertToThrift method to set RowCacheProvider (CASSANDRA-3405)
  * acquire compactionlock during truncate (CASSANDRA-3399)
  * fix displaying cfdef entries for super columnfamilies (CASSANDRA-3415)
- * (Hadoop) Fix empty row filtering (CASSANDRA-3450)
  * Make counter shard merging thread safe (CASSANDRA-3178)
 
+
 0.8.7
  * Kill server on wrapped OOME such as from FileChannel.map (CASSANDRA-3201)
  * Allow using quotes in "USE <keyspace>;" CLI command (CASSANDRA-3208)
diff --git a/src/java/org/apache/cassandra/hadoop/ColumnFamilyRecordReader.java b/src/java/org/apache/cassandra/hadoop/ColumnFamilyRecordReader.java
index 1c27638128..87408c6e2b 100644
--- a/src/java/org/apache/cassandra/hadoop/ColumnFamilyRecordReader.java
+++ b/src/java/org/apache/cassandra/hadoop/ColumnFamilyRecordReader.java
@@ -235,55 +235,50 @@ public class ColumnFamilyRecordReader extends RecordReader<ByteBuffer, SortedMap
             {
                 startToken = split.getStartToken();
             } 
-
-            // The removal of empty CF rows could result in an empty List<KeySlice> rows.
-            // Keep trying until we return on reaching the end of the range or rows is nonEmpty.
-            while (rows == null || rows.isEmpty()) {
-                if (startToken.equals(split.getEndToken()))
+            else if (startToken.equals(split.getEndToken()))
+            {
+                rows = null;
+                return;
+            }
+            
+            KeyRange keyRange = new KeyRange(batchRowCount)
+                                .setStart_token(startToken)
+                                .setEnd_token(split.getEndToken());
+            try
+            {
+                rows = client.get_range_slices(new ColumnParent(cfName),
+                                               predicate,
+                                               keyRange,
+                                               consistencyLevel);
+                  
+                // nothing new? reached the end
+                if (rows.isEmpty())
                 {
                     rows = null;
                     return;
                 }
 
-                KeyRange keyRange = new KeyRange(batchRowCount)
-                                    .setStart_token(startToken)
-                                    .setEnd_token(split.getEndToken());
-                try
-                {
-                    rows = client.get_range_slices(new ColumnParent(cfName),
-                                                   predicate,
-                                                   keyRange,
-                                                   consistencyLevel);
-
-                    // nothing new? reached the end
-                    if (rows.isEmpty())
-                    {
-                        rows = null;
-                        return;
-                    }
+                // Pre-compute the last row key, before removing empty rows
+                ByteBuffer lastRowKey = rows.get(rows.size() - 1).key;
 
-                    // Pre-compute the last row key, before removing empty rows
-                    ByteBuffer lastRowKey = rows.get(rows.size() - 1).key;
-
-                    // only remove empty rows if the slice predicate is empty
-                    if (isPredicateEmpty(predicate))
-                    {
-                        Iterator<KeySlice> rowsIterator = rows.iterator();
-                        while (rowsIterator.hasNext())
-                            if (rowsIterator.next().columns.isEmpty())
-                                rowsIterator.remove();
-                    }
-
-                    // reset to iterate through the new batch
-                    i = 0;
-
-                    // prepare for the next slice to be read
-                    startToken = partitioner.getTokenFactory().toString(partitioner.getToken(lastRowKey));
-                }
-                catch (Exception e)
+                // only remove empty rows if the slice predicate is empty
+                if (isPredicateEmpty(predicate))
                 {
-                    throw new RuntimeException(e);
+                    Iterator<KeySlice> rowsIterator = rows.iterator();
+                    while (rowsIterator.hasNext())
+                        if (rowsIterator.next().columns.isEmpty())
+                            rowsIterator.remove();
                 }
+                
+                // reset to iterate through the new batch
+                i = 0;
+
+                // prepare for the next slice to be read
+                startToken = partitioner.getTokenFactory().toString(partitioner.getToken(lastRowKey));
+            }
+            catch (Exception e)
+            {
+                throw new RuntimeException(e);
             }
         }
 
@@ -359,10 +354,8 @@ public class ColumnFamilyRecordReader extends RecordReader<ByteBuffer, SortedMap
     {
         if (predicate != null)
             if (predicate.isSetSlice_range())
-            {
-                if (predicate.getSlice_range().getStart() != null || predicate.getSlice_range().getFinish() != null)
+                if (predicate.getSlice_range().getStart() != null && predicate.getSlice_range().getFinish() != null)
                 return false;
-            }
             else if (predicate.isSetColumn_names())
                 return false;
 
