diff --git a/src/java/org/apache/cassandra/thrift/ThriftValidation.java b/src/java/org/apache/cassandra/thrift/ThriftValidation.java
index c673a9c9e6..de1ce56664 100644
--- a/src/java/org/apache/cassandra/thrift/ThriftValidation.java
+++ b/src/java/org/apache/cassandra/thrift/ThriftValidation.java
@@ -493,9 +493,10 @@ public class ThriftValidation
         if (range.start_token != null && range.end_key != null)
             throw new InvalidRequestException("start token + end key is not a supported key range");
 
+        IPartitioner p = StorageService.getPartitioner();
+
         if (range.start_key != null && range.end_key != null)
         {
-            IPartitioner p = StorageService.getPartitioner();
             Token startToken = p.getToken(range.start_key);
             Token endToken = p.getToken(range.end_key);
             if (startToken.compareTo(endToken) > 0 && !endToken.isMinimum(p))
@@ -506,6 +507,14 @@ public class ThriftValidation
                     throw new InvalidRequestException("start key must sort before (or equal to) finish key in your partitioner!");
             }
         }
+        else if (range.end_token != null)
+        {
+            RowPosition stop = p.getTokenFactory().fromString(range.end_token).maxKeyBound(p);
+            if (range.start_key != null && RowPosition.forKey(range.start_key, p).compareTo(stop) > 0)
+                throw new InvalidRequestException("Start key's token sorts after end token");
+            if (range.start_token != null && p.getTokenFactory().fromString(range.start_token).maxKeyBound(p).compareTo(stop) > 0)
+                throw new InvalidRequestException("Start token sorts after end token");
+        }
 
         validateFilterClauses(metadata, range.row_filter);
 
