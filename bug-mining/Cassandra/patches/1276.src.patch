diff --git a/CHANGES.txt b/CHANGES.txt
index 95a4cce944..ef93a3a74e 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -2,6 +2,8 @@
  * fix invalidate-related test failures (CASSANDRA-3437)
  * add next-gen cqlsh to bin/
  * (CQL) fix handling of rows with no columns (CASSANDRA-3424, 3473)
+ * fix querying supercolumns by name returning only a subset of
+   subcolumns or old subcolumn versions (CASSANDRA-3446)
 Merged from 0.8:
  * Make counter shard merging thread safe (CASSANDRA-3178)
  * fix updating CF row_cache_provider (CASSANDRA-3414)
@@ -12,6 +14,7 @@ Merged from 0.8:
  * Revert CASSANDRA-2855
  * Fix bug preventing the use of efficient cross-DC writes (CASSANDRA-3472)
 
+
 1.0.2
  * "defragment" rows for name-based queries under STCS (CASSANDRA-2503)
  * cleanup usage of StorageService.setMode() (CASANDRA-3388)
diff --git a/src/java/org/apache/cassandra/db/CollationController.java b/src/java/org/apache/cassandra/db/CollationController.java
index 38d6bd18bd..b59e526163 100644
--- a/src/java/org/apache/cassandra/db/CollationController.java
+++ b/src/java/org/apache/cassandra/db/CollationController.java
@@ -59,7 +59,9 @@ public class CollationController
 
     public ColumnFamily getTopLevelColumns()
     {
-        return filter.filter instanceof NamesQueryFilter && cfs.metadata.getDefaultValidator() != CounterColumnType.instance
+        return filter.filter instanceof NamesQueryFilter
+               && (cfs.metadata.cfType == ColumnFamilyType.Standard || filter.path.superColumnName != null)
+               && cfs.metadata.getDefaultValidator() != CounterColumnType.instance
                ? collectTimeOrderedData()
                : collectAllData();
     }
@@ -95,8 +97,7 @@ public class CollationController
 
             // avoid changing the filter columns of the original filter
             // (reduceNameFilter removes columns that are known to be irrelevant)
-            TreeSet<ByteBuffer> filterColumns = new TreeSet<ByteBuffer>(cfs.metadata.comparator);
-            filterColumns.addAll(((NamesQueryFilter) filter.filter).columns);
+            TreeSet<ByteBuffer> filterColumns = new TreeSet<ByteBuffer>(((NamesQueryFilter) filter.filter).columns);
             QueryFilter reducedFilter = new QueryFilter(filter.key, filter.path, new NamesQueryFilter(filterColumns));
 
             /* add the SSTables on disk */
@@ -181,9 +182,9 @@ public class CollationController
      */
     private void reduceNameFilter(QueryFilter filter, ColumnFamily returnCF, long sstableTimestamp)
     {
-        AbstractColumnContainer container = filter.path.superColumnName != null
-                                          ? (SuperColumn) returnCF.getColumn(filter.path.superColumnName)
-                                          : returnCF;
+        AbstractColumnContainer container = filter.path.superColumnName == null
+                                          ? returnCF
+                                          : (SuperColumn) returnCF.getColumn(filter.path.superColumnName);
         if (container == null)
             return;
 
@@ -191,7 +192,7 @@ public class CollationController
         {
             ByteBuffer filterColumn = iterator.next();
             IColumn column = container.getColumn(filterColumn);
-            if (column != null && column.minTimestamp() > sstableTimestamp)
+            if (column != null && column.timestamp() > sstableTimestamp)
                 iterator.remove();
         }
     }
diff --git a/src/java/org/apache/cassandra/db/Column.java b/src/java/org/apache/cassandra/db/Column.java
index 2af5396465..112f5b42f0 100644
--- a/src/java/org/apache/cassandra/db/Column.java
+++ b/src/java/org/apache/cassandra/db/Column.java
@@ -104,11 +104,6 @@ public class Column implements IColumn
         return timestamp;
     }
 
-    public long minTimestamp()
-    {
-        return timestamp;
-    }
-
     public boolean isMarkedForDelete()
     {
         return false;
diff --git a/src/java/org/apache/cassandra/db/IColumn.java b/src/java/org/apache/cassandra/db/IColumn.java
index 40b99e4f91..ade55f65a4 100644
--- a/src/java/org/apache/cassandra/db/IColumn.java
+++ b/src/java/org/apache/cassandra/db/IColumn.java
@@ -81,10 +81,4 @@ public interface IColumn
      * For a super column, this is the max column timestamp of the sub columns.
      */
     public long maxTimestamp();
-
-    /**
-     * For a standard column, this is the same as timestamp().
-     * For a super column, this is the min column timestamp of the sub columns.
-     */
-    public long minTimestamp();
 }
diff --git a/src/java/org/apache/cassandra/db/SuperColumn.java b/src/java/org/apache/cassandra/db/SuperColumn.java
index ed43e570a2..45aa7e749c 100644
--- a/src/java/org/apache/cassandra/db/SuperColumn.java
+++ b/src/java/org/apache/cassandra/db/SuperColumn.java
@@ -138,14 +138,6 @@ public class SuperColumn extends AbstractColumnContainer implements IColumn
         return maxTimestamp;
     }
 
-    public long minTimestamp()
-    {
-        long minTimestamp = getMarkedForDeleteAt();
-        for (IColumn subColumn : getSubColumns())
-            minTimestamp = Math.min(minTimestamp, subColumn.maxTimestamp());
-        return minTimestamp;
-    }
-
     public long mostRecentLiveChangeAt()
     {
         long max = Long.MIN_VALUE;
diff --git a/src/java/org/apache/cassandra/db/TreeMapBackedSortedColumns.java b/src/java/org/apache/cassandra/db/TreeMapBackedSortedColumns.java
index f14436de4a..238ca27d89 100644
--- a/src/java/org/apache/cassandra/db/TreeMapBackedSortedColumns.java
+++ b/src/java/org/apache/cassandra/db/TreeMapBackedSortedColumns.java
@@ -84,13 +84,21 @@ public class TreeMapBackedSortedColumns extends TreeMap<ByteBuffer, IColumn> imp
     public void addColumn(IColumn column, Allocator allocator)
     {
         ByteBuffer name = column.name();
+        // this is a slightly unusual way to structure this; a more natural way is shown in ThreadSafeSortedColumns,
+        // but TreeMap lacks putAbsent.  Rather than split it into a "get, then put" check, we do it as follows,
+        // which saves the extra "get" in the no-conflict case [for both normal and super columns],
+        // in exchange for a re-put in the SuperColumn case.
         IColumn oldColumn = put(name, column);
         if (oldColumn != null)
         {
             if (oldColumn instanceof SuperColumn)
             {
                 assert column instanceof SuperColumn;
+                // since oldColumn is where we've been accumulating results, it's usually going to be faster to
+                // add the new one to the old, then place old back in the Map, rather than copy the old contents
+                // into the new Map entry.
                 ((SuperColumn) oldColumn).putColumn((SuperColumn)column, allocator);
+                put(name,  oldColumn);
             }
             else
             {
diff --git a/test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java b/test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java
index f13b823a3d..f0d2c85b2d 100644
--- a/test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java
+++ b/test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java
@@ -51,6 +51,7 @@ import static junit.framework.Assert.assertEquals;
 import static junit.framework.Assert.assertTrue;
 import static org.apache.cassandra.Util.column;
 import static org.apache.cassandra.Util.getBytes;
+import static org.apache.cassandra.db.TableTest.assertColumns;
 import static org.junit.Assert.assertNull;
 
 import org.junit.Test;
@@ -575,14 +576,14 @@ public class ColumnFamilyStoreTest extends CleanupHelper
     {
         RowMutation rm = new RowMutation(cfs.table.name, key.key);
         ColumnFamily cf = ColumnFamily.create(cfs.table.name, cfs.getColumnFamilyName());
-        SuperColumn sc = new SuperColumn(scfName, LongType.instance);
+        SuperColumn sc = new SuperColumn(scfName, cfs.metadata.subcolumnComparator);
         for (Column col : cols)
             sc.addColumn(col);
         cf.addColumn(sc);
         rm.add(cf);
         rm.apply();
     }
-    
+
     private static void putColsStandard(ColumnFamilyStore cfs, DecoratedKey key, Column... cols) throws Throwable
     {
         RowMutation rm = new RowMutation(cfs.table.name, key.key);
@@ -679,4 +680,28 @@ public class ColumnFamilyStoreTest extends CleanupHelper
                 assertTrue("can not find backedup file:" + desc.filenameFor(c), new File(desc.filenameFor(c)).exists());
         }
     }
+    
+    @Test
+    public void testSuperSliceByNamesCommandOn() throws Throwable
+    {
+        String tableName = "Keyspace1";
+        String cfName= "Super4";
+        ByteBuffer superColName = ByteBufferUtil.bytes("HerpDerp");
+        DecoratedKey key = Util.dk("multiget-slice-resurrection");
+        Table table = Table.open(tableName);
+        ColumnFamilyStore cfs = table.getColumnFamilyStore(cfName);
+
+        // Initially create a SC with 1 subcolumn
+        putColsSuper(cfs, key, superColName, new Column(ByteBufferUtil.bytes("c1"), ByteBufferUtil.bytes("a"), 1));
+        cfs.forceBlockingFlush();
+
+        // Add another column
+        putColsSuper(cfs, key, superColName, new Column(ByteBufferUtil.bytes("c2"), ByteBufferUtil.bytes("b"), 2));
+
+        // Test fetching the supercolumn by name
+        SliceByNamesReadCommand cmd = new SliceByNamesReadCommand(tableName, key.key, new QueryPath(cfName), Collections.singletonList(superColName));
+        ColumnFamily cf = cmd.getRow(table).cf;
+        SuperColumn superColumn = (SuperColumn) cf.getColumn(superColName);
+        assertColumns(superColumn, "c1", "c2");
+    }
 }
diff --git a/test/unit/org/apache/cassandra/db/ColumnFamilyTest.java b/test/unit/org/apache/cassandra/db/ColumnFamilyTest.java
index 08149c7e96..2d2658fcad 100644
--- a/test/unit/org/apache/cassandra/db/ColumnFamilyTest.java
+++ b/test/unit/org/apache/cassandra/db/ColumnFamilyTest.java
@@ -30,13 +30,15 @@ import org.junit.Test;
 import org.apache.cassandra.io.util.DataOutputBuffer;
 import org.apache.cassandra.db.filter.QueryPath;
 import static org.apache.cassandra.Util.column;
+import static org.junit.Assert.assertEquals;
+
 import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.cassandra.utils.HeapAllocator;
 
 
 public class ColumnFamilyTest extends SchemaLoader
 {
-    // TODO test SuperColumns
+    // TODO test SuperColumns more
 
     @Test
     public void testSingleColumn() throws IOException
@@ -146,4 +148,34 @@ public class ColumnFamilyTest extends SchemaLoader
         cf_result.addColumn(QueryPath.column(ByteBufferUtil.bytes("col3")), ByteBufferUtil.bytes("z"), 2);
         assert cf_result.getColumn(ByteBufferUtil.bytes("col3")).value().equals(ByteBufferUtil.bytes("z"));
     }
+
+    private void testSuperColumnResolution(ISortedColumns.Factory factory)
+    {
+        ColumnFamilyStore cfs = Table.open("Keyspace1").getColumnFamilyStore("Super1");
+        ColumnFamily cf = ColumnFamily.create(cfs.metadata, factory);
+        ByteBuffer superColumnName = ByteBufferUtil.bytes("sc");
+        ByteBuffer subColumnName = ByteBufferUtil.bytes(1L);
+
+        Column first = new Column(subColumnName, ByteBufferUtil.bytes("one"), 1L);
+        Column second = new Column(subColumnName, ByteBufferUtil.bytes("two"), 2L);
+
+        cf.addColumn(superColumnName, first);
+
+        // resolve older + new
+        cf.addColumn(superColumnName, second);
+        assertEquals(second, cf.getColumn(superColumnName).getSubColumn(subColumnName));
+
+        // resolve new + older
+        cf.addColumn(superColumnName, first);
+        assertEquals(second, cf.getColumn(superColumnName).getSubColumn(subColumnName));
+    }
+
+    @Test
+    public void testSuperColumnResolution()
+    {
+        testSuperColumnResolution(TreeMapBackedSortedColumns.factory());
+        testSuperColumnResolution(ThreadSafeSortedColumns.factory());
+        // array-sorted does allow conflict resolution IF it is the last column.  Bit of an edge case.
+        testSuperColumnResolution(ArrayBackedSortedColumns.factory());
+    }
 }
diff --git a/test/unit/org/apache/cassandra/db/TableTest.java b/test/unit/org/apache/cassandra/db/TableTest.java
index 3460adbc0c..62ae97a6b2 100644
--- a/test/unit/org/apache/cassandra/db/TableTest.java
+++ b/test/unit/org/apache/cassandra/db/TableTest.java
@@ -542,17 +542,10 @@ public class TableTest extends CleanupHelper
 
         String[] columnNames1 = names.toArray(new String[0]);
         String[] la = L.toArray(new String[columns.size()]);
-        StringBuffer lasb = new StringBuffer();
-        for (String l: la)
-        {
-            lasb.append(l);
-            lasb.append(", ");
-        }
 
         assert Arrays.equals(la, columnNames1)
-                : String.format("Columns [%s(as string: %s)])] is not expected [%s]",
+                : String.format("Columns [%s])] is not expected [%s]",
                                 ((container == null) ? "" : container.getComparator().getColumnsString(columns)),
-                                lasb.toString(),
                                 StringUtils.join(columnNames1, ","));
     }
 
@@ -573,6 +566,4 @@ public class TableTest extends CleanupHelper
         assertEquals(0, ByteBufferUtil.compareUnsigned(column.value(), ByteBufferUtil.bytes(value)));
         assertEquals(timestamp, column.timestamp());
     }
-
-
 }
