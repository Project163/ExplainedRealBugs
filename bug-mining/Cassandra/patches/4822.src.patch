diff --git a/src/java/org/apache/cassandra/db/AbstractReadCommandBuilder.java b/src/java/org/apache/cassandra/db/AbstractReadCommandBuilder.java
index dab22c70e1..afbab74d82 100644
--- a/src/java/org/apache/cassandra/db/AbstractReadCommandBuilder.java
+++ b/src/java/org/apache/cassandra/db/AbstractReadCommandBuilder.java
@@ -189,6 +189,13 @@ public abstract class AbstractReadCommandBuilder
 
     protected ClusteringIndexFilter makeFilter()
     {
+        // StatementRestrictions.isColumnRange() returns false for static compact tables, which means
+        // SelectStatement.makeClusteringIndexFilter uses a names filter with no clusterings for static
+        // compact tables, here we reproduce this behavior (CASSANDRA-11223). Note that this code is only
+        // called by tests.
+        if (cfs.metadata.isStaticCompactTable())
+            return new ClusteringIndexNamesFilter(new TreeSet<>(cfs.metadata.comparator), reversed);
+
         if (clusterings != null)
         {
             return new ClusteringIndexNamesFilter(clusterings, reversed);
diff --git a/src/java/org/apache/cassandra/db/PartitionRangeReadCommand.java b/src/java/org/apache/cassandra/db/PartitionRangeReadCommand.java
index 617e2f50f3..fb2dd0d422 100644
--- a/src/java/org/apache/cassandra/db/PartitionRangeReadCommand.java
+++ b/src/java/org/apache/cassandra/db/PartitionRangeReadCommand.java
@@ -309,7 +309,8 @@ public class PartitionRangeReadCommand extends ReadCommand
     @Override
     public boolean selectsFullPartition()
     {
-        return dataRange.selectsAllPartition() && !rowFilter().hasExpressionOnClusteringOrRegularColumns();
+        return metadata().isStaticCompactTable() ||
+               (dataRange.selectsAllPartition() && !rowFilter().hasExpressionOnClusteringOrRegularColumns());
     }
 
     @Override
diff --git a/src/java/org/apache/cassandra/db/SinglePartitionReadCommand.java b/src/java/org/apache/cassandra/db/SinglePartitionReadCommand.java
index 319eeb4044..686ec35c61 100644
--- a/src/java/org/apache/cassandra/db/SinglePartitionReadCommand.java
+++ b/src/java/org/apache/cassandra/db/SinglePartitionReadCommand.java
@@ -918,7 +918,8 @@ public class SinglePartitionReadCommand extends ReadCommand
     @Override
     public boolean selectsFullPartition()
     {
-        return clusteringIndexFilter.selectsAllPartition() && !rowFilter().hasExpressionOnClusteringOrRegularColumns();
+        return metadata().isStaticCompactTable() ||
+               (clusteringIndexFilter.selectsAllPartition() && !rowFilter().hasExpressionOnClusteringOrRegularColumns());
     }
 
     @Override
diff --git a/src/java/org/apache/cassandra/db/filter/ClusteringIndexNamesFilter.java b/src/java/org/apache/cassandra/db/filter/ClusteringIndexNamesFilter.java
index 7769f2e3f8..f4859cd1ae 100644
--- a/src/java/org/apache/cassandra/db/filter/ClusteringIndexNamesFilter.java
+++ b/src/java/org/apache/cassandra/db/filter/ClusteringIndexNamesFilter.java
@@ -72,7 +72,9 @@ public class ClusteringIndexNamesFilter extends AbstractClusteringIndexFilter
 
     public boolean selectsAllPartition()
     {
-        return false;
+        // if the clusterings set is empty we are selecting a static row and in this case we want to count
+        // static rows so we return true
+        return clusterings.isEmpty();
     }
 
     public boolean selects(Clustering clustering)
diff --git a/test/unit/org/apache/cassandra/cql3/validation/operations/SelectLimitTest.java b/test/unit/org/apache/cassandra/cql3/validation/operations/SelectLimitTest.java
index 7e90c0a355..8ef4b58c53 100644
--- a/test/unit/org/apache/cassandra/cql3/validation/operations/SelectLimitTest.java
+++ b/test/unit/org/apache/cassandra/cql3/validation/operations/SelectLimitTest.java
@@ -94,6 +94,43 @@ public class SelectLimitTest extends CQLTester
 
     }
 
+    @Test
+    public void testLimitInStaticTable() throws Throwable
+    {
+        createTable("CREATE TABLE %s (k int, v int, PRIMARY KEY (k) ) WITH COMPACT STORAGE ");
+
+        for (int i = 0; i < 10; i++)
+            execute("INSERT INTO %s(k, v) VALUES (?, ?)", i, i);
+
+        assertRows(execute("SELECT * FROM %s LIMIT 5"),
+                   row(0, 0),
+                   row(1, 1),
+                   row(2, 2),
+                   row(3, 3),
+                   row(4, 4));
+
+        assertRows(execute("SELECT v FROM %s LIMIT 5"),
+                   row(0),
+                   row(1),
+                   row(2),
+                   row(3),
+                   row(4));
+
+        assertRows(execute("SELECT k FROM %s LIMIT 5"),
+                   row(0),
+                   row(1),
+                   row(2),
+                   row(3),
+                   row(4));
+
+        assertRows(execute("SELECT DISTINCT k FROM %s LIMIT 5"),
+                   row(0),
+                   row(1),
+                   row(2),
+                   row(3),
+                   row(4));
+    }
+
     /**
      * Check for #7052 bug,
      * migrated from cql_tests.py:TestCQL.limit_compact_table()
diff --git a/test/unit/org/apache/cassandra/db/PartitionRangeReadTest.java b/test/unit/org/apache/cassandra/db/PartitionRangeReadTest.java
index d5fb8fa367..c6968daa85 100644
--- a/test/unit/org/apache/cassandra/db/PartitionRangeReadTest.java
+++ b/test/unit/org/apache/cassandra/db/PartitionRangeReadTest.java
@@ -30,7 +30,9 @@ import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
 import org.apache.cassandra.*;
+import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.config.ColumnDefinition;
+import org.apache.cassandra.db.marshal.AsciiType;
 import org.apache.cassandra.db.rows.Row;
 import org.apache.cassandra.db.marshal.IntegerType;
 import org.apache.cassandra.db.partitions.*;
@@ -44,6 +46,7 @@ public class PartitionRangeReadTest
     public static final String KEYSPACE2 = "PartitionRangeReadTest2";
     public static final String CF_STANDARD1 = "Standard1";
     public static final String CF_STANDARDINT = "StandardInteger1";
+    public static final String CF_COMPACT1 = "Compact1";
 
     @BeforeClass
     public static void defineSchema() throws ConfigurationException
@@ -52,7 +55,13 @@ public class PartitionRangeReadTest
         SchemaLoader.createKeyspace(KEYSPACE1,
                                     KeyspaceParams.simple(1),
                                     SchemaLoader.standardCFMD(KEYSPACE1, CF_STANDARD1),
-                                    SchemaLoader.denseCFMD(KEYSPACE1, CF_STANDARDINT, IntegerType.instance));
+                                    SchemaLoader.denseCFMD(KEYSPACE1, CF_STANDARDINT, IntegerType.instance),
+                                    CFMetaData.Builder.create(KEYSPACE1, CF_COMPACT1, false, false, false)
+                                                      .addPartitionKey("key", AsciiType.instance)
+                                                      .addClusteringColumn("column1", AsciiType.instance)
+                                                      .addRegularColumn("value", AsciiType.instance)
+                                                      .addStaticColumn("val", AsciiType.instance)
+                                                      .build());
         SchemaLoader.createKeyspace(KEYSPACE2,
                                     KeyspaceParams.simple(1),
                                     SchemaLoader.standardCFMD(KEYSPACE2, CF_STANDARD1));
@@ -108,6 +117,30 @@ public class PartitionRangeReadTest
         assertTrue(row.getCell(cDef).value().equals(ByteBufferUtil.bytes("val2")));
     }
 
+    @Test
+    public void testLimits()
+    {
+        ColumnFamilyStore cfs = Keyspace.open(KEYSPACE1).getColumnFamilyStore(CF_COMPACT1);
+        for (int i = 0; i < 10; i++)
+        {
+            new RowUpdateBuilder(cfs.metadata, 0, Integer.toString(i))
+            .add("val", "abcd")
+            .build()
+            .applyUnsafe();
+
+            new RowUpdateBuilder(cfs.metadata, 0, Integer.toString(i))
+            .clustering("column1")
+            .add("value", "")
+            .build()
+            .applyUnsafe();
+        }
+
+        assertEquals(10, Util.getAll(Util.cmd(cfs).build()).size());
+
+        for (int i = 0; i < 10; i++)
+            assertEquals(i, Util.getAll(Util.cmd(cfs).withLimit(i).build()).size());
+    }
+
     @Test
     public void testRangeSliceInclusionExclusion() throws Throwable
     {
