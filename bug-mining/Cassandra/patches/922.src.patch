diff --git a/CHANGES.txt b/CHANGES.txt
index 56c7c38f0f..ebf6f0f94c 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -5,6 +5,7 @@
  * avoid attempting to replay mutations from dropped keyspaces (CASSANDRA-2631)
  * avoid using cached position of a key when GT is requested (CASSANDRA-2633)
  * fix counting bloom filter true positives (CASSANDRA-2637)
+ * initialize local ep state prior to gossip startup if needed (CASSANDRA-2638)
 
 
 0.8.0-rc1
diff --git a/src/java/org/apache/cassandra/gms/Gossiper.java b/src/java/org/apache/cassandra/gms/Gossiper.java
index 37b453948c..7e23dd4fa0 100644
--- a/src/java/org/apache/cassandra/gms/Gossiper.java
+++ b/src/java/org/apache/cassandra/gms/Gossiper.java
@@ -27,6 +27,7 @@ import java.util.*;
 import java.util.Map.Entry;
 import java.util.concurrent.*;
 
+import org.apache.cassandra.db.SystemTable;
 import org.apache.cassandra.net.MessageProducer;
 import org.apache.cassandra.utils.FBUtilities;
 import org.cliffc.high_scale_lib.NonBlockingHashMap;
@@ -838,15 +839,9 @@ public class Gossiper implements IFailureDetectionEventListener
         }
 
         /* initialize the heartbeat state for this localEndpoint */
+        maybeInitializeLocalState(generationNbr);
         EndpointState localState = endpointStateMap.get(FBUtilities.getLocalAddress());
-        if ( localState == null )
-        {
-            HeartBeatState hbState = new HeartBeatState(generationNbr);
-            localState = new EndpointState(hbState);
-            localState.markAlive();
-            endpointStateMap.put(FBUtilities.getLocalAddress(), localState);
-        }
-
+        
         //notify snitches that Gossiper is about to start
         DatabaseDescriptor.getEndpointSnitch().gossiperStarting();
         if (logger.isTraceEnabled())
@@ -857,6 +852,19 @@ public class Gossiper implements IFailureDetectionEventListener
                                                               Gossiper.intervalInMillis,
                                                               TimeUnit.MILLISECONDS);
     }
+    
+    // initialize local HB state if needed.
+    public void maybeInitializeLocalState(int generationNbr) 
+    {
+        EndpointState localState = endpointStateMap.get(FBUtilities.getLocalAddress());
+        if ( localState == null )
+        {
+            HeartBeatState hbState = new HeartBeatState(generationNbr);
+            localState = new EndpointState(hbState);
+            localState.markAlive();
+            endpointStateMap.put(FBUtilities.getLocalAddress(), localState);
+        }
+    }
 
     /**
      * Add an endpoint we knew about previously, but whose state is unknown
diff --git a/src/java/org/apache/cassandra/service/AbstractCassandraDaemon.java b/src/java/org/apache/cassandra/service/AbstractCassandraDaemon.java
index 0378edcab1..a9e343adf5 100644
--- a/src/java/org/apache/cassandra/service/AbstractCassandraDaemon.java
+++ b/src/java/org/apache/cassandra/service/AbstractCassandraDaemon.java
@@ -29,6 +29,7 @@ import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 
+import org.apache.cassandra.gms.Gossiper;
 import org.apache.log4j.PropertyConfigurator;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -179,6 +180,7 @@ public abstract class AbstractCassandraDaemon implements CassandraDaemon
         UUID lastMigration = Migration.getLastMigrationId();
         if ((lastMigration != null) && (lastMigration.timestamp() > currentMigration.timestamp()))
         {
+            Gossiper.instance.maybeInitializeLocalState(SystemTable.incrementAndGetGeneration());
             MigrationManager.applyMigrations(currentMigration, lastMigration);
         }
         
