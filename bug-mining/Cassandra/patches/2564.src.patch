diff --git a/CHANGES.txt b/CHANGES.txt
index 46b14fca2f..8e757b26ae 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -10,6 +10,7 @@
  * Don't special case received counts in CAS timeout exceptions (CASSANDRA-6595)
  * Add support for 2.1 global counter shards (CASSANDRA-6505)
  * Fix NPE when streaming connection is not yet established (CASSANDRA-6210)
+ * Avoid rare duplicate read repair triggering (CASSANDRA-6606)
 Merged from 1.2:
  * fsync compression metadata (CASSANDRA-6531)
  * Validate CF existence on execution for prepared statement (CASSANDRA-6535)
diff --git a/src/java/org/apache/cassandra/service/ReadCallback.java b/src/java/org/apache/cassandra/service/ReadCallback.java
index d66524203a..afff530818 100644
--- a/src/java/org/apache/cassandra/service/ReadCallback.java
+++ b/src/java/org/apache/cassandra/service/ReadCallback.java
@@ -117,7 +117,7 @@ public class ReadCallback<TMessage, TResolved> implements IAsyncCallback<TMessag
         if (n >= blockfor && resolver.isDataPresent())
         {
             condition.signalAll();
-            maybeResolveForRepair();
+            maybeResolveForRepair(n);
         }
     }
 
@@ -151,11 +151,11 @@ public class ReadCallback<TMessage, TResolved> implements IAsyncCallback<TMessag
 
     /**
      * Check digests in the background on the Repair stage if we've received replies
-     * too all the requests we sent.
+     * to all the requests we sent.
      */
-    protected void maybeResolveForRepair()
+    protected void maybeResolveForRepair(int n)
     {
-        if (blockfor < endpoints.size() && received.get() == endpoints.size())
+        if (blockfor < endpoints.size() && n == endpoints.size())
         {
             assert resolver.isDataPresent();
             StageManager.getStage(Stage.READ_REPAIR).execute(new AsyncRepairRunner());
