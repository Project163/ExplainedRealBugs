diff --git a/CHANGES.txt b/CHANGES.txt
index d27be1ffb2..6c601e5a88 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 1.2.19
+ * Don't allow compacted sstables to be marked as compacting (CASSANDRA-7145)
  * Track expired tombstones (CASSANDRA-7810)
  * Validate empty cell names from counter updates (CASSANDRA-7798)
  * Improve PasswordAuthenticator default super user setup (CASSANDRA-7788)
diff --git a/src/java/org/apache/cassandra/db/DataTracker.java b/src/java/org/apache/cassandra/db/DataTracker.java
index 3e271d3391..a1092fadee 100644
--- a/src/java/org/apache/cassandra/db/DataTracker.java
+++ b/src/java/org/apache/cassandra/db/DataTracker.java
@@ -22,6 +22,7 @@ import java.util.*;
 import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.atomic.AtomicReference;
 
+import com.google.common.base.Predicate;
 import com.google.common.collect.*;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -183,6 +184,18 @@ public class DataTracker
         if (inactive.size() < sstables.size())
             return false;
 
+        if (Iterables.any(sstables, new Predicate<SSTableReader>()
+        {
+            @Override
+            public boolean apply(SSTableReader sstable)
+            {
+                return sstable.isMarkedCompacted();
+            }
+        }))
+        {
+            return false;
+        }
+
         View newView = currentView.markCompacting(inactive);
         return view.compareAndSet(currentView, newView);
     }
diff --git a/src/java/org/apache/cassandra/db/compaction/LeveledManifest.java b/src/java/org/apache/cassandra/db/compaction/LeveledManifest.java
index fc108835a9..796eb903a6 100644
--- a/src/java/org/apache/cassandra/db/compaction/LeveledManifest.java
+++ b/src/java/org/apache/cassandra/db/compaction/LeveledManifest.java
@@ -529,7 +529,10 @@ public class LeveledManifest
                 // add sstables from L1 that overlap candidates
                 // if the overlapping ones are already busy in a compaction, leave it out.
                 // TODO try to find a set of L0 sstables that only overlaps with non-busy L1 sstables
-                candidates = Sets.union(candidates, overlapping(candidates, generations[1]));
+                Set<SSTableReader> l1overlapping = overlapping(candidates, generations[1]);
+                if (Sets.intersection(l1overlapping, compacting).size() > 0)
+                    return Collections.emptyList();
+                candidates = Sets.union(candidates, l1overlapping);
             }
             // check overlap with L0 compacting sstables to make sure we are not generating overlap in L1.
             Iterable<SSTableReader> compactingL0 = Iterables.filter(generations[0], Predicates.in(compacting));
diff --git a/src/java/org/apache/cassandra/io/sstable/SSTableReader.java b/src/java/org/apache/cassandra/io/sstable/SSTableReader.java
index 4af1cdcc8b..ba7093c4f8 100644
--- a/src/java/org/apache/cassandra/io/sstable/SSTableReader.java
+++ b/src/java/org/apache/cassandra/io/sstable/SSTableReader.java
@@ -994,6 +994,11 @@ public class SSTableReader extends SSTable implements Closeable
         return !isCompacted.getAndSet(true);
     }
 
+    public boolean isMarkedCompacted()
+    {
+        return isCompacted.get();
+    }
+
     public void markSuspect()
     {
         if (logger.isDebugEnabled())
