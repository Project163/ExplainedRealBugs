diff --git a/src/java/org/apache/cassandra/db/marshal/AbstractType.java b/src/java/org/apache/cassandra/db/marshal/AbstractType.java
index 1b94a74441..7a674336a7 100644
--- a/src/java/org/apache/cassandra/db/marshal/AbstractType.java
+++ b/src/java/org/apache/cassandra/db/marshal/AbstractType.java
@@ -332,6 +332,19 @@ public abstract class AbstractType<T> implements Comparator<ByteBuffer>
         return this;
     }
 
+    /**
+     * Returns an AbstractType instance that is equivalent to this one, but with all nested UDTs explicitly frozen and
+     * all collections in UDTs explicitly frozen.
+     *
+     * This is only necessary for 2.x -> 3.x schema migrations, and can be removed in Cassandra 4.0.
+     *
+     * See CASSANDRA-11609
+     */
+    public AbstractType<?> freezeNestedUDTs()
+    {
+        return this;
+    }
+
     /**
      * Returns {@code true} for types where empty should be handled like {@code null} like {@link Int32Type}.
      */
diff --git a/src/java/org/apache/cassandra/db/marshal/ListType.java b/src/java/org/apache/cassandra/db/marshal/ListType.java
index 4480dcb035..b3fc4f5cbb 100644
--- a/src/java/org/apache/cassandra/db/marshal/ListType.java
+++ b/src/java/org/apache/cassandra/db/marshal/ListType.java
@@ -109,6 +109,15 @@ public class ListType<T> extends CollectionType<List<T>>
             return this;
     }
 
+    @Override
+    public AbstractType<?> freezeNestedUDTs()
+    {
+        if (elements.isUDT() && elements.isMultiCell())
+            return getInstance(elements.freeze(), isMultiCell);
+        else
+            return getInstance(elements.freezeNestedUDTs(), isMultiCell);
+    }
+
     @Override
     public boolean isMultiCell()
     {
diff --git a/src/java/org/apache/cassandra/db/marshal/MapType.java b/src/java/org/apache/cassandra/db/marshal/MapType.java
index 425ffc25f5..3c5af99c4a 100644
--- a/src/java/org/apache/cassandra/db/marshal/MapType.java
+++ b/src/java/org/apache/cassandra/db/marshal/MapType.java
@@ -116,6 +116,20 @@ public class MapType<K, V> extends CollectionType<Map<K, V>>
             return this;
     }
 
+    @Override
+    public AbstractType<?> freezeNestedUDTs()
+    {
+        AbstractType<?> keyType = (keys.isUDT() && keys.isMultiCell())
+                                ? keys.freeze()
+                                : keys.freezeNestedUDTs();
+
+        AbstractType<?> valueType = (values.isUDT() && values.isMultiCell())
+                                  ? values.freeze()
+                                  : values.freezeNestedUDTs();
+
+        return getInstance(keyType, valueType, isMultiCell);
+    }
+
     @Override
     public boolean isCompatibleWithFrozen(CollectionType<?> previous)
     {
diff --git a/src/java/org/apache/cassandra/db/marshal/SetType.java b/src/java/org/apache/cassandra/db/marshal/SetType.java
index 22577b3652..46c0741d78 100644
--- a/src/java/org/apache/cassandra/db/marshal/SetType.java
+++ b/src/java/org/apache/cassandra/db/marshal/SetType.java
@@ -104,6 +104,15 @@ public class SetType<T> extends CollectionType<Set<T>>
             return this;
     }
 
+    @Override
+    public AbstractType<?> freezeNestedUDTs()
+    {
+        if (elements.isUDT() && elements.isMultiCell())
+            return getInstance(elements.freeze(), isMultiCell);
+        else
+            return getInstance(elements.freezeNestedUDTs(), isMultiCell);
+    }
+
     @Override
     public boolean isCompatibleWithFrozen(CollectionType<?> previous)
     {
diff --git a/src/java/org/apache/cassandra/db/marshal/UserType.java b/src/java/org/apache/cassandra/db/marshal/UserType.java
index 72ed895285..433cb870af 100644
--- a/src/java/org/apache/cassandra/db/marshal/UserType.java
+++ b/src/java/org/apache/cassandra/db/marshal/UserType.java
@@ -21,6 +21,7 @@ import java.nio.ByteBuffer;
 import java.nio.charset.CharacterCodingException;
 import java.nio.charset.StandardCharsets;
 import java.util.*;
+import java.util.stream.Collectors;
 
 import com.google.common.base.Objects;
 
@@ -302,6 +303,17 @@ public class UserType extends TupleType
             return this;
     }
 
+    @Override
+    public AbstractType<?> freezeNestedUDTs()
+    {
+        // the behavior here doesn't exactly match the method name: we want to freeze everything inside of UDTs
+        List<AbstractType<?>> newTypes = fieldTypes().stream()
+                .map(subtype -> (subtype.isFreezable() && subtype.isMultiCell() ? subtype.freeze() : subtype))
+                .collect(Collectors.toList());
+
+        return new UserType(keyspace, name, fieldNames, newTypes, isMultiCell);
+    }
+
     @Override
     public int hashCode()
     {
diff --git a/src/java/org/apache/cassandra/schema/LegacySchemaMigrator.java b/src/java/org/apache/cassandra/schema/LegacySchemaMigrator.java
index 9d277d6e7a..ebe80060d4 100644
--- a/src/java/org/apache/cassandra/schema/LegacySchemaMigrator.java
+++ b/src/java/org/apache/cassandra/schema/LegacySchemaMigrator.java
@@ -683,6 +683,11 @@ public final class LegacySchemaMigrator
 
         AbstractType<?> validator = parseType(row.getString("validator"));
 
+        // In the 2.x schema we didn't store UDT's with a FrozenType wrapper because they were implicitly frozen.  After
+        // CASSANDRA-7423 (non-frozen UDTs), this is no longer true, so we need to freeze nested UDTs to properly
+        // migrate the schema.  See CASSANDRA-11609.
+        validator = validator.freezeNestedUDTs();
+
         return new ColumnDefinition(keyspace, table, name, validator, componentIndex, kind);
     }
 
