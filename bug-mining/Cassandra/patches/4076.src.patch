diff --git a/CHANGES.txt b/CHANGES.txt
index 57e985d251..024aaa017f 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 3.0.3
+ * Ensure SSTables for legacy KEYS indexes can be read (CASSANDRA-11045)
  * Added support for IBM zSystems architecture (CASSANDRA-11054)
  * Update CQL documentation (CASSANDRA-10899)
  * Check the column name, not cell name, for dropped columns when reading
diff --git a/src/java/org/apache/cassandra/db/LegacyLayout.java b/src/java/org/apache/cassandra/db/LegacyLayout.java
index e9e5169175..6121227ccd 100644
--- a/src/java/org/apache/cassandra/db/LegacyLayout.java
+++ b/src/java/org/apache/cassandra/db/LegacyLayout.java
@@ -142,7 +142,7 @@ public abstract class LegacyLayout
         ByteBuffer column = metadata.isCompound() ? CompositeType.extractComponent(cellname, metadata.comparator.size()) : cellname;
         if (column == null)
         {
-            // 2ndary indexes tables used to be compound but dense, but we've transformed then into regular tables
+            // Tables for composite 2ndary indexes used to be compound but dense, but we've transformed them into regular tables
             // (non compact ones) but with no regular column (i.e. we only care about the clustering). So we'll get here
             // in that case, and what we want to return is basically a row marker.
             if (metadata.partitionColumns().isEmpty())
diff --git a/src/java/org/apache/cassandra/index/internal/CassandraIndex.java b/src/java/org/apache/cassandra/index/internal/CassandraIndex.java
index 158b12769d..7cb4471994 100644
--- a/src/java/org/apache/cassandra/index/internal/CassandraIndex.java
+++ b/src/java/org/apache/cassandra/index/internal/CassandraIndex.java
@@ -10,6 +10,7 @@ import java.util.regex.Pattern;
 import java.util.stream.Collectors;
 import java.util.stream.StreamSupport;
 
+import com.google.common.collect.ImmutableSet;
 import org.apache.commons.lang3.StringUtils;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -26,6 +27,7 @@ import org.apache.cassandra.db.lifecycle.SSTableSet;
 import org.apache.cassandra.db.lifecycle.View;
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.db.marshal.CollectionType;
+import org.apache.cassandra.db.marshal.EmptyType;
 import org.apache.cassandra.db.partitions.PartitionIterator;
 import org.apache.cassandra.db.partitions.PartitionUpdate;
 import org.apache.cassandra.db.rows.*;
@@ -710,14 +712,35 @@ public abstract class CassandraIndex implements Index
         CassandraIndexFunctions utils = getFunctions(indexMetadata, target);
         ColumnDefinition indexedColumn = target.left;
         AbstractType<?> indexedValueType = utils.getIndexedValueType(indexedColumn);
-        CFMetaData.Builder builder = CFMetaData.Builder.create(baseCfsMetadata.ksName,
-                                                               baseCfsMetadata.indexColumnFamilyName(indexMetadata))
-                                                       .withId(baseCfsMetadata.cfId)
-                                                       .withPartitioner(new LocalPartitioner(indexedValueType))
-                                                       .addPartitionKey(indexedColumn.name, indexedColumn.type);
-
-        builder.addClusteringColumn("partition_key", baseCfsMetadata.partitioner.partitionOrdering());
-        builder = utils.addIndexClusteringColumns(builder, baseCfsMetadata, indexedColumn);
+
+        // Tables for legacy KEYS indexes are non-compound and dense
+        CFMetaData.Builder builder = indexMetadata.isKeys()
+                                     ? CFMetaData.Builder.create(baseCfsMetadata.ksName,
+                                                                 baseCfsMetadata.indexColumnFamilyName(indexMetadata),
+                                                                 true, false, false)
+                                     : CFMetaData.Builder.create(baseCfsMetadata.ksName,
+                                                                 baseCfsMetadata.indexColumnFamilyName(indexMetadata));
+
+        builder =  builder.withId(baseCfsMetadata.cfId)
+                          .withPartitioner(new LocalPartitioner(indexedValueType))
+                          .addPartitionKey(indexedColumn.name, indexedColumn.type)
+                          .addClusteringColumn("partition_key", baseCfsMetadata.partitioner.partitionOrdering());
+
+        if (indexMetadata.isKeys())
+        {
+            // A dense, compact table for KEYS indexes must have a compact
+            // value column defined, even though it is never used
+            CompactTables.DefaultNames names =
+                CompactTables.defaultNameGenerator(ImmutableSet.of(indexedColumn.name.toString(), "partition_key"));
+            builder = builder.addRegularColumn(names.defaultCompactValueName(), EmptyType.instance);
+        }
+        else
+        {
+            // The clustering columns for a table backing a COMPOSITES index are dependent
+            // on the specific type of index (there are specializations for indexes on collections)
+            builder = utils.addIndexClusteringColumns(builder, baseCfsMetadata, indexedColumn);
+        }
+
         return builder.build().reloadIndexMetadataProperties(baseCfsMetadata);
     }
 
