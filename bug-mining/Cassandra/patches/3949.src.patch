diff --git a/CHANGES.txt b/CHANGES.txt
index 008d4d4ea9..6ccde28b16 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 2.1.12
+ * Don't remove level info when running upgradesstables (CASSANDRA-10692)
  * Create compression chunk for sending file only (CASSANDRA-10680)
  * Make buffered read size configurable (CASSANDRA-10249)
  * Forbid compact clustering column type changes in ALTER TABLE (CASSANDRA-8879)
diff --git a/src/java/org/apache/cassandra/db/compaction/WrappingCompactionStrategy.java b/src/java/org/apache/cassandra/db/compaction/WrappingCompactionStrategy.java
index ae6759942e..71a6bc17c9 100644
--- a/src/java/org/apache/cassandra/db/compaction/WrappingCompactionStrategy.java
+++ b/src/java/org/apache/cassandra/db/compaction/WrappingCompactionStrategy.java
@@ -122,6 +122,21 @@ public final class WrappingCompactionStrategy extends AbstractCompactionStrategy
         }, false);
     }
 
+    @Override
+    public AbstractCompactionTask getCompactionTask(Collection<SSTableReader> sstables, final int gcBefore, long maxSSTableBytes)
+    {
+        assert sstables.size() > 0;
+        boolean repairedSSTables = sstables.iterator().next().isRepaired();
+        for (SSTableReader sstable : sstables)
+            if (repairedSSTables != sstable.isRepaired())
+                throw new RuntimeException("Can't mix repaired and unrepaired sstables in a compaction");
+
+        if (repairedSSTables)
+            return repaired.getCompactionTask(sstables, gcBefore, maxSSTableBytes);
+        else
+            return unrepaired.getCompactionTask(sstables, gcBefore, maxSSTableBytes);
+    }
+
     @Override
     public synchronized AbstractCompactionTask getUserDefinedTask(Collection<SSTableReader> sstables, int gcBefore)
     {
diff --git a/test/unit/org/apache/cassandra/db/compaction/LeveledCompactionStrategyTest.java b/test/unit/org/apache/cassandra/db/compaction/LeveledCompactionStrategyTest.java
index da54eee61b..cb9cbb454a 100644
--- a/test/unit/org/apache/cassandra/db/compaction/LeveledCompactionStrategyTest.java
+++ b/test/unit/org/apache/cassandra/db/compaction/LeveledCompactionStrategyTest.java
@@ -23,6 +23,7 @@ import java.util.Collection;
 import java.util.List;
 import java.util.Random;
 import java.util.UUID;
+import java.util.concurrent.ExecutionException;
 
 import org.junit.After;
 import org.junit.Before;
@@ -278,4 +279,38 @@ public class LeveledCompactionStrategyTest extends SchemaLoader
         assertTrue(unrepaired.manifest.getLevel(1).contains(sstable2));
         assertFalse(repaired.manifest.getLevel(1).contains(sstable2));
     }
+
+    @Test
+    public void testDontRemoveLevelInfoUpgradeSSTables() throws InterruptedException, ExecutionException
+    {
+        byte [] b = new byte[100 * 1024];
+        new Random().nextBytes(b);
+        ByteBuffer value = ByteBuffer.wrap(b); // 100 KB value, make it easy to have multiple files
+
+        // Enough data to have a level 1 and 2
+        int rows = 20;
+        int columns = 10;
+
+        // Adds enough data to trigger multiple sstable per level
+        for (int r = 0; r < rows; r++)
+        {
+            DecoratedKey key = Util.dk(String.valueOf(r));
+            Mutation rm = new Mutation(ksname, key.getKey());
+            for (int c = 0; c < columns; c++)
+            {
+                rm.add(cfname, Util.cellname("column" + c), value, 0);
+            }
+            rm.apply();
+            cfs.forceBlockingFlush();
+        }
+        waitForLeveling(cfs);
+        cfs.forceBlockingFlush();
+        LeveledCompactionStrategy strategy = (LeveledCompactionStrategy) ((WrappingCompactionStrategy) cfs.getCompactionStrategy()).getWrappedStrategies().get(1);
+        assertTrue(strategy.getAllLevelSize()[1] > 0);
+
+        cfs.disableAutoCompaction();
+        cfs.sstablesRewrite(false);
+        assertTrue(strategy.getAllLevelSize()[1] > 0);
+
+    }
 }
