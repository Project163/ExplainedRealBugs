diff --git a/src/java/org/apache/cassandra/db/ColumnFamilyStore.java b/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
index 15e3c6a0bc..3b9e34fc7e 100644
--- a/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
+++ b/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
@@ -289,7 +289,7 @@ public final class ColumnFamilyStore implements ColumnFamilyStoreMBean
      * This method forces a compaction of the SSTables on disk. We wait
      * for the process to complete by waiting on a future pointer.
     */
-    List<SSTableReader> forceAntiCompaction(List<Range> ranges, InetAddress target)
+    List<SSTableReader> forceAntiCompaction(Collection<Range> ranges, InetAddress target)
     {
         assert ranges != null;
         Future<List<SSTableReader>> futurePtr = CompactionManager.instance().submit(ColumnFamilyStore.this, ranges, target);
@@ -717,7 +717,7 @@ public final class ColumnFamilyStore implements ColumnFamilyStoreMBean
         return maxFile;
     }
 
-    List<SSTableReader> doAntiCompaction(List<Range> ranges, InetAddress target) throws IOException
+    List<SSTableReader> doAntiCompaction(Collection<Range> ranges, InetAddress target) throws IOException
     {
         return doFileAntiCompaction(ssTables_.getSSTables(), ranges, target);
     }
diff --git a/src/java/org/apache/cassandra/db/CompactionManager.java b/src/java/org/apache/cassandra/db/CompactionManager.java
index 41e4c15d5b..e9b1413932 100644
--- a/src/java/org/apache/cassandra/db/CompactionManager.java
+++ b/src/java/org/apache/cassandra/db/CompactionManager.java
@@ -21,6 +21,7 @@ package org.apache.cassandra.db;
 import java.io.IOException;
 import java.lang.management.ManagementFactory;
 import java.util.List;
+import java.util.Collection;
 import java.util.concurrent.Callable;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Future;
@@ -74,10 +75,10 @@ public class CompactionManager implements CompactionManagerMBean
     static class FileCompactor2 implements Callable<List<SSTableReader>>
     {
         private ColumnFamilyStore columnFamilyStore_;
-        private List<Range> ranges_;
+        private Collection<Range> ranges_;
         private InetAddress target_;
 
-        FileCompactor2(ColumnFamilyStore columnFamilyStore, List<Range> ranges, InetAddress target)
+        FileCompactor2(ColumnFamilyStore columnFamilyStore, Collection<Range> ranges, InetAddress target)
         {
             columnFamilyStore_ = columnFamilyStore;
             ranges_ = ranges;
@@ -187,7 +188,7 @@ public class CompactionManager implements CompactionManagerMBean
         compactor_.submit(new CleanupCompactor(columnFamilyStore));
     }
 
-    public Future<List<SSTableReader>> submit(ColumnFamilyStore columnFamilyStore, List<Range> ranges, InetAddress target)
+    public Future<List<SSTableReader>> submit(ColumnFamilyStore columnFamilyStore, Collection<Range> ranges, InetAddress target)
     {
         return compactor_.submit( new FileCompactor2(columnFamilyStore, ranges, target) );
     }
diff --git a/src/java/org/apache/cassandra/db/Table.java b/src/java/org/apache/cassandra/db/Table.java
index 0492cf12dc..6ac5948e97 100644
--- a/src/java/org/apache/cassandra/db/Table.java
+++ b/src/java/org/apache/cassandra/db/Table.java
@@ -301,7 +301,7 @@ public class Table
      * do a complete compaction since we can figure out based on the ranges
      * whether the files need to be split.
     */
-    public List<SSTableReader> forceAntiCompaction(List<Range> ranges, InetAddress target)
+    public List<SSTableReader> forceAntiCompaction(Collection<Range> ranges, InetAddress target)
     {
         List<SSTableReader> allResults = new ArrayList<SSTableReader>();
         Set<String> columnFamilies = tableMetadata_.getColumnFamilies();
diff --git a/src/java/org/apache/cassandra/dht/BootStrapper.java b/src/java/org/apache/cassandra/dht/BootStrapper.java
index 2fe48a1636..3792128ac9 100644
--- a/src/java/org/apache/cassandra/dht/BootStrapper.java
+++ b/src/java/org/apache/cassandra/dht/BootStrapper.java
@@ -18,13 +18,7 @@
 
 package org.apache.cassandra.dht;
 
- import java.util.ArrayList;
- import java.util.Collections;
- import java.util.HashMap;
- import java.util.HashSet;
- import java.util.List;
- import java.util.Map;
- import java.util.Set;
+ import java.util.*;
  import java.util.concurrent.locks.Condition;
  import java.io.IOException;
  import java.io.UnsupportedEncodingException;
@@ -54,6 +48,9 @@ package org.apache.cassandra.dht;
  import org.apache.cassandra.io.SSTableWriter;
  import org.apache.cassandra.db.ColumnFamilyStore;
  import org.apache.cassandra.db.Table;
+ import com.google.common.collect.Multimap;
+ import com.google.common.collect.HashMultimap;
+ import com.google.common.collect.ArrayListMultimap;
 
 
  /**
@@ -95,11 +92,11 @@ public class BootStrapper
         {
             public void run()
             {
-                Map<Range, Set<InetAddress>> rangesWithSourceTarget = getRangesWithSources();
+                Multimap<Range, InetAddress> rangesWithSourceTarget = getRangesWithSources();
                 if (logger.isDebugEnabled())
                         logger.debug("Beginning bootstrap process for " + address + " ...");
                 /* Send messages to respective folks to stream data over to me */
-                for (Map.Entry<InetAddress, List<Range>> entry : getWorkMap(rangesWithSourceTarget).entrySet())
+                for (Map.Entry<InetAddress, Collection<Range>> entry : getWorkMap(rangesWithSourceTarget).asMap().entrySet())
                 {
                     InetAddress source = entry.getKey();
                     BootstrapMetadata bsMetadata = new BootstrapMetadata(address, entry.getValue());
@@ -147,24 +144,24 @@ public class BootStrapper
         }
     }
 
-    Map<Range, Set<InetAddress>> getRangesWithSources()
+    Multimap<Range, InetAddress> getRangesWithSources()
     {
         Map<Token, InetAddress> map = tokenMetadata.cloneTokenEndPointMap();
         assert map.size() > 0;
         map.put(token, address);
-        Set<Range> myRanges = replicationStrategy.getAddressRanges(map).get(address);
+        Collection<Range> myRanges = replicationStrategy.getAddressRanges(map).get(address);
         map.remove(token);
 
-        Map<Range, Set<InetAddress>> myRangeAddresses = new HashMap<Range, Set<InetAddress>>();
-        Map<Range, Set<InetAddress>> rangeAddresses = replicationStrategy.getRangeAddresses(map);
+        Multimap<Range, InetAddress> myRangeAddresses = HashMultimap.create();
+        Multimap<Range, InetAddress> rangeAddresses = replicationStrategy.getRangeAddresses(map);
         for (Range range : rangeAddresses.keySet())
         {
             for (Range myRange : myRanges)
             {
                 if (range.contains(myRange.right()))
                 {
-                    assert !myRangeAddresses.containsKey(myRange);
-                    myRangeAddresses.put(myRange, rangeAddresses.get(range));
+                    myRangeAddresses.putAll(myRange, rangeAddresses.get(range));
+                    break;
                 }
             }
         }
@@ -179,18 +176,18 @@ public class BootStrapper
         return btc.getToken();
     }
 
-    static Map<InetAddress, List<Range>> getWorkMap(Map<Range, Set<InetAddress>> rangesWithSourceTarget)
+    static Multimap<InetAddress, Range> getWorkMap(Multimap<Range, InetAddress> rangesWithSourceTarget)
     {
         return getWorkMap(rangesWithSourceTarget, FailureDetector.instance());
     }
 
-    static Map<InetAddress, List<Range>> getWorkMap(Map<Range, Set<InetAddress>> rangesWithSourceTarget, IFailureDetector failureDetector)
+    static Multimap<InetAddress, Range> getWorkMap(Multimap<Range, InetAddress> rangesWithSourceTarget, IFailureDetector failureDetector)
     {
         /*
          * Map whose key is the source node and the value is a map whose key is the
          * target and value is the list of ranges to be sent to it.
         */
-        Map<InetAddress, List<Range>> sources = new HashMap<InetAddress, List<Range>>();
+        Multimap<InetAddress, Range> sources = ArrayListMultimap.create();
 
         // TODO look for contiguous ranges and map them to the same source
         for (Range range : rangesWithSourceTarget.keySet())
@@ -199,13 +196,7 @@ public class BootStrapper
             {
                 if (failureDetector.isAlive(source))
                 {
-                    List<Range> ranges = sources.get(source);
-                    if (ranges == null)
-                    {
-                        ranges = new ArrayList<Range>();
-                        sources.put(source, ranges);
-                    }
-                    ranges.add(range);
+                    sources.put(source, range);
                     break;
                 }
             }
diff --git a/src/java/org/apache/cassandra/dht/BootstrapMetadata.java b/src/java/org/apache/cassandra/dht/BootstrapMetadata.java
index 085c2b1c45..ef5401bf2d 100644
--- a/src/java/org/apache/cassandra/dht/BootstrapMetadata.java
+++ b/src/java/org/apache/cassandra/dht/BootstrapMetadata.java
@@ -23,6 +23,7 @@ import java.io.DataOutputStream;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Collection;
 
 import org.apache.cassandra.io.ICompactSerializer;
 import org.apache.cassandra.net.CompactEndPointSerializationHelper;
@@ -51,9 +52,9 @@ class BootstrapMetadata
     }
     
     protected InetAddress target_;
-    protected List<Range> ranges_;
+    protected Collection<Range> ranges_;
     
-    BootstrapMetadata(InetAddress target, List<Range> ranges)
+    BootstrapMetadata(InetAddress target, Collection<Range> ranges)
     {
         target_ = target;
         ranges_ = ranges;
diff --git a/src/java/org/apache/cassandra/dht/BootstrapMetadataVerbHandler.java b/src/java/org/apache/cassandra/dht/BootstrapMetadataVerbHandler.java
index 5f0c7a09a0..bc82368e7f 100644
--- a/src/java/org/apache/cassandra/dht/BootstrapMetadataVerbHandler.java
+++ b/src/java/org/apache/cassandra/dht/BootstrapMetadataVerbHandler.java
@@ -22,6 +22,7 @@ import java.io.File;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Collection;
 
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.db.Table;
@@ -93,7 +94,7 @@ public class BootstrapMetadataVerbHandler implements IVerbHandler
      * locally for each range and then stream them using
      * the Bootstrap protocol to the target endpoint.
     */
-    private void doTransfer(InetAddress target, List<Range> ranges) throws IOException
+    private void doTransfer(InetAddress target, Collection<Range> ranges) throws IOException
     {
         if ( ranges.size() == 0 )
         {
diff --git a/src/java/org/apache/cassandra/locator/AbstractReplicationStrategy.java b/src/java/org/apache/cassandra/locator/AbstractReplicationStrategy.java
index 8fa5cbf749..2b6b26175c 100644
--- a/src/java/org/apache/cassandra/locator/AbstractReplicationStrategy.java
+++ b/src/java/org/apache/cassandra/locator/AbstractReplicationStrategy.java
@@ -23,8 +23,8 @@ import java.util.*;
 
 import org.apache.log4j.Logger;
 
-import org.apache.commons.lang.StringUtils;
-
+import com.google.common.collect.HashMultimap;
+import com.google.common.collect.Multimap;
 import org.apache.cassandra.dht.IPartitioner;
 import org.apache.cassandra.dht.Range;
 import org.apache.cassandra.dht.Token;
@@ -33,7 +33,6 @@ import org.apache.cassandra.service.IResponseResolver;
 import org.apache.cassandra.service.InvalidRequestException;
 import org.apache.cassandra.service.QuorumResponseHandler;
 import org.apache.cassandra.utils.FBUtilities;
-import org.apache.cassandra.config.DatabaseDescriptor;
 
 /**
  * This class contains a helper method that will be used by
@@ -177,46 +176,39 @@ public abstract class AbstractReplicationStrategy
 
     // TODO this is pretty inefficient. also the inverse (getRangeAddresses) below.
     // fixing this probably requires merging tokenmetadata into replicationstrategy, so we can cache/invalidate cleanly
-    public Map<InetAddress, Set<Range>> getAddressRanges(Map<Token, InetAddress> tokenMap)
+    public Multimap<InetAddress, Range> getAddressRanges(Map<Token, InetAddress> metadata)
     {
-        Map<InetAddress, Set<Range>> map = new HashMap<InetAddress, Set<Range>>();
-
-        for (InetAddress ep : tokenMap.values())
-        {
-            map.put(ep, new HashSet<Range>());
-        }
+        Multimap<InetAddress, Range> map = HashMultimap.create();
 
-        for (Token token : tokenMap.keySet())
+        for (Token token : metadata.keySet())
         {
-            Range range = getPrimaryRangeFor(token, tokenMap);
-            for (InetAddress ep : getNaturalEndpoints(token, tokenMap))
+            Range range = getPrimaryRangeFor(token, metadata);
+            for (InetAddress ep : getNaturalEndpoints(token, metadata))
             {
-                map.get(ep).add(range);
+                map.put(ep, range);
             }
         }
 
         return map;
     }
 
-    public Map<Range, Set<InetAddress>> getRangeAddresses(Map<Token, InetAddress> tokenMap)
+    public Multimap<Range, InetAddress> getRangeAddresses(Map<Token, InetAddress> metadata)
     {
-        Map<Range, Set<InetAddress>> map = new HashMap<Range, Set<InetAddress>>();
+        Multimap<Range, InetAddress> map = HashMultimap.create();
 
-        for (Token token : tokenMap.keySet())
+        for (Token token : metadata.keySet())
         {
-            Range range = getPrimaryRangeFor(token, tokenMap);
-            HashSet<InetAddress> addresses = new HashSet<InetAddress>();
-            for (InetAddress ep : getNaturalEndpoints(token, tokenMap))
+            Range range = getPrimaryRangeFor(token, metadata);
+            for (InetAddress ep : getNaturalEndpoints(token, metadata))
             {
-                addresses.add(ep);
+                map.put(range, ep);
             }
-            map.put(range, addresses);
         }
 
         return map;
     }
 
-    public Map<InetAddress, Set<Range>> getAddressRanges()
+    public Multimap<InetAddress, Range> getAddressRanges()
     {
         return getAddressRanges(tokenMetadata_.cloneTokenEndPointMap());
     }
diff --git a/src/java/org/apache/cassandra/service/StorageService.java b/src/java/org/apache/cassandra/service/StorageService.java
index 00d590ab03..7c49711966 100644
--- a/src/java/org/apache/cassandra/service/StorageService.java
+++ b/src/java/org/apache/cassandra/service/StorageService.java
@@ -84,7 +84,7 @@ public final class StorageService implements IEndPointStateChangeSubscriber, Sto
         return partitioner_;
     }
 
-    public Set<Range> getLocalRanges()
+    public Collection<Range> getLocalRanges()
     {
         return getRangesForEndPoint(FBUtilities.getLocalAddress());
     }
@@ -672,7 +672,7 @@ public final class StorageService implements IEndPointStateChangeSubscriber, Sto
      * @param ep endpoint we are interested in.
      * @return ranges for the specified endpoint.
      */
-    Set<Range> getRangesForEndPoint(InetAddress ep)
+    Collection<Range> getRangesForEndPoint(InetAddress ep)
     {
         return replicationStrategy_.getAddressRanges().get(ep);
     }
diff --git a/test/unit/org/apache/cassandra/dht/BootStrapperTest.java b/test/unit/org/apache/cassandra/dht/BootStrapperTest.java
index 46e91a28d6..d8d67a08fe 100644
--- a/test/unit/org/apache/cassandra/dht/BootStrapperTest.java
+++ b/test/unit/org/apache/cassandra/dht/BootStrapperTest.java
@@ -23,6 +23,7 @@ import java.net.UnknownHostException;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import java.util.Collection;
 
 import org.apache.commons.lang.StringUtils;
 import static org.junit.Assert.assertEquals;
@@ -32,6 +33,7 @@ import org.apache.cassandra.locator.TokenMetadata;
 import org.apache.cassandra.service.StorageService;
 import org.apache.cassandra.gms.IFailureDetector;
 import org.apache.cassandra.gms.IFailureDetectionEventListener;
+import com.google.common.collect.Multimap;
 
 public class BootStrapperTest {
     @Test
@@ -54,10 +56,10 @@ public class BootStrapperTest {
         TokenMetadata tmd = ss.getTokenMetadata();
         assertEquals(numOldNodes, tmd.cloneTokenEndPointMap().size());
         BootStrapper b = new BootStrapper(ss.getReplicationStrategy(), myEndpoint, myToken, tmd);
-        Map<Range, Set<InetAddress>> res = b.getRangesWithSources();
+        Multimap<Range, InetAddress> res = b.getRangesWithSources();
         
         int transferCount = 0;
-        for (Map.Entry<Range, Set<InetAddress>> e : res.entrySet())
+        for (Map.Entry<Range, Collection<InetAddress>> e : res.asMap().entrySet())
         {
             assert e.getValue() != null && e.getValue().size() > 0 : StringUtils.join(e.getValue(), ", ");
             transferCount++;
@@ -77,9 +79,9 @@ public class BootStrapperTest {
             public void registerFailureDetectionEventListener(IFailureDetectionEventListener listener) { throw new UnsupportedOperationException(); }
             public void unregisterFailureDetectionEventListener(IFailureDetectionEventListener listener) { throw new UnsupportedOperationException(); }
         };
-        Map<InetAddress, List<Range>> temp = BootStrapper.getWorkMap(res, mockFailureDetector);
+        Multimap<InetAddress, Range> temp = BootStrapper.getWorkMap(res, mockFailureDetector);
         assertEquals(1, temp.keySet().size());
-        assertEquals(1, temp.values().iterator().next().size());
+        assertEquals(1, temp.asMap().values().iterator().next().size());
         assert !temp.keySet().iterator().next().equals(myEndpoint);
     }
 
