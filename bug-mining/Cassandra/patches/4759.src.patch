diff --git a/CHANGES.txt b/CHANGES.txt
index 9b31d487b2..b13b777e76 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 3.11.0
+ * Allow CONTAINS statements filtering on the partition key and itâ€™s parts (CASSANDRA-13275)
  * Fall back to even ranges calculation in clusters with vnodes when tokens are distributed unevenly (CASSANDRA-13229)
  * Fix duration type validation to prevent overflow (CASSANDRA-13218)
  * Forbid unsupported creation of SASI indexes over partition key columns (CASSANDRA-13228)
diff --git a/src/java/org/apache/cassandra/cql3/restrictions/PartitionKeySingleRestrictionSet.java b/src/java/org/apache/cassandra/cql3/restrictions/PartitionKeySingleRestrictionSet.java
index b34ff54588..f2b427d449 100644
--- a/src/java/org/apache/cassandra/cql3/restrictions/PartitionKeySingleRestrictionSet.java
+++ b/src/java/org/apache/cassandra/cql3/restrictions/PartitionKeySingleRestrictionSet.java
@@ -135,8 +135,9 @@ final class PartitionKeySingleRestrictionSet extends RestrictionSetWrapper imple
     {
         if (isEmpty())
             return false;
+
         // slice or has unrestricted key component
-        return hasUnrestrictedPartitionKeyComponents(cfm) || hasSlice();
+        return hasUnrestrictedPartitionKeyComponents(cfm) || hasSlice() || hasContains();
     }
 
     @Override
diff --git a/src/java/org/apache/cassandra/cql3/restrictions/RestrictionSet.java b/src/java/org/apache/cassandra/cql3/restrictions/RestrictionSet.java
index 3a1bcb10ea..a0816d252a 100644
--- a/src/java/org/apache/cassandra/cql3/restrictions/RestrictionSet.java
+++ b/src/java/org/apache/cassandra/cql3/restrictions/RestrictionSet.java
@@ -281,6 +281,16 @@ final class RestrictionSet implements Restrictions, Iterable<SingleRestriction>
         return false;
     }
 
+    public boolean hasContains()
+    {
+        for (SingleRestriction restriction : this)
+        {
+            if (restriction.isContains())
+                return true;
+        }
+        return false;
+    }
+
     public final boolean hasSlice()
     {
         for (SingleRestriction restriction : this)
diff --git a/src/java/org/apache/cassandra/cql3/restrictions/RestrictionSetWrapper.java b/src/java/org/apache/cassandra/cql3/restrictions/RestrictionSetWrapper.java
index 996a1c45c7..5157de0368 100644
--- a/src/java/org/apache/cassandra/cql3/restrictions/RestrictionSetWrapper.java
+++ b/src/java/org/apache/cassandra/cql3/restrictions/RestrictionSetWrapper.java
@@ -89,6 +89,11 @@ class RestrictionSetWrapper implements Restrictions
         return restrictions.hasIN();
     }
 
+    public boolean hasContains()
+    {
+        return restrictions.hasContains();
+    }
+
     public boolean hasSlice()
     {
         return restrictions.hasSlice();
diff --git a/src/java/org/apache/cassandra/cql3/restrictions/Restrictions.java b/src/java/org/apache/cassandra/cql3/restrictions/Restrictions.java
index 8a5140a3ea..5d11e9fbe9 100644
--- a/src/java/org/apache/cassandra/cql3/restrictions/Restrictions.java
+++ b/src/java/org/apache/cassandra/cql3/restrictions/Restrictions.java
@@ -54,6 +54,11 @@ public interface Restrictions extends Restriction
      */
     public boolean hasIN();
 
+    /**
+     * Checks if any of the underlying restrictions is a CONTAINS / CONTAINS KEY restriction.
+     * @return <code>true</code> if any of the underlying restrictions is CONTAINS, <code>false</code> otherwise
+     */
+    public boolean hasContains();
     /**
      * Checks if any of the underlying restrictions is a slice.
      * @return <code>true</code> if any of the underlying restrictions is a slice, <code>false</code> otherwise
diff --git a/src/java/org/apache/cassandra/cql3/restrictions/StatementRestrictions.java b/src/java/org/apache/cassandra/cql3/restrictions/StatementRestrictions.java
index 8a8ee56049..15a090b7df 100644
--- a/src/java/org/apache/cassandra/cql3/restrictions/StatementRestrictions.java
+++ b/src/java/org/apache/cassandra/cql3/restrictions/StatementRestrictions.java
@@ -429,8 +429,7 @@ public final class StatementRestrictions
             // components must have a EQ. Only the last partition key component can be in IN relation.
             if (partitionKeyRestrictions.needFiltering(cfm))
             {
-                if (!allowFiltering && !forView && !hasQueriableIndex
-                    && (partitionKeyRestrictions.hasUnrestrictedPartitionKeyComponents(cfm) || partitionKeyRestrictions.hasSlice()))
+                if (!allowFiltering && !forView && !hasQueriableIndex)
                     throw new InvalidRequestException(REQUIRES_ALLOW_FILTERING_MESSAGE);
 
                 if (partitionKeyRestrictions.hasIN())
@@ -518,7 +517,6 @@ public final class StatementRestrictions
             checkFalse(clusteringColumnsRestrictions.hasIN() && selectsComplexColumn,
                        "Cannot restrict clustering columns by IN relations when a collection is selected by the query");
             checkFalse(clusteringColumnsRestrictions.hasContains() && !hasQueriableIndex && !allowFiltering,
-
                        "Clustering columns can only be restricted with CONTAINS with a secondary index or filtering");
 
             if (hasClusteringColumnsRestrictions() && clusteringColumnsRestrictions.needFiltering())
diff --git a/src/java/org/apache/cassandra/cql3/restrictions/TokenFilter.java b/src/java/org/apache/cassandra/cql3/restrictions/TokenFilter.java
index 400706b793..13b3e3ea7d 100644
--- a/src/java/org/apache/cassandra/cql3/restrictions/TokenFilter.java
+++ b/src/java/org/apache/cassandra/cql3/restrictions/TokenFilter.java
@@ -67,6 +67,11 @@ final class TokenFilter implements PartitionKeyRestrictions
         return isOnToken() ? false : restrictions.hasIN();
     }
 
+    public boolean hasContains()
+    {
+        return isOnToken() ? false : restrictions.hasContains();
+    }
+
     public boolean hasOnlyEqualityRestrictions()
     {
         return isOnToken() ? false : restrictions.hasOnlyEqualityRestrictions();
diff --git a/src/java/org/apache/cassandra/cql3/restrictions/TokenRestriction.java b/src/java/org/apache/cassandra/cql3/restrictions/TokenRestriction.java
index e90319d667..82b27ddce8 100644
--- a/src/java/org/apache/cassandra/cql3/restrictions/TokenRestriction.java
+++ b/src/java/org/apache/cassandra/cql3/restrictions/TokenRestriction.java
@@ -225,6 +225,11 @@ public abstract class TokenRestriction implements PartitionKeyRestrictions
         {
             return Collections.singletonList(value.bindAndGet(options));
         }
+
+        public boolean hasContains()
+        {
+            return false;
+        }
     }
 
     public static class SliceRestriction extends TokenRestriction
@@ -237,6 +242,11 @@ public abstract class TokenRestriction implements PartitionKeyRestrictions
             slice = TermSlice.newInstance(bound, inclusive, term);
         }
 
+        public boolean hasContains()
+        {
+            return false;
+        }
+
         @Override
         public boolean hasSlice()
         {
diff --git a/test/unit/org/apache/cassandra/cql3/validation/operations/SelectOrderedPartitionerTest.java b/test/unit/org/apache/cassandra/cql3/validation/operations/SelectOrderedPartitionerTest.java
index 3957305254..003258a551 100644
--- a/test/unit/org/apache/cassandra/cql3/validation/operations/SelectOrderedPartitionerTest.java
+++ b/test/unit/org/apache/cassandra/cql3/validation/operations/SelectOrderedPartitionerTest.java
@@ -66,7 +66,6 @@ public class SelectOrderedPartitionerTest extends CQLTester
         });
     }
 
-
     @Test
     public void testFilteringOnAllPartitionKeysWithTokenRestriction() throws Throwable
     {
@@ -122,6 +121,31 @@ public class SelectOrderedPartitionerTest extends CQLTester
         });
     }
 
+    @Test
+    public void testTokenAndCollections() throws Throwable
+    {
+        createTable("CREATE TABLE %s (a frozen<map<int, int>>, b int, c int, PRIMARY KEY (a, b))");
+
+        for (int i = 0; i < 10; i++)
+        {
+            execute("INSERT INTO %s (a,b,c) VALUES (?, ?, ?)", map(i, i), i, i);
+            execute("INSERT INTO %s (a,b,c) VALUES (?, ?, ?)", map(i, i, 100, 200), i + 10, i + 10);
+        }
+
+        beforeAndAfterFlush(() -> {
+            assertRows(execute("SELECT * FROM %s WHERE token(a) > token({0: 0}) AND a CONTAINS KEY 9 ALLOW FILTERING"),
+                                    row(map(9, 9), 9, 9),
+                                    row(map(9, 9, 100, 200), 19, 19));
+
+            assertRows(execute("SELECT * FROM %s WHERE token(a) > token({0: 0}) AND a CONTAINS KEY 9 AND a CONTAINS 200 ALLOW FILTERING"),
+                       row(map(9, 9, 100, 200), 19, 19));
+
+            assertRows(execute("SELECT * FROM %s WHERE token(a) > token({0: 0}) AND a CONTAINS KEY 9 AND b = 19 ALLOW FILTERING"),
+                       row(map(9, 9, 100, 200), 19, 19));
+        });
+    }
+
+
     @Test
     public void testTokenFunctionWithSingleColumnPartitionKey() throws Throwable
     {
diff --git a/test/unit/org/apache/cassandra/cql3/validation/operations/SelectTest.java b/test/unit/org/apache/cassandra/cql3/validation/operations/SelectTest.java
index 572d90356e..9a24bd0d7d 100644
--- a/test/unit/org/apache/cassandra/cql3/validation/operations/SelectTest.java
+++ b/test/unit/org/apache/cassandra/cql3/validation/operations/SelectTest.java
@@ -549,8 +549,8 @@ public class SelectTest extends CQLTester
         createTable("CREATE TABLE %s (account text, id int, categories map<text,text>, PRIMARY KEY (account, id))");
 
         // create an index on
-        createIndex("CREATE INDEX id_index ON %s(id)");
-        createIndex("CREATE INDEX categories_values_index ON %s(categories)");
+        createIndex("CREATE INDEX ON %s(id)");
+        createIndex("CREATE INDEX ON %s(categories)");
 
         beforeAndAfterFlush(() -> {
 
@@ -1373,7 +1373,7 @@ public class SelectTest extends CQLTester
     public void testSelectCountPaging() throws Throwable
     {
         createTable("create table %s (field1 text, field2 timeuuid, field3 boolean, primary key(field1, field2))");
-        createIndex("create index test_index on %s (field3)");
+        createIndex("create index on %s (field3)");
 
         execute("insert into %s (field1, field2, field3) values ('hola', now(), false)");
         execute("insert into %s (field1, field2, field3) values ('hola', now(), false)");
@@ -2306,8 +2306,9 @@ public class SelectTest extends CQLTester
     @Test
     public void testIndexQueryWithValueOver64K() throws Throwable
     {
-        createTable("CREATE TABLE %s (a int, b int, c blob, PRIMARY KEY (a, b))");
-        createIndex("CREATE INDEX test ON %s (c)");
+        String tableName = createTable("CREATE TABLE %s (a int, b int, c blob, PRIMARY KEY (a, b))");
+        String idx = tableName + "_c_idx";
+        createIndex("CREATE INDEX " + idx + " ON %s (c)");
 
         execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?)", 0, 0, bytes(1));
         execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?)", 0, 1, bytes(2));
@@ -2315,7 +2316,7 @@ public class SelectTest extends CQLTester
         assertInvalidMessage("Index expression values may not be larger than 64K",
                              "SELECT * FROM %s WHERE c = ?  ALLOW FILTERING", TOO_BIG);
 
-        dropIndex("DROP INDEX %s.test");
+        dropIndex("DROP INDEX %s." + idx);
         assertEmpty(execute("SELECT * FROM %s WHERE c = ?  ALLOW FILTERING", TOO_BIG));
     }
 
@@ -3764,6 +3765,58 @@ public class SelectTest extends CQLTester
         });
     }
 
+    @Test
+    public void testContainsOnPartitionKey() throws Throwable
+    {
+        testContainsOnPartitionKey("CREATE TABLE %s (pk frozen<map<int, int>>, ck int, v int, PRIMARY KEY (pk, ck))");
+    }
+
+    @Test
+    public void testContainsOnPartitionKeyPart() throws Throwable
+    {
+        testContainsOnPartitionKey("CREATE TABLE %s (pk frozen<map<int, int>>, ck int, v int, PRIMARY KEY ((pk, ck)))");
+    }
+
+    private void testContainsOnPartitionKey(String schema) throws Throwable
+    {
+        createTable(schema);
+
+        execute("INSERT INTO %s (pk, ck, v) VALUES (?, ?, ?)", map(1, 2), 1, 1);
+        execute("INSERT INTO %s (pk, ck, v) VALUES (?, ?, ?)", map(1, 2), 2, 2);
+
+        execute("INSERT INTO %s (pk, ck, v) VALUES (?, ?, ?)", map(1, 2, 3, 4), 1, 3);
+        execute("INSERT INTO %s (pk, ck, v) VALUES (?, ?, ?)", map(1, 2, 3, 4), 2, 3);
+
+        execute("INSERT INTO %s (pk, ck, v) VALUES (?, ?, ?)", map(5, 6), 5, 5);
+        execute("INSERT INTO %s (pk, ck, v) VALUES (?, ?, ?)", map(7, 8), 6, 6);
+
+        assertInvalidMessage(StatementRestrictions.REQUIRES_ALLOW_FILTERING_MESSAGE,
+                             "SELECT * FROM %s WHERE pk CONTAINS KEY 1");
+
+        beforeAndAfterFlush(() -> {
+            assertRowsIgnoringOrder(execute("SELECT * FROM %s WHERE pk CONTAINS KEY 1 ALLOW FILTERING"),
+                                    row(map(1, 2), 1, 1),
+                                    row(map(1, 2), 2, 2),
+                                    row(map(1, 2, 3, 4), 1, 3),
+                                    row(map(1, 2, 3, 4), 2, 3));
+
+            assertRowsIgnoringOrder(execute("SELECT * FROM %s WHERE pk CONTAINS KEY 1 AND pk CONTAINS 4 ALLOW FILTERING"),
+                                    row(map(1, 2, 3, 4), 1, 3),
+                                    row(map(1, 2, 3, 4), 2, 3));
+
+            assertRowsIgnoringOrder(execute("SELECT * FROM %s WHERE pk CONTAINS KEY 1 AND pk CONTAINS KEY 3 ALLOW FILTERING"),
+                                    row(map(1, 2, 3, 4), 1, 3),
+                                    row(map(1, 2, 3, 4), 2, 3));
+
+            assertRowsIgnoringOrder(execute("SELECT * FROM %s WHERE pk CONTAINS KEY 1 AND v = 3 ALLOW FILTERING"),
+                                    row(map(1, 2, 3, 4), 1, 3),
+                                    row(map(1, 2, 3, 4), 2, 3));
+
+            assertRowsIgnoringOrder(execute("SELECT * FROM %s WHERE pk CONTAINS KEY 1 AND ck = 1 AND v = 3 ALLOW FILTERING"),
+                                    row(map(1, 2, 3, 4), 1, 3));
+        });
+    }
+
     @Test
     public void filteringWithOrderClause() throws Throwable
     {
