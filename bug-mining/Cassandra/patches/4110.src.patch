diff --git a/CHANGES.txt b/CHANGES.txt
index 75653863cd..5674b9d57d 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 2.2.6
+ * Fix SELECT on tuple relations for mixed ASC/DESC clustering order (CASSANDRA-7281)
  * (cqlsh) Support utf-8/cp65001 encoding on Windows (CASSANDRA-11030)
  * Fix paging on DISTINCT queries repeats result when first row in partition changes (CASSANDRA-10010)
 Merged from 2.1:
diff --git a/src/java/org/apache/cassandra/cql3/restrictions/AbstractRestriction.java b/src/java/org/apache/cassandra/cql3/restrictions/AbstractRestriction.java
index 64c94f45d5..dac7203f4f 100644
--- a/src/java/org/apache/cassandra/cql3/restrictions/AbstractRestriction.java
+++ b/src/java/org/apache/cassandra/cql3/restrictions/AbstractRestriction.java
@@ -19,12 +19,13 @@ package org.apache.cassandra.cql3.restrictions;
 
 import java.nio.ByteBuffer;
 
+import org.apache.cassandra.config.ColumnDefinition;
+
 import org.apache.cassandra.cql3.ColumnSpecification;
 import org.apache.cassandra.cql3.QueryOptions;
 import org.apache.cassandra.cql3.statements.Bound;
 import org.apache.cassandra.db.composites.CompositesBuilder;
 import org.apache.cassandra.exceptions.InvalidRequestException;
-
 import static org.apache.cassandra.cql3.statements.RequestValidations.checkBindValueSet;
 import static org.apache.cassandra.cql3.statements.RequestValidations.checkFalse;
 import static org.apache.cassandra.cql3.statements.RequestValidations.checkNotNull;
@@ -97,4 +98,16 @@ abstract class AbstractRestriction  implements Restriction
         checkFalse(value.remaining() > 0xFFFF, "Index expression values may not be larger than 64K");
         return value;
     }
+
+    /**
+     * Reverses the specified bound if the column type is a reversed one.
+     *
+     * @param columnDefinition the column definition
+     * @param bound the bound
+     * @return the bound reversed if the column type was a reversed one or the original bound
+     */
+    protected static Bound reverseBoundIfNeeded(ColumnDefinition columnDefinition, Bound bound)
+    {
+        return columnDefinition.isReversedType() ? bound.reverse() : bound;
+    }
 }
diff --git a/src/java/org/apache/cassandra/cql3/restrictions/ForwardingPrimaryKeyRestrictions.java b/src/java/org/apache/cassandra/cql3/restrictions/ForwardingPrimaryKeyRestrictions.java
index 03c6cbc23c..71855a0d77 100644
--- a/src/java/org/apache/cassandra/cql3/restrictions/ForwardingPrimaryKeyRestrictions.java
+++ b/src/java/org/apache/cassandra/cql3/restrictions/ForwardingPrimaryKeyRestrictions.java
@@ -18,7 +18,6 @@
 package org.apache.cassandra.cql3.restrictions;
 
 import java.nio.ByteBuffer;
-import java.util.Collection;
 import java.util.List;
 
 import org.apache.cassandra.config.ColumnDefinition;
@@ -51,7 +50,7 @@ abstract class ForwardingPrimaryKeyRestrictions implements PrimaryKeyRestriction
     }
 
     @Override
-    public Collection<ColumnDefinition> getColumnDefs()
+    public List<ColumnDefinition> getColumnDefs()
     {
         return getDelegate().getColumnDefs();
     }
diff --git a/src/java/org/apache/cassandra/cql3/restrictions/MultiColumnRestriction.java b/src/java/org/apache/cassandra/cql3/restrictions/MultiColumnRestriction.java
index 84a3952f37..96e6f2b101 100644
--- a/src/java/org/apache/cassandra/cql3/restrictions/MultiColumnRestriction.java
+++ b/src/java/org/apache/cassandra/cql3/restrictions/MultiColumnRestriction.java
@@ -20,11 +20,9 @@ package org.apache.cassandra.cql3.restrictions;
 import java.nio.ByteBuffer;
 import java.util.*;
 
-import org.apache.cassandra.cql3.Term.Terminal;
-
-import org.apache.cassandra.cql3.Term;
 import org.apache.cassandra.config.ColumnDefinition;
 import org.apache.cassandra.cql3.*;
+import org.apache.cassandra.cql3.Term.Terminal;
 import org.apache.cassandra.cql3.functions.Function;
 import org.apache.cassandra.cql3.statements.Bound;
 import org.apache.cassandra.db.IndexExpression;
@@ -68,7 +66,7 @@ public abstract class MultiColumnRestriction extends AbstractRestriction
     }
 
     @Override
-    public Collection<ColumnDefinition> getColumnDefs()
+    public List<ColumnDefinition> getColumnDefs()
     {
         return columnDefs;
     }
@@ -361,14 +359,62 @@ public abstract class MultiColumnRestriction extends AbstractRestriction
         @Override
         public CompositesBuilder appendBoundTo(CompositesBuilder builder, Bound bound, QueryOptions options)
         {
-            List<ByteBuffer> vals = componentBounds(bound, options);
+            boolean reversed = getFirstColumn().isReversedType();
+
+            EnumMap<Bound, List<ByteBuffer>> componentBounds = new EnumMap<Bound, List<ByteBuffer>>(Bound.class);
+            componentBounds.put(Bound.START, componentBounds(Bound.START, options));
+            componentBounds.put(Bound.END, componentBounds(Bound.END, options));
 
-            for (int i = 0, m = vals.size(); i < m; i++)
+            List<List<ByteBuffer>> toAdd = new ArrayList<>();
+            List<ByteBuffer> values = new ArrayList<>();
+
+            for (int i = 0, m = columnDefs.size(); i < m; i++)
             {
-                ByteBuffer v = checkNotNull(vals.get(i), "Invalid null value in condition for column %s", columnDefs.get(i).name);
-                builder.addElementToAll(v);
+                ColumnDefinition column = columnDefs.get(i);
+                Bound b = reverseBoundIfNeeded(column, bound);
+
+                // For mixed order columns, we need to create additional slices when 2 columns are in reverse order
+                if (reversed != column.isReversedType())
+                {
+                    reversed = column.isReversedType();
+                    // As we are switching direction we need to add the current composite
+                    toAdd.add(values);
+
+                    // The new bound side has no value for this component.  just stop
+                    if (!hasComponent(b, i, componentBounds))
+                        continue;
+
+                    // The other side has still some components. We need to end the slice that we have just open.
+                    if (hasComponent(b.reverse(), i, componentBounds))
+                        toAdd.add(values);
+
+                    // We need to rebuild where we are in this bound side
+                    values = new ArrayList<ByteBuffer>();
+
+                    List<ByteBuffer> vals = componentBounds.get(b);
+
+                    int n = Math.min(i, vals.size());
+                    for (int j = 0; j < n; j++)
+                    {
+                        ByteBuffer v = checkNotNull(vals.get(j),
+                                                    "Invalid null value in condition for column %s",
+                                                    columnDefs.get(j).name);
+                        values.add(v);
+                    }
+                }
+
+                if (!hasComponent(b, i, componentBounds))
+                    continue;
+
+                ByteBuffer v = checkNotNull(componentBounds.get(b).get(i), "Invalid null value in condition for column %s", columnDefs.get(i).name);
+                values.add(v);
             }
-            return builder;
+            toAdd.add(values);
+
+            if (bound.isEnd())
+                Collections.reverse(toAdd);
+
+            return builder.addAllElementsToAll(toAdd);
         }
 
         @Override
@@ -378,9 +424,9 @@ public abstract class MultiColumnRestriction extends AbstractRestriction
         }
 
         @Override
-        public boolean hasBound(Bound b)
+        public boolean hasBound(Bound bound)
         {
-            return slice.hasBound(b);
+            return slice.hasBound(bound);
         }
 
         @Override
@@ -390,9 +436,9 @@ public abstract class MultiColumnRestriction extends AbstractRestriction
         }
 
         @Override
-        public boolean isInclusive(Bound b)
+        public boolean isInclusive(Bound bound)
         {
-            return slice.isInclusive(b);
+            return slice.isInclusive(bound);
         }
 
         @Override
@@ -448,6 +494,9 @@ public abstract class MultiColumnRestriction extends AbstractRestriction
          */
         private List<ByteBuffer> componentBounds(Bound b, QueryOptions options) throws InvalidRequestException
         {
+            if (!slice.hasBound(b))
+                return Collections.emptyList();
+
             Terminal terminal = slice.bound(b).bind(options);
 
             if (terminal instanceof Tuples.Value)
@@ -457,5 +506,10 @@ public abstract class MultiColumnRestriction extends AbstractRestriction
 
             return Collections.singletonList(terminal.get(options.getProtocolVersion()));
         }
+
+        private boolean hasComponent(Bound b, int index, EnumMap<Bound, List<ByteBuffer>> componentBounds)
+        {
+            return componentBounds.get(b).size() > index;
+        }
     }
 }
diff --git a/src/java/org/apache/cassandra/cql3/restrictions/PrimaryKeyRestrictionSet.java b/src/java/org/apache/cassandra/cql3/restrictions/PrimaryKeyRestrictionSet.java
index 3a20f6a97a..936dbd63f9 100644
--- a/src/java/org/apache/cassandra/cql3/restrictions/PrimaryKeyRestrictionSet.java
+++ b/src/java/org/apache/cassandra/cql3/restrictions/PrimaryKeyRestrictionSet.java
@@ -18,10 +18,9 @@
 package org.apache.cassandra.cql3.restrictions;
 
 import java.nio.ByteBuffer;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.List;
+import java.util.*;
 
+import org.apache.cassandra.db.composites.Composite;
 import org.apache.cassandra.config.ColumnDefinition;
 import org.apache.cassandra.cql3.QueryOptions;
 import org.apache.cassandra.cql3.functions.Function;
@@ -31,7 +30,6 @@ import org.apache.cassandra.db.composites.*;
 import org.apache.cassandra.db.composites.Composite.EOC;
 import org.apache.cassandra.db.index.SecondaryIndexManager;
 import org.apache.cassandra.exceptions.InvalidRequestException;
-
 import static org.apache.cassandra.cql3.statements.RequestValidations.checkFalse;
 import static org.apache.cassandra.cql3.statements.RequestValidations.invalidRequest;
 
@@ -163,7 +161,7 @@ final class PrimaryKeyRestrictionSet extends AbstractPrimaryKeyRestrictions
     @Override
     public List<Composite> valuesAsComposites(QueryOptions options) throws InvalidRequestException
     {
-        return appendTo(new CompositesBuilder(ctype), options).build();
+        return filterAndSort(appendTo(new CompositesBuilder(ctype), options).build());
     }
 
     @Override
@@ -197,29 +195,16 @@ final class PrimaryKeyRestrictionSet extends AbstractPrimaryKeyRestrictions
         {
             ColumnDefinition def = r.getFirstColumn();
 
-            // In a restriction, we always have Bound.START < Bound.END for the "base" comparator.
-            // So if we're doing a reverse slice, we must inverse the bounds when giving them as start and end of the slice filter.
-            // But if the actual comparator itself is reversed, we must inversed the bounds too.
-            Bound b = !def.isReversedType() ? bound : bound.reverse();
             if (keyPosition != def.position() || r.isContains())
                 break;
 
             if (r.isSlice())
             {
-                if (!r.hasBound(b))
-                {
-                    // There wasn't any non EQ relation on that key, we select all records having the preceding component as prefix.
-                    // For composites, if there was preceding component and we're computing the end, we must change the last component
-                    // End-Of-Component, otherwise we would be selecting only one record.
-                    return builder.buildWithEOC(bound.isEnd() ? EOC.END : EOC.START);
-                }
-
-                r.appendBoundTo(builder, b, options);
-                Composite.EOC eoc = eocFor(r, bound, b);
-                return builder.buildWithEOC(eoc);
+                r.appendBoundTo(builder, bound, options);
+                return filterAndSort(setEocs(r, bound, builder.build()));
             }
 
-            r.appendBoundTo(builder, b, options);
+            r.appendBoundTo(builder, bound, options);
 
             if (builder.hasMissingElements())
                 return Collections.emptyList();
@@ -233,7 +218,71 @@ final class PrimaryKeyRestrictionSet extends AbstractPrimaryKeyRestrictions
         // case using the eoc would be bad, since for the random partitioner we have no guarantee that
         // prefix.end() will sort after prefix (see #5240).
         EOC eoc = !builder.hasRemaining() ? EOC.NONE : (bound.isEnd() ? EOC.END : EOC.START);
-        return builder.buildWithEOC(eoc);
+        return filterAndSort(builder.buildWithEOC(eoc));
+    }
+
+    /**
+     * Removes duplicates and sort the specified composites.
+     *
+     * @param composites the composites to filter and sort
+     * @return the composites sorted and without duplicates
+     */
+    private List<Composite> filterAndSort(List<Composite> composites)
+    {
+        if (composites.size() <= 1)
+            return composites;
+
+        TreeSet<Composite> set = new TreeSet<Composite>(ctype);
+        set.addAll(composites);
+        return new ArrayList<>(set);
+    }
+
+    /**
+     * Sets EOCs for the composites returned by the specified slice restriction for the given bound.
+     *
+     * @param r the slice restriction
+     * @param bound the bound
+     * @param composites the composites
+     * @return the composites with their EOCs properly set
+     */
+    private List<Composite> setEocs(Restriction r, Bound bound, List<Composite> composites)
+    {
+        List<Composite> list = new ArrayList<>(composites.size());
+
+        // The first column of the slice might not be the first clustering column (e.g. clustering_0 = ? AND (clustering_1, clustering_2) >= (?, ?)
+        int offset = r.getFirstColumn().position();
+
+        for (int i = 0, m = composites.size(); i < m; i++)
+        {
+            Composite composite = composites.get(i);
+
+            // Handle the no bound case
+            if (composite.size() == offset)
+            {
+                list.add(composite.withEOC(bound.isEnd() ? EOC.END : EOC.START));
+                continue;
+            }
+
+            // In the case of mixed order columns, we will have some extra slices where the columns change directions.
+            // For example: if we have clustering_0 DESC and clustering_1 ASC a slice like (clustering_0, clustering_1) > (1, 2)
+            // will produce 2 slices: [EMPTY, 1.START] and [1.2.END, 1.END]
+            // So, the END bound will return 2 composite with the same values 1
+            if (composite.size() <= r.getLastColumn().position() && i < m - 1 && composite.equals(composites.get(i + 1)))
+            {
+                list.add(composite.withEOC(EOC.START));
+                list.add(composites.get(i++).withEOC(EOC.END));
+                continue;
+            }
+
+            // Handle the normal bounds
+            ColumnDefinition column = r.getColumnDefs().get(composite.size() - 1 - offset);
+            Bound b = reverseBoundIfNeeded(column, bound);
+
+            Composite.EOC eoc = eocFor(r, bound, b);
+            list.add(composite.withEOC(eoc));
+        }
+
+        return list;
     }
 
     @Override
@@ -307,7 +356,7 @@ final class PrimaryKeyRestrictionSet extends AbstractPrimaryKeyRestrictions
     }
 
     @Override
-    public Collection<ColumnDefinition> getColumnDefs()
+    public List<ColumnDefinition> getColumnDefs()
     {
         return restrictions.getColumnDefs();
     }
diff --git a/src/java/org/apache/cassandra/cql3/restrictions/Restriction.java b/src/java/org/apache/cassandra/cql3/restrictions/Restriction.java
index c115a3b962..f0ea6a7af8 100644
--- a/src/java/org/apache/cassandra/cql3/restrictions/Restriction.java
+++ b/src/java/org/apache/cassandra/cql3/restrictions/Restriction.java
@@ -17,7 +17,6 @@
  */
 package org.apache.cassandra.cql3.restrictions;
 
-import java.util.Collection;
 import java.util.List;
 
 import org.apache.cassandra.config.ColumnDefinition;
@@ -60,7 +59,7 @@ public interface Restriction
      * Returns the column definitions in position order.
      * @return the column definitions in position order.
      */
-    public Collection<ColumnDefinition> getColumnDefs();
+    public List<ColumnDefinition> getColumnDefs();
 
     /**
      * Return an Iterable over all of the functions (both native and user-defined) used by any component
diff --git a/src/java/org/apache/cassandra/cql3/restrictions/RestrictionSet.java b/src/java/org/apache/cassandra/cql3/restrictions/RestrictionSet.java
index 6bf7666219..676ed13f34 100644
--- a/src/java/org/apache/cassandra/cql3/restrictions/RestrictionSet.java
+++ b/src/java/org/apache/cassandra/cql3/restrictions/RestrictionSet.java
@@ -75,9 +75,9 @@ final class RestrictionSet implements Restrictions, Iterable<Restriction>
     }
 
     @Override
-    public final Set<ColumnDefinition> getColumnDefs()
+    public final List<ColumnDefinition> getColumnDefs()
     {
-        return restrictions.keySet();
+        return new ArrayList<>(restrictions.keySet());
     }
 
     @Override
diff --git a/src/java/org/apache/cassandra/cql3/restrictions/SingleColumnRestriction.java b/src/java/org/apache/cassandra/cql3/restrictions/SingleColumnRestriction.java
index afa0419e21..735a2e2385 100644
--- a/src/java/org/apache/cassandra/cql3/restrictions/SingleColumnRestriction.java
+++ b/src/java/org/apache/cassandra/cql3/restrictions/SingleColumnRestriction.java
@@ -52,7 +52,7 @@ public abstract class SingleColumnRestriction extends AbstractRestriction
     }
 
     @Override
-    public Collection<ColumnDefinition> getColumnDefs()
+    public List<ColumnDefinition> getColumnDefs()
     {
         return Collections.singletonList(columnDef);
     }
@@ -351,7 +351,12 @@ public abstract class SingleColumnRestriction extends AbstractRestriction
         @Override
         public CompositesBuilder appendBoundTo(CompositesBuilder builder, Bound bound, QueryOptions options)
         {
-            ByteBuffer value = slice.bound(bound).bindAndGet(options);
+            Bound b = reverseBoundIfNeeded(getFirstColumn(), bound);
+
+            if (!hasBound(b))
+                return builder;
+
+            ByteBuffer value = slice.bound(b).bindAndGet(options);
             checkBindValueSet(value, "Invalid unset value for column %s", columnDef.name);
             return builder.addElementToAll(value);
 
diff --git a/src/java/org/apache/cassandra/cql3/restrictions/TokenRestriction.java b/src/java/org/apache/cassandra/cql3/restrictions/TokenRestriction.java
index f8cd0dc7ee..3cd3304491 100644
--- a/src/java/org/apache/cassandra/cql3/restrictions/TokenRestriction.java
+++ b/src/java/org/apache/cassandra/cql3/restrictions/TokenRestriction.java
@@ -18,7 +18,6 @@
 package org.apache.cassandra.cql3.restrictions;
 
 import java.nio.ByteBuffer;
-import java.util.Collection;
 import java.util.Collections;
 import java.util.List;
 
@@ -67,7 +66,7 @@ public abstract class TokenRestriction extends AbstractPrimaryKeyRestrictions
     }
 
     @Override
-    public Collection<ColumnDefinition> getColumnDefs()
+    public List<ColumnDefinition> getColumnDefs()
     {
         return columnDefs;
     }
diff --git a/src/java/org/apache/cassandra/cql3/statements/ModificationStatement.java b/src/java/org/apache/cassandra/cql3/statements/ModificationStatement.java
index 8b594ddac1..fbdfc0cef7 100644
--- a/src/java/org/apache/cassandra/cql3/statements/ModificationStatement.java
+++ b/src/java/org/apache/cassandra/cql3/statements/ModificationStatement.java
@@ -48,7 +48,6 @@ import org.apache.cassandra.transport.messages.ResultMessage;
 import org.apache.cassandra.triggers.TriggerExecutor;
 import org.apache.cassandra.utils.Pair;
 import org.apache.cassandra.utils.UUIDGen;
-
 import static org.apache.cassandra.cql3.statements.RequestValidations.checkFalse;
 import static org.apache.cassandra.cql3.statements.RequestValidations.checkNotNull;
 import static org.apache.cassandra.cql3.statements.RequestValidations.invalidRequest;
@@ -310,7 +309,7 @@ public abstract class ModificationStatement implements CQLStatement
             r.appendTo(keyBuilder, options);
         }
 
-        return Lists.transform(keyBuilder.build(), new com.google.common.base.Function<Composite, ByteBuffer>()
+        return Lists.transform(filterAndSort(keyBuilder.build()), new com.google.common.base.Function<Composite, ByteBuffer>()
         {
             @Override
             public ByteBuffer apply(Composite composite)
@@ -404,6 +403,22 @@ public abstract class ModificationStatement implements CQLStatement
         return builder.build().get(0); // We only allow IN for row keys so far
     }
 
+    /**
+     * Removes duplicates and sort the specified composites.
+     *
+     * @param composites the composites to filter and sort
+     * @return the composites sorted and without duplicates
+     */
+    private List<Composite> filterAndSort(List<Composite> composites)
+    {
+        if (composites.size() <= 1)
+            return composites;
+
+        TreeSet<Composite> set = new TreeSet<Composite>(cfm.getKeyValidatorAsCType());
+        set.addAll(composites);
+        return new ArrayList<>(set);
+    }
+
     protected ColumnDefinition getFirstEmptyKey()
     {
         for (ColumnDefinition def : cfm.clusteringColumns())
diff --git a/src/java/org/apache/cassandra/db/composites/CompositesBuilder.java b/src/java/org/apache/cassandra/db/composites/CompositesBuilder.java
index 25a510fb39..9a4da9ed22 100644
--- a/src/java/org/apache/cassandra/db/composites/CompositesBuilder.java
+++ b/src/java/org/apache/cassandra/db/composites/CompositesBuilder.java
@@ -181,9 +181,6 @@ public final class CompositesBuilder
 
                     List<ByteBuffer> value = values.get(j);
 
-                    if (value.isEmpty())
-                        hasMissingElements = true;
-
                     if (value.contains(null))
                         containsNull = true;
                     if (value.contains(ByteBufferUtil.UNSET_BYTE_BUFFER))
@@ -283,26 +280,15 @@ public final class CompositesBuilder
         if (elementsList.isEmpty())
             return singletonList(builder.build().withEOC(eoc));
 
-        // Use a Set to sort if needed and eliminate duplicates
-        Set<Composite> set = newSet();
+        List<Composite> list = new ArrayList<>();
 
         for (int i = 0, m = elementsList.size(); i < m; i++)
         {
             List<ByteBuffer> elements = elementsList.get(i);
-            set.add(builder.buildWith(elements).withEOC(eoc));
+            list.add(builder.buildWith(elements).withEOC(eoc));
         }
 
-        return new ArrayList<>(set);
-    }
-
-    /**
-     * Returns a new <code>Set</code> instance that will be used to eliminate duplicates and sort the results.
-     *
-     * @return a new <code>Set</code> instance.
-     */
-    private Set<Composite> newSet()
-    {
-        return new TreeSet<>(ctype);
+        return list;
     }
 
     private void checkUpdateable()
diff --git a/test/unit/org/apache/cassandra/cql3/restrictions/PrimaryKeyRestrictionSetTest.java b/test/unit/org/apache/cassandra/cql3/restrictions/PrimaryKeyRestrictionSetTest.java
index 05d6e98afe..1deeb9ef3f 100644
--- a/test/unit/org/apache/cassandra/cql3/restrictions/PrimaryKeyRestrictionSetTest.java
+++ b/test/unit/org/apache/cassandra/cql3/restrictions/PrimaryKeyRestrictionSetTest.java
@@ -31,11 +31,10 @@ import org.apache.cassandra.cql3.statements.Bound;
 import org.apache.cassandra.db.ColumnFamilyType;
 import org.apache.cassandra.db.composites.Composite;
 import org.apache.cassandra.db.composites.Composite.EOC;
-import org.apache.cassandra.db.composites.Composites;
 import org.apache.cassandra.db.composites.CompoundSparseCellNameType;
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.db.marshal.Int32Type;
-import org.apache.cassandra.exceptions.InvalidRequestException;
+import org.apache.cassandra.db.marshal.ReversedType;
 import org.apache.cassandra.utils.ByteBufferUtil;
 
 import static java.util.Arrays.asList;
@@ -45,9 +44,9 @@ import static org.junit.Assert.assertTrue;
 public class PrimaryKeyRestrictionSetTest
 {
     @Test
-    public void testBoundsAsCompositesWithNoRestrictions() throws InvalidRequestException
+    public void testBoundsAsCompositesWithNoRestrictions()
     {
-        CFMetaData cfMetaData = newCFMetaData(1);
+        CFMetaData cfMetaData = newCFMetaData(Sort.ASC);
 
         PrimaryKeyRestrictions restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
 
@@ -64,9 +63,9 @@ public class PrimaryKeyRestrictionSetTest
      * Test 'clustering_0 = 1' with only one clustering column
      */
     @Test
-    public void testBoundsAsCompositesWithOneEqRestrictionsAndOneClusteringColumn() throws InvalidRequestException
+    public void testBoundsAsCompositesWithOneEqRestrictionsAndOneClusteringColumn()
     {
-        CFMetaData cfMetaData = newCFMetaData(1);
+        CFMetaData cfMetaData = newCFMetaData(Sort.ASC);
 
         ByteBuffer clustering_0 = ByteBufferUtil.bytes(1);
         Restriction eq = newSingleEq(cfMetaData, 0, clustering_0);
@@ -87,9 +86,9 @@ public class PrimaryKeyRestrictionSetTest
      * Test 'clustering_1 = 1' with 2 clustering columns
      */
     @Test
-    public void testBoundsAsCompositesWithOneEqRestrictionsAndTwoClusteringColumns() throws InvalidRequestException
+    public void testBoundsAsCompositesWithOneEqRestrictionsAndTwoClusteringColumns()
     {
-        CFMetaData cfMetaData = newCFMetaData(2);
+        CFMetaData cfMetaData = newCFMetaData(Sort.ASC, Sort.ASC);
 
         ByteBuffer clustering_0 = ByteBufferUtil.bytes(1);
         Restriction eq = newSingleEq(cfMetaData, 0, clustering_0);
@@ -110,13 +109,13 @@ public class PrimaryKeyRestrictionSetTest
      * Test 'clustering_0 IN (1, 2, 3)' with only one clustering column
      */
     @Test
-    public void testBoundsAsCompositesWithOneInRestrictionsAndOneClusteringColumn() throws InvalidRequestException
+    public void testBoundsAsCompositesWithOneInRestrictionsAndOneClusteringColumn()
     {
         ByteBuffer value1 = ByteBufferUtil.bytes(1);
         ByteBuffer value2 = ByteBufferUtil.bytes(2);
         ByteBuffer value3 = ByteBufferUtil.bytes(3);
 
-        CFMetaData cfMetaData = newCFMetaData(2);
+        CFMetaData cfMetaData = newCFMetaData(Sort.ASC, Sort.ASC);
 
         Restriction in = newSingleIN(cfMetaData, 0, value1, value2, value3);
 
@@ -140,9 +139,9 @@ public class PrimaryKeyRestrictionSetTest
      * Test slice restriction (e.g 'clustering_0 > 1') with only one clustering column
      */
     @Test
-    public void testBoundsAsCompositesWithSliceRestrictionsAndOneClusteringColumn() throws InvalidRequestException
+    public void testBoundsAsCompositesWithSliceRestrictionsAndOneClusteringColumn()
     {
-        CFMetaData cfMetaData = newCFMetaData(1);
+        CFMetaData cfMetaData = newCFMetaData(Sort.ASC, Sort.ASC);
 
         ByteBuffer value1 = ByteBufferUtil.bytes(1);
         ByteBuffer value2 = ByteBufferUtil.bytes(2);
@@ -222,13 +221,99 @@ public class PrimaryKeyRestrictionSetTest
         assertComposite(bounds.get(0), value2, EOC.END);
     }
 
+    /**
+     * Test slice restriction (e.g 'clustering_0 > 1') with only one descending clustering column
+     */
+    @Test
+    public void testBoundsAsCompositesWithSliceRestrictionsAndOneDescendingClusteringColumn()
+    {
+        CFMetaData cfMetaData = newCFMetaData(Sort.DESC, Sort.DESC);
+
+        ByteBuffer value1 = ByteBufferUtil.bytes(1);
+        ByteBuffer value2 = ByteBufferUtil.bytes(2);
+
+        Restriction slice = newSingleSlice(cfMetaData, 0, Bound.START, false, value1);
+        PrimaryKeyRestrictions restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
+        restrictions = restrictions.mergeWith(slice);
+
+        List<Composite> bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertEmptyComposite(bounds.get(0));
+
+        bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertComposite(bounds.get(0), value1, EOC.START);
+
+        slice = newSingleSlice(cfMetaData, 0, Bound.START, true, value1);
+        restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
+        restrictions = restrictions.mergeWith(slice);
+
+        bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertEmptyComposite(bounds.get(0));
+
+        bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertComposite(bounds.get(0), value1, EOC.END);
+
+        slice = newSingleSlice(cfMetaData, 0, Bound.END, true, value1);
+        restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
+        restrictions = restrictions.mergeWith(slice);
+
+        bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertComposite(bounds.get(0), value1, EOC.NONE);
+
+        bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertEmptyComposite(bounds.get(0));
+
+        slice = newSingleSlice(cfMetaData, 0, Bound.END, false, value1);
+        restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
+        restrictions = restrictions.mergeWith(slice);
+
+        bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertComposite(bounds.get(0), value1, EOC.END);
+
+        bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertEmptyComposite(bounds.get(0));
+
+        slice = newSingleSlice(cfMetaData, 0, Bound.START, false, value1);
+        Restriction slice2 = newSingleSlice(cfMetaData, 0, Bound.END, false, value2);
+        restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
+        restrictions = restrictions.mergeWith(slice).mergeWith(slice2);
+
+        bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertComposite(bounds.get(0), value2, EOC.END);
+
+        bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertComposite(bounds.get(0), value1, EOC.START);
+
+        slice = newSingleSlice(cfMetaData, 0, Bound.START, true, value1);
+        slice2 = newSingleSlice(cfMetaData, 0, Bound.END, true, value2);
+        restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
+        restrictions = restrictions.mergeWith(slice).mergeWith(slice2);
+
+        bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertComposite(bounds.get(0), value2, EOC.NONE);
+
+        bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertComposite(bounds.get(0), value1, EOC.END);
+    }
+
     /**
      * Test 'clustering_0 = 1 AND clustering_1 IN (1, 2, 3)'
      */
     @Test
-    public void testBoundsAsCompositesWithEqAndInRestrictions() throws InvalidRequestException
+    public void testBoundsAsCompositesWithEqAndInRestrictions()
     {
-        CFMetaData cfMetaData = newCFMetaData(2);
+        CFMetaData cfMetaData = newCFMetaData(Sort.ASC, Sort.ASC);
 
         ByteBuffer value1 = ByteBufferUtil.bytes(1);
         ByteBuffer value2 = ByteBufferUtil.bytes(2);
@@ -255,9 +340,9 @@ public class PrimaryKeyRestrictionSetTest
      * Test equal and slice restrictions (e.g 'clustering_0 = 0 clustering_1 > 1')
      */
     @Test
-    public void testBoundsAsCompositesWithEqAndSliceRestrictions() throws InvalidRequestException
+    public void testBoundsAsCompositesWithEqAndSliceRestrictions()
     {
-        CFMetaData cfMetaData = newCFMetaData(2);
+        CFMetaData cfMetaData = newCFMetaData(Sort.ASC, Sort.ASC);
 
         ByteBuffer value1 = ByteBufferUtil.bytes(1);
         ByteBuffer value2 = ByteBufferUtil.bytes(2);
@@ -286,218 +371,909 @@ public class PrimaryKeyRestrictionSetTest
         assertComposite(bounds.get(0), value3, value1, EOC.NONE);
 
         bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
-        assertEquals(1, bounds.size());
-        assertComposite(bounds.get(0), value3, EOC.END);
+        assertEquals(1, bounds.size());
+        assertComposite(bounds.get(0), value3, EOC.END);
+
+        slice = newSingleSlice(cfMetaData, 1, Bound.END, true, value1);
+        restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
+        restrictions = restrictions.mergeWith(eq).mergeWith(slice);
+
+        bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertComposite(bounds.get(0), value3, EOC.START);
+
+        bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertComposite(bounds.get(0), value3, value1, EOC.END);
+
+        slice = newSingleSlice(cfMetaData, 1, Bound.END, false, value1);
+        restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
+        restrictions = restrictions.mergeWith(eq).mergeWith(slice);
+
+        bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertComposite(bounds.get(0), value3, EOC.START);
+
+        bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertComposite(bounds.get(0), value3, value1, EOC.START);
+
+        slice = newSingleSlice(cfMetaData, 1, Bound.START, false, value1);
+        Restriction slice2 = newSingleSlice(cfMetaData, 1, Bound.END, false, value2);
+        restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
+        restrictions = restrictions.mergeWith(eq).mergeWith(slice).mergeWith(slice2);
+
+        bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertComposite(bounds.get(0), value3, value1, EOC.END);
+
+        bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertComposite(bounds.get(0), value3, value2, EOC.START);
+
+        slice = newSingleSlice(cfMetaData, 1, Bound.START, true, value1);
+        slice2 = newSingleSlice(cfMetaData, 1, Bound.END, true, value2);
+        restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
+        restrictions = restrictions.mergeWith(eq).mergeWith(slice).mergeWith(slice2);
+
+        bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertComposite(bounds.get(0), value3, value1, EOC.NONE);
+
+        bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertComposite(bounds.get(0), value3, value2, EOC.END);
+    }
+
+    /**
+     * Test '(clustering_0, clustering_1) = (1, 2)' with two clustering column
+     */
+    @Test
+    public void testBoundsAsCompositesWithMultiEqRestrictions()
+    {
+        CFMetaData cfMetaData = newCFMetaData(Sort.ASC, Sort.ASC);
+
+        ByteBuffer value1 = ByteBufferUtil.bytes(1);
+        ByteBuffer value2 = ByteBufferUtil.bytes(2);
+        Restriction eq = newMultiEq(cfMetaData, 0, value1, value2);
+        PrimaryKeyRestrictions restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
+        restrictions = restrictions.mergeWith(eq);
+
+        List<Composite> bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertComposite(bounds.get(0), value1, value2, EOC.START);
+
+        bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertComposite(bounds.get(0), value1, value2, EOC.END);
+    }
+
+    /**
+     * Test '(clustering_0, clustering_1) IN ((1, 2), (2, 3))' with two clustering column
+     */
+    @Test
+    public void testBoundsAsCompositesWithMultiInRestrictions()
+    {
+        CFMetaData cfMetaData = newCFMetaData(Sort.ASC, Sort.ASC);
+
+        ByteBuffer value1 = ByteBufferUtil.bytes(1);
+        ByteBuffer value2 = ByteBufferUtil.bytes(2);
+        ByteBuffer value3 = ByteBufferUtil.bytes(3);
+        Restriction in = newMultiIN(cfMetaData, 0, asList(value1, value2), asList(value2, value3));
+        PrimaryKeyRestrictions restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
+        restrictions = restrictions.mergeWith(in);
+
+        List<Composite> bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
+        assertEquals(2, bounds.size());
+        assertComposite(bounds.get(0), value1, value2, EOC.START);
+        assertComposite(bounds.get(1), value2, value3, EOC.START);
+
+        bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
+        assertEquals(2, bounds.size());
+        assertComposite(bounds.get(0), value1, value2, EOC.END);
+        assertComposite(bounds.get(1), value2, value3, EOC.END);
+    }
+
+    /**
+     * Test multi-column slice restrictions (e.g '(clustering_0) > (1)') with only one clustering column
+     */
+    @Test
+    public void testBoundsAsCompositesWithMultiSliceRestrictionsWithOneClusteringColumn()
+    {
+        CFMetaData cfMetaData = newCFMetaData(Sort.ASC);
+
+        ByteBuffer value1 = ByteBufferUtil.bytes(1);
+        ByteBuffer value2 = ByteBufferUtil.bytes(2);
+
+        Restriction slice = newMultiSlice(cfMetaData, 0, Bound.START, false, value1);
+        PrimaryKeyRestrictions restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
+        restrictions = restrictions.mergeWith(slice);
+
+        List<Composite> bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertComposite(bounds.get(0), value1, EOC.END);
+
+        bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertEmptyComposite(bounds.get(0));
+
+        slice = newMultiSlice(cfMetaData, 0, Bound.START, true, value1);
+        restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
+        restrictions = restrictions.mergeWith(slice);
+
+        bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertComposite(bounds.get(0), value1, EOC.NONE);
+
+        bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertEmptyComposite(bounds.get(0));
+
+        slice = newMultiSlice(cfMetaData, 0, Bound.END, true, value1);
+        restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
+        restrictions = restrictions.mergeWith(slice);
+
+        bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertEmptyComposite(bounds.get(0));
+
+        bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertComposite(bounds.get(0), value1, EOC.END);
+
+        slice = newMultiSlice(cfMetaData, 0, Bound.END, false, value1);
+        restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
+        restrictions = restrictions.mergeWith(slice);
+
+        bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertEmptyComposite(bounds.get(0));
+
+        bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertComposite(bounds.get(0), value1, EOC.START);
+
+        slice = newMultiSlice(cfMetaData, 0, Bound.START, false, value1);
+        Restriction slice2 = newMultiSlice(cfMetaData, 0, Bound.END, false, value2);
+        restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
+        restrictions = restrictions.mergeWith(slice).mergeWith(slice2);
+
+        bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertComposite(bounds.get(0), value1, EOC.END);
+
+        bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertComposite(bounds.get(0), value2, EOC.START);
+
+        slice = newMultiSlice(cfMetaData, 0, Bound.START, true, value1);
+        slice2 = newMultiSlice(cfMetaData, 0, Bound.END, true, value2);
+        restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
+        restrictions = restrictions.mergeWith(slice).mergeWith(slice2);
+
+        bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertComposite(bounds.get(0), value1, EOC.NONE);
+
+        bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertComposite(bounds.get(0), value2, EOC.END);
+    }
+
+    /**
+     * Test multi-column slice restrictions (e.g '(clustering_0) > (1)') with only one clustering column in reverse
+     * order
+     */
+    @Test
+    public void testBoundsAsCompositesWithMultiSliceRestrictionsWithOneDescendingClusteringColumn()
+    {
+        CFMetaData cfMetaData = newCFMetaData(Sort.DESC);
+
+        ByteBuffer value1 = ByteBufferUtil.bytes(1);
+        ByteBuffer value2 = ByteBufferUtil.bytes(2);
+
+        Restriction slice = newMultiSlice(cfMetaData, 0, Bound.START, false, value1);
+        PrimaryKeyRestrictions restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
+        restrictions = restrictions.mergeWith(slice);
+
+        List<Composite> bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertEmptyComposite(bounds.get(0));
+
+        bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertComposite(bounds.get(0), value1, EOC.START);
+
+        slice = newMultiSlice(cfMetaData, 0, Bound.START, true, value1);
+        restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
+        restrictions = restrictions.mergeWith(slice);
+
+        bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertEmptyComposite(bounds.get(0));
+
+        bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertComposite(bounds.get(0), value1, EOC.END);
+
+        slice = newMultiSlice(cfMetaData, 0, Bound.END, true, value1);
+        restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
+        restrictions = restrictions.mergeWith(slice);
+
+        bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertComposite(bounds.get(0), value1, EOC.NONE);
+
+        bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertEmptyComposite(bounds.get(0));
+
+        slice = newMultiSlice(cfMetaData, 0, Bound.END, false, value1);
+        restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
+        restrictions = restrictions.mergeWith(slice);
+
+        bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertComposite(bounds.get(0), value1, EOC.END);
+
+        bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertEmptyComposite(bounds.get(0));
+
+        slice = newMultiSlice(cfMetaData, 0, Bound.START, false, value1);
+        Restriction slice2 = newMultiSlice(cfMetaData, 0, Bound.END, false, value2);
+        restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
+        restrictions = restrictions.mergeWith(slice).mergeWith(slice2);
+
+        bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertComposite(bounds.get(0), value2, EOC.END);
+
+        bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertComposite(bounds.get(0), value1, EOC.START);
+
+        slice = newMultiSlice(cfMetaData, 0, Bound.START, true, value1);
+        slice2 = newMultiSlice(cfMetaData, 0, Bound.END, true, value2);
+        restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
+        restrictions = restrictions.mergeWith(slice).mergeWith(slice2);
+
+        bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertComposite(bounds.get(0), value2, EOC.NONE);
+
+        bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertComposite(bounds.get(0), value1, EOC.END);
+    }
+
+    /**
+     * Test multi-column slice restrictions (e.g '(clustering_0, clustering_1) > (1, 2)')
+     */
+    @Test
+    public void testBoundsAsCompositesWithMultiSliceRestrictionsWithTwoClusteringColumn()
+    {
+        CFMetaData cfMetaData = newCFMetaData(Sort.ASC, Sort.ASC);
+
+        ByteBuffer value1 = ByteBufferUtil.bytes(1);
+        ByteBuffer value2 = ByteBufferUtil.bytes(2);
+
+        // (clustering_0, clustering1) > (1, 2)
+        Restriction slice = newMultiSlice(cfMetaData, 0, Bound.START, false, value1, value2);
+        PrimaryKeyRestrictions restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
+        restrictions = restrictions.mergeWith(slice);
+
+        List<Composite> bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertComposite(bounds.get(0), value1, value2, EOC.END);
+
+        bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertEmptyComposite(bounds.get(0));
+
+        // (clustering_0, clustering1) >= (1, 2)
+        slice = newMultiSlice(cfMetaData, 0, Bound.START, true, value1, value2);
+        restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
+        restrictions = restrictions.mergeWith(slice);
+
+        bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertComposite(bounds.get(0), value1, value2, EOC.NONE);
+
+        bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertEmptyComposite(bounds.get(0));
+
+        // (clustering_0, clustering1) <= (1, 2)
+        slice = newMultiSlice(cfMetaData, 0, Bound.END, true, value1, value2);
+        restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
+        restrictions = restrictions.mergeWith(slice);
+
+        bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertEmptyComposite(bounds.get(0));
+
+        bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertComposite(bounds.get(0), value1, value2, EOC.END);
+
+        // (clustering_0, clustering1) < (1, 2)
+        slice = newMultiSlice(cfMetaData, 0, Bound.END, false, value1, value2);
+        restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
+        restrictions = restrictions.mergeWith(slice);
+
+        bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertEmptyComposite(bounds.get(0));
+
+        bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertComposite(bounds.get(0), value1, value2, EOC.START);
+
+        // (clustering_0, clustering1) > (1, 2) AND (clustering_0) < (2)
+        slice = newMultiSlice(cfMetaData, 0, Bound.START, false, value1, value2);
+        Restriction slice2 = newMultiSlice(cfMetaData, 0, Bound.END, false, value2);
+        restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
+        restrictions = restrictions.mergeWith(slice).mergeWith(slice2);
+
+        bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertComposite(bounds.get(0), value1, value2, EOC.END);
+
+        bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertComposite(bounds.get(0), value2, EOC.START);
+
+        // (clustering_0, clustering1) >= (1, 2) AND (clustering_0, clustering1) <= (2, 1)
+        slice = newMultiSlice(cfMetaData, 0, Bound.START, true, value1, value2);
+        slice2 = newMultiSlice(cfMetaData, 0, Bound.END, true, value2, value1);
+        restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
+        restrictions = restrictions.mergeWith(slice).mergeWith(slice2);
+
+        bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertComposite(bounds.get(0), value1, value2, EOC.NONE);
+
+        bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertComposite(bounds.get(0), value2, value1, EOC.END);
+    }
+
+    /**
+     * Test multi-column slice restrictions with 2 descending clustering columns (e.g '(clustering_0, clustering_1) > (1, 2)')
+     */
+    @Test
+    public void testBoundsAsCompositesWithMultiSliceRestrictionsWithTwoDescendingClusteringColumns()
+    {
+        CFMetaData cfMetaData = newCFMetaData(Sort.DESC, Sort.DESC);
+
+        ByteBuffer value1 = ByteBufferUtil.bytes(1);
+        ByteBuffer value2 = ByteBufferUtil.bytes(2);
+
+        // (clustering_0, clustering1) > (1, 2)
+        Restriction slice = newMultiSlice(cfMetaData, 0, Bound.START, false, value1, value2);
+        PrimaryKeyRestrictions restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
+        restrictions = restrictions.mergeWith(slice);
+
+        List<Composite> bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertEmptyComposite(bounds.get(0));
+
+        bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertComposite(bounds.get(0), value1, value2, EOC.START);
+
+        // (clustering_0, clustering1) >= (1, 2)
+        slice = newMultiSlice(cfMetaData, 0, Bound.START, true, value1, value2);
+        restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
+        restrictions = restrictions.mergeWith(slice);
+
+        bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertEmptyComposite(bounds.get(0));
+
+        bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertComposite(bounds.get(0), value1, value2, EOC.END);
+
+        // (clustering_0, clustering1) <= (1, 2)
+        slice = newMultiSlice(cfMetaData, 0, Bound.END, true, value1, value2);
+        restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
+        restrictions = restrictions.mergeWith(slice);
+
+        bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertComposite(bounds.get(0), value1, value2, EOC.NONE);
+
+        bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertEmptyComposite(bounds.get(0));
+
+        // (clustering_0, clustering1) < (1, 2)
+        slice = newMultiSlice(cfMetaData, 0, Bound.END, false, value1, value2);
+        restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
+        restrictions = restrictions.mergeWith(slice);
+
+        bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertComposite(bounds.get(0), value1, value2, EOC.END);
+
+        bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertEmptyComposite(bounds.get(0));
+
+
+        // (clustering_0, clustering1) > (1, 2) AND (clustering_0) < (2)
+        slice = newMultiSlice(cfMetaData, 0, Bound.START, false, value1, value2);
+        Restriction slice2 = newMultiSlice(cfMetaData, 0, Bound.END, false, value2);
+        restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
+        restrictions = restrictions.mergeWith(slice).mergeWith(slice2);
+
+        bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertComposite(bounds.get(0), value2, EOC.END);
+
+        bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertComposite(bounds.get(0), value1, value2, EOC.START);
+
+        // (clustering_0, clustering1) >= (1, 2) AND (clustering_0, clustering1) <= (2, 1)
+        slice = newMultiSlice(cfMetaData, 0, Bound.START, true, value1, value2);
+        slice2 = newMultiSlice(cfMetaData, 0, Bound.END, true, value2, value1);
+        restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
+        restrictions = restrictions.mergeWith(slice).mergeWith(slice2);
+
+        bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertComposite(bounds.get(0), value2, value1, EOC.NONE);
+
+        bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
+        assertEquals(1, bounds.size());
+        assertComposite(bounds.get(0), value1, value2, EOC.END);
+    }
+
+    /**
+     * Test multi-column slice restrictions with 1 descending clustering column and 1 ascending
+     * (e.g '(clustering_0, clustering_1) > (1, 2)')
+     */
+    @Test
+    public void testBoundsAsCompositesWithMultiSliceRestrictionsWithOneDescendingAndOneAscendingClusteringColumns()
+    {
+        CFMetaData cfMetaData = newCFMetaData(Sort.DESC, Sort.ASC);
+
+        ByteBuffer value1 = ByteBufferUtil.bytes(1);
+        ByteBuffer value2 = ByteBufferUtil.bytes(2);
+
+        // (clustering_0, clustering1) > (1, 2)
+        Restriction slice = newMultiSlice(cfMetaData, 0, Bound.START, false, value1, value2);
+        PrimaryKeyRestrictions restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
+        restrictions = restrictions.mergeWith(slice);
+
+        List<Composite> bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
+        assertEquals(2, bounds.size());
+        assertEmptyComposite(bounds.get(0));
+        assertComposite(bounds.get(1), value1, value2, EOC.END);
+
+        bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
+        assertEquals(2, bounds.size());
+        assertComposite(bounds.get(0), value1, EOC.START);
+        assertComposite(bounds.get(1), value1, EOC.END);
+
+        // (clustering_0, clustering1) >= (1, 2)
+        slice = newMultiSlice(cfMetaData, 0, Bound.START, true, value1, value2);
+        restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
+        restrictions = restrictions.mergeWith(slice);
+
+        bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
+        assertEquals(2, bounds.size());
+        assertEmptyComposite(bounds.get(0));
+        assertComposite(bounds.get(1), value1, value2, EOC.NONE);
+
+        bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
+        assertEquals(2, bounds.size());
+        assertComposite(bounds.get(0), value1, EOC.START);
+        assertComposite(bounds.get(1), value1, EOC.END);
+
+        // (clustering_0, clustering1) <= (1, 2)
+        slice = newMultiSlice(cfMetaData, 0, Bound.END, true, value1, value2);
+        restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
+        restrictions = restrictions.mergeWith(slice);
+
+        bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
+        assertEquals(2, bounds.size());
+        assertComposite(bounds.get(0), value1, EOC.START);
+        assertComposite(bounds.get(1), value1, EOC.END);
+
+        bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
+        assertEquals(2, bounds.size());
+        assertComposite(bounds.get(0), value1, value2, EOC.END);
+        assertEmptyComposite(bounds.get(1));
+
+        // (clustering_0, clustering1) < (1, 2)
+        slice = newMultiSlice(cfMetaData, 0, Bound.END, false, value1, value2);
+        restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
+        restrictions = restrictions.mergeWith(slice);
+
+        bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
+        assertEquals(2, bounds.size());
+        assertComposite(bounds.get(0), value1, EOC.START);
+        assertComposite(bounds.get(1), value1, EOC.END);
+
+        bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
+        assertEquals(2, bounds.size());
+        assertComposite(bounds.get(0), value1, value2, EOC.START);
+        assertEmptyComposite(bounds.get(1));
+
+        // (clustering_0, clustering1) > (1, 2) AND (clustering_0) < (2)
+        slice = newMultiSlice(cfMetaData, 0, Bound.START, false, value1, value2);
+        Restriction slice2 = newMultiSlice(cfMetaData, 0, Bound.END, false, value2);
+        restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
+        restrictions = restrictions.mergeWith(slice).mergeWith(slice2);
+
+        bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
+        assertEquals(2, bounds.size());
+        assertComposite(bounds.get(0), value2, EOC.END);
+        assertComposite(bounds.get(1), value1, value2, EOC.END);
+
+        bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
+        assertEquals(2, bounds.size());
+        assertComposite(bounds.get(0), value1, EOC.START);
+        assertComposite(bounds.get(1), value1, EOC.END);
+
+        // (clustering_0) > (1) AND (clustering_0, clustering1) < (2, 1)
+        slice = newMultiSlice(cfMetaData, 0, Bound.START, false, value1);
+        slice2 = newMultiSlice(cfMetaData, 0, Bound.END, false, value2, value1);
+        restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
+        restrictions = restrictions.mergeWith(slice).mergeWith(slice2);
+
+        bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
+        assertEquals(2, bounds.size());
+        assertComposite(bounds.get(0), value2, EOC.START);
+        assertComposite(bounds.get(1), value2, EOC.END);
+
+        bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
+        assertEquals(2, bounds.size());
+        assertComposite(bounds.get(0), value2, value1, EOC.START);
+        assertComposite(bounds.get(1), value1, EOC.START);
+
+        // (clustering_0, clustering1) >= (1, 2) AND (clustering_0, clustering1) <= (2, 1)
+        slice = newMultiSlice(cfMetaData, 0, Bound.START, true, value1, value2);
+        slice2 = newMultiSlice(cfMetaData, 0, Bound.END, true, value2, value1);
+        restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
+        restrictions = restrictions.mergeWith(slice).mergeWith(slice2);
+
+        bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
+        assertEquals(3, bounds.size());
+        assertComposite(bounds.get(0), value2, EOC.START);
+        assertComposite(bounds.get(1), value2, EOC.END);
+        assertComposite(bounds.get(2), value1, value2, EOC.NONE);
+
+        bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
+        assertEquals(3, bounds.size());
+        assertComposite(bounds.get(0), value2, value1, EOC.END);
+        assertComposite(bounds.get(1), value1, EOC.START);
+        assertComposite(bounds.get(2), value1, EOC.END);
+    }
+
+    /**
+     * Test multi-column slice restrictions with 1 descending clustering column and 1 ascending
+     * (e.g '(clustering_0, clustering_1) > (1, 2)')
+     */
+    @Test
+    public void testBoundsAsCompositesWithMultiSliceRestrictionsWithOneAscendingAndOneDescendingClusteringColumns()
+    {
+        CFMetaData cfMetaData = newCFMetaData(Sort.ASC, Sort.DESC);
+
+        ByteBuffer value1 = ByteBufferUtil.bytes(1);
+        ByteBuffer value2 = ByteBufferUtil.bytes(2);
+
+        // (clustering_0, clustering1) > (1, 2)
+        Restriction slice = newMultiSlice(cfMetaData, 0, Bound.START, false, value1, value2);
+        PrimaryKeyRestrictions restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
+        restrictions = restrictions.mergeWith(slice);
+
+        List<Composite> bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
+        assertEquals(2, bounds.size());
+        assertComposite(bounds.get(0), value1, EOC.START);
+        assertComposite(bounds.get(1), value1, EOC.END);
+
+        bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
+        assertEquals(2, bounds.size());
+        assertComposite(bounds.get(0), value1, value2, EOC.START);
+        assertEmptyComposite(bounds.get(1));
+
+        // (clustering_0, clustering1) >= (1, 2)
+        slice = newMultiSlice(cfMetaData, 0, Bound.START, true, value1, value2);
+        restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
+        restrictions = restrictions.mergeWith(slice);
+
+        bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
+        assertEquals(2, bounds.size());
+        assertComposite(bounds.get(0), value1, EOC.START);
+        assertComposite(bounds.get(1), value1, EOC.END);
+
+        bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
+        assertEquals(2, bounds.size());
+        assertComposite(bounds.get(0), value1, value2, EOC.END);
+        assertEmptyComposite(bounds.get(1));
 
-        slice = newSingleSlice(cfMetaData, 1, Bound.END, true, value1);
+        // (clustering_0, clustering1) <= (1, 2)
+        slice = newMultiSlice(cfMetaData, 0, Bound.END, true, value1, value2);
         restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
-        restrictions = restrictions.mergeWith(eq).mergeWith(slice);
+        restrictions = restrictions.mergeWith(slice);
 
         bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
-        assertEquals(1, bounds.size());
-        assertComposite(bounds.get(0), value3, EOC.START);
+        assertEquals(2, bounds.size());
+        assertEmptyComposite(bounds.get(0));
+        assertComposite(bounds.get(1), value1, value2, EOC.NONE);
 
         bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
-        assertEquals(1, bounds.size());
-        assertComposite(bounds.get(0), value3, value1, EOC.END);
+        assertEquals(2, bounds.size());
+        assertComposite(bounds.get(0), value1, EOC.START);
+        assertComposite(bounds.get(1), value1, EOC.END);
 
-        slice = newSingleSlice(cfMetaData, 1, Bound.END, false, value1);
+        // (clustering_0, clustering1) < (1, 2)
+        slice = newMultiSlice(cfMetaData, 0, Bound.END, false, value1, value2);
         restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
-        restrictions = restrictions.mergeWith(eq).mergeWith(slice);
+        restrictions = restrictions.mergeWith(slice);
 
         bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
-        assertEquals(1, bounds.size());
-        assertComposite(bounds.get(0), value3, EOC.START);
+        assertEquals(2, bounds.size());
+        assertEmptyComposite(bounds.get(0));
+        assertComposite(bounds.get(1), value1, value2, EOC.END);
 
         bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
-        assertEquals(1, bounds.size());
-        assertComposite(bounds.get(0), value3, value1, EOC.START);
+        assertEquals(2, bounds.size());
+        assertComposite(bounds.get(0), value1, EOC.START);
+        assertComposite(bounds.get(1), value1, EOC.END);
 
-        slice = newSingleSlice(cfMetaData, 1, Bound.START, false, value1);
-        Restriction slice2 = newSingleSlice(cfMetaData, 1, Bound.END, false, value2);
+        // (clustering_0, clustering1) > (1, 2) AND (clustering_0) < (2)
+        slice = newMultiSlice(cfMetaData, 0, Bound.START, false, value1, value2);
+        Restriction slice2 = newMultiSlice(cfMetaData, 0, Bound.END, false, value2);
         restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
-        restrictions = restrictions.mergeWith(eq).mergeWith(slice).mergeWith(slice2);
+        restrictions = restrictions.mergeWith(slice).mergeWith(slice2);
 
         bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
-        assertEquals(1, bounds.size());
-        assertComposite(bounds.get(0), value3, value1, EOC.END);
+        assertEquals(2, bounds.size());
+        assertComposite(bounds.get(0), value1, EOC.START);
+        assertComposite(bounds.get(1), value1, EOC.END);
 
         bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
-        assertEquals(1, bounds.size());
-        assertComposite(bounds.get(0), value3, value2, EOC.START);
+        assertEquals(2, bounds.size());
+        assertComposite(bounds.get(0), value1, value2, EOC.START);
+        assertComposite(bounds.get(1), value2, EOC.START);
 
-        slice = newSingleSlice(cfMetaData, 1, Bound.START, true, value1);
-        slice2 = newSingleSlice(cfMetaData, 1, Bound.END, true, value2);
+        // (clustering_0, clustering1) >= (1, 2) AND (clustering_0, clustering1) <= (2, 1)
+        slice = newMultiSlice(cfMetaData, 0, Bound.START, true, value1, value2);
+        slice2 = newMultiSlice(cfMetaData, 0, Bound.END, true, value2, value1);
         restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
-        restrictions = restrictions.mergeWith(eq).mergeWith(slice).mergeWith(slice2);
+        restrictions = restrictions.mergeWith(slice).mergeWith(slice2);
 
         bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
-        assertEquals(1, bounds.size());
-        assertComposite(bounds.get(0), value3, value1, EOC.NONE);
+        assertEquals(3, bounds.size());
+        assertComposite(bounds.get(0), value1, EOC.START);
+        assertComposite(bounds.get(1), value1, EOC.END);
+        assertComposite(bounds.get(2), value2, value1, EOC.NONE);
 
         bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
-        assertEquals(1, bounds.size());
-        assertComposite(bounds.get(0), value3, value2, EOC.END);
+        assertEquals(3, bounds.size());
+        assertComposite(bounds.get(0), value1, value2, EOC.END);
+        assertComposite(bounds.get(1), value2, EOC.START);
+        assertComposite(bounds.get(2), value2, EOC.END);
     }
 
     /**
-     * Test '(clustering_0, clustering_1) = (1, 2)' with two clustering column
+     * Test multi-column slice restrictions with 2 ascending clustering column and 2 descending
+     * (e.g '(clustering_0, clustering1, clustering_3, clustering4) > (1, 2, 3, 4)')
      */
     @Test
-    public void testBoundsAsCompositesWithMultiEqRestrictions() throws InvalidRequestException
+    public void testBoundsAsCompositesWithMultiSliceRestrictionsWithTwoAscendingAndTwoDescendingClusteringColumns()
     {
-        CFMetaData cfMetaData = newCFMetaData(2);
+        CFMetaData cfMetaData = newCFMetaData(Sort.ASC, Sort.ASC, Sort.DESC, Sort.DESC);
 
         ByteBuffer value1 = ByteBufferUtil.bytes(1);
         ByteBuffer value2 = ByteBufferUtil.bytes(2);
-        Restriction eq = newMultiEq(cfMetaData, 0, value1, value2);
+        ByteBuffer value3 = ByteBufferUtil.bytes(3);
+        ByteBuffer value4 = ByteBufferUtil.bytes(4);
+
+        // (clustering_0, clustering1, clustering_2, clustering_3) > (1, 2, 3, 4)
+        Restriction slice = newMultiSlice(cfMetaData, 0, Bound.START, false, value1, value2, value3, value4);
         PrimaryKeyRestrictions restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
-        restrictions = restrictions.mergeWith(eq);
+        restrictions = restrictions.mergeWith(slice);
 
         List<Composite> bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
-        assertEquals(1, bounds.size());
+        assertEquals(2, bounds.size());
         assertComposite(bounds.get(0), value1, value2, EOC.START);
+        assertComposite(bounds.get(1), value1, value2, EOC.END);
 
         bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
-        assertEquals(1, bounds.size());
-        assertComposite(bounds.get(0), value1, value2, EOC.END);
-    }
-
-    /**
-     * Test '(clustering_0, clustering_1) IN ((1, 2), (2, 3))' with two clustering column
-     */
-    @Test
-    public void testBoundsAsCompositesWithMultiInRestrictions() throws InvalidRequestException
-    {
-        CFMetaData cfMetaData = newCFMetaData(2);
+        assertEquals(2, bounds.size());
+        assertComposite(bounds.get(0), value1, value2, value3, value4, EOC.START);
+        assertEmptyComposite(bounds.get(1));
 
-        ByteBuffer value1 = ByteBufferUtil.bytes(1);
-        ByteBuffer value2 = ByteBufferUtil.bytes(2);
-        ByteBuffer value3 = ByteBufferUtil.bytes(3);
-        Restriction in = newMultiIN(cfMetaData, 0, asList(value1, value2), asList(value2, value3));
-        PrimaryKeyRestrictions restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
-        restrictions = restrictions.mergeWith(in);
+        // clustering_0 = 1 AND (clustering_1, clustering_2, clustering_3) > (2, 3, 4)
+        Restriction eq = newSingleEq(cfMetaData, 0, value1);
+        slice = newMultiSlice(cfMetaData, 1, Bound.START, false, value2, value3, value4);
+        restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
+        restrictions = restrictions.mergeWith(slice);
+        restrictions = restrictions.mergeWith(eq);
 
-        List<Composite> bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
+        bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
         assertEquals(2, bounds.size());
         assertComposite(bounds.get(0), value1, value2, EOC.START);
-        assertComposite(bounds.get(1), value2, value3, EOC.START);
+        assertComposite(bounds.get(1), value1, value2, EOC.END);
 
         bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
         assertEquals(2, bounds.size());
-        assertComposite(bounds.get(0), value1, value2, EOC.END);
-        assertComposite(bounds.get(1), value2, value3, EOC.END);
-    }
+        assertComposite(bounds.get(0), value1, value2, value3, value4, EOC.START);
+        assertComposite(bounds.get(1), value1, EOC.END);
 
-    /**
-     * Test multi-column slice restrictions (e.g '(clustering_0) > (1)') with only one clustering column
-     */
-    @Test
-    public void testBoundsAsCompositesWithMultiSliceRestrictionsWithOneClusteringColumn() throws InvalidRequestException
-    {
-        CFMetaData cfMetaData = newCFMetaData(1);
+        // clustering_0 = 1 AND (clustering_1, clustering_2, clustering_3) > (2, 3, 4)
+        Restriction in = newSingleIN(cfMetaData, 0, value1, value2);
+        slice = newMultiSlice(cfMetaData, 1, Bound.START, false, value2, value3, value4);
+        restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
+        restrictions = restrictions.mergeWith(slice);
+        restrictions = restrictions.mergeWith(in);
 
-        ByteBuffer value1 = ByteBufferUtil.bytes(1);
-        ByteBuffer value2 = ByteBufferUtil.bytes(2);
+        bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
+        assertEquals(4, bounds.size());
+        assertComposite(bounds.get(0), value1, value2, EOC.START);
+        assertComposite(bounds.get(1), value1, value2, EOC.END);
+        assertComposite(bounds.get(2), value2, value2, EOC.START);
+        assertComposite(bounds.get(3), value2, value2, EOC.END);
 
-        Restriction slice = newMultiSlice(cfMetaData, 0, Bound.START, false, value1);
-        PrimaryKeyRestrictions restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
+        bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
+        assertEquals(4, bounds.size());
+        assertComposite(bounds.get(0), value1, value2, value3, value4, EOC.START);
+        assertComposite(bounds.get(1), value1, EOC.END);
+        assertComposite(bounds.get(2), value2, value2, value3, value4, EOC.START);
+        assertComposite(bounds.get(3), value2, EOC.END);
+
+        // (clustering_0, clustering1) >= (1, 2)
+        slice = newMultiSlice(cfMetaData, 0, Bound.START, true, value1, value2);
+        restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
         restrictions = restrictions.mergeWith(slice);
 
-        List<Composite> bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
+        bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
         assertEquals(1, bounds.size());
-        assertComposite(bounds.get(0), value1, EOC.END);
+        assertComposite(bounds.get(0), value1, value2, EOC.NONE);
 
         bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
         assertEquals(1, bounds.size());
         assertEmptyComposite(bounds.get(0));
 
-        slice = newMultiSlice(cfMetaData, 0, Bound.START, true, value1);
+        // (clustering_0, clustering1, clustering_2, clustering_3) >= (1, 2, 3, 4)
+        slice = newMultiSlice(cfMetaData, 0, Bound.START, true, value1, value2, value3, value4);
         restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
         restrictions = restrictions.mergeWith(slice);
 
         bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
-        assertEquals(1, bounds.size());
-        assertComposite(bounds.get(0), value1, EOC.NONE);
+        assertEquals(2, bounds.size());
+        assertComposite(bounds.get(0), value1, value2, EOC.START);
+        assertComposite(bounds.get(1), value1, value2, EOC.END);
 
         bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
-        assertEquals(1, bounds.size());
-        assertEmptyComposite(bounds.get(0));
+        assertEquals(2, bounds.size());
+        assertComposite(bounds.get(0), value1, value2, value3, value4, EOC.END);
+        assertEmptyComposite(bounds.get(1));
 
-        slice = newMultiSlice(cfMetaData, 0, Bound.END, true, value1);
+        // (clustering_0, clustering1, clustering_2, clustering_3) <= (1, 2, 3, 4)
+        slice = newMultiSlice(cfMetaData, 0, Bound.END, true, value1, value2, value3, value4);
         restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
         restrictions = restrictions.mergeWith(slice);
 
         bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
-        assertEquals(1, bounds.size());
+        assertEquals(2, bounds.size());
         assertEmptyComposite(bounds.get(0));
+        assertComposite(bounds.get(1), value1, value2, value3, value4, EOC.NONE);
 
         bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
-        assertEquals(1, bounds.size());
-        assertComposite(bounds.get(0), value1, EOC.END);
+        assertEquals(2, bounds.size());
+        assertComposite(bounds.get(0), value1, value2, EOC.START);
+        assertComposite(bounds.get(1), value1, value2, EOC.END);
 
-        slice = newMultiSlice(cfMetaData, 0, Bound.END, false, value1);
+        // (clustering_0, clustering1, clustering_2, clustering_3) < (1, 2, 3, 4)
+        slice = newMultiSlice(cfMetaData, 0, Bound.END, false, value1, value2, value3, value4);
         restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
         restrictions = restrictions.mergeWith(slice);
 
         bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
-        assertEquals(1, bounds.size());
+        assertEquals(2, bounds.size());
         assertEmptyComposite(bounds.get(0));
+        assertComposite(bounds.get(1), value1, value2, value3, value4, EOC.END);
 
         bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
-        assertEquals(1, bounds.size());
-        assertComposite(bounds.get(0), value1, EOC.START);
+        assertEquals(2, bounds.size());
+        assertComposite(bounds.get(0), value1, value2, EOC.START);
+        assertComposite(bounds.get(1), value1, value2, EOC.END);
 
-        slice = newMultiSlice(cfMetaData, 0, Bound.START, false, value1);
-        Restriction slice2 = newMultiSlice(cfMetaData, 0, Bound.END, false, value2);
+        // (clustering_0, clustering1, clustering_2, clustering_3) > (1, 2, 3, 4) AND (clustering_0, clustering_1) < (2, 3)
+        slice = newMultiSlice(cfMetaData, 0, Bound.START, false, value1, value2, value3, value4);
+        Restriction slice2 = newMultiSlice(cfMetaData, 0, Bound.END, false, value2, value3);
         restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
         restrictions = restrictions.mergeWith(slice).mergeWith(slice2);
 
         bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
-        assertEquals(1, bounds.size());
-        assertComposite(bounds.get(0), value1, EOC.END);
+        assertEquals(2, bounds.size());
+        assertComposite(bounds.get(0), value1, value2, EOC.START);
+        assertComposite(bounds.get(1), value1, value2, EOC.END);
 
         bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
-        assertEquals(1, bounds.size());
-        assertComposite(bounds.get(0), value2, EOC.START);
+        assertEquals(2, bounds.size());
+        assertComposite(bounds.get(0), value1, value2, value3, value4, EOC.START);
+        assertComposite(bounds.get(1), value2, value3, EOC.START);
 
-        slice = newMultiSlice(cfMetaData, 0, Bound.START, true, value1);
-        slice2 = newMultiSlice(cfMetaData, 0, Bound.END, true, value2);
+        // (clustering_0, clustering1, clustering_2, clustering_3) >= (1, 2, 3, 4) AND (clustering_0, clustering1, clustering_2, clustering_3) <= (4, 3, 2, 1)
+        slice = newMultiSlice(cfMetaData, 0, Bound.START, true, value1, value2, value3, value4);
+        slice2 = newMultiSlice(cfMetaData, 0, Bound.END, true, value4, value3, value2, value1);
         restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
         restrictions = restrictions.mergeWith(slice).mergeWith(slice2);
 
         bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
-        assertEquals(1, bounds.size());
-        assertComposite(bounds.get(0), value1, EOC.NONE);
+        assertEquals(3, bounds.size());
+        assertComposite(bounds.get(0), value1, value2,  EOC.START);
+        assertComposite(bounds.get(1), value1, value2, EOC.END);
+        assertComposite(bounds.get(2), value4, value3, value2, value1, EOC.NONE);
 
         bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
-        assertEquals(1, bounds.size());
-        assertComposite(bounds.get(0), value2, EOC.END);
+        assertEquals(3, bounds.size());
+        assertComposite(bounds.get(0), value1, value2, value3, value4, EOC.END);
+        assertComposite(bounds.get(1), value4, value3, EOC.START);
+        assertComposite(bounds.get(2), value4, value3, EOC.END);
     }
 
     /**
-     * Test multi-column slice restrictions (e.g '(clustering_0, clustering_1) > (1, 2)')
+     * Test multi-column slice restrictions with ascending, descending, ascending and descending columns
+     * (e.g '(clustering_0, clustering1, clustering_3, clustering4) > (1, 2, 3, 4)')
      */
     @Test
-    public void testBoundsAsCompositesWithMultiSliceRestrictionsWithTwoClusteringColumn() throws InvalidRequestException
+    public void testBoundsAsCompositesWithMultiSliceRestrictionsMixingAscendingDescendingClusteringColumns()
     {
-        CFMetaData cfMetaData = newCFMetaData(2);
+        CFMetaData cfMetaData = newCFMetaData(Sort.ASC, Sort.DESC, Sort.ASC, Sort.DESC);
 
         ByteBuffer value1 = ByteBufferUtil.bytes(1);
         ByteBuffer value2 = ByteBufferUtil.bytes(2);
+        ByteBuffer value3 = ByteBufferUtil.bytes(3);
+        ByteBuffer value4 = ByteBufferUtil.bytes(4);
 
-        // (clustering_0, clustering1) > (1, 2)
-        Restriction slice = newMultiSlice(cfMetaData, 0, Bound.START, false, value1, value2);
+        // (clustering_0, clustering1, clustering_2, clustering_3) > (1, 2, 3, 4)
+        Restriction slice = newMultiSlice(cfMetaData, 0, Bound.START, false, value1, value2, value3, value4);
         PrimaryKeyRestrictions restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
         restrictions = restrictions.mergeWith(slice);
 
         List<Composite> bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
-        assertEquals(1, bounds.size());
-        assertComposite(bounds.get(0), value1, value2, EOC.END);
+        assertEquals(4, bounds.size());
+        assertComposite(bounds.get(0), value1, EOC.START);
+        assertComposite(bounds.get(1), value1, value2, value3, EOC.START);
+        assertComposite(bounds.get(2), value1, value2, value3, EOC.END);
+        assertComposite(bounds.get(3), value1, EOC.END);
+
 
         bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
-        assertEquals(1, bounds.size());
-        assertEmptyComposite(bounds.get(0));
+        assertEquals(4, bounds.size());
+        assertComposite(bounds.get(0), value1, value2, EOC.START);
+        assertComposite(bounds.get(1), value1, value2, value3, value4, EOC.START);
+        assertComposite(bounds.get(2), value1, value2, EOC.END);
+        assertEmptyComposite(bounds.get(3));
+
+        // clustering_0 = 1 AND (clustering_1, clustering_2, clustering_3) > (2, 3, 4)
+        Restriction eq = newSingleEq(cfMetaData, 0, value1);
+        slice = newMultiSlice(cfMetaData, 1, Bound.START, false, value2, value3, value4);
+        restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
+        restrictions = restrictions.mergeWith(slice);
+        restrictions = restrictions.mergeWith(eq);
+
+        bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
+        assertEquals(3, bounds.size());
+        assertComposite(bounds.get(0), value1, EOC.START);
+        assertComposite(bounds.get(1), value1, value2, value3, EOC.START);
+        assertComposite(bounds.get(2), value1, value2, value3, EOC.END);
+
+        bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
+        assertEquals(3, bounds.size());
+        assertComposite(bounds.get(0), value1, value2, EOC.START);
+        assertComposite(bounds.get(1), value1, value2, value3, value4, EOC.START);
+        assertComposite(bounds.get(2), value1, value2, EOC.END);
 
         // (clustering_0, clustering1) >= (1, 2)
         slice = newMultiSlice(cfMetaData, 0, Bound.START, true, value1, value2);
@@ -505,75 +1281,129 @@ public class PrimaryKeyRestrictionSetTest
         restrictions = restrictions.mergeWith(slice);
 
         bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
-        assertEquals(1, bounds.size());
-        assertComposite(bounds.get(0), value1, value2, EOC.NONE);
+        assertEquals(2, bounds.size());
+        assertComposite(bounds.get(0), value1, EOC.START);
+        assertComposite(bounds.get(1), value1, EOC.END);
 
         bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
-        assertEquals(1, bounds.size());
-        assertEmptyComposite(bounds.get(0));
+        assertEquals(2, bounds.size());
+        assertComposite(bounds.get(0), value1, value2, EOC.END);
+        assertEmptyComposite(bounds.get(1));
 
-        // (clustering_0, clustering1) <= (1, 2)
-        slice = newMultiSlice(cfMetaData, 0, Bound.END, true, value1, value2);
+        // (clustering_0, clustering1, clustering_2, clustering_3) >= (1, 2, 3, 4)
+        slice = newMultiSlice(cfMetaData, 0, Bound.START, true, value1, value2, value3, value4);
         restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
         restrictions = restrictions.mergeWith(slice);
 
         bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
-        assertEquals(1, bounds.size());
+        assertEquals(4, bounds.size());
+        assertComposite(bounds.get(0), value1, EOC.START);
+        assertComposite(bounds.get(1), value1, value2, value3, EOC.START);
+        assertComposite(bounds.get(2), value1, value2, value3, EOC.END);
+        assertComposite(bounds.get(3), value1, EOC.END);
+
+        bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
+        assertEquals(4, bounds.size());
+        assertComposite(bounds.get(0), value1, value2, EOC.START);
+        assertComposite(bounds.get(1), value1, value2, value3, value4, EOC.END);
+        assertComposite(bounds.get(2), value1, value2, EOC.END);
+        assertEmptyComposite(bounds.get(3));
+
+
+        // (clustering_0, clustering1, clustering_2, clustering_3) <= (1, 2, 3, 4)
+        slice = newMultiSlice(cfMetaData, 0, Bound.END, true, value1, value2, value3, value4);
+        restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
+        restrictions = restrictions.mergeWith(slice);
+
+        bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
+        assertEquals(4, bounds.size());
         assertEmptyComposite(bounds.get(0));
+        assertComposite(bounds.get(1), value1, value2, EOC.START);
+        assertComposite(bounds.get(2), value1, value2, value3, value4, EOC.NONE);
+        assertComposite(bounds.get(3), value1, value2, EOC.END);
 
         bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
-        assertEquals(1, bounds.size());
-        assertComposite(bounds.get(0), value1, value2, EOC.END);
+        assertEquals(4, bounds.size());
+        assertComposite(bounds.get(0), value1, EOC.START);
+        assertComposite(bounds.get(1), value1, value2, value3, EOC.START);
+        assertComposite(bounds.get(2), value1, value2, value3, EOC.END);
+        assertComposite(bounds.get(3), value1, EOC.END);
 
-        // (clustering_0, clustering1) < (1, 2)
-        slice = newMultiSlice(cfMetaData, 0, Bound.END, false, value1, value2);
+        // (clustering_0, clustering1, clustering_2, clustering_3) < (1, 2, 3, 4)
+        slice = newMultiSlice(cfMetaData, 0, Bound.END, false, value1, value2, value3, value4);
         restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
         restrictions = restrictions.mergeWith(slice);
 
         bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
-        assertEquals(1, bounds.size());
+        assertEquals(4, bounds.size());
         assertEmptyComposite(bounds.get(0));
+        assertComposite(bounds.get(1), value1, value2, EOC.START);
+        assertComposite(bounds.get(2), value1, value2, value3, value4, EOC.END);
+        assertComposite(bounds.get(3), value1, value2, EOC.END);
 
         bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
-        assertEquals(1, bounds.size());
-        assertComposite(bounds.get(0), value1, value2, EOC.START);
+        assertEquals(4, bounds.size());
+        assertComposite(bounds.get(0), value1, EOC.START);
+        assertComposite(bounds.get(1), value1, value2, value3, EOC.START);
+        assertComposite(bounds.get(2), value1, value2, value3, EOC.END);
+        assertComposite(bounds.get(3), value1, EOC.END);
 
-        // (clustering_0, clustering1) > (1, 2) AND (clustering_0) < (2)
-        slice = newMultiSlice(cfMetaData, 0, Bound.START, false, value1, value2);
-        Restriction slice2 = newMultiSlice(cfMetaData, 0, Bound.END, false, value2);
+        // (clustering_0, clustering1, clustering_2, clustering_3) > (1, 2, 3, 4) AND (clustering_0, clustering_1) < (2, 3)
+        slice = newMultiSlice(cfMetaData, 0, Bound.START, false, value1, value2, value3, value4);
+        Restriction slice2 = newMultiSlice(cfMetaData, 0, Bound.END, false, value2, value3);
         restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
         restrictions = restrictions.mergeWith(slice).mergeWith(slice2);
 
         bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
-        assertEquals(1, bounds.size());
-        assertComposite(bounds.get(0), value1, value2, EOC.END);
+        assertEquals(5, bounds.size());
+        assertComposite(bounds.get(0), value1, EOC.START);
+        assertComposite(bounds.get(1), value1, value2, value3, EOC.START);
+        assertComposite(bounds.get(2), value1, value2, value3, EOC.END);
+        assertComposite(bounds.get(3), value1, EOC.END);
+        assertComposite(bounds.get(4), value2, value3, EOC.END);
 
         bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
-        assertEquals(1, bounds.size());
-        assertComposite(bounds.get(0), value2, EOC.START);
-
-        // (clustering_0, clustering1) >= (1, 2) AND (clustering_0, clustering1) <= (2, 1)
-        slice = newMultiSlice(cfMetaData, 0, Bound.START, true, value1, value2);
-        slice2 = newMultiSlice(cfMetaData, 0, Bound.END, true, value2, value1);
+        assertEquals(5, bounds.size());
+        assertComposite(bounds.get(0), value1, value2, EOC.START);
+        assertComposite(bounds.get(1), value1, value2, value3, value4, EOC.START);
+        assertComposite(bounds.get(2), value1, value2, EOC.END);
+        assertComposite(bounds.get(3), value2, EOC.START);
+        assertComposite(bounds.get(4), value2, EOC.END);
+
+        // (clustering_0, clustering1, clustering_2, clustering_3) >= (1, 2, 3, 4) AND (clustering_0, clustering1, clustering_2, clustering_3) <= (4, 3, 2, 1)
+        slice = newMultiSlice(cfMetaData, 0, Bound.START, true, value1, value2, value3, value4);
+        slice2 = newMultiSlice(cfMetaData, 0, Bound.END, true, value4, value3, value2, value1);
         restrictions = new PrimaryKeyRestrictionSet(cfMetaData.comparator);
         restrictions = restrictions.mergeWith(slice).mergeWith(slice2);
 
         bounds = restrictions.boundsAsComposites(Bound.START, QueryOptions.DEFAULT);
-        assertEquals(1, bounds.size());
-        assertComposite(bounds.get(0), value1, value2, EOC.NONE);
+        assertEquals(7, bounds.size());
+        assertComposite(bounds.get(0), value1, EOC.START);
+        assertComposite(bounds.get(1), value1, value2, value3, EOC.START);
+        assertComposite(bounds.get(2), value1, value2, value3, EOC.END);
+        assertComposite(bounds.get(3), value1, EOC.END);
+        assertComposite(bounds.get(4), value4, value3, EOC.START);
+        assertComposite(bounds.get(5), value4, value3, value2, value1, EOC.NONE);
+        assertComposite(bounds.get(6), value4, value3, EOC.END);
 
         bounds = restrictions.boundsAsComposites(Bound.END, QueryOptions.DEFAULT);
-        assertEquals(1, bounds.size());
-        assertComposite(bounds.get(0), value2, value1, EOC.END);
+        assertEquals(7, bounds.size());
+        assertComposite(bounds.get(0), value1, value2, EOC.START);
+        assertComposite(bounds.get(1), value1, value2, value3, value4, EOC.END);
+        assertComposite(bounds.get(2), value1, value2, EOC.END);
+        assertComposite(bounds.get(3), value4, EOC.START);
+        assertComposite(bounds.get(4), value4, value3, value2, EOC.START);
+        assertComposite(bounds.get(5), value4, value3, value2, EOC.END);
+        assertComposite(bounds.get(6), value4, EOC.END);
     }
 
     /**
      * Test mixing single and multi equals restrictions (e.g. clustering_0 = 1 AND (clustering_1, clustering_2) = (2, 3))
      */
     @Test
-    public void testBoundsAsCompositesWithSingleEqAndMultiEqRestrictions() throws InvalidRequestException
+    public void testBoundsAsCompositesWithSingleEqAndMultiEqRestrictions()
     {
-        CFMetaData cfMetaData = newCFMetaData(4);
+        CFMetaData cfMetaData = newCFMetaData(Sort.ASC, Sort.ASC, Sort.ASC, Sort.ASC);
 
         ByteBuffer value1 = ByteBufferUtil.bytes(1);
         ByteBuffer value2 = ByteBufferUtil.bytes(2);
@@ -643,9 +1473,9 @@ public class PrimaryKeyRestrictionSetTest
      * Test clustering_0 = 1 AND (clustering_1, clustering_2) IN ((2, 3), (4, 5))
      */
     @Test
-    public void testBoundsAsCompositesWithSingleEqAndMultiINRestrictions() throws InvalidRequestException
+    public void testBoundsAsCompositesWithSingleEqAndMultiINRestrictions()
     {
-        CFMetaData cfMetaData = newCFMetaData(4);
+        CFMetaData cfMetaData = newCFMetaData(Sort.ASC, Sort.ASC, Sort.ASC, Sort.ASC);
 
         ByteBuffer value1 = ByteBufferUtil.bytes(1);
         ByteBuffer value2 = ByteBufferUtil.bytes(2);
@@ -706,9 +1536,9 @@ public class PrimaryKeyRestrictionSetTest
      * (e.g. clustering_0 = 1 AND (clustering_1, clustering_2) > (2, 3))
      */
     @Test
-    public void testBoundsAsCompositesWithSingleEqAndSliceRestrictions() throws InvalidRequestException
+    public void testBoundsAsCompositesWithSingleEqAndSliceRestrictions()
     {
-        CFMetaData cfMetaData = newCFMetaData(3);
+        CFMetaData cfMetaData = newCFMetaData(Sort.ASC, Sort.ASC, Sort.ASC);
 
         ByteBuffer value1 = ByteBufferUtil.bytes(1);
         ByteBuffer value2 = ByteBufferUtil.bytes(2);
@@ -766,9 +1596,9 @@ public class PrimaryKeyRestrictionSetTest
      * (e.g. clustering_0 = 1 AND (clustering_1, clustering_2) > (2, 3))
      */
     @Test
-    public void testBoundsAsCompositesWithMultiEqAndSingleSliceRestrictions() throws InvalidRequestException
+    public void testBoundsAsCompositesWithMultiEqAndSingleSliceRestrictions()
     {
-        CFMetaData cfMetaData = newCFMetaData(3);
+        CFMetaData cfMetaData = newCFMetaData(Sort.ASC, Sort.ASC, Sort.ASC);
 
         ByteBuffer value1 = ByteBufferUtil.bytes(1);
         ByteBuffer value2 = ByteBufferUtil.bytes(2);
@@ -790,9 +1620,9 @@ public class PrimaryKeyRestrictionSetTest
     }
 
     @Test
-    public void testBoundsAsCompositesWithSeveralMultiColumnRestrictions() throws InvalidRequestException
+    public void testBoundsAsCompositesWithSeveralMultiColumnRestrictions()
     {
-        CFMetaData cfMetaData = newCFMetaData(4);
+        CFMetaData cfMetaData = newCFMetaData(Sort.ASC, Sort.ASC, Sort.ASC, Sort.ASC);
 
         ByteBuffer value1 = ByteBufferUtil.bytes(1);
         ByteBuffer value2 = ByteBufferUtil.bytes(2);
@@ -852,7 +1682,7 @@ public class PrimaryKeyRestrictionSetTest
      */
     private static void assertEmptyComposite(Composite composite)
     {
-        assertEquals(Composites.EMPTY, composite);
+        assertTrue(composite.isEmpty());
     }
 
     /**
@@ -947,20 +1777,20 @@ public class PrimaryKeyRestrictionSetTest
      * @param numberOfClusteringColumns the number of clustering column
      * @return a new <code>CFMetaData</code> instance
      */
-    private static CFMetaData newCFMetaData(int numberOfClusteringColumns)
+    private static CFMetaData newCFMetaData(Sort... sorts)
     {
         List<AbstractType<?>> types = new ArrayList<>();
 
-        for (int i = 0; i < numberOfClusteringColumns; i++)
-            types.add(Int32Type.instance);
+        for (Sort sort : sorts)
+            types.add(sort == Sort.ASC ? Int32Type.instance : ReversedType.getInstance(Int32Type.instance));
 
         CompoundSparseCellNameType cType = new CompoundSparseCellNameType(types);
         CFMetaData cfMetaData = new CFMetaData("keyspace", "test", ColumnFamilyType.Standard, cType);
 
-        for (int i = 0; i < numberOfClusteringColumns; i++)
+        for (int i = 0; i < sorts.length; i++)
         {
             ByteBuffer name = ByteBufferUtil.bytes("clustering_" + i);
-            ColumnDefinition columnDef = ColumnDefinition.clusteringKeyDef(cfMetaData, name, Int32Type.instance, i);
+            ColumnDefinition columnDef = ColumnDefinition.clusteringKeyDef(cfMetaData, name, types.get(i), i);
             cfMetaData.addColumnDefinition(columnDef);
         }
         cfMetaData.rebuild();
@@ -1117,4 +1947,10 @@ public class PrimaryKeyRestrictionSetTest
             terms.add(toTerm(value));
         return terms;
     }
+
+    private static enum Sort
+    {
+        ASC,
+        DESC;
+    }
 }
diff --git a/test/unit/org/apache/cassandra/cql3/validation/operations/SelectMultiColumnRelationTest.java b/test/unit/org/apache/cassandra/cql3/validation/operations/SelectMultiColumnRelationTest.java
index b3232d58d3..b8a1d508ad 100644
--- a/test/unit/org/apache/cassandra/cql3/validation/operations/SelectMultiColumnRelationTest.java
+++ b/test/unit/org/apache/cassandra/cql3/validation/operations/SelectMultiColumnRelationTest.java
@@ -792,8 +792,10 @@ public class SelectMultiColumnRelationTest extends CQLTester
                     row(0, 0, 1, 0)
             );
 
-            // preserve pre-6875 behavior (even though the query result is technically incorrect)
-            assertEmpty(execute("SELECT * FROM %s WHERE a = ? AND (b, c) > (?, ?)", 0, 1, 0));
+            assertRows(execute("SELECT * FROM %s WHERE a = ? AND (b, c) > (?, ?)", 0, 1, 0),
+                    row(0,1, 1, 1),
+                    row(0, 1, 1, 0)
+                    );
         }
     }
 
@@ -990,6 +992,859 @@ public class SelectMultiColumnRelationTest extends CQLTester
                              "SELECT * from %s WHERE (i, j) IN ? ALLOW FILTERING", unset());
     }
 
+    @Test
+    public void testMixedOrderColumns1() throws Throwable
+    {
+        createTable("CREATE TABLE %s (a int, b int, c int, d int, e int, PRIMARY KEY (a, b, c, d, e)) " +
+                "WITH CLUSTERING ORDER BY (b DESC, c ASC, d DESC, e ASC)");
+
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 2, 0, -1, 0);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 2, 0, -1, 1);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 2, 0, 1, 1);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 1, -1, 0, 0);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 1, -1, 1, 1);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 1, -1, 1, 0);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 1, 0, 1, -1);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 1, 0, 1, 1);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 1, 0, 0, -1);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 1, 0, 0, 0);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 1, 0, 0, 1);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 1, 0, -1, -1);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 1, 1, 0, -1);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 1, 1, 0, 0);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 1, 1, 0, -1);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 1, 1, 0, 0);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 1, 1, 0, 1);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 1, 1, -1, 0);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 0, 0, 0, 0);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, -1, 0, -1, 0);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, -1, 0, 0, 0);
+        assertRows(execute(
+                        "SELECT * FROM %s" +
+                                " WHERE a = ? " +
+                                "AND (b,c,d,e)<=(?,?,?,?) " +
+                                "AND (b)>(?)", 0, 2, 0, 1, 1, -1),
+
+                row( 0, 2, 0, 1, 1),
+                row( 0, 2, 0, -1, 0),
+                row( 0, 2, 0, -1, 1),
+                row( 0, 1, -1, 1, 0),
+                row( 0, 1, -1, 1, 1),
+                row( 0, 1, -1, 0, 0),
+                row( 0, 1, 0, 1, -1),
+                row( 0, 1, 0, 1, 1),
+                row( 0, 1, 0, 0, -1),
+                row( 0, 1, 0, 0, 0),
+                row( 0, 1, 0, 0, 1),
+                row( 0, 1, 0, -1, -1),
+                row( 0, 1, 1, 0, -1),
+                row( 0, 1, 1, 0, 0),
+                row( 0, 1, 1, 0, 1),
+                row( 0, 1, 1, -1, 0),
+                row( 0, 0, 0, 0, 0)
+        );
+
+
+
+        assertRows(execute(
+                        "SELECT * FROM %s" +
+                                " WHERE a = ? " +
+                                "AND (b,c,d,e)<=(?,?,?,?) " +
+                                "AND (b)>=(?)", 0, 2, 0, 1, 1, -1),
+
+                row( 0, 2, 0, 1, 1),
+                row( 0, 2, 0, -1, 0),
+                row( 0, 2, 0, -1, 1),
+                row( 0, 1, -1, 1, 0),
+                row( 0, 1, -1, 1, 1),
+                row( 0, 1, -1, 0, 0),
+                row( 0, 1, 0, 1, -1),
+                row( 0, 1, 0, 1, 1),
+                row( 0, 1, 0, 0, -1),
+                row( 0, 1, 0, 0, 0),
+                row( 0, 1, 0, 0, 1),
+                row( 0, 1, 0, -1, -1),
+                row( 0, 1, 1, 0, -1),
+                row( 0, 1, 1, 0, 0),
+                row( 0, 1, 1, 0, 1),
+                row( 0, 1, 1, -1, 0),
+                row( 0, 0, 0, 0, 0),
+                row( 0, -1, 0, 0, 0),
+                row( 0, -1, 0, -1, 0)
+        );
+
+        assertRows(execute(
+                        "SELECT * FROM %s" +
+                                " WHERE a = ? " +
+                                "AND (b,c,d)>=(?,?,?)"+
+                                "AND (b,c,d,e)<(?,?,?,?) ", 0, 1, 1,0,1,  1, 0,1),
+                row( 0, 1, 1, 0, -1),
+                row( 0, 1, 1, 0, 0)
+
+        );
+
+        assertRows(execute(
+                        "SELECT * FROM %s" +
+                                " WHERE a = ? " +
+                                "AND (b,c,d,e)>(?,?,?,?)"+
+                                "AND (b,c,d)<=(?,?,?) ", 0, -1, 0,-1,-1,  2, 0,-1),
+
+                row( 0, 2, 0, -1, 0),
+                row( 0, 2, 0, -1, 1),
+                row( 0, 1, -1, 1, 0),
+                row( 0, 1, -1, 1, 1),
+                row( 0, 1, -1, 0, 0),
+                row( 0, 1, 0, 1, -1),
+                row( 0, 1, 0, 1, 1),
+                row( 0, 1, 0, 0, -1),
+                row( 0, 1, 0, 0, 0),
+                row( 0, 1, 0, 0, 1),
+                row( 0, 1, 0, -1, -1),
+                row( 0, 1, 1, 0, -1),
+                row( 0, 1, 1, 0, 0),
+                row( 0, 1, 1, 0, 1),
+                row( 0, 1, 1, -1, 0),
+                row( 0, 0, 0, 0, 0),
+                row( 0, -1, 0, 0, 0),
+                row( 0, -1, 0, -1, 0)
+        );
+
+        assertRows(execute(
+                        "SELECT * FROM %s" +
+                                " WHERE a = ? " +
+                                "AND (b,c,d,e) < (?,?,?,?) " +
+                                "AND (b,c,d,e)>(?,?,?,?)", 0, 1, 0, 0, 0, 1, 0,-1,-1),
+                row(0, 1, 0, 0, -1)
+        );
+
+        assertRows(execute(
+                        "SELECT * FROM %s" +
+                                " WHERE a = ? " +
+                                "AND (b,c,d,e) <= (?,?,?,?) " +
+                                "AND (b,c,d,e)>(?,?,?,?)", 0, 1, 0, 0, 0, 1, 0,-1,-1),
+                row(0, 1, 0, 0, -1),
+                row(0, 1, 0, 0, 0)
+        );
+
+        assertRows(execute(
+                        "SELECT * FROM %s" +
+                                " WHERE a = ? " +
+                                "AND (b)<(?) " +
+                                "AND (b,c,d,e)>(?,?,?,?)", 0, 2, -1, 0,-1,-1),
+
+                row( 0, 1, -1, 1, 0),
+                row( 0, 1, -1, 1, 1),
+                row( 0, 1, -1, 0, 0),
+                row( 0, 1, 0, 1, -1),
+                row( 0, 1, 0, 1, 1),
+                row( 0, 1, 0, 0, -1),
+                row( 0, 1, 0, 0, 0),
+                row( 0, 1, 0, 0, 1),
+                row( 0, 1, 0, -1, -1),
+                row( 0, 1, 1, 0, -1),
+                row( 0, 1, 1, 0, 0),
+                row( 0, 1, 1, 0, 1),
+                row( 0, 1, 1, -1, 0),
+                row( 0, 0, 0, 0, 0),
+                row( 0, -1, 0, 0, 0),
+                row( 0, -1, 0, -1, 0)
+
+        );
+
+
+
+        assertRows(execute(
+                        "SELECT * FROM %s" +
+                                " WHERE a = ? " +
+                                "AND (b)<(?) " +
+                                "AND (b)>(?)", 0, 2, -1),
+
+                row( 0, 1, -1, 1, 0),
+                row( 0, 1, -1, 1, 1),
+                row( 0, 1, -1, 0, 0),
+                row( 0, 1, 0, 1, -1),
+                row( 0, 1, 0, 1, 1),
+                row( 0, 1, 0, 0, -1),
+                row( 0, 1, 0, 0, 0),
+                row( 0, 1, 0, 0, 1),
+                row( 0, 1, 0, -1, -1),
+                row( 0, 1, 1, 0, -1),
+                row( 0, 1, 1, 0, 0),
+                row( 0, 1, 1, 0, 1),
+                row( 0, 1, 1, -1, 0),
+                row( 0, 0, 0, 0, 0)
+
+        );
+
+        assertRows(execute(
+                        "SELECT * FROM %s" +
+                                " WHERE a = ? " +
+                                "AND (b)<(?) " +
+                                "AND (b)>=(?)", 0, 2, -1),
+
+                row( 0, 1, -1, 1, 0),
+                row( 0, 1, -1, 1, 1),
+                row( 0, 1, -1, 0, 0),
+                row( 0, 1, 0, 1, -1),
+                row( 0, 1, 0, 1, 1),
+                row( 0, 1, 0, 0, -1),
+                row( 0, 1, 0, 0, 0),
+                row( 0, 1, 0, 0, 1),
+                row( 0, 1, 0, -1, -1),
+                row( 0, 1, 1, 0, -1),
+                row( 0, 1, 1, 0, 0),
+                row( 0, 1, 1, 0, 1),
+                row( 0, 1, 1, -1, 0),
+                row( 0, 0, 0, 0, 0),
+                row( 0, -1, 0, 0, 0),
+                row( 0, -1, 0, -1, 0)
+        );
+
+        assertRows(execute(
+                        "SELECT * FROM %s" +
+                                " WHERE a = ? " +
+                                "AND (b,c,d,e)<=(?,?,?,?) " +
+                                "AND (b,c,d,e)>(?,?,?,?)", 0, 2, 0, 1, 1, -1, 0,-1,-1),
+
+                row( 0, 2, 0, 1, 1),
+                row( 0, 2, 0, -1, 0),
+                row( 0, 2, 0, -1, 1),
+                row( 0, 1, -1, 1, 0),
+                row( 0, 1, -1, 1, 1),
+                row( 0, 1, -1, 0, 0),
+                row( 0, 1, 0, 1, -1),
+                row( 0, 1, 0, 1, 1),
+                row( 0, 1, 0, 0, -1),
+                row( 0, 1, 0, 0, 0),
+                row( 0, 1, 0, 0, 1),
+                row( 0, 1, 0, -1, -1),
+                row( 0, 1, 1, 0, -1),
+                row( 0, 1, 1, 0, 0),
+                row( 0, 1, 1, 0, 1),
+                row( 0, 1, 1, -1, 0),
+                row( 0, 0, 0, 0, 0),
+                row( 0, -1, 0, 0, 0),
+                row( 0, -1, 0, -1, 0)
+        );
+
+        assertRows(execute(
+                        "SELECT * FROM %s" +
+                                " WHERE a = ? " +
+                                "AND (b,c)<=(?,?) " +
+                                "AND (b,c,d,e)>(?,?,?,?)", 0, 2, 0, -1, 0,-1,-1),
+
+                row( 0, 2, 0, 1, 1),
+                row( 0, 2, 0, -1, 0),
+                row( 0, 2, 0, -1, 1),
+                row( 0, 1, -1, 1, 0),
+                row( 0, 1, -1, 1, 1),
+                row( 0, 1, -1, 0, 0),
+                row( 0, 1, 0, 1, -1),
+                row( 0, 1, 0, 1, 1),
+                row( 0, 1, 0, 0, -1),
+                row( 0, 1, 0, 0, 0),
+                row( 0, 1, 0, 0, 1),
+                row( 0, 1, 0, -1, -1),
+                row( 0, 1, 1, 0, -1),
+                row( 0, 1, 1, 0, 0),
+                row( 0, 1, 1, 0, 1),
+                row( 0, 1, 1, -1, 0),
+                row( 0, 0, 0, 0, 0),
+                row( 0, -1, 0, 0, 0),
+                row( 0, -1, 0, -1, 0)
+        );
+
+        assertRows(execute(
+                        "SELECT * FROM %s" +
+                                " WHERE a = ? " +
+                                "AND (b,c,d)<=(?,?,?) " +
+                                "AND (b,c,d,e)>(?,?,?,?)", 0, 2, 0,-1, -1, 0,-1,-1),
+
+                row( 0, 2, 0, -1, 0),
+                row( 0, 2, 0, -1, 1),
+                row( 0, 1, -1, 1, 0),
+                row( 0, 1, -1, 1, 1),
+                row( 0, 1, -1, 0, 0),
+                row( 0, 1, 0, 1, -1),
+                row( 0, 1, 0, 1, 1),
+                row( 0, 1, 0, 0, -1),
+                row( 0, 1, 0, 0, 0),
+                row( 0, 1, 0, 0, 1),
+                row( 0, 1, 0, -1, -1),
+                row( 0, 1, 1, 0, -1),
+                row( 0, 1, 1, 0, 0),
+                row( 0, 1, 1, 0, 1),
+                row( 0, 1, 1, -1, 0),
+                row( 0, 0, 0, 0, 0),
+                row( 0, -1, 0, 0, 0),
+                row( 0, -1, 0, -1, 0)
+        );
+
+        assertRows(execute(
+                        "SELECT * FROM %s" +
+                                " WHERE a = ? " +
+                                "AND (b,c,d,e)>(?,?,?,?)"+
+                                "AND (b,c,d)<=(?,?,?) ", 0, -1, 0,-1,-1,  2, 0,-1),
+
+                row( 0, 2, 0, -1, 0),
+                row( 0, 2, 0, -1, 1),
+                row( 0, 1, -1, 1, 0),
+                row( 0, 1, -1, 1, 1),
+                row( 0, 1, -1, 0, 0),
+                row( 0, 1, 0, 1, -1),
+                row( 0, 1, 0, 1, 1),
+                row( 0, 1, 0, 0, -1),
+                row( 0, 1, 0, 0, 0),
+                row( 0, 1, 0, 0, 1),
+                row( 0, 1, 0, -1, -1),
+                row( 0, 1, 1, 0, -1),
+                row( 0, 1, 1, 0, 0),
+                row( 0, 1, 1, 0, 1),
+                row( 0, 1, 1, -1, 0),
+                row( 0, 0, 0, 0, 0),
+                row( 0, -1, 0, 0, 0),
+                row( 0, -1, 0, -1, 0)
+        );
+
+        assertRows(execute(
+                        "SELECT * FROM %s" +
+                                " WHERE a = ? " +
+                                "AND (b,c,d)>=(?,?,?)"+
+                                "AND (b,c,d,e)<(?,?,?,?) ", 0, 1, 1,0,1,  1, 0,1),
+                row( 0, 1, 1, 0, -1),
+                row( 0, 1, 1, 0, 0)
+        );
+        assertRows(execute(
+                        "SELECT * FROM %s" +
+                                " WHERE a = ? " +
+                                "AND (b,c,d,e)<(?,?,?,?) "+
+                                "AND (b,c,d)>=(?,?,?)", 0, 1, 1,0,1,1,  1, 0),
+                row( 0, 1, 1, 0, -1),
+                row( 0, 1, 1, 0, 0)
+
+        );
+
+        assertRows(execute(
+                        "SELECT * FROM %s" +
+                                " WHERE a = ? " +
+                                "AND (b,c)<(?,?) " +
+                                "AND (b,c,d,e)>(?,?,?,?)", 0, 2, 0, -1, 0,-1,-1),
+                row( 0, 1, -1, 1, 0),
+                row( 0, 1, -1, 1, 1),
+                row( 0, 1, -1, 0, 0),
+                row( 0, 1, 0, 1, -1),
+                row( 0, 1, 0, 1, 1),
+                row( 0, 1, 0, 0, -1),
+                row( 0, 1, 0, 0, 0),
+                row( 0, 1, 0, 0, 1),
+                row( 0, 1, 0, -1, -1),
+                row( 0, 1, 1, 0, -1),
+                row( 0, 1, 1, 0, 0),
+                row( 0, 1, 1, 0, 1),
+                row( 0, 1, 1, -1, 0),
+                row( 0, 0, 0, 0, 0),
+                row( 0, -1, 0, 0, 0),
+                row( 0, -1, 0, -1, 0)
+        );
+
+        assertRows(execute(
+                        "SELECT * FROM %s" +
+                                " WHERE a = ? " +
+                                "AND (b,c)<(?,?) " +
+                                "AND (b,c,d,e)>(?,?,?,?)", 0, 2, 0, -1, 0,-1,-1),
+                row( 0, 1, -1, 1, 0),
+                row( 0, 1, -1, 1, 1),
+                row( 0, 1, -1, 0, 0),
+                row( 0, 1, 0, 1, -1),
+                row( 0, 1, 0, 1, 1),
+                row( 0, 1, 0, 0, -1),
+                row( 0, 1, 0, 0, 0),
+                row( 0, 1, 0, 0, 1),
+                row( 0, 1, 0, -1, -1),
+                row( 0, 1, 1, 0, -1),
+                row( 0, 1, 1, 0, 0),
+                row( 0, 1, 1, 0, 1),
+                row( 0, 1, 1, -1, 0),
+                row( 0, 0, 0, 0, 0),
+                row( 0, -1, 0, 0, 0),
+                row( 0, -1, 0, -1, 0)
+        );
+
+        assertRows(execute("SELECT * FROM %s WHERE a = ? AND (b,c,d,e) <= (?,?,?,?)", 0, 1, 0, 0, 0),
+                row(0, 1, -1, 1, 0),
+                row(0, 1, -1, 1, 1),
+                row(0, 1, -1, 0, 0),
+                row(0, 1, 0, 0, -1),
+                row(0, 1, 0, 0, 0),
+                row(0, 1, 0, -1, -1),
+                row(0, 0, 0, 0, 0),
+                row(0, -1, 0, 0, 0),
+                row(0, -1, 0, -1, 0)
+        );
+
+        assertRows(execute("SELECT * FROM %s WHERE a = ? AND (b,c,d,e) > (?,?,?,?)", 0, 1, 0, 0, 0),
+                row(0, 2, 0, 1, 1),
+                row(0, 2, 0, -1, 0),
+                row(0, 2, 0, -1, 1),
+                row(0, 1, 0,  1, -1),
+                row(0, 1, 0,  1, 1),
+                row(0, 1, 0,  0, 1),
+                row(0, 1, 1,  0, -1),
+                row(0, 1, 1,  0, 0),
+                row(0, 1, 1,  0, 1),
+                row(0, 1, 1, -1, 0)
+        );
+
+        assertRows(execute("SELECT * FROM %s WHERE a = ? AND (b,c,d,e) >= (?,?,?,?)", 0, 1, 0, 0, 0),
+                row( 0, 2, 0, 1, 1),
+                row(0, 2, 0, -1, 0),
+                row(0, 2, 0, -1, 1),
+                row(0, 1, 0,  1, -1),
+                row(0, 1, 0,  1, 1),
+                row(0, 1, 0,  0, 0),
+                row(0, 1, 0,  0, 1),
+                row(0, 1, 1,  0, -1),
+                row(0, 1, 1,  0, 0),
+                row(0, 1, 1,  0, 1),
+                row(0, 1, 1, -1, 0)
+        );
+
+        assertRows(execute("SELECT * FROM %s WHERE a = ? AND (b,c,d) >= (?,?,?)", 0, 1, 0, 0),
+                row( 0, 2, 0, 1, 1),
+                row(0, 2, 0, -1, 0),
+                row(0, 2, 0, -1, 1),
+                row(0, 1, 0,  1, -1),
+                row(0, 1, 0,  1, 1),
+                row(0, 1, 0,  0, -1),
+                row(0, 1, 0,  0, 0),
+                row(0, 1, 0,  0, 1),
+                row(0, 1, 1,  0, -1),
+                row(0, 1, 1,  0, 0),
+                row(0, 1, 1,  0, 1),
+                row(0, 1, 1, -1, 0)
+        );
+
+        assertRows(execute("SELECT * FROM %s WHERE a = ? AND (b,c,d) > (?,?,?)", 0, 1, 0, 0),
+                row(0, 2, 0, 1, 1),
+                row(0, 2, 0, -1, 0),
+                row(0, 2, 0, -1, 1),
+                row(0, 1, 0,  1, -1),
+                row(0, 1, 0,  1, 1),
+                row(0, 1, 1,  0, -1),
+                row(0, 1, 1,  0, 0),
+                row(0, 1, 1,  0, 1),
+                row(0, 1, 1, -1, 0)
+        );
+
+    }
+
+    @Test
+    public void testMixedOrderColumns2() throws Throwable
+    {
+        createTable("CREATE TABLE %s (a int, b int, c int, d int, e int, PRIMARY KEY (a, b, c, d, e)) " +
+                "WITH CLUSTERING ORDER BY (b DESC, c ASC, d ASC, e ASC)");
+
+        // b and d are reversed in the clustering order
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 2, 0, -1, 0);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 2, 0, -1, 1);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 1, -1, 0, 0);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 1, -1, 1, 0);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 1, -1, 1, 1);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 1, 0, 1, -1);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 1, 0, 1, 1);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 1, 0, 0, -1);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 1, 0, 0, 0);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 1, 0, 0, 1);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 1, 0, -1, -1);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 1, 1, 0, -1);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 1, 1, 0, 0);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 1, 1, 0, -1);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 1, 1, 0, 0);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 1, 1, 0, 1);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 1, 1, -1, 0);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 0, 0, 0, 0);
+
+        assertRows(execute("SELECT * FROM %s WHERE a = ? AND (b,c,d,e) <= (?,?,?,?)", 0, 1, 0, 0, 0),
+                row(0, 1, -1, 0, 0),
+                row(0, 1, -1, 1, 0),
+                row(0, 1, -1, 1, 1),
+                row(0, 1, 0, -1, -1),
+                row(0, 1, 0, 0, -1),
+                row(0, 1, 0, 0, 0),
+                row(0, 0, 0, 0, 0)
+        );
+
+        assertRows(execute("SELECT * FROM %s WHERE a = ? AND (b,c,d,e) > (?,?,?,?)", 0, 1, 0, 0, 0),
+                row(0, 2, 0, -1, 0),
+                row(0, 2, 0, -1, 1),
+                row(0, 1, 0,  0, 1),
+                row(0, 1, 0,  1, -1),
+                row(0, 1, 0,  1, 1),
+                row(0, 1, 1, -1, 0),
+                row(0, 1, 1,  0, -1),
+                row(0, 1, 1,  0, 0),
+                row(0, 1, 1,  0, 1)
+        );
+        assertRows(execute("SELECT * FROM %s WHERE a = ? AND (b,c,d,e) >= (?,?,?,?)", 0, 1, 0, 0, 0),
+                row(0, 2, 0, -1, 0),
+                row(0, 2, 0, -1, 1),
+                row(0, 1, 0,  0, 0),
+                row(0, 1, 0,  0, 1),
+                row(0, 1, 0,  1, -1),
+                row(0, 1, 0,  1, 1),
+                row(0, 1, 1, -1, 0),
+                row(0, 1, 1,  0, -1),
+                row(0, 1, 1,  0, 0),
+                row(0, 1, 1,  0, 1)
+        );
+    }
+
+    @Test
+    public void testMixedOrderColumns3() throws Throwable
+    {
+        createTable("create table %s (a int, b int, c int, PRIMARY KEY (a, b, c)) WITH CLUSTERING ORDER BY (b DESC, c ASC)");
+
+        execute("INSERT INTO %s (a, b, c) VALUES (?,?,?);", 0, 2, 3);
+        execute("INSERT INTO %s (a, b, c) VALUES (?,?,?);", 0, 2, 4);
+        execute("INSERT INTO %s (a, b, c) VALUES (?,?,?);", 0, 4, 4);
+        execute("INSERT INTO %s (a, b, c) VALUES (?,?,?);", 0, 3, 4);
+        execute("INSERT INTO %s (a, b, c) VALUES (?,?,?);", 0, 4, 5);
+        execute("INSERT INTO %s (a, b, c) VALUES (?,?,?);", 0, 4, 6);
+
+
+        assertRows(execute("SELECT * FROM %s WHERE a = ? AND (b,c)>=(?,?) AND (b,c)<(?,?) ALLOW FILTERING", 0, 2, 3, 4, 5),
+                row(0, 4, 4), row(0, 3, 4), row(0, 2, 3), row(0, 2, 4)
+        );
+        assertRows(execute("SELECT * FROM %s WHERE a = ? AND (b,c)>=(?,?) AND (b,c)<=(?,?) ALLOW FILTERING", 0, 2, 3, 4, 5),
+                row(0, 4, 4), row(0, 4, 5), row(0, 3, 4), row(0, 2, 3), row(0, 2, 4)
+        );
+        assertRows(execute("SELECT * FROM %s WHERE a = ? AND (b,c)<(?,?) ALLOW FILTERING", 0, 4, 5),
+                row(0, 4, 4),row(0, 3, 4),row(0, 2, 3),row(0, 2, 4)
+        );
+
+        assertRows(execute("SELECT * FROM %s WHERE a = ? AND (b,c)>(?,?) ALLOW FILTERING", 0, 4, 5),
+                row(0, 4, 6)
+        );
+
+        assertRows(execute("SELECT * FROM %s WHERE a = ? AND (b)<(?) and (b)>(?) ALLOW FILTERING", 0, 4, 2),
+                row(0, 3, 4)
+        );
+    }
+
+    @Test
+    public void testMixedOrderColumns4() throws Throwable
+    {
+        createTable("CREATE TABLE %s (a int, b int, c int, d int, e int, PRIMARY KEY (a, b, c, d, e)) " +
+                "WITH CLUSTERING ORDER BY (b ASC, c DESC, d DESC, e ASC)");
+
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 2, 0, -1, 0);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 2, 0, -1, 1);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 2, 0, 1, 1);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 2, -1, 1, 1);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 2, -3, 1, 1);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 1, -1, 0, 0);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 1, -1, 1, 1);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 1, -1, 1, 0);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 1, 0, 1, -1);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 1, 0, 1, 1);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 1, 0, 0, -1);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 1, 0, 0, 0);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 1, 0, 0, 1);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 1, 0, -1, -1);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 1, 1, 0, -1);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 1, 1, 0, 0);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 1, 1, 0, -1);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 1, 1, 0, 0);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 1, 1, 0, 1);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 1, 1, -1, 0);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, 0, 0, 0, 0);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, -1, 0, -1, 0);
+        execute("INSERT INTO %s (a, b, c, d, e) VALUES (?, ?, ?, ?, ?)", 0, -1, 0, 0, 0);
+
+        assertRows(execute(
+                        "SELECT * FROM %s" +
+                                " WHERE a = ? " +
+                                "AND (b,c,d,e)<(?,?,?,?) " +
+                                "AND (b,c,d,e)>(?,?,?,?)", 0, 2, 0, 1, 1, -1, 0, -1, -1),
+
+                row(0, -1, 0, 0, 0),
+                row(0, -1, 0, -1, 0),
+                row(0, 0, 0, 0, 0),
+                row(0, 1, 1, 0, -1),
+                row(0, 1, 1, 0, 0),
+                row(0, 1, 1, 0, 1),
+                row(0, 1, 1, -1, 0),
+                row(0, 1, 0, 1, -1),
+                row(0, 1, 0, 1, 1),
+                row(0, 1, 0, 0, -1),
+                row(0, 1, 0, 0, 0),
+                row(0, 1, 0, 0, 1),
+                row(0, 1, 0, -1, -1),
+                row(0, 1, -1, 1, 0),
+                row(0, 1, -1, 1, 1),
+                row(0, 1, -1, 0, 0),
+                row(0, 2, 0, -1, 0),
+                row(0, 2, 0, -1, 1),
+                row(0, 2, -1, 1, 1),
+                row(0, 2, -3, 1, 1)
+
+        );
+
+
+        assertRows(execute(
+                        "SELECT * FROM %s" +
+                                " WHERE a = ? " +
+                                "AND (b,c,d,e) < (?,?,?,?) " +
+                                "AND (b,c,d,e)>(?,?,?,?)", 0, 1, 0, 0, 0, 1, 0, -1, -1),
+                row(0, 1, 0, 0, -1)
+        );
+
+        assertRows(execute(
+                        "SELECT * FROM %s" +
+                                " WHERE a = ? " +
+                                "AND (b,c,d,e) <= (?,?,?,?) " +
+                                "AND (b,c,d,e)>(?,?,?,?)", 0, 1, 0, 0, 0, 1, 0,-1,-1),
+                row(0, 1, 0, 0, -1),
+                row(0, 1, 0, 0, 0)
+        );
+
+
+        assertRows(execute(
+                        "SELECT * FROM %s" +
+                                " WHERE a = ? " +
+                                "AND (b,c,d,e)<=(?,?,?,?) " +
+                                "AND (b,c,d,e)>(?,?,?,?)", 0, 2, 0, 1, 1, -1, 0,-1,-1),
+
+                row( 0, -1, 0, 0, 0),
+                row( 0, -1, 0, -1, 0),
+                row(0, 0, 0, 0, 0),
+                row( 0, 1, 1, 0, -1),
+                row( 0, 1, 1, 0, 0),
+                row( 0, 1, 1, 0, 1),
+                row( 0, 1, 1, -1, 0),
+                row( 0, 1, 0, 1, -1),
+                row( 0, 1, 0, 1, 1),
+                row( 0, 1, 0, 0, -1),
+                row( 0, 1, 0, 0, 0),
+                row( 0, 1, 0, 0, 1),
+                row( 0, 1, 0, -1, -1),
+                row( 0, 1, -1, 1, 0),
+                row( 0, 1, -1, 1, 1),
+                row( 0, 1, -1, 0, 0),
+                row( 0, 2, 0, 1, 1),
+                row( 0, 2, 0, -1, 0),
+                row( 0, 2, 0, -1, 1),
+                row(  0, 2, -1, 1, 1),
+                row(  0, 2, -3, 1, 1)
+        );
+
+        assertRows(execute(
+                        "SELECT * FROM %s" +
+                                " WHERE a = ? " +
+                                "AND (b,c)<=(?,?) " +
+                                "AND (b,c,d,e)>(?,?,?,?)", 0, 2, 0, -1, 0,-1,-1),
+
+                row( 0, -1, 0, 0, 0),
+                row(0, -1, 0, -1, 0),
+                row( 0, 0, 0, 0, 0),
+                row( 0, 1, 1, 0, -1),
+                row( 0, 1, 1, 0, 0),
+                row( 0, 1, 1, 0, 1),
+                row( 0, 1, 1, -1, 0),
+                row( 0, 1, 0, 1, -1),
+                row( 0, 1, 0, 1, 1),
+                row( 0, 1, 0, 0, -1),
+                row( 0, 1, 0, 0, 0),
+                row( 0, 1, 0, 0, 1),
+                row( 0, 1, 0, -1, -1),
+                row( 0, 1, -1, 1, 0),
+                row( 0, 1, -1, 1, 1),
+                row( 0, 1, -1, 0, 0),
+                row( 0, 2, 0, 1, 1),
+                row( 0, 2, 0, -1, 0),
+                row( 0, 2, 0, -1, 1),
+                row(  0, 2, -1, 1, 1),
+                row(  0, 2, -3, 1, 1)
+        );
+
+        assertRows(execute(
+                        "SELECT * FROM %s" +
+                                " WHERE a = ? " +
+                                "AND (b,c)<(?,?) " +
+                                "AND (b,c,d,e)>(?,?,?,?)", 0, 2, 0, -1, 0, -1, -1),
+                row( 0, -1, 0, 0, 0),
+                row( 0, -1, 0, -1, 0),
+                row( 0, 0, 0, 0, 0),
+                row( 0, 1, 1, 0, -1),
+                row( 0, 1, 1, 0, 0),
+                row( 0, 1, 1, 0, 1),
+                row( 0, 1, 1, -1, 0),
+                row( 0, 1, 0, 1, -1),
+                row( 0, 1, 0, 1, 1),
+                row( 0, 1, 0, 0, -1),
+                row( 0, 1, 0, 0, 0),
+                row( 0, 1, 0, 0, 1),
+                row( 0, 1, 0, -1, -1),
+                row( 0, 1, -1, 1, 0),
+                row( 0, 1, -1, 1, 1),
+                row( 0, 1, -1, 0, 0),
+                row(  0, 2, -1, 1, 1),
+                row(0, 2, -3, 1, 1)
+        );
+
+        assertRows(execute(
+                        "SELECT * FROM %s" +
+                                " WHERE a = ? " +
+                                "AND (b,c,d,e)<=(?,?,?,?) " +
+                                "AND (b)>=(?)", 0, 2, 0, 1, 1, -1),
+
+                row( 0, -1, 0, 0, 0),
+                row( 0, -1, 0, -1, 0),
+                row( 0, 0, 0, 0, 0),
+                row( 0, 1, 1, 0, -1),
+                row(0, 1, 1, 0, 0),
+                row( 0, 1, 1, 0, 1),
+                row( 0, 1, 1, -1, 0),
+                row( 0, 1, 0, 1, -1),
+                row( 0, 1, 0, 1, 1),
+                row( 0, 1, 0, 0, -1),
+                row( 0, 1, 0, 0, 0),
+                row( 0, 1, 0, 0, 1),
+                row( 0, 1, 0, -1, -1),
+                row( 0, 1, -1, 1, 0),
+                row( 0, 1, -1, 1, 1),
+                row( 0, 1, -1, 0, 0),
+                row( 0, 2, 0, 1, 1),
+                row( 0, 2, 0, -1, 0),
+                row( 0, 2, 0, -1, 1),
+                row(  0, 2, -1, 1, 1),
+                row(  0, 2, -3, 1, 1)
+        );
+
+        assertRows(execute(
+                        "SELECT * FROM %s" +
+                                " WHERE a = ? " +
+                                "AND (b,c,d,e)<=(?,?,?,?) " +
+                                "AND (b)>(?)", 0, 2, 0, 1, 1, -1),
+
+                row( 0, 0, 0, 0, 0),
+                row( 0, 1, 1, 0, -1),
+                row( 0, 1, 1, 0, 0),
+                row( 0, 1, 1, 0, 1),
+                row( 0, 1, 1, -1, 0),
+                row( 0, 1, 0, 1, -1),
+                row( 0, 1, 0, 1, 1),
+                row( 0, 1, 0, 0, -1),
+                row( 0, 1, 0, 0, 0),
+                row( 0, 1, 0, 0, 1),
+                row( 0, 1, 0, -1, -1),
+                row( 0, 1, -1, 1, 0),
+                row( 0, 1, -1, 1, 1),
+                row( 0, 1, -1, 0, 0),
+                row( 0, 2, 0, 1, 1),
+                row( 0, 2, 0, -1, 0),
+                row( 0, 2, 0, -1, 1),
+                row(  0, 2, -1, 1, 1),
+                row(  0, 2, -3, 1, 1)
+        );
+
+        assertRows(execute("SELECT * FROM %s WHERE a = ? AND (b,c,d,e) <= (?,?,?,?)", 0, 1, 0, 0, 0),
+                row(0, -1, 0, 0, 0),
+                row(0, -1, 0, -1, 0),
+                row(0, 0, 0, 0, 0),
+                row(0, 1, 0, 0, -1),
+                row(0, 1, 0, 0, 0),
+                row(0, 1, 0, -1, -1),
+                row(0, 1, -1, 1, 0),
+                row(0, 1, -1, 1, 1),
+                row(0, 1, -1, 0, 0)
+        );
+
+        assertRows(execute("SELECT * FROM %s WHERE a = ? AND (b,c,d,e) > (?,?,?,?)", 0, 1, 0, 0, 0),
+                row(0, 1, 1,  0, -1),
+                row(0, 1, 1,  0, 0),
+                row(0, 1, 1, 0, 1),
+                row(0, 1, 1, -1, 0),
+                row(0, 1, 0,  1, -1),
+                row(0, 1, 0,  1, 1),
+                row(0, 1, 0,  0, 1),
+                row(0, 2, 0, 1, 1),
+                row(0, 2, 0, -1, 0),
+                row(0, 2, 0, -1, 1),
+                row(  0, 2, -1, 1, 1),
+                row(  0, 2, -3, 1, 1)
+
+        );
+
+        assertRows(execute("SELECT * FROM %s WHERE a = ? AND (b,c,d,e) >= (?,?,?,?)", 0, 1, 0, 0, 0),
+                row(0, 1, 1,  0, -1),
+                row(0, 1, 1,  0, 0),
+                row(0, 1, 1, 0, 1),
+                row(0, 1, 1, -1, 0),
+                row(0, 1, 0,  1, -1),
+                row(0, 1, 0,  1, 1),
+                row(0, 1, 0,  0, 0),
+                row(0, 1, 0,  0, 1),
+                row(0, 2, 0, 1, 1),
+                row(0, 2, 0, -1, 0),
+                row(0, 2, 0, -1, 1),
+                row(  0, 2, -1, 1, 1),
+                row(  0, 2, -3, 1, 1)
+        );
+
+        assertRows(execute("SELECT * FROM %s WHERE a = ? AND (b,c,d) >= (?,?,?)", 0, 1, 0, 0),
+                row(0, 1, 1,  0, -1),
+                row(0, 1, 1,  0, 0),
+                row(0, 1, 1, 0, 1),
+                row(0, 1, 1, -1, 0),
+                row(0, 1, 0,  1, -1),
+                row(0, 1, 0,  1, 1),
+                row(0, 1, 0,  0, -1),
+                row(0, 1, 0,  0, 0),
+                row(0, 1, 0,  0, 1),
+                row(0, 2, 0, 1, 1),
+                row(0, 2, 0, -1, 0),
+                row(0, 2, 0, -1, 1),
+                row(  0, 2, -1, 1, 1),
+                row(  0, 2, -3, 1, 1)
+        );
+
+        assertRows(execute("SELECT * FROM %s WHERE a = ? AND (b,c,d) > (?,?,?)", 0, 1, 0, 0),
+                row(0, 1, 1,  0, -1),
+                row(0, 1, 1,  0, 0),
+                row(0, 1, 1,  0, 1),
+                row(0, 1, 1, -1, 0),
+                row(0, 1, 0,  1, -1),
+                row(0, 1, 0,  1, 1),
+                row(0, 2, 0, 1, 1),
+                row(0, 2, 0, -1, 0),
+                row(0, 2, 0, -1, 1),
+                row(  0, 2, -1, 1, 1),
+                row(  0, 2, -3, 1, 1)
+        );
+
+        assertRows(execute(
+                        "SELECT * FROM %s" +
+                                " WHERE a = ? " +
+                                "AND (b) < (?) ", 0, 0),
+                row(0, -1, 0, 0, 0), row(0, -1, 0, -1, 0)
+        );
+        assertRows(execute(
+                        "SELECT * FROM %s" +
+                                " WHERE a = ? " +
+                                "AND (b) <= (?) ", 0,-1),
+                row(0, -1, 0, 0, 0), row(0, -1, 0, -1, 0)
+        );
+        assertRows(execute(
+                        "SELECT * FROM %s" +
+                                " WHERE a = ? " +
+                                "AND (b,c,d,e) < (?,?,?,?) and (b,c,d,e) > (?,?,?,?) ", 0, 2, 0, 0, 0, 2, -2, 0, 0),
+                row(0, 2, 0, -1, 0),
+                row(0, 2, 0, -1, 1),
+                row(0, 2, -1, 1, 1)
+        );
+    }
+
     /**
      * Check select on tuple relations, see CASSANDRA-8613
      * migrated from cql_tests.py:TestCQL.simple_tuple_query_test()
