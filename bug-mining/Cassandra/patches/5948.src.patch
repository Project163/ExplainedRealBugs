diff --git a/CHANGES.txt b/CHANGES.txt
index 9043898b48..6a43be11a8 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 4.1
+ * Fix improper CDC commit log segments deletion in non-blocking mode (CASSANDRA-17233)
  * Add support for string concatenations through the + operator (CASSANDRA-17190)
  * Limit the maximum hints size per host (CASSANDRA-17142)
  * Add a virtual table for exposing batch metrics (CASSANDRA-17225)
diff --git a/src/java/org/apache/cassandra/db/commitlog/CommitLog.java b/src/java/org/apache/cassandra/db/commitlog/CommitLog.java
index c605234224..03f328dff6 100644
--- a/src/java/org/apache/cassandra/db/commitlog/CommitLog.java
+++ b/src/java/org/apache/cassandra/db/commitlog/CommitLog.java
@@ -505,7 +505,7 @@ public class CommitLog implements CommitLogMBean
         CommitLogSegment.resetReplayLimit();
         if (DatabaseDescriptor.isCDCEnabled() && deleteSegments)
             for (File f : new File(DatabaseDescriptor.getCDCLogLocation()).tryList())
-                FileUtils.deleteWithConfirm(f);
+                f.delete();
     }
 
     /**
diff --git a/src/java/org/apache/cassandra/db/commitlog/CommitLogDescriptor.java b/src/java/org/apache/cassandra/db/commitlog/CommitLogDescriptor.java
index 82207ee72e..ed2af1bd0d 100644
--- a/src/java/org/apache/cassandra/db/commitlog/CommitLogDescriptor.java
+++ b/src/java/org/apache/cassandra/db/commitlog/CommitLogDescriptor.java
@@ -191,15 +191,27 @@ public class CommitLogDescriptor
 
     public static CommitLogDescriptor fromFileName(String name)
     {
-        Matcher matcher;
-        if (!(matcher = COMMIT_LOG_FILE_PATTERN.matcher(name)).matches())
+        Matcher matcher = extactFromFileName(name);
+        long id = Long.parseLong(matcher.group(3).split(SEPARATOR)[1]);
+        return new CommitLogDescriptor(Integer.parseInt(matcher.group(2)), id, null, new EncryptionContext());
+    }
+
+    public static long idFromFileName(String name)
+    {
+        Matcher matcher = extactFromFileName(name);
+        return Long.parseLong(matcher.group(3).split(SEPARATOR)[1]);
+    }
+
+    private static Matcher extactFromFileName(String name)
+    {
+        Matcher matcher = COMMIT_LOG_FILE_PATTERN.matcher(name);
+        if (!matcher.matches())
             throw new RuntimeException("Cannot parse the version of the file: " + name);
 
         if (matcher.group(3) == null)
             throw new UnsupportedOperationException("Commitlog segment is too old to open; upgrade to 1.2.5+ first");
 
-        long id = Long.parseLong(matcher.group(3).split(SEPARATOR)[1]);
-        return new CommitLogDescriptor(Integer.parseInt(matcher.group(2)), id, null, new EncryptionContext());
+        return matcher;
     }
 
     public int getMessagingVersion()
diff --git a/src/java/org/apache/cassandra/db/commitlog/CommitLogSegment.java b/src/java/org/apache/cassandra/db/commitlog/CommitLogSegment.java
index 06218f8b85..89fe96b2ef 100644
--- a/src/java/org/apache/cassandra/db/commitlog/CommitLogSegment.java
+++ b/src/java/org/apache/cassandra/db/commitlog/CommitLogSegment.java
@@ -48,7 +48,6 @@ import org.apache.cassandra.utils.IntegerInterval;
 import org.apache.cassandra.utils.concurrent.OpOrder;
 import org.apache.cassandra.utils.concurrent.WaitQueue;
 
-import static com.codahale.metrics.Timer.*;
 import static org.apache.cassandra.utils.Clock.Global.currentTimeMillis;
 import static org.apache.cassandra.utils.FBUtilities.updateChecksumInt;
 import static org.apache.cassandra.utils.concurrent.WaitQueue.newWaitQueue;
@@ -678,9 +677,8 @@ public abstract class CommitLogSegment
     {
         public int compare(File f, File f2)
         {
-            CommitLogDescriptor desc = CommitLogDescriptor.fromFileName(f.name());
-            CommitLogDescriptor desc2 = CommitLogDescriptor.fromFileName(f2.name());
-            return Long.compare(desc.id, desc2.id);
+            return Long.compare(CommitLogDescriptor.idFromFileName(f.name()),
+                                CommitLogDescriptor.idFromFileName(f2.name()));
         }
     }
 
diff --git a/src/java/org/apache/cassandra/db/commitlog/CommitLogSegmentManagerCDC.java b/src/java/org/apache/cassandra/db/commitlog/CommitLogSegmentManagerCDC.java
index 71c6efa881..f00bbfc613 100644
--- a/src/java/org/apache/cassandra/db/commitlog/CommitLogSegmentManagerCDC.java
+++ b/src/java/org/apache/cassandra/db/commitlog/CommitLogSegmentManagerCDC.java
@@ -30,6 +30,8 @@ import java.util.stream.Collectors;
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Preconditions;
 import com.google.common.util.concurrent.RateLimiter;
+import com.google.common.util.concurrent.Uninterruptibles;
+
 import org.apache.cassandra.io.util.File;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -84,21 +86,49 @@ public class CommitLogSegmentManagerCDC extends AbstractCommitLogSegmentManager
 
     /**
      * Delete the oldest hard-linked CDC commit log segment to free up space.
-     * @return total deleted file size in bytes
+     * @param bytesToFree, the minimum space to free up
+     * @return total size under the CDC folder in bytes after deletion
      */
-    public long deleteOldestLinkedCDCCommitLogSegment()
+    public long deleteOldLinkedCDCCommitLogSegment(long bytesToFree)
     {
+        if (bytesToFree <= 0)
+            return 0;
+
         File cdcDir = new File(DatabaseDescriptor.getCDCLogLocation());
         Preconditions.checkState(cdcDir.isDirectory(), "The CDC directory does not exist.");
         File[] files = cdcDir.tryList(f -> CommitLogDescriptor.isValid(f.name()));
-        Preconditions.checkState(files != null && files.length > 0,
-                                 "There should be at least 1 CDC commit log segment.");
+        if (files == null || files.length == 0)
+        {
+            logger.warn("Skip deleting due to no CDC commit log segments found.");
+            return 0;
+        }
         List<File> sorted = Arrays.stream(files)
-                                  .sorted(Comparator.comparingLong(File::lastModified))
+                                  // sort by the commmit log segment id
+                                  .sorted(new CommitLogSegment.CommitLogSegmentFileComparator())
                                   .collect(Collectors.toList());
-        File oldestCdcFile = sorted.get(0);
-        File cdcIndexFile = CommitLogDescriptor.inferCdcIndexFile(oldestCdcFile);
-        return deleteCDCFiles(oldestCdcFile, cdcIndexFile);
+        long bytesDeleted = 0;
+        long bytesRemaining = 0;
+        boolean deletionCompleted = false;
+        // keep deleting from old to new until it reaches to the goal or the current writing segment
+        for (File linkedCdcFile : sorted)
+        {
+            // only evaluate/update when deletionCompleted is false
+            if (!deletionCompleted)
+            {
+                deletionCompleted = bytesDeleted >= bytesToFree || linkedCdcFile.equals(allocatingFrom().getCDCFile());
+            }
+
+            if (deletionCompleted)
+            {
+                bytesRemaining += linkedCdcFile.length();
+            }
+            else
+            {
+                File cdcIndexFile = CommitLogDescriptor.inferCdcIndexFile(linkedCdcFile);
+                bytesDeleted += deleteCDCFiles(linkedCdcFile, cdcIndexFile);
+            }
+        }
+        return bytesRemaining;
     }
 
     private long deleteCDCFiles(File cdcLink, File cdcIndexFile)
@@ -142,6 +172,7 @@ public class CommitLogSegmentManagerCDC extends AbstractCommitLogSegmentManager
         CommitLogSegment segment = allocatingFrom();
         CommitLogSegment.Allocation alloc;
 
+        ensureSegmentPermittedIfNotBlockWrites(segment);
         throwIfForbidden(mutation, segment);
         while ( null == (alloc = segment.allocate(mutation, size)) )
         {
@@ -149,6 +180,7 @@ public class CommitLogSegmentManagerCDC extends AbstractCommitLogSegmentManager
             advanceAllocatingFrom(segment);
             segment = allocatingFrom();
 
+            ensureSegmentPermittedIfNotBlockWrites(segment);
             throwIfForbidden(mutation, segment);
         }
 
@@ -158,6 +190,16 @@ public class CommitLogSegmentManagerCDC extends AbstractCommitLogSegmentManager
         return alloc;
     }
 
+    // Non-blocking mode has just recently been enabled for CDC.
+    // The segment is still marked as FORBIDDEN. It should be set to PERMITTED.
+    private void ensureSegmentPermittedIfNotBlockWrites(CommitLogSegment segment)
+    {
+        if (!DatabaseDescriptor.getCDCBlockWrites() && segment.getCDCState() == CDCState.FORBIDDEN)
+        {
+            segment.setCDCState(CDCState.PERMITTED);
+        }
+    }
+
     private void throwIfForbidden(Mutation mutation, CommitLogSegment segment) throws CDCWriteException
     {
         if (mutation.trackedByCDC() && segment.getCDCState() == CDCState.FORBIDDEN)
@@ -264,29 +306,32 @@ public class CommitLogSegmentManagerCDC extends AbstractCommitLogSegmentManager
          */
         void processNewSegment(CommitLogSegment segment)
         {
+            int segmentSize = defaultSegmentSize();
+            long allowance = allowableCDCBytes();
+            boolean blocking = DatabaseDescriptor.getCDCBlockWrites();
+
             // See synchronization in CommitLogSegment.setCDCState
-            synchronized(segment.cdcStateLock)
+            synchronized (segment.cdcStateLock)
             {
-                int segmentSize = defaultSegmentSize();
-                long allowance = allowableCDCBytes();
-                boolean blocking = DatabaseDescriptor.getCDCBlockWrites();
                 segment.setCDCState(blocking && segmentSize + sizeInProgress.get() > allowance
                                     ? CDCState.FORBIDDEN
                                     : CDCState.PERMITTED);
 
-                // Remove the oldest cdc segment file when exceeding the CDC storage allowance
-                while (!blocking && segmentSize + sizeInProgress.get() > allowance)
-                {
-                    long releasedSize = segmentManager.deleteOldestLinkedCDCCommitLogSegment();
-                    sizeInProgress.getAndAdd(-releasedSize);
-                    logger.debug("Freed up {} bytes after deleting the oldest CDC commit log segment in non-blocking mode. " +
-                                 "Total on-disk CDC size: {}; allowed CDC size: {}",
-                                 releasedSize, sizeInProgress.get() + segmentSize, allowance);
-                }
-
-                // Aggresively count in the (estimated) size of new segments.
+                // Aggressively count in the (estimated) size of new segments.
                 if (segment.getCDCState() == CDCState.PERMITTED)
-                    sizeInProgress.getAndAdd(segmentSize);
+                    addSize(segmentSize);
+            }
+
+            // Remove the oldest cdc segment file when exceeding the CDC storage allowance
+            if (!blocking && sizeInProgress.get() > allowance)
+            {
+                long bytesToFree = sizeInProgress.get() - allowance;
+                long remainingSize = segmentManager.deleteOldLinkedCDCCommitLogSegment(bytesToFree);
+                long releasedSize = sizeInProgress.get() - remainingSize;
+                sizeInProgress.getAndSet(remainingSize);
+                logger.debug("Freed up {} ({}) bytes after deleting the oldest CDC commit log segments in non-blocking mode. " +
+                             "Total on-disk CDC size: {}; allowed CDC size: {}",
+                             releasedSize, bytesToFree, remainingSize, allowance);
             }
 
             // Take this opportunity to kick off a recalc to pick up any consumer file deletion.
@@ -295,18 +340,23 @@ public class CommitLogSegmentManagerCDC extends AbstractCommitLogSegmentManager
 
         void processDiscardedSegment(CommitLogSegment segment)
         {
-            // See synchronization in CommitLogSegment.setCDCState
-            synchronized(segment.cdcStateLock)
+            if (!segment.getCDCFile().exists())
+            {
+                logger.debug("Not processing discarded CommitLogSegment {}; this segment appears to have been deleted already.", segment);
+                return;
+            }
+
+            synchronized (segment.cdcStateLock)
             {
-                // Add to flushed size before decrementing unflushed so we don't have a window of false generosity
+                // Add to flushed size before decrementing unflushed, so we don't have a window of false generosity
                 if (segment.getCDCState() == CDCState.CONTAINS)
-                    sizeInProgress.getAndAdd(segment.onDiskSize());
+                    addSize(segment.onDiskSize());
 
                 // Subtract the (estimated) size of the segment from processNewSegment.
                 // For the segement that CONTAINS, we update with adding the actual onDiskSize and removing the estimated size.
                 // For the segment that remains in PERMITTED, the file is to be deleted and the estimate should be returned.
                 if (segment.getCDCState() != CDCState.FORBIDDEN)
-                    sizeInProgress.getAndAdd(-defaultSegmentSize());
+                    addSize(-defaultSegmentSize());
             }
 
             // Take this opportunity to kick off a recalc to pick up any consumer file deletion.
@@ -380,14 +430,12 @@ public class CommitLogSegmentManagerCDC extends AbstractCommitLogSegmentManager
     @VisibleForTesting
     public long updateCDCTotalSize()
     {
+        long sleepTime = DatabaseDescriptor.getCDCDiskCheckInterval() + 50L;
+        // Give the update time to finish the last run if any. Therefore, avoid modifying production code only for testing purpose.
+        Uninterruptibles.sleepUninterruptibly(sleepTime, TimeUnit.MILLISECONDS);
         cdcSizeTracker.submitOverflowSizeRecalculation();
-
         // Give the update time to run
-        try
-        {
-            Thread.sleep(DatabaseDescriptor.getCDCDiskCheckInterval() + 10);
-        }
-        catch (InterruptedException e) {}
+        Uninterruptibles.sleepUninterruptibly(sleepTime, TimeUnit.MILLISECONDS);
 
         return cdcSizeTracker.getAllocatedSize();
     }
diff --git a/test/unit/org/apache/cassandra/db/commitlog/CommitLogDescriptorTest.java b/test/unit/org/apache/cassandra/db/commitlog/CommitLogDescriptorTest.java
index 87b5fb0fd6..5ef83b48a1 100644
--- a/test/unit/org/apache/cassandra/db/commitlog/CommitLogDescriptorTest.java
+++ b/test/unit/org/apache/cassandra/db/commitlog/CommitLogDescriptorTest.java
@@ -40,6 +40,7 @@ import org.apache.cassandra.io.util.FileSegmentInputStream;
 import org.apache.cassandra.net.MessagingService;
 import org.apache.cassandra.security.EncryptionContext;
 import org.apache.cassandra.security.EncryptionContextGenerator;
+import org.assertj.core.api.Assertions;
 
 public class CommitLogDescriptorTest
 {
@@ -88,6 +89,21 @@ public class CommitLogDescriptorTest
         Assert.assertEquals(MessagingService.current_version, CommitLogDescriptor.fromFileName(newCLName).getMessagingVersion());
     }
 
+    @Test
+    public void testExactIdFromFileName()
+    {
+        Assertions.assertThatThrownBy(() -> CommitLogDescriptor.idFromFileName("CommitLog-1340512736956320000.log"))
+                  .hasMessageContaining("Commitlog segment is too old to open")
+                  .isInstanceOf(UnsupportedOperationException.class);
+
+        Assertions.assertThatThrownBy(() -> CommitLogDescriptor.idFromFileName("CommitLog--1340512736956320000.log"))
+                  .hasMessageContaining("Cannot parse the version of the file")
+                  .isInstanceOf(RuntimeException.class);
+
+        Assertions.assertThat(CommitLogDescriptor.idFromFileName("CommitLog-2-1340512736956320000.log"))
+                  .isEqualTo(1340512736956320000L);
+    }
+
     // migrated from CommitLogTest
     private void testDescriptorPersistence(CommitLogDescriptor desc) throws IOException
     {
diff --git a/test/unit/org/apache/cassandra/db/commitlog/CommitLogSegmentManagerCDCTest.java b/test/unit/org/apache/cassandra/db/commitlog/CommitLogSegmentManagerCDCTest.java
index b5902e5357..af33c79a14 100644
--- a/test/unit/org/apache/cassandra/db/commitlog/CommitLogSegmentManagerCDCTest.java
+++ b/test/unit/org/apache/cassandra/db/commitlog/CommitLogSegmentManagerCDCTest.java
@@ -107,22 +107,20 @@ public class CommitLogSegmentManagerCDCTest extends CQLTester
     public void testNonblockingShouldMaintainSteadyDiskUsage() throws Throwable
     {
         final int commitlogSize = DatabaseDescriptor.getCommitLogSegmentSize() / 1024 / 1024;
-        final int cdcSizeLimit = commitlogSize + 1;
-        // Clear out all CDC files
-        for (File f : new File(DatabaseDescriptor.getCDCLogLocation()).tryList()) {
-            FileUtils.deleteWithConfirm(f);
-        }
-        testWithNonblockingMode(() -> testWithCDCSpaceInMb(cdcSizeLimit, () -> {
+        final int targetFilesCount = 3;
+        final long cdcSizeLimit = commitlogSize * targetFilesCount;
+        final int mutationSize = DatabaseDescriptor.getCommitLogSegmentSize() / 3;
+        testWithNonblockingMode(() -> testWithCDCSpaceInMb((int) cdcSizeLimit, () -> {
             CommitLogSegmentManagerCDC cdcMgr = (CommitLogSegmentManagerCDC)CommitLog.instance.segmentManager;
-            Assert.assertEquals(0, cdcMgr.updateCDCTotalSize());
 
-            createTableAndBulkWrite();
+            createTableAndBulkWrite(mutationSize);
 
-            // Only the current commit log will be kept.
-            // The older ones are deleted immediately on creating a new segment due to exceeding size limit.
             long actualSize = cdcMgr.updateCDCTotalSize();
-            Assert.assertTrue(actualSize <= cdcSizeLimit * 1024 * 1024);
-            Assert.assertTrue(actualSize >= DatabaseDescriptor.getCommitLogSegmentSize());
+            long cdcSizeLimitBytes = cdcSizeLimit * 1024 * 1024;
+            Assert.assertTrue(String.format("Actual size (%s) should not exceed the size limit (%s)", actualSize, cdcSizeLimitBytes),
+                              actualSize <= cdcSizeLimitBytes * targetFilesCount);
+            Assert.assertTrue(String.format("Actual size (%s) should be at least the mutation size (%s)", actualSize, mutationSize),
+                              actualSize >= mutationSize);
         }));
     }
 
@@ -395,10 +393,6 @@ public class CommitLogSegmentManagerCDCTest extends CQLTester
         {
             test.run();
         }
-        catch (Throwable e)
-        {
-            e.printStackTrace();
-        }
         finally
         {
             CommitLog.instance.setCDCBlockWrites(original);
@@ -420,13 +414,23 @@ public class CommitLogSegmentManagerCDCTest extends CQLTester
     }
 
     private String createTableAndBulkWrite() throws Throwable
+    {
+        return createTableAndBulkWrite(DatabaseDescriptor.getCommitLogSegmentSize() / 3);
+    }
+
+    private String createTableAndBulkWrite(int mutationSize) throws Throwable
     {
         String tableName = createTable("CREATE TABLE %s (idx int, data text, primary key(idx)) WITH cdc=true;");
-        bulkWrite(tableName);
+        bulkWrite(tableName, mutationSize);
         return tableName;
     }
 
     private void bulkWrite(String tableName) throws Throwable
+    {
+        bulkWrite(tableName, DatabaseDescriptor.getCommitLogSegmentSize() / 3);
+    }
+
+    private void bulkWrite(String tableName, int mutationSize) throws Throwable
     {
         TableMetadata ccfm = Keyspace.open(keyspace()).getColumnFamilyStore(tableName).metadata();
         boolean blockWrites = DatabaseDescriptor.getCDCBlockWrites();
@@ -436,7 +440,7 @@ public class CommitLogSegmentManagerCDCTest extends CQLTester
             for (int i = 0; i < 1000; i++)
             {
                 new RowUpdateBuilder(ccfm, 0, i)
-                .add("data", randomizeBuffer(DatabaseDescriptor.getCommitLogSegmentSize() / 3))
+                .add("data", randomizeBuffer(mutationSize))
                 .build().applyFuture().get();
             }
             if (blockWrites)
