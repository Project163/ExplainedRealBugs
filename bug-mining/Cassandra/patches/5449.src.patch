diff --git a/CHANGES.txt b/CHANGES.txt
index adc97ddd7c..7287c0b747 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 4.0-beta2
+ * Improve logging for socket connection/disconnection (CASSANDRA-15980)
  * Throw FSWriteError upon write failures in order to apply DiskFailurePolicy (CASSANDRA-15928)
  * Forbid altering UDTs used in partition keys (CASSANDRA-15933)
  * Fix version parsing logic when upgrading from 3.0 (CASSANDRA-15973)
diff --git a/src/java/org/apache/cassandra/net/InboundConnectionInitiator.java b/src/java/org/apache/cassandra/net/InboundConnectionInitiator.java
index 4ad3d8cb87..e02512ba6a 100644
--- a/src/java/org/apache/cassandra/net/InboundConnectionInitiator.java
+++ b/src/java/org/apache/cassandra/net/InboundConnectionInitiator.java
@@ -237,8 +237,8 @@ public class InboundConnectionInitiator
             if (sslHandler != null)
             {
                 SSLSession session = sslHandler.engine().getSession();
-                logger.info("connection from peer {} to {}, protocol = {}, cipher suite = {}",
-                            ctx.channel().remoteAddress(), ctx.channel().localAddress(), session.getProtocol(), session.getCipherSuite());
+                logger.info("connection from peer {} to {}, protocol = {}",
+                            ctx.channel().remoteAddress(), ctx.channel().localAddress(), session.getProtocol());
             }
         }
 
@@ -391,6 +391,17 @@ public class InboundConnectionInitiator
 
             BufferPool.setRecycleWhenFreeForCurrentThread(false);
             pipeline.replace(this, "streamInbound", new StreamingInboundHandler(from, current_version, null));
+
+            logger.info("{} streaming connection established, version = {}, framing = {}, encryption = {}",
+                        SocketFactory.channelId(from,
+                                                (InetSocketAddress) channel.remoteAddress(),
+                                                settings.bindAddress,
+                                                (InetSocketAddress) channel.localAddress(),
+                                                ConnectionType.STREAMING,
+                                                channel.id().asShortText()),
+                        current_version,
+                        initiate.framing,
+                        pipeline.get("ssl") != null ? encryptionLogStatement(pipeline.channel(), settings.encryption) : "disabled");
         }
 
         @VisibleForTesting
@@ -445,11 +456,11 @@ public class InboundConnectionInitiator
             InboundMessageHandler handler =
                 settings.handlers.apply(from).createHandler(frameDecoder, initiate.type, pipeline.channel(), useMessagingVersion);
 
-            logger.info("{} connection established, version = {}, framing = {}, encryption = {}",
+            logger.info("{} messaging connection established, version = {}, framing = {}, encryption = {}",
                         handler.id(true),
                         useMessagingVersion,
                         initiate.framing,
-                        pipeline.get("ssl") != null ? encryptionLogStatement(settings.encryption) : "disabled");
+                        pipeline.get("ssl") != null ? encryptionLogStatement(pipeline.channel(), settings.encryption) : "disabled");
 
             pipeline.addLast("deserialize", handler);
 
diff --git a/src/java/org/apache/cassandra/net/InboundConnectionSettings.java b/src/java/org/apache/cassandra/net/InboundConnectionSettings.java
index a07395b8f2..20f185aa7f 100644
--- a/src/java/org/apache/cassandra/net/InboundConnectionSettings.java
+++ b/src/java/org/apache/cassandra/net/InboundConnectionSettings.java
@@ -84,7 +84,7 @@ public class InboundConnectionSettings
     public String toString()
     {
         return format("address: (%s), nic: %s, encryption: %s",
-                      bindAddress, FBUtilities.getNetworkInterface(bindAddress.address), SocketFactory.encryptionLogStatement(encryption));
+                      bindAddress, FBUtilities.getNetworkInterface(bindAddress.address), SocketFactory.encryptionLogStatement(null, encryption));
     }
 
     public InboundConnectionSettings withAuthenticator(IInternodeAuthenticator authenticator)
diff --git a/src/java/org/apache/cassandra/net/OutboundConnection.java b/src/java/org/apache/cassandra/net/OutboundConnection.java
index e7eca86c17..b0edc0369f 100644
--- a/src/java/org/apache/cassandra/net/OutboundConnection.java
+++ b/src/java/org/apache/cassandra/net/OutboundConnection.java
@@ -1151,7 +1151,7 @@ public class OutboundConnection
                                     id(true),
                                     success.messagingVersion,
                                     settings.framing,
-                                    encryptionLogStatement(settings.encryption));
+                                    encryptionLogStatement(channel, settings.encryption));
                         break;
 
                     case RETRY:
diff --git a/src/java/org/apache/cassandra/net/OutboundConnections.java b/src/java/org/apache/cassandra/net/OutboundConnections.java
index 029d5e13f6..f1e1276259 100644
--- a/src/java/org/apache/cassandra/net/OutboundConnections.java
+++ b/src/java/org/apache/cassandra/net/OutboundConnections.java
@@ -27,6 +27,9 @@ import java.util.function.Function;
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.collect.ImmutableList;
 
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
 import com.carrotsearch.hppc.ObjectObjectHashMap;
 import io.netty.util.concurrent.Future;
 import org.apache.cassandra.config.Config;
@@ -47,6 +50,8 @@ import static org.apache.cassandra.net.ConnectionType.SMALL_MESSAGES;
  */
 public class OutboundConnections
 {
+    private static final Logger logger = LoggerFactory.getLogger(OutboundConnections.class);
+
     @VisibleForTesting
     public static final int LARGE_MESSAGE_THRESHOLD = Integer.getInteger(Config.PROPERTY_PREFIX + "otcp_large_message_threshold", 1024 * 64)
     - Math.max(Math.max(LegacyLZ4Constants.HEADER_LENGTH, FrameEncoderCrc.HEADER_AND_TRAILER_LENGTH), FrameEncoderLZ4.HEADER_AND_TRAILER_LENGTH);
@@ -281,6 +286,8 @@ public class OutboundConnections
                 if (cur.small == prev.small && cur.large == prev.large && cur.urgent == prev.urgent
                     && !Gossiper.instance.isKnownEndpoint(connections.template.to))
                 {
+                    logger.info("Closing outbound connections to {}, as inactive and not known by Gossiper",
+                                connections.template.to);
                     // close entirely if no traffic and the endpoint is unknown
                     messagingService.closeOutboundNow(connections);
                     continue;
diff --git a/src/java/org/apache/cassandra/net/SocketFactory.java b/src/java/org/apache/cassandra/net/SocketFactory.java
index da2d4612a1..a8ee72990a 100644
--- a/src/java/org/apache/cassandra/net/SocketFactory.java
+++ b/src/java/org/apache/cassandra/net/SocketFactory.java
@@ -30,6 +30,7 @@ import java.util.concurrent.TimeoutException;
 import javax.annotation.Nullable;
 import javax.net.ssl.SSLEngine;
 import javax.net.ssl.SSLParameters;
+import javax.net.ssl.SSLSession;
 
 import com.google.common.collect.ImmutableList;
 import org.slf4j.Logger;
@@ -51,7 +52,6 @@ import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.socket.nio.NioServerSocketChannel;
 import io.netty.channel.socket.nio.NioSocketChannel;
 import io.netty.channel.unix.Errors;
-import io.netty.handler.ssl.OpenSsl;
 import io.netty.handler.ssl.SslContext;
 import io.netty.handler.ssl.SslHandler;
 import io.netty.util.concurrent.DefaultEventExecutorChooserFactory;
@@ -237,6 +237,32 @@ public final class SocketFactory
         return "enabled (" + encryptionType + ')';
     }
 
+    static String encryptionLogStatement(Channel channel, EncryptionOptions options)
+    {
+        if (options == null || !options.isEnabled())
+            return "disabled";
+
+        StringBuilder sb = new StringBuilder(64);
+        if (options.optional)
+            sb.append("optional (factory=");
+        else
+            sb.append("enabled (factory=");
+        sb.append(SSLFactory.openSslIsAvailable() ? "openssl" : "jdk");
+
+        final SslHandler sslHandler = channel == null ? null : channel.pipeline().get(SslHandler.class);
+        if (sslHandler != null)
+        {
+            SSLSession session = sslHandler.engine().getSession();
+            sb.append(";protocol=")
+              .append(session.getProtocol())
+              .append(";cipher=")
+              .append(session.getCipherSuite());
+        }
+
+        sb.append(')');
+        return sb.toString();
+    }
+
     EventLoopGroup defaultGroup()
     {
         return defaultGroup;
diff --git a/src/java/org/apache/cassandra/transport/ServerConnection.java b/src/java/org/apache/cassandra/transport/ServerConnection.java
index de8a02a318..06e7842e90 100644
--- a/src/java/org/apache/cassandra/transport/ServerConnection.java
+++ b/src/java/org/apache/cassandra/transport/ServerConnection.java
@@ -137,7 +137,7 @@ public class ServerConnection extends Connection
             }
             catch (SSLPeerUnverifiedException e)
             {
-                logger.error("Failed to get peer certificates for peer {}", channel().remoteAddress(), e);
+                logger.debug("Failed to get peer certificates for peer {}", channel().remoteAddress(), e);
             }
         }
         return certificates;
