diff --git a/CHANGES.txt b/CHANGES.txt
index 38b9b1747e..e015a0b370 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 4.0
+ * Fix pending repair manager index out of bounds check (CASSANDRA-13769)
  * Don't use RangeFetchMapCalculator when RF=1 (CASSANDRA-13576)
  * Don't optimise trivial ranges in RangeFetchMapCalculator (CASSANDRA-13664)
  * Use an ExecutorService for repair commands instead of new Thread(..).start() (CASSANDRA-13594)
diff --git a/src/java/org/apache/cassandra/db/compaction/PendingRepairManager.java b/src/java/org/apache/cassandra/db/compaction/PendingRepairManager.java
index 2786396bdf..4596381932 100644
--- a/src/java/org/apache/cassandra/db/compaction/PendingRepairManager.java
+++ b/src/java/org/apache/cassandra/db/compaction/PendingRepairManager.java
@@ -300,6 +300,9 @@ class PendingRepairManager
             sessions.add(entry.getKey());
         }
 
+        if (sessions.isEmpty())
+            return null;
+
         // we want the session with the most compactions at the head of the list
         sessions.sort((o1, o2) -> numTasks.get(o2) - numTasks.get(o1));
 
diff --git a/test/unit/org/apache/cassandra/db/compaction/PendingRepairManagerTest.java b/test/unit/org/apache/cassandra/db/compaction/PendingRepairManagerTest.java
index 93b68b57f7..33e996b614 100644
--- a/test/unit/org/apache/cassandra/db/compaction/PendingRepairManagerTest.java
+++ b/test/unit/org/apache/cassandra/db/compaction/PendingRepairManagerTest.java
@@ -173,6 +173,27 @@ public class PendingRepairManagerTest extends AbstractPendingRepairTest
         Assert.assertNull(prm.getNextBackgroundTask(FBUtilities.nowInSeconds()));
     }
 
+    /**
+     * If all sessions should be cleaned up, getNextBackgroundTask should return null
+     */
+    @Test
+    public void getNextBackgroundTaskAllCleanup() throws Exception
+    {
+        PendingRepairManager prm = csm.getPendingRepairManagers().get(0);
+        UUID repairID = registerSession(cfs, true, true);
+        LocalSessionAccessor.prepareUnsafe(repairID, COORDINATOR, PARTICIPANTS);
+
+        SSTableReader sstable = makeSSTable(true);
+        mutateRepaired(sstable, repairID);
+        prm.addSSTable(sstable);
+        Assert.assertNotNull(prm.get(repairID));
+        Assert.assertNotNull(prm.get(repairID));
+        LocalSessionAccessor.finalizeUnsafe(repairID);
+
+        Assert.assertNull(prm.getNextBackgroundTask(FBUtilities.nowInSeconds()));
+
+    }
+
     @Test
     public void maximalTaskNeedsCleanup()
     {
