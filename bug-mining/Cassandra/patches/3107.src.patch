diff --git a/CHANGES.txt b/CHANGES.txt
index 4954b7f7b5..7be8979b79 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,6 @@
 2.0.11:
+ * Explicitly disallowing mixing multi-column and single-column
+   relations on clustering columns (CASSANDRA-7711)
  * Better error message when condition is set on PK column (CASSANDRA-7804)
  * Forbid re-adding dropped counter columns (CASSANDRA-7831)
  * Fix CFMetaData#isThriftCompatible() for PK-only tables (CASSANDRA-7832)
diff --git a/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java b/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
index a360d495b0..ea1d8e9ef7 100644
--- a/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
+++ b/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
@@ -28,6 +28,8 @@ import org.github.jamm.MemoryMeter;
 
 import org.apache.cassandra.auth.Permission;
 import org.apache.cassandra.cql3.*;
+import org.apache.cassandra.cql3.CFDefinition.Name;
+import org.apache.cassandra.cql3.CFDefinition.Name.Kind;
 import org.apache.cassandra.transport.messages.ResultMessage;
 import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.db.*;
@@ -1400,6 +1402,8 @@ public class SelectStatement implements CQLStatement, MeasurableForPreparedCache
              */
             boolean hasQueriableIndex = false;
             boolean hasQueriableClusteringColumnIndex = false;
+            boolean hasSingleColumnRelations = false;
+            boolean hasMultiColumnRelations = false;
             for (Relation relation : whereClause)
             {
                 if (relation.isMultiColumn())
@@ -1411,7 +1415,9 @@ public class SelectStatement implements CQLStatement, MeasurableForPreparedCache
                         boolean[] queriable = processRelationEntity(stmt, relation, entity, cfDef);
                         hasQueriableIndex |= queriable[0];
                         hasQueriableClusteringColumnIndex |= queriable[1];
-                        names.add(cfDef.get(entity));
+                        Name name = cfDef.get(entity);
+                        names.add(name);
+                        hasMultiColumnRelations |= Kind.COLUMN_ALIAS.equals(name.kind);
                     }
                     updateRestrictionsForRelation(stmt, names, rel, boundNames);
                 }
@@ -1421,9 +1427,13 @@ public class SelectStatement implements CQLStatement, MeasurableForPreparedCache
                     boolean[] queriable = processRelationEntity(stmt, relation, rel.getEntity(), cfDef);
                     hasQueriableIndex |= queriable[0];
                     hasQueriableClusteringColumnIndex |= queriable[1];
-                    updateRestrictionsForRelation(stmt, cfDef.get(rel.getEntity()), rel, boundNames);
+                    Name name = cfDef.get(rel.getEntity());
+                    hasSingleColumnRelations |= Kind.COLUMN_ALIAS.equals(name.kind);
+                    updateRestrictionsForRelation(stmt, name, rel, boundNames);
                 }
             }
+            if (hasSingleColumnRelations && hasMultiColumnRelations)
+                throw new InvalidRequestException("Mixing single column relations and multi column relations on clustering columns is not allowed");
 
              // At this point, the select statement if fully constructed, but we still have a few things to validate
             processPartitionKeyRestrictions(stmt, cfDef, hasQueriableIndex);
diff --git a/test/unit/org/apache/cassandra/cql3/MultiColumnRelationTest.java b/test/unit/org/apache/cassandra/cql3/MultiColumnRelationTest.java
index 121a8d312a..498d3327a4 100644
--- a/test/unit/org/apache/cassandra/cql3/MultiColumnRelationTest.java
+++ b/test/unit/org/apache/cassandra/cql3/MultiColumnRelationTest.java
@@ -112,6 +112,12 @@ public class MultiColumnRelationTest
             return null;
     }
 
+    @Test(expected=InvalidRequestException.class)
+    public void testMixMultiColumnRelationsAndSingleColumn() throws Throwable
+    {
+        execute("SELECT * FROM %s.multiple_clustering WHERE a = 1 AND (b) in ((2),(3)) AND c > 4");
+    }
+
     @Test(expected=SyntaxException.class)
     public void testEmptyIdentifierTuple() throws Throwable
     {
