diff --git a/CHANGES.txt b/CHANGES.txt
index 0ea7e9e333..e00d11c588 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 3.0.19
+ * Fix handling FS errors on writing and reading flat files - LogTransaction and hints (CASSANDRA-15053)
  * Avoid double closing the iterator to avoid overcounting the number of requests (CASSANDRA-15058)
  * Improve `nodetool status -r` speed (CASSANDRA-14847)
  * Improve merkle tree size and time on heap (CASSANDRA-14096)
diff --git a/src/java/org/apache/cassandra/db/lifecycle/LogReplica.java b/src/java/org/apache/cassandra/db/lifecycle/LogReplica.java
index 44400d1011..26fa82ccd2 100644
--- a/src/java/org/apache/cassandra/db/lifecycle/LogReplica.java
+++ b/src/java/org/apache/cassandra/db/lifecycle/LogReplica.java
@@ -19,7 +19,13 @@
 package org.apache.cassandra.db.lifecycle;
 
 import java.io.File;
+import java.io.IOException;
 
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import org.apache.cassandra.io.FSError;
+import org.apache.cassandra.io.FSReadError;
 import org.apache.cassandra.io.util.FileUtils;
 import org.apache.cassandra.utils.NativeLibrary;
 
@@ -36,17 +42,27 @@ import org.apache.cassandra.utils.NativeLibrary;
  */
 final class LogReplica implements AutoCloseable
 {
+    private static final Logger logger = LoggerFactory.getLogger(LogReplica.class);
+
     private final File file;
     private int folderDescriptor;
 
     static LogReplica create(File folder, String fileName)
     {
-        return new LogReplica(new File(fileName), NativeLibrary.tryOpenDirectory(folder.getPath()));
+        int folderFD = NativeLibrary.tryOpenDirectory(folder.getPath());
+        if (folderFD == -1)
+            throw new FSReadError(new IOException(String.format("Invalid folder descriptor trying to create log replica %s", folder.getPath())), folder.getPath());
+
+        return new LogReplica(new File(fileName), folderFD);
     }
 
     static LogReplica open(File file)
     {
-        return new LogReplica(file, NativeLibrary.tryOpenDirectory(file.getParentFile().getPath()));
+        int folderFD = NativeLibrary.tryOpenDirectory(file.getParentFile().getPath());
+        if (folderFD == -1)
+            throw new FSReadError(new IOException(String.format("Invalid folder descriptor trying to create log replica %s", file.getParentFile().getPath())), file.getParentFile().getPath());
+
+        return new LogReplica(file, folderFD);
     }
 
     LogReplica(File file, int folderDescriptor)
@@ -63,7 +79,15 @@ final class LogReplica implements AutoCloseable
     void append(LogRecord record)
     {
         boolean existed = exists();
-        FileUtils.appendAndSync(file, record.toString());
+        try
+        {
+            FileUtils.appendAndSync(file, record.toString());
+        }
+        catch (FSError e)
+        {
+            logger.error("Failed to sync file {}", file, e);
+            FileUtils.handleFSErrorAndPropagate(e);
+        }
 
         // If the file did not exist before appending the first
         // line, then sync the folder as well since now it must exist
@@ -73,8 +97,16 @@ final class LogReplica implements AutoCloseable
 
     void syncFolder()
     {
-        if (folderDescriptor >= 0)
-            NativeLibrary.trySync(folderDescriptor);
+        try
+        {
+            if (folderDescriptor >= 0)
+                NativeLibrary.trySync(folderDescriptor);
+        }
+        catch (FSError e)
+        {
+            logger.error("Failed to sync directory descriptor {}", folderDescriptor, e);
+            FileUtils.handleFSErrorAndPropagate(e);
+        }
     }
 
     void delete()
diff --git a/src/java/org/apache/cassandra/db/lifecycle/LogReplicaSet.java b/src/java/org/apache/cassandra/db/lifecycle/LogReplicaSet.java
index d8b214137d..0bf20e5b38 100644
--- a/src/java/org/apache/cassandra/db/lifecycle/LogReplicaSet.java
+++ b/src/java/org/apache/cassandra/db/lifecycle/LogReplicaSet.java
@@ -15,7 +15,6 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 package org.apache.cassandra.db.lifecycle;
 
 import java.io.File;
@@ -32,6 +31,7 @@ import com.google.common.annotations.VisibleForTesting;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import org.apache.cassandra.io.FSError;
 import org.apache.cassandra.io.util.FileUtils;
 import org.apache.cassandra.utils.Throwables;
 
@@ -61,7 +61,15 @@ public class LogReplicaSet implements AutoCloseable
     {
         File folder = file.getParentFile();
         assert !replicasByFile.containsKey(folder);
-        replicasByFile.put(folder, LogReplica.open(file));
+        try
+        {
+            replicasByFile.put(folder, LogReplica.open(file));
+        }
+        catch(FSError e)
+        {
+            logger.error("Failed to open log replica {}", file, e);
+            FileUtils.handleFSErrorAndPropagate(e);
+        }
 
         if (logger.isTraceEnabled())
             logger.trace("Added log file replica {} ", file);
@@ -72,14 +80,21 @@ public class LogReplicaSet implements AutoCloseable
         if (replicasByFile.containsKey(folder))
             return;
 
-        @SuppressWarnings("resource")  // LogReplicas are closed in LogReplicaSet::close
-        final LogReplica replica = LogReplica.create(folder, fileName);
-
-        records.forEach(replica::append);
-        replicasByFile.put(folder, replica);
+        try
+        {
+            @SuppressWarnings("resource")  // LogReplicas are closed in LogReplicaSet::close
+            final LogReplica replica = LogReplica.create(folder, fileName);
+            records.forEach(replica::append);
+            replicasByFile.put(folder, replica);
 
-        if (logger.isTraceEnabled())
-            logger.trace("Created new file replica {}", replica);
+            if (logger.isTraceEnabled())
+                logger.trace("Created new file replica {}", replica);
+        }
+        catch(FSError e)
+        {
+            logger.error("Failed to create log replica {}/{}", folder,  fileName, e);
+            FileUtils.handleFSErrorAndPropagate(e);
+        }
     }
 
     Throwable syncFolder(Throwable accumulate)
diff --git a/src/java/org/apache/cassandra/db/lifecycle/LogTransaction.java b/src/java/org/apache/cassandra/db/lifecycle/LogTransaction.java
index 00a222a5f5..9bbf69d77e 100644
--- a/src/java/org/apache/cassandra/db/lifecycle/LogTransaction.java
+++ b/src/java/org/apache/cassandra/db/lifecycle/LogTransaction.java
@@ -37,11 +37,13 @@ import org.apache.cassandra.db.Directories;
 import org.apache.cassandra.db.SystemKeyspace;
 import org.apache.cassandra.db.compaction.OperationType;
 import org.apache.cassandra.db.lifecycle.LogRecord.Type;
+import org.apache.cassandra.io.FSWriteError;
 import org.apache.cassandra.io.sstable.Component;
 import org.apache.cassandra.io.sstable.Descriptor;
 import org.apache.cassandra.io.sstable.SSTable;
 import org.apache.cassandra.io.sstable.SnapshotDeletingTask;
 import org.apache.cassandra.io.sstable.format.SSTableReader;
+import org.apache.cassandra.io.util.FileUtils;
 import org.apache.cassandra.utils.*;
 import org.apache.cassandra.utils.concurrent.Ref;
 import org.apache.cassandra.utils.concurrent.RefCounted;
@@ -222,7 +224,7 @@ class LogTransaction extends Transactional.AbstractTransactional implements Tran
         catch (IOException e)
         {
             logger.error("Unable to delete {}", file, e);
-            throw new RuntimeException(e);
+            FileUtils.handleFSErrorAndPropagate(new FSWriteError(e, file));
         }
     }
 
@@ -256,8 +258,10 @@ class LogTransaction extends Transactional.AbstractTransactional implements Tran
             if (logger.isTraceEnabled())
                 logger.trace("Removing files for transaction {}", name());
 
+            // this happens if we forget to close a txn and the garbage collector closes it for us
+            // or if the transaction journal was never properly created in the first place
             if (!data.completed())
-            { // this happens if we forget to close a txn and the garbage collector closes it for us
+            {
                 logger.error("{} was not completed, trying to abort it now", data);
                 Throwable err = Throwables.perform((Throwable)null, data::abort);
                 if (err != null)
diff --git a/src/java/org/apache/cassandra/hints/HintsCatalog.java b/src/java/org/apache/cassandra/hints/HintsCatalog.java
index d1f6fbaebf..7d5c8e6006 100644
--- a/src/java/org/apache/cassandra/hints/HintsCatalog.java
+++ b/src/java/org/apache/cassandra/hints/HintsCatalog.java
@@ -26,8 +26,13 @@ import java.util.stream.Stream;
 import javax.annotation.Nullable;
 
 import com.google.common.collect.ImmutableMap;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
+import org.apache.cassandra.io.FSError;
 import org.apache.cassandra.io.FSReadError;
+import org.apache.cassandra.io.FSWriteError;
+import org.apache.cassandra.io.util.FileUtils;
 import org.apache.cassandra.utils.NativeLibrary;
 import org.apache.cassandra.utils.SyncUtil;
 
@@ -38,6 +43,8 @@ import static java.util.stream.Collectors.groupingBy;
  */
 final class HintsCatalog
 {
+    private static final Logger logger = LoggerFactory.getLogger(HintsCatalog.class);
+
     private final File hintsDirectory;
     private final Map<UUID, HintsStore> stores;
     private final ImmutableMap<String, Object> writerParams;
@@ -142,8 +149,21 @@ final class HintsCatalog
         int fd = NativeLibrary.tryOpenDirectory(hintsDirectory.getAbsolutePath());
         if (fd != -1)
         {
-            SyncUtil.trySync(fd);
-            NativeLibrary.tryCloseFD(fd);
+            try
+            {
+                SyncUtil.trySync(fd);
+                NativeLibrary.tryCloseFD(fd);
+            }
+            catch (FSError e) // trySync failed
+            {
+                logger.error("Unable to sync directory {}", hintsDirectory.getAbsolutePath(), e);
+                FileUtils.handleFSErrorAndPropagate(e);
+            }
+        }
+        else
+        {
+            logger.error("Unable to open directory {}", hintsDirectory.getAbsolutePath());
+            FileUtils.handleFSErrorAndPropagate(new FSWriteError(new IOException(String.format("Unable to open hint directory %s", hintsDirectory.getAbsolutePath())), hintsDirectory.getAbsolutePath()));
         }
     }
 
diff --git a/src/java/org/apache/cassandra/hints/HintsWriteExecutor.java b/src/java/org/apache/cassandra/hints/HintsWriteExecutor.java
index eb1bffe02b..51a5362f95 100644
--- a/src/java/org/apache/cassandra/hints/HintsWriteExecutor.java
+++ b/src/java/org/apache/cassandra/hints/HintsWriteExecutor.java
@@ -22,9 +22,14 @@ import java.nio.ByteBuffer;
 import java.util.Iterator;
 import java.util.concurrent.*;
 
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
 import org.apache.cassandra.concurrent.DebuggableThreadPoolExecutor;
 import org.apache.cassandra.config.DatabaseDescriptor;
+import org.apache.cassandra.io.FSError;
 import org.apache.cassandra.io.FSWriteError;
+import org.apache.cassandra.io.util.FileUtils;
 
 /**
  * A single threaded executor that exclusively writes all the hints and otherwise manipulate the writers.
@@ -35,6 +40,8 @@ import org.apache.cassandra.io.FSWriteError;
  */
 final class HintsWriteExecutor
 {
+    private static final Logger logger = LoggerFactory.getLogger(HintsWriteExecutor.class);
+
     static final int WRITE_BUFFER_SIZE = 256 << 10;
 
     private final HintsCatalog catalog;
@@ -151,7 +158,15 @@ final class HintsWriteExecutor
         {
             HintsBuffer buffer = bufferPool.currentBuffer();
             buffer.waitForModifications();
-            flush(buffer);
+            try
+            {
+                flush(buffer);
+            }
+            catch(FSError e)
+            {
+                logger.error("Unable to flush hint buffer: {}", e.getLocalizedMessage(), e);
+                FileUtils.handleFSErrorAndPropagate(e);
+            }
         }
     }
 
diff --git a/src/java/org/apache/cassandra/io/util/FileUtils.java b/src/java/org/apache/cassandra/io/util/FileUtils.java
index 80df67ba20..ed683d017d 100644
--- a/src/java/org/apache/cassandra/io/util/FileUtils.java
+++ b/src/java/org/apache/cassandra/io/util/FileUtils.java
@@ -46,6 +46,7 @@ import org.apache.cassandra.io.FSWriteError;
 import org.apache.cassandra.io.sstable.CorruptSSTableException;
 import org.apache.cassandra.utils.JVMStabilityInspector;
 
+import static com.google.common.base.Throwables.propagate;
 import static org.apache.cassandra.utils.Throwables.maybeFail;
 import static org.apache.cassandra.utils.Throwables.merge;
 
@@ -497,6 +498,21 @@ public final class FileUtils
         if (handler != null)
             handler.handleFSError(e);
     }
+
+    /**
+     * handleFSErrorAndPropagate will invoke the disk failure policy error handler,
+     * which may or may not stop the daemon or transports. However, if we don't exit,
+     * we still want to propagate the exception to the caller in case they have custom
+     * exception handling
+     *
+     * @param e A filesystem error
+     */
+    public static void handleFSErrorAndPropagate(FSError e)
+    {
+        handleFSError(e);
+        throw propagate(e);
+    }
+
     /**
      * Get the size of a directory in bytes
      * @param directory The directory for which we need size.
diff --git a/src/java/org/apache/cassandra/utils/NativeLibrary.java b/src/java/org/apache/cassandra/utils/NativeLibrary.java
index f96859eac1..0cc690e3ab 100644
--- a/src/java/org/apache/cassandra/utils/NativeLibrary.java
+++ b/src/java/org/apache/cassandra/utils/NativeLibrary.java
@@ -30,6 +30,8 @@ import org.slf4j.LoggerFactory;
 
 import com.sun.jna.LastErrorException;
 
+import org.apache.cassandra.io.FSWriteError;
+
 import static org.apache.cassandra.utils.NativeLibrary.OSType.LINUX;
 import static org.apache.cassandra.utils.NativeLibrary.OSType.MAC;
 import static org.apache.cassandra.utils.NativeLibrary.OSType.WINDOWS;
@@ -318,7 +320,9 @@ public final class NativeLibrary
             if (!(e instanceof LastErrorException))
                 throw e;
 
-            logger.warn("fsync({}) failed, errorno ({}) {}", fd, errno(e), e);
+            String errMsg = String.format("fsync(%s) failed, errno %s", fd, errno(e));
+            logger.warn(errMsg);
+            throw new FSWriteError(e, errMsg);
         }
     }
 
@@ -340,7 +344,9 @@ public final class NativeLibrary
             if (!(e instanceof LastErrorException))
                 throw e;
 
-            logger.warn(String.format("close(%d) failed, errno (%d).", fd, errno(e)));
+            String errMsg = String.format("close(%d) failed, errno (%d).", fd, errno(e));
+            logger.warn(errMsg);
+            throw new FSWriteError(e, errMsg);
         }
     }
 
