diff --git a/CHANGES.txt b/CHANGES.txt
index b7bbe09c0d..e5865925f1 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,9 +1,6 @@
-1.2.14
- * Randomize batchlog candidates selection (CASSANDRA-6481)
-
-
 1.2.13
- * Fix thundering herd on endpoint cache invalidation (CASSANDRA-6345)
+ * Randomize batchlog candidates selection (CASSANDRA-6481)
+ * Fix thundering herd on endpoint cache invalidation (CASSANDRA-6345, 6485)
  * Optimize FD phi calculation (CASSANDRA-6386)
  * Improve initial FD phi estimate when starting up (CASSANDRA-6385)
  * Don't list CQL3 table in CLI describe even if named explicitely 
diff --git a/src/java/org/apache/cassandra/locator/AbstractReplicationStrategy.java b/src/java/org/apache/cassandra/locator/AbstractReplicationStrategy.java
index 51c41192c4..c36fde4da9 100644
--- a/src/java/org/apache/cassandra/locator/AbstractReplicationStrategy.java
+++ b/src/java/org/apache/cassandra/locator/AbstractReplicationStrategy.java
@@ -116,19 +116,20 @@ public abstract class AbstractReplicationStrategy
         ArrayList<InetAddress> endpoints = getCachedEndpoints(keyToken);
         if (endpoints == null)
         {
-            if (tokenMetadataClone == null)
+            TokenMetadata tm; // local reference in case another thread nulls tMC out from under us
+            if ((tm = tokenMetadataClone) == null)
             {
                 // synchronize to prevent thundering herd post-invalidation
                 synchronized (this)
                 {
-                    if (tokenMetadataClone == null)
-                        tokenMetadataClone = tokenMetadata.cloneOnlyTokenMap();
+                    if ((tm = tokenMetadataClone) == null)
+                        tm = tokenMetadataClone = tokenMetadata.cloneOnlyTokenMap();
                 }
                 // if our clone got invalidated, it's possible there is a new token to account for too
-                keyToken = TokenMetadata.firstToken(tokenMetadataClone.sortedTokens(), searchToken);
+                keyToken = TokenMetadata.firstToken(tm.sortedTokens(), searchToken);
             }
 
-            endpoints = new ArrayList<InetAddress>(calculateNaturalEndpoints(searchToken, tokenMetadataClone));
+            endpoints = new ArrayList<InetAddress>(calculateNaturalEndpoints(searchToken, tm));
             cachedEndpoints.put(keyToken, endpoints);
         }
 
