diff --git a/CHANGES.txt b/CHANGES.txt
index f0cffa551e..670a8a2d0f 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -37,7 +37,7 @@
  * CFMetaData.convertToThrift method to set RowCacheProvider (CASSANDRA-3405)
  * acquire compactionlock during truncate (CASSANDRA-3399)
  * fix displaying cfdef entries for super columnfamilies (CASSANDRA-3415)
-
+ * (Hadoop) Fix empty row filtering (CASSANDRA-3450)
 
 0.8.7
  * Kill server on wrapped OOME such as from FileChannel.map (CASSANDRA-3201)
diff --git a/src/java/org/apache/cassandra/hadoop/ColumnFamilyRecordReader.java b/src/java/org/apache/cassandra/hadoop/ColumnFamilyRecordReader.java
index 87408c6e2b..1c27638128 100644
--- a/src/java/org/apache/cassandra/hadoop/ColumnFamilyRecordReader.java
+++ b/src/java/org/apache/cassandra/hadoop/ColumnFamilyRecordReader.java
@@ -235,50 +235,55 @@ public class ColumnFamilyRecordReader extends RecordReader<ByteBuffer, SortedMap
             {
                 startToken = split.getStartToken();
             } 
-            else if (startToken.equals(split.getEndToken()))
-            {
-                rows = null;
-                return;
-            }
-            
-            KeyRange keyRange = new KeyRange(batchRowCount)
-                                .setStart_token(startToken)
-                                .setEnd_token(split.getEndToken());
-            try
-            {
-                rows = client.get_range_slices(new ColumnParent(cfName),
-                                               predicate,
-                                               keyRange,
-                                               consistencyLevel);
-                  
-                // nothing new? reached the end
-                if (rows.isEmpty())
+
+            // The removal of empty CF rows could result in an empty List<KeySlice> rows.
+            // Keep trying until we return on reaching the end of the range or rows is nonEmpty.
+            while (rows == null || rows.isEmpty()) {
+                if (startToken.equals(split.getEndToken()))
                 {
                     rows = null;
                     return;
                 }
 
-                // Pre-compute the last row key, before removing empty rows
-                ByteBuffer lastRowKey = rows.get(rows.size() - 1).key;
+                KeyRange keyRange = new KeyRange(batchRowCount)
+                                    .setStart_token(startToken)
+                                    .setEnd_token(split.getEndToken());
+                try
+                {
+                    rows = client.get_range_slices(new ColumnParent(cfName),
+                                                   predicate,
+                                                   keyRange,
+                                                   consistencyLevel);
+
+                    // nothing new? reached the end
+                    if (rows.isEmpty())
+                    {
+                        rows = null;
+                        return;
+                    }
 
-                // only remove empty rows if the slice predicate is empty
-                if (isPredicateEmpty(predicate))
+                    // Pre-compute the last row key, before removing empty rows
+                    ByteBuffer lastRowKey = rows.get(rows.size() - 1).key;
+
+                    // only remove empty rows if the slice predicate is empty
+                    if (isPredicateEmpty(predicate))
+                    {
+                        Iterator<KeySlice> rowsIterator = rows.iterator();
+                        while (rowsIterator.hasNext())
+                            if (rowsIterator.next().columns.isEmpty())
+                                rowsIterator.remove();
+                    }
+
+                    // reset to iterate through the new batch
+                    i = 0;
+
+                    // prepare for the next slice to be read
+                    startToken = partitioner.getTokenFactory().toString(partitioner.getToken(lastRowKey));
+                }
+                catch (Exception e)
                 {
-                    Iterator<KeySlice> rowsIterator = rows.iterator();
-                    while (rowsIterator.hasNext())
-                        if (rowsIterator.next().columns.isEmpty())
-                            rowsIterator.remove();
+                    throw new RuntimeException(e);
                 }
-                
-                // reset to iterate through the new batch
-                i = 0;
-
-                // prepare for the next slice to be read
-                startToken = partitioner.getTokenFactory().toString(partitioner.getToken(lastRowKey));
-            }
-            catch (Exception e)
-            {
-                throw new RuntimeException(e);
             }
         }
 
@@ -354,8 +359,10 @@ public class ColumnFamilyRecordReader extends RecordReader<ByteBuffer, SortedMap
     {
         if (predicate != null)
             if (predicate.isSetSlice_range())
-                if (predicate.getSlice_range().getStart() != null && predicate.getSlice_range().getFinish() != null)
+            {
+                if (predicate.getSlice_range().getStart() != null || predicate.getSlice_range().getFinish() != null)
                 return false;
+            }
             else if (predicate.isSetColumn_names())
                 return false;
 
