diff --git a/test/unit/org/apache/cassandra/cql3/ViewComplexDeletionsTest.java b/test/unit/org/apache/cassandra/cql3/ViewComplexDeletionsTest.java
index 51852ce8b1..33fa6d91a9 100644
--- a/test/unit/org/apache/cassandra/cql3/ViewComplexDeletionsTest.java
+++ b/test/unit/org/apache/cassandra/cql3/ViewComplexDeletionsTest.java
@@ -18,32 +18,23 @@
 
 package org.apache.cassandra.cql3;
 
-import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collection;
+import java.util.Comparator;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
 import java.util.stream.Collectors;
 
-import org.junit.After;
-import org.junit.Before;
-import org.junit.BeforeClass;
 import org.junit.Ignore;
 import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
 
 import org.apache.cassandra.db.ColumnFamilyStore;
 import org.apache.cassandra.db.Keyspace;
 import org.apache.cassandra.db.SystemKeyspace;
 import org.apache.cassandra.db.compaction.CompactionManager;
+import org.apache.cassandra.io.sstable.format.SSTableReader;
 import org.apache.cassandra.schema.SchemaConstants;
-import org.apache.cassandra.transport.ProtocolVersion;
 import org.apache.cassandra.utils.FBUtilities;
 
-import static org.apache.cassandra.cql3.ViewComplexTest.createView;
-import static org.apache.cassandra.cql3.ViewComplexTest.updateView;
-import static org.apache.cassandra.cql3.ViewComplexTest.updateViewWithFlush;
 import static org.junit.Assert.assertEquals;
 
 /* ViewComplexTest class has been split into multiple ones because of timeout issues (CASSANDRA-16670)
@@ -54,38 +45,8 @@ import static org.junit.Assert.assertEquals;
  * - ViewComplexTest
  * - ViewComplexLivenessTest
  */
-@RunWith(Parameterized.class)
-public class ViewComplexDeletionsTest extends CQLTester
+public class ViewComplexDeletionsTest extends ViewComplexTester
 {
-    @Parameterized.Parameter
-    public ProtocolVersion version;
-
-    @Parameterized.Parameters()
-    public static Collection<Object[]> versions()
-    {
-        return ViewComplexTest.versions();
-    }
-
-    private final List<String> views = new ArrayList<>();
-
-    @BeforeClass
-    public static void startup()
-    {
-        ViewComplexTest.startup();
-    }
-
-    @Before
-    public void begin()
-    {
-        ViewComplexTest.beginSetup(views);
-    }
-
-    @After
-    public void end() throws Throwable
-    {
-        ViewComplexTest.endTearDown(views, version, this);
-    }
-
     // for now, unselected column cannot be fully supported, SEE CASSANDRA-11500
     @Ignore
     @Test
@@ -95,44 +56,41 @@ public class ViewComplexDeletionsTest extends CQLTester
         execute("USE " + keyspace());
         executeNet(version, "USE " + keyspace());
         createTable("CREATE TABLE %s (k int, c int, a int, b int, PRIMARY KEY (k, c))");
-        createView("mv",
-                   "CREATE MATERIALIZED VIEW %s AS SELECT k,c FROM %%s WHERE k IS NOT NULL AND c IS NOT NULL PRIMARY KEY (k,c)",
-                   version,
-                   this,
-                   views);
+        String mv = createView("CREATE MATERIALIZED VIEW %s " +
+                                 "AS SELECT k,c FROM %%s WHERE k IS NOT NULL AND c IS NOT NULL PRIMARY KEY (k,c)");
         Keyspace ks = Keyspace.open(keyspace());
-        ks.getColumnFamilyStore("mv").disableAutoCompaction();
+        ks.getColumnFamilyStore(mv).disableAutoCompaction();
 
-        updateView("UPDATE %s USING TIMESTAMP 10 SET b=1 WHERE k=1 AND c=1", version, this);
+        updateView("UPDATE %s USING TIMESTAMP 10 SET b=1 WHERE k=1 AND c=1");
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
         assertRows(execute("SELECT * from %s"), row(1, 1, null, 1));
-        assertRows(execute("SELECT * from mv"), row(1, 1));
-        updateView("DELETE b FROM %s USING TIMESTAMP 11 WHERE k=1 AND c=1", version, this);
+        assertRows(execute("SELECT * from " + mv), row(1, 1));
+        updateView("DELETE b FROM %s USING TIMESTAMP 11 WHERE k=1 AND c=1");
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
         assertEmpty(execute("SELECT * from %s"));
-        assertEmpty(execute("SELECT * from mv"));
-        updateView("UPDATE %s USING TIMESTAMP 1 SET a=1 WHERE k=1 AND c=1", version, this);
+        assertEmpty(execute("SELECT * from " + mv));
+        updateView("UPDATE %s USING TIMESTAMP 1 SET a=1 WHERE k=1 AND c=1");
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
         assertRows(execute("SELECT * from %s"), row(1, 1, 1, null));
-        assertRows(execute("SELECT * from mv"), row(1, 1));
+        assertRows(execute("SELECT * from " + mv), row(1, 1));
 
         execute("truncate %s;");
 
         // removal generated by unselected column should not shadow PK update with smaller timestamp
-        updateViewWithFlush("UPDATE %s USING TIMESTAMP 18 SET a=1 WHERE k=1 AND c=1", flush, version, this);
+        updateViewWithFlush("UPDATE %s USING TIMESTAMP 18 SET a=1 WHERE k=1 AND c=1", flush);
         assertRows(execute("SELECT * from %s"), row(1, 1, 1, null));
-        assertRows(execute("SELECT * from mv"), row(1, 1));
+        assertRows(execute("SELECT * from " + mv), row(1, 1));
 
-        updateViewWithFlush("UPDATE %s USING TIMESTAMP 20 SET a=null WHERE k=1 AND c=1", flush, version, this);
+        updateViewWithFlush("UPDATE %s USING TIMESTAMP 20 SET a=null WHERE k=1 AND c=1", flush);
         assertRows(execute("SELECT * from %s"));
-        assertRows(execute("SELECT * from mv"));
+        assertRows(execute("SELECT * from " + mv));
 
-        updateViewWithFlush("INSERT INTO %s(k,c) VALUES(1,1) USING TIMESTAMP 15", flush, version, this);
+        updateViewWithFlush("INSERT INTO %s(k,c) VALUES(1,1) USING TIMESTAMP 15", flush);
         assertRows(execute("SELECT * from %s"), row(1, 1, null, null));
-        assertRows(execute("SELECT * from mv"), row(1, 1));
+        assertRows(execute("SELECT * from " + mv), row(1, 1));
     }
 
     @Test
@@ -152,78 +110,75 @@ public class ViewComplexDeletionsTest extends CQLTester
         execute("USE " + keyspace());
         executeNet(version, "USE " + keyspace());
         createTable("CREATE TABLE %s (k int, c int, a int, b int, e int, f int, PRIMARY KEY (k, c))");
-        createView("mv",
-                   "CREATE MATERIALIZED VIEW %s AS SELECT a, b, c, k FROM %%s WHERE k IS NOT NULL AND c IS NOT NULL PRIMARY KEY (k,c)",
-                   version,
-                   this,
-                   views);
+        String mv = createView("CREATE MATERIALIZED VIEW %s AS SELECT a, b, c, k FROM %%s " +
+                                 "WHERE k IS NOT NULL AND c IS NOT NULL PRIMARY KEY (k,c)");
         Keyspace ks = Keyspace.open(keyspace());
-        ks.getColumnFamilyStore("mv").disableAutoCompaction();
+        ks.getColumnFamilyStore(mv).disableAutoCompaction();
 
-        updateViewWithFlush("UPDATE %s USING TIMESTAMP 10 SET b=1 WHERE k=1 AND c=1", flush, version, this);
+        updateViewWithFlush("UPDATE %s USING TIMESTAMP 10 SET b=1 WHERE k=1 AND c=1", flush);
         assertRows(execute("SELECT * from %s"), row(1, 1, null, 1, null, null));
-        assertRows(execute("SELECT * from mv"), row(1, 1, null, 1));
+        assertRows(execute("SELECT * from " + mv), row(1, 1, null, 1));
 
-        updateViewWithFlush("DELETE b FROM %s USING TIMESTAMP 11 WHERE k=1 AND c=1", flush, version, this);
+        updateViewWithFlush("DELETE b FROM %s USING TIMESTAMP 11 WHERE k=1 AND c=1", flush);
         assertEmpty(execute("SELECT * from %s"));
-        assertEmpty(execute("SELECT * from mv"));
+        assertEmpty(execute("SELECT * from " + mv));
 
-        updateViewWithFlush("UPDATE %s USING TIMESTAMP 1 SET a=1 WHERE k=1 AND c=1", flush, version, this);
+        updateViewWithFlush("UPDATE %s USING TIMESTAMP 1 SET a=1 WHERE k=1 AND c=1", flush);
         assertRows(execute("SELECT * from %s"), row(1, 1, 1, null, null, null));
-        assertRows(execute("SELECT * from mv"), row(1, 1, 1, null));
+        assertRows(execute("SELECT * from " + mv), row(1, 1, 1, null));
 
-        updateViewWithFlush("DELETE a FROM %s USING TIMESTAMP 1 WHERE k=1 AND c=1", flush, version, this);
+        updateViewWithFlush("DELETE a FROM %s USING TIMESTAMP 1 WHERE k=1 AND c=1", flush);
         assertEmpty(execute("SELECT * from %s"));
-        assertEmpty(execute("SELECT * from mv"));
+        assertEmpty(execute("SELECT * from " + mv));
 
         // view livenessInfo should not be affected by selected column ts or tb
-        updateViewWithFlush("INSERT INTO %s(k,c) VALUES(1,1) USING TIMESTAMP 0", flush, version, this);
+        updateViewWithFlush("INSERT INTO %s(k,c) VALUES(1,1) USING TIMESTAMP 0", flush);
         assertRows(execute("SELECT * from %s"), row(1, 1, null, null, null, null));
-        assertRows(execute("SELECT * from mv"), row(1, 1, null, null));
+        assertRows(execute("SELECT * from " + mv), row(1, 1, null, null));
 
-        updateViewWithFlush("UPDATE %s USING TIMESTAMP 12 SET b=1 WHERE k=1 AND c=1", flush, version, this);
+        updateViewWithFlush("UPDATE %s USING TIMESTAMP 12 SET b=1 WHERE k=1 AND c=1", flush);
         assertRows(execute("SELECT * from %s"), row(1, 1, null, 1, null, null));
-        assertRows(execute("SELECT * from mv"), row(1, 1, null, 1));
+        assertRows(execute("SELECT * from " + mv), row(1, 1, null, 1));
 
-        updateViewWithFlush("DELETE b FROM %s USING TIMESTAMP 13 WHERE k=1 AND c=1", flush, version, this);
+        updateViewWithFlush("DELETE b FROM %s USING TIMESTAMP 13 WHERE k=1 AND c=1", flush);
         assertRows(execute("SELECT * from %s"), row(1, 1, null, null, null, null));
-        assertRows(execute("SELECT * from mv"), row(1, 1, null, null));
+        assertRows(execute("SELECT * from " + mv), row(1, 1, null, null));
 
-        updateViewWithFlush("DELETE FROM %s USING TIMESTAMP 14 WHERE k=1 AND c=1", flush, version, this);
+        updateViewWithFlush("DELETE FROM %s USING TIMESTAMP 14 WHERE k=1 AND c=1", flush);
         assertEmpty(execute("SELECT * from %s"));
-        assertEmpty(execute("SELECT * from mv"));
+        assertEmpty(execute("SELECT * from " + mv));
 
-        updateViewWithFlush("INSERT INTO %s(k,c) VALUES(1,1) USING TIMESTAMP 15", flush, version, this);
+        updateViewWithFlush("INSERT INTO %s(k,c) VALUES(1,1) USING TIMESTAMP 15", flush);
         assertRows(execute("SELECT * from %s"), row(1, 1, null, null, null, null));
-        assertRows(execute("SELECT * from mv"), row(1, 1, null, null));
+        assertRows(execute("SELECT * from " + mv), row(1, 1, null, null));
 
-        updateViewWithFlush("UPDATE %s USING TTL 3 SET b=1 WHERE k=1 AND c=1", flush, version, this);
+        updateViewWithFlush("UPDATE %s USING TTL 3 SET b=1 WHERE k=1 AND c=1", flush);
         assertRows(execute("SELECT * from %s"), row(1, 1, null, 1, null, null));
-        assertRows(execute("SELECT * from mv"), row(1, 1, null, 1));
+        assertRows(execute("SELECT * from " + mv), row(1, 1, null, 1));
 
         TimeUnit.SECONDS.sleep(4);
 
         assertRows(execute("SELECT * from %s"), row(1, 1, null, null, null, null));
-        assertRows(execute("SELECT * from mv"), row(1, 1, null, null));
+        assertRows(execute("SELECT * from " + mv), row(1, 1, null, null));
 
-        updateViewWithFlush("DELETE FROM %s USING TIMESTAMP 15 WHERE k=1 AND c=1", flush, version, this);
+        updateViewWithFlush("DELETE FROM %s USING TIMESTAMP 15 WHERE k=1 AND c=1", flush);
         assertEmpty(execute("SELECT * from %s"));
-        assertEmpty(execute("SELECT * from mv"));
+        assertEmpty(execute("SELECT * from " + mv));
 
         execute("truncate %s;");
 
         // removal generated by unselected column should not shadow selected column with smaller timestamp
-        updateViewWithFlush("UPDATE %s USING TIMESTAMP 18 SET e=1 WHERE k=1 AND c=1", flush, version, this);
+        updateViewWithFlush("UPDATE %s USING TIMESTAMP 18 SET e=1 WHERE k=1 AND c=1", flush);
         assertRows(execute("SELECT * from %s"), row(1, 1, null, null, 1, null));
-        assertRows(execute("SELECT * from mv"), row(1, 1, null, null));
+        assertRows(execute("SELECT * from " + mv), row(1, 1, null, null));
 
-        updateViewWithFlush("UPDATE %s USING TIMESTAMP 18 SET e=null WHERE k=1 AND c=1", flush, version, this);
+        updateViewWithFlush("UPDATE %s USING TIMESTAMP 18 SET e=null WHERE k=1 AND c=1", flush);
         assertRows(execute("SELECT * from %s"));
-        assertRows(execute("SELECT * from mv"));
+        assertRows(execute("SELECT * from " + mv));
 
-        updateViewWithFlush("UPDATE %s USING TIMESTAMP 16 SET a=1 WHERE k=1 AND c=1", flush, version, this);
+        updateViewWithFlush("UPDATE %s USING TIMESTAMP 16 SET a=1 WHERE k=1 AND c=1", flush);
         assertRows(execute("SELECT * from %s"), row(1, 1, 1, null, null, null));
-        assertRows(execute("SELECT * from mv"), row(1, 1, 1, null));
+        assertRows(execute("SELECT * from " + mv), row(1, 1, 1, null));
     }
 
     @Test
@@ -238,7 +193,7 @@ public class ViewComplexDeletionsTest extends CQLTester
         testRangeDeletion(false);
     }
 
-    public void testRangeDeletion(boolean flush) throws Throwable
+    private void testRangeDeletion(boolean flush) throws Throwable
     {
         // for partition range deletion, need to know that existing row is shadowed instead of not existed.
         createTable("CREATE TABLE %s (a int, b int, c int, d int, PRIMARY KEY (a))");
@@ -246,40 +201,37 @@ public class ViewComplexDeletionsTest extends CQLTester
         execute("USE " + keyspace());
         executeNet(version, "USE " + keyspace());
 
-        createView("mv_test1",
-                   "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a IS NOT NULL AND b IS NOT NULL PRIMARY KEY (a, b)",
-                   version,
-                   this,
-                   views);
+        String mv = createView("CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s " +
+                                 "WHERE a IS NOT NULL AND b IS NOT NULL PRIMARY KEY (a, b)");
 
         Keyspace ks = Keyspace.open(keyspace());
-        ks.getColumnFamilyStore("mv_test1").disableAutoCompaction();
+        ks.getColumnFamilyStore(mv).disableAutoCompaction();
 
         execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?) using timestamp 0", 1, 1, 1, 1);
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
 
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test1"), row(1, 1, 1, 1));
+        assertRowsIgnoringOrder(execute("SELECT * FROM " + mv), row(1, 1, 1, 1));
 
         // remove view row
-        updateView("UPDATE %s using timestamp 1 set b = null WHERE a=1", version, this);
+        updateView("UPDATE %s using timestamp 1 set b = null WHERE a=1");
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
 
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test1"));
+        assertRowsIgnoringOrder(execute("SELECT * FROM " + mv));
         // remove base row, no view updated generated.
-        updateView("DELETE FROM %s using timestamp 2 where a=1", version, this);
+        updateView("DELETE FROM %s using timestamp 2 where a=1");
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
 
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test1"));
+        assertRowsIgnoringOrder(execute("SELECT * FROM " + mv));
 
         // restor view row with b,c column. d is still tombstone
-        updateView("UPDATE %s using timestamp 3 set b = 1,c = 1 where a=1", version, this); // upsert
+        updateView("UPDATE %s using timestamp 3 set b = 1,c = 1 where a=1"); // upsert
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
 
-        assertRowsIgnoringOrder(execute("SELECT * FROM mv_test1"), row(1, 1, 1, null));
+        assertRowsIgnoringOrder(execute("SELECT * FROM " + mv), row(1, 1, 1, null));
     }
 
     @Test
@@ -305,64 +257,61 @@ public class ViewComplexDeletionsTest extends CQLTester
         executeNet(version, "USE " + keyspace());
         Keyspace ks = Keyspace.open(keyspace());
 
-        createView("mv",
-                   "create materialized view %s as select * from %%s where p is not null and v1 is not null primary key (v1, p);",
-                   version,
-                   this,
-                   views);
-        ks.getColumnFamilyStore("mv").disableAutoCompaction();
+        String mv = createView("create materialized view %s as select * from %%s " +
+                                 "where p is not null and v1 is not null primary key (v1, p)");
+        ks.getColumnFamilyStore(mv).disableAutoCompaction();
 
         // sstable-1, Set initial values TS=1
-        updateView("Insert into %s (p, v1, v2) values (3, 1, 3) using timestamp 1;", version, this);
+        updateView("Insert into %s (p, v1, v2) values (3, 1, 3) using timestamp 1;");
 
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
 
-        assertRowsIgnoringOrder(execute("SELECT v2, WRITETIME(v2) from mv WHERE v1 = ? AND p = ?", 1, 3), row(3, 1L));
+        assertRowsIgnoringOrder(execute("SELECT v2, WRITETIME(v2) from " + mv + " WHERE v1 = ? AND p = ?", 1, 3), row(3, 1L));
         // sstable-2
-        updateView("Delete from %s using timestamp 2 where p = 3;", version, this);
+        updateView("Delete from %s using timestamp 2 where p = 3;");
 
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
 
-        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from mv"));
+        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from " + mv));
         // sstable-3
-        updateView("Insert into %s (p, v1) values (3, 1) using timestamp 3;", version, this);
+        updateView("Insert into %s (p, v1) values (3, 1) using timestamp 3;");
 
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
 
-        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from mv"), row(1, 3, null, null));
+        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from " + mv), row(1, 3, null, null));
         // sstable-4
-        updateView("UPdate %s using timestamp 4 set v1 = 2 where p = 3;", version, this);
+        updateView("UPdate %s using timestamp 4 set v1 = 2 where p = 3;");
 
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
 
-        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from mv"), row(2, 3, null, null));
+        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from " + mv), row(2, 3, null, null));
         // sstable-5
-        updateView("UPdate %s using timestamp 5 set v1 = 1 where p = 3;", version, this);
+        updateView("UPdate %s using timestamp 5 set v1 = 1 where p = 3;");
 
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
 
-        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from mv"), row(1, 3, null, null));
+        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from " + mv), row(1, 3, null, null));
 
         if (flush)
         {
             // compact sstable 2 and 4, 5;
-            ColumnFamilyStore cfs = ks.getColumnFamilyStore("mv");
+            ColumnFamilyStore cfs = ks.getColumnFamilyStore(mv);
             List<String> sstables = cfs.getLiveSSTables()
                                        .stream()
-                                       .sorted((s1, s2) -> s1.descriptor.generation - s2.descriptor.generation)
-                                       .map(s -> s.getFilename())
+                                       .sorted(Comparator.comparingInt(s -> s.descriptor.generation))
+                                       .map(SSTableReader::getFilename)
                                        .collect(Collectors.toList());
             String dataFiles = String.join(",", Arrays.asList(sstables.get(1), sstables.get(3), sstables.get(4)));
             CompactionManager.instance.forceUserDefinedCompaction(dataFiles);
             assertEquals(3, cfs.getLiveSSTables().size());
         }
         // regular tombstone should be retained after compaction
-        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from mv"), row(1, 3, null, null));
+        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from " + mv), row(1, 3, null, null));
     }
 
     @Test
@@ -387,63 +336,60 @@ public class ViewComplexDeletionsTest extends CQLTester
         executeNet(version, "USE " + keyspace());
         Keyspace ks = Keyspace.open(keyspace());
 
-        createView("mv2",
-                   "create materialized view %s as select * from %%s where p1 is not null and p2 is not null primary key (p2, p1);",
-                   version,
-                   this,
-                   views);
-        ks.getColumnFamilyStore("mv2").disableAutoCompaction();
+        String mv = createView("create materialized view %s as select * from %%s " +
+                                 "where p1 is not null and p2 is not null primary key (p2, p1)");
+        ks.getColumnFamilyStore(mv).disableAutoCompaction();
 
         // Set initial values TS=1
-        updateView("Insert into %s (p1, p2, v1, v2) values (1, 2, 3, 4) using timestamp 1;", version, this);
+        updateView("Insert into %s (p1, p2, v1, v2) values (1, 2, 3, 4) using timestamp 1;");
 
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
 
-        assertRowsIgnoringOrder(execute("SELECT v1, v2, WRITETIME(v2) from mv2 WHERE p1 = ? AND p2 = ?", 1, 2),
+        assertRowsIgnoringOrder(execute("SELECT v1, v2, WRITETIME(v2) from " + mv + " WHERE p1 = ? AND p2 = ?", 1, 2),
                                 row(3, 4, 1L));
         // remove row/mv TS=2
-        updateView("Delete from %s using timestamp 2 where p1 = 1 and p2 = 2;", version, this);
+        updateView("Delete from %s using timestamp 2 where p1 = 1 and p2 = 2;");
 
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
         // view are empty
-        assertRowsIgnoringOrder(execute("SELECT * from mv2"));
+        assertRowsIgnoringOrder(execute("SELECT * from " + mv));
         // insert PK with TS=3
-        updateView("Insert into %s (p1, p2) values (1, 2) using timestamp 3;", version, this);
+        updateView("Insert into %s (p1, p2) values (1, 2) using timestamp 3;");
 
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
         // deleted column in MV remained dead
-        assertRowsIgnoringOrder(execute("SELECT * from mv2"), row(2, 1, null, null));
+        assertRowsIgnoringOrder(execute("SELECT * from " + mv), row(2, 1, null, null));
 
-        ks.getColumnFamilyStore("mv2").forceMajorCompaction();
-        assertRowsIgnoringOrder(execute("SELECT * from mv2"), row(2, 1, null, null));
+        ks.getColumnFamilyStore(mv).forceMajorCompaction();
+        assertRowsIgnoringOrder(execute("SELECT * from " + mv), row(2, 1, null, null));
 
         // reset values
-        updateView("Insert into %s (p1, p2, v1, v2) values (1, 2, 3, 4) using timestamp 10;", version, this);
+        updateView("Insert into %s (p1, p2, v1, v2) values (1, 2, 3, 4) using timestamp 10;");
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
 
-        assertRowsIgnoringOrder(execute("SELECT v1, v2, WRITETIME(v2) from mv2 WHERE p1 = ? AND p2 = ?", 1, 2),
+        assertRowsIgnoringOrder(execute("SELECT v1, v2, WRITETIME(v2) from " + mv + " WHERE p1 = ? AND p2 = ?", 1, 2),
                                 row(3, 4, 10L));
 
-        updateView("UPDATE %s using timestamp 20 SET v2 = 5 WHERE p1 = 1 and p2 = 2", version, this);
+        updateView("UPDATE %s using timestamp 20 SET v2 = 5 WHERE p1 = 1 and p2 = 2");
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
 
-        assertRowsIgnoringOrder(execute("SELECT v1, v2, WRITETIME(v2) from mv2 WHERE p1 = ? AND p2 = ?", 1, 2),
+        assertRowsIgnoringOrder(execute("SELECT v1, v2, WRITETIME(v2) from " + mv + " WHERE p1 = ? AND p2 = ?", 1, 2),
                                 row(3, 5, 20L));
 
-        updateView("DELETE FROM %s using timestamp 10 WHERE p1 = 1 and p2 = 2", version, this);
+        updateView("DELETE FROM %s using timestamp 10 WHERE p1 = 1 and p2 = 2");
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
 
-        assertRowsIgnoringOrder(execute("SELECT v1, v2, WRITETIME(v2) from mv2 WHERE p1 = ? AND p2 = ?", 1, 2),
+        assertRowsIgnoringOrder(execute("SELECT v1, v2, WRITETIME(v2) from " + mv + " WHERE p1 = ? AND p2 = ?", 1, 2),
                                 row(null, 5, 20L));
     }
 
-    public void complexTimestampWithbaseNonPKColumnsInViewPKDeletionTest(boolean flush) throws Throwable
+    private void complexTimestampWithbaseNonPKColumnsInViewPKDeletionTest(boolean flush) throws Throwable
     {
         createTable("create table %s (p int primary key, v1 int, v2 int)");
 
@@ -451,43 +397,40 @@ public class ViewComplexDeletionsTest extends CQLTester
         executeNet(version, "USE " + keyspace());
         Keyspace ks = Keyspace.open(keyspace());
 
-        createView("mv",
-                   "create materialized view %s as select * from %%s where p is not null and v1 is not null primary key (v1, p);",
-                   version,
-                   this,
-                   views);
-        ks.getColumnFamilyStore("mv").disableAutoCompaction();
+        String mv = createView("create materialized view %s as select * from %%s " +
+                                 "where p is not null and v1 is not null primary key (v1, p)");
+        ks.getColumnFamilyStore(mv).disableAutoCompaction();
 
         // Set initial values TS=1
-        updateView("Insert into %s (p, v1, v2) values (3, 1, 5) using timestamp 1;", version, this);
+        updateView("Insert into %s (p, v1, v2) values (3, 1, 5) using timestamp 1;");
 
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
 
-        assertRowsIgnoringOrder(execute("SELECT v2, WRITETIME(v2) from mv WHERE v1 = ? AND p = ?", 1, 3), row(5, 1L));
+        assertRowsIgnoringOrder(execute("SELECT v2, WRITETIME(v2) from " + mv + " WHERE v1 = ? AND p = ?", 1, 3), row(5, 1L));
         // remove row/mv TS=2
-        updateView("Delete from %s using timestamp 2 where p = 3;", version, this);
+        updateView("Delete from %s using timestamp 2 where p = 3;");
 
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
         // view are empty
-        assertRowsIgnoringOrder(execute("SELECT * from mv"));
+        assertRowsIgnoringOrder(execute("SELECT * from " + mv));
         // insert PK with TS=3
-        updateView("Insert into %s (p, v1) values (3, 1) using timestamp 3;", version, this);
+        updateView("Insert into %s (p, v1) values (3, 1) using timestamp 3;");
 
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
         // deleted column in MV remained dead
-        assertRowsIgnoringOrder(execute("SELECT * from mv"), row(1, 3, null));
+        assertRowsIgnoringOrder(execute("SELECT * from " + mv), row(1, 3, null));
 
         // insert values TS=2, it should be considered dead due to previous tombstone
-        updateView("Insert into %s (p, v1, v2) values (3, 1, 5) using timestamp 2;", version, this);
+        updateView("Insert into %s (p, v1, v2) values (3, 1, 5) using timestamp 2;");
 
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
         // deleted column in MV remained dead
-        assertRowsIgnoringOrder(execute("SELECT * from mv"), row(1, 3, null));
-        assertRowsIgnoringOrder(execute("SELECT * from mv limit 1"), row(1, 3, null));
+        assertRowsIgnoringOrder(execute("SELECT * from " + mv), row(1, 3, null));
+        assertRowsIgnoringOrder(execute("SELECT * from " + mv + " limit 1"), row(1, 3, null));
 
         // insert values TS=2, it should be considered dead due to previous tombstone
         executeNet(version, "UPDATE %s USING TIMESTAMP 3 SET v2 = ? WHERE p = ?", 4, 3);
@@ -495,11 +438,11 @@ public class ViewComplexDeletionsTest extends CQLTester
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
 
-        assertRows(execute("SELECT v1, p, v2, WRITETIME(v2) from mv"), row(1, 3, 4, 3L));
+        assertRows(execute("SELECT v1, p, v2, WRITETIME(v2) from " + mv), row(1, 3, 4, 3L));
 
-        ks.getColumnFamilyStore("mv").forceMajorCompaction();
-        assertRows(execute("SELECT v1, p, v2, WRITETIME(v2) from mv"), row(1, 3, 4, 3L));
-        assertRows(execute("SELECT v1, p, v2, WRITETIME(v2) from mv limit 1"), row(1, 3, 4, 3L));
+        ks.getColumnFamilyStore(mv).forceMajorCompaction();
+        assertRows(execute("SELECT v1, p, v2, WRITETIME(v2) from " + mv), row(1, 3, 4, 3L));
+        assertRows(execute("SELECT v1, p, v2, WRITETIME(v2) from " + mv + " limit 1"), row(1, 3, 4, 3L));
     }
 
     @Test
@@ -509,18 +452,15 @@ public class ViewComplexDeletionsTest extends CQLTester
         executeNet(version, "USE " + keyspace());
 
         createTable("CREATE TABLE %s (k1 int primary key, v1 int)");
-        createView("view1",
-                   "CREATE MATERIALIZED VIEW view1 AS SELECT * FROM %%s WHERE k1 IS NOT NULL AND v1 IS NOT NULL PRIMARY KEY (v1, k1)",
-                   version,
-                   this,
-                   views);
+        createView("CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s " +
+                   "WHERE k1 IS NOT NULL AND v1 IS NOT NULL PRIMARY KEY (v1, k1)");
 
         ColumnFamilyStore batchlog = Keyspace.open(SchemaConstants.SYSTEM_KEYSPACE_NAME).getColumnFamilyStore(SystemKeyspace.BATCHES);
         batchlog.disableAutoCompaction();
         batchlog.forceBlockingFlush();
         int batchlogSSTables = batchlog.getLiveSSTables().size();
 
-        updateView("INSERT INTO %s(k1, v1) VALUES(1, 1)", version, this);
+        updateView("INSERT INTO %s(k1, v1) VALUES(1, 1)");
         batchlog.forceBlockingFlush();
         assertEquals(batchlogSSTables, batchlog.getLiveSSTables().size());
     }
diff --git a/test/unit/org/apache/cassandra/cql3/ViewComplexLivenessTest.java b/test/unit/org/apache/cassandra/cql3/ViewComplexLivenessTest.java
index 6999bef2d6..7b4aa1a9f4 100644
--- a/test/unit/org/apache/cassandra/cql3/ViewComplexLivenessTest.java
+++ b/test/unit/org/apache/cassandra/cql3/ViewComplexLivenessTest.java
@@ -18,26 +18,14 @@
 
 package org.apache.cassandra.cql3;
 
-import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collection;
-import java.util.List;
 
-import org.junit.After;
-import org.junit.Before;
-import org.junit.BeforeClass;
 import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
 
 import org.apache.cassandra.db.ColumnFamilyStore;
 import org.apache.cassandra.db.Keyspace;
-import org.apache.cassandra.transport.ProtocolVersion;
 import org.apache.cassandra.utils.FBUtilities;
 
-import static org.apache.cassandra.cql3.ViewComplexTest.createView;
-import static org.apache.cassandra.cql3.ViewComplexTest.updateView;
-import static org.apache.cassandra.cql3.ViewComplexTest.updateViewWithFlush;
 import static org.junit.Assert.assertEquals;
 
 /* ViewComplexTest class has been split into multiple ones because of timeout issues (CASSANDRA-16670)
@@ -48,38 +36,8 @@ import static org.junit.Assert.assertEquals;
  * - ViewComplexTest
  * - ViewComplexLivenessTest
  */
-@RunWith(Parameterized.class)
-public class ViewComplexLivenessTest extends CQLTester
+public class ViewComplexLivenessTest extends ViewComplexTester
 {
-    @Parameterized.Parameter
-    public ProtocolVersion version;
-
-    @Parameterized.Parameters()
-    public static Collection<Object[]> versions()
-    {
-        return ViewComplexTest.versions();
-    }
-
-    private final List<String> views = new ArrayList<>();
-
-    @BeforeClass
-    public static void startup()
-    {
-        ViewComplexTest.startup();
-    }
-
-    @Before
-    public void begin()
-    {
-        ViewComplexTest.beginSetup(views);
-    }
-
-    @After
-    public void end() throws Throwable
-    {
-        ViewComplexTest.endTearDown(views, version, this);
-    }
-
     @Test
     public void testUnselectedColumnWithExpiredLivenessInfo() throws Throwable
     {
@@ -90,48 +48,45 @@ public class ViewComplexLivenessTest extends CQLTester
         executeNet(version, "USE " + keyspace());
         Keyspace ks = Keyspace.open(keyspace());
 
-        createView("mv",
-                   "create materialized view %s as select k,c,b from %%s where c is not null and k is not null primary key (c, k);",
-                   version,
-                   this,
-                   views);
-        ks.getColumnFamilyStore("mv").disableAutoCompaction();
+        String name = createView("create materialized view %s as select k,c,b from %%s " +
+                                 "where c is not null and k is not null primary key (c, k)");
+        ks.getColumnFamilyStore(name).disableAutoCompaction();
 
         // sstable-1, Set initial values TS=1
-        updateViewWithFlush("UPDATE %s SET a = 1 WHERE k = 1 AND c = 1;", flush, version, this);
+        updateViewWithFlush("UPDATE %s SET a = 1 WHERE k = 1 AND c = 1;", flush);
 
         assertRowsIgnoringOrder(execute("SELECT * from %s WHERE k = 1 AND c = 1;"),
                                 row(1, 1, 1, null));
-        assertRowsIgnoringOrder(execute("SELECT k,c,b from mv WHERE k = 1 AND c = 1;"),
+        assertRowsIgnoringOrder(execute("SELECT k,c,b from " + name + " WHERE k = 1 AND c = 1;"),
                                 row(1, 1, null));
 
         // sstable-2
-        updateViewWithFlush("INSERT INTO %s(k,c) VALUES(1,1) USING TTL 5", flush, version, this);
+        updateViewWithFlush("INSERT INTO %s(k,c) VALUES(1,1) USING TTL 5", flush);
 
         assertRowsIgnoringOrder(execute("SELECT * from %s WHERE k = 1 AND c = 1;"),
                                 row(1, 1, 1, null));
-        assertRowsIgnoringOrder(execute("SELECT k,c,b from mv WHERE k = 1 AND c = 1;"),
+        assertRowsIgnoringOrder(execute("SELECT k,c,b from " + name + " WHERE k = 1 AND c = 1;"),
                                 row(1, 1, null));
 
         Thread.sleep(5001);
 
         assertRowsIgnoringOrder(execute("SELECT * from %s WHERE k = 1 AND c = 1;"),
                                 row(1, 1, 1, null));
-        assertRowsIgnoringOrder(execute("SELECT k,c,b from mv WHERE k = 1 AND c = 1;"),
+        assertRowsIgnoringOrder(execute("SELECT k,c,b from " + name + " WHERE k = 1 AND c = 1;"),
                                 row(1, 1, null));
 
         // sstable-3
-        updateViewWithFlush("Update %s set a = null where k = 1 AND c = 1;", flush, version, this);
+        updateViewWithFlush("Update %s set a = null where k = 1 AND c = 1;", flush);
 
         assertRowsIgnoringOrder(execute("SELECT * from %s WHERE k = 1 AND c = 1;"));
-        assertRowsIgnoringOrder(execute("SELECT k,c,b from mv WHERE k = 1 AND c = 1;"));
+        assertRowsIgnoringOrder(execute("SELECT k,c,b from " + name + " WHERE k = 1 AND c = 1;"));
 
         // sstable-4
-        updateViewWithFlush("Update %s USING TIMESTAMP 1 set b = 1 where k = 1 AND c = 1;", flush, version, this);
+        updateViewWithFlush("Update %s USING TIMESTAMP 1 set b = 1 where k = 1 AND c = 1;", flush);
 
         assertRowsIgnoringOrder(execute("SELECT * from %s WHERE k = 1 AND c = 1;"),
                                 row(1, 1, null, 1));
-        assertRowsIgnoringOrder(execute("SELECT k,c,b from mv WHERE k = 1 AND c = 1;"),
+        assertRowsIgnoringOrder(execute("SELECT k,c,b from " + name + " WHERE k = 1 AND c = 1;"),
                                 row(1, 1, 1));
     }
 
@@ -157,35 +112,29 @@ public class ViewComplexLivenessTest extends CQLTester
         executeNet(version, "USE " + keyspace());
         Keyspace ks = Keyspace.open(keyspace());
 
-        createView("mv1",
-                   "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE k IS NOT NULL AND a IS NOT NULL PRIMARY KEY (k, a);",
-                   version,
-                   this,
-                   views);
-        createView("mv2",
-                   "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE k IS NOT NULL AND a IS NOT NULL PRIMARY KEY (a, k);",
-                   version,
-                   this,
-                   views);
-        ks.getColumnFamilyStore("mv1").disableAutoCompaction();
-        ks.getColumnFamilyStore("mv2").disableAutoCompaction();
+        String mv1 = createView("CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s " +
+                                "WHERE k IS NOT NULL AND a IS NOT NULL PRIMARY KEY (k, a)");
+        String mv2 = createView("CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s " +
+                                "WHERE k IS NOT NULL AND a IS NOT NULL PRIMARY KEY (a, k)");
+        ks.getColumnFamilyStore(mv1).disableAutoCompaction();
+        ks.getColumnFamilyStore(mv2).disableAutoCompaction();
 
         for (int i = 1; i <= 100; i++)
-            updateView("INSERT INTO %s(k, a, b) VALUES (?, ?, ?);", version, this, i, i, i);
+            updateView("INSERT INTO %s(k, a, b) VALUES (?, ?, ?);", i, i, i);
         for (int i = 1; i <= 100; i++)
         {
             if (i % 50 == 0)
                 continue;
             // create expired liveness
-            updateView("DELETE a FROM %s WHERE k = ?;", version, this, i);
+            updateView("DELETE a FROM %s WHERE k = ?;", i);
         }
         if (flush)
         {
-            ks.getColumnFamilyStore("mv1").forceBlockingFlush();
-            ks.getColumnFamilyStore("mv2").forceBlockingFlush();
+            ks.getColumnFamilyStore(mv1).forceBlockingFlush();
+            ks.getColumnFamilyStore(mv2).forceBlockingFlush();
         }
 
-        for (String view : Arrays.asList("mv1", "mv2"))
+        for (String view : Arrays.asList(mv1, mv2))
         {
             // paging
             assertEquals(1, executeNetWithPaging(version, String.format("SELECT k,a,b FROM %s limit 1", view), 1).all().size());
@@ -211,21 +160,18 @@ public class ViewComplexLivenessTest extends CQLTester
         executeNet(version, "USE " + keyspace());
         Keyspace ks = Keyspace.open(keyspace());
 
-        createView("mv",
-                   "create materialized view %s as select * from %%s where p is not null and v1 is not null primary key (v1, p)"
-                           + " with gc_grace_seconds=5;",
-                   version,
-                   this,
-                   views);
-        ColumnFamilyStore cfs = ks.getColumnFamilyStore("mv");
+        String name = createView("create materialized view %s as select * from %%s " +
+                                 "where p is not null and v1 is not null primary key (v1, p) " +
+                                 "with gc_grace_seconds=5");
+        ColumnFamilyStore cfs = ks.getColumnFamilyStore(name);
         cfs.disableAutoCompaction();
 
-        updateView("Insert into %s (p, v1, v2) values (1, 1, 1) ;", version, this);
-        assertRowsIgnoringOrder(execute("SELECT p, v1, v2 from mv"), row(1, 1, 1));
+        updateView("Insert into %s (p, v1, v2) values (1, 1, 1)");
+        assertRowsIgnoringOrder(execute("SELECT p, v1, v2 from " + name), row(1, 1, 1));
 
-        updateView("Update %s set v1 = null WHERE p = 1", version, this);
+        updateView("Update %s set v1 = null WHERE p = 1");
         FBUtilities.waitOnFutures(ks.flush());
-        assertRowsIgnoringOrder(execute("SELECT p, v1, v2 from mv"));
+        assertRowsIgnoringOrder(execute("SELECT p, v1, v2 from " + name));
 
         cfs.forceMajorCompaction(); // before gc grace second, strict-liveness tombstoned dead row remains
         assertEquals(1, cfs.getLiveSSTables().size());
@@ -236,18 +182,18 @@ public class ViewComplexLivenessTest extends CQLTester
         cfs.forceMajorCompaction(); // after gc grace second, no data left
         assertEquals(0, cfs.getLiveSSTables().size());
 
-        updateView("Update %s using ttl 5 set v1 = 1 WHERE p = 1", version, this);
+        updateView("Update %s using ttl 5 set v1 = 1 WHERE p = 1");
         FBUtilities.waitOnFutures(ks.flush());
-        assertRowsIgnoringOrder(execute("SELECT p, v1, v2 from mv"), row(1, 1, 1));
+        assertRowsIgnoringOrder(execute("SELECT p, v1, v2 from " + name), row(1, 1, 1));
 
         cfs.forceMajorCompaction(); // before ttl+gc_grace_second, strict-liveness ttled dead row remains
         assertEquals(1, cfs.getLiveSSTables().size());
-        assertRowsIgnoringOrder(execute("SELECT p, v1, v2 from mv"), row(1, 1, 1));
+        assertRowsIgnoringOrder(execute("SELECT p, v1, v2 from " + name), row(1, 1, 1));
 
         Thread.sleep(5500); // after expired, before gc_grace_second
         cfs.forceMajorCompaction();// before ttl+gc_grace_second, strict-liveness ttled dead row remains
         assertEquals(1, cfs.getLiveSSTables().size());
-        assertRowsIgnoringOrder(execute("SELECT p, v1, v2 from mv"));
+        assertRowsIgnoringOrder(execute("SELECT p, v1, v2 from " + name));
 
         Thread.sleep(5500); // after expired + gc_grace_second
         assertEquals(1, cfs.getLiveSSTables().size()); // no auto compaction.
diff --git a/test/unit/org/apache/cassandra/cql3/ViewComplexTTLTest.java b/test/unit/org/apache/cassandra/cql3/ViewComplexTTLTest.java
index 76a8933fb7..7c49ffae3f 100644
--- a/test/unit/org/apache/cassandra/cql3/ViewComplexTTLTest.java
+++ b/test/unit/org/apache/cassandra/cql3/ViewComplexTTLTest.java
@@ -18,24 +18,12 @@
 
 package org.apache.cassandra.cql3;
 
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.BeforeClass;
 import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
 
 import org.apache.cassandra.db.Keyspace;
-import org.apache.cassandra.transport.ProtocolVersion;
 import org.apache.cassandra.utils.FBUtilities;
 
-import static org.apache.cassandra.cql3.ViewComplexTest.createView;
-import static org.apache.cassandra.cql3.ViewComplexTest.updateView;
-import static org.apache.cassandra.cql3.ViewComplexTest.updateViewWithFlush;
+import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
 /* ViewComplexTest class has been split into multiple ones because of timeout issues (CASSANDRA-16670)
@@ -46,38 +34,8 @@ import static org.junit.Assert.assertTrue;
  * - ViewComplexTest
  * - ViewComplexLivenessTest
  */
-@RunWith(Parameterized.class)
-public class ViewComplexTTLTest extends CQLTester
+public class ViewComplexTTLTest extends ViewComplexTester
 {
-    @Parameterized.Parameter
-    public ProtocolVersion version;
-
-    @Parameterized.Parameters()
-    public static Collection<Object[]> versions()
-    {
-        return ViewComplexTest.versions();
-    }
-
-    private final List<String> views = new ArrayList<>();
-
-    @BeforeClass
-    public static void startup()
-    {
-        ViewComplexTest.startup();
-    }
-
-    @Before
-    public void begin()
-    {
-        ViewComplexTest.beginSetup(views);
-    }
-
-    @After
-    public void end() throws Throwable
-    {
-        ViewComplexTest.endTearDown(views, version, this);
-    }
-
     @Test
     public void testUpdateColumnInViewPKWithTTLWithFlush() throws Throwable
     {
@@ -101,75 +59,72 @@ public class ViewComplexTTLTest extends CQLTester
         executeNet(version, "USE " + keyspace());
         Keyspace ks = Keyspace.open(keyspace());
 
-        createView("mv",
-                   "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE k IS NOT NULL AND a IS NOT NULL PRIMARY KEY (a, k)",
-                   version,
-                   this,
-                   views);
-        ks.getColumnFamilyStore("mv").disableAutoCompaction();
+        String mv = createView("CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s " +
+                               "WHERE k IS NOT NULL AND a IS NOT NULL PRIMARY KEY (a, k)");
+        ks.getColumnFamilyStore(mv).disableAutoCompaction();
 
-        updateView("UPDATE %s SET a = 1 WHERE k = 1;", version, this);
+        updateView("UPDATE %s SET a = 1 WHERE k = 1;");
 
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
 
         assertRows(execute("SELECT * from %s"), row(1, 1, null));
-        assertRows(execute("SELECT * from mv"), row(1, 1, null));
+        assertRows(execute("SELECT * from " + mv), row(1, 1, null));
 
-        updateView("DELETE a FROM %s WHERE k = 1", version, this);
+        updateView("DELETE a FROM %s WHERE k = 1");
 
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
 
         assertRows(execute("SELECT * from %s"));
-        assertEmpty(execute("SELECT * from mv"));
+        assertEmpty(execute("SELECT * from " + mv));
 
-        updateView("INSERT INTO %s (k) VALUES (1);", version, this);
+        updateView("INSERT INTO %s (k) VALUES (1);");
 
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
 
         assertRows(execute("SELECT * from %s"), row(1, null, null));
-        assertEmpty(execute("SELECT * from mv"));
+        assertEmpty(execute("SELECT * from " + mv));
 
-        updateView("UPDATE %s USING TTL 5 SET a = 10 WHERE k = 1;", version, this);
+        updateView("UPDATE %s USING TTL 5 SET a = 10 WHERE k = 1;");
 
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
 
         assertRows(execute("SELECT * from %s"), row(1, 10, null));
-        assertRows(execute("SELECT * from mv"), row(10, 1, null));
+        assertRows(execute("SELECT * from " + mv), row(10, 1, null));
 
-        updateView("UPDATE %s SET b = 100 WHERE k = 1;", version, this);
+        updateView("UPDATE %s SET b = 100 WHERE k = 1;");
 
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
 
         assertRows(execute("SELECT * from %s"), row(1, 10, 100));
-        assertRows(execute("SELECT * from mv"), row(10, 1, 100));
+        assertRows(execute("SELECT * from " + mv), row(10, 1, 100));
 
         Thread.sleep(5000);
 
         // 'a' is TTL of 5 and removed.
         assertRows(execute("SELECT * from %s"), row(1, null, 100));
-        assertEmpty(execute("SELECT * from mv"));
-        assertEmpty(execute("SELECT * from mv WHERE k = ? AND a = ?", 1, 10));
+        assertEmpty(execute("SELECT * from " + mv));
+        assertEmpty(execute("SELECT * from " + mv + " WHERE k = ? AND a = ?", 1, 10));
 
-        updateView("DELETE b FROM %s WHERE k=1", version, this);
+        updateView("DELETE b FROM %s WHERE k=1");
 
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
 
         assertRows(execute("SELECT * from %s"), row(1, null, null));
-        assertEmpty(execute("SELECT * from mv"));
+        assertEmpty(execute("SELECT * from " + mv));
 
-        updateView("DELETE FROM %s WHERE k=1;", version, this);
+        updateView("DELETE FROM %s WHERE k=1;");
 
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
 
         assertEmpty(execute("SELECT * from %s"));
-        assertEmpty(execute("SELECT * from mv"));
+        assertEmpty(execute("SELECT * from " + mv));
     }
     @Test
     public void testUnselectedColumnsTTLWithFlush() throws Throwable
@@ -194,47 +149,44 @@ public class ViewComplexTTLTest extends CQLTester
         executeNet(version, "USE " + keyspace());
         Keyspace ks = Keyspace.open(keyspace());
 
-        createView("mv",
-                   "CREATE MATERIALIZED VIEW %s AS SELECT p, c FROM %%s WHERE p IS NOT NULL AND c IS NOT NULL PRIMARY KEY (c, p);",
-                   version,
-                   this,
-                   views);
-        ks.getColumnFamilyStore("mv").disableAutoCompaction();
+        String mv = createView("CREATE MATERIALIZED VIEW %s AS SELECT p, c FROM %%s " +
+                               "WHERE p IS NOT NULL AND c IS NOT NULL PRIMARY KEY (c, p)");
+        ks.getColumnFamilyStore(mv).disableAutoCompaction();
 
-        updateViewWithFlush("INSERT INTO %s (p, c) VALUES (0, 0) USING TTL 3;", flush, version, this);
+        updateViewWithFlush("INSERT INTO %s (p, c) VALUES (0, 0) USING TTL 3;", flush);
 
-        updateViewWithFlush("UPDATE %s USING TTL 1000 SET v = 0 WHERE p = 0 and c = 0;", flush, version, this);
+        updateViewWithFlush("UPDATE %s USING TTL 1000 SET v = 0 WHERE p = 0 and c = 0;", flush);
 
-        assertRowsIgnoringOrder(execute("SELECT * from mv WHERE c = ? AND p = ?", 0, 0), row(0, 0));
+        assertRowsIgnoringOrder(execute("SELECT * from " + mv + " WHERE c = ? AND p = ?", 0, 0), row(0, 0));
 
         Thread.sleep(3000);
 
         UntypedResultSet.Row row = execute("SELECT v, ttl(v) from %s WHERE c = ? AND p = ?", 0, 0).one();
-        assertTrue("row should have value of 0", row.getInt("v") == 0);
+        assertEquals("row should have value of 0", 0, row.getInt("v"));
         assertTrue("row should have ttl less than 1000", row.getInt("ttl(v)") < 1000);
-        assertRowsIgnoringOrder(execute("SELECT * from mv WHERE c = ? AND p = ?", 0, 0), row(0, 0));
+        assertRowsIgnoringOrder(execute("SELECT * from " + mv + " WHERE c = ? AND p = ?", 0, 0), row(0, 0));
 
-        updateViewWithFlush("DELETE FROM %s WHERE p = 0 and c = 0;", flush, version, this);
-        assertRowsIgnoringOrder(execute("SELECT * from mv WHERE c = ? AND p = ?", 0, 0));
+        updateViewWithFlush("DELETE FROM %s WHERE p = 0 and c = 0;", flush);
+        assertRowsIgnoringOrder(execute("SELECT * from " + mv + " WHERE c = ? AND p = ?", 0, 0));
 
-        updateViewWithFlush("INSERT INTO %s (p, c) VALUES (0, 0) ", flush, version, this);
-        assertRowsIgnoringOrder(execute("SELECT * from mv WHERE c = ? AND p = ?", 0, 0), row(0, 0));
+        updateViewWithFlush("INSERT INTO %s (p, c) VALUES (0, 0) ", flush);
+        assertRowsIgnoringOrder(execute("SELECT * from " + mv + " WHERE c = ? AND p = ?", 0, 0), row(0, 0));
 
         // already have a live row, no need to apply the unselected cell ttl
-        updateViewWithFlush("UPDATE %s USING TTL 3 SET v = 0 WHERE p = 0 and c = 0;", flush, version, this);
-        assertRowsIgnoringOrder(execute("SELECT * from mv WHERE c = ? AND p = ?", 0, 0), row(0, 0));
+        updateViewWithFlush("UPDATE %s USING TTL 3 SET v = 0 WHERE p = 0 and c = 0;", flush);
+        assertRowsIgnoringOrder(execute("SELECT * from " + mv + " WHERE c = ? AND p = ?", 0, 0), row(0, 0));
 
-        updateViewWithFlush("INSERT INTO %s (p, c) VALUES (1, 1) USING TTL 3", flush, version, this);
-        assertRowsIgnoringOrder(execute("SELECT * from mv WHERE c = ? AND p = ?", 1, 1), row(1, 1));
+        updateViewWithFlush("INSERT INTO %s (p, c) VALUES (1, 1) USING TTL 3", flush);
+        assertRowsIgnoringOrder(execute("SELECT * from " + mv + " WHERE c = ? AND p = ?", 1, 1), row(1, 1));
 
         Thread.sleep(4000);
 
-        assertRowsIgnoringOrder(execute("SELECT * from mv WHERE c = ? AND p = ?", 0, 0), row(0, 0));
-        assertRowsIgnoringOrder(execute("SELECT * from mv WHERE c = ? AND p = ?", 1, 1));
+        assertRowsIgnoringOrder(execute("SELECT * from " + mv + " WHERE c = ? AND p = ?", 0, 0), row(0, 0));
+        assertRowsIgnoringOrder(execute("SELECT * from " + mv + " WHERE c = ? AND p = ?", 1, 1));
 
         // unselected should keep view row alive
-        updateViewWithFlush("UPDATE %s SET v = 0 WHERE p = 1 and c = 1;", flush, version, this);
-        assertRowsIgnoringOrder(execute("SELECT * from mv WHERE c = ? AND p = ?", 1, 1), row(1, 1));
+        updateViewWithFlush("UPDATE %s SET v = 0 WHERE p = 1 and c = 1;", flush);
+        assertRowsIgnoringOrder(execute("SELECT * from " + mv + " WHERE c = ? AND p = ?", 1, 1), row(1, 1));
 
     } 
 
@@ -248,11 +200,11 @@ public class ViewComplexTTLTest extends CQLTester
         executeNet(version, "USE " + keyspace());
         Keyspace ks = Keyspace.open(keyspace());
 
-        updateView("INSERT INTO %s (p, c, v) VALUES (0, 0, 0) using timestamp 1;", version, this);
+        updateView("INSERT INTO %s (p, c, v) VALUES (0, 0, 0) using timestamp 1;");
 
         FBUtilities.waitOnFutures(ks.flush());
 
-        updateView("INSERT INTO %s (p, c, v) VALUES (0, 0, 0) USING TTL 3 and timestamp 1;", version, this);
+        updateView("INSERT INTO %s (p, c, v) VALUES (0, 0, 0) USING TTL 3 and timestamp 1;");
 
         FBUtilities.waitOnFutures(ks.flush());
 
@@ -263,11 +215,11 @@ public class ViewComplexTTLTest extends CQLTester
         // reversed order
         execute("truncate %s;");
 
-        updateView("INSERT INTO %s (p, c, v) VALUES (0, 0, 0) USING TTL 3 and timestamp 1;", version, this);
+        updateView("INSERT INTO %s (p, c, v) VALUES (0, 0, 0) USING TTL 3 and timestamp 1;");
 
         FBUtilities.waitOnFutures(ks.flush());
 
-        updateView("INSERT INTO %s (p, c, v) VALUES (0, 0, 0) USING timestamp 1;", version, this);
+        updateView("INSERT INTO %s (p, c, v) VALUES (0, 0, 0) USING timestamp 1;");
 
         FBUtilities.waitOnFutures(ks.flush());
 
diff --git a/test/unit/org/apache/cassandra/cql3/ViewComplexTest.java b/test/unit/org/apache/cassandra/cql3/ViewComplexTest.java
index ea05eef50c..27cbf07826 100644
--- a/test/unit/org/apache/cassandra/cql3/ViewComplexTest.java
+++ b/test/unit/org/apache/cassandra/cql3/ViewComplexTest.java
@@ -21,7 +21,6 @@ package org.apache.cassandra.cql3;
 import java.nio.ByteBuffer;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collection;
 import java.util.Comparator;
 import java.util.HashMap;
 import java.util.Iterator;
@@ -30,21 +29,12 @@ import java.util.Map;
 import java.util.stream.Collectors;
 
 import com.google.common.base.Objects;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.BeforeClass;
 import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
 
-import com.datastax.driver.core.exceptions.OperationTimedOutException;
-import org.apache.cassandra.concurrent.SEPExecutor;
-import org.apache.cassandra.concurrent.Stage;
 import org.apache.cassandra.db.ColumnFamilyStore;
 import org.apache.cassandra.db.Keyspace;
 import org.apache.cassandra.db.compaction.CompactionManager;
-import org.apache.cassandra.transport.ProtocolVersion;
+import org.apache.cassandra.io.sstable.format.SSTableReader;
 import org.apache.cassandra.utils.FBUtilities;
 
 import static org.junit.Assert.fail;
@@ -57,85 +47,8 @@ import static org.junit.Assert.fail;
  * - ViewComplexTest
  * - ViewComplexLivenessTest
  */
-@RunWith(Parameterized.class)
-public class ViewComplexTest extends CQLTester
+public class ViewComplexTest extends ViewComplexTester
 {
-    @Parameterized.Parameter
-    public ProtocolVersion version;
-
-    @Parameterized.Parameters()
-    public static Collection<Object[]> versions()
-    {
-        return ProtocolVersion.SUPPORTED.stream()
-                                        .map(v -> new Object[]{v})
-                                        .collect(Collectors.toList());
-    }
-
-    private final List<String> views = new ArrayList<>();
-
-    @BeforeClass
-    public static void startup()
-    {
-        requireNetwork();
-    }
-
-    @Before
-    public void begin()
-    {
-        beginSetup(views);
-    }
-
-    public static void beginSetup(List<String> views)
-    {
-        views.clear();
-    }
-
-    @After
-    public void end() throws Throwable
-    {
-        endTearDown(views, version, this);
-    }
-
-    public static void endTearDown(List<String> views, ProtocolVersion version, CQLTester cqlTester) throws Throwable
-    {
-        for (String viewName : views)
-            cqlTester.executeNet(version, "DROP MATERIALIZED VIEW " + viewName);
-    }
-
-    public static void createView(String name, String query, ProtocolVersion version, CQLTester cqlTester, List<String> views) throws Throwable
-    {
-        try
-        {
-            cqlTester.executeNet(version, String.format(query, name));
-            // If exception is thrown, the view will not be added to the list; since it shouldn't have been created, this is
-            // the desired behavior
-            views.add(name);
-        }
-        catch (OperationTimedOutException ex)
-        {
-            // ... except for timeout, when we actually do not know whether the view was created or not
-            views.add(name);
-            throw ex;
-        }
-    }
-
-    public static void updateView(String query, ProtocolVersion version, CQLTester cqlTester, Object... params) throws Throwable
-    {
-        updateViewWithFlush(query, false, version, cqlTester, params);
-    }
-
-    public static void updateViewWithFlush(String query, boolean flush, ProtocolVersion version, CQLTester cqlTester, Object... params) throws Throwable
-    {
-        cqlTester.executeNet(version, query, params);
-        while (!(((SEPExecutor) Stage.VIEW_MUTATION.executor()).getPendingTaskCount() == 0
-                && ((SEPExecutor) Stage.VIEW_MUTATION.executor()).getActiveTaskCount() == 0))
-        {
-            Thread.sleep(1);
-        }
-        if (flush)
-            Keyspace.open(cqlTester.keyspace()).flush();
-    }
-
     @Test
     public void testNonBaseColumnInViewPkWithFlush() throws Throwable
     {
@@ -145,10 +58,10 @@ public class ViewComplexTest extends CQLTester
     @Test
     public void testNonBaseColumnInViewPkWithoutFlush() throws Throwable
     {
-        testNonBaseColumnInViewPk(true);
+        testNonBaseColumnInViewPk(false);
     }
 
-    public void testNonBaseColumnInViewPk(boolean flush) throws Throwable
+    private void testNonBaseColumnInViewPk(boolean flush) throws Throwable
     {
         createTable("create table %s (p1 int, p2 int, v1 int, v2 int, primary key (p1,p2))");
 
@@ -156,50 +69,47 @@ public class ViewComplexTest extends CQLTester
         executeNet(version, "USE " + keyspace());
         Keyspace ks = Keyspace.open(keyspace());
 
-        createView("mv",
-                   "create materialized view %s as select * from %%s where p1 is not null and p2 is not null primary key (p2, p1)"
-                           + " with gc_grace_seconds=5;",
-                   version,
-                   this,
-                   views);
-        ColumnFamilyStore cfs = ks.getColumnFamilyStore("mv");
+        String mv = createView("create materialized view %s as select * from %%s " +
+                               "where p1 is not null and p2 is not null primary key (p2, p1) " +
+                               "with gc_grace_seconds=5");
+        ColumnFamilyStore cfs = ks.getColumnFamilyStore(mv);
         cfs.disableAutoCompaction();
 
-        updateView("UPDATE %s USING TIMESTAMP 1 set v1 =1 where p1 = 1 AND p2 = 1;", version, this);
+        updateView("UPDATE %s USING TIMESTAMP 1 set v1 =1 where p1 = 1 AND p2 = 1;");
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
         assertRowsIgnoringOrder(execute("SELECT p1, p2, v1, v2 from %s"), row(1, 1, 1, null));
-        assertRowsIgnoringOrder(execute("SELECT p1, p2, v1, v2 from mv"), row(1, 1, 1, null));
+        assertRowsIgnoringOrder(execute("SELECT p1, p2, v1, v2 from " + mv), row(1, 1, 1, null));
 
-        updateView("UPDATE %s USING TIMESTAMP 2 set v1 = null, v2 = 1 where p1 = 1 AND p2 = 1;", version, this);
+        updateView("UPDATE %s USING TIMESTAMP 2 set v1 = null, v2 = 1 where p1 = 1 AND p2 = 1;");
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
         assertRowsIgnoringOrder(execute("SELECT p1, p2, v1, v2 from %s"), row(1, 1, null, 1));
-        assertRowsIgnoringOrder(execute("SELECT p1, p2, v1, v2 from mv"), row(1, 1, null, 1));
+        assertRowsIgnoringOrder(execute("SELECT p1, p2, v1, v2 from " + mv), row(1, 1, null, 1));
 
-        updateView("UPDATE %s USING TIMESTAMP 2 set v2 = null where p1 = 1 AND p2 = 1;", version, this);
+        updateView("UPDATE %s USING TIMESTAMP 2 set v2 = null where p1 = 1 AND p2 = 1;");
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
         assertRowsIgnoringOrder(execute("SELECT p1, p2, v1, v2 from %s"));
-        assertRowsIgnoringOrder(execute("SELECT p1, p2, v1, v2 from mv"));
+        assertRowsIgnoringOrder(execute("SELECT p1, p2, v1, v2 from " + mv));
 
-        updateView("INSERT INTO %s (p1,p2) VALUES(1,1) USING TIMESTAMP 3;", version, this);
+        updateView("INSERT INTO %s (p1,p2) VALUES(1,1) USING TIMESTAMP 3;");
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
         assertRowsIgnoringOrder(execute("SELECT p1, p2, v1, v2 from %s"), row(1, 1, null, null));
-        assertRowsIgnoringOrder(execute("SELECT p1, p2, v1, v2 from mv"), row(1, 1, null, null));
+        assertRowsIgnoringOrder(execute("SELECT p1, p2, v1, v2 from " + mv), row(1, 1, null, null));
 
-        updateView("DELETE FROM %s USING TIMESTAMP 4 WHERE p1 =1 AND p2 = 1;", version, this);
+        updateView("DELETE FROM %s USING TIMESTAMP 4 WHERE p1 =1 AND p2 = 1;");
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
         assertRowsIgnoringOrder(execute("SELECT p1, p2, v1, v2 from %s"));
-        assertRowsIgnoringOrder(execute("SELECT p1, p2, v1, v2 from mv"));
+        assertRowsIgnoringOrder(execute("SELECT p1, p2, v1, v2 from " + mv));
 
-        updateView("UPDATE %s USING TIMESTAMP 5 set v2 = 1 where p1 = 1 AND p2 = 1;", version, this);
+        updateView("UPDATE %s USING TIMESTAMP 5 set v2 = 1 where p1 = 1 AND p2 = 1;");
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
         assertRowsIgnoringOrder(execute("SELECT p1, p2, v1, v2 from %s"), row(1, 1, null, 1));
-        assertRowsIgnoringOrder(execute("SELECT p1, p2, v1, v2 from mv"), row(1, 1, null, 1));
+        assertRowsIgnoringOrder(execute("SELECT p1, p2, v1, v2 from " + mv), row(1, 1, null, 1));
     }
 
     @Test
@@ -222,58 +132,55 @@ public class ViewComplexTest extends CQLTester
         executeNet(version, "USE " + keyspace());
         Keyspace ks = Keyspace.open(keyspace());
 
-        createView("mv",
-                   "create materialized view %s as select * from %%s where p is not null and v1 is not null primary key (v1, p);",
-                   version,
-                   this,
-                   views);
-        ks.getColumnFamilyStore("mv").disableAutoCompaction();
+        String mv = createView("create materialized view %s as select * from %%s " +
+                               "where p is not null and v1 is not null primary key (v1, p)");
+        ks.getColumnFamilyStore(mv).disableAutoCompaction();
 
         // sstable 1, Set initial values TS=1
-        updateView("Insert into %s (p, v1, v2) values (3, 1, 3) using timestamp 1;", version, this);
+        updateView("Insert into %s (p, v1, v2) values (3, 1, 3) using timestamp 1;");
 
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
 
-        assertRowsIgnoringOrder(execute("SELECT v2, WRITETIME(v2) from mv WHERE v1 = ? AND p = ?", 1, 3), row(3, 1L));
+        assertRowsIgnoringOrder(execute("SELECT v2, WRITETIME(v2) from " + mv + " WHERE v1 = ? AND p = ?", 1, 3), row(3, 1L));
         // sstable 2
-        updateView("UPdate %s using timestamp 2 set v2 = null where p = 3", version, this);
+        updateView("UPdate %s using timestamp 2 set v2 = null where p = 3");
 
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
 
-        assertRowsIgnoringOrder(execute("SELECT v2, WRITETIME(v2) from mv WHERE v1 = ? AND p = ?", 1, 3),
+        assertRowsIgnoringOrder(execute("SELECT v2, WRITETIME(v2) from " + mv + " WHERE v1 = ? AND p = ?", 1, 3),
                                 row(null, null));
         // sstable 3
-        updateView("UPdate %s using timestamp 3 set v1 = 2 where p = 3", version, this);
+        updateView("UPdate %s using timestamp 3 set v1 = 2 where p = 3");
 
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
 
-        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from mv"), row(2, 3, null, null));
+        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from " + mv), row(2, 3, null, null));
         // sstable 4
-        updateView("UPdate %s using timestamp 4 set v1 = 1 where p = 3", version, this);
+        updateView("UPdate %s using timestamp 4 set v1 = 1 where p = 3");
 
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
 
-        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from mv"), row(1, 3, null, null));
+        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from " + mv), row(1, 3, null, null));
 
         if (flush)
         {
             // compact sstable 2 and 3;
-            ColumnFamilyStore cfs = ks.getColumnFamilyStore("mv");
+            ColumnFamilyStore cfs = ks.getColumnFamilyStore(mv);
             List<String> sstables = cfs.getLiveSSTables()
                                        .stream()
                                        .sorted(Comparator.comparingInt(s -> s.descriptor.generation))
-                                       .map(s -> s.getFilename())
+                                       .map(SSTableReader::getFilename)
                                        .collect(Collectors.toList());
             String dataFiles = String.join(",", Arrays.asList(sstables.get(1), sstables.get(2)));
             CompactionManager.instance.forceUserDefinedCompaction(dataFiles);
         }
         // cell-tombstone in sstable 4 is not compacted away, because the shadowable tombstone is shadowed by new row.
-        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from mv"), row(1, 3, null, null));
-        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from mv limit 1"), row(1, 3, null, null));
+        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from " + mv), row(1, 3, null, null));
+        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from " + mv + " limit 1"), row(1, 3, null, null));
     }
 
     @Test
@@ -313,58 +220,57 @@ public class ViewComplexTest extends CQLTester
 
         for (int i = 0; i < mvStatements.size(); i++)
         {
-            String name = "mv" + i;
+            String name = createView(mvStatements.get(i));
             viewNames.add(name);
-            createView(name, mvStatements.get(i), version, this, views);
             ks.getColumnFamilyStore(name).disableAutoCompaction();
         }
 
         // insert
-        updateViewWithFlush("INSERT INTO %s (a,b,c,d,e,f) VALUES(1,1,1,1,1,1) using timestamp 1", flush, version, this);
+        updateViewWithFlush("INSERT INTO %s (a,b,c,d,e,f) VALUES(1,1,1,1,1,1) using timestamp 1", flush);
         assertBaseViews(row(1, 1, 1, 1, 1, 1), viewNames);
 
-        updateViewWithFlush("UPDATE %s using timestamp 2 SET c=0, d=0 WHERE a=1 AND b=1", flush, version, this);
+        updateViewWithFlush("UPDATE %s using timestamp 2 SET c=0, d=0 WHERE a=1 AND b=1", flush);
         assertBaseViews(row(1, 1, 0, 0, 1, 1), viewNames);
 
-        updateViewWithFlush("UPDATE %s using timestamp 2 SET e=0, f=0 WHERE a=1 AND b=1", flush, version, this);
+        updateViewWithFlush("UPDATE %s using timestamp 2 SET e=0, f=0 WHERE a=1 AND b=1", flush);
         assertBaseViews(row(1, 1, 0, 0, 0, 0), viewNames);
 
-        updateViewWithFlush("DELETE FROM %s using timestamp 2 WHERE a=1 AND b=1", flush, version, this);
+        updateViewWithFlush("DELETE FROM %s using timestamp 2 WHERE a=1 AND b=1", flush);
         assertBaseViews(null, viewNames);
 
         // partial update unselected, selected
-        updateViewWithFlush("UPDATE %s using timestamp 3 SET f=1 WHERE a=1 AND b=1", flush, version, this);
+        updateViewWithFlush("UPDATE %s using timestamp 3 SET f=1 WHERE a=1 AND b=1", flush);
         assertBaseViews(row(1, 1, null, null, null, 1), viewNames);
 
-        updateViewWithFlush("UPDATE %s using timestamp 4 SET e = 1, f=null WHERE a=1 AND b=1", flush, version, this);
+        updateViewWithFlush("UPDATE %s using timestamp 4 SET e = 1, f=null WHERE a=1 AND b=1", flush);
         assertBaseViews(row(1, 1, null, null, 1, null), viewNames);
 
-        updateViewWithFlush("UPDATE %s using timestamp 4 SET e = null WHERE a=1 AND b=1", flush, version, this);
+        updateViewWithFlush("UPDATE %s using timestamp 4 SET e = null WHERE a=1 AND b=1", flush);
         assertBaseViews(null, viewNames);
 
-        updateViewWithFlush("UPDATE %s using timestamp 5 SET c = 1 WHERE a=1 AND b=1", flush, version, this);
+        updateViewWithFlush("UPDATE %s using timestamp 5 SET c = 1 WHERE a=1 AND b=1", flush);
         assertBaseViews(row(1, 1, 1, null, null, null), viewNames);
 
-        updateViewWithFlush("UPDATE %s using timestamp 5 SET c = null WHERE a=1 AND b=1", flush, version, this);
+        updateViewWithFlush("UPDATE %s using timestamp 5 SET c = null WHERE a=1 AND b=1", flush);
         assertBaseViews(null, viewNames);
 
-        updateViewWithFlush("UPDATE %s using timestamp 6 SET d = 1 WHERE a=1 AND b=1", flush, version, this);
+        updateViewWithFlush("UPDATE %s using timestamp 6 SET d = 1 WHERE a=1 AND b=1", flush);
         assertBaseViews(row(1, 1, null, 1, null, null), viewNames);
 
-        updateViewWithFlush("UPDATE %s using timestamp 7 SET d = null WHERE a=1 AND b=1", flush, version, this);
+        updateViewWithFlush("UPDATE %s using timestamp 7 SET d = null WHERE a=1 AND b=1", flush);
         assertBaseViews(null, viewNames);
 
-        updateViewWithFlush("UPDATE %s using timestamp 8 SET f = 1 WHERE a=1 AND b=1", flush, version, this);
+        updateViewWithFlush("UPDATE %s using timestamp 8 SET f = 1 WHERE a=1 AND b=1", flush);
         assertBaseViews(row(1, 1, null, null, null, 1), viewNames);
 
-        updateViewWithFlush("UPDATE %s using timestamp 6 SET c = 1 WHERE a=1 AND b=1", flush, version, this);
+        updateViewWithFlush("UPDATE %s using timestamp 6 SET c = 1 WHERE a=1 AND b=1", flush);
         assertBaseViews(row(1, 1, 1, null, null, 1), viewNames);
 
         // view row still alive due to c=1@6
-        updateViewWithFlush("UPDATE %s using timestamp 8 SET f = null WHERE a=1 AND b=1", flush, version, this);
+        updateViewWithFlush("UPDATE %s using timestamp 8 SET f = null WHERE a=1 AND b=1", flush);
         assertBaseViews(row(1, 1, 1, null, null, null), viewNames);
 
-        updateViewWithFlush("UPDATE %s using timestamp 6 SET c = null WHERE a=1 AND b=1", flush, version, this);
+        updateViewWithFlush("UPDATE %s using timestamp 6 SET c = null WHERE a=1 AND b=1", flush);
         assertBaseViews(null, viewNames);
     }
 
diff --git a/test/unit/org/apache/cassandra/cql3/ViewComplexTester.java b/test/unit/org/apache/cassandra/cql3/ViewComplexTester.java
new file mode 100644
index 0000000000..a934649f8e
--- /dev/null
+++ b/test/unit/org/apache/cassandra/cql3/ViewComplexTester.java
@@ -0,0 +1,130 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.cassandra.cql3;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.stream.Collectors;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import com.datastax.driver.core.exceptions.OperationTimedOutException;
+import org.apache.cassandra.concurrent.Stage;
+import org.apache.cassandra.db.Keyspace;
+import org.apache.cassandra.transport.ProtocolVersion;
+
+/* ViewComplexTest class has been split into multiple ones because of timeout issues (CASSANDRA-16670)
+ * Any changes here check if they apply to the other classes:
+ * - ViewComplexUpdatesTest
+ * - ViewComplexDeletionsTest
+ * - ViewComplexTTLTest
+ * - ViewComplexTest
+ * - ViewComplexLivenessTest
+ */
+@RunWith(Parameterized.class)
+public abstract class ViewComplexTester extends CQLTester
+{
+    private static final AtomicInteger seqNumber = new AtomicInteger();
+
+    @Parameterized.Parameter
+    public ProtocolVersion version;
+
+    @Parameterized.Parameters()
+    public static Collection<Object[]> versions()
+    {
+        return ProtocolVersion.SUPPORTED.stream()
+                                        .map(v -> new Object[]{v})
+                                        .collect(Collectors.toList());
+    }
+
+    protected final List<String> views = new ArrayList<>();
+
+    @BeforeClass
+    public static void startup()
+    {
+        requireNetwork();
+    }
+
+    @Before
+    public void begin() throws Throwable
+    {
+        views.clear();
+    }
+
+    @After
+    public void end() throws Throwable
+    {
+        dropMViews();
+    }
+
+    protected void dropMViews() throws Throwable
+    {
+        for (String viewName : views)
+            executeNet(version, "DROP MATERIALIZED VIEW " + viewName);
+    }
+
+    protected String createView(String query) throws Throwable
+    {
+        String name = createViewName();
+
+        try
+        {
+            executeNet(version, String.format(query, name));
+            // If exception is thrown, the view will not be added to the list; since it shouldn't have been created, this is
+            // the desired behavior
+            views.add(name);
+        }
+        catch (OperationTimedOutException ex)
+        {
+            // ... except for timeout, when we actually do not know whether the view was created or not
+            views.add(name);
+            throw ex;
+        }
+
+        return name;
+    }
+
+    protected static String createViewName()
+    {
+        return "mv" + seqNumber.getAndIncrement();
+    }
+
+    protected void updateView(String query, Object... params) throws Throwable
+    {
+        updateViewWithFlush(query, false, params);
+    }
+
+    protected void updateViewWithFlush(String query, boolean flush, Object... params) throws Throwable
+    {
+        executeNet(version, query, params);
+        while (!(Stage.VIEW_MUTATION.executor().getPendingTaskCount() == 0
+                 && Stage.VIEW_MUTATION.executor().getActiveTaskCount() == 0))
+        {
+            Thread.sleep(1);
+        }
+        if (flush)
+            Keyspace.open(keyspace()).flush();
+    }
+}
diff --git a/test/unit/org/apache/cassandra/cql3/ViewComplexUpdatesTest.java b/test/unit/org/apache/cassandra/cql3/ViewComplexUpdatesTest.java
index f2a627df56..76ae3619f6 100644
--- a/test/unit/org/apache/cassandra/cql3/ViewComplexUpdatesTest.java
+++ b/test/unit/org/apache/cassandra/cql3/ViewComplexUpdatesTest.java
@@ -18,25 +18,13 @@
 
 package org.apache.cassandra.cql3;
 
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
 import java.util.concurrent.TimeUnit;
 
-import org.junit.After;
-import org.junit.Before;
-import org.junit.BeforeClass;
 import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
 
 import org.apache.cassandra.db.Keyspace;
-import org.apache.cassandra.transport.ProtocolVersion;
 import org.apache.cassandra.utils.FBUtilities;
 
-import static org.apache.cassandra.cql3.ViewComplexTest.createView;
-import static org.apache.cassandra.cql3.ViewComplexTest.updateView;
-
 /* ViewComplexTest class has been split into multiple ones because of timeout issues (CASSANDRA-16670)
  * Any changes here check if they apply to the other classes:
  * - ViewComplexUpdatesTest
@@ -45,38 +33,8 @@ import static org.apache.cassandra.cql3.ViewComplexTest.updateView;
  * - ViewComplexTest
  * - ViewComplexLivenessTest
  */
-@RunWith(Parameterized.class)
-public class ViewComplexUpdatesTest extends CQLTester
+public class ViewComplexUpdatesTest extends ViewComplexTester
 {
-    @Parameterized.Parameter
-    public ProtocolVersion version;
-
-    @Parameterized.Parameters()
-    public static Collection<Object[]> versions()
-    {
-        return ViewComplexTest.versions();
-    }
-
-    private final List<String> views = new ArrayList<>();
-
-    @BeforeClass
-    public static void startup()
-    {
-        ViewComplexTest.startup();
-    }
-
-    @Before
-    public void begin()
-    {
-        ViewComplexTest.beginSetup(views);
-    }
-
-    @After
-    public void end() throws Throwable
-    {
-        ViewComplexTest.endTearDown(views, version, this);
-    }
-
     @Test
     public void testUpdateColumnNotInViewWithFlush() throws Throwable
     {
@@ -99,90 +57,87 @@ public class ViewComplexUpdatesTest extends CQLTester
         executeNet(version, "USE " + keyspace());
         Keyspace ks = Keyspace.open(keyspace());
 
-        createView("mv",
-                   "CREATE MATERIALIZED VIEW %s AS SELECT p, c FROM %%s WHERE p IS NOT NULL AND c IS NOT NULL PRIMARY KEY (c, p);",
-                   version,
-                   this,
-                   views);
-        ks.getColumnFamilyStore("mv").disableAutoCompaction();
+        String mv = createView("CREATE MATERIALIZED VIEW %s AS SELECT p, c FROM %%s " +
+                               "WHERE p IS NOT NULL AND c IS NOT NULL PRIMARY KEY (c, p)");
+        ks.getColumnFamilyStore(mv).disableAutoCompaction();
 
-        updateView("UPDATE %s USING TIMESTAMP 0 SET v1 = 1 WHERE p = 0 AND c = 0", version, this);
+        updateView("UPDATE %s USING TIMESTAMP 0 SET v1 = 1 WHERE p = 0 AND c = 0");
 
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
 
         assertRowsIgnoringOrder(execute("SELECT * from %s WHERE c = ? AND p = ?", 0, 0), row(0, 0, 1, null));
-        assertRowsIgnoringOrder(execute("SELECT * from mv WHERE c = ? AND p = ?", 0, 0), row(0, 0));
+        assertRowsIgnoringOrder(execute("SELECT * from " + mv + " WHERE c = ? AND p = ?", 0, 0), row(0, 0));
 
-        updateView("DELETE v1 FROM %s USING TIMESTAMP 1 WHERE p = 0 AND c = 0", version, this);
+        updateView("DELETE v1 FROM %s USING TIMESTAMP 1 WHERE p = 0 AND c = 0");
 
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
 
         assertEmpty(execute("SELECT * from %s WHERE c = ? AND p = ?", 0, 0));
-        assertEmpty(execute("SELECT * from mv WHERE c = ? AND p = ?", 0, 0));
+        assertEmpty(execute("SELECT * from " + mv + " WHERE c = ? AND p = ?", 0, 0));
 
         // shadowed by tombstone
-        updateView("UPDATE %s USING TIMESTAMP 1 SET v1 = 1 WHERE p = 0 AND c = 0", version, this);
+        updateView("UPDATE %s USING TIMESTAMP 1 SET v1 = 1 WHERE p = 0 AND c = 0");
 
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
 
         assertEmpty(execute("SELECT * from %s WHERE c = ? AND p = ?", 0, 0));
-        assertEmpty(execute("SELECT * from mv WHERE c = ? AND p = ?", 0, 0));
+        assertEmpty(execute("SELECT * from " + mv + " WHERE c = ? AND p = ?", 0, 0));
 
-        updateView("UPDATE %s USING TIMESTAMP 2 SET v2 = 1 WHERE p = 0 AND c = 0", version, this);
+        updateView("UPDATE %s USING TIMESTAMP 2 SET v2 = 1 WHERE p = 0 AND c = 0");
 
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
 
         assertRowsIgnoringOrder(execute("SELECT * from %s WHERE c = ? AND p = ?", 0, 0), row(0, 0, null, 1));
-        assertRowsIgnoringOrder(execute("SELECT * from mv WHERE c = ? AND p = ?", 0, 0), row(0, 0));
+        assertRowsIgnoringOrder(execute("SELECT * from " + mv + " WHERE c = ? AND p = ?", 0, 0), row(0, 0));
 
-        updateView("DELETE v1 FROM %s USING TIMESTAMP 3 WHERE p = 0 AND c = 0", version, this);
+        updateView("DELETE v1 FROM %s USING TIMESTAMP 3 WHERE p = 0 AND c = 0");
 
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
 
         assertRowsIgnoringOrder(execute("SELECT * from %s WHERE c = ? AND p = ?", 0, 0), row(0, 0, null, 1));
-        assertRowsIgnoringOrder(execute("SELECT * from mv WHERE c = ? AND p = ?", 0, 0), row(0, 0));
+        assertRowsIgnoringOrder(execute("SELECT * from " + mv + " WHERE c = ? AND p = ?", 0, 0), row(0, 0));
 
-        updateView("DELETE v2 FROM %s USING TIMESTAMP 4 WHERE p = 0 AND c = 0", version, this);
+        updateView("DELETE v2 FROM %s USING TIMESTAMP 4 WHERE p = 0 AND c = 0");
 
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
 
         assertEmpty(execute("SELECT * from %s WHERE c = ? AND p = ?", 0, 0));
-        assertEmpty(execute("SELECT * from mv WHERE c = ? AND p = ?", 0, 0));
+        assertEmpty(execute("SELECT * from " + mv + " WHERE c = ? AND p = ?", 0, 0));
 
-        updateView("UPDATE %s USING TTL 3 SET v2 = 1 WHERE p = 0 AND c = 0", version, this);
+        updateView("UPDATE %s USING TTL 3 SET v2 = 1 WHERE p = 0 AND c = 0");
 
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
 
         assertRowsIgnoringOrder(execute("SELECT * from %s WHERE c = ? AND p = ?", 0, 0), row(0, 0, null, 1));
-        assertRowsIgnoringOrder(execute("SELECT * from mv WHERE c = ? AND p = ?", 0, 0), row(0, 0));
+        assertRowsIgnoringOrder(execute("SELECT * from " + mv + " WHERE c = ? AND p = ?", 0, 0), row(0, 0));
 
         Thread.sleep(TimeUnit.SECONDS.toMillis(3));
 
         assertRowsIgnoringOrder(execute("SELECT * from %s WHERE c = ? AND p = ?", 0, 0));
-        assertRowsIgnoringOrder(execute("SELECT * from mv WHERE c = ? AND p = ?", 0, 0));
+        assertRowsIgnoringOrder(execute("SELECT * from " + mv + " WHERE c = ? AND p = ?", 0, 0));
 
-        updateView("UPDATE %s SET v2 = 1 WHERE p = 0 AND c = 0", version, this);
+        updateView("UPDATE %s SET v2 = 1 WHERE p = 0 AND c = 0");
 
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
 
         assertRowsIgnoringOrder(execute("SELECT * from %s WHERE c = ? AND p = ?", 0, 0), row(0, 0, null, 1));
-        assertRowsIgnoringOrder(execute("SELECT * from mv WHERE c = ? AND p = ?", 0, 0), row(0, 0));
+        assertRowsIgnoringOrder(execute("SELECT * from " + mv + " WHERE c = ? AND p = ?", 0, 0), row(0, 0));
 
         assertInvalidMessage(String.format("Cannot drop column v2 on base table %s with materialized views", baseTable), "ALTER TABLE %s DROP v2");
         // // drop unselected base column, unselected metadata should be removed, thus view row is dead
         // updateView("ALTER TABLE %s DROP v2");
         // assertRowsIgnoringOrder(execute("SELECT * from %s WHERE c = ? AND p = ?", 0, 0));
-        // assertRowsIgnoringOrder(execute("SELECT * from mv WHERE c = ? AND p = ?", 0, 0));
+        // assertRowsIgnoringOrder(execute("SELECT * from " + mv + " WHERE c = ? AND p = ?", 0, 0));
         // assertRowsIgnoringOrder(execute("SELECT * from %s"));
-        // assertRowsIgnoringOrder(execute("SELECT * from mv"));
+        // assertRowsIgnoringOrder(execute("SELECT * from " + mv));
     }
 
     @Test
@@ -197,56 +152,53 @@ public class ViewComplexUpdatesTest extends CQLTester
         testPartialUpdateWithUnselectedCollections(false);
     }
 
-    public void testPartialUpdateWithUnselectedCollections(boolean flush) throws Throwable
+    private void testPartialUpdateWithUnselectedCollections(boolean flush) throws Throwable
     {
         execute("USE " + keyspace());
         executeNet(version, "USE " + keyspace());
         String baseTable = createTable("CREATE TABLE %s (k int, c int, a int, b int, l list<int>, s set<int>, m map<int,int>, PRIMARY KEY (k, c))");
-        createView("mv",
-                   "CREATE MATERIALIZED VIEW %s AS SELECT a, b, c, k FROM %%s WHERE k IS NOT NULL AND c IS NOT NULL PRIMARY KEY (c, k)",
-                   version,
-                   this,
-                   views);
+        String mv = createView("CREATE MATERIALIZED VIEW %s AS SELECT a, b, c, k FROM %%s " +
+                               "WHERE k IS NOT NULL AND c IS NOT NULL PRIMARY KEY (c, k)");
         Keyspace ks = Keyspace.open(keyspace());
-        ks.getColumnFamilyStore("mv").disableAutoCompaction();
+        ks.getColumnFamilyStore(mv).disableAutoCompaction();
 
-        updateView("UPDATE %s SET l=l+[1,2,3] WHERE k = 1 AND c = 1", version, this);
+        updateView("UPDATE %s SET l=l+[1,2,3] WHERE k = 1 AND c = 1");
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
-        assertRows(execute("SELECT * from mv"), row(1, 1, null, null));
+        assertRows(execute("SELECT * from " + mv), row(1, 1, null, null));
 
-        updateView("UPDATE %s SET l=l-[1,2] WHERE k = 1 AND c = 1", version, this);
+        updateView("UPDATE %s SET l=l-[1,2] WHERE k = 1 AND c = 1");
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
-        assertRows(execute("SELECT * from mv"), row(1, 1, null, null));
+        assertRows(execute("SELECT * from " + mv), row(1, 1, null, null));
 
-        updateView("UPDATE %s SET b=3 WHERE k=1 AND c=1", version, this);
+        updateView("UPDATE %s SET b=3 WHERE k=1 AND c=1");
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
-        assertRows(execute("SELECT * from mv"), row(1, 1, null, 3));
+        assertRows(execute("SELECT * from " + mv), row(1, 1, null, 3));
 
-        updateView("UPDATE %s SET b=null, l=l-[3], s=s-{3} WHERE k = 1 AND c = 1", version, this);
+        updateView("UPDATE %s SET b=null, l=l-[3], s=s-{3} WHERE k = 1 AND c = 1");
         if (flush)
         {
             FBUtilities.waitOnFutures(ks.flush());
-            ks.getColumnFamilyStore("mv").forceMajorCompaction();
+            ks.getColumnFamilyStore(mv).forceMajorCompaction();
         }
         assertRowsIgnoringOrder(execute("SELECT k,c,a,b from %s"));
-        assertRowsIgnoringOrder(execute("SELECT * from mv"));
+        assertRowsIgnoringOrder(execute("SELECT * from " + mv));
 
-        updateView("UPDATE %s SET m=m+{3:3}, l=l-[1], s=s-{2} WHERE k = 1 AND c = 1", version, this);
+        updateView("UPDATE %s SET m=m+{3:3}, l=l-[1], s=s-{2} WHERE k = 1 AND c = 1");
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
         assertRowsIgnoringOrder(execute("SELECT k,c,a,b from %s"), row(1, 1, null, null));
-        assertRowsIgnoringOrder(execute("SELECT * from mv"), row(1, 1, null, null));
+        assertRowsIgnoringOrder(execute("SELECT * from " + mv), row(1, 1, null, null));
 
         assertInvalidMessage(String.format("Cannot drop column m on base table %s with materialized views", baseTable), "ALTER TABLE %s DROP m");
         // executeNet(version, "ALTER TABLE %s DROP m");
-        // ks.getColumnFamilyStore("mv").forceMajorCompaction();
+        // ks.getColumnFamilyStore(mv).forceMajorCompaction();
         // assertRowsIgnoringOrder(execute("SELECT k,c,a,b from %s WHERE k = 1 AND c = 1"));
-        // assertRowsIgnoringOrder(execute("SELECT * from mv WHERE k = 1 AND c = 1"));
+        // assertRowsIgnoringOrder(execute("SELECT * from " + mv + " WHERE k = 1 AND c = 1"));
         // assertRowsIgnoringOrder(execute("SELECT k,c,a,b from %s"));
-        // assertRowsIgnoringOrder(execute("SELECT * from mv"));
+        // assertRowsIgnoringOrder(execute("SELECT * from " + mv));
     }
 
     @Test
@@ -261,7 +213,7 @@ public class ViewComplexUpdatesTest extends CQLTester
         testUpdateWithColumnTimestampSmallerThanPk(false);
     }
 
-    public void testUpdateWithColumnTimestampSmallerThanPk(boolean flush) throws Throwable
+    private void testUpdateWithColumnTimestampSmallerThanPk(boolean flush) throws Throwable
     {
         createTable("create table %s (p int primary key, v1 int, v2 int)");
 
@@ -269,34 +221,31 @@ public class ViewComplexUpdatesTest extends CQLTester
         executeNet(version, "USE " + keyspace());
         Keyspace ks = Keyspace.open(keyspace());
 
-        createView("mv",
-                   "create materialized view %s as select * from %%s where p is not null and v1 is not null primary key (v1, p);",
-                   version,
-                   this,
-                   views);
-        ks.getColumnFamilyStore("mv").disableAutoCompaction();
+        String mv = createView("create materialized view %s as select * from %%s " +
+                               "where p is not null and v1 is not null primary key (v1, p)");
+        ks.getColumnFamilyStore(mv).disableAutoCompaction();
 
         // reset value
-        updateView("Insert into %s (p, v1, v2) values (3, 1, 3) using timestamp 6;", version, this);
+        updateView("Insert into %s (p, v1, v2) values (3, 1, 3) using timestamp 6;");
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
-        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from mv"), row(1, 3, 3, 6L));
+        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from " + mv), row(1, 3, 3, 6L));
         // increase pk's timestamp to 20
-        updateView("Insert into %s (p) values (3) using timestamp 20;", version, this);
+        updateView("Insert into %s (p) values (3) using timestamp 20;");
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
-        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from mv"), row(1, 3, 3, 6L));
+        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from " + mv), row(1, 3, 3, 6L));
         // change v1's to 2 and remove existing view row with ts7
-        updateView("UPdate %s using timestamp 7 set v1 = 2 where p = 3;", version, this);
+        updateView("UPdate %s using timestamp 7 set v1 = 2 where p = 3;");
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
-        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from mv"), row(2, 3, 3, 6L));
-        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from mv limit 1"), row(2, 3, 3, 6L));
+        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from " + mv), row(2, 3, 3, 6L));
+        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from " + mv + " limit 1"), row(2, 3, 3, 6L));
         // change v1's to 1 and remove existing view row with ts8
-        updateView("UPdate %s using timestamp 8 set v1 = 1 where p = 3;", version, this);
+        updateView("UPdate %s using timestamp 8 set v1 = 1 where p = 3;");
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
-        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from mv"), row(1, 3, 3, 6L));
+        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from " + mv), row(1, 3, 3, 6L));
     }
 
     @Test
@@ -313,7 +262,7 @@ public class ViewComplexUpdatesTest extends CQLTester
         testUpdateWithColumnTimestampBiggerThanPk(false);
     }
 
-    public void testUpdateWithColumnTimestampBiggerThanPk(boolean flush) throws Throwable
+    private void testUpdateWithColumnTimestampBiggerThanPk(boolean flush) throws Throwable
     {
         // CASSANDRA-11500 able to shadow old view row with column ts greater tahn pk's ts and re-insert the view row
         String baseTable = createTable("CREATE TABLE %s (k int PRIMARY KEY, a int, b int);");
@@ -322,50 +271,47 @@ public class ViewComplexUpdatesTest extends CQLTester
         executeNet(version, "USE " + keyspace());
         Keyspace ks = Keyspace.open(keyspace());
 
-        createView("mv",
-                   "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE k IS NOT NULL AND a IS NOT NULL PRIMARY KEY (k, a);",
-                   version,
-                   this,
-                   views);
-        ks.getColumnFamilyStore("mv").disableAutoCompaction();
-        updateView("DELETE FROM %s USING TIMESTAMP 0 WHERE k = 1;", version, this);
+        String mv = createView("CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s " +
+                               "WHERE k IS NOT NULL AND a IS NOT NULL PRIMARY KEY (k, a)");
+        ks.getColumnFamilyStore(mv).disableAutoCompaction();
+        updateView("DELETE FROM %s USING TIMESTAMP 0 WHERE k = 1;");
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
         // sstable-1, Set initial values TS=1
-        updateView("INSERT INTO %s(k, a, b) VALUES (1, 1, 1) USING TIMESTAMP 1;", version, this);
+        updateView("INSERT INTO %s(k, a, b) VALUES (1, 1, 1) USING TIMESTAMP 1;");
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
-        assertRowsIgnoringOrder(execute("SELECT k,a,b from mv"), row(1, 1, 1));
-        updateView("UPDATE %s USING TIMESTAMP 10 SET b = 2 WHERE k = 1;", version, this);
-        assertRowsIgnoringOrder(execute("SELECT k,a,b from mv"), row(1, 1, 2));
+        assertRowsIgnoringOrder(execute("SELECT k,a,b from " + mv), row(1, 1, 1));
+        updateView("UPDATE %s USING TIMESTAMP 10 SET b = 2 WHERE k = 1;");
+        assertRowsIgnoringOrder(execute("SELECT k,a,b from " + mv), row(1, 1, 2));
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
-        assertRowsIgnoringOrder(execute("SELECT k,a,b from mv"), row(1, 1, 2));
-        updateView("UPDATE %s USING TIMESTAMP 2 SET a = 2 WHERE k = 1;", version, this);
-        assertRowsIgnoringOrder(execute("SELECT k,a,b from mv"), row(1, 2, 2));
+        assertRowsIgnoringOrder(execute("SELECT k,a,b from " + mv), row(1, 1, 2));
+        updateView("UPDATE %s USING TIMESTAMP 2 SET a = 2 WHERE k = 1;");
+        assertRowsIgnoringOrder(execute("SELECT k,a,b from " + mv), row(1, 2, 2));
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
-        ks.getColumnFamilyStore("mv").forceMajorCompaction();
-        assertRowsIgnoringOrder(execute("SELECT k,a,b from mv"), row(1, 2, 2));
-        assertRowsIgnoringOrder(execute("SELECT k,a,b from mv limit 1"), row(1, 2, 2));
-        updateView("UPDATE %s USING TIMESTAMP 11 SET a = 1 WHERE k = 1;", version, this);
+        ks.getColumnFamilyStore(mv).forceMajorCompaction();
+        assertRowsIgnoringOrder(execute("SELECT k,a,b from " + mv), row(1, 2, 2));
+        assertRowsIgnoringOrder(execute("SELECT k,a,b from " + mv + " limit 1"), row(1, 2, 2));
+        updateView("UPDATE %s USING TIMESTAMP 11 SET a = 1 WHERE k = 1;");
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
-        assertRowsIgnoringOrder(execute("SELECT k,a,b from mv"), row(1, 1, 2));
+        assertRowsIgnoringOrder(execute("SELECT k,a,b from " + mv), row(1, 1, 2));
         assertRowsIgnoringOrder(execute("SELECT k,a,b from %s"), row(1, 1, 2));
 
         // set non-key base column as tombstone, view row is removed with shadowable
-        updateView("UPDATE %s USING TIMESTAMP 12 SET a = null WHERE k = 1;", version, this);
+        updateView("UPDATE %s USING TIMESTAMP 12 SET a = null WHERE k = 1;");
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
-        assertRowsIgnoringOrder(execute("SELECT k,a,b from mv"));
+        assertRowsIgnoringOrder(execute("SELECT k,a,b from " + mv));
         assertRowsIgnoringOrder(execute("SELECT k,a,b from %s"), row(1, null, 2));
 
         // column b should be alive
-        updateView("UPDATE %s USING TIMESTAMP 13 SET a = 1 WHERE k = 1;", version, this);
+        updateView("UPDATE %s USING TIMESTAMP 13 SET a = 1 WHERE k = 1;");
         if (flush)
             FBUtilities.waitOnFutures(ks.flush());
-        assertRowsIgnoringOrder(execute("SELECT k,a,b from mv"), row(1, 1, 2));
+        assertRowsIgnoringOrder(execute("SELECT k,a,b from " + mv), row(1, 1, 2));
         assertRowsIgnoringOrder(execute("SELECT k,a,b from %s"), row(1, 1, 2));
 
         assertInvalidMessage(String.format("Cannot drop column a on base table %s with materialized views", baseTable), "ALTER TABLE %s DROP a");
