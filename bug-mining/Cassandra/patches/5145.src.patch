diff --git a/CHANGES.txt b/CHANGES.txt
index 025d4b0ecb..063e8fb1a7 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 3.0.18
+ * Counters fail to increment in 2.1/2.2 to 3.X mixed version clusters (CASSANDRA-14958)
  * Streaming needs to synchronise access to LifecycleTransaction (CASSANDRA-14554)
  * Fix cassandra-stress write hang with default options (CASSANDRA-14616)
  * Differentiate between slices and RTs when decoding legacy bounds (CASSANDRA-14919)
diff --git a/src/java/org/apache/cassandra/db/LegacyLayout.java b/src/java/org/apache/cassandra/db/LegacyLayout.java
index 9600355a90..004495930a 100644
--- a/src/java/org/apache/cassandra/db/LegacyLayout.java
+++ b/src/java/org/apache/cassandra/db/LegacyLayout.java
@@ -514,7 +514,7 @@ public abstract class LegacyLayout
             else if (cell.isCounterUpdate())
             {
                 out.writeLong(cell.timestamp);
-                long count = CounterContext.instance().getLocalCount(cell.value);
+                long count = CounterContext.instance().getUpdateCount(cell.value);
                 ByteBufferUtil.writeWithLength(ByteBufferUtil.bytes(count), out);
                 continue;
             }
@@ -585,7 +585,7 @@ public abstract class LegacyLayout
             else if (cell.isCounterUpdate())
             {
                 size += TypeSizes.sizeof(cell.timestamp);
-                long count = CounterContext.instance().getLocalCount(cell.value);
+                long count = CounterContext.instance().getUpdateCount(cell.value);
                 size += ByteBufferUtil.serializedSizeWithLength(ByteBufferUtil.bytes(count));
                 continue;
             }
diff --git a/src/java/org/apache/cassandra/db/context/CounterContext.java b/src/java/org/apache/cassandra/db/context/CounterContext.java
index b40246455d..d0952d06c9 100644
--- a/src/java/org/apache/cassandra/db/context/CounterContext.java
+++ b/src/java/org/apache/cassandra/db/context/CounterContext.java
@@ -136,6 +136,14 @@ public class CounterContext
         return ContextState.wrap(context).getCounterId().equals(UPDATE_CLOCK_ID);
     }
 
+    /**
+     * Returns the count associated with the update counter id, or 0 if no such shard is present.
+     */
+    public long getUpdateCount(ByteBuffer context)
+    {
+        return getClockAndCountOf(context, UPDATE_CLOCK_ID).count;
+    }
+
     /**
      * Creates a counter context with a single global, 2.1+ shard (a result of increment).
      */
@@ -708,14 +716,6 @@ public class CounterContext
         return getClockAndCountOf(context, CounterId.getLocalId());
     }
 
-    /**
-     * Returns the count associated with the local counter id, or 0 if no such shard is present.
-     */
-    public long getLocalCount(ByteBuffer context)
-    {
-        return getLocalClockAndCount(context).count;
-    }
-
     /**
      * Returns the clock and the count associated with the given counter id, or (0, 0) if no such shard is present.
      */
