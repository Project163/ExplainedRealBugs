diff --git a/src/java/org/apache/cassandra/analytics/AnalyticsContext.java b/src/java/org/apache/cassandra/analytics/AnalyticsContext.java
deleted file mode 100644
index 2d61a7715a..0000000000
--- a/src/java/org/apache/cassandra/analytics/AnalyticsContext.java
+++ /dev/null
@@ -1,771 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.cassandra.analytics;
-
-import java.io.IOException;
-import java.net.DatagramPacket;
-import java.net.DatagramSocket;
-import java.net.InetSocketAddress;
-import java.net.SocketAddress;
-import java.net.SocketException;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Random;
-import java.util.Set;
-import java.util.Timer;
-import java.util.TimerTask;
-import java.util.TreeMap;
-import java.util.concurrent.locks.Lock;
-import java.util.concurrent.locks.ReentrantLock;
-
-import org.apache.cassandra.config.DatabaseDescriptor;
-import org.apache.cassandra.service.StorageService;
-import org.apache.cassandra.utils.LogUtil;
-import org.apache.log4j.Logger;
-
-
-
-/**
- * Context for sending metrics to Ganglia. This class drives the entire metric collection process.
- *
- * Author : Avinash Lakshman ( alakshman@facebook.com) & Prashant Malik ( pmalik@facebook.com ) & Karthik Ranganathan ( kranganathan@facebook.com )
- */
-public class AnalyticsContext
-{
-	private static Logger logger_ = Logger.getLogger(AnalyticsContext.class);
-
-	private static final String PERIOD_PROPERTY = "period";
-	private static final String SERVERS_PROPERTY = "servers";
-	private static final String UNITS_PROPERTY = "units";
-	private static final String SLOPE_PROPERTY = "slope";
-	private static final String TMAX_PROPERTY = "tmax";
-	private static final String DMAX_PROPERTY = "dmax";
-
-	private static final String DEFAULT_UNITS = "";
-	private static final String DEFAULT_SLOPE = "both";
-	private static final int DEFAULT_TMAX = 60;
-	private static final int DEFAULT_DMAX = 0;
-	private static final int DEFAULT_PORT = 8649;
-	private static final int BUFFER_SIZE = 1500;			 // as per libgmond.c
-
-	private static final Map<Class,String> typeTable_ = new HashMap<Class,String>(5);
-
-	private Map<String,RecordMap> bufferedData_ = new HashMap<String,RecordMap>();
-    /* Keeps the MetricRecord for each abstraction that implements IAnalyticsSource */
-    private Map<String, MetricsRecord> recordMap_ = new HashMap<String, MetricsRecord>();
-	private Map<String,Object> attributeMap_ = new HashMap<String,Object>();
-	private Set<IAnalyticsSource> updaters = new HashSet<IAnalyticsSource>(1);
-	private List<InetSocketAddress> metricsServers_;
-
-	private Map<String, String> unitsTable_;
-	private Map<String, String> slopeTable_;
-	private Map<String, String> tmaxTable_;
-	private Map<String, String> dmaxTable_;
-
-	/* singleton instance */
-	private static AnalyticsContext instance_;
-    /* Used to lock the factory for creation of StorageService instance */
-    private static Lock createLock_ = new ReentrantLock();
-
-	/**
-	 * Default period in seconds at which data is sent to the metrics system.
-	*/
-	private static final int DEFAULT_PERIOD = 5;
-
-	/**
-	 * Port to which we should write the data.
-	 */
-	private int port_ = DEFAULT_PORT;
-
-	private Timer timer = null;
-	private int period_ = DEFAULT_PERIOD;
-	private volatile boolean isMonitoring = false;
-	private byte[] buffer_ = new byte[BUFFER_SIZE];
-	private int offset_;
-
-	private DatagramSocket datagramSocket_;
-
-	static class TagMap extends TreeMap<String,Object>
-	{
-		private static final long serialVersionUID = 3546309335061952993L;
-		TagMap()
-		{
-			super();
-		}
-		TagMap(TagMap orig)
-		{
-			super(orig);
-		}
-	}
-
-	static class MetricMap extends TreeMap<String,Number>
-	{
-		private static final long serialVersionUID = -7495051861141631609L;
-	}
-
-	static class RecordMap extends HashMap<TagMap,MetricMap>
-	{
-		private static final long serialVersionUID = 259835619700264611L;
-	}
-
-	static
-	{
-		typeTable_.put(String.class, "string");
-		typeTable_.put(Byte.class, "int8");
-		typeTable_.put(Short.class, "int16");
-		typeTable_.put(Integer.class, "int32");
-		typeTable_.put(Float.class, "float");
-	}
-
-
-	/**
-	* Initializes the context.
-	*/
-	public void init(String contextName, String serverSpecList)
-	{
-		String periodStr = getAttribute(PERIOD_PROPERTY);
-
-		if (periodStr != null)
-		{
-			int period = 0;
-			try
-			{
-				period = Integer.parseInt(periodStr);
-			}
-			catch (NumberFormatException nfe)
-			{
-			}
-
-			if (period <= 0)
-			{
-				throw new AnalyticsException("Invalid period: " + periodStr);
-			}
-
-			setPeriod(period);
-		}
-
-		metricsServers_ = parse(serverSpecList, port_);
-		unitsTable_ = getAttributeTable(UNITS_PROPERTY);
-		slopeTable_ = getAttributeTable(SLOPE_PROPERTY);
-		tmaxTable_ = getAttributeTable(TMAX_PROPERTY);
-		dmaxTable_ = getAttributeTable(DMAX_PROPERTY);
-
-		try
-		{
-			datagramSocket_ = new DatagramSocket();
-		}
-		catch (SocketException se)
-		{
-			se.printStackTrace();
-		}
-	}
-
-	/**
-	 * Sends a record to the metrics system.
-	 */
-	public void emitRecord(String recordName, OutputRecord outRec) throws IOException
-	{
-		// emit each metric in turn
-		for (String metricName : outRec.getMetricNames())
-		{
-			Object metric = outRec.getMetric(metricName);
-			String type = (String) typeTable_.get(metric.getClass());
-			emitMetric(metricName, type, metric.toString());
-		}
-	}
-
-	/**
-	 * Helper which actually writes the metric in XDR format.
-	 *
-	 * @param name
-	 * @param type
-	 * @param value
-	 * @throws IOException
-	 */
-	private void emitMetric(String name, String type, String value) throws IOException
-	{
-		String units = getUnits(name);
-		int slope = getSlope(name);
-		int tmax = getTmax(name);
-		int dmax = getDmax(name);
-		offset_ = 0;
-
-		xdr_int(0); // metric_user_defined
-		xdr_string(type);
-		xdr_string(name);
-		xdr_string(value);
-		xdr_string(units);
-		xdr_int(slope);
-		xdr_int(tmax);
-		xdr_int(dmax);
-
-		for (InetSocketAddress socketAddress : metricsServers_)
-		{
-			DatagramPacket packet = new DatagramPacket(buffer_, offset_, socketAddress);
-			datagramSocket_.send(packet);
-		}
-	}
-
-	private String getUnits(String metricName)
-	{
-		String result = (String) unitsTable_.get(metricName);
-		if (result == null)
-		{
-			result = DEFAULT_UNITS;
-		}
-
-		return result;
-	}
-
-	private int getSlope(String metricName)
-	{
-		String slopeString = (String) slopeTable_.get(metricName);
-		if (slopeString == null)
-		{
-			slopeString = DEFAULT_SLOPE;
-		}
-
-		return ("zero".equals(slopeString) ? 0 : 3); // see gmetric.c
-	}
-
-	private int getTmax(String metricName)
-	{
-		String tmaxString = (String) tmaxTable_.get(metricName);
-		if (tmaxString == null)
-		{
-			return DEFAULT_TMAX;
-		}
-		else
-		{
-			return Integer.parseInt(tmaxString);
-		}
-	}
-
-	private int getDmax(String metricName)
-	{
-		String dmaxString = (String) dmaxTable_.get(metricName);
-		if (dmaxString == null)
-		{
-			return DEFAULT_DMAX;
-		}
-		else
-		{
-			return Integer.parseInt(dmaxString);
-		}
-	}
-
-	/**
-	 * Puts a string into the buffer by first writing the size of the string
-	 * as an int, followed by the bytes of the string, padded if necessary to
-	 * a multiple of 4.
-	 */
-	private void xdr_string(String s)
-	{
-		byte[] bytes = s.getBytes();
-		int len = bytes.length;
-		xdr_int(len);
-		System.arraycopy(bytes, 0, buffer_, offset_, len);
-		offset_ += len;
-		pad();
-	}
-
-	/**
-	 * Pads the buffer with zero bytes up to the nearest multiple of 4.
-	 */
-	private void pad()
-	{
-		int newOffset = ((offset_ + 3) / 4) * 4;
-		while (offset_ < newOffset)
-		{
-			buffer_[offset_++] = 0;
-		}
-	}
-
-	/**
-	 * Puts an integer into the buffer as 4 bytes, big-endian.
-	 */
-	private void xdr_int(int i)
-	{
-		buffer_[offset_++] = (byte) ((i >> 24) & 0xff);
-		buffer_[offset_++] = (byte) ((i >> 16) & 0xff);
-		buffer_[offset_++] = (byte) ((i >> 8) & 0xff);
-		buffer_[offset_++] = (byte) (i & 0xff);
-	}
-
-
-
-	/**
-	 * Returns the names of all the factory's attributes.
-	 *
-	 * @return the attribute names
-	 */
-	public String[] getAttributeNames()
-	{
-		String[] result = new String[attributeMap_.size()];
-		int i = 0;
-		// for (String attributeName : attributeMap.keySet()) {
-		Iterator<String> it = attributeMap_.keySet().iterator();
-		while (it.hasNext())
-		{
-			result[i++] = it.next();
-		}
-		return result;
-	}
-
-	/**
-	 * Sets the named factory attribute to the specified value, creating it
-	 * if it did not already exist.	If the value is null, this is the same as
-	 * calling removeAttribute.
-	 *
-	 * @param attributeName the attribute name
-	 * @param value the new attribute value
-	 */
-	public void setAttribute(String attributeName, Object value)
-	{
-		attributeMap_.put(attributeName, value);
-	}
-
-	/**
-	 * Removes the named attribute if it exists.
-	 *
-	 * @param attributeName the attribute name
-	 */
-	public void removeAttribute(String attributeName)
-	{
-		attributeMap_.remove(attributeName);
-	}
-
-	/**
-	 * Returns the value of the named attribute, or null if there is no
-	 * attribute of that name.
-	 *
-	 * @param attributeName the attribute name
-	 * @return the attribute value
-	 */
-	public String getAttribute(String attributeName)
-	{
-		return (String)attributeMap_.get(attributeName);
-	}
-
-
-	/**
-	 * Returns an attribute-value map derived from the factory attributes
-	 * by finding all factory attributes that begin with
-	 * <i>contextName</i>.<i>tableName</i>.	The returned map consists of
-	 * those attributes with the contextName and tableName stripped off.
-	 */
-	protected Map<String,String> getAttributeTable(String tableName)
-	{
-		String prefix = tableName + ".";
-		Map<String,String> result = new HashMap<String,String>();
-		for (String attributeName : getAttributeNames())
-		{
-			if (attributeName.startsWith(prefix))
-			{
-				String name = attributeName.substring(prefix.length());
-				String value = (String) getAttribute(attributeName);
-				result.put(name, value);
-			}
-		}
-		return result;
-	}
-
-	/**
-	 * Starts or restarts monitoring, the emitting of metrics records.
-	 */
-	public void startMonitoring() throws IOException {
-		if (!isMonitoring)
-		{
-			startTimer();
-			isMonitoring = true;
-		}
-	}
-
-	/**
-	 * Stops monitoring.	This does not free buffered data.
-	 * @see #close()
-	 */
-	public void stopMonitoring() {
-		if (isMonitoring)
-		{
-            if (timer != null)
-            {
-                timer.cancel();
-                timer = null;
-            }
-			isMonitoring = false;
-		}
-	}
-
-	/**
-	 * Returns true if monitoring is currently in progress.
-	 */
-	public boolean isMonitoring() {
-		return isMonitoring;
-	}
-
-	/**
-	 * Stops monitoring and frees buffered data, returning this
-	 * object to its initial state.
-	 */
-	public void close()
-	{
-		stopMonitoring();
-		clearUpdaters();
-	}
-
-	/**
-	 * Creates a new AbstractMetricsRecord instance with the given <code>recordName</code>.
-	 * Throws an exception if the metrics implementation is configured with a fixed
-	 * set of record names and <code>recordName</code> is not in that set.
-	 *
-	 * @param recordName the name of the record
-	 * @throws AnalyticsException if recordName conflicts with configuration data
-	 */
-	public final void createRecord(String recordName)
-	{
-		if (bufferedData_.get(recordName) == null)
-		{
-			bufferedData_.put(recordName, new RecordMap());
-		}
-        recordMap_.put(recordName, new MetricsRecord(recordName, this));
-	}
-
-	/**
-	 * Return the MetricsRecord associated with this record name.
-	 * @param recordName the name of the record
-	 * @return newly created instance of MetricsRecordImpl or subclass
-	 */
-	public MetricsRecord getMetricsRecord(String recordName)
-	{
-		return recordMap_.get(recordName);
-	}
-
-	/**
-	 * Registers a callback to be called at time intervals determined by
-	 * the configuration.
-	 *
-	 * @param updater object to be run periodically; it should update
-	 * some metrics records
-	 */
-	public void registerUpdater(final IAnalyticsSource updater)
-	{
-		if (!updaters.contains(updater)) {
-			updaters.add(updater);
-		}
-	}
-
-	/**
-	 * Removes a callback, if it exists.
-	 *
-	 * @param updater object to be removed from the callback list
-	 */
-	public void unregisterUpdater(IAnalyticsSource updater)
-	{
-		updaters.remove(updater);
-	}
-
-	private void clearUpdaters()
-	{
-		updaters.clear();
-	}
-
-	/**
-	 * Starts timer if it is not already started
-	 */
-	private void startTimer()
-	{
-		if (timer == null)
-		{
-			timer = new Timer("Timer thread for monitoring AnalyticsContext", true);
-			TimerTask task = new TimerTask()
-			{
-				public void run()
-				{
-					try
-					{
-						timerEvent();
-					}
-					catch (IOException ioe)
-					{
-						ioe.printStackTrace();
-					}
-				}
-			};
-			long millis = period_ * 1000;
-			timer.scheduleAtFixedRate(task, millis, millis);
-		}
-	}
-
-	/**
-	 * Timer callback.
-	 */
-	private void timerEvent() throws IOException
-	{
-		if (isMonitoring)
-		{
-			Collection<IAnalyticsSource> myUpdaters;
-
-			// we don't need to synchronize as there will not be any
-			// addition or removal of listeners
-			myUpdaters = new ArrayList<IAnalyticsSource>(updaters);
-
-			// Run all the registered updates without holding a lock
-			// on this context
-			for (IAnalyticsSource updater : myUpdaters)
-			{
-				try
-				{
-					updater.doUpdates(this);
-				}
-				catch (Throwable throwable)
-				{
-					throwable.printStackTrace();
-				}
-			}
-			emitRecords();
-		}
-	}
-
-	/**
-	 *	Emits the records.
-	 */
-	private void emitRecords() throws IOException
-	{
-		for (String recordName : bufferedData_.keySet())
-		{
-			RecordMap recordMap = bufferedData_.get(recordName);
-			synchronized (recordMap)
-			{
-				for (TagMap tagMap : recordMap.keySet())
-				{
-					MetricMap metricMap = recordMap.get(tagMap);
-					OutputRecord outRec = new OutputRecord(tagMap, metricMap);
-					emitRecord(recordName, outRec);
-				}
-			}
-		}
-		flush();
-	}
-
-	/**
-	 * Called each period after all records have been emitted, this method does nothing.
-	 * Subclasses may override it in order to perform some kind of flush.
-	 */
-	protected void flush() throws IOException
-	{
-	}
-
-	/**
-	 * Called by MetricsRecordImpl.update().	Creates or updates a row in
-	 * the internal table of metric data.
-	 */
-	protected void update(MetricsRecord record)
-	{
-		String recordName = record.getRecordName();
-		TagMap tagTable = record.getTagTable();
-		Map<String,MetricValue> metricUpdates = record.getMetricTable();
-
-		RecordMap recordMap = getRecordMap(recordName);
-		synchronized (recordMap)
-		{
-			MetricMap metricMap = recordMap.get(tagTable);
-			if (metricMap == null)
-			{
-				metricMap = new MetricMap();
-				TagMap tagMap = new TagMap(tagTable); // clone tags
-				recordMap.put(tagMap, metricMap);
-			}
-			for (String metricName : metricUpdates.keySet())
-			{
-				MetricValue updateValue = metricUpdates.get(metricName);
-				Number updateNumber = updateValue.getNumber();
-				Number currentNumber = metricMap.get(metricName);
-				if (currentNumber == null || updateValue.isAbsolute())
-				{
-					metricMap.put(metricName, updateNumber);
-				}
-				else
-				{
-					Number newNumber = sum(updateNumber, currentNumber);
-					metricMap.put(metricName, newNumber);
-				}
-			}
-		}
-	}
-
-	private RecordMap getRecordMap(String recordName)
-	{
-		return bufferedData_.get(recordName);
-	}
-
-	/**
-	 * Adds two numbers, coercing the second to the type of the first.
-	 *
-	 */
-	private Number sum(Number a, Number b)
-	{
-		if (a instanceof Integer)
-		{
-			return Integer.valueOf(a.intValue() + b.intValue());
-		}
-		else if (a instanceof Float)
-		{
-			return Float.valueOf(a.floatValue() + b.floatValue());
-		}
-		else if (a instanceof Short)
-		{
-			return Short.valueOf((short)(a.shortValue() + b.shortValue()));
-		}
-		else if (a instanceof Byte)
-		{
-			return Byte.valueOf((byte)(a.byteValue() + b.byteValue()));
-		}
-		else
-		{
-			// should never happen
-			throw new AnalyticsException("Invalid number type");
-		}
-	}
-
-	/**
-	 * Called by MetricsRecordImpl.remove().	Removes any matching row in
-	 * the internal table of metric data.	A row matches if it has the same
-	 * tag names and tag values.
-	 */
-	protected void remove(MetricsRecord record)
-	{
-		String recordName = record.getRecordName();
-		TagMap tagTable = record.getTagTable();
-
-		RecordMap recordMap = getRecordMap(recordName);
-
-		recordMap.remove(tagTable);
-	}
-
-	/**
-	 * Returns the timer period.
-	 */
-	public int getPeriod()
-	{
-		return period_;
-	}
-
-	/**
-	 * Sets the timer period
-	 */
-	protected void setPeriod(int period)
-	{
-		this.period_ = period;
-	}
-
-	/**
-	 * Sets the default port to listen on
-	 */
-	public void setPort(int port)
-	{
-		port_ = port;
-	}
-
-	/**
-	 * Parses a space and/or comma separated sequence of server specifications
-	 * of the form <i>hostname</i> or <i>hostname:port</i>.	If
-	 * the specs string is null, defaults to localhost:defaultPort.
-	 *
-	 * @return a list of InetSocketAddress objects.
-	 */
-	private static List<InetSocketAddress> parse(String specs, int defaultPort)
-	{
-		List<InetSocketAddress> result = new ArrayList<InetSocketAddress>(1);
-		if (specs == null) {
-			result.add(new InetSocketAddress("localhost", defaultPort));
-		}
-		else {
-			String[] specStrings = specs.split("[ ,]+");
-			for (String specString : specStrings) {
-				int colon = specString.indexOf(':');
-				if (colon < 0 || colon == specString.length() - 1)
-				{
-					result.add(new InetSocketAddress(specString, defaultPort));
-				} else
-				{
-					String hostname = specString.substring(0, colon);
-					int port = Integer.parseInt(specString.substring(colon+1));
-					result.add(new InetSocketAddress(hostname, port));
-				}
-			}
-		}
-		return result;
-	}
-
-	/**
-	 * Starts up the analytics context and registers the VM metrics.
-	 */
-	public void start()
-	{
-		// register the vm analytics object with the analytics context to update the data
-		registerUpdater(new VMAnalyticsSource());
-
-
-        init("analyticsContext", DatabaseDescriptor.getGangliaServers());
-
-		try
-		{
-			startMonitoring();
-		}
-		catch(IOException e)
-		{
-			logger_.error(LogUtil.throwableToString(e));
-		}
-	}
-
-	public void stop()
-	{
-		close();
-	}
-
-    /**
-     * Factory method that gets an instance of the StorageService
-     * class.
-     */
-    public static AnalyticsContext instance()
-    {
-        if ( instance_ == null )
-        {
-        	AnalyticsContext.createLock_.lock();
-            try
-            {
-                if ( instance_ == null )
-                {
-                    instance_ = new AnalyticsContext();
-                }
-            }
-            finally
-            {
-                createLock_.unlock();
-            }
-        }
-        return instance_;
-    }
-}
diff --git a/src/java/org/apache/cassandra/analytics/AnalyticsException.java b/src/java/org/apache/cassandra/analytics/AnalyticsException.java
deleted file mode 100644
index 70e47bb833..0000000000
--- a/src/java/org/apache/cassandra/analytics/AnalyticsException.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.cassandra.analytics;
-
-/**
- * General-purpose, unchecked metrics exception.
- *
- * Author : Avinash Lakshman ( alakshman@facebook.com) & Prashant Malik ( pmalik@facebook.com ) & Karthik Ranganathan ( kranganathan@facebook.com )
- */
-public class AnalyticsException extends RuntimeException
-{
-
-	  private static final long serialVersionUID = -1643257498540498497L;
-
-	  /**
-	   * Creates a new instance of MetricsException
-	   */
-	  public AnalyticsException()
-	  {
-	  }
-
-	  /** Creates a new instance of MetricsException
-	   *
-	   * @param message an error message
-	   */
-	  public AnalyticsException(String message)
-	  {
-	    super(message);
-	  }
-
-	}
diff --git a/src/java/org/apache/cassandra/analytics/DBAnalyticsSource.java b/src/java/org/apache/cassandra/analytics/DBAnalyticsSource.java
deleted file mode 100644
index fdaecbb80d..0000000000
--- a/src/java/org/apache/cassandra/analytics/DBAnalyticsSource.java
+++ /dev/null
@@ -1,182 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.cassandra.analytics;
-
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicLong;
-
-/**
- * This class sets up the analytics package to report metrics into
- * Ganglia for the various DB operations such as: reads per second,
- * average read latency, writes per second, average write latency.
- *
- * Author : Avinash Lakshman ( alakshman@facebook.com) & Prashant Malik ( pmalik@facebook.com ) & Karthik Ranganathan ( kranganathan@facebook.com )
- */
-public class DBAnalyticsSource implements IAnalyticsSource
-{
-    private static final String METRIC_READ_OPS = "Read Operations";
-    private static final String RECORD_READ_OPS = "ReadOperationsRecord";
-    private static final String TAG_READOPS = "ReadOperationsTag";
-    private static final String TAG_READ_OPS = "ReadOperationsTagValue";
-
-    private static final String METRIC_READ_AVG = "Average Read Latency";
-    private static final String RECORD_READ_AVG = "ReadLatencyRecord";
-    private static final String TAG_READAVG = "AverageReadLatencyTag";
-    private static final String TAG_READ_AVG = "ReadLatencyTagValue";
-
-    private static final String METRIC_WRITE_OPS = "Write Operations";
-    private static final String RECORD_WRITE_OPS = "WriteOperationsRecord";
-    private static final String TAG_WRITEOPS = "WriteOperationsTag";
-    private static final String TAG_WRITE_OPS = "WriteOperationsTagValue";
-
-    private static final String METRIC_WRITE_AVG = "Average Write Latency";
-    private static final String RECORD_WRITE_AVG = "WriteLatencyRecord";
-    private static final String TAG_WRITEAVG = "AverageWriteLatencyTag";
-    private static final String TAG_WRITE_AVG = "WriteLatencyTagValue";
-
-    /* keep track of the number of read operations */
-    private AtomicInteger readOperations_ = new AtomicInteger(0);
-
-    /* keep track of the number of read latencies */
-    private AtomicLong readLatencies_ = new AtomicLong(0);
-
-    /* keep track of the number of write operations */
-    private AtomicInteger writeOperations_ = new AtomicInteger(0);
-
-    /* keep track of the number of write latencies */
-    private AtomicLong writeLatencies_ = new AtomicLong(0);
-
-    /**
-     * Create all the required records we intend to display, and
-     * register with the AnalyticsContext.
-     */
-    public DBAnalyticsSource()
-    {
-        /* register with the AnalyticsContext */
-        AnalyticsContext.instance().registerUpdater(this);
-        /* set the units for the metric type */
-        AnalyticsContext.instance().setAttribute("units." + METRIC_READ_OPS, "r/s");
-        /* create the record */
-        AnalyticsContext.instance().createRecord(RECORD_READ_OPS);
-
-        /* set the units for the metric type */
-        AnalyticsContext.instance().setAttribute("units." + METRIC_READ_AVG, "ms");
-        /* create the record */
-        AnalyticsContext.instance().createRecord(RECORD_READ_AVG);
-
-        /* set the units for the metric type */
-        AnalyticsContext.instance().setAttribute("units." + METRIC_WRITE_OPS, "w/s");
-        /* create the record */
-        AnalyticsContext.instance().createRecord(RECORD_WRITE_OPS);
-
-        /* set the units for the metric type */
-        AnalyticsContext.instance().setAttribute("units." + METRIC_WRITE_AVG, "ms");
-        /* create the record */
-        AnalyticsContext.instance().createRecord(RECORD_WRITE_AVG);
-    }
-
-    /**
-     * Update each of the records with the relevant data
-     *
-     * @param context the reference to the context which has called this callback
-     */
-    public void doUpdates(AnalyticsContext context)
-    {
-        // update the read operations record
-        MetricsRecord readUsageRecord = context.getMetricsRecord(RECORD_READ_OPS);
-        int period = context.getPeriod();
-
-        if(readUsageRecord != null)
-        {
-            if ( readOperations_.get() > 0 )
-            {
-                readUsageRecord.setTag(TAG_READOPS, TAG_READ_OPS);
-                readUsageRecord.setMetric(METRIC_READ_OPS, readOperations_.get() / period);
-                readUsageRecord.update();
-            }
-        }
-
-        // update the read latency record
-        MetricsRecord readLatencyRecord = context.getMetricsRecord(RECORD_READ_AVG);
-        if(readLatencyRecord != null)
-        {
-            if ( readOperations_.get() > 0 )
-            {
-                readLatencyRecord.setTag(TAG_READAVG, TAG_READ_AVG);
-                readLatencyRecord.setMetric(METRIC_READ_AVG, readLatencies_.get() / readOperations_.get() );
-                readLatencyRecord.update();
-            }
-        }
-
-        // update the write operations record
-        MetricsRecord writeUsageRecord = context.getMetricsRecord(RECORD_WRITE_OPS);
-        if(writeUsageRecord != null)
-        {
-            if ( writeOperations_.get() > 0 )
-            {
-                writeUsageRecord.setTag(TAG_WRITEOPS, TAG_WRITE_OPS);
-                writeUsageRecord.setMetric(METRIC_WRITE_OPS, writeOperations_.get() / period);
-                writeUsageRecord.update();
-            }
-        }
-
-        // update the write latency record
-        MetricsRecord writeLatencyRecord = context.getMetricsRecord(RECORD_WRITE_AVG);
-        if(writeLatencyRecord != null)
-        {
-            if ( writeOperations_.get() > 0 )
-            {
-                writeLatencyRecord.setTag(TAG_WRITEAVG, TAG_WRITE_AVG);
-                writeLatencyRecord.setMetric(METRIC_WRITE_AVG, writeLatencies_.get() / writeOperations_.get() );
-                writeLatencyRecord.update();
-            }
-        }
-
-        clear();
-    }
-
-    /**
-     * Reset all the metric records
-     */
-    private void clear()
-    {
-        readOperations_.set(0);
-        readLatencies_.set(0);
-        writeOperations_.set(0);
-        writeLatencies_.set(0);
-    }
-
-    /**
-     * Update the read statistics.
-     */
-    public void updateReadStatistics(long latency)
-    {
-        readOperations_.incrementAndGet();
-        readLatencies_.addAndGet(latency);
-    }
-
-    /**
-     * Update the write statistics.
-     */
-    public void updateWriteStatistics(long latency)
-    {
-        writeOperations_.incrementAndGet();
-        writeLatencies_.addAndGet(latency);
-    }
-}
diff --git a/src/java/org/apache/cassandra/analytics/IAnalyticsSource.java b/src/java/org/apache/cassandra/analytics/IAnalyticsSource.java
deleted file mode 100644
index 146ce6d6bb..0000000000
--- a/src/java/org/apache/cassandra/analytics/IAnalyticsSource.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.cassandra.analytics;
-
-/**
- * Call-back interface.  See <code>AnalyticsContext.registerUpdater()</code>.
- * This callback is called at a regular (pre-registered time interval) in
- * order to update the metric values.
- *
- * Author : Avinash Lakshman ( alakshman@facebook.com) & Prashant Malik ( pmalik@facebook.com ) & Karthik Ranganathan ( kranganathan@facebook.com )
- */
-public interface IAnalyticsSource
-{
-  /**
-   * Timer-based call-back from the metric library.
-   */
-  public abstract void doUpdates(AnalyticsContext context);
-
-}
diff --git a/src/java/org/apache/cassandra/analytics/MetricValue.java b/src/java/org/apache/cassandra/analytics/MetricValue.java
deleted file mode 100644
index 90743b3ee9..0000000000
--- a/src/java/org/apache/cassandra/analytics/MetricValue.java
+++ /dev/null
@@ -1,77 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.cassandra.analytics;
-
-
-/**
- * A Number that is either an absolute or an incremental amount.
- *
- * Author : Avinash Lakshman ( alakshman@facebook.com) & Prashant Malik ( pmalik@facebook.com ) & Karthik Ranganathan ( kranganathan@facebook.com )
- */
-public class MetricValue
-{
-	public static final boolean ABSOLUTE = false;
-	public static final boolean INCREMENT = true;
-
-	private boolean isIncrement;
-	private Number number;
-
-	/**
-	 * Creates a new instance of MetricValue
-	 *
-	 *  @param number this initializes the initial value of this metric
-	 *  @param isIncrement sets if the metric can be incremented or only set
-	 */
-	public MetricValue(Number number, boolean isIncrement)
-	{
-		this.number = number;
-		this.isIncrement = isIncrement;
-	}
-
-	/**
-	 * Checks if this metric can be incremented.
-	 *
-	 * @return true if the value of this metric can be incremented, false otherwise
-	 */
-	public boolean isIncrement()
-	{
-		return isIncrement;
-	}
-
-	/**
-	 * Checks if the value of this metric is always an absolute value. This is the
-	 * inverse of isIncrement.
-	 *
-	 * @return true if the
-	 */
-	public boolean isAbsolute()
-	{
-		return !isIncrement;
-	}
-
-	/**
-	 * Returns the current number value of the metric.
-	 *
-	 * @return the Number value of this metric
-	 */
-	public Number getNumber()
-	{
-		return number;
-	}
-}
diff --git a/src/java/org/apache/cassandra/analytics/MetricsRecord.java b/src/java/org/apache/cassandra/analytics/MetricsRecord.java
deleted file mode 100644
index 8a4a331dc2..0000000000
--- a/src/java/org/apache/cassandra/analytics/MetricsRecord.java
+++ /dev/null
@@ -1,265 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.cassandra.analytics;
-
-import java.util.LinkedHashMap;
-import java.util.Map;
-
-
-/**
- * This class keeps a back-pointer to the AnalyticsContext
- * and delegates back to it on <code>update</code> and <code>remove()</code>.
- *
- * Author : Avinash Lakshman ( alakshman@facebook.com) & Prashant Malik ( pmalik@facebook.com ) & Karthik Ranganathan ( kranganathan@facebook.com )
- */
-public class MetricsRecord {
-
-	private AnalyticsContext.TagMap tagTable = new AnalyticsContext.TagMap();
-	private Map<String,MetricValue> metricTable = new LinkedHashMap<String,MetricValue>();
-
-	private String recordName;
-	private AnalyticsContext context;
-
-
-	/**
-	 * Creates a new instance of MetricsRecord
-	 *
-	 *  @param recordName name of this record
-	 *  @param context the context which this record is a part of
-	 */
-	protected MetricsRecord(String recordName, AnalyticsContext context)
-	{
-		this.recordName = recordName;
-		this.context = context;
-	}
-
-	/**
-	 * Returns the record name.
-	 *
-	 * @return the record name
-	 */
-	public String getRecordName() {
-		return recordName;
-	}
-
-	/**
-	 * Sets the named tag to the specified value.
-	 *
-	 * @param tagName name of the tag
-	 * @param tagValue new value of the tag
-	 * @throws MetricsException if the tagName conflicts with the configuration
-	 */
-	public void setTag(String tagName, String tagValue) {
-		if (tagValue == null) {
-			tagValue = "";
-		}
-		tagTable.put(tagName, tagValue);
-	}
-
-	/**
-	 * Sets the named tag to the specified value.
-	 *
-	 * @param tagName name of the tag
-	 * @param tagValue new value of the tag
-	 * @throws MetricsException if the tagName conflicts with the configuration
-	 */
-	public void setTag(String tagName, int tagValue) {
-		tagTable.put(tagName, Integer.valueOf(tagValue));
-	}
-
-	/**
-	 * Sets the named tag to the specified value.
-	 *
-	 * @param tagName name of the tag
-	 * @param tagValue new value of the tag
-	 * @throws MetricsException if the tagName conflicts with the configuration
-	 */
-	public void setTag(String tagName, short tagValue) {
-		tagTable.put(tagName, Short.valueOf(tagValue));
-	}
-
-	/**
-	 * Sets the named tag to the specified value.
-	 *
-	 * @param tagName name of the tag
-	 * @param tagValue new value of the tag
-	 * @throws MetricsException if the tagName conflicts with the configuration
-	 */
-	public void setTag(String tagName, byte tagValue)
-	{
-		tagTable.put(tagName, Byte.valueOf(tagValue));
-	}
-
-	/**
-	 * Sets the named metric to the specified value.
-	 *
-	 * @param metricName name of the metric
-	 * @param metricValue new value of the metric
-	 * @throws MetricsException if the metricName or the type of the metricValue
-	 * conflicts with the configuration
-	 */
-	public void setMetric(String metricName, int metricValue)
-	{
-		setAbsolute(metricName, Integer.valueOf(metricValue));
-	}
-
-	/**
-	 * Sets the named metric to the specified value.
-	 *
-	 * @param metricName name of the metric
-	 * @param metricValue new value of the metric
-	 * @throws MetricsException if the metricName or the type of the metricValue
-	 * conflicts with the configuration
-	 */
-	public void setMetric(String metricName, short metricValue)
-	{
-		setAbsolute(metricName, Short.valueOf(metricValue));
-	}
-
-	/**
-	 * Sets the named metric to the specified value.
-	 *
-	 * @param metricName name of the metric
-	 * @param metricValue new value of the metric
-	 * @throws MetricsException if the metricName or the type of the metricValue
-	 * conflicts with the configuration
-	 */
-	public void setMetric(String metricName, byte metricValue)
-	{
-		setAbsolute(metricName, Byte.valueOf(metricValue));
-	}
-
-	/**
-	 * Sets the named metric to the specified value.
-	 *
-	 * @param metricName name of the metric
-	 * @param metricValue new value of the metric
-	 * @throws MetricsException if the metricName or the type of the metricValue
-	 * conflicts with the configuration
-	 */
-	public void setMetric(String metricName, float metricValue)
-	{
-		setAbsolute(metricName, Float.valueOf(metricValue));
-	}
-
-	/**
-	 * Increments the named metric by the specified value.
-	 *
-	 * @param metricName name of the metric
-	 * @param metricValue incremental value
-	 * @throws MetricsException if the metricName or the type of the metricValue
-	 * conflicts with the configuration
-	 */
-	public void incrMetric(String metricName, int metricValue)
-	{
-		setIncrement(metricName, Integer.valueOf(metricValue));
-	}
-
-	/**
-	 * Increments the named metric by the specified value.
-	 *
-	 * @param metricName name of the metric
-	 * @param metricValue incremental value
-	 * @throws MetricsException if the metricName or the type of the metricValue
-	 * conflicts with the configuration
-	 */
-	public void incrMetric(String metricName, short metricValue)
-	{
-		setIncrement(metricName, Short.valueOf(metricValue));
-	}
-
-	/**
-	 * Increments the named metric by the specified value.
-	 *
-	 * @param metricName name of the metric
-	 * @param metricValue incremental value
-	 * @throws MetricsException if the metricName or the type of the metricValue
-	 * conflicts with the configuration
-	 */
-	public void incrMetric(String metricName, byte metricValue)
-	{
-		setIncrement(metricName, Byte.valueOf(metricValue));
-	}
-
-	/**
-	 * Increments the named metric by the specified value.
-	 *
-	 * @param metricName name of the metric
-	 * @param metricValue incremental value
-	 * @throws MetricsException if the metricName or the type of the metricValue
-	 * conflicts with the configuration
-	 */
-	public void incrMetric(String metricName, float metricValue)
-	{
-		setIncrement(metricName, Float.valueOf(metricValue));
-	}
-
-	/**
-	 * Sets the value of the metric identified by metricName with the
-	 * number metricValue.
-	 *
-	 * @param metricName name of the metric
-	 * @param metricValue number value to which it should be updated
-	 */
-	private void setAbsolute(String metricName, Number metricValue)
-	{
-		metricTable.put(metricName, new MetricValue(metricValue, MetricValue.ABSOLUTE));
-	}
-
-	/**
-	 * Increments the value of the metric identified by metricName with the
-	 * number metricValue.
-	 *
-	 * @param metricName name of the metric
-	 * @param metricValue number value by which it should be incremented
-	 */
-	private void setIncrement(String metricName, Number metricValue)
-	{
-		metricTable.put(metricName, new MetricValue(metricValue, MetricValue.INCREMENT));
-	}
-
-	/**
-	 * Updates the table of buffered data which is to be sent periodically.
-	 * If the tag values match an existing row, that row is updated;
-	 * otherwise, a new row is added.
-	 */
-	public void update()
-	{
-		context.update(this);
-	}
-
-	/**
-	 * Removes the row, if it exists, in the buffered data table having tags
-	 * that equal the tags that have been set on this record.
-	 */
-	public void remove()
-	{
-		context.remove(this);
-	}
-
-	AnalyticsContext.TagMap getTagTable()
-	{
-		return tagTable;
-	}
-
-	Map<String, MetricValue> getMetricTable()
-	{
-		return metricTable;
-	}
-}
diff --git a/src/java/org/apache/cassandra/analytics/OutputRecord.java b/src/java/org/apache/cassandra/analytics/OutputRecord.java
deleted file mode 100644
index bf5568479e..0000000000
--- a/src/java/org/apache/cassandra/analytics/OutputRecord.java
+++ /dev/null
@@ -1,82 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.cassandra.analytics;
-
-import java.util.Collections;
-import java.util.Set;
-
-/**
- * Represents a record of metric data to be sent to a metrics system.
- *
- * Author : Avinash Lakshman ( alakshman@facebook.com) & Prashant Malik ( pmalik@facebook.com ) & Karthik Ranganathan ( kranganathan@facebook.com )
- */
-public class OutputRecord
-{
-	private AnalyticsContext.TagMap tagMap;
-	private AnalyticsContext.MetricMap metricMap;
-
-	/**
-	 * Creates a new instance of OutputRecord
-	 */
-	OutputRecord(AnalyticsContext.TagMap tagMap, AnalyticsContext.MetricMap metricMap)
-	{
-		this.tagMap = tagMap;
-		this.metricMap = metricMap;
-	}
-
-	/**
-	 * Returns the set of tag names.
-	 */
-	public Set<String> getTagNames()
-	{
-		return Collections.unmodifiableSet(tagMap.keySet());
-	}
-
-	/**
-	 * Returns a tag object which is can be a String, Integer, Short or Byte.
-	 *
-	 * @return the tag value, or null if there is no such tag
-	 */
-	public Object getTag(String name)
-	{
-		return tagMap.get(name);
-	}
-
-	/**
-	 * Returns the set of metric names.
-	 *
-	 * @return the set of metric names
-	 */
-	public Set<String> getMetricNames()
-	{
-		return Collections.unmodifiableSet(metricMap.keySet());
-	}
-
-	/**
-	 * Returns the metric object which can be a Float, Integer, Short or Byte.
-	 *
-	 * @param name name of the metric for which the value is being requested
-	 * @return return the tag value, or null if there is no such tag
-	 */
-	public Number getMetric(String name)
-	{
-		return (Number) metricMap.get(name);
-	}
-
-}
\ No newline at end of file
diff --git a/src/java/org/apache/cassandra/analytics/VMAnalyticsSource.java b/src/java/org/apache/cassandra/analytics/VMAnalyticsSource.java
deleted file mode 100644
index 631ca0e079..0000000000
--- a/src/java/org/apache/cassandra/analytics/VMAnalyticsSource.java
+++ /dev/null
@@ -1,86 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.cassandra.analytics;
-
-import java.lang.management.ManagementFactory;
-import java.lang.management.MemoryMXBean;
-import java.lang.management.MemoryUsage;
-import java.util.HashMap;
-import java.util.Map;
-
-import org.apache.cassandra.config.DatabaseDescriptor;
-import org.apache.cassandra.service.StorageService;
-import org.apache.cassandra.utils.LogUtil;
-import org.apache.log4j.Logger;
-
-
-/**
- * This class sets up the analytics package to report metrics into
- * Ganglia for VM heap utilization.
- *
- * Author : Avinash Lakshman ( alakshman@facebook.com) & Prashant Malik ( pmalik@facebook.com ) & Karthik Ranganathan ( kranganathan@facebook.com )
- */
-
-public class VMAnalyticsSource implements IAnalyticsSource
-{
-	private static final String METRIC_MEMUSAGE = "VM Heap Utilization";
-	private static final String RECORD_MEMUSAGE = "MemoryUsageRecord";
-	private static final String TAG_MEMUSAGE = "MemoryUsageTag";
-	private static final String TAG_MEMUSAGE_MEMUSED = "MemoryUsedTagValue";
-
-	/**
-	 * Setup the Ganglia record to display the VM heap utilization.
-	 */
-	public VMAnalyticsSource()
-	{
-		// set the units for the metric type
-		AnalyticsContext.instance().setAttribute("units." + METRIC_MEMUSAGE, "MB");
-		// create the record
-        AnalyticsContext.instance().createRecord(RECORD_MEMUSAGE);
-  	}
-
-	/**
-	 * Update the VM heap utilization record with the relevant data.
-	 *
-	 * @param context the reference to the context which has called this callback
-	 */
-	public void doUpdates(AnalyticsContext context)
-	{
-        // update the memory used record
-		MetricsRecord memUsageRecord = context.getMetricsRecord(RECORD_MEMUSAGE);
-		if(memUsageRecord != null)
-		{
-			updateUsedMemory(memUsageRecord);
-		}
-	}
-
-	private void updateUsedMemory(MetricsRecord memUsageRecord)
-	{
-		memUsageRecord.setTag(TAG_MEMUSAGE, TAG_MEMUSAGE_MEMUSED);
-		memUsageRecord.setMetric(METRIC_MEMUSAGE, getMemoryUsed());
-		memUsageRecord.update();
-	}
-
-	private float getMemoryUsed()
-	{
-        MemoryMXBean memoryMxBean = ManagementFactory.getMemoryMXBean();
-        MemoryUsage memUsage = memoryMxBean.getHeapMemoryUsage();
-        return (float)memUsage.getUsed()/(1024 * 1024);
-	}
-}
diff --git a/src/java/org/apache/cassandra/config/DatabaseDescriptor.java b/src/java/org/apache/cassandra/config/DatabaseDescriptor.java
index b614c7b44c..d3cf628aa4 100644
--- a/src/java/org/apache/cassandra/config/DatabaseDescriptor.java
+++ b/src/java/org/apache/cassandra/config/DatabaseDescriptor.java
@@ -49,8 +49,6 @@ public class DatabaseDescriptor
     private static long rpcTimeoutInMillis_ = 2000;
     private static Set<String> seeds_ = new HashSet<String>();
     private static String snapshotDirectory_;
-    /* Keeps the list of Ganglia servers to contact */
-    private static String[] gangliaServers_ ;
     /* Keeps the list of data file directories */
     private static String[] dataFileDirectories_;
     /* Current index into the above list of directories */
@@ -121,9 +119,6 @@ public class DatabaseDescriptor
             /* Cluster Name */
             clusterName_ = xmlUtils.getNodeValue("/Storage/ClusterName");
 
-            /* Ganglia servers contact list */
-            gangliaServers_ = xmlUtils.getNodeValues("/Storage/GangliaServers/GangliaServer");
-
             /* Hashing strategy */
             partitionerClass_ = xmlUtils.getNodeValue("/Storage/Partitioner");
             try
@@ -544,18 +539,6 @@ public class DatabaseDescriptor
     {
         return jobJarFileLocation_;
     }
-
-    public static String getGangliaServers()
-    {
-    	StringBuilder sb = new StringBuilder();
-    	for ( int i = 0; i < gangliaServers_.length; ++i )
-    	{
-    		sb.append(gangliaServers_[i]);
-    		if ( i != (gangliaServers_.length - 1) )
-    			sb.append(", ");
-    	}
-    	return sb.toString();
-    }
     
     public static Map<String, CFMetaData> getTableMetaData(String tableName)
     {
diff --git a/src/java/org/apache/cassandra/db/Table.java b/src/java/org/apache/cassandra/db/Table.java
index 6e72c9b87f..023717efa1 100644
--- a/src/java/org/apache/cassandra/db/Table.java
+++ b/src/java/org/apache/cassandra/db/Table.java
@@ -28,7 +28,6 @@ import java.util.concurrent.ExecutionException;
 import org.apache.commons.collections.IteratorUtils;
 import org.apache.commons.collections.Predicate;
 
-import org.apache.cassandra.analytics.DBAnalyticsSource;
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.dht.BootstrapInitiateMessage;
 import org.apache.cassandra.dht.Range;
@@ -309,8 +308,6 @@ public class Table
     private Table.TableMetadata tableMetadata_;
     /* ColumnFamilyStore per column family */
     private Map<String, ColumnFamilyStore> columnFamilyStores_ = new HashMap<String, ColumnFamilyStore>();
-    /* The AnalyticsSource instance which keeps track of statistics reported to Ganglia. */
-    private DBAnalyticsSource dbAnalyticsSource_;
     // cache application CFs since Range queries ask for them a _lot_
     private SortedSet<String> applicationColumnFamilies_;
 
@@ -473,7 +470,6 @@ public class Table
     private Table(String table) throws IOException
     {
         table_ = table;
-        dbAnalyticsSource_ = new DBAnalyticsSource();
         tableMetadata_ = Table.TableMetadata.instance(table);
         for (String columnFamily : tableMetadata_.getColumnFamilies())
         {
@@ -594,7 +590,6 @@ public class Table
     void load(Row row) throws IOException
     {
         String key = row.key();
-        long start = System.currentTimeMillis();
                 
         for (ColumnFamily columnFamily : row.getColumnFamilies())
         {
@@ -606,8 +601,6 @@ public class Table
         	}
         }
         row.clear();
-        long timeTaken = System.currentTimeMillis() - start;
-        dbAnalyticsSource_.updateWriteStatistics(timeTaken);
     }
 
     public SortedSet<String> getApplicationColumnFamilies()
diff --git a/src/java/org/apache/cassandra/service/StorageService.java b/src/java/org/apache/cassandra/service/StorageService.java
index 6ad80dfe6d..bbf980c90f 100644
--- a/src/java/org/apache/cassandra/service/StorageService.java
+++ b/src/java/org/apache/cassandra/service/StorageService.java
@@ -30,7 +30,6 @@ import java.util.concurrent.locks.ReentrantLock;
 import javax.management.MBeanServer;
 import javax.management.ObjectName;
 
-import org.apache.cassandra.analytics.AnalyticsContext;
 import org.apache.cassandra.concurrent.*;
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.db.*;
@@ -267,8 +266,6 @@ public final class StorageService implements IEndPointStateChangeSubscriber, Sto
         SelectorManager.getSelectorManager().start();
         SelectorManager.getUdpSelectorManager().start();
 
-        /* start the analytics context package */
-        AnalyticsContext.instance().start();
         /* starts a load timer thread */
         loadTimer_.schedule( new LoadDisseminator(), StorageService.threshold_, StorageService.threshold_);
         
