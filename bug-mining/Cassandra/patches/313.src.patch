diff --git a/src/java/org/apache/cassandra/avro/CassandraServer.java b/src/java/org/apache/cassandra/avro/CassandraServer.java
index 6c5714a444..4aa9364979 100644
--- a/src/java/org/apache/cassandra/avro/CassandraServer.java
+++ b/src/java/org/apache/cassandra/avro/CassandraServer.java
@@ -36,16 +36,14 @@ import org.apache.avro.generic.GenericData;
 import org.apache.avro.ipc.AvroRemoteException;
 import org.apache.avro.util.Utf8;
 import org.apache.cassandra.config.DatabaseDescriptor;
-import org.apache.cassandra.db.ColumnFamily;
-import org.apache.cassandra.db.IColumn;
-import org.apache.cassandra.db.ReadCommand;
-import org.apache.cassandra.db.Row;
-import org.apache.cassandra.db.RowMutation;
-import org.apache.cassandra.db.SliceByNamesReadCommand;
+import org.apache.cassandra.db.*;
 import org.apache.cassandra.db.filter.QueryPath;
 import org.apache.cassandra.db.marshal.MarshalException;
 import org.apache.cassandra.service.StorageProxy;
 import static org.apache.cassandra.utils.FBUtilities.UTF8;
+
+import org.apache.cassandra.service.StorageService;
+import org.apache.cassandra.utils.Bytes;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import static org.apache.cassandra.avro.AvroRecordFactory.*;
@@ -132,12 +130,12 @@ public class CassandraServer implements Cassandra {
     private Map<String, Collection<IColumn>> multigetColumns(List<ReadCommand> commands, ConsistencyLevel level)
     throws InvalidRequestException, UnavailableException, TimedOutException
     {
-        Map<byte[], ColumnFamily> cfamilies = readColumnFamily(commands, level);
+        Map<DecoratedKey, ColumnFamily> cfamilies = readColumnFamily(commands, level);
         Map<String, Collection<IColumn>> columnFamiliesMap = new HashMap<String, Collection<IColumn>>();
         
         for (ReadCommand command : commands)
         {
-            ColumnFamily cfamily = cfamilies.get(command.key);
+            ColumnFamily cfamily = cfamilies.get(StorageService.getPartitioner().decorateKey(command.key));
             if (cfamily == null)
                 continue;
 
@@ -165,11 +163,11 @@ public class CassandraServer implements Cassandra {
         return columnFamiliesMap;
     }
     
-    protected Map<byte[], ColumnFamily> readColumnFamily(List<ReadCommand> commands, ConsistencyLevel consistency)
+    protected Map<DecoratedKey, ColumnFamily> readColumnFamily(List<ReadCommand> commands, ConsistencyLevel consistency)
     throws InvalidRequestException, UnavailableException, TimedOutException
     {
         // TODO - Support multiple column families per row, right now row only contains 1 column family
-        Map<byte[], ColumnFamily> columnFamilyKeyMap = new HashMap<byte[],ColumnFamily>();
+        Map<DecoratedKey, ColumnFamily> columnFamilyKeyMap = new HashMap<DecoratedKey, ColumnFamily>();
         
         if (consistency == ConsistencyLevel.ZERO)
             throw newInvalidRequestException("Consistency level zero may not be applied to read operations");
@@ -199,7 +197,7 @@ public class CassandraServer implements Cassandra {
 
         for (Row row: rows)
         {
-            columnFamilyKeyMap.put(row.key.key, row.cf);
+            columnFamilyKeyMap.put(row.key, row.cf);
         }
         
         return columnFamilyKeyMap;
diff --git a/src/java/org/apache/cassandra/thrift/CassandraServer.java b/src/java/org/apache/cassandra/thrift/CassandraServer.java
index 8e6066a7fd..7bfe034db1 100644
--- a/src/java/org/apache/cassandra/thrift/CassandraServer.java
+++ b/src/java/org/apache/cassandra/thrift/CassandraServer.java
@@ -84,11 +84,11 @@ public class CassandraServer implements Cassandra.Iface
         storageService = StorageService.instance;
     }
     
-    protected Map<byte[], ColumnFamily> readColumnFamily(List<ReadCommand> commands, ConsistencyLevel consistency_level)
+    protected Map<DecoratedKey, ColumnFamily> readColumnFamily(List<ReadCommand> commands, ConsistencyLevel consistency_level)
     throws InvalidRequestException, UnavailableException, TimedOutException
     {
         // TODO - Support multiple column families per row, right now row only contains 1 column family
-        Map<byte[], ColumnFamily> columnFamilyKeyMap = new HashMap<byte[],ColumnFamily>();
+        Map<DecoratedKey, ColumnFamily> columnFamilyKeyMap = new HashMap<DecoratedKey, ColumnFamily>();
 
         if (consistency_level == ConsistencyLevel.ZERO)
         {
@@ -119,7 +119,7 @@ public class CassandraServer implements Cassandra.Iface
 
         for (Row row: rows)
         {
-            columnFamilyKeyMap.put(row.key.key, row.cf);
+            columnFamilyKeyMap.put(row.key, row.cf);
         }
         return columnFamilyKeyMap;
     }
@@ -197,11 +197,11 @@ public class CassandraServer implements Cassandra.Iface
     private Map<byte[], List<ColumnOrSuperColumn>> getSlice(List<ReadCommand> commands, ConsistencyLevel consistency_level)
     throws InvalidRequestException, UnavailableException, TimedOutException
     {
-        Map<byte[], ColumnFamily> columnFamilies = readColumnFamily(commands, consistency_level);
+        Map<DecoratedKey, ColumnFamily> columnFamilies = readColumnFamily(commands, consistency_level);
         Map<byte[], List<ColumnOrSuperColumn>> columnFamiliesMap = new HashMap<byte[], List<ColumnOrSuperColumn>>();
         for (ReadCommand command: commands)
         {
-            ColumnFamily cf = columnFamilies.get(command.key);
+            ColumnFamily cf = columnFamilies.get(StorageService.getPartitioner().decorateKey(command.key));
             boolean reverseOrder = command instanceof SliceFromReadCommand && ((SliceFromReadCommand)command).reversed;
             List<ColumnOrSuperColumn> thriftifiedColumns = thriftifyColumnFamily(cf, command.queryPath.superColumnName != null, reverseOrder);
             columnFamiliesMap.put(command.key, thriftifiedColumns);
@@ -321,12 +321,12 @@ public class CassandraServer implements Cassandra.Iface
         }
 
         Map<byte[], ColumnOrSuperColumn> columnFamiliesMap = new HashMap<byte[], ColumnOrSuperColumn>();
-        Map<byte[], ColumnFamily> cfamilies = readColumnFamily(commands, consistency_level);
+        Map<DecoratedKey, ColumnFamily> cfamilies = readColumnFamily(commands, consistency_level);
 
 
         for (ReadCommand command: commands)
         {
-            ColumnFamily cf = cfamilies.get(command.key);
+            ColumnFamily cf = cfamilies.get(StorageService.getPartitioner().decorateKey(command.key));
             if (cf == null)
             {
                 columnFamiliesMap.put(command.key, new ColumnOrSuperColumn());
