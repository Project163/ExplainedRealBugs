diff --git a/src/java/org/apache/cassandra/db/compaction/LazilyCompactedRow.java b/src/java/org/apache/cassandra/db/compaction/LazilyCompactedRow.java
index b562ba5507..9962d3f2cf 100644
--- a/src/java/org/apache/cassandra/db/compaction/LazilyCompactedRow.java
+++ b/src/java/org/apache/cassandra/db/compaction/LazilyCompactedRow.java
@@ -134,6 +134,9 @@ public class LazilyCompactedRow extends AbstractCompactedRow implements Iterable
     {
         assert !closed;
 
+        // create merge iterator for reduced rows
+        Iterator<OnDiskAtom> iter = iterator();
+
         // no special-case for rows.size == 1, we're actually skipping some bytes here so just
         // blindly updating everything wouldn't be correct
         DataOutputBuffer out = new DataOutputBuffer();
@@ -142,7 +145,10 @@ public class LazilyCompactedRow extends AbstractCompactedRow implements Iterable
         {
             DeletionTime.serializer.serialize(emptyColumnFamily.deletionInfo().getTopLevelDeletion(), out);
             // do not update digest in case of missing or purged row level tombstones, see CASSANDRA-8979
-            if (emptyColumnFamily.deletionInfo().getTopLevelDeletion() != DeletionTime.LIVE)
+            // - digest for non-empty rows needs to be updated with deletion in any case to match digest with versions before patch
+            // - empty rows must not update digest in case of LIVE delete status to avoid mismatches with non-existing rows
+            //   this will however introduce in return a digest mismatch for versions before patch (which would update digest in any case)
+            if (iter.hasNext() || emptyColumnFamily.deletionInfo().getTopLevelDeletion() != DeletionTime.LIVE)
             {
                 digest.update(out.getData(), 0, out.getLength());
             }
@@ -154,7 +160,6 @@ public class LazilyCompactedRow extends AbstractCompactedRow implements Iterable
 
         // initialize indexBuilder for the benefit of its tombstoneTracker, used by our reducing iterator
         indexBuilder = new ColumnIndex.Builder(emptyColumnFamily, key.key, out);
-        Iterator<OnDiskAtom> iter = iterator();
         while (iter.hasNext())
             iter.next().updateDigest(digest);
         close();
diff --git a/src/java/org/apache/cassandra/db/compaction/PrecompactedRow.java b/src/java/org/apache/cassandra/db/compaction/PrecompactedRow.java
index f41e073ce0..db72847abe 100644
--- a/src/java/org/apache/cassandra/db/compaction/PrecompactedRow.java
+++ b/src/java/org/apache/cassandra/db/compaction/PrecompactedRow.java
@@ -157,20 +157,15 @@ public class PrecompactedRow extends AbstractCompactedRow
         if (compactedCf == null)
             return;
 
-        // do not update digest in case of missing or purged row level tombstones, see CASSANDRA-8979
-        if (compactedCf.deletionInfo().getTopLevelDeletion() != DeletionTime.LIVE)
+        DataOutputBuffer buffer = new DataOutputBuffer();
+        try
         {
-            DataOutputBuffer buffer = new DataOutputBuffer();
-            try
-            {
-                DeletionTime.serializer.serialize(compactedCf.deletionInfo().getTopLevelDeletion(), buffer);
-
-                digest.update(buffer.getData(), 0, buffer.getLength());
-            }
-            catch (IOException e)
-            {
-                throw new RuntimeException(e);
-            }
+            DeletionTime.serializer.serialize(compactedCf.deletionInfo().getTopLevelDeletion(), buffer);
+            digest.update(buffer.getData(), 0, buffer.getLength());
+        }
+        catch (IOException e)
+        {
+            throw new RuntimeException(e);
         }
         compactedCf.updateDigest(digest);
     }
