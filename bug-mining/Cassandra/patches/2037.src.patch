diff --git a/CHANGES.txt b/CHANGES.txt
index 455aa5dff9..9a4c475827 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -5,6 +5,7 @@
  * add memtable_flush_period_in_ms (CASSANDRA-4237)
  * replace supercolumns internally by composites (CASSANDRA-3237, 5123)
  * upgrade thrift to 0.9.0 (CASSANDRA-3719)
+ * drop unnecessary keyspace from user-defined compaction API (CASSANDRA-5139)
 
 
 1.2.2
diff --git a/src/java/org/apache/cassandra/db/compaction/CompactionManager.java b/src/java/org/apache/cassandra/db/compaction/CompactionManager.java
index 9c5bbe03a1..01cee9d0d7 100644
--- a/src/java/org/apache/cassandra/db/compaction/CompactionManager.java
+++ b/src/java/org/apache/cassandra/db/compaction/CompactionManager.java
@@ -29,9 +29,7 @@ import javax.management.ObjectName;
 
 import com.google.common.base.Predicates;
 import com.google.common.base.Throwables;
-import com.google.common.collect.ConcurrentHashMultiset;
-import com.google.common.collect.Iterators;
-import com.google.common.collect.Multiset;
+import com.google.common.collect.*;
 import com.google.common.primitives.Longs;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -44,6 +42,7 @@ import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.config.Schema;
 import org.apache.cassandra.db.*;
+import org.apache.cassandra.db.Table;
 import org.apache.cassandra.db.commitlog.ReplayPosition;
 import org.apache.cassandra.db.compaction.CompactionInfo.Holder;
 import org.apache.cassandra.db.index.SecondaryIndex;
@@ -361,42 +360,32 @@ public class CompactionManager implements CompactionManagerMBean
         return executor.submit(runnable);
     }
 
-    public void forceUserDefinedCompaction(String ksname, String dataFiles)
+    public void forceUserDefinedCompaction(String dataFiles)
     {
-        if (!Schema.instance.getTables().contains(ksname))
-            throw new IllegalArgumentException("Unknown keyspace " + ksname);
-
         String[] filenames = dataFiles.split(",");
-        Collection<Descriptor> descriptors = new ArrayList<Descriptor>(filenames.length);
+        Multimap<Pair<String, String>, Descriptor> descriptors = ArrayListMultimap.create();
 
-        String cfname = null;
         for (String filename : filenames)
         {
             // extract keyspace and columnfamily name from filename
             Descriptor desc = Descriptor.fromFilename(filename.trim());
-            if (!desc.ksname.equals(ksname))
-            {
-                throw new IllegalArgumentException("Given keyspace " + ksname + " does not match with file " + filename);
-            }
-            if (cfname == null)
-            {
-                cfname = desc.cfname;
-            }
-            else if (!cfname.equals(desc.cfname))
+            if (Schema.instance.getCFMetaData(desc) == null)
             {
-                throw new IllegalArgumentException("All provided sstables should be for the same column family");
+                logger.warn("Schema does not exist for file {}. Skipping.", filename);
+                continue;
             }
-            File directory = new File(ksname + File.separator + cfname);
+            File directory = new File(desc.ksname + File.separator + desc.cfname);
+            // group by keyspace/columnfamily
             Pair<Descriptor, String> p = Descriptor.fromFilename(directory, filename.trim());
-            if (!p.right.equals(Component.DATA.name()))
-            {
-                throw new IllegalArgumentException(filename + " does not appear to be a data file");
-            }
-            descriptors.add(p.left);
+            Pair<String, String> key = Pair.create(p.left.ksname, p.left.cfname);
+            descriptors.put(key, p.left);
         }
 
-        ColumnFamilyStore cfs = Table.open(ksname).getColumnFamilyStore(cfname);
-        submitUserDefined(cfs, descriptors, getDefaultGcBefore(cfs));
+        for (Pair<String, String> key : descriptors.keySet())
+        {
+            ColumnFamilyStore cfs = Table.open(key.left).getColumnFamilyStore(key.right);
+            submitUserDefined(cfs, descriptors.get(key), getDefaultGcBefore(cfs));
+        }
     }
 
     public Future<?> submitUserDefined(final ColumnFamilyStore cfs, final Collection<Descriptor> dataFiles, final int gcBefore)
diff --git a/src/java/org/apache/cassandra/db/compaction/CompactionManagerMBean.java b/src/java/org/apache/cassandra/db/compaction/CompactionManagerMBean.java
index e24e79c7d4..25f7c322b7 100644
--- a/src/java/org/apache/cassandra/db/compaction/CompactionManagerMBean.java
+++ b/src/java/org/apache/cassandra/db/compaction/CompactionManagerMBean.java
@@ -58,11 +58,13 @@ public interface CompactionManagerMBean
 
     /**
      * Triggers the compaction of user specified sstables.
+     * You can specify files from various keyspaces and columnfamilies.
+     * If you do so, user defined compaction is performed several times to the groups of files
+     * in the same keyspace/columnfamily.
      *
-     * @param ksname the keyspace for the sstables to compact
      * @param dataFiles a comma separated list of sstable filename to compact
      */
-    public void forceUserDefinedCompaction(String ksname, String dataFiles);
+    public void forceUserDefinedCompaction(String dataFiles);
 
     /**
      * Stop all running compaction-like tasks having the provided {@code type}.
diff --git a/test/unit/org/apache/cassandra/db/compaction/CompactionsTest.java b/test/unit/org/apache/cassandra/db/compaction/CompactionsTest.java
index 540e50b42b..94a95736c6 100644
--- a/test/unit/org/apache/cassandra/db/compaction/CompactionsTest.java
+++ b/test/unit/org/apache/cassandra/db/compaction/CompactionsTest.java
@@ -268,7 +268,7 @@ public class CompactionsTest extends SchemaLoader
         int prevGeneration = sstable.descriptor.generation;
         String file = new File(sstable.descriptor.filenameFor(Component.DATA)).getName();
         // submit user defined compaction on flushed sstable
-        CompactionManager.instance.forceUserDefinedCompaction(TABLE1, file);
+        CompactionManager.instance.forceUserDefinedCompaction(file);
         // wait until user defined compaction finishes
         do
         {
