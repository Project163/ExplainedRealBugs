diff --git a/CHANGES.txt b/CHANGES.txt
index 432faa8c4d..89aaea0249 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 3.0.26:
+ * Avoid useless SSTable reads during single partition queries (CASSANDRA-16944)
  * Debian init respects CASSANDRA_HEAPDUMP_DIR (CASSANDRA-13843)
  * Catch UnsatisfiedLinkError in WindowsTimer (CASSANDRA-16085)
  * Avoid removing batch when it's not created during view replication (CASSANDRA-16175)
diff --git a/src/java/org/apache/cassandra/db/SinglePartitionReadCommand.java b/src/java/org/apache/cassandra/db/SinglePartitionReadCommand.java
index d2ed3f25ea..dc9abc9760 100644
--- a/src/java/org/apache/cassandra/db/SinglePartitionReadCommand.java
+++ b/src/java/org/apache/cassandra/db/SinglePartitionReadCommand.java
@@ -893,6 +893,7 @@ public class SinglePartitionReadCommand extends ReadCommand
 
             long currentMaxTs = sstable.getMaxTimestamp();
             filter = reduceFilter(filter, result, currentMaxTs);
+
             if (filter == null)
                 break;
 
@@ -1047,10 +1048,21 @@ public class SinglePartitionReadCommand extends ReadCommand
      */
     private boolean isRowComplete(Row row, Columns requestedColumns, long sstableTimestamp)
     {
+        // Static rows do not have row deletion or primary key liveness info
+        if (!row.isStatic())
+        {
+            // If the row has been deleted or is part of a range deletion we know that we have enough information and can
+            // stop at this point.
+            // Note that deleted rows in compact tables (non static) do not have a row deletion. Single column
+            // cells are deleted instead. By consequence this check will not work for those, but the row will appear as complete later on
+            // in the method.
+            if (!row.deletion().isLive() && row.deletion().time().deletes(sstableTimestamp))
+                return true;
 
-        // Note that compact tables will always have an empty primary key liveness info.
-        if (metadata().isCQLTable() && (row.primaryKeyLivenessInfo().isEmpty() || row.primaryKeyLivenessInfo().timestamp() <= sstableTimestamp))
-            return false;
+            // Note that compact tables will always have an empty primary key liveness info.
+            if (metadata().isCQLTable() && (row.primaryKeyLivenessInfo().isEmpty() || row.primaryKeyLivenessInfo().timestamp() <= sstableTimestamp))
+                return false;
+        }
 
         for (ColumnDefinition column : requestedColumns)
         {
diff --git a/test/distributed/org/apache/cassandra/distributed/test/SinglePartitionReadCommandTest.java b/test/distributed/org/apache/cassandra/distributed/test/SinglePartitionReadCommandTest.java
index 0b7b0e7543..3f53b6bc4d 100644
--- a/test/distributed/org/apache/cassandra/distributed/test/SinglePartitionReadCommandTest.java
+++ b/test/distributed/org/apache/cassandra/distributed/test/SinglePartitionReadCommandTest.java
@@ -144,4 +144,79 @@ public class SinglePartitionReadCommandTest extends TestBaseImpl
             assertRows(cluster.coordinator(2).execute(withKeyspace("SELECT DISTINCT s1 FROM %s.tbl WHERE pk=2"), ConsistencyLevel.ALL));
         }
     }
+
+    @Test
+    public void testCompactAndNonCompactTableWithRowOnOneNodeAndRowDeletionOnTheOther() throws Throwable
+    {
+        for (String options : new String[] {"WITH COMPACT STORAGE", ""})
+        {
+            try (Cluster cluster = init(builder().withNodes(2).start()))
+            {
+                cluster.schemaChange(withKeyspace("CREATE TABLE %s.tbl (pk int, ck text, v int, PRIMARY KEY (pk, ck)) " + options));
+                cluster.get(1).executeInternal(withKeyspace("INSERT INTO %s.tbl (pk, ck, v) VALUES (1, '1', 1) USING TIMESTAMP 1000"));
+                cluster.get(1).executeInternal(withKeyspace("INSERT INTO %s.tbl (pk, ck, v) VALUES (2, '1', 1) USING TIMESTAMP 1001"));
+                cluster.get(1).flush(KEYSPACE);
+                cluster.get(1).executeInternal(withKeyspace("UPDATE %s.tbl USING TIMESTAMP 2000 SET v = 2 WHERE pk = 1 AND ck = '1'"));
+                cluster.get(1).executeInternal(withKeyspace("INSERT INTO %s.tbl (pk, ck, v) VALUES (2, '2', 2) USING TIMESTAMP 3001"));
+                cluster.get(1).flush(KEYSPACE);
+
+                cluster.get(2).executeInternal(withKeyspace("DELETE FROM %s.tbl USING TIMESTAMP 2001 WHERE pk=2 AND ck='1'"));
+                cluster.get(2).executeInternal(withKeyspace("DELETE FROM %s.tbl USING TIMESTAMP 3000 WHERE pk=1 AND ck='1'"));
+                cluster.get(2).flush(KEYSPACE);
+
+                assertRows(cluster.coordinator(2).execute(withKeyspace("SELECT * FROM %s.tbl WHERE pk=1 AND ck='1'"), ConsistencyLevel.ALL));
+                assertRows(cluster.coordinator(2).execute(withKeyspace("SELECT v FROM %s.tbl WHERE pk=1 AND ck='1'"), ConsistencyLevel.ALL));
+
+                assertRows(cluster.coordinator(2).execute(withKeyspace("SELECT * FROM %s.tbl WHERE pk=2 AND ck='1'"), ConsistencyLevel.ALL,
+                           row(2, "2", 2)));
+                assertRows(cluster.coordinator(2).execute(withKeyspace("SELECT v FROM %s.tbl WHERE pk=2 AND ck='1'"), ConsistencyLevel.ALL,
+                           row(2)));
+            }
+        }
+    }
+
+    @Test
+    public void testCompactAndNonCompactTableWithRowOnOneNodeAndRangeDeletionOnTheOther() throws Throwable
+    {
+        for (String options : new String[] {"WITH COMPACT STORAGE", ""})
+        {
+            try (Cluster cluster = init(builder().withNodes(2).start()))
+            {
+                cluster.schemaChange(
+                        withKeyspace("CREATE TABLE %s.tbl (pk int, ck text, v int, PRIMARY KEY (pk, ck)) " + options));
+                cluster.get(1).executeInternal(
+                        withKeyspace("INSERT INTO %s.tbl (pk, ck, v) VALUES (1, '1', 1) USING TIMESTAMP 1000"));
+                cluster.get(1).executeInternal(
+                        withKeyspace("INSERT INTO %s.tbl (pk, ck, v) VALUES (1, '2', 2) USING TIMESTAMP 1001"));
+                cluster.get(1).executeInternal(
+                        withKeyspace("INSERT INTO %s.tbl (pk, ck, v) VALUES (2, '1', 1) USING TIMESTAMP 1001"));
+                cluster.get(1).flush(KEYSPACE);
+                cluster.get(1).executeInternal(
+                        withKeyspace("UPDATE %s.tbl USING TIMESTAMP 2000 SET v = 2 WHERE pk = 1 AND ck = '1'"));
+                cluster.get(1).executeInternal(
+                        withKeyspace("INSERT INTO %s.tbl (pk, ck, v) VALUES (2, '2', 2) USING TIMESTAMP 3001"));
+                cluster.get(1).flush(KEYSPACE);
+
+                cluster.get(2).executeInternal(
+                        withKeyspace("DELETE FROM %s.tbl USING TIMESTAMP 2001 WHERE pk=2 AND ck >= '1' AND ck < '2'"));
+                cluster.get(2).executeInternal(
+                        withKeyspace("DELETE FROM %s.tbl USING TIMESTAMP 3000 WHERE pk=1 AND ck >= '1'"));
+                cluster.get(2).flush(KEYSPACE);
+
+                assertRows(cluster.coordinator(2).execute(withKeyspace("SELECT * FROM %s.tbl WHERE pk=1 AND ck='1'"),
+                        ConsistencyLevel.ALL));
+                assertRows(cluster.coordinator(2).execute(withKeyspace("SELECT v FROM %s.tbl WHERE pk=1 AND ck='1'"),
+                        ConsistencyLevel.ALL));
+                assertRows(cluster.coordinator(2).execute(withKeyspace("SELECT * FROM %s.tbl WHERE pk=1 AND ck='2'"),
+                        ConsistencyLevel.ALL, row(1, "2", 2)));
+                assertRows(cluster.coordinator(2).execute(withKeyspace("SELECT v FROM %s.tbl WHERE pk=1 AND ck='2'"),
+                        ConsistencyLevel.ALL, row(2)));
+
+                assertRows(cluster.coordinator(2).execute(withKeyspace("SELECT * FROM %s.tbl WHERE pk=1 AND ck='1'"),
+                        ConsistencyLevel.ALL, row(2, "2", 2)));
+                assertRows(cluster.coordinator(2).execute(withKeyspace("SELECT v FROM %s.tbl WHERE pk=1 AND ck='1'"),
+                        ConsistencyLevel.ALL, row(2)));
+            }
+        }
+    }
 }
\ No newline at end of file
diff --git a/test/unit/org/apache/cassandra/cql3/validation/miscellaneous/SSTablesIteratedTest.java b/test/unit/org/apache/cassandra/cql3/validation/miscellaneous/SSTablesIteratedTest.java
index 684f158dbd..44233d6e85 100644
--- a/test/unit/org/apache/cassandra/cql3/validation/miscellaneous/SSTablesIteratedTest.java
+++ b/test/unit/org/apache/cassandra/cql3/validation/miscellaneous/SSTablesIteratedTest.java
@@ -149,7 +149,7 @@ public class SSTablesIteratedTest extends CQLTester
         execute("DELETE FROM %s WHERE pk = 1 AND ck = 1");
         flush();
 
-        executeAndCheck("SELECT * FROM %s WHERE pk = 1 AND ck = 1", 2);
+        executeAndCheck("SELECT * FROM %s WHERE pk = 1 AND ck = 1", 1);
     }
 
     @Test
@@ -163,7 +163,7 @@ public class SSTablesIteratedTest extends CQLTester
         execute("DELETE FROM %s WHERE a=? AND b=?", 1, 1);
         flush();
 
-        executeAndCheck("SELECT * FROM %s WHERE a=1 AND b=1 AND c=1", 2);
+        executeAndCheck("SELECT * FROM %s WHERE a=1 AND b=1 AND c=1", 1);
     }
 
     @Test
@@ -294,10 +294,10 @@ public class SSTablesIteratedTest extends CQLTester
         execute("DELETE FROM %s WHERE a=? AND b=?", 1, 1);
         flush();
 
-        executeAndCheck("SELECT * FROM %s WHERE a=1 AND b=1 AND c=1", 2);
+        executeAndCheck("SELECT * FROM %s WHERE a=1 AND b=1 AND c=1", 1);
 
         execute("ALTER TABLE %s DROP COMPACT STORAGE");
-        executeAndCheck("SELECT * FROM %s WHERE a=1 AND b=1 AND c=1", 2);
+        executeAndCheck("SELECT * FROM %s WHERE a=1 AND b=1 AND c=1", 1);
     }
 
     @Test
@@ -316,10 +316,10 @@ public class SSTablesIteratedTest extends CQLTester
         execute("DELETE FROM %s WHERE a=? AND b=?", 1, 1);
         flush();
 
-        executeAndCheck("SELECT * FROM %s WHERE a=1 AND b=1 AND c=1", 3);
+        executeAndCheck("SELECT * FROM %s WHERE a=1 AND b=1 AND c=1", 1);
 
         execute("ALTER TABLE %s DROP COMPACT STORAGE");
-        executeAndCheck("SELECT * FROM %s WHERE a=1 AND b=1 AND c=1", 3);
+        executeAndCheck("SELECT * FROM %s WHERE a=1 AND b=1 AND c=1", 1);
     }
 
     @Test
@@ -342,7 +342,12 @@ public class SSTablesIteratedTest extends CQLTester
         executeAndCheck("SELECT * FROM %s WHERE a=1 AND b=1 AND c=1", 1);
 
         execute("ALTER TABLE %s DROP COMPACT STORAGE");
-        executeAndCheck("SELECT * FROM %s WHERE a=1 AND b=1 AND c=1", 3);
+
+        // For non static compact tables, row deletions are done through deletion of the compact column (d in this case).
+        // Once converted into non compact table as the row does not have a primary key liveness the code does not
+        // have enough to allow the logic to stop at the first SSTable and has to read the second one where it find
+        // the range deletion.
+        executeAndCheck("SELECT * FROM %s WHERE a=1 AND b=1 AND c=1", 2);
     }
 
     @Test
@@ -760,21 +765,21 @@ public class SSTablesIteratedTest extends CQLTester
         execute("UPDATE %s USING TIMESTAMP 3003 SET v1 = ? WHERE pk = ? AND c = ?", 3, 4, 1);
         flush();
 
-        executeAndCheck("SELECT * FROM %s WHERE pk = 1 AND c = 1", 3);
-        executeAndCheck("SELECT c, v1 FROM %s WHERE pk = 1 AND c = 1", 3);
-        executeAndCheck("SELECT v1, v2 FROM %s WHERE pk = 1 AND c = 1", 3);
+        executeAndCheck("SELECT * FROM %s WHERE pk = 1 AND c = 1", 1);
+        executeAndCheck("SELECT c, v1 FROM %s WHERE pk = 1 AND c = 1", 1);
+        executeAndCheck("SELECT v1, v2 FROM %s WHERE pk = 1 AND c = 1", 1);
 
-        executeAndCheck("SELECT * FROM %s WHERE pk = 2 AND c = 1", 3, row(2, 1, 3, null));
-        executeAndCheck("SELECT v1, v2 FROM %s WHERE pk = 2 AND c = 1", 3, row(3, null));
-        executeAndCheck("SELECT v2 FROM %s WHERE pk = 2 AND c = 1", 3, row((Integer) null));
+        executeAndCheck("SELECT * FROM %s WHERE pk = 2 AND c = 1", 2, row(2, 1, 3, null));
+        executeAndCheck("SELECT v1, v2 FROM %s WHERE pk = 2 AND c = 1", 2, row(3, null));
+        executeAndCheck("SELECT v2 FROM %s WHERE pk = 2 AND c = 1", 2, row((Integer) null));
 
-        executeAndCheck("SELECT * FROM %s WHERE pk = 3 AND c = 1", 3);
-        executeAndCheck("SELECT c, v1 FROM %s WHERE pk = 3 AND c = 1", 3);
-        executeAndCheck("SELECT v1, v2 FROM %s WHERE pk = 3 AND c = 1", 3);
+        executeAndCheck("SELECT * FROM %s WHERE pk = 3 AND c = 1", 1);
+        executeAndCheck("SELECT c, v1 FROM %s WHERE pk = 3 AND c = 1", 1);
+        executeAndCheck("SELECT v1, v2 FROM %s WHERE pk = 3 AND c = 1", 1);
 
-        executeAndCheck("SELECT * FROM %s WHERE pk = 4 AND c = 1", 3, row(4, 1, 3, null));
-        executeAndCheck("SELECT v1, v2 FROM %s WHERE pk = 4 AND c = 1", 3, row(3, null));
-        executeAndCheck("SELECT v2 FROM %s WHERE pk = 4 AND c = 1", 3, row((Integer) null));
+        executeAndCheck("SELECT * FROM %s WHERE pk = 4 AND c = 1", 2, row(4, 1, 3, null));
+        executeAndCheck("SELECT v1, v2 FROM %s WHERE pk = 4 AND c = 1", 2, row(3, null));
+        executeAndCheck("SELECT v2 FROM %s WHERE pk = 4 AND c = 1", 2, row((Integer) null));
     }
 
     @Test
@@ -798,21 +803,21 @@ public class SSTablesIteratedTest extends CQLTester
         execute("UPDATE %s USING TIMESTAMP 3003 SET v1 = ? WHERE pk = ? AND c = ?", 3, 4, 1);
         flush();
 
-        executeAndCheck("SELECT * FROM %s WHERE pk = 1 AND c = 1", 3);
-        executeAndCheck("SELECT c, v1 FROM %s WHERE pk = 1 AND c = 1", 3);
-        executeAndCheck("SELECT v1, v2 FROM %s WHERE pk = 1 AND c = 1", 3);
+        executeAndCheck("SELECT * FROM %s WHERE pk = 1 AND c = 1", 1);
+        executeAndCheck("SELECT c, v1 FROM %s WHERE pk = 1 AND c = 1", 1);
+        executeAndCheck("SELECT v1, v2 FROM %s WHERE pk = 1 AND c = 1", 1);
 
-        executeAndCheck("SELECT * FROM %s WHERE pk = 2 AND c = 1", 3, row(2, 1, 3, null));
-        executeAndCheck("SELECT v1, v2 FROM %s WHERE pk = 2 AND c = 1", 3, row(3, null));
-        executeAndCheck("SELECT v2 FROM %s WHERE pk = 2 AND c = 1", 3, row((Integer) null));
+        executeAndCheck("SELECT * FROM %s WHERE pk = 2 AND c = 1", 2, row(2, 1, 3, null));
+        executeAndCheck("SELECT v1, v2 FROM %s WHERE pk = 2 AND c = 1", 2, row(3, null));
+        executeAndCheck("SELECT v2 FROM %s WHERE pk = 2 AND c = 1", 2, row((Integer) null));
 
-        executeAndCheck("SELECT * FROM %s WHERE pk = 3 AND c = 1", 3);
-        executeAndCheck("SELECT c, v1 FROM %s WHERE pk = 3 AND c = 1", 3);
-        executeAndCheck("SELECT v1, v2 FROM %s WHERE pk = 3 AND c = 1", 3);
+        executeAndCheck("SELECT * FROM %s WHERE pk = 3 AND c = 1", 1);
+        executeAndCheck("SELECT c, v1 FROM %s WHERE pk = 3 AND c = 1", 1);
+        executeAndCheck("SELECT v1, v2 FROM %s WHERE pk = 3 AND c = 1", 1);
 
-        executeAndCheck("SELECT * FROM %s WHERE pk = 4 AND c = 1", 3, row(4, 1, 3, null));
-        executeAndCheck("SELECT v1, v2 FROM %s WHERE pk = 4 AND c = 1", 3, row(3, null));
-        executeAndCheck("SELECT v2 FROM %s WHERE pk = 4 AND c = 1", 3, row((Integer) null));
+        executeAndCheck("SELECT * FROM %s WHERE pk = 4 AND c = 1", 2, row(4, 1, 3, null));
+        executeAndCheck("SELECT v1, v2 FROM %s WHERE pk = 4 AND c = 1", 2, row(3, null));
+        executeAndCheck("SELECT v2 FROM %s WHERE pk = 4 AND c = 1", 2, row((Integer) null));
     }
 
     @Test
@@ -983,4 +988,168 @@ public class SSTablesIteratedTest extends CQLTester
         executeAndCheck("SELECT v1, v2 FROM %s WHERE pk = 4", 3, row(3, null));
         executeAndCheck("SELECT v2 FROM %s WHERE pk = 4", 3, row((Integer) null));
     }
+
+    @Test
+    public void testNonCompactTableWithStaticColumnAndRowDeletion() throws Throwable
+    {
+        createTable("CREATE TABLE %s (pk int, c int, s int static, v int, PRIMARY KEY(pk, c))");
+
+        execute("INSERT INTO %s (pk, c, s, v) VALUES (?, ?, ?, ?) USING TIMESTAMP 1000", 1, 1, 1, 1);
+        execute("INSERT INTO %s (pk, s) VALUES (?, ?) USING TIMESTAMP 1001", 2, 2);
+        execute("INSERT INTO %s (pk, c, v) VALUES (?, ?, ?) USING TIMESTAMP 1002", 3, 1, 1);
+        flush();
+        execute("UPDATE %s USING TIMESTAMP 2000 SET v = ? WHERE pk = ? AND c = ?", 2, 1, 1);
+        execute("INSERT INTO %s (pk, c, v) VALUES (?, ?, ?) USING TIMESTAMP 2001", 2, 1, 2);
+        execute("DELETE FROM %s USING TIMESTAMP 2001 WHERE pk = ? AND c = ?", 3, 1);
+        flush();
+        execute("DELETE FROM %s USING TIMESTAMP 3000 WHERE pk = ? AND c = ?", 1, 1);
+        execute("DELETE FROM %s USING TIMESTAMP 3001 WHERE pk = ? AND c = ?", 2, 1);
+        execute("INSERT INTO %s (pk, s) VALUES (?, ?) USING TIMESTAMP 3002", 3, 3);
+        flush();
+
+        executeAndCheck("SELECT * FROM %s WHERE pk = 1", 3, row(1, null, 1, null));
+        executeAndCheck("SELECT * FROM %s WHERE pk = 1 AND c = 1", 3);
+        // In 3.0 the SinglePartitionReadCommand is looking for all the fetching columns which always includes the
+        // static ones so it needs to go through all the SSTables.
+        executeAndCheck("SELECT v FROM %s WHERE pk = 1 AND c = 1", 3);
+
+        executeAndCheck("SELECT * FROM %s WHERE pk = 2", 3, row(2, null, 2, null));
+        executeAndCheck("SELECT * FROM %s WHERE pk = 2 AND c = 1", 3);
+        executeAndCheck("SELECT v FROM %s WHERE pk = 2 AND c = 1", 3);
+
+        executeAndCheck("SELECT * FROM %s WHERE pk = 3", 3, row(3, null, 3, null));
+        executeAndCheck("SELECT * FROM %s WHERE pk = 3 AND c = 1", 2);
+        executeAndCheck("SELECT v FROM %s WHERE pk = 3 AND c = 1", 2);
+    }
+
+    @Test
+    public void testNonCompactTableWithStaticColumnAndRangeDeletion() throws Throwable
+    {
+        createTable("CREATE TABLE %s (pk int, c int, s int static, v int, PRIMARY KEY(pk, c))");
+
+        execute("INSERT INTO %s (pk, c, s, v) VALUES (?, ?, ?, ?) USING TIMESTAMP 1000", 1, 1, 1, 1);
+        execute("INSERT INTO %s (pk, s) VALUES (?, ?) USING TIMESTAMP 1001", 2, 2);
+        execute("INSERT INTO %s (pk, c, v) VALUES (?, ?, ?) USING TIMESTAMP 1002", 3, 1, 1);
+        flush();
+        execute("UPDATE %s USING TIMESTAMP 2000 SET v = ? WHERE pk = ? AND c = ?", 2, 1, 1);
+        execute("INSERT INTO %s (pk, c, v) VALUES (?, ?, ?) USING TIMESTAMP 2001", 2, 1, 2);
+        execute("DELETE FROM %s USING TIMESTAMP 2001 WHERE pk = ? AND c >= ?", 3, 0);
+        flush();
+        execute("DELETE FROM %s USING TIMESTAMP 3000 WHERE pk = ? AND c > ?", 1, 0);
+        execute("DELETE FROM %s USING TIMESTAMP 3001 WHERE pk = ? AND c > ?", 2, 0);
+        execute("INSERT INTO %s (pk, s) VALUES (?, ?) USING TIMESTAMP 3002", 3, 3);
+        flush();
+
+        executeAndCheck("SELECT * FROM %s WHERE pk = 1", 3, row(1, null, 1, null));
+        executeAndCheck("SELECT * FROM %s WHERE pk = 1 AND c = 1", 3);
+        // In 3.0 the SinglePartitionReadCommand is looking for all the fetching columns which always includes the
+        // static ones so it needs to go through all the SSTables.
+        executeAndCheck("SELECT v FROM %s WHERE pk = 1 AND c = 1", 3);
+
+        executeAndCheck("SELECT * FROM %s WHERE pk = 2", 3, row(2, null, 2, null));
+        executeAndCheck("SELECT * FROM %s WHERE pk = 2 AND c = 1", 3);
+        executeAndCheck("SELECT v FROM %s WHERE pk = 2 AND c = 1", 3);
+
+        executeAndCheck("SELECT * FROM %s WHERE pk = 3", 3, row(3, null, 3, null));
+        executeAndCheck("SELECT * FROM %s WHERE pk = 3 AND c = 1", 2);
+        executeAndCheck("SELECT v FROM %s WHERE pk = 3 AND c = 1", 2);
+    }
+
+    @Test
+    public void testNonCompactTableWithStaticColumn() throws Throwable
+    {
+        createTable("CREATE TABLE %s (pk int, c int, s int static, v int, PRIMARY KEY(pk, c))");
+
+        execute("INSERT INTO %s (pk, c, s, v) VALUES (?, ?, ?, ?) USING TIMESTAMP 1000", 1, 1, 1, 1);
+        execute("INSERT INTO %s (pk, c, v) VALUES (?, ?, ?) USING TIMESTAMP 1001", 2, 1, 1);
+        execute("INSERT INTO %s (pk, c, v) VALUES (?, ?, ?) USING TIMESTAMP 1002", 3, 1, 1);
+        flush();
+        execute("UPDATE %s USING TIMESTAMP 2000 SET v = ? WHERE pk = ? AND c = ?", 2, 1, 1);
+        execute("UPDATE %s USING TIMESTAMP 2001 SET v = ? WHERE pk = ? AND c = ?", 2, 2, 1);
+        execute("INSERT INTO %s (pk, c, v) VALUES (?, ?, ?) USING TIMESTAMP 2002", 3, 1, 2);
+        flush();
+        execute("UPDATE %s USING TIMESTAMP 3000 SET s = ? WHERE pk = ?", 2, 1);
+        execute("INSERT INTO %s (pk, s) VALUES (?, ?) USING TIMESTAMP 3001", 2, 1);
+        execute("INSERT INTO %s (pk, c, s, v) VALUES (?, ?, ?, ?) USING TIMESTAMP 3002", 3, 1, 1, 3);
+        flush();
+
+        executeAndCheck("SELECT * FROM %s WHERE pk = 1", 3, row(1, 1, 2, 2));
+        executeAndCheck("SELECT * FROM %s WHERE pk = 1 AND c = 1", 3, row(1, 1, 2, 2));
+        executeAndCheck("SELECT v FROM %s WHERE pk = 1 AND c = 1", 3, row(2));
+        executeAndCheck("SELECT s FROM %s WHERE pk = 1", 3, row(2));
+        executeAndCheck("SELECT DISTINCT s FROM %s WHERE pk = 1", 3, row(2));
+
+        executeAndCheck("SELECT * FROM %s WHERE pk = 2", 3, row(2, 1, 1, 2));
+        executeAndCheck("SELECT * FROM %s WHERE pk = 2 AND c = 1", 3, row(2, 1, 1, 2));
+        executeAndCheck("SELECT v FROM %s WHERE pk = 2 AND c = 1", 3, row(2));
+        executeAndCheck("SELECT s FROM %s WHERE pk = 2", 3, row(1));
+        executeAndCheck("SELECT DISTINCT s FROM %s WHERE pk = 2", 3, row(1));
+
+        executeAndCheck("SELECT * FROM %s WHERE pk = 3", 3, row(3, 1, 1, 3));
+        executeAndCheck("SELECT * FROM %s WHERE pk = 3 AND c = 1", 1, row(3, 1, 1, 3));
+        executeAndCheck("SELECT v FROM %s WHERE pk = 3 AND c = 1", 1, row(3));
+        executeAndCheck("SELECT s FROM %s WHERE pk = 3", 3, row(1));
+        executeAndCheck("SELECT DISTINCT s FROM %s WHERE pk = 3", 3, row(1));
+    }
+
+    @Test
+    public void testCompactStaticTable() throws Throwable
+    {
+        createTable("CREATE TABLE %s (pk int PRIMARY KEY, v int) WITH COMPACT STORAGE");
+
+        execute("INSERT INTO %s (pk, v) VALUES (?, ?) USING TIMESTAMP 1000", 1, 1);
+        execute("INSERT INTO %s (pk, v) VALUES (?, ?) USING TIMESTAMP 1001", 2, 1);
+        execute("INSERT INTO %s (pk, v) VALUES (?, ?) USING TIMESTAMP 1002", 3, 1);
+        execute("INSERT INTO %s (pk, v) VALUES (?, ?) USING TIMESTAMP 1003", 4, 1);
+        flush();
+        execute("INSERT INTO %s (pk, v) VALUES (?, ?) USING TIMESTAMP 2000", 1, 2);
+        execute("UPDATE %s USING TIMESTAMP 2001 SET v = ? WHERE pk = ?", 2, 2);
+        execute("DELETE FROM %s USING TIMESTAMP 2002 WHERE pk = ?", 3);
+        execute("DELETE v FROM %s USING TIMESTAMP 2003 WHERE pk = ?", 4);
+        flush();
+
+        executeAndCheck("SELECT * FROM %s WHERE pk = 1", 1, row(1, 2));
+        executeAndCheck("SELECT v FROM %s WHERE pk = 1", 1, row(2));
+        executeAndCheck("SELECT * FROM %s WHERE pk = 2", 1, row(2, 2));
+        executeAndCheck("SELECT v FROM %s WHERE pk = 2", 1, row(2));
+        executeAndCheck("SELECT * FROM %s WHERE pk = 3", 1);
+        executeAndCheck("SELECT v FROM %s WHERE pk = 3", 1);
+        executeAndCheck("SELECT * FROM %s WHERE pk = 4", 1);
+        executeAndCheck("SELECT v FROM %s WHERE pk = 4", 1);
+    }
+
+    @Test
+    public void testNonCompositeCompactTableWithMultipleRegularColumns() throws Throwable
+    {
+        createTable("CREATE TABLE %s (pk int PRIMARY KEY, v1 int, v2 int) WITH COMPACT STORAGE");
+
+        execute("INSERT INTO %s (pk, v1, v2) VALUES (?, ?, ?) USING TIMESTAMP 1000", 1, 1, 1);
+        execute("INSERT INTO %s (pk, v1, v2) VALUES (?, ?, ?) USING TIMESTAMP 1001", 2, 1, 1);
+        execute("INSERT INTO %s (pk, v1, v2) VALUES (?, ?, ?) USING TIMESTAMP 1002", 3, 1, 1);
+        execute("INSERT INTO %s (pk, v1, V2) VALUES (?, ?, ?) USING TIMESTAMP 1003", 4, 1, 1);
+        execute("INSERT INTO %s (pk, v1, V2) VALUES (?, ?, ?) USING TIMESTAMP 1004", 5, 1, 1);
+        flush();
+        execute("INSERT INTO %s (pk, v1) VALUES (?, ?) USING TIMESTAMP 2000", 1, 2);
+        execute("UPDATE %s USING TIMESTAMP 2001 SET v1 = ? WHERE pk = ?", 2, 2);
+        execute("DELETE FROM %s USING TIMESTAMP 2002 WHERE pk = ?", 3);
+        execute("DELETE v1 FROM %s USING TIMESTAMP 2003 WHERE pk = ?", 4);
+        execute("DELETE v1, v2 FROM %s USING TIMESTAMP 2004 WHERE pk = ?", 5);
+        flush();
+
+        executeAndCheck("SELECT * FROM %s WHERE pk = 1", 2, row(1, 2, 1));
+        executeAndCheck("SELECT v1 FROM %s WHERE pk = 1", 2, row(2));
+        executeAndCheck("SELECT v2 FROM %s WHERE pk = 1", 2, row(1));
+        executeAndCheck("SELECT * FROM %s WHERE pk = 2", 2, row(2, 2, 1));
+        executeAndCheck("SELECT v1 FROM %s WHERE pk = 2", 2, row(2));
+        executeAndCheck("SELECT v2 FROM %s WHERE pk = 2", 2, row(1));
+        executeAndCheck("SELECT * FROM %s WHERE pk = 3", 1);
+        executeAndCheck("SELECT v1 FROM %s WHERE pk = 3", 1);
+        executeAndCheck("SELECT v2 FROM %s WHERE pk = 3", 1);
+        executeAndCheck("SELECT * FROM %s WHERE pk = 4", 2, row(4, null, 1));
+        executeAndCheck("SELECT v1 FROM %s WHERE pk = 4", 2, row((Integer) null));
+        executeAndCheck("SELECT v2 FROM %s WHERE pk = 4", 2, row(1));
+        executeAndCheck("SELECT * FROM %s WHERE pk = 5", 1);
+        executeAndCheck("SELECT v1 FROM %s WHERE pk = 5", 1);
+        executeAndCheck("SELECT v2 FROM %s WHERE pk = 5", 1);
+    }
 }
