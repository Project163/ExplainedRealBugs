diff --git a/CHANGES.txt b/CHANGES.txt
index bfece4fbf2..0045e04ff3 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -16,6 +16,8 @@
  * Set isRunning flag later in binary protocol server (CASSANDRA-5467)
  * Fix use of CQL3 functions with descencind clustering order (CASSANDRA-5472)
  * Prevent repair when protocol version does not match (CASSANDRA-5523)
+ * Disallow renaming columns one at a time for thrift table in CQL3
+   (CASSANDRA-5531)
 Merged from 1.1
  * Add retry mechanism to OTC for non-droppable_verbs (CASSANDRA-5393)
  * Use allocator information to improve memtable memory usage estimate
diff --git a/pylib/cqlshlib/cql3handling.py b/pylib/cqlshlib/cql3handling.py
index 00e2d0f03c..15f7c543a9 100644
--- a/pylib/cqlshlib/cql3handling.py
+++ b/pylib/cqlshlib/cql3handling.py
@@ -1469,7 +1469,7 @@ class CqlTableDef:
         cf.partition_key_validator = lookup_casstype(cf.key_validator)
         cf.comparator = lookup_casstype(cf.comparator)
         cf.default_validator = lookup_casstype(cf.default_validator)
-        cf.coldefs = coldefs
+        cf.coldefs = cf.filter_regular_coldefs(coldefs)
         cf.compact_storage = cf.is_compact_storage()
         cf.key_aliases = cf.get_key_aliases()
         cf.partition_key_components = cf.key_aliases
@@ -1478,6 +1478,10 @@ class CqlTableDef:
         cf.columns = cf.get_columns()
         return cf
 
+    def filter_regular_coldefs(self, cols):
+        return [ c for c in cols if c.get('type', 'regular') == 'regular' ]
+
+
     # not perfect, but good enough; please read CFDefinition constructor comments
     # returns False if we are dealing with a CQL3 table, True otherwise.
     # 'compact' here means 'needs WITH COMPACT STORAGE option for CREATE TABLE in CQL3'.
diff --git a/src/java/org/apache/cassandra/cql3/statements/AlterTableStatement.java b/src/java/org/apache/cassandra/cql3/statements/AlterTableStatement.java
index b07a8a8caa..c6af2a02f3 100644
--- a/src/java/org/apache/cassandra/cql3/statements/AlterTableStatement.java
+++ b/src/java/org/apache/cassandra/cql3/statements/AlterTableStatement.java
@@ -22,6 +22,10 @@ import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
+
+import com.google.common.base.Predicate;
+import com.google.common.collect.Sets;
 
 import org.apache.cassandra.auth.Permission;
 import org.apache.cassandra.config.CFMetaData;
@@ -187,6 +191,12 @@ public class AlterTableStatement extends SchemaAlteringStatement
                 cfProps.applyToCFMetadata(cfm);
                 break;
             case RENAME:
+
+                if (cfm.getKeyAliases().size() < cfDef.keys.size() && !renamesAllAliases(cfDef, renames.keySet(), CFDefinition.Name.Kind.KEY_ALIAS, cfDef.keys.size()))
+                    throw new InvalidRequestException("When upgrading from Thrift, all the columns of the (composite) partition key must be renamed together.");
+                if (cfm.getColumnAliases().size() < cfDef.columns.size() && !renamesAllAliases(cfDef, renames.keySet(), CFDefinition.Name.Kind.COLUMN_ALIAS, cfDef.columns.size()))
+                    throw new InvalidRequestException("When upgrading from Thrift, all the columns of the (composite) clustering key must be renamed together.");
+
                 for (Map.Entry<ColumnIdentifier, ColumnIdentifier> entry : renames.entrySet())
                 {
                     CFDefinition.Name from = cfDef.get(entry.getKey());
@@ -219,6 +229,24 @@ public class AlterTableStatement extends SchemaAlteringStatement
         MigrationManager.announceColumnFamilyUpdate(cfm);
     }
 
+    private static boolean renamesAllAliases(CFDefinition cfDef, Set<ColumnIdentifier> names, CFDefinition.Name.Kind kind, int expected)
+    {
+        int renamed = Sets.filter(names, isA(cfDef, kind)).size();
+        return renamed == 0 || renamed == expected;
+    }
+
+    private static Predicate<ColumnIdentifier> isA(final CFDefinition cfDef, final CFDefinition.Name.Kind kind)
+    {
+        return new Predicate<ColumnIdentifier>()
+        {
+            public boolean apply(ColumnIdentifier input)
+            {
+                CFDefinition.Name name = cfDef.get(input);
+                return name != null && name.kind == kind;
+            }
+        };
+    }
+
     private static List<ByteBuffer> rename(int pos, ColumnIdentifier newName, List<ByteBuffer> aliases)
     {
         if (pos < aliases.size())
@@ -229,6 +257,7 @@ public class AlterTableStatement extends SchemaAlteringStatement
         }
         else
         {
+            // We insert nulls temporarly, but have checked that all the aliases are renamed
             List<ByteBuffer> newList = new ArrayList<ByteBuffer>(pos + 1);
             for (int i = 0; i < pos; ++i)
                 newList.add(i < aliases.size() ? aliases.get(i) : null);
