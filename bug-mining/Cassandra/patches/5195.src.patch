diff --git a/CHANGES.txt b/CHANGES.txt
index 652833ee76..eae281518f 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 3.0.19
+ * Handle paging states serialized with a different version than the session's (CASSANDRA-15176)
  * Throw IOE instead of asserting on unsupporter peer versions (CASSANDRA-15066)
  * Update token metadata when handling MOVING/REMOVING_TOKEN events (CASSANDRA-15120)
  * Add ability to customize cassandra log directory using $CASSANDRA_LOG_DIR (CASSANDRA-15090)
diff --git a/src/java/org/apache/cassandra/io/util/DataOutputBuffer.java b/src/java/org/apache/cassandra/io/util/DataOutputBuffer.java
index 7586543f3a..195fdb4e91 100644
--- a/src/java/org/apache/cassandra/io/util/DataOutputBuffer.java
+++ b/src/java/org/apache/cassandra/io/util/DataOutputBuffer.java
@@ -163,6 +163,19 @@ public class DataOutputBuffer extends BufferedDataOutputStreamPlus
 
     public ByteBuffer buffer()
     {
+        return buffer(true);
+    }
+
+    public ByteBuffer buffer(boolean duplicate)
+    {
+        if (!duplicate)
+        {
+            ByteBuffer buf = buffer;
+            buf.flip();
+            buffer = null;
+            return buf;
+        }
+
         ByteBuffer result = buffer.duplicate();
         result.flip();
         return result;
diff --git a/src/java/org/apache/cassandra/service/pager/PagingState.java b/src/java/org/apache/cassandra/service/pager/PagingState.java
index 30e14c3c50..7de7e6f69c 100644
--- a/src/java/org/apache/cassandra/service/pager/PagingState.java
+++ b/src/java/org/apache/cassandra/service/pager/PagingState.java
@@ -21,10 +21,12 @@ import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.util.*;
 
+import com.google.common.annotations.VisibleForTesting;
+import com.google.common.primitives.Ints;
+
 import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.db.Clustering;
 import org.apache.cassandra.db.LegacyLayout;
-import org.apache.cassandra.db.TypeSizes;
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.db.marshal.BytesType;
 import org.apache.cassandra.db.rows.Cell;
@@ -33,10 +35,17 @@ import org.apache.cassandra.io.util.DataInputBuffer;
 import org.apache.cassandra.io.util.DataOutputBuffer;
 import org.apache.cassandra.io.util.DataOutputBufferFixed;
 import org.apache.cassandra.net.MessagingService;
-import org.apache.cassandra.transport.Server;
 import org.apache.cassandra.transport.ProtocolException;
-import org.apache.cassandra.utils.ByteBufferUtil;
 
+import static org.apache.cassandra.db.TypeSizes.sizeof;
+import static org.apache.cassandra.db.TypeSizes.sizeofUnsignedVInt;
+import static org.apache.cassandra.transport.Server.VERSION_3;
+import static org.apache.cassandra.transport.Server.VERSION_4;
+import static org.apache.cassandra.utils.ByteBufferUtil.*;
+import static org.apache.cassandra.utils.vint.VIntCoding.computeUnsignedVIntSize;
+import static org.apache.cassandra.utils.vint.VIntCoding.getUnsignedVInt;
+
+@SuppressWarnings("WeakerAccess")
 public class PagingState
 {
     public final ByteBuffer partitionKey;  // Can be null for single partition queries.
@@ -52,92 +61,228 @@ public class PagingState
         this.remainingInPartition = remainingInPartition;
     }
 
-    public static PagingState deserialize(ByteBuffer bytes, int protocolVersion)
+    public ByteBuffer serialize(int protocolVersion)
     {
-        if (bytes == null)
-            return null;
-
-        try (DataInputBuffer in = new DataInputBuffer(bytes, true))
+        assert rowMark == null || protocolVersion == rowMark.protocolVersion;
+        try
         {
-            ByteBuffer pk;
-            RowMark mark;
-            int remaining, remainingInPartition;
-            if (protocolVersion <= Server.VERSION_3)
-            {
-                pk = ByteBufferUtil.readWithShortLength(in);
-                mark = new RowMark(ByteBufferUtil.readWithShortLength(in), protocolVersion);
-                remaining = in.readInt();
-                // Note that while 'in.available()' is theoretically an estimate of how many bytes are available
-                // without blocking, we know that since we're reading a ByteBuffer it will be exactly how many
-                // bytes remain to be read. And the reason we want to condition this is for backward compatility
-                // as we used to not set this.
-                remainingInPartition = in.available() > 0 ? in.readInt() : Integer.MAX_VALUE;
-            }
-            else
-            {
-                pk = ByteBufferUtil.readWithVIntLength(in);
-                mark = new RowMark(ByteBufferUtil.readWithVIntLength(in), protocolVersion);
-                remaining = (int)in.readUnsignedVInt();
-                remainingInPartition = (int)in.readUnsignedVInt();
-            }
-            return new PagingState(pk.hasRemaining() ? pk : null,
-                                   mark.mark.hasRemaining() ? mark : null,
-                                   remaining,
-                                   remainingInPartition);
+            return protocolVersion > VERSION_3 ? modernSerialize() : legacySerialize(true);
         }
         catch (IOException e)
         {
-            throw new ProtocolException("Invalid value for the paging state");
+            throw new RuntimeException(e);
         }
     }
 
-    public ByteBuffer serialize(int protocolVersion)
+    public int serializedSize(int protocolVersion)
     {
         assert rowMark == null || protocolVersion == rowMark.protocolVersion;
-        try (DataOutputBuffer out = new DataOutputBufferFixed(serializedSize(protocolVersion)))
+
+        return protocolVersion > VERSION_3 ? modernSerializedSize() : legacySerializedSize(true);
+    }
+
+    /**
+     * It's possible to receive a V3 paging state on a V4 client session, and vice versa - so we cannot
+     * blindly rely on the protocol version provided. We must verify first that the buffer indeed contains
+     * a paging state that adheres to the protocol version provided, or, if not - see if it is in a different
+     * version, in which case we try the other format.
+     */
+    public static PagingState deserialize(ByteBuffer bytes, int protocolVersion)
+    {
+        if (bytes == null)
+            return null;
+
+        try
         {
-            ByteBuffer pk = partitionKey == null ? ByteBufferUtil.EMPTY_BYTE_BUFFER : partitionKey;
-            ByteBuffer mark = rowMark == null ? ByteBufferUtil.EMPTY_BYTE_BUFFER : rowMark.mark;
-            if (protocolVersion <= Server.VERSION_3)
+            /*
+             * We can't just attempt to deser twice, as we risk to misinterpet short/vint
+             * lengths and allocate huge byte arrays for readWithVIntLength() or,
+             * to a lesser extent, readWithShortLength()
+             */
+
+            if (protocolVersion > VERSION_3)
             {
-                ByteBufferUtil.writeWithShortLength(pk, out);
-                ByteBufferUtil.writeWithShortLength(mark, out);
-                out.writeInt(remaining);
-                out.writeInt(remainingInPartition);
+                if (isModernSerialized(bytes)) return modernDeserialize(bytes, protocolVersion);
+                if (isLegacySerialized(bytes)) return legacyDeserialize(bytes, VERSION_3);
             }
-            else
+
+            if (protocolVersion < VERSION_4)
             {
-                ByteBufferUtil.writeWithVIntLength(pk, out);
-                ByteBufferUtil.writeWithVIntLength(mark, out);
-                out.writeUnsignedVInt(remaining);
-                out.writeUnsignedVInt(remainingInPartition);
+                if (isLegacySerialized(bytes)) return legacyDeserialize(bytes, protocolVersion);
+                if (isModernSerialized(bytes)) return modernDeserialize(bytes, VERSION_4);
             }
-            return out.buffer();
         }
         catch (IOException e)
         {
-            throw new RuntimeException(e);
+            throw new ProtocolException("Invalid value for the paging state");
         }
+
+        throw new ProtocolException("Invalid value for the paging state");
     }
 
-    public int serializedSize(int protocolVersion)
+    /*
+     * Modern serde (> VERSION_3)
+     */
+
+    @SuppressWarnings({ "resource", "RedundantSuppression" })
+    private ByteBuffer modernSerialize() throws IOException
     {
-        assert rowMark == null || protocolVersion == rowMark.protocolVersion;
-        ByteBuffer pk = partitionKey == null ? ByteBufferUtil.EMPTY_BYTE_BUFFER : partitionKey;
-        ByteBuffer mark = rowMark == null ? ByteBufferUtil.EMPTY_BYTE_BUFFER : rowMark.mark;
-        if (protocolVersion <= Server.VERSION_3)
-        {
-            return ByteBufferUtil.serializedSizeWithShortLength(pk)
-                 + ByteBufferUtil.serializedSizeWithShortLength(mark)
-                 + 8; // remaining & remainingInPartition
-        }
-        else
+        DataOutputBuffer out = new DataOutputBufferFixed(modernSerializedSize());
+        writeWithVIntLength(null == partitionKey ? EMPTY_BYTE_BUFFER : partitionKey, out);
+        writeWithVIntLength(null == rowMark ? EMPTY_BYTE_BUFFER : rowMark.mark, out);
+        out.writeUnsignedVInt(remaining);
+        out.writeUnsignedVInt(remainingInPartition);
+        return out.buffer(false);
+    }
+
+    private static boolean isModernSerialized(ByteBuffer bytes)
+    {
+        int index = bytes.position();
+        int limit = bytes.limit();
+
+        long partitionKeyLen = getUnsignedVInt(bytes, index, limit);
+        if (partitionKeyLen < 0)
+            return false;
+        index += computeUnsignedVIntSize(partitionKeyLen) + partitionKeyLen;
+        if (index >= limit)
+            return false;
+
+        long rowMarkerLen = getUnsignedVInt(bytes, index, limit);
+        if (rowMarkerLen < 0)
+            return false;
+        index += computeUnsignedVIntSize(rowMarkerLen) + rowMarkerLen;
+        if (index >= limit)
+            return false;
+
+        long remaining = getUnsignedVInt(bytes, index, limit);
+        if (remaining < 0)
+            return false;
+        index += computeUnsignedVIntSize(remaining);
+        if (index >= limit)
+            return false;
+
+        long remainingInPartition = getUnsignedVInt(bytes, index, limit);
+        if (remainingInPartition < 0)
+            return false;
+        index += computeUnsignedVIntSize(remainingInPartition);
+        return index == limit;
+    }
+
+    @SuppressWarnings({ "resource", "RedundantSuppression" })
+    private static PagingState modernDeserialize(ByteBuffer bytes, int protocolVersion) throws IOException
+    {
+        if (protocolVersion < VERSION_4)
+            throw new IllegalArgumentException();
+
+        DataInputBuffer in = new DataInputBuffer(bytes, false);
+
+        ByteBuffer partitionKey = readWithVIntLength(in);
+        ByteBuffer rawMark = readWithVIntLength(in);
+        int remaining = Ints.checkedCast(in.readUnsignedVInt());
+        int remainingInPartition = Ints.checkedCast(in.readUnsignedVInt());
+
+        return new PagingState(partitionKey.hasRemaining() ? partitionKey : null,
+                               rawMark.hasRemaining() ? new RowMark(rawMark, protocolVersion) : null,
+                               remaining,
+                               remainingInPartition);
+    }
+
+    private int modernSerializedSize()
+    {
+        return serializedSizeWithVIntLength(null == partitionKey ? EMPTY_BYTE_BUFFER : partitionKey)
+             + serializedSizeWithVIntLength(null == rowMark ? EMPTY_BYTE_BUFFER : rowMark.mark)
+             + sizeofUnsignedVInt(remaining)
+             + sizeofUnsignedVInt(remainingInPartition);
+    }
+
+    /*
+     * Legacy serde (< VERSION_4)
+     *
+     * There are two versions of legacy PagingState format - one used by 2.1/2.2 and one used by 3.0+.
+     * The latter includes remainingInPartition count, while the former doesn't.
+     */
+
+    @VisibleForTesting
+    @SuppressWarnings({ "resource", "RedundantSuppression" })
+    ByteBuffer legacySerialize(boolean withRemainingInPartition) throws IOException
+    {
+        DataOutputBuffer out = new DataOutputBufferFixed(legacySerializedSize(withRemainingInPartition));
+        writeWithShortLength(null == partitionKey ? EMPTY_BYTE_BUFFER : partitionKey, out);
+        writeWithShortLength(null == rowMark ? EMPTY_BYTE_BUFFER : rowMark.mark, out);
+        out.writeInt(remaining);
+        if (withRemainingInPartition)
+            out.writeInt(remainingInPartition);
+        return out.buffer(false);
+    }
+
+    private static boolean isLegacySerialized(ByteBuffer bytes)
+    {
+        int index = bytes.position();
+        int limit = bytes.limit();
+
+        if (limit - index < 2)
+            return false;
+        short partitionKeyLen = bytes.getShort(index);
+        if (partitionKeyLen < 0)
+            return false;
+        index += 2 + partitionKeyLen;
+
+        if (limit - index < 2)
+            return false;
+        short rowMarkerLen = bytes.getShort(index);
+        if (rowMarkerLen < 0)
+            return false;
+        index += 2 + rowMarkerLen;
+
+        if (limit - index < 4)
+            return false;
+        int remaining = bytes.getInt(index);
+        if (remaining < 0)
+            return false;
+        index += 4;
+
+        // V3 encoded by 2.1/2.2 - sans remainingInPartition
+        if (index == limit)
+            return true;
+
+        if (limit - index == 4)
         {
-            return ByteBufferUtil.serializedSizeWithVIntLength(pk)
-                 + ByteBufferUtil.serializedSizeWithVIntLength(mark)
-                 + TypeSizes.sizeofUnsignedVInt(remaining)
-                 + TypeSizes.sizeofUnsignedVInt(remainingInPartition);
+            int remainingInPartition = bytes.getInt(index);
+            return remainingInPartition >= 0; // the value must make sense
         }
+        return false;
+    }
+
+    @SuppressWarnings({ "resource", "RedundantSuppression" })
+    private static PagingState legacyDeserialize(ByteBuffer bytes, int protocolVersion) throws IOException
+    {
+        if (protocolVersion > VERSION_3)
+            throw new IllegalArgumentException();
+
+        DataInputBuffer in = new DataInputBuffer(bytes, false);
+
+        ByteBuffer partitionKey = readWithShortLength(in);
+        ByteBuffer rawMark = readWithShortLength(in);
+        int remaining = in.readInt();
+        /*
+         * 2.1/2.2 implementations of V3 protocol did not write remainingInPartition, but C* 3.0+ does, so we need
+         * to handle both variants of V3 serialization for compatibility.
+         */
+        int remainingInPartition = in.available() > 0 ? in.readInt() : Integer.MAX_VALUE;
+
+        return new PagingState(partitionKey.hasRemaining() ? partitionKey : null,
+                               rawMark.hasRemaining() ? new RowMark(rawMark, protocolVersion) : null,
+                               remaining,
+                               remainingInPartition);
+    }
+
+    @VisibleForTesting
+    int legacySerializedSize(boolean withRemainingInPartition)
+    {
+        return serializedSizeWithShortLength(null == partitionKey ? EMPTY_BYTE_BUFFER : partitionKey)
+             + serializedSizeWithShortLength(null == rowMark ? EMPTY_BYTE_BUFFER : rowMark.mark)
+             + sizeof(remaining)
+             + (withRemainingInPartition ? sizeof(remainingInPartition) : 0);
     }
 
     @Override
@@ -162,7 +307,7 @@ public class PagingState
     public String toString()
     {
         return String.format("PagingState(key=%s, cellname=%s, remaining=%d, remainingInPartition=%d",
-                             partitionKey != null ? ByteBufferUtil.bytesToHex(partitionKey) : null,
+                             partitionKey != null ? bytesToHex(partitionKey) : null,
                              rowMark,
                              remaining,
                              remainingInPartition);
@@ -205,7 +350,7 @@ public class PagingState
         public static RowMark create(CFMetaData metadata, Row row, int protocolVersion)
         {
             ByteBuffer mark;
-            if (protocolVersion <= Server.VERSION_3)
+            if (protocolVersion <= VERSION_3)
             {
                 // We need to be backward compatible with 2.1/2.2 nodes paging states. Which means we have to send
                 // the full cellname of the "last" cell in the row we get (since that's how 2.1/2.2 nodes will start after
@@ -216,7 +361,7 @@ public class PagingState
                     // If the last returned row has no cell, this means in 2.1/2.2 terms that we stopped on the row
                     // marker. Note that this shouldn't happen if the table is COMPACT.
                     assert !metadata.isCompactTable();
-                    mark = LegacyLayout.encodeCellName(metadata, row.clustering(), ByteBufferUtil.EMPTY_BYTE_BUFFER, null);
+                    mark = LegacyLayout.encodeCellName(metadata, row.clustering(), EMPTY_BYTE_BUFFER, null);
                 }
                 else
                 {
@@ -238,7 +383,7 @@ public class PagingState
             if (mark == null)
                 return null;
 
-            return protocolVersion <= Server.VERSION_3
+            return protocolVersion <= VERSION_3
                  ? LegacyLayout.decodeClustering(metadata, mark)
                  : Clustering.serializer.deserialize(mark, MessagingService.VERSION_30, makeClusteringTypes(metadata));
         }
@@ -261,7 +406,7 @@ public class PagingState
         @Override
         public String toString()
         {
-            return mark == null ? "null" : ByteBufferUtil.bytesToHex(mark);
+            return mark == null ? "null" : bytesToHex(mark);
         }
     }
 }
diff --git a/src/java/org/apache/cassandra/utils/vint/VIntCoding.java b/src/java/org/apache/cassandra/utils/vint/VIntCoding.java
index daf5006b94..27448e2f7c 100644
--- a/src/java/org/apache/cassandra/utils/vint/VIntCoding.java
+++ b/src/java/org/apache/cassandra/utils/vint/VIntCoding.java
@@ -49,6 +49,7 @@ package org.apache.cassandra.utils.vint;
 import java.io.DataInput;
 import java.io.DataOutput;
 import java.io.IOException;
+import java.nio.ByteBuffer;
 
 import net.nicoulaj.compilecommand.annotations.Inline;
 
@@ -78,6 +79,46 @@ public class VIntCoding
         return retval;
     }
 
+    /**
+     * Note this method is the same as {@link #readUnsignedVInt(DataInput)},
+     * except that we do *not* block if there are not enough bytes in the buffer
+     * to reconstruct the value.
+     *
+     * WARNING: this method is only safe for vints we know to be representable by a positive long value.
+     *
+     * @return -1 if there are not enough bytes in the input to read the value; else, the vint unsigned value.
+     */
+    public static long getUnsignedVInt(ByteBuffer input, int readerIndex)
+    {
+        return getUnsignedVInt(input, readerIndex, input.limit());
+    }
+
+    public static long getUnsignedVInt(ByteBuffer input, int readerIndex, int readerLimit)
+    {
+        if (readerIndex >= readerLimit)
+            return -1;
+
+        int firstByte = input.get(readerIndex++);
+
+        //Bail out early if this is one byte, necessary or it fails later
+        if (firstByte >= 0)
+            return firstByte;
+
+        int size = numberOfExtraBytesToRead(firstByte);
+        if (readerIndex + size > readerLimit)
+            return -1;
+
+        long retval = firstByte & firstByteValueMask(size);
+        for (int ii = 0; ii < size; ii++)
+        {
+            byte b = input.get(readerIndex++);
+            retval <<= 8;
+            retval |= b & 0xff;
+        }
+
+        return retval;
+    }
+
     public static long readVInt(DataInput input) throws IOException {
         return decodeZigZag64(readUnsignedVInt(input));
     }
diff --git a/test/unit/org/apache/cassandra/service/QueryPagerTest.java b/test/unit/org/apache/cassandra/service/QueryPagerTest.java
index 34f1bcf9fc..27c630d8db 100644
--- a/test/unit/org/apache/cassandra/service/QueryPagerTest.java
+++ b/test/unit/org/apache/cassandra/service/QueryPagerTest.java
@@ -242,9 +242,10 @@ public class QueryPagerTest
     public void sliceQueryTest() throws Exception
     {
         sliceQueryTest(false, Server.VERSION_3);
-        sliceQueryTest(true, Server.VERSION_4);
-        sliceQueryTest(false, Server.VERSION_3);
-        sliceQueryTest(true, Server.VERSION_4);
+        sliceQueryTest(true,  Server.VERSION_3);
+
+        sliceQueryTest(false, Server.VERSION_4);
+        sliceQueryTest(true,  Server.VERSION_4);
     }
 
     public void sliceQueryTest(boolean testPagingState, int protocolVersion) throws Exception
@@ -275,9 +276,10 @@ public class QueryPagerTest
     public void reversedSliceQueryTest() throws Exception
     {
         reversedSliceQueryTest(false, Server.VERSION_3);
-        reversedSliceQueryTest(true, Server.VERSION_4);
-        reversedSliceQueryTest(false, Server.VERSION_3);
-        reversedSliceQueryTest(true, Server.VERSION_4);
+        reversedSliceQueryTest(true,  Server.VERSION_3);
+
+        reversedSliceQueryTest(false, Server.VERSION_4);
+        reversedSliceQueryTest(true,  Server.VERSION_4);
     }
 
     public void reversedSliceQueryTest(boolean testPagingState, int protocolVersion) throws Exception
@@ -308,9 +310,10 @@ public class QueryPagerTest
     public void multiQueryTest() throws Exception
     {
         multiQueryTest(false, Server.VERSION_3);
-        multiQueryTest(true, Server.VERSION_4);
-        multiQueryTest(false, Server.VERSION_3);
-        multiQueryTest(true, Server.VERSION_4);
+        multiQueryTest(true,  Server.VERSION_3);
+
+        multiQueryTest(false, Server.VERSION_4);
+        multiQueryTest(true,  Server.VERSION_4);
     }
 
     public void multiQueryTest(boolean testPagingState, int protocolVersion) throws Exception
@@ -346,9 +349,10 @@ public class QueryPagerTest
     public void rangeNamesQueryTest() throws Exception
     {
         rangeNamesQueryTest(false, Server.VERSION_3);
-        rangeNamesQueryTest(true, Server.VERSION_4);
-        rangeNamesQueryTest(false, Server.VERSION_3);
-        rangeNamesQueryTest(true, Server.VERSION_4);
+        rangeNamesQueryTest(true,  Server.VERSION_3);
+
+        rangeNamesQueryTest(false, Server.VERSION_4);
+        rangeNamesQueryTest(true,  Server.VERSION_4);
     }
 
     public void rangeNamesQueryTest(boolean testPagingState, int protocolVersion) throws Exception
@@ -375,9 +379,10 @@ public class QueryPagerTest
     public void rangeSliceQueryTest() throws Exception
     {
         rangeSliceQueryTest(false, Server.VERSION_3);
-        rangeSliceQueryTest(true, Server.VERSION_4);
-        rangeSliceQueryTest(false, Server.VERSION_3);
-        rangeSliceQueryTest(true, Server.VERSION_4);
+        rangeSliceQueryTest(true,  Server.VERSION_3);
+
+        rangeSliceQueryTest(false, Server.VERSION_4);
+        rangeSliceQueryTest(true,  Server.VERSION_4);
     }
 
     public void rangeSliceQueryTest(boolean testPagingState, int protocolVersion) throws Exception
diff --git a/test/unit/org/apache/cassandra/service/pager/PagingStateTest.java b/test/unit/org/apache/cassandra/service/pager/PagingStateTest.java
index ba82e85d67..8e48771f52 100644
--- a/test/unit/org/apache/cassandra/service/pager/PagingStateTest.java
+++ b/test/unit/org/apache/cassandra/service/pager/PagingStateTest.java
@@ -1,4 +1,3 @@
-
 /*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
@@ -19,6 +18,7 @@
 */
 package org.apache.cassandra.service.pager;
 
+import java.io.IOException;
 import java.nio.ByteBuffer;
 
 import org.junit.Test;
@@ -29,15 +29,21 @@ import org.apache.cassandra.cql3.ColumnIdentifier;
 import org.apache.cassandra.db.*;
 import org.apache.cassandra.db.rows.*;
 import org.apache.cassandra.db.marshal.*;
-import org.apache.cassandra.transport.Server;
 import org.apache.cassandra.utils.ByteBufferUtil;
 
+import static org.apache.cassandra.transport.Server.VERSION_3;
+import static org.apache.cassandra.transport.Server.VERSION_4;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
 public class PagingStateTest
 {
     private PagingState makeSomePagingState(int protocolVersion)
+    {
+        return makeSomePagingState(protocolVersion, 0);
+    }
+
+    private PagingState makeSomePagingState(int protocolVersion, int remainingInPartition)
     {
         CFMetaData metadata = CFMetaData.Builder.create("ks", "tbl")
                                                 .addPartitionKey("k", AsciiType.instance)
@@ -52,7 +58,7 @@ public class PagingStateTest
         Clustering c = new Clustering(ByteBufferUtil.bytes("c1"), ByteBufferUtil.bytes(42));
         Row row = BTreeRow.singleCellRow(c, BufferCell.live(metadata, def, 0, ByteBufferUtil.EMPTY_BYTE_BUFFER));
         PagingState.RowMark mark = PagingState.RowMark.create(metadata, row, protocolVersion);
-        return new PagingState(pk, mark, 10, 0);
+        return new PagingState(pk, mark, 10, remainingInPartition);
     }
 
     @Test
@@ -70,9 +76,9 @@ public class PagingStateTest
          *     PagingState state = new PagingState(pk, cn.toByteBuffer(), 10);
          *     System.out.println("PagingState = " + ByteBufferUtil.bytesToHex(state.serialize()));
          */
-        PagingState state = makeSomePagingState(Server.VERSION_3);
+        PagingState state = makeSomePagingState(VERSION_3);
 
-        String serializedState = ByteBufferUtil.bytesToHex(state.serialize(Server.VERSION_3));
+        String serializedState = ByteBufferUtil.bytesToHex(state.serialize(VERSION_3));
         // Note that we don't assert exact equality because we know 3.0 nodes include the "remainingInPartition" number
         // that is not present on 2.1/2.2 nodes. We know this is ok however because we know that 2.1/2.2 nodes will ignore
         // anything remaining once they have properly deserialized a paging state.
@@ -80,20 +86,56 @@ public class PagingStateTest
     }
 
     @Test
-    public void testSerializeDeserializeV3()
+    public void testSerializeV3DeserializeV3()
+    {
+        PagingState state = makeSomePagingState(VERSION_3);
+        ByteBuffer serialized = state.serialize(VERSION_3);
+        assertEquals(serialized.remaining(), state.serializedSize(VERSION_3));
+        assertEquals(state, PagingState.deserialize(serialized, VERSION_3));
+    }
+
+    @Test
+    public void testSerializeV4DeserializeV4()
+    {
+        PagingState state = makeSomePagingState(VERSION_4);
+        ByteBuffer serialized = state.serialize(VERSION_4);
+        assertEquals(serialized.remaining(), state.serializedSize(VERSION_4));
+        assertEquals(state, PagingState.deserialize(serialized, VERSION_4));
+    }
+
+    @Test
+    public void testSerializeV3DeserializeV4()
+    {
+        PagingState state = makeSomePagingState(VERSION_3);
+        ByteBuffer serialized = state.serialize(VERSION_3);
+        assertEquals(serialized.remaining(), state.serializedSize(VERSION_3));
+        assertEquals(state, PagingState.deserialize(serialized, VERSION_4));
+    }
+
+    @Test
+    public void testSerializeV4DeserializeV3()
+    {
+        PagingState state = makeSomePagingState(VERSION_4);
+        ByteBuffer serialized = state.serialize(VERSION_4);
+        assertEquals(serialized.remaining(), state.serializedSize(VERSION_4));
+        assertEquals(state, PagingState.deserialize(serialized, VERSION_3));
+    }
+
+    @Test
+    public void testSerializeV3WithoutRemainingInPartitionDeserializeV3() throws IOException
     {
-        PagingState state = makeSomePagingState(Server.VERSION_3);
-        ByteBuffer serialized = state.serialize(Server.VERSION_3);
-        assertEquals(serialized.remaining(), state.serializedSize(Server.VERSION_3));
-        assertEquals(state, PagingState.deserialize(serialized, Server.VERSION_3));
+        PagingState state = makeSomePagingState(VERSION_3, Integer.MAX_VALUE);
+        ByteBuffer serialized = state.legacySerialize(false);
+        assertEquals(serialized.remaining(), state.legacySerializedSize(false));
+        assertEquals(state, PagingState.deserialize(serialized, VERSION_3));
     }
 
     @Test
-    public void testSerializeDeserializeV4()
+    public void testSerializeV3WithoutRemainingInPartitionDeserializeV4() throws IOException
     {
-        PagingState state = makeSomePagingState(Server.VERSION_4);
-        ByteBuffer serialized = state.serialize(Server.VERSION_4);
-        assertEquals(serialized.remaining(), state.serializedSize(Server.VERSION_4));
-        assertEquals(state, PagingState.deserialize(serialized, Server.VERSION_4));
+        PagingState state = makeSomePagingState(VERSION_3, Integer.MAX_VALUE);
+        ByteBuffer serialized = state.legacySerialize(false);
+        assertEquals(serialized.remaining(), state.legacySerializedSize(false));
+        assertEquals(state, PagingState.deserialize(serialized, VERSION_4));
     }
 }
