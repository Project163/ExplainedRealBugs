diff --git a/CHANGES.txt b/CHANGES.txt
index 02048723ef..6a8cb3549e 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 4.0.8
+ * Fix possible race condition on repair snapshots (CASSANDRA-17955)
  * Fix ASM bytecode version inconsistency (CASSANDRA-17873)
 Merged from 3.11:
 Merged from 3.0:
diff --git a/src/java/org/apache/cassandra/db/repair/CassandraTableRepairManager.java b/src/java/org/apache/cassandra/db/repair/CassandraTableRepairManager.java
index 983e30f207..aab9f0b15b 100644
--- a/src/java/org/apache/cassandra/db/repair/CassandraTableRepairManager.java
+++ b/src/java/org/apache/cassandra/db/repair/CassandraTableRepairManager.java
@@ -34,7 +34,7 @@ import org.apache.cassandra.dht.Token;
 import org.apache.cassandra.io.sstable.format.SSTableReader;
 import org.apache.cassandra.repair.TableRepairManager;
 import org.apache.cassandra.repair.ValidationPartitionIterator;
-import org.apache.cassandra.repair.Validator;
+import org.apache.cassandra.service.ActiveRepairService;
 
 public class CassandraTableRepairManager implements TableRepairManager
 {
@@ -66,17 +66,26 @@ public class CassandraTableRepairManager implements TableRepairManager
     @Override
     public synchronized void snapshot(String name, Collection<Range<Token>> ranges, boolean force)
     {
-        if (force || !cfs.snapshotExists(name))
+        try
         {
-            cfs.snapshot(name, new Predicate<SSTableReader>()
-            {
-                public boolean apply(SSTableReader sstable)
+            ActiveRepairService.instance.snapshotExecutor.submit(() -> {
+                if (force || !cfs.snapshotExists(name))
                 {
-                    return sstable != null &&
-                           !sstable.metadata().isIndex() && // exclude SSTables from 2i
-                           new Bounds<>(sstable.first.getToken(), sstable.last.getToken()).intersects(ranges);
+                    cfs.snapshot(name, new Predicate<SSTableReader>()
+                    {
+                        public boolean apply(SSTableReader sstable)
+                        {
+                            return sstable != null &&
+                                   !sstable.metadata().isIndex() && // exclude SSTables from 2i
+                                   new Bounds<>(sstable.first.getToken(), sstable.last.getToken()).intersects(ranges);
+                        }
+                    }, true, false); //ephemeral snapshot, if repair fails, it will be cleaned next startup
                 }
-            }, true, false); //ephemeral snapshot, if repair fails, it will be cleaned next startup
+            }).get();
+        }
+        catch (Exception ex)
+        {
+            throw new RuntimeException(String.format("Unable to take a snapshot %s on %s.%s", name, cfs.metadata.keyspace, cfs.metadata.name), ex);
         }
 
     }
diff --git a/src/java/org/apache/cassandra/service/ActiveRepairService.java b/src/java/org/apache/cassandra/service/ActiveRepairService.java
index 4a990f662c..e3ec218f6d 100644
--- a/src/java/org/apache/cassandra/service/ActiveRepairService.java
+++ b/src/java/org/apache/cassandra/service/ActiveRepairService.java
@@ -198,10 +198,10 @@ public class ActiveRepairService implements IEndpointStateChangeSubscriber, IFai
     private final Gossiper gossiper;
     private final Cache<Integer, Pair<ParentRepairStatus, List<String>>> repairStatusByCmd;
 
-    private final DebuggableThreadPoolExecutor clearSnapshotExecutor = DebuggableThreadPoolExecutor.createWithMaximumPoolSize("RepairClearSnapshot",
-                                                                                                                              1,
-                                                                                                                              1,
-                                                                                                                              TimeUnit.HOURS);
+    public final DebuggableThreadPoolExecutor snapshotExecutor = DebuggableThreadPoolExecutor.createWithMaximumPoolSize("RepairSnapshotExecutor",
+                                                                                                                        1,
+                                                                                                                        1,
+                                                                                                                        TimeUnit.HOURS);
 
     public ActiveRepairService(IFailureDetector failureDetector, Gossiper gossiper)
     {
@@ -697,8 +697,9 @@ public class ActiveRepairService implements IEndpointStateChangeSubscriber, IFai
      *
      * clears out any snapshots created by this repair
      *
-     * @param parentSessionId
-     * @return
+     * @param parentSessionId id of parent session
+     * @return parent session of given id or null if there is not such
+     * @see org.apache.cassandra.db.repair.CassandraTableRepairManager#snapshot(String, Collection, boolean) 
      */
     public synchronized ParentRepairSession removeParentRepairSession(UUID parentSessionId)
     {
@@ -709,7 +710,7 @@ public class ActiveRepairService implements IEndpointStateChangeSubscriber, IFai
 
         if (session.hasSnapshots)
         {
-            clearSnapshotExecutor.submit(() -> {
+            snapshotExecutor.submit(() -> {
                 logger.info("[repair #{}] Clearing snapshots for {}", parentSessionId,
                             session.columnFamilyStores.values()
                                                       .stream()
