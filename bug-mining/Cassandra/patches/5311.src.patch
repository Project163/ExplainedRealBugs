diff --git a/CHANGES.txt b/CHANGES.txt
index 8c8e74b976..96211281c2 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 4.0-alpha4
+ * Fixed flakey test in SASIIndexTest by shutting down its ExecutorService (CASSANDRA-15528)
  * Fixed empty check in TrieMemIndex due to potential state inconsistency in ConcurrentSkipListMap (CASSANDRA-15526)
  * Add compaction allocation measurement test (CASSANDRA-15388)
  * Added UnleveledSSTables global and table level metric (CASSANDRA-15620)
diff --git a/test/unit/org/apache/cassandra/index/sasi/SASIIndexTest.java b/test/unit/org/apache/cassandra/index/sasi/SASIIndexTest.java
index 0be05b901a..c64bec97d4 100644
--- a/test/unit/org/apache/cassandra/index/sasi/SASIIndexTest.java
+++ b/test/unit/org/apache/cassandra/index/sasi/SASIIndexTest.java
@@ -1099,25 +1099,30 @@ public class SASIIndexTest
 
         int previousCount = 0;
 
-        do
+        try
         {
-            // this loop figures out if number of search results monotonically increasing
-            // to make sure that concurrent updates don't interfere with reads, uses first_name and age
-            // indexes to test correctness of both Trie and SkipList ColumnIndex implementations.
+            do
+            {
+                // this loop figures out if number of search results monotonically increasing
+                // to make sure that concurrent updates don't interfere with reads, uses first_name and age
+                // indexes to test correctness of both Trie and SkipList ColumnIndex implementations.
 
-            Set<DecoratedKey> rows = getPaged(store, 100, buildExpression(firstName, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose("a")),
-                                                          buildExpression(age, Operator.EQ, Int32Type.instance.decompose(26)));
+                Set<DecoratedKey> rows = getPaged(store, 100, buildExpression(firstName, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose("a")),
+                                                  buildExpression(age, Operator.EQ, Int32Type.instance.decompose(26)));
 
-            Assert.assertTrue(previousCount <= rows.size());
-            previousCount = rows.size();
-        }
-        while (updates.get() < writeCount);
-
-        // to make sure that after all of the writes are done we can read all "count" worth of rows
-        Set<DecoratedKey> rows = getPaged(store, 100, buildExpression(firstName, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose("a")),
-                                                      buildExpression(age, Operator.EQ, Int32Type.instance.decompose(26)));
+                Assert.assertTrue(previousCount <= rows.size());
+                previousCount = rows.size();
+            }
+            while (updates.get() < writeCount);
 
-        Assert.assertEquals(writeCount, rows.size());
+            // to make sure that after all of the writes are done we can read all "count" worth of rows
+            Set<DecoratedKey> rows = getPaged(store, 100, buildExpression(firstName, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose("a")),
+                            buildExpression(age, Operator.EQ, Int32Type.instance.decompose(26)));
+            Assert.assertEquals(writeCount, rows.size());
+        } finally {
+            scheduler.shutdownNow();
+            scheduler.awaitTermination(30, TimeUnit.SECONDS);
+        }
     }
 
     @Test
