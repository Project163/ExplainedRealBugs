diff --git a/src/java/org/apache/cassandra/db/BinaryMemtable.java b/src/java/org/apache/cassandra/db/BinaryMemtable.java
index 7f01866a35..7ab7c78fc6 100644
--- a/src/java/org/apache/cassandra/db/BinaryMemtable.java
+++ b/src/java/org/apache/cassandra/db/BinaryMemtable.java
@@ -120,7 +120,7 @@ public class BinaryMemtable implements IFlushable<DecoratedKey>
     public SSTableReader writeSortedContents(List<DecoratedKey> sortedKeys) throws IOException
     {
         logger.info("Writing " + this);
-        String path = cfs.getTempSSTablePath();
+        String path = cfs.getFlushPath();
         SSTableWriter writer = new SSTableWriter(path, sortedKeys.size(), StorageService.getPartitioner());
 
         for (DecoratedKey key : sortedKeys)
diff --git a/src/java/org/apache/cassandra/db/ColumnFamilyStore.java b/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
index b93542fa87..d0e2ef7faf 100644
--- a/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
+++ b/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
@@ -335,10 +335,13 @@ public class ColumnFamilyStore implements ColumnFamilyStoreMBean
      * When the sstable object is closed, it will be renamed to a non-temporary
      * format, so incomplete sstables can be recognized and removed on startup.
      */
-    synchronized String getTempSSTablePath()
+    public String getFlushPath()
     {
-        String fname = getTempSSTableFileName();
-        return new File(DatabaseDescriptor.getNextAvailableDataLocation() + File.separator + table_, fname).getAbsolutePath();
+        long guessedSize = 2 * DatabaseDescriptor.getMemtableThroughput() * 1024*1024; // 2* adds room for keys, column indexes
+        String location = DatabaseDescriptor.getDataFileLocationForTable(table_, guessedSize);
+        if (location == null)
+            throw new RuntimeException("Insufficient disk space to flush");
+        return new File(location, getTempSSTableFileName()).getAbsolutePath();
     }
 
     public String getTempSSTableFileName()
diff --git a/src/java/org/apache/cassandra/db/CompactionManager.java b/src/java/org/apache/cassandra/db/CompactionManager.java
index 88e3bd999a..96b2f98df3 100644
--- a/src/java/org/apache/cassandra/db/CompactionManager.java
+++ b/src/java/org/apache/cassandra/db/CompactionManager.java
@@ -51,8 +51,6 @@ public class CompactionManager implements CompactionManagerMBean
     private static final Logger logger = Logger.getLogger(CompactionManager.class);
     public static final CompactionManager instance;
 
-    private static volatile boolean gcRequested;
-
     private int minimumCompactionThreshold = 4; // compact this many sstables min at a time
     private int maximumCompactionThreshold = 32; // compact this many sstables max at a time
 
@@ -68,36 +66,6 @@ public class CompactionManager implements CompactionManagerMBean
         {
             throw new RuntimeException(e);
         }
-
-        /**
-         * thread that requests GCs to clean out obsolete sstables, sleeping rpc timeout first so that most in-progress ops can complete
-         * (thus, no longer reference the sstables in question)
-         */
-        new Thread(new Runnable()
-        {
-            final long gcDelay = DatabaseDescriptor.getRpcTimeout();
-
-            public void run()
-            {
-                while (true)
-                {
-                    try
-                    {
-                        Thread.sleep(gcDelay * 10);
-                        if (gcRequested)
-                        {
-                            Thread.sleep(gcDelay);
-                            System.gc();
-                            gcRequested = false;
-                        }
-                    }
-                    catch (InterruptedException e)
-                    {
-                        throw new AssertionError(e);
-                    }
-                }
-            }
-        }, "COMPACTION-GC-INVOKER").start();
     }
 
     private CompactionExecutor executor = new CompactionExecutor();
@@ -337,7 +305,6 @@ public class CompactionManager implements CompactionManagerMBean
 
         SSTableReader ssTable = writer.closeAndOpenReader(DatabaseDescriptor.getKeysCachedFraction(table.name, cfs.getColumnFamilyName()));
         cfs.replaceCompactedSSTables(sstables, Arrays.asList(ssTable));
-        gcRequested = true;
         submitMinorIfNeeded(cfs);
 
         String format = "Compacted to %s.  %d/%d bytes for %d keys.  Time: %dms.";
@@ -364,7 +331,7 @@ public class CompactionManager implements CompactionManagerMBean
         logger.info("AntiCompacting [" + StringUtils.join(sstables, ",") + "]");
         // Calculate the expected compacted filesize
         long expectedRangeFileSize = cfs.getExpectedCompactedFileSize(sstables) / 2;
-        String compactionFileLocation = DatabaseDescriptor.getDataFileLocationForTable(table.name, expectedRangeFileSize);
+        String compactionFileLocation = table.getDataFileLocation(expectedRangeFileSize);
         if (compactionFileLocation == null)
         {
             throw new UnsupportedOperationException("disk full");
@@ -438,7 +405,6 @@ public class CompactionManager implements CompactionManagerMBean
         {
             cfs.replaceCompactedSSTables(originalSSTables, sstables);
         }
-        gcRequested = true;
     }
 
     /**
diff --git a/src/java/org/apache/cassandra/db/Memtable.java b/src/java/org/apache/cassandra/db/Memtable.java
index fd21598015..8d8e3642af 100644
--- a/src/java/org/apache/cassandra/db/Memtable.java
+++ b/src/java/org/apache/cassandra/db/Memtable.java
@@ -154,7 +154,7 @@ public class Memtable implements Comparable<Memtable>, IFlushable<DecoratedKey>
     {
         logger.info("Writing " + this);
         ColumnFamilyStore cfStore = Table.open(table).getColumnFamilyStore(columnfamilyName);
-        SSTableWriter writer = new SSTableWriter(cfStore.getTempSSTablePath(), columnFamilies.size(), StorageService.getPartitioner());
+        SSTableWriter writer = new SSTableWriter(cfStore.getFlushPath(), columnFamilies.size(), StorageService.getPartitioner());
 
         DataOutputBuffer buffer = new DataOutputBuffer();
         for (DecoratedKey key : sortedKeys)
diff --git a/src/java/org/apache/cassandra/db/Table.java b/src/java/org/apache/cassandra/db/Table.java
index 80b887ab93..0be0dbf2db 100644
--- a/src/java/org/apache/cassandra/db/Table.java
+++ b/src/java/org/apache/cassandra/db/Table.java
@@ -21,9 +21,6 @@ package org.apache.cassandra.db;
 import java.util.*;
 import java.io.IOException;
 import java.io.File;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.locks.Lock;
-import java.util.concurrent.locks.ReentrantLock;
 import java.util.concurrent.locks.ReentrantReadWriteLock;
 import java.util.concurrent.Future;
 
@@ -32,11 +29,13 @@ import com.google.common.collect.AbstractIterator;
 import com.google.common.collect.Iterables;
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.dht.Range;
+import org.apache.cassandra.io.SSTableDeletingReference;
 import org.apache.cassandra.io.SSTableReader;
 import org.apache.cassandra.io.util.FileUtils;
 
 import java.net.InetAddress;
 
+import org.apache.cassandra.service.StorageService;
 import org.apache.cassandra.utils.*;
 import org.apache.cassandra.db.filter.*;
 import org.cliffc.high_scale_lib.NonBlockingHashMap;
@@ -476,7 +475,22 @@ public class Table
 
     public String getDataFileLocation(long expectedCompactedFileSize)
     {
-        return DatabaseDescriptor.getDataFileLocationForTable(name, expectedCompactedFileSize);
+        String path = DatabaseDescriptor.getDataFileLocationForTable(name, expectedCompactedFileSize);
+        if (path == null)
+        {
+            // retry after GCing to force unmap of compacted SSTables so they can be deleted
+            StorageService.requestGC();
+            try
+            {
+                Thread.sleep(SSTableDeletingReference.RETRY_DELAY * 2);
+            }
+            catch (InterruptedException e)
+            {
+                throw new AssertionError(e);
+            }
+            path = DatabaseDescriptor.getDataFileLocationForTable(name, expectedCompactedFileSize);
+        }
+        return path;
     }
 
     public static String getSnapshotPath(String dataDirPath, String tableName, String snapshotName)
diff --git a/src/java/org/apache/cassandra/io/SSTableDeletingReference.java b/src/java/org/apache/cassandra/io/SSTableDeletingReference.java
index e425727b70..b123161a5c 100644
--- a/src/java/org/apache/cassandra/io/SSTableDeletingReference.java
+++ b/src/java/org/apache/cassandra/io/SSTableDeletingReference.java
@@ -9,12 +9,12 @@ import java.util.TimerTask;
 
 import org.apache.log4j.Logger;
 
-class SSTableDeletingReference extends PhantomReference<SSTableReader>
+public class SSTableDeletingReference extends PhantomReference<SSTableReader>
 {
     private static final Logger logger = Logger.getLogger(SSTableDeletingReference.class);
 
     private static final Timer timer = new Timer("SSTABLE-CLEANUP-TIMER");
-    private static final int RETRY_DELAY = 10000;
+    public static final int RETRY_DELAY = 10000;
 
     public final String path;
     private boolean deleteOnCleanup;
@@ -54,7 +54,7 @@ class SSTableDeletingReference extends PhantomReference<SSTableReader>
             {
                 if (attempts++ < DeletionService.MAX_RETRIES)
                 {
-                    timer.schedule(this, 10000);
+                    timer.schedule(this, RETRY_DELAY);
                     return;
                 }
                 else
diff --git a/src/java/org/apache/cassandra/io/SSTableReader.java b/src/java/org/apache/cassandra/io/SSTableReader.java
index bbc1c48790..01e8d07f06 100644
--- a/src/java/org/apache/cassandra/io/SSTableReader.java
+++ b/src/java/org/apache/cassandra/io/SSTableReader.java
@@ -564,4 +564,3 @@ class FileSSTableMap
         return "FileSSTableMap {" + StringUtils.join(map.keySet(), ", ") + "}";
     }
 }
-
diff --git a/src/java/org/apache/cassandra/service/StorageService.java b/src/java/org/apache/cassandra/service/StorageService.java
index 558bddaa67..4971133975 100644
--- a/src/java/org/apache/cassandra/service/StorageService.java
+++ b/src/java/org/apache/cassandra/service/StorageService.java
@@ -1472,6 +1472,12 @@ public class StorageService implements IEndPointStateChangeSubscriber, StorageSe
         return isClientMode;
     }
 
+    public static void requestGC()
+    {
+        logger_.info("requesting GC to free disk space");
+        System.gc();
+    }
+
     // Never ever do this at home. Used by tests.
     Map<String, AbstractReplicationStrategy> setReplicationStrategyUnsafe(Map<String, AbstractReplicationStrategy> replacement)
     {
@@ -1494,5 +1500,4 @@ public class StorageService implements IEndPointStateChangeSubscriber, StorageSe
         tokenMetadata_ = tmd;
         return old;
     }
-
 }
