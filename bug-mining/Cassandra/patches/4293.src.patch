diff --git a/CHANGES.txt b/CHANGES.txt
index 3d166aa421..103eff0bd1 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,6 @@
 3.0.7
+ * Remove unneeded code to repair index summaries that have
+   been improperly down-sampled (CASSANDRA-11127)
  * Avoid WriteTimeoutExceptions during commit log replay due to materialized
    view lock contention (CASSANDRA-11891)
  * Prevent OOM failures on SSTable corruption, improve tests for corruption detection (CASSANDRA-9530)
diff --git a/src/java/org/apache/cassandra/io/sstable/format/SSTableReader.java b/src/java/org/apache/cassandra/io/sstable/format/SSTableReader.java
index 9bb1767bf8..9f2663e2b5 100644
--- a/src/java/org/apache/cassandra/io/sstable/format/SSTableReader.java
+++ b/src/java/org/apache/cassandra/io/sstable/format/SSTableReader.java
@@ -744,30 +744,8 @@ public abstract class SSTableReader extends SSTable implements SelfRefCounted<SS
 
             dfile = dbuilder.buildData(descriptor, sstableMetadata);
 
-            // Check for an index summary that was downsampled even though the serialization format doesn't support
-            // that.  If it was downsampled, rebuild it.  See CASSANDRA-8993 for details.
-        if (!descriptor.version.hasSamplingLevel() && !builtSummary && !validateSummarySamplingLevel() && ifile != null)
-            {
-                indexSummary.close();
-                ifile.close();
-                dfile.close();
-
-                logger.info("Detected erroneously downsampled index summary; will rebuild summary at full sampling");
-                FileUtils.deleteWithConfirm(new File(descriptor.filenameFor(Component.SUMMARY)));
-
-                try(SegmentedFile.Builder ibuilderRebuild = SegmentedFile.getBuilder(DatabaseDescriptor.getIndexAccessMode(), false);
-                    SegmentedFile.Builder dbuilderRebuild = SegmentedFile.getBuilder(DatabaseDescriptor.getDiskAccessMode(), compression))
-                {
-                    buildSummary(false, ibuilderRebuild, dbuilderRebuild, false, Downsampling.BASE_SAMPLING_LEVEL);
-                    ifile = ibuilderRebuild.buildIndex(descriptor, indexSummary);
-                    dfile = dbuilderRebuild.buildData(descriptor, sstableMetadata);
-                    saveSummary(ibuilderRebuild, dbuilderRebuild);
-                }
-            }
-            else if (saveSummaryIfCreated && builtSummary)
-            {
+            if (saveSummaryIfCreated && builtSummary)
                 saveSummary(ibuilder, dbuilder);
-            }
         }
         catch (Throwable t)
         { // Because the tidier has not been set-up yet in SSTableReader.open(), we must release the files in case of error
@@ -900,53 +878,6 @@ public abstract class SSTableReader extends SSTable implements SelfRefCounted<SS
         return true;
     }
 
-    /**
-     * Validates that an index summary has full sampling, as expected when the serialization format does not support
-     * persisting the sampling level.
-     * @return true if the summary has full sampling, false otherwise
-     */
-    private boolean validateSummarySamplingLevel()
-    {
-        // We need to check index summary entries against the index to verify that none of them were dropped due to
-        // downsampling.  Downsampling can drop any of the first BASE_SAMPLING_LEVEL entries (repeating that drop pattern
-        // for the remainder of the summary).  Unfortunately, the first entry to be dropped is the entry at
-        // index (BASE_SAMPLING_LEVEL - 1), so we need to check a full set of BASE_SAMPLING_LEVEL entries.
-        if (ifile == null)
-            return false;
-
-        int i = 0;
-        int summaryEntriesChecked = 0;
-        int expectedIndexInterval = getMinIndexInterval();
-        String path = null;
-        try (FileDataInput in = ifile.createReader(0))
-        {
-            path = in.getPath();
-            while (!in.isEOF())
-            {
-                ByteBuffer indexKey = ByteBufferUtil.readWithShortLength(in);
-                if (i % expectedIndexInterval == 0)
-                {
-                    ByteBuffer summaryKey = ByteBuffer.wrap(indexSummary.getKey(i / expectedIndexInterval));
-                    if (!summaryKey.equals(indexKey))
-                        return false;
-                    summaryEntriesChecked++;
-
-                    if (summaryEntriesChecked == Downsampling.BASE_SAMPLING_LEVEL)
-                        return true;
-                }
-                RowIndexEntry.Serializer.skip(in, descriptor.version);
-                i++;
-            }
-        }
-        catch (IOException e)
-        {
-            markSuspect();
-            throw new CorruptSSTableException(e, path);
-        }
-
-        return true;
-    }
-
     /**
      * Save index summary to Summary.db file.
      *
