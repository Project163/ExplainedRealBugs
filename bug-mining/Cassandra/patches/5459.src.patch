diff --git a/CHANGES.txt b/CHANGES.txt
index 9b4f8c3e8a..2d66ee2598 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -6,6 +6,7 @@
  * 3.x fails to start if commit log has range tombstones from a column which is also deleted (CASSANDRA-15970)
  * Forbid altering UDTs used in partition keys (CASSANDRA-15933)
  * Fix empty/null json string representation (CASSANDRA-15896)
+ * Handle difference in timestamp precision between java8 and java11 in LogFIle.java (CASSANDRA-16050)
 Merged from 2.2:
  * Fix CQL parsing of collections when the column type is reversed (CASSANDRA-15814)
 
diff --git a/src/java/org/apache/cassandra/db/lifecycle/LogFile.java b/src/java/org/apache/cassandra/db/lifecycle/LogFile.java
index 6e820df9fa..ac64f13485 100644
--- a/src/java/org/apache/cassandra/db/lifecycle/LogFile.java
+++ b/src/java/org/apache/cassandra/db/lifecycle/LogFile.java
@@ -231,18 +231,31 @@ final class LogFile implements AutoCloseable
         // it matches. Because we delete files from oldest to newest, the latest update time should
         // always match.
         record.status.onDiskRecord = record.withExistingFiles(existingFiles);
-        if (record.updateTime != record.status.onDiskRecord.updateTime && record.status.onDiskRecord.updateTime > 0)
+        // we can have transaction files with mismatching updateTime resolutions due to switching between jdk8 and jdk11, truncate both to be consistent:
+        if (truncateMillis(record.updateTime) != truncateMillis(record.status.onDiskRecord.updateTime) && record.status.onDiskRecord.updateTime > 0)
         {
-            record.setError(String.format("Unexpected files detected for sstable [%s], " +
-                                          "record [%s]: last update time [%tT] should have been [%tT]",
+            record.setError(String.format("Unexpected files detected for sstable [%s]: " +
+                                          "record [%s]: last update time [%tc] (%d) should have been [%tc] (%d)",
                                           record.fileName(),
                                           record,
                                           record.status.onDiskRecord.updateTime,
+                                          record.status.onDiskRecord.updateTime,
+                                          record.updateTime,
                                           record.updateTime));
 
         }
     }
 
+    /**
+     * due to difference in timestamp resolution between jdk8 and 11 we need to return second resolution here (number
+     * should end in 000): https://bugs.openjdk.java.net/browse/JDK-8177809
+     */
+    static long truncateMillis(long lastModified)
+    {
+        return lastModified - (lastModified % 1000);
+    }
+
+
     static void verifyRecordWithCorruptedLastRecord(LogRecord record)
     {
         if (record.type == Type.REMOVE && record.status.onDiskRecord.numFiles < record.numFiles)
diff --git a/test/unit/org/apache/cassandra/db/lifecycle/LogTransactionTest.java b/test/unit/org/apache/cassandra/db/lifecycle/LogTransactionTest.java
index 2544a0d531..7ba1c397fe 100644
--- a/test/unit/org/apache/cassandra/db/lifecycle/LogTransactionTest.java
+++ b/test/unit/org/apache/cassandra/db/lifecycle/LogTransactionTest.java
@@ -1105,6 +1105,59 @@ public class LogTransactionTest extends AbstractTransactionalTest
         tidier.run();
     }
 
+    @Test
+    public void testTruncateFileUpdateTime() throws IOException
+    {
+        // Idea is that we truncate the actual modification time on disk after creating the log file.
+        // On java11 this would fail since we would have millisecond resolution in the log file, but
+        // then the file gives second resolution.
+        testTruncatedModificationTimesHelper(sstable ->
+                                  {
+                                      // increase the modification time of the Data file
+                                      for (String filePath : sstable.getAllFilePaths())
+                                      {
+                                          File f = new File(filePath);
+                                          long lastModified = f.lastModified();
+                                          f.setLastModified(lastModified - (lastModified % 1000));
+                                      }
+                                  });
+    }
+
+    private static void testTruncatedModificationTimesHelper(Consumer<SSTableReader> modifier) throws IOException
+    {
+        ColumnFamilyStore cfs = MockSchema.newCFS(KEYSPACE);
+        File dataFolder = new Directories(cfs.metadata).getDirectoryForNewSSTables();
+        SSTableReader sstableOld = sstable(dataFolder, cfs, 0, 128);
+        SSTableReader sstableNew = sstable(dataFolder, cfs, 1, 128);
+
+        // simulate tracking sstables with a committed transaction except the checksum will be wrong
+        LogTransaction log = new LogTransaction(OperationType.COMPACTION);
+        assertNotNull(log);
+
+        log.trackNew(sstableNew);
+        LogTransaction.SSTableTidier tidier = log.obsoleted(sstableOld);
+
+        //modify the old sstable files
+        modifier.accept(sstableOld);
+
+        //Fake a commit
+        log.txnFile().commit();
+
+        LogTransaction.removeUnfinishedLeftovers(cfs.metadata);
+
+        // only the new files should be there
+        assertFiles(dataFolder.getPath(), Sets.newHashSet(sstableNew.getAllFilePaths()));
+        sstableNew.selfRef().release();
+
+        // complete the transaction to avoid LEAK errors
+        assertNull(log.complete(null));
+
+        assertFiles(dataFolder.getPath(), Sets.newHashSet(sstableNew.getAllFilePaths()));
+
+        // make sure to run the tidier to avoid any leaks in the logs
+        tidier.run();
+    }
+
     @Test
     public void testGetTemporaryFilesSafeAfterObsoletion() throws Throwable
     {
