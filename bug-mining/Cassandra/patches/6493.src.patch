diff --git a/CHANGES.txt b/CHANGES.txt
index 6670601f06..19a62ea12f 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 5.1
+ * Support querying LocalStrategy tables with any partitioner (CASSANDRA-19692)
  * Relax slow_query_log_timeout for MultiNodeSAITest (CASSANDRA-19693)
  * Audit Log entries are missing identity for mTLS connections (CASSANDRA-19669)
  * Add support for the BETWEEN operator in WHERE clauses (CASSANDRA-19604)
diff --git a/src/java/org/apache/cassandra/locator/LocalStrategy.java b/src/java/org/apache/cassandra/locator/LocalStrategy.java
index 4032ce1594..5b24bce139 100644
--- a/src/java/org/apache/cassandra/locator/LocalStrategy.java
+++ b/src/java/org/apache/cassandra/locator/LocalStrategy.java
@@ -17,10 +17,11 @@
  */
 package org.apache.cassandra.locator;
 
+import java.util.IdentityHashMap;
 import java.util.List;
 import java.util.Map;
 
-import org.apache.cassandra.config.DatabaseDescriptor;
+import org.apache.cassandra.dht.IPartitioner;
 import org.apache.cassandra.dht.Range;
 import org.apache.cassandra.dht.Token;
 import org.apache.cassandra.tcm.ClusterMetadata;
@@ -33,6 +34,8 @@ import org.apache.cassandra.utils.FBUtilities;
 public class LocalStrategy extends SystemStrategy
 {
     private static final ReplicationFactor RF = ReplicationFactor.fullOnly(1);
+    private static final Map<IPartitioner, EntireRange> perPartitionerRanges = new IdentityHashMap<>();
+
     public LocalStrategy(String keyspaceName, Map<String, String> configOptions)
     {
         super(keyspaceName, configOptions);
@@ -41,13 +44,13 @@ public class LocalStrategy extends SystemStrategy
     @Override
     public EndpointsForRange calculateNaturalReplicas(Token token, ClusterMetadata metadata)
     {
-        return EntireRange.localReplicas;
+        return getRange(token.getPartitioner()).localReplicas;
     }
 
     @Override
     public DataPlacement calculateDataPlacement(Epoch epoch, List<Range<Token>> ranges, ClusterMetadata metadata)
     {
-        return EntireRange.placement;
+        return getRange(ranges.get(0).left.getPartitioner()).placement;
     }
 
     @Override
@@ -56,6 +59,11 @@ public class LocalStrategy extends SystemStrategy
         return RF;
     }
 
+    private EntireRange getRange(IPartitioner partitioner)
+    {
+        return perPartitionerRanges.computeIfAbsent(partitioner, EntireRange::new);
+    }
+
     /**
      * For lazy initialisation. In some circumstances, we may want to instantiate LocalStrategy without initialising
      * DatabaseDescriptor; FQL replay is one such usage as we initialise the KeyspaceMetadata objects, which now eagerly
@@ -63,9 +71,16 @@ public class LocalStrategy extends SystemStrategy
      */
     static class EntireRange
     {
-        public static final Range<Token> entireRange = new Range<>(DatabaseDescriptor.getPartitioner().getMinimumToken(), DatabaseDescriptor.getPartitioner().getMinimumToken());
-        public static final EndpointsForRange localReplicas = EndpointsForRange.of(new Replica(FBUtilities.getBroadcastAddressAndPort(), entireRange, true));
-        public static final DataPlacement placement = new DataPlacement(ReplicaGroups.builder().withReplicaGroup(VersionedEndpoints.forRange(Epoch.FIRST, localReplicas)).build(),
-                                                                        ReplicaGroups.builder().withReplicaGroup(VersionedEndpoints.forRange(Epoch.FIRST, localReplicas)).build());
+        public final Range<Token> entireRange;
+        public final EndpointsForRange localReplicas;
+        public final DataPlacement placement;
+
+        private EntireRange(IPartitioner partitioner)
+        {
+            entireRange = new Range<>(partitioner.getMinimumToken(), partitioner.getMinimumToken());
+            localReplicas = EndpointsForRange.of(new Replica(FBUtilities.getBroadcastAddressAndPort(), entireRange, true));
+            ReplicaGroups rg = ReplicaGroups.builder(1).withReplicaGroup(VersionedEndpoints.forRange(Epoch.FIRST, localReplicas)).build();
+            placement = new DataPlacement(rg, rg);
+        }
     }
 }
diff --git a/test/unit/org/apache/cassandra/cql3/SystemKeyspaceQueryTest.java b/test/unit/org/apache/cassandra/cql3/SystemKeyspaceQueryTest.java
new file mode 100644
index 0000000000..8da29df678
--- /dev/null
+++ b/test/unit/org/apache/cassandra/cql3/SystemKeyspaceQueryTest.java
@@ -0,0 +1,56 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.cassandra.cql3;
+
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+import org.apache.cassandra.utils.TimeUUID;
+
+import static org.apache.cassandra.db.SystemKeyspace.BATCHES;
+import static org.apache.cassandra.db.SystemKeyspace.LOCAL;
+import static org.apache.cassandra.db.SystemKeyspace.METADATA_LOG;
+import static org.apache.cassandra.db.SystemKeyspace.SNAPSHOT_TABLE_NAME;
+import static org.apache.cassandra.schema.SchemaConstants.SYSTEM_KEYSPACE_NAME;
+
+public class SystemKeyspaceQueryTest extends CQLTester
+{
+    @BeforeClass
+    public static void setUp()
+    {
+        requireNetwork();
+    }
+
+    @Test
+    public void testSelectsWithDifferentPartitioners()
+    {
+        // Verify that querying tables which use ReversedLongLocalPartitioner doesn't cause an error
+        assertRowCountNet(executeNet(String.format("SELECT * FROM %s.%s WHERE epoch = 1",
+                                                   SYSTEM_KEYSPACE_NAME, METADATA_LOG)), 0);
+        assertRowCountNet(executeNet(String.format("SELECT * FROM %s.%s WHERE epoch = 1",
+                                                   SYSTEM_KEYSPACE_NAME, SNAPSHOT_TABLE_NAME)), 0);
+        // system.batches table uses LocalPartitioner
+        assertRowCountNet(executeNet(String.format("SELECT * FROM %s.%s WHERE id = %s",
+                                                   SYSTEM_KEYSPACE_NAME, BATCHES,
+                                                   TimeUUID.Generator.nextTimeUUID())), 0);
+        // Query a table using the global system partitioner
+        assertRowCountNet(executeNet(String.format("SELECT * FROM %s.%s WHERE key = 'invalidkey'",
+                                                   SYSTEM_KEYSPACE_NAME, LOCAL)), 0);
+    }
+}
