diff --git a/CHANGES.txt b/CHANGES.txt
index f44cdb96ec..60e5cdc9b9 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -17,6 +17,8 @@
    (CASSANDRA-5718)
  * Add KeyCacheHitRate metric to CF metrics (CASSANDRA-5868)
  * cqlsh: add support for multiline comments (CASSANDRA-5798)
+ * Handle CQL3 SELECT duplicate IN restrictions on clustering columns
+   (CASSANDRA-5856)
 Merged from 1.1:
  * Correctly validate sparse composite cells in scrub (CASSANDRA-5855)
 
diff --git a/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java b/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
index 4f559e5c28..44a1e6451f 100644
--- a/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
+++ b/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
@@ -350,12 +350,6 @@ public class SelectStatement implements CQLStatement
             }
             else
             {
-                // The IN query might not have listed the values in comparator order, so we need to re-sort
-                // the bounds lists to make sure the slices works correctly
-                Comparator<ByteBuffer> cmp = isReversed ? cfDef.cfm.comparator.reverseComparator : cfDef.cfm.comparator;
-                Collections.sort(startBounds, cmp);
-                Collections.sort(endBounds, cmp);
-
                 List<ColumnSlice> l = new ArrayList<ColumnSlice>(startBounds.size());
                 for (int i = 0; i < startBounds.size(); i++)
                 {
@@ -368,12 +362,7 @@ public class SelectStatement implements CQLStatement
                 slices = l.toArray(new ColumnSlice[l.size()]);
             }
 
-            SliceQueryFilter filter = new SliceQueryFilter(slices,
-                                                           isReversed,
-                                                           getLimit(),
-                                                           toGroup,
-                                                           multiplier);
-            return filter;
+            return new SliceQueryFilter(slices, isReversed, getLimit(), toGroup, multiplier);
         }
         else
         {
@@ -581,12 +570,12 @@ public class SelectStatement implements CQLStatement
         return false;
     }
 
-    private static List<ByteBuffer> buildBound(Bound bound,
-                                               Collection<CFDefinition.Name> names,
-                                               Restriction[] restrictions,
-                                               boolean isReversed,
-                                               ColumnNameBuilder builder,
-                                               List<ByteBuffer> variables) throws InvalidRequestException
+    private List<ByteBuffer> buildBound(Bound bound,
+                                        Collection<CFDefinition.Name> names,
+                                        Restriction[] restrictions,
+                                        boolean isReversed,
+                                        ColumnNameBuilder builder,
+                                        List<ByteBuffer> variables) throws InvalidRequestException
     {
         // The end-of-component of composite doesn't depend on whether the
         // component type is reversed or not (i.e. the ReversedType is applied
@@ -616,7 +605,9 @@ public class SelectStatement implements CQLStatement
                 {
                     // IN query, we only support it on the clustering column
                     assert name.position == names.size() - 1;
-                    List<ByteBuffer> l = new ArrayList<ByteBuffer>(r.eqValues.size());
+                    // The IN query might not have listed the values in comparator order, so we need to re-sort
+                    // the bounds lists to make sure the slices works correctly (also, to avoid duplicates).
+                    TreeSet<ByteBuffer> s = new TreeSet<ByteBuffer>(isReversed ? cfDef.cfm.comparator.reverseComparator : cfDef.cfm.comparator);
                     for (Term t : r.eqValues)
                     {
                         ByteBuffer val = t.bindAndGet(variables);
@@ -624,9 +615,9 @@ public class SelectStatement implements CQLStatement
                             throw new InvalidRequestException(String.format("Invalid null clustering key part %s", name));
                         ColumnNameBuilder copy = builder.copy().add(val);
                         // See below for why this
-                        l.add((bound == Bound.END && copy.remainingCount() > 0) ? copy.buildAsEndOfRange() : copy.build());
+                        s.add((bound == Bound.END && copy.remainingCount() > 0) ? copy.buildAsEndOfRange() : copy.build());
                     }
-                    return l;
+                    return new ArrayList<ByteBuffer>(s);
                 }
 
                 ByteBuffer val = r.eqValues.get(0).bindAndGet(variables);
