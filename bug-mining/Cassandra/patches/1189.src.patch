diff --git a/CHANGES.txt b/CHANGES.txt
index 0e028f5899..47b7366076 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -18,6 +18,8 @@
  * (Hadoop) allow wrapping ranges in queries (CASSANDRA-3137)
  * (Hadoop) check all interfaces for a match with split location
    before falling back to random replica (CASSANDRA-3211)
+ * Fix bug where the failure detector can take too long to mark a host 
+   down (CASSANDRA-3273)
 
 
 0.8.6
diff --git a/src/java/org/apache/cassandra/gms/FailureDetector.java b/src/java/org/apache/cassandra/gms/FailureDetector.java
index 2f045efde2..ebe51324ae 100644
--- a/src/java/org/apache/cassandra/gms/FailureDetector.java
+++ b/src/java/org/apache/cassandra/gms/FailureDetector.java
@@ -121,7 +121,14 @@ public class FailureDetector implements IFailureDetector, FailureDetectorMBean
             logger_.error("unknown endpoint " + ep);
         return epState != null && epState.isAlive();
     }
-    
+
+    public void clear(InetAddress ep)
+    {
+        ArrivalWindow heartbeatWindow = arrivalSamples_.get(ep);
+        if (heartbeatWindow != null)
+            heartbeatWindow.clear();
+    }
+
     public void report(InetAddress ep)
     {
         if (logger_.isTraceEnabled())
@@ -149,7 +156,9 @@ public class FailureDetector implements IFailureDetector, FailureDetectorMBean
             logger_.trace("PHI for " + ep + " : " + phi);
         
         if ( phi > phiConvictThreshold_ )
-        {     
+        {
+            logger_.trace("notifying listeners that {} is down", ep);
+            logger_.trace("intervals: {} mean: {}", hbWnd, hbWnd.mean());
             for ( IFailureDetectionEventListener listener : fdEvntListeners_ )
             {
                 listener.convict(ep, phi);
@@ -206,6 +215,11 @@ class ArrivalWindow
     // change.
     private final double PHI_FACTOR = 1.0 / Math.log(10.0);
 
+    // in the event of a long partition, never record an interval longer than the rpc timeout,
+    // since if a host is regularly experiencing connectivity problems lasting this long we'd
+    // rather mark it down quickly instead of adapting
+    private final double MAX_INTERVAL_IN_MS = DatabaseDescriptor.getRpcTimeout();
+
     ArrivalWindow(int size)
     {
         arrivalIntervals_ = new BoundedStatsDeque(size);
@@ -216,14 +230,17 @@ class ArrivalWindow
         double interArrivalTime;
         if ( tLast_ > 0L )
         {                        
-            interArrivalTime = (value - tLast_);            
+            interArrivalTime = (value - tLast_);
         }
         else
         {
             interArrivalTime = Gossiper.intervalInMillis / 2;
         }
-        tLast_ = value;            
-        arrivalIntervals_.add(interArrivalTime);        
+        if (interArrivalTime <= MAX_INTERVAL_IN_MS)
+            arrivalIntervals_.add(interArrivalTime);
+        else
+            logger_.debug("Ignoring interval time of {}", interArrivalTime);
+        tLast_ = value;
     }
     
     synchronized double sum()
diff --git a/src/java/org/apache/cassandra/gms/Gossiper.java b/src/java/org/apache/cassandra/gms/Gossiper.java
index 0efb94f7b9..3c92aaf110 100644
--- a/src/java/org/apache/cassandra/gms/Gossiper.java
+++ b/src/java/org/apache/cassandra/gms/Gossiper.java
@@ -665,6 +665,13 @@ public class Gossiper implements IFailureDetectionEventListener
             if ( remoteGeneration > localGeneration )
             {
                 localEndpointState.updateTimestamp();
+                // this node was dead and the generation changed, this indicates a reboot, or possibly a takeover
+                // we will clean the fd intervals for it and relearn them
+                if (!localEndpointState.isAlive())
+                {
+                    logger.debug("Clearing interval times for {} due to generation change", endpoint);
+                    fd.clear(endpoint);
+                }
                 fd.report(endpoint);
                 return;
             }
@@ -676,6 +683,7 @@ public class Gossiper implements IFailureDetectionEventListener
                 if ( remoteVersion > localVersion )
                 {
                     localEndpointState.updateTimestamp();
+                    // just a version change, report to the fd
                     fd.report(endpoint);
                 }
             }
diff --git a/src/java/org/apache/cassandra/gms/IFailureDetector.java b/src/java/org/apache/cassandra/gms/IFailureDetector.java
index 426eec8031..df12bb497a 100644
--- a/src/java/org/apache/cassandra/gms/IFailureDetector.java
+++ b/src/java/org/apache/cassandra/gms/IFailureDetector.java
@@ -37,7 +37,13 @@ public interface IFailureDetector
      * @return true if UP and false if DOWN.
      */
     public boolean isAlive(InetAddress ep);
-    
+
+    /**
+     * Clear any existing interval timings for this endpoint
+     * @param ep
+     */
+    public void clear(InetAddress ep);
+
     /**
      * This method is invoked by any entity wanting to interrogate the status of an endpoint. 
      * In our case it would be the Gossiper. The Failure Detector will then calculate Phi and
