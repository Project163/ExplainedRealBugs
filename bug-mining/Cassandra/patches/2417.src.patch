diff --git a/CHANGES.txt b/CHANGES.txt
index 53bc84890e..48fcf589ea 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -24,6 +24,7 @@
  * stress: add username/password authentication support (CASSANDRA-6068)
  * Fix indexed queries with row cache enabled on parent table (CASSANDRA-5732)
  * Fix compaction race during columnfamily drop (CASSANDRA-5957)
+ * Fix validation of empty column names for compact tables (CASSANDRA-6152)
 
 
 1.2.10
diff --git a/src/java/org/apache/cassandra/cql3/QueryProcessor.java b/src/java/org/apache/cassandra/cql3/QueryProcessor.java
index c4e7c44595..71a57f434c 100644
--- a/src/java/org/apache/cassandra/cql3/QueryProcessor.java
+++ b/src/java/org/apache/cassandra/cql3/QueryProcessor.java
@@ -102,18 +102,21 @@ public class QueryProcessor
         }
     }
 
-    public static void validateColumnNames(Iterable<ByteBuffer> columns)
-    throws InvalidRequestException
+    public static void validateColumnNames(Iterable<ByteBuffer> columnNames) throws InvalidRequestException
     {
-        for (ByteBuffer name : columns)
-        {
-            if (name.remaining() > IColumn.MAX_NAME_LENGTH)
-                throw new InvalidRequestException(String.format("column name is too long (%s > %s)",
-                                                                name.remaining(),
-                                                                IColumn.MAX_NAME_LENGTH));
-            if (name.remaining() == 0)
-                throw new InvalidRequestException("zero-length column name");
-        }
+        for (ByteBuffer name : columnNames)
+            validateColumnName(name);
+    }
+
+    public static void validateColumnName(ByteBuffer name) throws InvalidRequestException
+    {
+        if (name.remaining() > IColumn.MAX_NAME_LENGTH)
+            throw new InvalidRequestException(String.format("The sum of all clustering columns is too long (%s > %s)",
+                                                            name.remaining(),
+                                                            IColumn.MAX_NAME_LENGTH));
+
+        if (name.remaining() == 0)
+            throw new InvalidRequestException("Invalid empty value for clustering column of COMPACT TABLE");
     }
 
     private static ResultMessage processStatement(CQLStatement statement, ConsistencyLevel cl, QueryState queryState, List<ByteBuffer> variables)
diff --git a/src/java/org/apache/cassandra/cql3/UpdateParameters.java b/src/java/org/apache/cassandra/cql3/UpdateParameters.java
index e8da34c4a8..b938fea2ea 100644
--- a/src/java/org/apache/cassandra/cql3/UpdateParameters.java
+++ b/src/java/org/apache/cassandra/cql3/UpdateParameters.java
@@ -24,6 +24,7 @@ import java.util.Map;
 
 import org.apache.cassandra.cql3.statements.ColumnGroupMap;
 import org.apache.cassandra.db.*;
+import org.apache.cassandra.exceptions.InvalidRequestException;
 import org.apache.cassandra.utils.Pair;
 
 /**
@@ -48,25 +49,31 @@ public class UpdateParameters
         this.prefetchedLists = prefetchedLists;
     }
 
-    public Column makeColumn(ByteBuffer name, ByteBuffer value)
+    public Column makeColumn(ByteBuffer name, ByteBuffer value) throws InvalidRequestException
     {
+        QueryProcessor.validateColumnName(name);
         return ttl > 0
              ? new ExpiringColumn(name, value, timestamp, ttl)
              : new Column(name, value, timestamp);
     }
 
-    public Column makeTombstone(ByteBuffer name)
+    public Column makeTombstone(ByteBuffer name) throws InvalidRequestException
     {
+        QueryProcessor.validateColumnName(name);
         return new DeletedColumn(name, localDeletionTime, timestamp);
     }
 
-    public RangeTombstone makeRangeTombstone(ByteBuffer start, ByteBuffer end)
+    public RangeTombstone makeRangeTombstone(ByteBuffer start, ByteBuffer end) throws InvalidRequestException
     {
+        QueryProcessor.validateColumnName(start);
+        QueryProcessor.validateColumnName(end);
         return new RangeTombstone(start, end, timestamp, localDeletionTime);
     }
 
-    public RangeTombstone makeTombstoneForOverwrite(ByteBuffer start, ByteBuffer end)
+    public RangeTombstone makeTombstoneForOverwrite(ByteBuffer start, ByteBuffer end) throws InvalidRequestException
     {
+        QueryProcessor.validateColumnName(start);
+        QueryProcessor.validateColumnName(end);
         return new RangeTombstone(start, end, timestamp - 1, localDeletionTime);
     }
 
