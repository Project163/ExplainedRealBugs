diff --git a/CHANGES.txt b/CHANGES.txt
index d8a348d5fc..906f91fb56 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -2,6 +2,7 @@
  * Fix saving triggers to schema (CASSANDRA-6789)
  * Fix trigger mutations when base mutation list is immutable (CASSANDRA-6790)
  * Fix accounting in FileCacheService to allow re-using RAR (CASSANDRA-6838)
+ * Fix static counter columns (CASSANDRA-6827)
 
 
 2.0.6
diff --git a/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java b/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
index 100383fdf4..53b2c05656 100644
--- a/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
+++ b/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
@@ -25,6 +25,7 @@ import com.google.common.base.Predicate;
 import com.google.common.collect.AbstractIterator;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
+
 import org.github.jamm.MemoryMeter;
 
 import org.apache.cassandra.auth.Permission;
@@ -33,6 +34,7 @@ import org.apache.cassandra.transport.messages.ResultMessage;
 import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.config.ColumnDefinition;
 import org.apache.cassandra.db.*;
+import org.apache.cassandra.db.context.CounterContext;
 import org.apache.cassandra.db.filter.*;
 import org.apache.cassandra.db.marshal.*;
 import org.apache.cassandra.dht.*;
@@ -1052,7 +1054,7 @@ public class SelectStatement implements CQLStatement, MeasurableForPreparedCache
                 staticValues = new HashMap<>();
                 ColumnGroupMap group = builder.firstGroup();
                 for (CFDefinition.Name name : Iterables.filter(selection.getColumnsList(), isStaticFilter))
-                    staticValues.put(name, name.type.isCollection() ? getCollectionValue(name, group) : getSimpleValue(name, group));
+                    staticValues.put(name, getValue(name, group));
                 builder.discardFirst();
 
                 // If there was static columns but there is no actual row, then provided the select was a full
@@ -1180,6 +1182,16 @@ public class SelectStatement implements CQLStatement, MeasurableForPreparedCache
         }
     }
 
+    private static ByteBuffer getValue(CFDefinition.Name name, ColumnGroupMap columns)
+    {
+        if (name.type.isCollection())
+            return getCollectionValue(name, columns);
+        else if (name.type.isCommutative())
+            return getCounterValue(name, columns);
+
+        return getSimpleValue(name, columns);
+    }
+
     private static ByteBuffer getCollectionValue(CFDefinition.Name name, ColumnGroupMap columns)
     {
         List<Pair<ByteBuffer, Column>> collection = columns.getCollection(name.name.key);
@@ -1192,6 +1204,12 @@ public class SelectStatement implements CQLStatement, MeasurableForPreparedCache
         return c == null ? null : c.value();
     }
 
+    private static ByteBuffer getCounterValue(CFDefinition.Name name, ColumnGroupMap columns)
+    {
+        Column c = columns.getSimple(name.name.key);
+        return c == null ? null : CounterColumnType.instance.decompose(CounterContext.instance().total(c.value()));
+    }
+
     private static boolean isReversedType(CFDefinition.Name name)
     {
         return name.type instanceof ReversedType;
