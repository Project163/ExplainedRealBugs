diff --git a/CHANGES.txt b/CHANGES.txt
index d7b0fc241c..b9596d9d4c 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 2.2.6
+ * Non-obsoleting compaction operations over compressed files can impose rate limit on normal reads (CASSANDRA-11301)
  * Add missing newline at end of bin/cqlsh (CASSANDRA-11325)
  * Fix AE in nodetool cfstats (backport CASSANDRA-10859) (CASSANDRA-11297)
  * Unresolved hostname leads to replace being ignored (CASSANDRA-11210)
diff --git a/src/java/org/apache/cassandra/io/compress/CompressedRandomAccessReader.java b/src/java/org/apache/cassandra/io/compress/CompressedRandomAccessReader.java
index e6ac60abda..ccfa5e75a0 100644
--- a/src/java/org/apache/cassandra/io/compress/CompressedRandomAccessReader.java
+++ b/src/java/org/apache/cassandra/io/compress/CompressedRandomAccessReader.java
@@ -41,26 +41,15 @@ public class CompressedRandomAccessReader extends RandomAccessReader
 {
     public static CompressedRandomAccessReader open(ChannelProxy channel, CompressionMetadata metadata)
     {
-        try
-        {
-            return new CompressedRandomAccessReader(channel, metadata, null);
-        }
-        catch (FileNotFoundException e)
-        {
-            throw new RuntimeException(e);
-        }
+        return new CompressedRandomAccessReader(channel, metadata, null, null);
     }
 
     public static CompressedRandomAccessReader open(ICompressedFile file)
     {
-        try
-        {
-            return new CompressedRandomAccessReader(file.channel(), file.getMetadata(), file);
-        }
-        catch (FileNotFoundException e)
-        {
-            throw new RuntimeException(e);
-        }
+        return new CompressedRandomAccessReader(file.channel(),
+                                                file.getMetadata(),
+                                                file,
+                                                file instanceof PoolingSegmentedFile ? (PoolingSegmentedFile) file : null);
     }
 
     private final TreeMap<Long, MappedByteBuffer> chunkSegments;
@@ -76,9 +65,9 @@ public class CompressedRandomAccessReader extends RandomAccessReader
     // raw checksum bytes
     private ByteBuffer checksumBytes;
 
-    protected CompressedRandomAccessReader(ChannelProxy channel, CompressionMetadata metadata, ICompressedFile file) throws FileNotFoundException
+    protected CompressedRandomAccessReader(ChannelProxy channel, CompressionMetadata metadata, ICompressedFile file, PoolingSegmentedFile owner)
     {
-        super(channel, metadata.chunkLength(), metadata.compressedFileLength, metadata.compressor().preferredBufferType(), file instanceof PoolingSegmentedFile ? (PoolingSegmentedFile) file : null);
+        super(channel, metadata.chunkLength(), metadata.compressedFileLength, metadata.compressor().preferredBufferType(), owner);
         this.metadata = metadata;
         checksum = new Adler32();
 
diff --git a/src/java/org/apache/cassandra/io/compress/CompressedThrottledReader.java b/src/java/org/apache/cassandra/io/compress/CompressedThrottledReader.java
index a29129c2bd..2b07c50f69 100644
--- a/src/java/org/apache/cassandra/io/compress/CompressedThrottledReader.java
+++ b/src/java/org/apache/cassandra/io/compress/CompressedThrottledReader.java
@@ -21,8 +21,6 @@ package org.apache.cassandra.io.compress;
  */
 
 
-import java.io.FileNotFoundException;
-
 import com.google.common.util.concurrent.RateLimiter;
 
 import org.apache.cassandra.io.util.ChannelProxy;
@@ -32,9 +30,9 @@ public class CompressedThrottledReader extends CompressedRandomAccessReader
 {
     private final RateLimiter limiter;
 
-    public CompressedThrottledReader(ChannelProxy channel, CompressionMetadata metadata, ICompressedFile file, RateLimiter limiter) throws FileNotFoundException
+    public CompressedThrottledReader(ChannelProxy channel, CompressionMetadata metadata, ICompressedFile file, RateLimiter limiter)
     {
-        super(channel, metadata, file);
+        super(channel, metadata, file, null);
         this.limiter = limiter;
     }
 
@@ -46,13 +44,6 @@ public class CompressedThrottledReader extends CompressedRandomAccessReader
 
     public static CompressedThrottledReader open(ICompressedFile file, RateLimiter limiter)
     {
-        try
-        {
-            return new CompressedThrottledReader(file.channel(), file.getMetadata(), file, limiter);
-        }
-        catch (FileNotFoundException e)
-        {
-            throw new RuntimeException(e);
-        }
+        return new CompressedThrottledReader(file.channel(), file.getMetadata(), file, limiter);
     }
 }
diff --git a/test/unit/org/apache/cassandra/io/compress/CompressedRandomAccessReaderTest.java b/test/unit/org/apache/cassandra/io/compress/CompressedRandomAccessReaderTest.java
index 0cf4cfa51c..931422b83c 100644
--- a/test/unit/org/apache/cassandra/io/compress/CompressedRandomAccessReaderTest.java
+++ b/test/unit/org/apache/cassandra/io/compress/CompressedRandomAccessReaderTest.java
@@ -24,20 +24,26 @@ import java.io.RandomAccessFile;
 import java.util.Collections;
 import java.util.Random;
 
+import com.google.common.util.concurrent.RateLimiter;
 import org.junit.Test;
+
 import org.apache.cassandra.db.composites.SimpleDenseCellNameType;
 import org.apache.cassandra.db.marshal.BytesType;
 import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.io.sstable.CorruptSSTableException;
 import org.apache.cassandra.io.sstable.metadata.MetadataCollector;
 import org.apache.cassandra.io.util.ChannelProxy;
+import org.apache.cassandra.io.util.CompressedPoolingSegmentedFile;
+import org.apache.cassandra.io.util.FileDataInput;
 import org.apache.cassandra.io.util.FileMark;
 import org.apache.cassandra.io.util.RandomAccessReader;
 import org.apache.cassandra.io.util.SequentialWriter;
 import org.apache.cassandra.utils.SyncUtil;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
 
 public class CompressedRandomAccessReaderTest
 {
@@ -234,6 +240,60 @@ public class CompressedRandomAccessReaderTest
         }
     }
 
+    @Test
+    public void testThrottledReadersAreNotCached() throws IOException
+    {
+        String CONTENT = "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Etiam vitae.";
+
+        File file = new File("testThrottledReadersAreNotCached");
+        file.deleteOnExit();
+
+        File metadata = new File(file.getPath() + ".meta");
+        metadata.deleteOnExit();
+
+        MetadataCollector sstableMetadataCollector = new MetadataCollector(new SimpleDenseCellNameType(BytesType.instance)).replayPosition(null);
+        try (SequentialWriter writer = new CompressedSequentialWriter(file, metadata.getPath(), new CompressionParameters(SnappyCompressor.instance), sstableMetadataCollector))
+        {
+            writer.write(CONTENT.getBytes());
+            writer.finish();
+        }
+
+        CompressionMetadata meta = new CompressionMetadata(metadata.getPath(), file.length());
+
+        try(ChannelProxy channel = new ChannelProxy(file);
+            CompressedPoolingSegmentedFile segmentedFile = new CompressedPoolingSegmentedFile(channel, meta))
+        {
+            //The cache bucket is only initialized by a call to FileCacheService.instance.get() so first
+            // we must create a reader using the interface for accessing segments
+            FileDataInput reader = segmentedFile.getSegment(0);
+            assertNotNull(reader);
+            reader.close();
+
+            //Now we create a throttled reader, this should not be added to the cache
+            RateLimiter limiter = RateLimiter.create(1024);
+            reader = segmentedFile.createThrottledReader(limiter);
+            assertNotNull(reader);
+            assertTrue(reader instanceof CompressedThrottledReader);
+            reader.close();
+
+            //We retrieve 2 readers, neither should be a throttled reader
+            FileDataInput[] readers =
+            {
+                segmentedFile.getSegment(0),
+                segmentedFile.getSegment(0)
+            };
+
+            for (FileDataInput r : readers)
+            {
+                assertNotNull(r);
+                assertFalse(r instanceof CompressedThrottledReader);
+            }
+
+            for (FileDataInput r : readers)
+                r.close();
+        }
+    }
+
     private void updateChecksum(RandomAccessFile file, long checksumOffset, byte[] checksum) throws IOException
     {
         file.seek(checksumOffset);
