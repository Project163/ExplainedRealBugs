diff --git a/CHANGES.txt b/CHANGES.txt
index 189aec477a..3b47c33806 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 3.11.9
+ * Don't attempt value skipping with mixed version cluster (CASSANDRA-15833)
  * Avoid failing compactions with very large partitions (CASSANDRA-15164)
  * Make sure LCS handles duplicate sstable added/removed notifications correctly (CASSANDRA-14103)
 Merged from 3.0:
diff --git a/src/java/org/apache/cassandra/db/filter/ColumnFilter.java b/src/java/org/apache/cassandra/db/filter/ColumnFilter.java
index 37da86ae56..57ff729add 100644
--- a/src/java/org/apache/cassandra/db/filter/ColumnFilter.java
+++ b/src/java/org/apache/cassandra/db/filter/ColumnFilter.java
@@ -28,6 +28,7 @@ import org.apache.cassandra.cql3.ColumnIdentifier;
 import org.apache.cassandra.db.*;
 import org.apache.cassandra.db.rows.CellPath;
 import org.apache.cassandra.config.ColumnDefinition;
+import org.apache.cassandra.gms.Gossiper;
 import org.apache.cassandra.io.util.DataInputPlus;
 import org.apache.cassandra.io.util.DataOutputPlus;
 import org.apache.cassandra.net.MessagingService;
@@ -351,6 +352,10 @@ public class ColumnFilter
                     s.put(subSelection.column().name, subSelection);
             }
 
+            // see CASSANDRA-15833
+            if (isFetchAll && Gossiper.instance.isAnyNodeOn30())
+                queried = null;
+
             return new ColumnFilter(isFetchAll, isFetchAll ? metadata.partitionColumns() : null, queried, s);
         }
     }
@@ -495,6 +500,10 @@ public class ColumnFilter
                 }
             }
 
+            // See CASSANDRA-15833
+            if (version <= MessagingService.VERSION_3014 && isFetchAll)
+                queried = null;
+
             return new ColumnFilter(isFetchAll, fetched, queried, subSelections);
         }
 
diff --git a/test/distributed/org/apache/cassandra/distributed/impl/AbstractCluster.java b/test/distributed/org/apache/cassandra/distributed/impl/AbstractCluster.java
index 3cb8dacf1e..349301984a 100644
--- a/test/distributed/org/apache/cassandra/distributed/impl/AbstractCluster.java
+++ b/test/distributed/org/apache/cassandra/distributed/impl/AbstractCluster.java
@@ -129,7 +129,7 @@ public abstract class AbstractCluster<I extends IInstance> implements ICluster<I
         private volatile Versions.Version version;
         private volatile boolean isShutdown = true;
 
-        protected IInvokableInstance delegate()
+        public IInvokableInstance delegate()
         {
             if (delegate == null)
                 throw new IllegalStateException("Can't use shut down instances, delegate is null");
diff --git a/test/distributed/org/apache/cassandra/distributed/impl/DelegatingInvokableInstance.java b/test/distributed/org/apache/cassandra/distributed/impl/DelegatingInvokableInstance.java
index 690e50325b..ffc20e9471 100644
--- a/test/distributed/org/apache/cassandra/distributed/impl/DelegatingInvokableInstance.java
+++ b/test/distributed/org/apache/cassandra/distributed/impl/DelegatingInvokableInstance.java
@@ -38,7 +38,7 @@ import org.apache.cassandra.distributed.shared.NetworkTopology;
 
 public abstract class DelegatingInvokableInstance implements IInvokableInstance
 {
-    protected abstract IInvokableInstance delegate();
+    public abstract IInvokableInstance delegate();
     protected abstract IInvokableInstance delegateForStartup();
     
     @Override
@@ -224,4 +224,9 @@ public abstract class DelegatingInvokableInstance implements IInvokableInstance
         return delegate().sync(f);
     }
 
+    @Override
+    public <O> O callOnInstance(SerializableCallable<O> call)
+    {
+        return delegate().callOnInstance(call);
+    }
 }
diff --git a/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeReadTest.java b/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeReadTest.java
new file mode 100644
index 0000000000..249e1b89ca
--- /dev/null
+++ b/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeReadTest.java
@@ -0,0 +1,102 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.cassandra.distributed.upgrade;
+
+import java.util.UUID;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+import org.apache.cassandra.distributed.UpgradeableCluster;
+import org.apache.cassandra.distributed.api.ConsistencyLevel;
+import org.apache.cassandra.distributed.api.Feature;
+import org.apache.cassandra.distributed.impl.DelegatingInvokableInstance;
+import org.apache.cassandra.distributed.shared.DistributedTestBase;
+import org.apache.cassandra.distributed.shared.Versions;
+import org.apache.cassandra.gms.Gossiper;
+
+public class MixedModeReadTest extends UpgradeTestBase
+{
+    public static final String TABLE_NAME = "tbl";
+    public static final String CREATE_TABLE = String.format(
+      "CREATE TABLE %s.%s (key int, c1 text, c2 text, c3 text, PRIMARY KEY (key))",
+      DistributedTestBase.KEYSPACE, TABLE_NAME);
+
+    public static final String INSERT = String.format(
+      "INSERT INTO %s.%s (key, c1, c2, c3) VALUES (?, ?, ?, ?)",
+      DistributedTestBase.KEYSPACE, TABLE_NAME);
+
+    public static final String SELECT_C1 = String.format("SELECT key, c1 FROM %s.%s WHERE key = ?",
+                                                         DistributedTestBase.KEYSPACE, TABLE_NAME);
+    public static final String SELECT_TRACE = "SELECT activity FROM system_traces.events where session_id = ? and source = ? ALLOW FILTERING;";
+
+    @Test
+    public void mixedModeReadColumnSubsetDigestCheck() throws Throwable
+    {
+        new TestCase()
+        .nodes(2)
+        .nodesToUpgrade(1)
+        .upgrade(Versions.Major.v30, Versions.Major.v3X)
+        .withConfig(config -> config.with(Feature.GOSSIP, Feature.NETWORK))
+        .setup(cluster -> {
+            cluster.schemaChange(CREATE_TABLE);
+            cluster.coordinator(1).execute(INSERT, ConsistencyLevel.ALL, 1, "foo", "bar", "baz");
+            cluster.coordinator(1).execute(INSERT, ConsistencyLevel.ALL, 2, "foo", "bar", "baz");
+
+            // baseline to show no digest mismatches before upgrade
+            checkTraceForDigestMismatch(cluster, 1);
+            checkTraceForDigestMismatch(cluster, 2);
+        })
+        .runAfterNodeUpgrade((cluster, node) -> {
+            if (node != 1)
+                return; // shouldn't happen but guard for future test changes
+
+
+            // we need to let gossip settle or the test will fail
+            int attempts = 1;
+            while (!((DelegatingInvokableInstance) (cluster.get(1))).delegate().callOnInstance(() -> Gossiper.instance.isAnyNodeOn30()))
+            {
+                if (attempts > 30)
+                    throw new RuntimeException("Gossiper.instance.isAnyNodeOn30() continually returns false despite expecting to be true");
+                Thread.sleep(1000);
+            }
+
+            // should not cause a disgest mismatch in mixed mode
+            checkTraceForDigestMismatch(cluster, 1);
+            checkTraceForDigestMismatch(cluster, 2);
+        })
+        .run();
+    }
+
+    private void checkTraceForDigestMismatch(UpgradeableCluster cluster, int coordinatorNode)
+    {
+        UUID sessionId = UUID.randomUUID();
+        cluster.coordinator(coordinatorNode).executeWithTracing(sessionId, SELECT_C1, ConsistencyLevel.ALL, 1);
+        Object[][] results = cluster.coordinator(coordinatorNode)
+                                    .execute(SELECT_TRACE, ConsistencyLevel.ALL,
+                                             sessionId, cluster.get(coordinatorNode).broadcastAddress().getAddress());
+        for (Object[] result : results)
+        {
+            String activity = (String) result[0];
+            Assert.assertFalse("Found Digest Mismatch", activity.toLowerCase().contains("mismatch for key"));
+        }
+    }
+
+
+}
diff --git a/test/unit/org/apache/cassandra/db/filter/ColumnFilterTest.java b/test/unit/org/apache/cassandra/db/filter/ColumnFilterTest.java
index db06d2038f..41fd0a7eaf 100644
--- a/test/unit/org/apache/cassandra/db/filter/ColumnFilterTest.java
+++ b/test/unit/org/apache/cassandra/db/filter/ColumnFilterTest.java
@@ -54,9 +54,6 @@ public class ColumnFilterTest
 
         testRoundTrip(ColumnFilter.selection(metadata.partitionColumns().without(v1)), metadata, MessagingService.VERSION_30);
         testRoundTrip(ColumnFilter.selection(metadata.partitionColumns().without(v1)), metadata, MessagingService.VERSION_3014);
-
-        testRoundTrip(ColumnFilter.selection(metadata, metadata.partitionColumns().without(v1)), metadata, MessagingService.VERSION_30);
-        testRoundTrip(ColumnFilter.selection(metadata, metadata.partitionColumns().without(v1)), metadata, MessagingService.VERSION_3014);
     }
 
     static void testRoundTrip(ColumnFilter columnFilter, CFMetaData metadata, int version) throws Exception
