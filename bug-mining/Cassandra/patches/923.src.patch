diff --git a/CHANGES.txt b/CHANGES.txt
index c753213bf5..610e8b473a 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -22,7 +22,8 @@
  * avoid using cached position of a key when GT is requested (CASSANDRA-2633)
  * fix counting bloom filter true positives (CASSANDRA-2637)
  * initialize local ep state prior to gossip startup if needed (CASSANDRA-2638)
-  
+ * fix empty Result with secondary index when limit=1 (CASSANDRA-2628)
+
 
 0.7.5
  * improvements/fixes to PIG driver (CASSANDRA-1618, CASSANDRA-2387,
diff --git a/src/java/org/apache/cassandra/db/ColumnFamilyStore.java b/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
index 9d60fe0ab1..69ca242599 100644
--- a/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
+++ b/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
@@ -1569,12 +1569,15 @@ public class ColumnFamilyStore implements ColumnFamilyStoreMBean
             if (logger.isDebugEnabled())
                 logger.debug(String.format("Scanning index %s starting with %s",
                                            expressionString(primary), indexCFS.getComparator().getString(startKey)));
+
+            // We shouldn't fetch only 1 row as this provides buggy paging in case the first row doesn't satisfy all clauses
+            int count = Math.max(clause.count, 2);
             QueryFilter indexFilter = QueryFilter.getSliceFilter(indexKey,
                                                                  new QueryPath(indexCFS.getColumnFamilyName()),
                                                                  startKey,
                                                                  ByteBufferUtil.EMPTY_BYTE_BUFFER,
                                                                  false,
-                                                                 clause.count);
+                                                                 count);
             ColumnFamily indexRow = indexCFS.getColumnFamily(indexFilter);
             logger.debug("fetched {}", indexRow);
             if (indexRow == null)
diff --git a/test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java b/test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java
index 8f9db8141d..7f5765ec72 100644
--- a/test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java
+++ b/test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java
@@ -355,6 +355,45 @@ public class ColumnFamilyStoreTest extends CleanupHelper
     
     }
 
+    // See CASSANDRA-2628
+    @Test
+    public void testIndexScanWithLimitOne() throws IOException
+    {
+        RowMutation rm;
+
+        rm = new RowMutation("Keyspace1", ByteBufferUtil.bytes("kk1"));
+        rm.add(new QueryPath("Indexed1", null, ByteBufferUtil.bytes("notbirthdate")), ByteBufferUtil.bytes(1L), 0);
+        rm.add(new QueryPath("Indexed1", null, ByteBufferUtil.bytes("birthdate")), ByteBufferUtil.bytes(1L), 0);
+        rm.apply();
+
+        rm = new RowMutation("Keyspace1", ByteBufferUtil.bytes("kk2"));
+        rm.add(new QueryPath("Indexed1", null, ByteBufferUtil.bytes("notbirthdate")), ByteBufferUtil.bytes(2L), 0);
+        rm.add(new QueryPath("Indexed1", null, ByteBufferUtil.bytes("birthdate")), ByteBufferUtil.bytes(1L), 0);
+        rm.apply();
+
+        rm = new RowMutation("Keyspace1", ByteBufferUtil.bytes("kk3"));
+        rm.add(new QueryPath("Indexed1", null, ByteBufferUtil.bytes("notbirthdate")), ByteBufferUtil.bytes(2L), 0);
+        rm.add(new QueryPath("Indexed1", null, ByteBufferUtil.bytes("birthdate")), ByteBufferUtil.bytes(1L), 0);
+        rm.apply();
+
+        rm = new RowMutation("Keyspace1", ByteBufferUtil.bytes("kk4"));
+        rm.add(new QueryPath("Indexed1", null, ByteBufferUtil.bytes("notbirthdate")), ByteBufferUtil.bytes(2L), 0);
+        rm.add(new QueryPath("Indexed1", null, ByteBufferUtil.bytes("birthdate")), ByteBufferUtil.bytes(1L), 0);
+        rm.apply();
+
+        // basic single-expression query
+        IndexExpression expr1 = new IndexExpression(ByteBufferUtil.bytes("birthdate"), IndexOperator.EQ, ByteBufferUtil.bytes(1L));
+        IndexExpression expr2 = new IndexExpression(ByteBufferUtil.bytes("notbirthdate"), IndexOperator.GT, ByteBufferUtil.bytes(1L));
+        IndexClause clause = new IndexClause(Arrays.asList(new IndexExpression[]{ expr1, expr2 }), ByteBufferUtil.EMPTY_BYTE_BUFFER, 1);
+        IFilter filter = new IdentityQueryFilter();
+        IPartitioner p = StorageService.getPartitioner();
+        Range range = new Range(p.getMinimumToken(), p.getMinimumToken());
+        List<Row> rows = Table.open("Keyspace1").getColumnFamilyStore("Indexed1").scan(clause, range, filter);
+
+        assert rows != null;
+        assert rows.size() == 1 : StringUtils.join(rows, ",");
+    }
+
     @Test
     public void testIndexCreate() throws IOException, ConfigurationException, InterruptedException, ExecutionException
     {
