diff --git a/CHANGES.txt b/CHANGES.txt
index 46206b16cb..268d0119b4 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 3.0.6
+ * Fix paging for range queries where all clustering columns are specified (CASSANDRA-11669)
  * Don't require HEAP_NEW_SIZE to be set when using G1 (CASSANDRA-11600)
  * Fix sstabledump not showing cells after tombstone marker (CASSANDRA-11654)
  * Ignore all LocalStrategy keyspaces for streaming and other related
diff --git a/src/java/org/apache/cassandra/db/PartitionRangeReadCommand.java b/src/java/org/apache/cassandra/db/PartitionRangeReadCommand.java
index 9fce15e53e..9585b595ee 100644
--- a/src/java/org/apache/cassandra/db/PartitionRangeReadCommand.java
+++ b/src/java/org/apache/cassandra/db/PartitionRangeReadCommand.java
@@ -165,10 +165,7 @@ public class PartitionRangeReadCommand extends ReadCommand
 
     public QueryPager getPager(PagingState pagingState, int protocolVersion)
     {
-        if (isNamesQuery())
-            return new RangeNamesQueryPager(this, pagingState, protocolVersion);
-        else
-            return new RangeSliceQueryPager(this, pagingState, protocolVersion);
+            return new PartitionRangeQueryPager(this, pagingState, protocolVersion);
     }
 
     protected void recordLatency(TableMetrics metric, long latencyNanos)
diff --git a/src/java/org/apache/cassandra/service/pager/RangeSliceQueryPager.java b/src/java/org/apache/cassandra/service/pager/PartitionRangeQueryPager.java
similarity index 94%
rename from src/java/org/apache/cassandra/service/pager/RangeSliceQueryPager.java
rename to src/java/org/apache/cassandra/service/pager/PartitionRangeQueryPager.java
index 6ad8649870..9c216e3362 100644
--- a/src/java/org/apache/cassandra/service/pager/RangeSliceQueryPager.java
+++ b/src/java/org/apache/cassandra/service/pager/PartitionRangeQueryPager.java
@@ -31,22 +31,21 @@ import org.apache.cassandra.index.Index;
 import org.apache.cassandra.schema.IndexMetadata;
 
 /**
- * Pages a RangeSliceCommand whose predicate is a slice query.
+ * Pages a PartitionRangeReadCommand.
  *
  * Note: this only work for CQL3 queries for now (because thrift queries expect
  * a different limit on the rows than on the columns, which complicates it).
  */
-public class RangeSliceQueryPager extends AbstractQueryPager
+public class PartitionRangeQueryPager extends AbstractQueryPager
 {
-    private static final Logger logger = LoggerFactory.getLogger(RangeSliceQueryPager.class);
+    private static final Logger logger = LoggerFactory.getLogger(PartitionRangeQueryPager.class);
 
     private volatile DecoratedKey lastReturnedKey;
     private volatile PagingState.RowMark lastReturnedRow;
 
-    public RangeSliceQueryPager(PartitionRangeReadCommand command, PagingState state, int protocolVersion)
+    public PartitionRangeQueryPager(PartitionRangeReadCommand command, PagingState state, int protocolVersion)
     {
         super(command, protocolVersion);
-        assert !command.isNamesQuery();
 
         if (state != null)
         {
diff --git a/src/java/org/apache/cassandra/service/pager/RangeNamesQueryPager.java b/src/java/org/apache/cassandra/service/pager/RangeNamesQueryPager.java
deleted file mode 100644
index 9801565912..0000000000
--- a/src/java/org/apache/cassandra/service/pager/RangeNamesQueryPager.java
+++ /dev/null
@@ -1,92 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.cassandra.service.pager;
-
-import org.apache.cassandra.db.*;
-import org.apache.cassandra.db.rows.*;
-import org.apache.cassandra.dht.*;
-import org.apache.cassandra.exceptions.RequestExecutionException;
-
-/**
- * Pages a RangeSliceCommand whose predicate is a name query.
- *
- * Note: this only work for NamesQueryFilter that have countCQL3Rows() set,
- * because this assumes the pageSize is counted in number of internal rows
- * returned. More precisely, this doesn't do in-row paging so this assumes
- * that the counter returned by columnCounter() will count 1 for each internal
- * row.
- */
-public class RangeNamesQueryPager extends AbstractQueryPager
-{
-    private volatile DecoratedKey lastReturnedKey;
-
-    public RangeNamesQueryPager(PartitionRangeReadCommand command, PagingState state, int protocolVersion)
-    {
-        super(command, protocolVersion);
-        assert command.isNamesQuery();
-
-        if (state != null)
-        {
-            lastReturnedKey = command.metadata().decorateKey(state.partitionKey);
-            restoreState(lastReturnedKey, state.remaining, state.remainingInPartition);
-        }
-    }
-
-    public PagingState state()
-    {
-        return lastReturnedKey == null
-             ? null
-             : new PagingState(lastReturnedKey.getKey(), null, maxRemaining(), remainingInPartition());
-    }
-
-    protected ReadCommand nextPageReadCommand(int pageSize)
-    throws RequestExecutionException
-    {
-        PartitionRangeReadCommand pageCmd = ((PartitionRangeReadCommand)command).withUpdatedLimit(command.limits().forPaging(pageSize));
-        if (lastReturnedKey != null)
-            pageCmd = pageCmd.forSubRange(makeExcludingKeyBounds(lastReturnedKey));
-
-        return pageCmd;
-    }
-
-    protected void recordLast(DecoratedKey key, Row last)
-    {
-        lastReturnedKey = key;
-    }
-
-    protected boolean isPreviouslyReturnedPartition(DecoratedKey key)
-    {
-        // Note that lastReturnedKey can be null, but key cannot.
-        return key.equals(lastReturnedKey);
-    }
-
-    private AbstractBounds<PartitionPosition> makeExcludingKeyBounds(PartitionPosition lastReturnedKey)
-    {
-        // We return a range that always exclude lastReturnedKey, since we've already
-        // returned it.
-        AbstractBounds<PartitionPosition> bounds = ((PartitionRangeReadCommand)command).dataRange().keyRange();
-        if (bounds instanceof Range || bounds instanceof Bounds)
-        {
-            return new Range<PartitionPosition>(lastReturnedKey, bounds.right);
-        }
-        else
-        {
-            return new ExcludingBounds<PartitionPosition>(lastReturnedKey, bounds.right);
-        }
-    }
-}
