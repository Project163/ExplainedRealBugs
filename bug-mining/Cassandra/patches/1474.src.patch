diff --git a/CHANGES.txt b/CHANGES.txt
index 6786c9d9b6..069c1e335f 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,3 +1,8 @@
+1.1-dev
+ * avoid unproductive deserializing of cached rows during compaction
+   (CASSANDRA-3921)
+
+
 1.1-beta1
  * add nodetool rebuild_index (CASSANDRA-3583)
  * add nodetool rangekeysample (CASSANDRA-2917)
diff --git a/src/java/org/apache/cassandra/db/compaction/CompactionController.java b/src/java/org/apache/cassandra/db/compaction/CompactionController.java
index 4d1e36fddf..7db5723a19 100644
--- a/src/java/org/apache/cassandra/db/compaction/CompactionController.java
+++ b/src/java/org/apache/cassandra/db/compaction/CompactionController.java
@@ -31,6 +31,7 @@ import org.apache.cassandra.db.DecoratedKey;
 import org.apache.cassandra.db.EchoedRow;
 import org.apache.cassandra.io.sstable.SSTableIdentityIterator;
 import org.apache.cassandra.io.sstable.SSTableReader;
+import org.apache.cassandra.service.CacheService;
 
 /**
  * Manage compaction options.
@@ -100,6 +101,13 @@ public class CompactionController
 
     public void removeDeletedInCache(DecoratedKey key)
     {
+        // For the copying cache, we'd need to re-serialize the updated cachedRow, which would be racy
+        // vs other updates.  We'll just ignore it instead, since the next update to this row will invalidate it
+        // anyway, so the odds of a "tombstones consuming memory indefinitely" problem are minimal.
+        // See https://issues.apache.org/jira/browse/CASSANDRA-3921 for more discussion.
+        if (CacheService.instance.rowCache.isPutCopying())
+            return;
+
         ColumnFamily cachedRow = cfs.getRawCachedRow(key);
         if (cachedRow != null)
             ColumnFamilyStore.removeDeleted(cachedRow, gcBefore);
