diff --git a/CHANGES.txt b/CHANGES.txt
index fb95e14112..f67f0c2671 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -45,7 +45,9 @@
  * Add alias support to SELECT statement (CASSANDRA-5075)
  * Don't create empty RowMutations in CommitLogReplayer (CASSANDRA-5541)
 
+
 1.2.5
+ * Ensure that submitBackground enqueues at least one task (CASSANDRA-5554)
  * fix 2i updates with identical values and timestamps (CASSANDRA-5540)
  * fix compaction throttling bursty-ness (CASSANDRA-4316)
  * reduce memory consumption of IndexSummary (CASSANDRA-5506)
diff --git a/src/java/org/apache/cassandra/db/compaction/CompactionManager.java b/src/java/org/apache/cassandra/db/compaction/CompactionManager.java
index 758068c62d..e0d186f954 100644
--- a/src/java/org/apache/cassandra/db/compaction/CompactionManager.java
+++ b/src/java/org/apache/cassandra/db/compaction/CompactionManager.java
@@ -122,8 +122,8 @@ public class CompactionManager implements CompactionManagerMBean
 
     /**
      * Call this whenever a compaction might be needed on the given columnfamily.
-     * It's okay to over-call (within reason) since the compactions are single-threaded,
-     * and if a call is unnecessary, it will just be no-oped in the bucketing phase.
+     * It's okay to over-call (within reason) if a call is unnecessary, it will
+     * turn into a no-op in the bucketing/candidate-scan phase.
      */
     public List<Future<?>> submitBackground(final ColumnFamilyStore cfs)
     {
@@ -146,12 +146,14 @@ public class CompactionManager implements CompactionManagerMBean
                      cfs.name,
                      cfs.getCompactionStrategy().getClass().getSimpleName());
         List<Future<?>> futures = new ArrayList<Future<?>>();
-        // if we have room for more compactions, then fill up executor
-        while (executor.getActiveCount() + futures.size() < executor.getMaximumPoolSize())
-        {
+
+        // we must schedule it at least once, otherwise compaction will stop for a CF until next flush
+        do {
             futures.add(executor.submit(new BackgroundCompactionTask(cfs)));
             compactingCF.add(cfs);
-        }
+            // if we have room for more compactions, then fill up executor
+        } while (executor.getActiveCount() + futures.size() < executor.getMaximumPoolSize());
+
         return futures;
     }
 
@@ -490,7 +492,6 @@ public class CompactionManager implements CompactionManagerMBean
                 throw new IOException("disk full");
 
             SSTableScanner scanner = sstable.getScanner(getRateLimiter());
-            long rowsRead = 0;
             List<Column> indexedColumnsInRow = null;
 
             CleanupInfo ci = new CleanupInfo(sstable, scanner);
