diff --git a/CHANGES.txt b/CHANGES.txt
index 5e87435c5d..58dbc7b542 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -6,6 +6,7 @@
  * Don't expire columns sooner than they should in 2ndary indexes (CASSANDRA-5079)
  * Pig: correctly decode row keys in widerow mode (CASSANDRA-5098)
  * nodetool repair command now prints progress (CASSANDRA-4767)
+ * fix user defined compaction to run against 1.1 data directory (CASSANDRA-5118)
 
 
 1.1.8
diff --git a/src/java/org/apache/cassandra/db/compaction/CompactionManager.java b/src/java/org/apache/cassandra/db/compaction/CompactionManager.java
index 40e01caf7d..b6f96b62f2 100644
--- a/src/java/org/apache/cassandra/db/compaction/CompactionManager.java
+++ b/src/java/org/apache/cassandra/db/compaction/CompactionManager.java
@@ -323,27 +323,32 @@ public class CompactionManager implements CompactionManagerMBean
         if (!Schema.instance.getTables().contains(ksname))
             throw new IllegalArgumentException("Unknown keyspace " + ksname);
 
-        File directory = new File(ksname);
         String[] filenames = dataFiles.split(",");
         Collection<Descriptor> descriptors = new ArrayList<Descriptor>(filenames.length);
 
         String cfname = null;
         for (String filename : filenames)
         {
-            Pair<Descriptor, String> p = Descriptor.fromFilename(directory, filename.trim());
-            if (!p.right.equals(Component.DATA.name()))
+            // extract keyspace and columnfamily name from filename
+            Descriptor desc = Descriptor.fromFilename(filename.trim());
+            if (!desc.ksname.equals(ksname))
             {
-                throw new IllegalArgumentException(filename + " does not appear to be a data file");
+                throw new IllegalArgumentException("Given keyspace " + ksname + " does not match with file " + filename);
             }
             if (cfname == null)
             {
-                cfname = p.left.cfname;
+                cfname = desc.cfname;
             }
-            else if (!cfname.equals(p.left.cfname))
+            else if (!cfname.equals(desc.cfname))
             {
                 throw new IllegalArgumentException("All provided sstables should be for the same column family");
             }
-
+            File directory = new File(ksname + File.separator + cfname);
+            Pair<Descriptor, String> p = Descriptor.fromFilename(directory, filename.trim());
+            if (!p.right.equals(Component.DATA.name()))
+            {
+                throw new IllegalArgumentException(filename + " does not appear to be a data file");
+            }
             descriptors.add(p.left);
         }
 
diff --git a/test/unit/org/apache/cassandra/db/compaction/CompactionsTest.java b/test/unit/org/apache/cassandra/db/compaction/CompactionsTest.java
index 55616a23b5..c73935a65f 100644
--- a/test/unit/org/apache/cassandra/db/compaction/CompactionsTest.java
+++ b/test/unit/org/apache/cassandra/db/compaction/CompactionsTest.java
@@ -279,6 +279,46 @@ public class CompactionsTest extends SchemaLoader
         testDontPurgeAccidentaly("test2", "SuperDirectGC", true);
     }
 
+    @Test
+    public void testUserDefinedCompaction() throws Exception
+    {
+        Table table = Table.open(TABLE1);
+        final String cfname = "Standard3"; // use clean(no sstable) CF
+        ColumnFamilyStore cfs = table.getColumnFamilyStore(cfname);
+
+        // disable compaction while flushing
+        cfs.disableAutoCompaction();
+
+        final int ROWS_PER_SSTABLE = 10;
+        for (int i = 0; i < ROWS_PER_SSTABLE; i++) {
+            DecoratedKey key = Util.dk(String.valueOf(i));
+            RowMutation rm = new RowMutation(TABLE1, key.key);
+            rm.add(new QueryPath(cfname, null, ByteBufferUtil.bytes("col")),
+                   ByteBufferUtil.EMPTY_BYTE_BUFFER,
+                   System.currentTimeMillis());
+            rm.apply();
+        }
+        cfs.forceBlockingFlush();
+        Collection<SSTableReader> sstables = cfs.getSSTables();
+
+        assert sstables.size() == 1;
+        SSTableReader sstable = sstables.iterator().next();
+
+        int prevGeneration = sstable.descriptor.generation;
+        String file = new File(sstable.descriptor.filenameFor(Component.DATA)).getName();
+        // submit user defined compaction on flushed sstable
+        CompactionManager.instance.forceUserDefinedCompaction(TABLE1, file);
+        // wait until user defined compaction finishes
+        do
+        {
+            Thread.sleep(100);
+        } while (CompactionManager.instance.getPendingTasks() > 0 || CompactionManager.instance.getActiveCompactions() > 0);
+        // CF should have only one sstable with generation number advanced
+        sstables = cfs.getSSTables();
+        assert sstables.size() == 1;
+        assert sstables.iterator().next().descriptor.generation == prevGeneration + 1;
+    }
+
     private void testDontPurgeAccidentaly(String k, String cfname, boolean forceDeserialize) throws IOException, ExecutionException, InterruptedException
     {
         // This test catches the regression of CASSANDRA-2786
