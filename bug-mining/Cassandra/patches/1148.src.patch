diff --git a/CHANGES.txt b/CHANGES.txt
index b0d26daba8..e86995c8cf 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 1.0.0-rc1
+ * Update CQL to generate microsecond timestamps by default (CASSANDRA-3227)
  * Fix counting CFMetadata towards Memtable liveRatio (CASSANDRA-3023)
  * Kill server on wrapped OOME such as from FileChannel.map (CASSANDRA-3201)
  * remove unnecessary copy when adding to row cache (CASSANDRA-3223)
diff --git a/NEWS.txt b/NEWS.txt
index 98e2b2b703..93ef34b147 100644
--- a/NEWS.txt
+++ b/NEWS.txt
@@ -3,6 +3,13 @@
 
 Upgrading
 ---------
+    - CQL inserts/updates now generate microsecond resolution timestamps
+      by default, instead of millisecond. THIS MEANS A ROLLING UPGRADE COULD
+      MIX milliseconds and microseconds, with clients talking to servers
+      generating milliseconds unable to overwrite the larger microsecond
+      timestamps. If this is important for your application, you can either
+      perform a non-rolling upgrade to 1.0, or update your application first
+      to use explicit timestamps with the "USING timestamp=X" syntax.
     - the BinaryMemtable bulk-load interface has been removed. Use the
       sstableloader tool instead.
     - the compaction_thread_priority setting has been removed from 
diff --git a/doc/cql/CQL.textile b/doc/cql/CQL.textile
index a5135937aa..9b90edc996 100644
--- a/doc/cql/CQL.textile
+++ b/doc/cql/CQL.textile
@@ -96,6 +96,8 @@ INSERT INTO <COLUMN FAMILY> (<KEY>, <col>, <col>, ...) VALUES (<key>, <val>, <va
 
 An @INSERT@ is used to write one or more columns to a record in a Cassandra column family. No results are returned. 
 
+If timestamp is unspecified, the server will generate a timestamp based on microseconds since 1970.
+
 Unlike SQL, the semantics of @INSERT@ and @UPDATE@ are identical, in either case a record is created if none existed before, and updated when it does.  For information on modifiers and types, see the "@UPDATE@":#update section below.
 
 h2(#update). UPDATE
diff --git a/src/java/org/apache/cassandra/cql/AbstractModification.java b/src/java/org/apache/cassandra/cql/AbstractModification.java
index e60beda961..d5503c1606 100644
--- a/src/java/org/apache/cassandra/cql/AbstractModification.java
+++ b/src/java/org/apache/cassandra/cql/AbstractModification.java
@@ -71,9 +71,9 @@ public abstract class AbstractModification
         return cLevel != null;
     }
 
-    public long getTimestamp()
+    public long getTimestamp(ClientState clientState)
     {
-        return timestamp == null ? System.currentTimeMillis() : timestamp;
+        return timestamp == null ? clientState.getTimestamp() : timestamp;
     }
 
     public boolean isSetTimestamp()
diff --git a/src/java/org/apache/cassandra/cql/DeleteStatement.java b/src/java/org/apache/cassandra/cql/DeleteStatement.java
index eea36ed97e..630a242054 100644
--- a/src/java/org/apache/cassandra/cql/DeleteStatement.java
+++ b/src/java/org/apache/cassandra/cql/DeleteStatement.java
@@ -81,41 +81,39 @@ public class DeleteStatement extends AbstractModification
 
         for (Term key : keys)
         {
-            rowMutations.add(mutationForKey(key.getByteBuffer(keyType), keyspace, timestamp));
+            rowMutations.add(mutationForKey(key.getByteBuffer(keyType), keyspace, timestamp, clientState));
         }
 
         return rowMutations;
     }
 
     /** {@inheritDoc} */
-    public RowMutation mutationForKey(ByteBuffer key, String keyspace, Long timestamp) throws InvalidRequestException
+    public RowMutation mutationForKey(ByteBuffer key, String keyspace, Long timestamp, ClientState clientState) throws InvalidRequestException
     {
         RowMutation rm = new RowMutation(keyspace, key);
 
-        mutationForKey(rm, keyspace, timestamp);
-
-        return rm;
-    }
-
-    /** {@inheritDoc} */
-    public void mutationForKey(RowMutation mutation, String keyspace, Long timestamp) throws InvalidRequestException
-    {
         CFMetaData metadata = validateColumnFamily(keyspace, columnFamily);
         QueryProcessor.validateKeyAlias(metadata, keyName);
 
         AbstractType comparator = metadata.getComparatorFor(null);
 
-        if (columns.size() < 1) // No columns, delete the row
-            mutation.delete(new QueryPath(columnFamily), (timestamp == null) ? getTimestamp() : timestamp);
-        else    // Delete specific columns
+        if (columns.size() < 1)
+        {
+            // No columns, delete the row
+            rm.delete(new QueryPath(columnFamily), (timestamp == null) ? getTimestamp(clientState) : timestamp);
+        }
+        else
         {
+            // Delete specific columns
             for (Term column : columns)
             {
                 ByteBuffer columnName = column.getByteBuffer(comparator);
                 validateColumnName(columnName);
-                mutation.delete(new QueryPath(columnFamily, null, columnName), (timestamp == null) ? getTimestamp() : timestamp);
+                rm.delete(new QueryPath(columnFamily, null, columnName), (timestamp == null) ? getTimestamp(clientState) : timestamp);
             }
         }
+
+        return rm;
     }
 
     public String toString()
diff --git a/src/java/org/apache/cassandra/cql/UpdateStatement.java b/src/java/org/apache/cassandra/cql/UpdateStatement.java
index db3676aaa2..90428be8a8 100644
--- a/src/java/org/apache/cassandra/cql/UpdateStatement.java
+++ b/src/java/org/apache/cassandra/cql/UpdateStatement.java
@@ -159,7 +159,7 @@ public class UpdateStatement extends AbstractModification
 
         for (Term key: keys)
         {
-            rowMutations.add(mutationForKey(keyspace, key.getByteBuffer(getKeyType(keyspace)), metadata, timestamp));
+            rowMutations.add(mutationForKey(keyspace, key.getByteBuffer(getKeyType(keyspace)), metadata, timestamp, clientState));
         }
 
         return rowMutations;
@@ -168,16 +168,18 @@ public class UpdateStatement extends AbstractModification
     /**
      * Compute a row mutation for a single key
      *
+     *
      * @param keyspace working keyspace
      * @param key key to change
      * @param metadata information about CF
      * @param timestamp global timestamp to use for every key mutation
      *
+     * @param clientState
      * @return row mutation
      *
      * @throws InvalidRequestException on the wrong request
      */
-    private IMutation mutationForKey(String keyspace, ByteBuffer key, CFMetaData metadata, Long timestamp) throws InvalidRequestException
+    private IMutation mutationForKey(String keyspace, ByteBuffer key, CFMetaData metadata, Long timestamp, ClientState clientState) throws InvalidRequestException
     {
         AbstractType<?> comparator = getComparator(keyspace);
 
@@ -200,7 +202,7 @@ public class UpdateStatement extends AbstractModification
                 validateColumn(metadata, colName, colValue);
                 rm.add(new QueryPath(columnFamily, null, colName),
                        colValue,
-                       (timestamp == null) ? getTimestamp() : timestamp,
+                       (timestamp == null) ? getTimestamp(clientState) : timestamp,
                        getTimeToLive());
             }
             else
diff --git a/src/java/org/apache/cassandra/service/ClientState.java b/src/java/org/apache/cassandra/service/ClientState.java
index 7c095c28be..97493d8548 100644
--- a/src/java/org/apache/cassandra/service/ClientState.java
+++ b/src/java/org/apache/cassandra/service/ClientState.java
@@ -48,6 +48,8 @@ public class ClientState
     // Reusable array for authorization
     private final List<Object> resource = new ArrayList<Object>();
 
+    private long clock;
+
     /**
      * Construct a new, empty ClientState: can be reused after logout() or reset().
      */
@@ -180,4 +182,16 @@ public class ClientState
                                                         perm,
                                                         Resources.toString(resource)));
     }
+
+    /**
+     * This clock guarantees that updates from a given client will be ordered in the sequence seen,
+     * even if multiple updates happen in the same millisecond.  This can be useful when a client
+     * wants to perform multiple updates to a single column.
+     */
+    public long getTimestamp()
+    {
+        long current = System.currentTimeMillis() * 1000;
+        clock = clock >= current ? clock + 1 : current;
+        return clock;
+    }
 }
