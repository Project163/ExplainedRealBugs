diff --git a/CHANGES.txt b/CHANGES.txt
index 376b556354..7342354997 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -23,6 +23,8 @@ dev
  * close file handle used for post-flush truncate (CASSANDRA-1790)
  * various code cleanup (CASSANDRA-1793, -1794, -1795)
  * fix range queries against wrapped range (CASSANDRA-1781)
+ * fix consistencylevel calculations for NetworkTopologyStrategy
+   (CASSANDRA-1804)
 
 
 0.7.0-rc1
diff --git a/src/java/org/apache/cassandra/config/DatabaseDescriptor.java b/src/java/org/apache/cassandra/config/DatabaseDescriptor.java
index 0cae7d73e9..ab0415d112 100644
--- a/src/java/org/apache/cassandra/config/DatabaseDescriptor.java
+++ b/src/java/org/apache/cassandra/config/DatabaseDescriptor.java
@@ -815,11 +815,6 @@ public class    DatabaseDescriptor
         return conf.rpc_port;
     }
 
-    public static int getReplicationFactor(String table)
-    {
-        return tables.get(table).replicationFactor;
-    }
-
     public static long getRpcTimeout()
     {
         return conf.rpc_timeout_in_ms;
diff --git a/src/java/org/apache/cassandra/locator/AbstractReplicationStrategy.java b/src/java/org/apache/cassandra/locator/AbstractReplicationStrategy.java
index 9ec15c114b..1f997cbafc 100644
--- a/src/java/org/apache/cassandra/locator/AbstractReplicationStrategy.java
+++ b/src/java/org/apache/cassandra/locator/AbstractReplicationStrategy.java
@@ -125,10 +125,9 @@ public abstract class AbstractReplicationStrategy
         return WriteResponseHandler.create(writeEndpoints, hintedEndpoints, consistencyLevel, table);
     }
 
-    // instance method so test subclasses can override it
-    int getReplicationFactor()
+    public int getReplicationFactor()
     {
-       return DatabaseDescriptor.getReplicationFactor(table);
+        return DatabaseDescriptor.getTableDefinition(table).replicationFactor;
     }
 
     /**
diff --git a/src/java/org/apache/cassandra/service/QuorumResponseHandler.java b/src/java/org/apache/cassandra/service/QuorumResponseHandler.java
index c21aac2e42..a703e05718 100644
--- a/src/java/org/apache/cassandra/service/QuorumResponseHandler.java
+++ b/src/java/org/apache/cassandra/service/QuorumResponseHandler.java
@@ -25,6 +25,7 @@ import java.util.concurrent.TimeoutException;
 import java.io.IOException;
 
 import org.apache.cassandra.config.DatabaseDescriptor;
+import org.apache.cassandra.db.Table;
 import org.apache.cassandra.net.IAsyncCallback;
 import org.apache.cassandra.net.Message;
 import org.apache.cassandra.net.MessagingService;
@@ -110,9 +111,9 @@ public class QuorumResponseHandler<T> implements IAsyncCallback
             case ANY:
                 return 1;
             case QUORUM:
-                return (DatabaseDescriptor.getReplicationFactor(table) / 2) + 1;
+                return (Table.open(table).getReplicationStrategy().getReplicationFactor() / 2) + 1;
             case ALL:
-                return DatabaseDescriptor.getReplicationFactor(table);
+                return Table.open(table).getReplicationStrategy().getReplicationFactor();
             default:
                 throw new UnsupportedOperationException("invalid consistency level: " + table.toString());
         }
diff --git a/src/java/org/apache/cassandra/service/StorageService.java b/src/java/org/apache/cassandra/service/StorageService.java
index 7471aaf55d..2bb83f9838 100644
--- a/src/java/org/apache/cassandra/service/StorageService.java
+++ b/src/java/org/apache/cassandra/service/StorageService.java
@@ -1738,7 +1738,7 @@ public class StorageService implements IEndpointStateChangeSubscriber, StorageSe
         for (String table : DatabaseDescriptor.getNonSystemTables())
         {
             // if the replication factor is 1 the data is lost so we shouldn't wait for confirmation
-            if (DatabaseDescriptor.getReplicationFactor(table) == 1)
+            if (Table.open(table).getReplicationStrategy().getReplicationFactor() == 1)
                 continue;
 
             // get all ranges that change ownership (that is, a node needs
diff --git a/src/java/org/apache/cassandra/service/WriteResponseHandler.java b/src/java/org/apache/cassandra/service/WriteResponseHandler.java
index 3ea15c97f4..95e5e3f362 100644
--- a/src/java/org/apache/cassandra/service/WriteResponseHandler.java
+++ b/src/java/org/apache/cassandra/service/WriteResponseHandler.java
@@ -26,6 +26,7 @@ import java.util.concurrent.atomic.AtomicInteger;
 import com.google.common.collect.ImmutableMultimap;
 import com.google.common.collect.Multimap;
 import org.apache.cassandra.config.DatabaseDescriptor;
+import org.apache.cassandra.db.Table;
 import org.apache.cassandra.net.Message;
 import org.apache.cassandra.thrift.ConsistencyLevel;
 import org.apache.cassandra.thrift.UnavailableException;
@@ -93,9 +94,9 @@ public class WriteResponseHandler extends AbstractWriteResponseHandler
         }
         // at most one node per range can bootstrap at a time, and these will be added to the write until
         // bootstrap finishes (at which point we no longer need to write to the old ones).
-        assert 1 <= blockFor && blockFor <= 2 * DatabaseDescriptor.getReplicationFactor(table)
+        assert 1 <= blockFor && blockFor <= 2 * Table.open(table).getReplicationStrategy().getReplicationFactor()
             : String.format("invalid response count %d for replication factor %d",
-                            blockFor, DatabaseDescriptor.getReplicationFactor(table));
+                            blockFor, Table.open(table).getReplicationStrategy().getReplicationFactor());
         return blockFor;
     }
 
diff --git a/test/unit/org/apache/cassandra/dht/BootStrapperTest.java b/test/unit/org/apache/cassandra/dht/BootStrapperTest.java
index 7fc460203a..d42e87c270 100644
--- a/test/unit/org/apache/cassandra/dht/BootStrapperTest.java
+++ b/test/unit/org/apache/cassandra/dht/BootStrapperTest.java
@@ -33,6 +33,7 @@ import org.junit.Test;
 
 import com.google.common.collect.Multimap;
 
+import org.apache.cassandra.db.Table;
 import org.apache.cassandra.gms.ApplicationState;
 import org.apache.cassandra.gms.IFailureDetectionEventListener;
 import org.apache.cassandra.gms.IFailureDetector;
@@ -146,7 +147,7 @@ public class BootStrapperTest extends CleanupHelper
         final int[] clusterSizes = new int[] { 1, 3, 5, 10, 100};
         for (String table : DatabaseDescriptor.getNonSystemTables())
         {
-            int replicationFactor = DatabaseDescriptor.getReplicationFactor(table);
+            int replicationFactor = Table.open(table).getReplicationStrategy().getReplicationFactor();
             for (int clusterSize : clusterSizes)
                 if (clusterSize >= replicationFactor)
                     testSourceTargetComputation(table, clusterSize, replicationFactor);
diff --git a/test/unit/org/apache/cassandra/locator/OldNetworkTopologyStrategyTest.java b/test/unit/org/apache/cassandra/locator/OldNetworkTopologyStrategyTest.java
index c42d7c3e2c..288491d3a8 100644
--- a/test/unit/org/apache/cassandra/locator/OldNetworkTopologyStrategyTest.java
+++ b/test/unit/org/apache/cassandra/locator/OldNetworkTopologyStrategyTest.java
@@ -30,11 +30,12 @@ import org.junit.Before;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
-import org.apache.cassandra.config.DatabaseDescriptor;
+
+import org.apache.cassandra.SchemaLoader;
 import org.apache.cassandra.dht.BigIntegerToken;
 import org.apache.cassandra.dht.Token;
 
-public class OldNetworkTopologyStrategyTest
+public class OldNetworkTopologyStrategyTest extends SchemaLoader
 {
     private List<Token> endpointTokens;
     private List<Token> keyTokens;
@@ -71,7 +72,7 @@ public class OldNetworkTopologyStrategyTest
         expectedResults.put("25", buildResult("254.0.0.4", "254.0.0.1", "254.0.0.2"));
         expectedResults.put("35", buildResult("254.0.0.1", "254.0.0.2", "254.0.0.3"));
 
-        runTestForReplicatedTables(strategy);
+        testGetEndpoints(strategy, keyTokens.toArray(new Token[0]));
     }
 
     /**
@@ -96,7 +97,7 @@ public class OldNetworkTopologyStrategyTest
         expectedResults.put("25", buildResult("254.0.0.4", "254.1.0.3", "254.0.0.1"));
         expectedResults.put("35", buildResult("254.0.0.1", "254.1.0.3", "254.0.0.2"));
 
-        runTestForReplicatedTables(strategy);
+        testGetEndpoints(strategy, keyTokens.toArray(new Token[0]));
     }
 
     /**
@@ -122,16 +123,7 @@ public class OldNetworkTopologyStrategyTest
         expectedResults.put("25", buildResult("254.1.0.4", "254.0.0.1", "254.0.0.2"));
         expectedResults.put("35", buildResult("254.0.0.1", "254.0.1.3", "254.1.0.4"));
 
-        runTestForReplicatedTables(strategy);
-    }
-
-    private void runTestForReplicatedTables(AbstractReplicationStrategy strategy) throws UnknownHostException
-    {
-        for (String table : DatabaseDescriptor.getNonSystemTables())
-        {
-            if (DatabaseDescriptor.getReplicationFactor(table) == 3)
-                testGetEndpoints(strategy, keyTokens.toArray(new Token[0]), table);
-        }
+        testGetEndpoints(strategy, keyTokens.toArray(new Token[0]));
     }
 
     private ArrayList<InetAddress> buildResult(String... addresses) throws UnknownHostException
@@ -156,7 +148,7 @@ public class OldNetworkTopologyStrategyTest
         tmd.updateNormalToken(endpointToken, ep);
     }
 
-    private void testGetEndpoints(AbstractReplicationStrategy strategy, Token[] keyTokens, String table) throws UnknownHostException
+    private void testGetEndpoints(AbstractReplicationStrategy strategy, Token[] keyTokens) throws UnknownHostException
     {
         for (Token keyToken : keyTokens)
         {
diff --git a/test/unit/org/apache/cassandra/locator/SimpleStrategyTest.java b/test/unit/org/apache/cassandra/locator/SimpleStrategyTest.java
index f53680c783..56d7089ac4 100644
--- a/test/unit/org/apache/cassandra/locator/SimpleStrategyTest.java
+++ b/test/unit/org/apache/cassandra/locator/SimpleStrategyTest.java
@@ -94,7 +94,7 @@ public class SimpleStrategyTest extends CleanupHelper
             for (int i = 0; i < keyTokens.length; i++)
             {
                 List<InetAddress> endpoints = strategy.getNaturalEndpoints(keyTokens[i]);
-                assertEquals(DatabaseDescriptor.getReplicationFactor(table), endpoints.size());
+                assertEquals(strategy.getReplicationFactor(), endpoints.size());
                 List<InetAddress> correctEndpoints = new ArrayList<InetAddress>();
                 for (int j = 0; j < endpoints.size(); j++)
                     correctEndpoints.add(hosts.get((i + j + 1) % hosts.size()));
@@ -140,7 +140,7 @@ public class SimpleStrategyTest extends CleanupHelper
 
             StorageService.calculatePendingRanges(strategy, table);
 
-            int replicationFactor = DatabaseDescriptor.getReplicationFactor(table);
+            int replicationFactor = strategy.getReplicationFactor();
 
             for (int i = 0; i < keyTokens.length; i++)
             {
diff --git a/test/unit/org/apache/cassandra/service/AntiEntropyServiceTest.java b/test/unit/org/apache/cassandra/service/AntiEntropyServiceTest.java
index ccbdcc0157..7402233469 100644
--- a/test/unit/org/apache/cassandra/service/AntiEntropyServiceTest.java
+++ b/test/unit/org/apache/cassandra/service/AntiEntropyServiceTest.java
@@ -171,7 +171,7 @@ public class AntiEntropyServiceTest extends CleanupHelper
     public void testGetNeighborsPlusOne() throws Throwable
     {
         // generate rf+1 nodes, and ensure that all nodes are returned
-        Set<InetAddress> expected = addTokens(1 + DatabaseDescriptor.getReplicationFactor(tablename));
+        Set<InetAddress> expected = addTokens(1 + Table.open(tablename).getReplicationStrategy().getReplicationFactor());
         expected.remove(FBUtilities.getLocalAddress());
         assertEquals(expected, AntiEntropyService.getNeighbors(tablename));
     }
@@ -182,7 +182,7 @@ public class AntiEntropyServiceTest extends CleanupHelper
         TokenMetadata tmd = StorageService.instance.getTokenMetadata();
 
         // generate rf*2 nodes, and ensure that only neighbors specified by the ARS are returned
-        addTokens(2 * DatabaseDescriptor.getReplicationFactor(tablename));
+        addTokens(2 * Table.open(tablename).getReplicationStrategy().getReplicationFactor());
         AbstractReplicationStrategy ars = Table.open(tablename).getReplicationStrategy();
         Set<InetAddress> expected = new HashSet<InetAddress>();
         for (Range replicaRange : ars.getAddressRanges().get(FBUtilities.getLocalAddress()))
diff --git a/test/unit/org/apache/cassandra/service/MoveTest.java b/test/unit/org/apache/cassandra/service/MoveTest.java
index ba75a22d93..90b80ef7c3 100644
--- a/test/unit/org/apache/cassandra/service/MoveTest.java
+++ b/test/unit/org/apache/cassandra/service/MoveTest.java
@@ -92,7 +92,7 @@ public class MoveTest extends CleanupHelper
             strategy = getStrategy(table, tmd);
             for (Token token : keyTokens)
             {
-                int replicationFactor = DatabaseDescriptor.getReplicationFactor(table);
+                int replicationFactor = strategy.getReplicationFactor();
 
                 HashSet<InetAddress> actual = new HashSet<InetAddress>(tmd.getWriteEndpoints(token, table, strategy.calculateNaturalEndpoints(token, tmd)));
                 HashSet<InetAddress> expected = new HashSet<InetAddress>();
@@ -217,7 +217,7 @@ public class MoveTest extends CleanupHelper
             }
 
             // just to be sure that things still work according to the old tests, run them:
-            if (DatabaseDescriptor.getReplicationFactor(table) != 3)
+            if (strategy.getReplicationFactor() != 3)
                 continue;
             // tokens 5, 15 and 25 should go three nodes
             for (int i=0; i<3; ++i)
@@ -334,7 +334,7 @@ public class MoveTest extends CleanupHelper
                 assertTrue(expectedEndpoints.get(table).get(keyTokens.get(i)).containsAll(endpoints));
             }
 
-            if (DatabaseDescriptor.getReplicationFactor(table) != 3)
+            if (strategy.getReplicationFactor() != 3)
                 continue;
             // leave this stuff in to guarantee the old tests work the way they were supposed to.
             // tokens 5, 15 and 25 should go three nodes
