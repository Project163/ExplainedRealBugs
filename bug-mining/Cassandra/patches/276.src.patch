diff --git a/src/java/org/apache/cassandra/db/ColumnFamilyStore.java b/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
index d0e2ef7faf..0bef41f8bd 100644
--- a/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
+++ b/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
@@ -1144,24 +1144,19 @@ public class ColumnFamilyStore implements ColumnFamilyStoreMBean
         }
     }
 
+    public boolean hasUnreclaimedSpace()
+    {
+        return ssTables_.getLiveSize() < ssTables_.getTotalSize();
+    }
+
     public long getTotalDiskSpaceUsed()
     {
-        long n = 0;
-        for (File file : files())
-        {
-            n += file.length();
-        }
-        return n;
+        return ssTables_.getTotalSize();
     }
 
     public long getLiveDiskSpaceUsed()
     {
-        long n = 0;
-        for (SSTableReader sstable : ssTables_)
-        {
-            n += sstable.bytesOnDisk();
-        }
-        return n;
+        return ssTables_.getLiveSize();
     }
 
     public int getLiveSSTableCount()
diff --git a/src/java/org/apache/cassandra/db/Table.java b/src/java/org/apache/cassandra/db/Table.java
index 0be0dbf2db..e8792a1c9a 100644
--- a/src/java/org/apache/cassandra/db/Table.java
+++ b/src/java/org/apache/cassandra/db/Table.java
@@ -208,7 +208,7 @@ public class Table
         return tableMetadata.getColumnFamilies();
     }
 
-    Collection<ColumnFamilyStore> getColumnFamilyStores()
+    public Collection<ColumnFamilyStore> getColumnFamilyStores()
     {
         return Collections.unmodifiableCollection(columnFamilyStores.values());
     }
@@ -479,7 +479,7 @@ public class Table
         if (path == null)
         {
             // retry after GCing to force unmap of compacted SSTables so they can be deleted
-            StorageService.requestGC();
+            StorageService.instance.requestGC();
             try
             {
                 Thread.sleep(SSTableDeletingReference.RETRY_DELAY * 2);
diff --git a/src/java/org/apache/cassandra/io/SSTableDeletingReference.java b/src/java/org/apache/cassandra/io/SSTableDeletingReference.java
index b123161a5c..e8c7256808 100644
--- a/src/java/org/apache/cassandra/io/SSTableDeletingReference.java
+++ b/src/java/org/apache/cassandra/io/SSTableDeletingReference.java
@@ -1,6 +1,7 @@
 package org.apache.cassandra.io;
 
 import java.io.File;
+import java.io.IOError;
 import java.io.IOException;
 import java.lang.ref.PhantomReference;
 import java.lang.ref.ReferenceQueue;
@@ -9,6 +10,8 @@ import java.util.TimerTask;
 
 import org.apache.log4j.Logger;
 
+import org.apache.cassandra.io.util.FileUtils;
+
 public class SSTableDeletingReference extends PhantomReference<SSTableReader>
 {
     private static final Logger logger = Logger.getLogger(SSTableDeletingReference.class);
@@ -16,13 +19,17 @@ public class SSTableDeletingReference extends PhantomReference<SSTableReader>
     private static final Timer timer = new Timer("SSTABLE-CLEANUP-TIMER");
     public static final int RETRY_DELAY = 10000;
 
+    private final SSTableTracker tracker;
     public final String path;
+    private final long size;
     private boolean deleteOnCleanup;
 
-    SSTableDeletingReference(SSTableReader referent, ReferenceQueue<? super SSTableReader> q)
+    SSTableDeletingReference(SSTableTracker tracker, SSTableReader referent, ReferenceQueue<? super SSTableReader> q)
     {
         super(referent, q);
+        this.tracker = tracker;
         this.path = referent.path;
+        this.size = referent.bytesOnDisk();
     }
 
     public void deleteOnCleanup()
@@ -62,10 +69,18 @@ public class SSTableDeletingReference extends PhantomReference<SSTableReader>
                     throw new RuntimeException("Unable to delete " + path);
                 }
             }
+            try
+            {
+                FileUtils.deleteWithConfirm(new File(SSTable.indexFilename(path)));
+                FileUtils.deleteWithConfirm(new File(SSTable.filterFilename(path)));
+                FileUtils.deleteWithConfirm(new File(SSTable.compactedFilename(path)));
+            }
+            catch (IOException e)
+            {
+                throw new IOError(e);
+            }
+            tracker.spaceReclaimed(size);
             logger.info("Deleted " + path);
-            DeletionService.submitDeleteWithRetry(SSTable.indexFilename(path));
-            DeletionService.submitDeleteWithRetry(SSTable.filterFilename(path));
-            DeletionService.submitDeleteWithRetry(SSTable.compactedFilename(path));
         }
     }
 }
diff --git a/src/java/org/apache/cassandra/io/SSTableReader.java b/src/java/org/apache/cassandra/io/SSTableReader.java
index 01e8d07f06..179edf27fc 100644
--- a/src/java/org/apache/cassandra/io/SSTableReader.java
+++ b/src/java/org/apache/cassandra/io/SSTableReader.java
@@ -135,7 +135,7 @@ public class SSTableReader extends SSTable implements Comparable<SSTableReader>
         return sstable;
     }
 
-    SSTableDeletingReference phantomReference;
+    private volatile SSTableDeletingReference phantomReference;
     // jvm can only map up to 2GB at a time, so we split index/data into segments of that size when using mmap i/o
     private final MappedByteBuffer[] indexBuffers;
     private final MappedByteBuffer[] buffers;
@@ -196,11 +196,15 @@ public class SSTableReader extends SSTable implements Comparable<SSTableReader>
         this.indexPositions = indexPositions;
         this.spannedIndexDataPositions = spannedIndexDataPositions;
         this.bf = bloomFilter;
-        phantomReference = new SSTableDeletingReference(this, finalizerQueue);
-        finalizers.add(phantomReference);
         this.keyCache = keyCache;
     }
 
+    public void addFinalizingReference(SSTableTracker tracker)
+    {
+        phantomReference = new SSTableDeletingReference(tracker, this, finalizerQueue);
+        finalizers.add(phantomReference);
+    }
+
     private static MappedByteBuffer mmap(String filename, long start, int size) throws IOException
     {
         RandomAccessFile raf;
diff --git a/src/java/org/apache/cassandra/io/SSTableTracker.java b/src/java/org/apache/cassandra/io/SSTableTracker.java
index 1e3b861b96..7154e2fd5d 100644
--- a/src/java/org/apache/cassandra/io/SSTableTracker.java
+++ b/src/java/org/apache/cassandra/io/SSTableTracker.java
@@ -23,11 +23,14 @@ package org.apache.cassandra.io;
 
 import java.util.*;
 import java.io.IOException;
+import java.util.concurrent.atomic.AtomicLong;
 
 
 public class SSTableTracker implements Iterable<SSTableReader>
 {
     private volatile Set<SSTableReader> sstables;
+    private final AtomicLong liveSize = new AtomicLong();
+    private final AtomicLong totalSize = new AtomicLong();
 
     public SSTableTracker(Collection<SSTableReader> sstables)
     {
@@ -42,12 +45,17 @@ public class SSTableTracker implements Iterable<SSTableReader>
         {
             assert sstable.getIndexPositions() != null;
             sstablesNew.add(sstable);
+            long size = sstable.bytesOnDisk();
+            liveSize.addAndGet(size);
+            totalSize.addAndGet(size);
+            sstable.addFinalizingReference(this);
         }
 
         for (SSTableReader sstable : oldSSTables)
         {
             sstablesNew.remove(sstable);
             sstable.markCompacted();
+            liveSize.addAndGet(-sstable.bytesOnDisk());
         }
 
         sstables = Collections.unmodifiableSet(sstablesNew);
@@ -102,4 +110,20 @@ public class SSTableTracker implements Iterable<SSTableReader>
         }
         return n;
     }
+
+    public long getLiveSize()
+    {
+        return liveSize.get();
+    }
+
+    public long getTotalSize()
+    {
+        return totalSize.get();
+    }
+
+    public void spaceReclaimed(long size)
+    {
+        totalSize.addAndGet(-size);
+    }
 }
+
diff --git a/src/java/org/apache/cassandra/service/StorageService.java b/src/java/org/apache/cassandra/service/StorageService.java
index 4971133975..17826ceb53 100644
--- a/src/java/org/apache/cassandra/service/StorageService.java
+++ b/src/java/org/apache/cassandra/service/StorageService.java
@@ -1472,10 +1472,31 @@ public class StorageService implements IEndPointStateChangeSubscriber, StorageSe
         return isClientMode;
     }
 
-    public static void requestGC()
+    public synchronized void requestGC()
     {
-        logger_.info("requesting GC to free disk space");
-        System.gc();
+        if (hasUnreclaimedSpace())
+        {
+            logger_.info("requesting GC to free disk space");
+            System.gc();
+            try
+            {
+                Thread.sleep(1000);
+            }
+            catch (InterruptedException e)
+            {
+                throw new AssertionError(e);
+            }
+        }
+    }
+
+    private boolean hasUnreclaimedSpace()
+    {
+        for (ColumnFamilyStore cfs : ColumnFamilyStore.all())
+        {
+            if (cfs.hasUnreclaimedSpace())
+                return true;
+        }
+        return false;
     }
 
     // Never ever do this at home. Used by tests.
