diff --git a/CHANGES.txt b/CHANGES.txt
index 64cc60c5f7..2e8d2c9a51 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 1.2.1
+ * drain should flush system CFs too (CASSANDRA-4446)
  * add inter_dc_tcp_nodelay setting (CASSANDRA-5148)
  * re-allow wrapping ranges for start_token/end_token range pairing (CASSANDRA-5106)
  * fix validation compaction of empty rows (CASSADRA-5136)
diff --git a/src/java/org/apache/cassandra/db/Table.java b/src/java/org/apache/cassandra/db/Table.java
index bb5e6ee32d..d92308196a 100644
--- a/src/java/org/apache/cassandra/db/Table.java
+++ b/src/java/org/apache/cassandra/db/Table.java
@@ -75,6 +75,13 @@ public class Table
     private final ConcurrentMap<UUID, ColumnFamilyStore> columnFamilyStores = new ConcurrentHashMap<UUID, ColumnFamilyStore>();
     private final Object[] indexLocks;
     private volatile AbstractReplicationStrategy replicationStrategy;
+    public static final Function<String,Table> tableTransformer = new Function<String, Table>()
+    {
+        public Table apply(String tableName)
+        {
+            return Table.open(tableName);
+        }
+    };
 
     public static Table open(String table)
     {
@@ -456,14 +463,17 @@ public class Table
 
     public static Iterable<Table> all()
     {
-        Function<String, Table> transformer = new Function<String, Table>()
-        {
-            public Table apply(String tableName)
-            {
-                return Table.open(tableName);
-            }
-        };
-        return Iterables.transform(Schema.instance.getTables(), transformer);
+        return Iterables.transform(Schema.instance.getTables(), tableTransformer);
+    }
+
+    public static Iterable<Table> nonSystem()
+    {
+        return Iterables.transform(Schema.instance.getNonSystemTables(), tableTransformer);
+    }
+
+    public static Iterable<Table> system()
+    {
+        return Iterables.transform(Schema.systemKeyspaceNames, tableTransformer);
     }
 
     @Override
diff --git a/src/java/org/apache/cassandra/service/StorageService.java b/src/java/org/apache/cassandra/service/StorageService.java
index 15339c49ee..efa748769c 100644
--- a/src/java/org/apache/cassandra/service/StorageService.java
+++ b/src/java/org/apache/cassandra/service/StorageService.java
@@ -3193,18 +3193,35 @@ public class StorageService extends NotificationBroadcasterSupport implements IE
         StorageProxy.instance.verifyNoHintsInProgress();
 
         setMode(Mode.DRAINING, "flushing column families", false);
-        List<ColumnFamilyStore> cfses = new ArrayList<ColumnFamilyStore>();
-        for (String tableName : Schema.instance.getNonSystemTables())
+        // count CFs first, since forceFlush could block for the flushWriter to get a queue slot empty
+        totalCFs = 0;
+        for (Table table : Table.nonSystem())
+            totalCFs += table.getColumnFamilyStores().size();
+        remainingCFs = totalCFs;
+        // flush
+        List<Future<?>> flushes = new ArrayList<Future<?>>();
+        for (Table table : Table.nonSystem())
         {
-            Table table = Table.open(tableName);
-            cfses.addAll(table.getColumnFamilyStores());
+            for (ColumnFamilyStore cfs : table.getColumnFamilyStores())
+                flushes.add(cfs.forceFlush());
         }
-        totalCFs = remainingCFs = cfses.size();
-        for (ColumnFamilyStore cfs : cfses)
+        // wait for the flushes.
+        // TODO this is a godawful way to track progress, since they flush in parallel.  a long one could
+        // thus make several short ones "instant" if we wait for them later.
+        for (Future f : flushes)
         {
-            cfs.forceBlockingFlush();
+            FBUtilities.waitOnFuture(f);
             remainingCFs--;
         }
+        // flush the system ones after all the rest are done, just in case flushing modifies any system state
+        // like CASSANDRA-5151. don't bother with progress tracking since system data is tiny.
+        flushes.clear();
+        for (Table table : Table.system())
+        {
+            for (ColumnFamilyStore cfs : table.getColumnFamilyStores())
+                flushes.add(cfs.forceFlush());
+        }
+        FBUtilities.waitOnFutures(flushes);
 
         ColumnFamilyStore.postFlushExecutor.shutdown();
         ColumnFamilyStore.postFlushExecutor.awaitTermination(60, TimeUnit.SECONDS);
