diff --git a/CHANGES.txt b/CHANGES.txt
index 7f8c7a64bb..1470674d42 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -8,6 +8,7 @@ dev
  * require index_type to be present when specifying index_name
    on ColumnDef (CASSANDRA-1759)
  * fix add/remove index bugs in CFMetadata (CASSANDRA-1768)
+ * rebuild Strategy during system_update_keyspace (CASSANDRA-1762)
 
 
 0.7.0-rc1
diff --git a/src/java/org/apache/cassandra/db/Table.java b/src/java/org/apache/cassandra/db/Table.java
index 061cd1eac6..7cc81bc200 100644
--- a/src/java/org/apache/cassandra/db/Table.java
+++ b/src/java/org/apache/cassandra/db/Table.java
@@ -96,7 +96,7 @@ public class Table
     public final Map<Integer, ColumnFamilyStore> columnFamilyStores = new HashMap<Integer, ColumnFamilyStore>(); // TODO make private again
     private final Object[] indexLocks;
     private ScheduledFuture<?> flushTask;
-    public final AbstractReplicationStrategy replicationStrategy;
+    private volatile AbstractReplicationStrategy replicationStrategy;
 
     public static Table open(String table)
     {
@@ -244,11 +244,7 @@ public class Table
         KSMetaData ksm = DatabaseDescriptor.getKSMetaData(table);
         try
         {
-            replicationStrategy = AbstractReplicationStrategy.createReplicationStrategy(table,
-                                                                                        ksm.strategyClass,
-                                                                                        StorageService.instance.getTokenMetadata(),
-                                                                                        DatabaseDescriptor.getEndpointSnitch(),
-                                                                                        ksm.strategyOptions);
+            createReplicationStrategy(ksm);
         }
         catch (ConfigurationException e)
         {
@@ -302,7 +298,19 @@ public class Table
         };
         flushTask = StorageService.scheduledTasks.scheduleWithFixedDelay(runnable, minCheckMs, minCheckMs, TimeUnit.MILLISECONDS);
     }
-    
+
+    public void createReplicationStrategy(KSMetaData ksm) throws ConfigurationException
+    {
+        if (replicationStrategy != null)
+            StorageService.instance.getTokenMetadata().unregister(replicationStrategy);
+            
+        replicationStrategy = AbstractReplicationStrategy.createReplicationStrategy(ksm.name,
+                                                                                    ksm.strategyClass,
+                                                                                    StorageService.instance.getTokenMetadata(),
+                                                                                    DatabaseDescriptor.getEndpointSnitch(),
+                                                                                    ksm.strategyOptions);
+    }
+
     // best invoked on the compaction mananger.
     public void dropCf(Integer cfId) throws IOException
     {
@@ -557,6 +565,11 @@ public class Table
         return new IndexBuilder(cfs, columns, iter);
     }
 
+    public AbstractReplicationStrategy getReplicationStrategy()
+    {
+        return replicationStrategy;
+    }
+
     public class IndexBuilder implements ICompactionInfo
     {
         private final ColumnFamilyStore cfs;
diff --git a/src/java/org/apache/cassandra/db/migration/UpdateKeyspace.java b/src/java/org/apache/cassandra/db/migration/UpdateKeyspace.java
index ed5c3326cd..ba6059eee0 100644
--- a/src/java/org/apache/cassandra/db/migration/UpdateKeyspace.java
+++ b/src/java/org/apache/cassandra/db/migration/UpdateKeyspace.java
@@ -5,6 +5,7 @@ import org.apache.cassandra.config.ConfigurationException;
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.config.KSMetaData;
 import org.apache.cassandra.db.Table;
+import org.apache.cassandra.service.StorageService;
 import org.apache.cassandra.utils.FBUtilities;
 import org.apache.cassandra.utils.UUIDGen;
 
@@ -59,7 +60,18 @@ public class UpdateKeyspace extends Migration
     {
         DatabaseDescriptor.clearTableDefinition(oldKsm, newVersion);
         DatabaseDescriptor.setTableDefinition(newKsm, newVersion);
-        Table.open(newKsm.name).replicationStrategy.clearEndpointCache();
+
+
+        Table table = Table.open(newKsm.name);
+        try
+        {
+            table.createReplicationStrategy(newKsm);
+        }
+        catch (ConfigurationException e)
+        {
+            throw new IOException(e);
+        }
+
         logger.info("Keyspace updated. Please perform any manual operations.");
     }
 
diff --git a/src/java/org/apache/cassandra/dht/BootStrapper.java b/src/java/org/apache/cassandra/dht/BootStrapper.java
index f548153474..2473280d28 100644
--- a/src/java/org/apache/cassandra/dht/BootStrapper.java
+++ b/src/java/org/apache/cassandra/dht/BootStrapper.java
@@ -191,7 +191,7 @@ public class BootStrapper
     Multimap<Range, InetAddress> getRangesWithSources(String table)
     {
         assert tokenMetadata.sortedTokens().size() > 0;
-        final AbstractReplicationStrategy strat = Table.open(table).replicationStrategy;
+        final AbstractReplicationStrategy strat = Table.open(table).getReplicationStrategy();
         Collection<Range> myRanges = strat.getPendingAddressRanges(tokenMetadata, token, address);
 
         Multimap<Range, InetAddress> myRangeAddresses = ArrayListMultimap.create();
diff --git a/src/java/org/apache/cassandra/locator/TokenMetadata.java b/src/java/org/apache/cassandra/locator/TokenMetadata.java
index 4a5652d403..e3812e0285 100644
--- a/src/java/org/apache/cassandra/locator/TokenMetadata.java
+++ b/src/java/org/apache/cassandra/locator/TokenMetadata.java
@@ -540,6 +540,11 @@ public class TokenMetadata
         subscribers.add(subscriber);
     }
 
+    public void unregister(AbstractReplicationStrategy subscriber)
+    {
+        subscribers.remove(subscriber);
+    }
+
     /**
      * write endpoints may be different from read endpoints, because read endpoints only need care about the
      * "natural" nodes for a token, but write endpoints also need to account for nodes that are bootstrapping
diff --git a/src/java/org/apache/cassandra/service/DatacenterQuorumResponseHandler.java b/src/java/org/apache/cassandra/service/DatacenterQuorumResponseHandler.java
index d950cee6cf..6267df94e9 100644
--- a/src/java/org/apache/cassandra/service/DatacenterQuorumResponseHandler.java
+++ b/src/java/org/apache/cassandra/service/DatacenterQuorumResponseHandler.java
@@ -65,7 +65,7 @@ public class DatacenterQuorumResponseHandler<T> extends QuorumResponseHandler<T>
     @Override
     public int determineBlockFor(ConsistencyLevel consistency_level, String table)
 	{
-        NetworkTopologyStrategy stategy = (NetworkTopologyStrategy) Table.open(table).replicationStrategy;
+        NetworkTopologyStrategy stategy = (NetworkTopologyStrategy) Table.open(table).getReplicationStrategy();
 		return (stategy.getReplicationFactor(localdc) / 2) + 1;
 	}
 }
diff --git a/src/java/org/apache/cassandra/service/DatacenterSyncWriteResponseHandler.java b/src/java/org/apache/cassandra/service/DatacenterSyncWriteResponseHandler.java
index 9264140b69..86278f4d25 100644
--- a/src/java/org/apache/cassandra/service/DatacenterSyncWriteResponseHandler.java
+++ b/src/java/org/apache/cassandra/service/DatacenterSyncWriteResponseHandler.java
@@ -63,7 +63,7 @@ public class DatacenterSyncWriteResponseHandler extends AbstractWriteResponseHan
         super(writeEndpoints, hintedEndpoints, consistencyLevel);
         assert consistencyLevel == ConsistencyLevel.LOCAL_QUORUM;
 
-        strategy = (NetworkTopologyStrategy) Table.open(table).replicationStrategy;
+        strategy = (NetworkTopologyStrategy) Table.open(table).getReplicationStrategy();
 
         for (String dc : strategy.getDatacenters())
         {
diff --git a/src/java/org/apache/cassandra/service/DatacenterWriteResponseHandler.java b/src/java/org/apache/cassandra/service/DatacenterWriteResponseHandler.java
index 4719f5c488..f5345a4f8b 100644
--- a/src/java/org/apache/cassandra/service/DatacenterWriteResponseHandler.java
+++ b/src/java/org/apache/cassandra/service/DatacenterWriteResponseHandler.java
@@ -65,7 +65,7 @@ public class DatacenterWriteResponseHandler extends WriteResponseHandler
     @Override
     protected int determineBlockFor(String table)
     {
-        NetworkTopologyStrategy strategy = (NetworkTopologyStrategy) Table.open(table).replicationStrategy;
+        NetworkTopologyStrategy strategy = (NetworkTopologyStrategy) Table.open(table).getReplicationStrategy();
         return (strategy.getReplicationFactor(localdc) / 2) + 1;
     }
 
diff --git a/src/java/org/apache/cassandra/service/StorageProxy.java b/src/java/org/apache/cassandra/service/StorageProxy.java
index 0cf5721d2e..c33c41b077 100644
--- a/src/java/org/apache/cassandra/service/StorageProxy.java
+++ b/src/java/org/apache/cassandra/service/StorageProxy.java
@@ -104,7 +104,7 @@ public class StorageProxy implements StorageProxyMBean
             {
                 mostRecentRowMutation = rm;
                 String table = rm.getTable();
-                AbstractReplicationStrategy rs = Table.open(table).replicationStrategy;
+                AbstractReplicationStrategy rs = Table.open(table).getReplicationStrategy();
 
                 List<InetAddress> naturalEndpoints = ss.getNaturalEndpoints(table, rm.key());
                 Collection<InetAddress> writeEndpoints = ss.getTokenMetadata().getWriteEndpoints(StorageService.getPartitioner().getToken(rm.key()), table, naturalEndpoints);
@@ -342,7 +342,7 @@ public class StorageProxy implements StorageProxyMBean
                 if (logger.isDebugEnabled())
                     logger.debug("strongread reading " + (m == message ? "data" : "digest") + " for " + command + " from " + m.getMessageId() + "@" + endpoint);
             }
-            AbstractReplicationStrategy rs = Table.open(command.table).replicationStrategy;
+            AbstractReplicationStrategy rs = Table.open(command.table).getReplicationStrategy();
             QuorumResponseHandler<Row> quorumResponseHandler = rs.getQuorumResponseHandler(new ReadResponseResolver(command.table), consistency_level);
             MessagingService.instance.sendRR(messages, endpoints, quorumResponseHandler);
             quorumResponseHandlers.add(quorumResponseHandler);
@@ -368,7 +368,7 @@ public class StorageProxy implements StorageProxyMBean
             }
             catch (DigestMismatchException ex)
             {
-                AbstractReplicationStrategy rs = Table.open(command.table).replicationStrategy;
+                AbstractReplicationStrategy rs = Table.open(command.table).getReplicationStrategy();
                 QuorumResponseHandler<Row> qrhRepair = rs.getQuorumResponseHandler(new ReadResponseResolver(command.table), ConsistencyLevel.QUORUM);
                 if (logger.isDebugEnabled())
                     logger.debug("Digest mismatch:", ex);
@@ -448,7 +448,7 @@ public class StorageProxy implements StorageProxyMBean
 
                 // collect replies and resolve according to consistency level
                 RangeSliceResponseResolver resolver = new RangeSliceResponseResolver(command.keyspace, liveEndpoints);
-                AbstractReplicationStrategy rs = Table.open(command.keyspace).replicationStrategy;
+                AbstractReplicationStrategy rs = Table.open(command.keyspace).getReplicationStrategy();
                 QuorumResponseHandler<List<Row>> handler = rs.getQuorumResponseHandler(resolver, consistency_level);
                 // TODO bail early if live endpoints can't satisfy requested consistency level
                 for (InetAddress endpoint : liveEndpoints) 
@@ -664,7 +664,7 @@ public class StorageProxy implements StorageProxyMBean
 
             // collect replies and resolve according to consistency level
             RangeSliceResponseResolver resolver = new RangeSliceResponseResolver(keyspace, liveEndpoints);
-            AbstractReplicationStrategy rs = Table.open(keyspace).replicationStrategy;
+            AbstractReplicationStrategy rs = Table.open(keyspace).getReplicationStrategy();
             QuorumResponseHandler<List<Row>> handler = rs.getQuorumResponseHandler(resolver, consistency_level);
             
             // bail early if live endpoints can't satisfy requested consistency level
diff --git a/src/java/org/apache/cassandra/service/StorageService.java b/src/java/org/apache/cassandra/service/StorageService.java
index fa404258f3..7471aaf55d 100644
--- a/src/java/org/apache/cassandra/service/StorageService.java
+++ b/src/java/org/apache/cassandra/service/StorageService.java
@@ -558,7 +558,7 @@ public class StorageService implements IEndpointStateChangeSubscriber, StorageSe
         Map<Range, List<InetAddress>> rangeToEndpointMap = new HashMap<Range, List<InetAddress>>();
         for (Range range : ranges)
         {
-            rangeToEndpointMap.put(range, Table.open(keyspace).replicationStrategy.getNaturalEndpoints(range.right));
+            rangeToEndpointMap.put(range, Table.open(keyspace).getReplicationStrategy().getNaturalEndpoints(range.right));
         }
         return rangeToEndpointMap;
     }
@@ -824,7 +824,7 @@ public class StorageService implements IEndpointStateChangeSubscriber, StorageSe
     private void calculatePendingRanges()
     {
         for (String table : DatabaseDescriptor.getNonSystemTables())
-            calculatePendingRanges(Table.open(table).replicationStrategy, table);
+            calculatePendingRanges(Table.open(table).getReplicationStrategy(), table);
     }
 
     // public & static for testing purposes
@@ -894,7 +894,7 @@ public class StorageService implements IEndpointStateChangeSubscriber, StorageSe
     private Multimap<InetAddress, Range> getNewSourceRanges(String table, Set<Range> ranges) 
     {
         InetAddress myAddress = FBUtilities.getLocalAddress();
-        Multimap<Range, InetAddress> rangeAddresses = Table.open(table).replicationStrategy.getRangeAddresses(tokenMetadata_);
+        Multimap<Range, InetAddress> rangeAddresses = Table.open(table).getReplicationStrategy().getRangeAddresses(tokenMetadata_);
         Multimap<InetAddress, Range> sourceRanges = HashMultimap.create();
         IFailureDetector failureDetector = FailureDetector.instance;
 
@@ -1017,7 +1017,7 @@ public class StorageService implements IEndpointStateChangeSubscriber, StorageSe
 
         // Find (for each range) all nodes that store replicas for these ranges as well
         for (Range range : ranges)
-            currentReplicaEndpoints.put(range, Table.open(table).replicationStrategy.calculateNaturalEndpoints(range.right, tokenMetadata_));
+            currentReplicaEndpoints.put(range, Table.open(table).getReplicationStrategy().calculateNaturalEndpoints(range.right, tokenMetadata_));
 
         TokenMetadata temp = tokenMetadata_.cloneAfterAllLeft();
 
@@ -1035,7 +1035,7 @@ public class StorageService implements IEndpointStateChangeSubscriber, StorageSe
         // range.
         for (Range range : ranges)
         {
-            Collection<InetAddress> newReplicaEndpoints = Table.open(table).replicationStrategy.calculateNaturalEndpoints(range.right, temp);
+            Collection<InetAddress> newReplicaEndpoints = Table.open(table).getReplicationStrategy().calculateNaturalEndpoints(range.right, temp);
             newReplicaEndpoints.removeAll(currentReplicaEndpoints.get(range));
             if (logger_.isDebugEnabled())
                 if (newReplicaEndpoints.isEmpty())
@@ -1359,7 +1359,7 @@ public class StorageService implements IEndpointStateChangeSubscriber, StorageSe
      */
     Collection<Range> getRangesForEndpoint(String table, InetAddress ep)
     {
-        return Table.open(table).replicationStrategy.getAddressRanges().get(ep);
+        return Table.open(table).getReplicationStrategy().getAddressRanges().get(ep);
     }
 
     /**
@@ -1409,7 +1409,7 @@ public class StorageService implements IEndpointStateChangeSubscriber, StorageSe
      */
     public List<InetAddress> getNaturalEndpoints(String table, Token token)
     {
-        return Table.open(table).replicationStrategy.getNaturalEndpoints(token);
+        return Table.open(table).getReplicationStrategy().getNaturalEndpoints(token);
     }
 
     /**
@@ -1427,7 +1427,7 @@ public class StorageService implements IEndpointStateChangeSubscriber, StorageSe
     public List<InetAddress> getLiveNaturalEndpoints(String table, Token token)
     {
         List<InetAddress> liveEps = new ArrayList<InetAddress>();
-        List<InetAddress> endpoints = Table.open(table).replicationStrategy.getNaturalEndpoints(token);
+        List<InetAddress> endpoints = Table.open(table).getReplicationStrategy().getNaturalEndpoints(token);
 
         for (InetAddress endpoint : endpoints)
         {
diff --git a/test/unit/org/apache/cassandra/locator/ReplicationStrategyEndpointCacheTest.java b/test/unit/org/apache/cassandra/locator/ReplicationStrategyEndpointCacheTest.java
index 4b4b57a5d6..33dc4cc4c1 100644
--- a/test/unit/org/apache/cassandra/locator/ReplicationStrategyEndpointCacheTest.java
+++ b/test/unit/org/apache/cassandra/locator/ReplicationStrategyEndpointCacheTest.java
@@ -43,7 +43,7 @@ public class ReplicationStrategyEndpointCacheTest extends SchemaLoader
         tmd = new TokenMetadata();
         searchToken = new BigIntegerToken(String.valueOf(15));
 
-        strategy = getStrategyWithNewTokenMetadata(Table.open("Keyspace3").replicationStrategy, tmd);
+        strategy = getStrategyWithNewTokenMetadata(Table.open("Keyspace3").getReplicationStrategy(), tmd);
 
         tmd.updateNormalToken(new BigIntegerToken(String.valueOf(10)), InetAddress.getByName("127.0.0.1"));
         tmd.updateNormalToken(new BigIntegerToken(String.valueOf(20)), InetAddress.getByName("127.0.0.2"));
diff --git a/test/unit/org/apache/cassandra/locator/SimpleStrategyTest.java b/test/unit/org/apache/cassandra/locator/SimpleStrategyTest.java
index c2cdce4d12..6055f43b45 100644
--- a/test/unit/org/apache/cassandra/locator/SimpleStrategyTest.java
+++ b/test/unit/org/apache/cassandra/locator/SimpleStrategyTest.java
@@ -43,7 +43,7 @@ public class SimpleStrategyTest extends SchemaLoader
     @Test
     public void tryValidTable()
     {
-        assert Table.open("Keyspace1").replicationStrategy != null;
+        assert Table.open("Keyspace1").getReplicationStrategy() != null;
     }
 
     @Test
diff --git a/test/unit/org/apache/cassandra/service/AntiEntropyServiceTest.java b/test/unit/org/apache/cassandra/service/AntiEntropyServiceTest.java
index 27fb3318da..ccbdcc0157 100644
--- a/test/unit/org/apache/cassandra/service/AntiEntropyServiceTest.java
+++ b/test/unit/org/apache/cassandra/service/AntiEntropyServiceTest.java
@@ -183,7 +183,7 @@ public class AntiEntropyServiceTest extends CleanupHelper
 
         // generate rf*2 nodes, and ensure that only neighbors specified by the ARS are returned
         addTokens(2 * DatabaseDescriptor.getReplicationFactor(tablename));
-        AbstractReplicationStrategy ars = Table.open(tablename).replicationStrategy;
+        AbstractReplicationStrategy ars = Table.open(tablename).getReplicationStrategy();
         Set<InetAddress> expected = new HashSet<InetAddress>();
         for (Range replicaRange : ars.getAddressRanges().get(FBUtilities.getLocalAddress()))
         {
