diff --git a/CHANGES.txt b/CHANGES.txt
index 1ffec7dc91..e1c963cbc5 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -25,6 +25,7 @@
  * Add -no-snapshot option to scrub (CASSANDRA-5891)
  * Fix to support off heap bloom filters size greater than 2 GB (CASSANDRA-5903)
  * Properly handle parsing huge map and set literals (CASSANDRA-5893)
+ * Fix LCS L0 compaction may overlap in L1 (CASSANDRA-5907)
 Merged from 1.1:
  * Correctly validate sparse composite cells in scrub (CASSANDRA-5855)
 
diff --git a/src/java/org/apache/cassandra/db/compaction/LeveledManifest.java b/src/java/org/apache/cassandra/db/compaction/LeveledManifest.java
index f62c796232..fc108835a9 100644
--- a/src/java/org/apache/cassandra/db/compaction/LeveledManifest.java
+++ b/src/java/org/apache/cassandra/db/compaction/LeveledManifest.java
@@ -530,13 +530,13 @@ public class LeveledManifest
                 // if the overlapping ones are already busy in a compaction, leave it out.
                 // TODO try to find a set of L0 sstables that only overlaps with non-busy L1 sstables
                 candidates = Sets.union(candidates, overlapping(candidates, generations[1]));
-                // check overlap with L0 compacting sstables to make sure we are not generating overlap in L1.
-                Iterable<SSTableReader> compactingL0 = Iterables.filter(generations[0], Predicates.in(compacting));
-                if (!Sets.intersection(candidates, compacting).isEmpty() || !overlapping(candidates, compactingL0).isEmpty())
-                    return Collections.emptyList();
             }
-
-            return candidates.size() > 1 ? candidates : Collections.<SSTableReader>emptyList();
+            // check overlap with L0 compacting sstables to make sure we are not generating overlap in L1.
+            Iterable<SSTableReader> compactingL0 = Iterables.filter(generations[0], Predicates.in(compacting));
+            if (candidates.size() < 2 || !Sets.intersection(candidates, compacting).isEmpty() || !overlapping(candidates, compactingL0).isEmpty())
+                return Collections.emptyList();
+            else
+                return candidates;
         }
 
         // for non-L0 compactions, pick up where we left off last time
