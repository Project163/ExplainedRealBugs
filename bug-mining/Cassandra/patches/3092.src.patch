diff --git a/src/java/org/apache/cassandra/config/CFMetaData.java b/src/java/org/apache/cassandra/config/CFMetaData.java
index 2a93b39bc9..b42ce69da2 100644
--- a/src/java/org/apache/cassandra/config/CFMetaData.java
+++ b/src/java/org/apache/cassandra/config/CFMetaData.java
@@ -217,7 +217,7 @@ public final class CFMetaData
     public static final CFMetaData SchemaFunctionsCf = compile("CREATE TABLE " + SystemKeyspace.SCHEMA_FUNCTIONS_CF + " ("
                                                                + "namespace text,"
                                                                + "name text,"
-                                                               + "signature text,"
+                                                               + "signature blob,"
                                                                + "argument_names list<text>,"
                                                                + "argument_types list<text>,"
                                                                + "return_type text,"
diff --git a/src/java/org/apache/cassandra/config/UFMetaData.java b/src/java/org/apache/cassandra/config/UFMetaData.java
deleted file mode 100644
index 4d5f6d38ca..0000000000
--- a/src/java/org/apache/cassandra/config/UFMetaData.java
+++ /dev/null
@@ -1,306 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.cassandra.config;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-import org.apache.commons.lang3.builder.ToStringBuilder;
-
-import org.antlr.runtime.ANTLRStringStream;
-import org.antlr.runtime.CharStream;
-import org.antlr.runtime.CommonTokenStream;
-import org.antlr.runtime.RecognitionException;
-import org.antlr.runtime.TokenStream;
-import org.apache.cassandra.cql3.AssignementTestable;
-import org.apache.cassandra.cql3.CQL3Type;
-import org.apache.cassandra.cql3.ColumnIdentifier;
-import org.apache.cassandra.cql3.ColumnSpecification;
-import org.apache.cassandra.cql3.CqlLexer;
-import org.apache.cassandra.cql3.CqlParser;
-import org.apache.cassandra.cql3.QueryProcessor;
-import org.apache.cassandra.cql3.UntypedResultSet;
-import org.apache.cassandra.cql3.udf.UDFFunctionOverloads;
-import org.apache.cassandra.cql3.udf.UDFRegistry;
-import org.apache.cassandra.db.CFRowAdder;
-import org.apache.cassandra.db.ColumnFamily;
-import org.apache.cassandra.db.Keyspace;
-import org.apache.cassandra.db.Mutation;
-import org.apache.cassandra.db.RangeTombstone;
-import org.apache.cassandra.db.Row;
-import org.apache.cassandra.db.SystemKeyspace;
-import org.apache.cassandra.db.composites.Composite;
-import org.apache.cassandra.db.marshal.AbstractType;
-import org.apache.cassandra.db.marshal.CompositeType;
-import org.apache.cassandra.db.marshal.UTF8Type;
-import org.apache.cassandra.exceptions.InvalidRequestException;
-
-/**
- * Defined (and loaded) user functions.
- * <p/>
- * In practice, because user functions are global, we have only one instance of
- * this class that retrieve through the Schema class.
- */
-public final class UFMetaData
-{
-    public final String namespace;
-    public final String functionName;
-    public final String qualifiedName;
-    public final String returnType;
-    public final List<String> argumentNames;
-    public final List<String> argumentTypes;
-    public final String language;
-    public final String body;
-    public final boolean deterministic;
-
-    public final String signature;
-    public final List<CQL3Type> cqlArgumentTypes;
-    public final CQL3Type cqlReturnType;
-
-    static final CompositeType partKey = (CompositeType) CFMetaData.SchemaFunctionsCf.getKeyValidator();
-
-    // TODO tracking "valid" status via an exception field is really bad style - but we need some way to mark a function as "dead"
-    public InvalidRequestException invalid;
-
-    public UFMetaData(String namespace, String functionName, boolean deterministic, List<String> argumentNames,
-                      List<String> argumentTypes, String returnType, String language, String body)
-    {
-        this.namespace = namespace != null ? namespace.toLowerCase() : "";
-        this.functionName = functionName.toLowerCase();
-        this.qualifiedName = qualifiedName(namespace, functionName);
-        this.returnType = returnType;
-        this.argumentNames = argumentNames;
-        this.argumentTypes = argumentTypes;
-        this.language = language == null ? "class" : language.toLowerCase();
-        this.body = body;
-        this.deterministic = deterministic;
-
-        this.cqlArgumentTypes = new ArrayList<>(argumentTypes.size());
-        InvalidRequestException inv = null;
-        CQL3Type rt = null;
-        try
-        {
-            rt = parseCQLType(returnType);
-            for (String argumentType : argumentTypes)
-                cqlArgumentTypes.add(parseCQLType(argumentType));
-        }
-        catch (InvalidRequestException e)
-        {
-            inv = e;
-        }
-        this.invalid = inv;
-        this.cqlReturnType = rt;
-
-        StringBuilder signature = new StringBuilder();
-        signature.append(qualifiedName);
-        for (String argumentType : argumentTypes)
-        {
-            signature.append(',');
-            signature.append(argumentType);
-        }
-        this.signature = signature.toString();
-    }
-
-    public boolean compatibleArgs(String ksName, String cfName, List<? extends AssignementTestable> providedArgs)
-    {
-        int cnt = cqlArgumentTypes.size();
-        if (cnt != providedArgs.size())
-            return false;
-        for (int i = 0; i < cnt; i++)
-        {
-            AssignementTestable provided = providedArgs.get(i);
-
-            if (provided == null)
-                continue;
-
-            AbstractType<?> argType = cqlArgumentTypes.get(i).getType();
-
-            ColumnSpecification expected = makeArgSpec(ksName, cfName, argType, i);
-            if (!provided.isAssignableTo(ksName, expected))
-                return false;
-        }
-
-        return true;
-    }
-
-    public ColumnSpecification makeArgSpec(String ksName, String cfName, AbstractType<?> argType, int i)
-    {
-        return new ColumnSpecification(ksName,
-                                       cfName,
-                                       new ColumnIdentifier("arg" + i + "(" + qualifiedName + ")", true), argType);
-    }
-
-    private static CQL3Type parseCQLType(String cqlType)
-    throws InvalidRequestException
-    {
-        CharStream stream = new ANTLRStringStream(cqlType);
-        CqlLexer lexer = new CqlLexer(stream);
-
-        TokenStream tokenStream = new CommonTokenStream(lexer);
-        CqlParser parser = new CqlParser(tokenStream);
-        try
-        {
-            CQL3Type.Raw rawType = parser.comparatorType();
-            // TODO CASSANDRA-7563 use appropiate keyspace here ... keyspace must be fully qualified
-            CQL3Type t = rawType.prepare(null);
-            // TODO CASSANDRA-7563 support "complex" types (UDT, tuples, collections), remove catch-NPE below
-            if (!(t instanceof CQL3Type.Native))
-                throw new InvalidRequestException("non-native CQL type '" + cqlType + "' not supported");
-            return t;
-        }
-        catch (NullPointerException | InvalidRequestException | RecognitionException e)
-        {
-            throw new InvalidRequestException("invalid CQL type '" + cqlType + "'");
-        }
-    }
-
-    public static String qualifiedName(String namespace, String functionName)
-    {
-        if (namespace == null)
-            return "::" + functionName;
-        return (namespace + "::" + functionName).toLowerCase();
-    }
-
-    public static Mutation dropFunction(long timestamp, String namespace, String functionName)
-    {
-        UDFFunctionOverloads sigMap = UDFRegistry.getFunctionSigMap(UFMetaData.qualifiedName(namespace, functionName));
-        if (sigMap == null || sigMap.isEmpty())
-            return null;
-
-        Mutation mutation = new Mutation(Keyspace.SYSTEM_KS, partKey.decompose(namespace, functionName));
-        ColumnFamily cf = mutation.addOrGet(SystemKeyspace.SCHEMA_FUNCTIONS_CF);
-
-        int ldt = (int) (System.currentTimeMillis() / 1000);
-        for (UFMetaData f : sigMap.values())
-            udfRemove(timestamp, cf, ldt, f);
-
-        return mutation;
-    }
-
-    private static Composite udfSignatureKey(UFMetaData function)
-    {
-        return CFMetaData.SchemaFunctionsCf.comparator.make(function.signature);
-    }
-
-    private static void udfRemove(long timestamp, ColumnFamily cf, int ldt, UFMetaData f)
-    {
-        Composite prefix = udfSignatureKey(f);
-        cf.addAtom(new RangeTombstone(prefix, prefix.end(), timestamp, ldt));
-    }
-
-    public static Mutation createOrReplaceFunction(long timestamp, UFMetaData f)
-    {
-        Mutation mutation = new Mutation(Keyspace.SYSTEM_KS, partKey.decompose(f.namespace, f.functionName));
-        ColumnFamily cf = mutation.addOrGet(SystemKeyspace.SCHEMA_FUNCTIONS_CF);
-
-        Composite prefix = udfSignatureKey(f);
-        CFRowAdder adder = new CFRowAdder(cf, prefix, timestamp);
-
-        adder.resetCollection("argument_names");
-        adder.resetCollection("argument_types");
-        adder.add("name", f.functionName);
-        adder.add("return_type", f.returnType);
-        adder.add("language", f.language);
-        adder.add("body", f.body);
-        adder.add("deterministic", f.deterministic);
-
-        for (String argName : f.argumentNames)
-            adder.addListEntry("argument_names", argName);
-        for (String argType : f.argumentTypes)
-            adder.addListEntry("argument_types", argType);
-
-        return mutation;
-    }
-
-    public static UFMetaData fromSchema(UntypedResultSet.Row row)
-    {
-        String namespace = row.getString("namespace");
-        String name = row.getString("name");
-        List<String> argumentNames = row.getList("argument_names", UTF8Type.instance);
-        List<String> argumentTypes = row.getList("argument_types", UTF8Type.instance);
-        String returnType = row.getString("return_type");
-        boolean deterministic = row.getBoolean("deterministic");
-        String language = row.getString("language");
-        String body = row.getString("body");
-
-        return new UFMetaData(namespace, name, deterministic, argumentNames, argumentTypes, returnType, language, body);
-    }
-
-    public static Map<String, UFMetaData> fromSchema(Row row)
-    {
-        UntypedResultSet results = QueryProcessor.resultify("SELECT * FROM system." + SystemKeyspace.SCHEMA_FUNCTIONS_CF, row);
-        Map<String, UFMetaData> udfs = new HashMap<>(results.size());
-        for (UntypedResultSet.Row result : results)
-        {
-            UFMetaData udf = fromSchema(result);
-            udfs.put(udf.signature, udf);
-        }
-        return udfs;
-    }
-
-    public boolean equals(Object o)
-    {
-        if (this == o)
-            return true;
-        if (o == null || getClass() != o.getClass())
-            return false;
-
-        UFMetaData that = (UFMetaData) o;
-        if (!signature.equals(that.signature))
-            return false;
-        if (deterministic != that.deterministic)
-            return false;
-        if (argumentNames != null ? !argumentNames.equals(that.argumentNames) : that.argumentNames != null)
-            return false;
-        if (body != null ? !body.equals(that.body) : that.body != null)
-            return false;
-        if (!namespace.equals(that.namespace))
-            return false;
-        if (!language.equals(that.language))
-            return false;
-        if (returnType != null ? !returnType.equals(that.returnType) : that.returnType != null)
-            return false;
-
-        return true;
-    }
-
-    public int hashCode()
-    {
-        int result = signature.hashCode();
-        result = 31 * result + (returnType != null ? returnType.hashCode() : 0);
-        result = 31 * result + (argumentNames != null ? argumentNames.hashCode() : 0);
-        result = 31 * result + (argumentTypes.hashCode());
-        result = 31 * result + (language.hashCode());
-        result = 31 * result + (body != null ? body.hashCode() : 0);
-        result = 31 * result + (deterministic ? 1 : 0);
-        return result;
-    }
-
-    public String toString()
-    {
-        return new ToStringBuilder(this)
-               .append("signature", signature)
-               .append("returnType", returnType)
-               .append("deterministic", deterministic)
-               .append("language", language)
-               .append("body", body)
-               .toString();
-    }
-}
diff --git a/src/java/org/apache/cassandra/cql3/AbstractMarker.java b/src/java/org/apache/cassandra/cql3/AbstractMarker.java
index 10a4dff27d..7e39bfc83b 100644
--- a/src/java/org/apache/cassandra/cql3/AbstractMarker.java
+++ b/src/java/org/apache/cassandra/cql3/AbstractMarker.java
@@ -71,9 +71,9 @@ public abstract class AbstractMarker extends Term.NonTerminal
             throw new AssertionError();
         }
 
-        public boolean isAssignableTo(String keyspace, ColumnSpecification receiver)
+        public AssignmentTestable.TestResult testAssignment(String keyspace, ColumnSpecification receiver)
         {
-            return true;
+            return AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;
         }
 
         @Override
diff --git a/src/java/org/apache/cassandra/cql3/AssignmentTestable.java b/src/java/org/apache/cassandra/cql3/AssignmentTestable.java
new file mode 100644
index 0000000000..41b80eb87b
--- /dev/null
+++ b/src/java/org/apache/cassandra/cql3/AssignmentTestable.java
@@ -0,0 +1,72 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.cassandra.cql3;
+
+import java.util.Collection;
+
+public interface AssignmentTestable
+{
+    /**
+     * @return whether this object can be assigned to the provided receiver. We distinguish
+     * between 3 values: 
+     *   - EXACT_MATCH if this object is exactly of the type expected by the receiver
+     *   - WEAKLY_ASSIGNABLE if this object is not exactly the expected type but is assignable nonetheless
+     *   - NOT_ASSIGNABLE if it's not assignable
+     * Most caller should just call the isAssignable() method on the result, though functions have a use for
+     * testing "strong" equality to decide the most precise overload to pick when multiple could match.
+     */
+    public TestResult testAssignment(String keyspace, ColumnSpecification receiver);
+
+    public enum TestResult
+    {
+        EXACT_MATCH, WEAKLY_ASSIGNABLE, NOT_ASSIGNABLE;
+
+        public boolean isAssignable()
+        {
+            return this != NOT_ASSIGNABLE;
+        }
+
+        public boolean isExactMatch()
+        {
+            return this == EXACT_MATCH;
+        }
+
+        // Test all elements of toTest for assignment. If all are exact match, return exact match. If any is not assignable,
+        // return not assignable. Otherwise, return weakly assignable.
+        public static TestResult testAll(String keyspace, ColumnSpecification receiver, Collection<? extends AssignmentTestable> toTest)
+        {
+            TestResult res = EXACT_MATCH;
+            for (AssignmentTestable rt : toTest)
+            {
+                if (rt == null)
+                {
+                    res = WEAKLY_ASSIGNABLE;
+                    continue;
+                }
+
+                TestResult t = rt.testAssignment(keyspace, receiver);
+                if (t == NOT_ASSIGNABLE)
+                    return NOT_ASSIGNABLE;
+
+                if (t == WEAKLY_ASSIGNABLE)
+                    res = WEAKLY_ASSIGNABLE;
+            }
+            return res;
+        }
+    }
+}
diff --git a/src/java/org/apache/cassandra/cql3/Constants.java b/src/java/org/apache/cassandra/cql3/Constants.java
index c6cc4b85fe..9d4ce8743f 100644
--- a/src/java/org/apache/cassandra/cql3/Constants.java
+++ b/src/java/org/apache/cassandra/cql3/Constants.java
@@ -67,15 +67,17 @@ public abstract class Constants
 
         public Term prepare(String keyspace, ColumnSpecification receiver) throws InvalidRequestException
         {
-            if (!isAssignableTo(keyspace, receiver))
+            if (!testAssignment(keyspace, receiver).isAssignable())
                 throw new InvalidRequestException("Invalid null value for counter increment/decrement");
 
             return NULL_VALUE;
         }
 
-        public boolean isAssignableTo(String keyspace, ColumnSpecification receiver)
+        public AssignmentTestable.TestResult testAssignment(String keyspace, ColumnSpecification receiver)
         {
-            return !(receiver.type instanceof CounterColumnType);
+            return receiver.type instanceof CounterColumnType
+                 ? AssignmentTestable.TestResult.NOT_ASSIGNABLE
+                 : AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;
         }
 
         @Override
@@ -129,7 +131,7 @@ public abstract class Constants
 
         public Value prepare(String keyspace, ColumnSpecification receiver) throws InvalidRequestException
         {
-            if (!isAssignableTo(keyspace, receiver))
+            if (!testAssignment(keyspace, receiver).isAssignable())
                 throw new InvalidRequestException(String.format("Invalid %s constant (%s) for \"%s\" of type %s", type, text, receiver.name, receiver.type.asCQL3Type()));
 
             return new Value(parsedValue(receiver.type));
@@ -159,15 +161,15 @@ public abstract class Constants
             return text;
         }
 
-        public boolean isAssignableTo(String keyspace, ColumnSpecification receiver)
+        public AssignmentTestable.TestResult testAssignment(String keyspace, ColumnSpecification receiver)
         {
             CQL3Type receiverType = receiver.type.asCQL3Type();
             if (receiverType.isCollection())
-                return false;
+                return AssignmentTestable.TestResult.NOT_ASSIGNABLE;
 
             if (!(receiverType instanceof CQL3Type.Native))
                 // Skip type validation for custom types. May or may not be a good idea
-                return true;
+                return AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;
 
             CQL3Type.Native nt = (CQL3Type.Native)receiverType;
             switch (type)
@@ -180,9 +182,9 @@ public abstract class Constants
                         case INET:
                         case VARCHAR:
                         case TIMESTAMP:
-                            return true;
+                            return AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;
                     }
-                    return false;
+                    break;
                 case INTEGER:
                     switch (nt)
                     {
@@ -194,42 +196,42 @@ public abstract class Constants
                         case INT:
                         case TIMESTAMP:
                         case VARINT:
-                            return true;
+                            return AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;
                     }
-                    return false;
+                    break;
                 case UUID:
                     switch (nt)
                     {
                         case UUID:
                         case TIMEUUID:
-                            return true;
+                            return AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;
                     }
-                    return false;
+                    break;
                 case FLOAT:
                     switch (nt)
                     {
                         case DECIMAL:
                         case DOUBLE:
                         case FLOAT:
-                            return true;
+                            return AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;
                     }
-                    return false;
+                    break;
                 case BOOLEAN:
                     switch (nt)
                     {
                         case BOOLEAN:
-                            return true;
+                            return AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;
                     }
-                    return false;
+                    break;
                 case HEX:
                     switch (nt)
                     {
                         case BLOB:
-                            return true;
+                            return AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;
                     }
-                    return false;
+                    break;
             }
-            return false;
+            return AssignmentTestable.TestResult.NOT_ASSIGNABLE;
         }
 
         @Override
diff --git a/src/java/org/apache/cassandra/cql3/Cql.g b/src/java/org/apache/cassandra/cql3/Cql.g
index 5cf61dff3e..054f1a2369 100644
--- a/src/java/org/apache/cassandra/cql3/Cql.g
+++ b/src/java/org/apache/cassandra/cql3/Cql.g
@@ -42,7 +42,7 @@ options {
     import org.apache.cassandra.auth.IResource;
     import org.apache.cassandra.cql3.*;
     import org.apache.cassandra.cql3.statements.*;
-    import org.apache.cassandra.cql3.functions.FunctionCall;
+    import org.apache.cassandra.cql3.functions.*;
     import org.apache.cassandra.db.marshal.CollectionType;
     import org.apache.cassandra.exceptions.ConfigurationException;
     import org.apache.cassandra.exceptions.InvalidRequestException;
@@ -300,8 +300,7 @@ unaliasedSelector returns [Selectable s]
     :  ( c=cident                                  { tmp = c; }
        | K_WRITETIME '(' c=cident ')'              { tmp = new Selectable.WritetimeOrTTL(c, true); }
        | K_TTL       '(' c=cident ')'              { tmp = new Selectable.WritetimeOrTTL(c, false); }
-       | f=functionName args=selectionFunctionArgs { tmp = new Selectable.WithFunction("", f, args); }
-       | bn=udfName '::' fn=udfName args=selectionFunctionArgs { tmp = new Selectable.WithFunction(bn, fn, args); }
+       | f=functionName args=selectionFunctionArgs { tmp = new Selectable.WithFunction(f, args); }
        ) ( '.' fi=cident { tmp = new Selectable.WithFieldSelection(tmp, fi); } )* { $s = tmp; }
     ;
 
@@ -494,20 +493,20 @@ createFunctionStatement returns [CreateFunctionStatement expr]
         boolean ifNotExists = false;
 
         boolean deterministic = true;
-        String language = "CLASS";
+        String language = "class";
         String bodyOrClassName = null;
-        List<CreateFunctionStatement.Argument> args = new ArrayList<CreateFunctionStatement.Argument>();
+        List<ColumnIdentifier> argsNames = new ArrayList<>();
+        List<CQL3Type.Raw> argsTypes = new ArrayList<>();
     }
     : K_CREATE (K_OR K_REPLACE { orReplace = true; })?
       ((K_NON { deterministic = false; })? K_DETERMINISTIC)?
       K_FUNCTION
       (K_IF K_NOT K_EXISTS { ifNotExists = true; })?
-      ( bn=udfName '::' )?
-      fn=udfName
+      fn=functionName
       '('
         (
-          k=cident v=comparatorType { args.add(new CreateFunctionStatement.Argument(k, v)); }
-          ( ',' k=cident v=comparatorType { args.add(new CreateFunctionStatement.Argument(k, v)); } )*
+          k=cident v=comparatorType { argsNames.add(k); argsTypes.add(v); }
+          ( ',' k=cident v=comparatorType { argsNames.add(k); argsTypes.add(v); } )*
         )?
       ')'
       K_RETURNS
@@ -523,7 +522,7 @@ createFunctionStatement returns [CreateFunctionStatement expr]
             )
           )
       )
-      { $expr = new CreateFunctionStatement(bn, fn, language, bodyOrClassName, deterministic, rt, args, orReplace, ifNotExists); }
+      { $expr = new CreateFunctionStatement(fn, language.toLowerCase(), bodyOrClassName, deterministic, argsNames, argsTypes, rt, orReplace, ifNotExists); }
     ;
 
 dropFunctionStatement returns [DropFunctionStatement expr]
@@ -532,9 +531,8 @@ dropFunctionStatement returns [DropFunctionStatement expr]
     }
     : K_DROP K_FUNCTION
       (K_IF K_EXISTS { ifExists = true; } )?
-      ( bn=udfName '::' )?
-      fn=udfName
-      { $expr = new DropFunctionStatement(bn, fn, ifExists); }
+      fn=functionName
+      { $expr = new DropFunctionStatement(fn, ifExists); }
     ;
 
 /**
@@ -968,15 +966,15 @@ intValue returns [Term.Raw value]
     | QMARK         { $value = newBindVariables(null); }
     ;
 
-functionName returns [String s]
-    : f=IDENT                       { $s = $f.text; }
-    | u=unreserved_function_keyword { $s = u; }
-    | K_TOKEN                       { $s = "token"; }
+functionName returns [FunctionName s]
+    : f=allowedFunctionName                            { $s = new FunctionName(f); }
+    | b=allowedFunctionName '::' f=allowedFunctionName { $s = new FunctionName(b, f); }
     ;
 
-udfName returns [String s]
+allowedFunctionName returns [String s]
     : f=IDENT                       { $s = $f.text; }
     | u=unreserved_function_keyword { $s = u; }
+    | K_TOKEN                       { $s = "token"; }
     ;
 
 functionArgs returns [List<Term.Raw> a]
@@ -988,8 +986,7 @@ functionArgs returns [List<Term.Raw> a]
 
 term returns [Term.Raw term]
     : v=value                          { $term = v; }
-    | f=functionName args=functionArgs { $term = new FunctionCall.Raw("", f, args); }
-    | bn=udfName '::' fn=udfName args=functionArgs { $term = new FunctionCall.Raw(bn, fn, args); }
+    | f=functionName args=functionArgs { $term = new FunctionCall.Raw(f, args); }
     | '(' c=comparatorType ')' t=term  { $term = new TypeCast(c, t); }
     ;
 
diff --git a/src/java/org/apache/cassandra/cql3/Lists.java b/src/java/org/apache/cassandra/cql3/Lists.java
index c8598cc6a1..51af7277d5 100644
--- a/src/java/org/apache/cassandra/cql3/Lists.java
+++ b/src/java/org/apache/cassandra/cql3/Lists.java
@@ -97,22 +97,22 @@ public abstract class Lists
             ColumnSpecification valueSpec = Lists.valueSpecOf(receiver);
             for (Term.Raw rt : elements)
             {
-                if (!rt.isAssignableTo(keyspace, valueSpec))
+                if (!rt.testAssignment(keyspace, valueSpec).isAssignable())
                     throw new InvalidRequestException(String.format("Invalid list literal for %s: value %s is not of type %s", receiver.name, rt, valueSpec.type.asCQL3Type()));
             }
         }
 
-        public boolean isAssignableTo(String keyspace, ColumnSpecification receiver)
+        public AssignmentTestable.TestResult testAssignment(String keyspace, ColumnSpecification receiver)
         {
-            try
-            {
-                validateAssignableTo(keyspace, receiver);
-                return true;
-            }
-            catch (InvalidRequestException e)
-            {
-                return false;
-            }
+            if (!(receiver.type instanceof ListType))
+                return AssignmentTestable.TestResult.NOT_ASSIGNABLE;
+
+            // If there is no elements, we can't say it's an exact match (an empty list if fundamentally polymorphic).
+            if (elements.isEmpty())
+                return AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;
+
+            ColumnSpecification valueSpec = Lists.valueSpecOf(receiver);
+            return AssignmentTestable.TestResult.testAll(keyspace, valueSpec, elements);
         }
 
         @Override
diff --git a/src/java/org/apache/cassandra/cql3/Maps.java b/src/java/org/apache/cassandra/cql3/Maps.java
index e38543848e..00bdbeca5c 100644
--- a/src/java/org/apache/cassandra/cql3/Maps.java
+++ b/src/java/org/apache/cassandra/cql3/Maps.java
@@ -98,24 +98,36 @@ public abstract class Maps
             ColumnSpecification valueSpec = Maps.valueSpecOf(receiver);
             for (Pair<Term.Raw, Term.Raw> entry : entries)
             {
-                if (!entry.left.isAssignableTo(keyspace, keySpec))
+                if (!entry.left.testAssignment(keyspace, keySpec).isAssignable())
                     throw new InvalidRequestException(String.format("Invalid map literal for %s: key %s is not of type %s", receiver.name, entry.left, keySpec.type.asCQL3Type()));
-                if (!entry.right.isAssignableTo(keyspace, valueSpec))
+                if (!entry.right.testAssignment(keyspace, valueSpec).isAssignable())
                     throw new InvalidRequestException(String.format("Invalid map literal for %s: value %s is not of type %s", receiver.name, entry.right, valueSpec.type.asCQL3Type()));
             }
         }
 
-        public boolean isAssignableTo(String keyspace, ColumnSpecification receiver)
+        public AssignmentTestable.TestResult testAssignment(String keyspace, ColumnSpecification receiver)
         {
-            try
-            {
-                validateAssignableTo(keyspace, receiver);
-                return true;
-            }
-            catch (InvalidRequestException e)
+            if (!(receiver.type instanceof MapType))
+                return AssignmentTestable.TestResult.NOT_ASSIGNABLE;
+
+            // If there is no elements, we can't say it's an exact match (an empty map if fundamentally polymorphic).
+            if (entries.isEmpty())
+                return AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;
+
+            ColumnSpecification keySpec = Maps.keySpecOf(receiver);
+            ColumnSpecification valueSpec = Maps.valueSpecOf(receiver);
+            // It's an exact match if all are exact match, but is not assignable as soon as any is non assignable.
+            AssignmentTestable.TestResult res = AssignmentTestable.TestResult.EXACT_MATCH;
+            for (Pair<Term.Raw, Term.Raw> entry : entries)
             {
-                return false;
+                AssignmentTestable.TestResult t1 = entry.left.testAssignment(keyspace, keySpec);
+                AssignmentTestable.TestResult t2 = entry.right.testAssignment(keyspace, valueSpec);
+                if (t1 == AssignmentTestable.TestResult.NOT_ASSIGNABLE || t2 == AssignmentTestable.TestResult.NOT_ASSIGNABLE)
+                    return AssignmentTestable.TestResult.NOT_ASSIGNABLE;
+                if (t1 != AssignmentTestable.TestResult.EXACT_MATCH || t2 != AssignmentTestable.TestResult.EXACT_MATCH)
+                    res = AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;
             }
+            return res;
         }
 
         @Override
diff --git a/src/java/org/apache/cassandra/cql3/Sets.java b/src/java/org/apache/cassandra/cql3/Sets.java
index 20d9ac5240..7360889a9a 100644
--- a/src/java/org/apache/cassandra/cql3/Sets.java
+++ b/src/java/org/apache/cassandra/cql3/Sets.java
@@ -106,22 +106,28 @@ public abstract class Sets
             ColumnSpecification valueSpec = Sets.valueSpecOf(receiver);
             for (Term.Raw rt : elements)
             {
-                if (!rt.isAssignableTo(keyspace, valueSpec))
+                if (!rt.testAssignment(keyspace, valueSpec).isAssignable())
                     throw new InvalidRequestException(String.format("Invalid set literal for %s: value %s is not of type %s", receiver.name, rt, valueSpec.type.asCQL3Type()));
             }
         }
 
-        public boolean isAssignableTo(String keyspace, ColumnSpecification receiver)
+        public AssignmentTestable.TestResult testAssignment(String keyspace, ColumnSpecification receiver)
         {
-            try
-            {
-                validateAssignableTo(keyspace, receiver);
-                return true;
-            }
-            catch (InvalidRequestException e)
+            if (!(receiver.type instanceof SetType))
             {
-                return false;
+                // We've parsed empty maps as a set literal to break the ambiguity so handle that case now
+                if (receiver.type instanceof MapType && elements.isEmpty())
+                    return AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;
+
+                return AssignmentTestable.TestResult.NOT_ASSIGNABLE;
             }
+
+            // If there is no elements, we can't say it's an exact match (an empty set if fundamentally polymorphic).
+            if (elements.isEmpty())
+                return AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;
+
+            ColumnSpecification valueSpec = Sets.valueSpecOf(receiver);
+            return AssignmentTestable.TestResult.testAll(keyspace, valueSpec, elements);
         }
 
         @Override
diff --git a/src/java/org/apache/cassandra/cql3/Term.java b/src/java/org/apache/cassandra/cql3/Term.java
index e5206c8d15..54406262be 100644
--- a/src/java/org/apache/cassandra/cql3/Term.java
+++ b/src/java/org/apache/cassandra/cql3/Term.java
@@ -76,7 +76,7 @@ public interface Term
      *   - a function call
      *   - a marker
      */
-    public interface Raw extends AssignementTestable
+    public interface Raw extends AssignmentTestable
     {
         /**
          * This method validates this RawTerm is valid for provided column
diff --git a/src/java/org/apache/cassandra/cql3/Tuples.java b/src/java/org/apache/cassandra/cql3/Tuples.java
index cc04ebc4b2..23552b8bff 100644
--- a/src/java/org/apache/cassandra/cql3/Tuples.java
+++ b/src/java/org/apache/cassandra/cql3/Tuples.java
@@ -110,21 +110,21 @@ public class Tuples
 
                 Term.Raw value = elements.get(i);
                 ColumnSpecification spec = componentSpecOf(receiver, i);
-                if (!value.isAssignableTo(keyspace, spec))
+                if (!value.testAssignment(keyspace, spec).isAssignable())
                     throw new InvalidRequestException(String.format("Invalid tuple literal for %s: component %d is not of type %s", receiver.name, i, spec.type.asCQL3Type()));
             }
         }
 
-        public boolean isAssignableTo(String keyspace, ColumnSpecification receiver)
+        public AssignmentTestable.TestResult testAssignment(String keyspace, ColumnSpecification receiver)
         {
             try
             {
                 validateAssignableTo(keyspace, receiver);
-                return true;
+                return AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;
             }
             catch (InvalidRequestException e)
             {
-                return false;
+                return AssignmentTestable.TestResult.NOT_ASSIGNABLE;
             }
         }
 
diff --git a/src/java/org/apache/cassandra/cql3/TypeCast.java b/src/java/org/apache/cassandra/cql3/TypeCast.java
index 3250e3b40b..10b040e586 100644
--- a/src/java/org/apache/cassandra/cql3/TypeCast.java
+++ b/src/java/org/apache/cassandra/cql3/TypeCast.java
@@ -17,6 +17,7 @@
  */
 package org.apache.cassandra.cql3;
 
+import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.exceptions.InvalidRequestException;
 
 public class TypeCast implements Term.Raw
@@ -32,11 +33,11 @@ public class TypeCast implements Term.Raw
 
     public Term prepare(String keyspace, ColumnSpecification receiver) throws InvalidRequestException
     {
-        if (!term.isAssignableTo(keyspace, castedSpecOf(keyspace, receiver)))
+        if (!term.testAssignment(keyspace, castedSpecOf(keyspace, receiver)).isAssignable())
             throw new InvalidRequestException(String.format("Cannot cast value %s to type %s", term, type));
 
-        if (!isAssignableTo(keyspace, receiver))
-            throw new InvalidRequestException(String.format("Cannot assign value %s to %s of type %s", this, receiver, receiver.type.asCQL3Type()));
+        if (!testAssignment(keyspace, receiver).isAssignable())
+            throw new InvalidRequestException(String.format("Cannot assign value %s to %s of type %s", this, receiver.name, receiver.type.asCQL3Type()));
 
         return term.prepare(keyspace, receiver);
     }
@@ -46,11 +47,17 @@ public class TypeCast implements Term.Raw
         return new ColumnSpecification(receiver.ksName, receiver.cfName, new ColumnIdentifier(toString(), true), type.prepare(keyspace).getType());
     }
 
-    public boolean isAssignableTo(String keyspace, ColumnSpecification receiver)
+    public AssignmentTestable.TestResult testAssignment(String keyspace, ColumnSpecification receiver)
     {
         try
         {
-            return receiver.type.isValueCompatibleWith(type.prepare(keyspace).getType());
+            AbstractType<?> castedType = type.prepare(keyspace).getType();
+            if (receiver.type.equals(castedType))
+                return AssignmentTestable.TestResult.EXACT_MATCH;
+            else if (receiver.type.isValueCompatibleWith(castedType))
+                return AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;
+            else
+                return AssignmentTestable.TestResult.NOT_ASSIGNABLE;
         }
         catch (InvalidRequestException e)
         {
diff --git a/src/java/org/apache/cassandra/cql3/UntypedResultSet.java b/src/java/org/apache/cassandra/cql3/UntypedResultSet.java
index 42d0cb8258..0cec9a611e 100644
--- a/src/java/org/apache/cassandra/cql3/UntypedResultSet.java
+++ b/src/java/org/apache/cassandra/cql3/UntypedResultSet.java
@@ -219,6 +219,11 @@ public abstract class UntypedResultSet implements Iterable<UntypedResultSet.Row>
             return data.get(column) != null;
         }
 
+        public ByteBuffer getBlob(String column)
+        {
+            return data.get(column);
+        }
+
         public String getString(String column)
         {
             return UTF8Type.instance.compose(data.get(column));
diff --git a/src/java/org/apache/cassandra/cql3/UserTypes.java b/src/java/org/apache/cassandra/cql3/UserTypes.java
index 9d66c16e87..763791b07c 100644
--- a/src/java/org/apache/cassandra/cql3/UserTypes.java
+++ b/src/java/org/apache/cassandra/cql3/UserTypes.java
@@ -99,21 +99,21 @@ public abstract class UserTypes
                     continue;
 
                 ColumnSpecification fieldSpec = fieldSpecOf(receiver, i);
-                if (!value.isAssignableTo(keyspace, fieldSpec))
+                if (!value.testAssignment(keyspace, fieldSpec).isAssignable())
                     throw new InvalidRequestException(String.format("Invalid user type literal for %s: field %s is not of type %s", receiver, field, fieldSpec.type.asCQL3Type()));
             }
         }
 
-        public boolean isAssignableTo(String keyspace, ColumnSpecification receiver)
+        public AssignmentTestable.TestResult testAssignment(String keyspace, ColumnSpecification receiver)
         {
             try
             {
                 validateAssignableTo(keyspace, receiver);
-                return true;
+                return AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;
             }
             catch (InvalidRequestException e)
             {
-                return false;
+                return AssignmentTestable.TestResult.NOT_ASSIGNABLE;
             }
         }
 
diff --git a/src/java/org/apache/cassandra/cql3/functions/AbstractFunction.java b/src/java/org/apache/cassandra/cql3/functions/AbstractFunction.java
index 5dbfbf3fd8..d5a40a0905 100644
--- a/src/java/org/apache/cassandra/cql3/functions/AbstractFunction.java
+++ b/src/java/org/apache/cassandra/cql3/functions/AbstractFunction.java
@@ -17,32 +17,36 @@
  */
 package org.apache.cassandra.cql3.functions;
 
-import java.util.Arrays;
 import java.util.List;
 
+import com.google.common.base.Objects;
+
 import org.apache.cassandra.db.marshal.AbstractType;
 
+/**
+ * Base class for our native/hardcoded functions.
+ */
 public abstract class AbstractFunction implements Function
 {
-    public final String name;
-    public final List<AbstractType<?>> argsType;
-    public final AbstractType<?> returnType;
+    protected final FunctionName name;
+    protected final List<AbstractType<?>> argTypes;
+    protected final AbstractType<?> returnType;
 
-    protected AbstractFunction(String name, AbstractType<?> returnType, AbstractType<?>... argsType)
+    protected AbstractFunction(FunctionName name, List<AbstractType<?>> argTypes, AbstractType<?> returnType)
     {
         this.name = name;
-        this.argsType = Arrays.asList(argsType);
+        this.argTypes = argTypes;
         this.returnType = returnType;
     }
 
-    public String name()
+    public FunctionName name()
     {
         return name;
     }
 
-    public List<AbstractType<?>> argsType()
+    public List<AbstractType<?>> argTypes()
     {
-        return argsType;
+        return argTypes;
     }
 
     public AbstractType<?> returnType()
@@ -50,23 +54,36 @@ public abstract class AbstractFunction implements Function
         return returnType;
     }
 
-    // Most of our functions are pure, the other ones should override this
-    public boolean isPure()
+    @Override
+    public boolean equals(Object o)
+    {
+        if (!(o instanceof AbstractFunction))
+            return false;
+
+        AbstractFunction that = (AbstractFunction)o;
+        return Objects.equal(this.name, that.name)
+            && Objects.equal(this.argTypes, that.argTypes)
+            && Objects.equal(this.returnType, that.returnType);
+    }
+
+    @Override
+    public int hashCode()
     {
-        return true;
+        return Objects.hashCode(name, argTypes, returnType);
     }
 
-    /**
-     * Creates a trivial factory that always return the provided function.
-     */
-    public static Function.Factory factory(final Function fun)
+    @Override
+    public String toString()
     {
-        return new Function.Factory()
+        StringBuilder sb = new StringBuilder();
+        sb.append(name).append(" : (");
+        for (int i = 0; i < argTypes.size(); i++)
         {
-            public Function create(String ksName, String cfName)
-            {
-                return fun;
-            }
-        };
+            if (i > 0)
+                sb.append(", ");
+            sb.append(argTypes.get(i).asCQL3Type());
+        }
+        sb.append(") -> ").append(returnType.asCQL3Type());
+        return sb.toString();
     }
 }
diff --git a/src/java/org/apache/cassandra/cql3/functions/BytesConversionFcts.java b/src/java/org/apache/cassandra/cql3/functions/BytesConversionFcts.java
index e3023db7bf..6ea0a550af 100644
--- a/src/java/org/apache/cassandra/cql3/functions/BytesConversionFcts.java
+++ b/src/java/org/apache/cassandra/cql3/functions/BytesConversionFcts.java
@@ -34,7 +34,7 @@ public abstract class BytesConversionFcts
     public static Function makeToBlobFunction(AbstractType<?> fromType)
     {
         String name = fromType.asCQL3Type() + "asblob";
-        return new AbstractFunction(name, BytesType.instance, fromType)
+        return new NativeFunction(name, BytesType.instance, fromType)
         {
             public ByteBuffer execute(List<ByteBuffer> parameters)
             {
@@ -46,7 +46,7 @@ public abstract class BytesConversionFcts
     public static Function makeFromBlobFunction(final AbstractType<?> toType)
     {
         final String name = "blobas" + toType.asCQL3Type();
-        return new AbstractFunction(name, toType, BytesType.instance)
+        return new NativeFunction(name, toType, BytesType.instance)
         {
             public ByteBuffer execute(List<ByteBuffer> parameters) throws InvalidRequestException
             {
@@ -66,7 +66,7 @@ public abstract class BytesConversionFcts
         };
     }
 
-    public static final Function VarcharAsBlobFct = new AbstractFunction("varcharasblob", BytesType.instance, UTF8Type.instance)
+    public static final Function VarcharAsBlobFct = new NativeFunction("varcharasblob", BytesType.instance, UTF8Type.instance)
     {
         public ByteBuffer execute(List<ByteBuffer> parameters)
         {
@@ -74,7 +74,7 @@ public abstract class BytesConversionFcts
         }
     };
 
-    public static final Function BlobAsVarcharFact = new AbstractFunction("blobasvarchar", UTF8Type.instance, BytesType.instance)
+    public static final Function BlobAsVarcharFact = new NativeFunction("blobasvarchar", UTF8Type.instance, BytesType.instance)
     {
         public ByteBuffer execute(List<ByteBuffer> parameters)
         {
diff --git a/src/java/org/apache/cassandra/cql3/functions/Function.java b/src/java/org/apache/cassandra/cql3/functions/Function.java
index ba5ae20af4..dc2a0db16a 100644
--- a/src/java/org/apache/cassandra/cql3/functions/Function.java
+++ b/src/java/org/apache/cassandra/cql3/functions/Function.java
@@ -25,8 +25,8 @@ import org.apache.cassandra.exceptions.InvalidRequestException;
 
 public interface Function
 {
-    public String name();
-    public List<AbstractType<?>> argsType();
+    public FunctionName name();
+    public List<AbstractType<?>> argTypes();
     public AbstractType<?> returnType();
 
     public ByteBuffer execute(List<ByteBuffer> parameters) throws InvalidRequestException;
@@ -34,12 +34,6 @@ public interface Function
     // Whether the function is a pure function (as in doesn't depend on, nor produce side effects).
     public boolean isPure();
 
-    public interface Factory
-    {
-        // We allow the function to be parametered by the keyspace it is part of because the
-        // "token" function needs it (the argument depends on the keyValidator). However,
-        // for most function, the factory will just always the same function object (see
-        // AbstractFunction).
-        public Function create(String ksName, String cfName);
-    }
+    // Whether the function is a native/harcoded one.
+    public boolean isNative();
 }
diff --git a/src/java/org/apache/cassandra/cql3/functions/FunctionCall.java b/src/java/org/apache/cassandra/cql3/functions/FunctionCall.java
index d83d48fade..d2ef90c6ab 100644
--- a/src/java/org/apache/cassandra/cql3/functions/FunctionCall.java
+++ b/src/java/org/apache/cassandra/cql3/functions/FunctionCall.java
@@ -22,8 +22,6 @@ import java.util.ArrayList;
 import java.util.List;
 
 import org.apache.cassandra.cql3.*;
-import org.apache.cassandra.cql3.udf.UDFunction;
-import org.apache.cassandra.cql3.udf.UDFRegistry;
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.db.marshal.CollectionType;
 import org.apache.cassandra.db.marshal.ListType;
@@ -113,39 +111,33 @@ public class FunctionCall extends Term.NonTerminal
 
     public static class Raw implements Term.Raw
     {
-        private final String namespace;
-        private final String functionName;
+        private final FunctionName name;
         private final List<Term.Raw> terms;
 
-        public Raw(String namespace, String functionName, List<Term.Raw> terms)
+        public Raw(FunctionName name, List<Term.Raw> terms)
         {
-            this.namespace = namespace;
-            this.functionName = functionName;
+            this.name = name;
             this.terms = terms;
         }
 
         public Term prepare(String keyspace, ColumnSpecification receiver) throws InvalidRequestException
         {
-            Function fun = null;
-            if (namespace.isEmpty())
-                fun = Functions.get(keyspace, functionName, terms, receiver);
-
+            Function fun = Functions.get(keyspace, name, terms, receiver.ksName, receiver.cfName);
             if (fun == null)
-            {
-                UDFunction udf = UDFRegistry.resolveFunction(namespace, functionName, receiver.ksName, receiver.cfName, terms);
-                if (udf != null)
-                    // got a user defined function to call
-                    fun = udf.create(terms);
-            }
+                throw new InvalidRequestException(String.format("Unknown function %s called", name));
 
-            if (fun == null)
-                throw new InvalidRequestException(String.format("Unknown function %s called", namespace.isEmpty() ? functionName : namespace + "::" + functionName));
+            // Functions.get() will complain if no function "name" type check with the provided arguments.
+            // We still have to validate that the return type matches however
+            if (!receiver.type.isValueCompatibleWith(fun.returnType()))
+                throw new InvalidRequestException(String.format("Type error: cannot assign result of function %s (type %s) to %s (type %s)",
+                                                                fun.name(), fun.returnType().asCQL3Type(),
+                                                                receiver.name, receiver.type.asCQL3Type()));
 
             List<Term> parameters = new ArrayList<Term>(terms.size());
             boolean allTerminal = true;
             for (int i = 0; i < terms.size(); i++)
             {
-                Term t = terms.get(i).prepare(keyspace, Functions.makeArgSpec(receiver, fun, i));
+                Term t = terms.get(i).prepare(keyspace, Functions.makeArgSpec(receiver.ksName, receiver.cfName, fun, i));
                 if (t instanceof NonTerminal)
                     allTerminal = false;
                 parameters.add(t);
@@ -171,23 +163,33 @@ public class FunctionCall extends Term.NonTerminal
             return executeInternal(fun, buffers);
         }
 
-        public boolean isAssignableTo(String keyspace, ColumnSpecification receiver)
+        public AssignmentTestable.TestResult testAssignment(String keyspace, ColumnSpecification receiver)
         {
-            AbstractType<?> returnType = Functions.getReturnType(functionName, receiver.ksName, receiver.cfName);
-            // Note: if returnType == null, it means the function doesn't exist. We may get this if an undefined function
-            // is used as argument of another, existing, function. In that case, we return true here because we'll catch
-            // the fact that the method is undefined latter anyway and with a more helpful error message that if we were
-            // to return false here.
-            return returnType == null || receiver.type.isValueCompatibleWith(returnType);
+            // Note: Functions.get() will return null if the function doesn't exist, or throw is no function matching
+            // the arguments can be found. We may get one of those if an undefined/wrong function is used as argument
+            // of another, existing, function. In that case, we return true here because we'll throw a proper exception
+            // later with a more helpful error message that if we were to return false here.
+            try
+            {
+                Function fun = Functions.get(keyspace, name, terms, receiver.ksName, receiver.cfName);
+                if (fun != null && receiver.type.equals(fun.returnType()))
+                    return AssignmentTestable.TestResult.EXACT_MATCH;
+                else if (fun == null || receiver.type.isValueCompatibleWith(fun.returnType()))
+                    return AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;
+                else
+                    return AssignmentTestable.TestResult.NOT_ASSIGNABLE;
+            }
+            catch (InvalidRequestException e)
+            {
+                return AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;
+            }
         }
 
         @Override
         public String toString()
         {
             StringBuilder sb = new StringBuilder();
-            if (!namespace.isEmpty())
-                sb.append(namespace).append("::");
-            sb.append(functionName).append("(");
+            sb.append(name).append("(");
             for (int i = 0; i < terms.size(); i++)
             {
                 if (i > 0)
diff --git a/src/java/org/apache/cassandra/cql3/functions/FunctionName.java b/src/java/org/apache/cassandra/cql3/functions/FunctionName.java
new file mode 100644
index 0000000000..814bbbfc16
--- /dev/null
+++ b/src/java/org/apache/cassandra/cql3/functions/FunctionName.java
@@ -0,0 +1,66 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.cassandra.cql3.functions;
+
+import com.google.common.base.Objects;
+
+public class FunctionName
+{
+    public final String namespace;
+    public final String name;
+
+    // Use by toString rather than built from 'bundle' and 'name' so as to
+    // preserve the original case.
+    private final String displayName;
+
+    public FunctionName(String name)
+    {
+        this("", name);
+    }
+
+    public FunctionName(String namespace, String name)
+    {
+        this.namespace = namespace.toLowerCase();
+        this.name = name.toLowerCase();
+
+        this.displayName = namespace.isEmpty() ? name : namespace + "::" + name;
+    }
+
+    @Override
+    public final int hashCode()
+    {
+        return Objects.hashCode(namespace, name);
+    }
+
+    @Override
+    public final boolean equals(Object o)
+    {
+        if (!(o instanceof FunctionName))
+            return false;
+
+        FunctionName that = (FunctionName)o;
+        return Objects.equal(this.namespace, that.namespace)
+            && Objects.equal(this.name, that.name);
+    }
+
+    @Override
+    public String toString()
+    {
+        return displayName;
+    }
+}
diff --git a/src/java/org/apache/cassandra/cql3/functions/Functions.java b/src/java/org/apache/cassandra/cql3/functions/Functions.java
index 977d242321..18feb36d15 100644
--- a/src/java/org/apache/cassandra/cql3/functions/Functions.java
+++ b/src/java/org/apache/cassandra/cql3/functions/Functions.java
@@ -17,34 +17,43 @@
  */
 package org.apache.cassandra.cql3.functions;
 
+import java.util.ArrayList;
 import java.util.List;
 
 import com.google.common.collect.ArrayListMultimap;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
-import org.apache.cassandra.cql3.ColumnIdentifier;
-import org.apache.cassandra.cql3.ColumnSpecification;
-import org.apache.cassandra.cql3.CQL3Type;
-import org.apache.cassandra.cql3.AssignementTestable;
+import org.apache.cassandra.config.Schema;
+import org.apache.cassandra.cql3.*;
+import org.apache.cassandra.db.Keyspace;
+import org.apache.cassandra.db.SystemKeyspace;
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.exceptions.InvalidRequestException;
 
 public abstract class Functions
 {
+    private static final Logger logger = LoggerFactory.getLogger(Functions.class);
+
+    // We special case the token function because that's the only function whose argument types actually
+    // depend on the table on which the function is called. Because it's the sole exception, it's easier
+    // to handle it as a special case.
+    private static final FunctionName TOKEN_FUNCTION_NAME = new FunctionName("token");
+
+    private static final String SELECT_UDFS = "SELECT * FROM " + Keyspace.SYSTEM_KS + '.' + SystemKeyspace.SCHEMA_FUNCTIONS_CF;
+
     private Functions() {}
 
-    // If we ever allow this to be populated at runtime, this will need to be thread safe.
-    private static final ArrayListMultimap<String, Function.Factory> declared = ArrayListMultimap.create();
+    private static final ArrayListMultimap<FunctionName, Function> declared = ArrayListMultimap.create();
+
     static
     {
-        // All method sharing the same name must have the same returnType. We could find a way to make that clear.
-        declared.put("token", TokenFct.factory);
-
-        declared.put("now", AbstractFunction.factory(TimeuuidFcts.nowFct));
-        declared.put("mintimeuuid", AbstractFunction.factory(TimeuuidFcts.minTimeuuidFct));
-        declared.put("maxtimeuuid", AbstractFunction.factory(TimeuuidFcts.maxTimeuuidFct));
-        declared.put("dateof", AbstractFunction.factory(TimeuuidFcts.dateOfFct));
-        declared.put("unixtimestampof", AbstractFunction.factory(TimeuuidFcts.unixTimestampOfFct));
-        declared.put("uuid", AbstractFunction.factory(UuidFcts.uuidFct));
+        declare(TimeuuidFcts.nowFct);
+        declare(TimeuuidFcts.minTimeuuidFct);
+        declare(TimeuuidFcts.maxTimeuuidFct);
+        declare(TimeuuidFcts.dateOfFct);
+        declare(TimeuuidFcts.unixTimestampOfFct);
+        declare(UuidFcts.uuidFct);
 
         for (CQL3Type type : CQL3Type.Native.values())
         {
@@ -53,137 +62,189 @@ public abstract class Functions
             if (type == CQL3Type.Native.VARCHAR || type == CQL3Type.Native.BLOB)
                 continue;
 
-            Function toBlob = BytesConversionFcts.makeToBlobFunction(type.getType());
-            Function fromBlob = BytesConversionFcts.makeFromBlobFunction(type.getType());
-            declared.put(toBlob.name(), AbstractFunction.factory(toBlob));
-            declared.put(fromBlob.name(), AbstractFunction.factory(fromBlob));
+            declare(BytesConversionFcts.makeToBlobFunction(type.getType()));
+            declare(BytesConversionFcts.makeFromBlobFunction(type.getType()));
         }
-        declared.put("varcharasblob", AbstractFunction.factory(BytesConversionFcts.VarcharAsBlobFct));
-        declared.put("blobasvarchar", AbstractFunction.factory(BytesConversionFcts.BlobAsVarcharFact));
+        declare(BytesConversionFcts.VarcharAsBlobFct);
+        declare(BytesConversionFcts.BlobAsVarcharFact);
     }
 
-    public static boolean contains(String functionName)
+    private static void declare(Function fun)
     {
-        return declared.containsKey(functionName);
+        declared.put(fun.name(), fun);
     }
 
-    public static AbstractType<?> getReturnType(String functionName, String ksName, String cfName)
+    /**
+     * Loading existing UDFs from the schema.
+     */
+    public static void loadUDFFromSchema()
     {
-        List<Function.Factory> factories = declared.get(functionName.toLowerCase());
-        return factories.isEmpty()
-             ? null // That's ok, we'll complain later
-             : factories.get(0).create(ksName, cfName).returnType();
+        logger.debug("Loading UDFs");
+        for (UntypedResultSet.Row row : QueryProcessor.executeOnceInternal(SELECT_UDFS))
+            addFunction(UDFunction.fromSchema(row));
     }
 
-    public static ColumnSpecification makeArgSpec(ColumnSpecification receiver, Function fun, int i)
+    public static ColumnSpecification makeArgSpec(String receiverKs, String receiverCf, Function fun, int i)
     {
-        return new ColumnSpecification(receiver.ksName,
-                receiver.cfName,
-                new ColumnIdentifier("arg" + i +  "(" + fun.name() + ")", true),
-                fun.argsType().get(i));
+        return new ColumnSpecification(receiverKs,
+                                       receiverCf,
+                                       new ColumnIdentifier("arg" + i +  "(" + fun.name().toString().toLowerCase() + ")", true),
+                                       fun.argTypes().get(i));
     }
 
-    public static Function get(String keyspace, String name, List<? extends AssignementTestable> providedArgs, ColumnSpecification receiver) throws InvalidRequestException
+    public static Function get(String keyspace,
+                               FunctionName name,
+                               List<? extends AssignmentTestable> providedArgs,
+                               String receiverKs,
+                               String receiverCf)
+    throws InvalidRequestException
     {
-        List<Function.Factory> factories = declared.get(name.toLowerCase());
-        if (factories.isEmpty())
+        if (name.equals(TOKEN_FUNCTION_NAME))
+            return new TokenFct(Schema.instance.getCFMetaData(receiverKs, receiverCf));
+
+        List<Function> candidates = declared.get(name);
+        if (candidates.isEmpty())
             return null;
 
-        // Fast path if there is not choice
-        if (factories.size() == 1)
+        // Fast path if there is only one choice
+        if (candidates.size() == 1)
         {
-            Function fun = factories.get(0).create(receiver.ksName, receiver.cfName);
-            validateTypes(keyspace, fun, providedArgs, receiver);
+            Function fun = candidates.get(0);
+            validateTypes(keyspace, fun, providedArgs, receiverKs, receiverCf);
             return fun;
         }
 
-        Function candidate = null;
-        for (Function.Factory factory : factories)
+        List<Function> compatibles = null;
+        for (Function toTest : candidates)
         {
-            Function toTest = factory.create(receiver.ksName, receiver.cfName);
-            if (!isValidType(keyspace, toTest, providedArgs, receiver))
-                continue;
-
-            if (candidate == null)
-                candidate = toTest;
-            else
-                throw new InvalidRequestException(String.format("Ambiguous call to function %s (can match both type signature %s and %s): use type casts to disambiguate", name, signature(candidate), signature(toTest)));
+            AssignmentTestable.TestResult r = matchAguments(keyspace, toTest, providedArgs, receiverKs, receiverCf);
+            switch (r)
+            {
+                case EXACT_MATCH:
+                    // We always favor exact matches
+                    return toTest;
+                case WEAKLY_ASSIGNABLE:
+                    if (compatibles == null)
+                        compatibles = new ArrayList<>();
+                    compatibles.add(toTest);
+                    break;
+            }
         }
-        if (candidate == null)
-            throw new InvalidRequestException(String.format("Invalid call to function %s, none of its type signature matches (known type signatures: %s)", name, signatures(factories, receiver)));
-        return candidate;
+
+        if (compatibles == null || compatibles.isEmpty())
+            throw new InvalidRequestException(String.format("Invalid call to function %s, none of its type signatures match (known type signatures: %s)",
+                                                            name, toString(candidates)));
+
+        if (compatibles.size() > 1)
+            throw new InvalidRequestException(String.format("Ambiguous call to function %s (can be matched by following signatures: %s): use type casts to disambiguate",
+                        name, toString(compatibles)));
+
+        return compatibles.get(0);
+    }
+
+    public static List<Function> find(FunctionName name)
+    {
+        return declared.get(name);
     }
 
-    private static void validateTypes(String keyspace, Function fun, List<? extends AssignementTestable> providedArgs, ColumnSpecification receiver) throws InvalidRequestException
+    public static Function find(FunctionName name, List<AbstractType<?>> argTypes)
     {
-        if (!receiver.type.isValueCompatibleWith(fun.returnType()))
-            throw new InvalidRequestException(String.format("Type error: cannot assign result of function %s (type %s) to %s (type %s)", fun.name(), fun.returnType().asCQL3Type(), receiver, receiver.type.asCQL3Type()));
+        for (Function f : declared.get(name))
+        {
+            if (f.argTypes().equals(argTypes))
+                return f;
+        }
+        return null;
+    }
 
-        if (providedArgs.size() != fun.argsType().size())
-            throw new InvalidRequestException(String.format("Invalid number of arguments in call to function %s: %d required but %d provided", fun.name(), fun.argsType().size(), providedArgs.size()));
+    // This method and matchArguments are somewhat duplicate, but this method allows us to provide more precise errors in the common
+    // case where there is no override for a given function. This is thus probably worth the minor code duplication.
+    private static void validateTypes(String keyspace,
+                                      Function fun,
+                                      List<? extends AssignmentTestable> providedArgs,
+                                      String receiverKs,
+                                      String receiverCf)
+    throws InvalidRequestException
+    {
+        if (providedArgs.size() != fun.argTypes().size())
+            throw new InvalidRequestException(String.format("Invalid number of arguments in call to function %s: %d required but %d provided", fun.name(), fun.argTypes().size(), providedArgs.size()));
 
         for (int i = 0; i < providedArgs.size(); i++)
         {
-            AssignementTestable provided = providedArgs.get(i);
+            AssignmentTestable provided = providedArgs.get(i);
 
             // If the concrete argument is a bind variables, it can have any type.
             // We'll validate the actually provided value at execution time.
             if (provided == null)
                 continue;
 
-            ColumnSpecification expected = makeArgSpec(receiver, fun, i);
-            if (!provided.isAssignableTo(keyspace, expected))
+            ColumnSpecification expected = makeArgSpec(receiverKs, receiverCf, fun, i);
+            if (!provided.testAssignment(keyspace, expected).isAssignable())
                 throw new InvalidRequestException(String.format("Type error: %s cannot be passed as argument %d of function %s of type %s", provided, i, fun.name(), expected.type.asCQL3Type()));
         }
     }
 
-    private static boolean isValidType(String keyspace, Function fun, List<? extends AssignementTestable> providedArgs, ColumnSpecification receiver)
+    private static AssignmentTestable.TestResult matchAguments(String keyspace,
+                                                               Function fun,
+                                                               List<? extends AssignmentTestable> providedArgs,
+                                                               String receiverKs,
+                                                               String receiverCf)
     {
-        if (!receiver.type.isValueCompatibleWith(fun.returnType()))
-            return false;
-
-        if (providedArgs.size() != fun.argsType().size())
-            return false;
+        if (providedArgs.size() != fun.argTypes().size())
+            return AssignmentTestable.TestResult.NOT_ASSIGNABLE;
 
+        // It's an exact match if all are exact match, but is not assignable as soon as any is non assignable.
+        AssignmentTestable.TestResult res = AssignmentTestable.TestResult.EXACT_MATCH;
         for (int i = 0; i < providedArgs.size(); i++)
         {
-            AssignementTestable provided = providedArgs.get(i);
-
-            // If the concrete argument is a bind variables, it can have any type.
-            // We'll validate the actually provided value at execution time.
+            AssignmentTestable provided = providedArgs.get(i);
             if (provided == null)
+            {
+                res = AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;
                 continue;
-
-            ColumnSpecification expected = makeArgSpec(receiver, fun, i);
-            if (!provided.isAssignableTo(keyspace, expected))
-                return false;
+            }
+
+            ColumnSpecification expected = makeArgSpec(receiverKs, receiverCf, fun, i);
+            AssignmentTestable.TestResult argRes = provided.testAssignment(keyspace, expected);
+            if (argRes == AssignmentTestable.TestResult.NOT_ASSIGNABLE)
+                return AssignmentTestable.TestResult.NOT_ASSIGNABLE;
+            if (argRes == AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE)
+                res = AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;
         }
-        return true;
+        return res;
     }
 
-    private static String signature(Function fun)
+    private static String toString(List<Function> funs)
     {
-        List<AbstractType<?>> args = fun.argsType();
         StringBuilder sb = new StringBuilder();
-        sb.append("(");
-        for (int i = 0; i < args.size(); i++)
+        for (int i = 0; i < funs.size(); i++)
         {
             if (i > 0) sb.append(", ");
-            sb.append(args.get(i).asCQL3Type());
+            sb.append(funs.get(i));
         }
-        sb.append(") -> ");
-        sb.append(fun.returnType().asCQL3Type());
         return sb.toString();
     }
 
-    private static String signatures(List<Function.Factory> factories, ColumnSpecification receiver)
+    // This is *not* thread safe but is only called in DefsTables that is synchronized.
+    public static void addFunction(UDFunction fun)
     {
-        StringBuilder sb = new StringBuilder();
-        for (int i = 0; i < factories.size(); i++)
-        {
-            if (i > 0) sb.append(", ");
-            sb.append(signature(factories.get(i).create(receiver.ksName, receiver.cfName)));
-        }
-        return sb.toString();
+        // We shouldn't get there unless that function don't exist
+        assert find(fun.name(), fun.argTypes()) == null;
+        declare(fun);
+    }
+
+    // Same remarks than for addFunction
+    public static void removeFunction(FunctionName name, List<AbstractType<?>> argsTypes)
+    {
+        Function old = find(name, argsTypes);
+        assert old != null && !old.isNative();
+        declared.remove(old.name(), old);
+    }
+
+    // Same remarks than for addFunction
+    public static void replaceFunction(UDFunction fun)
+    {
+        removeFunction(fun.name(), fun.argTypes());
+        addFunction(fun);
     }
 }
diff --git a/src/java/org/apache/cassandra/cql3/AssignementTestable.java b/src/java/org/apache/cassandra/cql3/functions/NativeFunction.java
similarity index 50%
rename from src/java/org/apache/cassandra/cql3/AssignementTestable.java
rename to src/java/org/apache/cassandra/cql3/functions/NativeFunction.java
index 02b301318a..d658d9dd9e 100644
--- a/src/java/org/apache/cassandra/cql3/AssignementTestable.java
+++ b/src/java/org/apache/cassandra/cql3/functions/NativeFunction.java
@@ -15,12 +15,36 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.apache.cassandra.cql3;
+package org.apache.cassandra.cql3.functions;
 
-public interface AssignementTestable
+import java.util.Arrays;
+
+import org.apache.cassandra.db.marshal.AbstractType;
+
+/**
+ * Base class for our native/hardcoded functions.
+ */
+public abstract class NativeFunction extends AbstractFunction
 {
-    /**
-     * @return whether this object can be assigned to the provided receiver
-     */
-    public boolean isAssignableTo(String keyspace, ColumnSpecification receiver);
+    protected NativeFunction(String name, AbstractType<?> returnType, AbstractType<?>... argTypes)
+    {
+        this(new FunctionName(name), returnType, argTypes);
+    }
+
+    protected NativeFunction(FunctionName name, AbstractType<?> returnType, AbstractType<?>... argTypes)
+    {
+        super(name, Arrays.asList(argTypes), returnType);
+    }
+
+    // Most of our functions are pure, the other ones should override this
+    public boolean isPure()
+    {
+        return true;
+    }
+
+    public boolean isNative()
+    {
+        return true;
+    }
 }
+
diff --git a/src/java/org/apache/cassandra/cql3/functions/ReflectionBasedUDF.java b/src/java/org/apache/cassandra/cql3/functions/ReflectionBasedUDF.java
new file mode 100644
index 0000000000..68e388d9c9
--- /dev/null
+++ b/src/java/org/apache/cassandra/cql3/functions/ReflectionBasedUDF.java
@@ -0,0 +1,126 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.cassandra.cql3.functions;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.nio.ByteBuffer;
+import java.util.Arrays;
+import java.util.List;
+
+import org.apache.cassandra.cql3.*;
+import org.apache.cassandra.db.marshal.AbstractType;
+import org.apache.cassandra.exceptions.InvalidRequestException;
+
+/**
+ * User-defined function using a method in a class loaded on the classpath by
+ * reflection.
+ *
+ * This is used when the LANGUAGE of the UDF definition is "class".
+ */
+class ReflectionBasedUDF extends UDFunction
+{
+    public final Method method;
+
+    ReflectionBasedUDF(FunctionName name,
+                       List<ColumnIdentifier> argNames,
+                       List<AbstractType<?>> argTypes,
+                       AbstractType<?> returnType,
+                       String language,
+                       String body,
+                       boolean deterministic)
+    throws InvalidRequestException
+    {
+        super(name, argNames, argTypes, returnType, language, body, deterministic);
+        assert language.equals("class");
+        this.method = resolveClassMethod();
+    }
+
+    private Method resolveClassMethod() throws InvalidRequestException
+    {
+        Class<?> jReturnType = returnType.getSerializer().getType();
+        Class<?> paramTypes[] = new Class[argTypes.size()];
+        for (int i = 0; i < paramTypes.length; i++)
+            paramTypes[i] = argTypes.get(i).getSerializer().getType();
+
+        String className;
+        String methodName;
+        int i = body.indexOf('#');
+        if (i != -1)
+        {
+            methodName = body.substring(i + 1);
+            className = body.substring(0, i);
+        }
+        else
+        {
+            methodName = name.name;
+            className = body;
+        }
+        try
+        {
+            Class<?> cls = Class.forName(className, false, Thread.currentThread().getContextClassLoader());
+
+            Method method = cls.getMethod(methodName, paramTypes);
+
+            if (!Modifier.isStatic(method.getModifiers()))
+                throw new InvalidRequestException("Method " + className + '.' + methodName + '(' + Arrays.toString(paramTypes) + ") is not static");
+
+            if (!jReturnType.isAssignableFrom(method.getReturnType()))
+            {
+                throw new InvalidRequestException("Method " + className + '.' + methodName + '(' + Arrays.toString(paramTypes) + ") " +
+                                                  "has incompatible return type " + method.getReturnType() + " (not assignable to " + jReturnType + ')');
+            }
+
+            return method;
+        }
+        catch (ClassNotFoundException e)
+        {
+            throw new InvalidRequestException("Class " + className + " does not exist");
+        }
+        catch (NoSuchMethodException e)
+        {
+            throw new InvalidRequestException("Method " + className + '.' + methodName + '(' + Arrays.toString(paramTypes) + ") does not exist");
+        }
+    }
+
+    public ByteBuffer execute(List<ByteBuffer> parameters) throws InvalidRequestException
+    {
+        Object[] parms = new Object[argTypes.size()];
+        for (int i = 0; i < parms.length; i++)
+        {
+            ByteBuffer bb = parameters.get(i);
+            if (bb != null)
+                parms[i] = argTypes.get(i).compose(bb);
+        }
+
+        Object result;
+        try
+        {
+            result = method.invoke(null, parms);
+            @SuppressWarnings("unchecked") ByteBuffer r = result != null ? ((AbstractType) returnType).decompose(result) : null;
+            return r;
+        }
+        catch (InvocationTargetException | IllegalAccessException e)
+        {
+            Throwable c = e.getCause();
+            logger.error("Invocation of function {} failed", name, c);
+            throw new InvalidRequestException("Invocation of function " + name + " failed: " + c);
+        }
+    }
+}
diff --git a/src/java/org/apache/cassandra/cql3/functions/TimeuuidFcts.java b/src/java/org/apache/cassandra/cql3/functions/TimeuuidFcts.java
index be20102f48..9b7bbf0673 100644
--- a/src/java/org/apache/cassandra/cql3/functions/TimeuuidFcts.java
+++ b/src/java/org/apache/cassandra/cql3/functions/TimeuuidFcts.java
@@ -29,7 +29,7 @@ import org.apache.cassandra.utils.UUIDGen;
 
 public abstract class TimeuuidFcts
 {
-    public static final Function nowFct = new AbstractFunction("now", TimeUUIDType.instance)
+    public static final Function nowFct = new NativeFunction("now", TimeUUIDType.instance)
     {
         public ByteBuffer execute(List<ByteBuffer> parameters)
         {
@@ -43,7 +43,7 @@ public abstract class TimeuuidFcts
         }
     };
 
-    public static final Function minTimeuuidFct = new AbstractFunction("mintimeuuid", TimeUUIDType.instance, TimestampType.instance)
+    public static final Function minTimeuuidFct = new NativeFunction("mintimeuuid", TimeUUIDType.instance, TimestampType.instance)
     {
         public ByteBuffer execute(List<ByteBuffer> parameters)
         {
@@ -55,7 +55,7 @@ public abstract class TimeuuidFcts
         }
     };
 
-    public static final Function maxTimeuuidFct = new AbstractFunction("maxtimeuuid", TimeUUIDType.instance, TimestampType.instance)
+    public static final Function maxTimeuuidFct = new NativeFunction("maxtimeuuid", TimeUUIDType.instance, TimestampType.instance)
     {
         public ByteBuffer execute(List<ByteBuffer> parameters)
         {
@@ -67,7 +67,7 @@ public abstract class TimeuuidFcts
         }
     };
 
-    public static final Function dateOfFct = new AbstractFunction("dateof", TimestampType.instance, TimeUUIDType.instance)
+    public static final Function dateOfFct = new NativeFunction("dateof", TimestampType.instance, TimeUUIDType.instance)
     {
         public ByteBuffer execute(List<ByteBuffer> parameters)
         {
@@ -79,7 +79,7 @@ public abstract class TimeuuidFcts
         }
     };
 
-    public static final Function unixTimestampOfFct = new AbstractFunction("unixtimestampof", LongType.instance, TimeUUIDType.instance)
+    public static final Function unixTimestampOfFct = new NativeFunction("unixtimestampof", LongType.instance, TimeUUIDType.instance)
     {
         public ByteBuffer execute(List<ByteBuffer> parameters)
         {
diff --git a/src/java/org/apache/cassandra/cql3/functions/TokenFct.java b/src/java/org/apache/cassandra/cql3/functions/TokenFct.java
index 5093a72739..2504a66752 100644
--- a/src/java/org/apache/cassandra/cql3/functions/TokenFct.java
+++ b/src/java/org/apache/cassandra/cql3/functions/TokenFct.java
@@ -22,26 +22,17 @@ import java.util.List;
 
 import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.config.ColumnDefinition;
-import org.apache.cassandra.config.Schema;
 import org.apache.cassandra.db.composites.CBuilder;
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.dht.IPartitioner;
 import org.apache.cassandra.exceptions.InvalidRequestException;
 import org.apache.cassandra.service.StorageService;
 
-public class TokenFct extends AbstractFunction
+public class TokenFct extends NativeFunction
 {
     // The actual token function depends on the partitioner used
     private static final IPartitioner partitioner = StorageService.getPartitioner();
 
-    public static final Function.Factory factory = new Function.Factory()
-    {
-        public Function create(String ksName, String cfName)
-        {
-            return new TokenFct(Schema.instance.getCFMetaData(ksName, cfName));
-        }
-    };
-
     private final CFMetaData cfm;
 
     public TokenFct(CFMetaData cfm)
diff --git a/src/java/org/apache/cassandra/cql3/functions/UDFunction.java b/src/java/org/apache/cassandra/cql3/functions/UDFunction.java
new file mode 100644
index 0000000000..558fb72a53
--- /dev/null
+++ b/src/java/org/apache/cassandra/cql3/functions/UDFunction.java
@@ -0,0 +1,250 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.cassandra.cql3.functions;
+
+import java.nio.ByteBuffer;
+import java.nio.charset.StandardCharsets;
+import java.security.MessageDigest;
+import java.util.*;
+
+import com.google.common.base.Objects;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import org.apache.cassandra.config.CFMetaData;
+import org.apache.cassandra.cql3.*;
+import org.apache.cassandra.db.*;
+import org.apache.cassandra.db.composites.Composite;
+import org.apache.cassandra.db.marshal.AbstractType;
+import org.apache.cassandra.db.marshal.CompositeType;
+import org.apache.cassandra.db.marshal.UTF8Type;
+import org.apache.cassandra.db.marshal.TypeParser;
+import org.apache.cassandra.exceptions.*;
+import org.apache.cassandra.utils.FBUtilities;
+
+/**
+ * Base class for User Defined Functions.
+ */
+public abstract class UDFunction extends AbstractFunction
+{
+    protected static final Logger logger = LoggerFactory.getLogger(UDFunction.class);
+
+    protected final List<ColumnIdentifier> argNames;
+
+    protected final String language;
+    protected final String body;
+    private final boolean deterministic;
+
+    protected UDFunction(FunctionName name,
+                         List<ColumnIdentifier> argNames,
+                         List<AbstractType<?>> argTypes,
+                         AbstractType<?> returnType,
+                         String language,
+                         String body,
+                         boolean deterministic)
+    {
+        super(name, argTypes, returnType);
+        this.argNames = argNames;
+        this.language = language;
+        this.body = body;
+        this.deterministic = deterministic;
+    }
+
+    public static UDFunction create(FunctionName name,
+                                    List<ColumnIdentifier> argNames,
+                                    List<AbstractType<?>> argTypes,
+                                    AbstractType<?> returnType,
+                                    String language,
+                                    String body,
+                                    boolean deterministic)
+    throws InvalidRequestException
+    {
+        switch (language)
+        {
+            case "class": return new ReflectionBasedUDF(name, argNames, argTypes, returnType, language, body, deterministic);
+            default: throw new InvalidRequestException(String.format("Invalid language %s for '%s'", language, name));
+        }
+    }
+
+    /**
+     * It can happen that a function has been declared (is listed in the scheam) but cannot
+     * be loaded (maybe only on some nodes). This is the case for instance if the class defining
+     * the class is not on the classpath for some of the node, or after a restart. In that case,
+     * we create a "fake" function so that:
+     *  1) the broken function can be dropped easily if that is what people want to do.
+     *  2) we return a meaningful error message if the function is executed (something more precise
+     *     than saying that the function doesn't exist)
+     */
+    private static UDFunction createBrokenFunction(FunctionName name,
+                                                  List<ColumnIdentifier> argNames,
+                                                  List<AbstractType<?>> argTypes,
+                                                  AbstractType<?> returnType,
+                                                  String language,
+                                                  String body,
+                                                  final InvalidRequestException reason)
+    {
+        return new UDFunction(name, argNames, argTypes, returnType, language, body, true)
+        {
+            public ByteBuffer execute(List<ByteBuffer> parameters) throws InvalidRequestException
+            {
+                throw new InvalidRequestException(String.format("Function '%s' exists but hasn't been loaded successfully for the following reason: %s. "
+                                                              + "Please see the server log for more details", this, reason.getMessage()));
+            }
+        };
+    }
+
+    // We allow method overloads, so a function is not uniquely identified by its name only, but
+    // also by its argument types. To distinguish overloads of given function name in the schema 
+    // we use a "signature" which is just a SHA-1 of it's argument types (we could replace that by
+    // using a "signature" UDT that would be comprised of the function name and argument types,
+    // which we could then use as clustering column. But as we haven't yet used UDT in system tables,
+    // We'll left that decision to #6717).
+    private static ByteBuffer computeSignature(List<AbstractType<?>> argTypes)
+    {
+        MessageDigest digest = FBUtilities.newMessageDigest("SHA-1");
+        for (AbstractType<?> type : argTypes)
+            digest.update(type.toString().getBytes(StandardCharsets.UTF_8));
+        return ByteBuffer.wrap(digest.digest());
+    }
+
+    public boolean isPure()
+    {
+        return deterministic;
+    }
+
+    public boolean isNative()
+    {
+        return false;
+    }
+
+    private static Mutation makeSchemaMutation(FunctionName name)
+    {
+        CompositeType kv = (CompositeType)CFMetaData.SchemaFunctionsCf.getKeyValidator();
+        return new Mutation(Keyspace.SYSTEM_KS, kv.decompose(name.namespace, name.name));
+    }
+
+    // TODO: we should allow removing just one function, not all functions having a given name
+    public static Mutation dropFromSchema(long timestamp, FunctionName fun)
+    {
+        Mutation mutation = makeSchemaMutation(fun);
+        mutation.delete(SystemKeyspace.SCHEMA_FUNCTIONS_CF, timestamp);
+        return mutation;
+    }
+
+    public Mutation toSchemaUpdate(long timestamp)
+    {
+        Mutation mutation = makeSchemaMutation(name);
+        ColumnFamily cf = mutation.addOrGet(SystemKeyspace.SCHEMA_FUNCTIONS_CF);
+
+        Composite prefix = CFMetaData.SchemaFunctionsCf.comparator.make(computeSignature(argTypes));
+        CFRowAdder adder = new CFRowAdder(cf, prefix, timestamp);
+
+        adder.resetCollection("argument_names");
+        adder.resetCollection("argument_types");
+        adder.add("return_type", returnType.toString());
+        adder.add("language", language);
+        adder.add("body", body);
+        adder.add("deterministic", deterministic);
+
+        for (int i = 0; i < argNames.size(); i++)
+        {
+            adder.addListEntry("argument_names", argNames.get(i).bytes);
+            adder.addListEntry("argument_types", argTypes.get(i).toString());
+        }
+
+        return mutation;
+    }
+
+    public static UDFunction fromSchema(UntypedResultSet.Row row)
+    {
+        String namespace = row.getString("namespace");
+        String fname = row.getString("name");
+        FunctionName name = new FunctionName(namespace, fname);
+
+        List<String> names = row.getList("argument_names", UTF8Type.instance);
+        List<String> types = row.getList("argument_types", UTF8Type.instance);
+
+        List<ColumnIdentifier> argNames = new ArrayList<>(names.size());
+        for (String arg : names)
+            argNames.add(new ColumnIdentifier(arg, true));
+
+        List<AbstractType<?>> argTypes = new ArrayList<>(types.size());
+        for (String type : types)
+            argTypes.add(parseType(type));
+
+        AbstractType<?> returnType = parseType(row.getString("return_type"));
+
+        boolean deterministic = row.getBoolean("deterministic");
+        String language = row.getString("language");
+        String body = row.getString("body");
+
+        try
+        {
+            return create(name, argNames, argTypes, returnType, language, body, deterministic);
+        }
+        catch (InvalidRequestException e)
+        {
+            logger.error(String.format("Cannot load function '%s' from schema: this function won't be available (on this node)", name), e);
+            return createBrokenFunction(name, argNames, argTypes, returnType, language, body, e);
+        }
+    }
+
+    private static AbstractType<?> parseType(String str)
+    {
+        // We only use this when reading the schema where we shouldn't get an error
+        try
+        {
+            return TypeParser.parse(str);
+        }
+        catch (SyntaxException | ConfigurationException e)
+        {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public static Map<ByteBuffer, UDFunction> fromSchema(Row row)
+    {
+        UntypedResultSet results = QueryProcessor.resultify("SELECT * FROM system." + SystemKeyspace.SCHEMA_FUNCTIONS_CF, row);
+        Map<ByteBuffer, UDFunction> udfs = new HashMap<>(results.size());
+        for (UntypedResultSet.Row result : results)
+            udfs.put(result.getBlob("signature"), fromSchema(result));
+        return udfs;
+    }
+
+    @Override
+    public boolean equals(Object o)
+    {
+        if (!(o instanceof UDFunction))
+            return false;
+
+        UDFunction that = (UDFunction)o;
+        return Objects.equal(this.name, that.name)
+            && Objects.equal(this.argNames, that.argNames)
+            && Objects.equal(this.argTypes, that.argTypes)
+            && Objects.equal(this.returnType, that.returnType)
+            && Objects.equal(this.language, that.language)
+            && Objects.equal(this.body, that.body)
+            && Objects.equal(this.deterministic, that.deterministic);
+    }
+
+    @Override
+    public int hashCode()
+    {
+        return Objects.hashCode(name, argNames, argTypes, returnType, language, body, deterministic);
+    }
+}
diff --git a/src/java/org/apache/cassandra/cql3/functions/UuidFcts.java b/src/java/org/apache/cassandra/cql3/functions/UuidFcts.java
index 718bcbc1a5..1bf4c17176 100644
--- a/src/java/org/apache/cassandra/cql3/functions/UuidFcts.java
+++ b/src/java/org/apache/cassandra/cql3/functions/UuidFcts.java
@@ -26,7 +26,7 @@ import org.apache.cassandra.serializers.UUIDSerializer;
 
 public abstract class UuidFcts
 {
-    public static final Function uuidFct = new AbstractFunction("uuid", UUIDType.instance)
+    public static final Function uuidFct = new NativeFunction("uuid", UUIDType.instance)
     {
         public ByteBuffer execute(List<ByteBuffer> parameters)
         {
diff --git a/src/java/org/apache/cassandra/cql3/statements/CreateFunctionStatement.java b/src/java/org/apache/cassandra/cql3/statements/CreateFunctionStatement.java
index 47bacd21a4..a54409e0a2 100644
--- a/src/java/org/apache/cassandra/cql3/statements/CreateFunctionStatement.java
+++ b/src/java/org/apache/cassandra/cql3/statements/CreateFunctionStatement.java
@@ -21,57 +21,50 @@ import java.util.ArrayList;
 import java.util.List;
 
 import org.apache.cassandra.auth.Permission;
-import org.apache.cassandra.config.Schema;
-import org.apache.cassandra.config.UFMetaData;
 import org.apache.cassandra.cql3.CQL3Type;
 import org.apache.cassandra.cql3.ColumnIdentifier;
-import org.apache.cassandra.cql3.QueryOptions;
-import org.apache.cassandra.cql3.functions.Functions;
-import org.apache.cassandra.cql3.udf.UDFRegistry;
+import org.apache.cassandra.cql3.functions.*;
+import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.exceptions.InvalidRequestException;
 import org.apache.cassandra.exceptions.RequestValidationException;
 import org.apache.cassandra.exceptions.UnauthorizedException;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
-import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.transport.Event;
-import org.apache.cassandra.transport.messages.ResultMessage;
 
 /**
  * A <code>CREATE FUNCTION</code> statement parsed from a CQL query.
  */
 public final class CreateFunctionStatement extends SchemaAlteringStatement
 {
-    final boolean orReplace;
-    final boolean ifNotExists;
-    final String namespace;
-    final String functionName;
-    final String qualifiedName;
-    final String language;
-    final String body;
-    final boolean deterministic;
-    final CQL3Type.Raw returnType;
-    final List<Argument> arguments;
-
-    private UFMetaData ufMeta;
-
-    public CreateFunctionStatement(String namespace, String functionName, String language, String body, boolean deterministic,
-                                   CQL3Type.Raw returnType, List<Argument> arguments, boolean orReplace, boolean ifNotExists)
+    private final boolean orReplace;
+    private final boolean ifNotExists;
+    private final FunctionName functionName;
+    private final String language;
+    private final String body;
+    private final boolean deterministic;
+
+    private final List<ColumnIdentifier> argNames;
+    private final List<CQL3Type.Raw> argRawTypes;
+    private final CQL3Type.Raw rawReturnType;
+
+    public CreateFunctionStatement(FunctionName functionName,
+                                   String language,
+                                   String body,
+                                   boolean deterministic,
+                                   List<ColumnIdentifier> argNames,
+                                   List<CQL3Type.Raw> argRawTypes,
+                                   CQL3Type.Raw rawReturnType,
+                                   boolean orReplace,
+                                   boolean ifNotExists)
     {
-        super();
-        this.namespace = namespace != null ? namespace : "";
         this.functionName = functionName;
-        this.qualifiedName = UFMetaData.qualifiedName(namespace, functionName);
         this.language = language;
         this.body = body;
         this.deterministic = deterministic;
-        this.returnType = returnType;
-        this.arguments = arguments;
-        assert functionName != null : "null function name";
-        assert language != null : "null function language";
-        assert body != null : "null function body";
-        assert returnType != null : "null function returnType";
-        assert arguments != null : "null function arguments";
+        this.argNames = argNames;
+        this.argRawTypes = argRawTypes;
+        this.rawReturnType = rawReturnType;
         this.orReplace = orReplace;
         this.ifNotExists = ifNotExists;
     }
@@ -83,23 +76,10 @@ public final class CreateFunctionStatement extends SchemaAlteringStatement
         state.hasAllKeyspacesAccess(Permission.CREATE);
     }
 
-    /**
-     * The <code>CqlParser</code> only goes as far as extracting the keyword arguments
-     * from these statements, so this method is responsible for processing and
-     * validating.
-     *
-     * @throws org.apache.cassandra.exceptions.InvalidRequestException if arguments are missing or unacceptable
-     */
-    public void validate(ClientState state) throws RequestValidationException
+    public void validate(ClientState state) throws InvalidRequestException
     {
-        if (!namespace.isEmpty() && !namespace.matches("\\w+"))
-            throw new InvalidRequestException(String.format("\"%s\" is not a valid function name", qualifiedName));
-        if (!functionName.matches("\\w+"))
-            throw new InvalidRequestException(String.format("\"%s\" is not a valid function name", qualifiedName));
-        if (namespace.length() > Schema.NAME_LENGTH)
-            throw new InvalidRequestException(String.format("UDF namespace names shouldn't be more than %s characters long (got \"%s\")", Schema.NAME_LENGTH, qualifiedName));
-        if (functionName.length() > Schema.NAME_LENGTH)
-            throw new InvalidRequestException(String.format("UDF function names shouldn't be more than %s characters long (got \"%s\")", Schema.NAME_LENGTH, qualifiedName));
+        if (ifNotExists && orReplace)
+            throw new InvalidRequestException("Cannot use both 'OR REPLACE' and 'IF NOT EXISTS' directives");
     }
 
     public Event.SchemaChange changeEvent()
@@ -107,75 +87,34 @@ public final class CreateFunctionStatement extends SchemaAlteringStatement
         return null;
     }
 
-    public ResultMessage executeInternal(QueryState state, QueryOptions options)
-    {
-        try
-        {
-            doExecute();
-            return super.executeInternal(state, options);
-        }
-        catch (RequestValidationException e)
-        {
-            throw new RuntimeException(e);
-        }
-    }
-
-    public ResultMessage execute(QueryState state, QueryOptions options) throws RequestValidationException
-    {
-        doExecute();
-        return super.execute(state, options);
-    }
-
-    private void doExecute() throws RequestValidationException
-    {
-        boolean exists = UDFRegistry.hasFunction(qualifiedName);
-        if (exists && ifNotExists)
-            throw new InvalidRequestException(String.format("Function '%s' already exists.", qualifiedName));
-        if (exists && !orReplace)
-            throw new InvalidRequestException(String.format("Function '%s' already exists.", qualifiedName));
-
-        if (namespace.isEmpty() && Functions.contains(functionName))
-            throw new InvalidRequestException(String.format("Function name '%s' is reserved by CQL.", qualifiedName));
-
-        List<Argument> args = arguments;
-        List<String> argumentNames = new ArrayList<>(args.size());
-        List<String> argumentTypes = new ArrayList<>(args.size());
-        for (Argument arg : args)
-        {
-            argumentNames.add(arg.getName().toString());
-            argumentTypes.add(arg.getType().toString());
-        }
-        this.ufMeta = new UFMetaData(namespace, functionName, deterministic, argumentNames, argumentTypes,
-                                     returnType.toString(), language, body);
-
-        UDFRegistry.tryCreateFunction(ufMeta);
-    }
-
     public boolean announceMigration(boolean isLocalOnly) throws RequestValidationException
     {
-        MigrationManager.announceNewFunction(ufMeta, isLocalOnly);
-        return true;
-    }
-
-    public static final class Argument
-    {
-        final ColumnIdentifier name;
-        final CQL3Type.Raw type;
+        List<AbstractType<?>> argTypes = new ArrayList<>(argRawTypes.size());
+        for (CQL3Type.Raw rawType : argRawTypes)
+            // We have no proper keyspace to give, which means that this will break (NPE currently)
+            // for UDT: #7791 is open to fix this
+            argTypes.add(rawType.prepare(null).getType());
 
-        public Argument(ColumnIdentifier name, CQL3Type.Raw type)
-        {
-            this.name = name;
-            this.type = type;
-        }
+        AbstractType<?> returnType = rawReturnType.prepare(null).getType();
 
-        public ColumnIdentifier getName()
+        Function old = Functions.find(functionName, argTypes);
+        if (old != null)
         {
-            return name;
+            if (ifNotExists)
+                return false;
+            if (!orReplace)
+                throw new InvalidRequestException(String.format("Function %s already exists", old));
+
+            // Means we're replacing the function. We still need to validate that 1) it's not a native function and 2) that the return type
+            // matches (or that could break existing code badly)
+            if (old.isNative())
+                throw new InvalidRequestException(String.format("Cannot replace native function %s", old));
+            if (!old.returnType().isValueCompatibleWith(returnType))
+                throw new InvalidRequestException(String.format("Cannot replace function %s, the new return type %s is not compatible with the return type %s of existing function",
+                                                                functionName, returnType.asCQL3Type(), old.returnType().asCQL3Type()));
         }
 
-        public CQL3Type.Raw getType()
-        {
-            return type;
-        }
+        MigrationManager.announceNewFunction(UDFunction.create(functionName, argNames, argTypes, returnType, language, body, deterministic), isLocalOnly);
+        return true;
     }
 }
diff --git a/src/java/org/apache/cassandra/cql3/statements/DropFunctionStatement.java b/src/java/org/apache/cassandra/cql3/statements/DropFunctionStatement.java
index 159f385ac6..4c963a8000 100644
--- a/src/java/org/apache/cassandra/cql3/statements/DropFunctionStatement.java
+++ b/src/java/org/apache/cassandra/cql3/statements/DropFunctionStatement.java
@@ -17,9 +17,10 @@
  */
 package org.apache.cassandra.cql3.statements;
 
+import java.util.List;
+
 import org.apache.cassandra.auth.Permission;
-import org.apache.cassandra.config.Schema;
-import org.apache.cassandra.config.UFMetaData;
+import org.apache.cassandra.cql3.functions.*;
 import org.apache.cassandra.exceptions.InvalidRequestException;
 import org.apache.cassandra.exceptions.RequestValidationException;
 import org.apache.cassandra.exceptions.UnauthorizedException;
@@ -32,17 +33,12 @@ import org.apache.cassandra.transport.Event;
  */
 public final class DropFunctionStatement extends SchemaAlteringStatement
 {
-    private final String namespace;
-    private final String functionName;
-    private final String qualifiedName;
+    private final FunctionName functionName;
     private final boolean ifExists;
 
-    public DropFunctionStatement(String namespace, String functionName, boolean ifExists)
+    public DropFunctionStatement(FunctionName functionName, boolean ifExists)
     {
-        super();
-        this.namespace = namespace == null ? "" : namespace;
         this.functionName = functionName;
-        this.qualifiedName = UFMetaData.qualifiedName(namespace, functionName);
         this.ifExists = ifExists;
     }
 
@@ -62,14 +58,6 @@ public final class DropFunctionStatement extends SchemaAlteringStatement
      */
     public void validate(ClientState state) throws RequestValidationException
     {
-        if (!namespace.isEmpty() && !namespace.matches("\\w+"))
-            throw new InvalidRequestException(String.format("\"%s\" is not a valid function name", qualifiedName));
-        if (!functionName.matches("\\w+"))
-            throw new InvalidRequestException(String.format("\"%s\" is not a valid function name", qualifiedName));
-        if (namespace.length() > Schema.NAME_LENGTH)
-            throw new InvalidRequestException(String.format("UDF namespace names shouldn't be more than %s characters long (got \"%s\")", Schema.NAME_LENGTH, qualifiedName));
-        if (functionName.length() > Schema.NAME_LENGTH)
-            throw new InvalidRequestException(String.format("UDF function names shouldn't be more than %s characters long (got \"%s\")", Schema.NAME_LENGTH, qualifiedName));
     }
 
     public Event.SchemaChange changeEvent()
@@ -77,20 +65,21 @@ public final class DropFunctionStatement extends SchemaAlteringStatement
         return null;
     }
 
-    // no execute() - drop propagated via MigrationManager
-
     public boolean announceMigration(boolean isLocalOnly) throws RequestValidationException
     {
-        try
-        {
-            MigrationManager.announceFunctionDrop(namespace, functionName, isLocalOnly);
-            return true;
-        }
-        catch (InvalidRequestException e)
+        List<Function> olds = Functions.find(functionName);
+        if (olds == null || olds.isEmpty())
         {
             if (ifExists)
                 return false;
-            throw e;
+            throw new InvalidRequestException(String.format("Cannot drop non existing function '%s'", functionName));
         }
+
+        for (Function f : olds)
+            if (f.isNative())
+                throw new InvalidRequestException(String.format("Cannot drop function '%s' because it has native overloads", functionName));
+
+        MigrationManager.announceFunctionDrop(functionName, isLocalOnly);
+        return true;
     }
 }
diff --git a/src/java/org/apache/cassandra/cql3/statements/Selectable.java b/src/java/org/apache/cassandra/cql3/statements/Selectable.java
index ab0a5a3cfa..be47d17f84 100644
--- a/src/java/org/apache/cassandra/cql3/statements/Selectable.java
+++ b/src/java/org/apache/cassandra/cql3/statements/Selectable.java
@@ -21,6 +21,7 @@ package org.apache.cassandra.cql3.statements;
 import java.util.List;
 
 import org.apache.cassandra.cql3.ColumnIdentifier;
+import org.apache.cassandra.cql3.functions.FunctionName;
 
 public interface Selectable
 {
@@ -44,13 +45,11 @@ public interface Selectable
 
     public static class WithFunction implements Selectable
     {
-        public final String namespace;
-        public final String functionName;
+        public final FunctionName functionName;
         public final List<Selectable> args;
 
-        public WithFunction(String namespace, String functionName, List<Selectable> args)
+        public WithFunction(FunctionName functionName, List<Selectable> args)
         {
-            this.namespace = namespace;
             this.functionName = functionName;
             this.args = args;
         }
@@ -59,8 +58,6 @@ public interface Selectable
         public String toString()
         {
             StringBuilder sb = new StringBuilder();
-            if (!namespace.isEmpty())
-                sb.append(namespace).append("::");
             sb.append(functionName).append("(");
             for (int i = 0; i < args.size(); i++)
             {
diff --git a/src/java/org/apache/cassandra/cql3/statements/Selection.java b/src/java/org/apache/cassandra/cql3/statements/Selection.java
index 325ef15601..20211b281c 100644
--- a/src/java/org/apache/cassandra/cql3/statements/Selection.java
+++ b/src/java/org/apache/cassandra/cql3/statements/Selection.java
@@ -29,8 +29,6 @@ import org.apache.cassandra.cql3.functions.Function;
 import org.apache.cassandra.cql3.functions.Functions;
 import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.config.ColumnDefinition;
-import org.apache.cassandra.cql3.udf.UDFunction;
-import org.apache.cassandra.cql3.udf.UDFRegistry;
 import org.apache.cassandra.db.Cell;
 import org.apache.cassandra.db.CounterCell;
 import org.apache.cassandra.db.ExpiringCell;
@@ -163,25 +161,11 @@ public abstract class Selection
                 args.add(makeSelector(cfm, new RawSelector(rawArg, null), defs, null));
 
             // resolve built-in functions before user defined functions
-            AbstractType<?> returnType = Functions.getReturnType(withFun.functionName, cfm.ksName, cfm.cfName);
-            if (returnType == null)
-            {
-                UDFunction userFun = UDFRegistry.resolveFunction(withFun.namespace, withFun.functionName, cfm.ksName, cfm.cfName, args);
-                if (userFun != null)
-                {
-                    // got a user defined function to call
-                    Function fun = userFun.create(args);
-                    ColumnSpecification spec = makeFunctionSpec(cfm, withFun, fun.returnType(), raw.alias);
-                    if (metadata != null)
-                        metadata.add(spec);
-                    return new FunctionSelector(userFun.create(args), args);
-                }
-                throw new InvalidRequestException(String.format("Unknown function '%s'", withFun.namespace.isEmpty() ? withFun.functionName : withFun.namespace + "::" + withFun.functionName));
-            }
-            ColumnSpecification spec = makeFunctionSpec(cfm, withFun, returnType, raw.alias);
-            Function fun = Functions.get(cfm.ksName, withFun.functionName, args, spec);
+            Function fun = Functions.get(cfm.ksName, withFun.functionName, args, cfm.ksName, cfm.cfName);
+            if (fun == null)
+                throw new InvalidRequestException(String.format("Unknown function '%s'", withFun.functionName));
             if (metadata != null)
-                metadata.add(spec);
+                metadata.add(makeFunctionSpec(cfm, withFun, fun.returnType(), raw.alias));
             return new FunctionSelector(fun, args);
         }
     }
@@ -208,7 +192,7 @@ public abstract class Selection
                                                         ColumnIdentifier alias) throws InvalidRequestException
     {
         if (returnType == null)
-            throw new InvalidRequestException(String.format("Unknown function %s called in selection clause", fun.namespace.isEmpty() ? fun.functionName : fun.namespace +"::"+fun.functionName));
+            throw new InvalidRequestException(String.format("Unknown function %s called in selection clause", fun.functionName));
 
         return new ColumnSpecification(cfm.ksName,
                                        cfm.cfName,
@@ -385,14 +369,19 @@ public abstract class Selection
         }
     }
 
-    private static abstract class Selector implements AssignementTestable
+    private static abstract class Selector implements AssignmentTestable
     {
         public abstract ByteBuffer compute(ResultSetBuilder rs) throws InvalidRequestException;
         public abstract AbstractType<?> getType();
 
-        public boolean isAssignableTo(String keyspace, ColumnSpecification receiver)
+        public AssignmentTestable.TestResult testAssignment(String keyspace, ColumnSpecification receiver)
         {
-            return receiver.type.isValueCompatibleWith(getType());
+            if (receiver.type.equals(getType()))
+                return AssignmentTestable.TestResult.EXACT_MATCH;
+            else if (receiver.type.isValueCompatibleWith(getType()))
+                return AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;
+            else
+                return AssignmentTestable.TestResult.NOT_ASSIGNABLE;
         }
     }
 
diff --git a/src/java/org/apache/cassandra/cql3/udf/UDFFunctionOverloads.java b/src/java/org/apache/cassandra/cql3/udf/UDFFunctionOverloads.java
deleted file mode 100644
index aa6892a70c..0000000000
--- a/src/java/org/apache/cassandra/cql3/udf/UDFFunctionOverloads.java
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.cassandra.cql3.udf;
-
-import java.util.Collection;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
-
-import org.apache.cassandra.config.UFMetaData;
-import org.apache.cassandra.cql3.AssignementTestable;
-import org.apache.cassandra.exceptions.InvalidRequestException;
-
-public final class UDFFunctionOverloads
-{
-    final Map<String, UFMetaData> signatureMap = new ConcurrentHashMap<>();
-    final Map<String, UDFunction> udfInstances = new ConcurrentHashMap<>();
-
-    public void addAndInit(UFMetaData uf, boolean addIfInvalid)
-    {
-        try
-        {
-            UDFunction UDFunction = new UDFunction(uf);
-            udfInstances.put(uf.signature, UDFunction);
-        }
-        catch (InvalidRequestException e)
-        {
-            uf.invalid = e;
-        }
-
-        if (uf.invalid == null || addIfInvalid)
-            signatureMap.put(uf.signature, uf);
-    }
-
-    public void remove(UFMetaData uf)
-    {
-        signatureMap.remove(uf.signature);
-        udfInstances.remove(uf.signature);
-    }
-
-    public Collection<UFMetaData> values()
-    {
-        return signatureMap.values();
-    }
-
-    public boolean isEmpty()
-    {
-        return signatureMap.isEmpty();
-    }
-
-    public UDFunction resolveFunction(String ksName, String cfName, List<? extends AssignementTestable> args)
-    throws InvalidRequestException
-    {
-        for (UFMetaData candidate : signatureMap.values())
-        {
-            // Currently the UDF implementation must use concrete types (like Double, Integer) instead of base types (like Number).
-            // To support handling of base types it is necessary to construct new, temporary instances of UDFFunction with the
-            // signature for the current request in UDFFunction#argsType + UDFFunction#returnType.
-            // Additionally we need the requested return type (AssignementTestable) has a parameter for this method.
-            if (candidate.compatibleArgs(ksName, cfName, args))
-            {
-
-                // TODO CASSANDRA-7557 (specific per-function EXECUTE permission ??)
-
-                if (candidate.invalid != null)
-                    throw new InvalidRequestException(candidate.invalid.getMessage());
-                return udfInstances.get(candidate.signature);
-            }
-        }
-        return null;
-    }
-}
diff --git a/src/java/org/apache/cassandra/cql3/udf/UDFRegistry.java b/src/java/org/apache/cassandra/cql3/udf/UDFRegistry.java
deleted file mode 100644
index cb3f1a1512..0000000000
--- a/src/java/org/apache/cassandra/cql3/udf/UDFRegistry.java
+++ /dev/null
@@ -1,146 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.cassandra.cql3.udf;
-
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import org.apache.cassandra.config.UFMetaData;
-import org.apache.cassandra.cql3.AssignementTestable;
-import org.apache.cassandra.cql3.QueryProcessor;
-import org.apache.cassandra.cql3.UntypedResultSet;
-import org.apache.cassandra.cql3.functions.Functions;
-import org.apache.cassandra.db.Keyspace;
-import org.apache.cassandra.db.SystemKeyspace;
-import org.apache.cassandra.exceptions.InvalidRequestException;
-
-/**
- * Central registry for user defined functions (CASSANDRA-7395).
- * <p/>
- * UDFs are maintained in {@code system.schema_functions} table and distributed to all nodes.
- * <p/>
- * UDFs are not maintained in {@link org.apache.cassandra.cql3.functions.Functions} class to have a strict
- * distinction between 'core CQL' functions provided by Cassandra and functions provided by the user.
- * 'Core CQL' functions have precedence over UDFs.
- */
-public class UDFRegistry
-{
-    private static final Logger logger = LoggerFactory.getLogger(UDFRegistry.class);
-
-    static final String SELECT_CQL = "SELECT namespace, name, signature, deterministic, argument_names, argument_types, " +
-                                     "return_type, language, body FROM " +
-                                     Keyspace.SYSTEM_KS + '.' + SystemKeyspace.SCHEMA_FUNCTIONS_CF;
-
-    private static final Map<String, UDFFunctionOverloads> functions = new ConcurrentHashMap<>();
-
-    public static void init()
-    {
-        refreshInitial();
-    }
-
-    /**
-     * Initial loading of all existing UDFs.
-     */
-    public static void refreshInitial()
-    {
-        logger.debug("Refreshing UDFs");
-        for (UntypedResultSet.Row row : QueryProcessor.executeOnceInternal(SELECT_CQL))
-        {
-            UFMetaData uf = UFMetaData.fromSchema(row);
-            UDFFunctionOverloads sigMap = functions.get(uf.qualifiedName);
-            if (sigMap == null)
-                functions.put(uf.qualifiedName, sigMap = new UDFFunctionOverloads());
-
-            if (Functions.contains(uf.qualifiedName))
-                logger.warn("The UDF '" + uf.functionName + "' cannot be used because it uses the same name as the CQL " +
-                            "function with the same name. You should drop this function but can do a " +
-                            "'DESCRIBE FUNCTION "+uf.functionName+";' in cqlsh before to get more information about it.");
-
-            // add the function to the registry even if it is invalid (to be able to drop it)
-            sigMap.addAndInit(uf, true);
-
-            if (uf.invalid != null)
-                logger.error("Loaded invalid UDF : " + uf.invalid.getMessage());
-        }
-    }
-
-    public static boolean hasFunction(String qualifiedName)
-    {
-        UDFFunctionOverloads sigMap = functions.get(qualifiedName.toLowerCase());
-        return sigMap != null && !sigMap.isEmpty();
-    }
-
-    public static UDFunction resolveFunction(String namespace, String functionName, String ksName, String cfName,
-                                             List<? extends AssignementTestable> args)
-    throws InvalidRequestException
-    {
-        UDFFunctionOverloads sigMap = functions.get(UFMetaData.qualifiedName(namespace, functionName));
-        if (sigMap != null)
-            return sigMap.resolveFunction(ksName, cfName, args);
-        return null;
-    }
-
-    public static void migrateDropFunction(UFMetaData uf)
-    {
-        UDFFunctionOverloads sigMap = functions.get(uf.qualifiedName);
-        if (sigMap == null)
-            return;
-
-        sigMap.remove(uf);
-    }
-
-    public static void migrateUpdateFunction(UFMetaData uf)
-    {
-        migrateAddFunction(uf);
-    }
-
-    public static void migrateAddFunction(UFMetaData uf)
-    {
-        addFunction(uf, true);
-    }
-
-    /**
-     * Used by {@link org.apache.cassandra.cql3.statements.CreateFunctionStatement} to create or replace a new function.
-     */
-    public static void tryCreateFunction(UFMetaData ufMeta) throws InvalidRequestException
-    {
-        addFunction(ufMeta, false);
-
-        if (ufMeta.invalid != null)
-            throw ufMeta.invalid;
-    }
-
-    private static void addFunction(UFMetaData uf, boolean addIfInvalid)
-    {
-        UDFFunctionOverloads sigMap = functions.get(uf.qualifiedName);
-        if (sigMap == null)
-            functions.put(uf.qualifiedName, sigMap = new UDFFunctionOverloads());
-
-        sigMap.addAndInit(uf, addIfInvalid);
-    }
-
-    public static UDFFunctionOverloads getFunctionSigMap(String qualifiedName)
-    {
-        return functions.get(qualifiedName);
-    }
-}
diff --git a/src/java/org/apache/cassandra/cql3/udf/UDFunction.java b/src/java/org/apache/cassandra/cql3/udf/UDFunction.java
deleted file mode 100644
index 61e52e5c49..0000000000
--- a/src/java/org/apache/cassandra/cql3/udf/UDFunction.java
+++ /dev/null
@@ -1,182 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.cassandra.cql3.udf;
-
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.lang.reflect.Modifier;
-import java.nio.ByteBuffer;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import org.apache.cassandra.config.UFMetaData;
-import org.apache.cassandra.cql3.AssignementTestable;
-import org.apache.cassandra.cql3.functions.Function;
-import org.apache.cassandra.db.marshal.AbstractType;
-import org.apache.cassandra.exceptions.InvalidRequestException;
-
-/**
- * UDFunction contains the <i>invokable</i> instance of a user defined function.
- * Currently (as of CASSANDRA-7395) only {@code public static} methods in a {@link public} class
- * can be invoked.
- * CASSANDRA-7562 will introduce Java source code UDFs and CASSANDRA-7526 will introduce JSR-223 scripting languages.
- * Invocations of UDFs are routed via this class.
- */
-public class UDFunction
-{
-    private static final Logger logger = LoggerFactory.getLogger(UDFunction.class);
-
-    public final UFMetaData meta;
-
-    public final Method method;
-
-    UDFunction(UFMetaData meta) throws InvalidRequestException
-    {
-        this.meta = meta;
-
-        Method m;
-        switch (meta.language)
-        {
-            case "class":
-                m = resolveClassMethod();
-                break;
-            default:
-                throw new InvalidRequestException("Invalid UDF language " + meta.language + " for '" + meta.qualifiedName + '\'');
-        }
-        this.method = m;
-    }
-
-    private Method resolveClassMethod() throws InvalidRequestException
-    {
-        Class<?> jReturnType = meta.cqlReturnType.getType().getSerializer().getType();
-        Class<?> paramTypes[] = new Class[meta.cqlArgumentTypes.size()];
-        for (int i = 0; i < paramTypes.length; i++)
-            paramTypes[i] = meta.cqlArgumentTypes.get(i).getType().getSerializer().getType();
-
-        String className;
-        String methodName;
-        int i = meta.body.indexOf('#');
-        if (i != -1)
-        {
-            methodName = meta.body.substring(i + 1);
-            className = meta.body.substring(0, i);
-        }
-        else
-        {
-            methodName = meta.functionName;
-            className = meta.body;
-        }
-        try
-        {
-            Class<?> cls = Class.forName(className, false, Thread.currentThread().getContextClassLoader());
-
-            Method method = cls.getMethod(methodName, paramTypes);
-
-            if (!Modifier.isStatic(method.getModifiers()))
-                throw new InvalidRequestException("Method " + className + '.' + methodName + '(' + Arrays.toString(paramTypes) + ") is not static");
-
-            if (!jReturnType.isAssignableFrom(method.getReturnType()))
-            {
-                throw new InvalidRequestException("Method " + className + '.' + methodName + '(' + Arrays.toString(paramTypes) + ") " +
-                                                  "has incompatible return type " + method.getReturnType() + " (not assignable to " + jReturnType + ')');
-            }
-
-            return method;
-        }
-        catch (ClassNotFoundException e)
-        {
-            throw new InvalidRequestException("Class " + className + " does not exist");
-        }
-        catch (NoSuchMethodException e)
-        {
-            throw new InvalidRequestException("Method " + className + '.' + methodName + '(' + Arrays.toString(paramTypes) + ") does not exist");
-        }
-    }
-
-    public Function create(List<? extends AssignementTestable> providedArgs)
-    {
-        final int argCount = providedArgs.size();
-        final List<AbstractType<?>> argsType = new ArrayList<>(argCount);
-        final AbstractType<?> returnType = meta.cqlReturnType.getType();
-        for (int i = 0; i < argCount; i++)
-        {
-            AbstractType<?> argType = meta.cqlArgumentTypes.get(i).getType();
-            argsType.add(argType);
-        }
-
-        return new Function()
-        {
-            public String name()
-            {
-                return meta.qualifiedName;
-            }
-
-            public List<AbstractType<?>> argsType()
-            {
-                return argsType;
-            }
-
-            public AbstractType<?> returnType()
-            {
-                return returnType;
-            }
-
-            public ByteBuffer execute(List<ByteBuffer> parameters) throws InvalidRequestException
-            {
-                Object[] parms = new Object[argCount];
-                for (int i = 0; i < parms.length; i++)
-                {
-                    ByteBuffer bb = parameters.get(i);
-                    if (bb != null)
-                    {
-                        AbstractType<?> argType = argsType.get(i);
-                        parms[i] = argType.compose(bb);
-                    }
-                }
-
-                Object result;
-                try
-                {
-                    result = method.invoke(null, parms);
-                    @SuppressWarnings("unchecked") ByteBuffer r = result != null ? ((AbstractType) returnType).decompose(result) : null;
-                    return r;
-                }
-                catch (InvocationTargetException e)
-                {
-                    Throwable c = e.getCause();
-                    logger.error("Invocation of UDF {} failed", meta.qualifiedName, c);
-                    throw new InvalidRequestException("Invocation of UDF " + meta.qualifiedName + " failed: " + c);
-                }
-                catch (IllegalAccessException e)
-                {
-                    throw new InvalidRequestException("UDF " + meta.qualifiedName + " invocation failed: " + e);
-                }
-            }
-
-            public boolean isPure()
-            {
-                return meta.deterministic;
-            }
-        };
-    }
-}
diff --git a/src/java/org/apache/cassandra/db/DefsTables.java b/src/java/org/apache/cassandra/db/DefsTables.java
index e8692a7f5f..f1fe0bf80d 100644
--- a/src/java/org/apache/cassandra/db/DefsTables.java
+++ b/src/java/org/apache/cassandra/db/DefsTables.java
@@ -24,9 +24,6 @@ import java.util.*;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.MapDifference;
 import com.google.common.collect.Maps;
-import org.apache.cassandra.config.UFMetaData;
-import org.apache.cassandra.cql3.udf.UDFRegistry;
-import org.apache.cassandra.db.commitlog.CommitLog;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -35,6 +32,9 @@ import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.config.KSMetaData;
 import org.apache.cassandra.config.Schema;
 import org.apache.cassandra.config.UTMetaData;
+import org.apache.cassandra.cql3.functions.Functions;
+import org.apache.cassandra.cql3.functions.UDFunction;
+import org.apache.cassandra.db.commitlog.CommitLog;
 import org.apache.cassandra.db.compaction.CompactionManager;
 import org.apache.cassandra.db.filter.QueryFilter;
 import org.apache.cassandra.db.marshal.AsciiType;
@@ -393,8 +393,8 @@ public class DefsTables
             if (!cfFunctions.hasColumns())
                 continue;
 
-            for (UFMetaData uf : UFMetaData.fromSchema(new Row(entry.getKey(), cfFunctions)).values())
-                addFunction(uf);
+            for (UDFunction udf : UDFunction.fromSchema(new Row(entry.getKey(), cfFunctions)).values())
+                addFunction(udf);
         }
 
         for (Map.Entry<DecoratedKey, MapDifference.ValueDifference<ColumnFamily>> modifiedEntry : diff.entriesDiffering().entrySet())
@@ -405,26 +405,26 @@ public class DefsTables
 
             if (!prevCFFunctions.hasColumns()) // whole namespace was deleted and now it's re-created
             {
-                for (UFMetaData uf : UFMetaData.fromSchema(new Row(namespace, newCFFunctions)).values())
-                    addFunction(uf);
+                for (UDFunction udf : UDFunction.fromSchema(new Row(namespace, newCFFunctions)).values())
+                    addFunction(udf);
             }
             else if (!newCFFunctions.hasColumns()) // whole namespace is deleted
             {
-                for (UFMetaData uf : UFMetaData.fromSchema(new Row(namespace, prevCFFunctions)).values())
-                    dropFunction(uf);
+                for (UDFunction udf : UDFunction.fromSchema(new Row(namespace, prevCFFunctions)).values())
+                    dropFunction(udf);
             }
             else // has modifications in the functions, need to perform nested diff to determine what was really changed
             {
-                MapDifference<String, UFMetaData> functionsDiff = Maps.difference(UFMetaData.fromSchema(new Row(namespace, prevCFFunctions)),
-                    UFMetaData.fromSchema(new Row(namespace, newCFFunctions)));
+                MapDifference<ByteBuffer, UDFunction> functionsDiff = Maps.difference(UDFunction.fromSchema(new Row(namespace, prevCFFunctions)),
+                                                                                      UDFunction.fromSchema(new Row(namespace, newCFFunctions)));
 
-                for (UFMetaData function : functionsDiff.entriesOnlyOnRight().values())
-                    addFunction(function);
+                for (UDFunction udf : functionsDiff.entriesOnlyOnRight().values())
+                    addFunction(udf);
 
-                for (UFMetaData function : functionsDiff.entriesOnlyOnLeft().values())
-                    dropFunction(function);
+                for (UDFunction udf : functionsDiff.entriesOnlyOnLeft().values())
+                    dropFunction(udf);
 
-                for (MapDifference.ValueDifference<UFMetaData> tdiff : functionsDiff.entriesDiffering().values())
+                for (MapDifference.ValueDifference<UDFunction> tdiff : functionsDiff.entriesDiffering().values())
                     updateFunction(tdiff.rightValue()); // use the most recent value
             }
         }
@@ -478,14 +478,14 @@ public class DefsTables
             MigrationManager.instance.notifyCreateUserType(ut);
     }
 
-    private static void addFunction(UFMetaData uf)
+    private static void addFunction(UDFunction udf)
     {
-        logger.info("Loading {}", uf);
+        logger.info("Loading {}", udf);
 
-        UDFRegistry.migrateAddFunction(uf);
+        Functions.addFunction(udf);
 
         if (!StorageService.instance.isClientMode())
-            MigrationManager.instance.notifyCreateFunction(uf);
+            MigrationManager.instance.notifyCreateFunction(udf);
     }
 
     private static void updateKeyspace(KSMetaData newState)
@@ -530,14 +530,14 @@ public class DefsTables
             MigrationManager.instance.notifyUpdateUserType(ut);
     }
 
-    private static void updateFunction(UFMetaData uf)
+    private static void updateFunction(UDFunction udf)
     {
-        logger.info("Updating {}", uf);
+        logger.info("Updating {}", udf);
 
-        UDFRegistry.migrateUpdateFunction(uf);
+        Functions.replaceFunction(udf);
 
         if (!StorageService.instance.isClientMode())
-            MigrationManager.instance.notifyUpdateFunction(uf);
+            MigrationManager.instance.notifyUpdateFunction(udf);
     }
 
     private static void dropKeyspace(String ksName)
@@ -619,14 +619,15 @@ public class DefsTables
             MigrationManager.instance.notifyDropUserType(ut);
     }
 
-    private static void dropFunction(UFMetaData uf)
+    private static void dropFunction(UDFunction udf)
     {
-        logger.info("Drop {}", uf);
+        logger.info("Drop {}", udf);
 
-        UDFRegistry.migrateDropFunction(uf);
+        // TODO: this is kind of broken as this remove all overloads of the function name
+        Functions.removeFunction(udf.name(), udf.argTypes());
 
         if (!StorageService.instance.isClientMode())
-            MigrationManager.instance.notifyDropFunction(uf);
+            MigrationManager.instance.notifyDropFunction(udf);
     }
 
     private static KSMetaData makeNewKeyspaceDefinition(KSMetaData ksm, CFMetaData toExclude)
@@ -644,4 +645,3 @@ public class DefsTables
             SystemKeyspace.forceBlockingFlush(cf);
     }
 }
-
diff --git a/src/java/org/apache/cassandra/service/CassandraDaemon.java b/src/java/org/apache/cassandra/service/CassandraDaemon.java
index daa135f4d3..2153c85fa6 100644
--- a/src/java/org/apache/cassandra/service/CassandraDaemon.java
+++ b/src/java/org/apache/cassandra/service/CassandraDaemon.java
@@ -33,7 +33,6 @@ import javax.management.StandardMBean;
 
 import com.google.common.collect.Iterables;
 import com.google.common.util.concurrent.Uninterruptibles;
-import org.apache.cassandra.cql3.udf.UDFRegistry;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -44,6 +43,7 @@ import org.apache.cassandra.concurrent.StageManager;
 import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.config.Schema;
+import org.apache.cassandra.cql3.functions.Functions;
 import org.apache.cassandra.db.ColumnFamilyStore;
 import org.apache.cassandra.db.Directories;
 import org.apache.cassandra.db.Keyspace;
@@ -235,8 +235,9 @@ public class CassandraDaemon
             System.exit(100);
         }
 
-        // load keyspace descriptions.
+        // load keyspace && function descriptions.
         DatabaseDescriptor.loadSchemas();
+        Functions.loadUDFFromSchema();
 
         // clean up compaction leftovers
         Map<Pair<String, String>, Map<Integer, UUID>> unfinishedCompactions = SystemKeyspace.getUnfinishedCompactions();
@@ -366,9 +367,6 @@ public class CassandraDaemon
         if (!FBUtilities.getBroadcastAddress().equals(InetAddress.getLoopbackAddress()))
             waitForGossipToSettle();
 
-        // UDF
-        UDFRegistry.init();
-
         // Thift
         InetAddress rpcAddr = DatabaseDescriptor.getRpcAddress();
         int rpcPort = DatabaseDescriptor.getRpcPort();
diff --git a/src/java/org/apache/cassandra/service/MigrationManager.java b/src/java/org/apache/cassandra/service/MigrationManager.java
index 6e930e6724..b3277ee31a 100644
--- a/src/java/org/apache/cassandra/service/MigrationManager.java
+++ b/src/java/org/apache/cassandra/service/MigrationManager.java
@@ -29,8 +29,6 @@ import java.util.concurrent.*;
 import java.lang.management.ManagementFactory;
 import java.lang.management.RuntimeMXBean;
 
-import org.apache.cassandra.config.UFMetaData;
-import org.apache.cassandra.exceptions.InvalidRequestException;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -40,10 +38,14 @@ import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.config.KSMetaData;
 import org.apache.cassandra.config.UTMetaData;
 import org.apache.cassandra.config.Schema;
+import org.apache.cassandra.cql3.functions.FunctionName;
+import org.apache.cassandra.cql3.functions.UDFunction;
 import org.apache.cassandra.db.*;
 import org.apache.cassandra.db.marshal.UserType;
 import org.apache.cassandra.exceptions.AlreadyExistsException;
 import org.apache.cassandra.exceptions.ConfigurationException;
+import org.apache.cassandra.exceptions.InvalidRequestException;
+import org.apache.cassandra.exceptions.SyntaxException;
 import org.apache.cassandra.gms.*;
 import org.apache.cassandra.io.IVersionedSerializer;
 import org.apache.cassandra.io.util.DataOutputPlus;
@@ -175,22 +177,22 @@ public class MigrationManager
             listener.onCreateUserType(ut.keyspace, ut.getNameAsString());
     }
 
-    public void notifyCreateFunction(UFMetaData uf)
+    public void notifyCreateFunction(UDFunction udf)
     {
         for (IMigrationListener listener : listeners)
-            listener.onCreateFunction(uf.namespace, uf.functionName);
+            listener.onCreateFunction(udf.name().namespace, udf.name().name);
     }
 
-    public void notifyUpdateFunction(UFMetaData uf)
+    public void notifyUpdateFunction(UDFunction udf)
     {
         for (IMigrationListener listener : listeners)
-            listener.onUpdateFunction(uf.namespace, uf.functionName);
+            listener.onUpdateFunction(udf.name().namespace, udf.name().name);
     }
 
-    public void notifyDropFunction(UFMetaData uf)
+    public void notifyDropFunction(UDFunction udf)
     {
         for (IMigrationListener listener : listeners)
-            listener.onDropFunction(uf.namespace, uf.functionName);
+            listener.onDropFunction(udf.name().namespace, udf.name().name);
     }
 
     public void notifyUpdateKeyspace(KSMetaData ksm)
@@ -372,24 +374,16 @@ public class MigrationManager
         announce(addSerializedKeyspace(UTMetaData.dropFromSchema(droppedType, FBUtilities.timestampMicros()), droppedType.keyspace), announceLocally);
     }
 
-    public static void announceFunctionDrop(String namespace, String functionName, boolean announceLocally) throws InvalidRequestException
+    public static void announceFunctionDrop(FunctionName fun, boolean announceLocally) throws InvalidRequestException
     {
-        Mutation mutation = UFMetaData.dropFunction(FBUtilities.timestampMicros(), namespace, functionName);
-        if (mutation == null)
-            throw new InvalidRequestException(String.format("Cannot drop non existing function '%s'.", functionName));
-
-        logger.info(String.format("Drop Function '%s::%s'", namespace, functionName));
-        announce(mutation, announceLocally);
+        logger.info(String.format("Drop Function '%s'", fun));
+        announce(UDFunction.dropFromSchema(FBUtilities.timestampMicros(), fun), announceLocally);
     }
 
-    public static void announceNewFunction(UFMetaData function, boolean announceLocally)
-        throws ConfigurationException
+    public static void announceNewFunction(UDFunction udf, boolean announceLocally)
     {
-        Mutation mutation = UFMetaData.createOrReplaceFunction(FBUtilities.timestampMicros(), function);
-        if (mutation == null)
-            throw new ConfigurationException(String.format("Function '%s' already exists.", function.qualifiedName));
-
-        logger.info(String.format("Create Function '%s'", function));
+        Mutation mutation = udf.toSchemaUpdate(FBUtilities.timestampMicros());
+        logger.info(String.format("Create Function '%s'", udf.name()));
         announce(mutation, announceLocally);
     }
 
diff --git a/test/unit/org/apache/cassandra/cql3/CQLTester.java b/test/unit/org/apache/cassandra/cql3/CQLTester.java
index cb32577828..760878c642 100644
--- a/test/unit/org/apache/cassandra/cql3/CQLTester.java
+++ b/test/unit/org/apache/cassandra/cql3/CQLTester.java
@@ -66,6 +66,10 @@ public abstract class CQLTester
     private String currentTable;
     private final Set<String> currentTypes = new HashSet<>();
 
+    // We don't use USE_PREPARED_VALUES in the code below so some test can foce value preparation (if the result
+    // is not expected to be the same without preparation)
+    private boolean usePrepared = USE_PREPARED_VALUES;
+
     @BeforeClass
     public static void setUpClass() throws Throwable
     {
@@ -80,6 +84,9 @@ public abstract class CQLTester
     @After
     public void afterTest() throws Throwable
     {
+        // Restore standard behavior in case it was changed
+        usePrepared = USE_PREPARED_VALUES;
+
         if (currentTable == null)
             return;
 
@@ -162,6 +169,16 @@ public abstract class CQLTester
         return currentTable;
     }
 
+    protected void forcePreparedValues()
+    {
+        this.usePrepared = true;
+    }
+
+    protected void stopForcingPreparedValues()
+    {
+        this.usePrepared = USE_PREPARED_VALUES;
+    }
+
     protected String createType(String query)
     {
         String typeName = "type_" + seqNumber.getAndIncrement();
@@ -222,7 +239,7 @@ public abstract class CQLTester
             query = String.format(query, KEYSPACE + "." + currentTable);
 
             UntypedResultSet rs;
-            if (USE_PREPARED_VALUES)
+            if (usePrepared)
             {
                 logger.info("Executing: {} with values {}", query, formatAllValues(values));
                 rs = QueryProcessor.executeOnceInternal(query, transformValues(values));
diff --git a/test/unit/org/apache/cassandra/cql3/TypeCastTest.java b/test/unit/org/apache/cassandra/cql3/TypeCastTest.java
new file mode 100644
index 0000000000..7b9c9a22ff
--- /dev/null
+++ b/test/unit/org/apache/cassandra/cql3/TypeCastTest.java
@@ -0,0 +1,54 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.cassandra.cql3;
+
+import org.junit.Test;
+
+/**
+ * Type-casting is mostly using for functions and their use with functions is
+ * tested in UFTest. This is a few additional "sanity" tests.
+ */
+public class TypeCastTest extends CQLTester
+{
+    @Test
+    public void testTypeCasts() throws Throwable
+    {
+        createTable("CREATE TABLE %s (k int PRIMARY KEY, t text, a ascii, d double, i int)");
+
+        // The followings is fine
+        execute("UPDATE %s SET t = 'foo' WHERE k = ?", 0);
+        execute("UPDATE %s SET t = (ascii)'foo' WHERE k = ?", 0);
+        execute("UPDATE %s SET t = (text)(ascii)'foo' WHERE k = ?", 0);
+        execute("UPDATE %s SET a = 'foo' WHERE k = ?", 0);
+        execute("UPDATE %s SET a = (ascii)'foo' WHERE k = ?", 0);
+
+        // But trying to put some explicitely type-casted text into an ascii
+        // column should be rejected (even though the text is actually ascci)
+        assertInvalid("UPDATE %s SET a = (text)'foo' WHERE k = ?", 0);
+
+        // This is also fine because integer constants works for both integer and float types
+        execute("UPDATE %s SET i = 3 WHERE k = ?", 0);
+        execute("UPDATE %s SET i = (int)3 WHERE k = ?", 0);
+        execute("UPDATE %s SET d = 3 WHERE k = ?", 0);
+        execute("UPDATE %s SET d = (double)3 WHERE k = ?", 0);
+
+        // But values for ints and doubles are not truly compatible (their binary representation differs)
+        assertInvalid("UPDATE %s SET d = (int)3 WHERE k = ?", 0);
+        assertInvalid("UPDATE %s SET i = (double)3 WHERE k = ?", 0);
+    }
+}
diff --git a/test/unit/org/apache/cassandra/cql3/UFTest.java b/test/unit/org/apache/cassandra/cql3/UFTest.java
index ec494a6627..84161b201d 100644
--- a/test/unit/org/apache/cassandra/cql3/UFTest.java
+++ b/test/unit/org/apache/cassandra/cql3/UFTest.java
@@ -33,154 +33,158 @@ public class UFTest extends CQLTester
         return val != null ? (float)Math.sin(val) : null;
     }
 
-    public Float nonStaticMethod(Float val)
-    {
-        return new Float(1.0);
-    }
-
-    private static Float privateMethod(Float val)
-    {
-        return new Float(1.0);
-    }
-
-    @Test
-    public void ddlCreateFunction() throws Throwable
-    {
-        createTable("CREATE TABLE %s (key int primary key, val double)"); // not used, but required by CQLTester
-
-        execute("create function foo::cf ( input double ) returns double using 'org.apache.cassandra.cql3.UFTest#sin'");
-        execute("drop function foo::cf");
-    }
-
-    @Test(expected = InvalidRequestException.class)
-    public void ddlCreateFunctionFail() throws Throwable
-    {
-        createTable("CREATE TABLE %s (key int primary key, val double)"); // not used, but required by CQLTester
-
-        execute("create function foo::cff ( input double ) returns double using 'org.apache.cassandra.cql3.UFTest#sin'");
-        execute("create function foo::cff ( input double ) returns double using 'org.apache.cassandra.cql3.UFTest#sin'");
-    }
-
-
-    @Test
-    public void ddlCreateIfNotExistsFunction() throws Throwable
+    public static Double badSin(Double val)
     {
-        createTable("CREATE TABLE %s (key int primary key, val double)"); // not used, but required by CQLTester
-
-        execute("create function if not exists foo::cfine ( input double ) returns double using 'org.apache.cassandra.cql3.UFTest#sin'");
-        execute("drop function foo::cfine");
+        return 42.0;
     }
 
-
-    @Test(expected = InvalidRequestException.class)
-    public void ddlCreateFunctionBadClass() throws Throwable
+    public static String badSinBadReturn(Double val)
     {
-        createTable("CREATE TABLE %s (key int primary key, val double)"); // not used, but required by CQLTester
-        execute("create function foo::cff ( input double ) returns double using 'org.apache.cassandra.cql3.DoesNotExist#doesnotexist'");
+        return "foo";
     }
 
-    @Test(expected = InvalidRequestException.class)
-    public void ddlCreateFunctionBadMethod() throws Throwable
+    public Float nonStaticMethod(Float val)
     {
-        createTable("CREATE TABLE %s (key int primary key, val double)"); // not used, but required by CQLTester
-        execute("create function foo::cff ( input double ) returns double using 'org.apache.cassandra.cql3.UFTest#doesnotexist'");
+        return new Float(1.0);
     }
 
-    @Test(expected = InvalidRequestException.class)
-    public void ddlCreateFunctionBadArgType() throws Throwable
+    private static Float privateMethod(Float val)
     {
-        createTable("CREATE TABLE %s (key int primary key, val double)"); // not used, but required by CQLTester
-        execute("create function foo::cff ( input text ) returns double using 'org.apache.cassandra.cql3.UFTest#sin'");
+        return new Float(1.0);
     }
 
-    @Test(expected = InvalidRequestException.class)
-    public void ddlCreateFunctionBadReturnType() throws Throwable
+    public static String repeat(String v, Integer n)
     {
-        createTable("CREATE TABLE %s (key int primary key, val double)"); // not used, but required by CQLTester
-        execute("create function foo::cff ( input double ) returns text using 'org.apache.cassandra.cql3.UFTest#sin'");
+        StringBuilder sb = new StringBuilder();
+        for (int i = 0; i < n; i++)
+            sb.append(v);
+        return sb.toString();
     }
 
-    @Test(expected = InvalidRequestException.class)
-    public void ddlCreateFunctionNonStaticMethod() throws Throwable
+    public static String overloaded(String v)
     {
-        createTable("CREATE TABLE %s (key int primary key, val double)"); // not used, but required by CQLTester
-        execute("create function foo::cff ( input float ) returns float using 'org.apache.cassandra.cql3.UFTest#nonStaticMethod'");
+        return "f1";
     }
 
-    @Test(expected = InvalidRequestException.class)
-    public void ddlCreateFunctionNonPublicMethod() throws Throwable
+    public static String overloaded(Integer v)
     {
-        createTable("CREATE TABLE %s (key int primary key, val double)"); // not used, but required by CQLTester
-        execute("create function foo::cff ( input float ) returns float using 'org.apache.cassandra.cql3.UFTest#privateMethod'");
+        return "f2";
     }
 
-    @Test(expected = InvalidRequestException.class)
-    public void ddlCreateIfNotExistsFunctionFail() throws Throwable
+    public static String overloaded(String v1, String v2)
     {
-        createTable("CREATE TABLE %s (key int primary key, val double)"); // not used, but required by CQLTester
-
-        execute("create function if not exists foo::cfinef ( input double ) returns double using 'org.apache.cassandra.cql3.UFTest#sin'");
-        execute("create function if not exists foo::cfinef ( input double ) returns double using 'org.apache.cassandra.cql3.UFTest#sin'");
+        return "f3";
     }
 
     @Test
-    public void ddlCreateOrReplaceFunction() throws Throwable
-    {
-        createTable("CREATE TABLE %s (key int primary key, val double)"); // not used, but required by CQLTester
+    public void testFunctionCreationAndDrop() throws Throwable
+    {
+        createTable("CREATE TABLE %s (key int PRIMARY KEY, d double)");
+
+        execute("INSERT INTO %s(key, d) VALUES (?, ?)", 1, 1d);
+        execute("INSERT INTO %s(key, d) VALUES (?, ?)", 2, 2d);
+        execute("INSERT INTO %s(key, d) VALUES (?, ?)", 3, 3d);
+
+        // creation with a bad class
+        assertInvalid("CREATE FUNCTION foo::sin1 ( input double ) RETURNS double USING 'org.apache.cassandra.cql3.DoesNotExist#doesnotexist'");
+        // and a good class but inexisting method
+        assertInvalid("CREATE FUNCTION foo::sin2 ( input double ) RETURNS double USING 'org.apache.cassandra.cql3.UFTest#doesnotexist'");
+        // with a non static method
+        assertInvalid("CREATE FUNCTION foo::sin3 ( input float ) RETURNS float USING 'org.apache.cassandra.cql3.UFTest#nonStaticMethod'");
+        // with a non public method
+        assertInvalid("CREATE FUNCTION foo::sin4 ( input float ) RETURNS float USING 'org.apache.cassandra.cql3.UFTest#privateMethod'");
+
+        // creation with bad argument types
+        assertInvalid("CREATE FUNCTION foo::sin5 ( input text ) RETURNS double USING 'org.apache.cassandra.cql3.UFTest#sin'");
+        // with bad return types
+        assertInvalid("CREATE FUNCTION foo::sin6 ( input double ) RETURNS text USING 'org.apache.cassandra.cql3.UFTest#sin'");
+
+        // simple creation
+        execute("CREATE FUNCTION foo::sin ( input double ) RETURNS double USING 'org.apache.cassandra.cql3.UFTest#sin'");
+        // check we can't recreate the same function
+        assertInvalid("CREATE FUNCTION foo::sin ( input double ) RETURNS double USING 'org.apache.cassandra.cql3.UFTest#sin'");
+        // but that it doesn't complay with "IF NOT EXISTS"
+        execute("CREATE FUNCTION IF NOT EXISTS foo::sin ( input double ) RETURNS double USING 'org.apache.cassandra.cql3.UFTest#sin'");
+
+        // Validate that it works as expected
+        assertRows(execute("SELECT key, foo::sin(d) FROM %s"),
+            row(1, Math.sin(1d)),
+            row(2, Math.sin(2d)),
+            row(3, Math.sin(3d))
+        );
 
-        execute("create function foo::corf ( input double ) returns double using 'org.apache.cassandra.cql3.UFTest#sin'");
-        execute("create or replace function foo::corf ( input double ) returns double using 'org.apache.cassandra.cql3.UFTest#sin'");
-    }
+        // Replace the method with incompatible return type
+        assertInvalid("CREATE OR REPLACE FUNCTION foo::sin ( input double ) RETURNS text USING 'org.apache.cassandra.cql3.UFTest#badSinBadReturn'");
+        // proper replacement
+        execute("CREATE OR REPLACE FUNCTION foo::sin ( input double ) RETURNS double USING 'org.apache.cassandra.cql3.UFTest#badSin'");
 
-    @Test(expected = InvalidRequestException.class)
-    public void ddlDropNonExistingFunction() throws Throwable
-    {
-        createTable("CREATE TABLE %s (key int primary key, val double)"); // not used, but required by CQLTester
+        // Validate the method as been replaced
+        assertRows(execute("SELECT key, foo::sin(d) FROM %s"),
+            row(1, 42.0),
+            row(2, 42.0),
+            row(3, 42.0)
+        );
 
-        execute("drop function foo::dnef");
-    }
+        // same function but without namespace
+        execute("CREATE FUNCTION sin ( input double ) RETURNS double USING 'org.apache.cassandra.cql3.UFTest#sin'");
+        assertRows(execute("SELECT key, sin(d) FROM %s"),
+            row(1, Math.sin(1d)),
+            row(2, Math.sin(2d)),
+            row(3, Math.sin(3d))
+        );
 
-    @Test
-    public void ddlDropIfExistsNonExistingFunction() throws Throwable
-    {
-        createTable("CREATE TABLE %s (key int primary key, val double)"); // not used, but required by CQLTester
+        // Drop with and without namespace
+        execute("DROP FUNCTION foo::sin");
+        execute("DROP FUNCTION sin");
 
-        execute("drop function if exists foo::dienef");
+        // Drop unexisting function
+        assertInvalid("DROP FUNCTION foo::sin");
+        // but don't complain with "IF EXISTS"
+        execute("DROP FUNCTION IF EXISTS foo::sin");
     }
 
     @Test
-    public void namespaceUserFunctions() throws Throwable
+    public void testFunctionExecution() throws Throwable
     {
-        createTable("CREATE TABLE %s (key int primary key, val double)");
+        createTable("CREATE TABLE %s (v text PRIMARY KEY)");
 
-        execute("create or replace function math::sin ( input double ) returns double using 'org.apache.cassandra.cql3.UFTest'");
+        execute("INSERT INTO %s(v) VALUES (?)", "aaa");
 
-        execute("INSERT INTO %s (key, val) VALUES (?, ?)", 1, 1d);
-        execute("INSERT INTO %s (key, val) VALUES (?, ?)", 2, 2d);
-        execute("INSERT INTO %s (key, val) VALUES (?, ?)", 3, 3d);
+        execute("CREATE FUNCTION repeat (v text, n int) RETURNS text USING 'org.apache.cassandra.cql3.UFTest#repeat'");
 
-        assertRows(execute("SELECT key, val, math::sin(val) FROM %s"),
-                   row(1, 1d, Math.sin(1d)),
-                   row(2, 2d, Math.sin(2d)),
-                   row(3, 3d, Math.sin(3d))
-        );
+        assertRows(execute("SELECT v FROM %s WHERE v=repeat(?, ?)", "a", 3), row("aaa"));
+        assertEmpty(execute("SELECT v FROM %s WHERE v=repeat(?, ?)", "a", 2));
     }
 
     @Test
-    public void nonNamespaceUserFunctions() throws Throwable
+    public void testFunctionOverloading() throws Throwable
     {
-        createTable("CREATE TABLE %s (key int primary key, val double)");
+        createTable("CREATE TABLE %s (k text PRIMARY KEY, v int)");
 
-        execute("create or replace function sin ( input double ) returns double using 'org.apache.cassandra.cql3.UFTest'");
+        execute("INSERT INTO %s(k, v) VALUES (?, ?)", "f2", 1);
 
-        execute("INSERT INTO %s (key, val) VALUES (?, ?)", 1, 1d);
-        execute("INSERT INTO %s (key, val) VALUES (?, ?)", 2, 2d);
-        execute("INSERT INTO %s (key, val) VALUES (?, ?)", 3, 3d);
+        execute("CREATE FUNCTION overloaded(v varchar) RETURNS text USING 'org.apache.cassandra.cql3.UFTest'");
+        execute("CREATE OR REPLACE FUNCTION overloaded(i int) RETURNS text USING 'org.apache.cassandra.cql3.UFTest'");
+        execute("CREATE OR REPLACE FUNCTION overloaded(v1 text, v2 text) RETURNS text USING 'org.apache.cassandra.cql3.UFTest'");
+        execute("CREATE OR REPLACE FUNCTION overloaded(v ascii) RETURNS text USING 'org.apache.cassandra.cql3.UFTest'");
 
-        assertRows(execute("SELECT key, val, sin(val) FROM %s"),
-                   row(1, 1d, Math.sin(1d)),
-                   row(2, 2d, Math.sin(2d)),
-                   row(3, 3d, Math.sin(3d))
+        // text == varchar, so this should be considered as a duplicate
+        assertInvalid("CREATE FUNCTION overloaded(v varchar) RETURNS text USING 'org.apache.cassandra.cql3.UFTest'");
+
+        assertRows(execute("SELECT overloaded(k), overloaded(v), overloaded(k, k) FROM %s"),
+            row("f1", "f2", "f3")
         );
+
+        forcePreparedValues();
+        // This shouldn't work if we use preparation since there no way to know which overload to use
+        assertInvalid("SELECT v FROM %s WHERE k = overloaded(?)", "foo");
+        stopForcingPreparedValues();
+
+        // but those should since we specifically cast
+        assertEmpty(execute("SELECT v FROM %s WHERE k = overloaded((text)?)", "foo"));
+        assertRows(execute("SELECT v FROM %s WHERE k = overloaded((int)?)", 3), row(1));
+        assertEmpty(execute("SELECT v FROM %s WHERE k = overloaded((ascii)?)", "foo"));
+        // And since varchar == text, this should work too
+        assertEmpty(execute("SELECT v FROM %s WHERE k = overloaded((varchar)?)", "foo"));
     }
 }
