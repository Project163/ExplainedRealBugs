diff --git a/doc/cql3/CQL.textile b/doc/cql3/CQL.textile
index 7fa333d70a..ca0962704f 100644
--- a/doc/cql3/CQL.textile
+++ b/doc/cql3/CQL.textile
@@ -1806,15 +1806,18 @@ The @now@ function takes no arguments and generates a new unique timeuuid (at th
 bc(sample). 
 SELECT * FROM myTable WHERE t = now()
 
+
 will never return any result by design, since the value returned by @now()@ is guaranteed to be unique.
 
 h4. @minTimeuuid@ and @maxTimeuuid@
 
 The @minTimeuuid@ (resp. @maxTimeuuid@) function takes a @timestamp@ value @t@ (which can be "either a timestamp or a date string":#usingtimestamps ) and return a _fake_ @timeuuid@ corresponding to the _smallest_ (resp. _biggest_) possible @timeuuid@ having for timestamp @t@. So for instance:
- 
+
+
 bc(sample). 
 SELECT * FROM myTable WHERE t > maxTimeuuid('2013-01-01 00:05+0000') AND t < minTimeuuid('2013-02-02 10:00+0000')
- 
+
+
 will select all rows where the @timeuuid@ column @t@ is strictly older than '2013-01-01 00:05+0000' but strictly younger than '2013-02-02 10:00+0000'.  Please note that @t >= maxTimeuuid('2013-01-01 00:05+0000')@ would still _not_ select a @timeuuid@ generated exactly at '2013-01-01 00:05+0000' and is essentially equivalent to @t > maxTimeuuid('2013-01-01 00:05+0000')@.
 
 _Warning_: We called the values generated by @minTimeuuid@ and @maxTimeuuid@ _fake_ UUID because they do no respect the Time-Based UUID generation process specified by the "RFC 4122":http://www.ietf.org/rfc/rfc4122.txt. In particular, the value returned by these 2 methods will not be unique. This means you should only use those methods for querying (as in the example above). Inserting the result of those methods is almost certainly _a bad idea_.
@@ -1846,30 +1849,36 @@ h3(#countFct). Count
 
 The @count@ function can be used to count the rows returned by a query. Example:
 
-bc(sample).
+bc(sample). 
 SELECT COUNT(*) FROM plays;
 SELECT COUNT(1) FROM plays;
 
 It also can be used to count the non null value of a given column. Example:
 
-bc(sample).
+bc(sample). 
 SELECT COUNT(scores) FROM plays;
 
 h3(#maxMinFcts). Max and Min
 
 The @max@ and @min@ functions can be used to compute the maximum and the minimum value returned by a query for a given column.
 
-bc(sample).
+bc(sample). 
 SELECT MIN(players), MAX(players) FROM plays WHERE game = 'quake';
 
 h3(#sumFct). Sum
 
 The @sum@ function can be used to sum up all the values returned by a query for a given column.
 
-h3(#sumFct). Avg
+bc(sample). 
+SELECT SUM(players) FROM plays;
+
+h3(#avgFct). Avg
 
 The @avg@ function can be used to compute the average of all the values returned by a query for a given column.
 
+bc(sample). 
+SELECT AVG(players) FROM plays;
+
 h2(#udfs). User-Defined Functions
 
 User-defined functions allow execution of user-provided code in Cassandra. By default, Cassandra supports defining functions in _Java_ and _JavaScript_. Support for other JSR 223 compliant scripting languages (such as Python, Ruby, and Scala) can be added by adding a JAR to the classpath.
