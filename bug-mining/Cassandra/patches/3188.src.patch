diff --git a/CHANGES.txt b/CHANGES.txt
index aa14be9814..9d10d84fee 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,7 @@
 2.1.1
+ * Fix IllegalArgumentException when a list of IN values containing tuples
+   is passed as a single arg to a prepared statement with the v1 or v2
+   protocol (CASSANDRA-8062)
  * Fix ClassCastException in DISTINCT query on static columns with
    query paging (CASSANDRA-8108)
  * Fix NPE on null nested UDT inside a set (CASSANDRA-8105)
diff --git a/src/java/org/apache/cassandra/cql3/Tuples.java b/src/java/org/apache/cassandra/cql3/Tuples.java
index f0d7a13651..883cc60026 100644
--- a/src/java/org/apache/cassandra/cql3/Tuples.java
+++ b/src/java/org/apache/cassandra/cql3/Tuples.java
@@ -240,13 +240,13 @@ public class Tuples
             this.elements = items;
         }
 
-        public static InValue fromSerialized(ByteBuffer value, ListType type) throws InvalidRequestException
+        public static InValue fromSerialized(ByteBuffer value, ListType type, QueryOptions options) throws InvalidRequestException
         {
             try
             {
                 // Collections have this small hack that validate cannot be called on a serialized object,
-                // but compose does the validation (so we're fine).
-                List<?> l = (List<?>)type.compose(value);
+                // but the deserialization does the validation (so we're fine).
+                List<?> l = (List<?>)type.getSerializer().deserializeForNativeProtocol(value, options.getProtocolVersion());
 
                 assert type.elements instanceof TupleType;
                 TupleType tupleType = (TupleType) type.elements;
@@ -391,7 +391,7 @@ public class Tuples
         public InValue bind(QueryOptions options) throws InvalidRequestException
         {
             ByteBuffer value = options.getValues().get(bindIndex);
-            return value == null ? null : InValue.fromSerialized(value, (ListType)receiver.type);
+            return value == null ? null : InValue.fromSerialized(value, (ListType)receiver.type, options);
         }
     }
 
