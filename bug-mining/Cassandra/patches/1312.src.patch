diff --git a/CHANGES.txt b/CHANGES.txt
index b62294776a..87362cc8e2 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -6,6 +6,7 @@
  * (CQL) INSERT/UPDATE/DELETE/TRUNCATE commands should allow CF names to
    be qualified by keyspace (CASSANDRA-3419)
  * always remove endpoints from delevery queue in HH (CASSANDRA-3546)
+ * fix race between cf flush and its 2ndary indexes flush (CASSANDRA-3547)
 
 
 1.0.5
diff --git a/src/java/org/apache/cassandra/db/ColumnFamilyStore.java b/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
index a45aef2845..0e547fda6f 100644
--- a/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
+++ b/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
@@ -669,7 +669,6 @@ public class ColumnFamilyStore implements ColumnFamilyStoreMBean
             }
 
             assert getMemtableThreadSafe() == oldMemtable;
-            oldMemtable.freeze();
             final ReplayPosition ctx = writeCommitLog ? CommitLog.instance.getContext() : ReplayPosition.NONE;
             logger.debug("flush position is {}", ctx);
 
@@ -678,8 +677,13 @@ public class ColumnFamilyStore implements ColumnFamilyStoreMBean
             // don't assume that this.memtable is dirty; forceFlush can bring us here during index build even if it is not
             for (ColumnFamilyStore cfs : concatWithIndexes())
             {
-                if (!cfs.getMemtableThreadSafe().isClean())
+                Memtable mt = cfs.getMemtableThreadSafe();
+                if (!mt.isClean() && !mt.isFrozen())
+                {
+                    // We need to freeze indexes too because they can be concurrently flushed too (#3547)
+                    mt.freeze();
                     icc.add(cfs);
+                }
             }
             final CountDownLatch latch = new CountDownLatch(icc.size());
             for (ColumnFamilyStore cfs : icc)
@@ -689,11 +693,6 @@ public class ColumnFamilyStore implements ColumnFamilyStoreMBean
                 memtable.flushAndSignal(latch, flushWriter, ctx);
             }
 
-            // we marked our memtable as frozen as part of the concurrency control,
-            // so even if there was nothing to flush we need to switch it out
-            if (!icc.contains(this))
-                data.renewMemtable();
-
             if (memtableSwitchCount == Integer.MAX_VALUE)
                 memtableSwitchCount = 0;
             memtableSwitchCount++;
