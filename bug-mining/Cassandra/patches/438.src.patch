diff --git a/src/java/org/apache/cassandra/config/DatabaseDescriptor.java b/src/java/org/apache/cassandra/config/DatabaseDescriptor.java
index 00bd0d109f..753accc117 100644
--- a/src/java/org/apache/cassandra/config/DatabaseDescriptor.java
+++ b/src/java/org/apache/cassandra/config/DatabaseDescriptor.java
@@ -19,9 +19,7 @@
 package org.apache.cassandra.config;
 
 import java.io.*;
-import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
-import java.lang.reflect.InvocationTargetException;
 import java.net.InetAddress;
 import java.net.MalformedURLException;
 import java.net.URL;
@@ -35,6 +33,7 @@ import org.slf4j.LoggerFactory;
 
 import org.apache.cassandra.auth.AllowAllAuthenticator;
 import org.apache.cassandra.auth.IAuthenticator;
+import org.apache.cassandra.auth.IAuthority;
 import org.apache.cassandra.config.Config.RequestSchedulerId;
 import org.apache.cassandra.db.ClockType;
 import org.apache.cassandra.db.ColumnFamilyType;
@@ -83,6 +82,7 @@ public class DatabaseDescriptor
     private static Config conf;
 
     private static IAuthenticator authenticator = new AllowAllAuthenticator();
+    private static IAuthority authority = new AllowAllAuthenticator();
 
     private final static String DEFAULT_CONFIGURATION = "cassandra.yaml";
 
@@ -192,17 +192,8 @@ public class DatabaseDescriptor
             /* Authentication and authorization backend, implementing IAuthenticator */
             if (conf.authenticator != null)
             {
-                try
-                {
-                    Class cls = Class.forName(conf.authenticator);
-                    authenticator = (IAuthenticator) cls.getConstructor().newInstance();
-                }
-                catch (ClassNotFoundException e)
-                {
-                    throw new ConfigurationException("Invalid authenticator class " + conf.authenticator);
-                }
+                authenticator = FBUtilities.<IAuthenticator>construct(conf.authenticator, "authenticator");
             }
-
             authenticator.validateConfiguration();
             
             /* Hashing strategy */
@@ -404,43 +395,7 @@ public class DatabaseDescriptor
 
     private static IEndpointSnitch createEndpointSnitch(String endpointSnitchClassName) throws ConfigurationException
     {
-        IEndpointSnitch snitch;
-        Class cls;
-        try
-        {
-            cls = Class.forName(endpointSnitchClassName);
-        }
-        catch (ClassNotFoundException e)
-        {
-            throw new ConfigurationException("Unable to load endpointsnitch class " + endpointSnitchClassName);
-        }
-        Constructor ctor;
-        try
-        {
-            ctor = cls.getConstructor();
-        }
-        catch (NoSuchMethodException e)
-        {
-            throw new ConfigurationException("No default constructor found in " + endpointSnitchClassName);
-        }
-        try
-        {
-            snitch = (IEndpointSnitch)ctor.newInstance();
-        }
-        catch (InstantiationException e)
-        {
-            throw new ConfigurationException("endpointsnitch class " + endpointSnitchClassName + "is abstract");
-        }
-        catch (IllegalAccessException e)
-        {
-            throw new ConfigurationException("Access to " + endpointSnitchClassName + " constructor was rejected");
-        }
-        catch (InvocationTargetException e)
-        {
-            if (e.getCause() instanceof ConfigurationException)
-                throw (ConfigurationException)e.getCause();
-            throw new ConfigurationException("Error instantiating " + endpointSnitchClassName + " " + e.getMessage());
-        }
+        IEndpointSnitch snitch = FBUtilities.<IEndpointSnitch>construct(endpointSnitchClassName, "snitch");
         return conf.dynamic_snitch ? new DynamicEndpointSnitch(snitch) : snitch;
     }
     
@@ -553,15 +508,7 @@ public class DatabaseDescriptor
             }
             String strategyClassName = keyspace.replica_placement_strategy.replace("RackUnawareStrategy", "SimpleStrategy")
                                                                           .replace("RackAwareStrategy", "OldNetworkTopologyStrategy");
-            Class<? extends AbstractReplicationStrategy> strategyClass = null;
-            try
-            {
-                strategyClass = (Class<? extends AbstractReplicationStrategy>) Class.forName(strategyClassName);
-            }
-            catch (ClassNotFoundException e)
-            {
-                throw new ConfigurationException("Invalid replicaplacementstrategy class " + keyspace.replica_placement_strategy);
-            }
+            Class<AbstractReplicationStrategy> strategyClass = FBUtilities.<AbstractReplicationStrategy>classForName(strategyClassName, "replication-strategy");
             
             /* Data replication factor */
             if (keyspace.replication_factor == null)
@@ -676,8 +623,6 @@ public class DatabaseDescriptor
 
     public static AbstractType getComparator(String compareWith) throws ConfigurationException
     {
-        Class<? extends AbstractType> typeClass;
-        
         if (compareWith == null)
             compareWith = "BytesType";
 
@@ -692,16 +637,7 @@ public class DatabaseDescriptor
         }
 
         String className = reconcileWith.indexOf('.') >= 0 ? reconcileWith : TimestampReconciler.class.getPackage().getName() + '.' + reconcileWith;
-        Class<? extends AbstractReconciler> reconcilerClass;
-        try
-        {
-            reconcilerClass = (Class<? extends AbstractReconciler>) Class.forName(className);
-        }
-        catch (ClassNotFoundException e)
-        {
-            throw new ConfigurationException("Unable to load class " + className);
-        }
-
+        Class<? extends AbstractReconciler> reconcilerClass = FBUtilities.<AbstractReconciler>classForName(className, "reconciler");
         try
         {
             Field field = reconcilerClass.getDeclaredField("instance");
diff --git a/src/java/org/apache/cassandra/hadoop/ConfigHelper.java b/src/java/org/apache/cassandra/hadoop/ConfigHelper.java
index e35d921aba..6e070fd11a 100644
--- a/src/java/org/apache/cassandra/hadoop/ConfigHelper.java
+++ b/src/java/org/apache/cassandra/hadoop/ConfigHelper.java
@@ -20,6 +20,7 @@ package org.apache.cassandra.hadoop;
  * 
  */
 
+import org.apache.cassandra.config.ConfigurationException;
 import org.apache.cassandra.dht.IPartitioner;
 import org.apache.cassandra.thrift.SlicePredicate;
 import org.apache.cassandra.utils.FBUtilities;
@@ -254,6 +255,13 @@ public class ConfigHelper
 
     public static IPartitioner getPartitioner(Configuration conf)
     {
-        return FBUtilities.newPartitioner(conf.get(PARTITIONER_CONFIG)); 
+        try
+        {
+            return FBUtilities.newPartitioner(conf.get(PARTITIONER_CONFIG)); 
+        }
+        catch (ConfigurationException e)
+        {
+            throw new RuntimeException(e);
+        }
     }
 }
diff --git a/src/java/org/apache/cassandra/locator/AbstractReplicationStrategy.java b/src/java/org/apache/cassandra/locator/AbstractReplicationStrategy.java
index 3fc353026d..0a78309326 100644
--- a/src/java/org/apache/cassandra/locator/AbstractReplicationStrategy.java
+++ b/src/java/org/apache/cassandra/locator/AbstractReplicationStrategy.java
@@ -250,17 +250,7 @@ public abstract class AbstractReplicationStrategy
                                                                         Map<String, String> strategyOptions)
             throws ConfigurationException
     {
-        AbstractReplicationStrategy strategy;
-        Class<? extends AbstractReplicationStrategy> c;
-        try
-        {
-            c = (Class<? extends AbstractReplicationStrategy>) Class.forName(strategyClassName);
-        }
-        catch (ClassNotFoundException e)
-        {
-            throw new ConfigurationException("Invalid replication strategy class: " + strategyClassName);
-        }
-
+        Class<AbstractReplicationStrategy> c = FBUtilities.<AbstractReplicationStrategy>classForName(strategyClassName, "replication-strategy");
         return createReplicationStrategy(table, c, tokenMetadata, snitch, strategyOptions);
     }
 }
diff --git a/src/java/org/apache/cassandra/utils/FBUtilities.java b/src/java/org/apache/cassandra/utils/FBUtilities.java
index a9409a2e15..a898757169 100644
--- a/src/java/org/apache/cassandra/utils/FBUtilities.java
+++ b/src/java/org/apache/cassandra/utils/FBUtilities.java
@@ -19,7 +19,9 @@
 package org.apache.cassandra.utils;
 
 import java.io.*;
+import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
 import java.math.BigInteger;
 import java.net.InetAddress;
 import java.net.URL;
@@ -541,51 +543,86 @@ public class FBUtilities
         }
     }
 
-    public static IPartitioner newPartitioner(String partitionerClassName)
+    public static IPartitioner newPartitioner(String partitionerClassName) throws ConfigurationException
     {
         if (!partitionerClassName.contains("."))
             partitionerClassName = "org.apache.cassandra.dht." + partitionerClassName;
+        return FBUtilities.<IPartitioner>construct(partitionerClassName, "partitioner");
+    }
 
+    public static AbstractType getComparator(String compareWith) throws ConfigurationException
+    {
+        String className = compareWith.contains(".") ? compareWith : "org.apache.cassandra.db.marshal." + compareWith;
+        Class<? extends AbstractType> typeClass = FBUtilities.<AbstractType>classForName(className, "abstract-type");
         try
         {
-            Class cls = Class.forName(partitionerClassName);
-            return (IPartitioner) cls.getConstructor().newInstance();
+            Field field = typeClass.getDeclaredField("instance");
+            return (AbstractType) field.get(null);
         }
-        catch (Exception e)
+        catch (NoSuchFieldException e)
         {
-            throw new RuntimeException("Invalid partitioner class " + partitionerClassName);
+            ConfigurationException ex = new ConfigurationException("Invalid comparator: must define a public static instance field.");
+            ex.initCause(e);
+            throw ex;
+        }
+        catch (IllegalAccessException e)
+        {
+            ConfigurationException ex = new ConfigurationException("Invalid comparator: must define a public static instance field.");
+            ex.initCause(e);
+            throw ex;
         }
     }
 
-    public static AbstractType getComparator(String compareWith) throws ConfigurationException
+    /**
+     * @return The Class for the given name.
+     * @param classname Fully qualified classname.
+     * @param readable Descriptive noun for the role the class plays.
+     * @throws ConfigurationException If the class cannot be found.
+     */
+    public static <T> Class<T> classForName(String classname, String readable) throws ConfigurationException
     {
-        String className = compareWith.contains(".") ? compareWith : "org.apache.cassandra.db.marshal." + compareWith;
-        Class<? extends AbstractType> typeClass;
         try
         {
-            typeClass = (Class<? extends AbstractType>) Class.forName(className);
+            return (Class<T>)Class.forName(classname);
         }
         catch (ClassNotFoundException e)
         {
-            throw new ConfigurationException("Unable to load class " + className);
+            throw new ConfigurationException(String.format("Unable to find %s class '%s': is the CLASSPATH set correctly?", readable, classname));
         }
+    }
 
+    /**
+     * Constructs an instance of the given class, which must have a no-arg constructor.
+     * TODO: Similar method for our 'instance member' singleton pattern would be nice.
+     * @param classname Fully qualified classname.
+     * @param readable Descriptive noun for the role the class plays.
+     * @throws ConfigurationException If the class cannot be found.
+     */
+    public static <T> T construct(String classname, String readable) throws ConfigurationException
+    {
+        Class<T> cls = FBUtilities.<T>classForName(classname, readable);
         try
         {
-            Field field = typeClass.getDeclaredField("instance");
-            return (AbstractType) field.get(null);
+            Constructor ctor = cls.getConstructor();
+            return (T)ctor.newInstance();
         }
-        catch (NoSuchFieldException e)
+        catch (NoSuchMethodException e)
         {
-            ConfigurationException ex = new ConfigurationException("Invalid comparator: must define a public static instance field.");
-            ex.initCause(e);
-            throw ex;
+            throw new ConfigurationException(String.format("No default constructor for %s class '%s'.", readable, classname));
         }
         catch (IllegalAccessException e)
         {
-            ConfigurationException ex = new ConfigurationException("Invalid comparator: must define a public static instance field.");
-            ex.initCause(e);
-            throw ex;
+            throw new ConfigurationException(String.format("Default constructor for %s class '%s' is inaccessible.", readable, classname));
+        }
+        catch (InstantiationException e)
+        {
+            throw new ConfigurationException(String.format("Cannot use abstract class '%s' as %s.", classname, readable));
+        }
+        catch (InvocationTargetException e)
+        {
+            if (e.getCause() instanceof ConfigurationException)
+                throw (ConfigurationException)e.getCause();
+            throw new ConfigurationException(String.format("Error instantiating %s class '%s'.", readable, classname), e);
         }
     }
 
