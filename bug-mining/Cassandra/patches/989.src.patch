diff --git a/CHANGES.txt b/CHANGES.txt
index 16ff7153de..ba4e3bbb08 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -29,6 +29,8 @@
  * fix scan wrongly throwing assertion error (CASSANDRA-2653)
  * Always use even distribution for merkle tree with RandomPartitionner
    (CASSANDRA-2841)
+ * allow deleting a row and updating indexed columns in it in the
+   same mutation (CASSANDRA-2773)
 
 
 0.7.6
diff --git a/src/java/org/apache/cassandra/db/Table.java b/src/java/org/apache/cassandra/db/Table.java
index a9a7546b5c..b027168430 100644
--- a/src/java/org/apache/cassandra/db/Table.java
+++ b/src/java/org/apache/cassandra/db/Table.java
@@ -429,7 +429,16 @@ public class Table
             ByteBuffer name = iter.next();
             IColumn newColumn = cf.getColumn(name); // null == row delete or it wouldn't be marked Mutated
             if (newColumn != null && cf.isMarkedForDelete())
-                throw new UnsupportedOperationException("Index manager cannot support deleting and inserting into a row in the same mutation");
+            {
+                // row is marked for delete, but column was also updated.  if column is timestamped less than
+                // the row tombstone, treat it as if it didn't exist.  Otherwise we don't care about row
+                // tombstone for the purpose of the index update and we can proceed as usual.
+                if (newColumn.timestamp() <= cf.getMarkedForDeleteAt())
+                {
+                    // don't remove from the cf object; that can race w/ CommitLog write.  Leaving it is harmless.
+                    newColumn = null;
+                }
+            }
             IColumn oldColumn = oldIndexedColumns.getColumn(name);
 
             // deletions are irrelevant to the index unless we're changing state from live -> deleted, i.e.,
