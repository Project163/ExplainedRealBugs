diff --git a/CHANGES.txt b/CHANGES.txt
index 78643d5e04..e038599df8 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -22,6 +22,7 @@
  * cqlsh: fix DESCRIBE for 1.1 cfs in CQL3 (CASSANDRA-5101)
  * Correctly gossip with nodes >= 1.1.7 (CASSANDRA-5102)
  * Ensure CL guarantees on digest mismatch (CASSANDRA-5113)
+ * Validate correctly selects on composite partition key (CASSANDRA-5122)
 Merged from 1.1:
  * Pig: correctly decode row keys in widerow mode (CASSANDRA-5098)
 
diff --git a/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java b/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
index b41659c1e4..e88784c17f 100644
--- a/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
+++ b/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
@@ -271,10 +271,10 @@ public class SelectStatement implements CQLStatement
             RowPosition finishKey = RowPosition.forKey(finishKeyBytes, p);
             if (startKey.compareTo(finishKey) > 0 && !finishKey.isMinimum(p))
             {
-                if (p instanceof RandomPartitioner)
-                    throw new InvalidRequestException("Start key sorts after end key. This is not allowed; you probably should not specify end key at all, under RandomPartitioner");
-                else
+                if (p.preservesOrder())
                     throw new InvalidRequestException("Start key must sort before (or equal to) finish key in your partitioner!");
+                else
+                    throw new InvalidRequestException("Start key sorts after end key. This is not allowed; you probably should not specify end key at all under random partitioner");
             }
             if (includeKeyBound(Bound.START))
             {
@@ -991,6 +991,7 @@ public class SelectStatement implements CQLStatement
             CFDefinition cfDef = cfm.getCfDef();
             SelectStatement stmt = new SelectStatement(cfDef, getBoundsTerms(), parameters);
             CFDefinition.Name[] names = new CFDefinition.Name[getBoundsTerms()];
+            IPartitioner partitioner = StorageService.getPartitioner();
 
             // Select clause
             if (parameters.isCount)
@@ -1044,8 +1045,6 @@ public class SelectStatement implements CQLStatement
                 switch (name.kind)
                 {
                     case KEY_ALIAS:
-                        if (rel.operator() != Relation.Type.EQ && rel.operator() != Relation.Type.IN && !rel.onToken && !StorageService.getPartitioner().preservesOrder())
-                            throw new InvalidRequestException("Only EQ and IN relation are supported on the partition key for RandomPartitioner (unless you use the token() function)");
                         stmt.keyRestrictions[name.position] = updateRestriction(name, stmt.keyRestrictions[name.position], rel);
                         break;
                     case COLUMN_ALIAS:
@@ -1111,7 +1110,11 @@ public class SelectStatement implements CQLStatement
                 if (restriction == null)
                 {
                     if (stmt.onToken)
-                        throw new InvalidRequestException(String.format("The token() function must be applied to all partition key components or none of them"));
+                        throw new InvalidRequestException("The token() function must be applied to all partition key components or none of them");
+
+                    // Under a non order perserving partitioner, the only time not restricting a key part is allowed is if none are restricted
+                    if (!partitioner.preservesOrder() && i > 0 && stmt.keyRestrictions[i-1] != null)
+                        throw new InvalidRequestException(String.format("Partition key part %s must be restricted since preceding part is", cname));
 
                     stmt.isKeyRange = true;
                     shouldBeDone = true;
@@ -1145,6 +1148,9 @@ public class SelectStatement implements CQLStatement
                 }
                 else
                 {
+                    if (!partitioner.preservesOrder())
+                        throw new InvalidRequestException("Only EQ and IN relation are supported on the partition key for random partitioners (unless you use the token() function)");
+
                     stmt.isKeyRange = true;
                     shouldBeDone = true;
                 }
