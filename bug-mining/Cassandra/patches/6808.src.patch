diff --git a/CHANGES.txt b/CHANGES.txt
index 512459f5e8..6935dd4489 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 5.0.5
+ * Get SAI MemtableIndex refs before SSTableIndex refs at query time (CASSANDRA-20709)
  * Fix MAX_SEGMENT_SIZE < chunkSize in MmappedRegions::updateState (CASSANDRA-20636)
  * Full Java 17 support (CASSANDRA-20681)
  * Ensure replica filtering protection does not trigger unnecessary short read protection reads (CASSANDRA-20639)
diff --git a/src/java/org/apache/cassandra/index/sai/disk/IndexSearchResultIterator.java b/src/java/org/apache/cassandra/index/sai/disk/IndexSearchResultIterator.java
index 83887698fc..e59d7c6e35 100644
--- a/src/java/org/apache/cassandra/index/sai/disk/IndexSearchResultIterator.java
+++ b/src/java/org/apache/cassandra/index/sai/disk/IndexSearchResultIterator.java
@@ -30,9 +30,11 @@ import org.apache.cassandra.db.PartitionPosition;
 import org.apache.cassandra.dht.AbstractBounds;
 import org.apache.cassandra.exceptions.QueryCancelledException;
 import org.apache.cassandra.index.sai.QueryContext;
+import org.apache.cassandra.index.sai.memory.MemtableIndex;
 import org.apache.cassandra.index.sai.plan.Expression;
 import org.apache.cassandra.index.sai.iterators.KeyRangeIterator;
 import org.apache.cassandra.index.sai.iterators.KeyRangeUnionIterator;
+import org.apache.cassandra.index.sai.plan.QueryViewBuilder;
 import org.apache.cassandra.index.sai.utils.PrimaryKey;
 import org.apache.cassandra.io.util.FileUtils;
 import org.apache.cassandra.utils.Throwables;
@@ -51,22 +53,39 @@ public class IndexSearchResultIterator extends KeyRangeIterator
 
     /**
      * Builds a new {@link IndexSearchResultIterator} that wraps a {@link KeyRangeUnionIterator} over the
-     * results of searching the {@link org.apache.cassandra.index.sai.memory.MemtableIndex} and the {@link SSTableIndex}es.
+     * results of searching the {@link QueryViewBuilder.QueryExpressionView}.
+     */
+    public static IndexSearchResultIterator build(QueryViewBuilder.QueryExpressionView queryView,
+                                                  AbstractBounds<PartitionPosition> keyRange,
+                                                  QueryContext queryContext,
+                                                  boolean includeMemtables,
+                                                  Runnable onClose)
+    {
+        return build(queryView.expression, queryView.memtableIndexes, queryView.sstableIndexes, keyRange, queryContext, includeMemtables, onClose);
+    }
+
+    /**
+     * Builds a new {@link IndexSearchResultIterator} that wraps a {@link KeyRangeUnionIterator} over the
+     * results of searching the {@link org.apache.cassandra.index.sai.memory.MemtableIndex}es and the {@link SSTableIndex}es.
      */
     public static IndexSearchResultIterator build(Expression expression,
+                                                  Collection<MemtableIndex> memtableIndexes,
                                                   Collection<SSTableIndex> sstableIndexes,
                                                   AbstractBounds<PartitionPosition> keyRange,
                                                   QueryContext queryContext,
                                                   boolean includeMemtables,
                                                   Runnable onClose)
     {
-        List<KeyRangeIterator> subIterators = new ArrayList<>(sstableIndexes.size() + (includeMemtables ? 1 : 0));
+        int size = sstableIndexes.size() + (includeMemtables ? memtableIndexes.size() : 0);
+        List<KeyRangeIterator> subIterators = new ArrayList<>(size);
 
         if (includeMemtables)
         {
-            KeyRangeIterator memtableIterator = expression.getIndex().memtableIndexManager().searchMemtableIndexes(queryContext, expression, keyRange);
-            if (memtableIterator != null)
+            for (MemtableIndex memtableIndex : memtableIndexes)
+            {
+                KeyRangeIterator memtableIterator = memtableIndex.search(queryContext, expression, keyRange);
                 subIterators.add(memtableIterator);
+            }
         }
 
         for (SSTableIndex sstableIndex : sstableIndexes)
@@ -98,7 +117,7 @@ public class IndexSearchResultIterator extends KeyRangeIterator
     }
 
     public static IndexSearchResultIterator build(List<KeyRangeIterator> sstableIntersections,
-                                                  KeyRangeIterator memtableResults,
+                                                  List<KeyRangeIterator> memtableResults,
                                                   Set<SSTableIndex> referencedIndexes,
                                                   QueryContext queryContext,
                                                   Runnable onClose)
diff --git a/src/java/org/apache/cassandra/index/sai/memory/MemtableIndexManager.java b/src/java/org/apache/cassandra/index/sai/memory/MemtableIndexManager.java
index 36e48a04b1..abd62dbff1 100644
--- a/src/java/org/apache/cassandra/index/sai/memory/MemtableIndexManager.java
+++ b/src/java/org/apache/cassandra/index/sai/memory/MemtableIndexManager.java
@@ -19,9 +19,10 @@
 package org.apache.cassandra.index.sai.memory;
 
 import java.nio.ByteBuffer;
+import java.util.ArrayList;
 import java.util.Collection;
+import java.util.Collections;
 import java.util.Iterator;
-import java.util.List;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.TimeUnit;
@@ -31,17 +32,10 @@ import javax.annotation.Nullable;
 import com.google.common.annotations.VisibleForTesting;
 
 import org.apache.cassandra.db.DecoratedKey;
-import org.apache.cassandra.db.PartitionPosition;
 import org.apache.cassandra.db.lifecycle.LifecycleNewTracker;
 import org.apache.cassandra.db.memtable.Memtable;
 import org.apache.cassandra.db.rows.Row;
-import org.apache.cassandra.dht.AbstractBounds;
-import org.apache.cassandra.index.sai.QueryContext;
 import org.apache.cassandra.index.sai.StorageAttachedIndex;
-import org.apache.cassandra.index.sai.plan.Expression;
-import org.apache.cassandra.index.sai.iterators.KeyRangeIterator;
-import org.apache.cassandra.index.sai.iterators.KeyRangeUnionIterator;
-import org.apache.cassandra.index.sai.utils.PrimaryKey;
 import org.apache.cassandra.utils.Clock;
 import org.apache.cassandra.utils.FBUtilities;
 
@@ -134,47 +128,19 @@ public class MemtableIndexManager
                                    .orElse(null);
     }
 
-    public KeyRangeIterator searchMemtableIndexes(QueryContext queryContext, Expression e, AbstractBounds<PartitionPosition> keyRange)
+    public long liveMemtableWriteCount()
     {
-        Collection<MemtableIndex> memtableIndexes = liveMemtableIndexMap.values();
-
-        if (memtableIndexes.isEmpty())
-        {
-            return KeyRangeIterator.empty();
-        }
-
-        KeyRangeIterator.Builder builder = KeyRangeUnionIterator.builder(memtableIndexes.size());
-
-        for (MemtableIndex memtableIndex : memtableIndexes)
-        {
-            builder.add(memtableIndex.search(queryContext, e, keyRange));
-        }
-
-        return builder.build();
+        return liveMemtableIndexMap.values().stream().mapToLong(MemtableIndex::writeCount).sum();
     }
 
-    public KeyRangeIterator limitToTopResults(QueryContext context, List<PrimaryKey> source, Expression e)
+    public Collection<MemtableIndex> getLiveMemtableIndexesSnapshot()
     {
-        Collection<MemtableIndex> memtables = liveMemtableIndexMap.values();
-
-        if (memtables.isEmpty())
-        {
-            return KeyRangeIterator.empty();
-        }
-
-        KeyRangeUnionIterator.Builder builder = KeyRangeUnionIterator.builder(memtables.size());
-
-        for (MemtableIndex index : memtables)
-        {
-            builder.add(index.limitToTopResults(source, e, context.vectorContext().limit()));
-        }
-
-        return builder.build();
-    }
+        Collection<MemtableIndex> memtableIndexes = liveMemtableIndexMap.values();
+        if (memtableIndexes.isEmpty())
+            return Collections.emptyList();
 
-    public long liveMemtableWriteCount()
-    {
-        return liveMemtableIndexMap.values().stream().mapToLong(MemtableIndex::writeCount).sum();
+        // Copy the values. Otherwise, we'll only have a view of the map's values which is subject to change.
+        return new ArrayList<>(memtableIndexes);
     }
 
     public long estimatedMemIndexMemoryUsed()
diff --git a/src/java/org/apache/cassandra/index/sai/plan/QueryController.java b/src/java/org/apache/cassandra/index/sai/plan/QueryController.java
index 8bd1e25f28..09d54611eb 100644
--- a/src/java/org/apache/cassandra/index/sai/plan/QueryController.java
+++ b/src/java/org/apache/cassandra/index/sai/plan/QueryController.java
@@ -65,7 +65,6 @@ import org.apache.cassandra.net.ParamType;
 import org.apache.cassandra.schema.TableMetadata;
 import org.apache.cassandra.tracing.Tracing;
 import org.apache.cassandra.utils.InsertionOrderedNavigableSet;
-import org.apache.cassandra.utils.Pair;
 import org.apache.cassandra.utils.Throwables;
 
 import static org.apache.cassandra.config.CassandraRelevantProperties.SAI_VECTOR_SEARCH_ORDER_CHUNK_SIZE;
@@ -178,12 +177,12 @@ public class QueryController
      * This is achieved by creating an on-disk view of the query that maps the expressions to
      * the {@link SSTableIndex}s that will satisfy the expression.
      * <p>
-     * Each (expression, SSTable indexes) pair is then passed to
-     * {@link IndexSearchResultIterator#build(Expression, Collection, AbstractBounds, QueryContext, boolean, Runnable)}
-     * to search the in-memory index associated with the expression and the SSTable indexes, the results of
+     * Each {@link QueryViewBuilder.QueryExpressionView} is then passed to
+     * {@link IndexSearchResultIterator#build(QueryViewBuilder.QueryExpressionView, AbstractBounds, QueryContext, boolean, Runnable)}
+     * to search the in-memory indexes associated with the expression and the SSTable indexes, the results of
      * which are unioned and returned.
      * <p>
-     * The results from each call to {@link IndexSearchResultIterator#build(Expression, Collection, AbstractBounds, QueryContext, boolean, Runnable)}
+     * The results from each call to {@link IndexSearchResultIterator#build(QueryViewBuilder.QueryExpressionView, AbstractBounds, QueryContext, boolean, Runnable)}
      * are added to a {@link KeyRangeIntersectionIterator} and returned if strict filtering is allowed.
      * <p>
      * If strict filtering is not allowed, indexes are split into two groups according to the repaired status of their 
@@ -214,22 +213,23 @@ public class QueryController
                 // If strict filtering is enabled, evaluate indexes for both repaired and un-repaired SSTables together.
                 // This usually means we are making this local index query in the context of a user query that reads 
                 // from a single replica and thus can safely perform local intersections.
-                for (Pair<Expression, Collection<SSTableIndex>> queryViewPair : queryView.view)
-                    builder.add(IndexSearchResultIterator.build(queryViewPair.left, queryViewPair.right, mergeRange, queryContext, true, () -> {}));
+                for (QueryViewBuilder.QueryExpressionView queryExpressionView : queryView.view)
+                    builder.add(IndexSearchResultIterator.build(queryExpressionView, mergeRange, queryContext, true, () -> {}));
             }
             else
             {
                 KeyRangeIterator.Builder repairedBuilder = KeyRangeIntersectionIterator.builder(expressions.size(), () -> {});
 
-                for (Pair<Expression, Collection<SSTableIndex>> queryViewPair : queryView.view)
+                for (QueryViewBuilder.QueryExpressionView queryExpressionView : queryView.view)
                 {
+                    Expression expression = queryExpressionView.expression;
                     // The initial sizes here reflect little more than an effort to avoid resizing for 
                     // partition-restricted searches w/ LCS:
                     List<SSTableIndex> repaired = new ArrayList<>(5);
                     List<SSTableIndex> unrepaired = new ArrayList<>(5);
 
                     // Split SSTable indexes into repaired and un-reparired:
-                    for (SSTableIndex index : queryViewPair.right)
+                    for (SSTableIndex index : queryExpressionView.sstableIndexes)
                         if (index.getSSTable().isRepaired())
                             repaired.add(index);
                         else
@@ -237,7 +237,7 @@ public class QueryController
 
                     // Always build an iterator for the un-repaired set, given this must include Memtable indexes...  
                     IndexSearchResultIterator unrepairedIterator =
-                            IndexSearchResultIterator.build(queryViewPair.left, unrepaired, mergeRange, queryContext, true, () -> {});
+                            IndexSearchResultIterator.build(expression, queryExpressionView.memtableIndexes, unrepaired, mergeRange, queryContext, true, () -> {});
 
                     // ...but ignore it if our combined results are empty.
                     if (unrepairedIterator.getMaxKeys() > 0)
@@ -253,7 +253,7 @@ public class QueryController
 
                     // ...then only add an iterator to the repaired intersection if repaired SSTable indexes exist. 
                     if (!repaired.isEmpty())
-                        repairedBuilder.add(IndexSearchResultIterator.build(queryViewPair.left, repaired, mergeRange, queryContext, false, () -> {}));
+                        repairedBuilder.add(IndexSearchResultIterator.build(expression, Collections.emptyList(), repaired, mergeRange, queryContext, false, () -> {}));
                 }
 
                 if (repairedBuilder.rangeCount() > 0)
@@ -274,8 +274,8 @@ public class QueryController
         int referencedIndexes = 0;
 
         // We want to make sure that no individual column expression touches too many SSTable-attached indexes:
-        for (Pair<Expression, Collection<SSTableIndex>> expressionSSTables : queryView.view)
-            referencedIndexes = Math.max(referencedIndexes, expressionSSTables.right.size());
+        for (QueryViewBuilder.QueryExpressionView expressionSSTables : queryView.view)
+            referencedIndexes = Math.max(referencedIndexes, expressionSSTables.sstableIndexes.size());
 
         if (Guardrails.saiSSTableIndexesPerQuery.failsOn(referencedIndexes, null))
         {
@@ -319,14 +319,19 @@ public class QueryController
         StorageAttachedIndex index = indexFor(expression);
         assert index != null;
         Expression planExpression = Expression.create(index).add(Operator.ANN, expression.getIndexValue().duplicate());
-        // search memtable before referencing sstable indexes; otherwise we may miss newly flushed memtable index
-        KeyRangeIterator memtableResults = index.memtableIndexManager().searchMemtableIndexes(queryContext, planExpression, mergeRange);
 
         QueryViewBuilder.QueryView queryView = new QueryViewBuilder(Collections.singleton(planExpression), mergeRange).build();
         Runnable onClose = () -> queryView.referencedIndexes.forEach(SSTableIndex::releaseQuietly);
 
         try
         {
+            List<KeyRangeIterator> memtableResults = queryView.view
+                                                              .stream()
+                                                              .map(v -> v.memtableIndexes)
+                                                              .flatMap(Collection::stream)
+                                                              .map(idx -> idx.search(queryContext, planExpression, mergeRange))
+                                                              .collect(Collectors.toList());
+
             List<KeyRangeIterator> sstableIntersections = queryView.view
                                                                    .stream()
                                                                    .map(this::createRowIdIterator)
@@ -360,16 +365,21 @@ public class QueryController
         Expression planExpression = Expression.create(index);
         planExpression.add(Operator.ANN, expression.getIndexValue().duplicate());
 
-        // search memtable before referencing sstable indexes; otherwise we may miss newly flushed memtable index
-        KeyRangeIterator memtableResults = index.memtableIndexManager().limitToTopResults(queryContext, sourceKeys, planExpression);
         QueryViewBuilder.QueryView queryView = new QueryViewBuilder(Collections.singleton(planExpression), mergeRange).build();
         Runnable onClose = () -> queryView.referencedIndexes.forEach(SSTableIndex::releaseQuietly);
 
         try
         {
+            List<KeyRangeIterator> memtableResults = queryView.view
+                                                              .stream()
+                                                              .map(v -> v.memtableIndexes)
+                                                              .flatMap(Collection::stream)
+                                                              .map(idx -> idx.limitToTopResults(sourceKeys, planExpression, vectorQueryContext.limit()))
+                                                              .collect(Collectors.toList());
+
             List<KeyRangeIterator> sstableIntersections = queryView.view
                                                                    .stream()
-                                                                   .flatMap(pair -> pair.right.stream())
+                                                                   .flatMap(pair -> pair.sstableIndexes.stream())
                                                                    .map(idx -> {
                                                                        try
                                                                        {
@@ -395,15 +405,15 @@ public class QueryController
     /**
      * Create row id iterator from different indexes' on-disk searcher of the same sstable
      */
-    private KeyRangeIterator createRowIdIterator(Pair<Expression, Collection<SSTableIndex>> indexExpression)
+    private KeyRangeIterator createRowIdIterator(QueryViewBuilder.QueryExpressionView indexExpression)
     {
-        List<KeyRangeIterator> subIterators = indexExpression.right
+        List<KeyRangeIterator> subIterators = indexExpression.sstableIndexes
                            .stream()
                            .map(index ->
                                 {
                                     try
                                     {
-                                        List<KeyRangeIterator> iterators = index.search(indexExpression.left, mergeRange, queryContext);
+                                        List<KeyRangeIterator> iterators = index.search(indexExpression.expression, mergeRange, queryContext);
                                         // concat the result from multiple segments for the same index
                                         return KeyRangeConcatIterator.builder(iterators.size()).add(iterators).build();
                                     }
diff --git a/src/java/org/apache/cassandra/index/sai/plan/QueryViewBuilder.java b/src/java/org/apache/cassandra/index/sai/plan/QueryViewBuilder.java
index 81aa2ab1e9..cecd45a928 100644
--- a/src/java/org/apache/cassandra/index/sai/plan/QueryViewBuilder.java
+++ b/src/java/org/apache/cassandra/index/sai/plan/QueryViewBuilder.java
@@ -28,9 +28,9 @@ import java.util.stream.Collectors;
 import org.apache.cassandra.db.PartitionPosition;
 import org.apache.cassandra.dht.AbstractBounds;
 import org.apache.cassandra.index.sai.disk.SSTableIndex;
+import org.apache.cassandra.index.sai.memory.MemtableIndex;
 import org.apache.cassandra.index.sai.view.View;
 import org.apache.cassandra.io.sstable.format.SSTableReader;
-import org.apache.cassandra.utils.Pair;
 
 /**
  * Build a query specific view of the on-disk indexes for a query. This will return a
@@ -52,12 +52,26 @@ public class QueryViewBuilder
         this.range = range;
     }
 
+    public static class QueryExpressionView
+    {
+        public final Expression expression;
+        public final Collection<MemtableIndex> memtableIndexes;
+        public final Collection<SSTableIndex> sstableIndexes;
+
+        public QueryExpressionView(Expression expression, Collection<MemtableIndex> memtableIndexes, Collection<SSTableIndex> sstableIndexes)
+        {
+            this.expression = expression;
+            this.memtableIndexes = memtableIndexes;
+            this.sstableIndexes = sstableIndexes;
+        }
+    }
+
     public static class QueryView
     {
-        public final Collection<Pair<Expression, Collection<SSTableIndex>>> view;
+        public final Collection<QueryExpressionView> view;
         public final Set<SSTableIndex> referencedIndexes;
 
-        public QueryView(Collection<Pair<Expression, Collection<SSTableIndex>>> view, Set<SSTableIndex> referencedIndexes)
+        public QueryView(Collection<QueryExpressionView> view, Set<SSTableIndex> referencedIndexes)
         {
             this.view = view;
             this.referencedIndexes = referencedIndexes;
@@ -72,8 +86,8 @@ public class QueryViewBuilder
             referencedIndexes.clear();
             boolean failed = false;
 
-            Collection<Pair<Expression, Collection<SSTableIndex>>> view = getQueryView(expressions);
-            for (SSTableIndex index : view.stream().map(pair -> pair.right).flatMap(Collection::stream).collect(Collectors.toList()))
+            Collection<QueryExpressionView> view = getQueryView(expressions);
+            for (SSTableIndex index : view.stream().map(v -> v.sstableIndexes).flatMap(Collection::stream).collect(Collectors.toList()))
             {
                 if (index.reference())
                     referencedIndexes.add(index);
@@ -88,9 +102,9 @@ public class QueryViewBuilder
         }
     }
 
-    private Collection<Pair<Expression, Collection<SSTableIndex>>> getQueryView(Collection<Expression> expressions)
+    private Collection<QueryExpressionView> getQueryView(Collection<Expression> expressions)
     {
-        List<Pair<Expression, Collection<SSTableIndex>>> queryView = new ArrayList<>();
+        List<QueryExpressionView> queryView = new ArrayList<>();
 
         for (Expression expression : expressions)
         {
@@ -99,10 +113,13 @@ public class QueryViewBuilder
             if (expression.isNotIndexed())
                 continue;
 
-            // Select all the sstable indexes that have a term range that is satisfied by this expression and 
+            // Fetch the memtables first to ensure we don't miss any newly flushed memtable index
+            Collection<MemtableIndex> memtableIndexes = expression.getIndex().memtableIndexManager().getLiveMemtableIndexesSnapshot();
+            // Select all the sstable indexes that have a term range that is satisfied by this expression and
             // overlap with the key range being queried.
             View view = expression.getIndex().view();
-            queryView.add(Pair.create(expression, selectIndexesInRange(view.match(expression))));
+            Collection<SSTableIndex> sstableIndexes = selectIndexesInRange(view.match(expression));
+            queryView.add(new QueryExpressionView(expression, memtableIndexes, sstableIndexes));
         }
 
         return queryView;
diff --git a/test/unit/org/apache/cassandra/index/sai/plan/FlushIndexWhileQueryingTest.java b/test/unit/org/apache/cassandra/index/sai/plan/FlushIndexWhileQueryingTest.java
new file mode 100644
index 0000000000..8fa871427c
--- /dev/null
+++ b/test/unit/org/apache/cassandra/index/sai/plan/FlushIndexWhileQueryingTest.java
@@ -0,0 +1,84 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.cassandra.index.sai.plan;
+
+import java.util.concurrent.ForkJoinPool;
+
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+
+import org.apache.cassandra.index.sai.SAITester;
+import org.apache.cassandra.index.sai.disk.IndexSearchResultIterator;
+import org.apache.cassandra.inject.Injections;
+import org.apache.cassandra.inject.InvokePointBuilder;
+
+/**
+ * Test to cover edge cases related to memtable flush during query execution.
+ */
+public class FlushIndexWhileQueryingTest extends SAITester
+{
+    @Test
+    public void testFlushDuringEqualityQuery() throws Throwable
+    {
+        createTable("CREATE TABLE %s (k text PRIMARY KEY, x int)");
+
+        createIndex("CREATE CUSTOM INDEX ON %s(x) USING 'sai'");
+
+        execute("INSERT INTO %s (k, x) VALUES (?, ?)", "a", 0);
+        execute("INSERT INTO %s (k, x) VALUES (?, ?)", "b", 0);
+        execute("INSERT INTO %s (k, x) VALUES (?, ?)", "c", 1);
+
+        // We use a barrier to trigger flush at precisely the right time
+        InvokePointBuilder initialInvokePoint = InvokePointBuilder.newInvokePoint()
+                                                           .onClass(QueryViewBuilder.class)
+                                                           .onMethod("build")
+                                                           .atExit();
+        Injections.Barrier initialBarrier = Injections.newBarrier("pause_query", 2, false)
+                                                      .add(initialInvokePoint)
+                                                      .build();
+        InvokePointBuilder secondInvokePoint = InvokePointBuilder.newInvokePoint()
+                                                           .onClass(IndexSearchResultIterator.class)
+                                                           .onMethod("build")
+                                                           .atEntry();
+        Injections.Barrier secondBarrier = Injections.newBarrier("resume_query", 2, false)
+                                                     .add(secondInvokePoint)
+                                                     .build();
+
+        Injections.inject(initialBarrier, secondBarrier);
+
+        // Flush in a separate thread to allow the query to run concurrently
+        ForkJoinPool.commonPool().submit(() -> {
+            try
+            {
+                initialBarrier.arrive();
+                flush();
+                secondBarrier.arrive();
+            }
+            catch (InterruptedException t)
+            {
+                throw new RuntimeException(t);
+            }
+        });
+
+        assertRowCount(execute("SELECT k FROM %s WHERE x = 0"), 2);
+        assertEquals("Confirm that we hit the barrier (helps in case method name changed)", 0, initialBarrier.getCount());
+        assertEquals("Confirm that we hit the barrier (helps in case method name changed)", 0, secondBarrier.getCount());
+    }
+}
