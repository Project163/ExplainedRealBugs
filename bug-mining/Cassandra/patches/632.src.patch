diff --git a/contrib/stress/bin/stress b/contrib/stress/bin/stress
new file mode 100755
index 0000000000..1284b3c09a
--- /dev/null
+++ b/contrib/stress/bin/stress
@@ -0,0 +1,49 @@
+#!/bin/sh
+
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+if [ "x$CLASSPATH" = "x" ]; then
+    # Cassandra class files.
+    if [ ! -d `dirname $0`/../../../build/classes ]; then
+        echo "Unable to locate cassandra class files" >&2
+        exit 1
+    fi
+
+    # Circuit class files.
+    if [ ! -d `dirname $0`/../build/classes ]; then
+        echo "Unable to locate stress class files" >&2
+        exit 1
+    fi
+
+    CLASSPATH=`dirname $0`/../../../build/classes:`dirname $0`/../build/classes
+    for jar in `dirname $0`/../../../lib/*.jar; do
+        CLASSPATH=$CLASSPATH:$jar
+    done
+fi
+
+if [ -x $JAVA_HOME/bin/java ]; then
+    JAVA=$JAVA_HOME/bin/java
+else
+    JAVA=`which java`
+fi
+
+if [ "x$JAVA" = "x" ]; then
+    echo "Java executable not found (hint: set JAVA_HOME)" >&2
+    exit 1
+fi
+
+$JAVA -server -cp $CLASSPATH org.apache.cassandra.contrib.stress.Stress $@
diff --git a/contrib/stress/build.xml b/contrib/stress/build.xml
new file mode 100644
index 0000000000..6f921eb8f8
--- /dev/null
+++ b/contrib/stress/build.xml
@@ -0,0 +1,56 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+ ~ Licensed to the Apache Software Foundation (ASF) under one
+ ~ or more contributor license agreements.  See the NOTICE file
+ ~ distributed with this work for additional information
+ ~ regarding copyright ownership.  The ASF licenses this file
+ ~ to you under the Apache License, Version 2.0 (the
+ ~ "License"); you may not use this file except in compliance
+ ~ with the License.  You may obtain a copy of the License at
+ ~
+ ~    http://www.apache.org/licenses/LICENSE-2.0
+ ~
+ ~ Unless required by applicable law or agreed to in writing,
+ ~ software distributed under the License is distributed on an
+ ~ "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ ~ KIND, either express or implied.  See the License for the
+ ~ specific language governing permissions and limitations
+ ~ under the License.
+ -->
+<project basedir="." default="build" name="stress">
+    <property name="cassandra.dir" value="../.." />
+    <property name="cassandra.lib" value="${cassandra.dir}/lib" />
+    <property name="cassandra.classes" value="${cassandra.dir}/build/classes" />
+    <property name="build.src" value="${basedir}/src" />
+    <property name="build.out" value="${basedir}/build" />
+    <property name="build.classes" value="${build.out}/classes" />
+    <property name="final.name" value="stress" />
+
+    <target name="init">
+        <mkdir dir="${build.classes}" />
+    </target>
+
+    <target depends="init" name="build">
+        <javac destdir="${build.classes}">
+            <src path="${build.src}" />
+            <classpath>
+                <path>
+                    <fileset dir="${cassandra.lib}">
+                        <include name="**/*.jar" />
+                    </fileset>
+                    <pathelement location="${cassandra.classes}" />
+                </path>
+            </classpath>
+        </javac>
+    </target>
+
+    <target name="jar" depends="build">
+        <mkdir dir="${build.classes}/META-INF" />
+        <jar jarfile="${build.out}/${final.name}.jar"
+                basedir="${build.classes}" />
+    </target>
+
+    <target name="clean">
+        <delete dir="${build.out}" />
+    </target>
+</project>
diff --git a/contrib/stress/src/org/apache/cassandra/contrib/stress/Session.java b/contrib/stress/src/org/apache/cassandra/contrib/stress/Session.java
new file mode 100644
index 0000000000..f833f47b75
--- /dev/null
+++ b/contrib/stress/src/org/apache/cassandra/contrib/stress/Session.java
@@ -0,0 +1,384 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.cassandra.contrib.stress;
+
+import org.apache.cassandra.db.ColumnFamilyType;
+import org.apache.cassandra.thrift.*;
+import org.apache.commons.cli.*;
+import org.apache.thrift.protocol.TBinaryProtocol;
+import org.apache.thrift.transport.TFramedTransport;
+import org.apache.thrift.transport.TSocket;
+import org.apache.thrift.transport.TTransport;
+
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.PrintStream;
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.concurrent.atomic.AtomicIntegerArray;
+import java.util.concurrent.atomic.AtomicLongArray;
+
+public class Session
+{
+    // command line options
+    public static final Options availableOptions = new Options();
+
+    public final AtomicIntegerArray operationCount;
+    public final AtomicIntegerArray keyCount;
+    public final AtomicLongArray latencies;
+
+    static
+    {
+        availableOptions.addOption("h",  "help",                 false,  "show this help message and exit.");
+        availableOptions.addOption("n",  "num-keys",             true,   "Number of keys, default:1000000.");
+        availableOptions.addOption("N",  "skip-keys",            true,   "Fraction of keys to skip initially, default:0.");
+        availableOptions.addOption("t",  "threads",              true,   "Number of threads to use, default:50.");
+        availableOptions.addOption("c",  "columns",              true,   "Number of columns per key, default:5.");
+        availableOptions.addOption("S",  "column-size",          true,   "Size of column values in bytes, default:34.");
+        availableOptions.addOption("C",  "cardinality",          true,   "Number of unique values stored in columns, default:50.");
+        availableOptions.addOption("d",  "nodes",                true,   "Host nodes (comma separated), default:locahost.");
+        availableOptions.addOption("s",  "stdev",                true,   "Standard Deviation Factor, default:0.1.");
+        availableOptions.addOption("r",  "random",               false,  "Use random key generator (STDEV will have no effect), default:false.");
+        availableOptions.addOption("f",  "file",                 true,   "Write output to file");
+        availableOptions.addOption("p",  "port",                 true,   "Thrift port, default:9160.");
+        availableOptions.addOption("m",  "unframed",             false,  "Use unframed transport, default:false.");
+        availableOptions.addOption("o",  "operation",            true,   "Operation to perform (INSERT, READ, RANGE_SLICE, INDEXED_RANGE_SLICE, MULTI_GET), default:INSERT.");
+        availableOptions.addOption("u",  "supercolumns",         true,   "Number of super columns per key, default:1.");
+        availableOptions.addOption("y",  "family-type",          true,   "Column Family Type (Super, Standard), default:Standard.");
+        availableOptions.addOption("k",  "keep-going",           false,  "Ignore errors inserting or reading, default:false.");
+        availableOptions.addOption("i",  "progress-interval",    true,   "Progress Report Interval (seconds), default:10.");
+        availableOptions.addOption("g",  "keys-per-call",        true,   "Amount of keys to get_range_slices or multiget per call, default:1000.");
+        availableOptions.addOption("l",  "replication-factor",   true,   "Replication Factor to use when creating needed column families, default:1.");
+        availableOptions.addOption("e",  "consistency-level",    true,   "Consistency Level to use (ONE, QUORUM, LOCAL_QUORUM, EACH_QUORUM, ALL, ANY), default:ONE.");
+        availableOptions.addOption("x",  "create-index",         true,   "Type of index to create on needed column families (KEYS).");
+    }
+
+    private int numKeys          = 1000 * 1000;
+    private float skipKeys       = 0;
+    private int threads          = 50;
+    private int columns          = 5;
+    private int columnSize       = 34;
+    private int cardinality      = 50;
+    private String[] nodes       = new String[] { "127.0.0.1" };
+    private boolean random       = false;
+    private boolean unframed     = false;
+    private boolean ignoreErrors = false;
+    private int port             = 9160;
+    private int superColumns     = 1;
+
+    private int progressInterval  = 10;
+    private int keysPerCall       = 1000;
+    private int replicationFactor = 1;
+
+    private PrintStream out = System.out;
+
+    private IndexType indexType = null;
+    private Stress.Operation operation = Stress.Operation.INSERT;
+    private ColumnFamilyType columnFamilyType = ColumnFamilyType.Standard;
+    private ConsistencyLevel consistencyLevel = ConsistencyLevel.ONE;
+
+    // required by Gaussian distribution.
+    protected int   mean;
+    protected float sigma;
+
+    public Session(String[] arguments) throws IllegalArgumentException
+    {
+        float STDev = 0.1f;
+        CommandLineParser parser = new PosixParser();
+
+        try
+        {
+            CommandLine cmd = parser.parse(availableOptions, arguments);
+
+            if (cmd.hasOption("h"))
+                throw new IllegalArgumentException("help");
+
+            if (cmd.hasOption("n"))
+                numKeys = Integer.parseInt(cmd.getOptionValue("n"));
+
+            if (cmd.hasOption("N"))
+                skipKeys = Float.parseFloat(cmd.getOptionValue("N"));
+
+            if (cmd.hasOption("t"))
+                threads = Integer.parseInt(cmd.getOptionValue("t"));
+
+            if (cmd.hasOption("c"))
+                columns = Integer.parseInt(cmd.getOptionValue("c"));
+
+            if (cmd.hasOption("S"))
+                columnSize = Integer.parseInt(cmd.getOptionValue("S"));
+
+            if (cmd.hasOption("C"))
+                cardinality = Integer.parseInt(cmd.getOptionValue("t"));
+
+            if (cmd.hasOption("d"))
+                nodes = cmd.getOptionValue("d").split(",");
+
+            if (cmd.hasOption("s"))
+                STDev = Float.parseFloat(cmd.getOptionValue("s"));
+
+            if (cmd.hasOption("r"))
+                random = Boolean.parseBoolean(cmd.getOptionValue("r"));
+
+            if (cmd.hasOption("f"))
+            {
+                try
+                {
+                    out = new PrintStream(new FileOutputStream(cmd.getOptionValue("f")));
+                }
+                catch (FileNotFoundException e)
+                {
+                    System.out.println(e.getMessage());
+                }
+            }
+
+            if (cmd.hasOption("p"))
+                port = Integer.parseInt(cmd.getOptionValue("p"));
+
+            if (cmd.hasOption("m"))
+                unframed = Boolean.parseBoolean(cmd.getOptionValue("m"));
+
+            if (cmd.hasOption("o"))
+                operation = Stress.Operation.valueOf(cmd.getOptionValue("o").toUpperCase());
+
+            if (cmd.hasOption("u"))
+                superColumns = Integer.parseInt(cmd.getOptionValue("u"));
+
+            if (cmd.hasOption("y"))
+                columnFamilyType = ColumnFamilyType.valueOf(cmd.getOptionValue("y"));
+
+            if (cmd.hasOption("k"))
+                ignoreErrors = Boolean.parseBoolean(cmd.getOptionValue("k"));
+
+            if (cmd.hasOption("i"))
+                progressInterval = Integer.parseInt(cmd.getOptionValue("i"));
+
+            if (cmd.hasOption("g"))
+                keysPerCall = Integer.parseInt(cmd.getOptionValue("g"));
+
+            if (cmd.hasOption("l"))
+                replicationFactor = Integer.parseInt(cmd.getOptionValue("l"));
+
+            if (cmd.hasOption("e"))
+                consistencyLevel = ConsistencyLevel.valueOf(cmd.getOptionValue("e").toUpperCase());
+
+            if (cmd.hasOption("x"))
+                indexType = IndexType.valueOf(cmd.getOptionValue("x").toUpperCase());
+        }
+        catch (ParseException e)
+        {
+            throw new IllegalArgumentException(e.getMessage(), e);
+        }
+
+        mean  = numKeys / 2;
+        sigma = numKeys * STDev;
+
+        operationCount = new AtomicIntegerArray(threads);
+        keyCount = new AtomicIntegerArray(threads);
+        latencies = new AtomicLongArray(threads);
+    }
+
+    public int getCardinality()
+    {
+        return cardinality;
+    }
+
+    public int getColumnSize()
+    {
+        return columnSize;
+    }
+
+    public boolean isUnframed()
+    {
+        return unframed;
+    }
+
+    public int getColumnsPerKey()
+    {
+        return columns;
+    }
+
+    public ColumnFamilyType getColumnFamilyType()
+    {
+        return columnFamilyType;
+    }
+
+    public int getNumKeys()
+    {
+        return numKeys;
+    }
+
+    public int getThreads()
+    {
+        return threads;
+    }
+
+    public float getSkipKeys()
+    {
+        return skipKeys;
+    }
+
+    public int getSuperColumns()
+    {
+        return superColumns;
+    }
+
+    public int getKeysPerThread()
+    {
+        return numKeys / threads;
+    }
+
+    public int getTotalKeysLength()
+    {
+        return Integer.toString(numKeys).length();
+    }
+
+    public ConsistencyLevel getConsistencyLevel()
+    {
+        return consistencyLevel;
+    }
+
+    public boolean ignoreErrors()
+    {
+        return ignoreErrors;
+    }
+
+    public Stress.Operation getOperation()
+    {
+        return operation;
+    }
+
+    public PrintStream getOutputStream()
+    {
+        return out;
+    }
+
+    public int getProgressInterval()
+    {
+        return progressInterval;
+    }
+
+    public boolean useRandomGenerator()
+    {
+        return random;
+    }
+
+    public int getKeysPerCall()
+    {
+        return keysPerCall;
+    }
+
+    // required by Gaussian distribution
+    public int getMean()
+    {
+        return mean;
+    }
+
+    // required by Gaussian distribution
+    public float getSigma()
+    {
+        return sigma;
+    }
+
+    /**
+     * Create Keyspace1 with Standard1 and Super1 column families
+     */
+    public void createKeySpaces()
+    {
+        KsDef keyspace = new KsDef();
+        ColumnDef standardColumn = new ColumnDef(ByteBuffer.wrap("C1".getBytes()), "UTF8Type");
+        ColumnDef superSubColumn = new ColumnDef(ByteBuffer.wrap("S1".getBytes()), "UTF8Type");
+
+        if (indexType != null)
+            standardColumn.setIndex_type(indexType).setIndex_name("Idx1");
+
+        // column family for standard columns
+        CfDef standardCfDef = new CfDef("Keyspace1", "Standard1").setColumn_metadata(Arrays.asList(standardColumn));
+
+        // column family with super columns
+        CfDef superCfDef = new CfDef("Keyspace1", "Super1").setColumn_metadata(Arrays.asList(superSubColumn)).setColumn_type("Super");
+
+        keyspace.setName("Keyspace1");
+        keyspace.setStrategy_class("org.apache.cassandra.locator.SimpleStrategy");
+        keyspace.setReplication_factor(replicationFactor);
+        keyspace.setCf_defs(new ArrayList<CfDef>(Arrays.asList(standardCfDef, superCfDef)));
+
+        Cassandra.Client client = getClient(false);
+
+        try
+        {
+            client.system_add_keyspace(keyspace);
+            out.println(String.format("Created keyspaces. Sleeping %ss for propagation.", nodes.length));
+
+            Thread.sleep(nodes.length * 1000); // seconds
+        }
+        catch (InvalidRequestException e)
+        {
+            out.println(e.getWhy());
+        }
+        catch (Exception e)
+        {
+            out.println(e.getMessage());
+        }
+    }
+
+    /**
+     * Thrift client connection with Keyspace1 set.
+     * @return cassandra client connection
+     */
+    public Cassandra.Client getClient()
+    {
+        return getClient(true);
+    }
+    /**
+     * Thrift client connection
+     * @param setKeyspace - should we set keyspace for client or not
+     * @return cassandra client connection
+     */
+    public Cassandra.Client getClient(boolean setKeyspace)
+    {
+        // random node selection for fake load balancing
+        String currentNode = nodes[Stress.randomizer.nextInt(nodes.length)];
+
+        TSocket socket = new TSocket(currentNode, port);
+        TTransport transport = (isUnframed()) ? socket : new TFramedTransport(socket);
+        Cassandra.Client client = new Cassandra.Client(new TBinaryProtocol(transport));
+
+        try
+        {
+            transport.open();
+
+            if (setKeyspace)
+            {
+                client.set_keyspace("Keyspace1");
+            }
+        }
+        catch (InvalidRequestException e)
+        {
+            throw new RuntimeException(e.getWhy());
+        }
+        catch (Exception e)
+        {
+            throw new RuntimeException(e.getMessage());
+        }
+
+        return client;
+    }
+
+}
diff --git a/contrib/stress/src/org/apache/cassandra/contrib/stress/Stress.java b/contrib/stress/src/org/apache/cassandra/contrib/stress/Stress.java
new file mode 100644
index 0000000000..9ef1e4f077
--- /dev/null
+++ b/contrib/stress/src/org/apache/cassandra/contrib/stress/Stress.java
@@ -0,0 +1,177 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.cassandra.contrib.stress;
+
+import org.apache.cassandra.contrib.stress.tests.*;
+import org.apache.cassandra.contrib.stress.util.OperationThread;
+import org.apache.commons.cli.Option;
+
+import java.io.PrintStream;
+import java.util.Random;
+
+public final class Stress
+{
+    public static enum Operation
+    {
+        INSERT, READ, RANGE_SLICE, INDEXED_RANGE_SLICE, MULTI_GET
+    }
+
+    public static Session session;
+    public static Random randomizer = new Random();
+
+    public static void main(String[] arguments) throws Exception
+    {
+        int epoch, total, oldTotal, latency, keyCount, oldKeyCount, oldLatency;
+
+        try
+        {
+            session = new Session(arguments);
+        }
+        catch (IllegalArgumentException e)
+        {
+            printHelpMessage();
+            return;
+        }
+
+        // creating keyspace and column families
+        if (session.getOperation() == Stress.Operation.INSERT)
+        {
+            session.createKeySpaces();
+        }
+
+        int threadCount  = session.getThreads();
+        Thread[] threads = new Thread[threadCount];
+        PrintStream out  = session.getOutputStream();
+
+        // creating required type of the threads for the test
+        try
+        {
+            for (int i = 0; i < threadCount; i++)
+            {
+                threads[i] = createOperation(i);
+            }
+        }
+        catch (Exception e)
+        {
+            System.err.println(e.getMessage());
+            return;
+        }
+
+        // starting worker threads
+        for (int i = 0; i < threadCount; i++)
+        {
+            threads[i].start();
+        }
+
+        // initialization of the values
+        boolean terminate = false;
+        epoch = total = latency = keyCount = 0;
+
+        int interval = session.getProgressInterval();
+        int epochIntervals = session.getProgressInterval() * 10;
+        long testStartTime = System.currentTimeMillis();
+
+        out.println("total,interval_op_rate,interval_key_rate,avg_latency,elapsed_time");
+
+        while (!terminate)
+        {
+            Thread.sleep(100);
+
+            int alive = 0;
+            for (Thread thread : threads)
+                if (thread.isAlive()) alive++;
+
+            if (alive == 0)
+                terminate = true;
+
+            epoch++;
+
+            if (terminate || epoch > epochIntervals)
+            {
+                epoch = 0;
+
+                oldTotal    = total;
+                oldLatency  = latency;
+                oldKeyCount = keyCount;
+
+                int currentTotal = 0, currentKeyCount = 0, currentLatency = 0;
+
+                for (Thread t : threads)
+                {
+                    OperationThread thread = (OperationThread) t;
+
+                    currentTotal    += session.operationCount.get(thread.index);
+                    currentKeyCount += session.keyCount.get(thread.index);
+                    currentLatency  += session.latencies.get(thread.index);
+                }
+
+                total    = currentTotal;
+                keyCount = currentKeyCount;
+                latency  = currentLatency;
+
+                int opDelta  = total - oldTotal;
+                int keyDelta = keyCount - oldKeyCount;
+                double latencyDelta = latency - oldLatency;
+
+                long currentTimeInSeconds = (System.currentTimeMillis() - testStartTime) / 1000;
+                String formattedDelta = (opDelta > 0) ? Double.toString(latencyDelta / (opDelta * 1000)) : "NaN";
+
+                out.println(String.format("%d,%d,%d,%s,%d", total, opDelta / interval, keyDelta / interval, formattedDelta, currentTimeInSeconds));
+            }
+        }
+    }
+
+    private static Thread createOperation(int index)
+    {
+        switch (session.getOperation())
+        {
+            case READ:
+                return new Reader(index);
+
+            case INSERT:
+                return new Inserter(index);
+
+            case RANGE_SLICE:
+                return new RangeSlicer(index);
+
+            case INDEXED_RANGE_SLICE:
+                return new IndexedRangeSlicer(index);
+
+            case MULTI_GET:
+                return new MultiGetter(index);
+        }
+
+        throw new UnsupportedOperationException();
+    }
+
+    /**
+     * Printing out help message
+     */
+    public static void printHelpMessage()
+    {
+        System.out.println("Usage: ./bin/stress [options]\n\nOptions:");
+
+        for(Object o : Session.availableOptions.getOptions())
+        {
+            Option option = (Option) o;
+            String upperCaseName = option.getLongOpt().toUpperCase();
+            System.out.println(String.format("-%s%s, --%s%s%n\t\t%s%n", option.getOpt(), (option.hasArg()) ? " "+upperCaseName : "",
+                                                            option.getLongOpt(), (option.hasArg()) ? "="+upperCaseName : "", option.getDescription()));
+        }
+    }
+}
diff --git a/contrib/stress/src/org/apache/cassandra/contrib/stress/tests/IndexedRangeSlicer.java b/contrib/stress/src/org/apache/cassandra/contrib/stress/tests/IndexedRangeSlicer.java
new file mode 100644
index 0000000000..e0d4cf1f41
--- /dev/null
+++ b/contrib/stress/src/org/apache/cassandra/contrib/stress/tests/IndexedRangeSlicer.java
@@ -0,0 +1,124 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.cassandra.contrib.stress.tests;
+
+import org.apache.cassandra.contrib.stress.util.OperationThread;
+import org.apache.cassandra.thrift.*;
+import org.apache.cassandra.utils.FBUtilities;
+
+import java.nio.ByteBuffer;
+import java.util.Arrays;
+import java.util.List;
+
+public class IndexedRangeSlicer extends OperationThread
+{
+    public IndexedRangeSlicer(int index)
+    {
+        super(index);
+    }
+
+    public void run()
+    {
+        String format = "%0" + session.getTotalKeysLength() + "d";
+        SlicePredicate predicate = new SlicePredicate().setSlice_range(new SliceRange(ByteBuffer.wrap(new byte[]{}),
+                                                                                      ByteBuffer.wrap(new byte[] {}),
+                                                                                      false, session.getColumnsPerKey()));
+
+        List<String> values = super.generateValues();
+        ColumnParent parent = new ColumnParent("Standard1");
+        int expectedPerValue = session.getNumKeys() / values.size();
+
+        ByteBuffer columnName = ByteBuffer.wrap("C1".getBytes());
+
+        for (int i = range.begins(); i < range.size(); i++)
+        {
+            int received = 0;
+
+            String startOffset = "0";
+            ByteBuffer value = ByteBuffer.wrap(values.get(i % values.size()).getBytes());
+
+            IndexExpression expression = new IndexExpression(columnName, IndexOperator.EQ, value);
+
+            while (received < expectedPerValue)
+            {
+                IndexClause clause = new IndexClause(Arrays.asList(expression), ByteBuffer.wrap(startOffset.getBytes()),
+                                                                                session.getKeysPerCall());
+
+                List<KeySlice> results = null;
+                long start = System.currentTimeMillis();
+
+                try
+                {
+                    results = client.get_indexed_slices(parent, clause, predicate, session.getConsistencyLevel());
+
+                    if (results.size() == 0)
+                    {
+                        throw new RuntimeException("No indexed values from offset received: " + startOffset);
+                    }
+                }
+                catch (InvalidRequestException e)
+                {
+                    System.err.println(e.getWhy());
+
+                    if (!session.ignoreErrors())
+                        return;
+                }
+                catch (Exception e)
+                {
+                    System.err.println(e.getMessage());
+
+                    if (!session.ignoreErrors())
+                        return;
+                }
+
+                received += results.size();
+
+                // convert max key found back to an integer, and increment it
+                startOffset = String.format(format, (1 + getMaxKey(results)));
+
+                session.operationCount.getAndIncrement(index);
+                session.keyCount.getAndAdd(index, results.size());
+                session.latencies.getAndAdd(index, System.currentTimeMillis() - start);
+            }
+        }
+    }
+
+    /**
+     * Get maximum key from keySlice list
+     * @param keySlices list of the KeySlice objects
+     * @return maximum key value of the list
+     */
+    private int getMaxKey(List<KeySlice> keySlices)
+    {
+        byte[] firstKey = keySlices.get(0).getKey();
+        int maxKey = FBUtilities.byteBufferToInt(ByteBuffer.wrap(firstKey));
+
+        for (KeySlice k : keySlices)
+        {
+            int currentKey = FBUtilities.byteBufferToInt(ByteBuffer.wrap(k.getKey()));
+
+            if (currentKey > maxKey)
+            {
+                maxKey = currentKey;
+            }
+        }
+
+        return maxKey;
+    }
+
+}
diff --git a/contrib/stress/src/org/apache/cassandra/contrib/stress/tests/Inserter.java b/contrib/stress/src/org/apache/cassandra/contrib/stress/tests/Inserter.java
new file mode 100644
index 0000000000..dc59ae3a89
--- /dev/null
+++ b/contrib/stress/src/org/apache/cassandra/contrib/stress/tests/Inserter.java
@@ -0,0 +1,131 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.cassandra.contrib.stress.tests;
+
+import org.apache.cassandra.contrib.stress.util.OperationThread;
+import org.apache.cassandra.db.ColumnFamilyType;
+import org.apache.cassandra.thrift.Column;
+import org.apache.cassandra.thrift.ColumnOrSuperColumn;
+import org.apache.cassandra.thrift.Mutation;
+import org.apache.cassandra.thrift.SuperColumn;
+
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+public class Inserter extends OperationThread
+{
+    public Inserter(int index)
+    {
+        super(index);
+    }
+
+    public void run()
+    {
+        List<String> values  = generateValues();
+        List<Column> columns = new ArrayList<Column>();
+        List<SuperColumn> superColumns = new ArrayList<SuperColumn>();
+
+        // format used for keys
+        String format = "%0" + session.getTotalKeysLength() + "d";
+
+        // columns = [Column('C' + str(j), 'unset', time.time() * 1000000) for j in xrange(columns_per_key)]
+        for (int i = 0; i < session.getColumnsPerKey(); i++)
+        {
+            byte[] columnName = ("C" + Integer.toString(i)).getBytes();
+            columns.add(new Column(ByteBuffer.wrap(columnName), ByteBuffer.wrap(new byte[] {}), System.currentTimeMillis()));
+        }
+
+        if (session.getColumnFamilyType() == ColumnFamilyType.Super)
+        {
+            // supers = [SuperColumn('S' + str(j), columns) for j in xrange(supers_per_key)]
+            for (int i = 0; i < session.getSuperColumns(); i++)
+            {
+                String superColumnName = "S" + Integer.toString(i);
+                superColumns.add(new SuperColumn(ByteBuffer.wrap(superColumnName.getBytes()), columns));
+            }
+        }
+
+        for (int i : range)
+        {
+            ByteBuffer key = ByteBuffer.wrap(String.format(format, i).getBytes());
+            Map<ByteBuffer, Map<String, List<Mutation>>> record = new HashMap<ByteBuffer, Map<String, List<Mutation>>>();
+
+            record.put(key, session.getColumnFamilyType() == ColumnFamilyType.Super
+                                                          ? getSuperColumnsMutationMap(superColumns)
+                                                          : getColumnsMutationMap(columns));
+
+            String value = values.get(i % values.size());
+
+            for (Column c : columns)
+                c.value = ByteBuffer.wrap(value.getBytes());
+
+            long start = System.currentTimeMillis();
+
+            try
+            {
+                client.batch_mutate(record, session.getConsistencyLevel());
+            }
+            catch (Exception e)
+            {
+                System.err.println(e.getMessage());
+
+                if (!session.ignoreErrors())
+                    return;
+            }
+
+            session.operationCount.getAndIncrement(index);
+            session.keyCount.getAndIncrement(index);
+            session.latencies.getAndAdd(index, System.currentTimeMillis() - start);
+        }
+    }
+
+    private Map<String, List<Mutation>> getSuperColumnsMutationMap(List<SuperColumn> superColumns)
+    {
+        List<Mutation> mutations = new ArrayList<Mutation>();
+        Map<String, List<Mutation>> mutationMap = new HashMap<String, List<Mutation>>();
+
+        for (SuperColumn s : superColumns)
+        {
+            ColumnOrSuperColumn superColumn = new ColumnOrSuperColumn().setSuper_column(s);
+            mutations.add(new Mutation().setColumn_or_supercolumn(superColumn));
+        }
+
+        mutationMap.put("Super1", mutations);
+
+        return mutationMap;
+    }
+
+    private Map<String, List<Mutation>> getColumnsMutationMap(List<Column> columns)
+    {
+        List<Mutation> mutations = new ArrayList<Mutation>();
+        Map<String, List<Mutation>> mutationMap = new HashMap<String, List<Mutation>>();
+
+        for (Column c : columns)
+        {
+            ColumnOrSuperColumn column = new ColumnOrSuperColumn().setColumn(c);
+            mutations.add(new Mutation().setColumn_or_supercolumn(column));
+        }
+
+        mutationMap.put("Standard1", mutations);
+
+        return mutationMap;
+    }
+}
diff --git a/contrib/stress/src/org/apache/cassandra/contrib/stress/tests/MultiGetter.java b/contrib/stress/src/org/apache/cassandra/contrib/stress/tests/MultiGetter.java
new file mode 100644
index 0000000000..ce6a420f97
--- /dev/null
+++ b/contrib/stress/src/org/apache/cassandra/contrib/stress/tests/MultiGetter.java
@@ -0,0 +1,144 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.cassandra.contrib.stress.tests;
+
+import org.apache.cassandra.contrib.stress.util.OperationThread;
+import org.apache.cassandra.db.ColumnFamilyType;
+import org.apache.cassandra.thrift.*;
+
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+
+public class MultiGetter extends OperationThread
+{
+    public MultiGetter(int index)
+    {
+        super(index);
+    }
+
+    public void run()
+    {
+        SlicePredicate predicate = new SlicePredicate().setSlice_range(new SliceRange(ByteBuffer.wrap(new byte[]{}),
+                                                                                      ByteBuffer.wrap(new byte[] {}),
+                                                                                      false, session.getColumnsPerKey()));
+
+        int offset = index * session.getKeysPerThread();
+        Map<ByteBuffer,List<ColumnOrSuperColumn>> results = null;
+        int count  = (((index + 1) * session.getKeysPerThread()) - offset) / session.getKeysPerCall();
+
+        if (session.getColumnFamilyType() == ColumnFamilyType.Super)
+        {
+            for (int i = 0; i < count; i++)
+            {
+                List<ByteBuffer> keys = generateKeys(offset, offset + session.getKeysPerCall());
+
+                for (int j = 0; j < session.getSuperColumns(); j++)
+                {
+                    ColumnParent parent = new ColumnParent("Super1").setSuper_column(("S" + j).getBytes());
+
+                    long start = System.currentTimeMillis();
+
+                    try
+                    {
+                        results = client.multiget_slice(keys, parent, predicate, session.getConsistencyLevel());
+
+                        if (results.size() == 0)
+                        {
+                            throw new RuntimeException(String.format("Keys %s not found", keys));
+                        }
+                    }
+                    catch (InvalidRequestException e)
+                    {
+                        System.err.println(e.getWhy());
+
+                        if (!session.ignoreErrors())
+                            return;
+                    }
+                    catch (Exception e)
+                    {
+                        System.err.println(e.getMessage());
+
+                        if (!session.ignoreErrors())
+                            return;
+                    }
+
+                    session.operationCount.getAndIncrement(index);
+                    session.keyCount.getAndAdd(index, keys.size());
+                    session.latencies.getAndAdd(index, System.currentTimeMillis() - start);
+
+                    offset += session.getKeysPerCall();
+                }
+            }
+        }
+        else
+        {
+            ColumnParent parent = new ColumnParent("Standard1");
+
+            for (int i = 0; i < count; i++)
+            {
+                List<ByteBuffer> keys = generateKeys(offset, offset + session.getKeysPerCall());
+
+                long start = System.currentTimeMillis();
+
+                try
+                {
+                    results = client.multiget_slice(keys, parent, predicate, session.getConsistencyLevel());
+
+                    if (results.size() == 0)
+                    {
+                        throw new RuntimeException(String.format("Keys %s not found", keys));
+                    }
+                }
+                catch (InvalidRequestException e)
+                {
+                    System.err.println(e.getWhy());
+
+                    if (!session.ignoreErrors())
+                        return;
+                }
+                catch (Exception e)
+                {
+                    System.err.println(e.getMessage());
+
+                    if (!session.ignoreErrors())
+                        return;
+                }
+
+                session.operationCount.getAndIncrement(index);
+                session.keyCount.getAndAdd(index, keys.size());
+                session.latencies.getAndAdd(index, System.currentTimeMillis() - start);
+
+                offset += session.getKeysPerCall();
+            }
+        }
+    }
+
+    private List<ByteBuffer> generateKeys(int start, int limit)
+    {
+        List<ByteBuffer> keys = new ArrayList<ByteBuffer>();
+
+        for (int i = start; i < limit; i++)
+        {
+            keys.add(ByteBuffer.wrap(generateKey()));
+        }
+
+        return keys;
+    }
+}
diff --git a/contrib/stress/src/org/apache/cassandra/contrib/stress/tests/RangeSlicer.java b/contrib/stress/src/org/apache/cassandra/contrib/stress/tests/RangeSlicer.java
new file mode 100644
index 0000000000..6b55822d2a
--- /dev/null
+++ b/contrib/stress/src/org/apache/cassandra/contrib/stress/tests/RangeSlicer.java
@@ -0,0 +1,148 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.cassandra.contrib.stress.tests;
+
+import org.apache.cassandra.contrib.stress.util.OperationThread;
+import org.apache.cassandra.db.ColumnFamilyType;
+import org.apache.cassandra.thrift.*;
+
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.List;
+
+public class RangeSlicer extends OperationThread
+{
+
+    public RangeSlicer(int index)
+    {
+        super(index);
+    }
+
+    public void run()
+    {
+        String format = "%0" + session.getTotalKeysLength() + "d";
+
+        // initial values
+        int current = range.begins();
+        int limit   = range.limit();
+        int count   = session.getColumnsPerKey();
+        int last    = current + session.getKeysPerCall();
+
+        SlicePredicate predicate = new SlicePredicate().setSlice_range(new SliceRange(ByteBuffer.wrap(new byte[] {}),
+                                                                                      ByteBuffer.wrap(new byte[] {}),
+                                                                                      false, count));
+
+        if (session.getColumnFamilyType() == ColumnFamilyType.Super)
+        {
+            while (current < limit)
+            {
+                byte[] start = String.format(format, current).getBytes();
+                byte[] end   = String.format(format, last).getBytes();
+
+                List<KeySlice> slices = new ArrayList<KeySlice>();
+                KeyRange range = new KeyRange(count).setStart_key(start).setEnd_key(end);
+
+                for (int i = 0; i < session.getSuperColumns(); i++)
+                {
+                    String superColumnName = "S" + Integer.toString(i);
+                    ColumnParent parent = new ColumnParent("Super1").setSuper_column(ByteBuffer.wrap(superColumnName.getBytes()));
+
+                    long startTime = System.currentTimeMillis();
+
+                    try
+                    {
+                        slices = client.get_range_slices(parent, predicate, range, session.getConsistencyLevel());
+
+                        if (slices.size() == 0)
+                        {
+                            throw new RuntimeException(String.format("Key %s not found.", superColumnName));
+                        }
+                    }
+                    catch (InvalidRequestException e)
+                    {
+                        System.err.println(e.getWhy());
+
+                        if (!session.ignoreErrors())
+                            return;
+                    }
+                    catch (Exception e)
+                    {
+                        System.err.println(e.getMessage());
+
+                        if (!session.ignoreErrors())
+                            return;
+                    }
+
+                    session.operationCount.getAndIncrement(index);
+                    session.latencies.getAndAdd(index, System.currentTimeMillis() - startTime);
+                }
+
+                current += slices.size() + 1;
+                last = current + slices.size() + 1;
+                session.keyCount.getAndAdd(index, slices.size());
+            }
+        }
+        else
+        {
+            ColumnParent parent = new ColumnParent("Standard1");
+
+            while (current < limit)
+            {
+                byte[] start = String.format(format, current).getBytes();
+                byte[] end   = String.format(format, last).getBytes();
+
+                List<KeySlice> slices = new ArrayList<KeySlice>();
+                KeyRange range = new KeyRange(count).setStart_key(start).setEnd_key(end);
+
+                long startTime = System.currentTimeMillis();
+
+                try
+                {
+                    slices = client.get_range_slices(parent, predicate, range, session.getConsistencyLevel());
+
+                    if (slices.size() == 0)
+                    {
+                        throw new RuntimeException(String.format("Range %s %s not found.", String.format(format, current),
+                                                                                           String.format(format, last)));
+                    }
+                }
+                catch (InvalidRequestException e)
+                {
+                    System.err.println(e.getWhy());
+
+                    if (!session.ignoreErrors())
+                        return;
+                }
+                catch (Exception e)
+                {
+                    System.err.println(e.getMessage());
+
+                    if (!session.ignoreErrors())
+                        return;
+                }
+
+                current += slices.size() + 1;
+                last = current + slices.size() + 1;
+
+                session.operationCount.getAndIncrement(index);
+                session.keyCount.getAndAdd(index, slices.size());
+                session.latencies.getAndAdd(index, System.currentTimeMillis() - startTime);
+            }
+        }
+    }
+}
diff --git a/contrib/stress/src/org/apache/cassandra/contrib/stress/tests/Reader.java b/contrib/stress/src/org/apache/cassandra/contrib/stress/tests/Reader.java
new file mode 100644
index 0000000000..6a1000e6d9
--- /dev/null
+++ b/contrib/stress/src/org/apache/cassandra/contrib/stress/tests/Reader.java
@@ -0,0 +1,132 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.cassandra.contrib.stress.tests;
+
+import org.apache.cassandra.contrib.stress.util.OperationThread;
+import org.apache.cassandra.db.ColumnFamilyType;
+import org.apache.cassandra.thrift.ColumnOrSuperColumn;
+import org.apache.cassandra.thrift.ColumnParent;
+import org.apache.cassandra.thrift.SlicePredicate;
+import org.apache.cassandra.thrift.SliceRange;
+
+import java.nio.ByteBuffer;
+import java.util.List;
+
+public class Reader extends OperationThread
+{
+    public Reader(int index)
+    {
+        super(index);
+    }
+
+    public void run()
+    {
+        SliceRange sliceRange = new SliceRange();
+
+        // start/finish
+        sliceRange.setStart(new byte[] {}).setFinish(new byte[] {});
+
+        // reversed/count
+        sliceRange.setReversed(false).setCount(session.getColumnsPerKey());
+
+        // initialize SlicePredicate with existing SliceRange
+        SlicePredicate predicate = new SlicePredicate().setSlice_range(sliceRange);
+
+        if (session.getColumnFamilyType() == ColumnFamilyType.Super)
+        {
+            runSuperColumnReader(predicate);
+        }
+        else
+        {
+            runColumnReader(predicate);
+        }
+    }
+
+    private void runSuperColumnReader(SlicePredicate predicate)
+    {
+        for (int i = 0; i < session.getKeysPerThread(); i++)
+        {
+            ByteBuffer key = ByteBuffer.wrap(generateKey());
+
+            for (int j = 0; j < session.getSuperColumns(); j++)
+            {
+                String superColumn = 'S' + Integer.toString(j);
+                ColumnParent parent = new ColumnParent("Super1").setSuper_column(superColumn.getBytes());
+
+                long start = System.currentTimeMillis();
+
+                try
+                {
+                    List<ColumnOrSuperColumn> columns;
+                    columns = client.get_slice(key, parent, predicate, session.getConsistencyLevel());
+
+                    if (columns == null)
+                    {
+                        throw new RuntimeException(String.format("Key %s not found.", superColumn));
+                    }
+                }
+                catch (Exception e)
+                {
+                    System.err.println(e.getMessage());
+
+                    if (!session.ignoreErrors())
+                        break;
+                }
+
+                session.operationCount.getAndIncrement(index);
+                session.keyCount.getAndIncrement(index);
+                session.latencies.getAndAdd(index, System.currentTimeMillis() - start);
+            }
+        }
+    }
+
+    private void runColumnReader(SlicePredicate predicate)
+    {
+        ColumnParent parent = new ColumnParent("Standard1");
+
+        for (int i = 0; i < session.getKeysPerThread(); i++)
+        {
+            byte[] key = generateKey();
+            ByteBuffer keyBuffer = ByteBuffer.wrap(key);
+
+            long start = System.currentTimeMillis();
+
+            try
+            {
+                List<ColumnOrSuperColumn> columns;
+                columns = client.get_slice(keyBuffer, parent, predicate, session.getConsistencyLevel());
+
+                if (columns == null)
+                {
+                    throw new RuntimeException(String.format("Key %s not found.", key.toString()));
+                }
+            }
+            catch (Exception e)
+            {
+                System.err.println(e.getMessage());
+
+                if (!session.ignoreErrors())
+                    break;
+            }
+
+            session.operationCount.getAndIncrement(index);
+            session.keyCount.getAndIncrement(index);
+            session.latencies.getAndAdd(index, System.currentTimeMillis() - start);
+        }
+    }
+}
diff --git a/contrib/stress/src/org/apache/cassandra/contrib/stress/util/OperationThread.java b/contrib/stress/src/org/apache/cassandra/contrib/stress/util/OperationThread.java
new file mode 100644
index 0000000000..d51b97644c
--- /dev/null
+++ b/contrib/stress/src/org/apache/cassandra/contrib/stress/util/OperationThread.java
@@ -0,0 +1,181 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.cassandra.contrib.stress.util;
+
+import org.apache.cassandra.contrib.stress.Session;
+import org.apache.cassandra.contrib.stress.Stress;
+import org.apache.cassandra.thrift.Cassandra;
+
+import java.math.BigInteger;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Random;
+
+public abstract class OperationThread extends Thread
+{
+    public final int index;
+
+    protected final Session session;
+    protected final Cassandra.Client client;
+
+    protected final Range range;
+
+    protected Double nextGaussian = null;
+
+    public OperationThread(int idx)
+    {
+        index = idx;
+        session = Stress.session;
+
+        int keysPerThread = session.getKeysPerThread();
+        range = new Range((int) (keysPerThread * (idx + session.getSkipKeys())), keysPerThread * (idx + 1));
+
+        client = session.getClient();
+    }
+
+    /**
+     * def generate_values():
+     *   values = []
+     *   for i in xrange(0, options.cardinality):
+     *       h = md5(str(i)).hexdigest()
+     *       values.append(h * int(options.column_size/len(h)) + h[:options.column_size % len(h)])
+     *   return values
+     *
+     * @return Collection of the values
+     */
+    protected List<String> generateValues()
+    {
+        List<String> values = new ArrayList<String>();
+
+        for (int i = 0; i < session.getCardinality(); i++)
+        {
+            String hash = getMD5(Integer.toString(i));
+            int times = session.getColumnSize() / hash.length();
+            int sumReminder = session.getColumnSize() % hash.length();
+
+            values.add(new StringBuilder(multiplyString(hash, times)).append(hash.substring(0, sumReminder)).toString());
+        }
+
+        return values;
+    }
+
+    /**
+     * key generator using Gauss or Random algorithm
+     * @return byte[] representation of the key string
+     */
+    protected byte[] generateKey()
+    {
+        return (session.useRandomGenerator()) ? generateRandomKey() : generateGaussKey();
+    }
+
+    /**
+     * Random key generator
+     * @return byte[] representation of the key string
+     */
+    private byte[] generateRandomKey()
+    {
+        String format = "%0" + session.getTotalKeysLength() + "d";
+        return String.format(format, Stress.randomizer.nextInt(session.getNumKeys() - 1)).getBytes();
+    }
+
+    /**
+     * Gauss key generator
+     * @return byte[] representation of the key string
+     */
+    private byte[] generateGaussKey()
+    {
+        String format = "%0" + session.getTotalKeysLength() + "f";
+
+        for (;;)
+        {
+            double token = nextGaussian(session.getMean(), session.getSigma());
+
+            if (0 <= token && token < session.getNumKeys())
+            {
+                return String.format(format, token).getBytes();
+            }
+        }
+    }
+
+    /**
+     * Gaussian distribution.
+     * @param mu is the mean
+     * @param sigma is the standard deviation
+     *
+     * @return next Gaussian distribution number
+     */
+    private double nextGaussian(int mu, float sigma)
+    {
+        Random random = Stress.randomizer;
+        Double currentState = nextGaussian;
+
+        if (currentState == null)
+        {
+            double x2pi  = random.nextDouble() * 2 * Math.PI;
+            double g2rad = Math.sqrt(-2.0 * Math.log(1.0 - random.nextDouble()));
+
+            currentState = Math.cos(x2pi) * g2rad;
+            nextGaussian = Math.sin(x2pi) * g2rad;
+        }
+
+        return mu + currentState * sigma;
+    }
+
+    /**
+     * MD5 string generation
+     * @param input String
+     * @return md5 representation of the string
+     */
+    private String getMD5(String input)
+    {
+        try
+        {
+            MessageDigest md = MessageDigest.getInstance("MD5");
+            byte[] messageDigest = md.digest(input.getBytes());
+            StringBuilder hash = new StringBuilder(new BigInteger(1, messageDigest).toString(16));
+
+            while (hash.length() < 32)
+                hash.append("0").append(hash);
+
+            return hash.toString();
+        }
+        catch (NoSuchAlgorithmException e)
+        {
+            throw new RuntimeException(e);
+        }
+    }
+
+    /**
+     * Equal to python/ruby - 's' * times
+     * @param str String to multiple
+     * @param times multiplication times
+     * @return multiplied string
+     */
+    private String multiplyString(String str, int times)
+    {
+        StringBuilder result = new StringBuilder();
+
+        for (int i = 0; i < times; i++)
+            result.append(str);
+
+        return result.toString();
+    }
+
+}
diff --git a/contrib/stress/src/org/apache/cassandra/contrib/stress/util/Range.java b/contrib/stress/src/org/apache/cassandra/contrib/stress/util/Range.java
new file mode 100644
index 0000000000..04117dc7c8
--- /dev/null
+++ b/contrib/stress/src/org/apache/cassandra/contrib/stress/util/Range.java
@@ -0,0 +1,72 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.cassandra.contrib.stress.util;
+
+import java.util.Iterator;
+
+public class Range implements Iterable<Integer>, Iterator<Integer>
+{
+    private int begin, current, limit;
+
+    public Range(int end)
+    {
+        this(0, end);
+    }
+
+    public Range(int start, int end)
+    {
+        begin = current = start;
+        limit = end;
+    }
+
+    public boolean hasNext()
+    {
+        return (current < limit);
+    }
+
+    public Integer next()
+    {
+        return current++;
+    }
+
+    public void remove()
+    {
+        throw new UnsupportedOperationException();
+    }
+
+    public Iterator<Integer> iterator()
+    {
+        return this;
+    }
+
+    public int begins()
+    {
+        return begin;
+    }
+
+    public int limit()
+    {
+        return limit;
+    }
+
+    public int size()
+    {
+        return limit - begin;
+    }
+
+}
