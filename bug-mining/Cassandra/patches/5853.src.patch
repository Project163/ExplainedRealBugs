diff --git a/test/distributed/org/apache/cassandra/distributed/test/OptimiseStreamsRepairTest.java b/test/distributed/org/apache/cassandra/distributed/test/OptimiseStreamsRepairTest.java
index 96ae1dc6e0..14d49dc0ca 100644
--- a/test/distributed/org/apache/cassandra/distributed/test/OptimiseStreamsRepairTest.java
+++ b/test/distributed/org/apache/cassandra/distributed/test/OptimiseStreamsRepairTest.java
@@ -32,6 +32,7 @@ import java.util.concurrent.Callable;
 import java.util.function.Function;
 import java.util.function.Predicate;
 
+import java.util.concurrent.TimeoutException;
 import org.junit.Test;
 
 import net.bytebuddy.ByteBuddy;
@@ -86,9 +87,12 @@ public class OptimiseStreamsRepairTest extends TestBaseImpl
             cluster.forEach(c -> c.flush(KEYSPACE));
             cluster.forEach(c -> c.forceCompact(KEYSPACE, "tbl"));
 
+            long [] marks = PreviewRepairTest.logMark(cluster);
             NodeToolResult res = cluster.get(1).nodetoolResult("repair", KEYSPACE, "-os");
             res.asserts().success();
 
+            PreviewRepairTest.waitLogsRepairFullyFinished(cluster, marks);
+
             res = cluster.get(1).nodetoolResult("repair", KEYSPACE, "-vd");
             res.asserts().success();
             res.asserts().notificationContains("Repaired data is in sync");
@@ -162,7 +166,7 @@ public class OptimiseStreamsRepairTest extends TestBaseImpl
     }
 
     @Test
-    public void randomTest() throws IOException
+    public void randomTest() throws IOException, TimeoutException
     {
         try(Cluster cluster = init(Cluster.build(3)
                                           .withConfig(config -> config.set("hinted_handoff_enabled", false)
@@ -180,9 +184,10 @@ public class OptimiseStreamsRepairTest extends TestBaseImpl
                 for (int j = 1; j <= 3; j++)
                     cluster.get(j).executeInternal("INSERT INTO "+KEYSPACE+".tbl (id, t) values (?,?)", r.nextInt(), i * 2 + 2);
 
+            long [] marks = PreviewRepairTest.logMark(cluster);
             NodeToolResult res = cluster.get(1).nodetoolResult("repair", KEYSPACE, "-os");
             res.asserts().success();
-
+            PreviewRepairTest.waitLogsRepairFullyFinished(cluster, marks);
             res = cluster.get(1).nodetoolResult("repair", KEYSPACE, "-vd");
             res.asserts().success();
             res.asserts().notificationContains("Repaired data is in sync");
diff --git a/test/distributed/org/apache/cassandra/distributed/test/PreviewRepairTest.java b/test/distributed/org/apache/cassandra/distributed/test/PreviewRepairTest.java
index 1ad1ba62de..849bc652e1 100644
--- a/test/distributed/org/apache/cassandra/distributed/test/PreviewRepairTest.java
+++ b/test/distributed/org/apache/cassandra/distributed/test/PreviewRepairTest.java
@@ -29,6 +29,7 @@ import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 
@@ -106,6 +107,7 @@ public class PreviewRepairTest extends TestBaseImpl
                 FBUtilities.waitOnFutures(CompactionManager.instance.submitBackground(cfs));
                 cfs.disableAutoCompaction();
             }));
+            long[] marks = logMark(cluster);
             cluster.get(1).callOnInstance(repair(options(false, false)));
             // now re-enable autocompaction on node1, this moves the sstables for the new repair to repaired
             cluster.get(1).runOnInstance(() -> {
@@ -114,8 +116,7 @@ public class PreviewRepairTest extends TestBaseImpl
                 FBUtilities.waitOnFutures(CompactionManager.instance.submitBackground(cfs));
             });
 
-            //IR and Preview repair can't run concurrently. In case the test is flaky, please check CASSANDRA-15685
-            Thread.sleep(1000);
+            waitLogsRepairFullyFinished(cluster, marks);
 
             RepairResult rs = cluster.get(1).callOnInstance(repair(options(true, false)));
             assertTrue(rs.success); // preview repair should succeed
@@ -123,6 +124,22 @@ public class PreviewRepairTest extends TestBaseImpl
         }
     }
 
+    public static void waitLogsRepairFullyFinished(Cluster cluster, long[] marks) throws TimeoutException
+    {
+        for (int i = 0; i < cluster.size(); i++)
+            cluster.get(i + 1).logs().watchFor(marks[i], "Finalized local repair session");
+    }
+
+    public static long[] logMark(Cluster cluster)
+    {
+        long [] marks = new long[cluster.size()];
+        for (int i = 0; i < cluster.size(); i++)
+        {
+            marks[i] = cluster.get(i + 1).logs().mark();
+        }
+        return marks;
+    }
+
     /**
      * another case where the repaired datasets could mismatch is if an incremental repair finishes just as the preview
      * repair is starting up.
