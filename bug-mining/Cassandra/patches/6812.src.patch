diff --git a/modules/accord b/modules/accord
index 2b80b0233f..07ba9c85d0 160000
--- a/modules/accord
+++ b/modules/accord
@@ -1 +1 @@
-Subproject commit 2b80b0233f96464430058d70f7398df11066c3a6
+Subproject commit 07ba9c85d083b586ff5c2382ef747b0fe71a9c47
diff --git a/src/java/org/apache/cassandra/service/accord/journal/AccordTopologyUpdate.java b/src/java/org/apache/cassandra/service/accord/journal/AccordTopologyUpdate.java
index a01580363f..940c9090a5 100644
--- a/src/java/org/apache/cassandra/service/accord/journal/AccordTopologyUpdate.java
+++ b/src/java/org/apache/cassandra/service/accord/journal/AccordTopologyUpdate.java
@@ -51,6 +51,7 @@ public interface AccordTopologyUpdate
     void applyTo(TopologyImage accumulator);
     long epoch();
 
+    Journal.TopologyUpdate getUpdate();
     static AccordTopologyUpdate newTopology(Journal.TopologyUpdate update)
     {
         return new NewTopology(update);
@@ -161,9 +162,25 @@ public interface AccordTopologyUpdate
             switch (t.kind())
             {
                 case NewTopology:
+                {
                     TopologyUpdateSerializer.instance.serialize(((NewTopology) t).update, out);
                     break;
-                case Topologies:
+                }
+                case NoOp:
+                {
+                    TopologyImage image = (TopologyImage) t;
+                    Invariants.require(image.update == null);
+                    if (image.syncStatus == null)
+                        out.writeByte(Byte.MAX_VALUE);
+                    else
+                        out.writeByte(image.syncStatus.ordinal());
+
+                    KeySerializers.ranges.serialize(image.closed, out);
+                    KeySerializers.ranges.serialize(image.retired, out);
+                    break;
+                }
+                case TopologyImage:
+                {
                     TopologyImage image = (TopologyImage) t;
 
                     out.writeBoolean(image.update != null);
@@ -177,6 +194,7 @@ public interface AccordTopologyUpdate
                     KeySerializers.ranges.serialize(image.closed, out);
                     KeySerializers.ranges.serialize(image.retired, out);
                     break;
+                }
                 default:
                     throw new UnhandledEnum(t.kind());
             }
@@ -191,9 +209,20 @@ public interface AccordTopologyUpdate
             {
                 case NewTopology:
                     return new NewTopology(TopologyUpdateSerializer.instance.deserialize(in));
-                case Topologies:
+                case NoOp:
                 {
-                    TopologyImage image = new TopologyImage(epoch);
+                    TopologyImage image = new TopologyImage(epoch, Kind.NoOp);
+                    byte syncStateByte = in.readByte();
+                    if (syncStateByte != Byte.MAX_VALUE)
+                        image.syncStatus = AccordConfigurationService.SyncStatus.values()[syncStateByte];
+
+                    image.closed = KeySerializers.ranges.deserialize(in);
+                    image.retired = KeySerializers.ranges.deserialize(in);
+                    return image;
+                }
+                case TopologyImage:
+                {
+                    TopologyImage image = new TopologyImage(epoch, Kind.TopologyImage);
                     if (in.readBoolean())
                         image.update = TopologyUpdateSerializer.instance.deserialize(in);
 
@@ -221,7 +250,19 @@ public interface AccordTopologyUpdate
                 case NewTopology:
                     size += TopologyUpdateSerializer.instance.serializedSize(((NewTopology) t).update);
                     break;
-                case Topologies:
+                case NoOp:
+                {
+                    TopologyImage image = (TopologyImage) t;
+                    Invariants.require(image.update == null);
+
+                    size += Byte.BYTES;
+
+                    size += KeySerializers.ranges.serializedSize(image.closed);
+                    size += KeySerializers.ranges.serializedSize(image.retired);
+                    break;
+                }
+                case TopologyImage:
+                {
                     TopologyImage image = (TopologyImage) t;
 
                     size += TypeSizes.sizeof(image.update != null);
@@ -233,6 +274,7 @@ public interface AccordTopologyUpdate
                     size += KeySerializers.ranges.serializedSize(image.closed);
                     size += KeySerializers.ranges.serializedSize(image.retired);
                     break;
+                }
                 default:
                     throw new UnhandledEnum(t.kind());
             }
@@ -242,8 +284,12 @@ public interface AccordTopologyUpdate
 
     enum Kind
     {
+        // New Topology, written to journal when the node first learned about it
         NewTopology,
-        Topologies
+        // Used when accumulating state during compaction or replay
+        TopologyImage,
+        // Effectively unchanged topology
+        NoOp
     }
 
     class ImmutableTopoloyImage extends Journal.TopologyUpdate
@@ -263,10 +309,30 @@ public interface AccordTopologyUpdate
         private Ranges retired = Ranges.EMPTY;
 
         private final long epoch;
+        private final Kind kind;
 
-        public TopologyImage(long epoch)
+        public TopologyImage(long epoch, Kind kind)
         {
+            Invariants.require(kind != Kind.NewTopology);
             this.epoch = epoch;
+            this.kind = kind;
+        }
+
+        public TopologyImage asImage(Journal.TopologyUpdate update)
+        {
+            TopologyImage image = new TopologyImage(epoch, Kind.TopologyImage);
+            image.update = update.cloneWithEquivalentEpoch(epoch);
+            image.closed = closed;
+            image.retired = retired;
+            return image;
+        }
+
+        public TopologyImage asNoOp()
+        {
+            TopologyImage image = new TopologyImage(epoch, Kind.NoOp);
+            image.closed = closed;
+            image.retired = retired;
+            return image;
         }
 
         @Override
@@ -275,10 +341,16 @@ public interface AccordTopologyUpdate
             return this.epoch;
         }
 
+        @Override
+        public Journal.TopologyUpdate getUpdate()
+        {
+            return update;
+        }
+
         @Override
         public Kind kind()
         {
-            return Kind.Topologies;
+            return kind;
         }
 
         @Override
@@ -327,6 +399,12 @@ public interface AccordTopologyUpdate
             return this.epoch;
         }
 
+        @Override
+        public Journal.TopologyUpdate getUpdate()
+        {
+            return update;
+        }
+
         @Override
         public Kind kind()
         {
@@ -385,7 +463,7 @@ public interface AccordTopologyUpdate
         @Override
         protected NavigableMap<Long, TopologyImage> accumulate(NavigableMap<Long, TopologyImage> allEpochs, AccordTopologyUpdate update)
         {
-            update.applyTo(allEpochs.computeIfAbsent(update.epoch(), v -> new TopologyImage(update.epoch())));
+            update.applyTo(allEpochs.computeIfAbsent(update.epoch(), v -> new TopologyImage(update.epoch(), Kind.TopologyImage)));
             return allEpochs;
         }
     }
@@ -434,8 +512,16 @@ public interface AccordTopologyUpdate
         public void reserialize(JournalKey key, Accumulator from, DataOutputPlus out, Version version) throws IOException
         {
             out.writeUnsignedVInt32(from.get().size());
+            Journal.TopologyUpdate prev = null;
             for (TopologyImage value : from.get().values())
+            {
+                Journal.TopologyUpdate tmp = value.update;
+                if (prev != null && value.update.isEquivalent(prev))
+                    value = value.asNoOp();
+
+                prev = tmp;
                 Serializer.instance.serialize(value, out);
+            }
         }
 
         @Override
@@ -443,13 +529,18 @@ public interface AccordTopologyUpdate
         {
             long minEpoch = this.minEpoch.epoch();
             int count = in.readUnsignedVInt32();
+            AccordTopologyUpdate prev = null;
             while (--count >= 0)
             {
                 AccordTopologyUpdate update = Serializer.instance.deserialize(in);
+                if (update.kind() == Kind.NoOp)
+                {
+                    Invariants.require(prev != null);
+                    update = ((TopologyImage) update).asImage(prev.getUpdate());
+                }
                 if (update.epoch() >= minEpoch)
                     into.update(update);
-                else
-                    return;
+                prev = update;
             }
         }
     }
diff --git a/test/distributed/org/apache/cassandra/fuzz/topology/IdenticalTopologyTest.java b/test/distributed/org/apache/cassandra/fuzz/topology/IdenticalTopologyTest.java
new file mode 100644
index 0000000000..b35954735e
--- /dev/null
+++ b/test/distributed/org/apache/cassandra/fuzz/topology/IdenticalTopologyTest.java
@@ -0,0 +1,97 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.cassandra.fuzz.topology;
+
+import org.junit.Test;
+
+import org.apache.cassandra.db.Keyspace;
+import org.apache.cassandra.distributed.Cluster;
+import org.apache.cassandra.distributed.api.ConsistencyLevel;
+import org.apache.cassandra.distributed.shared.ClusterUtils;
+import org.apache.cassandra.distributed.test.log.FuzzTestBase;
+import org.apache.cassandra.harry.SchemaSpec;
+import org.apache.cassandra.harry.dsl.HistoryBuilder;
+import org.apache.cassandra.harry.dsl.ReplayingHistoryBuilder;
+import org.apache.cassandra.harry.execution.InJvmDTestVisitExecutor;
+import org.apache.cassandra.harry.execution.QueryBuildingVisitExecutor;
+import org.apache.cassandra.harry.gen.Generator;
+import org.apache.cassandra.harry.gen.SchemaGenerators;
+import org.apache.cassandra.schema.SchemaConstants;
+import org.apache.cassandra.service.accord.AccordKeyspace;
+import org.apache.cassandra.service.accord.AccordService;
+import org.apache.cassandra.service.consensus.TransactionalMode;
+
+import static org.apache.cassandra.harry.checker.TestHelper.withRandom;
+
+public class IdenticalTopologyTest extends FuzzTestBase
+{
+    private static final int POPULATION = 1000;
+
+    @Test
+    public void identicalTopologyTest() throws Throwable
+    {
+        try (Cluster cluster = init(builder().withNodes(1)
+                                             .withConfig(cfg -> cfg.set("accord.journal.compaction_period", "600s") // deliberately high
+                                                                   .set("max_value_size", "1MiB")) // deliberately low
+                                             .start(),
+                                    1))
+        {
+            withRandom(rng -> {
+                cluster.get(1).runOnInstance(() -> {
+                    Keyspace.open(SchemaConstants.ACCORD_KEYSPACE_NAME).getColumnFamilyStore(AccordKeyspace.JOURNAL).disableAutoCompaction();
+                });
+
+                Generator<SchemaSpec> schemaGen = SchemaGenerators.trivialSchema(KEYSPACE, "bootstrap_fuzz", POPULATION,
+                                                                                 SchemaSpec.optionsBuilder()
+                                                                                           .addWriteTimestamps(false)
+                                                                                           .withTransactionalMode(TransactionalMode.full));
+
+                SchemaSpec schema = schemaGen.generate(rng);
+                cluster.schemaChange(schema.compile());
+                HistoryBuilder history = new ReplayingHistoryBuilder(schema.valueGenerators,
+                                                                     hb -> InJvmDTestVisitExecutor.builder()
+                                                                                                  .consistencyLevel(ConsistencyLevel.QUORUM)
+                                                                                                  .wrapQueries(QueryBuildingVisitExecutor.WrapQueries.TRANSACTION)
+                                                                                                  .pageSizeSelector(p -> InJvmDTestVisitExecutor.PageSizeSelector.NO_PAGING)
+                                                                                                  .build(schema, hb, cluster));
+
+                for (int i = 0; i <= 100; i++)
+                {
+                    cluster.schemaChange(String.format("ALTER TABLE %s.%s WITH comment = '%d';", schema.keyspace, schema.table, i));
+
+                    for (int j = 0; j < 5; j++)
+                        history.insert(j);
+                    if (i % 20 == 0)
+                    {
+                        cluster.get(1).runOnInstance(() -> {
+                            ((AccordService) AccordService.instance()).journal().closeCurrentSegmentForTestingIfNonEmpty();
+                        });
+                    }
+                }
+                cluster.get(1).runOnInstance(() -> {
+                    ((AccordService) AccordService.instance()).journal().compactor().run();
+                });
+                cluster.get(1).forceCompact("system_accord", "journal");
+                ClusterUtils.stopUnchecked(cluster.get(1));
+                cluster.get(1).startup();
+            });
+        }
+    }
+}
+
diff --git a/test/unit/org/apache/cassandra/service/accord/journal/AccordTopologyUpdateTest.java b/test/unit/org/apache/cassandra/service/accord/journal/AccordTopologyUpdateTest.java
index c9ed1c5af3..109aa3ed46 100644
--- a/test/unit/org/apache/cassandra/service/accord/journal/AccordTopologyUpdateTest.java
+++ b/test/unit/org/apache/cassandra/service/accord/journal/AccordTopologyUpdateTest.java
@@ -141,7 +141,8 @@ public class AccordTopologyUpdateTest
             switch (kind)
             {
                 case NewTopology: return new AccordTopologyUpdate.NewTopology(topologyUpdateGen.next(rs));
-                case Topologies: return new AccordTopologyUpdate.TopologyImage(epochGen.nextLong(rs));
+                case TopologyImage: return new AccordTopologyUpdate.TopologyImage(epochGen.nextLong(rs), AccordTopologyUpdate.Kind.TopologyImage);
+                case NoOp: return new AccordTopologyUpdate.TopologyImage(epochGen.nextLong(rs), AccordTopologyUpdate.Kind.NoOp);
                 default: throw new AssertionError("Unknown kind: " + kind);
             }
         };
