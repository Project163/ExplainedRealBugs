diff --git a/CHANGES.txt b/CHANGES.txt
index 75dd48aa02..49eb15619f 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 5.1
+ * Include column drop timestamp in alter table transformation (CASSANDRA-18961)
  * Make JMX SSL configurable in cassandra.yaml (CASSANDRA-18508)
  * Fix cqlsh CAPTURE command to save query results without trace details when TRACING is ON (CASSANDRA-19105)
  * Optionally prevent tombstone purging during repair (CASSANDRA-20071)
diff --git a/src/java/org/apache/cassandra/cql3/statements/schema/AlterSchemaStatement.java b/src/java/org/apache/cassandra/cql3/statements/schema/AlterSchemaStatement.java
index a3be1d0e06..590a55a3f9 100644
--- a/src/java/org/apache/cassandra/cql3/statements/schema/AlterSchemaStatement.java
+++ b/src/java/org/apache/cassandra/cql3/statements/schema/AlterSchemaStatement.java
@@ -17,6 +17,7 @@
  */
 package org.apache.cassandra.cql3.statements.schema;
 
+import java.util.Optional;
 import java.util.Set;
 
 import com.google.common.collect.ImmutableSet;
@@ -46,6 +47,8 @@ abstract public class AlterSchemaStatement implements CQLStatement.SingleKeyspac
     // TODO: not sure if this is going to stay the same, or will be replaced by more efficient serialization/sanitation means
     // or just `toString` for every statement
     private String cql;
+    public static final long NO_EXECUTION_TIMESTAMP = -1;
+    private long executionTimestamp = NO_EXECUTION_TIMESTAMP;
 
     protected AlterSchemaStatement(String keyspaceName)
     {
@@ -57,6 +60,11 @@ abstract public class AlterSchemaStatement implements CQLStatement.SingleKeyspac
         this.cql = cql;
     }
 
+    public void setExecutionTimestamp(long executionTimestamp)
+    {
+        this.executionTimestamp = executionTimestamp;
+    }
+
     @Override
     public String cql()
     {
@@ -103,6 +111,12 @@ abstract public class AlterSchemaStatement implements CQLStatement.SingleKeyspac
         return keyspaceName;
     }
 
+    @Override
+    public Optional<Long> fixedTimestampMicros()
+    {
+        return executionTimestamp == NO_EXECUTION_TIMESTAMP ? Optional.empty() : Optional.of(executionTimestamp);
+    }
+
     public ResultMessage executeLocally(QueryState state, QueryOptions options)
     {
         return execute(state);
@@ -147,6 +161,7 @@ abstract public class AlterSchemaStatement implements CQLStatement.SingleKeyspac
             throw ire("Virtual keyspace '%s' is not user-modifiable", keyspaceName);
 
         validateKeyspaceName();
+        setExecutionTimestamp(state.getTimestamp());
         // Perform a 'dry-run' attempt to apply the transformation locally before submitting to the CMS. This can save a
         // round trip to the CMS for things syntax errors, but also fail fast for things like configuration errors.
         // Such failures may be dependent on the specific node's config (for things like guardrails/memtable
@@ -158,7 +173,6 @@ abstract public class AlterSchemaStatement implements CQLStatement.SingleKeyspac
         // cluster, as config can be heterogenous falling back to safe defaults may occur on some nodes.
         ClusterMetadata metadata = ClusterMetadata.current();
         apply(metadata);
-
         ClusterMetadata result = Schema.instance.submit(this);
 
         KeyspacesDiff diff = Keyspaces.diff(metadata.schema.getKeyspaces(), result.schema.getKeyspaces());
@@ -225,6 +239,7 @@ abstract public class AlterSchemaStatement implements CQLStatement.SingleKeyspac
         return "AlterSchemaStatement{" +
                "keyspaceName='" + keyspaceName + '\'' +
                ", cql='" + cql() + '\'' +
+               ", executionTimestamp="+executionTimestamp +
                '}';
     }
 }
diff --git a/src/java/org/apache/cassandra/cql3/statements/schema/AlterTableStatement.java b/src/java/org/apache/cassandra/cql3/statements/schema/AlterTableStatement.java
index 3a5b9ae8fb..4302919ca9 100644
--- a/src/java/org/apache/cassandra/cql3/statements/schema/AlterTableStatement.java
+++ b/src/java/org/apache/cassandra/cql3/statements/schema/AlterTableStatement.java
@@ -474,7 +474,14 @@ public abstract class AlterTableStatement extends AlterSchemaStatement
          */
         private long getTimestamp()
         {
-            return timestamp == null ? ClientState.getTimestamp() : timestamp;
+            // Prior to Metadata serialization V5, the execution timestamp was not included in AlterSchema
+            // serializations. Instead, the current time (from ClientState::getTimestamp) was used, making
+            // DROP COLUMN non-idempotent and causing potenial data loss as described in CASSANDRA-18961.
+            // This was fixed before release by serialization V5, but we include a dangerous backwards
+            // compatibility option here or so that we can still apply pre-V5 serialized transformations
+            // (which would only exist in clusters running pre-release versions of Cassandra). Once all peers
+            // are running a V5 compatible version, ClientState::getTimestamp will never be used.
+            return timestamp == null ? fixedTimestampMicros().orElseGet(ClientState::getTimestamp) : timestamp;
         }
     }
 
diff --git a/src/java/org/apache/cassandra/io/sstable/CQLSSTableWriter.java b/src/java/org/apache/cassandra/io/sstable/CQLSSTableWriter.java
index 8bb882071e..dbe91cee10 100644
--- a/src/java/org/apache/cassandra/io/sstable/CQLSSTableWriter.java
+++ b/src/java/org/apache/cassandra/io/sstable/CQLSSTableWriter.java
@@ -801,7 +801,7 @@ public class CQLSSTableWriter implements Closeable
         private void commitKeyspaceMetadata(KeyspaceMetadata keyspaceMetadata)
         {
             SchemaTransformation schemaTransformation = metadata -> metadata.schema.getKeyspaces().withAddedOrUpdated(keyspaceMetadata);
-            ClusterMetadataService.instance().commit(new AlterSchema(schemaTransformation, Schema.instance));
+            ClusterMetadataService.instance().commit(new AlterSchema(schemaTransformation));
         }
 
         /**
diff --git a/src/java/org/apache/cassandra/schema/Schema.java b/src/java/org/apache/cassandra/schema/Schema.java
index 147d24a804..afb987a7a0 100644
--- a/src/java/org/apache/cassandra/schema/Schema.java
+++ b/src/java/org/apache/cassandra/schema/Schema.java
@@ -289,7 +289,7 @@ public final class Schema implements SchemaProvider
         // result of this execution can be either a complete failure/timeout, or a success, but together with a log of
         // operations that have to be applied before we can do anything
         return ClusterMetadataService.instance()
-                                     .commit(new AlterSchema(transformation, this),
+                                     .commit(new AlterSchema(transformation),
                                              (metadata) -> metadata,
                                              (code, reason) -> {
                                                  switch (code)
diff --git a/src/java/org/apache/cassandra/tcm/membership/NodeVersion.java b/src/java/org/apache/cassandra/tcm/membership/NodeVersion.java
index 9ce9f46021..88d5296352 100644
--- a/src/java/org/apache/cassandra/tcm/membership/NodeVersion.java
+++ b/src/java/org/apache/cassandra/tcm/membership/NodeVersion.java
@@ -34,7 +34,7 @@ import static org.apache.cassandra.db.TypeSizes.sizeofUnsignedVInt;
 public class NodeVersion implements Comparable<NodeVersion>
 {
     public static final Serializer serializer = new Serializer();
-    public static final Version CURRENT_METADATA_VERSION = Version.V4;
+    public static final Version CURRENT_METADATA_VERSION = Version.V5;
     public static final NodeVersion CURRENT = new NodeVersion(new CassandraVersion(FBUtilities.getReleaseVersionString()), CURRENT_METADATA_VERSION);
     private static final CassandraVersion SINCE_VERSION = CassandraVersion.CASSANDRA_5_0;
 
diff --git a/src/java/org/apache/cassandra/tcm/serialization/Version.java b/src/java/org/apache/cassandra/tcm/serialization/Version.java
index 7c6177dcf6..ed601009f6 100644
--- a/src/java/org/apache/cassandra/tcm/serialization/Version.java
+++ b/src/java/org/apache/cassandra/tcm/serialization/Version.java
@@ -46,6 +46,10 @@ public enum Version
      * - Serialize allowAutoSnapshot and incrementalBackups when serializing TableParams
      */
     V4(4),
+    /**
+     * - AlterSchema includes execution timestamp
+     */
+    V5(5),
 
     UNKNOWN(Integer.MAX_VALUE);
 
diff --git a/src/java/org/apache/cassandra/tcm/transformations/AlterSchema.java b/src/java/org/apache/cassandra/tcm/transformations/AlterSchema.java
index 3751934224..93692f55ba 100644
--- a/src/java/org/apache/cassandra/tcm/transformations/AlterSchema.java
+++ b/src/java/org/apache/cassandra/tcm/transformations/AlterSchema.java
@@ -28,6 +28,8 @@ import java.util.stream.Stream;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
+
+import org.apache.cassandra.cql3.statements.schema.AlterSchemaStatement;
 import org.apache.cassandra.exceptions.AlreadyExistsException;
 import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.exceptions.InvalidRequestException;
@@ -38,8 +40,6 @@ import org.apache.cassandra.schema.DistributedSchema;
 import org.apache.cassandra.schema.KeyspaceMetadata;
 import org.apache.cassandra.schema.Keyspaces;
 import org.apache.cassandra.schema.ReplicationParams;
-import org.apache.cassandra.schema.Schema;
-import org.apache.cassandra.schema.SchemaProvider;
 import org.apache.cassandra.schema.SchemaTransformation;
 import org.apache.cassandra.schema.TableMetadata;
 import org.apache.cassandra.schema.Tables;
@@ -53,7 +53,9 @@ import org.apache.cassandra.tcm.sequences.LockedRanges;
 import org.apache.cassandra.tcm.serialization.AsymmetricMetadataSerializer;
 import org.apache.cassandra.tcm.serialization.Version;
 import org.apache.cassandra.utils.JVMStabilityInspector;
+import org.apache.cassandra.utils.vint.VIntCoding;
 
+import static org.apache.cassandra.cql3.statements.schema.AlterSchemaStatement.NO_EXECUTION_TIMESTAMP;
 import static org.apache.cassandra.exceptions.ExceptionCode.ALREADY_EXISTS;
 import static org.apache.cassandra.exceptions.ExceptionCode.CONFIG_ERROR;
 import static org.apache.cassandra.exceptions.ExceptionCode.INVALID;
@@ -65,14 +67,11 @@ public class AlterSchema implements Transformation
     private static final Logger logger = LoggerFactory.getLogger(AlterSchema.class);
     public static final Serializer serializer = new Serializer();
 
-    public final SchemaTransformation schemaTransformation;
-    protected final SchemaProvider schemaProvider;
+    private final SchemaTransformation schemaTransformation;
 
-    public AlterSchema(SchemaTransformation schemaTransformation,
-                       SchemaProvider schemaProvider)
+    public AlterSchema(SchemaTransformation schemaTransformation)
     {
         this.schemaTransformation = schemaTransformation;
-        this.schemaProvider = schemaProvider;
     }
 
     @Override
@@ -95,7 +94,6 @@ public class AlterSchema implements Transformation
             // log. In this case, there is a connected client and associated ClientState, so to avoid duplicate warnings
             // pause capture and resume after in applying the schema change.
             schemaTransformation.enterExecution();
-
             // Guard against an invalid SchemaTransformation supplying a TableMetadata with a future epoch
             newKeyspaces = schemaTransformation.apply(prev);
             newKeyspaces.forEach(ksm -> {
@@ -253,20 +251,33 @@ public class AlterSchema implements Transformation
         public void serialize(Transformation t, DataOutputPlus out, Version version) throws IOException
         {
             SchemaTransformation.serializer.serialize(((AlterSchema) t).schemaTransformation, out, version);
+            if (version.isAtLeast(Version.V5))
+            {
+                long fixedTimestamp = ((AlterSchema)t).schemaTransformation.fixedTimestampMicros().orElse(NO_EXECUTION_TIMESTAMP);
+                out.writeVInt(fixedTimestamp);
+            }
         }
 
         @Override
         public AlterSchema deserialize(DataInputPlus in, Version version) throws IOException
         {
-            return new AlterSchema(SchemaTransformation.serializer.deserialize(in, version),
-                                   Schema.instance);
-
+            SchemaTransformation transformation = SchemaTransformation.serializer.deserialize(in, version);
+            if (version.isAtLeast(Version.V5))
+            {
+                long timestamp = in.readVInt();
+                if (transformation instanceof AlterSchemaStatement)
+                    ((AlterSchemaStatement) transformation).setExecutionTimestamp(timestamp);
+            }
+            return new AlterSchema(transformation);
         }
 
         @Override
         public long serializedSize(Transformation t, Version version)
         {
-            return SchemaTransformation.serializer.serializedSize(((AlterSchema) t).schemaTransformation, version);
+            long size = SchemaTransformation.serializer.serializedSize(((AlterSchema) t).schemaTransformation, version);
+            if (version.isAtLeast(Version.V5))
+                size += VIntCoding.computeVIntSize(((AlterSchema)t).schemaTransformation.fixedTimestampMicros().orElse(NO_EXECUTION_TIMESTAMP));
+            return size;
         }
     }
 
diff --git a/test/distributed/org/apache/cassandra/distributed/test/DropColumnTest.java b/test/distributed/org/apache/cassandra/distributed/test/DropColumnTest.java
new file mode 100644
index 0000000000..e3b85a8c86
--- /dev/null
+++ b/test/distributed/org/apache/cassandra/distributed/test/DropColumnTest.java
@@ -0,0 +1,98 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.cassandra.distributed.test;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.util.Map;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.TimeUnit;
+
+import com.google.common.util.concurrent.Uninterruptibles;
+import org.junit.Test;
+
+import org.apache.cassandra.db.Keyspace;
+import org.apache.cassandra.distributed.Cluster;
+import org.apache.cassandra.distributed.api.IInvokableInstance;
+import org.apache.cassandra.schema.DroppedColumn;
+
+import static org.junit.Assert.assertEquals;
+
+public class DropColumnTest extends TestBaseImpl
+{
+    @Test
+    public void dropTest() throws IOException, ExecutionException, InterruptedException
+    {
+        try (Cluster cluster = init(Cluster.build(2).start()))
+        {
+            cluster.schemaChange(withKeyspace("create table %s.tbl (id int primary key, a int, b int, c int)"));
+            cluster.filters().allVerbs().messagesMatching((i, i1, iMessage) -> {
+                Uninterruptibles.sleepUninterruptibly(1, TimeUnit.SECONDS);
+                return false;
+            }).drop();
+            cluster.schemaChange(withKeyspace("alter table %s.tbl drop b"));
+            cluster.filters().reset();
+
+            long dropTimeNode1 = getDropTime(cluster.get(1));
+            long dropTimeNode2 = getDropTime(cluster.get(2));
+
+            assertEquals(dropTimeNode1, dropTimeNode2);
+
+            cluster.get(2).shutdown().get();
+            cluster.get(2).startup();
+
+            assertEquals(dropTimeNode1, getDropTime(cluster.get(2)));
+        }
+    }
+
+    @Test
+    public void dropUsingTimestampTest() throws IOException, ExecutionException, InterruptedException
+    {
+        try (Cluster cluster = init(Cluster.build(2).start()))
+        {
+            cluster.schemaChange(withKeyspace("create table %s.tbl (id int primary key, a int, b int, c int)"));
+            cluster.filters().allVerbs().messagesMatching((i, i1, iMessage) -> {
+                Uninterruptibles.sleepUninterruptibly(1, TimeUnit.SECONDS);
+                return false;
+            }).drop();
+            cluster.schemaChange(withKeyspace("alter table %s.tbl drop b using timestamp 99999"));
+            cluster.filters().reset();
+
+            long dropTimeNode1 = getDropTime(cluster.get(1));
+            long dropTimeNode2 = getDropTime(cluster.get(2));
+
+            assertEquals(dropTimeNode1, dropTimeNode2);
+            assertEquals(99999, dropTimeNode1);
+
+            cluster.get(2).shutdown().get();
+            cluster.get(2).startup();
+
+            assertEquals(dropTimeNode1, getDropTime(cluster.get(2)));
+        }
+    }
+
+    private long getDropTime(IInvokableInstance instance)
+    {
+        return instance.callOnInstance(() -> {
+            Map<ByteBuffer, DroppedColumn> droppedColumns = Keyspace.open(KEYSPACE).getColumnFamilyStore("tbl").metadata().droppedColumns;
+            assertEquals(1, droppedColumns.size());
+            return droppedColumns.values().iterator().next().droppedTime;
+        });
+    }
+}
diff --git a/test/distributed/org/apache/cassandra/distributed/test/log/CMSTestBase.java b/test/distributed/org/apache/cassandra/distributed/test/log/CMSTestBase.java
index e254798915..ffc7f96bba 100644
--- a/test/distributed/org/apache/cassandra/distributed/test/log/CMSTestBase.java
+++ b/test/distributed/org/apache/cassandra/distributed/test/log/CMSTestBase.java
@@ -33,7 +33,6 @@ import org.apache.cassandra.locator.ReplicaCollection;
 import org.apache.cassandra.schema.DistributedSchema;
 import org.apache.cassandra.schema.KeyspaceMetadata;
 import org.apache.cassandra.schema.Keyspaces;
-import org.apache.cassandra.schema.SchemaProvider;
 import org.apache.cassandra.tcm.ClusterMetadata;
 import org.apache.cassandra.tcm.ClusterMetadataService;
 import org.apache.cassandra.tcm.Commit;
@@ -45,7 +44,6 @@ import org.apache.cassandra.tcm.ownership.UniformRangePlacement;
 import org.apache.cassandra.tcm.transformations.AlterSchema;
 import org.apache.cassandra.tcm.transformations.cms.Initialize;
 import org.apache.cassandra.utils.FBUtilities;
-import org.mockito.Mockito;
 
 public class CMSTestBase
 {
@@ -87,19 +85,12 @@ public class CMSTestBase
         public final Murmur3Partitioner partitioner;
         public final LocalLog log;
         public final ClusterMetadataService service;
-        public final SchemaProvider schemaProvider;
         public final TokenPlacementModel.ReplicationFactor rf;
 
         public CMSSut(IIsolatedExecutor.SerializableFunction<LocalLog, Processor> processorFactory, boolean addListeners, TokenPlacementModel.ReplicationFactor rf)
-        {
-            this(processorFactory, addListeners, Mockito.mock(SchemaProvider.class), rf);
-        }
-
-        public CMSSut(IIsolatedExecutor.SerializableFunction<LocalLog, Processor> processorFactory, boolean addListeners, SchemaProvider schemaProvider, TokenPlacementModel.ReplicationFactor rf)
         {
             partitioner = Murmur3Partitioner.instance;
             this.rf = rf;
-            this.schemaProvider = schemaProvider;
             ClusterMetadata initial = new ClusterMetadata(partitioner);
             log = LocalLog.logSpec()
                           .sync()
@@ -129,7 +120,7 @@ public class CMSTestBase
             });
             service.commit(new AlterSchema((cm) -> {
                 return cm.schema.getKeyspaces().with(Keyspaces.of(KeyspaceMetadata.create("test", rf.asKeyspaceParams())));
-            }, schemaProvider));
+            }));
         }
 
         public void close()
diff --git a/test/distributed/org/apache/cassandra/distributed/test/log/ClusterMetadataTestHelper.java b/test/distributed/org/apache/cassandra/distributed/test/log/ClusterMetadataTestHelper.java
index d06d79afd1..b27952d284 100644
--- a/test/distributed/org/apache/cassandra/distributed/test/log/ClusterMetadataTestHelper.java
+++ b/test/distributed/org/apache/cassandra/distributed/test/log/ClusterMetadataTestHelper.java
@@ -52,7 +52,6 @@ import org.apache.cassandra.schema.KeyspaceMetadata;
 import org.apache.cassandra.schema.KeyspaceParams;
 import org.apache.cassandra.schema.Keyspaces;
 import org.apache.cassandra.schema.ReplicationParams;
-import org.apache.cassandra.schema.Schema;
 import org.apache.cassandra.schema.SchemaTransformation;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.tcm.AtomicLongBackedProcessor;
@@ -203,7 +202,7 @@ public class ClusterMetadataTestHelper
         CreateKeyspaceStatement createKeyspaceStatement = new CreateKeyspaceStatement(name, attributes, false);
         try
         {
-            commit(new AlterSchema(createKeyspaceStatement, Schema.instance));
+            commit(new AlterSchema(createKeyspaceStatement));
         }
         catch (Throwable e)
         {
@@ -216,7 +215,7 @@ public class ClusterMetadataTestHelper
         CreateKeyspaceStatement createKeyspaceStatement = (CreateKeyspaceStatement) QueryProcessor.parseStatement(statement).prepare(ClientState.forInternalCalls());
         try
         {
-            commit(new AlterSchema(createKeyspaceStatement, Schema.instance));
+            commit(new AlterSchema(createKeyspaceStatement));
         }
         catch (Throwable e)
         {
@@ -839,7 +838,7 @@ public class ClusterMetadataTestHelper
         try
         {
             SchemaTransformation transformation = (cm) -> cm.schema.getKeyspaces().withAddedOrUpdated(keyspace);
-            commit(new AlterSchema(transformation, Schema.instance));
+            commit(new AlterSchema(transformation));
         }
         catch (Exception e)
         {
diff --git a/test/unit/org/apache/cassandra/schema/SchemaChangeDuringRangeMovementTest.java b/test/unit/org/apache/cassandra/schema/SchemaChangeDuringRangeMovementTest.java
index 7c7eb8fb22..e6cdb1be82 100644
--- a/test/unit/org/apache/cassandra/schema/SchemaChangeDuringRangeMovementTest.java
+++ b/test/unit/org/apache/cassandra/schema/SchemaChangeDuringRangeMovementTest.java
@@ -157,14 +157,14 @@ public class SchemaChangeDuringRangeMovementTest extends CQLTester
                               "WITH REPLICATION = {'class':'SimpleStrategy','replication_factor':9}", RF9_KS4));
 
         SchemaTransformation dropAllowed = (metadata_) -> metadata_.schema.getKeyspaces().without(RF9_KS4).without(RF9_KS3);
-        metadata = ClusterMetadataService.instance().commit(new AlterSchema(dropAllowed, Schema.instance));
+        metadata = ClusterMetadataService.instance().commit(new AlterSchema(dropAllowed));
         assertFalse(metadata.schema.getKeyspaces().containsKeyspace(RF9_KS4));
         assertFalse(metadata.schema.getKeyspaces().containsKeyspace(RF9_KS3));
 
         try
         {
             SchemaTransformation dropRejected = (metadata_) -> metadata_.schema.getKeyspaces().without(RF9_KS2).without(RF9_KS1);
-            ClusterMetadataService.instance().commit(new AlterSchema(dropRejected, Schema.instance));
+            ClusterMetadataService.instance().commit(new AlterSchema(dropRejected));
             fail("Expected exception");
         }
         catch (IllegalStateException e)
diff --git a/test/unit/org/apache/cassandra/schema/SchemaTest.java b/test/unit/org/apache/cassandra/schema/SchemaTest.java
index d8f176cccd..fcf3c6997b 100644
--- a/test/unit/org/apache/cassandra/schema/SchemaTest.java
+++ b/test/unit/org/apache/cassandra/schema/SchemaTest.java
@@ -209,7 +209,9 @@ public class SchemaTest
 
     private static AlterSchemaStatement cql(String keyspace, String cql)
     {
-        return (AlterSchemaStatement) QueryProcessor.parseStatement(String.format(cql, keyspace))
-                                                    .prepare(ClientState.forInternalCalls());
+        AlterSchemaStatement statement = (AlterSchemaStatement) QueryProcessor.parseStatement(String.format(cql, keyspace))
+                                                                              .prepare(ClientState.forInternalCalls());
+        statement.setExecutionTimestamp(System.currentTimeMillis() * 1000);
+        return statement;
     }
 }
