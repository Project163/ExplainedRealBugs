diff --git a/CHANGES.txt b/CHANGES.txt
index f4d744aa79..07ccdf23a8 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 4.1-alpha2
+ * Remove expired snapshots of dropped tables after restart (CASSANDRA-17619) 
 Merged from 4.0:
  * silence benign SslClosedEngineException (CASSANDRA-17565)
 Merged from 3.11:
diff --git a/src/java/org/apache/cassandra/service/snapshot/SnapshotLoader.java b/src/java/org/apache/cassandra/service/snapshot/SnapshotLoader.java
index 75ae9ee5b5..5f50937bf4 100644
--- a/src/java/org/apache/cassandra/service/snapshot/SnapshotLoader.java
+++ b/src/java/org/apache/cassandra/service/snapshot/SnapshotLoader.java
@@ -21,6 +21,7 @@ package org.apache.cassandra.service.snapshot;
 import java.io.IOException;
 import java.nio.file.FileVisitResult;
 import java.nio.file.Files;
+import java.nio.file.NoSuchFileException;
 import java.nio.file.Path;
 import java.nio.file.Paths;
 import java.nio.file.SimpleFileVisitor;
@@ -65,7 +66,7 @@ public class SnapshotLoader extends SimpleFileVisitor<Path>
 
     public SnapshotLoader(String[] dataDirectories)
     {
-        this.dataDirectories = Arrays.stream(dataDirectories).map(Paths::get).collect(Collectors.toList());
+        this(Arrays.stream(dataDirectories).map(Paths::get).collect(Collectors.toList()));
     }
 
     public SnapshotLoader(Collection<Path> dataDirs)
@@ -79,16 +80,38 @@ public class SnapshotLoader extends SimpleFileVisitor<Path>
         {
             try
             {
-                Files.walkFileTree(dataDir, Collections.EMPTY_SET, 5, this);
+                if (dataDir.toFile().exists())
+                {
+                    Files.walkFileTree(dataDir, Collections.EMPTY_SET, 5, this);
+                }
+                else
+                {
+                    logger.debug("Skipping non-existing data directory {}", dataDir);
+                }
             }
             catch (IOException e)
             {
-                throw new RuntimeException(String.format("Error while loading snapshots from %s", dataDir));
+                throw new RuntimeException(String.format("Error while loading snapshots from %s", dataDir), e);
             }
         }
         return snapshots.values().stream().map(TableSnapshot.Builder::build).collect(Collectors.toSet());
     }
 
+    @Override
+    public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {
+        // Cassandra can remove some files while traversing the tree,
+        // for example when SSTables are compacted while we are walking it.
+        // SnapshotLoader is interested only in SSTables in snapshot directories which are not compacted,
+        // but we need to cover these in regular table directories too.
+        // If listing failed but such file exists and the exception is not NoSuchFileException, then we
+        // have a legitimate error while traversing the tree, otherwise just skip it and continue with the listing.
+        if (Files.exists(file) && !(exc instanceof NoSuchFileException))
+            return super.visitFileFailed(file, exc);
+        else
+            return FileVisitResult.CONTINUE;
+    }
+
+    @Override
     public FileVisitResult preVisitDirectory(Path subdir, BasicFileAttributes attrs)
     {
         if (subdir.getParent().getFileName().toString().equals(SNAPSHOT_SUBDIR))
@@ -108,7 +131,7 @@ public class SnapshotLoader extends SimpleFileVisitor<Path>
             return FileVisitResult.SKIP_SUBTREE;
         }
 
-        return subdir.getFileName().equals(Directories.BACKUPS_SUBDIR)
+        return subdir.getFileName().toString().equals(Directories.BACKUPS_SUBDIR)
                ? FileVisitResult.SKIP_SUBTREE
                : FileVisitResult.CONTINUE;
     }
diff --git a/src/java/org/apache/cassandra/service/snapshot/SnapshotManager.java b/src/java/org/apache/cassandra/service/snapshot/SnapshotManager.java
index 8d127a3c4b..a6eeb8858d 100644
--- a/src/java/org/apache/cassandra/service/snapshot/SnapshotManager.java
+++ b/src/java/org/apache/cassandra/service/snapshot/SnapshotManager.java
@@ -32,14 +32,12 @@ import org.apache.cassandra.concurrent.ScheduledExecutorPlus;
 import org.apache.cassandra.config.CassandraRelevantProperties;
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.db.Directories;
-import org.apache.cassandra.db.Keyspace;
 
 import java.util.concurrent.TimeoutException;
-import java.util.function.Supplier;
-import java.util.stream.Stream;
-import java.util.stream.StreamSupport;
+import java.util.stream.Collectors;
 
 import com.google.common.annotations.VisibleForTesting;
+import com.google.common.base.Joiner;
 
 import org.apache.cassandra.io.util.File;
 import org.apache.cassandra.utils.ExecutorUtils;
@@ -52,7 +50,6 @@ public class SnapshotManager {
 
     private static final Logger logger = LoggerFactory.getLogger(SnapshotManager.class);
 
-    private final Supplier<Stream<TableSnapshot>> snapshotLoader;
     private final long initialDelaySeconds;
     private final long cleanupPeriodSeconds;
 
@@ -68,18 +65,14 @@ public class SnapshotManager {
     public SnapshotManager()
     {
         this(CassandraRelevantProperties.SNAPSHOT_CLEANUP_INITIAL_DELAY_SECONDS.getInt(),
-             CassandraRelevantProperties.SNAPSHOT_CLEANUP_PERIOD_SECONDS.getInt(),
-             () -> StreamSupport.stream(Keyspace.all().spliterator(), false)
-                                .flatMap(ks -> ks.getAllSnapshots()));
+             CassandraRelevantProperties.SNAPSHOT_CLEANUP_PERIOD_SECONDS.getInt());
     }
 
     @VisibleForTesting
-    protected SnapshotManager(long initialDelaySeconds, long cleanupPeriodSeconds,
-                              Supplier<Stream<TableSnapshot>> snapshotLoader)
+    protected SnapshotManager(long initialDelaySeconds, long cleanupPeriodSeconds)
     {
         this.initialDelaySeconds = initialDelaySeconds;
         this.cleanupPeriodSeconds = cleanupPeriodSeconds;
-        this.snapshotLoader = snapshotLoader;
     }
 
     public Collection<TableSnapshot> getExpiringSnapshots()
@@ -116,8 +109,15 @@ public class SnapshotManager {
     @VisibleForTesting
     protected synchronized void loadSnapshots()
     {
-        logger.debug("Loading snapshots");
-        snapshotLoader.get().forEach(this::addSnapshot);
+        SnapshotLoader loader = new SnapshotLoader(DatabaseDescriptor.getAllDataFileLocations());
+        addSnapshots(loader.loadSnapshots());
+    }
+
+    @VisibleForTesting
+    protected synchronized void addSnapshots(Collection<TableSnapshot> snapshots)
+    {
+        logger.debug("Adding snapshots: {}.", Joiner.on(", ").join(snapshots.stream().map(s -> s.getId()).collect(Collectors.toList())));
+        snapshots.forEach(this::addSnapshot);
     }
 
     // TODO: Support pausing snapshot cleanup
@@ -125,7 +125,8 @@ public class SnapshotManager {
     {
         if (cleanupTaskFuture == null)
         {
-            logger.info("Scheduling expired snapshot cleanup with initialDelaySeconds={} and cleanupPeriodSeconds={}");
+            logger.info("Scheduling expired snapshot cleanup with initialDelaySeconds={} and cleanupPeriodSeconds={}",
+                        initialDelaySeconds, cleanupPeriodSeconds);
             cleanupTaskFuture = executor.scheduleWithFixedDelay(this::clearExpiredSnapshots, initialDelaySeconds,
                                                                 cleanupPeriodSeconds, TimeUnit.SECONDS);
         }
@@ -138,8 +139,11 @@ public class SnapshotManager {
         while (!expiringSnapshots.isEmpty() && expiringSnapshots.peek().isExpired(now))
         {
             TableSnapshot expiredSnapshot = expiringSnapshots.peek();
-            logger.debug("Removing expired snapshot {}.", expiredSnapshot);
-            clearSnapshot(expiredSnapshot);
+            if (expiredSnapshot != null)
+            {
+                logger.debug("Removing expired snapshot {}.", expiredSnapshot);
+                clearSnapshot(expiredSnapshot);
+            }
         }
     }
 
diff --git a/src/java/org/apache/cassandra/service/snapshot/TableSnapshot.java b/src/java/org/apache/cassandra/service/snapshot/TableSnapshot.java
index 7a2cdc0f89..93fe2455c4 100644
--- a/src/java/org/apache/cassandra/service/snapshot/TableSnapshot.java
+++ b/src/java/org/apache/cassandra/service/snapshot/TableSnapshot.java
@@ -248,7 +248,7 @@ public class TableSnapshot
         {
             try
             {
-                logger.debug("Loading snapshot manifest from {}", manifestFile);
+                logger.trace("Loading snapshot manifest from {}", manifestFile);
                 SnapshotManifest manifest = SnapshotManifest.deserializeFromJsonFile(manifestFile);
                 createdAt = manifest.createdAt;
                 expiresAt = manifest.expiresAt;
diff --git a/test/distributed/org/apache/cassandra/distributed/test/AutoSnapshotTtlTest.java b/test/distributed/org/apache/cassandra/distributed/test/AutoSnapshotTtlTest.java
index ace3b8fc26..afa7984b70 100644
--- a/test/distributed/org/apache/cassandra/distributed/test/AutoSnapshotTtlTest.java
+++ b/test/distributed/org/apache/cassandra/distributed/test/AutoSnapshotTtlTest.java
@@ -36,6 +36,7 @@ import static java.util.concurrent.TimeUnit.SECONDS;
 import static org.apache.cassandra.db.ColumnFamilyStore.SNAPSHOT_DROP_PREFIX;
 import static org.apache.cassandra.db.ColumnFamilyStore.SNAPSHOT_TRUNCATE_PREFIX;
 import static org.apache.cassandra.distributed.Cluster.build;
+import static org.apache.cassandra.distributed.shared.ClusterUtils.stopUnchecked;
 import static org.awaitility.Awaitility.await;
 
 public class AutoSnapshotTtlTest extends TestBaseImpl
@@ -119,6 +120,41 @@ public class AutoSnapshotTtlTest extends TestBaseImpl
         }
     }
 
+    /**
+     * Check that when auto_snapshot_ttl=5s, snapshots created from TRUNCATE are expired after 10s
+     */
+    @Test
+    public void testAutoSnapshotTTlOnDropAfterRestart() throws IOException
+    {
+        int TWENTY_SECONDS = 20; // longer TTL to allow snapshot to survive node restart
+        try (Cluster cluster = init(build().withNodes(1)
+                                           .withConfig(c -> c.with(Feature.GOSSIP)
+                                                             .set("auto_snapshot_ttl", String.format("%ds", TWENTY_SECONDS)))
+                                           .start()))
+        {
+            IInvokableInstance instance = cluster.get(1);
+
+            cluster.schemaChange(withKeyspace("CREATE TABLE %s.tbl (key int, value text, PRIMARY KEY (key))"));
+
+            populate(cluster);
+
+            // Drop Table
+            cluster.schemaChange(withKeyspace("DROP TABLE %s.tbl;"));
+
+            // Restart node
+            stopUnchecked(instance);
+            instance.startup();
+
+            // Check snapshot is listed after restart
+            instance.nodetoolResult("listsnapshots").asserts().success().stdoutContains(SNAPSHOT_DROP_PREFIX);
+
+            // Check snapshot is removed after at most 21s
+            await().timeout(TWENTY_SECONDS + 1, SECONDS)
+                   .pollInterval(1, SECONDS)
+                   .until(() -> !instance.nodetoolResult("listsnapshots").getStdout().contains(SNAPSHOT_DROP_PREFIX));
+        }
+    }
+
     /**
      * Check that when auto_snapshot_ttl is unset, snapshots created from DROP or TRUNCATE do not expire
      */
diff --git a/test/distributed/org/apache/cassandra/distributed/test/SnapshotsTest.java b/test/distributed/org/apache/cassandra/distributed/test/SnapshotsTest.java
index 1029301fca..5a37bc36b0 100644
--- a/test/distributed/org/apache/cassandra/distributed/test/SnapshotsTest.java
+++ b/test/distributed/org/apache/cassandra/distributed/test/SnapshotsTest.java
@@ -18,15 +18,6 @@
 
 package org.apache.cassandra.distributed.test;
 
-import java.io.IOException;
-import java.util.Arrays;
-
-import org.junit.After;
-import org.junit.AfterClass;
-import org.junit.Assert;
-import org.junit.BeforeClass;
-import org.junit.Test;
-
 import org.apache.cassandra.config.CassandraRelevantProperties;
 import org.apache.cassandra.distributed.Cluster;
 import org.apache.cassandra.distributed.api.ConsistencyLevel;
@@ -34,14 +25,28 @@ import org.apache.cassandra.distributed.api.Feature;
 import org.apache.cassandra.distributed.api.IInvokableInstance;
 import org.apache.cassandra.distributed.api.NodeToolResult;
 import org.apache.cassandra.distributed.shared.WithProperties;
+import org.apache.cassandra.utils.Clock;
+import org.junit.After;
+import org.junit.AfterClass;
+import org.junit.BeforeClass;
+import org.junit.Test;
 
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.regex.Pattern;
+
+import static java.lang.String.format;
+import static java.util.concurrent.TimeUnit.SECONDS;
 import static org.apache.cassandra.distributed.shared.ClusterUtils.stopUnchecked;
+import static org.awaitility.Awaitility.await;
+import static org.junit.Assert.assertEquals;
 
 public class SnapshotsTest extends TestBaseImpl
 {
     public static final Integer SNAPSHOT_CLEANUP_PERIOD_SECONDS = 1;
     public static final Integer FIVE_SECONDS = 5;
-    private static WithProperties properties = new WithProperties();
+    public static final Integer TEN_SECONDS = 10;
+    private static final WithProperties properties = new WithProperties();
     private static Cluster cluster;
 
     @BeforeClass
@@ -53,12 +58,13 @@ public class SnapshotsTest extends TestBaseImpl
         cluster = init(Cluster.build(1).withConfig(c -> c.with(Feature.GOSSIP)).start());
     }
 
-
     @After
     public void clearAllSnapshots()
     {
-        cluster.schemaChange("DROP KEYSPACE IF EXISTS default;");
+        cluster.schemaChange(withKeyspace("DROP TABLE IF EXISTS %s.tbl;"));
         cluster.get(1).nodetoolResult("clearsnapshot", "--all").asserts().success();
+        for (String tag : new String[] {"basic", "first", "second", "tag1"})
+            waitForSnapshotCleared(tag);
     }
 
     @AfterClass
@@ -70,14 +76,12 @@ public class SnapshotsTest extends TestBaseImpl
     }
 
     @Test
-    public void testSnapshotsCleanupByTTL() throws Exception
+    public void testSnapshotsCleanupByTTL()
     {
-        cluster.get(1).nodetoolResult("snapshot", "--ttl", String.format("%ds", FIVE_SECONDS),
+        cluster.get(1).nodetoolResult("snapshot", "--ttl", format("%ds", FIVE_SECONDS),
                                       "-t", "basic").asserts().success();
-        cluster.get(1).nodetoolResult("listsnapshots").asserts().success().stdoutContains("basic");
-
-        Thread.sleep(2 * FIVE_SECONDS * 1000L);
-        cluster.get(1).nodetoolResult("listsnapshots").asserts().success().stdoutNotContains("basic");
+        waitForSnapshotPresent("basic");
+        waitForSnapshotCleared("basic");
     }
 
     @Test
@@ -87,20 +91,32 @@ public class SnapshotsTest extends TestBaseImpl
         IInvokableInstance instance = cluster.get(1);
 
         // Create snapshot and check exists
-        instance.nodetoolResult("snapshot", "--ttl", String.format("%ds", TWENTY_SECONDS),
+        instance.nodetoolResult("snapshot", "--ttl", format("%ds", TWENTY_SECONDS),
                                 "-t", "basic").asserts().success();
-        instance.nodetoolResult("listsnapshots").asserts().success().stdoutContains("basic");
+        waitForSnapshotPresent("basic");
 
         // Restart node
+        long beforeStop = Clock.Global.currentTimeMillis();
         stopUnchecked(instance);
         instance.startup();
-
-        // Check snapshot still exists after restart
-        instance.nodetoolResult("listsnapshots").asserts().success().stdoutContains("basic");
+        long afterStart = Clock.Global.currentTimeMillis();
+
+        // if stop & start of the node took more than 20 seconds
+        // we assume that the snapshot should be expired by now, so we wait until we do not see it
+        if (afterStart - beforeStop > 20_000)
+        {
+            waitForSnapshotCleared("basic");
+            return;
+        }
+        else
+        {
+            // Check snapshot still exists after restart
+            cluster.get(1).nodetoolResult("listsnapshots").asserts().stdoutContains("basic");
+        }
 
         // Sleep for 2*TTL and then check snapshot is gone
         Thread.sleep(TWENTY_SECONDS * 1000L);
-        cluster.get(1).nodetoolResult("listsnapshots").asserts().success().stdoutNotContains("basic");
+        waitForSnapshotCleared("basic");
     }
 
     @Test
@@ -108,8 +124,10 @@ public class SnapshotsTest extends TestBaseImpl
     {
         IInvokableInstance instance = cluster.get(1);
 
-        instance.nodetoolResult("snapshot", "--ttl", String.format("%ds", 1),
-                                "-t", "basic").asserts().failure().stdoutContains(String.format("ttl for snapshot must be at least %d seconds", FIVE_SECONDS));
+        instance.nodetoolResult("snapshot", "--ttl", format("%ds", 1), "-t", "basic")
+                .asserts()
+                .failure()
+                .stdoutContains(format("ttl for snapshot must be at least %d seconds", FIVE_SECONDS));
 
         instance.nodetoolResult("snapshot", "--ttl", "invalid-ttl").asserts().failure();
     }
@@ -122,125 +140,192 @@ public class SnapshotsTest extends TestBaseImpl
 
         // take snapshot with ttl
         cluster.get(1).nodetoolResult("snapshot", "--ttl",
-                                      String.format("%ds", 1000),
+                                      format("%ds", 1000),
                                       "-t", "snapshot_with_ttl").asserts().success();
 
         // list snaphots without TTL
-        NodeToolResult.Asserts withoutTTLResult = cluster.get(1).nodetoolResult("listsnapshots", "-nt").asserts().success();
-        withoutTTLResult.stdoutContains("snapshot_without_ttl");
-        withoutTTLResult.stdoutNotContains("snapshot_with_ttl");
+        waitForSnapshot("snapshot_without_ttl", true, true);
+        waitForSnapshot("snapshot_with_ttl", false, true);
 
         // list all snapshots
-        NodeToolResult.Asserts allSnapshotsResult = cluster.get(1).nodetoolResult("listsnapshots").asserts().success();
-        allSnapshotsResult.stdoutContains("snapshot_without_ttl");
-        allSnapshotsResult.stdoutContains("snapshot_with_ttl");
+        waitForSnapshotPresent("snapshot_without_ttl");
+        waitForSnapshotPresent("snapshot_with_ttl");
     }
 
     @Test
-    public void testManualSnapshotCleanup() throws Exception
-    {
+    public void testManualSnapshotCleanup() {
         // take snapshots with ttl
-        NodeToolResult.Asserts listSnapshotsResult;
         cluster.get(1).nodetoolResult("snapshot", "--ttl",
-                                      String.format("%ds", FIVE_SECONDS),
+                                      format("%ds", TEN_SECONDS),
                                       "-t", "first").asserts().success();
 
         cluster.get(1).nodetoolResult("snapshot", "--ttl",
-                                      String.format("%ds", FIVE_SECONDS),
+                                      format("%ds", TEN_SECONDS),
                                       "-t", "second").asserts().success();
 
-        listSnapshotsResult = cluster.get(1).nodetoolResult("listsnapshots").asserts().success();
-        listSnapshotsResult.stdoutContains("first");
-        listSnapshotsResult.stdoutContains("second");
+        waitForSnapshotPresent("first");
+        waitForSnapshotPresent("second");
 
         cluster.get(1).nodetoolResult("clearsnapshot", "-t", "first").asserts().success();
 
-        listSnapshotsResult = cluster.get(1).nodetoolResult("listsnapshots").asserts().success();
-        listSnapshotsResult.stdoutNotContains("first");
-        listSnapshotsResult.stdoutContains("second");
-
-        Thread.sleep(2 * FIVE_SECONDS * 1000L);
+        waitForSnapshotCleared("first");
+        waitForSnapshotPresent("second");
 
-        listSnapshotsResult = cluster.get(1).nodetoolResult("listsnapshots").asserts().success();
-        listSnapshotsResult.stdoutNotContains("first");
-        listSnapshotsResult.stdoutNotContains("second");
+        // wait for the second snapshot to be removed as well
+        waitForSnapshotCleared("second");
     }
 
     @Test
-    public void testSecondaryIndexCleanup() throws Exception
+    public void testSecondaryIndexCleanup()
     {
-        cluster.schemaChange("CREATE KEYSPACE IF NOT EXISTS default WITH replication = {'class': 'SimpleStrategy', 'replication_factor': 2};");
-        cluster.schemaChange("CREATE TABLE default.tbl (key int, value text, PRIMARY KEY (key))");
-        cluster.schemaChange("CREATE INDEX value_idx ON default.tbl (value)");
+        cluster.schemaChange(withKeyspace("CREATE TABLE %s.tbl (key int, value text, PRIMARY KEY (key))"));
+        cluster.schemaChange(withKeyspace("CREATE INDEX value_idx ON %s.tbl (value)"));
 
         populate(cluster);
 
         cluster.get(1).nodetoolResult("snapshot", "--ttl",
-                                      String.format("%ds", FIVE_SECONDS),
+                                      format("%ds", FIVE_SECONDS),
                                       "-t", "first",
-                                      "-kt", "default.tbl").asserts().success();
+                                      "-kt", withKeyspace("%s.tbl")).asserts().success();
+
+        waitForSnapshotPresent("first");
+        waitForSnapshotCleared("first");
+    }
+
+    @Test
+    public void testListSnapshotOfDroppedTable()
+    {
+        IInvokableInstance instance = cluster.get(1);
+
+        cluster.schemaChange(withKeyspace("CREATE TABLE %s.tbl (key int, value text, PRIMARY KEY (key))"));
+
+        populate(cluster);
+
+        instance.nodetoolResult("snapshot",
+                                      "-t", "tag1",
+                                      "-kt", withKeyspace("%s.tbl")).asserts().success();
+
+        // Check snapshot is listed when table is not dropped
+        waitForSnapshotPresent("tag1");
 
-        NodeToolResult.Asserts listSnapshotsResult;
+        // Drop Table
+        cluster.schemaChange(withKeyspace("DROP TABLE %s.tbl;"));
 
-        listSnapshotsResult = cluster.get(1).nodetoolResult("listsnapshots").asserts().success();
-        listSnapshotsResult.stdoutContains("first");
+        // Check snapshot is listed after table is dropped
+        waitForSnapshotPresent("tag1");
 
-        Thread.sleep(FIVE_SECONDS * 2 * 1000);
+        // Restart node
+        stopUnchecked(instance);
+        instance.startup();
 
-        listSnapshotsResult = cluster.get(1).nodetoolResult("listsnapshots").asserts().success();
-        listSnapshotsResult.stdoutNotContains("first");
+        // Check snapshot of dropped table still exists after restart
+        waitForSnapshotPresent("tag1");
     }
 
     @Test
-    public void testListSnapshotOfDroppedTable()
+    public void testTTLSnapshotOfDroppedTable()
     {
         IInvokableInstance instance = cluster.get(1);
 
-        cluster.schemaChange("CREATE KEYSPACE IF NOT EXISTS default WITH replication = {'class': 'SimpleStrategy', 'replication_factor': 2};");
-        cluster.schemaChange("CREATE TABLE default.tbl (key int, value text, PRIMARY KEY (key))");
+        cluster.schemaChange(withKeyspace("CREATE TABLE %s.tbl (key int, value text, PRIMARY KEY (key))"));
 
         populate(cluster);
 
         instance.nodetoolResult("snapshot",
-                                      "-t", "tag1",
-                                      "-kt", "default.tbl").asserts().success();
+                                "-t", "tag1",
+                                "-kt", withKeyspace("%s.tbl"),
+                                "--ttl", format("%ds", FIVE_SECONDS)).asserts().success();
 
         // Check snapshot is listed when table is not dropped
         instance.nodetoolResult("listsnapshots").asserts().success().stdoutContains("tag1");
 
         // Drop Table
-        cluster.schemaChange("DROP TABLE default.tbl;");
+        cluster.schemaChange(withKeyspace("DROP TABLE %s.tbl;"));
 
         // Check snapshot is listed after table is dropped
         instance.nodetoolResult("listsnapshots").asserts().success().stdoutContains("tag1");
 
+        // Check snapshot is removed after at most 10s
+        await().timeout(2L * FIVE_SECONDS, SECONDS)
+               .pollInterval(1, SECONDS)
+               .until(() -> !instance.nodetoolResult("listsnapshots").getStdout().contains("tag1"));
+    }
+
+    @Test
+    public void testTTLSnapshotOfDroppedTableAfterRestart()
+    {
+        IInvokableInstance instance = cluster.get(1);
+
+        cluster.schemaChange(withKeyspace("CREATE TABLE %s.tbl (key int, value text, PRIMARY KEY (key))"));
+
+        populate(cluster);
+
+        instance.nodetoolResult("snapshot",
+                                "-t", "tag1",
+                                "-kt", withKeyspace("%s.tbl"),
+                                "--ttl", "1h").asserts().success();
+
+
+        // Check snapshot is listed when table is not dropped
+        waitForSnapshotPresent("tag1");
+
+        // Drop Table
+        cluster.schemaChange(withKeyspace("DROP TABLE %s.tbl;"));
+
         // Restart node
         stopUnchecked(instance);
         instance.startup();
 
-        // Check snapshot of dropped table still exists after restart
-        instance.nodetoolResult("listsnapshots").asserts().success().stdoutContains("tag1");
+        // Check snapshot still exists after restart
+        waitForSnapshotPresent("tag1");
     }
 
     @Test
     public void testSameTimestampOnEachTableOfSnaphot()
     {
         cluster.get(1).nodetoolResult("snapshot", "-t", "sametimestamp").asserts().success();
+        waitForSnapshotPresent("sametimestamp");
         NodeToolResult result = cluster.get(1).nodetoolResult("listsnapshots");
 
+        Pattern COMPILE = Pattern.compile(" +");
         long distinctTimestamps = Arrays.stream(result.getStdout().split("\n"))
                                    .filter(line -> line.startsWith("sametimestamp"))
-                                   .map(line -> line.replaceAll(" +", " ").split(" ")[7])
+                                   .map(line -> COMPILE.matcher(line).replaceAll(" ").split(" ")[7])
                                    .distinct()
                                    .count();
 
         // assert all dates are same so there is just one value accross all individual tables
-        Assert.assertEquals(1, distinctTimestamps);
+        assertEquals(1, distinctTimestamps);
     }
 
     private void populate(Cluster cluster)
     {
         for (int i = 0; i < 100; i++)
-            cluster.coordinator(1).execute("INSERT INTO default.tbl (key, value) VALUES (?, 'txt')", ConsistencyLevel.ONE, i);
+            cluster.coordinator(1).execute(withKeyspace("INSERT INTO %s.tbl (key, value) VALUES (?, 'txt')"), ConsistencyLevel.ONE, i);
+    }
+
+    private void waitForSnapshotPresent(String snapshotName)
+    {
+        waitForSnapshot(snapshotName, true, false);
+    }
+
+    private void waitForSnapshotCleared(String snapshotName)
+    {
+        waitForSnapshot(snapshotName, false, false);
+    }
+
+    private void waitForSnapshot(String snapshotName, boolean expectPresent, boolean noTTL)
+    {
+        await().timeout(20, SECONDS)
+               .pollInterval(1, SECONDS)
+               .until(() -> {
+                    NodeToolResult listsnapshots;
+                    if (noTTL)
+                        listsnapshots = cluster.get(1).nodetoolResult("listsnapshots", "-nt");
+                    else
+                        listsnapshots = cluster.get(1).nodetoolResult("listsnapshots");
+
+                    return expectPresent == listsnapshots.getStdout().contains(snapshotName);
+                });
     }
 }
diff --git a/test/unit/org/apache/cassandra/cql3/validation/operations/AutoSnapshotTest.java b/test/unit/org/apache/cassandra/cql3/validation/operations/AutoSnapshotTest.java
index ecb84f3285..eedcdb0a9a 100644
--- a/test/unit/org/apache/cassandra/cql3/validation/operations/AutoSnapshotTest.java
+++ b/test/unit/org/apache/cassandra/cql3/validation/operations/AutoSnapshotTest.java
@@ -21,7 +21,6 @@ import java.time.Instant;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Map;
-import java.util.concurrent.TimeUnit;
 
 import com.google.common.util.concurrent.Uninterruptibles;
 import org.junit.AfterClass;
@@ -39,6 +38,7 @@ import org.apache.cassandra.service.snapshot.TableSnapshot;
 import org.assertj.core.api.Condition;
 
 import static java.util.concurrent.TimeUnit.SECONDS;
+import static java.lang.String.format;
 import static org.apache.cassandra.db.ColumnFamilyStore.SNAPSHOT_DROP_PREFIX;
 import static org.assertj.core.api.Assertions.assertThat;
 
@@ -106,7 +106,7 @@ public class AutoSnapshotTest extends CQLTester
 
         execute("DROP TABLE %s");
 
-        verifyAutoSnapshot(SNAPSHOT_DROP_PREFIX, tableDir);
+        verifyAutoSnapshot(SNAPSHOT_DROP_PREFIX, tableDir, currentTable());
     }
 
     @Test
@@ -124,7 +124,36 @@ public class AutoSnapshotTest extends CQLTester
 
         execute("DROP TABLE %s");
 
-        verifyAutoSnapshot(SNAPSHOT_DROP_PREFIX, tableDir);
+        verifyAutoSnapshot(SNAPSHOT_DROP_PREFIX, tableDir, currentTable());
+    }
+
+    @Test
+    public void testAutoSnapshotOnDropKeyspace() throws Throwable
+    {
+        // Create tables A and B and flush
+        ColumnFamilyStore tableA = createAndPopulateTable();
+        ColumnFamilyStore tableB = createAndPopulateTable();
+        flush();
+
+        // Check no snapshots
+        assertThat(tableA.listSnapshots()).isEmpty();
+        assertThat(tableB.listSnapshots()).isEmpty();
+
+        // Drop keyspace, should have snapshot for table A and B
+        execute(format("DROP KEYSPACE %s", keyspace()));
+        verifyAutoSnapshot(SNAPSHOT_DROP_PREFIX, tableA, tableA.name);
+        verifyAutoSnapshot(SNAPSHOT_DROP_PREFIX, tableB, tableB.name);
+    }
+
+    private ColumnFamilyStore createAndPopulateTable() throws Throwable
+    {
+        createTable("CREATE TABLE %s (a int, b int, c int, PRIMARY KEY(a, b))");
+        // Check there are no snapshots
+        ColumnFamilyStore tableA = getCurrentColumnFamilyStore();
+
+        execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?)", 0, 0, 0);
+        execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?)", 0, 1, 1);
+        return tableA;
     }
 
     /**
@@ -132,7 +161,7 @@ public class AutoSnapshotTest extends CQLTester
      * - A snapshot is created when auto_snapshot = true.
      * - TTL is added to the snapshot when auto_snapshot_ttl != null
      */
-    private void verifyAutoSnapshot(String snapshotPrefix, ColumnFamilyStore tableDir)
+    private void verifyAutoSnapshot(String snapshotPrefix, ColumnFamilyStore tableDir, String expectedTableName)
     {
         Map<String, TableSnapshot> snapshots = tableDir.listSnapshots();
         if (autoSnapshotEnabled)
@@ -140,7 +169,7 @@ public class AutoSnapshotTest extends CQLTester
             assertThat(snapshots).hasSize(1);
             assertThat(snapshots).hasKeySatisfying(new Condition<>(k -> k.startsWith(snapshotPrefix), "is dropped snapshot"));
             TableSnapshot snapshot = snapshots.values().iterator().next();
-            assertThat(snapshot.getTableName()).isEqualTo(currentTable());
+            assertThat(snapshot.getTableName()).isEqualTo(expectedTableName);
             if (autoSnapshotTTl == null)
             {
                 // check that the snapshot has NO TTL
diff --git a/test/unit/org/apache/cassandra/service/snapshot/SnapshotManagerTest.java b/test/unit/org/apache/cassandra/service/snapshot/SnapshotManagerTest.java
index b07bb23487..0c078d47da 100644
--- a/test/unit/org/apache/cassandra/service/snapshot/SnapshotManagerTest.java
+++ b/test/unit/org/apache/cassandra/service/snapshot/SnapshotManagerTest.java
@@ -22,7 +22,6 @@ import java.time.Instant;
 import java.util.Arrays;
 import java.util.List;
 import java.util.UUID;
-import java.util.stream.Stream;
 
 import org.junit.BeforeClass;
 import org.junit.ClassRule;
@@ -71,8 +70,8 @@ public class SnapshotManagerTest
         List<TableSnapshot> snapshots = Arrays.asList(expired, nonExpired, nonExpiring);
 
         // Create SnapshotManager with 3 snapshots: expired, non-expired and non-expiring
-        SnapshotManager manager = new SnapshotManager(3, 3, snapshots::stream);
-        manager.loadSnapshots();
+        SnapshotManager manager = new SnapshotManager(3, 3);
+        manager.addSnapshots(snapshots);
 
         // Only expiring snapshots should be loaded
         assertThat(manager.getExpiringSnapshots()).hasSize(2);
@@ -82,7 +81,7 @@ public class SnapshotManagerTest
 
     @Test
     public void testClearExpiredSnapshots() throws Exception {
-        SnapshotManager manager = new SnapshotManager(3, 3, Stream::empty);
+        SnapshotManager manager = new SnapshotManager(3, 3);
 
         // Add 3 snapshots: expired, non-expired and non-expiring
         TableSnapshot expired = generateSnapshotDetails("expired", Instant.EPOCH);
@@ -111,7 +110,7 @@ public class SnapshotManagerTest
 
     @Test
     public void testScheduledCleanup() throws Exception {
-        SnapshotManager manager = new SnapshotManager(0, 1, Stream::empty);
+        SnapshotManager manager = new SnapshotManager(0, 1);
         try
         {
             // Start snapshot manager which should start expired snapshot cleanup thread
@@ -150,7 +149,7 @@ public class SnapshotManagerTest
     public void testClearSnapshot() throws Exception
     {
         // Given
-        SnapshotManager manager = new SnapshotManager(1, 3, Stream::empty);
+        SnapshotManager manager = new SnapshotManager(1, 3);
         TableSnapshot expiringSnapshot = generateSnapshotDetails("snapshot", now().plusMillis(50000));
         manager.addSnapshot(expiringSnapshot);
         assertThat(manager.getExpiringSnapshots()).contains(expiringSnapshot);
