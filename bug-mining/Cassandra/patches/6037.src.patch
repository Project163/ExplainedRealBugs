diff --git a/CHANGES.txt b/CHANGES.txt
index 99847be043..31c62caa57 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 4.0.5
+ * Ensure FileStreamTask cannot compromise shared channel proxy for system table when interrupted (CASSANDRA-17663)
  * silence benign SslClosedEngineException (CASSANDRA-17565)
 Merged from 3.11:
 Merged from 3.0:
diff --git a/src/java/org/apache/cassandra/repair/LocalSyncTask.java b/src/java/org/apache/cassandra/repair/LocalSyncTask.java
index ffa786cc10..99315754bd 100644
--- a/src/java/org/apache/cassandra/repair/LocalSyncTask.java
+++ b/src/java/org/apache/cassandra/repair/LocalSyncTask.java
@@ -20,6 +20,8 @@ package org.apache.cassandra.repair;
 import java.util.Collections;
 import java.util.List;
 import java.util.UUID;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.atomic.AtomicBoolean;
 
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Preconditions;
@@ -58,8 +60,8 @@ public class LocalSyncTask extends SyncTask implements StreamEventHandler
     @VisibleForTesting
     public final boolean transferRanges;
 
-    private boolean active = true;
-    private StreamPlan streamPlan;
+    private final AtomicBoolean active = new AtomicBoolean(true);
+    private final CompletableFuture<StreamPlan> planFuture = new CompletableFuture<>();
 
     public LocalSyncTask(RepairJobDesc desc, InetAddressAndPort local, InetAddressAndPort remote,
                          List<Range<Token>> diff, UUID pendingRepair,
@@ -105,9 +107,9 @@ public class LocalSyncTask extends SyncTask implements StreamEventHandler
      * that will be called out of band once the streams complete.
      */
     @Override
-    protected synchronized void startSync()
+    protected void startSync()
     {
-        if (active)
+        if (active.get())
         {
             InetAddressAndPort remote = nodePair.peer;
 
@@ -115,8 +117,9 @@ public class LocalSyncTask extends SyncTask implements StreamEventHandler
             logger.info("{} {}", previewKind.logPrefix(desc.sessionId), message);
             Tracing.traceRepair(message);
 
-            streamPlan = createStreamPlan();
-            streamPlan.execute();
+            StreamPlan plan = createStreamPlan();
+            plan.execute();
+            planFuture.complete(plan);
         }
     }
 
@@ -153,11 +156,10 @@ public class LocalSyncTask extends SyncTask implements StreamEventHandler
     }
 
     @Override
-    public synchronized void onSuccess(StreamState result)
+    public void onSuccess(StreamState result)
     {
-        if (active)
+        if (active.compareAndSet(true, false))
         {
-            active = false;
             String status = result.hasAbortedSession() ? "aborted" : "complete";
             String message = String.format("Sync %s using session %s between %s and %s on %s",
                                            status, desc.sessionId, nodePair.coordinator, nodePair.peer, desc.columnFamily);
@@ -169,11 +171,10 @@ public class LocalSyncTask extends SyncTask implements StreamEventHandler
     }
 
     @Override
-    public synchronized void onFailure(Throwable t)
+    public void onFailure(Throwable t)
     {
-        if (active)
+        if (active.compareAndSet(true, false))
         {
-            active = false;
             setException(t);
             finished();
         }
@@ -191,22 +192,12 @@ public class LocalSyncTask extends SyncTask implements StreamEventHandler
     }
 
     @Override
-    public synchronized void abort()
+    public void abort()
     {
-        if (active)
+        planFuture.whenComplete((plan, cause) ->
         {
-            if (streamPlan == null)
-            {
-                active = false;
-                String message = String.format("Sync for session %s between %s and %s on %s aborted before starting",
-                                               desc.sessionId, nodePair.coordinator, nodePair.peer, desc.columnFamily);
-                logger.debug("{} {}", previewKind.logPrefix(desc.sessionId), message);
-                set(stat);
-            }
-            else
-            {
-                streamPlan.getCoordinator().getAllStreamSessions().forEach(StreamSession::abort);
-            }
-        }
+            assert plan != null : "StreamPlan future should never be completed exceptionally";
+            plan.getCoordinator().getAllStreamSessions().forEach(StreamSession::abort);
+        });
     }
 }
diff --git a/src/java/org/apache/cassandra/streaming/StreamSession.java b/src/java/org/apache/cassandra/streaming/StreamSession.java
index 9a3428591c..b2739b331a 100644
--- a/src/java/org/apache/cassandra/streaming/StreamSession.java
+++ b/src/java/org/apache/cassandra/streaming/StreamSession.java
@@ -1039,6 +1039,12 @@ public class StreamSession implements IEndpointStateChangeSubscriber
 
     public synchronized void abort()
     {
+        if (state.isFinalState())
+        {
+            logger.debug("[Stream #{}] Stream session with peer {} is already in a final state on abort.", planId(), peer);
+            return;
+        }
+
         logger.info("[Stream #{}] Aborting stream session with peer {}...", planId(), peer);
 
         if (getMessageSender().connected())
diff --git a/src/java/org/apache/cassandra/streaming/async/NettyStreamingMessageSender.java b/src/java/org/apache/cassandra/streaming/async/NettyStreamingMessageSender.java
index fba56f58eb..2b9111627a 100644
--- a/src/java/org/apache/cassandra/streaming/async/NettyStreamingMessageSender.java
+++ b/src/java/org/apache/cassandra/streaming/async/NettyStreamingMessageSender.java
@@ -167,7 +167,7 @@ public class NettyStreamingMessageSender implements StreamingMessageSender
     /**
      * Used by initiator to setup control message channel connecting to follower
      */
-    private void setupControlMessageChannel() throws IOException
+    private void setupControlMessageChannel(OutboundConnectionSettings templateWithConnectTo) throws IOException
     {
         if (controlMessageChannel == null)
         {
@@ -177,7 +177,7 @@ public class NettyStreamingMessageSender implements StreamingMessageSender
              *  b) for streaming receiver (note: both initiator and follower can receive streaming files) to reveive files,
              *     in {@link Handler#setupStreamingPipeline}
              */
-            controlMessageChannel = createChannel(true);
+            controlMessageChannel = createChannel(true, templateWithConnectTo);
             scheduleKeepAliveTask(controlMessageChannel);
         }
     }
@@ -194,9 +194,9 @@ public class NettyStreamingMessageSender implements StreamingMessageSender
         task.future = scheduledFuture;
     }
     
-    private Channel createChannel(boolean isInboundHandlerNeeded) throws IOException
+    private Channel createChannel(boolean isInboundHandlerNeeded, OutboundConnectionSettings templateWithConnectTo) throws IOException
     {
-        Channel channel = factory.createConnection(template, streamingVersion);
+        Channel channel = factory.createConnection(templateWithConnectTo, streamingVersion);
         session.attachOutbound(channel);
 
         if (isInboundHandlerNeeded)
@@ -236,13 +236,16 @@ public class NettyStreamingMessageSender implements StreamingMessageSender
                 throw new RuntimeException("Cannot send stream data messages for preview streaming sessions");
             if (logger.isDebugEnabled())
                 logger.debug("{} Sending {}", createLogTag(session, null), message);
-            fileTransferExecutor.submit(new FileStreamTask((OutgoingStreamMessage)message));
+
+            // Supply a preferred IP up-front to avoid trying to get it in the executor thread, which can be interrupted.
+            OutboundConnectionSettings templateWithConnectTo = template.withConnectTo(template.connectTo());
+            fileTransferExecutor.submit(new FileStreamTask((OutgoingStreamMessage) message, templateWithConnectTo));
             return;
         }
 
         try
         {
-            setupControlMessageChannel();
+            setupControlMessageChannel(template);
             sendControlMessage(controlMessageChannel, message, future -> onControlMessageComplete(future, message));
         }
         catch (Exception e)
@@ -315,9 +318,12 @@ public class NettyStreamingMessageSender implements StreamingMessageSender
          */
         private final StreamMessage msg;
 
-        FileStreamTask(OutgoingStreamMessage ofm)
+        private final OutboundConnectionSettings templateWithConnectTo;
+
+        FileStreamTask(OutgoingStreamMessage ofm, OutboundConnectionSettings templateWithConnectTo)
         {
             this.msg = ofm;
+            this.templateWithConnectTo = templateWithConnectTo;
         }
 
         /**
@@ -326,6 +332,7 @@ public class NettyStreamingMessageSender implements StreamingMessageSender
         FileStreamTask(StreamMessage msg)
         {
             this.msg = msg;
+            this.templateWithConnectTo = null;
         }
 
         @Override
@@ -337,7 +344,7 @@ public class NettyStreamingMessageSender implements StreamingMessageSender
             Channel channel = null;
             try
             {
-                channel = getOrCreateChannel();
+                channel = getOrCreateChannel(templateWithConnectTo);
                 if (!channel.attr(TRANSFERRING_FILE_ATTR).compareAndSet(false, true))
                     throw new IllegalStateException("channel's transferring state is currently set to true. refusing to start new stream");
 
@@ -406,7 +413,7 @@ public class NettyStreamingMessageSender implements StreamingMessageSender
             }
         }
 
-        private Channel getOrCreateChannel()
+        private Channel getOrCreateChannel(OutboundConnectionSettings templateWithConnectTo)
         {
             Thread currentThread = Thread.currentThread();
             try
@@ -415,7 +422,7 @@ public class NettyStreamingMessageSender implements StreamingMessageSender
                 if (channel != null)
                     return channel;
 
-                channel = createChannel(false);
+                channel = createChannel(false, templateWithConnectTo);
                 threadToChannelMap.put(currentThread, channel);
                 return channel;
             }
diff --git a/test/distributed/org/apache/cassandra/distributed/test/RepairErrorsTest.java b/test/distributed/org/apache/cassandra/distributed/test/RepairErrorsTest.java
index 8b77b3f056..37c9171542 100644
--- a/test/distributed/org/apache/cassandra/distributed/test/RepairErrorsTest.java
+++ b/test/distributed/org/apache/cassandra/distributed/test/RepairErrorsTest.java
@@ -18,6 +18,7 @@
 
 package org.apache.cassandra.distributed.test;
 
+import java.io.IOException;
 import java.util.concurrent.Callable;
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
@@ -29,10 +30,15 @@ import net.bytebuddy.implementation.bind.annotation.SuperCall;
 import org.junit.Test;
 
 import org.apache.cassandra.concurrent.DebuggableThreadPoolExecutor;
+import org.apache.cassandra.db.ColumnFamilyStore;
+import org.apache.cassandra.db.Keyspace;
 import org.apache.cassandra.db.SystemKeyspace;
+import org.apache.cassandra.db.streaming.CassandraIncomingFile;
 import org.apache.cassandra.distributed.Cluster;
 import org.apache.cassandra.distributed.api.ConsistencyLevel;
+import org.apache.cassandra.distributed.api.IInvokableInstance;
 import org.apache.cassandra.distributed.api.NodeToolResult;
+import org.apache.cassandra.io.util.DataInputPlus;
 import org.apache.cassandra.locator.InetAddressAndPort;
 import org.apache.cassandra.service.ActiveRepairService;
 import org.apache.cassandra.streaming.StreamSession;
@@ -47,7 +53,6 @@ import static org.apache.cassandra.distributed.api.Feature.NETWORK;
 
 public class RepairErrorsTest extends TestBaseImpl
 {
-    @SuppressWarnings("Convert2MethodRef")
     @Test
     public void testRemoteSyncFailure() throws Exception
     {
@@ -90,14 +95,63 @@ public class RepairErrorsTest extends TestBaseImpl
             result = cluster.get(1).nodetoolResult("repair", KEYSPACE);
             result.asserts().success();
 
-            // Make sure we've cleaned up sessions and parent sessions:
-            Integer parents = cluster.get(1).callOnInstance(() -> ActiveRepairService.instance.parentRepairSessionCount());
-            assertEquals(0, parents.intValue());
-            Integer sessions = cluster.get(1).callOnInstance(() -> ActiveRepairService.instance.sessionCount());
-            assertEquals(0, sessions.intValue());
+            assertNoActiveRepairSessions(cluster.get(1));
         }
     }
 
+    @Test
+    public void testRemoteStreamFailure() throws Exception
+    {
+        try (Cluster cluster = init(Cluster.build(3)
+                                           .withConfig(config -> config.with(GOSSIP, NETWORK)
+                                                                       .set("disk_failure_policy", "stop")
+                                                                       .set("disk_access_mode", "mmap_index_only"))
+                                           .withInstanceInitializer(ByteBuddyHelperStreamFailure::installStreamHandlingFailure).start()))
+        {
+            // Make sure we don't auto-compact the peers table. We'll need to try it manually later.
+            cluster.get(1).runOnInstance(() -> {
+                ColumnFamilyStore cfs = Keyspace.open("system").getColumnFamilyStore("peers_v2");
+                cfs.disableAutoCompaction();
+            });
+
+            cluster.schemaChange("create table " + KEYSPACE + ".tbl (id int primary key, x int)");
+
+            // On repair, this data layout will require two (local) syncs from node 1 and one remote sync from node 2:
+            cluster.get(1).executeInternal("insert into " + KEYSPACE + ".tbl (id, x) VALUES (?,?)", 1, 1);
+            cluster.get(2).executeInternal("insert into " + KEYSPACE + ".tbl (id, x) VALUES (?,?)", 2, 2);
+            cluster.get(3).executeInternal("insert into " + KEYSPACE + ".tbl (id, x) VALUES (?,?)", 3, 3);
+            cluster.forEach(i -> i.flush(KEYSPACE));
+
+            // Flush system.peers_v2, or there won't be any SSTables...
+            cluster.forEach(i -> i.flush("system"));
+
+            // Stream reading will fail on node 3, and this will interrupt node 1 just as it starts to stream to node 2.
+            NodeToolResult result = cluster.get(1).nodetoolResult("repair", KEYSPACE);
+            result.asserts().failure();
+
+            // Ensure that the peers table is compactable even after the file streaming task is interrupted.
+            cluster.get(1).runOnInstance(() -> {
+                ColumnFamilyStore cfs = Keyspace.open("system").getColumnFamilyStore("peers_v2");
+                cfs.forceMajorCompaction();
+            });
+
+            assertTrue(cluster.get(1).logs().grep("Stopping transports as disk_failure_policy is stop").getResult().isEmpty());
+            assertTrue(cluster.get(1).logs().grep("FSReadError").getResult().isEmpty());
+
+            assertNoActiveRepairSessions(cluster.get(1));
+        }
+    }
+
+    @SuppressWarnings("Convert2MethodRef")
+    private void assertNoActiveRepairSessions(IInvokableInstance instance)
+    {
+        // Make sure we've cleaned up sessions and parent sessions:
+        Integer parents = instance.callOnInstance(() -> ActiveRepairService.instance.parentRepairSessionCount());
+        assertEquals(0, parents.intValue());
+        Integer sessions = instance.callOnInstance(() -> ActiveRepairService.instance.sessionCount());
+        assertEquals(0, sessions.intValue());
+    }
+
     public static class ByteBuddyHelper
     {
         public static void installStreamPlanExecutionFailure(ClassLoader cl, int nodeNumber)
@@ -162,4 +216,53 @@ public class RepairErrorsTest extends TestBaseImpl
             return zuper.call();
         }
     }
+
+    public static class ByteBuddyHelperStreamFailure
+    {
+        public static void installStreamHandlingFailure(ClassLoader cl, int nodeNumber)
+        {
+            if (nodeNumber == 3)
+            {
+                new ByteBuddy().rebase(CassandraIncomingFile.class)
+                        .method(named("read"))
+                        .intercept(MethodDelegation.to(ByteBuddyHelperStreamFailure.class))
+                        .make()
+                        .load(cl, ClassLoadingStrategy.Default.INJECTION);
+            }
+
+            if (nodeNumber == 1)
+            {
+                new ByteBuddy().rebase(SystemKeyspace.class)
+                        .method(named("getPreferredIP"))
+                        .intercept(MethodDelegation.to(ByteBuddyHelperStreamFailure.class))
+                        .make()
+                        .load(cl, ClassLoadingStrategy.Default.INJECTION);
+            }
+        }
+
+        @SuppressWarnings("unused")
+        public static void read(DataInputPlus in, int version) throws IOException
+        {
+            throw new IOException("Failing incoming file read from test!");
+        }
+
+        @SuppressWarnings("unused")
+        public static InetAddressAndPort getPreferredIP(InetAddressAndPort ep, @SuperCall Callable<InetAddressAndPort> zuper) throws Exception
+        {
+            if (Thread.currentThread().getName().contains("NettyStreaming-Outbound") && ep.address.toString().contains("127.0.0.2"))
+            {
+                try
+                {
+                    TimeUnit.SECONDS.sleep(10);
+                }
+                catch (InterruptedException e)
+                {
+                    // Leave the interrupt flag intact for the ChannelProxy downstream...
+                    Thread.currentThread().interrupt();
+                }
+            }
+
+            return zuper.call();
+        }
+    }
 }
