diff --git a/src/java/org/apache/cassandra/db/Column.java b/src/java/org/apache/cassandra/db/Column.java
index 27343755de..e6a109f6af 100644
--- a/src/java/org/apache/cassandra/db/Column.java
+++ b/src/java/org/apache/cassandra/db/Column.java
@@ -22,6 +22,7 @@ import java.io.DataInputStream;
 import java.io.DataOutputStream;
 import java.io.IOException;
 import java.util.Collection;
+import java.util.Map;
 import java.nio.ByteBuffer;
 
 import org.apache.commons.lang.ArrayUtils;
diff --git a/src/java/org/apache/cassandra/db/ColumnFamily.java b/src/java/org/apache/cassandra/db/ColumnFamily.java
index 18f6c31bd6..0554f4d680 100644
--- a/src/java/org/apache/cassandra/db/ColumnFamily.java
+++ b/src/java/org/apache/cassandra/db/ColumnFamily.java
@@ -133,7 +133,7 @@ public final class ColumnFamily
         this(cfName, columnType, ColumnComparatorFactory.getComparator(indexType));
     }
 
-    ColumnFamily cloneMeShallow()
+    public ColumnFamily cloneMeShallow()
     {
         ColumnFamily cf = new ColumnFamily(name_, type_, getComparator());
         cf.markedForDeleteAt = markedForDeleteAt;
@@ -218,7 +218,7 @@ public final class ColumnFamily
 		addColumn(column);
     }
 
-    void clear()
+    public void clear()
     {
         if (logger_.isDebugEnabled())
           logger_.debug("clearing");
@@ -230,7 +230,7 @@ public final class ColumnFamily
      * If we find an old column that has the same name
      * the ask it to resolve itself else add the new column .
     */
-    void addColumn(IColumn column)
+    public void addColumn(IColumn column)
     {
         String name = column.name();
         IColumn oldColumn = columns_.get(name);
diff --git a/src/java/org/apache/cassandra/db/ColumnFamilyStore.java b/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
index 16bec2eee5..89e1d2740b 100644
--- a/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
+++ b/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
@@ -39,9 +39,12 @@ import org.apache.cassandra.net.EndPoint;
 import org.apache.cassandra.service.StorageService;
 import org.apache.cassandra.utils.*;
 import org.apache.cassandra.concurrent.DebuggableThreadPoolExecutor;
+import org.apache.cassandra.db.filter.QueryFilter;
+import org.apache.cassandra.db.filter.ColumnIterator;
+import org.apache.cassandra.db.filter.NamesQueryFilter;
+
 import org.apache.commons.lang.StringUtils;
 import org.apache.commons.collections.IteratorUtils;
-import org.apache.commons.collections.comparators.ReverseComparator;
 
 import org.cliffc.high_scale_lib.NonBlockingHashMap;
 import org.cliffc.high_scale_lib.NonBlockingHashSet;
@@ -663,8 +666,7 @@ public final class ColumnFamilyStore implements ColumnFamilyStoreMBean
                 // don't operate directly on the supercolumn, it could be the one in the memtable.
                 // instead, create a new SC and add in the subcolumns that qualify.
                 cf.remove(cname);
-                SuperColumn sc = new SuperColumn(cname);
-                sc.markForDeleteAt(c.getLocalDeletionTime(), c.getMarkedForDeleteAt());
+                SuperColumn sc = ((SuperColumn)c).cloneMeShallow();
                 for (IColumn subColumn : c.getSubColumns())
                 {
                     if (subColumn.timestamp() > minTimestamp)
@@ -1556,8 +1558,23 @@ public final class ColumnFamilyStore implements ColumnFamilyStoreMBean
      * only the latest version of a column is returned
      */
     public ColumnFamily getColumnFamily(QueryFilter filter)
-    throws IOException, ExecutionException, InterruptedException
+    throws IOException
     {
+        String[] values = RowMutation.getColumnAndColumnFamily(filter.columnFamilyColumn);
+
+        // if we are querying subcolumns of a supercolumn, fetch the supercolumn with NQF, then filter in-memory.
+        if (values.length > 1)
+        {
+            QueryFilter nameFilter = new NamesQueryFilter(filter.key, values[0], values[1]);
+            ColumnFamily cf = getColumnFamily(nameFilter);
+            for (IColumn column : cf.getAllColumns())
+            {
+                filter.filterSuperColumn((SuperColumn) column);
+            }
+            return removeDeleted(cf);
+        }
+
+        // we are querying top-level columns, do a merging fetch with indexes.
         sstableLock_.readLock().lock();
         List<ColumnIterator> iterators = new ArrayList<ColumnIterator>();
         try
@@ -1606,7 +1623,7 @@ public final class ColumnFamilyStore implements ColumnFamilyStoreMBean
             Comparator<IColumn> comparator = filter.getColumnComparator();
             Iterator collated = IteratorUtils.collatedIterator(comparator, iterators);
             if (!collated.hasNext())
-                return ColumnFamily.create(table_, filter.getColumnFamilyName());
+                return ColumnFamily.create(table_, columnFamily_);
 
             filter.collectColumns(returnCF, collated);
 
diff --git a/src/java/org/apache/cassandra/db/Memtable.java b/src/java/org/apache/cassandra/db/Memtable.java
index 6b325ff7a9..70f4d32664 100644
--- a/src/java/org/apache/cassandra/db/Memtable.java
+++ b/src/java/org/apache/cassandra/db/Memtable.java
@@ -23,7 +23,6 @@ import java.util.*;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import org.apache.commons.collections.comparators.ReverseComparator;
 import org.apache.commons.lang.ArrayUtils;
 
 import org.apache.cassandra.config.DatabaseDescriptor;
@@ -33,6 +32,8 @@ import org.apache.cassandra.io.SSTableReader;
 import org.apache.cassandra.io.SSTableWriter;
 import org.apache.cassandra.service.StorageService;
 import org.apache.cassandra.utils.DestructivePQIterator;
+import org.apache.cassandra.db.filter.*;
+
 import org.apache.log4j.Logger;
 
 /**
@@ -234,8 +235,7 @@ public class Memtable implements Comparable<Memtable>
                     if (subColumn != null)
                     {
                         columnFamily = cFamily.cloneMeShallow();
-                        SuperColumn container = new SuperColumn(superColumn.name());
-                        container.markForDeleteAt(superColumn.getLocalDeletionTime(), superColumn.getMarkedForDeleteAt());
+                        SuperColumn container = superColumn.cloneMeShallow();
                         container.addColumn(subColumn);
                         columnFamily.addColumn(container);
                     }
@@ -321,42 +321,28 @@ public class Memtable implements Comparable<Memtable>
     /**
      * obtain an iterator of columns in this memtable in the specified order starting from a given column.
      */
-    ColumnIterator getColumnIterator(final String key, final String cfName, final boolean isAscending, String startColumn)
+    public ColumnIterator getSliceIterator(SliceQueryFilter filter)
     {
-        ColumnFamily cf = columnFamilies_.get(key);
-        final ColumnFamily columnFamily;
-        if (cf != null)
-            columnFamily = cf.cloneMeShallow();
-        else
-            columnFamily = ColumnFamily.create(table_, cfName);
+        ColumnFamily cf = columnFamilies_.get(filter.key);
+        final ColumnFamily columnFamily = cf == null ? ColumnFamily.create(table_, filter.getColumnFamilyName()) : cf.cloneMeShallow();
 
         final IColumn columns[] = (cf == null ? columnFamily : cf).getAllColumns().toArray(new IColumn[columnFamily.getAllColumns().size()]);
         // TODO if we are dealing with supercolumns, we need to clone them while we have the read lock since they can be modified later
-        if (!isAscending)
+        if (!filter.isAscending)
             ArrayUtils.reverse(columns);
         IColumn startIColumn;
-        if (DatabaseDescriptor.getColumnFamilyType(table_, cfName).equals("Standard"))
-            startIColumn = new Column(startColumn);
+        if (DatabaseDescriptor.getColumnFamilyType(table_, filter.getColumnFamilyName()).equals("Standard"))
+            startIColumn = new Column(filter.start);
         else
-            startIColumn = new SuperColumn(startColumn);
+            startIColumn = new SuperColumn(filter.start);
 
         // can't use a ColumnComparatorFactory comparator since those compare on both name and time (and thus will fail to match
         // our dummy column, since the time there is arbitrary).
-        Comparator<IColumn> comparator = new Comparator<IColumn>()
-        {
-            public int compare(IColumn column1, IColumn column2)
-            {
-                return column1.name().compareTo(column2.name());
-            }
-        };
-        if (!isAscending)
-        {
-            comparator = new ReverseComparator(comparator);
-        }
+        Comparator<IColumn> comparator = filter.getColumnComparator();
         int index = Arrays.binarySearch(columns, startIColumn, comparator);
         final int startIndex = index < 0 ? -(index + 1) : index;
 
-        return new ColumnIterator()
+        return new AbstractColumnIterator()
         {
             private int curIndex_ = startIndex;
 
@@ -374,12 +360,39 @@ public class Memtable implements Comparable<Memtable>
             {
                 return columns[curIndex_++];
             }
+        };
+    }
+
+    public ColumnIterator getNamesIterator(final NamesQueryFilter filter)
+    {
+        ColumnFamily cf = columnFamilies_.get(filter.key);
+        final ColumnFamily columnFamily = cf == null ? ColumnFamily.create(table_, filter.getColumnFamilyName()) : cf.cloneMeShallow();
+        final Map<String, IColumn> columnsContainer = cf == null ? null : cf.getColumns();
 
-            public void close() throws IOException {}
+        return new SimpleAbstractColumnIterator()
+        {
+            private Iterator<String> iter = filter.columns.iterator();
+            private String current;
 
-            public void remove()
+            public ColumnFamily getColumnFamily()
             {
-                throw new UnsupportedOperationException();
+                return columnFamily;
+            }
+
+            protected IColumn computeNext()
+            {
+                if (columnsContainer == null)
+                {
+                    return endOfData();
+                }
+                while (iter.hasNext())
+                {
+                    current = iter.next();
+                    IColumn column = columnsContainer.get(current);
+                    if (column != null)
+                        return column;
+                }
+                return endOfData();
             }
         };
     }
diff --git a/src/java/org/apache/cassandra/db/NamesFilter.java b/src/java/org/apache/cassandra/db/NamesFilter.java
deleted file mode 100644
index 665f4fffe8..0000000000
--- a/src/java/org/apache/cassandra/db/NamesFilter.java
+++ /dev/null
@@ -1,99 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.cassandra.db;
-
-import java.io.DataInputStream;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-
-import org.apache.cassandra.io.DataInputBuffer;
-import org.apache.cassandra.io.SSTableReader;
-
-
-
-public class NamesFilter implements IFilter
-{
-    /* list of column names to filter against. */
-    private List<String> names_;
-
-    NamesFilter(List<String> names)
-    {
-        names_ = new ArrayList<String>(names);
-    }
-
-    public ColumnFamily filter(String cf, ColumnFamily columnFamily)
-    {
-        if ( columnFamily == null )
-        {
-            return null;
-        }
-    	String[] values = RowMutation.getColumnAndColumnFamily(cf);
-        ColumnFamily filteredCf = columnFamily.cloneMeShallow();
-		if( values.length == 1 )
-		{
-			Collection<IColumn> columns = columnFamily.getAllColumns();
-			for(IColumn column : columns)
-			{
-		        if ( names_.contains(column.name()) )
-		        {
-					filteredCf.addColumn(column);
-		        }
-			}
-		}
-		else if (values.length == 2 && columnFamily.isSuper())
-		{
-    		Collection<IColumn> columns = columnFamily.getAllColumns();
-    		for(IColumn column : columns)
-    		{
-    			SuperColumn superColumn = (SuperColumn)column;
-    			SuperColumn filteredSuperColumn = new SuperColumn(superColumn.name());
-				filteredCf.addColumn(filteredSuperColumn);
-        		Collection<IColumn> subColumns = superColumn.getSubColumns();
-        		for(IColumn subColumn : subColumns)
-        		{
-    		        if ( names_.contains(subColumn.name()) )
-    		        {
-    		            filteredSuperColumn.addColumn(subColumn);
-    		        }
-    			}
-    		}
-		}
-    	else
-    	{
-    		throw new UnsupportedOperationException();
-    	}
-		return filteredCf;
-    }
-
-    public IColumn filter(IColumn column, DataInputStream dis) throws IOException
-    {
-        if (!names_.contains(column.name()))
-        {
-            column = null;
-        }
-        return column;
-    }
-
-    public DataInputBuffer next(String key, String cf, SSTableReader ssTable) throws IOException
-    {
-    	return ssTable.next(key, cf, names_, null);
-    }
-
-}
diff --git a/src/java/org/apache/cassandra/db/SliceByNamesReadCommand.java b/src/java/org/apache/cassandra/db/SliceByNamesReadCommand.java
index c2ee8b49f8..720045239f 100644
--- a/src/java/org/apache/cassandra/db/SliceByNamesReadCommand.java
+++ b/src/java/org/apache/cassandra/db/SliceByNamesReadCommand.java
@@ -20,22 +20,20 @@ package org.apache.cassandra.db;
 import java.io.DataInputStream;
 import java.io.DataOutputStream;
 import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
+import java.util.*;
 
 import org.apache.commons.lang.StringUtils;
 
 public class SliceByNamesReadCommand extends ReadCommand
 {
     public final String columnFamily;
-    public final List<String> columnNames;
+    public final SortedSet<String> columnNames;
 
-    public SliceByNamesReadCommand(String table, String key, String columnFamily, List<String> columnNames)
+    public SliceByNamesReadCommand(String table, String key, String columnFamily, Collection<String> columnNames)
     {
         super(table, key, CMD_TYPE_GET_SLICE_BY_NAMES);
         this.columnFamily = columnFamily;
-        this.columnNames = Collections.unmodifiableList(columnNames);
+        this.columnNames = new TreeSet<String>(columnNames);
     }
 
     @Override
diff --git a/src/java/org/apache/cassandra/db/SuperColumn.java b/src/java/org/apache/cassandra/db/SuperColumn.java
index 6114caa538..63c49839b5 100644
--- a/src/java/org/apache/cassandra/db/SuperColumn.java
+++ b/src/java/org/apache/cassandra/db/SuperColumn.java
@@ -24,6 +24,7 @@ import java.io.IOException;
 import java.io.Serializable;
 import java.util.Collection;
 import java.util.Set;
+import java.util.Map;
 import java.util.concurrent.atomic.AtomicInteger;
 
 import org.apache.commons.lang.ArrayUtils;
@@ -62,6 +63,13 @@ public final class SuperColumn implements IColumn, Serializable
     	name_ = name;
     }
 
+    public SuperColumn cloneMeShallow()
+    {
+        SuperColumn sc = new SuperColumn(name_);
+        sc.markForDeleteAt(localDeletionTime, markedForDeleteAt);
+        return sc;
+    }
+
 	public boolean isMarkedForDelete()
 	{
 		return markedForDeleteAt > Long.MIN_VALUE;
diff --git a/src/java/org/apache/cassandra/db/Table.java b/src/java/org/apache/cassandra/db/Table.java
index 3babfe46f9..fd6dc55c27 100644
--- a/src/java/org/apache/cassandra/db/Table.java
+++ b/src/java/org/apache/cassandra/db/Table.java
@@ -43,6 +43,10 @@ import org.apache.cassandra.net.io.IStreamComplete;
 import org.apache.cassandra.net.io.StreamContextManager;
 import org.apache.cassandra.service.StorageService;
 import org.apache.cassandra.utils.*;
+import org.apache.cassandra.db.filter.QueryFilter;
+import org.apache.cassandra.db.filter.SliceQueryFilter;
+import org.apache.cassandra.db.filter.NamesQueryFilter;
+
 import org.apache.log4j.Logger;
 
 /**
@@ -495,6 +499,7 @@ public class Table
     /**
      * Selects the row associated with the given key.
     */
+    @Deprecated // CF should be our atom of work, not Row
     public Row get(String key) throws IOException
     {        
         Row row = new Row(table_, key);
@@ -520,13 +525,14 @@ public class Table
     /**
      * Selects the specified column family for the specified key.
     */
-    public ColumnFamily get(String key, String cf) throws IOException
+    @Deprecated // single CFs could be larger than memory
+    public ColumnFamily get(String key, String columnFamilyColumn) throws IOException
     {
-        String[] values = RowMutation.getColumnAndColumnFamily(cf);
+        String[] values = RowMutation.getColumnAndColumnFamily(columnFamilyColumn);
         long start = System.currentTimeMillis();
         ColumnFamilyStore cfStore = columnFamilyStores_.get(values[0]);
-        assert cfStore != null : "Column family " + cf + " has not been defined";
-        ColumnFamily columnFamily = cfStore.getColumnFamily(key, cf, new IdentityFilter());
+        assert cfStore != null : "Column family " + columnFamilyColumn + " has not been defined";
+        ColumnFamily columnFamily = cfStore.getColumnFamily(key, columnFamilyColumn, new IdentityFilter());
         long timeTaken = System.currentTimeMillis() - start;
         dbAnalyticsSource_.updateReadStatistics(timeTaken);
         return columnFamily;
@@ -567,19 +573,11 @@ public class Table
      *  param @ cf - column family we are interested in.
      *  param @ columns - columns that are part of the above column family.
     */
-    public Row getRow(String key, String cf, List<String> columns) throws IOException
+    public Row getRow(String key, String columnFamilyColumn, SortedSet<String> columns) throws IOException
     {
-    	Row row = new Row(table_, key);
-        String[] values = RowMutation.getColumnAndColumnFamily(cf);
-        ColumnFamilyStore cfStore = columnFamilyStores_.get(values[0]);
-
-        if ( cfStore != null )
-        {
-        	ColumnFamily columnFamily = cfStore.getColumnFamily(key, cf, new NamesFilter(new ArrayList<String>(columns)));
-        	if ( columnFamily != null )
-        		row.addColumnFamily(columnFamily);
-        }
-    	return row;
+        // TODO for large CFs we will want a specialized iterator
+        QueryFilter filter = new NamesQueryFilter(key, columnFamilyColumn, columns);
+        return getRow(key, filter);
     }
 
     /**
@@ -587,12 +585,17 @@ public class Table
     */
     public Row getRow(String key, String cfName, String start, String finish, boolean isAscending, int offset, int count) throws IOException
     {
+        QueryFilter filter = new SliceQueryFilter(key, cfName, start, finish, isAscending, offset, count);
+        return getRow(key, filter);
+    }
+
+    private Row getRow(String key, QueryFilter filter) throws IOException
+    {
+        ColumnFamilyStore cfStore = columnFamilyStores_.get(filter.getColumnFamilyName());
         Row row = new Row(table_, key);
-        ColumnFamilyStore cfStore = columnFamilyStores_.get(cfName);
         long start1 = System.currentTimeMillis();
         try
         {
-            QueryFilter filter = new SliceQueryFilter(key, cfName, start, finish, isAscending, offset, count);
             ColumnFamily columnFamily = cfStore.getColumnFamily(filter);
             if (columnFamily != null)
                 row.addColumnFamily(columnFamily);
diff --git a/src/java/org/apache/cassandra/db/TimeFilter.java b/src/java/org/apache/cassandra/db/TimeFilter.java
index 4b910022a5..ba06d0da36 100644
--- a/src/java/org/apache/cassandra/db/TimeFilter.java
+++ b/src/java/org/apache/cassandra/db/TimeFilter.java
@@ -74,8 +74,7 @@ class TimeFilter implements IFilter
             for (IColumn column : columns)
             {
                 SuperColumn superColumn = (SuperColumn) column;
-                SuperColumn filteredSuperColumn = new SuperColumn(superColumn.name());
-                filteredSuperColumn.markForDeleteAt(column.getLocalDeletionTime(), column.getMarkedForDeleteAt());
+                SuperColumn filteredSuperColumn = superColumn.cloneMeShallow();
                 filteredCf.addColumn(filteredSuperColumn);
                 Collection<IColumn> subColumns = superColumn.getSubColumns();
                 for (IColumn subColumn : subColumns)
diff --git a/src/java/org/apache/cassandra/db/filter/AbstractColumnIterator.java b/src/java/org/apache/cassandra/db/filter/AbstractColumnIterator.java
new file mode 100644
index 0000000000..0f00b54cfa
--- /dev/null
+++ b/src/java/org/apache/cassandra/db/filter/AbstractColumnIterator.java
@@ -0,0 +1,14 @@
+package org.apache.cassandra.db.filter;
+
+import java.io.IOException;
+
+public abstract class AbstractColumnIterator implements ColumnIterator
+{
+    public void close() throws IOException
+    {}
+
+    public void remove()
+    {
+        throw new UnsupportedOperationException();
+    }
+}
diff --git a/src/java/org/apache/cassandra/db/filter/ColumnIterator.java b/src/java/org/apache/cassandra/db/filter/ColumnIterator.java
new file mode 100644
index 0000000000..a043bb42f4
--- /dev/null
+++ b/src/java/org/apache/cassandra/db/filter/ColumnIterator.java
@@ -0,0 +1,20 @@
+package org.apache.cassandra.db.filter;
+
+import java.util.Iterator;
+import java.io.IOException;
+
+import org.apache.cassandra.db.IColumn;
+import org.apache.cassandra.db.ColumnFamily;
+
+public interface ColumnIterator extends Iterator<IColumn>
+{
+    /**
+     *  returns the CF of the column being iterated.
+     *  The CF is only guaranteed to be available after a call to next() or hasNext().
+     */
+    public abstract ColumnFamily getColumnFamily();
+
+    /** clean up any open resources */
+    public void close() throws IOException;
+}
+
diff --git a/src/java/org/apache/cassandra/db/filter/NamesQueryFilter.java b/src/java/org/apache/cassandra/db/filter/NamesQueryFilter.java
new file mode 100644
index 0000000000..9839711b35
--- /dev/null
+++ b/src/java/org/apache/cassandra/db/filter/NamesQueryFilter.java
@@ -0,0 +1,59 @@
+package org.apache.cassandra.db.filter;
+
+import java.io.IOException;
+import java.util.SortedSet;
+import java.util.Arrays;
+import java.util.TreeSet;
+
+import org.apache.cassandra.io.SSTableReader;
+import org.apache.cassandra.utils.ReducingIterator;
+import org.apache.cassandra.db.filter.ColumnIterator;
+import org.apache.cassandra.db.Memtable;
+import org.apache.cassandra.db.ColumnFamily;
+import org.apache.cassandra.db.IColumn;
+import org.apache.cassandra.db.SuperColumn;
+
+public class NamesQueryFilter extends QueryFilter
+{
+    public final SortedSet<String> columns;
+
+    public NamesQueryFilter(String key, String columnFamilyColumn, SortedSet<String> columns)
+    {
+        super(key, columnFamilyColumn);
+        this.columns = columns;
+    }
+
+    public NamesQueryFilter(String key, String columnFamilyColumn, String column)
+    {
+        this(key, columnFamilyColumn, new TreeSet<String>(Arrays.asList(column)));
+    }
+
+    public ColumnIterator getMemColumnIterator(Memtable memtable)
+    {
+        return memtable.getNamesIterator(this);
+    }
+
+    public ColumnIterator getSSTableColumnIterator(SSTableReader sstable) throws IOException
+    {
+        return new SSTableNamesIterator(sstable.getFilename(), key, getColumnFamilyName(), columns);
+    }
+
+    public void filterSuperColumn(SuperColumn superColumn)
+    {
+        for (IColumn column : superColumn.getSubColumns())
+        {
+            if (!columns.contains(column.name()))
+            {
+                superColumn.remove(column.name());
+            }
+        }
+    }
+
+    public void collectColumns(ColumnFamily returnCF, ReducingIterator<IColumn> reducedColumns)
+    {
+        for (IColumn column : reducedColumns)
+        {
+            returnCF.addColumn(column);
+        }
+    }
+}
diff --git a/src/java/org/apache/cassandra/db/QueryFilter.java b/src/java/org/apache/cassandra/db/filter/QueryFilter.java
similarity index 87%
rename from src/java/org/apache/cassandra/db/QueryFilter.java
rename to src/java/org/apache/cassandra/db/filter/QueryFilter.java
index 5cf7a0f56d..20558e5932 100644
--- a/src/java/org/apache/cassandra/db/QueryFilter.java
+++ b/src/java/org/apache/cassandra/db/filter/QueryFilter.java
@@ -1,16 +1,12 @@
-package org.apache.cassandra.db;
+package org.apache.cassandra.db.filter;
 
 import java.io.IOException;
-import java.util.List;
 import java.util.Comparator;
 import java.util.Iterator;
-import java.util.Collection;
-
-import org.apache.commons.collections.comparators.ReverseComparator;
-import org.apache.commons.collections.IteratorUtils;
 
 import org.apache.cassandra.io.SSTableReader;
 import org.apache.cassandra.utils.ReducingIterator;
+import org.apache.cassandra.db.*;
 
 public abstract class QueryFilter
 {
@@ -42,7 +38,13 @@ public abstract class QueryFilter
      */
     public abstract void collectColumns(ColumnFamily returnCF, ReducingIterator<IColumn> reducedColumns);
 
-    protected Comparator<IColumn> getColumnComparator()
+    /**
+     * subcolumns of a supercolumn are unindexed, so to pick out parts of those we operate in-memory.
+     * @param superColumn
+     */
+    public abstract void filterSuperColumn(SuperColumn superColumn);
+
+    public Comparator<IColumn> getColumnComparator()
     {
         return new Comparator<IColumn>()
         {
@@ -84,6 +86,6 @@ public abstract class QueryFilter
 
     public String getColumnFamilyName()
     {
-        return RowMutation.getColumnAndColumnFamily(columnFamilyColumn)[0]);
+        return RowMutation.getColumnAndColumnFamily(columnFamilyColumn)[0];
     }
 }
diff --git a/src/java/org/apache/cassandra/db/filter/SSTableNamesIterator.java b/src/java/org/apache/cassandra/db/filter/SSTableNamesIterator.java
new file mode 100644
index 0000000000..8cb5c1b5f5
--- /dev/null
+++ b/src/java/org/apache/cassandra/db/filter/SSTableNamesIterator.java
@@ -0,0 +1,45 @@
+package org.apache.cassandra.db.filter;
+
+import java.io.IOException;
+import java.util.SortedSet;
+import java.util.Iterator;
+
+import org.apache.cassandra.db.ColumnFamily;
+import org.apache.cassandra.db.IColumn;
+import org.apache.cassandra.io.SSTableReader;
+import org.apache.cassandra.io.DataInputBuffer;
+
+public class SSTableNamesIterator extends SimpleAbstractColumnIterator
+{
+    private ColumnFamily cf;
+    private Iterator<IColumn> iter;
+    public final SortedSet<String> columns;
+
+    // TODO make this actually iterate so we don't have to read + deserialize + filter data that we don't need due to merging other sstables
+    public SSTableNamesIterator(String filename, String key, String cfName, SortedSet<String> columns) throws IOException
+    {
+        this.columns = columns;
+        SSTableReader ssTable = SSTableReader.open(filename);
+        DataInputBuffer buffer = ssTable.next(key, cfName, columns);
+        cf = ColumnFamily.serializer().deserialize(buffer);
+        iter = cf.getAllColumns().iterator();
+    }
+
+    public ColumnFamily getColumnFamily()
+    {
+        return cf;
+    }
+
+    protected IColumn computeNext()
+    {
+        if (iter == null)
+            return endOfData();
+        while (iter.hasNext())
+        {
+            IColumn c = iter.next();
+            if (columns.contains(c.name()))
+                return c;
+        }
+        return endOfData();
+    }
+}
diff --git a/src/java/org/apache/cassandra/db/ColumnIterator.java b/src/java/org/apache/cassandra/db/filter/SSTableSliceIterator.java
similarity index 61%
rename from src/java/org/apache/cassandra/db/ColumnIterator.java
rename to src/java/org/apache/cassandra/db/filter/SSTableSliceIterator.java
index 42a184b775..90c82db720 100644
--- a/src/java/org/apache/cassandra/db/ColumnIterator.java
+++ b/src/java/org/apache/cassandra/db/filter/SSTableSliceIterator.java
@@ -1,133 +1,105 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.cassandra.db;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Iterator;
-
-import org.apache.cassandra.io.DataInputBuffer;
-import org.apache.cassandra.io.DataOutputBuffer;
-import org.apache.cassandra.io.SSTableReader;
-import org.apache.cassandra.io.SequenceFile.ColumnGroupReader;
-import com.google.common.collect.AbstractIterator;
-
-public interface ColumnIterator extends Iterator<IColumn>
-{
-    /**
-     *  returns the CF of the column being iterated.
-     *  The CF is only guaranteed to be available after a call to next() or hasNext().
-     */
-    public abstract ColumnFamily getColumnFamily();
-
-    /** clean up any open resources */
-    public void close() throws IOException;
-}
-
-/**
- *  A Column Iterator over SSTable
- */
-class SSTableColumnIterator extends AbstractIterator<IColumn> implements ColumnIterator
-{
-    protected boolean isAscending;
-    private String startColumn;
-    private DataOutputBuffer outBuf = new DataOutputBuffer();
-    private DataInputBuffer inBuf = new DataInputBuffer();
-    private int curColumnIndex;
-    private ColumnFamily curCF = null;
-    private ArrayList<IColumn> curColumns = new ArrayList<IColumn>();
-    private ColumnGroupReader reader;
-
-    public SSTableColumnIterator(String filename, String key, String cfName, String startColumn, boolean isAscending)
-    throws IOException
-    {
-        this.isAscending = isAscending;
-        SSTableReader ssTable = SSTableReader.open(filename);
-        reader = ssTable.getColumnGroupReader(key, cfName, startColumn, isAscending);
-        this.startColumn = startColumn;
-        curColumnIndex = isAscending ? 0 : -1;
-    }
-
-    private boolean isColumnNeeded(IColumn column)
-    {
-        if (isAscending)
-            return (column.name().compareTo(startColumn) >= 0);
-        else
-            return (column.name().compareTo(startColumn) <= 0);
-    }
-
-    private void getColumnsFromBuffer() throws IOException
-    {
-        inBuf.reset(outBuf.getData(), outBuf.getLength());
-        ColumnFamily columnFamily = ColumnFamily.serializer().deserialize(inBuf);
-
-        if (curCF == null)
-            curCF = columnFamily.cloneMeShallow();
-        curColumns.clear();
-        for (IColumn column : columnFamily.getAllColumns())
-            if (isColumnNeeded(column))
-                curColumns.add(column);
-
-        if (isAscending)
-            curColumnIndex = 0;
-        else
-            curColumnIndex = curColumns.size() - 1;
-    }
-
-    public ColumnFamily getColumnFamily()
-    {
-        return curCF;
-    }
-
-    protected IColumn computeNext()
-    {
-        while (true)
-        {
-            if (isAscending)
-            {
-                if (curColumnIndex < curColumns.size())
-                {
-                    return curColumns.get(curColumnIndex++);
-                }
-            }
-            else
-            {
-                if (curColumnIndex >= 0)
-                {
-                    return curColumns.get(curColumnIndex--);
-                }
-            }
-
-            try
-            {
-                if (!reader.getNextBlock(outBuf))
-                    return endOfData();
-                getColumnsFromBuffer();
-            }
-            catch (IOException e)
-            {
-                throw new RuntimeException(e);
-            }
-        }
-    }
-
-    public void close() throws IOException
-    {
-        reader.close();
-    }
-}
+package org.apache.cassandra.db.filter;
+
+import java.util.ArrayList;
+import java.io.IOException;
+
+import org.apache.cassandra.db.IColumn;
+import org.apache.cassandra.db.ColumnFamily;
+import org.apache.cassandra.io.DataOutputBuffer;
+import org.apache.cassandra.io.DataInputBuffer;
+import org.apache.cassandra.io.SequenceFile;
+import org.apache.cassandra.io.SSTableReader;
+import com.google.common.collect.AbstractIterator;
+
+/**
+ *  A Column Iterator over SSTable
+ */
+class SSTableSliceIterator extends AbstractIterator<IColumn> implements ColumnIterator
+{
+    protected boolean isAscending;
+    private String startColumn;
+    private DataOutputBuffer outBuf = new DataOutputBuffer();
+    private DataInputBuffer inBuf = new DataInputBuffer();
+    private int curColumnIndex;
+    private ColumnFamily curCF = null;
+    private ArrayList<IColumn> curColumns = new ArrayList<IColumn>();
+    private SequenceFile.ColumnGroupReader reader;
+
+    public SSTableSliceIterator(String filename, String key, String cfName, String startColumn, boolean isAscending)
+    throws IOException
+    {
+        this.isAscending = isAscending;
+        SSTableReader ssTable = SSTableReader.open(filename);
+        reader = ssTable.getColumnGroupReader(key, cfName, startColumn, isAscending);
+        this.startColumn = startColumn;
+        curColumnIndex = isAscending ? 0 : -1;
+    }
+
+    private boolean isColumnNeeded(IColumn column)
+    {
+        if (isAscending)
+            return (column.name().compareTo(startColumn) >= 0);
+        else
+            return (column.name().compareTo(startColumn) <= 0);
+    }
+
+    private void getColumnsFromBuffer() throws IOException
+    {
+        inBuf.reset(outBuf.getData(), outBuf.getLength());
+        ColumnFamily columnFamily = ColumnFamily.serializer().deserialize(inBuf);
+
+        if (curCF == null)
+            curCF = columnFamily.cloneMeShallow();
+        curColumns.clear();
+        for (IColumn column : columnFamily.getAllColumns())
+            if (isColumnNeeded(column))
+                curColumns.add(column);
+
+        if (isAscending)
+            curColumnIndex = 0;
+        else
+            curColumnIndex = curColumns.size() - 1;
+    }
+
+    public ColumnFamily getColumnFamily()
+    {
+        return curCF;
+    }
+
+    protected IColumn computeNext()
+    {
+        while (true)
+        {
+            if (isAscending)
+            {
+                if (curColumnIndex < curColumns.size())
+                {
+                    return curColumns.get(curColumnIndex++);
+                }
+            }
+            else
+            {
+                if (curColumnIndex >= 0)
+                {
+                    return curColumns.get(curColumnIndex--);
+                }
+            }
+
+            try
+            {
+                if (!reader.getNextBlock(outBuf))
+                    return endOfData();
+                getColumnsFromBuffer();
+            }
+            catch (IOException e)
+            {
+                throw new RuntimeException(e);
+            }
+        }
+    }
+
+    public void close() throws IOException
+    {
+        reader.close();
+    }
+}
diff --git a/src/java/org/apache/cassandra/db/filter/SimpleAbstractColumnIterator.java b/src/java/org/apache/cassandra/db/filter/SimpleAbstractColumnIterator.java
new file mode 100644
index 0000000000..636b04b206
--- /dev/null
+++ b/src/java/org/apache/cassandra/db/filter/SimpleAbstractColumnIterator.java
@@ -0,0 +1,11 @@
+package org.apache.cassandra.db.filter;
+
+import java.io.IOException;
+
+import org.apache.cassandra.db.IColumn;
+import com.google.common.collect.AbstractIterator;
+
+public abstract class SimpleAbstractColumnIterator extends AbstractIterator<IColumn> implements ColumnIterator
+{
+    public void close() throws IOException {}
+}
diff --git a/src/java/org/apache/cassandra/db/SliceQueryFilter.java b/src/java/org/apache/cassandra/db/filter/SliceQueryFilter.java
similarity index 79%
rename from src/java/org/apache/cassandra/db/SliceQueryFilter.java
rename to src/java/org/apache/cassandra/db/filter/SliceQueryFilter.java
index 1b25f04811..74d0b57d75 100644
--- a/src/java/org/apache/cassandra/db/SliceQueryFilter.java
+++ b/src/java/org/apache/cassandra/db/filter/SliceQueryFilter.java
@@ -1,4 +1,4 @@
-package org.apache.cassandra.db;
+package org.apache.cassandra.db.filter;
 
 import java.io.IOException;
 import java.util.Comparator;
@@ -7,6 +7,7 @@ import org.apache.commons.collections.comparators.ReverseComparator;
 
 import org.apache.cassandra.io.SSTableReader;
 import org.apache.cassandra.utils.ReducingIterator;
+import org.apache.cassandra.db.*;
 
 public class SliceQueryFilter extends QueryFilter
 {
@@ -26,16 +27,22 @@ public class SliceQueryFilter extends QueryFilter
 
     public ColumnIterator getMemColumnIterator(Memtable memtable)
     {
-        return memtable.getColumnIterator(key, columnFamilyColumn, isAscending, start);
+        return memtable.getSliceIterator(this);
     }
 
     public ColumnIterator getSSTableColumnIterator(SSTableReader sstable) throws IOException
     {
-        return new SSTableColumnIterator(sstable.getFilename(), key, columnFamilyColumn, start, isAscending);
+        return new SSTableSliceIterator(sstable.getFilename(), key, getColumnFamilyName(), start, isAscending);
+    }
+
+    public void filterSuperColumn(SuperColumn superColumn)
+    {
+        // TODO write this after CASSANDRA-240 is done
+        throw new UnsupportedOperationException();
     }
 
     @Override
-    protected Comparator<IColumn> getColumnComparator()
+    public Comparator<IColumn> getColumnComparator()
     {
         Comparator<IColumn> comparator = super.getColumnComparator();
         return isAscending ? comparator : new ReverseComparator(comparator);
diff --git a/src/java/org/apache/cassandra/io/IFileReader.java b/src/java/org/apache/cassandra/io/IFileReader.java
index bd6475940f..ee8cd977c4 100644
--- a/src/java/org/apache/cassandra/io/IFileReader.java
+++ b/src/java/org/apache/cassandra/io/IFileReader.java
@@ -20,6 +20,7 @@ package org.apache.cassandra.io;
 
 import java.io.IOException;
 import java.util.List;
+import java.util.SortedSet;
 
 /**
  * Interface to read from the SequenceFile abstraction.
@@ -78,7 +79,7 @@ public interface IFileReader
      * @return number of bytes read.
      *
     */
-    public long next(String key, DataOutputBuffer bufOut, String columnFamilyName, List<String> columnNames, IndexHelper.TimeRange timeRange, long position) throws IOException;
+    public long next(String key, DataOutputBuffer bufOut, String columnFamilyName, SortedSet<String> columnNames, IndexHelper.TimeRange timeRange, long position) throws IOException;
 
     /**
      * Close the file after reading.
diff --git a/src/java/org/apache/cassandra/io/IndexHelper.java b/src/java/org/apache/cassandra/io/IndexHelper.java
index 387fc19e46..484554ca5b 100644
--- a/src/java/org/apache/cassandra/io/IndexHelper.java
+++ b/src/java/org/apache/cassandra/io/IndexHelper.java
@@ -221,7 +221,7 @@ public class IndexHelper
 	 * @param totalNumCols the total number of columns
 	 * @return a list of subranges which contain all the columns in columnNames
 	 */
-	static List<ColumnRange> getMultiColumnRangesFromNameIndex(List<String> columnNames, List<IndexHelper.ColumnIndexInfo> columnIndexList, int dataSize, int totalNumCols)
+	static List<ColumnRange> getMultiColumnRangesFromNameIndex(SortedSet<String> columnNames, List<IndexHelper.ColumnIndexInfo> columnIndexList, int dataSize, int totalNumCols)
 	{
 		List<ColumnRange> columnRanges = new ArrayList<ColumnRange>();				
 
diff --git a/src/java/org/apache/cassandra/io/SSTableReader.java b/src/java/org/apache/cassandra/io/SSTableReader.java
index 41e2f41812..2f0d54bc89 100644
--- a/src/java/org/apache/cassandra/io/SSTableReader.java
+++ b/src/java/org/apache/cassandra/io/SSTableReader.java
@@ -285,12 +285,12 @@ public class SSTableReader extends SSTable
         }
     }
 
-    public DataInputBuffer next(final String clientKey, String cfName, List<String> columnNames) throws IOException
+    public DataInputBuffer next(final String clientKey, String cfName, SortedSet<String> columnNames) throws IOException
     {
         return next(clientKey, cfName, columnNames, null);
     }
 
-    public DataInputBuffer next(final String clientKey, String cfName, List<String> columnNames, IndexHelper.TimeRange timeRange) throws IOException
+    public DataInputBuffer next(final String clientKey, String cfName, SortedSet<String> columnNames, IndexHelper.TimeRange timeRange) throws IOException
     {
         IFileReader dataReader = null;
         try
@@ -327,8 +327,8 @@ public class SSTableReader extends SSTable
     {
         String[] values = RowMutation.getColumnAndColumnFamily(columnFamilyColumn);
         String columnFamilyName = values[0];
-        List<String> cnNames = (values.length == 1) ? null : Arrays.asList(values[1]);
-        return next(clientKey, columnFamilyName, cnNames);
+        SortedSet<String> columnNames = (values.length == 1) ? null : new TreeSet<String>(Arrays.asList(values[1]));
+        return next(clientKey, columnFamilyName, columnNames);
     }
 
     /**
diff --git a/src/java/org/apache/cassandra/io/SequenceFile.java b/src/java/org/apache/cassandra/io/SequenceFile.java
index 1a2ec591db..db5b35f26e 100644
--- a/src/java/org/apache/cassandra/io/SequenceFile.java
+++ b/src/java/org/apache/cassandra/io/SequenceFile.java
@@ -20,10 +20,7 @@ package org.apache.cassandra.io;
 
 import java.io.*;
 import java.nio.ByteBuffer;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-import java.util.Arrays;
+import java.util.*;
 
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.utils.BloomFilter;
@@ -485,7 +482,7 @@ public class SequenceFile
          * @return number of bytes that were read.
          * @throws IOException
          */
-        public long next(String key, DataOutputBuffer bufOut, String columnFamilyName, List<String> columnNames, IndexHelper.TimeRange timeRange, long position) throws IOException
+        public long next(String key, DataOutputBuffer bufOut, String columnFamilyName, SortedSet<String> columnNames, IndexHelper.TimeRange timeRange, long position) throws IOException
         {
             assert timeRange == null || columnNames == null; // at most one may be non-null
 
@@ -597,7 +594,7 @@ public class SequenceFile
             bufOut.write(file_, dataSize);
         }
 
-        private void readColumns(String key, DataOutputBuffer bufOut, String columnFamilyName, List<String> cNames)
+        private void readColumns(String key, DataOutputBuffer bufOut, String columnFamilyName, SortedSet<String> cNames)
                 throws IOException
         {
             int dataSize = file_.readInt();
@@ -655,9 +652,6 @@ public class SequenceFile
                 dataSize -= 4;
 
                 // TODO: this is name sorted - but eventually this should be sorted by the same criteria as the col index
-                /* sort the required list of columns */
-                cNames = new ArrayList<String>(cNames);
-                Collections.sort(cNames);
                 /* get the various column ranges we have to read */
                 List<IndexHelper.ColumnRange> columnRanges = IndexHelper.getMultiColumnRangesFromNameIndex(cNames, columnIndexList, dataSize, totalNumCols);
 
diff --git a/src/java/org/apache/cassandra/test/TestRunner.java b/src/java/org/apache/cassandra/test/TestRunner.java
index d02bdeb353..ae77f6b2c5 100644
--- a/src/java/org/apache/cassandra/test/TestRunner.java
+++ b/src/java/org/apache/cassandra/test/TestRunner.java
@@ -17,10 +17,7 @@
  */
 package org.apache.cassandra.test;
 
-import java.util.Collection;
-import java.util.Random;
-import java.util.ArrayList;
-import java.util.List;
+import java.util.*;
 
 import org.apache.cassandra.db.ColumnFamily;
 import org.apache.cassandra.db.IColumn;
@@ -84,7 +81,7 @@ public class TestRunner
         System.out.println(row);
         */
         
-        List<String> list = new ArrayList<String>();
+        TreeSet<String> list = new TreeSet<String>();
         list.add("SuperColumn-0");
         list.add("SuperColumn-189");
         list.add("SuperColumn-23");
diff --git a/test/unit/org/apache/cassandra/db/RemoveSuperColumnTest.java b/test/unit/org/apache/cassandra/db/RemoveSuperColumnTest.java
index 485db71435..42bee3b176 100644
--- a/test/unit/org/apache/cassandra/db/RemoveSuperColumnTest.java
+++ b/test/unit/org/apache/cassandra/db/RemoveSuperColumnTest.java
@@ -30,6 +30,8 @@ import org.junit.Test;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertEquals;
 
+import org.apache.cassandra.db.filter.NamesQueryFilter;
+
 public class RemoveSuperColumnTest
 {
     @Test
@@ -125,11 +127,7 @@ public class RemoveSuperColumnTest
         List<ColumnFamily> families;
         ColumnFamily resolved;
 
-        families = store.getColumnFamilies("key1", "Super2:SC1", new NamesFilter(Arrays.asList("Column2")));
-        resolved = ColumnFamilyStore.removeDeleted(ColumnFamily.resolve(families));
-        validateNewDataFamily(resolved);
-
-        resolved = store.getColumnFamily("key1", "Super2:SC1:Column2", new IdentityFilter());
+        resolved = store.getColumnFamily(new NamesQueryFilter("key1", "Super2:SC1", "Column2"));
         validateNewDataFamily(resolved);
     }
 
