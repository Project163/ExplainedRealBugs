diff --git a/CHANGES.txt b/CHANGES.txt
index c626d3761e..ed323857f0 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -12,6 +12,7 @@
  * Fix NPE when streaming connection is not yet established (CASSANDRA-6210)
  * Avoid rare duplicate read repair triggering (CASSANDRA-6606)
  * Fix paging discardFirst (CASSANDRA-6555)
+ * Fix ArrayIndexOutOfBoundsException in 2ndary index query (CASSANDRA-6470)
 Merged from 1.2:
  * fsync compression metadata (CASSANDRA-6531)
  * Validate CF existence on execution for prepared statement (CASSANDRA-6535)
diff --git a/src/java/org/apache/cassandra/db/DataRange.java b/src/java/org/apache/cassandra/db/DataRange.java
index 713027c143..b8e0bf5182 100644
--- a/src/java/org/apache/cassandra/db/DataRange.java
+++ b/src/java/org/apache/cassandra/db/DataRange.java
@@ -184,8 +184,11 @@ public class DataRange
         private ColumnSlice[] slicesForKey(ByteBuffer key)
         {
             // We don't call that until it's necessary, so assume we have to do some hard work
-            ByteBuffer newStart = equals(startKey(), key) ? columnStart : null;
-            ByteBuffer newFinish = equals(stopKey(), key) ? columnFinish : null;
+            // Also note that columnStart and columnFinish, when used, only "restrict" the filter slices,
+            // it doesn't expand on them. As such, we can ignore the case where they are empty and we do
+            // as it screw up with the logic below (see #6592)
+            ByteBuffer newStart = equals(startKey(), key) && columnStart.hasRemaining() ? columnStart : null;
+            ByteBuffer newFinish = equals(stopKey(), key) && columnFinish.hasRemaining() ? columnFinish : null;
 
             List<ColumnSlice> newSlices = new ArrayList<ColumnSlice>(sliceFilter.slices.length); // in the common case, we'll have the same number of slices
 
