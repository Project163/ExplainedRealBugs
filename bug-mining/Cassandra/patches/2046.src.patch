diff --git a/CHANGES.txt b/CHANGES.txt
index f684747909..8e77bf7970 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -29,6 +29,7 @@
  * Fix forceFlush behavior (CASSANDRA-5241)
  * cqlsh: Add username autocompletion (CASSANDRA-5231)
  * Fix CQL3 composite partition key error (CASSANDRA-5240)
+ * Allow IN clause on last clustering key (CASSANDRA-5230)
 
 
 1.2.1
diff --git a/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java b/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
index 4badb8e1da..825844a4db 100644
--- a/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
+++ b/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
@@ -419,16 +419,20 @@ public class SelectStatement implements CQLStatement
             assert r != null && r.isEquality();
             if (r.eqValues.size() > 1)
             {
-                assert cfDef.isCompact;
-                // We have a IN. We only support this for the last column, so just create all columns and return.
+                // We have a IN, which we only support for the last column.
+                // If compact, just add all values and we're done. Otherwise,
+                // for each value of the IN, creates all the columns corresponding to the selection.
                 SortedSet<ByteBuffer> columns = new TreeSet<ByteBuffer>(cfDef.cfm.comparator);
                 Iterator<Term> iter = r.eqValues.iterator();
                 while (iter.hasNext())
                 {
                     Term v = iter.next();
                     ColumnNameBuilder b = iter.hasNext() ? builder.copy() : builder;
-                    ByteBuffer cname = b.add(v.bindAndGet(variables)).build();
-                    columns.add(cname);
+                    b.add(v.bindAndGet(variables));
+                    if (cfDef.isCompact)
+                        columns.add(b.build());
+                    else
+                        columns.addAll(addSelectedColumns(b));
                 }
                 return columns;
             }
@@ -438,6 +442,11 @@ public class SelectStatement implements CQLStatement
             }
         }
 
+        return addSelectedColumns(builder);
+    }
+
+    private SortedSet<ByteBuffer> addSelectedColumns(ColumnNameBuilder builder)
+    {
         if (cfDef.isCompact)
         {
             return FBUtilities.singleton(builder.build());
@@ -947,9 +956,9 @@ public class SelectStatement implements CQLStatement
                     if (!cfDef.isComposite && (!restriction.isInclusive(Bound.START) || !restriction.isInclusive(Bound.END)))
                         stmt.sliceRestriction = restriction;
                 }
-                // We only support IN for the last name and for compact storage so far
-                // TODO: #3885 allows us to extend to non compact as well, but that remains to be done
-                else if (restriction.eqValues.size() > 1 && (!cfDef.isCompact || i != stmt.columnRestrictions.length - 1))
+                // We only support IN for the last name so far
+                // TODO: #3885 allows us to extend to other parts (cf. #4762)
+                else if (restriction.eqValues.size() > 1 && i != stmt.columnRestrictions.length - 1)
                 {
                     throw new InvalidRequestException(String.format("PRIMARY KEY part %s cannot be restricted by IN relation", cname));
                 }
