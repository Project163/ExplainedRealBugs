diff --git a/test/distributed/org/apache/cassandra/distributed/upgrade/ClusterMetadataSingleNodeUpgradeTest.java b/test/distributed/org/apache/cassandra/distributed/upgrade/ClusterMetadataSingleNodeUpgradeTest.java
new file mode 100644
index 0000000000..fcda7f705b
--- /dev/null
+++ b/test/distributed/org/apache/cassandra/distributed/upgrade/ClusterMetadataSingleNodeUpgradeTest.java
@@ -0,0 +1,47 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.cassandra.distributed.upgrade;
+
+import org.junit.Test;
+
+import org.apache.cassandra.distributed.Constants;
+import org.apache.cassandra.distributed.api.Feature;
+
+public class ClusterMetadataSingleNodeUpgradeTest extends UpgradeTestBase
+{
+    @Test
+    public void testSingleNodeUpgrade() throws Throwable
+    {
+        new TestCase()
+        .nodes(1)
+        .nodesToUpgrade(1)
+        .withConfig((cfg) -> cfg.with(Feature.NETWORK, Feature.GOSSIP)
+                                .set(Constants.KEY_DTEST_FULL_STARTUP, true))
+        .upgradesToCurrentFrom(v41)
+        .setup((cluster) -> {
+            cluster.schemaChange(withKeyspace("ALTER KEYSPACE %s WITH replication = {'class': 'SimpleStrategy', 'replication_factor':1}"));
+            cluster.schemaChange("CREATE TABLE " + KEYSPACE + ".tbl (pk int, ck int, v int, PRIMARY KEY (pk, ck))");
+        })
+        .runAfterClusterUpgrade((cluster) -> {
+            cluster.get(1).nodetoolResult("initializecms").asserts().success();
+            // make sure we can execute transformations:
+            cluster.schemaChange(withKeyspace("ALTER TABLE %s.tbl with comment = 'hello123'"));
+        }).run();
+    }
+}
diff --git a/test/distributed/org/apache/cassandra/distributed/upgrade/ClusterMetadataUpgradeHintsTest.java b/test/distributed/org/apache/cassandra/distributed/upgrade/ClusterMetadataUpgradeHintsTest.java
new file mode 100644
index 0000000000..a55515f80f
--- /dev/null
+++ b/test/distributed/org/apache/cassandra/distributed/upgrade/ClusterMetadataUpgradeHintsTest.java
@@ -0,0 +1,76 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.cassandra.distributed.upgrade;
+
+import java.util.concurrent.TimeUnit;
+
+import org.junit.Test;
+
+import org.apache.cassandra.distributed.api.ConsistencyLevel;
+import org.apache.cassandra.distributed.api.Feature;
+import org.apache.cassandra.distributed.api.IInvokableInstance;
+import org.apache.cassandra.distributed.api.SimpleQueryResult;
+import org.apache.cassandra.metrics.HintsServiceMetrics;
+import org.awaitility.Awaitility;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+
+public class ClusterMetadataUpgradeHintsTest extends UpgradeTestBase
+{
+    @Test
+    public void upgradeWithHintsTest() throws Throwable
+    {
+        final int rowCount = 50;
+        new TestCase()
+        .nodes(3)
+        .nodesToUpgrade(1, 2, 3)
+        .withConfig((cfg) -> cfg.with(Feature.NETWORK, Feature.GOSSIP))
+        .upgradesToCurrentFrom(v41)
+        .setup((cluster) -> {
+            cluster.schemaChange(withKeyspace("ALTER KEYSPACE %s WITH replication = {'class': 'SimpleStrategy', 'replication_factor':3}"));
+            cluster.schemaChange("CREATE TABLE " + KEYSPACE + ".tbl (k int, v int, PRIMARY KEY (k))");
+            cluster.get(2).nodetoolResult("pausehandoff").asserts().success();
+
+            // insert some data while node1 is down so that hints are written
+            cluster.get(1).shutdown().get();
+            for (int i = 0; i < rowCount; i++)
+                cluster.coordinator(2).execute("INSERT INTO " + KEYSPACE + ".tbl(k,v) VALUES (?, ?)", ConsistencyLevel.ANY, i, i);
+            cluster.get(2).flush(KEYSPACE);
+            cluster.get(3).flush(KEYSPACE);
+            cluster.get(1).startup();
+
+            // Check that none of the writes got to node1
+            SimpleQueryResult rows = cluster.get(1).executeInternalWithResult("SELECT * FROM " + KEYSPACE + ".tbl");
+            assertFalse(rows.hasNext());
+        })
+        .runAfterClusterUpgrade((cluster) -> {
+            Awaitility.waitAtMost(10, TimeUnit.SECONDS).until(() -> {
+                SimpleQueryResult rows = cluster.get(1).executeInternalWithResult("SELECT * FROM " + KEYSPACE + ".tbl");
+                return rows.toObjectArrays().length == rowCount;
+            });
+
+            IInvokableInstance inst = (IInvokableInstance)cluster.get(2);
+            long hintsDelivered = inst.callOnInstance(() -> {
+                return (long)HintsServiceMetrics.hintsSucceeded.getCount();
+            });
+            assertEquals(rowCount, hintsDelivered);
+        }).run();
+    }
+}
diff --git a/test/distributed/org/apache/cassandra/distributed/upgrade/ClusterMetadataUpgradeHostIdTest.java b/test/distributed/org/apache/cassandra/distributed/upgrade/ClusterMetadataUpgradeHostIdTest.java
new file mode 100644
index 0000000000..c05279da1f
--- /dev/null
+++ b/test/distributed/org/apache/cassandra/distributed/upgrade/ClusterMetadataUpgradeHostIdTest.java
@@ -0,0 +1,103 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.cassandra.distributed.upgrade;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.UUID;
+import java.util.concurrent.TimeUnit;
+
+import com.google.common.util.concurrent.Uninterruptibles;
+import org.junit.Test;
+
+import org.apache.cassandra.distributed.Constants;
+import org.apache.cassandra.distributed.UpgradeableCluster;
+import org.apache.cassandra.distributed.api.Feature;
+import org.apache.cassandra.locator.InetAddressAndPort;
+import org.apache.cassandra.tcm.membership.NodeId;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.psjava.util.AssertStatus.assertTrue;
+
+public class ClusterMetadataUpgradeHostIdTest extends UpgradeTestBase
+{
+    @Test
+    public void upgradeHostIdUpdateTest() throws Throwable
+    {
+        Map<InetAddressAndPort, UUID> expectedUUIDs = new HashMap<>();
+        new TestCase()
+        .nodes(3)
+        .nodesToUpgrade(1, 2, 3)
+        .withConfig((cfg) -> cfg.with(Feature.NETWORK, Feature.GOSSIP)
+                                .set(Constants.KEY_DTEST_FULL_STARTUP, true))
+        .upgradesToCurrentFrom(v41)
+        .setup((cluster) -> {
+            cluster.schemaChange(withKeyspace("ALTER KEYSPACE %s WITH replication = {'class': 'SimpleStrategy', 'replication_factor':2}"));
+            cluster.schemaChange("CREATE TABLE " + KEYSPACE + ".tbl (pk int, ck int, v int, PRIMARY KEY (pk, ck))");
+            expectedUUIDs.putAll(getHostIds(cluster, 1));
+            for (UUID hostId : expectedUUIDs.values())
+                assertFalse(NodeId.isValidNodeId(hostId));
+        })
+        .runAfterClusterUpgrade((cluster) -> {
+            for (int i = 1; i <= 3; i++)
+                assertEquals(expectedUUIDs, getHostIds(cluster, i));
+
+            cluster.get(1).nodetoolResult("initializecms").asserts().success();
+
+            Map<InetAddressAndPort, UUID> postUpgradeUUIDs = new HashMap<>(getHostIds(cluster, 1));
+            boolean found = false;
+            for (int i = 0; i < 20; i++)
+            {
+                if (postUpgradeUUIDs.values().stream().allMatch(NodeId::isValidNodeId))
+                {
+                    found = true;
+                    break;
+                }
+                System.out.println("NOT ALL VALID: "+postUpgradeUUIDs);
+                Uninterruptibles.sleepUninterruptibly(1, TimeUnit.SECONDS);
+                postUpgradeUUIDs = new HashMap<>(getHostIds(cluster, 1));
+            }
+            assertTrue(found);
+
+            for (int i = 2; i <= 3; i++)
+                while(!getHostIds(cluster, i).equals(postUpgradeUUIDs))
+                    Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);
+        }).run();
+    }
+
+    private static Map<InetAddressAndPort, UUID> getHostIds(UpgradeableCluster cluster, int instance)
+    {
+        String gossipInfo = cluster.get(instance).nodetoolResult("gossipinfo").getStdout();
+        InetAddressAndPort host = null;
+        Map<InetAddressAndPort, UUID> hostIds = new HashMap<>();
+        for (String l : gossipInfo.split("\n"))
+        {
+            if (l.startsWith("/"))
+                host = InetAddressAndPort.getByNameUnchecked(l.replace("/", ""));
+
+            if (l.contains("HOST_ID"))
+            {
+                String hostIdStr = l.split(":")[2];
+                hostIds.put(host, UUID.fromString(hostIdStr));
+            }
+        }
+        return hostIds;
+    }
+}
diff --git a/test/distributed/org/apache/cassandra/distributed/upgrade/ClusterMetadataUpgradeIgnoreHostTest.java b/test/distributed/org/apache/cassandra/distributed/upgrade/ClusterMetadataUpgradeIgnoreHostTest.java
new file mode 100644
index 0000000000..290af7acc8
--- /dev/null
+++ b/test/distributed/org/apache/cassandra/distributed/upgrade/ClusterMetadataUpgradeIgnoreHostTest.java
@@ -0,0 +1,50 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.cassandra.distributed.upgrade;
+
+import org.junit.Test;
+
+import org.apache.cassandra.distributed.Constants;
+import org.apache.cassandra.distributed.api.Feature;
+
+public class ClusterMetadataUpgradeIgnoreHostTest extends UpgradeTestBase
+{
+    @Test
+    public void upgradeIgnoreHostsTest() throws Throwable
+    {
+        new TestCase()
+        .nodes(3)
+        .nodesToUpgrade(1, 2, 3)
+        .withConfig((cfg) -> cfg.with(Feature.NETWORK, Feature.GOSSIP)
+                                .set(Constants.KEY_DTEST_FULL_STARTUP, true))
+        .upgradesToCurrentFrom(v41)
+        .setup((cluster) -> {
+            cluster.schemaChange(withKeyspace("ALTER KEYSPACE %s WITH replication = {'class': 'SimpleStrategy', 'replication_factor':2}"));
+            cluster.schemaChange("CREATE TABLE " + KEYSPACE + ".tbl (pk int, ck int, v int, PRIMARY KEY (pk, ck))");
+        })
+        .runAfterClusterUpgrade((cluster) -> {
+            // todo; isolate node 3 - actually shutting it down makes us throw exceptions when test finishes
+            cluster.filters().allVerbs().to(3).drop();
+            cluster.filters().allVerbs().from(3).drop();
+            cluster.get(1).nodetoolResult("initializecms").asserts().failure(); // node3 unreachable
+            cluster.get(1).nodetoolResult("initializecms", "--ignore", "127.0.0.1").asserts().failure(); // can't ignore localhost
+            cluster.get(1).nodetoolResult("initializecms", "--ignore", "127.0.0.3").asserts().success();
+        }).run();
+    }
+}
diff --git a/test/distributed/org/apache/cassandra/distributed/upgrade/ClusterMetadataUpgradeIgnoreHostsTest.java b/test/distributed/org/apache/cassandra/distributed/upgrade/ClusterMetadataUpgradeIgnoreHostsTest.java
new file mode 100644
index 0000000000..8dc7940441
--- /dev/null
+++ b/test/distributed/org/apache/cassandra/distributed/upgrade/ClusterMetadataUpgradeIgnoreHostsTest.java
@@ -0,0 +1,50 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.cassandra.distributed.upgrade;
+
+import org.junit.Test;
+
+import org.apache.cassandra.distributed.Constants;
+import org.apache.cassandra.distributed.api.Feature;
+
+public class ClusterMetadataUpgradeIgnoreHostsTest extends UpgradeTestBase
+{
+    @Test
+    public void upgradeIgnoreHostsTest() throws Throwable
+    {
+        new TestCase()
+        .nodes(3)
+        .nodesToUpgrade(1, 2, 3)
+        .withConfig((cfg) -> cfg.with(Feature.NETWORK, Feature.GOSSIP)
+                                .set(Constants.KEY_DTEST_FULL_STARTUP, true))
+        .upgradesToCurrentFrom(v41)
+        .setup((cluster) -> {
+            cluster.schemaChange(withKeyspace("ALTER KEYSPACE %s WITH replication = {'class': 'SimpleStrategy', 'replication_factor':2}"));
+            cluster.schemaChange("CREATE TABLE " + KEYSPACE + ".tbl (pk int, ck int, v int, PRIMARY KEY (pk, ck))");
+        })
+        .runAfterClusterUpgrade((cluster) -> {
+            // todo; isolate node 3 - actually shutting it down makes us throw exceptions when test finishes
+            cluster.filters().allVerbs().to(3).drop();
+            cluster.filters().allVerbs().from(3).drop();
+            cluster.get(1).nodetoolResult("initializecms").asserts().failure(); // node3 unreachable
+            cluster.get(1).nodetoolResult("initializecms", "--ignore", "127.0.0.1").asserts().failure(); // can't ignore localhost
+            cluster.get(1).nodetoolResult("initializecms", "--ignore", "127.0.0.3").asserts().success();
+        }).run();
+    }
+}
diff --git a/test/distributed/org/apache/cassandra/distributed/upgrade/ClusterMetadataUpgradeTest.java b/test/distributed/org/apache/cassandra/distributed/upgrade/ClusterMetadataUpgradeTest.java
index 61ca3ab901..f6a8f8b7c9 100644
--- a/test/distributed/org/apache/cassandra/distributed/upgrade/ClusterMetadataUpgradeTest.java
+++ b/test/distributed/org/apache/cassandra/distributed/upgrade/ClusterMetadataUpgradeTest.java
@@ -18,27 +18,16 @@
 
 package org.apache.cassandra.distributed.upgrade;
 
-import java.util.HashMap;
-import java.util.Map;
 import java.util.UUID;
-import java.util.concurrent.TimeUnit;
 
 import org.junit.Test;
 
-import com.google.monitoring.runtime.instrumentation.common.util.concurrent.Uninterruptibles;
 import org.apache.cassandra.distributed.Constants;
-import org.apache.cassandra.distributed.UpgradeableCluster;
-import org.apache.cassandra.distributed.api.ConsistencyLevel;
 import org.apache.cassandra.distributed.api.Feature;
 import org.apache.cassandra.distributed.api.IInvokableInstance;
-import org.apache.cassandra.distributed.api.SimpleQueryResult;
 import org.apache.cassandra.distributed.shared.ClusterUtils;
-import org.apache.cassandra.locator.InetAddressAndPort;
-import org.apache.cassandra.metrics.HintsServiceMetrics;
 import org.apache.cassandra.tcm.membership.NodeId;
-import org.awaitility.Awaitility;
 
-import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.psjava.util.AssertStatus.assertTrue;
 
@@ -74,150 +63,4 @@ public class ClusterMetadataUpgradeTest extends UpgradeTestBase
             });
         }).run();
     }
-
-    @Test
-    public void upgradeWithHintsTest() throws Throwable
-    {
-        final int rowCount = 50;
-        new TestCase()
-        .nodes(3)
-        .nodesToUpgrade(1, 2, 3)
-        .withConfig((cfg) -> cfg.with(Feature.NETWORK, Feature.GOSSIP))
-        .upgradesToCurrentFrom(v41)
-        .setup((cluster) -> {
-            cluster.schemaChange(withKeyspace("ALTER KEYSPACE %s WITH replication = {'class': 'SimpleStrategy', 'replication_factor':3}"));
-            cluster.schemaChange("CREATE TABLE " + KEYSPACE + ".tbl (k int, v int, PRIMARY KEY (k))");
-            cluster.get(2).nodetoolResult("pausehandoff").asserts().success();
-
-            // insert some data while node1 is down so that hints are written
-            cluster.get(1).shutdown().get();
-            for (int i = 0; i < rowCount; i++)
-                cluster.coordinator(2).execute("INSERT INTO " + KEYSPACE + ".tbl(k,v) VALUES (?, ?)", ConsistencyLevel.ANY, i, i);
-            cluster.get(2).flush(KEYSPACE);
-            cluster.get(3).flush(KEYSPACE);
-            cluster.get(1).startup();
-
-            // Check that none of the writes got to node1
-            SimpleQueryResult rows = cluster.get(1).executeInternalWithResult("SELECT * FROM " + KEYSPACE + ".tbl");
-            assertFalse(rows.hasNext());
-        })
-        .runAfterClusterUpgrade((cluster) -> {
-            Awaitility.waitAtMost(10, TimeUnit.SECONDS).until(() -> {
-                SimpleQueryResult rows = cluster.get(1).executeInternalWithResult("SELECT * FROM " + KEYSPACE + ".tbl");
-                return rows.toObjectArrays().length == rowCount;
-            });
-
-            IInvokableInstance inst = (IInvokableInstance)cluster.get(2);
-            long hintsDelivered = inst.callOnInstance(() -> {
-                return (long)HintsServiceMetrics.hintsSucceeded.getCount();
-            });
-            assertEquals(rowCount, hintsDelivered);
-        }).run();
-    }
-
-    @Test
-    public void upgradeIgnoreHostsTest() throws Throwable
-    {
-        new TestCase()
-        .nodes(3)
-        .nodesToUpgrade(1, 2, 3)
-        .withConfig((cfg) -> cfg.with(Feature.NETWORK, Feature.GOSSIP)
-                                .set(Constants.KEY_DTEST_FULL_STARTUP, true))
-        .upgradesToCurrentFrom(v41)
-        .setup((cluster) -> {
-            cluster.schemaChange(withKeyspace("ALTER KEYSPACE %s WITH replication = {'class': 'SimpleStrategy', 'replication_factor':2}"));
-            cluster.schemaChange("CREATE TABLE " + KEYSPACE + ".tbl (pk int, ck int, v int, PRIMARY KEY (pk, ck))");
-        })
-        .runAfterClusterUpgrade((cluster) -> {
-            // todo; isolate node 3 - actually shutting it down makes us throw exceptions when test finishes
-            cluster.filters().allVerbs().to(3).drop();
-            cluster.filters().allVerbs().from(3).drop();
-            cluster.get(1).nodetoolResult("initializecms").asserts().failure(); // node3 unreachable
-            cluster.get(1).nodetoolResult("initializecms", "--ignore", "127.0.0.1").asserts().failure(); // can't ignore localhost
-            cluster.get(1).nodetoolResult("initializecms", "--ignore", "127.0.0.3").asserts().success();
-        }).run();
-    }
-
-    @Test
-    public void upgradeHostIdUpdateTest() throws Throwable
-    {
-        Map<InetAddressAndPort, UUID> expectedUUIDs = new HashMap<>();
-        new TestCase()
-        .nodes(3)
-        .nodesToUpgrade(1, 2, 3)
-        .withConfig((cfg) -> cfg.with(Feature.NETWORK, Feature.GOSSIP)
-                                .set(Constants.KEY_DTEST_FULL_STARTUP, true))
-        .upgradesToCurrentFrom(v41)
-        .setup((cluster) -> {
-            cluster.schemaChange(withKeyspace("ALTER KEYSPACE %s WITH replication = {'class': 'SimpleStrategy', 'replication_factor':2}"));
-            cluster.schemaChange("CREATE TABLE " + KEYSPACE + ".tbl (pk int, ck int, v int, PRIMARY KEY (pk, ck))");
-            expectedUUIDs.putAll(getHostIds(cluster, 1));
-            for (UUID hostId : expectedUUIDs.values())
-                assertFalse(NodeId.isValidNodeId(hostId));
-        })
-        .runAfterClusterUpgrade((cluster) -> {
-            for (int i = 1; i <= 3; i++)
-                assertEquals(expectedUUIDs, getHostIds(cluster, i));
-
-            cluster.get(1).nodetoolResult("initializecms").asserts().success();
-
-            Map<InetAddressAndPort, UUID> postUpgradeUUIDs = new HashMap<>(getHostIds(cluster, 1));
-            boolean found = false;
-            for (int i = 0; i < 20; i++)
-            {
-                if (postUpgradeUUIDs.values().stream().allMatch(NodeId::isValidNodeId))
-                {
-                    found = true;
-                    break;
-                }
-                System.out.println("NOT ALL VALID: "+postUpgradeUUIDs);
-                Uninterruptibles.sleepUninterruptibly(1, TimeUnit.SECONDS);
-                postUpgradeUUIDs = new HashMap<>(getHostIds(cluster, 1));
-            }
-            assertTrue(found);
-
-            for (int i = 2; i <= 3; i++)
-                while(!getHostIds(cluster, i).equals(postUpgradeUUIDs))
-                    Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);
-        }).run();
-    }
-
-    @Test
-    public void testSingleNodeUpgrade() throws Throwable
-    {
-        new TestCase()
-        .nodes(1)
-        .nodesToUpgrade(1)
-        .withConfig((cfg) -> cfg.with(Feature.NETWORK, Feature.GOSSIP)
-                                .set(Constants.KEY_DTEST_FULL_STARTUP, true))
-        .upgradesToCurrentFrom(v41)
-        .setup((cluster) -> {
-            cluster.schemaChange(withKeyspace("ALTER KEYSPACE %s WITH replication = {'class': 'SimpleStrategy', 'replication_factor':1}"));
-            cluster.schemaChange("CREATE TABLE " + KEYSPACE + ".tbl (pk int, ck int, v int, PRIMARY KEY (pk, ck))");
-        })
-        .runAfterClusterUpgrade((cluster) -> {
-            cluster.get(1).nodetoolResult("initializecms").asserts().success();
-            // make sure we can execute transformations:
-            cluster.schemaChange(withKeyspace("ALTER TABLE %s.tbl with comment = 'hello123'"));
-        }).run();
-    }
-
-    private static Map<InetAddressAndPort, UUID> getHostIds(UpgradeableCluster cluster, int instance)
-    {
-        String gossipInfo = cluster.get(instance).nodetoolResult("gossipinfo").getStdout();
-        InetAddressAndPort host = null;
-        Map<InetAddressAndPort, UUID> hostIds = new HashMap<>();
-        for (String l : gossipInfo.split("\n"))
-        {
-            if (l.startsWith("/"))
-                host = InetAddressAndPort.getByNameUnchecked(l.replace("/", ""));
-
-            if (l.contains("HOST_ID"))
-            {
-                String hostIdStr = l.split(":")[2];
-                hostIds.put(host, UUID.fromString(hostIdStr));
-            }
-        }
-        return hostIds;
-    }
 }
diff --git a/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeTTLOverflowAfterUpgradeTest.java b/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeTTLOverflowAfterUpgradeTest.java
new file mode 100644
index 0000000000..c4c105be0a
--- /dev/null
+++ b/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeTTLOverflowAfterUpgradeTest.java
@@ -0,0 +1,74 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.cassandra.distributed.upgrade;
+
+import org.junit.Test;
+
+import org.apache.cassandra.utils.StorageCompatibilityMode;
+
+import static org.apache.cassandra.distributed.upgrade.MixedModeTTLOverflowUpgradeTest.assertPolicyTriggersAt2038;
+import static org.apache.cassandra.distributed.upgrade.MixedModeTTLOverflowUpgradeTest.assertPolicyTriggersAt2106;
+import static org.apache.cassandra.distributed.upgrade.MixedModeTTLOverflowUpgradeTest.restartNodeWithCompatibilityMode;
+import static org.apache.cassandra.utils.StorageCompatibilityMode.NONE;
+import static org.apache.cassandra.utils.StorageCompatibilityMode.UPGRADING;
+
+/**
+ * Tests TTL the overflow policy triggers at the correct limit: year 2038 <=nb or 2186 >=oa
+ * <p>
+ * <=oa overflow policy triggers at year 2038. That could be <=4.1 or 5.0 with 4.x storage compatibility
+ * >oa overflow policy triggers at year 2106. That is >=5.0 using >=5.x storage compatibility
+ *
+ * @see StorageCompatibilityMode
+ */
+public class MixedModeTTLOverflowAfterUpgradeTest extends UpgradeTestBase
+{
+    @Test
+    public void testTTLOverflowAfterUpgrade() throws Throwable
+    {
+        MixedModeTTLOverflowUpgradeTest.testTTLOverflow((cluster, node) -> {
+            if (node == 1) // only node1 is upgraded, and the cluster is in mixed versions mode
+            {
+                assertPolicyTriggersAt2038(cluster.coordinator(1));
+                assertPolicyTriggersAt2038(cluster.coordinator(2));
+            }
+            else // both nodes have been upgraded, and the cluster isn't in mixed version mode anymore
+            {
+                assertPolicyTriggersAt2038(cluster.coordinator(1));
+                assertPolicyTriggersAt2038(cluster.coordinator(2));
+
+                // We restart one node on 5.0 >oa hence 2038 should still be the limit as the other node is 5.0 <=oa
+                // We're on compatibility mode where oa and oa nodes are a possibility
+                restartNodeWithCompatibilityMode(cluster, 1, UPGRADING);
+                assertPolicyTriggersAt2038(cluster.coordinator(1));
+                assertPolicyTriggersAt2038(cluster.coordinator(2));
+
+                // We restart the other node so they're all on 5.0 >oa hence 2106 should be the limit
+                restartNodeWithCompatibilityMode(cluster, 2, UPGRADING);
+                assertPolicyTriggersAt2106(cluster.coordinator(1));
+                assertPolicyTriggersAt2106(cluster.coordinator(2));
+
+                // We restart the cluster out of compatibility mode once everything is 5.0oa TTL 2106
+                restartNodeWithCompatibilityMode(cluster, 1, NONE);
+                restartNodeWithCompatibilityMode(cluster, 2, NONE);
+                assertPolicyTriggersAt2106(cluster.coordinator(1));
+                assertPolicyTriggersAt2106(cluster.coordinator(2));
+            }
+        });
+    }
+}
diff --git a/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeTTLOverflowUpgradeTest.java b/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeTTLOverflowUpgradeTest.java
index dbae49151e..390865ddb5 100644
--- a/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeTTLOverflowUpgradeTest.java
+++ b/test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeTTLOverflowUpgradeTest.java
@@ -81,41 +81,7 @@ public class MixedModeTTLOverflowUpgradeTest extends UpgradeTestBase
         });
     }
 
-    @Test
-    public void testTTLOverflowAfterUpgrade() throws Throwable
-    {
-        testTTLOverflow((cluster, node) -> {
-            if (node == 1) // only node1 is upgraded, and the cluster is in mixed versions mode
-            {
-                assertPolicyTriggersAt2038(cluster.coordinator(1));
-                assertPolicyTriggersAt2038(cluster.coordinator(2));
-            }
-            else // both nodes have been upgraded, and the cluster isn't in mixed version mode anymore
-            {
-                assertPolicyTriggersAt2038(cluster.coordinator(1));
-                assertPolicyTriggersAt2038(cluster.coordinator(2));
-
-                // We restart one node on 5.0 >oa hence 2038 should still be the limit as the other node is 5.0 <=oa
-                // We're on compatibility mode where oa and oa nodes are a possibility
-                restartNodeWithCompatibilityMode(cluster, 1, UPGRADING);
-                assertPolicyTriggersAt2038(cluster.coordinator(1));
-                assertPolicyTriggersAt2038(cluster.coordinator(2));
-
-                // We restart the other node so they're all on 5.0 >oa hence 2106 should be the limit
-                restartNodeWithCompatibilityMode(cluster, 2, UPGRADING);
-                assertPolicyTriggersAt2106(cluster.coordinator(1));
-                assertPolicyTriggersAt2106(cluster.coordinator(2));
-
-                // We restart the cluster out of compatibility mode once everything is 5.0oa TTL 2106
-                restartNodeWithCompatibilityMode(cluster, 1, NONE);
-                restartNodeWithCompatibilityMode(cluster, 2, NONE);
-                assertPolicyTriggersAt2106(cluster.coordinator(1));
-                assertPolicyTriggersAt2106(cluster.coordinator(2));
-            }
-        });
-    }
-
-    private static void testTTLOverflow(RunOnClusterAndNode runAfterNodeUpgrade) throws Throwable
+    static void testTTLOverflow(RunOnClusterAndNode runAfterNodeUpgrade) throws Throwable
     {
         new TestCase()
                 .nodes(2)
@@ -134,21 +100,21 @@ public class MixedModeTTLOverflowUpgradeTest extends UpgradeTestBase
                 .run();
     }
 
-    private static void restartNodeWithCompatibilityMode(UpgradeableCluster cluster, int node, StorageCompatibilityMode mode) throws Throwable
+    static void restartNodeWithCompatibilityMode(UpgradeableCluster cluster, int node, StorageCompatibilityMode mode) throws Throwable
     {
         cluster.get(node).shutdown().get();
         cluster.get(node).config().set("storage_compatibility_mode", mode.toString());
         cluster.get(node).startup();
     }
 
-    private static void assertPolicyTriggersAt2038(ICoordinator coordinator)
+    static void assertPolicyTriggersAt2038(ICoordinator coordinator)
     {
         Assertions.assertThatThrownBy(() -> coordinator.execute(withKeyspace("INSERT INTO %s.t (k, v) VALUES (0, 0) USING TTL " + Attributes.MAX_TTL), ALL))
                   .hasMessageContaining("exceeds maximum supported expiration date")
                   .hasMessageContaining("2038");
     }
 
-    private static void assertPolicyTriggersAt2106(ICoordinator coordinator)
+    static void assertPolicyTriggersAt2106(ICoordinator coordinator)
     {
         boolean overflowPoliciesApply = (Clock.Global.currentTimeMillis() / 1000) > (Cell.MAX_DELETION_TIME - Attributes.MAX_TTL);
 
