diff --git a/CHANGES.txt b/CHANGES.txt
index b96758091a..d701a221af 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 3.0.17
+ * Handle repeat open bound from SRP in read repair (CASSANDRA-14330)
  * Use zero as default score in DynamicEndpointSnitch (CASSANDRA-14252)
  * Respect max hint window when hinting for LWT (CASSANDRA-14215)
  * Adding missing WriteType enum values to v3, v4, and v5 spec (CASSANDRA-13697)
diff --git a/src/java/org/apache/cassandra/db/ReadResponse.java b/src/java/org/apache/cassandra/db/ReadResponse.java
index c59d00a551..bc44a1b925 100644
--- a/src/java/org/apache/cassandra/db/ReadResponse.java
+++ b/src/java/org/apache/cassandra/db/ReadResponse.java
@@ -107,13 +107,33 @@ public abstract class ReadResponse
                 try (UnfilteredRowIterator partition = iter.next())
                 {
                     if (partition.partitionKey().equals(key))
-                        return ImmutableBTreePartition.create(partition).toString();
+                        return toDebugString(partition, command.metadata());
                 }
             }
         }
         return "<key " + key + " not found>";
     }
 
+    private String toDebugString(UnfilteredRowIterator partition, CFMetaData metadata)
+    {
+        StringBuilder sb = new StringBuilder();
+
+        sb.append(String.format("[%s.%s] key=%s partition_deletion=%s columns=%s",
+                                metadata.ksName,
+                                metadata.cfName,
+                                metadata.getKeyValidator().getString(partition.partitionKey().getKey()),
+                                partition.partitionLevelDeletion(),
+                                partition.columns()));
+
+        if (partition.staticRow() != Rows.EMPTY_STATIC_ROW)
+            sb.append("\n    ").append(partition.staticRow().toString(metadata, true));
+
+        while (partition.hasNext())
+            sb.append("\n    ").append(partition.next().toString(metadata, true));
+
+        return sb.toString();
+    }
+
     protected static ByteBuffer makeDigest(UnfilteredPartitionIterator iterator, ReadCommand command)
     {
         MessageDigest digest = FBUtilities.threadLocalMD5Digest();
diff --git a/src/java/org/apache/cassandra/db/rows/RangeTombstoneBoundMarker.java b/src/java/org/apache/cassandra/db/rows/RangeTombstoneBoundMarker.java
index 6f4afa5c11..0079114aad 100644
--- a/src/java/org/apache/cassandra/db/rows/RangeTombstoneBoundMarker.java
+++ b/src/java/org/apache/cassandra/db/rows/RangeTombstoneBoundMarker.java
@@ -140,7 +140,7 @@ public class RangeTombstoneBoundMarker extends AbstractRangeTombstoneMarker
 
     public String toString(CFMetaData metadata)
     {
-        return "Marker " + bound.toString(metadata) + '@' + deletion.markedForDeleteAt();
+        return String.format("Marker %s@%d/%d", bound.toString(metadata), deletion.markedForDeleteAt(), deletion.localDeletionTime());
     }
 
     @Override
diff --git a/src/java/org/apache/cassandra/db/rows/RangeTombstoneBoundaryMarker.java b/src/java/org/apache/cassandra/db/rows/RangeTombstoneBoundaryMarker.java
index 0683d7625a..c4bc2f2383 100644
--- a/src/java/org/apache/cassandra/db/rows/RangeTombstoneBoundaryMarker.java
+++ b/src/java/org/apache/cassandra/db/rows/RangeTombstoneBoundaryMarker.java
@@ -153,7 +153,10 @@ public class RangeTombstoneBoundaryMarker extends AbstractRangeTombstoneMarker
 
     public String toString(CFMetaData metadata)
     {
-        return String.format("Marker %s@%d-%d", bound.toString(metadata), endDeletion.markedForDeleteAt(), startDeletion.markedForDeleteAt());
+        return String.format("Marker %s@%d/%d-%d/%d",
+                             bound.toString(metadata),
+                             endDeletion.markedForDeleteAt(), endDeletion.localDeletionTime(),
+                             startDeletion.markedForDeleteAt(), startDeletion.localDeletionTime());
     }
 
     @Override
diff --git a/src/java/org/apache/cassandra/service/DataResolver.java b/src/java/org/apache/cassandra/service/DataResolver.java
index f02b565ded..2252913832 100644
--- a/src/java/org/apache/cassandra/service/DataResolver.java
+++ b/src/java/org/apache/cassandra/service/DataResolver.java
@@ -331,8 +331,10 @@ public class DataResolver extends ResponseResolver
                     // The following can be pretty verbose, but it's really only triggered if a bug happen, so we'd
                     // rather get more info to debug than not.
                     CFMetaData table = command.metadata();
-                    String details = String.format("Error merging RTs on %s.%s: merged=%s, versions=%s, sources={%s}, responses:%n %s",
+                    String details = String.format("Error merging RTs on %s.%s: command=%s, reversed=%b, merged=%s, versions=%s, sources={%s}, responses:%n %s",
                                                    table.ksName, table.cfName,
+                                                   command.toCQLString(),
+                                                   isReversed,
                                                    merged == null ? "null" : merged.toString(table),
                                                    '[' + Joiner.on(", ").join(Iterables.transform(Arrays.asList(versions), rt -> rt == null ? "null" : rt.toString(table))) + ']',
                                                    Arrays.toString(sources),
@@ -395,11 +397,24 @@ public class DataResolver extends ResponseResolver
                         DeletionTime partitionRepairDeletion = partitionLevelRepairDeletion(i);
                         if (markerToRepair[i] == null && currentDeletion.supersedes(partitionRepairDeletion))
                         {
-                            // Since there is an ongoing merged deletion, the only way we don't have an open repair for
-                            // this source is that it had a range open with the same deletion as current and it's
-                            // closing it.
-                            assert marker.isClose(isReversed) && currentDeletion.equals(marker.closeDeletionTime(isReversed))
-                                 : String.format("currentDeletion=%s, marker=%s", currentDeletion, marker.toString(command.metadata()));
+                            /*
+                             * Since there is an ongoing merged deletion, the only two ways we don't have an open repair for
+                             * this source are that:
+                             *
+                             * 1) it had a range open with the same deletion as current marker, and the marker is coming from
+                             *    a short read protection response - repeating the open RT bound, or
+                             * 2) it had a range open with the same deletion as current marker, and the marker is closing it.
+                             */
+                            if (!marker.isBoundary() && marker.isOpen(isReversed)) // (1)
+                            {
+                                assert currentDeletion.equals(marker.openDeletionTime(isReversed))
+                                    : String.format("currentDeletion=%s, marker=%s", currentDeletion, marker.toString(command.metadata()));
+                            }
+                            else // (2)
+                            {
+                                assert marker.isClose(isReversed) && currentDeletion.equals(marker.closeDeletionTime(isReversed))
+                                    : String.format("currentDeletion=%s, marker=%s", currentDeletion, marker.toString(command.metadata()));
+                            }
 
                             // and so unless it's a boundary whose opening deletion time is still equal to the current
                             // deletion (see comment above for why this can actually happen), we have to repair the source
