diff --git a/src/java/org/apache/cassandra/db/commitlog/AbstractCommitLogService.java b/src/java/org/apache/cassandra/db/commitlog/AbstractCommitLogService.java
index 59bf691295..300a2bd165 100644
--- a/src/java/org/apache/cassandra/db/commitlog/AbstractCommitLogService.java
+++ b/src/java/org/apache/cassandra/db/commitlog/AbstractCommitLogService.java
@@ -31,7 +31,7 @@ public abstract class AbstractCommitLogService
     // how often should we log syngs that lag behind our desired period
     private static final long LAG_REPORT_INTERVAL = TimeUnit.MINUTES.toMillis(5);
 
-    private final Thread thread;
+    private Thread thread;
     private volatile boolean shutdown = false;
 
     // all Allocations written before this time will be synced
@@ -45,6 +45,10 @@ public abstract class AbstractCommitLogService
     protected final WaitQueue syncComplete = new WaitQueue();
     private final Semaphore haveWork = new Semaphore(1);
 
+    private final CommitLog commitLog;
+    private final String name;
+    private final long pollIntervalMillis;
+
     private static final Logger logger = LoggerFactory.getLogger(AbstractCommitLogService.class);
 
     /**
@@ -54,6 +58,15 @@ public abstract class AbstractCommitLogService
      * Subclasses may be notified when a sync finishes by using the syncComplete WaitQueue.
      */
     AbstractCommitLogService(final CommitLog commitLog, final String name, final long pollIntervalMillis)
+    {
+        this.commitLog = commitLog;
+        this.name = name;
+        this.pollIntervalMillis = pollIntervalMillis;
+        start();
+    }
+
+    // Separated into individual method for unit testing stop/start capability
+    private void start()
     {
         if (pollIntervalMillis < 1)
             throw new IllegalArgumentException(String.format("Commit log flush interval must be positive: %dms", pollIntervalMillis));
@@ -170,6 +183,29 @@ public abstract class AbstractCommitLogService
         haveWork.release(1);
     }
 
+    /**
+     * FOR TESTING ONLY
+     */
+    public void startUnsafe()
+    {
+        while (haveWork.availablePermits() < 1)
+            haveWork.release();
+
+        while (haveWork.availablePermits() > 1)
+        {
+            try
+            {
+                haveWork.acquire();
+            }
+            catch (InterruptedException e)
+            {
+                throw new RuntimeException(e);
+            }
+        }
+        shutdown = false;
+        start();
+    }
+
     public void awaitTermination() throws InterruptedException
     {
         thread.join();
diff --git a/src/java/org/apache/cassandra/db/commitlog/CommitLog.java b/src/java/org/apache/cassandra/db/commitlog/CommitLog.java
index 55b00222b4..95b549d542 100644
--- a/src/java/org/apache/cassandra/db/commitlog/CommitLog.java
+++ b/src/java/org/apache/cassandra/db/commitlog/CommitLog.java
@@ -318,9 +318,36 @@ public class CommitLog implements CommitLogMBean
     /**
      * FOR TESTING PURPOSES. See CommitLogAllocator.
      */
-    public void resetUnsafe()
+    public void resetUnsafe(boolean deleteSegments)
     {
-        allocator.resetUnsafe();
+        stopUnsafe(deleteSegments);
+        startUnsafe();
+    }
+
+    /**
+     * FOR TESTING PURPOSES. See CommitLogAllocator.
+     */
+    public void stopUnsafe(boolean deleteSegments)
+    {
+        executor.shutdown();
+        try
+        {
+            executor.awaitTermination();
+        }
+        catch (InterruptedException e)
+        {
+            throw new RuntimeException(e);
+        }
+        allocator.stopUnsafe(deleteSegments);
+    }
+
+    /**
+     * FOR TESTING PURPOSES.  See CommitLogAllocator
+     */
+    public void startUnsafe()
+    {
+        allocator.startUnsafe();
+        executor.startUnsafe();
     }
 
     /**
diff --git a/src/java/org/apache/cassandra/db/commitlog/CommitLogSegmentManager.java b/src/java/org/apache/cassandra/db/commitlog/CommitLogSegmentManager.java
index a897f758d7..8e1cc17819 100644
--- a/src/java/org/apache/cassandra/db/commitlog/CommitLogSegmentManager.java
+++ b/src/java/org/apache/cassandra/db/commitlog/CommitLogSegmentManager.java
@@ -45,6 +45,7 @@ import org.apache.cassandra.config.Schema;
 import org.apache.cassandra.db.ColumnFamilyStore;
 import org.apache.cassandra.db.Keyspace;
 import org.apache.cassandra.db.Mutation;
+import org.apache.cassandra.io.FSWriteError;
 import org.apache.cassandra.io.util.FileUtils;
 import org.apache.cassandra.net.MessagingService;
 import org.apache.cassandra.utils.Pair;
@@ -516,21 +517,13 @@ public class CommitLogSegmentManager
         return Futures.allAsList(flushes.values());
     }
 
-    /**
-     * Resets all the segments, for testing purposes. DO NOT USE THIS OUTSIDE OF TESTS.
-     */
-    public void resetUnsafe()
-    {
-        stopUnsafe();
-        startUnsafe();
-    }
-
     /**
      * Stops CL, for testing purposes. DO NOT USE THIS OUTSIDE OF TESTS.
+     * Only call this after the AbstractCommitLogService is shut down.
      */
-    public void stopUnsafe()
+    public void stopUnsafe(boolean deleteSegments)
     {
-        logger.debug("Closing and clearing existing commit log segments...");
+        logger.debug("CLSM closing and clearing existing commit log segments...");
 
         while (!segmentManagementTasks.isEmpty())
             Thread.yield();
@@ -546,18 +539,36 @@ public class CommitLogSegmentManager
         }
 
         for (CommitLogSegment segment : activeSegments)
-            segment.close();
+            closeAndDeleteSegmentUnsafe(segment, deleteSegments);
         activeSegments.clear();
 
         for (CommitLogSegment segment : availableSegments)
-            segment.close();
+            closeAndDeleteSegmentUnsafe(segment, deleteSegments);
         availableSegments.clear();
 
         allocatingFrom = null;
 
+        segmentManagementTasks.clear();
+
         size.set(0L);
 
-        logger.debug("Done with closing and clearing existing commit log segments.");
+        logger.debug("CLSM done with closing and clearing existing commit log segments.");
+    }
+
+    private static void closeAndDeleteSegmentUnsafe(CommitLogSegment segment, boolean delete)
+    {
+        segment.close();
+        if (!delete)
+            return;
+
+        try
+        {
+            segment.delete();
+        }
+        catch (AssertionError ignored)
+        {
+            // segment file does not exit
+        }
     }
 
     /**
@@ -566,7 +577,6 @@ public class CommitLogSegmentManager
     public void startUnsafe()
     {
         start();
-
         wakeManager();
     }
 
diff --git a/test/unit/org/apache/cassandra/SchemaLoader.java b/test/unit/org/apache/cassandra/SchemaLoader.java
index 98cabe25a4..bf1d683164 100644
--- a/test/unit/org/apache/cassandra/SchemaLoader.java
+++ b/test/unit/org/apache/cassandra/SchemaLoader.java
@@ -22,7 +22,6 @@ import java.nio.ByteBuffer;
 import java.util.*;
 
 import org.junit.After;
-import org.junit.AfterClass;
 import org.junit.BeforeClass;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -429,11 +428,12 @@ public class SchemaLoader
 
     public static void cleanupAndLeaveDirs()
     {
-        CommitLog.instance.allocator.stopUnsafe(); // unmap CLS before attempting to delete or Windows complains
+        // We need to stop and unmap all CLS instances prior to cleanup() or we'll get failures on Windows.
+        CommitLog.instance.stopUnsafe(true);
         mkdirs();
         cleanup();
         mkdirs();
-        CommitLog.instance.allocator.startUnsafe(); // cleanup screws w/ CommitLog, this brings it back to safe state
+        CommitLog.instance.startUnsafe();
     }
 
     public static void cleanup()
diff --git a/test/unit/org/apache/cassandra/db/CommitLogTest.java b/test/unit/org/apache/cassandra/db/CommitLogTest.java
index 22f1fba59d..2d6e7fd31c 100644
--- a/test/unit/org/apache/cassandra/db/CommitLogTest.java
+++ b/test/unit/org/apache/cassandra/db/CommitLogTest.java
@@ -138,7 +138,7 @@ public class CommitLogTest
     @Test
     public void testDontDeleteIfDirty() throws Exception
     {
-        CommitLog.instance.resetUnsafe();
+        CommitLog.instance.resetUnsafe(true);
         // Roughly 32 MB mutation
         Mutation rm = new Mutation(KEYSPACE1, bytes("k"));
         rm.add(CF1, Util.cellname("c1"), ByteBuffer.allocate(DatabaseDescriptor.getCommitLogSegmentSize()/4), 0);
@@ -168,7 +168,7 @@ public class CommitLogTest
     public void testDeleteIfNotDirty() throws Exception
     {
         DatabaseDescriptor.getCommitLogSegmentSize();
-        CommitLog.instance.resetUnsafe();
+        CommitLog.instance.resetUnsafe(true);
         // Roughly 32 MB mutation
         Mutation rm = new Mutation(KEYSPACE1, bytes("k"));
         rm.add(CF1, Util.cellname("c1"), ByteBuffer.allocate((DatabaseDescriptor.getCommitLogSegmentSize()/4) - 1), 0);
@@ -226,7 +226,7 @@ public class CommitLogTest
     @Test
     public void testEqualRecordLimit() throws Exception
     {
-        CommitLog.instance.resetUnsafe();
+        CommitLog.instance.resetUnsafe(true);
 
         Mutation rm = new Mutation(KEYSPACE1, bytes("k"));
         rm.add(CF1, Util.cellname("c1"), ByteBuffer.allocate(getMaxRecordDataSize()), 0);
@@ -236,7 +236,7 @@ public class CommitLogTest
     @Test
     public void testExceedRecordLimit() throws Exception
     {
-        CommitLog.instance.resetUnsafe();
+        CommitLog.instance.resetUnsafe(true);
         try
         {
             Mutation rm = new Mutation(KEYSPACE1, bytes("k"));
@@ -345,7 +345,7 @@ public class CommitLogTest
     @Test
     public void testTruncateWithoutSnapshot()
     {
-        CommitLog.instance.resetUnsafe();
+        CommitLog.instance.resetUnsafe(true);
         boolean prev = DatabaseDescriptor.isAutoSnapshot();
         DatabaseDescriptor.setAutoSnapshot(false);
         ColumnFamilyStore cfs1 = Keyspace.open(KEYSPACE1).getColumnFamilyStore("Standard1");
@@ -374,7 +374,7 @@ public class CommitLogTest
     @Test
     public void testTruncateWithoutSnapshotNonDurable()
     {
-        CommitLog.instance.resetUnsafe();
+        CommitLog.instance.resetUnsafe(true);
         boolean prevAutoSnapshot = DatabaseDescriptor.isAutoSnapshot();
         DatabaseDescriptor.setAutoSnapshot(false);
         Keyspace notDurableKs = Keyspace.open(KEYSPACE2);
diff --git a/test/unit/org/apache/cassandra/db/MmapFileTest.java b/test/unit/org/apache/cassandra/db/MmapFileTest.java
new file mode 100644
index 0000000000..0c67ff7a81
--- /dev/null
+++ b/test/unit/org/apache/cassandra/db/MmapFileTest.java
@@ -0,0 +1,163 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.cassandra.db;
+
+import java.io.File;
+import java.io.RandomAccessFile;
+import java.lang.management.ManagementFactory;
+import java.nio.MappedByteBuffer;
+import java.nio.channels.FileChannel;
+import java.nio.file.StandardOpenOption;
+import javax.management.MBeanServer;
+import javax.management.ObjectName;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+import sun.nio.ch.DirectBuffer;
+
+public class MmapFileTest
+{
+    /**
+     * Verifies that {@link sun.misc.Cleaner} works and that mmap'd files can be deleted.
+     */
+    @Test
+    public void testMmapFile() throws Exception
+    {
+        ObjectName bpmName = new ObjectName("java.nio:type=BufferPool,name=mapped");
+
+        MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
+        Long mmapCount = (Long) mbs.getAttribute(bpmName, "Count");
+        Long mmapMemoryUsed = (Long) mbs.getAttribute(bpmName, "MemoryUsed");
+
+        Assert.assertEquals("# of mapped buffers should be 0", Long.valueOf(0L), mmapCount);
+        Assert.assertEquals("amount of mapped memory should be 0", Long.valueOf(0L), mmapMemoryUsed);
+
+        File f1 = File.createTempFile("MmapFileTest1", ".bin");
+        File f2 = File.createTempFile("MmapFileTest2", ".bin");
+        File f3 = File.createTempFile("MmapFileTest2", ".bin");
+
+        try
+        {
+            int size = 1024 * 1024;
+
+            try (RandomAccessFile raf = new RandomAccessFile(f1, "rw"))
+            {
+                raf.setLength(size);
+            }
+
+            try (RandomAccessFile raf = new RandomAccessFile(f2, "rw"))
+            {
+                raf.setLength(size);
+            }
+
+            try (RandomAccessFile raf = new RandomAccessFile(f3, "rw"))
+            {
+                raf.setLength(size);
+            }
+
+            try (FileChannel channel = FileChannel.open(f1.toPath(), StandardOpenOption.WRITE, StandardOpenOption.READ))
+            {
+                MappedByteBuffer buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, size);
+
+                mmapCount = (Long) mbs.getAttribute(bpmName, "Count");
+                mmapMemoryUsed = (Long) mbs.getAttribute(bpmName, "MemoryUsed");
+                Assert.assertEquals("mapped buffers don't work?", Long.valueOf(1L), mmapCount);
+                Assert.assertTrue("mapped buffers don't work?", mmapMemoryUsed >= size);
+
+                Assert.assertTrue(buffer.isDirect());
+
+                buffer.putInt(42);
+                buffer.putInt(42);
+                buffer.putInt(42);
+                buffer.putInt(42);
+                buffer.putInt(42);
+
+                ((DirectBuffer) buffer).cleaner().clean();
+            }
+
+            mmapCount = (Long) mbs.getAttribute(bpmName, "Count");
+            mmapMemoryUsed = (Long) mbs.getAttribute(bpmName, "MemoryUsed");
+            Assert.assertEquals("# of mapped buffers should be 0", Long.valueOf(0L), mmapCount);
+            Assert.assertEquals("amount of mapped memory should be 0", Long.valueOf(0L), mmapMemoryUsed);
+
+            try (FileChannel channel = FileChannel.open(f2.toPath(), StandardOpenOption.WRITE, StandardOpenOption.READ))
+            {
+                MappedByteBuffer buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, size);
+
+                // # of mapped buffers is == 1 here - seems that previous direct buffer for 'f1' is deallocated now
+
+                mmapCount = (Long) mbs.getAttribute(bpmName, "Count");
+                mmapMemoryUsed = (Long) mbs.getAttribute(bpmName, "MemoryUsed");
+                Assert.assertEquals("mapped buffers don't work?", Long.valueOf(1L), mmapCount);
+                Assert.assertTrue("mapped buffers don't work?", mmapMemoryUsed >= size);
+
+                Assert.assertTrue(buffer.isDirect());
+
+                buffer.putInt(42);
+                buffer.putInt(42);
+                buffer.putInt(42);
+                buffer.putInt(42);
+                buffer.putInt(42);
+
+                ((DirectBuffer) buffer).cleaner().clean();
+            }
+
+            mmapCount = (Long) mbs.getAttribute(bpmName, "Count");
+            mmapMemoryUsed = (Long) mbs.getAttribute(bpmName, "MemoryUsed");
+            Assert.assertEquals("# of mapped buffers should be 0", Long.valueOf(0L), mmapCount);
+            Assert.assertEquals("amount of mapped memory should be 0", Long.valueOf(0L), mmapMemoryUsed);
+
+            try (FileChannel channel = FileChannel.open(f3.toPath(), StandardOpenOption.WRITE, StandardOpenOption.READ))
+            {
+                MappedByteBuffer buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, size);
+
+                mmapCount = (Long) mbs.getAttribute(bpmName, "Count");
+                mmapMemoryUsed = (Long) mbs.getAttribute(bpmName, "MemoryUsed");
+                Assert.assertEquals("mapped buffers don't work?", Long.valueOf(1L), mmapCount);
+                Assert.assertTrue("mapped buffers don't work?", mmapMemoryUsed >= size);
+
+                Assert.assertTrue(buffer.isDirect());
+
+                buffer.putInt(42);
+                buffer.putInt(42);
+                buffer.putInt(42);
+                buffer.putInt(42);
+                buffer.putInt(42);
+
+                ((DirectBuffer) buffer).cleaner().clean();
+            }
+
+            mmapCount = (Long) mbs.getAttribute(bpmName, "Count");
+            mmapMemoryUsed = (Long) mbs.getAttribute(bpmName, "MemoryUsed");
+            Assert.assertEquals("# of mapped buffers should be 0", Long.valueOf(0L), mmapCount);
+            Assert.assertEquals("amount of mapped memory should be 0", Long.valueOf(0L), mmapMemoryUsed);
+
+            Assert.assertTrue(f1.delete());
+            Assert.assertTrue(f2.delete());
+            Assert.assertTrue(f3.delete());
+        }
+        finally
+        {
+            Runtime.getRuntime().gc();
+            f1.delete();
+            f2.delete();
+            f3.delete();
+        }
+    }
+}
diff --git a/test/unit/org/apache/cassandra/db/RecoveryManager2Test.java b/test/unit/org/apache/cassandra/db/RecoveryManager2Test.java
index 8023d107f1..772c827427 100644
--- a/test/unit/org/apache/cassandra/db/RecoveryManager2Test.java
+++ b/test/unit/org/apache/cassandra/db/RecoveryManager2Test.java
@@ -82,7 +82,7 @@ public class RecoveryManager2Test
         logger.debug("begin manual replay");
         // replay the commit log (nothing on Standard1 should be replayed since everything was flushed, so only the row on Standard2
         // will be replayed)
-        CommitLog.instance.resetUnsafe();
+        CommitLog.instance.resetUnsafe(false);
         int replayed = CommitLog.instance.recover();
         assert replayed == 1 : "Expecting only 1 replayed mutation, got " + replayed;
     }
diff --git a/test/unit/org/apache/cassandra/db/RecoveryManager3Test.java b/test/unit/org/apache/cassandra/db/RecoveryManager3Test.java
index 13d649d189..75946fd345 100644
--- a/test/unit/org/apache/cassandra/db/RecoveryManager3Test.java
+++ b/test/unit/org/apache/cassandra/db/RecoveryManager3Test.java
@@ -91,7 +91,7 @@ public class RecoveryManager3Test
                 FileUtils.deleteWithConfirm(file);
         }
 
-        CommitLog.instance.resetUnsafe(); // disassociate segments from live CL
+        CommitLog.instance.resetUnsafe(false); // disassociate segments from live CL
         CommitLog.instance.recover();
 
         assertColumns(Util.getColumnFamily(keyspace1, dk, "Standard1"), "col1");
diff --git a/test/unit/org/apache/cassandra/db/RecoveryManagerTest.java b/test/unit/org/apache/cassandra/db/RecoveryManagerTest.java
index 78e82f3abf..9eefaef012 100644
--- a/test/unit/org/apache/cassandra/db/RecoveryManagerTest.java
+++ b/test/unit/org/apache/cassandra/db/RecoveryManagerTest.java
@@ -71,14 +71,14 @@ public class RecoveryManagerTest
     @Test
     public void testNothingToRecover() throws IOException
     {
-        CommitLog.instance.resetUnsafe();
+        CommitLog.instance.resetUnsafe(true);
         CommitLog.instance.recover();
     }
 
     @Test
     public void testOne() throws IOException
     {
-        CommitLog.instance.resetUnsafe();
+        CommitLog.instance.resetUnsafe(true);
         Keyspace keyspace1 = Keyspace.open(KEYSPACE1);
         Keyspace keyspace2 = Keyspace.open(KEYSPACE2);
 
@@ -99,7 +99,7 @@ public class RecoveryManagerTest
         keyspace1.getColumnFamilyStore("Standard1").clearUnsafe();
         keyspace2.getColumnFamilyStore("Standard3").clearUnsafe();
 
-        CommitLog.instance.resetUnsafe(); // disassociate segments from live CL
+        CommitLog.instance.resetUnsafe(false); // disassociate segments from live CL
         CommitLog.instance.recover();
 
         assertColumns(Util.getColumnFamily(keyspace1, dk, "Standard1"), "col1");
@@ -109,7 +109,7 @@ public class RecoveryManagerTest
     @Test
     public void testRecoverCounter() throws IOException
     {
-        CommitLog.instance.resetUnsafe();
+        CommitLog.instance.resetUnsafe(true);
         Keyspace keyspace1 = Keyspace.open(KEYSPACE1);
 
         Mutation rm;
@@ -126,7 +126,7 @@ public class RecoveryManagerTest
 
         keyspace1.getColumnFamilyStore("Counter1").clearUnsafe();
 
-        CommitLog.instance.resetUnsafe(); // disassociate segments from live CL
+        CommitLog.instance.resetUnsafe(false); // disassociate segments from live CL
         CommitLog.instance.recover();
 
         cf = Util.getColumnFamily(keyspace1, dk, "Counter1");
@@ -141,7 +141,7 @@ public class RecoveryManagerTest
     @Test
     public void testRecoverPIT() throws Exception
     {
-        CommitLog.instance.resetUnsafe();
+        CommitLog.instance.resetUnsafe(true);
         Date date = CommitLogArchiver.format.parse("2112:12:12 12:12:12");
         long timeMS = date.getTime() - 5000;
 
@@ -156,7 +156,7 @@ public class RecoveryManagerTest
             rm.apply();
         }
         keyspace1.getColumnFamilyStore("Standard1").clearUnsafe();
-        CommitLog.instance.resetUnsafe(); // disassociate segments from live CL
+        CommitLog.instance.resetUnsafe(false); // disassociate segments from live CL
         CommitLog.instance.recover();
 
         ColumnFamily cf = Util.getColumnFamily(keyspace1, dk, "Standard1");
@@ -167,7 +167,7 @@ public class RecoveryManagerTest
     @Test
     public void testRecoverPITUnordered() throws Exception
     {
-        CommitLog.instance.resetUnsafe();
+        CommitLog.instance.resetUnsafe(true);
         Date date = CommitLogArchiver.format.parse("2112:12:12 12:12:12");
         long timeMS = date.getTime();
 
@@ -193,7 +193,7 @@ public class RecoveryManagerTest
         Assert.assertEquals(10, cf.getColumnCount());
 
         keyspace1.getColumnFamilyStore("Standard1").clearUnsafe();
-        CommitLog.instance.resetUnsafe(); // disassociate segments from live CL
+        CommitLog.instance.resetUnsafe(false); // disassociate segments from live CL
         CommitLog.instance.recover();
 
         cf = Util.getColumnFamily(keyspace1, dk, "Standard1");
diff --git a/test/unit/org/apache/cassandra/db/RecoveryManagerTruncateTest.java b/test/unit/org/apache/cassandra/db/RecoveryManagerTruncateTest.java
index d0f7cff934..32d51d8444 100644
--- a/test/unit/org/apache/cassandra/db/RecoveryManagerTruncateTest.java
+++ b/test/unit/org/apache/cassandra/db/RecoveryManagerTruncateTest.java
@@ -72,7 +72,7 @@ public class RecoveryManagerTruncateTest
 
 		// and now truncate it
 		cfs.truncateBlocking();
-        CommitLog.instance.resetUnsafe();
+        CommitLog.instance.resetUnsafe(false);
 		CommitLog.instance.recover();
 
 		// and validate truncation.
