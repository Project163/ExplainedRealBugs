diff --git a/CHANGES.txt b/CHANGES.txt
index 9945c76602..fb9505bc5e 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 3.0.19
+ * Avoid double closing the iterator to avoid overcounting the number of requests (CASSANDRA-15058)
  * Improve `nodetool status -r` speed (CASSANDRA-14847)
  * Improve merkle tree size and time on heap (CASSANDRA-14096)
  * Add missing commands to nodetool-completion (CASSANDRA-14916)
diff --git a/src/java/org/apache/cassandra/db/partitions/UnfilteredPartitionIterators.java b/src/java/org/apache/cassandra/db/partitions/UnfilteredPartitionIterators.java
index efe3ff86fc..3f7d072992 100644
--- a/src/java/org/apache/cassandra/db/partitions/UnfilteredPartitionIterators.java
+++ b/src/java/org/apache/cassandra/db/partitions/UnfilteredPartitionIterators.java
@@ -233,6 +233,8 @@ public abstract class UnfilteredPartitionIterators
     /**
      * Digests the the provided iterator.
      *
+     * Caller must close the provided iterator.
+     *
      * @param command the command that has yield {@code iterator}. This can be null if {@code version >= MessagingService.VERSION_30}
      * as this is only used when producing digest to be sent to legacy nodes.
      * @param iterator the iterator to digest.
@@ -241,14 +243,11 @@ public abstract class UnfilteredPartitionIterators
      */
     public static void digest(ReadCommand command, UnfilteredPartitionIterator iterator, MessageDigest digest, int version)
     {
-        try (UnfilteredPartitionIterator iter = iterator)
+        while (iterator.hasNext())
         {
-            while (iter.hasNext())
+            try (UnfilteredRowIterator partition = iterator.next())
             {
-                try (UnfilteredRowIterator partition = iter.next())
-                {
-                    UnfilteredRowIterators.digest(command, partition, digest, version);
-                }
+                UnfilteredRowIterators.digest(command, partition, digest, version);
             }
         }
     }
diff --git a/test/distributed/org/apache/cassandra/distributed/test/DistributedReadWritePathTest.java b/test/distributed/org/apache/cassandra/distributed/test/DistributedReadWritePathTest.java
index 3578b2c750..238e9e7efa 100644
--- a/test/distributed/org/apache/cassandra/distributed/test/DistributedReadWritePathTest.java
+++ b/test/distributed/org/apache/cassandra/distributed/test/DistributedReadWritePathTest.java
@@ -22,7 +22,11 @@ import org.junit.Assert;
 import org.junit.Test;
 
 import org.apache.cassandra.db.ConsistencyLevel;
+import org.apache.cassandra.db.Keyspace;
 import org.apache.cassandra.distributed.Cluster;
+import org.apache.cassandra.distributed.impl.IInvokableInstance;
+
+import static org.junit.Assert.assertEquals;
 
 public class DistributedReadWritePathTest extends DistributedTestBase
 {
@@ -267,4 +271,30 @@ public class DistributedReadWritePathTest extends DistributedTestBase
 
         }
     }
+
+    @Test
+    public void metricsCountQueriesTest() throws Throwable
+    {
+        try (Cluster cluster = init(Cluster.create(2)))
+        {
+            cluster.schemaChange("CREATE TABLE " + KEYSPACE + ".tbl (pk int, ck int, v int, PRIMARY KEY (pk, ck))");
+            for (int i = 0; i < 100; i++)
+                cluster.coordinator(1).execute("INSERT INTO "+KEYSPACE+".tbl (pk, ck, v) VALUES (?,?,?)", ConsistencyLevel.ALL, i, i, i);
+
+            long readCount1 = readCount(cluster.get(1));
+            long readCount2 = readCount(cluster.get(2));
+            for (int i = 0; i < 100; i++)
+                cluster.coordinator(1).execute("SELECT * FROM "+KEYSPACE+".tbl WHERE pk = ? and ck = ?", ConsistencyLevel.ALL, i, i);
+
+            readCount1 = readCount(cluster.get(1)) - readCount1;
+            readCount2 = readCount(cluster.get(2)) - readCount2;
+            assertEquals(readCount1, readCount2);
+            assertEquals(100, readCount1);
+        }
+    }
+
+    private long readCount(IInvokableInstance instance)
+    {
+        return instance.callOnInstance(() -> Keyspace.open(KEYSPACE).getColumnFamilyStore("tbl").metric.readLatency.latency.getCount());
+    }
 }
