diff --git a/CHANGES.txt b/CHANGES.txt
index 0530134de9..65ba88f07d 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -4,6 +4,7 @@
  * fix assumption error in CLI when updating/describing keyspace (CASSANDRA-4322)
  * Adds offline sstablescrub to debian packaging (CASSANDRA-4642)
  * Automatic fixing of overlapping leveled sstables (CASSANDRA-4644)
+ * fix error when using ORDER BY with extended selections (CASSANDRA-4689)
 
 
 1.1.5
diff --git a/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java b/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
index a4d64cfccb..4a013b17a5 100644
--- a/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
+++ b/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
@@ -804,7 +804,7 @@ public class SelectStatement implements CQLStatement
             }
         }
 
-        orderResults(cqlRows);
+        orderResults(selection, cqlRows);
 
         // Internal calls always return columns in the comparator order, even when reverse was set
         if (isReversed)
@@ -819,7 +819,7 @@ public class SelectStatement implements CQLStatement
     /**
      * Orders results when multiple keys are selected (using IN)
      */
-    private void orderResults(List<CqlRow> cqlRows)
+    private void orderResults(List<Pair<CFDefinition.Name, Selector>> selection, List<CqlRow> cqlRows)
     {
         // There is nothing to do if
         //   a. there are no results,
@@ -828,12 +828,13 @@ public class SelectStatement implements CQLStatement
         if (cqlRows.isEmpty() || parameters.orderings.isEmpty() || keyRestriction == null || keyRestriction.eqValues.size() < 2)
             return;
 
+
         // optimization when only *one* order condition was given
         // because there is no point of using composite comparator if there is only one order condition
         if (parameters.orderings.size() == 1)
         {
             CFDefinition.Name ordering = cfDef.get(parameters.orderings.keySet().iterator().next());
-            Collections.sort(cqlRows, new SingleColumnComparator(getColumnPositionInSelect(ordering), ordering.type));
+            Collections.sort(cqlRows, new SingleColumnComparator(getColumnPositionInSelect(selection, ordering), ordering.type));
             return;
         }
 
@@ -848,18 +849,18 @@ public class SelectStatement implements CQLStatement
         {
             CFDefinition.Name orderingColumn = cfDef.get(identifier);
             types.add(orderingColumn.type);
-            positions[idx++] = getColumnPositionInSelect(orderingColumn);
+            positions[idx++] = getColumnPositionInSelect(selection, orderingColumn);
         }
 
         Collections.sort(cqlRows, new CompositeComparator(types, positions));
     }
 
     // determine position of column in the select clause
-    private int getColumnPositionInSelect(CFDefinition.Name columnName)
+    private int getColumnPositionInSelect(List<Pair<CFDefinition.Name, Selector>> selection, CFDefinition.Name columnName)
     {
-        for (int i = 0; i < selectedNames.size(); i++)
+        for (int i = 0; i < selection.size(); i++)
         {
-            if (selectedNames.get(i).left.equals(columnName))
+            if (selection.get(i).left.equals(columnName))
                 return i;
         }
 
