diff --git a/CHANGES.txt b/CHANGES.txt
index 5b41c58f71..847dce997a 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 4.1.6
+ * Use OpOrder in repairIterator to ensure we don't lose memtables mid-paxos repair (Cassandra-19668)
  * Refresh stale paxos commit (CASSANDRA-19617)
  * Reduce info logging from automatic paxos repair (CASSANDRA-19445)
  * Support legacy plain_text_auth section in credentials file removed unintentionally (CASSANDRA-19498)
diff --git a/src/java/org/apache/cassandra/service/paxos/uncommitted/PaxosUncommittedIndex.java b/src/java/org/apache/cassandra/service/paxos/uncommitted/PaxosUncommittedIndex.java
index 5e3b5404e8..87a6ff9f81 100644
--- a/src/java/org/apache/cassandra/service/paxos/uncommitted/PaxosUncommittedIndex.java
+++ b/src/java/org/apache/cassandra/service/paxos/uncommitted/PaxosUncommittedIndex.java
@@ -49,6 +49,7 @@ import org.apache.cassandra.schema.IndexMetadata;
 import org.apache.cassandra.schema.Indexes;
 import org.apache.cassandra.schema.TableId;
 import org.apache.cassandra.utils.CloseableIterator;
+import org.apache.cassandra.utils.concurrent.OpOrder;
 
 import static java.util.Collections.*;
 import static org.apache.cassandra.schema.SchemaConstants.SYSTEM_KEYSPACE_NAME;
@@ -135,21 +136,24 @@ public class PaxosUncommittedIndex implements Index, PaxosUncommittedTracker.Upd
     {
         Preconditions.checkNotNull(tableId);
 
-        View view = baseCfs.getTracker().getView();
-        List<Memtable> memtables = view.flushingMemtables.isEmpty()
-                                   ? view.liveMemtables
-                                   : ImmutableList.<Memtable>builder().addAll(view.flushingMemtables).addAll(view.liveMemtables).build();
+        try(OpOrder.Group op = baseCfs.readOrdering.start())
+        {
+            View view = baseCfs.getTracker().getView();
 
-        List<DataRange> dataRanges = ranges.stream().map(DataRange::forTokenRange).collect(Collectors.toList());
-        List<UnfilteredPartitionIterator> iters = new ArrayList<>(memtables.size() * ranges.size());
+            List<Memtable> memtables = view.flushingMemtables.isEmpty()
+                                       ? view.liveMemtables
+                                       : ImmutableList.<Memtable>builder().addAll(view.flushingMemtables).addAll(view.liveMemtables).build();
 
-        for (int j=0, jsize=dataRanges.size(); j<jsize; j++)
-        {
-            for (int i=0, isize=memtables.size(); i<isize; i++)
-                iters.add(memtables.get(i).partitionIterator(memtableColumnFilter, dataRanges.get(j), SSTableReadsListener.NOOP_LISTENER));
-        }
+            List<DataRange> dataRanges = ranges.stream().map(DataRange::forTokenRange).collect(Collectors.toList());
+            List<UnfilteredPartitionIterator> iters = new ArrayList<>(memtables.size() * ranges.size());
 
-        return getPaxosUpdates(iters, tableId, false);
+            for (int j = 0, jsize = dataRanges.size(); j < jsize; j++)
+            {
+                for (int i = 0, isize = memtables.size(); i < isize; i++)
+                    iters.add(memtables.get(i).partitionIterator(memtableColumnFilter, dataRanges.get(j), SSTableReadsListener.NOOP_LISTENER));
+            }
+            return getPaxosUpdates(iters, tableId, false);
+        }
     }
 
     public CloseableIterator<PaxosKeyState> flushIterator(Memtable flushing)
