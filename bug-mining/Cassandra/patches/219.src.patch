diff --git a/src/java/org/apache/cassandra/db/ColumnFamily.java b/src/java/org/apache/cassandra/db/ColumnFamily.java
index 039f67518c..8b45c697b0 100644
--- a/src/java/org/apache/cassandra/db/ColumnFamily.java
+++ b/src/java/org/apache/cassandra/db/ColumnFamily.java
@@ -103,7 +103,7 @@ public final class ColumnFamily implements IColumnContainer
         return (columnSerializer_ instanceof SuperColumnSerializer) ? ((SuperColumnSerializer)columnSerializer_).getComparator() : null;
     }
 
-    ColumnFamily cloneMe()
+    public ColumnFamily cloneMe()
     {
         ColumnFamily cf = cloneMeShallow();
         cf.columns_ = columns_.clone();
@@ -399,6 +399,9 @@ public final class ColumnFamily implements IColumnContainer
 
     public void resolve(ColumnFamily cf)
     {
+        // Row _does_ allow null CF objects :(  seems a necessary evil for efficiency
+        if (cf == null)
+            return;
         delete(cf);
         addAll(cf);
     }
diff --git a/src/java/org/apache/cassandra/db/ColumnFamilySerializer.java b/src/java/org/apache/cassandra/db/ColumnFamilySerializer.java
index 644f611417..065e2275e3 100644
--- a/src/java/org/apache/cassandra/db/ColumnFamilySerializer.java
+++ b/src/java/org/apache/cassandra/db/ColumnFamilySerializer.java
@@ -55,6 +55,12 @@ public class ColumnFamilySerializer implements ICompactSerializer2<ColumnFamily>
     {
         try
         {
+            if (columnFamily == null)
+            {
+                dos.writeUTF(""); // not a legal CF name
+                return;
+            }
+
             dos.writeUTF(columnFamily.name());
             dos.writeUTF(columnFamily.type_);
             dos.writeUTF(columnFamily.getComparatorName());
@@ -95,7 +101,10 @@ public class ColumnFamilySerializer implements ICompactSerializer2<ColumnFamily>
 
     public ColumnFamily deserialize(DataInput dis) throws IOException
     {
-        ColumnFamily cf = deserializeFromSSTableNoColumns(dis.readUTF(), dis.readUTF(), readComparator(dis), readComparator(dis), dis);
+        String cfName = dis.readUTF();
+        if (cfName.isEmpty())
+            return null;
+        ColumnFamily cf = deserializeFromSSTableNoColumns(cfName, dis.readUTF(), readComparator(dis), readComparator(dis), dis);
         deserializeColumns(dis, cf);
         return cf;
     }
diff --git a/src/java/org/apache/cassandra/db/Row.java b/src/java/org/apache/cassandra/db/Row.java
index 2fc4edd17a..3938cfa098 100644
--- a/src/java/org/apache/cassandra/db/Row.java
+++ b/src/java/org/apache/cassandra/db/Row.java
@@ -44,6 +44,8 @@ public class Row
 
     public Row(String key, ColumnFamily cf)
     {
+        assert key != null;
+        // cf may be null, indicating no data
         this.key = key;
         this.cf = cf;
     }
@@ -53,9 +55,19 @@ public class Row
      * what that means is that if there are any differences between the 2 rows then
      * this function will make the current row take the latest changes.
      */
-    public void resolve(Row other)
+    public Row resolve(Row other)
     {
+        if (cf == null)
+            return other;
         cf.resolve(other.cf);
+        return this;
+    }
+
+    public ColumnFamily diff (Row other)
+    {
+        if (cf == null)
+            return other.cf;
+        return cf.diff(other.cf);
     }
 
     public byte[] digest()
@@ -69,7 +81,8 @@ public class Row
         {
             throw new AssertionError(e);
         }
-        cf.updateDigest(digest);
+        if (cf != null)
+            cf.updateDigest(digest);
 
         return digest.digest();
     }
diff --git a/src/java/org/apache/cassandra/service/ConsistencyManager.java b/src/java/org/apache/cassandra/service/ConsistencyManager.java
index 8d51ddddb3..cb96f157d1 100644
--- a/src/java/org/apache/cassandra/service/ConsistencyManager.java
+++ b/src/java/org/apache/cassandra/service/ConsistencyManager.java
@@ -100,7 +100,7 @@ class ConsistencyManager implements Runnable
 		DataRepairHandler(int responseCount, IResponseResolver<Row> readResponseResolver)
 		{
 			readResponseResolver_ = readResponseResolver;
-			majority_ = (responseCount >> 1) + 1;  
+			majority_ = (responseCount / 2) + 1;  
 		}
 		
 		public void response(Message message)
diff --git a/src/java/org/apache/cassandra/service/ReadResponseResolver.java b/src/java/org/apache/cassandra/service/ReadResponseResolver.java
index 8e3286d348..9863d74277 100644
--- a/src/java/org/apache/cassandra/service/ReadResponseResolver.java
+++ b/src/java/org/apache/cassandra/service/ReadResponseResolver.java
@@ -63,8 +63,7 @@ public class ReadResponseResolver implements IResponseResolver<Row>
 	public Row resolve(List<Message> responses) throws DigestMismatchException, IOException
     {
         long startTime = System.currentTimeMillis();
-		Row resolved = null;
-		List<Row> rowList = new ArrayList<Row>();
+		List<Row> rows = new ArrayList<Row>();
 		List<InetAddress> endPoints = new ArrayList<InetAddress>();
 		String key = null;
 		byte[] digest = new byte[0];
@@ -89,7 +88,7 @@ public class ReadResponseResolver implements IResponseResolver<Row>
             }
             else
             {
-                rowList.add(result.row());
+                rows.add(result.row());
                 endPoints.add(response.getFrom());
                 key = result.row().key;
             }
@@ -98,7 +97,7 @@ public class ReadResponseResolver implements IResponseResolver<Row>
 		// If there is a mismatch then throw an exception so that read repair can happen.
         if (isDigestQuery)
         {
-            for (Row row : rowList)
+            for (Row row : rows)
             {
                 if (!Arrays.equals(row.digest(), digest))
                 {
@@ -109,25 +108,14 @@ public class ReadResponseResolver implements IResponseResolver<Row>
             }
         }
 
-        /* If the rowList is empty then we had some exception above. */
-        if (rowList.size() == 0)
-        {
-            return resolved;
-        }
-
-        /* Now calculate the resolved row */
-        resolved = new Row(key, rowList.get(0).cf);
-        for (Row other : rowList.subList(1, rowList.size()))
-        {
-            resolved.resolve(other);
-        }
+        Row resolved = resolveSuperset(rows);
 
         // At this point we have the return row;
         // Now we need to calculate the difference so that we can schedule read repairs
-        for (int i = 0; i < rowList.size(); i++)
+        for (int i = 0; i < rows.size(); i++)
         {
             // since retRow is the resolved row it can be used as the super set
-            ColumnFamily diffCf = rowList.get(i).cf.diff(resolved.cf);
+            ColumnFamily diffCf = rows.get(i).diff(resolved);
             if (diffCf == null) // no repair needs to happen
                 continue;
             // create the row mutation message based on the diff and schedule a read repair
@@ -141,6 +129,27 @@ public class ReadResponseResolver implements IResponseResolver<Row>
 		return resolved;
 	}
 
+    static Row resolveSuperset(List<Row> rows)
+    {
+        assert rows.size() > 0;
+        Row resolved = null;
+        for (Row row : rows)
+        {
+            if (row.cf != null)
+            {
+                resolved = new Row(row.key, row.cf.cloneMe());
+                break;
+            }
+        }
+        if (resolved == null)
+            return rows.get(0);
+        for (Row row : rows)
+        {
+            resolved = resolved.resolve(row);
+        }
+        return resolved;
+    }
+
 	public boolean isDataPresent(List<Message> responses)
 	{
         boolean isDataPresent = false;
diff --git a/src/java/org/apache/cassandra/service/StorageProxy.java b/src/java/org/apache/cassandra/service/StorageProxy.java
index d65cabbb0b..f0f61151ed 100644
--- a/src/java/org/apache/cassandra/service/StorageProxy.java
+++ b/src/java/org/apache/cassandra/service/StorageProxy.java
@@ -608,8 +608,10 @@ public class StorageProxy implements StorageProxyMBean
         Map<String, Collection<IColumn>> results = new TreeMap<String, Collection<IColumn>>();
         for (Row row : allRows)
         {
-            // for now, assume only one cf per row, since that is all we can specify in the Command.
-            results.put(row.key, row.cf.getSortedColumns());
+            if (row.cf == null)
+                results.put(row.key, Collections.<IColumn>emptyList());
+            else
+                results.put(row.key, row.cf.getSortedColumns());
         }
         rangeStats.add(System.currentTimeMillis() - startTime);
         return results;
diff --git a/test/system/test_server.py b/test/system/test_server.py
index 4d50c97523..6a1c85e332 100644
--- a/test/system/test_server.py
+++ b/test/system/test_server.py
@@ -542,6 +542,15 @@ class TestMutations(CassandraTester):
                 client.insert('Keyspace1', key, ColumnPath('Standard1', column=cname), 'v-' + cname, 0, ConsistencyLevel.ONE)
         cp = ColumnParent('Standard1')
 
+        # test empty slice
+        result = client.get_range_slice("Keyspace1", cp, SlicePredicate(column_names=['col1', 'col3']), 'key6', '', 1, ConsistencyLevel.ONE)
+        assert len(result) == 0
+
+        # test empty columns
+        result = client.get_range_slice("Keyspace1", cp, SlicePredicate(column_names=['a']), 'key2', '', 1, ConsistencyLevel.ONE)
+        assert len(result) == 1
+        assert len(result[0].columns) == 0
+
         # test column_names predicate
         result = client.get_range_slice("Keyspace1", cp, SlicePredicate(column_names=['col1', 'col3']), 'key2', 'key4', 5, ConsistencyLevel.ONE)
         assert len(result) == 3
diff --git a/test/unit/org/apache/cassandra/service/ReadResponseResolverTest.java b/test/unit/org/apache/cassandra/service/ReadResponseResolverTest.java
new file mode 100644
index 0000000000..ea9ce5f157
--- /dev/null
+++ b/test/unit/org/apache/cassandra/service/ReadResponseResolverTest.java
@@ -0,0 +1,90 @@
+package org.apache.cassandra.service;
+
+import java.util.Arrays;
+
+import org.junit.Test;
+
+import org.apache.cassandra.db.ColumnFamily;
+import org.apache.cassandra.db.Row;
+import static org.apache.cassandra.db.TableTest.assertColumns;
+import static org.apache.cassandra.Util.column;
+import static junit.framework.Assert.assertNull;
+
+public class ReadResponseResolverTest
+{
+    @Test
+    public void testResolveSupersetNewer()
+    {
+        ColumnFamily cf1 = ColumnFamily.create("Keyspace1", "Standard1");
+        cf1.addColumn(column("c1", "v1", 0));
+        Row row1 = new Row("key1", cf1);
+
+        ColumnFamily cf2 = ColumnFamily.create("Keyspace1", "Standard1");
+        cf2.addColumn(column("c1", "v2", 1));
+        Row row2 = new Row("key1", cf2);
+
+        Row resolved = ReadResponseResolver.resolveSuperset(Arrays.asList(row1, row2));
+        assertColumns(resolved.cf, "c1");
+        assertColumns(row1.diff(resolved), "c1");
+        assertNull(row2.diff(resolved));
+    }
+
+    @Test
+    public void testResolveSupersetDisjoint()
+    {
+        ColumnFamily cf1 = ColumnFamily.create("Keyspace1", "Standard1");
+        cf1.addColumn(column("c1", "v1", 0));
+        Row row1 = new Row("key1", cf1);
+
+        ColumnFamily cf2 = ColumnFamily.create("Keyspace1", "Standard1");
+        cf2.addColumn(column("c2", "v2", 1));
+        Row row2 = new Row("key1", cf2);
+
+        Row resolved = ReadResponseResolver.resolveSuperset(Arrays.asList(row1, row2));
+        assertColumns(resolved.cf, "c1", "c2");
+        assertColumns(row1.diff(resolved), "c2");
+        assertColumns(row2.diff(resolved), "c1");
+    }
+
+    @Test
+    public void testResolveSupersetNullOne()
+    {
+        Row row1 = new Row("key1", null);
+
+        ColumnFamily cf2 = ColumnFamily.create("Keyspace1", "Standard1");
+        cf2.addColumn(column("c2", "v2", 1));
+        Row row2 = new Row("key1", cf2);
+
+        Row resolved = ReadResponseResolver.resolveSuperset(Arrays.asList(row1, row2));
+        assertColumns(resolved.cf, "c2");
+        assertColumns(row1.diff(resolved), "c2");
+        assertNull(row2.diff(resolved));
+    }
+
+    @Test
+    public void testResolveSupersetNullTwo()
+    {
+        ColumnFamily cf1 = ColumnFamily.create("Keyspace1", "Standard1");
+        cf1.addColumn(column("c1", "v1", 0));
+        Row row1 = new Row("key1", cf1);
+
+        Row row2 = new Row("key1", null);
+
+        Row resolved = ReadResponseResolver.resolveSuperset(Arrays.asList(row1, row2));
+        assertColumns(resolved.cf, "c1");
+        assertNull(row1.diff(resolved));
+        assertColumns(row2.diff(resolved), "c1");
+    }
+
+    @Test
+    public void testResolveSupersetNullBoth()
+    {
+        Row row1 = new Row("key1", null);
+        Row row2 = new Row("key1", null);
+
+        Row resolved = ReadResponseResolver.resolveSuperset(Arrays.asList(row1, row2));
+        assertNull(resolved.cf);
+        assertNull(row1.diff(resolved));
+        assertNull(row2.diff(resolved));
+    }
+}
