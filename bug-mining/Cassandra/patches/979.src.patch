diff --git a/interface/cassandra.thrift b/interface/cassandra.thrift
index 04883fca89..a249a2f565 100644
--- a/interface/cassandra.thrift
+++ b/interface/cassandra.thrift
@@ -623,6 +623,13 @@ service Cassandra {
                                4:required i32 keys_per_split)
     throws (1:InvalidRequestException ire),
 
+  /** experimental API for hadoop/parallel query support.
+      may change violently and without warning.
+
+      returns alive endpoints, sorted by proximity, that belong in the same datacenter as the given endpoint */
+  list<string> sort_endpoints_by_proximity(1: string endpoint, 2: required list<string> endpoints, 3: bool restrictToSameDC)
+    throws (1:InvalidRequestException ire),
+
   /** adds a column family. returns the new schema id. */
   string system_add_column_family(1:required CfDef cf_def)
     throws (1:InvalidRequestException ire, 2:SchemaDisagreementException sde),
diff --git a/interface/thrift/gen-java/org/apache/cassandra/thrift/Cassandra.java b/interface/thrift/gen-java/org/apache/cassandra/thrift/Cassandra.java
index 41e387e887..faf379a0a9 100644
--- a/interface/thrift/gen-java/org/apache/cassandra/thrift/Cassandra.java
+++ b/interface/thrift/gen-java/org/apache/cassandra/thrift/Cassandra.java
@@ -255,6 +255,18 @@ public class Cassandra {
      */
     public List<String> describe_splits(String cfName, String start_token, String end_token, int keys_per_split) throws InvalidRequestException, org.apache.thrift.TException;
 
+    /**
+     * experimental API for hadoop/parallel query support.
+     * may change violently and without warning.
+     * 
+     * returns alive endpoints, sorted by proximity, that belong in the same datacenter as the given endpoint
+     * 
+     * @param endpoint
+     * @param endpoints
+     * @param restrictToSameDC
+     */
+    public List<String> sort_endpoints_by_proximity(String endpoint, List<String> endpoints, boolean restrictToSameDC) throws InvalidRequestException, org.apache.thrift.TException;
+
     /**
      * adds a column family. returns the new schema id.
      * 
@@ -358,6 +370,8 @@ public class Cassandra {
 
     public void describe_splits(String cfName, String start_token, String end_token, int keys_per_split, org.apache.thrift.async.AsyncMethodCallback<AsyncClient.describe_splits_call> resultHandler) throws org.apache.thrift.TException;
 
+    public void sort_endpoints_by_proximity(String endpoint, List<String> endpoints, boolean restrictToSameDC, org.apache.thrift.async.AsyncMethodCallback<AsyncClient.sort_endpoints_by_proximity_call> resultHandler) throws org.apache.thrift.TException;
+
     public void system_add_column_family(CfDef cf_def, org.apache.thrift.async.AsyncMethodCallback<AsyncClient.system_add_column_family_call> resultHandler) throws org.apache.thrift.TException;
 
     public void system_drop_column_family(String column_family, org.apache.thrift.async.AsyncMethodCallback<AsyncClient.system_drop_column_family_call> resultHandler) throws org.apache.thrift.TException;
@@ -1424,6 +1438,47 @@ public class Cassandra {
       throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "describe_splits failed: unknown result");
     }
 
+    public List<String> sort_endpoints_by_proximity(String endpoint, List<String> endpoints, boolean restrictToSameDC) throws InvalidRequestException, org.apache.thrift.TException
+    {
+      send_sort_endpoints_by_proximity(endpoint, endpoints, restrictToSameDC);
+      return recv_sort_endpoints_by_proximity();
+    }
+
+    public void send_sort_endpoints_by_proximity(String endpoint, List<String> endpoints, boolean restrictToSameDC) throws org.apache.thrift.TException
+    {
+      oprot_.writeMessageBegin(new org.apache.thrift.protocol.TMessage("sort_endpoints_by_proximity", org.apache.thrift.protocol.TMessageType.CALL, ++seqid_));
+      sort_endpoints_by_proximity_args args = new sort_endpoints_by_proximity_args();
+      args.setEndpoint(endpoint);
+      args.setEndpoints(endpoints);
+      args.setRestrictToSameDC(restrictToSameDC);
+      args.write(oprot_);
+      oprot_.writeMessageEnd();
+      oprot_.getTransport().flush();
+    }
+
+    public List<String> recv_sort_endpoints_by_proximity() throws InvalidRequestException, org.apache.thrift.TException
+    {
+      org.apache.thrift.protocol.TMessage msg = iprot_.readMessageBegin();
+      if (msg.type == org.apache.thrift.protocol.TMessageType.EXCEPTION) {
+        org.apache.thrift.TApplicationException x = org.apache.thrift.TApplicationException.read(iprot_);
+        iprot_.readMessageEnd();
+        throw x;
+      }
+      if (msg.seqid != seqid_) {
+        throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.BAD_SEQUENCE_ID, "sort_endpoints_by_proximity failed: out of sequence response");
+      }
+      sort_endpoints_by_proximity_result result = new sort_endpoints_by_proximity_result();
+      result.read(iprot_);
+      iprot_.readMessageEnd();
+      if (result.isSetSuccess()) {
+        return result.success;
+      }
+      if (result.ire != null) {
+        throw result.ire;
+      }
+      throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "sort_endpoints_by_proximity failed: unknown result");
+    }
+
     public String system_add_column_family(CfDef cf_def) throws InvalidRequestException, SchemaDisagreementException, org.apache.thrift.TException
     {
       send_system_add_column_family(cf_def);
@@ -2598,6 +2653,44 @@ public class Cassandra {
       }
     }
 
+    public void sort_endpoints_by_proximity(String endpoint, List<String> endpoints, boolean restrictToSameDC, org.apache.thrift.async.AsyncMethodCallback<sort_endpoints_by_proximity_call> resultHandler) throws org.apache.thrift.TException {
+      checkReady();
+      sort_endpoints_by_proximity_call method_call = new sort_endpoints_by_proximity_call(endpoint, endpoints, restrictToSameDC, resultHandler, this, protocolFactory, transport);
+      this.currentMethod = method_call;
+      manager.call(method_call);
+    }
+
+    public static class sort_endpoints_by_proximity_call extends org.apache.thrift.async.TAsyncMethodCall {
+      private String endpoint;
+      private List<String> endpoints;
+      private boolean restrictToSameDC;
+      public sort_endpoints_by_proximity_call(String endpoint, List<String> endpoints, boolean restrictToSameDC, org.apache.thrift.async.AsyncMethodCallback<sort_endpoints_by_proximity_call> resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
+        super(client, protocolFactory, transport, resultHandler, false);
+        this.endpoint = endpoint;
+        this.endpoints = endpoints;
+        this.restrictToSameDC = restrictToSameDC;
+      }
+
+      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
+        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("sort_endpoints_by_proximity", org.apache.thrift.protocol.TMessageType.CALL, 0));
+        sort_endpoints_by_proximity_args args = new sort_endpoints_by_proximity_args();
+        args.setEndpoint(endpoint);
+        args.setEndpoints(endpoints);
+        args.setRestrictToSameDC(restrictToSameDC);
+        args.write(prot);
+        prot.writeMessageEnd();
+      }
+
+      public List<String> getResult() throws InvalidRequestException, org.apache.thrift.TException {
+        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
+          throw new IllegalStateException("Method call not finished!");
+        }
+        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
+        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
+        return (new Client(prot)).recv_sort_endpoints_by_proximity();
+      }
+    }
+
     public void system_add_column_family(CfDef cf_def, org.apache.thrift.async.AsyncMethodCallback<system_add_column_family_call> resultHandler) throws org.apache.thrift.TException {
       checkReady();
       system_add_column_family_call method_call = new system_add_column_family_call(cf_def, resultHandler, this, protocolFactory, transport);
@@ -2856,6 +2949,7 @@ public class Cassandra {
       processMap_.put("describe_snitch", new describe_snitch());
       processMap_.put("describe_keyspace", new describe_keyspace());
       processMap_.put("describe_splits", new describe_splits());
+      processMap_.put("sort_endpoints_by_proximity", new sort_endpoints_by_proximity());
       processMap_.put("system_add_column_family", new system_add_column_family());
       processMap_.put("system_drop_column_family", new system_drop_column_family());
       processMap_.put("system_add_keyspace", new system_add_keyspace());
@@ -3811,6 +3905,44 @@ public class Cassandra {
 
     }
 
+    private class sort_endpoints_by_proximity implements ProcessFunction {
+      public void process(int seqid, org.apache.thrift.protocol.TProtocol iprot, org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
+      {
+        sort_endpoints_by_proximity_args args = new sort_endpoints_by_proximity_args();
+        try {
+          args.read(iprot);
+        } catch (org.apache.thrift.protocol.TProtocolException e) {
+          iprot.readMessageEnd();
+          org.apache.thrift.TApplicationException x = new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.PROTOCOL_ERROR, e.getMessage());
+          oprot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("sort_endpoints_by_proximity", org.apache.thrift.protocol.TMessageType.EXCEPTION, seqid));
+          x.write(oprot);
+          oprot.writeMessageEnd();
+          oprot.getTransport().flush();
+          return;
+        }
+        iprot.readMessageEnd();
+        sort_endpoints_by_proximity_result result = new sort_endpoints_by_proximity_result();
+        try {
+          result.success = iface_.sort_endpoints_by_proximity(args.endpoint, args.endpoints, args.restrictToSameDC);
+        } catch (InvalidRequestException ire) {
+          result.ire = ire;
+        } catch (Throwable th) {
+          LOGGER.error("Internal error processing sort_endpoints_by_proximity", th);
+          org.apache.thrift.TApplicationException x = new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, "Internal error processing sort_endpoints_by_proximity");
+          oprot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("sort_endpoints_by_proximity", org.apache.thrift.protocol.TMessageType.EXCEPTION, seqid));
+          x.write(oprot);
+          oprot.writeMessageEnd();
+          oprot.getTransport().flush();
+          return;
+        }
+        oprot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("sort_endpoints_by_proximity", org.apache.thrift.protocol.TMessageType.REPLY, seqid));
+        result.write(oprot);
+        oprot.writeMessageEnd();
+        oprot.getTransport().flush();
+      }
+
+    }
+
     private class system_add_column_family implements ProcessFunction {
       public void process(int seqid, org.apache.thrift.protocol.TProtocol iprot, org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
       {
@@ -25424,6 +25556,938 @@ public class Cassandra {
 
   }
 
+  public static class sort_endpoints_by_proximity_args implements org.apache.thrift.TBase<sort_endpoints_by_proximity_args, sort_endpoints_by_proximity_args._Fields>, java.io.Serializable, Cloneable   {
+    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("sort_endpoints_by_proximity_args");
+
+    private static final org.apache.thrift.protocol.TField ENDPOINT_FIELD_DESC = new org.apache.thrift.protocol.TField("endpoint", org.apache.thrift.protocol.TType.STRING, (short)1);
+    private static final org.apache.thrift.protocol.TField ENDPOINTS_FIELD_DESC = new org.apache.thrift.protocol.TField("endpoints", org.apache.thrift.protocol.TType.LIST, (short)2);
+    private static final org.apache.thrift.protocol.TField RESTRICT_TO_SAME_DC_FIELD_DESC = new org.apache.thrift.protocol.TField("restrictToSameDC", org.apache.thrift.protocol.TType.BOOL, (short)3);
+
+    public String endpoint;
+    public List<String> endpoints;
+    public boolean restrictToSameDC;
+
+    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
+    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
+      ENDPOINT((short)1, "endpoint"),
+      ENDPOINTS((short)2, "endpoints"),
+      RESTRICT_TO_SAME_DC((short)3, "restrictToSameDC");
+
+      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
+
+      static {
+        for (_Fields field : EnumSet.allOf(_Fields.class)) {
+          byName.put(field.getFieldName(), field);
+        }
+      }
+
+      /**
+       * Find the _Fields constant that matches fieldId, or null if its not found.
+       */
+      public static _Fields findByThriftId(int fieldId) {
+        switch(fieldId) {
+          case 1: // ENDPOINT
+            return ENDPOINT;
+          case 2: // ENDPOINTS
+            return ENDPOINTS;
+          case 3: // RESTRICT_TO_SAME_DC
+            return RESTRICT_TO_SAME_DC;
+          default:
+            return null;
+        }
+      }
+
+      /**
+       * Find the _Fields constant that matches fieldId, throwing an exception
+       * if it is not found.
+       */
+      public static _Fields findByThriftIdOrThrow(int fieldId) {
+        _Fields fields = findByThriftId(fieldId);
+        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
+        return fields;
+      }
+
+      /**
+       * Find the _Fields constant that matches name, or null if its not found.
+       */
+      public static _Fields findByName(String name) {
+        return byName.get(name);
+      }
+
+      private final short _thriftId;
+      private final String _fieldName;
+
+      _Fields(short thriftId, String fieldName) {
+        _thriftId = thriftId;
+        _fieldName = fieldName;
+      }
+
+      public short getThriftFieldId() {
+        return _thriftId;
+      }
+
+      public String getFieldName() {
+        return _fieldName;
+      }
+    }
+
+    // isset id assignments
+    private static final int __RESTRICTTOSAMEDC_ISSET_ID = 0;
+    private BitSet __isset_bit_vector = new BitSet(1);
+
+    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
+    static {
+      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
+      tmpMap.put(_Fields.ENDPOINT, new org.apache.thrift.meta_data.FieldMetaData("endpoint", org.apache.thrift.TFieldRequirementType.DEFAULT, 
+          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)));
+      tmpMap.put(_Fields.ENDPOINTS, new org.apache.thrift.meta_data.FieldMetaData("endpoints", org.apache.thrift.TFieldRequirementType.REQUIRED, 
+          new org.apache.thrift.meta_data.ListMetaData(org.apache.thrift.protocol.TType.LIST, 
+              new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING))));
+      tmpMap.put(_Fields.RESTRICT_TO_SAME_DC, new org.apache.thrift.meta_data.FieldMetaData("restrictToSameDC", org.apache.thrift.TFieldRequirementType.DEFAULT, 
+          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.BOOL)));
+      metaDataMap = Collections.unmodifiableMap(tmpMap);
+      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(sort_endpoints_by_proximity_args.class, metaDataMap);
+    }
+
+    public sort_endpoints_by_proximity_args() {
+    }
+
+    public sort_endpoints_by_proximity_args(
+      String endpoint,
+      List<String> endpoints,
+      boolean restrictToSameDC)
+    {
+      this();
+      this.endpoint = endpoint;
+      this.endpoints = endpoints;
+      this.restrictToSameDC = restrictToSameDC;
+      setRestrictToSameDCIsSet(true);
+    }
+
+    /**
+     * Performs a deep copy on <i>other</i>.
+     */
+    public sort_endpoints_by_proximity_args(sort_endpoints_by_proximity_args other) {
+      __isset_bit_vector.clear();
+      __isset_bit_vector.or(other.__isset_bit_vector);
+      if (other.isSetEndpoint()) {
+        this.endpoint = other.endpoint;
+      }
+      if (other.isSetEndpoints()) {
+        List<String> __this__endpoints = new ArrayList<String>();
+        for (String other_element : other.endpoints) {
+          __this__endpoints.add(other_element);
+        }
+        this.endpoints = __this__endpoints;
+      }
+      this.restrictToSameDC = other.restrictToSameDC;
+    }
+
+    public sort_endpoints_by_proximity_args deepCopy() {
+      return new sort_endpoints_by_proximity_args(this);
+    }
+
+    @Override
+    public void clear() {
+      this.endpoint = null;
+      this.endpoints = null;
+      setRestrictToSameDCIsSet(false);
+      this.restrictToSameDC = false;
+    }
+
+    public String getEndpoint() {
+      return this.endpoint;
+    }
+
+    public sort_endpoints_by_proximity_args setEndpoint(String endpoint) {
+      this.endpoint = endpoint;
+      return this;
+    }
+
+    public void unsetEndpoint() {
+      this.endpoint = null;
+    }
+
+    /** Returns true if field endpoint is set (has been assigned a value) and false otherwise */
+    public boolean isSetEndpoint() {
+      return this.endpoint != null;
+    }
+
+    public void setEndpointIsSet(boolean value) {
+      if (!value) {
+        this.endpoint = null;
+      }
+    }
+
+    public int getEndpointsSize() {
+      return (this.endpoints == null) ? 0 : this.endpoints.size();
+    }
+
+    public java.util.Iterator<String> getEndpointsIterator() {
+      return (this.endpoints == null) ? null : this.endpoints.iterator();
+    }
+
+    public void addToEndpoints(String elem) {
+      if (this.endpoints == null) {
+        this.endpoints = new ArrayList<String>();
+      }
+      this.endpoints.add(elem);
+    }
+
+    public List<String> getEndpoints() {
+      return this.endpoints;
+    }
+
+    public sort_endpoints_by_proximity_args setEndpoints(List<String> endpoints) {
+      this.endpoints = endpoints;
+      return this;
+    }
+
+    public void unsetEndpoints() {
+      this.endpoints = null;
+    }
+
+    /** Returns true if field endpoints is set (has been assigned a value) and false otherwise */
+    public boolean isSetEndpoints() {
+      return this.endpoints != null;
+    }
+
+    public void setEndpointsIsSet(boolean value) {
+      if (!value) {
+        this.endpoints = null;
+      }
+    }
+
+    public boolean isRestrictToSameDC() {
+      return this.restrictToSameDC;
+    }
+
+    public sort_endpoints_by_proximity_args setRestrictToSameDC(boolean restrictToSameDC) {
+      this.restrictToSameDC = restrictToSameDC;
+      setRestrictToSameDCIsSet(true);
+      return this;
+    }
+
+    public void unsetRestrictToSameDC() {
+      __isset_bit_vector.clear(__RESTRICTTOSAMEDC_ISSET_ID);
+    }
+
+    /** Returns true if field restrictToSameDC is set (has been assigned a value) and false otherwise */
+    public boolean isSetRestrictToSameDC() {
+      return __isset_bit_vector.get(__RESTRICTTOSAMEDC_ISSET_ID);
+    }
+
+    public void setRestrictToSameDCIsSet(boolean value) {
+      __isset_bit_vector.set(__RESTRICTTOSAMEDC_ISSET_ID, value);
+    }
+
+    public void setFieldValue(_Fields field, Object value) {
+      switch (field) {
+      case ENDPOINT:
+        if (value == null) {
+          unsetEndpoint();
+        } else {
+          setEndpoint((String)value);
+        }
+        break;
+
+      case ENDPOINTS:
+        if (value == null) {
+          unsetEndpoints();
+        } else {
+          setEndpoints((List<String>)value);
+        }
+        break;
+
+      case RESTRICT_TO_SAME_DC:
+        if (value == null) {
+          unsetRestrictToSameDC();
+        } else {
+          setRestrictToSameDC((Boolean)value);
+        }
+        break;
+
+      }
+    }
+
+    public Object getFieldValue(_Fields field) {
+      switch (field) {
+      case ENDPOINT:
+        return getEndpoint();
+
+      case ENDPOINTS:
+        return getEndpoints();
+
+      case RESTRICT_TO_SAME_DC:
+        return new Boolean(isRestrictToSameDC());
+
+      }
+      throw new IllegalStateException();
+    }
+
+    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
+    public boolean isSet(_Fields field) {
+      if (field == null) {
+        throw new IllegalArgumentException();
+      }
+
+      switch (field) {
+      case ENDPOINT:
+        return isSetEndpoint();
+      case ENDPOINTS:
+        return isSetEndpoints();
+      case RESTRICT_TO_SAME_DC:
+        return isSetRestrictToSameDC();
+      }
+      throw new IllegalStateException();
+    }
+
+    @Override
+    public boolean equals(Object that) {
+      if (that == null)
+        return false;
+      if (that instanceof sort_endpoints_by_proximity_args)
+        return this.equals((sort_endpoints_by_proximity_args)that);
+      return false;
+    }
+
+    public boolean equals(sort_endpoints_by_proximity_args that) {
+      if (that == null)
+        return false;
+
+      boolean this_present_endpoint = true && this.isSetEndpoint();
+      boolean that_present_endpoint = true && that.isSetEndpoint();
+      if (this_present_endpoint || that_present_endpoint) {
+        if (!(this_present_endpoint && that_present_endpoint))
+          return false;
+        if (!this.endpoint.equals(that.endpoint))
+          return false;
+      }
+
+      boolean this_present_endpoints = true && this.isSetEndpoints();
+      boolean that_present_endpoints = true && that.isSetEndpoints();
+      if (this_present_endpoints || that_present_endpoints) {
+        if (!(this_present_endpoints && that_present_endpoints))
+          return false;
+        if (!this.endpoints.equals(that.endpoints))
+          return false;
+      }
+
+      boolean this_present_restrictToSameDC = true;
+      boolean that_present_restrictToSameDC = true;
+      if (this_present_restrictToSameDC || that_present_restrictToSameDC) {
+        if (!(this_present_restrictToSameDC && that_present_restrictToSameDC))
+          return false;
+        if (this.restrictToSameDC != that.restrictToSameDC)
+          return false;
+      }
+
+      return true;
+    }
+
+    @Override
+    public int hashCode() {
+      HashCodeBuilder builder = new HashCodeBuilder();
+
+      boolean present_endpoint = true && (isSetEndpoint());
+      builder.append(present_endpoint);
+      if (present_endpoint)
+        builder.append(endpoint);
+
+      boolean present_endpoints = true && (isSetEndpoints());
+      builder.append(present_endpoints);
+      if (present_endpoints)
+        builder.append(endpoints);
+
+      boolean present_restrictToSameDC = true;
+      builder.append(present_restrictToSameDC);
+      if (present_restrictToSameDC)
+        builder.append(restrictToSameDC);
+
+      return builder.toHashCode();
+    }
+
+    public int compareTo(sort_endpoints_by_proximity_args other) {
+      if (!getClass().equals(other.getClass())) {
+        return getClass().getName().compareTo(other.getClass().getName());
+      }
+
+      int lastComparison = 0;
+      sort_endpoints_by_proximity_args typedOther = (sort_endpoints_by_proximity_args)other;
+
+      lastComparison = Boolean.valueOf(isSetEndpoint()).compareTo(typedOther.isSetEndpoint());
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      if (isSetEndpoint()) {
+        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.endpoint, typedOther.endpoint);
+        if (lastComparison != 0) {
+          return lastComparison;
+        }
+      }
+      lastComparison = Boolean.valueOf(isSetEndpoints()).compareTo(typedOther.isSetEndpoints());
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      if (isSetEndpoints()) {
+        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.endpoints, typedOther.endpoints);
+        if (lastComparison != 0) {
+          return lastComparison;
+        }
+      }
+      lastComparison = Boolean.valueOf(isSetRestrictToSameDC()).compareTo(typedOther.isSetRestrictToSameDC());
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      if (isSetRestrictToSameDC()) {
+        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.restrictToSameDC, typedOther.restrictToSameDC);
+        if (lastComparison != 0) {
+          return lastComparison;
+        }
+      }
+      return 0;
+    }
+
+    public _Fields fieldForId(int fieldId) {
+      return _Fields.findByThriftId(fieldId);
+    }
+
+    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
+      org.apache.thrift.protocol.TField field;
+      iprot.readStructBegin();
+      while (true)
+      {
+        field = iprot.readFieldBegin();
+        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
+          break;
+        }
+        switch (field.id) {
+          case 1: // ENDPOINT
+            if (field.type == org.apache.thrift.protocol.TType.STRING) {
+              this.endpoint = iprot.readString();
+            } else { 
+              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
+            }
+            break;
+          case 2: // ENDPOINTS
+            if (field.type == org.apache.thrift.protocol.TType.LIST) {
+              {
+                org.apache.thrift.protocol.TList _list119 = iprot.readListBegin();
+                this.endpoints = new ArrayList<String>(_list119.size);
+                for (int _i120 = 0; _i120 < _list119.size; ++_i120)
+                {
+                  String _elem121;
+                  _elem121 = iprot.readString();
+                  this.endpoints.add(_elem121);
+                }
+                iprot.readListEnd();
+              }
+            } else { 
+              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
+            }
+            break;
+          case 3: // RESTRICT_TO_SAME_DC
+            if (field.type == org.apache.thrift.protocol.TType.BOOL) {
+              this.restrictToSameDC = iprot.readBool();
+              setRestrictToSameDCIsSet(true);
+            } else { 
+              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
+            }
+            break;
+          default:
+            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
+        }
+        iprot.readFieldEnd();
+      }
+      iprot.readStructEnd();
+
+      // check for required fields of primitive type, which can't be checked in the validate method
+      validate();
+    }
+
+    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
+      validate();
+
+      oprot.writeStructBegin(STRUCT_DESC);
+      if (this.endpoint != null) {
+        oprot.writeFieldBegin(ENDPOINT_FIELD_DESC);
+        oprot.writeString(this.endpoint);
+        oprot.writeFieldEnd();
+      }
+      if (this.endpoints != null) {
+        oprot.writeFieldBegin(ENDPOINTS_FIELD_DESC);
+        {
+          oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRING, this.endpoints.size()));
+          for (String _iter122 : this.endpoints)
+          {
+            oprot.writeString(_iter122);
+          }
+          oprot.writeListEnd();
+        }
+        oprot.writeFieldEnd();
+      }
+      oprot.writeFieldBegin(RESTRICT_TO_SAME_DC_FIELD_DESC);
+      oprot.writeBool(this.restrictToSameDC);
+      oprot.writeFieldEnd();
+      oprot.writeFieldStop();
+      oprot.writeStructEnd();
+    }
+
+    @Override
+    public String toString() {
+      StringBuilder sb = new StringBuilder("sort_endpoints_by_proximity_args(");
+      boolean first = true;
+
+      sb.append("endpoint:");
+      if (this.endpoint == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.endpoint);
+      }
+      first = false;
+      if (!first) sb.append(", ");
+      sb.append("endpoints:");
+      if (this.endpoints == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.endpoints);
+      }
+      first = false;
+      if (!first) sb.append(", ");
+      sb.append("restrictToSameDC:");
+      sb.append(this.restrictToSameDC);
+      first = false;
+      sb.append(")");
+      return sb.toString();
+    }
+
+    public void validate() throws org.apache.thrift.TException {
+      // check for required fields
+      if (endpoints == null) {
+        throw new org.apache.thrift.protocol.TProtocolException("Required field 'endpoints' was not present! Struct: " + toString());
+      }
+    }
+
+  }
+
+  public static class sort_endpoints_by_proximity_result implements org.apache.thrift.TBase<sort_endpoints_by_proximity_result, sort_endpoints_by_proximity_result._Fields>, java.io.Serializable, Cloneable   {
+    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("sort_endpoints_by_proximity_result");
+
+    private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.LIST, (short)0);
+    private static final org.apache.thrift.protocol.TField IRE_FIELD_DESC = new org.apache.thrift.protocol.TField("ire", org.apache.thrift.protocol.TType.STRUCT, (short)1);
+
+    public List<String> success;
+    public InvalidRequestException ire;
+
+    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
+    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
+      SUCCESS((short)0, "success"),
+      IRE((short)1, "ire");
+
+      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
+
+      static {
+        for (_Fields field : EnumSet.allOf(_Fields.class)) {
+          byName.put(field.getFieldName(), field);
+        }
+      }
+
+      /**
+       * Find the _Fields constant that matches fieldId, or null if its not found.
+       */
+      public static _Fields findByThriftId(int fieldId) {
+        switch(fieldId) {
+          case 0: // SUCCESS
+            return SUCCESS;
+          case 1: // IRE
+            return IRE;
+          default:
+            return null;
+        }
+      }
+
+      /**
+       * Find the _Fields constant that matches fieldId, throwing an exception
+       * if it is not found.
+       */
+      public static _Fields findByThriftIdOrThrow(int fieldId) {
+        _Fields fields = findByThriftId(fieldId);
+        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
+        return fields;
+      }
+
+      /**
+       * Find the _Fields constant that matches name, or null if its not found.
+       */
+      public static _Fields findByName(String name) {
+        return byName.get(name);
+      }
+
+      private final short _thriftId;
+      private final String _fieldName;
+
+      _Fields(short thriftId, String fieldName) {
+        _thriftId = thriftId;
+        _fieldName = fieldName;
+      }
+
+      public short getThriftFieldId() {
+        return _thriftId;
+      }
+
+      public String getFieldName() {
+        return _fieldName;
+      }
+    }
+
+    // isset id assignments
+
+    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
+    static {
+      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
+      tmpMap.put(_Fields.SUCCESS, new org.apache.thrift.meta_data.FieldMetaData("success", org.apache.thrift.TFieldRequirementType.DEFAULT, 
+          new org.apache.thrift.meta_data.ListMetaData(org.apache.thrift.protocol.TType.LIST, 
+              new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING))));
+      tmpMap.put(_Fields.IRE, new org.apache.thrift.meta_data.FieldMetaData("ire", org.apache.thrift.TFieldRequirementType.DEFAULT, 
+          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
+      metaDataMap = Collections.unmodifiableMap(tmpMap);
+      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(sort_endpoints_by_proximity_result.class, metaDataMap);
+    }
+
+    public sort_endpoints_by_proximity_result() {
+    }
+
+    public sort_endpoints_by_proximity_result(
+      List<String> success,
+      InvalidRequestException ire)
+    {
+      this();
+      this.success = success;
+      this.ire = ire;
+    }
+
+    /**
+     * Performs a deep copy on <i>other</i>.
+     */
+    public sort_endpoints_by_proximity_result(sort_endpoints_by_proximity_result other) {
+      if (other.isSetSuccess()) {
+        List<String> __this__success = new ArrayList<String>();
+        for (String other_element : other.success) {
+          __this__success.add(other_element);
+        }
+        this.success = __this__success;
+      }
+      if (other.isSetIre()) {
+        this.ire = new InvalidRequestException(other.ire);
+      }
+    }
+
+    public sort_endpoints_by_proximity_result deepCopy() {
+      return new sort_endpoints_by_proximity_result(this);
+    }
+
+    @Override
+    public void clear() {
+      this.success = null;
+      this.ire = null;
+    }
+
+    public int getSuccessSize() {
+      return (this.success == null) ? 0 : this.success.size();
+    }
+
+    public java.util.Iterator<String> getSuccessIterator() {
+      return (this.success == null) ? null : this.success.iterator();
+    }
+
+    public void addToSuccess(String elem) {
+      if (this.success == null) {
+        this.success = new ArrayList<String>();
+      }
+      this.success.add(elem);
+    }
+
+    public List<String> getSuccess() {
+      return this.success;
+    }
+
+    public sort_endpoints_by_proximity_result setSuccess(List<String> success) {
+      this.success = success;
+      return this;
+    }
+
+    public void unsetSuccess() {
+      this.success = null;
+    }
+
+    /** Returns true if field success is set (has been assigned a value) and false otherwise */
+    public boolean isSetSuccess() {
+      return this.success != null;
+    }
+
+    public void setSuccessIsSet(boolean value) {
+      if (!value) {
+        this.success = null;
+      }
+    }
+
+    public InvalidRequestException getIre() {
+      return this.ire;
+    }
+
+    public sort_endpoints_by_proximity_result setIre(InvalidRequestException ire) {
+      this.ire = ire;
+      return this;
+    }
+
+    public void unsetIre() {
+      this.ire = null;
+    }
+
+    /** Returns true if field ire is set (has been assigned a value) and false otherwise */
+    public boolean isSetIre() {
+      return this.ire != null;
+    }
+
+    public void setIreIsSet(boolean value) {
+      if (!value) {
+        this.ire = null;
+      }
+    }
+
+    public void setFieldValue(_Fields field, Object value) {
+      switch (field) {
+      case SUCCESS:
+        if (value == null) {
+          unsetSuccess();
+        } else {
+          setSuccess((List<String>)value);
+        }
+        break;
+
+      case IRE:
+        if (value == null) {
+          unsetIre();
+        } else {
+          setIre((InvalidRequestException)value);
+        }
+        break;
+
+      }
+    }
+
+    public Object getFieldValue(_Fields field) {
+      switch (field) {
+      case SUCCESS:
+        return getSuccess();
+
+      case IRE:
+        return getIre();
+
+      }
+      throw new IllegalStateException();
+    }
+
+    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
+    public boolean isSet(_Fields field) {
+      if (field == null) {
+        throw new IllegalArgumentException();
+      }
+
+      switch (field) {
+      case SUCCESS:
+        return isSetSuccess();
+      case IRE:
+        return isSetIre();
+      }
+      throw new IllegalStateException();
+    }
+
+    @Override
+    public boolean equals(Object that) {
+      if (that == null)
+        return false;
+      if (that instanceof sort_endpoints_by_proximity_result)
+        return this.equals((sort_endpoints_by_proximity_result)that);
+      return false;
+    }
+
+    public boolean equals(sort_endpoints_by_proximity_result that) {
+      if (that == null)
+        return false;
+
+      boolean this_present_success = true && this.isSetSuccess();
+      boolean that_present_success = true && that.isSetSuccess();
+      if (this_present_success || that_present_success) {
+        if (!(this_present_success && that_present_success))
+          return false;
+        if (!this.success.equals(that.success))
+          return false;
+      }
+
+      boolean this_present_ire = true && this.isSetIre();
+      boolean that_present_ire = true && that.isSetIre();
+      if (this_present_ire || that_present_ire) {
+        if (!(this_present_ire && that_present_ire))
+          return false;
+        if (!this.ire.equals(that.ire))
+          return false;
+      }
+
+      return true;
+    }
+
+    @Override
+    public int hashCode() {
+      HashCodeBuilder builder = new HashCodeBuilder();
+
+      boolean present_success = true && (isSetSuccess());
+      builder.append(present_success);
+      if (present_success)
+        builder.append(success);
+
+      boolean present_ire = true && (isSetIre());
+      builder.append(present_ire);
+      if (present_ire)
+        builder.append(ire);
+
+      return builder.toHashCode();
+    }
+
+    public int compareTo(sort_endpoints_by_proximity_result other) {
+      if (!getClass().equals(other.getClass())) {
+        return getClass().getName().compareTo(other.getClass().getName());
+      }
+
+      int lastComparison = 0;
+      sort_endpoints_by_proximity_result typedOther = (sort_endpoints_by_proximity_result)other;
+
+      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      if (isSetSuccess()) {
+        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, typedOther.success);
+        if (lastComparison != 0) {
+          return lastComparison;
+        }
+      }
+      lastComparison = Boolean.valueOf(isSetIre()).compareTo(typedOther.isSetIre());
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      if (isSetIre()) {
+        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.ire, typedOther.ire);
+        if (lastComparison != 0) {
+          return lastComparison;
+        }
+      }
+      return 0;
+    }
+
+    public _Fields fieldForId(int fieldId) {
+      return _Fields.findByThriftId(fieldId);
+    }
+
+    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
+      org.apache.thrift.protocol.TField field;
+      iprot.readStructBegin();
+      while (true)
+      {
+        field = iprot.readFieldBegin();
+        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
+          break;
+        }
+        switch (field.id) {
+          case 0: // SUCCESS
+            if (field.type == org.apache.thrift.protocol.TType.LIST) {
+              {
+                org.apache.thrift.protocol.TList _list123 = iprot.readListBegin();
+                this.success = new ArrayList<String>(_list123.size);
+                for (int _i124 = 0; _i124 < _list123.size; ++_i124)
+                {
+                  String _elem125;
+                  _elem125 = iprot.readString();
+                  this.success.add(_elem125);
+                }
+                iprot.readListEnd();
+              }
+            } else { 
+              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
+            }
+            break;
+          case 1: // IRE
+            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
+              this.ire = new InvalidRequestException();
+              this.ire.read(iprot);
+            } else { 
+              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
+            }
+            break;
+          default:
+            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
+        }
+        iprot.readFieldEnd();
+      }
+      iprot.readStructEnd();
+
+      // check for required fields of primitive type, which can't be checked in the validate method
+      validate();
+    }
+
+    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
+      oprot.writeStructBegin(STRUCT_DESC);
+
+      if (this.isSetSuccess()) {
+        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
+        {
+          oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRING, this.success.size()));
+          for (String _iter126 : this.success)
+          {
+            oprot.writeString(_iter126);
+          }
+          oprot.writeListEnd();
+        }
+        oprot.writeFieldEnd();
+      } else if (this.isSetIre()) {
+        oprot.writeFieldBegin(IRE_FIELD_DESC);
+        this.ire.write(oprot);
+        oprot.writeFieldEnd();
+      }
+      oprot.writeFieldStop();
+      oprot.writeStructEnd();
+    }
+
+    @Override
+    public String toString() {
+      StringBuilder sb = new StringBuilder("sort_endpoints_by_proximity_result(");
+      boolean first = true;
+
+      sb.append("success:");
+      if (this.success == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.success);
+      }
+      first = false;
+      if (!first) sb.append(", ");
+      sb.append("ire:");
+      if (this.ire == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.ire);
+      }
+      first = false;
+      sb.append(")");
+      return sb.toString();
+    }
+
+    public void validate() throws org.apache.thrift.TException {
+      // check for required fields
+    }
+
+  }
+
   public static class system_add_column_family_args implements org.apache.thrift.TBase<system_add_column_family_args, system_add_column_family_args._Fields>, java.io.Serializable, Cloneable   {
     private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("system_add_column_family_args");
 
diff --git a/src/java/org/apache/cassandra/hadoop/ColumnFamilyInputFormat.java b/src/java/org/apache/cassandra/hadoop/ColumnFamilyInputFormat.java
index 97b6753dee..5c7af2a3d6 100644
--- a/src/java/org/apache/cassandra/hadoop/ColumnFamilyInputFormat.java
+++ b/src/java/org/apache/cassandra/hadoop/ColumnFamilyInputFormat.java
@@ -197,7 +197,7 @@ public class ColumnFamilyInputFormat extends InputFormat<ByteBuffer, SortedMap<B
         throw new IOException("failed connecting to all endpoints " + StringUtils.join(range.endpoints, ","));
     }
 
-    private static Cassandra.Client createConnection(String host, Integer port, boolean framed) throws IOException
+    static Cassandra.Client createConnection(String host, Integer port, boolean framed) throws IOException
     {
         TSocket socket = new TSocket(host, port);
         TTransport trans = framed ? new TFramedTransport(socket) : socket;
diff --git a/src/java/org/apache/cassandra/hadoop/ColumnFamilyRecordReader.java b/src/java/org/apache/cassandra/hadoop/ColumnFamilyRecordReader.java
index 509446fcc4..783e90380d 100644
--- a/src/java/org/apache/cassandra/hadoop/ColumnFamilyRecordReader.java
+++ b/src/java/org/apache/cassandra/hadoop/ColumnFamilyRecordReader.java
@@ -1,4 +1,5 @@
 package org.apache.cassandra.hadoop;
+
 /*
  * 
  * Licensed to the Apache Software Foundation (ASF) under one
@@ -20,7 +21,6 @@ package org.apache.cassandra.hadoop;
  * 
  */
 
-
 import java.io.IOException;
 import java.net.InetAddress;
 import java.net.UnknownHostException;
@@ -38,6 +38,7 @@ import org.apache.cassandra.dht.IPartitioner;
 import org.apache.cassandra.thrift.*;
 import org.apache.cassandra.utils.FBUtilities;
 import org.apache.cassandra.utils.Pair;
+import org.apache.commons.lang.StringUtils;
 import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.mapreduce.InputSplit;
 import org.apache.hadoop.mapreduce.RecordReader;
@@ -45,22 +46,35 @@ import org.apache.hadoop.mapreduce.TaskAttemptContext;
 import org.apache.thrift.TException;
 import org.apache.thrift.transport.TFramedTransport;
 import org.apache.thrift.transport.TSocket;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 public class ColumnFamilyRecordReader extends RecordReader<ByteBuffer, SortedMap<ByteBuffer, IColumn>>
 {
-    private ColumnFamilySplit split;
-    private RowIterator iter;
+    private static final Logger                              logger = LoggerFactory
+                                                                            .getLogger(ColumnFamilyRecordReader.class);
+    private ColumnFamilySplit                                split;
+    private RowIterator                                      iter;
     private Pair<ByteBuffer, SortedMap<ByteBuffer, IColumn>> currentRow;
-    private SlicePredicate predicate;
-    private int totalRowCount; // total number of rows to fetch
-    private int batchRowCount; // fetch this many per batch
-    private String cfName;
-    private String keyspace;
-    private TSocket socket;
-    private Cassandra.Client client;
-    private ConsistencyLevel consistencyLevel;
-
-    public void close() 
+    private SlicePredicate                                   predicate;
+    private int                                              totalRowCount;                                            // total
+                                                                                                                        // number
+                                                                                                                        // of
+                                                                                                                        // rows
+                                                                                                                        // to
+                                                                                                                        // fetch
+    private int                                              batchRowCount;                                            // fetch
+                                                                                                                        // this
+                                                                                                                        // many
+                                                                                                                        // per
+                                                                                                                        // batch
+    private String                                           cfName;
+    private String                                           keyspace;
+    private TSocket                                          socket;
+    private Cassandra.Client                                 client;
+    private ConsistencyLevel                                 consistencyLevel;
+
+    public void close()
     {
         if (socket != null && socket.isOpen())
         {
@@ -69,7 +83,7 @@ public class ColumnFamilyRecordReader extends RecordReader<ByteBuffer, SortedMap
             client = null;
         }
     }
-    
+
     public ByteBuffer getCurrentKey()
     {
         return currentRow.left;
@@ -79,13 +93,14 @@ public class ColumnFamilyRecordReader extends RecordReader<ByteBuffer, SortedMap
     {
         return currentRow.right;
     }
-    
+
     public float getProgress()
     {
-        // the progress is likely to be reported slightly off the actual but close enough
-        return ((float)iter.rowsRead()) / totalRowCount;
+        // the progress is likely to be reported slightly off the actual but
+        // close enough
+        return ((float) iter.rowsRead()) / totalRowCount;
     }
-    
+
     public void initialize(InputSplit split, TaskAttemptContext context) throws IOException
     {
         this.split = (ColumnFamilySplit) split;
@@ -95,10 +110,9 @@ public class ColumnFamilyRecordReader extends RecordReader<ByteBuffer, SortedMap
         batchRowCount = ConfigHelper.getRangeBatchSize(conf);
         cfName = ConfigHelper.getInputColumnFamily(conf);
         consistencyLevel = ConsistencyLevel.valueOf(ConfigHelper.getReadConsistencyLevel(conf));
-        
-        
+
         keyspace = ConfigHelper.getInputKeyspace(conf);
-        
+
         try
         {
             // only need to connect once
@@ -106,12 +120,31 @@ public class ColumnFamilyRecordReader extends RecordReader<ByteBuffer, SortedMap
                 return;
 
             // create connection using thrift
-            String location = getLocation();
-            socket = new TSocket(location, ConfigHelper.getRpcPort(conf));
-            TBinaryProtocol binaryProtocol = new TBinaryProtocol(new TFramedTransport(socket));
-            client = new Cassandra.Client(binaryProtocol);
-            socket.open();
-
+            List<String> locationsAttempted = new ArrayList<String>();
+            for (Iterator<String> it = getLocations(conf); it.hasNext();)
+            {
+                String location = it.next();
+                try
+                {
+                    socket = new TSocket(location, ConfigHelper.getRpcPort(conf));
+                    TBinaryProtocol binaryProtocol = new TBinaryProtocol(new TFramedTransport(socket));
+                    client = new Cassandra.Client(binaryProtocol);
+                    socket.open();
+                    break;
+                }
+                catch (TException e)
+                {
+                    logger.info("failed to connect to " + location + ':' + ConfigHelper.getRpcPort(conf), e);
+                    locationsAttempted.add(location);
+                    client = null;
+                }
+            }
+            if (null == client)
+            {
+                throw new RuntimeException("For the split " + split + " there were no locations "
+                        + (ConfigHelper.getInputSplitUseOnlySameDCReplica(conf) ? "(from same DC) " : "") + "alive: "
+                        + StringUtils.join(locationsAttempted, ", "));
+            }
             // log in
             client.set_keyspace(keyspace);
             if (ConfigHelper.getInputKeyspaceUserName(conf) != null)
@@ -130,7 +163,7 @@ public class ColumnFamilyRecordReader extends RecordReader<ByteBuffer, SortedMap
 
         iter = new RowIterator();
     }
-    
+
     public boolean nextKeyValue() throws IOException
     {
         if (!iter.hasNext())
@@ -140,46 +173,52 @@ public class ColumnFamilyRecordReader extends RecordReader<ByteBuffer, SortedMap
     }
 
     // we don't use endpointsnitch since we are trying to support hadoop nodes that are
-    // not necessarily on Cassandra machines, too.  This should be adequate for single-DC clusters, at least.
-    private String getLocation()
+    // not necessarily on Cassandra machines, too. This should be adequate for
+    // single-DC clusters, at least.
+    private Iterator<String> getLocations(final Configuration conf) throws IOException
     {
-        InetAddress[] localAddresses;
         try
         {
-            localAddresses = InetAddress.getAllByName(InetAddress.getLocalHost().getHostAddress());
+            for (InetAddress address : InetAddress.getAllByName(InetAddress.getLocalHost().getHostAddress()))
+            {
+                for (final String location : split.getLocations())
+                {
+                    InetAddress locationAddress = getInetAddressByName(location);
+                    if (address.equals(locationAddress))
+                    {
+                        // add fall back replicas from same DC via the following
+                        // Iterator
+                        return new SplitEndpointIterator(location, conf);
+                    }
+                }
+            }
         }
         catch (UnknownHostException e)
         {
             throw new AssertionError(e);
         }
-        for (InetAddress address : localAddresses)
+        
+        return Arrays.asList(split.getLocations()).iterator();
+    }
+
+    private static InetAddress getInetAddressByName(String name)
+    {
+        try
         {
-            for (String location : split.getLocations())
-            {
-                InetAddress locationAddress = null;
-                try
-                {
-                    locationAddress = InetAddress.getByName(location);
-                }
-                catch (UnknownHostException e)
-                {
-                    throw new AssertionError(e);
-                }
-                if (address.equals(locationAddress))
-                {
-                    return location;
-                }
-            }
+            return InetAddress.getByName(name);
+        }
+        catch (UnknownHostException e)
+        {
+            throw new AssertionError(e);
         }
-        return split.getLocations()[0];
     }
 
     private class RowIterator extends AbstractIterator<Pair<ByteBuffer, SortedMap<ByteBuffer, IColumn>>>
     {
-        private List<KeySlice> rows;
-        private String startToken;
-        private int totalRead = 0;
-        private int i = 0;
+        private List<KeySlice>     rows;
+        private String             startToken;
+        private int                totalRead = 0;
+        private int                i         = 0;
         private final AbstractType comparator;
         private final AbstractType subComparator;
         private final IPartitioner partitioner;
@@ -218,43 +257,39 @@ public class ColumnFamilyRecordReader extends RecordReader<ByteBuffer, SortedMap
 
         private void maybeInit()
         {
-            // check if we need another batch 
+            // check if we need another batch
             if (rows != null && i >= rows.size())
                 rows = null;
-            
+
             if (rows != null)
                 return;
 
             if (startToken == null)
             {
                 startToken = split.getStartToken();
-            } 
+            }
             else if (startToken.equals(split.getEndToken()))
             {
                 rows = null;
                 return;
             }
-            
-            KeyRange keyRange = new KeyRange(batchRowCount)
-                                .setStart_token(startToken)
-                                .setEnd_token(split.getEndToken());
+
+            KeyRange keyRange = new KeyRange(batchRowCount).setStart_token(startToken)
+                    .setEnd_token(split.getEndToken());
             try
             {
-                rows = client.get_range_slices(new ColumnParent(cfName),
-                                               predicate,
-                                               keyRange,
-                                               consistencyLevel);
-                  
+                rows = client.get_range_slices(new ColumnParent(cfName), predicate, keyRange, consistencyLevel);
+
                 // nothing new? reached the end
                 if (rows.isEmpty())
                 {
                     rows = null;
                     return;
                 }
-                               
+
                 // reset to iterate through this new batch
                 i = 0;
-                
+
                 // prepare for the next slice to be read
                 KeySlice lastRow = rows.get(rows.size() - 1);
                 ByteBuffer rowkey = lastRow.key;
@@ -279,7 +314,7 @@ public class ColumnFamilyRecordReader extends RecordReader<ByteBuffer, SortedMap
             maybeInit();
             if (rows == null)
                 return endOfData();
-            
+
             totalRead++;
             KeySlice ks = rows.get(i++);
             SortedMap<ByteBuffer, IColumn> map = new TreeMap<ByteBuffer, IColumn>(comparator);
@@ -300,7 +335,8 @@ public class ColumnFamilyRecordReader extends RecordReader<ByteBuffer, SortedMap
 
         private IColumn unthriftifySuper(SuperColumn super_column)
         {
-            org.apache.cassandra.db.SuperColumn sc = new org.apache.cassandra.db.SuperColumn(super_column.name, subComparator);
+            org.apache.cassandra.db.SuperColumn sc = new org.apache.cassandra.db.SuperColumn(super_column.name,
+                    subComparator);
             for (Column column : super_column.columns)
             {
                 sc.addColumn(unthriftifySimple(column));
@@ -313,4 +349,107 @@ public class ColumnFamilyRecordReader extends RecordReader<ByteBuffer, SortedMap
             return new org.apache.cassandra.db.Column(column.name, column.value, column.timestamp);
         }
     }
+
+    private class SplitEndpointIterator extends AbstractIterator<String>
+    {
+        private final boolean       restrictToSameDC;
+        private final String        location;
+        private final Configuration conf;
+        private Cassandra.Client    client;
+        private List<String>        endpoints;
+        private int                 endpointsIdx = -1;
+
+        SplitEndpointIterator(final String location, final Configuration conf)
+        {
+            this.location = location;
+            this.conf = conf;
+            restrictToSameDC = ConfigHelper.getInputSplitUseOnlySameDCReplica(conf);
+        }
+
+        protected String computeNext()
+        {
+            if (-1 == endpointsIdx)
+            {
+                // location is the preference. always return it first.
+                endpointsIdx = 0;
+                return location;
+            }
+            else
+            {
+                if (null == endpoints)
+                {
+                    try
+                    {
+                        for (String nextLocation : split.getLocations())
+                        {
+                            try
+                            {
+                                endpoints = sortEndpointsByProximity(nextLocation, Arrays.asList(split.getLocations()),
+                                        restrictToSameDC);
+                                if (location.equals(endpoints.get(0)))
+                                {
+                                    ++endpointsIdx;
+                                }
+                                break;
+                            }
+                            catch (TException e)
+                            {
+                                logger.info(
+                                        "failed to sortEndpointsByProximity(" + location + ", ["
+                                                + StringUtils.join(split.getLocations(), ',') + "], "
+                                                + restrictToSameDC + ")", e);
+                            }
+                            catch (IOException e)
+                            {
+                                logger.info(
+                                        "failed to sortEndpointsByProximity(" + location + ", ["
+                                                + StringUtils.join(split.getLocations(), ',') + "], "
+                                                + restrictToSameDC + ")", e);
+                            }
+                        }
+                    }
+                    catch (InvalidRequestException e)
+                    {
+                        throw new AssertionError(e);
+                    }
+                    if (null == endpoints)
+                    {
+                        throw new AssertionError("failed to find any fallback replica endpoints from "
+                                + StringUtils.join(split.getLocations(), ','));
+                    }
+                }
+                if (endpoints.size() > endpointsIdx)
+                {
+                    return endpoints.get(endpointsIdx++);
+                }
+            }
+            return endOfData();
+        }
+
+        private List<String> sortEndpointsByProximity(String connectTo, List<String> endpoints, boolean restrictToSameDC)
+                throws InvalidRequestException, TException, IOException
+        {
+            try
+            {
+                // try first our configured initialAddress
+                return getClient(ConfigHelper.getInitialAddress(conf)).sort_endpoints_by_proximity(location, endpoints,
+                        restrictToSameDC);
+            }
+            catch (IOException ex)
+            {
+                // connect through the endpoint. if it fails it's no good
+                // anyway.
+                return getClient(connectTo).sort_endpoints_by_proximity(location, endpoints, restrictToSameDC);
+            }
+        }
+
+        private Cassandra.Client getClient(String host) throws IOException
+        {
+            if (null == client)
+            {
+                client = ColumnFamilyInputFormat.createConnection(host, ConfigHelper.getRpcPort(conf), true);
+            }
+            return client;
+        }
+    }
 }
diff --git a/src/java/org/apache/cassandra/hadoop/ConfigHelper.java b/src/java/org/apache/cassandra/hadoop/ConfigHelper.java
index 0478ac7c12..a9e8a222ac 100644
--- a/src/java/org/apache/cassandra/hadoop/ConfigHelper.java
+++ b/src/java/org/apache/cassandra/hadoop/ConfigHelper.java
@@ -51,6 +51,7 @@ public class ConfigHelper
     private static final String INITIAL_THRIFT_ADDRESS = "cassandra.thrift.address";
     private static final String READ_CONSISTENCY_LEVEL = "cassandra.consistencylevel.read";
     private static final String WRITE_CONSISTENCY_LEVEL = "cassandra.consistencylevel.write";
+    private static final String INPUT_SPLIT_USE_ONLY_SAME_DC_REPLICA = "cassandra.input.split.useOnlySameDCReplica";
 
     /**
      * Set the keyspace and column family for the input of this job.
@@ -143,6 +144,24 @@ public class ConfigHelper
         return conf.getInt(INPUT_SPLIT_SIZE_CONFIG, DEFAULT_SPLIT_SIZE);
     }
 
+    /**
+     * If true only endpoints for a split within the same datacenter
+     * can be used if the localhost endpoint fails.
+     * Set to false if any of the split's replicas can be used.
+     *
+     * @param conf      Job configuration you are about to run
+     * @param inDC
+     */
+    public static void setInputSplitUseOnlySameDCReplica(Configuration conf, boolean inDC)
+    {
+        conf.setBoolean(INPUT_SPLIT_USE_ONLY_SAME_DC_REPLICA, inDC);
+    }
+
+    public static boolean getInputSplitUseOnlySameDCReplica(Configuration conf)
+    {
+        return conf.getBoolean(INPUT_SPLIT_USE_ONLY_SAME_DC_REPLICA, true);
+    }
+
     /**
      * Set the predicate that determines what columns will be selected from each row.
      *
diff --git a/src/java/org/apache/cassandra/thrift/CassandraServer.java b/src/java/org/apache/cassandra/thrift/CassandraServer.java
index 4baf84804d..fd3bc3e785 100644
--- a/src/java/org/apache/cassandra/thrift/CassandraServer.java
+++ b/src/java/org/apache/cassandra/thrift/CassandraServer.java
@@ -33,6 +33,8 @@ import java.util.zip.Inflater;
 
 import com.google.common.base.Predicates;
 import com.google.common.collect.Maps;
+import java.net.InetAddress;
+import java.net.UnknownHostException;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -48,12 +50,15 @@ import org.apache.cassandra.db.marshal.MarshalException;
 import org.apache.cassandra.db.migration.*;
 import org.apache.cassandra.db.context.CounterContext;
 import org.apache.cassandra.dht.*;
+import org.apache.cassandra.gms.FailureDetector;
+import org.apache.cassandra.gms.Gossiper;
 import org.apache.cassandra.locator.*;
 import org.apache.cassandra.scheduler.IRequestScheduler;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.StorageProxy;
 import org.apache.cassandra.service.StorageService;
 import org.apache.cassandra.utils.ByteBufferUtil;
+import org.apache.cassandra.utils.FBUtilities;
 import org.apache.thrift.TException;
 
 public class CassandraServer implements Cassandra.Iface
@@ -746,6 +751,45 @@ public class CassandraServer implements Cassandra.Iface
         return splits;
     }
 
+    public List<String> sort_endpoints_by_proximity(String endpoint, List<String> endpoints, boolean restrictToSameDC)
+            throws TException, InvalidRequestException
+    {
+        try
+        {
+            List<String> results = new ArrayList<String>();
+            InetAddress address = InetAddress.getByName(endpoint);
+            boolean endpointValid = null != Gossiper.instance.getEndpointStateForEndpoint(address);
+            String datacenter = DatabaseDescriptor
+                    .getEndpointSnitch().getDatacenter(endpointValid ? address : FBUtilities.getLocalAddress());
+            List<InetAddress> addresses = new ArrayList<InetAddress>();
+            for(String ep : endpoints)
+            {
+                addresses.add(InetAddress.getByName(ep));
+            }
+            IEndpointSnitch snitch = DatabaseDescriptor.getEndpointSnitch();
+            
+            //Only use the dynamic snitch when endpoint is a cassandra node
+            if (!endpointValid && snitch instanceof DynamicEndpointSnitch)
+                snitch = ((DynamicEndpointSnitch)snitch).subsnitch;
+            
+            snitch.sortByProximity(address, addresses);
+            for(InetAddress ep : addresses)
+            {
+                String dc = DatabaseDescriptor.getEndpointSnitch().getDatacenter(ep);
+                if(FailureDetector.instance.isAlive(ep) && (!restrictToSameDC || datacenter.equals(dc)))
+                {
+                    results.add(ep.getHostName());
+                }
+            }
+                        
+            return results;
+        }
+        catch (UnknownHostException e)
+        {
+            throw new InvalidRequestException(e.getMessage());
+        }
+    }
+
     public void login(AuthenticationRequest auth_request) throws AuthenticationException, AuthorizationException, TException
     {
          state().login(auth_request.getCredentials());
