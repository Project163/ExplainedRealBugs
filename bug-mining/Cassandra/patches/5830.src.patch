diff --git a/CHANGES.txt b/CHANGES.txt
index f79cf303b7..c808128762 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 4.0.2
+ * Delay auth setup until after gossip has settled to avoid unavailables on startup (CASSANDRA-16783)
  * Fix clustering order logic in CREATE MATERIALIZED VIEW (CASSANDRA-16898)
 
 4.0.1
diff --git a/src/java/org/apache/cassandra/service/CassandraDaemon.java b/src/java/org/apache/cassandra/service/CassandraDaemon.java
index 2cb12540c6..4844b8482b 100644
--- a/src/java/org/apache/cassandra/service/CassandraDaemon.java
+++ b/src/java/org/apache/cassandra/service/CassandraDaemon.java
@@ -440,6 +440,8 @@ public class CassandraDaemon
         if (!FBUtilities.getBroadcastAddressAndPort().equals(InetAddressAndPort.getLoopbackAddress()))
             Gossiper.waitToSettle();
 
+        StorageService.instance.doAuthSetup(false);
+
         // re-enable auto-compaction after gossip is settled, so correct disk boundaries are used
         for (Keyspace keyspace : Keyspace.all())
         {
diff --git a/src/java/org/apache/cassandra/service/StorageService.java b/src/java/org/apache/cassandra/service/StorageService.java
index 6c72682dda..9495b8abcd 100644
--- a/src/java/org/apache/cassandra/service/StorageService.java
+++ b/src/java/org/apache/cassandra/service/StorageService.java
@@ -1130,6 +1130,7 @@ public class StorageService extends NotificationBroadcasterSupport implements IE
             try
             {
                 joinTokenRing(0);
+                doAuthSetup(false);
             }
             catch (ConfigurationException e)
             {
@@ -1144,6 +1145,7 @@ public class StorageService extends NotificationBroadcasterSupport implements IE
             {
                 logger.info("Leaving write survey mode and joining ring at operator request");
                 finishJoiningRing(resumedBootstrap, SystemKeyspace.getSavedTokens());
+                doAuthSetup(false);
                 isSurveyMode = false;
                 daemon.start();
             }
@@ -1176,10 +1178,10 @@ public class StorageService extends NotificationBroadcasterSupport implements IE
         setTokens(tokens);
 
         assert tokenMetadata.sortedTokens().size() > 0;
-        doAuthSetup(false);
     }
 
-    private void doAuthSetup(boolean setUpSchema)
+    @VisibleForTesting
+    public void doAuthSetup(boolean setUpSchema)
     {
         if (!authSetupCalled.getAndSet(true))
         {
@@ -1203,6 +1205,13 @@ public class StorageService extends NotificationBroadcasterSupport implements IE
         return authSetupComplete;
     }
 
+    @VisibleForTesting
+    public boolean authSetupCalled()
+    {
+        return authSetupCalled.get();
+    }
+
+
     @VisibleForTesting
     public void setUpDistributedSystemKeyspaces()
     {
@@ -1847,6 +1856,7 @@ public class StorageService extends NotificationBroadcasterSupport implements IE
                             isSurveyMode = false;
                             progressSupport.progress("bootstrap", ProgressEvent.createNotification("Joining ring..."));
                             finishJoiningRing(true, bootstrapTokens);
+                            doAuthSetup(false);
                         }
                         progressSupport.progress("bootstrap", new ProgressEvent(ProgressEventType.COMPLETE, 1, 1, "Resume bootstrap complete"));
                         if (!isNativeTransportRunning())
diff --git a/test/distributed/org/apache/cassandra/distributed/impl/Instance.java b/test/distributed/org/apache/cassandra/distributed/impl/Instance.java
index d772d51758..971a2d4284 100644
--- a/test/distributed/org/apache/cassandra/distributed/impl/Instance.java
+++ b/test/distributed/org/apache/cassandra/distributed/impl/Instance.java
@@ -561,7 +561,8 @@ public class Instance extends IsolatedExecutor implements IInvokableInstance
 
                 SystemKeyspace.finishStartup();
 
-                CassandraDaemon.getInstanceForTesting().setupCompleted();
+                StorageService.instance.doAuthSetup(false);
+                CassandraDaemon.getInstanceForTesting().completeSetup();
 
                 if (config.has(NATIVE_PROTOCOL))
                 {
diff --git a/test/distributed/org/apache/cassandra/distributed/test/AuthTest.java b/test/distributed/org/apache/cassandra/distributed/test/AuthTest.java
new file mode 100644
index 0000000000..4f750809a2
--- /dev/null
+++ b/test/distributed/org/apache/cassandra/distributed/test/AuthTest.java
@@ -0,0 +1,56 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.cassandra.distributed.test;
+
+import java.io.IOException;
+import java.util.concurrent.TimeUnit;
+
+import com.google.common.util.concurrent.Uninterruptibles;
+import org.junit.Test;
+
+import org.apache.cassandra.distributed.Cluster;
+import org.apache.cassandra.service.StorageService;
+
+import static org.junit.Assert.assertTrue;
+
+public class AuthTest extends TestBaseImpl
+{
+
+    /**
+     * Simply tests that initialisation of a test Instance results in
+     * StorageService.instance.doAuthSetup being called as the regular
+     * startup does in CassandraDaemon.setup
+     */
+    @Test
+    public void authSetupIsCalledAfterStartup() throws IOException
+    {
+        try (Cluster cluster = Cluster.build().withNodes(1).start())
+        {
+            boolean setupCalled = cluster.get(1).callOnInstance(() -> {
+                long maxWait = TimeUnit.NANOSECONDS.convert(10, TimeUnit.SECONDS);
+                long start = System.nanoTime();
+                while (!StorageService.instance.authSetupCalled() && System.nanoTime() - start < maxWait)
+                    Uninterruptibles.sleepUninterruptibly(1, TimeUnit.SECONDS);
+
+                return StorageService.instance.authSetupCalled();
+            });
+            assertTrue(setupCalled);
+        }
+    }
+}
diff --git a/test/distributed/org/apache/cassandra/distributed/test/RepairDigestTrackingTest.java b/test/distributed/org/apache/cassandra/distributed/test/RepairDigestTrackingTest.java
index c8fc08868c..a4dacebc9b 100644
--- a/test/distributed/org/apache/cassandra/distributed/test/RepairDigestTrackingTest.java
+++ b/test/distributed/org/apache/cassandra/distributed/test/RepairDigestTrackingTest.java
@@ -28,6 +28,12 @@ import java.util.stream.Stream;
 
 import com.google.common.util.concurrent.Uninterruptibles;
 import org.apache.cassandra.concurrent.SEPExecutor;
+import org.apache.cassandra.dht.Token;
+import org.apache.cassandra.locator.AbstractReplicationStrategy;
+import org.apache.cassandra.locator.EndpointsForToken;
+import org.apache.cassandra.locator.InetAddressAndPort;
+import org.apache.cassandra.locator.ReplicaLayout;
+import org.apache.cassandra.locator.ReplicaUtils;
 import org.apache.cassandra.utils.Throwables;
 import org.junit.Assert;
 import org.junit.Test;
@@ -53,6 +59,7 @@ import org.apache.cassandra.service.StorageProxy.LocalReadRunnable;
 import org.apache.cassandra.utils.DiagnosticSnapshotService;
 
 import static net.bytebuddy.matcher.ElementMatchers.named;
+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;
 import static org.apache.cassandra.distributed.api.Feature.GOSSIP;
 import static org.apache.cassandra.distributed.api.Feature.NETWORK;
 import static org.apache.cassandra.distributed.shared.AssertUtils.assertRows;
@@ -359,6 +366,9 @@ public class RepairDigestTrackingTest extends TestBaseImpl
      * entirely within the scope of single {@link LocalReadRunnable}, but this test still attempts to validate some
      * assumptions about the cleanliness of the logs and the correctness of queries made when initial local reads and
      * local reads triggered by read repair (after speculative reads) execute at roughly the same time.
+     *
+     * This test depends on whether node1 gets a data or a digest request first, we force it to be a digest request
+     * in the forTokenReadLiveSorted ByteBuddy rule below.
      */
     @Test
     public void testLocalDataAndRemoteRequestConcurrency() throws Exception
@@ -397,7 +407,7 @@ public class RepairDigestTrackingTest extends TestBaseImpl
     public static class BBHelper
     {
         private static final CyclicBarrier barrier = new CyclicBarrier(2);
-        
+
         public static void install(ClassLoader classLoader, Integer num)
         {
             // Only install on the coordinating node, which is also a replica...
@@ -414,6 +424,12 @@ public class RepairDigestTrackingTest extends TestBaseImpl
                                .intercept(MethodDelegation.to(BBHelper.class))
                                .make()
                                .load(classLoader, ClassLoadingStrategy.Default.INJECTION);
+
+                new ByteBuddy().rebase(ReplicaLayout.class)
+                               .method(named("forTokenReadLiveSorted").and(takesArguments(AbstractReplicationStrategy.class, Token.class)))
+                               .intercept(MethodDelegation.to(BBHelper.class))
+                               .make()
+                               .load(classLoader, ClassLoadingStrategy.Default.INJECTION);
             }
         }
 
@@ -443,6 +459,23 @@ public class RepairDigestTrackingTest extends TestBaseImpl
                 throw Throwables.unchecked(e);
             }
         }
+
+        @SuppressWarnings({ "unused" })
+        public static ReplicaLayout.ForTokenRead forTokenReadLiveSorted(AbstractReplicationStrategy replicationStrategy, Token token)
+        {
+            try
+            {
+                EndpointsForToken.Builder builder = EndpointsForToken.builder(token, 3);
+                builder.add(ReplicaUtils.full(InetAddressAndPort.getByName("127.0.0.3")));
+                builder.add(ReplicaUtils.full(InetAddressAndPort.getByName("127.0.0.2")));
+                builder.add(ReplicaUtils.full(InetAddressAndPort.getByName("127.0.0.1")));
+                return new ReplicaLayout.ForTokenRead(replicationStrategy, builder.build());
+            }
+            catch (Exception e)
+            {
+                throw Throwables.unchecked(e);
+            }
+        }
     }
 
     private Object[][] rows(Object[][] head, Object[][]...tail)
