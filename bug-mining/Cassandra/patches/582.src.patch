diff --git a/CHANGES.txt b/CHANGES.txt
index 7743e66ce5..7f8c7a64bb 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -5,6 +5,8 @@ dev
    o.a.c.request.Request_responseStage -> RequestResponseStage,
    o.a.c.internal.Internal_responseStage -> InternalResponseStage
  * add AbstractType.fromString (CASSANDRA-1767)
+ * require index_type to be present when specifying index_name
+   on ColumnDef (CASSANDRA-1759)
  * fix add/remove index bugs in CFMetadata (CASSANDRA-1768)
 
 
@@ -23,7 +25,6 @@ dev
  * detect and warn when obsolete version of JNA is present (CASSANDRA-1770)
  * Update windows .bat files to work outside of main Cassandra
    directory (CASSANDRA-1713)
- * log threshold causing memtable flush (CASSANDRA-1675)
  * fix read repair regression from 0.6.7 (CASSANDRA-1727)
  * more-efficient read repair (CASSANDRA-1719)
  * fix hinted handoff replay (CASSANDRA-1656)
diff --git a/conf/cassandra.yaml b/conf/cassandra.yaml
index 75d7a73def..b012981365 100644
--- a/conf/cassandra.yaml
+++ b/conf/cassandra.yaml
@@ -1,9 +1,9 @@
 # Cassandra storage config YAML 
 
-#NOTE !!!!!!!! NOTE 
-# See http://wiki.apache.org/cassandra/StorageConfiguration for
-# full explanations of configuration directives
-#NOTE !!!!!!!! NOTE 
+# NOTE:
+#   See http://wiki.apache.org/cassandra/StorageConfiguration for
+#   full explanations of configuration directives
+# /NOTE
 
 # The name of the cluster. This is mainly used to prevent machines in
 # one logical cluster from joining another.
@@ -73,7 +73,7 @@ commitlog_sync: periodic
 # milliseconds.
 commitlog_sync_period_in_ms: 10000
 
-# Addresses of hosts that are deemed contact points. 
+# Addresses of hosts that are deemed contact points.
 # Cassandra nodes use this list of hosts to find each other and learn
 # the topology of the ring.  You must change this if you are running
 # multiple nodes!
@@ -266,10 +266,15 @@ request_scheduler: org.apache.cassandra.scheduler.NoScheduler
 #  the index is at the cost of space.
 index_interval: 128
 
-# A ColumnFamily is the Cassandra concept closest to a relational table. 
+# Keyspaces have ColumnFamilies.        (Usually 1 KS per application.)
+# ColumnFamilies have Rows.             (Dozens of CFs per KS.)
+# Rows contain Columns.                 (Many per CF.)
+# Columns contain name:value:timestamp. (Many per Row.)
 #
-# Keyspaces are separate groups of ColumnFamilies.  Except in very
-# unusual circumstances you will have one Keyspace per application.
+# A KS is most similar to a schema, and a CF is most similar to a relational table.
+#
+# Keyspaces, ColumnFamilies, and Columns may carry additional
+# metadata that change their behavior. These are as follows:
 #
 # Keyspace required parameters:
 # - name: name of the keyspace; "system" is
@@ -305,10 +310,10 @@ index_interval: 128
 #   different rack in in the first.  Additional datacenters are not
 #   guaranteed to get a replica.  Additional replicas after three are placed
 #   in ring order after the third without regard to rack or datacenter.
-#
 # - replication_factor: Number of replicas of each row
-# - column_families: column families associated with this keyspace
-#
+# Keyspace optional paramaters:
+# - strategy_options: Additional information for the replication strategy.
+# - column_families:
 #     ColumnFamily required parameters:
 #     - name: name of the ColumnFamily.  Must not contain the character "-".
 #     - compare_with: tells Cassandra how to sort the columns for slicing
@@ -340,6 +345,8 @@ index_interval: 128
 #        days). See http://wiki.apache.org/cassandra/DistributedDeletes
 #     - default_validation_class: specifies a validator class to use for
 #        validating all the column values in the CF.
+#     NOTE:
+#     min_ must be less than max_compaction_threshold!
 #     - min_compaction_threshold: the minimum number of SSTables needed
 #        to start a minor compaction.  increasing this will cause minor
 #        compactions to start less frequently and be more intensive. setting
@@ -348,6 +355,7 @@ index_interval: 128
 #        before a minor compaction is forced.  decreasing this will cause
 #        minor compactions to start more frequently and be less intensive.
 #        setting this to 0 disables minor compactions.  defaults to 32.
+#     /NOTE
 #     - row_cache_save_period_in_seconds: number of seconds between saving
 #        row caches.  The row caches can be saved periodically and if one
 #        exists on startup it will be loaded.
@@ -362,10 +370,25 @@ index_interval: 128
 #     - memtable_operations_in_millions: Number of operations in millions
 #        before the memtable is flushed. If undefined, throughput / 64 * 0.3
 #        will be used.
-#
-# NOTE: this keyspace definition is for demonstration purposes only.
-#       Cassandra will not load these definitions during startup. See
-#       http://wiki.apache.org/cassandra/FAQ#no_keyspaces for an explanation.
+#     - column_metadata:
+#         Column required parameters:
+#         - name: binds a validator (and optionally an indexer) to columns 
+#            with this name in any row of the enclosing column family.
+#         - validator: like cf.compare_with, an AbstractType that checks
+#            that the value of the column is well-defined.
+#         Column optional parameters:
+#         NOTE:
+#         index_name cannot be set if index_type is not also set!
+#         - index_name: User-friendly name for the index.
+#         - index_type: The type of index to be created. Currently only
+#            KEYS is supported.
+#         /NOTE
+# 
+# NOTE:
+#   this keyspace definition is for demonstration purposes only.
+#   Cassandra will not load these definitions during startup. See
+#   http://wiki.apache.org/cassandra/FAQ#no_keyspaces for an explanation.
+# /NOTE
 keyspaces:
     - name: Keyspace1
       replica_placement_strategy: org.apache.cassandra.locator.SimpleStrategy
@@ -414,4 +437,5 @@ keyspaces:
           column_metadata:
             - name: birthdate
               validator_class: LongType
+              index_name: birthdate_idx
               index_type: KEYS
diff --git a/src/java/org/apache/cassandra/config/ColumnDefinition.java b/src/java/org/apache/cassandra/config/ColumnDefinition.java
index 9fc8ed24e8..54f5b09ae6 100644
--- a/src/java/org/apache/cassandra/config/ColumnDefinition.java
+++ b/src/java/org/apache/cassandra/config/ColumnDefinition.java
@@ -101,17 +101,19 @@ public class ColumnDefinition {
         }
     }
 
-    public static ColumnDefinition fromColumnDef(ColumnDef cd) throws ConfigurationException
+    public static ColumnDefinition fromColumnDef(ColumnDef thriftColumnDef) throws ConfigurationException
     {
-        return new ColumnDefinition(cd.name, cd.validation_class, cd.index_type, cd.index_name);
+        validateIndexType(thriftColumnDef);
+        return new ColumnDefinition(thriftColumnDef.name, thriftColumnDef.validation_class, thriftColumnDef.index_type, thriftColumnDef.index_name);
     }
     
-    public static ColumnDefinition fromColumnDef(org.apache.cassandra.avro.ColumnDef cd) throws ConfigurationException
+    public static ColumnDefinition fromColumnDef(org.apache.cassandra.avro.ColumnDef avroColumnDef) throws ConfigurationException
     {
-        return new ColumnDefinition(cd.name,
-                cd.validation_class.toString(),
-                IndexType.valueOf(cd.index_type == null ? org.apache.cassandra.avro.CassandraServer.D_COLDEF_INDEXTYPE : cd.index_type.name()),
-                cd.index_name == null ? org.apache.cassandra.avro.CassandraServer.D_COLDEF_INDEXNAME : cd.index_name.toString());
+        validateIndexType(avroColumnDef);
+        return new ColumnDefinition(avroColumnDef.name,
+                avroColumnDef.validation_class.toString(),
+                IndexType.valueOf(avroColumnDef.index_type == null ? org.apache.cassandra.avro.CassandraServer.D_COLDEF_INDEXTYPE : avroColumnDef.index_type.name()),
+                avroColumnDef.index_name == null ? org.apache.cassandra.avro.CassandraServer.D_COLDEF_INDEXNAME : avroColumnDef.index_name.toString());
     }
 
     public static Map<ByteBuffer, ColumnDefinition> fromColumnDef(List<ColumnDef> thriftDefs) throws ConfigurationException
@@ -122,6 +124,7 @@ public class ColumnDefinition {
         Map<ByteBuffer, ColumnDefinition> cds = new TreeMap<ByteBuffer, ColumnDefinition>();
         for (ColumnDef thriftColumnDef : thriftDefs)
         {
+            validateIndexType(thriftColumnDef);
             cds.put(thriftColumnDef.name, fromColumnDef(thriftColumnDef));
         }
 
@@ -136,12 +139,25 @@ public class ColumnDefinition {
         Map<ByteBuffer, ColumnDefinition> cds = new TreeMap<ByteBuffer, ColumnDefinition>();
         for (org.apache.cassandra.avro.ColumnDef avroColumnDef : avroDefs)
         {
+            validateIndexType(avroColumnDef);
             cds.put(avroColumnDef.name, fromColumnDef(avroColumnDef));
         }
 
         return Collections.unmodifiableMap(cds);
     }
 
+    public static void validateIndexType(org.apache.cassandra.thrift.ColumnDef thriftColumnDef) throws ConfigurationException
+    {
+        if ((thriftColumnDef.index_name != null) && (thriftColumnDef.index_type == null))
+            throw new ConfigurationException("index_name cannot be set if index_type is not also set");
+    }
+
+    public static void validateIndexType(org.apache.cassandra.avro.ColumnDef avroColumnDef) throws ConfigurationException
+    {
+        if ((avroColumnDef.index_name != null) && (avroColumnDef.index_type == null))
+            throw new ConfigurationException("index_name cannot be set if index_type is not also set");
+    }
+
     @Override
     public String toString()
     {
diff --git a/src/java/org/apache/cassandra/config/DatabaseDescriptor.java b/src/java/org/apache/cassandra/config/DatabaseDescriptor.java
index c61af34da3..0cae7d73e9 100644
--- a/src/java/org/apache/cassandra/config/DatabaseDescriptor.java
+++ b/src/java/org/apache/cassandra/config/DatabaseDescriptor.java
@@ -585,6 +585,20 @@ public class    DatabaseDescriptor
 
                 for (RawColumnDefinition rcd : cf.column_metadata)
                 {
+                    if (rcd.name == null)
+                    {
+                        throw new ConfigurationException("name is required for column definitions.");
+                    }
+                    if (rcd.validator_class == null)
+                    {
+                        throw new ConfigurationException("validator is required for column definitions");
+                    }
+                    
+                    if ((rcd.index_type == null) && (rcd.index_name != null))
+                    {
+                        throw new ConfigurationException("index_name cannot be set if index_type is not also set");
+                    }
+
                     ByteBuffer columnName = ByteBuffer.wrap(rcd.name.getBytes(Charsets.UTF_8));
                     metadata.put(columnName, new ColumnDefinition(columnName, rcd.validator_class, rcd.index_type, rcd.index_name));
                 }
