diff --git a/src/java/org/apache/cassandra/service/StorageLoadBalancer.java b/src/java/org/apache/cassandra/service/StorageLoadBalancer.java
index 4e45a371ee..a81b890101 100644
--- a/src/java/org/apache/cassandra/service/StorageLoadBalancer.java
+++ b/src/java/org/apache/cassandra/service/StorageLoadBalancer.java
@@ -338,6 +338,11 @@ final class StorageLoadBalancer implements IEndPointStateChangeSubscriber
         }
         return null;
     }
+
+    public Map<EndPoint, Double> getLoadInfo()
+    {
+        return loadInfo_;
+    }
 }
 
 class MoveMessage implements Serializable
diff --git a/src/java/org/apache/cassandra/service/StorageService.java b/src/java/org/apache/cassandra/service/StorageService.java
index f40efad923..7a7c1cd052 100644
--- a/src/java/org/apache/cassandra/service/StorageService.java
+++ b/src/java/org/apache/cassandra/service/StorageService.java
@@ -379,16 +379,13 @@ public final class StorageService implements IEndPointStateChangeSubscriber, Sto
     */
     public Map<Range, List<EndPoint>> constructRangeToEndPointMap(Range[] ranges)
     {
-        if (logger_.isDebugEnabled())
-          logger_.debug("Constructing range to endpoint map ...");
         Map<Range, List<EndPoint>> rangeToEndPointMap = new HashMap<Range, List<EndPoint>>();
-        for ( Range range : ranges )
+        for (Range range : ranges)
         {
             EndPoint[] endpoints = nodePicker_.getReadStorageEndPoints(range.right());
-            rangeToEndPointMap.put(range, new ArrayList<EndPoint>( Arrays.asList(endpoints) ) );
+            // create a new ArrayList since a bunch of methods like to mutate the endpointmap List
+            rangeToEndPointMap.put(range, new ArrayList<EndPoint>(Arrays.asList(endpoints)));
         }
-        if (logger_.isDebugEnabled())
-          logger_.debug("Done constructing range to endpoint map ...");
         return rangeToEndPointMap;
     }
     
@@ -514,6 +511,22 @@ public final class StorageService implements IEndPointStateChangeSubscriber, Sto
         return FileUtils.stringifyFileSize(FileUtils.getUsedDiskSpace());
     }
 
+    public Map<String, String> getLoadMap()
+    {
+        Map<String, String> map = new HashMap<String, String>();
+        for (Map.Entry<EndPoint,Double> entry : storageLoadBalancer_.getLoadInfo().entrySet())
+        {
+            map.put(entry.getKey().getHost(), FileUtils.stringifyFileSize(entry.getValue()));
+        }
+        // gossiper doesn't bother sending to itself, so if there are no other nodes around
+        // we need to cheat to get load information for the local node
+        if (!map.containsKey(getLocalControlEndPoint().getHost()))
+        {
+            map.put(getLocalControlEndPoint().getHost(), getLoadString());
+        }
+        return map;
+    }
+
     /*
      * This method updates the token on disk and modifies the cached
      * StorageMetadata instance. This is only for the local endpoint.
diff --git a/src/java/org/apache/cassandra/service/StorageServiceMBean.java b/src/java/org/apache/cassandra/service/StorageServiceMBean.java
index e745a1f897..c8044e7e94 100644
--- a/src/java/org/apache/cassandra/service/StorageServiceMBean.java
+++ b/src/java/org/apache/cassandra/service/StorageServiceMBean.java
@@ -64,6 +64,9 @@ public interface StorageServiceMBean
     /** Human-readable load value */
     public String getLoadString();
 
+    /** Human-readable load value.  Keys are IP addresses. */
+    public Map<String, String> getLoadMap();
+
     /**
      * Return the generation value for this node.
      *
diff --git a/src/java/org/apache/cassandra/tools/NodeProbe.java b/src/java/org/apache/cassandra/tools/NodeProbe.java
index 0078204459..83fcd67f8b 100644
--- a/src/java/org/apache/cassandra/tools/NodeProbe.java
+++ b/src/java/org/apache/cassandra/tools/NodeProbe.java
@@ -205,17 +205,19 @@ public class NodeProbe
         Collections.sort(ranges);
         Set<String> liveNodes = ssProxy.getLiveNodes();
         Set<String> deadNodes = ssProxy.getUnreachableNodes();
+        Map<String, String> loadMap = ssProxy.getLoadMap();
 
         // Print range-to-endpoint mapping
         int counter = 0;
         outs.print(String.format("%-14s", "Address"));
         outs.print(String.format("%-11s", "Status"));
+        outs.print(String.format("%-14s", "Load"));
         outs.print(String.format("%-43s", "Range"));
         outs.println("Ring");
         // emphasize that we're showing the right part of each range
         if (ranges.size() > 1)
         {
-            outs.println(String.format("%-14s%-11s%-43s", "", "", ranges.get(0).left()));
+            outs.println(String.format("%-14s%-11s%-14s%-43s", "", "", "", ranges.get(0).left()));
         }
         // normal range & node info
         for (Range range : ranges) {
@@ -223,12 +225,17 @@ public class NodeProbe
             String primaryEndpoint = endpoints.get(0);
 
             outs.print(String.format("%-14s", primaryEndpoint));
+
             String status = liveNodes.contains(primaryEndpoint)
-                            ? "Up"
-                            : deadNodes.contains(primaryEndpoint)
-                              ? "Down"
-                              : "?";
+                          ? "Up"
+                          : deadNodes.contains(primaryEndpoint)
+                            ? "Down"
+                            : "?";
             outs.print(String.format("%-11s", status));
+
+            String load = loadMap.containsKey(primaryEndpoint) ? loadMap.get(primaryEndpoint) : "?";
+            outs.print(String.format("%-14s", load));
+
             outs.print(String.format("%-43s", range.right()));
 
             String asciiRingArt;
