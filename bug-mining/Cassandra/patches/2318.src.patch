diff --git a/CHANGES.txt b/CHANGES.txt
index b910f14ea4..0cb223fb74 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -4,6 +4,7 @@
  * Fix dateOf() function for pre-2.0 timestamp columns (CASSANDRA-5928)
  * Fix SSTable unintentionally loads BF when opened for batch (CASSANDRA-5938)
  * Add stream session progress to JMX (CASSANDRA-4757)
+ * Fix NPE during CAS operation (CASSANDRA-5925)
 Merged from 1.2:
  * Fix getBloomFilterDiskSpaceUsed for AlwaysPresentFilter (CASSANDRA-5900)
  * Don't announce schema version until we've loaded the changes locally
diff --git a/src/java/org/apache/cassandra/cql3/statements/ModificationStatement.java b/src/java/org/apache/cassandra/cql3/statements/ModificationStatement.java
index e9141f936e..93c4438d01 100644
--- a/src/java/org/apache/cassandra/cql3/statements/ModificationStatement.java
+++ b/src/java/org/apache/cassandra/cql3/statements/ModificationStatement.java
@@ -108,6 +108,8 @@ public abstract class ModificationStatement implements CQLStatement
 
     public void validate(ClientState state) throws InvalidRequestException
     {
+        if (hasConditions() && attrs.isTimestampSet())
+            throw new InvalidRequestException("Custom timestamps are not allowed when conditions are used");
     }
 
     public void addOperation(Operation op)
@@ -370,13 +372,17 @@ public abstract class ModificationStatement implements CQLStatement
             throw new InvalidRequestException("IN on the partition key is not supported with conditional updates");
 
         ColumnNameBuilder clusteringPrefix = createClusteringPrefixBuilder(variables);
-        UpdateParameters params = new UpdateParameters(cfm, variables, getTimestamp(queryState.getTimestamp(), variables), getTimeToLive(variables), null);
 
         ByteBuffer key = keys.get(0);
         ThriftValidation.validateKey(cfm, key);
 
-        ColumnFamily updates = updateForKey(key, clusteringPrefix, params);
-        ColumnFamily expected = buildConditions(key, clusteringPrefix, params);
+        UpdateParameters updParams = new UpdateParameters(cfm, variables, queryState.getTimestamp(), getTimeToLive(variables), null);
+        ColumnFamily updates = updateForKey(key, clusteringPrefix, updParams);
+
+        // When building the conditions, we should not use the TTL. It's not useful, and if a very low ttl (1 seconds) is used, it's possible
+        // for it to expire before actually build the conditions which would break since we would then test for the presence of tombstones.
+        UpdateParameters condParams = new UpdateParameters(cfm, variables, queryState.getTimestamp(), 0, null);
+        ColumnFamily expected = buildConditions(key, clusteringPrefix, condParams);
 
         ColumnFamily result = StorageProxy.cas(keyspace(),
                                                columnFamily(),
diff --git a/src/java/org/apache/cassandra/db/SystemKeyspace.java b/src/java/org/apache/cassandra/db/SystemKeyspace.java
index dba3421c9b..5dd505f67c 100644
--- a/src/java/org/apache/cassandra/db/SystemKeyspace.java
+++ b/src/java/org/apache/cassandra/db/SystemKeyspace.java
@@ -806,10 +806,11 @@ public class SystemKeyspace
 
     public static void savePaxosProposal(Commit commit)
     {
-        processInternal(String.format("UPDATE %s USING TIMESTAMP %d AND TTL %d SET proposal = 0x%s WHERE row_key = 0x%s AND cf_id = %s",
+        processInternal(String.format("UPDATE %s USING TIMESTAMP %d AND TTL %d SET in_progress_ballot = %s, proposal = 0x%s WHERE row_key = 0x%s AND cf_id = %s",
                                       PAXOS_CF,
                                       UUIDGen.microsTimestamp(commit.ballot),
                                       paxosTtl(commit.update.metadata),
+                                      commit.ballot,
                                       ByteBufferUtil.bytesToHex(commit.update.toBytes()),
                                       ByteBufferUtil.bytesToHex(commit.key),
                                       commit.update.id()));
