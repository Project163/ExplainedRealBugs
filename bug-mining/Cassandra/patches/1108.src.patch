diff --git a/CHANGES.txt b/CHANGES.txt
index 983280cbe3..9c045d488a 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -44,7 +44,7 @@
    Thrift<->Avro conversion methods (CASSANDRA-3032)
  * Add timeouts to client request schedulers (CASSANDRA-3079, 3096)
  * Cli to use hashes rather than array of hashes for strategy options (CASSANDRA-3081)
- * LeveledCompactionStrategy (CASSANDRA-1608, 3085, 3110, 3087)
+ * LeveledCompactionStrategy (CASSANDRA-1608, 3085, 3110, 3087, 3145)
  * Improvements of the CLI `describe` command (CASSANDRA-2630)
  * reduce window where dropped CF sstables may not be deleted (CASSANDRA-2942)
  * Expose gossip/FD info to JMX (CASSANDRA-2806)
@@ -65,6 +65,7 @@
  * use TreeMap backed column families for the SSTable simple writers
    (CASSANDRA-3148)
 
+
 0.8.5
  * fix NPE when encryption_options is unspecified (CASSANDRA-3007)
  * include column name in validation failure exceptions (CASSANDRA-2849)
diff --git a/src/java/org/apache/cassandra/db/ColumnFamilyStore.java b/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
index 0114fb35f2..d9d805f541 100644
--- a/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
+++ b/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
@@ -1303,7 +1303,7 @@ public class ColumnFamilyStore implements ColumnFamilyStoreMBean
             view = data.getView();
             // startAt == minimum is ok, but stopAt == minimum is confusing because all IntervalTree deals with
             // is Comparable, so it won't know to special-case that.
-            Comparable stopInTree = stopAt.isEmpty() ? view.intervalTree.max : stopAt;
+            Comparable stopInTree = stopAt.isEmpty() ? view.intervalTree.max() : stopAt;
             sstables = view.intervalTree.search(new Interval(startWith, stopInTree));
             if (SSTableReader.acquireReferences(sstables))
                 break;
diff --git a/src/java/org/apache/cassandra/db/DataTracker.java b/src/java/org/apache/cassandra/db/DataTracker.java
index fcfcff0f23..d30c183e89 100644
--- a/src/java/org/apache/cassandra/db/DataTracker.java
+++ b/src/java/org/apache/cassandra/db/DataTracker.java
@@ -516,11 +516,9 @@ public class DataTracker
 
         private IntervalTree buildIntervalTree(List<SSTableReader> sstables)
         {
-            List<SSTableReader> itsstList = ImmutableList.copyOf(Ordering.from(SSTable.sstableComparator).sortedCopy(sstables));
-            List<Interval> intervals = new ArrayList<Interval>(itsstList.size());
-            for (SSTableReader sstable : itsstList)
+            List<Interval> intervals = new ArrayList<Interval>(sstables.size());
+            for (SSTableReader sstable : sstables)
                 intervals.add(new Interval<SSTableReader>(sstable.first, sstable.last, sstable));
-            assert intervals.size() == sstables.size();
             return new IntervalTree<SSTableReader>(intervals);
         }
 
diff --git a/src/java/org/apache/cassandra/utils/IntervalTree/IntervalNode.java b/src/java/org/apache/cassandra/utils/IntervalTree/IntervalNode.java
index ebb07922fd..2482d28ecb 100644
--- a/src/java/org/apache/cassandra/utils/IntervalTree/IntervalNode.java
+++ b/src/java/org/apache/cassandra/utils/IntervalTree/IntervalNode.java
@@ -1,13 +1,16 @@
 package org.apache.cassandra.utils.IntervalTree;
 
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
-import java.util.concurrent.ConcurrentSkipListSet;
+import com.google.common.collect.ImmutableList;
 
 public class IntervalNode
 {
     Interval interval;
     Comparable v_pt;
+    Comparable v_min;
+    Comparable v_max;
     List<Interval> v_left;
     List<Interval> v_right;
     IntervalNode left = null;
@@ -17,7 +20,7 @@ public class IntervalNode
     {
         if (toBisect.size() > 0)
         {
-            v_pt = findMedianEndpoint(toBisect);
+            findMinMedianMax(toBisect);
             v_left = interval.minOrdering.sortedCopy(getIntersectingIntervals(toBisect));
             v_right = interval.maxOrdering.reverse().sortedCopy(getIntersectingIntervals(toBisect));
             //if i.min < v_pt then it goes to the left subtree
@@ -64,22 +67,22 @@ public class IntervalNode
         return retval;
     }
 
-    public Comparable findMedianEndpoint(List<Interval> intervals)
+    public void findMinMedianMax(List<Interval> intervals)
     {
-
-        ConcurrentSkipListSet<Comparable> sortedSet = new ConcurrentSkipListSet<Comparable>();
-
-        for (Interval interval : intervals)
+        if (intervals.size() > 0)
         {
-            sortedSet.add(interval.min);
-            sortedSet.add(interval.max);
-        }
-        int medianIndex = sortedSet.size() / 2;
-        if (sortedSet.size() > 0)
-        {
-            return (Comparable) sortedSet.toArray()[medianIndex];
+            List<Comparable> allEndpoints = new ArrayList<Comparable>(intervals.size() * 2);
+
+            for (Interval interval : intervals)
+            {
+                allEndpoints.add(interval.min);
+                allEndpoints.add(interval.max);
+            }
+            Collections.sort(allEndpoints);
+            v_pt = allEndpoints.get(intervals.size());
+            v_min = allEndpoints.get(0);
+            v_max = allEndpoints.get(allEndpoints.size() - 1);
         }
-        return null;
     }
 
 }
diff --git a/src/java/org/apache/cassandra/utils/IntervalTree/IntervalTree.java b/src/java/org/apache/cassandra/utils/IntervalTree/IntervalTree.java
index 323a980d29..1ecfef0ad0 100644
--- a/src/java/org/apache/cassandra/utils/IntervalTree/IntervalTree.java
+++ b/src/java/org/apache/cassandra/utils/IntervalTree/IntervalTree.java
@@ -8,9 +8,6 @@ public class IntervalTree<T>
 {
     private final IntervalNode head;
 
-    public Comparable max = null;
-    public Comparable min = null;
-
     public IntervalTree()
     {
         head = null;
@@ -18,14 +15,19 @@ public class IntervalTree<T>
 
     public IntervalTree(List<Interval> intervals)
     {
-        if (intervals.size() > 0)
-        {
-            min = intervals.get(0).min;
-            max = intervals.get(intervals.size() - 1).max;
-        }
         head = new IntervalNode(intervals);
     }
 
+    public Comparable max()
+    {
+        return head.v_max;
+    }
+
+    public Comparable min()
+    {
+        return head.v_min;
+    }
+
     public List<T> search(Interval searchInterval)
     {
         List<T> retlist = new LinkedList<T>();
