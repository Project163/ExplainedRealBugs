diff --git a/CHANGES.txt b/CHANGES.txt
index 537ac446fa..78167c6f4f 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -14,7 +14,7 @@
  * optimize away seek when compacting wide rows (CASSANDRA-2879)
  * single-pass streaming (CASSANDRA-2677, 3003)
  * use reference counting for deleting sstables instead of relying on GC
-   (CASSANDRA-2521)
+   (CASSANDRA-2521, 3179)
  * store hints as serialized mutations instead of pointers to data row
    (CASSANDRA-2045)
  * store hints in the coordinator node instead of in the closest replica 
diff --git a/src/java/org/apache/cassandra/io/util/MappedFileDataInput.java b/src/java/org/apache/cassandra/io/util/MappedFileDataInput.java
index 5c1a3b56d4..10c46c0d58 100644
--- a/src/java/org/apache/cassandra/io/util/MappedFileDataInput.java
+++ b/src/java/org/apache/cassandra/io/util/MappedFileDataInput.java
@@ -25,6 +25,8 @@ import java.nio.ByteBuffer;
 import java.nio.MappedByteBuffer;
 import java.nio.channels.FileChannel;
 
+import org.apache.cassandra.utils.ByteBufferUtil;
+
 public class MappedFileDataInput extends AbstractDataInput implements FileDataInput
 {
     private final MappedByteBuffer buffer;
@@ -117,11 +119,18 @@ public class MappedFileDataInput extends AbstractDataInput implements FileDataIn
             throw new IOException(String.format("mmap segment underflow; remaining is %d but %d requested",
                                                 remaining, length));
 
+        if (length == 0)
+            return ByteBufferUtil.EMPTY_BYTE_BUFFER;
+
         ByteBuffer bytes = buffer.duplicate();
         bytes.position(buffer.position() + position).limit(buffer.position() + position + length);
         position += length;
 
-        return bytes;
+        // we have to copy the data in case we unreference the underlying sstable.  See CASSANDRA-3179
+        ByteBuffer clone = ByteBuffer.allocate(bytes.remaining());
+        clone.put(bytes);
+        clone.flip();
+        return clone;
     }
 
     @Override
