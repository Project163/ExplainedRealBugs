diff --git a/CHANGES.txt b/CHANGES.txt
index 75b349fa38..8790518352 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,5 +1,6 @@
 1.1.next
  * Backport compaction exception handling from 1.2
+ * Correctly validate sparse composite cells in scrub (CASSANDRA-5855)
 
 
 1.1.12
diff --git a/src/java/org/apache/cassandra/db/Column.java b/src/java/org/apache/cassandra/db/Column.java
index 97aece0932..ea83146ce5 100644
--- a/src/java/org/apache/cassandra/db/Column.java
+++ b/src/java/org/apache/cassandra/db/Column.java
@@ -29,6 +29,7 @@ import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import org.apache.cassandra.config.CFMetaData;
+import org.apache.cassandra.cql3.CFDefinition;
 import org.apache.cassandra.db.marshal.*;
 import org.apache.cassandra.io.util.DataOutputBuffer;
 import org.apache.cassandra.utils.Allocator;
@@ -277,7 +278,23 @@ public class Column implements IColumn
     public void validateFields(CFMetaData metadata) throws MarshalException
     {
         validateName(metadata);
-        AbstractType<?> valueValidator = metadata.getValueValidator(name());
+        CFDefinition cfdef = metadata.getCfDef();
+
+        // If this is a CQL table, we need to pull out the CQL column name to look up the correct column type.
+        // (Note that COMPACT composites are handled by validateName, above.)
+        ByteBuffer internalName;
+        if (cfdef.isComposite && !cfdef.isCompact)
+        {
+            AbstractCompositeType comparator = (AbstractCompositeType) metadata.comparator;
+            List<AbstractCompositeType.CompositeComponent> components = comparator.deconstruct(name);
+            internalName = components.get(components.size() - 1).value;
+        }
+        else
+        {
+            internalName = name;
+        }
+
+        AbstractType<?> valueValidator = metadata.getValueValidator(internalName);
         if (valueValidator != null)
             valueValidator.validate(value());
     }
