diff --git a/CHANGES.txt b/CHANGES.txt
index d9b7eecf3b..28991cc4f3 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -52,6 +52,7 @@
  * avoid marking entire list of sstables as actively being compacted
    in multithreaded compaction (CASSANDRA-2765)
  * seek back after deserializing a row to update cache with (CASSANDRA-2752)
+ * avoid skipping rows in scrub for counter column family (CASSANDRA-2759)
 
 
 0.8.0-final
diff --git a/src/java/org/apache/cassandra/db/compaction/CompactionManager.java b/src/java/org/apache/cassandra/db/compaction/CompactionManager.java
index 1092ca2e31..ff83668ff0 100644
--- a/src/java/org/apache/cassandra/db/compaction/CompactionManager.java
+++ b/src/java/org/apache/cassandra/db/compaction/CompactionManager.java
@@ -637,6 +637,7 @@ public class CompactionManager implements CompactionManagerMBean
     {
         logger.info("Scrubbing " + sstable);
         CompactionController controller = new CompactionController(cfs, Collections.singletonList(sstable), getDefaultGcBefore(cfs), true);
+        boolean isCommutative = cfs.metadata.getDefaultValidator().isCommutative();
 
         // Calculate the expected compacted filesize
         String compactionFileLocation = cfs.table.getDataFileLocation(sstable.length());
@@ -759,6 +760,10 @@ public class CompactionManager implements CompactionManagerMBean
                         catch (Throwable th2)
                         {
                             throwIfFatal(th2);
+                            // Skipping rows is dangerous for counters (see CASSANDRA-2759)
+                            if (isCommutative)
+                                throw new IOError(th2);
+
                             logger.warn("Retry failed too.  Skipping to next row (retry's stacktrace follows)", th2);
                             writer.reset();
                             dataFile.seek(nextRowPositionFromIndex);
@@ -767,6 +772,10 @@ public class CompactionManager implements CompactionManagerMBean
                     }
                     else
                     {
+                        // Skipping rows is dangerous for counters (see CASSANDRA-2759)
+                        if (isCommutative)
+                            throw new IOError(th);
+
                         logger.warn("Row at " + dataStart + " is unreadable; skipping to next");
                         if (currentIndexKey != null)
                             dataFile.seek(nextRowPositionFromIndex);
