diff --git a/src/java/org/apache/cassandra/journal/ActiveSegment.java b/src/java/org/apache/cassandra/journal/ActiveSegment.java
index d6a4c19315..ed94b44c26 100644
--- a/src/java/org/apache/cassandra/journal/ActiveSegment.java
+++ b/src/java/org/apache/cassandra/journal/ActiveSegment.java
@@ -26,6 +26,7 @@ import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 import java.util.concurrent.atomic.AtomicLongFieldUpdater;
 import java.util.concurrent.locks.LockSupport;
 
+import accord.utils.Invariants;
 import com.codahale.metrics.Timer;
 import org.apache.cassandra.db.TypeSizes;
 import org.apache.cassandra.utils.*;
@@ -341,7 +342,7 @@ public final class ActiveSegment<K, V> extends Segment<K, V>
                 if ((int)prev >= next)
                 {
                     // already stopped allocating, might also be closed
-                    assert buffer == null || prev == buffer.capacity() + 1;
+                    Invariants.require(buffer == null || prev == buffer.capacity() + 1);
                     return false;
                 }
 
@@ -350,6 +351,7 @@ public final class ActiveSegment<K, V> extends Segment<K, V>
                     // stopped allocating now; can only succeed once, no further allocation or discardUnusedTail can succeed
                     endOfBuffer = (int)prev;
                     assert buffer != null && next == buffer.capacity() + 1;
+                    metadata.fsyncLimit((int) prev);
                     return prev == 0;
                 }
                 LockSupport.parkNanos(1);
diff --git a/src/java/org/apache/cassandra/journal/EntrySerializer.java b/src/java/org/apache/cassandra/journal/EntrySerializer.java
index d7aa4923e5..2272188212 100644
--- a/src/java/org/apache/cassandra/journal/EntrySerializer.java
+++ b/src/java/org/apache/cassandra/journal/EntrySerializer.java
@@ -17,16 +17,16 @@
  */
 package org.apache.cassandra.journal;
 
-import java.io.EOFException;
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.util.zip.CRC32;
-
 import accord.utils.Invariants;
 import org.apache.cassandra.db.TypeSizes;
 import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.cassandra.utils.Crc;
 
+import java.io.EOFException;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.util.zip.CRC32;
+
 import static org.apache.cassandra.journal.Journal.validateCRC;
 
 public final class EntrySerializer
@@ -96,8 +96,7 @@ public final class EntrySerializer
                            KeySupport<K> keySupport,
                            ByteBuffer from,
                            int syncedOffset,
-                           int userVersion)
-    throws IOException
+                           int userVersion) throws IOException
     {
         CRC32 crc = Crc.crc32();
         into.clear();
@@ -120,34 +119,52 @@ public final class EntrySerializer
         if (totalSize == 0)
             return -1;
         Invariants.require(totalSize > 0);
-        if (from.remaining() < totalSize)
-            return handleReadException(new EOFException(), from.limit(), syncedOffset);
 
+        try
         {
-            int headerSize = EntrySerializer.headerSize(keySupport, userVersion);
-            int headerCrc = readAndUpdateHeaderCrc(crc, from, headerSize);
-            try
-            {
-                validateCRC(crc, headerCrc);
-            }
-            catch (IOException e)
+            if (from.remaining() < totalSize)
+                return handleReadException(new EOFException(), from.limit(), syncedOffset);
             {
-                return handleReadException(e, from.position() + headerSize, syncedOffset);
+                int headerSize = EntrySerializer.headerSize(keySupport, userVersion);
+                int headerCrc = readAndUpdateHeaderCrc(crc, from, headerSize);
+                try
+                {
+                    validateCRC(crc, headerCrc);
+                }
+                catch (IOException e)
+                {
+                    return handleReadException(e, from.position() + headerSize, syncedOffset);
+                }
+
+                int recordCrc = readAndUpdateRecordCrc(crc, from, start + totalSize);
+                try
+                {
+                    validateCRC(crc, recordCrc);
+                }
+                catch (IOException e)
+                {
+                    return handleReadException(e, from.position(), syncedOffset);
+                }
             }
 
-            int recordCrc = readAndUpdateRecordCrc(crc, from, start + totalSize);
-            try
-            {
-                validateCRC(crc, recordCrc);
-            }
-            catch (IOException e)
-            {
-                return handleReadException(e, from.position(), syncedOffset);
-            }
+            readValidated(into, from, start, keySupport, userVersion);
+            return totalSize;
+        }
+        catch (IOException e)
+        {
+            throw new RecoverableJournalError(totalSize, e);
         }
+    }
 
-        readValidated(into, from, start, keySupport, userVersion);
-        return totalSize;
+    public static class RecoverableJournalError extends IOException
+    {
+        public final int knownLength;
+
+        public RecoverableJournalError(int knownLength, Throwable cause)
+        {
+            super(cause);
+            this.knownLength = knownLength;
+        }
     }
 
     private static <K> void readValidated(EntryHolder<K> into, ByteBuffer from, int start, KeySupport<K> keySupport, int userVersion)
diff --git a/src/java/org/apache/cassandra/journal/Metadata.java b/src/java/org/apache/cassandra/journal/Metadata.java
index bc3d3ad624..d921d02537 100644
--- a/src/java/org/apache/cassandra/journal/Metadata.java
+++ b/src/java/org/apache/cassandra/journal/Metadata.java
@@ -57,6 +57,11 @@ final class Metadata
         incrementRecordsCount();
     }
 
+    void fsyncLimit(int fsyncLimit)
+    {
+        this.fsyncLimit = fsyncLimit;
+    }
+
     int fsyncLimit()
     {
         return fsyncLimit;
diff --git a/src/java/org/apache/cassandra/journal/StaticSegment.java b/src/java/org/apache/cassandra/journal/StaticSegment.java
index 09558be144..ffd2ed154d 100644
--- a/src/java/org/apache/cassandra/journal/StaticSegment.java
+++ b/src/java/org/apache/cassandra/journal/StaticSegment.java
@@ -421,6 +421,13 @@ public final class StaticSegment<K, V> extends Segment<K, V>
                     return eof();
                 buffer.position(offset + length);
             }
+            catch (EntrySerializer.RecoverableJournalError e)
+            {
+                logger.warn("Caught a recoverable journal error, skipping bytes", e);
+                buffer.position(offset + e.knownLength);
+                // Recur here, as we anticipate an corrupt or incompletely written entry to be a very rare case.
+                return doAdvance();
+            }
             catch (IOException e)
             {
                 throw new JournalReadError(descriptor, file, e);
diff --git a/src/java/org/apache/cassandra/service/accord/AccordJournal.java b/src/java/org/apache/cassandra/service/accord/AccordJournal.java
index 9730fe84d4..4b8825eb4e 100644
--- a/src/java/org/apache/cassandra/service/accord/AccordJournal.java
+++ b/src/java/org/apache/cassandra/service/accord/AccordJournal.java
@@ -439,22 +439,23 @@ public class AccordJournal implements accord.api.Journal, RangeSearcher.Supplier
     {
         try (CloseableIterator<Journal.KeyRefs<JournalKey>> iter = journalTable.keyIterator())
         {
-            TxnId prev = null;
+            JournalKey prev = null;
             while (iter.hasNext())
             {
                 Journal.KeyRefs<JournalKey> ref = iter.next();
 
                 if (ref.key().type != JournalKey.Type.COMMAND_DIFF)
                     continue;
-
                 CommandStore commandStore = commandStores.forId(ref.key().commandStoreId);
                 Loader loader = commandStore.loader();
                 TxnId txnId = ref.key().id;
-                Invariants.require(prev == null || txnId.compareTo(prev) != 0,
-                                   "duplicate key detected %s == %s", txnId, prev);
-                prev = txnId;
                 try
                 {
+                    Invariants.require(prev == null ||
+                                       ref.key().commandStoreId != prev.commandStoreId ||
+                                       ref.key().id.compareTo(prev.id) != 0,
+                                       "duplicate key detected %s == %s", ref.key(), prev);
+                    prev = ref.key();
                     AsyncChains.getUnchecked(loader.load(txnId)
                                                    .map(command -> {
                                                        if (journalTable.shouldIndex(ref.key())
diff --git a/test/unit/org/apache/cassandra/journal/SegmentTest.java b/test/unit/org/apache/cassandra/journal/SegmentTest.java
index 3c1e7fee8a..da366d3ea6 100644
--- a/test/unit/org/apache/cassandra/journal/SegmentTest.java
+++ b/test/unit/org/apache/cassandra/journal/SegmentTest.java
@@ -165,7 +165,7 @@ public class SegmentTest
         tidier.await.issue();
         activeSegment.close(null);
 
-        StaticSegment.SequentialReader<TimeUUID> reader = StaticSegment.sequentialReader(descriptor, TimeUUIDKeySupport.INSTANCE, 0);
+        StaticSegment.SequentialReader<TimeUUID> reader = StaticSegment.sequentialReader(descriptor, TimeUUIDKeySupport.INSTANCE, activeSegment.metadata.fsyncLimit());
 
         // read all 4 entries sequentially and compare with originals
         assertTrue(reader.advance());
