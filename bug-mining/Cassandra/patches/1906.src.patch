diff --git a/CHANGES.txt b/CHANGES.txt
index fd6ab95ae4..c499919912 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -13,6 +13,7 @@
  * Optimize mostRecentTomstone check in CC.collectAllData (CASSANDRA-4883)
  * Change stream session ID to UUID to avoid collision from same node (CASSANDRA-4813)
  * Use Stats.db when bulk loading if present (CASSANDRA-4957)
+ * Skip repair on system_trace and keyspaces with RF=1 (CASSANDRA-4956)
 Merged from 1.1:
  * reset getRangeSlice filter after finishing a row for get_paged_slice
    (CASSANDRA-4919)
diff --git a/src/java/org/apache/cassandra/service/AntiEntropyService.java b/src/java/org/apache/cassandra/service/AntiEntropyService.java
index a7fa157d1d..9f97f95a16 100644
--- a/src/java/org/apache/cassandra/service/AntiEntropyService.java
+++ b/src/java/org/apache/cassandra/service/AntiEntropyService.java
@@ -115,10 +115,15 @@ public class AntiEntropyService
 
     /**
      * Requests repairs for the given table and column families, and blocks until all repairs have been completed.
+     *
+     * @return Future for asynchronous call or null if there is no need to repair
      */
     public RepairFuture submitRepairSession(Range<Token> range, String tablename, boolean isSequential, boolean isLocal, String... cfnames)
     {
-        RepairFuture futureTask = new RepairSession(range, tablename, isSequential, isLocal, cfnames).getFuture();
+        RepairSession session = new RepairSession(range, tablename, isSequential, isLocal, cfnames);
+        if (session.endpoints.isEmpty())
+            return null;
+        RepairFuture futureTask = session.getFuture();
         executor.execute(futureTask);
         return futureTask;
     }
diff --git a/src/java/org/apache/cassandra/service/StorageService.java b/src/java/org/apache/cassandra/service/StorageService.java
index 0e6fd307f2..0206f40812 100644
--- a/src/java/org/apache/cassandra/service/StorageService.java
+++ b/src/java/org/apache/cassandra/service/StorageService.java
@@ -2223,10 +2223,29 @@ public class StorageService implements IEndpointStateChangeSubscriber, StorageSe
      */
     public void forceTableRepair(final String tableName, boolean isSequential, boolean  isLocal, final String... columnFamilies) throws IOException
     {
-        if (Table.SYSTEM_KS.equals(tableName))
+        forceTableRepairRange(tableName, getLocalRanges(tableName), isSequential, isLocal, columnFamilies);
+    }
+
+    public void forceTableRepairPrimaryRange(final String tableName, boolean isSequential, boolean  isLocal, final String... columnFamilies) throws IOException
+    {
+        forceTableRepairRange(tableName, getLocalPrimaryRanges(), isSequential, isLocal, columnFamilies);
+    }
+
+    public void forceTableRepairRange(String beginToken, String endToken, final String tableName, boolean isSequential, boolean  isLocal, final String... columnFamilies) throws IOException
+    {
+        Token parsedBeginToken = getPartitioner().getTokenFactory().fromString(beginToken);
+        Token parsedEndToken = getPartitioner().getTokenFactory().fromString(endToken);
+
+        logger.info("starting user-requested repair of range ({}, {}] for keyspace {} and column families {}",
+                    parsedBeginToken, parsedEndToken, tableName, columnFamilies);
+        forceTableRepairRange(tableName, Collections.singleton(new Range<Token>(parsedBeginToken, parsedEndToken)), isSequential, isLocal, columnFamilies);
+    }
+
+    public void forceTableRepairRange(final String tableName, final Collection<Range<Token>> ranges, boolean isSequential, boolean  isLocal, final String... columnFamilies) throws IOException
+    {
+        if (Table.SYSTEM_KS.equals(tableName) || Tracing.TRACE_KS.equals(tableName))
             return;
 
-        Collection<Range<Token>> ranges = getLocalRanges(tableName);
         int cmd = nextRepairCommand.incrementAndGet();
         logger.info("Starting repair command #{}, repairing {} ranges.", cmd, ranges.size());
 
@@ -2247,6 +2266,11 @@ public class StorageService implements IEndpointStateChangeSubscriber, StorageSe
                 logger.error("Interrupted while waiting for the differencing of repair session " + future.session + " to be done. Repair may be imprecise.", e);
             }
         }
+        if (futures.isEmpty())
+        {
+            logger.info("Nothing to repair on {} for command #{}", tableName, cmd);
+            return;
+        }
 
         boolean failedSession = false;
 
@@ -2270,47 +2294,6 @@ public class StorageService implements IEndpointStateChangeSubscriber, StorageSe
             logger.info("Repair command #{} completed successfully", cmd);
     }
 
-    public void forceTableRepairPrimaryRange(final String tableName, boolean isSequential, boolean  isLocal, final String... columnFamilies) throws IOException
-    {
-        if (Table.SYSTEM_KS.equals(tableName))
-            return;
-
-        List<AntiEntropyService.RepairFuture> futures = new ArrayList<AntiEntropyService.RepairFuture>();
-        for (Range<Token> range : getLocalPrimaryRanges())
-        {
-            RepairFuture future = forceTableRepair(range, tableName, isSequential, isLocal, columnFamilies);
-            if (future != null)
-                futures.add(future);
-        }
-        if (futures.isEmpty())
-            return;
-        for (AntiEntropyService.RepairFuture future : futures)
-            FBUtilities.waitOnFuture(future);
-    }
-
-    public void forceTableRepairRange(String beginToken, String endToken, final String tableName, boolean isSequential, boolean  isLocal, final String... columnFamilies) throws IOException
-    {
-        if (Table.SYSTEM_KS.equals(tableName))
-            return;
-
-        Token parsedBeginToken = getPartitioner().getTokenFactory().fromString(beginToken);
-        Token parsedEndToken = getPartitioner().getTokenFactory().fromString(endToken);
-
-        logger.info("starting user-requested repair of range ({}, {}] for keyspace {} and column families {}",
-                     new Object[] {parsedBeginToken, parsedEndToken, tableName, columnFamilies});
-        AntiEntropyService.RepairFuture future = forceTableRepair(new Range<Token>(parsedBeginToken, parsedEndToken), tableName, isSequential, isLocal, columnFamilies);
-        if (future == null)
-            return;
-        try
-        {
-            future.get();
-        }
-        catch (Exception e)
-        {
-            logger.error("Repair session " + future.session.getName() + " failed.", e);
-        }
-    }
-
     public AntiEntropyService.RepairFuture forceTableRepair(final Range<Token> range, final String tableName, boolean isSequential, boolean  isLocal, final String... columnFamilies) throws IOException
     {
         ArrayList<String> names = new ArrayList<String>();
