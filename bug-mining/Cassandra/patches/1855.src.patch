diff --git a/CHANGES.txt b/CHANGES.txt
index 9fbccb097b..e14ffa78cd 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -31,6 +31,7 @@
  * Fix potential NPE during CFS reload (CASSANDRA-4786)
  * Composite indexes may miss results (CASSANDRA-4796)
  * Move consistency level to the protocol level (CASSANDRA-4734, 4824)
+ * Fix Subcolumn slice ends not respected (CASSANDRA-4826)
 Merged from 1.1:
  * fix indexing empty column values (CASSANDRA-4832)
  * allow JdbcDate to compose null Date objects (CASSANDRA-4830)
diff --git a/src/java/org/apache/cassandra/db/filter/SliceQueryFilter.java b/src/java/org/apache/cassandra/db/filter/SliceQueryFilter.java
index 2de284a566..af63fa03ea 100644
--- a/src/java/org/apache/cassandra/db/filter/SliceQueryFilter.java
+++ b/src/java/org/apache/cassandra/db/filter/SliceQueryFilter.java
@@ -25,6 +25,7 @@ import java.util.Comparator;
 import java.util.Iterator;
 import java.util.List;
 
+import com.google.common.collect.AbstractIterator;
 import com.google.common.collect.Iterators;
 import com.google.common.collect.Lists;
 import org.slf4j.Logger;
@@ -104,7 +105,7 @@ public class SliceQueryFilter implements IFilter
         // we clone shallow, then add, under the theory that generally we're interested in a relatively small number of subcolumns.
         // this may be a poor assumption.
         SuperColumn scFiltered = superColumn.cloneMeShallow();
-        Iterator<IColumn> subcolumns;
+        final Iterator<IColumn> subcolumns;
         if (reversed)
         {
             List<IColumn> columnsAsList = new ArrayList<IColumn>(superColumn.getSubColumns());
@@ -114,20 +115,27 @@ public class SliceQueryFilter implements IFilter
         {
             subcolumns = superColumn.getSubColumns().iterator();
         }
-
-        // iterate until we get to the "real" start column
-        Comparator<ByteBuffer> comparator = reversed ? superColumn.getComparator().reverseComparator : superColumn.getComparator();
-        while (subcolumns.hasNext())
+        final Comparator<ByteBuffer> comparator = reversed ? superColumn.getComparator().reverseComparator : superColumn.getComparator();
+        Iterator<IColumn> results = new AbstractIterator<IColumn>()
         {
-            IColumn column = subcolumns.next();
-            if (comparator.compare(column.name(), start()) >= 0)
+            protected IColumn computeNext()
             {
-                subcolumns = Iterators.concat(Iterators.singletonIterator(column), subcolumns);
-                break;
+                while (subcolumns.hasNext())
+                {
+                    IColumn subcolumn = subcolumns.next();
+                    // iterate until we get to the "real" start column
+                    if (comparator.compare(subcolumn.name(), start()) < 0)
+                        continue;
+                    // exit loop when columns are out of the range.
+                    if (finish().remaining() > 0 && comparator.compare(subcolumn.name(), finish()) > 0)
+                        break;
+                    return subcolumn;
+                }
+                return endOfData();
             }
-        }
+        };
         // subcolumns is either empty now, or has been redefined in the loop above. either is ok.
-        collectReducedColumns(scFiltered, subcolumns, gcBefore);
+        collectReducedColumns(scFiltered, results, gcBefore);
         return scFiltered;
     }
 
