diff --git a/CHANGES.txt b/CHANGES.txt
index cc50a23bb1..ae7343785a 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 3.0.6
+ * Ensure columnfilter covers indexed columns for thrift 2i queries (CASSANDRA-11523)
  * Only open one sstable scanner per sstable (CASSANDRA-11412)
  * Option to specify ProtocolVersion in cassandra-stress (CASSANDRA-11410)
  * ArithmeticException in avgFunctionForDecimal (CASSANDRA-11485)
diff --git a/src/java/org/apache/cassandra/index/internal/keys/KeysSearcher.java b/src/java/org/apache/cassandra/index/internal/keys/KeysSearcher.java
index f00bb2761b..189b652456 100644
--- a/src/java/org/apache/cassandra/index/internal/keys/KeysSearcher.java
+++ b/src/java/org/apache/cassandra/index/internal/keys/KeysSearcher.java
@@ -23,7 +23,9 @@ import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import org.apache.cassandra.config.CFMetaData;
+import org.apache.cassandra.config.ColumnDefinition;
 import org.apache.cassandra.db.*;
+import org.apache.cassandra.db.filter.ColumnFilter;
 import org.apache.cassandra.db.filter.DataLimits;
 import org.apache.cassandra.db.filter.RowFilter;
 import org.apache.cassandra.db.partitions.ImmutableBTreePartition;
@@ -89,10 +91,11 @@ public class KeysSearcher extends CassandraIndexSearcher
                     if (!command.selectsKey(key))
                         continue;
 
+                    ColumnFilter extendedFilter = getExtendedFilter(command.columnFilter());
                     SinglePartitionReadCommand dataCmd = SinglePartitionReadCommand.create(isForThrift(),
                                                                                            index.baseCfs.metadata,
                                                                                            command.nowInSec(),
-                                                                                           command.columnFilter(),
+                                                                                           extendedFilter,
                                                                                            command.rowFilter(),
                                                                                            DataLimits.NONE,
                                                                                            key,
@@ -134,6 +137,17 @@ public class KeysSearcher extends CassandraIndexSearcher
         };
     }
 
+    private ColumnFilter getExtendedFilter(ColumnFilter initialFilter)
+    {
+        if (command.columnFilter().includes(index.getIndexedColumn()))
+            return initialFilter;
+
+        ColumnFilter.Builder builder = ColumnFilter.selectionBuilder();
+        builder.addAll(initialFilter.fetchedColumns());
+        builder.add(index.getIndexedColumn());
+        return builder.build();
+    }
+
     private UnfilteredRowIterator filterIfStale(UnfilteredRowIterator iterator,
                                                 Row indexHit,
                                                 ByteBuffer indexedValue,
@@ -144,10 +158,12 @@ public class KeysSearcher extends CassandraIndexSearcher
         if (isForThrift)
         {
             // The data we got has gone though ThrifResultsMerger, so we're looking for the row whose clustering
-            // is the indexed name. Ans so we need to materialize the partition.
+            // is the indexed name and so we need to materialize the partition.
             ImmutableBTreePartition result = ImmutableBTreePartition.create(iterator);
             iterator.close();
             Row data = result.getRow(new Clustering(index.getIndexedColumn().name.bytes));
+            if (data == null)
+                return null;
 
             // for thrift tables, we need to compare the index entry against the compact value column,
             // not the column actually designated as the indexed column so we don't use the index function
@@ -164,7 +180,18 @@ public class KeysSearcher extends CassandraIndexSearcher
             }
             else
             {
-                return result.unfilteredIterator();
+                if (command.columnFilter().includes(index.getIndexedColumn()))
+                    return result.unfilteredIterator();
+
+                // The query on the base table used an extended column filter to ensure that the
+                // indexed column was actually read for use in the staleness check, before
+                // returning the results we must filter the base table partition so that it
+                // contains only the originally requested columns. See CASSANDRA-11523
+                ClusteringComparator comparator = result.metadata().comparator;
+                Slices.Builder slices = new Slices.Builder(comparator);
+                for (ColumnDefinition selected : command.columnFilter().fetchedColumns())
+                    slices.add(Slice.make(comparator, selected.name.bytes));
+                return result.unfilteredIterator(ColumnFilter.all(command.metadata()), slices.build(), false);
             }
         }
         else
