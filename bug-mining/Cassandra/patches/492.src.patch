diff --git a/CHANGES.txt b/CHANGES.txt
index 517260ae18..c4553e9e9c 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -5,6 +5,7 @@ dev
  * allow nodes to change IPs between restarts (CASSANDRA-1518)
  * remember ring state between restarts by default (CASSANDRA-1518)
  * flush index built flag so we can read it before log replay (CASSANDRA-1541)
+ * lock row cache updates to prevent race condition (CASSANDRA-1293)
 
 
 0.7-beta2
diff --git a/src/java/org/apache/cassandra/db/ColumnFamilyStore.java b/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
index f729742180..1468a9a824 100644
--- a/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
+++ b/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
@@ -551,6 +551,9 @@ public class ColumnFamilyStore implements ColumnFamilyStoreMBean
 
         boolean flushRequested = memtable.isThresholdViolated();
         memtable.put(key, columnFamily);
+        ColumnFamily cachedRow = getRawCachedRow(key);
+        if (cachedRow != null)
+            cachedRow.addAll(columnFamily);
         writeStats.addNano(System.nanoTime() - start);
         
         return flushRequested ? memtable : null;
diff --git a/src/java/org/apache/cassandra/db/Table.java b/src/java/org/apache/cassandra/db/Table.java
index 3b170fbe1e..982594f6e9 100644
--- a/src/java/org/apache/cassandra/db/Table.java
+++ b/src/java/org/apache/cassandra/db/Table.java
@@ -362,31 +362,25 @@ public class Table
                     }
                 }
 
-                if (mutatedIndexedColumns == null)
+                synchronized (indexLockFor(mutation.key()))
                 {
-                    // just update the actual value, no extra synchronization
+                    ColumnFamily oldIndexedColumns = null;
+                    if (mutatedIndexedColumns != null)
+                    {
+                        oldIndexedColumns = readCurrentIndexedColumns(key, cfs, mutatedIndexedColumns);
+                        ignoreObsoleteMutations(cf, cfs.metadata.reconciler, mutatedIndexedColumns, oldIndexedColumns);
+                    }
+
                     Memtable fullMemtable = cfs.apply(key, cf);
                     if (fullMemtable != null)
                         memtablesToFlush = addFullMemtable(memtablesToFlush, fullMemtable);
-                }
-                else
-                {
-                    synchronized (indexLockFor(mutation.key()))
-                    {
-                        ColumnFamily oldIndexedColumns = readCurrentIndexedColumns(key, cfs, mutatedIndexedColumns);
-                        ignoreObsoleteMutations(cf, cfs.metadata.reconciler, mutatedIndexedColumns, oldIndexedColumns);
 
-                        Memtable fullMemtable = cfs.apply(key, cf);
-                        if (fullMemtable != null)
-                            memtablesToFlush = addFullMemtable(memtablesToFlush, fullMemtable);
+                    if (mutatedIndexedColumns != null)
+                    {
                         // ignore full index memtables -- we flush those when the "master" one is full
                         applyIndexUpdates(mutation.key(), cf, cfs, mutatedIndexedColumns, oldIndexedColumns);
                     }
                 }
-
-                ColumnFamily cachedRow = cfs.getRawCachedRow(key);
-                if (cachedRow != null)
-                    cachedRow.addAll(cf);
             }
         }
         finally
diff --git a/src/java/org/apache/cassandra/db/migration/UpdateColumnFamily.java b/src/java/org/apache/cassandra/db/migration/UpdateColumnFamily.java
index b39c23956c..22ec6fc073 100644
--- a/src/java/org/apache/cassandra/db/migration/UpdateColumnFamily.java
+++ b/src/java/org/apache/cassandra/db/migration/UpdateColumnFamily.java
@@ -51,10 +51,6 @@ public class UpdateColumnFamily extends Migration
         this.oldCfm = oldCfm;
         this.newCfm = newCfm;
         
-        // we'll allow this eventually.
-        if (!oldCfm.column_metadata.equals(newCfm.column_metadata))
-            throw new ConfigurationException("Column meta information is not identical.");
-        
         // clone ksm but include the new cf def.
         KSMetaData newKsm = makeNewKeyspaceDefinition(ksm);
         rm = Migration.makeDefinitionMutation(newKsm, null, newVersion);
diff --git a/src/java/org/apache/cassandra/thrift/CassandraServer.java b/src/java/org/apache/cassandra/thrift/CassandraServer.java
index 6f17c1e2cc..119422da76 100644
--- a/src/java/org/apache/cassandra/thrift/CassandraServer.java
+++ b/src/java/org/apache/cassandra/thrift/CassandraServer.java
@@ -771,7 +771,7 @@ public class CassandraServer implements Cassandra.Iface
             throw new InvalidRequestException(String.format("%s live nodes are not enough to support replication factor %s",
                                                             totalNodes, ks_def.replication_factor));
         
-        //generate a meaningful error if the user setup keyspace and/or column definition incorrectly
+        // generate a meaningful error if the user setup keyspace and/or column definition incorrectly
         for (CfDef cf : ks_def.cf_defs) 
         {
             if (!cf.getKeyspace().equals(ks_def.getName()))
@@ -787,13 +787,12 @@ public class CassandraServer implements Cassandra.Iface
             {
                 cfDefs.add(convertToCFMetaData(cfDef));
             }
-            
-            KSMetaData ksm = new KSMetaData(
-                    ks_def.name, 
-                    (Class<? extends AbstractReplicationStrategy>)Class.forName(ks_def.strategy_class),
-                    ks_def.strategy_options,
-                    ks_def.replication_factor,
-                    cfDefs.toArray(new CFMetaData[cfDefs.size()]));
+
+            KSMetaData ksm = new KSMetaData(ks_def.name,
+                                            (Class<? extends AbstractReplicationStrategy>) Class.forName(ks_def.strategy_class),
+                                            ks_def.strategy_options,
+                                            ks_def.replication_factor,
+                                            cfDefs.toArray(new CFMetaData[cfDefs.size()]));
             applyMigrationOnStage(new AddKeyspace(ksm));
             return DatabaseDescriptor.getDefsVersion().toString();
         }
