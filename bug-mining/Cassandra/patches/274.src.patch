diff --git a/src/java/org/apache/cassandra/db/CommitLog.java b/src/java/org/apache/cassandra/db/CommitLog.java
index f089edb8d8..7a3321b9da 100644
--- a/src/java/org/apache/cassandra/db/CommitLog.java
+++ b/src/java/org/apache/cassandra/db/CommitLog.java
@@ -442,22 +442,10 @@ public class CommitLog
      * of any problems. This way we can assume that the subsequent commit log
      * entry will override the garbage left over by the previous write.
     */
-    void add(RowMutation rowMutation, Object serializedRow) throws IOException
+    Future<CommitLogContext> add(RowMutation rowMutation, Object serializedRow) throws IOException
     {
         Callable<CommitLogContext> task = new LogRecordAdder(rowMutation, serializedRow);
-
-        try
-        {
-            executor.submit(task).get();
-        }
-        catch (InterruptedException e)
-        {
-            throw new RuntimeException(e);
-        }
-        catch (ExecutionException e)
-        {
-            throw new RuntimeException(e);
-        }
+        return executor.submit(task);
     }
 
     /*
diff --git a/src/java/org/apache/cassandra/db/CommitLogExecutorService.java b/src/java/org/apache/cassandra/db/CommitLogExecutorService.java
index 58f17f8849..f6f773cbaf 100644
--- a/src/java/org/apache/cassandra/db/CommitLogExecutorService.java
+++ b/src/java/org/apache/cassandra/db/CommitLogExecutorService.java
@@ -42,12 +42,14 @@ public class CommitLogExecutorService extends AbstractExecutorService implements
 
     public CommitLogExecutorService()
     {
-        this(DatabaseDescriptor.getConcurrentWriters());    
+        this(DatabaseDescriptor.getCommitLogSync() == DatabaseDescriptor.CommitLogSync.batch
+             ? DatabaseDescriptor.getConcurrentWriters()
+             : 1024 * Runtime.getRuntime().availableProcessors());
     }
 
     public CommitLogExecutorService(int queueSize)
     {
-        queue = new ArrayBlockingQueue<CheaterFutureTask>(queueSize);
+        queue = new LinkedBlockingQueue<CheaterFutureTask>(queueSize);
         Runnable runnable = new WrappedRunnable()
         {
             public void runMayThrow() throws Exception
diff --git a/src/java/org/apache/cassandra/db/Table.java b/src/java/org/apache/cassandra/db/Table.java
index d32b42abaf..80b887ab93 100644
--- a/src/java/org/apache/cassandra/db/Table.java
+++ b/src/java/org/apache/cassandra/db/Table.java
@@ -21,6 +21,7 @@ package org.apache.cassandra.db;
 import java.util.*;
 import java.io.IOException;
 import java.io.File;
+import java.util.concurrent.ExecutionException;
 import java.util.concurrent.locks.Lock;
 import java.util.concurrent.locks.ReentrantLock;
 import java.util.concurrent.locks.ReentrantReadWriteLock;
@@ -52,6 +53,7 @@ public class Table
     static final ReentrantReadWriteLock flusherLock = new ReentrantReadWriteLock(true);
 
     private static Timer flushTimer = new Timer("FLUSH-TIMER");
+    private final boolean waitForCommitLog;
 
     // This is a result of pushing down the point in time when storage directories get created.  It used to happen in
     // CassandraDaemon, but it is possible to call Table.open without a running daemon, so it made sense to ensure
@@ -332,6 +334,7 @@ public class Table
     private Table(String table) throws IOException
     {
         name = table;
+        waitForCommitLog = DatabaseDescriptor.getCommitLogSync() == DatabaseDescriptor.CommitLogSync.batch;
         tableMetadata = Table.TableMetadata.instance(table);
         for (String columnFamily : tableMetadata.getColumnFamilies())
         {
@@ -406,7 +409,20 @@ public class Table
         try
         {
             if (writeCommitLog)
-                CommitLog.open().add(mutation, serializedMutation);
+            {
+                Future<CommitLog.CommitLogContext> future = CommitLog.open().add(mutation, serializedMutation);
+                if (waitForCommitLog)
+                {
+                    try
+                    {
+                        future.get();
+                    }
+                    catch (Exception e)
+                    {
+                        throw new RuntimeException(e);
+                    }
+                }
+            }
         
             for (ColumnFamily columnFamily : mutation.getColumnFamilies())
             {
