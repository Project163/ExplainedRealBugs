diff --git a/CHANGES.txt b/CHANGES.txt
index cc04ecaca6..c1d1991dbd 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -12,6 +12,7 @@
  * Add tombstone debug threshold and histogram (CASSANDRA-6042, 6057)
  * Fix fat client schema pull NPE (CASSANDRA-6089)
  * Fix memtable flushing for indexed tables (CASSANDRA-6112)
+ * Fix skipping columns with multiple slices (CASSANDRA-6119)
 
 
 1.2.10
diff --git a/src/java/org/apache/cassandra/db/columniterator/IndexedSliceReader.java b/src/java/org/apache/cassandra/db/columniterator/IndexedSliceReader.java
index 472ecfc5f2..df916b2eef 100644
--- a/src/java/org/apache/cassandra/db/columniterator/IndexedSliceReader.java
+++ b/src/java/org/apache/cassandra/db/columniterator/IndexedSliceReader.java
@@ -391,7 +391,7 @@ class IndexedSliceReader extends AbstractIterator<OnDiskAtom> implements OnDiskA
 
             // scan from index start
             OnDiskAtom column = null;
-            while (file.bytesPastMark(mark) < currentIndex.width)
+            while (file.bytesPastMark(mark) < currentIndex.width || column != null)
             {
                 // Only fetch a new column if we haven't dealt with the previous one.
                 if (column == null)
@@ -467,20 +467,31 @@ class IndexedSliceReader extends AbstractIterator<OnDiskAtom> implements OnDiskA
             OnDiskAtom.Serializer atomSerializer = emptyColumnFamily.getOnDiskSerializer();
             int columns = file.readInt();
 
-            for (int i = 0; i < columns; i++)
+            OnDiskAtom column = null;
+            int i = 0;
+            while (i < columns || column != null)
             {
-                OnDiskAtom column = atomSerializer.deserializeFromSSTable(file, sstable.descriptor.version);
+                // Only fetch a new column if we haven't dealt with the previous one.
+                if (column == null)
+                {
+                    column = atomSerializer.deserializeFromSSTable(file, sstable.descriptor.version);
+                    i++;
+                }
 
                 // col is before slice
                 // (If in slice, don't bother checking that until we change slice)
                 if (!inSlice && isColumnBeforeSliceStart(column))
+                {
+                    column = null;
                     continue;
+                }
 
                 // col is within slice
                 if (isColumnBeforeSliceFinish(column))
                 {
                     inSlice = true;
                     addColumn(column);
+                    column = null;
                 }
                 // col is after slice. more slices?
                 else
diff --git a/test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java b/test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java
index abe3f05167..cd30297b77 100644
--- a/test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java
+++ b/test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java
@@ -1158,6 +1158,204 @@ public class ColumnFamilyStoreTest extends SchemaLoader
         return k;
     }
 
+    @SuppressWarnings("unchecked")
+    @Test
+    public void testMultiRangeSomeEmptyNoIndex() throws Throwable
+    {
+        // in order not to change thrift interfaces at this stage we build SliceQueryFilter
+        // directly instead of using QueryFilter to build it for us
+        ColumnSlice[] ranges = new ColumnSlice[] {
+                new ColumnSlice(ByteBuffer.wrap(EMPTY_BYTE_ARRAY), bytes("colA")),
+                new ColumnSlice(bytes("colC"), bytes("colE")),
+                new ColumnSlice(bytes("colF"), bytes("colF")),
+                new ColumnSlice(bytes("colG"), bytes("colG")),
+                new ColumnSlice(bytes("colI"), ByteBuffer.wrap(EMPTY_BYTE_ARRAY)) };
+
+        ColumnSlice[] rangesReversed = new ColumnSlice[] {
+                new ColumnSlice(ByteBuffer.wrap(EMPTY_BYTE_ARRAY), bytes("colI")),
+                new ColumnSlice(bytes("colG"), bytes("colG")),
+                new ColumnSlice(bytes("colF"), bytes("colF")),
+                new ColumnSlice(bytes("colE"), bytes("colC")),
+                new ColumnSlice(bytes("colA"), ByteBuffer.wrap(EMPTY_BYTE_ARRAY)) };
+
+        String tableName = "Keyspace1";
+        String cfName = "Standard1";
+        Table table = Table.open(tableName);
+        ColumnFamilyStore cfs = table.getColumnFamilyStore(cfName);
+        cfs.clearUnsafe();
+
+        String[] letters = new String[] { "a", "b", "c", "d", "i" };
+        Column[] cols = new Column[letters.length];
+        for (int i = 0; i < cols.length; i++)
+        {
+            cols[i] = new Column(ByteBufferUtil.bytes("col" + letters[i].toUpperCase()),
+                    ByteBuffer.wrap(new byte[1]), 1);
+        }
+
+        putColsStandard(cfs, dk("a"), cols);
+
+        cfs.forceBlockingFlush();
+
+        SliceQueryFilter multiRangeForward = new SliceQueryFilter(ranges, false, 100);
+        SliceQueryFilter multiRangeForwardWithCounting = new SliceQueryFilter(ranges, false, 3);
+        SliceQueryFilter multiRangeReverse = new SliceQueryFilter(rangesReversed, true, 100);
+        SliceQueryFilter multiRangeReverseWithCounting = new SliceQueryFilter(rangesReversed, true, 3);
+
+        findRowGetSlicesAndAssertColsFound(cfs, multiRangeForward, "a", "colA", "colC", "colD", "colI");
+        findRowGetSlicesAndAssertColsFound(cfs, multiRangeForwardWithCounting, "a", "colA", "colC", "colD");
+        findRowGetSlicesAndAssertColsFound(cfs, multiRangeReverse, "a", "colI", "colD", "colC", "colA");
+        findRowGetSlicesAndAssertColsFound(cfs, multiRangeReverseWithCounting, "a", "colI", "colD", "colC");
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void testMultiRangeSomeEmptyIndexed() throws Throwable
+    {
+        // in order not to change thrift interfaces at this stage we build SliceQueryFilter
+        // directly instead of using QueryFilter to build it for us
+        ColumnSlice[] ranges = new ColumnSlice[] {
+                new ColumnSlice(ByteBuffer.wrap(EMPTY_BYTE_ARRAY), bytes("colA")),
+                new ColumnSlice(bytes("colC"), bytes("colE")),
+                new ColumnSlice(bytes("colF"), bytes("colF")),
+                new ColumnSlice(bytes("colG"), bytes("colG")),
+                new ColumnSlice(bytes("colI"), ByteBuffer.wrap(EMPTY_BYTE_ARRAY)) };
+
+        ColumnSlice[] rangesReversed = new ColumnSlice[] {
+                new ColumnSlice(ByteBuffer.wrap(EMPTY_BYTE_ARRAY), bytes("colI")),
+                new ColumnSlice(bytes("colG"), bytes("colG")),
+                new ColumnSlice(bytes("colF"), bytes("colF")),
+                new ColumnSlice(bytes("colE"), bytes("colC")),
+                new ColumnSlice(bytes("colA"), ByteBuffer.wrap(EMPTY_BYTE_ARRAY)) };
+
+        String tableName = "Keyspace1";
+        String cfName = "Standard1";
+        Table table = Table.open(tableName);
+        ColumnFamilyStore cfs = table.getColumnFamilyStore(cfName);
+        cfs.clearUnsafe();
+
+        String[] letters = new String[] { "a", "b", "c", "d", "i" };
+        Column[] cols = new Column[letters.length];
+        for (int i = 0; i < cols.length; i++)
+        {
+            cols[i] = new Column(ByteBufferUtil.bytes("col" + letters[i].toUpperCase()),
+                    ByteBuffer.wrap(new byte[1366]), 1);
+        }
+
+        putColsStandard(cfs, dk("a"), cols);
+
+        cfs.forceBlockingFlush();
+
+        SliceQueryFilter multiRangeForward = new SliceQueryFilter(ranges, false, 100);
+        SliceQueryFilter multiRangeForwardWithCounting = new SliceQueryFilter(ranges, false, 3);
+        SliceQueryFilter multiRangeReverse = new SliceQueryFilter(rangesReversed, true, 100);
+        SliceQueryFilter multiRangeReverseWithCounting = new SliceQueryFilter(rangesReversed, true, 3);
+
+        findRowGetSlicesAndAssertColsFound(cfs, multiRangeForward, "a", "colA", "colC", "colD", "colI");
+        findRowGetSlicesAndAssertColsFound(cfs, multiRangeForwardWithCounting, "a", "colA", "colC", "colD");
+        findRowGetSlicesAndAssertColsFound(cfs, multiRangeReverse, "a", "colI", "colD", "colC", "colA");
+        findRowGetSlicesAndAssertColsFound(cfs, multiRangeReverseWithCounting, "a", "colI", "colD", "colC");
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void testMultiRangeContiguousNoIndex() throws Throwable
+    {
+        // in order not to change thrift interfaces at this stage we build SliceQueryFilter
+        // directly instead of using QueryFilter to build it for us
+        ColumnSlice[] ranges = new ColumnSlice[] {
+                new ColumnSlice(ByteBuffer.wrap(EMPTY_BYTE_ARRAY), bytes("colA")),
+                new ColumnSlice(bytes("colC"), bytes("colE")),
+                new ColumnSlice(bytes("colF"), bytes("colF")),
+                new ColumnSlice(bytes("colG"), bytes("colG")),
+                new ColumnSlice(bytes("colI"), ByteBuffer.wrap(EMPTY_BYTE_ARRAY)) };
+
+        ColumnSlice[] rangesReversed = new ColumnSlice[] {
+                new ColumnSlice(ByteBuffer.wrap(EMPTY_BYTE_ARRAY), bytes("colI")),
+                new ColumnSlice(bytes("colG"), bytes("colG")),
+                new ColumnSlice(bytes("colF"), bytes("colF")),
+                new ColumnSlice(bytes("colE"), bytes("colC")),
+                new ColumnSlice(bytes("colA"), ByteBuffer.wrap(EMPTY_BYTE_ARRAY)) };
+
+        String tableName = "Keyspace1";
+        String cfName = "Standard1";
+        Table table = Table.open(tableName);
+        ColumnFamilyStore cfs = table.getColumnFamilyStore(cfName);
+        cfs.clearUnsafe();
+
+        String[] letters = new String[] { "a", "b", "c", "d", "e", "f", "g", "h", "i" };
+        Column[] cols = new Column[letters.length];
+        for (int i = 0; i < cols.length; i++)
+        {
+            cols[i] = new Column(ByteBufferUtil.bytes("col" + letters[i].toUpperCase()),
+                    ByteBuffer.wrap(new byte[1]), 1);
+        }
+
+        putColsStandard(cfs, dk("a"), cols);
+
+        cfs.forceBlockingFlush();
+
+        SliceQueryFilter multiRangeForward = new SliceQueryFilter(ranges, false, 100);
+        SliceQueryFilter multiRangeForwardWithCounting = new SliceQueryFilter(ranges, false, 3);
+        SliceQueryFilter multiRangeReverse = new SliceQueryFilter(rangesReversed, true, 100);
+        SliceQueryFilter multiRangeReverseWithCounting = new SliceQueryFilter(rangesReversed, true, 3);
+
+        findRowGetSlicesAndAssertColsFound(cfs, multiRangeForward, "a", "colA", "colC", "colD", "colE", "colF", "colG", "colI");
+        findRowGetSlicesAndAssertColsFound(cfs, multiRangeForwardWithCounting, "a", "colA", "colC", "colD");
+        findRowGetSlicesAndAssertColsFound(cfs, multiRangeReverse, "a", "colI", "colG", "colF", "colE", "colD", "colC", "colA");
+        findRowGetSlicesAndAssertColsFound(cfs, multiRangeReverseWithCounting, "a", "colI", "colG", "colF");
+
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void testMultiRangeContiguousIndexed() throws Throwable
+    {
+        // in order not to change thrift interfaces at this stage we build SliceQueryFilter
+        // directly instead of using QueryFilter to build it for us
+        ColumnSlice[] ranges = new ColumnSlice[] {
+                new ColumnSlice(ByteBuffer.wrap(EMPTY_BYTE_ARRAY), bytes("colA")),
+                new ColumnSlice(bytes("colC"), bytes("colE")),
+                new ColumnSlice(bytes("colF"), bytes("colF")),
+                new ColumnSlice(bytes("colG"), bytes("colG")),
+                new ColumnSlice(bytes("colI"), ByteBuffer.wrap(EMPTY_BYTE_ARRAY)) };
+
+        ColumnSlice[] rangesReversed = new ColumnSlice[] {
+                new ColumnSlice(ByteBuffer.wrap(EMPTY_BYTE_ARRAY), bytes("colI")),
+                new ColumnSlice(bytes("colG"), bytes("colG")),
+                new ColumnSlice(bytes("colF"), bytes("colF")),
+                new ColumnSlice(bytes("colE"), bytes("colC")),
+                new ColumnSlice(bytes("colA"), ByteBuffer.wrap(EMPTY_BYTE_ARRAY)) };
+
+        String tableName = "Keyspace1";
+        String cfName = "Standard1";
+        Table table = Table.open(tableName);
+        ColumnFamilyStore cfs = table.getColumnFamilyStore(cfName);
+        cfs.clearUnsafe();
+
+        String[] letters = new String[] { "a", "b", "c", "d", "e", "f", "g", "h", "i" };
+        Column[] cols = new Column[letters.length];
+        for (int i = 0; i < cols.length; i++)
+        {
+            cols[i] = new Column(ByteBufferUtil.bytes("col" + letters[i].toUpperCase()),
+                    ByteBuffer.wrap(new byte[1366]), 1);
+        }
+
+        putColsStandard(cfs, dk("a"), cols);
+
+        cfs.forceBlockingFlush();
+
+        SliceQueryFilter multiRangeForward = new SliceQueryFilter(ranges, false, 100);
+        SliceQueryFilter multiRangeForwardWithCounting = new SliceQueryFilter(ranges, false, 3);
+        SliceQueryFilter multiRangeReverse = new SliceQueryFilter(rangesReversed, true, 100);
+        SliceQueryFilter multiRangeReverseWithCounting = new SliceQueryFilter(rangesReversed, true, 3);
+
+        findRowGetSlicesAndAssertColsFound(cfs, multiRangeForward, "a", "colA", "colC", "colD", "colE", "colF", "colG", "colI");
+        findRowGetSlicesAndAssertColsFound(cfs, multiRangeForwardWithCounting, "a", "colA", "colC", "colD");
+        findRowGetSlicesAndAssertColsFound(cfs, multiRangeReverse, "a", "colI", "colG", "colF", "colE", "colD", "colC", "colA");
+        findRowGetSlicesAndAssertColsFound(cfs, multiRangeReverseWithCounting, "a", "colI", "colG", "colF");
+
+    }
+
     @SuppressWarnings("unchecked")
     @Test
     public void testMultiRangeIndexed() throws Throwable
