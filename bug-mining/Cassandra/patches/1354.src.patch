diff --git a/CHANGES.txt b/CHANGES.txt
index 6767d88ce0..ec37086d8f 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -7,6 +7,7 @@
    (CASSANDRA-3335)
 Merged from 0.8:
  * prevent new nodes from thinking down nodes are up forever (CASSANDRA-3626)
+ * Flush non-cfs backed secondary indexes (CASSANDRA-3659)
 
 
 1.0.6
diff --git a/src/java/org/apache/cassandra/db/ColumnFamilyStore.java b/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
index 7638ffcad1..50a07b039a 100644
--- a/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
+++ b/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
@@ -49,6 +49,7 @@ import org.apache.cassandra.db.compaction.LeveledCompactionStrategy;
 import org.apache.cassandra.db.filter.IFilter;
 import org.apache.cassandra.db.filter.QueryFilter;
 import org.apache.cassandra.db.filter.QueryPath;
+import org.apache.cassandra.db.index.SecondaryIndex;
 import org.apache.cassandra.db.index.SecondaryIndexManager;
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.dht.*;
@@ -673,7 +674,7 @@ public class ColumnFamilyStore implements ColumnFamilyStoreMBean
             logger.debug("flush position is {}", ctx);
 
             // submit the memtable for any indexed sub-cfses, and our own.
-            List<ColumnFamilyStore> icc = new ArrayList<ColumnFamilyStore>();
+            final List<ColumnFamilyStore> icc = new ArrayList<ColumnFamilyStore>();
             // don't assume that this.memtable is dirty; forceFlush can bring us here during index build even if it is not
             for (ColumnFamilyStore cfs : concatWithIndexes())
             {
@@ -705,6 +706,19 @@ public class ColumnFamilyStore implements ColumnFamilyStoreMBean
                 public void runMayThrow() throws InterruptedException, IOException
                 {
                     latch.await();
+                    
+                    if (!icc.isEmpty())
+                    {
+                        //only valid when memtables exist
+                        
+                        for (SecondaryIndex index : indexManager.getIndexesNotBackedByCfs())
+                        {
+                            // flush any non-cfs backed indexes
+                            logger.info("Flushing SecondaryIndex {}", index);
+                            index.forceBlockingFlush();
+                        }
+                    }
+                    
                     if (writeCommitLog)
                     {
                         // if we're not writing to the commit log, we are replaying the log, so marking
diff --git a/src/java/org/apache/cassandra/db/index/SecondaryIndexManager.java b/src/java/org/apache/cassandra/db/index/SecondaryIndexManager.java
index 88528ede7d..ee210ac306 100644
--- a/src/java/org/apache/cassandra/db/index/SecondaryIndexManager.java
+++ b/src/java/org/apache/cassandra/db/index/SecondaryIndexManager.java
@@ -308,7 +308,27 @@ public class SecondaryIndexManager
         return cfsList;
     }
         
-   
+    /**
+     * @return all indexes which do *not* use a backing CFS internally
+     */
+    public Collection<SecondaryIndex> getIndexesNotBackedByCfs()
+    {
+        // we use identity map because per row indexes use same instance
+        // across many columns
+        IdentityHashMap<SecondaryIndex, Object> indexList = new IdentityHashMap<SecondaryIndex, Object>();
+
+        for (Map.Entry<ByteBuffer, SecondaryIndex> entry : indexesByColumn.entrySet())
+        {
+            ColumnFamilyStore cfs = entry.getValue().getIndexCfs();
+            
+            if (cfs == null)
+                indexList.put(entry.getValue(), null);        
+        }
+        
+        return indexList.keySet();
+    }
+    
+    
     /**
      * Removes obsolete index entries and creates new ones for the given row key
      * and mutated columns.
