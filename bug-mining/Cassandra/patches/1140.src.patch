diff --git a/CHANGES.txt b/CHANGES.txt
index 5d724b4648..22b6dbaa74 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,3 +1,7 @@
+1.0.0-rc1
+ * Fix counting CFMetadata towards Memtable liveRatio (CASSANDRA-3023)
+
+
 1.0.0-beta1
  * removed binarymemtable (CASSANDRA-2692)
  * add commitlog_total_space_in_mb to prevent fragmented logs (CASSANDRA-2427)
diff --git a/build.xml b/build.xml
index 96408a94f1..f976f2b82a 100644
--- a/build.xml
+++ b/build.xml
@@ -366,7 +366,7 @@ url=${svn.entry.url}?pathrev=${svn.entry.commit.revision}
           </dependency>
           <dependency groupId="com.googlecode.json-simple" artifactId="json-simple" version="1.1"/>
           <dependency groupId="com.github.stephenc.high-scale-lib" artifactId="high-scale-lib" version="1.1.2"/>
-          <dependency groupId="com.github.stephenc" artifactId="jamm" version="0.2.4"/>
+          <dependency groupId="com.github.stephenc" artifactId="jamm" version="0.2.5"/>
           <dependency groupId="org.yaml" artifactId="snakeyaml" version="1.6"/>
           <dependency groupId="org.apache.cassandra.deps" artifactId="avro" version="1.4.0-cassandra-1">
             <exclusion groupId="org.jboss.netty" artifactId="netty"/>
@@ -1002,7 +1002,7 @@ url=${svn.entry.url}?pathrev=${svn.entry.commit.revision}
         <jvmarg value="-Dstorage-config=${test.conf}"/>
         <jvmarg value="-Daccess.properties=${test.conf}/access.properties"/>
         <jvmarg value="-Dlog4j.configuration=log4j-junit.properties" />
-        <jvmarg value="-javaagent:${basedir}/lib/jamm-0.2.4.jar" />
+        <jvmarg value="-javaagent:${basedir}/lib/jamm-0.2.5.jar" />
         <jvmarg value="-ea"/>
         <optjvmargs/>
         <classpath>
diff --git a/conf/cassandra-env.sh b/conf/cassandra-env.sh
index 8a83b57e1f..c46845de38 100644
--- a/conf/cassandra-env.sh
+++ b/conf/cassandra-env.sh
@@ -100,7 +100,7 @@ JVM_OPTS="$JVM_OPTS -ea"
 check_openjdk=`"${JAVA:-java}" -version 2>&1 | awk '{if (NR == 2) {print $1}}'`
 if [ "$check_openjdk" != "OpenJDK" ]
 then
-    JVM_OPTS="$JVM_OPTS -javaagent:$CASSANDRA_HOME/lib/jamm-0.2.4.jar"
+    JVM_OPTS="$JVM_OPTS -javaagent:$CASSANDRA_HOME/lib/jamm-0.2.5.jar"
 fi
 
 # enable thread priorities, primarily so we can give periodic tasks
diff --git a/src/java/org/apache/cassandra/db/Memtable.java b/src/java/org/apache/cassandra/db/Memtable.java
index 16bbda0369..cd5d0272a3 100644
--- a/src/java/org/apache/cassandra/db/Memtable.java
+++ b/src/java/org/apache/cassandra/db/Memtable.java
@@ -21,10 +21,7 @@ package org.apache.cassandra.db;
 import java.io.File;
 import java.io.IOException;
 import java.nio.ByteBuffer;
-import java.util.Collection;
-import java.util.Comparator;
-import java.util.Iterator;
-import java.util.Map;
+import java.util.*;
 import java.util.concurrent.*;
 import java.util.concurrent.atomic.AtomicLong;
 
@@ -55,7 +52,6 @@ public class Memtable
     private static final double MIN_SANE_LIVE_RATIO = 1.0;
     // max liveratio seen w/ 1-byte columns on a 64-bit jvm was 19. If it gets higher than 64 something is probably broken.
     private static final double MAX_SANE_LIVE_RATIO = 64.0;
-    private static final MemoryMeter meter = new MemoryMeter().omitSharedBufferOverhead();
 
     // we're careful to only allow one count to run at a time because counting is slow
     // (can be minutes, for a large memtable and a busy server), so we could keep memtables
@@ -70,6 +66,8 @@ public class Memtable
         }
     };
 
+    private final MemoryMeter meter;
+
     volatile static Memtable activelyMeasuring;
 
     private volatile boolean isFrozen;
@@ -84,6 +82,18 @@ public class Memtable
     public Memtable(ColumnFamilyStore cfs)
     {
         this.cfs = cfs;
+
+        Callable<Set<Object>> provider = new Callable<Set<Object>>()
+        {
+            public Set<Object> call() throws Exception
+            {
+                // avoid counting this once for each row
+                Set<Object> set = Collections.newSetFromMap(new IdentityHashMap<Object, Boolean>());
+                set.add(Memtable.this.cfs.metadata);
+                return set;
+            }
+        };
+        meter = new MemoryMeter().omitSharedBufferOverhead().withTrackerProvider(provider);
     }
 
     public long getLiveSize()
