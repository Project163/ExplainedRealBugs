diff --git a/bin/cqlsh b/bin/cqlsh
index 842a313d5f..574d49b53e 100755
--- a/bin/cqlsh
+++ b/bin/cqlsh
@@ -1187,7 +1187,7 @@ class Shell(cmd.Cmd):
             for cf in ksdef.cf_defs:
                 out.write('\n')
                 # yes, cf might be looked up again. oh well.
-                self.print_recreate_columnfamily(ksname, cf.name, out)
+                self.print_recreate_columnfamily(ksdef.name, cf.name, out)
 
     def print_recreate_columnfamily(self, ksname, cfname, out):
         """
@@ -1201,13 +1201,9 @@ class Shell(cmd.Cmd):
         """
 
         # no metainfo available from system.schema_* for system CFs, so we have
-        # to use cfdef-based description for those.  also, use cfdef-based
-        # description when the CF doesn't have a composite key.  that seems like
-        # an ok compromise between hiding "comparator",
-        # "default_validation_class", etc for cql3, and still allowing users
-        # to work with old cql2-style wide tables.
+        # to use cfdef-based description for those.
 
-        if cfname != 'system' \
+        if ksname != 'system' \
         and self.cqlver_atleast(3):
             try:
                 layout = self.get_columnfamily_layout(ksname, cfname)
@@ -1215,8 +1211,7 @@ class Shell(cmd.Cmd):
                 # most likely a 1.1 beta where cql3 is supported, but not system.schema_*
                 pass
             else:
-                if len(layout.key_components) > 1:
-                    return self.print_recreate_columnfamily_from_layout(layout, out)
+                return self.print_recreate_columnfamily_from_layout(layout, out)
 
         cfdef = self.get_columnfamily(cfname, ksname=ksname)
         return self.print_recreate_columnfamily_from_cfdef(cfdef, out)
diff --git a/pylib/cqlshlib/cql3handling.py b/pylib/cqlshlib/cql3handling.py
index 2bc7ef9dfe..1628c66508 100644
--- a/pylib/cqlshlib/cql3handling.py
+++ b/pylib/cqlshlib/cql3handling.py
@@ -41,6 +41,17 @@ class Cql3ParsingRuleSet(CqlParsingRuleSet):
         'compact', 'storage', 'order', 'by', 'asc', 'desc', 'clustering', 'token'
     ))
 
+    columnfamily_options = (
+        # (CQL option name, Thrift option name (or None if same))
+        ('comment', None),
+        ('comparator', 'comparator_type'),
+        ('read_repair_chance', None),
+        ('gc_grace_seconds', None),
+        ('default_validation', 'default_validation_class'),
+        ('replicate_on_write', None),
+        ('compaction_strategy_class', 'compaction_strategy'),
+    )
+
     columnfamily_layout_options = (
         'comment',
         'bloom_filter_fp_chance',
@@ -48,8 +59,6 @@ class Cql3ParsingRuleSet(CqlParsingRuleSet):
         'read_repair_chance',
         # 'local_read_repair_chance',   -- not yet a valid cql option
         'gc_grace_seconds',
-        'min_compaction_threshold',
-        'max_compaction_threshold',
         'replicate_on_write',
         'compaction_strategy_class',
     )
@@ -90,7 +99,7 @@ class Cql3ParsingRuleSet(CqlParsingRuleSet):
     def cql3_escape_name(name):
         return '"%s"' % name.replace('"', '""')
 
-    valid_cql3_word_re = re.compile(r'^[a-z][0-9a-z_]*$', re.I)
+    valid_cql3_word_re = re.compile(r'^[a-z][0-9a-z_]*$')
 
     @classmethod
     def is_valid_cql3_name(cls, s):
