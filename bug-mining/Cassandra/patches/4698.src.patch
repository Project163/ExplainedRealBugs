diff --git a/CHANGES.txt b/CHANGES.txt
index ca79a01c59..b46eb50a3f 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -8,6 +8,7 @@
  * Propagate row deletions in 2i tables on upgrade (CASSANDRA-13320)
  * Slice.isEmpty() returns false for some empty slices (CASSANDRA-13305)
  * Add formatted row output to assertEmpty in CQL Tester (CASSANDRA-13238)
+ * Legacy caching options can prevent 3.0 upgrade (CASSANDRA-13384)
 Merged from 2.2:
  * Honor truststore-password parameter in cassandra-stress (CASSANDRA-12773)
  * Discard in-flight shadow round responses (CASSANDRA-12653)
diff --git a/src/java/org/apache/cassandra/schema/LegacySchemaMigrator.java b/src/java/org/apache/cassandra/schema/LegacySchemaMigrator.java
index 09af763491..ac9cfd9538 100644
--- a/src/java/org/apache/cassandra/schema/LegacySchemaMigrator.java
+++ b/src/java/org/apache/cassandra/schema/LegacySchemaMigrator.java
@@ -21,6 +21,7 @@ import java.nio.ByteBuffer;
 import java.util.*;
 import java.util.stream.Collectors;
 
+import com.google.common.annotations.VisibleForTesting;
 import com.google.common.collect.HashMultimap;
 import com.google.common.collect.ImmutableList;
 import org.slf4j.Logger;
@@ -472,7 +473,7 @@ public final class LegacySchemaMigrator
         if (row.has("memtable_flush_period_in_ms"))
             params.memtableFlushPeriodInMs(row.getInt("memtable_flush_period_in_ms"));
 
-        params.caching(CachingParams.fromMap(fromJsonMap(row.getString("caching"))));
+        params.caching(cachingFromRow(row.getString("caching")));
 
         if (row.has("default_time_to_live"))
             params.defaultTimeToLive(row.getInt("default_time_to_live"));
@@ -502,6 +503,32 @@ public final class LegacySchemaMigrator
         return params.build();
     }
 
+    /**
+     *
+     * 2.1 and newer use JSON'ified map of caching parameters, but older versions had valid Strings
+     * NONE, KEYS_ONLY, ROWS_ONLY, and ALL
+     *
+     * @param caching, the string representing the table's caching options
+     * @return CachingParams object corresponding to the input string
+     */
+    @VisibleForTesting
+    public static CachingParams cachingFromRow(String caching)
+    {
+        switch(caching)
+        {
+            case "NONE":
+                return CachingParams.CACHE_NOTHING;
+            case "KEYS_ONLY":
+                return CachingParams.CACHE_KEYS;
+            case "ROWS_ONLY":
+                return new CachingParams(false, Integer.MAX_VALUE);
+            case "ALL":
+                return CachingParams.CACHE_EVERYTHING;
+            default:
+                return CachingParams.fromMap(fromJsonMap(caching));
+        }
+    }
+
     /*
      * The method is needed - to migrate max_compaction_threshold and min_compaction_threshold
      * to the compaction map, where they belong.
diff --git a/test/unit/org/apache/cassandra/schema/LegacySchemaMigratorTest.java b/test/unit/org/apache/cassandra/schema/LegacySchemaMigratorTest.java
index 3676ca3e5e..fe91ddc7a8 100644
--- a/test/unit/org/apache/cassandra/schema/LegacySchemaMigratorTest.java
+++ b/test/unit/org/apache/cassandra/schema/LegacySchemaMigratorTest.java
@@ -23,6 +23,7 @@ import java.util.*;
 import java.util.stream.Collectors;
 
 import com.google.common.collect.ImmutableList;
+import org.junit.Assert;
 import org.junit.Test;
 
 import org.apache.cassandra.SchemaLoader;
@@ -96,6 +97,31 @@ public class LegacySchemaMigratorTest
         expected.forEach(LegacySchemaMigratorTest::verifyIndexBuildStatus);
     }
 
+    @Test
+    public void testMigrateLegacyCachingOptions() throws IOException
+    {
+        CQLTester.cleanupAndLeaveDirs();
+
+        assertEquals(CachingParams.CACHE_EVERYTHING, LegacySchemaMigrator.cachingFromRow("ALL"));
+        assertEquals(CachingParams.CACHE_NOTHING, LegacySchemaMigrator.cachingFromRow("NONE"));
+        assertEquals(CachingParams.CACHE_KEYS, LegacySchemaMigrator.cachingFromRow("KEYS_ONLY"));
+        assertEquals(new CachingParams(false, Integer.MAX_VALUE), LegacySchemaMigrator.cachingFromRow("ROWS_ONLY"));
+        assertEquals(CachingParams.CACHE_KEYS, LegacySchemaMigrator.cachingFromRow("{\"keys\" : \"ALL\", \"rows_per_partition\" : \"NONE\"}" ));
+        assertEquals(new CachingParams(false, Integer.MAX_VALUE), LegacySchemaMigrator.cachingFromRow("{\"keys\" : \"NONE\", \"rows_per_partition\" : \"ALL\"}" ));
+        assertEquals(new CachingParams(true, 100), LegacySchemaMigrator.cachingFromRow("{\"keys\" : \"ALL\", \"rows_per_partition\" : \"100\"}" ));
+
+        try
+        {
+            LegacySchemaMigrator.cachingFromRow("EXCEPTION");
+            Assert.fail();
+        }
+        catch(RuntimeException e)
+        {
+            // Expected passing path
+            assertTrue(true);
+        }
+    }
+
     private static void loadLegacySchemaTables()
     {
         KeyspaceMetadata systemKeyspace = Schema.instance.getKSMetaData(SystemKeyspace.NAME);
