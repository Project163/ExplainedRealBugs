diff --git a/CHANGES.txt b/CHANGES.txt
index d111d11b00..e5e2b9cae3 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 3.0.9
+ * select_distinct_with_deletions_test failing on non-vnode environments (CASSANDRA-11126)
  * Stack Overflow returned to queries while upgrading (CASSANDRA-12527)
  * Fix legacy regex for temporary files from 2.2 (CASSANDRA-12565)
  * Add option to state current gc_grace_seconds to tools/bin/sstablemetadata (CASSANDRA-12208)
diff --git a/src/java/org/apache/cassandra/db/ReadCommand.java b/src/java/org/apache/cassandra/db/ReadCommand.java
index 36969f8bf8..c1762f19e2 100644
--- a/src/java/org/apache/cassandra/db/ReadCommand.java
+++ b/src/java/org/apache/cassandra/db/ReadCommand.java
@@ -744,7 +744,7 @@ public abstract class ReadCommand implements ReadQuery
                     out.writeInt(LegacyReadCommandSerializer.updateLimitForQuery(rangeCommand.limits().count(), filter.requestedSlices()));
 
                 int compositesToGroup;
-                boolean selectsStatics = !rangeCommand.columnFilter().fetchedColumns().statics.isEmpty() || filter.requestedSlices().selects(Clustering.STATIC_CLUSTERING);
+                boolean selectsStatics = !rangeCommand.columnFilter().fetchedColumns().statics.isEmpty() && filter.requestedSlices().selects(Clustering.STATIC_CLUSTERING);
                 if (limits.kind() == DataLimits.Kind.THRIFT_LIMIT)
                     compositesToGroup = -1;
                 else if (limits.isDistinct() && !selectsStatics)
diff --git a/src/java/org/apache/cassandra/service/pager/PagingState.java b/src/java/org/apache/cassandra/service/pager/PagingState.java
index 611523fd0f..30e14c3c50 100644
--- a/src/java/org/apache/cassandra/service/pager/PagingState.java
+++ b/src/java/org/apache/cassandra/service/pager/PagingState.java
@@ -213,7 +213,10 @@ public class PagingState
                 Iterator<Cell> cells = row.cellsInLegacyOrder(metadata, true).iterator();
                 if (!cells.hasNext())
                 {
-                    mark = LegacyLayout.encodeClustering(metadata, row.clustering());
+                    // If the last returned row has no cell, this means in 2.1/2.2 terms that we stopped on the row
+                    // marker. Note that this shouldn't happen if the table is COMPACT.
+                    assert !metadata.isCompactTable();
+                    mark = LegacyLayout.encodeCellName(metadata, row.clustering(), ByteBufferUtil.EMPTY_BYTE_BUFFER, null);
                 }
                 else
                 {
@@ -258,7 +261,7 @@ public class PagingState
         @Override
         public String toString()
         {
-            return ByteBufferUtil.bytesToHex(mark);
+            return mark == null ? "null" : ByteBufferUtil.bytesToHex(mark);
         }
     }
 }
