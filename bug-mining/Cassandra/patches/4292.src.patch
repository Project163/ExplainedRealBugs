diff --git a/CHANGES.txt b/CHANGES.txt
index f2276f0831..7215836185 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 2.2.7
+ * Fix possible race condition in CommitLog.recover (CASSANDRA-11743)
  * Enable client encryption in sstableloader with cli options (CASSANDRA-11708)
  * Possible memory leak in NIODataInputStream (CASSANDRA-11867)
  * Fix commit log replay after out-of-order flush completion (CASSANDRA-9669)
diff --git a/src/java/org/apache/cassandra/db/commitlog/CommitLog.java b/src/java/org/apache/cassandra/db/commitlog/CommitLog.java
index 7592f48169..9a6ba34480 100644
--- a/src/java/org/apache/cassandra/db/commitlog/CommitLog.java
+++ b/src/java/org/apache/cassandra/db/commitlog/CommitLog.java
@@ -130,11 +130,6 @@ public class CommitLog implements CommitLogMBean
         if (allocator.createReserveSegments)
             return 0;
 
-        // Allocator could be in the process of initial startup with 0 active and available segments. We need to wait for
-        // the allocation manager to finish allocation and add it to available segments so we don't get an invalid response
-        // on allocator.manages(...) below by grabbing a file off the filesystem before it's added to the CLQ.
-        allocator.allocatingFrom();
-
         FilenameFilter unmanagedFilesFilter = new FilenameFilter()
         {
             public boolean accept(File dir, String name)
@@ -142,7 +137,7 @@ public class CommitLog implements CommitLogMBean
                 // we used to try to avoid instantiating commitlog (thus creating an empty segment ready for writes)
                 // until after recover was finished.  this turns out to be fragile; it is less error-prone to go
                 // ahead and allow writes before recover(), and just skip active segments when we do.
-                return CommitLogDescriptor.isValid(name) && !allocator.manages(name);
+                return CommitLogDescriptor.isValid(name) && CommitLogSegment.shouldReplay(name);
             }
         };
 
@@ -435,6 +430,7 @@ public class CommitLog implements CommitLogMBean
             throw new RuntimeException(e);
         }
         allocator.stopUnsafe(deleteSegments);
+        CommitLogSegment.resetReplayLimit();
     }
 
     /**
diff --git a/src/java/org/apache/cassandra/db/commitlog/CommitLogSegment.java b/src/java/org/apache/cassandra/db/commitlog/CommitLogSegment.java
index d748006794..b6801d2fc5 100644
--- a/src/java/org/apache/cassandra/db/commitlog/CommitLogSegment.java
+++ b/src/java/org/apache/cassandra/db/commitlog/CommitLogSegment.java
@@ -64,6 +64,7 @@ public abstract class CommitLogSegment
 
     private final static long idBase;
     private final static AtomicInteger nextId = new AtomicInteger(1);
+    private static long replayLimitId;
     static
     {
         long maxId = Long.MIN_VALUE;
@@ -72,7 +73,7 @@ public abstract class CommitLogSegment
             if (CommitLogDescriptor.isValid(file.getName()))
                 maxId = Math.max(CommitLogDescriptor.fromFileName(file.getName()).id, maxId);
         }
-        idBase = Math.max(System.currentTimeMillis(), maxId + 1);
+        replayLimitId = idBase = Math.max(System.currentTimeMillis(), maxId + 1);
     }
 
     // The commit log entry overhead in bytes (int: length + int: head checksum + int: tail checksum)
@@ -184,6 +185,19 @@ public abstract class CommitLogSegment
         }
     }
 
+    static boolean shouldReplay(String name)
+    {
+        return CommitLogDescriptor.fromFileName(name).id < replayLimitId;
+    }
+
+    /**
+     * FOR TESTING PURPOSES.
+     */
+    static void resetReplayLimit()
+    {
+        replayLimitId = getNextId();
+    }
+
     // allocate bytes in the segment, or return -1 if not enough space
     private int allocate(int size)
     {
