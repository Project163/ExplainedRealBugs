diff --git a/CHANGES.txt b/CHANGES.txt
index fb881de5a3..95a6802903 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 4.0-alpha4
+ * Only track ideal CL failure when request CL met (CASSANDRA-15696)
  * Fix flaky CoordinatorMessagingTest and docstring in OutboundSink and ConsistentSession (CASSANDRA-15672)
  * Fix force compaction of wrapping ranges (CASSANDRA-15664)
  * Expose repair streaming metrics (CASSANDRA-15656)
diff --git a/src/java/org/apache/cassandra/service/AbstractWriteResponseHandler.java b/src/java/org/apache/cassandra/service/AbstractWriteResponseHandler.java
index 1889c79c28..b1eb5b31dd 100644
--- a/src/java/org/apache/cassandra/service/AbstractWriteResponseHandler.java
+++ b/src/java/org/apache/cassandra/service/AbstractWriteResponseHandler.java
@@ -73,6 +73,11 @@ public abstract class AbstractWriteResponseHandler<T> implements RequestCallback
       */
     private AbstractWriteResponseHandler idealCLDelegate;
 
+    /**
+     * We don't want to increment the writeFailedIdealCL if we didn't achieve the original requested CL
+     */
+    private boolean requestedCLAchieved = false;
+
     /**
      * @param callback           A callback to be called when the write is successful.
      * @param queryStartNanoTime
@@ -232,6 +237,13 @@ public abstract class AbstractWriteResponseHandler<T> implements RequestCallback
 
     protected void signal()
     {
+        //The ideal CL should only count as a strike if the requested CL was achieved.
+        //If the requested CL is not achieved it's fine for the ideal CL to also not be achieved.
+        if (idealCLDelegate != null)
+        {
+            idealCLDelegate.requestedCLAchieved = true;
+        }
+
         condition.signalAll();
         if (callback != null)
             callback.run();
@@ -279,8 +291,9 @@ public abstract class AbstractWriteResponseHandler<T> implements RequestCallback
         int decrementedValue = responsesAndExpirations.decrementAndGet();
         if (decrementedValue == 0)
         {
-            //The condition being signaled is a valid proxy for the CL being achieved
-            if (!condition.isSignaled())
+            // The condition being signaled is a valid proxy for the CL being achieved
+            // Only mark it as failed if the requested CL was achieved.
+            if (!condition.isSignaled() && requestedCLAchieved)
             {
                 replicaPlan.keyspace().metric.writeFailedIdealCL.inc();
             }
diff --git a/test/unit/org/apache/cassandra/service/WriteResponseHandlerTest.java b/test/unit/org/apache/cassandra/service/WriteResponseHandlerTest.java
index f06b706c68..5d8d19107a 100644
--- a/test/unit/org/apache/cassandra/service/WriteResponseHandlerTest.java
+++ b/test/unit/org/apache/cassandra/service/WriteResponseHandlerTest.java
@@ -232,6 +232,32 @@ public class WriteResponseHandlerTest
         assertEquals(0, ks.metric.idealCLWriteLatency.totalLatency.getCount());
     }
 
+    /**
+     * Validate that failing to achieve ideal CL doesn't increase the failure counter when not meeting CL
+     * @throws Throwable
+     */
+    @Test
+    public void failedIdealCLDoesNotIncrementsStatOnQueryFailure() throws Throwable
+    {
+        AbstractWriteResponseHandler awr = createWriteResponseHandler(ConsistencyLevel.LOCAL_QUORUM, ConsistencyLevel.EACH_QUORUM);
+
+        long startingCount = ks.metric.writeFailedIdealCL.getCount();
+
+        // Failure in local DC
+        awr.onResponse(createDummyMessage(0));
+        
+        awr.expired();
+        awr.expired();
+
+        //Fail in remote DC
+        awr.expired();
+        awr.expired();
+        awr.expired();
+
+        assertEquals(startingCount, ks.metric.writeFailedIdealCL.getCount());
+    }
+
+
     private static AbstractWriteResponseHandler createWriteResponseHandler(ConsistencyLevel cl, ConsistencyLevel ideal)
     {
         return createWriteResponseHandler(cl, ideal, System.nanoTime());
