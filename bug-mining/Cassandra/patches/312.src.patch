diff --git a/src/java/org/apache/cassandra/db/migration/AddColumnFamily.java b/src/java/org/apache/cassandra/db/migration/AddColumnFamily.java
index d6d6ceeab3..2fc7c743e6 100644
--- a/src/java/org/apache/cassandra/db/migration/AddColumnFamily.java
+++ b/src/java/org/apache/cassandra/db/migration/AddColumnFamily.java
@@ -77,11 +77,13 @@ public class AddColumnFamily extends Migration
         // reinitialize the table.
         KSMetaData ksm = DatabaseDescriptor.getTableDefinition(cfm.tableName);
         ksm = makeNewKeyspaceDefinition(ksm);
-        Table.open(ksm.name).initCf(cfm.cfId, cfm.cfName);
+        if (!clientMode)
+            Table.open(ksm.name).initCf(cfm.cfId, cfm.cfName);
         DatabaseDescriptor.setTableDefinition(ksm, newVersion);
         
-        // force creation of a new commit log segment.
-        CommitLog.instance().forceNewSegment();    
+        if (!clientMode)
+            // force creation of a new commit log segment.
+            CommitLog.instance().forceNewSegment();
     }
 
     @Override
diff --git a/src/java/org/apache/cassandra/db/migration/AddKeyspace.java b/src/java/org/apache/cassandra/db/migration/AddKeyspace.java
index db54982baf..6682fd135c 100644
--- a/src/java/org/apache/cassandra/db/migration/AddKeyspace.java
+++ b/src/java/org/apache/cassandra/db/migration/AddKeyspace.java
@@ -69,8 +69,11 @@ public class AddKeyspace extends Migration
         DatabaseDescriptor.setTableDefinition(ksm, newVersion);
         // these definitions could have come from somewhere else.
         CFMetaData.fixMaxId();
-        Table.open(ksm.name);
-        CommitLog.instance().forceNewSegment();
+        if (!clientMode)
+        {
+            Table.open(ksm.name);
+            CommitLog.instance().forceNewSegment();
+        }
     }
     
     private static final class Serializer implements ICompactSerializer<AddKeyspace>
diff --git a/src/java/org/apache/cassandra/db/migration/DropColumnFamily.java b/src/java/org/apache/cassandra/db/migration/DropColumnFamily.java
index 528ec597ed..b579405197 100644
--- a/src/java/org/apache/cassandra/db/migration/DropColumnFamily.java
+++ b/src/java/org/apache/cassandra/db/migration/DropColumnFamily.java
@@ -87,6 +87,8 @@ public class DropColumnFamily extends Migration
     @Override
     public void beforeApplyModels()
     {
+        if (clientMode)
+            return;
         ColumnFamilyStore cfs = Table.open(tableName).getColumnFamilyStore(cfName);
         cfs.snapshot(Table.getTimestampedSnapshotName(null));
     }
@@ -106,15 +108,19 @@ public class DropColumnFamily extends Migration
         KSMetaData ksm = makeNewKeyspaceDefinition(existing);
         CFMetaData.purge(cfm);
         DatabaseDescriptor.setTableDefinition(ksm, newVersion);
-        Table.open(ksm.name).dropCf(cfm.cfId);
         
-        // indicate that some files need to be deleted (eventually)
-        SystemTable.markForRemoval(cfm);
-        
-        // we don't really need a new segment, but let's force it to be consistent with other operations.
-        CommitLog.instance().forceNewSegment();
-
-        Migration.cleanupDeadFiles(blockOnFileDeletion);   
+        if (!clientMode)
+        {
+            Table.open(ksm.name).dropCf(cfm.cfId);
+            
+            // indicate that some files need to be deleted (eventually)
+            SystemTable.markForRemoval(cfm);
+            
+            // we don't really need a new segment, but let's force it to be consistent with other operations.
+            CommitLog.instance().forceNewSegment();
+    
+            Migration.cleanupDeadFiles(blockOnFileDeletion);
+        }
     }
     
     private static final class Serializer implements ICompactSerializer<DropColumnFamily>
diff --git a/src/java/org/apache/cassandra/db/migration/DropKeyspace.java b/src/java/org/apache/cassandra/db/migration/DropKeyspace.java
index ae789a59f8..d2198ae46c 100644
--- a/src/java/org/apache/cassandra/db/migration/DropKeyspace.java
+++ b/src/java/org/apache/cassandra/db/migration/DropKeyspace.java
@@ -70,7 +70,8 @@ public class DropKeyspace extends Migration
     @Override
     public void beforeApplyModels()
     {
-        Table.open(name).snapshot(null);
+        if (!clientMode)
+            Table.open(name).snapshot(null);
     }
 
     @Override
@@ -86,17 +87,24 @@ public class DropKeyspace extends Migration
         for (CFMetaData cfm : ksm.cfMetaData().values())
         {
             CFMetaData.purge(cfm);
-            table.dropCf(cfm.cfId);
-            SystemTable.markForRemoval(cfm);
+            if (!clientMode)
+            {
+                table.dropCf(cfm.cfId);
+                SystemTable.markForRemoval(cfm);
+            }
         }
                         
         // reset defs.
         DatabaseDescriptor.clearTableDefinition(ksm, newVersion);
-        CommitLog.instance().forceNewSegment();
-        Migration.cleanupDeadFiles(blockOnFileDeletion);
         
-        // clear up any local hinted data for this keyspace.
-        HintedHandOffManager.renameHints(name, null);
+        if (!clientMode)
+        {
+            CommitLog.instance().forceNewSegment();
+            Migration.cleanupDeadFiles(blockOnFileDeletion);
+            
+            // clear up any local hinted data for this keyspace.
+            HintedHandOffManager.renameHints(name, null);
+        }
     }
     
     private static final class Serializer implements ICompactSerializer<DropKeyspace>
diff --git a/src/java/org/apache/cassandra/db/migration/Migration.java b/src/java/org/apache/cassandra/db/migration/Migration.java
index 0d7677fc36..66cb51b8eb 100644
--- a/src/java/org/apache/cassandra/db/migration/Migration.java
+++ b/src/java/org/apache/cassandra/db/migration/Migration.java
@@ -18,21 +18,17 @@
 
 package org.apache.cassandra.db.migration;
 
-import org.apache.cassandra.concurrent.StageManager;
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.config.KSMetaData;
 import org.apache.cassandra.db.ColumnFamily;
 import org.apache.cassandra.db.ColumnFamilyStore;
 import org.apache.cassandra.db.CompactionManager;
 import org.apache.cassandra.db.DecoratedKey;
-import org.apache.cassandra.db.DefsTable;
 import org.apache.cassandra.db.IColumn;
 import org.apache.cassandra.db.RowMutation;
 import org.apache.cassandra.db.Table;
-import org.apache.cassandra.db.filter.NamesQueryFilter;
 import org.apache.cassandra.db.filter.QueryFilter;
 import org.apache.cassandra.db.filter.QueryPath;
-import org.apache.cassandra.db.filter.SliceQueryFilter;
 import org.apache.cassandra.gms.ApplicationState;
 import org.apache.cassandra.gms.Gossiper;
 import org.apache.cassandra.io.ICompactSerializer;
@@ -41,7 +37,6 @@ import org.apache.cassandra.service.StorageService;
 import org.apache.cassandra.utils.UUIDGen;
 import static org.apache.cassandra.utils.FBUtilities.UTF8;
 
-import org.apache.commons.lang.StringUtils;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -50,8 +45,6 @@ import java.io.DataInputStream;
 import java.io.DataOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
-import java.io.OutputStream;
-import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
 import java.util.Collection;
 import java.util.UUID;
@@ -89,10 +82,14 @@ public abstract class Migration
     protected final UUID newVersion;
     protected UUID lastVersion;
     
+    // this doesn't follow the serialized migration around.
+    protected final transient boolean clientMode;
+    
     Migration(UUID newVersion, UUID lastVersion)
     {
         this.newVersion = newVersion;
         this.lastVersion = lastVersion;
+        clientMode = StorageService.instance.isClientMode();
     }
 
     /** override this to perform logic before writing the migration or applying it.  defaults to nothing. */
@@ -106,37 +103,41 @@ public abstract class Migration
             throw new IOException("Previous version mismatch. cannot apply.");
         // write to schema
         assert rm != null;
-        rm.apply();
+        if (!clientMode)
+            rm.apply();
 
         beforeApplyModels();
         
         // write migration.
-        long now = System.currentTimeMillis();
-        byte[] buf = getBytes();
-        RowMutation migration = new RowMutation(Table.DEFINITIONS, MIGRATIONS_KEY);
-        migration.add(new QueryPath(MIGRATIONS_CF, null, UUIDGen.decompose(newVersion)), buf, now);
-        migration.apply();
-        
-        // note that we storing this in the system table, which is not replicated, instead of the definitions table, which is.
-        logger.debug("Applying migration " + newVersion.toString());
-        migration = new RowMutation(Table.DEFINITIONS, LAST_MIGRATION_KEY);
-        migration.add(new QueryPath(SCHEMA_CF, null, LAST_MIGRATION_KEY), UUIDGen.decompose(newVersion), now);
-        migration.apply();
-        
-        // flush changes out of memtables so we don't need to rely on the commit log.
-        for (Future f : Table.open(Table.DEFINITIONS).flush())
+        if (!clientMode)
         {
-            try
-            {
-                f.get();
-            }
-            catch (InterruptedException e)
-            {
-                throw new IOException(e);
-            }
-            catch (ExecutionException e)
+            long now = System.currentTimeMillis();
+            byte[] buf = getBytes();
+            RowMutation migration = new RowMutation(Table.DEFINITIONS, MIGRATIONS_KEY);
+            migration.add(new QueryPath(MIGRATIONS_CF, null, UUIDGen.decompose(newVersion)), buf, now);
+            migration.apply();
+            
+            // note that we storing this in the system table, which is not replicated, instead of the definitions table, which is.
+            logger.debug("Applying migration " + newVersion.toString());
+            migration = new RowMutation(Table.DEFINITIONS, LAST_MIGRATION_KEY);
+            migration.add(new QueryPath(SCHEMA_CF, null, LAST_MIGRATION_KEY), UUIDGen.decompose(newVersion), now);
+            migration.apply();
+        
+            // flush changes out of memtables so we don't need to rely on the commit log.
+            for (Future f : Table.open(Table.DEFINITIONS).flush())
             {
-                throw new IOException(e);
+                try
+                {
+                    f.get();
+                }
+                catch (InterruptedException e)
+                {
+                    throw new IOException(e);
+                }
+                catch (ExecutionException e)
+                {
+                    throw new IOException(e);
+                }
             }
         }
         
@@ -145,6 +146,9 @@ public abstract class Migration
     
     public final void announce()
     {
+        if (StorageService.instance.isClientMode())
+            return;
+        
         // immediate notification for esiting nodes.
         MigrationManager.announce(newVersion, Gossiper.instance.getLiveMembers());
         // this is for notifying nodes as they arrive in the cluster.
diff --git a/src/java/org/apache/cassandra/db/migration/RenameColumnFamily.java b/src/java/org/apache/cassandra/db/migration/RenameColumnFamily.java
index 952c7616fc..8626f405a6 100644
--- a/src/java/org/apache/cassandra/db/migration/RenameColumnFamily.java
+++ b/src/java/org/apache/cassandra/db/migration/RenameColumnFamily.java
@@ -105,14 +105,18 @@ public class RenameColumnFamily extends Migration
     {
         // leave it up to operators to ensure there are no writes going on durng the file rename. Just know that
         // attempting row mutations on oldcfName right now would be really bad.
-        renameCfStorageFiles(tableName, oldName, newName);
+        if (!clientMode)
+            renameCfStorageFiles(tableName, oldName, newName);
         
         // reset defs.
         KSMetaData ksm = makeNewKeyspaceDefinition(DatabaseDescriptor.getTableDefinition(tableName));
         DatabaseDescriptor.setTableDefinition(ksm, newVersion);
-        Table.open(ksm.name).renameCf(cfId, newName);
         
-        CommitLog.instance().forceNewSegment();
+        if (!clientMode)
+        {
+            Table.open(ksm.name).renameCf(cfId, newName);
+            CommitLog.instance().forceNewSegment();
+        }
     }
     
     // if this errors out, we are in a world of hurt.
diff --git a/src/java/org/apache/cassandra/db/migration/RenameKeyspace.java b/src/java/org/apache/cassandra/db/migration/RenameKeyspace.java
index b3d8c79dd4..5058b6d99e 100644
--- a/src/java/org/apache/cassandra/db/migration/RenameKeyspace.java
+++ b/src/java/org/apache/cassandra/db/migration/RenameKeyspace.java
@@ -80,7 +80,8 @@ public class RenameKeyspace extends Migration
     @Override
     public void applyModels() throws IOException
     {
-        renameKsStorageFiles(oldName, newName);
+        if (!clientMode)
+            renameKsStorageFiles(oldName, newName);
         
         KSMetaData oldKsm = DatabaseDescriptor.getTableDefinition(oldName);
         KSMetaData newKsm = KSMetaData.rename(oldKsm, newName, true);
@@ -88,12 +89,16 @@ public class RenameKeyspace extends Migration
         // it helps if the node is reasonably quiescent with respect to this ks.
         DatabaseDescriptor.clearTableDefinition(oldKsm, newVersion);
         DatabaseDescriptor.setTableDefinition(newKsm, newVersion);
-        Table.clear(oldKsm.name);
-        Table.open(newName);
-        // this isn't strictly necessary since the set of all cfs was not modified.
-        CommitLog.instance().forceNewSegment();
-
-        HintedHandOffManager.renameHints(oldName, newName);
+        
+        if (!clientMode)
+        {
+            Table.clear(oldKsm.name);
+            Table.open(newName);
+            // this isn't strictly necessary since the set of all cfs was not modified.
+            CommitLog.instance().forceNewSegment();
+    
+            HintedHandOffManager.renameHints(oldName, newName);
+        }
     }
     
     private static void renameKsStorageFiles(String oldKs, String newKs) throws IOException
diff --git a/src/java/org/apache/cassandra/service/StorageService.java b/src/java/org/apache/cassandra/service/StorageService.java
index 825cb8e94b..9c96c09922 100644
--- a/src/java/org/apache/cassandra/service/StorageService.java
+++ b/src/java/org/apache/cassandra/service/StorageService.java
@@ -18,6 +18,7 @@
 
 package org.apache.cassandra.service;
 
+import java.io.IOError;
 import java.io.IOException;
 import java.lang.management.ManagementFactory;
 import java.lang.reflect.Constructor;
@@ -306,6 +307,17 @@ public class StorageService implements IEndpointStateChangeSubscriber, StorageSe
         Gossiper.instance.register(this);
         Gossiper.instance.start(FBUtilities.getLocalAddress(), (int)(System.currentTimeMillis() / 1000)); // needed for node-ring gathering.
         setMode("Client", false);
+        
+        // sleep a while to allow gossip to warm up (the other nodes need to know about this one before they can reply).
+        try
+        {
+            Thread.sleep(5000L);
+        }
+        catch (Exception ex)
+        {
+            throw new IOError(ex);
+        }
+        MigrationManager.announce(DatabaseDescriptor.getDefsVersion(), DatabaseDescriptor.getSeeds());
     }
 
     public synchronized void initServer() throws IOException
