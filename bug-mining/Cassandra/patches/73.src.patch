diff --git a/src/java/org/apache/cassandra/db/Memtable.java b/src/java/org/apache/cassandra/db/Memtable.java
index 70f4d32664..d632fb7021 100644
--- a/src/java/org/apache/cassandra/db/Memtable.java
+++ b/src/java/org/apache/cassandra/db/Memtable.java
@@ -365,9 +365,8 @@ public class Memtable implements Comparable<Memtable>
 
     public ColumnIterator getNamesIterator(final NamesQueryFilter filter)
     {
-        ColumnFamily cf = columnFamilies_.get(filter.key);
+        final ColumnFamily cf = columnFamilies_.get(filter.key);
         final ColumnFamily columnFamily = cf == null ? ColumnFamily.create(table_, filter.getColumnFamilyName()) : cf.cloneMeShallow();
-        final Map<String, IColumn> columnsContainer = cf == null ? null : cf.getColumns();
 
         return new SimpleAbstractColumnIterator()
         {
@@ -381,14 +380,14 @@ public class Memtable implements Comparable<Memtable>
 
             protected IColumn computeNext()
             {
-                if (columnsContainer == null)
+                if (cf == null)
                 {
                     return endOfData();
                 }
                 while (iter.hasNext())
                 {
                     current = iter.next();
-                    IColumn column = columnsContainer.get(current);
+                    IColumn column = cf.getColumn(current);
                     if (column != null)
                         return column;
                 }
@@ -397,6 +396,38 @@ public class Memtable implements Comparable<Memtable>
         };
     }
 
+    public ColumnIterator getTimeIterator(final TimeQueryFilter filter)
+    {
+        final ColumnFamily cf = columnFamilies_.get(filter.key);
+        final ColumnFamily columnFamily = cf == null ? ColumnFamily.create(table_, filter.getColumnFamilyName()) : cf.cloneMeShallow();
+
+        return new SimpleAbstractColumnIterator()
+        {
+            private Iterator<IColumn> iter = cf == null ? null : cf.getAllColumns().iterator();
+
+            public ColumnFamily getColumnFamily()
+            {
+                return columnFamily;
+            }
+
+            protected IColumn computeNext()
+            {
+                if (iter == null)
+                {
+                    return endOfData();
+                }
+                while (iter.hasNext())
+                {
+                    IColumn column = iter.next();
+                    if (column.timestamp() < filter.since)
+                        break;
+                    return column;
+                }
+                return endOfData();
+            }
+        };
+    }
+
     void clearUnsafe()
     {
         columnFamilies_.clear();
diff --git a/src/java/org/apache/cassandra/db/Table.java b/src/java/org/apache/cassandra/db/Table.java
index fd6dc55c27..3072adfaec 100644
--- a/src/java/org/apache/cassandra/db/Table.java
+++ b/src/java/org/apache/cassandra/db/Table.java
@@ -46,6 +46,7 @@ import org.apache.cassandra.utils.*;
 import org.apache.cassandra.db.filter.QueryFilter;
 import org.apache.cassandra.db.filter.SliceQueryFilter;
 import org.apache.cassandra.db.filter.NamesQueryFilter;
+import org.apache.cassandra.db.filter.TimeQueryFilter;
 
 import org.apache.log4j.Logger;
 
@@ -550,19 +551,10 @@ public class Table
         return row;
     }
     
-    public Row getRow(String key, String cf, long sinceTimeStamp) throws IOException
+    public Row getRow(String key, String columnFamilyColumn, long sinceTimeStamp) throws IOException
     {
-        Row row = new Row(table_, key);
-        String[] values = RowMutation.getColumnAndColumnFamily(cf);
-        ColumnFamilyStore cfStore = columnFamilyStores_.get(values[0]);
-        long start1 = System.currentTimeMillis();
-        assert cfStore != null : "Column family " + cf + " has not been defined";
-        ColumnFamily columnFamily = cfStore.getColumnFamily(key, cf, new TimeFilter(sinceTimeStamp));
-        if ( columnFamily != null )
-            row.addColumnFamily(columnFamily);
-        long timeTaken = System.currentTimeMillis() - start1;
-        dbAnalyticsSource_.updateReadStatistics(timeTaken);
-        return row;
+        QueryFilter filter = new TimeQueryFilter(key, columnFamilyColumn, sinceTimeStamp);
+        return getRow(key, filter);
     }
 
     /**
diff --git a/src/java/org/apache/cassandra/db/TimeFilter.java b/src/java/org/apache/cassandra/db/TimeFilter.java
deleted file mode 100644
index ba06d0da36..0000000000
--- a/src/java/org/apache/cassandra/db/TimeFilter.java
+++ /dev/null
@@ -1,127 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.cassandra.db;
-
-import java.io.DataInputStream;
-import java.io.IOException;
-import java.util.Collection;
-
-import org.apache.cassandra.io.DataInputBuffer;
-import org.apache.cassandra.io.IndexHelper;
-import org.apache.cassandra.io.SSTableReader;
-
-
-/**
- * This class provides a filter for filtering out columns
- * that are older than a specific time.
- *
- * @author pmalik
- */
-class TimeFilter implements IFilter
-{
-    private long timeLimit_;
-
-    TimeFilter(long timeLimit)
-    {
-        timeLimit_ = timeLimit;
-    }
-
-    public ColumnFamily filter(String cf, ColumnFamily columnFamily)
-    {
-        if (columnFamily == null)
-            return null;
-
-        String[] values = RowMutation.getColumnAndColumnFamily(cf);
-        ColumnFamily filteredCf = columnFamily.cloneMeShallow();
-        if (values.length == 1 && !columnFamily.isSuper())
-        {
-            Collection<IColumn> columns = columnFamily.getAllColumns();
-            for (IColumn column : columns)
-            {
-                if (column.timestamp() >= timeLimit_)
-                {
-                    filteredCf.addColumn(column);
-                }
-                else
-                {
-                    break;
-                }
-            }
-        }
-        else if (values.length == 2 && columnFamily.isSuper())
-        {
-            /*
-                * TODO : For super columns we need to re-visit this issue.
-                * For now this function will set done to true if we are done with
-                * at least one super column
-                */
-            Collection<IColumn> columns = columnFamily.getAllColumns();
-            for (IColumn column : columns)
-            {
-                SuperColumn superColumn = (SuperColumn) column;
-                SuperColumn filteredSuperColumn = superColumn.cloneMeShallow();
-                filteredCf.addColumn(filteredSuperColumn);
-                Collection<IColumn> subColumns = superColumn.getSubColumns();
-                for (IColumn subColumn : subColumns)
-                {
-                    if (subColumn.timestamp() >= timeLimit_)
-                    {
-                        filteredSuperColumn.addColumn(subColumn);
-                    }
-                    else
-                    {
-                        break;
-                    }
-                }
-            }
-        }
-        else
-        {
-            throw new UnsupportedOperationException();
-        }
-        return filteredCf;
-    }
-
-    public IColumn filter(IColumn column, DataInputStream dis) throws IOException
-    {
-        long timeStamp = 0;
-        /*
-           * If its a column instance we need the timestamp to verify if
-           * it should be filtered , but at this instance the timestamp is not read
-           * so we read the timestamp and set the buffer back so that the rest of deserialization
-           * logic does not change.
-           */
-        if (column instanceof Column)
-        {
-            dis.mark(1000);
-            dis.readBoolean();
-            timeStamp = dis.readLong();
-            dis.reset();
-            if (timeStamp < timeLimit_)
-            {
-                return null;
-            }
-        }
-        return column;
-    }
-
-    public DataInputBuffer next(String key, String cfName, SSTableReader ssTable) throws IOException
-    {
-        return ssTable.next(key, cfName, null, new IndexHelper.TimeRange(timeLimit_, Long.MAX_VALUE));
-    }
-}
diff --git a/src/java/org/apache/cassandra/db/filter/SSTableNamesIterator.java b/src/java/org/apache/cassandra/db/filter/SSTableNamesIterator.java
index 8cb5c1b5f5..cfebffc430 100644
--- a/src/java/org/apache/cassandra/db/filter/SSTableNamesIterator.java
+++ b/src/java/org/apache/cassandra/db/filter/SSTableNamesIterator.java
@@ -21,8 +21,11 @@ public class SSTableNamesIterator extends SimpleAbstractColumnIterator
         this.columns = columns;
         SSTableReader ssTable = SSTableReader.open(filename);
         DataInputBuffer buffer = ssTable.next(key, cfName, columns);
-        cf = ColumnFamily.serializer().deserialize(buffer);
-        iter = cf.getAllColumns().iterator();
+        if (buffer.getLength() > 0)
+        {
+            cf = ColumnFamily.serializer().deserialize(buffer);
+            iter = cf.getAllColumns().iterator();
+        }
     }
 
     public ColumnFamily getColumnFamily()
diff --git a/src/java/org/apache/cassandra/db/filter/SSTableTimeIterator.java b/src/java/org/apache/cassandra/db/filter/SSTableTimeIterator.java
new file mode 100644
index 0000000000..1ba5deba0f
--- /dev/null
+++ b/src/java/org/apache/cassandra/db/filter/SSTableTimeIterator.java
@@ -0,0 +1,48 @@
+package org.apache.cassandra.db.filter;
+
+import java.util.Iterator;
+import java.io.IOException;
+
+import org.apache.cassandra.db.ColumnFamily;
+import org.apache.cassandra.db.IColumn;
+import org.apache.cassandra.io.SSTableReader;
+import org.apache.cassandra.io.DataInputBuffer;
+import org.apache.cassandra.io.IndexHelper;
+
+public class SSTableTimeIterator extends SimpleAbstractColumnIterator
+{
+    private ColumnFamily cf;
+    private Iterator<IColumn> iter;
+    public final long since;
+
+    public SSTableTimeIterator(String filename, String key, String cfName, long since) throws IOException
+    {
+        this.since = since;
+        SSTableReader ssTable = SSTableReader.open(filename);
+        DataInputBuffer buffer = ssTable.next(key, cfName, null, new IndexHelper.TimeRange(since, Long.MAX_VALUE));
+        if (buffer.getLength() > 0)
+        {
+            cf = ColumnFamily.serializer().deserialize(buffer);
+            iter = cf.getAllColumns().iterator();
+        }
+    }
+
+    public ColumnFamily getColumnFamily()
+    {
+        return cf;
+    }
+
+    protected IColumn computeNext()
+    {
+        if (iter == null)
+            return endOfData();
+        while (iter.hasNext())
+        {
+            IColumn c = iter.next();
+            if (c.timestamp() < since)
+                break;
+            return c;
+        }
+        return endOfData();
+    }
+}
diff --git a/src/java/org/apache/cassandra/db/filter/TimeQueryFilter.java b/src/java/org/apache/cassandra/db/filter/TimeQueryFilter.java
new file mode 100644
index 0000000000..24fd47394a
--- /dev/null
+++ b/src/java/org/apache/cassandra/db/filter/TimeQueryFilter.java
@@ -0,0 +1,54 @@
+package org.apache.cassandra.db.filter;
+
+import java.io.IOException;
+import java.util.Comparator;
+
+import org.apache.cassandra.db.*;
+import org.apache.cassandra.io.SSTableReader;
+import org.apache.cassandra.utils.ReducingIterator;
+
+public class TimeQueryFilter extends QueryFilter
+{
+    public final long since;
+
+    public TimeQueryFilter(String key, String columnFamilyColumn, long since)
+    {
+        super(key, columnFamilyColumn);
+        this.since = since;
+    }
+
+    public ColumnIterator getMemColumnIterator(Memtable memtable)
+    {
+        return memtable.getTimeIterator(this);
+    }
+
+    public ColumnIterator getSSTableColumnIterator(SSTableReader sstable) throws IOException
+    {
+        return new SSTableTimeIterator(sstable.getFilename(), key, getColumnFamilyName(), since);
+    }
+
+    @Override
+    public Comparator<IColumn> getColumnComparator()
+    {
+        return ColumnComparatorFactory.timestampComparator_;
+    }
+
+    public void collectColumns(ColumnFamily returnCF, ReducingIterator<IColumn> reducedColumns)
+    {
+        for (IColumn column : reducedColumns)
+        {
+            returnCF.addColumn(column);
+        }
+    }
+
+    public void filterSuperColumn(SuperColumn superColumn)
+    {
+        for (IColumn column : superColumn.getSubColumns())
+        {
+            if (column.timestamp() < since)
+            {
+                superColumn.remove(column.name());
+            }
+        }
+    }
+}
