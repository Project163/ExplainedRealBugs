diff --git a/CHANGES.txt b/CHANGES.txt
index b79aa276b5..8a52c9b32e 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 4.1
+ * Clients using JMX are unable to handle non-standard java types but we leak this into our interfaces (CASSANDRA-17527)
  * Remove stress server functionality (CASSANDRA-17535)
  * Reduce histogram snapshot long[] allocation overhead during speculative read and write threshold updates (CASSANDRA-17523)
  * Add guardrail for creation of secondary indexes (CASSANDRA-17498)
diff --git a/build.xml b/build.xml
index a26eb53017..e947b08427 100644
--- a/build.xml
+++ b/build.xml
@@ -550,7 +550,7 @@
           </dependency>
           <dependency groupId="org.apache.cassandra" artifactId="dtest-api" version="0.0.12" scope="test"/>
           <dependency groupId="org.apache.cassandra" artifactId="harry-core" version="0.0.1" scope="test"/>
-          <dependency groupId="org.reflections" artifactId="reflections" version="0.9.12" scope="test"/>
+          <dependency groupId="org.reflections" artifactId="reflections" version="0.10.2" scope="test"/>
           <dependency groupId="com.puppycrawl.tools" artifactId="checkstyle" version="8.40" scope="test"/>
           <dependency groupId="org.apache.hadoop" artifactId="hadoop-core" version="1.0.3" scope="provided">
             <exclusion groupId="org.mortbay.jetty" artifactId="servlet-api"/>
diff --git a/src/java/org/apache/cassandra/db/ColumnFamilyStore.java b/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
index 731585e535..35ca94214d 100644
--- a/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
+++ b/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
@@ -59,6 +59,7 @@ import com.google.common.base.Function;
 import com.google.common.base.Joiner;
 import com.google.common.base.Predicate;
 import com.google.common.base.Predicates;
+import com.google.common.base.Strings;
 import com.google.common.base.Throwables;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
@@ -219,6 +220,7 @@ public class ColumnFamilyStore implements ColumnFamilyStoreMBean
 
     public static final String SNAPSHOT_TRUNCATE_PREFIX = "truncated";
     public static final String SNAPSHOT_DROP_PREFIX = "dropped";
+    static final String TOKEN_DELIMITER = ":";
 
     static
     {
@@ -2332,11 +2334,37 @@ public class ColumnFamilyStore implements ColumnFamilyStoreMBean
         CompactionManager.instance.performMaximal(this, splitOutput);
     }
 
+    @Override
     public void forceCompactionForTokenRange(Collection<Range<Token>> tokenRanges) throws ExecutionException, InterruptedException
     {
         CompactionManager.instance.forceCompactionForTokenRange(this, tokenRanges);
     }
 
+    @Override
+    public void forceCompactionForTokenRanges(String... strings)
+    {
+        CompactionManager.instance.forceCompactionForTokenRange(this, toTokenRanges(DatabaseDescriptor.getPartitioner(), strings));
+    }
+
+    static Set<Range<Token>> toTokenRanges(IPartitioner partitioner, String... strings)
+    {
+        Token.TokenFactory tokenFactory = partitioner.getTokenFactory();
+        Set<Range<Token>> tokenRanges = new HashSet<>();
+        for (String str : strings)
+        {
+            String[] splits = str.split(TOKEN_DELIMITER);
+            assert splits.length == 2 : String.format("Unable to parse token range %s; needs to have two tokens separated by %s", str, TOKEN_DELIMITER);
+            String lhsStr = splits[0];
+            assert !Strings.isNullOrEmpty(lhsStr) : String.format("Unable to parse token range %s; left hand side of the token separater is empty", str);
+            String rhsStr = splits[1];
+            assert !Strings.isNullOrEmpty(rhsStr) : String.format("Unable to parse token range %s; right hand side of the token separater is empty", str);
+            Token lhs = tokenFactory.fromString(lhsStr);
+            Token rhs = tokenFactory.fromString(rhsStr);
+            tokenRanges.add(new Range<>(lhs, rhs));
+        }
+        return tokenRanges;
+    }
+
     public static Iterable<ColumnFamilyStore> all()
     {
         List<Iterable<ColumnFamilyStore>> stores = new ArrayList<>(Schema.instance.getKeyspaces().size());
diff --git a/src/java/org/apache/cassandra/db/ColumnFamilyStoreMBean.java b/src/java/org/apache/cassandra/db/ColumnFamilyStoreMBean.java
index f06b65a280..dd68c522fc 100644
--- a/src/java/org/apache/cassandra/db/ColumnFamilyStoreMBean.java
+++ b/src/java/org/apache/cassandra/db/ColumnFamilyStoreMBean.java
@@ -29,6 +29,7 @@ import javax.management.openmbean.OpenDataException;
 
 import org.apache.cassandra.dht.Range;
 import org.apache.cassandra.dht.Token;
+import org.apache.cassandra.utils.BreaksJMX;
 
 /**
  * The MBean interface for ColumnFamilyStore
@@ -53,7 +54,15 @@ public interface ColumnFamilyStoreMBean
     /**
      * force a major compaction of specified key range in this column family
      */
+    @BreaksJMX("This API was released in 3.10 using a parameter that takes Range of Token, which can only be done IFF client has Cassandra binaries in the classpath")
+    @Deprecated
     public void forceCompactionForTokenRange(Collection<Range<Token>> tokenRanges) throws ExecutionException, InterruptedException;
+
+    /**
+     * force a major compaction of specified key range in this column family
+     */
+    public void forceCompactionForTokenRanges(String... tokenRanges);
+
     /**
      * Gets the minimum number of sstables in queue before compaction kicks off
      */
diff --git a/src/java/org/apache/cassandra/db/DisallowedDirectories.java b/src/java/org/apache/cassandra/db/DisallowedDirectories.java
index 32ada8b128..968a08d8c7 100644
--- a/src/java/org/apache/cassandra/db/DisallowedDirectories.java
+++ b/src/java/org/apache/cassandra/db/DisallowedDirectories.java
@@ -24,6 +24,7 @@ import java.util.Collections;
 import java.util.Set;
 import java.util.concurrent.CopyOnWriteArraySet;
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.stream.Collectors;
 
 import com.google.common.annotations.VisibleForTesting;
 
@@ -49,14 +50,21 @@ public class DisallowedDirectories implements DisallowedDirectoriesMBean
         MBeanWrapper.instance.registerMBean(this, MBEAN_NAME, MBeanWrapper.OnException.LOG);
     }
 
-    public Set<File> getUnreadableDirectories()
+    @Override
+    public Set<java.io.File> getUnreadableDirectories()
     {
-        return Collections.unmodifiableSet(unreadableDirectories);
+        return toJmx(unreadableDirectories);
     }
 
-    public Set<File> getUnwritableDirectories()
+    @Override
+    public Set<java.io.File> getUnwritableDirectories()
     {
-        return Collections.unmodifiableSet(unwritableDirectories);
+        return toJmx(unwritableDirectories);
+    }
+
+    private static Set<java.io.File> toJmx(Set<File> set)
+    {
+        return set.stream().map(f -> f.toPath().toFile()).collect(Collectors.toSet());
     }
 
     public void markUnreadable(String path)
diff --git a/src/java/org/apache/cassandra/db/DisallowedDirectoriesMBean.java b/src/java/org/apache/cassandra/db/DisallowedDirectoriesMBean.java
index 7c6d530d53..e75bebecf3 100644
--- a/src/java/org/apache/cassandra/db/DisallowedDirectoriesMBean.java
+++ b/src/java/org/apache/cassandra/db/DisallowedDirectoriesMBean.java
@@ -17,9 +17,9 @@
  */
 package org.apache.cassandra.db;
 
+import java.io.File; //checkstyle: permit this import
 import java.util.Set;
 
-import org.apache.cassandra.io.util.File;
 public interface DisallowedDirectoriesMBean
 {
     public Set<File> getUnreadableDirectories();
diff --git a/src/java/org/apache/cassandra/db/guardrails/Guardrails.java b/src/java/org/apache/cassandra/db/guardrails/Guardrails.java
index 824160491f..88fc0f0c1a 100644
--- a/src/java/org/apache/cassandra/db/guardrails/Guardrails.java
+++ b/src/java/org/apache/cassandra/db/guardrails/Guardrails.java
@@ -618,9 +618,10 @@ public final class Guardrails implements GuardrailsMBean
         DEFAULT_CONFIG.setInSelectCartesianProductThreshold(warn, fail);
     }
 
-    public Set<ConsistencyLevel> getReadConsistencyLevelsWarned()
+    @Override
+    public Set<String> getReadConsistencyLevelsWarned()
     {
-        return DEFAULT_CONFIG.getReadConsistencyLevelsWarned();
+        return toJmx(DEFAULT_CONFIG.getReadConsistencyLevelsWarned());
     }
 
     @Override
@@ -630,9 +631,9 @@ public final class Guardrails implements GuardrailsMBean
     }
 
     @Override
-    public void setReadConsistencyLevelsWarned(Set<ConsistencyLevel> consistencyLevels)
+    public void setReadConsistencyLevelsWarned(Set<String> consistencyLevels)
     {
-        DEFAULT_CONFIG.setReadConsistencyLevelsWarned(consistencyLevels);
+        DEFAULT_CONFIG.setReadConsistencyLevelsWarned(fromJmx(consistencyLevels));
     }
 
     @Override
@@ -642,9 +643,9 @@ public final class Guardrails implements GuardrailsMBean
     }
 
     @Override
-    public Set<ConsistencyLevel> getReadConsistencyLevelsDisallowed()
+    public Set<String> getReadConsistencyLevelsDisallowed()
     {
-        return DEFAULT_CONFIG.getReadConsistencyLevelsDisallowed();
+        return toJmx(DEFAULT_CONFIG.getReadConsistencyLevelsDisallowed());
     }
 
     @Override
@@ -654,9 +655,9 @@ public final class Guardrails implements GuardrailsMBean
     }
 
     @Override
-    public void setReadConsistencyLevelsDisallowed(Set<ConsistencyLevel> consistencyLevels)
+    public void setReadConsistencyLevelsDisallowed(Set<String> consistencyLevels)
     {
-        DEFAULT_CONFIG.setReadConsistencyLevelsDisallowed(consistencyLevels);
+        DEFAULT_CONFIG.setReadConsistencyLevelsDisallowed(fromJmx(consistencyLevels));
     }
 
     @Override
@@ -666,9 +667,9 @@ public final class Guardrails implements GuardrailsMBean
     }
 
     @Override
-    public Set<ConsistencyLevel> getWriteConsistencyLevelsWarned()
+    public Set<String> getWriteConsistencyLevelsWarned()
     {
-        return DEFAULT_CONFIG.getWriteConsistencyLevelsWarned();
+        return toJmx(DEFAULT_CONFIG.getWriteConsistencyLevelsWarned());
     }
 
     @Override
@@ -678,9 +679,9 @@ public final class Guardrails implements GuardrailsMBean
     }
 
     @Override
-    public void setWriteConsistencyLevelsWarned(Set<ConsistencyLevel> consistencyLevels)
+    public void setWriteConsistencyLevelsWarned(Set<String> consistencyLevels)
     {
-        DEFAULT_CONFIG.setWriteConsistencyLevelsWarned(consistencyLevels);
+        DEFAULT_CONFIG.setWriteConsistencyLevelsWarned(fromJmx(consistencyLevels));
     }
 
     @Override
@@ -690,9 +691,9 @@ public final class Guardrails implements GuardrailsMBean
     }
 
     @Override
-    public Set<ConsistencyLevel> getWriteConsistencyLevelsDisallowed()
+    public Set<String> getWriteConsistencyLevelsDisallowed()
     {
-        return DEFAULT_CONFIG.getWriteConsistencyLevelsDisallowed();
+        return toJmx(DEFAULT_CONFIG.getWriteConsistencyLevelsDisallowed());
     }
 
     @Override
@@ -702,9 +703,9 @@ public final class Guardrails implements GuardrailsMBean
     }
 
     @Override
-    public void setWriteConsistencyLevelsDisallowed(Set<ConsistencyLevel> consistencyLevels)
+    public void setWriteConsistencyLevelsDisallowed(Set<String> consistencyLevels)
     {
-        DEFAULT_CONFIG.setWriteConsistencyLevelsDisallowed(consistencyLevels);
+        DEFAULT_CONFIG.setWriteConsistencyLevelsDisallowed(fromJmx(consistencyLevels));
     }
 
     @Override
@@ -750,4 +751,18 @@ public final class Guardrails implements GuardrailsMBean
     {
         return StringUtils.isEmpty(csv) ? Collections.emptySet() : fromCSV(csv).stream().map(parser).collect(Collectors.toSet());
     }
+
+    private static Set<String> toJmx(Set<ConsistencyLevel> set)
+    {
+        if (set == null)
+            return null;
+        return set.stream().map(ConsistencyLevel::name).collect(Collectors.toSet());
+    }
+
+    private static Set<ConsistencyLevel> fromJmx(Set<String> set)
+    {
+        if (set == null)
+            return null;
+        return set.stream().map(ConsistencyLevel::valueOf).collect(Collectors.toSet());
+    }
 }
diff --git a/src/java/org/apache/cassandra/db/guardrails/GuardrailsMBean.java b/src/java/org/apache/cassandra/db/guardrails/GuardrailsMBean.java
index 8d151a1032..ca4ea98e76 100644
--- a/src/java/org/apache/cassandra/db/guardrails/GuardrailsMBean.java
+++ b/src/java/org/apache/cassandra/db/guardrails/GuardrailsMBean.java
@@ -20,8 +20,6 @@ package org.apache.cassandra.db.guardrails;
 
 import java.util.Set;
 
-import org.apache.cassandra.db.ConsistencyLevel;
-
 /**
  * JMX entrypoint for updating the default guardrails configuration parsed from {@code cassandra.yaml}.
  * <p>
@@ -325,7 +323,7 @@ public interface GuardrailsMBean
     /**
      * @return consistency levels that are warned about when reading.
      */
-    Set<ConsistencyLevel> getReadConsistencyLevelsWarned();
+    Set<String> getReadConsistencyLevelsWarned();
 
     /**
      * @return Comma-separated list of consistency levels that are warned about when reading.
@@ -335,7 +333,7 @@ public interface GuardrailsMBean
     /**
      * @param consistencyLevels consistency levels that are warned about when reading.
      */
-    void setReadConsistencyLevelsWarned(Set<ConsistencyLevel> consistencyLevels);
+    void setReadConsistencyLevelsWarned(Set<String> consistencyLevels);
 
     /**
      * @param consistencyLevels Comma-separated list of consistency levels that are warned about when reading.
@@ -345,7 +343,7 @@ public interface GuardrailsMBean
     /**
      * @return consistency levels that are not allowed when reading.
      */
-    Set<ConsistencyLevel> getReadConsistencyLevelsDisallowed();
+    Set<String> getReadConsistencyLevelsDisallowed();
 
     /**
      * @return Comma-separated list of consistency levels that are not allowed when reading.
@@ -355,7 +353,7 @@ public interface GuardrailsMBean
     /**
      * @param consistencyLevels consistency levels that are not allowed when reading.
      */
-    void setReadConsistencyLevelsDisallowed(Set<ConsistencyLevel> consistencyLevels);
+    void setReadConsistencyLevelsDisallowed(Set<String> consistencyLevels);
 
     /**
      * @param consistencyLevels Comma-separated list of consistency levels that are not allowed when reading.
@@ -365,7 +363,7 @@ public interface GuardrailsMBean
     /**
      * @return consistency levels that are warned about when writing.
      */
-    Set<ConsistencyLevel> getWriteConsistencyLevelsWarned();
+    Set<String> getWriteConsistencyLevelsWarned();
 
     /**
      * @return Comma-separated list of consistency levels that are warned about when writing.
@@ -375,7 +373,7 @@ public interface GuardrailsMBean
     /**
      * @param consistencyLevels consistency levels that are warned about when writing.
      */
-    void setWriteConsistencyLevelsWarned(Set<ConsistencyLevel> consistencyLevels);
+    void setWriteConsistencyLevelsWarned(Set<String> consistencyLevels);
 
     /**
      * @param consistencyLevels Comma-separated list of consistency levels that are warned about when writing.
@@ -385,7 +383,7 @@ public interface GuardrailsMBean
     /**
      * @return consistency levels that are not allowed when writing.
      */
-    Set<ConsistencyLevel> getWriteConsistencyLevelsDisallowed();
+    Set<String> getWriteConsistencyLevelsDisallowed();
 
     /**
      * @return Comma-separated list of consistency levels that are not allowed when writing.
@@ -395,7 +393,7 @@ public interface GuardrailsMBean
     /**
      * @param consistencyLevels consistency levels that are not allowed when writing.
      */
-    void setWriteConsistencyLevelsDisallowed(Set<ConsistencyLevel> consistencyLevels);
+    void setWriteConsistencyLevelsDisallowed(Set<String> consistencyLevels);
 
     /**
      * @param consistencyLevels Comma-separated list of consistency levels that are not allowed when writing.
diff --git a/src/java/org/apache/cassandra/service/StorageService.java b/src/java/org/apache/cassandra/service/StorageService.java
index f9454b0bfb..d10cdb67ed 100644
--- a/src/java/org/apache/cassandra/service/StorageService.java
+++ b/src/java/org/apache/cassandra/service/StorageService.java
@@ -6105,7 +6105,7 @@ public class StorageService extends NotificationBroadcasterSupport implements IE
 
     public void enableAuditLog(String loggerName, String includedKeyspaces, String excludedKeyspaces, String includedCategories, String excludedCategories,
                                String includedUsers, String excludedUsers, Integer maxArchiveRetries, Boolean block, String rollCycle,
-                               Long maxLogSize, Integer maxQueueWeight, String archiveCommand) throws ConfigurationException, IllegalStateException
+                               Long maxLogSize, Integer maxQueueWeight, String archiveCommand) throws IllegalStateException
     {
         enableAuditLog(loggerName, Collections.emptyMap(), includedKeyspaces, excludedKeyspaces, includedCategories, excludedCategories, includedUsers, excludedUsers,
                        maxArchiveRetries, block, rollCycle, maxLogSize, maxQueueWeight, archiveCommand);
@@ -6121,7 +6121,7 @@ public class StorageService extends NotificationBroadcasterSupport implements IE
 
     public void enableAuditLog(String loggerName, Map<String, String> parameters, String includedKeyspaces, String excludedKeyspaces, String includedCategories, String excludedCategories,
                                String includedUsers, String excludedUsers, Integer maxArchiveRetries, Boolean block, String rollCycle,
-                               Long maxLogSize, Integer maxQueueWeight, String archiveCommand) throws ConfigurationException, IllegalStateException
+                               Long maxLogSize, Integer maxQueueWeight, String archiveCommand) throws IllegalStateException
     {
         final AuditLogOptions options = new AuditLogOptions.Builder(DatabaseDescriptor.getAuditLoggingOptions())
                                         .withEnabled(true)
diff --git a/src/java/org/apache/cassandra/service/StorageServiceMBean.java b/src/java/org/apache/cassandra/service/StorageServiceMBean.java
index d87f5b5b7d..f789c48dbd 100644
--- a/src/java/org/apache/cassandra/service/StorageServiceMBean.java
+++ b/src/java/org/apache/cassandra/service/StorageServiceMBean.java
@@ -35,6 +35,7 @@ import javax.management.openmbean.TabularData;
 
 import org.apache.cassandra.db.ColumnFamilyStoreMBean;
 import org.apache.cassandra.exceptions.ConfigurationException;
+import org.apache.cassandra.utils.BreaksJMX;
 
 public interface StorageServiceMBean extends NotificationEmitter
 {
@@ -830,19 +831,21 @@ public interface StorageServiceMBean extends NotificationEmitter
     public void disableAuditLog();
     public void enableAuditLog(String loggerName, Map<String, String> parameters, String includedKeyspaces, String excludedKeyspaces, String includedCategories, String excludedCategories,
                                String includedUsers, String excludedUsers, Integer maxArchiveRetries, Boolean block, String rollCycle,
-                               Long maxLogSize, Integer maxQueueWeight, String archiveCommand) throws ConfigurationException, IllegalStateException;
+                               Long maxLogSize, Integer maxQueueWeight, String archiveCommand) throws IllegalStateException;
 
+    @BreaksJMX("This API was exposed as throwing ConfigurationException, removing is binary compatible but not source; see https://docs.oracle.com/javase/specs/jls/se7/html/jls-13.html")
     @Deprecated
     public void enableAuditLog(String loggerName, Map<String, String> parameters, String includedKeyspaces, String excludedKeyspaces, String includedCategories, String excludedCategories,
                                String includedUsers, String excludedUsers) throws ConfigurationException, IllegalStateException;
 
+    @BreaksJMX("This API was exposed as throwing ConfigurationException, removing is binary compatible but not source; see https://docs.oracle.com/javase/specs/jls/se7/html/jls-13.html")
     @Deprecated
     public void enableAuditLog(String loggerName, String includedKeyspaces, String excludedKeyspaces, String includedCategories, String excludedCategories,
                                String includedUsers, String excludedUsers) throws ConfigurationException, IllegalStateException;
 
     public void enableAuditLog(String loggerName, String includedKeyspaces, String excludedKeyspaces, String includedCategories, String excludedCategories,
                                String includedUsers, String excludedUsers, Integer maxArchiveRetries, Boolean block, String rollCycle,
-                               Long maxLogSize, Integer maxQueueWeight, String archiveCommand) throws ConfigurationException, IllegalStateException;
+                               Long maxLogSize, Integer maxQueueWeight, String archiveCommand) throws IllegalStateException;
 
     public boolean isAuditLogEnabled();
     public String getCorruptedTombstoneStrategy();
diff --git a/src/java/org/apache/cassandra/utils/BreaksJMX.java b/src/java/org/apache/cassandra/utils/BreaksJMX.java
new file mode 100644
index 0000000000..566ef82196
--- /dev/null
+++ b/src/java/org/apache/cassandra/utils/BreaksJMX.java
@@ -0,0 +1,34 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.cassandra.utils;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Annotation to have JMX breaking APIs not trigger test failures, each example must explain why it is ok to expose a
+ * JMX breaking API
+ */
+@Retention(RetentionPolicy.RUNTIME)
+@Target({ ElementType.METHOD })
+public @interface BreaksJMX
+{
+    String value();
+}
diff --git a/test/distributed/org/apache/cassandra/distributed/impl/AbstractCluster.java b/test/distributed/org/apache/cassandra/distributed/impl/AbstractCluster.java
index 1a76ce0134..3e20baef00 100644
--- a/test/distributed/org/apache/cassandra/distributed/impl/AbstractCluster.java
+++ b/test/distributed/org/apache/cassandra/distributed/impl/AbstractCluster.java
@@ -95,8 +95,10 @@ import org.apache.cassandra.utils.Shared;
 import org.apache.cassandra.utils.Shared.Recursive;
 import org.apache.cassandra.utils.concurrent.Condition;
 import org.reflections.Reflections;
+import org.reflections.scanners.Scanners;
 import org.reflections.scanners.TypeAnnotationsScanner;
 import org.reflections.util.ConfigurationBuilder;
+import org.reflections.util.NameHelper;
 
 import static java.util.stream.Stream.of;
 import static org.apache.cassandra.distributed.impl.IsolatedExecutor.DEFAULT_SHUTDOWN_EXECUTOR;
@@ -105,7 +107,6 @@ import static org.apache.cassandra.utils.Shared.Recursive.ALL;
 import static org.apache.cassandra.utils.Shared.Recursive.NONE;
 import static org.apache.cassandra.utils.Shared.Scope.ANY;
 import static org.apache.cassandra.utils.concurrent.Condition.newOneTimeCondition;
-import static org.reflections.ReflectionUtils.forNames;
 
 /**
  * AbstractCluster creates, initializes and manages Cassandra instances ({@link Instance}.
@@ -1081,7 +1082,7 @@ public abstract class AbstractCluster<I extends IInstance> implements ICluster<I
     private static <A extends Annotation> Set<Class<?>> findClassesMarkedWith(Class<A> annotation, Predicate<A> testAnnotation)
     {
         Reflections reflections = new Reflections(ConfigurationBuilder.build("org.apache.cassandra").setExpandSuperTypes(false));
-        return forNames(reflections.getStore().getAll(TypeAnnotationsScanner.class, annotation.getName()),
+        return Utils.INSTANCE.forNames(reflections.get(Scanners.TypesAnnotated.get(annotation.getName())),
                         reflections.getConfiguration().getClassLoaders())
                .stream()
                .filter(testAnnotation(annotation, testAnnotation))
@@ -1247,5 +1248,11 @@ public abstract class AbstractCluster<I extends IInstance> implements ICluster<I
         });
         return lookup;
     }
+
+    // after upgrading a static function became an interface method, so need this class to mimic old behavior
+    private enum Utils implements NameHelper
+    {
+        INSTANCE;
+    }
 }
 
diff --git a/test/unit/org/apache/cassandra/cql3/validation/operations/CompactStorageTest.java b/test/unit/org/apache/cassandra/cql3/validation/operations/CompactStorageTest.java
index 4939895184..153fe5283f 100644
--- a/test/unit/org/apache/cassandra/cql3/validation/operations/CompactStorageTest.java
+++ b/test/unit/org/apache/cassandra/cql3/validation/operations/CompactStorageTest.java
@@ -47,10 +47,10 @@ import org.apache.cassandra.utils.FBUtilities;
 
 import static org.apache.cassandra.utils.ByteBufferUtil.EMPTY_BYTE_BUFFER;
 import static org.apache.cassandra.utils.ByteBufferUtil.bytes;
+import static org.apache.commons.lang3.StringUtils.isEmpty;
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
-import static org.reflections.util.Utils.isEmpty;
 
 public class CompactStorageTest extends CQLTester
 {
diff --git a/test/unit/org/apache/cassandra/db/ColumnFamilyStoreMBeanTest.java b/test/unit/org/apache/cassandra/db/ColumnFamilyStoreMBeanTest.java
new file mode 100644
index 0000000000..8d15f678e3
--- /dev/null
+++ b/test/unit/org/apache/cassandra/db/ColumnFamilyStoreMBeanTest.java
@@ -0,0 +1,118 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.cassandra.db;
+
+import java.util.Arrays;
+import java.util.Random;
+
+import com.google.common.collect.ImmutableSet;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+import org.apache.cassandra.config.DatabaseDescriptor;
+import org.apache.cassandra.dht.ByteOrderedPartitioner;
+import org.apache.cassandra.dht.IPartitioner;
+import org.apache.cassandra.dht.Murmur3Partitioner;
+import org.apache.cassandra.dht.OrderPreservingPartitioner;
+import org.apache.cassandra.dht.RandomPartitioner;
+import org.apache.cassandra.dht.Range;
+import org.apache.cassandra.dht.Token;
+import org.assertj.core.api.Assertions;
+import org.mockito.Mockito;
+import org.quicktheories.core.Gen;
+import org.quicktheories.impl.Constraint;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.quicktheories.QuickTheory.qt;
+
+public class ColumnFamilyStoreMBeanTest
+{
+    @BeforeClass
+    public static void setup()
+    {
+        // can't use client due to the fact thread pools startup and fail due to config issues
+        DatabaseDescriptor.daemonInitialization();
+    }
+
+    @Test
+    public void testToTokenRangesMurmur3Partitioner()
+    {
+        testToTokenRanges(Murmur3Partitioner.instance);
+    }
+
+    @Test
+    public void testToTokenRangesRandomPartitioner()
+    {
+        testToTokenRanges(RandomPartitioner.instance);
+    }
+
+    @Test
+    public void testToTokenRangesOrderPreservingPartitioner()
+    {
+        testToTokenRanges(OrderPreservingPartitioner.instance);
+    }
+
+    @Test
+    public void testToTokenRangesByteOrderedPartitioner()
+    {
+        testToTokenRanges(ByteOrderedPartitioner.instance);
+    }
+
+    @Test
+    public void testInvalidateTokenRangesFormat()
+    {
+        ColumnFamilyStore store = Mockito.mock(ColumnFamilyStore.class);
+        Mockito.doCallRealMethod().when(store).forceCompactionForTokenRanges(Mockito.any());
+        IPartitioner previous = DatabaseDescriptor.getPartitioner();
+        try
+        {
+            DatabaseDescriptor.setPartitionerUnsafe(ByteOrderedPartitioner.instance);
+
+            for (String s : Arrays.asList("testing", "t1:", ":t2", "spaces should not have an impact"))
+                Assertions.assertThatThrownBy(() -> store.forceCompactionForTokenRanges(s))
+                          .hasMessageStartingWith(String.format("Unable to parse token range %s;", s));
+        }
+        finally
+        {
+            DatabaseDescriptor.setPartitionerUnsafe(previous);
+        }
+
+    }
+
+    private static void testToTokenRanges(IPartitioner partitioner)
+    {
+        Token.TokenFactory tokenFactory = partitioner.getTokenFactory();
+        Gen<Token> tokenGen = tokenGen(partitioner);
+        qt().forAll(tokenGen, tokenGen)
+            .checkAssert((left, right) ->
+                         assertThat(ColumnFamilyStore.toTokenRanges(partitioner, toString(tokenFactory, left, right)))
+                         .isEqualTo(ImmutableSet.of(new Range<>(left, right))));
+    }
+
+    private static String toString(Token.TokenFactory tokenFactory, Token left, Token right)
+    {
+        return tokenFactory.toString(left) + ColumnFamilyStore.TOKEN_DELIMITER + tokenFactory.toString(right);
+    }
+
+    private static Gen<Token> tokenGen(IPartitioner partitioner)
+    {
+        // Random and RandomSource can not share the same seed, but there is a workaround...
+        // use RandomSource to generate a seed!
+        return rs -> partitioner.getRandomToken(new Random(rs.next(Constraint.none())));
+    }
+}
diff --git a/test/unit/org/apache/cassandra/db/guardrails/GuardrailConsistencyLevelsTester.java b/test/unit/org/apache/cassandra/db/guardrails/GuardrailConsistencyLevelsTester.java
index 5ca6d8a92b..14c3a5879b 100644
--- a/test/unit/org/apache/cassandra/db/guardrails/GuardrailConsistencyLevelsTester.java
+++ b/test/unit/org/apache/cassandra/db/guardrails/GuardrailConsistencyLevelsTester.java
@@ -24,8 +24,8 @@ import java.util.Set;
 import java.util.function.BiConsumer;
 import java.util.function.Function;
 import java.util.stream.Collectors;
+import java.util.stream.Stream;
 
-import com.google.common.collect.ImmutableSet;
 import org.junit.Before;
 import org.junit.Test;
 
@@ -38,24 +38,24 @@ public abstract class GuardrailConsistencyLevelsTester extends GuardrailTester
 {
     private final String warnedPropertyName;
     private final String disallowePropertyName;
-    private final Function<Guardrails, Set<ConsistencyLevel>> warnedGetter;
-    private final Function<Guardrails, Set<ConsistencyLevel>> disallowedGetter;
+    private final Function<Guardrails, Set<String>> warnedGetter;
+    private final Function<Guardrails, Set<String>> disallowedGetter;
     private final Function<Guardrails, String> warnedCSVGetter;
     private final Function<Guardrails, String> disallowedCSVGetter;
-    private final BiConsumer<Guardrails, Set<ConsistencyLevel>> warnedSetter;
-    private final BiConsumer<Guardrails, Set<ConsistencyLevel>> disallowedSetter;
+    private final BiConsumer<Guardrails, Set<String>> warnedSetter;
+    private final BiConsumer<Guardrails, Set<String>> disallowedSetter;
     private final BiConsumer<Guardrails, String> warnedCSVSetter;
     private final BiConsumer<Guardrails, String> disallowedCSVSetter;
 
     public GuardrailConsistencyLevelsTester(String warnedPropertyName,
                                             String disallowePropertyName,
                                             Values<ConsistencyLevel> guardrail,
-                                            Function<Guardrails, Set<ConsistencyLevel>> warnedGetter,
-                                            Function<Guardrails, Set<ConsistencyLevel>> disallowedGetter,
+                                            Function<Guardrails, Set<String>> warnedGetter,
+                                            Function<Guardrails, Set<String>> disallowedGetter,
                                             Function<Guardrails, String> warnedCSVGetter,
                                             Function<Guardrails, String> disallowedCSVGetter,
-                                            BiConsumer<Guardrails, Set<ConsistencyLevel>> warnedSetter,
-                                            BiConsumer<Guardrails, Set<ConsistencyLevel>> disallowedSetter,
+                                            BiConsumer<Guardrails, Set<String>> warnedSetter,
+                                            BiConsumer<Guardrails, Set<String>> disallowedSetter,
                                             BiConsumer<Guardrails, String> warnedCSVSetter,
                                             BiConsumer<Guardrails, String> disallowedCSVSetter)
     {
@@ -81,12 +81,12 @@ public abstract class GuardrailConsistencyLevelsTester extends GuardrailTester
 
     protected void warnConsistencyLevels(ConsistencyLevel... consistencyLevels)
     {
-        warnedSetter.accept(guardrails(), ImmutableSet.copyOf(consistencyLevels));
+        warnedSetter.accept(guardrails(), Stream.of(consistencyLevels).map(ConsistencyLevel::name).collect(Collectors.toSet()));
     }
 
     protected void disableConsistencyLevels(ConsistencyLevel... consistencyLevels)
     {
-        disallowedSetter.accept(guardrails(), ImmutableSet.copyOf(consistencyLevels));
+        disallowedSetter.accept(guardrails(), Stream.of(consistencyLevels).map(ConsistencyLevel::name).collect(Collectors.toSet()));
     }
 
     @Test
@@ -111,8 +111,9 @@ public abstract class GuardrailConsistencyLevelsTester extends GuardrailTester
         assertInvalidPropertyCSV("invalid1,ONE,invalid2", "INVALID1");
     }
 
-    private void assertValidProperty(Set<ConsistencyLevel> properties)
+    private void assertValidProperty(Set<ConsistencyLevel> input)
     {
+        Set<String> properties = input.stream().map(ConsistencyLevel::name).collect(Collectors.toSet());
         assertValidProperty(warnedSetter, warnedGetter, properties);
         assertValidProperty(disallowedSetter, disallowedGetter, properties);
     }
diff --git a/test/unit/org/apache/cassandra/tools/JMXStandardsTest.java b/test/unit/org/apache/cassandra/tools/JMXStandardsTest.java
new file mode 100644
index 0000000000..87b9ff93fd
--- /dev/null
+++ b/test/unit/org/apache/cassandra/tools/JMXStandardsTest.java
@@ -0,0 +1,186 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.cassandra.tools;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.Serializable;
+import java.lang.reflect.Method;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.SortedMap;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.TimeoutException;
+import java.util.regex.Pattern;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+import javax.management.ObjectName;
+import javax.management.openmbean.CompositeData;
+import javax.management.openmbean.OpenDataException;
+import javax.management.openmbean.TabularData;
+
+import com.google.common.collect.ImmutableSet;
+import org.junit.Assert;
+import org.junit.Test;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import org.apache.cassandra.utils.BreaksJMX;
+import org.assertj.core.api.Assertions;
+import org.reflections.Reflections;
+import org.reflections.scanners.Scanners;
+import org.reflections.util.ConfigurationBuilder;
+
+public class JMXStandardsTest
+{
+    private static final Logger logger = LoggerFactory.getLogger(JMXStandardsTest.class);
+
+    /**
+     * JMX typlically works well with java.* and javax.*, but not all types are serializable and will work, so this class
+     * goes with a explicit approval list, new APIs may fail if a java.* or javax.* is used not in this allow list, if
+     * that is the case it is fine to add here.
+     * <p>
+     * It is never fine to allow non java.* and javax.* types, they can not be handled by clients, so should never be
+     * allowed.
+     */
+    private static final Set<Class<?>> ALLOWED_TYPES = ImmutableSet.<Class<?>>builder()
+                                                       .add(Void.class).add(Void.TYPE)
+                                                       .add(Boolean.class).add(Boolean.TYPE)
+                                                       .add(Byte.class).add(Byte.TYPE)
+                                                       .add(Short.class).add(Short.TYPE)
+                                                       .add(Integer.class).add(Integer.TYPE)
+                                                       .add(Long.class).add(Long.TYPE)
+                                                       .add(Float.class).add(Float.TYPE)
+                                                       .add(Double.class).add(Double.TYPE)
+                                                       .add(String.class)
+                                                       .add(ByteBuffer.class)
+                                                       .add(InetAddress.class)
+                                                       .add(File.class)
+                                                       .add(List.class).add(Map.class).add(Set.class).add(SortedMap.class).add(Collection.class)
+                                                       .add(ObjectName.class).add(TabularData.class).add(CompositeData.class)
+                                                       // Exceptions
+                                                       // https://www.oracle.com/java/technologies/javase/management-extensions-best-practices.html
+                                                       // "It is recommended that exceptions thrown by MBeans be drawn from
+                                                       // the standard set defined in the java.* and javax.* packages on the
+                                                       // Java SE platform. If an MBean throws a non-standard exception, a
+                                                       // client that does not have that exception class will likely see
+                                                       // another exception such as ClassNotFoundException instead."
+                                                       .add(ExecutionException.class)
+                                                       .add(InterruptedException.class)
+                                                       .add(UnknownHostException.class)
+                                                       .add(IOException.class)
+                                                       .add(TimeoutException.class)
+                                                       .add(IllegalStateException.class)
+                                                       .add(ClassNotFoundException.class)
+                                                       .add(OpenDataException.class)
+                                                       .build();
+    /**
+     * This list is a set of types under java.* and javax.*, but are too vague that could cause issues; this does not
+     * mean issues will happen with JMX, only that issues may happen only after running and can not be detected at
+     * compile time.
+     */
+    private static final Set<Class<?>> DANGEROUS_TYPES = ImmutableSet.<Class<?>>builder()
+                                                         .add(Object.class)
+                                                         .add(Comparable.class)
+                                                         .add(Serializable.class)
+                                                         .add(Exception.class)
+                                                         .build();
+
+    @Test
+    public void interfaces() throws ClassNotFoundException
+    {
+        Reflections reflections = new Reflections(ConfigurationBuilder.build("org.apache.cassandra").setExpandSuperTypes(false));
+        Pattern mbeanPattern = Pattern.compile(".*MBean$");
+        Set<String> matches = reflections.getAll(Scanners.SubTypes).stream()
+                                         .filter(s -> mbeanPattern.matcher(s).find())
+                                         .collect(Collectors.toSet());
+
+        List<String> warnings = new ArrayList<>();
+        List<String> errors = new ArrayList<>();
+        for (String className : matches)
+        {
+            for (Class<?> klass = Class.forName(className); klass != null && !Object.class.equals(klass); klass = klass.getSuperclass())
+            {
+                Assertions.assertThat(klass).isInterface();
+                Method[] methods = klass.getDeclaredMethods();
+                for (int i = 0; i < methods.length; i++)
+                {
+                    Method method = methods[i];
+                    checkType(method, "return", method.getGenericReturnType(), warnings, errors);
+                    Stream.of(method.getGenericParameterTypes()).forEach(t -> checkType(method, "parameter", t, warnings, errors));
+                    Stream.of(method.getGenericExceptionTypes()).forEach(t -> checkType(method, "throws", t, warnings, errors));
+                }
+            }
+        }
+        if (!warnings.isEmpty())
+            warnings.forEach(logger::warn);
+        if (!errors.isEmpty())
+            throw new AssertionError("Errors detected while validating MBeans\n" + String.join("\n", errors));
+    }
+
+    private static void checkType(Method method, String sig, Type type, Collection<String> warnings, Collection<String> errors)
+    {
+        if (type instanceof Class<?>)
+        {
+            Class<?> klass = (Class<?>) type;
+            int numArrays = 0;
+            while (klass.isArray())
+            {
+                numArrays++;
+                klass = klass.getComponentType();
+            }
+            if (!ALLOWED_TYPES.contains(klass))
+            {
+                StringBuilder typeName = new StringBuilder(klass.getCanonicalName());
+                for (int i = 0; i < numArrays; i++)
+                    typeName.append("[]");
+                if (DANGEROUS_TYPES.contains(klass))
+                {
+                    warnings.add(String.format("Dangerous type used at signature %s, type %s; method '%s'", sig, typeName, method));
+                }
+                else
+                {
+                    String msg = String.format("Error at signature %s; type %s is not in the supported set of types, method method '%s'", sig, typeName, method);
+                    (method.isAnnotationPresent(BreaksJMX.class) ? warnings : errors).add(msg);
+                }
+            }
+        }
+        else if (type instanceof ParameterizedType)
+        {
+            ParameterizedType param = (ParameterizedType) type;
+            Type klass = param.getRawType();
+            Type[] args = param.getActualTypeArguments();
+            checkType(method, sig + ": " + param, klass, warnings, errors);
+            Stream.of(args).forEach(t -> checkType(method, sig + " of " + param, t, warnings, errors));
+        }
+        else
+        {
+            Assert.fail("Unknown type: " + type.getClass());
+        }
+    }
+}
