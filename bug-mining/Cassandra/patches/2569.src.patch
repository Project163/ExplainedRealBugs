diff --git a/CHANGES.txt b/CHANGES.txt
index d55b658e40..c7592fbad9 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -41,6 +41,7 @@
  * Fix NPE when streaming connection is not yet established (CASSANDRA-6210)
  * Avoid rare duplicate read repair triggering (CASSANDRA-6606)
  * Fix paging discardFirst (CASSANDRA-6555)
+ * Fix ArrayIndexOutOfBoundsException in 2ndary index query (CASSANDRA-6470)
 Merged from 1.2:
  * fsync compression metadata (CASSANDRA-6531)
  * Validate CF existence on execution for prepared statement (CASSANDRA-6535)
diff --git a/src/java/org/apache/cassandra/db/DataRange.java b/src/java/org/apache/cassandra/db/DataRange.java
index 453b16a4d0..91ff512123 100644
--- a/src/java/org/apache/cassandra/db/DataRange.java
+++ b/src/java/org/apache/cassandra/db/DataRange.java
@@ -185,8 +185,10 @@ public class DataRange
         private ColumnSlice[] slicesForKey(ByteBuffer key)
         {
             // We don't call that until it's necessary, so assume we have to do some hard work
-            Composite newStart = equals(startKey(), key) ? columnStart : null;
-            Composite newFinish = equals(stopKey(), key) ? columnFinish : null;
+            // it doesn't expand on them. As such, we can ignore the case where they are empty and we do
+            // as it screw up with the logic below (see #6592)
+            Composite newStart = equals(startKey(), key) && !columnStart.isEmpty() ? columnStart : null;
+            Composite newFinish = equals(stopKey(), key) && !columnFinish.isEmpty() ? columnFinish : null;
 
             List<ColumnSlice> newSlices = new ArrayList<ColumnSlice>(sliceFilter.slices.length); // in the common case, we'll have the same number of slices
 
