diff --git a/CHANGES.txt b/CHANGES.txt
index f5ae4e3440..98929cfff7 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -57,6 +57,7 @@
  * Rewrite nodetool help (CASSANDRA-2293)
  * Make CQL3 the default for CQL (CASSANDRA-4640)
  * update stress tool to be able to use CQL3 (CASSANDRA-4406)
+ * Accept all thrift update on CQL3 cf but don't expose their metadata (CASSANDRA-4377)
 
 
 1.1.6
diff --git a/src/java/org/apache/cassandra/config/CFMetaData.java b/src/java/org/apache/cassandra/config/CFMetaData.java
index 4e29fc7755..687b5f32ae 100644
--- a/src/java/org/apache/cassandra/config/CFMetaData.java
+++ b/src/java/org/apache/cassandra/config/CFMetaData.java
@@ -886,12 +886,7 @@ public final class CFMetaData
             def.setKey_alias(keyAliases.get(0));
         List<org.apache.cassandra.thrift.ColumnDef> column_meta = new ArrayList<org.apache.cassandra.thrift.ColumnDef>(column_metadata.size());
         for (ColumnDefinition cd : column_metadata.values())
-        {
-            // Non-null componentIndex are only used by CQL (so far) so we don't expose
-            // them through thrift
-            if (cd.componentIndex == null)
                 column_meta.add(cd.toThrift());
-        }
         def.setColumn_metadata(column_meta);
         def.setCompaction_strategy(compactionStrategyClass.getName());
         def.setCompaction_strategy_options(new HashMap<String, String>(compactionStrategyOptions));
@@ -1425,6 +1420,23 @@ public final class CFMetaData
         return cqlCfDef;
     }
 
+    /**
+     * Returns whether this CFMetaData has information non exposed on thrift so
+     * that it cannot be correctly handled automatically by thrift clients.
+     */
+    public boolean isThriftIncompatible()
+    {
+        if (!cqlCfDef.isComposite)
+            return false;
+
+        for (ColumnDefinition columnDef : column_metadata.values())
+        {
+            if (columnDef.componentIndex != null)
+                return true;
+        }
+        return false;
+    }
+
     @Override
     public String toString()
     {
diff --git a/src/java/org/apache/cassandra/config/KSMetaData.java b/src/java/org/apache/cassandra/config/KSMetaData.java
index 50cbb91aff..e700444eee 100644
--- a/src/java/org/apache/cassandra/config/KSMetaData.java
+++ b/src/java/org/apache/cassandra/config/KSMetaData.java
@@ -179,7 +179,11 @@ public final class KSMetaData
     {
         List<CfDef> cfDefs = new ArrayList<CfDef>(cfMetaData.size());
         for (CFMetaData cfm : cfMetaData().values())
-            cfDefs.add(cfm.toThrift());
+        {
+            // Don't expose CF that cannot be correctly handle by thrift; see CASSANDRA-4377 for further details
+            if (!cfm.isThriftIncompatible())
+                cfDefs.add(cfm.toThrift());
+        }
         KsDef ksdef = new KsDef(name, strategyClass.getName(), cfDefs);
         ksdef.setStrategy_options(strategyOptions);
         ksdef.setDurable_writes(durableWrites);
diff --git a/src/java/org/apache/cassandra/thrift/ThriftValidation.java b/src/java/org/apache/cassandra/thrift/ThriftValidation.java
index 36b3aca967..93b972d4e7 100644
--- a/src/java/org/apache/cassandra/thrift/ThriftValidation.java
+++ b/src/java/org/apache/cassandra/thrift/ThriftValidation.java
@@ -30,6 +30,7 @@ import org.apache.cassandra.db.filter.NamesQueryFilter;
 import org.apache.cassandra.db.filter.SliceQueryFilter;
 import org.apache.cassandra.db.index.SecondaryIndexManager;
 import org.apache.cassandra.db.marshal.AbstractType;
+import org.apache.cassandra.db.marshal.CompositeType;
 import org.apache.cassandra.db.marshal.MarshalException;
 import org.apache.cassandra.dht.IPartitioner;
 import org.apache.cassandra.dht.RandomPartitioner;
@@ -395,7 +396,7 @@ public class ThriftValidation
         if (!column.isSetTimestamp())
             throw new org.apache.cassandra.exceptions.InvalidRequestException("Column timestamp is required");
 
-        ColumnDefinition columnDef = metadata.getColumnDefinition(column.name);
+        ColumnDefinition columnDef = getColumnDefinition(metadata, column.name);
         try
         {
             AbstractType<?> validator = metadata.getValueValidator(columnDef);
@@ -422,6 +423,26 @@ public class ThriftValidation
                                                                               metadata.ksName));
     }
 
+    private static ColumnDefinition getColumnDefinition(CFMetaData metadata, ByteBuffer columnName)
+    {
+        if (metadata.comparator instanceof CompositeType)
+        {
+            CompositeType composite = (CompositeType)metadata.comparator;
+            ByteBuffer[] components = composite.split(columnName);
+            for (ColumnDefinition def : metadata.getColumn_metadata().values())
+            {
+                ByteBuffer toCompare = def.componentIndex == null ? columnName : components[def.componentIndex];
+                if (columnName.equals(toCompare))
+                    return def;
+            }
+            return null;
+        }
+        else
+        {
+            return metadata.getColumnDefinition(columnName);
+        }
+    }
+
     /**
      * Return, at most, the first 64K of the buffer. This avoids very large column values being
      * logged in their entirety.
