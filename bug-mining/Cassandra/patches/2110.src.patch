diff --git a/src/java/org/apache/cassandra/config/CFMetaData.java b/src/java/org/apache/cassandra/config/CFMetaData.java
index 01e7d0c52c..96b2ecad68 100644
--- a/src/java/org/apache/cassandra/config/CFMetaData.java
+++ b/src/java/org/apache/cassandra/config/CFMetaData.java
@@ -1693,6 +1693,12 @@ public final class CFMetaData
         return false;
     }
 
+    public void validateColumns(Iterable<Column> columns)
+    {
+        for (Column column : columns)
+            column.validateFields(this);
+    }
+
     @Override
     public String toString()
     {
diff --git a/src/java/org/apache/cassandra/cql3/statements/DeleteStatement.java b/src/java/org/apache/cassandra/cql3/statements/DeleteStatement.java
index 4fe52dab2f..dd72bb36a5 100644
--- a/src/java/org/apache/cassandra/cql3/statements/DeleteStatement.java
+++ b/src/java/org/apache/cassandra/cql3/statements/DeleteStatement.java
@@ -23,14 +23,10 @@ import java.util.*;
 import org.apache.cassandra.config.Schema;
 import org.apache.cassandra.cql3.*;
 import org.apache.cassandra.config.CFMetaData;
-import org.apache.cassandra.db.ConsistencyLevel;
-import org.apache.cassandra.db.ColumnFamily;
-import org.apache.cassandra.db.DeletionInfo;
-import org.apache.cassandra.db.RowMutation;
+import org.apache.cassandra.db.*;
 import org.apache.cassandra.db.marshal.*;
 import org.apache.cassandra.exceptions.*;
 import org.apache.cassandra.thrift.ThriftValidation;
-import org.apache.cassandra.utils.Pair;
 
 /**
  * A <code>DELETE</code> parsed from a CQL query statement.
@@ -103,7 +99,7 @@ public class DeleteStatement extends ModificationStatement
     throws InvalidRequestException
     {
         QueryProcessor.validateKey(key);
-        ColumnFamily cf = ColumnFamily.create(Schema.instance.getCFMetaData(cfDef.cfm.ksName, columnFamily()));
+        ColumnFamily cf = TreeMapBackedSortedColumns.factory.create(Schema.instance.getCFMetaData(cfDef.cfm.ksName, columnFamily()));
 
         if (toRemove.isEmpty() && builder.componentCount() == 0)
         {
diff --git a/src/java/org/apache/cassandra/cql3/statements/UpdateStatement.java b/src/java/org/apache/cassandra/cql3/statements/UpdateStatement.java
index f1c200332d..3213bd4a6b 100644
--- a/src/java/org/apache/cassandra/cql3/statements/UpdateStatement.java
+++ b/src/java/org/apache/cassandra/cql3/statements/UpdateStatement.java
@@ -212,7 +212,7 @@ public class UpdateStatement extends ModificationStatement
         validateKey(key);
 
         QueryProcessor.validateKey(key);
-        ColumnFamily cf = ColumnFamily.create(Schema.instance.getCFMetaData(cfDef.cfm.ksName, cfDef.cfm.cfName));
+        ColumnFamily cf = UnsortedColumns.factory.create(Schema.instance.getCFMetaData(cfDef.cfm.ksName, cfDef.cfm.cfName));
 
         // Inserting the CQL row marker (see #4361)
         // We always need to insert a marker, because of the following situation:
diff --git a/src/java/org/apache/cassandra/db/AbstractThreadUnsafeSortedColumns.java b/src/java/org/apache/cassandra/db/AbstractThreadUnsafeSortedColumns.java
index 3782dd2fa3..1c2fb54504 100644
--- a/src/java/org/apache/cassandra/db/AbstractThreadUnsafeSortedColumns.java
+++ b/src/java/org/apache/cassandra/db/AbstractThreadUnsafeSortedColumns.java
@@ -17,16 +17,24 @@
  */
 package org.apache.cassandra.db;
 
-public abstract class AbstractThreadUnsafeSortedColumns implements ISortedColumns
+import org.apache.cassandra.config.CFMetaData;
+
+public abstract class AbstractThreadUnsafeSortedColumns extends ColumnFamily
 {
-    private DeletionInfo deletionInfo;
+    protected DeletionInfo deletionInfo;
+
+    public AbstractThreadUnsafeSortedColumns(CFMetaData metadata)
+    {
+        this(metadata, DeletionInfo.LIVE);
+    }
 
-    public AbstractThreadUnsafeSortedColumns()
+    protected AbstractThreadUnsafeSortedColumns(CFMetaData metadata, DeletionInfo deletionInfo)
     {
-        deletionInfo = DeletionInfo.LIVE;
+        super(metadata);
+        this.deletionInfo = deletionInfo;
     }
 
-    public DeletionInfo getDeletionInfo()
+    public DeletionInfo deletionInfo()
     {
         return deletionInfo;
     }
@@ -48,6 +56,6 @@ public abstract class AbstractThreadUnsafeSortedColumns implements ISortedColumn
 
     public boolean isEmpty()
     {
-        return size() == 0;
+        return getColumnCount() == 0;
     }
 }
diff --git a/src/java/org/apache/cassandra/db/ArrayBackedSortedColumns.java b/src/java/org/apache/cassandra/db/ArrayBackedSortedColumns.java
index 863e8f53dc..b80883a24a 100644
--- a/src/java/org/apache/cassandra/db/ArrayBackedSortedColumns.java
+++ b/src/java/org/apache/cassandra/db/ArrayBackedSortedColumns.java
@@ -22,72 +22,56 @@ import java.util.*;
 
 import com.google.common.base.Function;
 import com.google.common.collect.AbstractIterator;
+import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
 
+import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.db.filter.ColumnSlice;
-import org.apache.cassandra.db.index.SecondaryIndexManager;
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.utils.Allocator;
 
 /**
- * A ISortedColumns backed by an ArrayList.
+ * A ColumnFamily backed by an ArrayList.
  * This implementation is not synchronized and should only be used when
  * thread-safety is not required. This implementation makes sense when the
  * main operations performed are iterating over the map and adding columns
  * (especially if insertion is in sorted order).
  */
-public class ArrayBackedSortedColumns extends AbstractThreadUnsafeSortedColumns implements ISortedColumns
+public class ArrayBackedSortedColumns extends AbstractThreadUnsafeSortedColumns
 {
-    private final AbstractType<?> comparator;
     private final boolean reversed;
     private final ArrayList<Column> columns;
 
-    public static final ISortedColumns.Factory factory = new Factory()
+    public static final ColumnFamily.Factory<ArrayBackedSortedColumns> factory = new Factory<ArrayBackedSortedColumns>()
     {
-        public ISortedColumns create(AbstractType<?> comparator, boolean insertReversed)
+        public ArrayBackedSortedColumns create(CFMetaData metadata, boolean insertReversed)
         {
-            return new ArrayBackedSortedColumns(comparator, insertReversed);
-        }
-
-        public ISortedColumns fromSorted(SortedMap<ByteBuffer, Column> sortedMap, boolean insertReversed)
-        {
-            return new ArrayBackedSortedColumns(sortedMap.values(), (AbstractType<?>)sortedMap.comparator(), insertReversed);
+            return new ArrayBackedSortedColumns(metadata, insertReversed);
         }
     };
 
-    public static ISortedColumns.Factory factory()
-    {
-        return factory;
-    }
-
-    private ArrayBackedSortedColumns(AbstractType<?> comparator, boolean reversed)
+    private ArrayBackedSortedColumns(CFMetaData metadata, boolean reversed)
     {
-        super();
-        this.comparator = comparator;
+        super(metadata);
         this.reversed = reversed;
         this.columns = new ArrayList<Column>();
     }
 
-    private ArrayBackedSortedColumns(Collection<Column> columns, AbstractType<?> comparator, boolean reversed)
+    private ArrayBackedSortedColumns(Collection<Column> columns, CFMetaData metadata, boolean reversed)
     {
-        this.comparator = comparator;
+        super(metadata);
         this.reversed = reversed;
         this.columns = new ArrayList<Column>(columns);
     }
 
-    public ISortedColumns.Factory getFactory()
-    {
-        return factory();
-    }
-
-    public AbstractType<?> getComparator()
+    public ColumnFamily.Factory getFactory()
     {
-        return comparator;
+        return factory;
     }
 
-    public ISortedColumns cloneMe()
+    public ColumnFamily cloneMe()
     {
-        return new ArrayBackedSortedColumns(columns, comparator, reversed);
+        return new ArrayBackedSortedColumns(columns, metadata, reversed);
     }
 
     public boolean isInsertReversed()
@@ -97,7 +81,7 @@ public class ArrayBackedSortedColumns extends AbstractThreadUnsafeSortedColumns
 
     private Comparator<ByteBuffer> internalComparator()
     {
-        return reversed ? comparator.reverseComparator : comparator;
+        return reversed ? getComparator().reverseComparator : getComparator();
     }
 
     public Column getColumn(ByteBuffer name)
@@ -125,7 +109,7 @@ public class ArrayBackedSortedColumns extends AbstractThreadUnsafeSortedColumns
         }
 
         // Fast path if inserting at the tail
-        int c = internalComparator().compare(columns.get(size() - 1).name(), column.name());
+        int c = internalComparator().compare(columns.get(getColumnCount() - 1).name(), column.name());
         // note that we want an assertion here (see addColumn javadoc), but we also want that if
         // assertion are disabled, addColumn works correctly with unsorted input
         assert c <= 0 : "Added column does not sort as the " + (reversed ? "first" : "last") + " column";
@@ -138,7 +122,7 @@ public class ArrayBackedSortedColumns extends AbstractThreadUnsafeSortedColumns
         else if (c == 0)
         {
             // Resolve against last
-            resolveAgainst(size() - 1, column, allocator);
+            resolveAgainst(getColumnCount() - 1, column, allocator);
         }
         else
         {
@@ -199,18 +183,13 @@ public class ArrayBackedSortedColumns extends AbstractThreadUnsafeSortedColumns
         return -mid - (result < 0 ? 1 : 2);
     }
 
-    public long addAllWithSizeDelta(ISortedColumns cm, Allocator allocator, Function<Column, Column> transformation, SecondaryIndexManager.Updater indexer)
-    {
-        throw new UnsupportedOperationException();
-    }
-
-    public void addAll(ISortedColumns cm, Allocator allocator, Function<Column, Column> transformation)
+    public void addAll(ColumnFamily cm, Allocator allocator, Function<Column, Column> transformation)
     {
-        delete(cm.getDeletionInfo());
+        delete(cm.deletionInfo());
         if (cm.isEmpty())
             return;
 
-        Column[] copy = columns.toArray(new Column[size()]);
+        Column[] copy = columns.toArray(new Column[getColumnCount()]);
         int idx = 0;
         Iterator<Column> other = reversed ? cm.reverseIterator(ColumnSlice.ALL_COLUMNS_ARRAY) : cm.iterator();
         Column otherColumn = other.next();
@@ -233,7 +212,7 @@ public class ArrayBackedSortedColumns extends AbstractThreadUnsafeSortedColumns
             else // c == 0
             {
                 columns.add(copy[idx]);
-                resolveAgainst(size() - 1, transformation.apply(otherColumn), allocator);
+                resolveAgainst(getColumnCount() - 1, transformation.apply(otherColumn), allocator);
                 idx++;
                 otherColumn = other.hasNext() ? other.next() : null;
             }
@@ -276,14 +255,7 @@ public class ArrayBackedSortedColumns extends AbstractThreadUnsafeSortedColumns
         return reversed ? new ForwardSortedCollection() : new ReverseSortedCollection();
     }
 
-    public void removeColumn(ByteBuffer name)
-    {
-        int pos = binarySearch(name);
-        if (pos >= 0)
-            columns.remove(pos);
-    }
-
-    public int size()
+    public int getColumnCount()
     {
         return columns.size();
     }
@@ -293,10 +265,15 @@ public class ArrayBackedSortedColumns extends AbstractThreadUnsafeSortedColumns
         columns.clear();
     }
 
-    public SortedSet<ByteBuffer> getColumnNames()
+    public Iterable<ByteBuffer> getColumnNames()
     {
-        // we could memoize the created set but it's unlikely we'll call this method a lot on the same object anyway
-        return new ColumnNamesSet();
+        return Iterables.transform(columns, new Function<Column, ByteBuffer>()
+        {
+            public ByteBuffer apply(Column column)
+            {
+                return column.name;
+            }
+        });
     }
 
     public Iterator<Column> iterator()
@@ -306,12 +283,12 @@ public class ArrayBackedSortedColumns extends AbstractThreadUnsafeSortedColumns
 
     public Iterator<Column> iterator(ColumnSlice[] slices)
     {
-        return new SlicesIterator(columns, comparator, slices, reversed);
+        return new SlicesIterator(columns, getComparator(), slices, reversed);
     }
 
     public Iterator<Column> reverseIterator(ColumnSlice[] slices)
     {
-        return new SlicesIterator(columns, comparator, slices, !reversed);
+        return new SlicesIterator(columns, getComparator(), slices, !reversed);
     }
 
     private static class SlicesIterator extends AbstractIterator<Column>
@@ -410,79 +387,4 @@ public class ArrayBackedSortedColumns extends AbstractThreadUnsafeSortedColumns
             return columns.iterator();
         }
     }
-
-    private class ColumnNamesSet extends AbstractSet<ByteBuffer> implements SortedSet<ByteBuffer>
-    {
-        public int size()
-        {
-            return columns.size();
-        }
-
-        public Iterator<ByteBuffer> iterator()
-        {
-            final Iterator<Column> outerIterator = ArrayBackedSortedColumns.this.iterator(); // handles reversed
-            return new Iterator<ByteBuffer>()
-            {
-                public boolean hasNext()
-                {
-                    return outerIterator.hasNext();
-                }
-
-                public ByteBuffer next()
-                {
-                    return outerIterator.next().name();
-                }
-
-                public void remove()
-                {
-                    outerIterator.remove();
-                }
-            };
-        }
-
-        public Comparator<ByteBuffer> comparator()
-        {
-            return getComparator();
-        }
-
-        public ByteBuffer first()
-        {
-            final ArrayBackedSortedColumns outerList = ArrayBackedSortedColumns.this;
-            if (outerList.isEmpty())
-                throw new NoSuchElementException();
-            return outerList.columns.get(outerList.reversed ? size() - 1 : 0).name();
-        }
-
-        public ByteBuffer last()
-        {
-            final ArrayBackedSortedColumns outerList = ArrayBackedSortedColumns.this;
-            if (outerList.isEmpty())
-                throw new NoSuchElementException();
-            return outerList.columns.get(outerList.reversed ? 0 : size() - 1).name();
-        }
-
-        /*
-         * It is fairly hard to implement headSet, tailSet and subSet so that they respect their specification.
-         * Namely, the part "The returned set is backed by this set, so changes in the returned set are reflected
-         * in this set, and vice-versa". Simply keeping a lower and upper index in the backing arrayList wouldn't
-         * ensure those property. Since we do not use those function so far, we prefer returning UnsupportedOperationException
-         * for now and revisit this when and if the need arise.
-         */
-        public SortedSet<ByteBuffer> headSet(ByteBuffer fromElement)
-        {
-            throw new UnsupportedOperationException();
-        }
-
-        // see headSet
-        public SortedSet<ByteBuffer> tailSet(ByteBuffer toElement)
-        {
-            throw new UnsupportedOperationException();
-        }
-
-        // see headSet
-        public SortedSet<ByteBuffer> subSet(ByteBuffer fromElement, ByteBuffer toElement)
-        {
-            throw new UnsupportedOperationException();
-        }
-    }
 }
diff --git a/src/java/org/apache/cassandra/db/AtomicSortedColumns.java b/src/java/org/apache/cassandra/db/AtomicSortedColumns.java
index a199b49099..bf0fce80a8 100644
--- a/src/java/org/apache/cassandra/db/AtomicSortedColumns.java
+++ b/src/java/org/apache/cassandra/db/AtomicSortedColumns.java
@@ -24,6 +24,7 @@ import java.util.concurrent.atomic.AtomicReference;
 import com.google.common.base.Function;
 import edu.stanford.ppl.concurrent.SnapTreeMap;
 
+import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.db.filter.ColumnSlice;
 import org.apache.cassandra.db.index.SecondaryIndexManager;
 import org.apache.cassandra.db.marshal.AbstractType;
@@ -45,40 +46,26 @@ import org.apache.cassandra.utils.Allocator;
  * isolated of other operations and could actually be fully ignored in the
  * face of a concurrent. Don't use it unless in a non-concurrent context.
  */
-public class AtomicSortedColumns implements ISortedColumns
+public class AtomicSortedColumns extends ColumnFamily
 {
     private final AtomicReference<Holder> ref;
 
-    public static final ISortedColumns.Factory factory = new Factory()
+    public static final ColumnFamily.Factory<AtomicSortedColumns> factory = new Factory<AtomicSortedColumns>()
     {
-        public ISortedColumns create(AbstractType<?> comparator, boolean insertReversed)
+        public AtomicSortedColumns create(CFMetaData metadata, boolean insertReversed)
         {
-            return new AtomicSortedColumns(comparator);
-        }
-
-        public ISortedColumns fromSorted(SortedMap<ByteBuffer, Column> sortedMap, boolean insertReversed)
-        {
-            return new AtomicSortedColumns(sortedMap);
+            return new AtomicSortedColumns(metadata);
         }
     };
 
-    public static ISortedColumns.Factory factory()
-    {
-        return factory;
-    }
-
-    private AtomicSortedColumns(AbstractType<?> comparator)
-    {
-        this(new Holder(comparator));
-    }
-
-    private AtomicSortedColumns(SortedMap<ByteBuffer, Column> columns)
+    private AtomicSortedColumns(CFMetaData metadata)
     {
-        this(new Holder(columns));
+        this(metadata, new Holder(metadata.comparator));
     }
 
-    private AtomicSortedColumns(Holder holder)
+    private AtomicSortedColumns(CFMetaData metadata, Holder holder)
     {
+        super(metadata);
         this.ref = new AtomicReference<Holder>(holder);
     }
 
@@ -87,17 +74,17 @@ public class AtomicSortedColumns implements ISortedColumns
         return (AbstractType<?>)ref.get().map.comparator();
     }
 
-    public ISortedColumns.Factory getFactory()
+    public ColumnFamily.Factory getFactory()
     {
         return factory;
     }
 
-    public ISortedColumns cloneMe()
+    public ColumnFamily cloneMe()
     {
-        return new AtomicSortedColumns(ref.get().cloneMe());
+        return new AtomicSortedColumns(metadata, ref.get().cloneMe());
     }
 
-    public DeletionInfo getDeletionInfo()
+    public DeletionInfo deletionInfo()
     {
         return ref.get().deletionInfo;
     }
@@ -142,12 +129,17 @@ public class AtomicSortedColumns implements ISortedColumns
         while (!ref.compareAndSet(current, modified));
     }
 
-    public void addAll(ISortedColumns cm, Allocator allocator, Function<Column, Column> transformation)
+    public void addAll(ColumnFamily cm, Allocator allocator, Function<Column, Column> transformation)
     {
         addAllWithSizeDelta(cm, allocator, transformation, SecondaryIndexManager.nullUpdater);
     }
 
-    public long addAllWithSizeDelta(ISortedColumns cm, Allocator allocator, Function<Column, Column> transformation, SecondaryIndexManager.Updater indexer)
+    /**
+     *  This is only called by Memtable.resolve, so only AtomicSortedColumns needs to implement it.
+     *
+     *  @return the difference in size seen after merging the given columns
+     */
+    public long addAllWithSizeDelta(ColumnFamily cm, Allocator allocator, Function<Column, Column> transformation, SecondaryIndexManager.Updater indexer)
     {
         /*
          * This operation needs to atomicity and isolation. To that end, we
@@ -168,10 +160,10 @@ public class AtomicSortedColumns implements ISortedColumns
         {
             sizeDelta = 0;
             current = ref.get();
-            DeletionInfo newDelInfo = current.deletionInfo.add(cm.getDeletionInfo());
+            DeletionInfo newDelInfo = current.deletionInfo.add(cm.deletionInfo());
             modified = new Holder(current.map.clone(), newDelInfo);
 
-            for (Column column : cm.getSortedColumns())
+            for (Column column : cm)
             {
                 sizeDelta += modified.addColumn(transformation.apply(column), allocator, indexer);
                 // bail early if we know we've been beaten
@@ -201,18 +193,6 @@ public class AtomicSortedColumns implements ISortedColumns
         return replaced;
     }
 
-    public void removeColumn(ByteBuffer name)
-    {
-        Holder current, modified;
-        do
-        {
-            current = ref.get();
-            modified = current.cloneMe();
-            modified.map.remove(name);
-        }
-        while (!ref.compareAndSet(current, modified));
-    }
-
     public void clear()
     {
         Holder current, modified;
@@ -244,7 +224,7 @@ public class AtomicSortedColumns implements ISortedColumns
         return ref.get().map.descendingMap().values();
     }
 
-    public int size()
+    public int getColumnCount()
     {
         return ref.get().map.size();
     }
@@ -254,11 +234,6 @@ public class AtomicSortedColumns implements ISortedColumns
         return ref.get().map.isEmpty();
     }
 
-    public Iterator<Column> iterator()
-    {
-        return getSortedColumns().iterator();
-    }
-
     public Iterator<Column> iterator(ColumnSlice[] slices)
     {
         return new ColumnSlice.NavigableMapIterator(ref.get().map, slices);
@@ -345,7 +320,7 @@ public class AtomicSortedColumns implements ISortedColumns
             }
         }
 
-        void retainAll(ISortedColumns columns)
+        void retainAll(ColumnFamily columns)
         {
             Iterator<Column> iter = map.values().iterator();
             Iterator<Column> toRetain = columns.iterator();
diff --git a/src/java/org/apache/cassandra/db/BatchlogManager.java b/src/java/org/apache/cassandra/db/BatchlogManager.java
index 946ec313af..500021d159 100644
--- a/src/java/org/apache/cassandra/db/BatchlogManager.java
+++ b/src/java/org/apache/cassandra/db/BatchlogManager.java
@@ -134,9 +134,9 @@ public class BatchlogManager implements BatchlogManagerMBean
         ByteBuffer writtenAt = LongType.instance.decompose(timestamp / 1000);
         ByteBuffer data = serializeRowMutations(mutations);
 
-        ColumnFamily cf = ColumnFamily.create(CFMetaData.BatchlogCF);
-        cf.addColumn(new Column(WRITTEN_AT, writtenAt, timestamp));
+        ColumnFamily cf = ArrayBackedSortedColumns.factory.create(CFMetaData.BatchlogCF);
         cf.addColumn(new Column(DATA, data, timestamp));
+        cf.addColumn(new Column(WRITTEN_AT, writtenAt, timestamp));
 
         return new RowMutation(Table.SYSTEM_KS, UUIDType.instance.decompose(uuid), cf);
     }
diff --git a/src/java/org/apache/cassandra/db/CollationController.java b/src/java/org/apache/cassandra/db/CollationController.java
index 5e477a8d81..2ea2d01216 100644
--- a/src/java/org/apache/cassandra/db/CollationController.java
+++ b/src/java/org/apache/cassandra/db/CollationController.java
@@ -43,7 +43,7 @@ public class CollationController
 
     private final ColumnFamilyStore cfs;
     private final QueryFilter filter;
-    private final ISortedColumns.Factory factory;
+    private final ColumnFamily.Factory factory;
     private final int gcBefore;
 
     private int sstablesIterated = 0;
@@ -55,8 +55,8 @@ public class CollationController
         this.gcBefore = gcBefore;
 
         this.factory = mutableColumns
-                     ? AtomicSortedColumns.factory()
-                     : ArrayBackedSortedColumns.factory();
+                     ? AtomicSortedColumns.factory
+                     : ArrayBackedSortedColumns.factory;
     }
 
     public ColumnFamily getTopLevelColumns()
@@ -75,7 +75,7 @@ public class CollationController
     private ColumnFamily collectTimeOrderedData()
     {
         logger.trace("collectTimeOrderedData");
-        ColumnFamily container = ColumnFamily.create(cfs.metadata, factory, filter.filter.isReversed());
+        ColumnFamily container = factory.create(cfs.metadata, filter.filter.isReversed());
         List<OnDiskAtomIterator> iterators = new ArrayList<OnDiskAtomIterator>();
         Tracing.trace("Acquiring sstable references");
         ColumnFamilyStore.ViewFragment view = cfs.markReferenced(filter.key);
@@ -84,7 +84,7 @@ public class CollationController
         // which requires addAtom to happen in sorted order.  Then we use addAll to merge into the final collection,
         // which allows a (sorted) set of columns to be merged even if they are not uniformly sorted after the existing
         // ones.
-        ColumnFamily temp = ColumnFamily.create(cfs.metadata, ArrayBackedSortedColumns.factory(), filter.filter.isReversed());
+        ColumnFamily temp = ArrayBackedSortedColumns.factory.create(cfs.metadata, filter.filter.isReversed());
 
         try
         {
@@ -229,7 +229,7 @@ public class CollationController
         Tracing.trace("Acquiring sstable references");
         ColumnFamilyStore.ViewFragment view = cfs.markReferenced(filter.key);
         List<OnDiskAtomIterator> iterators = new ArrayList<OnDiskAtomIterator>(Iterables.size(view.memtables) + view.sstables.size());
-        ColumnFamily returnCF = ColumnFamily.create(cfs.metadata, factory, filter.filter.isReversed());
+        ColumnFamily returnCF = factory.create(cfs.metadata, filter.filter.isReversed());
 
         try
         {
diff --git a/src/java/org/apache/cassandra/db/ColumnFamily.java b/src/java/org/apache/cassandra/db/ColumnFamily.java
index c1834127db..a72c1bd605 100644
--- a/src/java/org/apache/cassandra/db/ColumnFamily.java
+++ b/src/java/org/apache/cassandra/db/ColumnFamily.java
@@ -21,97 +21,66 @@ import java.nio.ByteBuffer;
 import java.security.MessageDigest;
 import java.util.Collection;
 import java.util.Iterator;
-import java.util.SortedSet;
 import java.util.UUID;
 
 import com.google.common.base.Function;
 import com.google.common.base.Functions;
 
-import org.apache.cassandra.db.filter.ColumnSlice;
-import org.apache.cassandra.db.index.SecondaryIndexManager;
-import org.apache.cassandra.db.marshal.AbstractType;
-import org.apache.cassandra.io.sstable.SSTable;
-import org.apache.cassandra.utils.*;
-
 import org.apache.commons.lang.builder.HashCodeBuilder;
 
 import org.apache.cassandra.cache.IRowCacheEntry;
 import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.config.Schema;
-import org.apache.cassandra.db.marshal.MarshalException;
+import org.apache.cassandra.db.filter.ColumnSlice;
+import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.io.sstable.ColumnStats;
+import org.apache.cassandra.io.sstable.SSTable;
+import org.apache.cassandra.utils.*;
 
-public class ColumnFamily implements IRowCacheEntry, Iterable<Column>
+/**
+ * A sorted map of columns.
+ * This represents the backing map of a colum family.
+ *
+ * Whether the implementation is thread safe or not is left to the
+ * implementing classes.
+ */
+public abstract class ColumnFamily implements Iterable<Column>, IRowCacheEntry
 {
     /* The column serializer for this Column Family. Create based on config. */
     public static final ColumnFamilySerializer serializer = new ColumnFamilySerializer();
-    private final CFMetaData cfm;
-    protected final ISortedColumns columns;
-
-    public static ColumnFamily create(UUID cfId)
-    {
-        return create(Schema.instance.getCFMetaData(cfId));
-    }
-
-    public static ColumnFamily create(UUID cfId, ISortedColumns.Factory factory)
-    {
-        return create(Schema.instance.getCFMetaData(cfId), factory);
-    }
-
-    public static ColumnFamily create(String tableName, String cfName)
-    {
-        return create(Schema.instance.getCFMetaData(tableName, cfName));
-    }
-
-    public static ColumnFamily create(CFMetaData cfm)
-    {
-        return create(cfm, TreeMapBackedSortedColumns.factory());
-    }
-
-    public static ColumnFamily create(CFMetaData cfm, ISortedColumns.Factory factory)
-    {
-        return create(cfm, factory, false);
-    }
 
-    public static ColumnFamily create(CFMetaData cfm, ISortedColumns.Factory factory, boolean reversedInsertOrder)
-    {
-        return new ColumnFamily(cfm, factory.create(cfm.comparator, reversedInsertOrder));
-    }
+    protected final CFMetaData metadata;
 
-    protected ColumnFamily(CFMetaData cfm, ISortedColumns columns)
+    protected ColumnFamily(CFMetaData metadata)
     {
-        this.columns = columns;
-        assert cfm != null;
-        this.cfm = cfm;
+        this.metadata = metadata;
     }
 
-    public ColumnFamily cloneMeShallow(ISortedColumns.Factory factory, boolean reversedInsertOrder)
+    public <T extends ColumnFamily> T cloneMeShallow(ColumnFamily.Factory<T> factory, boolean reversedInsertOrder)
     {
-        ColumnFamily cf = ColumnFamily.create(cfm, factory, reversedInsertOrder);
+        T cf = factory.create(metadata, reversedInsertOrder);
         cf.delete(this);
         return cf;
     }
 
     public ColumnFamily cloneMeShallow()
     {
-        return cloneMeShallow(columns.getFactory(), columns.isInsertReversed());
+        return cloneMeShallow(getFactory(), isInsertReversed());
     }
 
     public ColumnFamilyType getType()
     {
-        return cfm.cfType;
+        return metadata.cfType;
     }
 
-    public ColumnFamily cloneMe()
-    {
-        ColumnFamily cf = new ColumnFamily(cfm, columns.cloneMe());
-        cf.delete(this);
-        return cf;
-    }
+    /**
+     * Clones the column map.
+     */
+    public abstract ColumnFamily cloneMe();
 
     public UUID id()
     {
-        return cfm.cfId;
+        return metadata.cfId;
     }
 
     /**
@@ -119,7 +88,12 @@ public class ColumnFamily implements IRowCacheEntry, Iterable<Column>
      */
     public CFMetaData metadata()
     {
-        return cfm;
+        return metadata;
+    }
+
+    public void addColumn(Column column)
+    {
+        addColumn(column, HeapAllocator.instance);
     }
 
     public void addColumn(ByteBuffer name, ByteBuffer value, long timestamp)
@@ -162,9 +136,108 @@ public class ColumnFamily implements IRowCacheEntry, Iterable<Column>
         }
     }
 
-    public void clear()
+    /**
+     * Clear this column map, removing all columns.
+     */
+    public abstract void clear();
+
+    /**
+     * Returns the factory used for this ISortedColumns implementation.
+     */
+    public abstract Factory getFactory();
+
+    public abstract DeletionInfo deletionInfo();
+    public abstract void setDeletionInfo(DeletionInfo info);
+
+    public abstract void delete(DeletionInfo info);
+    public abstract void maybeResetDeletionTimes(int gcBefore);
+
+    /**
+     * Adds a column to this column map.
+     * If a column with the same name is already present in the map, it will
+     * be replaced by the newly added column.
+     */
+    public abstract void addColumn(Column column, Allocator allocator);
+
+    /**
+     * Adds all the columns of a given column map to this column map.
+     * This is equivalent to:
+     *   <code>
+     *   for (Column c : cm)
+     *      addColumn(c, ...);
+     *   </code>
+     *  but is potentially faster.
+     */
+     public abstract void addAll(ColumnFamily cm, Allocator allocator, Function<Column, Column> transformation);
+
+    /**
+     * Replace oldColumn if present by newColumn.
+     * Returns true if oldColumn was present and thus replaced.
+     * oldColumn and newColumn should have the same name.
+     */
+    public abstract boolean replace(Column oldColumn, Column newColumn);
+
+    /**
+     * Get a column given its name, returning null if the column is not
+     * present.
+     */
+    public abstract Column getColumn(ByteBuffer name);
+
+    /**
+     * Returns an iterable with the names of columns in this column map in the same order
+     * as the underlying columns themselves.
+     */
+    public abstract Iterable<ByteBuffer> getColumnNames();
+
+    /**
+     * Returns the columns of this column map as a collection.
+     * The columns in the returned collection should be sorted as the columns
+     * in this map.
+     */
+    public abstract Collection<Column> getSortedColumns();
+
+    /**
+     * Returns the columns of this column map as a collection.
+     * The columns in the returned collection should be sorted in reverse
+     * order of the columns in this map.
+     */
+    public abstract Collection<Column> getReverseSortedColumns();
+
+    /**
+     * Returns the number of columns in this map.
+     */
+    public abstract int getColumnCount();
+
+    /**
+     * Returns true if this map is empty, false otherwise.
+     */
+    public abstract boolean isEmpty();
+
+    /**
+     * Returns an iterator over the columns of this map that returns only the matching @param slices.
+     * The provided slices must be in order and must be non-overlapping.
+     */
+    public abstract Iterator<Column> iterator(ColumnSlice[] slices);
+
+    /**
+     * Returns a reversed iterator over the columns of this map that returns only the matching @param slices.
+     * The provided slices must be in reversed order and must be non-overlapping.
+     */
+    public abstract Iterator<Column> reverseIterator(ColumnSlice[] slices);
+
+    /**
+     * Returns if this map only support inserts in reverse order.
+     */
+    public abstract boolean isInsertReversed();
+
+    public void delete(ColumnFamily columns)
     {
-        columns.clear();
+        delete(columns.deletionInfo());
+    }
+
+    public void addAll(ColumnFamily cf, Allocator allocator)
+    {
+        addAll(cf, allocator, Functions.<Column>identity());
     }
 
     /*
@@ -174,7 +247,7 @@ public class ColumnFamily implements IRowCacheEntry, Iterable<Column>
     public ColumnFamily diff(ColumnFamily cfComposite)
     {
         assert cfComposite.id().equals(id());
-        ColumnFamily cfDiff = ColumnFamily.create(cfm);
+        ColumnFamily cfDiff = TreeMapBackedSortedColumns.factory.create(metadata);
         cfDiff.delete(cfComposite.deletionInfo());
 
         // (don't need to worry about cfNew containing Columns that are shadowed by
@@ -183,7 +256,7 @@ public class ColumnFamily implements IRowCacheEntry, Iterable<Column>
         for (Column columnExternal : cfComposite)
         {
             ByteBuffer cName = columnExternal.name();
-            Column columnInternal = this.columns.getColumn(cName);
+            Column columnInternal = getColumn(cName);
             if (columnInternal == null)
             {
                 cfDiff.addColumn(columnExternal);
@@ -206,7 +279,7 @@ public class ColumnFamily implements IRowCacheEntry, Iterable<Column>
     public long maxTimestamp()
     {
         long maxTimestamp = deletionInfo().maxTimestamp();
-        for (Column column : columns)
+        for (Column column : this)
             maxTimestamp = Math.max(maxTimestamp, column.maxTimestamp());
         return maxTimestamp;
     }
@@ -214,10 +287,12 @@ public class ColumnFamily implements IRowCacheEntry, Iterable<Column>
     @Override
     public int hashCode()
     {
-        return new HashCodeBuilder(373, 75437)
-                    .append(cfm)
-                    .append(deletionInfo())
-                    .append(columns).toHashCode();
+        HashCodeBuilder builder = new HashCodeBuilder(373, 75437)
+                .append(metadata)
+                .append(deletionInfo());
+        for (Column column : this)
+            builder.append(column);
+        return builder.hashCode();
     }
 
     @Override
@@ -225,27 +300,26 @@ public class ColumnFamily implements IRowCacheEntry, Iterable<Column>
     {
         if (this == o)
             return true;
-        if (o == null || this.getClass() != o.getClass())
+        if (o == null || !(o instanceof ColumnFamily))
             return false;
 
         ColumnFamily comparison = (ColumnFamily) o;
 
-        return cfm.equals(comparison.cfm)
-                && deletionInfo().equals(comparison.deletionInfo())
-                && ByteBufferUtil.compareUnsigned(digest(this), digest(comparison)) == 0;
+        return metadata.equals(comparison.metadata)
+               && deletionInfo().equals(comparison.deletionInfo())
+               && ByteBufferUtil.compareUnsigned(digest(this), digest(comparison)) == 0;
     }
 
     @Override
     public String toString()
     {
         StringBuilder sb = new StringBuilder("ColumnFamily(");
-        CFMetaData cfm = metadata();
-        sb.append(cfm == null ? "<anonymous>" : cfm.cfName);
+        sb.append(metadata == null ? "<anonymous>" : metadata.cfName);
 
         if (isMarkedForDelete())
             sb.append(" -").append(deletionInfo()).append("-");
 
-        sb.append(" [").append(getComparator().getColumnsString(getSortedColumns())).append("])");
+        sb.append(" [").append(getComparator().getColumnsString(this)).append("])");
         return sb.toString();
     }
 
@@ -259,7 +333,7 @@ public class ColumnFamily implements IRowCacheEntry, Iterable<Column>
 
     public void updateDigest(MessageDigest digest)
     {
-        for (Column column : columns)
+        for (Column column : this)
             column.updateDigest(digest);
     }
 
@@ -283,20 +357,6 @@ public class ColumnFamily implements IRowCacheEntry, Iterable<Column>
         addAll(cf, allocator);
     }
 
-    /**
-     * Goes over all columns and check the fields are valid (as far as we can
-     * tell).
-     * This is used to detect corruption after deserialization.
-     */
-    public void validateColumnFields() throws MarshalException
-    {
-        CFMetaData metadata = metadata();
-        for (Column column : this)
-        {
-            column.validateFields(metadata);
-        }
-    }
-
     public ColumnStats getColumnStats()
     {
         long minTimestampSeen = deletionInfo() == DeletionInfo.LIVE ? Long.MAX_VALUE : deletionInfo().minTimestamp();
@@ -304,7 +364,7 @@ public class ColumnFamily implements IRowCacheEntry, Iterable<Column>
         StreamingHistogram tombstones = new StreamingHistogram(SSTable.TOMBSTONE_HISTOGRAM_BIN_SIZE);
         int maxLocalDeletionTime = Integer.MIN_VALUE;
 
-        for (Column column : columns)
+        for (Column column : this)
         {
             minTimestampSeen = Math.min(minTimestampSeen, column.minTimestamp());
             maxTimestampSeen = Math.max(maxTimestampSeen, column.maxTimestamp());
@@ -316,122 +376,22 @@ public class ColumnFamily implements IRowCacheEntry, Iterable<Column>
         return new ColumnStats(getColumnCount(), minTimestampSeen, maxTimestampSeen, maxLocalDeletionTime, tombstones);
     }
 
-    public void delete(ColumnFamily cc2)
-    {
-        delete(cc2.columns.getDeletionInfo());
-    }
-
-    public void delete(DeletionInfo delInfo)
-    {
-        columns.delete(delInfo);
-    }
-
-    // Contrarily to delete(), this will use the provided info even if those
-    // are older that the current ones. Used for SuperColumn in QueryFilter.
-    // delete() is probably the right method in all other cases.
-    public void setDeletionInfo(DeletionInfo delInfo)
-    {
-        columns.setDeletionInfo(delInfo);
-    }
-
     public boolean isMarkedForDelete()
     {
         return !deletionInfo().isLive();
     }
 
-    public DeletionInfo deletionInfo()
-    {
-        return columns.getDeletionInfo();
-    }
-
-    public AbstractType<?> getComparator()
-    {
-        return columns.getComparator();
-    }
-
     /**
-     * Drops expired row-level tombstones.  Normally, these are dropped once the row no longer exists, but
-     * if new columns are inserted into the row post-deletion, they can keep the row tombstone alive indefinitely,
-     * with non-intuitive results.  See https://issues.apache.org/jira/browse/CASSANDRA-2317
+     * @return the comparator whose sorting order the contained columns conform to
      */
-    public void maybeResetDeletionTimes(int gcBefore)
-    {
-        columns.maybeResetDeletionTimes(gcBefore);
-    }
-
-    public long addAllWithSizeDelta(ColumnFamily cc, Allocator allocator, Function<Column, Column> transformation, SecondaryIndexManager.Updater indexer)
-    {
-        return columns.addAllWithSizeDelta(cc.columns, allocator, transformation, indexer);
-    }
-
-    public void addAll(ColumnFamily cc, Allocator allocator, Function<Column, Column> transformation)
-    {
-        columns.addAll(cc.columns, allocator, transformation);
-    }
-
-    public void addAll(ColumnFamily cc, Allocator allocator)
-    {
-        addAll(cc, allocator, Functions.<Column>identity());
-    }
-
-    public void addColumn(Column column)
-    {
-        addColumn(column, HeapAllocator.instance);
-    }
-
-    public void addColumn(Column column, Allocator allocator)
-    {
-        columns.addColumn(column, allocator);
-    }
-
-    public Column getColumn(ByteBuffer name)
-    {
-        return columns.getColumn(name);
-    }
-
-    public boolean replace(Column oldColumn, Column newColumn)
-    {
-        return columns.replace(oldColumn, newColumn);
-    }
-
-    /*
-    * Note that for some of the implementation backing the container, the
-    * return set may not have implementation for tailSet, headSet and subSet.
-    * See ColumnNamesSet in ArrayBackedSortedColumns for more details.
-    */
-    public SortedSet<ByteBuffer> getColumnNames()
-    {
-        return columns.getColumnNames();
-    }
-
-    public Collection<Column> getSortedColumns()
-    {
-        return columns.getSortedColumns();
-    }
-
-    public Collection<Column> getReverseSortedColumns()
-    {
-        return columns.getReverseSortedColumns();
-    }
-
-    public void remove(ByteBuffer columnName)
-    {
-        columns.removeColumn(columnName);
-    }
-
-    public int getColumnCount()
-    {
-        return columns.size();
-    }
-
-    public boolean isEmpty()
+    public AbstractType<?> getComparator()
     {
-        return columns.isEmpty();
+        return metadata.comparator;
     }
 
     public boolean hasOnlyTombstones()
     {
-        for (Column column : columns)
+        for (Column column : this)
         {
             if (column.isLive())
                 return false;
@@ -441,17 +401,7 @@ public class ColumnFamily implements IRowCacheEntry, Iterable<Column>
 
     public Iterator<Column> iterator()
     {
-        return columns.iterator();
-    }
-
-    public Iterator<Column> iterator(ColumnSlice[] slices)
-    {
-        return columns.iterator(slices);
-    }
-
-    public Iterator<Column> reverseIterator(ColumnSlice[] slices)
-    {
-        return columns.reverseIterator(slices);
+        return getSortedColumns().iterator();
     }
 
     public boolean hasIrrelevantData(int gcBefore)
@@ -461,10 +411,33 @@ public class ColumnFamily implements IRowCacheEntry, Iterable<Column>
             return true;
 
         // Do we have colums that are either deleted by the container or gcable tombstone?
-        for (Column column : columns)
+        for (Column column : this)
             if (deletionInfo().isDeleted(column) || column.hasIrrelevantData(gcBefore))
                 return true;
 
         return false;
     }
+
+    public abstract static class Factory <T extends ColumnFamily>
+    {
+        /**
+         * Returns a (initially empty) column map whose columns are sorted
+         * according to the provided comparator.
+         * The {@code insertReversed} flag is an hint on how we expect insertion to be perfomed,
+         * either in sorted or reverse sorted order. This is used by ArrayBackedSortedColumns to
+         * allow optimizing for both forward and reversed slices. This does not matter for ThreadSafeSortedColumns.
+         * Note that this is only an hint on how we expect to do insertion, this does not change the map sorting.
+         */
+        public abstract T create(CFMetaData metadata, boolean insertReversed);
+
+        public T create(CFMetaData metadata)
+        {
+            return create(metadata, false);
+        }
+
+        public T create(String keyspace, String cfName)
+        {
+            return create(Schema.instance.getCFMetaData(keyspace, cfName));
+        }
+    }
 }
diff --git a/src/java/org/apache/cassandra/db/ColumnFamilySerializer.java b/src/java/org/apache/cassandra/db/ColumnFamilySerializer.java
index 0a1db4e22e..ff967956e2 100644
--- a/src/java/org/apache/cassandra/db/ColumnFamilySerializer.java
+++ b/src/java/org/apache/cassandra/db/ColumnFamilySerializer.java
@@ -92,11 +92,16 @@ public class ColumnFamilySerializer implements IVersionedSerializer<ColumnFamily
     }
 
     public ColumnFamily deserialize(DataInput in, ColumnSerializer.Flag flag, int version) throws IOException
+    {
+        return deserialize(in, ArrayBackedSortedColumns.factory, flag, version);
+    }
+
+    public ColumnFamily deserialize(DataInput in, ColumnFamily.Factory factory, ColumnSerializer.Flag flag, int version) throws IOException
     {
         if (!in.readBoolean())
             return null;
 
-        ColumnFamily cf = ColumnFamily.create(deserializeCfId(in, version), ArrayBackedSortedColumns.factory());
+        ColumnFamily cf = factory.create(Schema.instance.getCFMetaData(deserializeCfId(in, version)));
         int expireBefore = (int) (System.currentTimeMillis() / 1000);
 
         if (cf.metadata().isSuper() && version < MessagingService.VERSION_20)
diff --git a/src/java/org/apache/cassandra/db/ColumnFamilyStore.java b/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
index f1bd877db0..972784acbf 100644
--- a/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
+++ b/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
@@ -1300,7 +1300,7 @@ public class ColumnFamilyStore implements ColumnFamilyStoreMBean
      */
     ColumnFamily filterColumnFamily(ColumnFamily cached, QueryFilter filter, int gcBefore)
     {
-        ColumnFamily cf = cached.cloneMeShallow(ArrayBackedSortedColumns.factory(), filter.filter.isReversed());
+        ColumnFamily cf = cached.cloneMeShallow(ArrayBackedSortedColumns.factory, filter.filter.isReversed());
         OnDiskAtomIterator ci = filter.getMemtableColumnIterator(cached, null);
         filter.collateOnDiskAtom(cf, Collections.singletonList(ci), gcBefore);
         return removeDeletedCF(cf, gcBefore);
diff --git a/src/java/org/apache/cassandra/db/CounterMutation.java b/src/java/org/apache/cassandra/db/CounterMutation.java
index 6bb3f44ed0..b414c0541d 100644
--- a/src/java/org/apache/cassandra/db/CounterMutation.java
+++ b/src/java/org/apache/cassandra/db/CounterMutation.java
@@ -28,6 +28,8 @@ import java.util.SortedSet;
 import java.util.TreeSet;
 import java.util.UUID;
 
+import com.google.common.collect.Iterables;
+
 import org.apache.cassandra.db.filter.NamesQueryFilter;
 import org.apache.cassandra.io.IVersionedSerializer;
 import org.apache.cassandra.net.MessageOut;
@@ -101,8 +103,8 @@ public class CounterMutation implements IMutation
 
     private void addReadCommandFromColumnFamily(String table, ByteBuffer key, ColumnFamily columnFamily, List<ReadCommand> commands)
     {
-        SortedSet s = new TreeSet<ByteBuffer>(columnFamily.metadata().comparator);
-        s.addAll(columnFamily.getColumnNames());
+        SortedSet<ByteBuffer> s = new TreeSet<ByteBuffer>(columnFamily.metadata().comparator);
+        Iterables.addAll(s, columnFamily.getColumnNames());
         commands.add(new SliceByNamesReadCommand(table, key, columnFamily.metadata().cfName, new NamesQueryFilter(s)));
     }
 
diff --git a/src/java/org/apache/cassandra/db/DefsTable.java b/src/java/org/apache/cassandra/db/DefsTable.java
index be9131489b..dadf140cdb 100644
--- a/src/java/org/apache/cassandra/db/DefsTable.java
+++ b/src/java/org/apache/cassandra/db/DefsTable.java
@@ -178,7 +178,7 @@ public class DefsTable
             if (Schema.invalidSchemaRow(row))
                 continue;
 
-            for (Column column : row.cf.columns)
+            for (Column column : row.cf)
             {
                 Date columnDate = new Date(column.timestamp());
 
@@ -218,7 +218,7 @@ public class DefsTable
 
             RowMutation mutation = new RowMutation(Table.SYSTEM_KS, row.key.key);
 
-            for (Column column : row.cf.columns)
+            for (Column column : row.cf)
             {
                 if (column.isLive())
                     mutation.add(columnFamily, column.name(), column.value(), microTimestamp);
@@ -275,10 +275,9 @@ public class DefsTable
             org.apache.avro.Schema schema = org.apache.avro.Schema.parse(ByteBufferUtil.string(value));
 
             // deserialize keyspaces using schema
-            Collection<Column> columns = cf.getSortedColumns();
-            keyspaces = new ArrayList<KSMetaData>(columns.size());
+            keyspaces = new ArrayList<KSMetaData>(Iterables.size(cf));
 
-            for (Column column : columns)
+            for (Column column : cf)
             {
                 if (column.name().equals(DEFINITION_SCHEMA_COLUMN_NAME))
                     continue;
diff --git a/src/java/org/apache/cassandra/db/EmptyColumns.java b/src/java/org/apache/cassandra/db/EmptyColumns.java
new file mode 100644
index 0000000000..aa48375de1
--- /dev/null
+++ b/src/java/org/apache/cassandra/db/EmptyColumns.java
@@ -0,0 +1,98 @@
+package org.apache.cassandra.db;
+
+import java.nio.ByteBuffer;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Iterator;
+
+import com.google.common.base.Function;
+
+import com.sun.xml.internal.xsom.impl.scd.Iterators;
+import org.apache.cassandra.config.CFMetaData;
+import org.apache.cassandra.db.filter.ColumnSlice;
+import org.apache.cassandra.utils.Allocator;
+
+public class EmptyColumns extends AbstractThreadUnsafeSortedColumns
+{
+    public static final Factory<EmptyColumns> factory = new Factory<EmptyColumns>()
+    {
+        public EmptyColumns create(CFMetaData metadata, boolean insertReversed)
+        {
+            assert !insertReversed;
+            return new EmptyColumns(metadata, DeletionInfo.LIVE);
+        }
+    };
+
+    public EmptyColumns(CFMetaData metadata, DeletionInfo info)
+    {
+        super(metadata, info);
+    }
+
+    public ColumnFamily cloneMe()
+    {
+        return new EmptyColumns(metadata, deletionInfo);
+    }
+
+    public void clear() {
+    }
+
+    public Factory<EmptyColumns> getFactory()
+    {
+        return factory;
+    }
+
+    public void addColumn(Column column, Allocator allocator)
+    {
+        throw new UnsupportedOperationException();
+    }
+
+    public void addAll(ColumnFamily cm, Allocator allocator, Function<Column, Column> transformation)
+    {
+        throw new UnsupportedOperationException();
+    }
+
+    public boolean replace(Column oldColumn, Column newColumn)
+    {
+        throw new UnsupportedOperationException();
+    }
+
+    public Column getColumn(ByteBuffer name)
+    {
+        throw new UnsupportedOperationException();
+    }
+
+    public Iterable<ByteBuffer> getColumnNames()
+    {
+        return Collections.emptyList();
+    }
+
+    public Collection<Column> getSortedColumns()
+    {
+        return Collections.emptyList();
+    }
+
+    public Collection<Column> getReverseSortedColumns()
+    {
+        return Collections.emptyList();
+    }
+
+    public int getColumnCount()
+    {
+        return 0;
+    }
+
+    public Iterator<Column> iterator(ColumnSlice[] slices)
+    {
+        return Iterators.empty();
+    }
+
+    public Iterator<Column> reverseIterator(ColumnSlice[] slices)
+    {
+        return Iterators.empty();
+    }
+
+    public boolean isInsertReversed()
+    {
+        return false;
+    }
+}
diff --git a/src/java/org/apache/cassandra/db/HintedHandOffManager.java b/src/java/org/apache/cassandra/db/HintedHandOffManager.java
index cb306aed1c..6f2ecb462b 100644
--- a/src/java/org/apache/cassandra/db/HintedHandOffManager.java
+++ b/src/java/org/apache/cassandra/db/HintedHandOffManager.java
@@ -129,7 +129,7 @@ public class HintedHandOffManager implements HintedHandOffManagerMBean
         // serialize the hint with id and version as a composite column name
         ByteBuffer name = comparator.decompose(hintId, MessagingService.current_version);
         ByteBuffer value = ByteBuffer.wrap(FBUtilities.serialize(mutation, RowMutation.serializer, MessagingService.current_version));
-        ColumnFamily cf = ColumnFamily.create(Schema.instance.getCFMetaData(Table.SYSTEM_KS, SystemTable.HINTS_CF));
+        ColumnFamily cf = ArrayBackedSortedColumns.factory.create(Schema.instance.getCFMetaData(Table.SYSTEM_KS, SystemTable.HINTS_CF));
         cf.addColumn(name, value, System.currentTimeMillis(), ttl);
 
         return new RowMutation(Table.SYSTEM_KS, UUIDType.instance.decompose(targetId), cf);
@@ -350,7 +350,7 @@ public class HintedHandOffManager implements HintedHandOffManagerMBean
 
             List<WriteResponseHandler> responseHandlers = Lists.newArrayList();
 
-            for (final Column hint : hintsPage.getSortedColumns())
+            for (final Column hint : hintsPage)
             {
                 // check if hints delivery has been paused during the process
                 if (hintedHandOffPaused)
diff --git a/src/java/org/apache/cassandra/db/ISortedColumns.java b/src/java/org/apache/cassandra/db/ISortedColumns.java
deleted file mode 100644
index f9ab2bfdef..0000000000
--- a/src/java/org/apache/cassandra/db/ISortedColumns.java
+++ /dev/null
@@ -1,179 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.cassandra.db;
-
-import java.nio.ByteBuffer;
-import java.util.Collection;
-import java.util.Iterator;
-import java.util.SortedMap;
-import java.util.SortedSet;
-
-import com.google.common.base.Function;
-
-import org.apache.cassandra.db.filter.ColumnSlice;
-import org.apache.cassandra.db.index.SecondaryIndexManager;
-import org.apache.cassandra.db.marshal.AbstractType;
-import org.apache.cassandra.utils.Allocator;
-
-/**
- * A sorted map of columns.
- * This represents the backing map of a colum family.
- *
- * Whether the implementation is thread safe or not is left to the
- * implementing classes.
- */
-public interface ISortedColumns extends Iterable<Column>
-{
-    /**
-     * Shallow cloning of the column map.
-     */
-    public ISortedColumns cloneMe();
-
-    /**
-     * Returns the factory used for this ISortedColumns implementation.
-     */
-    public Factory getFactory();
-
-    public DeletionInfo getDeletionInfo();
-    public void setDeletionInfo(DeletionInfo info);
-
-    public void delete(DeletionInfo info);
-    public void maybeResetDeletionTimes(int gcBefore);
-
-    /**
-     * Adds a column to this column map.
-     * If a column with the same name is already present in the map, it will
-     * be replaced by the newly added column.
-     */
-    public void addColumn(Column column, Allocator allocator);
-
-    /**
-     * Adds all the columns of a given column map to this column map.
-     * This is equivalent to:
-     *   <code>
-     *   for (Column c : cm)
-     *      add(c);
-     *   </code>
-     *  but is potentially faster.
-     *
-     *  @return the difference in size seen after merging the given columns
-     */
-    public long addAllWithSizeDelta(ISortedColumns cm, Allocator allocator, Function<Column, Column> transformation, SecondaryIndexManager.Updater indexer);
-
-    /**
-     * Adds the columns without necessarily computing the size delta
-     */
-    public void addAll(ISortedColumns cm, Allocator allocator, Function<Column, Column> transformation);
-
-    /**
-     * Replace oldColumn if present by newColumn.
-     * Returns true if oldColumn was present and thus replaced.
-     * oldColumn and newColumn should have the same name.
-     */
-    public boolean replace(Column oldColumn, Column newColumn);
-
-    /**
-     * Remove if present a column by name.
-     */
-    public void removeColumn(ByteBuffer name);
-
-    /**
-     * Clear this column map, removing all columns.
-     */
-    public void clear();
-
-    /**
-     * Get a column given its name, returning null if the column is not
-     * present.
-     */
-    public Column getColumn(ByteBuffer name);
-
-    /**
-     * Returns a set with the names of columns in this column map.
-     * The resulting set is sorted and the order is the one of the columns in
-     * this column map.
-     */
-    public SortedSet<ByteBuffer> getColumnNames();
-
-    /**
-     * Returns the columns of this column map as a collection.
-     * The columns in the returned collection should be sorted as the columns
-     * in this map.
-     */
-    public Collection<Column> getSortedColumns();
-
-    /**
-     * Returns the columns of this column map as a collection.
-     * The columns in the returned collection should be sorted in reverse
-     * order of the columns in this map.
-     */
-    public Collection<Column> getReverseSortedColumns();
-
-    /**
-     * Returns the number of columns in this map.
-     */
-    public int size();
-
-    /**
-     * Returns true if this map is empty, false otherwise.
-     */
-    public boolean isEmpty();
-
-    /**
-     * Returns an iterator over the columns of this map that returns only the matching @param slices.
-     * The provided slices must be in order and must be non-overlapping.
-     */
-    public Iterator<Column> iterator(ColumnSlice[] slices);
-
-    /**
-     * Returns a reversed iterator over the columns of this map that returns only the matching @param slices.
-     * The provided slices must be in reversed order and must be non-overlapping.
-     */
-    public Iterator<Column> reverseIterator(ColumnSlice[] slices);
-
-    /**
-     * Returns if this map only support inserts in reverse order.
-     */
-    public boolean isInsertReversed();
-
-    /**
-     * @return the comparator whose sorting order the contained columns conform to
-     */
-    public AbstractType<?> getComparator();
-
-    public interface Factory
-    {
-        /**
-         * Returns a (initially empty) column map whose columns are sorted
-         * according to the provided comparator.
-         * The {@code insertReversed} flag is an hint on how we expect insertion to be perfomed,
-         * either in sorted or reverse sorted order. This is used by ArrayBackedSortedColumns to
-         * allow optimizing for both forward and reversed slices. This does not matter for ThreadSafeSortedColumns.
-         * Note that this is only an hint on how we expect to do insertion, this does not change the map sorting.
-         */
-        public ISortedColumns create(AbstractType<?> comparator, boolean insertReversed);
-
-        /**
-         * Returns a column map whose columns are sorted according to the comparator of the provided sorted
-         * map (which thus, is assumed to _not_ be sorted by natural order) and that initially contains the
-         * columns in the provided sorted map.
-         * See {@code create} for the description of {@code insertReversed}
-         */
-        public ISortedColumns fromSorted(SortedMap<ByteBuffer, Column> sm, boolean insertReversed);
-    }
-}
diff --git a/src/java/org/apache/cassandra/db/Memtable.java b/src/java/org/apache/cassandra/db/Memtable.java
index 0bf94e8307..25c99f3f24 100644
--- a/src/java/org/apache/cassandra/db/Memtable.java
+++ b/src/java/org/apache/cassandra/db/Memtable.java
@@ -110,7 +110,7 @@ public class Memtable
     // We index the memtable by RowPosition only for the purpose of being able
     // to select key range using Token.KeyBound. However put() ensures that we
     // actually only store DecoratedKey.
-    private final ConcurrentNavigableMap<RowPosition, ColumnFamily> columnFamilies = new ConcurrentSkipListMap<RowPosition, ColumnFamily>();
+    private final ConcurrentNavigableMap<RowPosition, AtomicSortedColumns> rows = new ConcurrentSkipListMap<RowPosition, AtomicSortedColumns>();
     public final ColumnFamilyStore cfs;
     private final long creationTime;
 
@@ -121,7 +121,7 @@ public class Memtable
         public Column apply(Column c)
         {
             return c.localCopy(cfs, allocator);
-        };
+        }
     };
 
     // Record the comparator of the CFS at the creation of the memtable. This
@@ -154,11 +154,6 @@ public class Memtable
         return (long) (currentSize.get() * cfs.liveRatio);
     }
 
-    public long getSerializedSize()
-    {
-        return currentSize.get();
-    }
-
     public long getOperations()
     {
         return currentOperations.get();
@@ -201,9 +196,9 @@ public class Memtable
                     long start = System.currentTimeMillis();
                     // ConcurrentSkipListMap has cycles, so measureDeep will have to track a reference to EACH object it visits.
                     // So to reduce the memory overhead of doing a measurement, we break it up to row-at-a-time.
-                    long deepSize = meter.measure(columnFamilies);
+                    long deepSize = meter.measure(rows);
                     int objects = 0;
-                    for (Map.Entry<RowPosition, ColumnFamily> entry : columnFamilies.entrySet())
+                    for (Map.Entry<RowPosition, AtomicSortedColumns> entry : rows.entrySet())
                     {
                         deepSize += meter.measureDeep(entry.getKey()) + meter.measureDeep(entry.getValue());
                         objects += entry.getValue().getColumnCount();
@@ -229,7 +224,7 @@ public class Memtable
                         cfs.liveRatio = (cfs.liveRatio + newRatio) / 2.0;
 
                     logger.info("{} liveRatio is {} (just-counted was {}).  calculation took {}ms for {} columns",
-                                new Object[]{ cfs, cfs.liveRatio, newRatio, System.currentTimeMillis() - start, objects });
+                                cfs, cfs.liveRatio, newRatio, System.currentTimeMillis() - start, objects);
                     activelyMeasuring = null;
                 }
                 finally
@@ -244,13 +239,13 @@ public class Memtable
 
     private void resolve(DecoratedKey key, ColumnFamily cf, SecondaryIndexManager.Updater indexer)
     {
-        ColumnFamily previous = columnFamilies.get(key);
+        AtomicSortedColumns previous = rows.get(key);
 
         if (previous == null)
         {
-            ColumnFamily empty = cf.cloneMeShallow(AtomicSortedColumns.factory(), false);
+            AtomicSortedColumns empty = cf.cloneMeShallow(AtomicSortedColumns.factory, false);
             // We'll add the columns later. This avoids wasting works if we get beaten in the putIfAbsent
-            previous = columnFamilies.putIfAbsent(new DecoratedKey(key.token, allocator.clone(key.key)), empty);
+            previous = rows.putIfAbsent(new DecoratedKey(key.token, allocator.clone(key.key)), empty);
             if (previous == null)
                 previous = empty;
         }
@@ -267,7 +262,7 @@ public class Memtable
     {
         StringBuilder builder = new StringBuilder();
         builder.append("{");
-        for (Map.Entry<RowPosition, ColumnFamily> entry : columnFamilies.entrySet())
+        for (Map.Entry<RowPosition, AtomicSortedColumns> entry : rows.entrySet())
         {
             builder.append(entry.getKey()).append(": ").append(entry.getValue()).append(", ");
         }
@@ -290,25 +285,26 @@ public class Memtable
      * @param startWith Include data in the result from and including this key and to the end of the memtable
      * @return An iterator of entries with the data from the start key
      */
-    public Iterator<Map.Entry<DecoratedKey, ColumnFamily>> getEntryIterator(final RowPosition startWith, final RowPosition stopAt)
+    public Iterator<Map.Entry<DecoratedKey, AtomicSortedColumns>> getEntryIterator(final RowPosition startWith, final RowPosition stopAt)
     {
-        return new Iterator<Map.Entry<DecoratedKey, ColumnFamily>>()
+        return new Iterator<Map.Entry<DecoratedKey, AtomicSortedColumns>>()
         {
-            private Iterator<Map.Entry<RowPosition, ColumnFamily>> iter = stopAt.isMinimum()
-                                                                        ? columnFamilies.tailMap(startWith).entrySet().iterator()
-                                                                        : columnFamilies.subMap(startWith, true, stopAt, true).entrySet().iterator();
+            private Iterator<Map.Entry<RowPosition, AtomicSortedColumns>> iter = stopAt.isMinimum()
+                                                                                 ? rows.tailMap(startWith).entrySet().iterator()
+                                                                                 : rows.subMap(startWith, true, stopAt, true).entrySet().iterator();
 
             public boolean hasNext()
             {
                 return iter.hasNext();
             }
 
-            public Map.Entry<DecoratedKey, ColumnFamily> next()
+            public Map.Entry<DecoratedKey, AtomicSortedColumns> next()
             {
-                Map.Entry<RowPosition, ColumnFamily> entry = iter.next();
+                Map.Entry<RowPosition, AtomicSortedColumns> entry = iter.next();
                 // Actual stored key should be true DecoratedKey
                 assert entry.getKey() instanceof DecoratedKey;
-                return (Map.Entry<DecoratedKey, ColumnFamily>)(Object)entry; // yes, it's ugly
+                // Object cast is required since otherwise we can't turn RowPosition into DecoratedKey
+                return (Map.Entry<DecoratedKey, AtomicSortedColumns>) (Object)entry;
             }
 
             public void remove()
@@ -320,7 +316,7 @@ public class Memtable
 
     public boolean isClean()
     {
-        return columnFamilies.isEmpty();
+        return rows.isEmpty();
     }
 
     /**
@@ -398,12 +394,7 @@ public class Memtable
 
     public ColumnFamily getColumnFamily(DecoratedKey key)
     {
-        return columnFamilies.get(key);
-    }
-
-    void clearUnsafe()
-    {
-        columnFamilies.clear();
+        return rows.get(key);
     }
 
     public long creationTime()
@@ -423,7 +414,7 @@ public class Memtable
             this.context = context;
 
             long keySize = 0;
-            for (RowPosition key : columnFamilies.keySet())
+            for (RowPosition key : rows.keySet())
             {
                 //  make sure we don't write non-sensical keys
                 assert key instanceof DecoratedKey;
@@ -466,7 +457,7 @@ public class Memtable
             {
                 // (we can't clear out the map as-we-go to free up memory,
                 //  since the memtable is being used for queries in the "pending flush" category)
-                for (Map.Entry<RowPosition, ColumnFamily> entry : columnFamilies.entrySet())
+                for (Map.Entry<RowPosition, AtomicSortedColumns> entry : rows.entrySet())
                 {
                     ColumnFamily cf = entry.getValue();
                     if (cf.isMarkedForDelete())
@@ -514,7 +505,7 @@ public class Memtable
         {
             SSTableMetadata.Collector sstableMetadataCollector = SSTableMetadata.createCollector().replayPosition(context.get());
             return new SSTableWriter(filename,
-                                     columnFamilies.size(),
+                                     rows.size(),
                                      cfs.metadata,
                                      cfs.partitioner,
                                      sstableMetadataCollector);
diff --git a/src/java/org/apache/cassandra/db/RowIteratorFactory.java b/src/java/org/apache/cassandra/db/RowIteratorFactory.java
index 38d0fc14d1..1bc506b0db 100644
--- a/src/java/org/apache/cassandra/db/RowIteratorFactory.java
+++ b/src/java/org/apache/cassandra/db/RowIteratorFactory.java
@@ -64,7 +64,7 @@ public class RowIteratorFactory
         // memtables
         for (Memtable memtable : memtables)
         {
-            iterators.add(new ConvertToColumnIterator(filter, memtable.getEntryIterator(startWith, stopAt)));
+            iterators.add(new ConvertToColumnIterator<AtomicSortedColumns>(filter, memtable.getEntryIterator(startWith, stopAt)));
         }
 
         for (SSTableReader sstable : sstables)
@@ -85,7 +85,7 @@ public class RowIteratorFactory
             @Override
             protected void onKeyChange()
             {
-                this.returnCF = ColumnFamily.create(cfs.metadata);
+                this.returnCF = TreeMapBackedSortedColumns.factory.create(cfs.metadata);
             }
 
             public void reduce(OnDiskAtomIterator current)
@@ -122,12 +122,12 @@ public class RowIteratorFactory
     /**
      * Get a ColumnIterator for a specific key in the memtable.
      */
-    private static class ConvertToColumnIterator implements CloseableIterator<OnDiskAtomIterator>
+    private static class ConvertToColumnIterator<T extends ColumnFamily> implements CloseableIterator<OnDiskAtomIterator>
     {
         private final QueryFilter filter;
-        private final Iterator<Map.Entry<DecoratedKey, ColumnFamily>> iter;
+        private final Iterator<Map.Entry<DecoratedKey, T>> iter;
 
-        public ConvertToColumnIterator(QueryFilter filter, Iterator<Map.Entry<DecoratedKey, ColumnFamily>> iter)
+        public ConvertToColumnIterator(QueryFilter filter, Iterator<Map.Entry<DecoratedKey, T>> iter)
         {
             this.filter = filter;
             this.iter = iter;
@@ -147,7 +147,7 @@ public class RowIteratorFactory
          */
         public OnDiskAtomIterator next()
         {
-            final Map.Entry<DecoratedKey, ColumnFamily> entry = iter.next();
+            final Map.Entry<DecoratedKey, T> entry = iter.next();
             return new LazyColumnIterator(entry.getKey(), new IColumnIteratorFactory()
             {
                 public OnDiskAtomIterator create()
diff --git a/src/java/org/apache/cassandra/db/RowMutation.java b/src/java/org/apache/cassandra/db/RowMutation.java
index 9f3efa039d..e945138f42 100644
--- a/src/java/org/apache/cassandra/db/RowMutation.java
+++ b/src/java/org/apache/cassandra/db/RowMutation.java
@@ -116,7 +116,7 @@ public class RowMutation implements IMutation
         ColumnFamily cf = modifications.get(cfm.cfId);
         if (cf == null)
         {
-            cf = ColumnFamily.create(cfm);
+            cf = TreeMapBackedSortedColumns.factory.create(cfm);
             modifications.put(cfm.cfId, cf);
         }
         return cf;
@@ -280,7 +280,7 @@ public class RowMutation implements IMutation
             // We used to uselessly write the cf id here
             if (version < MessagingService.VERSION_12)
                 ColumnFamily.serializer.deserializeCfId(in, version);
-            ColumnFamily cf = ColumnFamily.serializer.deserialize(in, flag, version);
+            ColumnFamily cf = ColumnFamily.serializer.deserialize(in, UnsortedColumns.factory, flag, version);
             // We don't allow RowMutation with null column family, so we should never get null back.
             assert cf != null;
             return cf;
diff --git a/src/java/org/apache/cassandra/db/SliceQueryPager.java b/src/java/org/apache/cassandra/db/SliceQueryPager.java
index 551b50de36..7b8e4d4809 100644
--- a/src/java/org/apache/cassandra/db/SliceQueryPager.java
+++ b/src/java/org/apache/cassandra/db/SliceQueryPager.java
@@ -77,7 +77,7 @@ public class SliceQueryPager implements Iterator<ColumnFamily>
             else
                 slices = Arrays.copyOfRange(slices, i, slices.length);
         }
-        return cf == null ? ColumnFamily.create(cfs.metadata) : cf;
+        return cf == null ? EmptyColumns.factory.create(cfs.metadata) : cf;
     }
 
     public void remove()
diff --git a/src/java/org/apache/cassandra/db/SystemTable.java b/src/java/org/apache/cassandra/db/SystemTable.java
index 95c72980c5..567cf06c72 100644
--- a/src/java/org/apache/cassandra/db/SystemTable.java
+++ b/src/java/org/apache/cassandra/db/SystemTable.java
@@ -154,7 +154,7 @@ public class SystemTable
             cols.add(ByteBufferUtil.bytes("Token"));
             QueryFilter filter = QueryFilter.getNamesFilter(decorate(ByteBufferUtil.bytes("L")), OLD_STATUS_CF, cols);
             ColumnFamily oldCf = oldStatusCfs.getColumnFamily(filter);
-            Iterator<Column> oldColumns = oldCf.columns.iterator();
+            Iterator<Column> oldColumns = oldCf.iterator();
 
             String clusterName = null;
             try
@@ -587,7 +587,7 @@ public class SystemTable
 
     public static void setIndexBuilt(String table, String indexName)
     {
-        ColumnFamily cf = ColumnFamily.create(Table.SYSTEM_KS, INDEX_CF);
+        ColumnFamily cf = ArrayBackedSortedColumns.factory.create(Table.SYSTEM_KS, INDEX_CF);
         cf.addColumn(new Column(ByteBufferUtil.bytes(indexName), ByteBufferUtil.EMPTY_BYTE_BUFFER, FBUtilities.timestampMicros()));
         RowMutation rm = new RowMutation(Table.SYSTEM_KS, ByteBufferUtil.bytes(table), cf);
         rm.apply();
@@ -663,7 +663,7 @@ public class SystemTable
     {
         ByteBuffer ip = ByteBuffer.wrap(FBUtilities.getBroadcastAddress().getAddress());
 
-        ColumnFamily cf = ColumnFamily.create(Table.SYSTEM_KS, COUNTER_ID_CF);
+        ColumnFamily cf = ArrayBackedSortedColumns.factory.create(Table.SYSTEM_KS, COUNTER_ID_CF);
         cf.addColumn(new Column(newCounterId.bytes(), ip, now));
         RowMutation rm = new RowMutation(Table.SYSTEM_KS, ALL_LOCAL_NODE_ID_KEY, cf);
         rm.apply();
diff --git a/src/java/org/apache/cassandra/db/TreeMapBackedSortedColumns.java b/src/java/org/apache/cassandra/db/TreeMapBackedSortedColumns.java
index 20cbd900bb..a9b7c57c76 100644
--- a/src/java/org/apache/cassandra/db/TreeMapBackedSortedColumns.java
+++ b/src/java/org/apache/cassandra/db/TreeMapBackedSortedColumns.java
@@ -26,56 +26,50 @@ import java.util.TreeMap;
 
 import com.google.common.base.Function;
 
+import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.db.filter.ColumnSlice;
 import org.apache.cassandra.db.index.SecondaryIndexManager;
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.utils.Allocator;
 
-public class TreeMapBackedSortedColumns extends AbstractThreadUnsafeSortedColumns implements ISortedColumns
+public class TreeMapBackedSortedColumns extends AbstractThreadUnsafeSortedColumns
 {
     private final TreeMap<ByteBuffer, Column> map;
 
-    public static final ISortedColumns.Factory factory = new Factory()
+    public static final ColumnFamily.Factory<TreeMapBackedSortedColumns> factory = new Factory<TreeMapBackedSortedColumns>()
     {
-        public ISortedColumns create(AbstractType<?> comparator, boolean insertReversed)
+        public TreeMapBackedSortedColumns create(CFMetaData metadata, boolean insertReversed)
         {
-            return new TreeMapBackedSortedColumns(comparator);
-        }
-
-        public ISortedColumns fromSorted(SortedMap<ByteBuffer, Column> sortedMap, boolean insertReversed)
-        {
-            return new TreeMapBackedSortedColumns(sortedMap);
+            assert !insertReversed;
+            return new TreeMapBackedSortedColumns(metadata);
         }
     };
 
-    public static ISortedColumns.Factory factory()
-    {
-        return factory;
-    }
-
     public AbstractType<?> getComparator()
     {
         return (AbstractType<?>)map.comparator();
     }
 
-    private TreeMapBackedSortedColumns(AbstractType<?> comparator)
+    private TreeMapBackedSortedColumns(CFMetaData metadata)
     {
-        this.map = new TreeMap<ByteBuffer, Column>(comparator);
+        super(metadata);
+        this.map = new TreeMap<ByteBuffer, Column>(metadata.comparator);
     }
 
-    private TreeMapBackedSortedColumns(SortedMap<ByteBuffer, Column> columns)
+    private TreeMapBackedSortedColumns(CFMetaData metadata, SortedMap<ByteBuffer, Column> columns)
     {
+        super(metadata);
         this.map = new TreeMap<ByteBuffer, Column>(columns);
     }
 
-    public ISortedColumns.Factory getFactory()
+    public ColumnFamily.Factory getFactory()
     {
-        return factory();
+        return factory;
     }
 
-    public ISortedColumns cloneMe()
+    public ColumnFamily cloneMe()
     {
-        return new TreeMapBackedSortedColumns(map);
+        return new TreeMapBackedSortedColumns(metadata, map);
     }
 
     public boolean isInsertReversed()
@@ -115,22 +109,14 @@ public class TreeMapBackedSortedColumns extends AbstractThreadUnsafeSortedColumn
         return reconciledColumn.dataSize() - oldColumn.dataSize();
     }
 
-    public long addAllWithSizeDelta(ISortedColumns cm, Allocator allocator, Function<Column, Column> transformation, SecondaryIndexManager.Updater indexer)
-    {
-        delete(cm.getDeletionInfo());
-        for (Column column : cm.getSortedColumns())
-            addColumn(transformation.apply(column), allocator, indexer);
-
-        // we don't use this for memtables, so we don't bother computing size
-        return Long.MIN_VALUE;
-    }
-
     /**
      * We need to go through each column in the column container and resolve it before adding
      */
-    public void addAll(ISortedColumns cm, Allocator allocator, Function<Column, Column> transformation)
+    public void addAll(ColumnFamily cm, Allocator allocator, Function<Column, Column> transformation)
     {
-        addAllWithSizeDelta(cm, allocator, transformation, SecondaryIndexManager.nullUpdater);
+        delete(cm.deletionInfo());
+        for (Column column : cm)
+            addColumn(transformation.apply(column), allocator);
     }
 
     public boolean replace(Column oldColumn, Column newColumn)
@@ -161,17 +147,12 @@ public class TreeMapBackedSortedColumns extends AbstractThreadUnsafeSortedColumn
         return map.get(name);
     }
 
-    public void removeColumn(ByteBuffer name)
-    {
-        map.remove(name);
-    }
-
     public void clear()
     {
         map.clear();
     }
 
-    public int size()
+    public int getColumnCount()
     {
         return map.size();
     }
diff --git a/src/java/org/apache/cassandra/db/UnsortedColumns.java b/src/java/org/apache/cassandra/db/UnsortedColumns.java
new file mode 100644
index 0000000000..e8d74b42f9
--- /dev/null
+++ b/src/java/org/apache/cassandra/db/UnsortedColumns.java
@@ -0,0 +1,143 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.cassandra.db;
+
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Iterator;
+
+import com.google.common.base.Function;
+import com.google.common.collect.Iterables;
+
+import org.apache.cassandra.config.CFMetaData;
+import org.apache.cassandra.db.filter.ColumnSlice;
+import org.apache.cassandra.utils.Allocator;
+
+/**
+ * A ColumnFamily that allows inserting in any order, even unsorted.
+ *
+ * Operations that require sorting (getSortedColumns) or that cannot be efficient without it
+ * (replace, getColumn, etc.) are not supported.
+ */
+public class UnsortedColumns extends AbstractThreadUnsafeSortedColumns
+{
+    private final ArrayList<Column> columns;
+
+    public static final Factory<UnsortedColumns> factory = new Factory<UnsortedColumns>()
+    {
+        public UnsortedColumns create(CFMetaData metadata, boolean insertReversed)
+        {
+            assert !insertReversed;
+            return new UnsortedColumns(metadata);
+        }
+    };
+
+    private UnsortedColumns(CFMetaData metadata)
+    {
+        this(metadata, new ArrayList<Column>());
+    }
+
+    private UnsortedColumns(CFMetaData metadata, ArrayList<Column> columns)
+    {
+        super(metadata);
+        this.columns = columns;
+    }
+
+    public Factory getFactory()
+    {
+        return factory;
+    }
+
+    public ColumnFamily cloneMe()
+    {
+        return new UnsortedColumns(metadata, new ArrayList<Column>(columns));
+    }
+
+    public boolean isInsertReversed()
+    {
+        return false;
+    }
+
+    public void clear()
+    {
+        columns.clear();
+    }
+
+    public void addColumn(Column column, Allocator allocator)
+    {
+        columns.add(column);
+    }
+
+    public void addAll(ColumnFamily cm, Allocator allocator, Function<Column, Column> transformation)
+    {
+        for (Column column : cm)
+            addColumn(column);
+    }
+
+    public Iterator<Column> iterator()
+    {
+        return columns.iterator();
+    }
+
+    public boolean replace(Column oldColumn, Column newColumn)
+    {
+        throw new UnsupportedOperationException();
+    }
+
+    public Column getColumn(ByteBuffer name)
+    {
+        throw new UnsupportedOperationException();
+    }
+
+    public Iterable<ByteBuffer> getColumnNames()
+    {
+        return Iterables.transform(columns, new Function<Column, ByteBuffer>()
+        {
+            public ByteBuffer apply(Column column)
+            {
+                return column.name;
+            }
+        });
+    }
+
+    public Collection<Column> getSortedColumns()
+    {
+        throw new UnsupportedOperationException();
+    }
+
+    public Collection<Column> getReverseSortedColumns()
+    {
+        throw new UnsupportedOperationException();
+    }
+
+    public int getColumnCount()
+    {
+        return columns.size();
+    }
+
+    public Iterator<Column> iterator(ColumnSlice[] slices)
+    {
+        throw new UnsupportedOperationException();
+    }
+
+    public Iterator<Column> reverseIterator(ColumnSlice[] slices)
+    {
+        throw new UnsupportedOperationException();
+    }
+}
diff --git a/src/java/org/apache/cassandra/db/columniterator/IndexedSliceReader.java b/src/java/org/apache/cassandra/db/columniterator/IndexedSliceReader.java
index dd8f09f3ed..e02316c2c5 100644
--- a/src/java/org/apache/cassandra/db/columniterator/IndexedSliceReader.java
+++ b/src/java/org/apache/cassandra/db/columniterator/IndexedSliceReader.java
@@ -26,11 +26,7 @@ import java.util.List;
 
 import com.google.common.collect.AbstractIterator;
 
-import org.apache.cassandra.db.ColumnFamily;
-import org.apache.cassandra.db.DecoratedKey;
-import org.apache.cassandra.db.DeletionInfo;
-import org.apache.cassandra.db.OnDiskAtom;
-import org.apache.cassandra.db.RowIndexEntry;
+import org.apache.cassandra.db.*;
 import org.apache.cassandra.db.filter.ColumnSlice;
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.io.sstable.CorruptSSTableException;
@@ -83,13 +79,13 @@ class IndexedSliceReader extends AbstractIterator<OnDiskAtom> implements OnDiskA
                 if (indexes.isEmpty())
                 {
                     setToRowStart(sstable, indexEntry, input);
-                    this.emptyColumnFamily = ColumnFamily.create(sstable.metadata);
+                    this.emptyColumnFamily = EmptyColumns.factory.create(sstable.metadata);
                     emptyColumnFamily.delete(DeletionInfo.serializer().deserializeFromSSTable(file, version));
                     fetcher = new SimpleBlockFetcher();
                 }
                 else
                 {
-                    this.emptyColumnFamily = ColumnFamily.create(sstable.metadata);
+                    this.emptyColumnFamily = EmptyColumns.factory.create(sstable.metadata);
                     emptyColumnFamily.delete(indexEntry.deletionInfo());
                     fetcher = new IndexedBlockFetcher(indexEntry.position);
                 }
@@ -99,7 +95,7 @@ class IndexedSliceReader extends AbstractIterator<OnDiskAtom> implements OnDiskA
                 setToRowStart(sstable, indexEntry, input);
                 IndexHelper.skipBloomFilter(file, version.filterType);
                 this.indexes = IndexHelper.deserializeIndex(file);
-                this.emptyColumnFamily = ColumnFamily.create(sstable.metadata);
+                this.emptyColumnFamily = EmptyColumns.factory.create(sstable.metadata);
                 emptyColumnFamily.delete(DeletionInfo.serializer().deserializeFromSSTable(file, version));
                 fetcher = indexes.isEmpty()
                         ? new SimpleBlockFetcher()
diff --git a/src/java/org/apache/cassandra/db/columniterator/SSTableNamesIterator.java b/src/java/org/apache/cassandra/db/columniterator/SSTableNamesIterator.java
index 6399993cef..fe9d84f7bf 100644
--- a/src/java/org/apache/cassandra/db/columniterator/SSTableNamesIterator.java
+++ b/src/java/org/apache/cassandra/db/columniterator/SSTableNamesIterator.java
@@ -22,13 +22,7 @@ import java.nio.ByteBuffer;
 import java.util.*;
 
 import org.apache.cassandra.config.CFMetaData;
-import org.apache.cassandra.db.ColumnFamily;
-import org.apache.cassandra.db.ColumnFamilySerializer;
-import org.apache.cassandra.db.DecoratedKey;
-import org.apache.cassandra.db.DeletionInfo;
-import org.apache.cassandra.db.Column;
-import org.apache.cassandra.db.RowIndexEntry;
-import org.apache.cassandra.db.OnDiskAtom;
+import org.apache.cassandra.db.*;
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.io.sstable.CorruptSSTableException;
 import org.apache.cassandra.io.sstable.IndexHelper;
@@ -136,12 +130,10 @@ public class SSTableNamesIterator extends SimpleAbstractColumnIterator implement
 
         if (!indexEntry.isIndexed())
         {
-            // we can stop early if bloom filter says none of the columns actually exist -- but,
-            // we can't stop before initializing the cf above, in case there's a relevant tombstone
             ColumnFamilySerializer serializer = ColumnFamily.serializer;
             try
             {
-                cf = ColumnFamily.create(sstable.metadata);
+                cf = ArrayBackedSortedColumns.factory.create(sstable.metadata);
                 cf.delete(DeletionInfo.serializer().deserializeFromSSTable(file, sstable.descriptor.version));
             }
             catch (Exception e)
@@ -151,7 +143,7 @@ public class SSTableNamesIterator extends SimpleAbstractColumnIterator implement
         }
         else
         {
-            cf = ColumnFamily.create(sstable.metadata);
+            cf = ArrayBackedSortedColumns.factory.create(sstable.metadata);
             cf.delete(indexEntry.deletionInfo());
         }
 
diff --git a/src/java/org/apache/cassandra/db/columniterator/SimpleSliceReader.java b/src/java/org/apache/cassandra/db/columniterator/SimpleSliceReader.java
index 26b0dfb7d0..ac556b3586 100644
--- a/src/java/org/apache/cassandra/db/columniterator/SimpleSliceReader.java
+++ b/src/java/org/apache/cassandra/db/columniterator/SimpleSliceReader.java
@@ -23,11 +23,7 @@ import java.util.Iterator;
 
 import com.google.common.collect.AbstractIterator;
 
-import org.apache.cassandra.db.ColumnFamily;
-import org.apache.cassandra.db.DecoratedKey;
-import org.apache.cassandra.db.DeletionInfo;
-import org.apache.cassandra.db.OnDiskAtom;
-import org.apache.cassandra.db.RowIndexEntry;
+import org.apache.cassandra.db.*;
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.io.sstable.CorruptSSTableException;
 import org.apache.cassandra.io.sstable.Descriptor;
@@ -77,9 +73,9 @@ class SimpleSliceReader extends AbstractIterator<OnDiskAtom> implements OnDiskAt
                 IndexHelper.skipIndex(file);
             }
 
-            emptyColumnFamily = ColumnFamily.create(sstable.metadata);
+            emptyColumnFamily = EmptyColumns.factory.create(sstable.metadata);
             emptyColumnFamily.delete(DeletionInfo.serializer().deserializeFromSSTable(file, version));
-            atomIterator = emptyColumnFamily.metadata().getOnDiskIterator(file, file.readInt(), sstable.descriptor.version);
+            atomIterator = emptyColumnFamily.metadata().getOnDiskIterator(file, file.readInt(), version);
             mark = file.mark();
         }
         catch (IOException e)
diff --git a/src/java/org/apache/cassandra/db/compaction/LazilyCompactedRow.java b/src/java/org/apache/cassandra/db/compaction/LazilyCompactedRow.java
index 8f735d700c..d5b68cc6a1 100644
--- a/src/java/org/apache/cassandra/db/compaction/LazilyCompactedRow.java
+++ b/src/java/org/apache/cassandra/db/compaction/LazilyCompactedRow.java
@@ -234,7 +234,7 @@ public class LazilyCompactedRow extends AbstractCompactedRow implements Iterable
     {
         // all columns reduced together will have the same name, so there will only be one column
         // in the container; we just want to leverage the conflict resolution code from CF
-        ColumnFamily container = emptyColumnFamily.cloneMeShallow();
+        ColumnFamily container = emptyColumnFamily.cloneMeShallow(ArrayBackedSortedColumns.factory, false);
 
         // tombstone reference; will be reconciled w/ column during getReduced
         RangeTombstone tombstone;
diff --git a/src/java/org/apache/cassandra/db/compaction/ParallelCompactionIterable.java b/src/java/org/apache/cassandra/db/compaction/ParallelCompactionIterable.java
index f2faebd3fa..298d07036c 100644
--- a/src/java/org/apache/cassandra/db/compaction/ParallelCompactionIterable.java
+++ b/src/java/org/apache/cassandra/db/compaction/ParallelCompactionIterable.java
@@ -196,7 +196,7 @@ public class ParallelCompactionIterable extends AbstractCompactionIterable
 
             public ColumnFamily call() throws Exception
             {
-                final ColumnFamily returnCF = ColumnFamily.create(controller.cfs.metadata, ArrayBackedSortedColumns.factory());
+                final ColumnFamily returnCF = ArrayBackedSortedColumns.factory.create(controller.cfs.metadata);
 
                 List<CloseableIterator<Column>> data = new ArrayList<CloseableIterator<Column>>(rows.size());
                 for (Row row : rows)
@@ -295,7 +295,7 @@ public class ParallelCompactionIterable extends AbstractCompactionIterable
                         else
                         {
                             logger.debug("parallel eager deserialize from " + iter.getPath());
-                            queue.put(new RowContainer(new Row(iter.getKey(), iter.getColumnFamilyWithColumns(ArrayBackedSortedColumns.factory()))));
+                            queue.put(new RowContainer(new Row(iter.getKey(), iter.getColumnFamilyWithColumns(ArrayBackedSortedColumns.factory))));
                         }
                     }
                 }
diff --git a/src/java/org/apache/cassandra/db/compaction/PrecompactedRow.java b/src/java/org/apache/cassandra/db/compaction/PrecompactedRow.java
index 94509d1057..187cd872ec 100644
--- a/src/java/org/apache/cassandra/db/compaction/PrecompactedRow.java
+++ b/src/java/org/apache/cassandra/db/compaction/PrecompactedRow.java
@@ -103,7 +103,7 @@ public class PrecompactedRow extends AbstractCompactedRow
     {
         assert !rows.isEmpty();
 
-        final ColumnFamily returnCF = ColumnFamily.create(controller.cfs.metadata, ArrayBackedSortedColumns.factory());
+        final ColumnFamily returnCF = ArrayBackedSortedColumns.factory.create(controller.cfs.metadata);
 
         // transform into iterators that MergeIterator will like, and apply row-level tombstones
         List<CloseableIterator<Column>> data = new ArrayList<CloseableIterator<Column>>(rows.size());
@@ -111,7 +111,7 @@ public class PrecompactedRow extends AbstractCompactedRow
         {
             try
             {
-                ColumnFamily cf = row.getColumnFamilyWithColumns(ArrayBackedSortedColumns.factory());
+                ColumnFamily cf = row.getColumnFamilyWithColumns(ArrayBackedSortedColumns.factory);
                 returnCF.delete(cf);
                 data.add(FBUtilities.closeableIterator(cf.iterator()));
             }
diff --git a/src/java/org/apache/cassandra/db/filter/SliceQueryFilter.java b/src/java/org/apache/cassandra/db/filter/SliceQueryFilter.java
index 4f8a316fd1..01db13cbcc 100644
--- a/src/java/org/apache/cassandra/db/filter/SliceQueryFilter.java
+++ b/src/java/org/apache/cassandra/db/filter/SliceQueryFilter.java
@@ -17,18 +17,21 @@
  */
 package org.apache.cassandra.db.filter;
 
-import java.io.*;
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
 import java.nio.ByteBuffer;
-import java.util.*;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Comparator;
+import java.util.Iterator;
 
-import com.google.common.collect.AbstractIterator;
-import com.google.common.collect.Lists;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import org.apache.cassandra.db.*;
-import org.apache.cassandra.db.columniterator.OnDiskAtomIterator;
 import org.apache.cassandra.db.columniterator.ISSTableColumnIterator;
+import org.apache.cassandra.db.columniterator.OnDiskAtomIterator;
 import org.apache.cassandra.db.columniterator.SSTableSliceIterator;
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.db.marshal.CompositeType;
@@ -168,35 +171,22 @@ public class SliceQueryFilter implements IDiskAtomFilter
     {
         ColumnCounter counter = getColumnCounter(cf);
 
-        Collection<ByteBuffer> toRemove = null;
-        boolean trimRemaining = false;
-
         Collection<Column> columns = reversed
                                    ? cf.getReverseSortedColumns()
                                    : cf.getSortedColumns();
 
-        for (Column column : columns)
+        for (Iterator<Column> iter = columns.iterator(); iter.hasNext(); )
         {
-            if (trimRemaining)
-            {
-                toRemove.add(column.name());
-                continue;
-            }
-
+            Column column = iter.next();
             counter.count(column, cf);
+
             if (counter.live() > trimTo)
             {
-                toRemove = new HashSet<ByteBuffer>();
-                toRemove.add(column.name());
-                trimRemaining = true;
+                iter.remove();
+                while (iter.hasNext())
+                    iter.remove();
             }
         }
-
-        if (toRemove != null)
-        {
-            for (ByteBuffer columnName : toRemove)
-                cf.remove(columnName);
-        }
     }
 
     public ByteBuffer start()
diff --git a/src/java/org/apache/cassandra/db/index/AbstractSimplePerColumnSecondaryIndex.java b/src/java/org/apache/cassandra/db/index/AbstractSimplePerColumnSecondaryIndex.java
index d8a7333f70..dabba957d8 100644
--- a/src/java/org/apache/cassandra/db/index/AbstractSimplePerColumnSecondaryIndex.java
+++ b/src/java/org/apache/cassandra/db/index/AbstractSimplePerColumnSecondaryIndex.java
@@ -18,7 +18,6 @@
 package org.apache.cassandra.db.index;
 
 import java.nio.ByteBuffer;
-import java.util.concurrent.ExecutionException;
 
 import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.config.ColumnDefinition;
@@ -93,7 +92,7 @@ public abstract class AbstractSimplePerColumnSecondaryIndex extends PerColumnSec
 
         DecoratedKey valueKey = getIndexKeyFor(column.value());
         int localDeletionTime = (int) (System.currentTimeMillis() / 1000);
-        ColumnFamily cfi = ColumnFamily.create(indexCfs.metadata);
+        ColumnFamily cfi = ArrayBackedSortedColumns.factory.create(indexCfs.metadata);
         cfi.addTombstone(makeIndexColumnName(rowKey, column), localDeletionTime, column.timestamp());
         indexCfs.apply(valueKey, cfi, SecondaryIndexManager.nullUpdater);
         if (logger.isDebugEnabled())
@@ -103,7 +102,7 @@ public abstract class AbstractSimplePerColumnSecondaryIndex extends PerColumnSec
     public void insert(ByteBuffer rowKey, Column column)
     {
         DecoratedKey valueKey = getIndexKeyFor(column.value());
-        ColumnFamily cfi = ColumnFamily.create(indexCfs.metadata);
+        ColumnFamily cfi = ArrayBackedSortedColumns.factory.create(indexCfs.metadata);
         ByteBuffer name = makeIndexColumnName(rowKey, column);
         if (column instanceof ExpiringColumn)
         {
diff --git a/src/java/org/apache/cassandra/db/index/composites/CompositesSearcher.java b/src/java/org/apache/cassandra/db/index/composites/CompositesSearcher.java
index a33300044e..09747c0fbc 100644
--- a/src/java/org/apache/cassandra/db/index/composites/CompositesSearcher.java
+++ b/src/java/org/apache/cassandra/db/index/composites/CompositesSearcher.java
@@ -319,7 +319,7 @@ public class CompositesSearcher extends SecondaryIndexSearcher
                                 continue;
 
                             if (data == null)
-                                data = ColumnFamily.create(baseCfs.metadata);
+                                data = TreeMapBackedSortedColumns.factory.create(baseCfs.metadata);
                             data.resolve(newData);
                             columnsCount += dataFilter.lastCounted();
                         }
diff --git a/src/java/org/apache/cassandra/db/index/keys/KeysSearcher.java b/src/java/org/apache/cassandra/db/index/keys/KeysSearcher.java
index 62cdb7887f..d5ea5535c8 100644
--- a/src/java/org/apache/cassandra/db/index/keys/KeysSearcher.java
+++ b/src/java/org/apache/cassandra/db/index/keys/KeysSearcher.java
@@ -190,7 +190,7 @@ public class KeysSearcher extends SecondaryIndexSearcher
                         ColumnFamily data = baseCfs.getColumnFamily(new QueryFilter(dk, baseCfs.name, filter.initialFilter()));
                         // While the column family we'll get in the end should contains the primary clause column, the initialFilter may not have found it and can thus be null
                         if (data == null)
-                            data = ColumnFamily.create(baseCfs.metadata);
+                            data = TreeMapBackedSortedColumns.factory.create(baseCfs.metadata);
 
                         // as in CFS.filter - extend the filter to ensure we include the columns 
                         // from the index expressions, just in case they weren't included in the initialFilter
diff --git a/src/java/org/apache/cassandra/db/marshal/AbstractType.java b/src/java/org/apache/cassandra/db/marshal/AbstractType.java
index a60306e2c8..e261e9d0c4 100644
--- a/src/java/org/apache/cassandra/db/marshal/AbstractType.java
+++ b/src/java/org/apache/cassandra/db/marshal/AbstractType.java
@@ -173,7 +173,7 @@ public abstract class AbstractType<T> implements Comparator<ByteBuffer>
     }
 
     /* convenience method */
-    public String getColumnsString(Collection<Column> columns)
+    public String getColumnsString(Iterable<Column> columns)
     {
         StringBuilder builder = new StringBuilder();
         for (Column column : columns)
diff --git a/src/java/org/apache/cassandra/io/sstable/SSTableIdentityIterator.java b/src/java/org/apache/cassandra/io/sstable/SSTableIdentityIterator.java
index dd068fb70c..27144cc2f7 100644
--- a/src/java/org/apache/cassandra/io/sstable/SSTableIdentityIterator.java
+++ b/src/java/org/apache/cassandra/io/sstable/SSTableIdentityIterator.java
@@ -154,7 +154,7 @@ public class SSTableIdentityIterator implements Comparable<SSTableIdentityIterat
                 IndexHelper.skipBloomFilter(inputWithTracker, dataVersion.filterType);
                 IndexHelper.skipIndex(inputWithTracker);
             }
-            columnFamily = ColumnFamily.create(metadata);
+            columnFamily = EmptyColumns.factory.create(metadata);
             columnFamily.delete(DeletionInfo.serializer().deserializeFromSSTable(inputWithTracker, dataVersion));
 
             columnCount = inputWithTracker.readInt();
@@ -230,7 +230,7 @@ public class SSTableIdentityIterator implements Comparable<SSTableIdentityIterat
         }
     }
 
-    public ColumnFamily getColumnFamilyWithColumns(ISortedColumns.Factory containerFactory) throws IOException
+    public ColumnFamily getColumnFamilyWithColumns(ColumnFamily.Factory containerFactory) throws IOException
     {
         assert inputWithTracker.getBytesRead() == headerSize();
         ColumnFamily cf = columnFamily.cloneMeShallow(containerFactory, false);
@@ -240,7 +240,7 @@ public class SSTableIdentityIterator implements Comparable<SSTableIdentityIterat
         {
             try
             {
-                cf.validateColumnFields();
+                cf.metadata().validateColumns(cf);
             }
             catch (MarshalException e)
             {
diff --git a/src/java/org/apache/cassandra/io/sstable/SSTableSimpleUnsortedWriter.java b/src/java/org/apache/cassandra/io/sstable/SSTableSimpleUnsortedWriter.java
index 9207276d68..c3a6212116 100644
--- a/src/java/org/apache/cassandra/io/sstable/SSTableSimpleUnsortedWriter.java
+++ b/src/java/org/apache/cassandra/io/sstable/SSTableSimpleUnsortedWriter.java
@@ -107,7 +107,7 @@ public class SSTableSimpleUnsortedWriter extends AbstractSSTableSimpleWriter
         // If the CF already exist in memory, we'll just continue adding to it
         if (previous == null)
         {
-            previous = ColumnFamily.create(metadata, TreeMapBackedSortedColumns.factory());
+            previous = TreeMapBackedSortedColumns.factory.create(metadata);
             buffer.put(currentKey, previous);
         }
         else
diff --git a/src/java/org/apache/cassandra/io/sstable/SSTableSimpleWriter.java b/src/java/org/apache/cassandra/io/sstable/SSTableSimpleWriter.java
index d0b1b4a97b..f0b45b5f76 100644
--- a/src/java/org/apache/cassandra/io/sstable/SSTableSimpleWriter.java
+++ b/src/java/org/apache/cassandra/io/sstable/SSTableSimpleWriter.java
@@ -88,6 +88,6 @@ public class SSTableSimpleWriter extends AbstractSSTableSimpleWriter
 
     protected ColumnFamily getColumnFamily()
     {
-        return ColumnFamily.create(metadata, TreeMapBackedSortedColumns.factory());
+        return TreeMapBackedSortedColumns.factory.create(metadata);
     }
 }
diff --git a/src/java/org/apache/cassandra/io/sstable/SSTableWriter.java b/src/java/org/apache/cassandra/io/sstable/SSTableWriter.java
index 6f954dcb5b..9b6db46afa 100644
--- a/src/java/org/apache/cassandra/io/sstable/SSTableWriter.java
+++ b/src/java/org/apache/cassandra/io/sstable/SSTableWriter.java
@@ -242,7 +242,7 @@ public class SSTableWriter extends SSTable
         long maxTimestamp = Long.MIN_VALUE;
         int maxLocalDeletionTime = Integer.MIN_VALUE;
         StreamingHistogram tombstones = new StreamingHistogram(TOMBSTONE_HISTOGRAM_BIN_SIZE);
-        ColumnFamily cf = ColumnFamily.create(metadata, ArrayBackedSortedColumns.factory());
+        ColumnFamily cf = ArrayBackedSortedColumns.factory.create(metadata);
         cf.delete(deletionInfo);
 
         ColumnIndex.Builder columnIndexer = new ColumnIndex.Builder(cf, key.key, dataFile.stream);
diff --git a/src/java/org/apache/cassandra/service/MigrationManager.java b/src/java/org/apache/cassandra/service/MigrationManager.java
index a7b2fcf9ce..3d742a8b94 100644
--- a/src/java/org/apache/cassandra/service/MigrationManager.java
+++ b/src/java/org/apache/cassandra/service/MigrationManager.java
@@ -31,6 +31,7 @@ import java.util.concurrent.TimeUnit;
 import java.lang.management.ManagementFactory;
 import java.lang.management.RuntimeMXBean;
 
+import com.google.common.collect.Iterables;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -385,7 +386,7 @@ public class MigrationManager implements IEndpointStateChangeSubscriber
         ColumnFamilyStore cfStore = defs.getColumnFamilyStore(DefsTable.OLD_SCHEMA_CF);
         QueryFilter filter = QueryFilter.getNamesFilter(dkey, DefsTable.OLD_SCHEMA_CF, LAST_MIGRATION_KEY);
         ColumnFamily cf = cfStore.getColumnFamily(filter);
-        if (cf == null || cf.getColumnNames().size() == 0)
+        if (cf == null || Iterables.isEmpty(cf.getColumnNames()))
             return null;
         else
             return UUIDGen.getUUID(cf.getColumn(LAST_MIGRATION_KEY).value());
diff --git a/src/java/org/apache/cassandra/service/StorageProxy.java b/src/java/org/apache/cassandra/service/StorageProxy.java
index 0b29cdf324..a5e07957d4 100644
--- a/src/java/org/apache/cassandra/service/StorageProxy.java
+++ b/src/java/org/apache/cassandra/service/StorageProxy.java
@@ -320,7 +320,7 @@ public class StorageProxy implements StorageProxyMBean
 
     private static void asyncRemoveFromBatchlog(Collection<InetAddress> endpoints, UUID uuid)
     {
-        ColumnFamily cf = ColumnFamily.create(Schema.instance.getCFMetaData(Table.SYSTEM_KS, SystemTable.BATCHLOG_CF));
+        ColumnFamily cf = EmptyColumns.factory.create(Schema.instance.getCFMetaData(Table.SYSTEM_KS, SystemTable.BATCHLOG_CF));
         cf.delete(new DeletionInfo(FBUtilities.timestampMicros(), (int) (System.currentTimeMillis() / 1000)));
         AbstractWriteResponseHandler handler = new WriteResponseHandler(endpoints,
                                                                         Collections.<InetAddress>emptyList(),
diff --git a/src/java/org/apache/cassandra/thrift/CassandraServer.java b/src/java/org/apache/cassandra/thrift/CassandraServer.java
index e06000ef1d..3284a8daa2 100644
--- a/src/java/org/apache/cassandra/thrift/CassandraServer.java
+++ b/src/java/org/apache/cassandra/thrift/CassandraServer.java
@@ -52,7 +52,6 @@ import org.apache.cassandra.exceptions.RequestExecutionException;
 import org.apache.cassandra.exceptions.RequestValidationException;
 import org.apache.cassandra.exceptions.UnauthorizedException;
 import org.apache.cassandra.io.util.DataOutputBuffer;
-import org.apache.cassandra.locator.AbstractReplicationStrategy;
 import org.apache.cassandra.locator.DynamicEndpointSnitch;
 import org.apache.cassandra.scheduler.IRequestScheduler;
 import org.apache.cassandra.service.*;
@@ -684,7 +683,7 @@ public class CassandraServer implements Cassandra.Iface
             if (metadata.isSuper())
                 name = CompositeType.build(column_parent.super_column, name);
 
-            ColumnFamily cf = ColumnFamily.create(Schema.instance.getId(cState.getKeyspace(), column_parent.column_family));
+            ColumnFamily cf = ArrayBackedSortedColumns.factory.create(cState.getKeyspace(), column_parent.column_family);
             cf.addColumn(name, column.value, column.timestamp, column.ttl);
             rm = new RowMutation(cState.getKeyspace(), key, cf);
         }
diff --git a/src/java/org/apache/cassandra/tools/SSTableImport.java b/src/java/org/apache/cassandra/tools/SSTableImport.java
index be31540aae..8c58d70466 100644
--- a/src/java/org/apache/cassandra/tools/SSTableImport.java
+++ b/src/java/org/apache/cassandra/tools/SSTableImport.java
@@ -35,17 +35,10 @@ import org.apache.commons.cli.ParseException;
 import org.apache.commons.cli.PosixParser;
 
 import org.apache.cassandra.config.CFMetaData;
+import org.apache.cassandra.db.*;
 import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.config.Schema;
-import org.apache.cassandra.db.ColumnFamily;
-import org.apache.cassandra.db.ColumnFamilyType;
-import org.apache.cassandra.db.CounterColumn;
-import org.apache.cassandra.db.DecoratedKey;
-import org.apache.cassandra.db.DeletionInfo;
-import org.apache.cassandra.db.ExpiringColumn;
-import org.apache.cassandra.db.RangeTombstone;
-import org.apache.cassandra.db.SuperColumns;
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.db.marshal.BytesType;
 import org.apache.cassandra.db.marshal.CompositeType;
@@ -319,7 +312,7 @@ public class SSTableImport
      */
     public int importJson(String jsonFile, String keyspace, String cf, String ssTablePath) throws IOException
     {
-        ColumnFamily columnFamily = ColumnFamily.create(keyspace, cf);
+        ColumnFamily columnFamily = TreeMapBackedSortedColumns.factory.create(keyspace, cf);
         IPartitioner<?> partitioner = DatabaseDescriptor.getPartitioner();
 
         int importedKeys = (isSorted) ? importSorted(jsonFile, columnFamily, ssTablePath, partitioner)
diff --git a/src/java/org/apache/cassandra/tracing/TraceState.java b/src/java/org/apache/cassandra/tracing/TraceState.java
index 9cdb0f315f..52e6d044a2 100644
--- a/src/java/org/apache/cassandra/tracing/TraceState.java
+++ b/src/java/org/apache/cassandra/tracing/TraceState.java
@@ -24,15 +24,12 @@ import java.util.UUID;
 import java.util.concurrent.TimeUnit;
 
 import com.google.common.base.Stopwatch;
-import org.slf4j.Logger;
 import org.slf4j.helpers.MessageFormatter;
 
 import org.apache.cassandra.concurrent.Stage;
 import org.apache.cassandra.concurrent.StageManager;
 import org.apache.cassandra.config.CFMetaData;
-import org.apache.cassandra.db.ColumnFamily;
-import org.apache.cassandra.db.ConsistencyLevel;
-import org.apache.cassandra.db.RowMutation;
+import org.apache.cassandra.db.*;
 import org.apache.cassandra.service.StorageProxy;
 import org.apache.cassandra.utils.*;
 
@@ -94,11 +91,11 @@ public class TraceState
             public void runMayThrow() throws Exception
             {
                 CFMetaData cfMeta = CFMetaData.TraceEventsCf;
-                ColumnFamily cf = ColumnFamily.create(cfMeta);
+                ColumnFamily cf = ArrayBackedSortedColumns.factory.create(cfMeta);
+                Tracing.addColumn(cf, Tracing.buildName(cfMeta, eventId, ByteBufferUtil.bytes("activity")), message);
                 Tracing.addColumn(cf, Tracing.buildName(cfMeta, eventId, ByteBufferUtil.bytes("source")), FBUtilities.getBroadcastAddress());
-                Tracing.addColumn(cf, Tracing.buildName(cfMeta, eventId, ByteBufferUtil.bytes("thread")), threadName);
                 Tracing.addColumn(cf, Tracing.buildName(cfMeta, eventId, ByteBufferUtil.bytes("source_elapsed")), elapsed);
-                Tracing.addColumn(cf, Tracing.buildName(cfMeta, eventId, ByteBufferUtil.bytes("activity")), message);
+                Tracing.addColumn(cf, Tracing.buildName(cfMeta, eventId, ByteBufferUtil.bytes("thread")), threadName);
                 RowMutation mutation = new RowMutation(Tracing.TRACE_KS, sessionIdBytes, cf);
                 StorageProxy.mutate(Arrays.asList(mutation), ConsistencyLevel.ANY);
             }
diff --git a/src/java/org/apache/cassandra/tracing/Tracing.java b/src/java/org/apache/cassandra/tracing/Tracing.java
index 6281ca79f2..05045962e2 100644
--- a/src/java/org/apache/cassandra/tracing/Tracing.java
+++ b/src/java/org/apache/cassandra/tracing/Tracing.java
@@ -33,10 +33,7 @@ import org.apache.cassandra.concurrent.Stage;
 import org.apache.cassandra.concurrent.StageManager;
 import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.cql3.ColumnNameBuilder;
-import org.apache.cassandra.db.ColumnFamily;
-import org.apache.cassandra.db.ConsistencyLevel;
-import org.apache.cassandra.db.ExpiringColumn;
-import org.apache.cassandra.db.RowMutation;
+import org.apache.cassandra.db.*;
 import org.apache.cassandra.db.marshal.TimeUUIDType;
 import org.apache.cassandra.net.MessageIn;
 import org.apache.cassandra.service.StorageProxy;
@@ -176,7 +173,7 @@ public class Tracing
                 public void runMayThrow() throws Exception
                 {
                     CFMetaData cfMeta = CFMetaData.TraceSessionsCf;
-                    ColumnFamily cf = ColumnFamily.create(cfMeta);
+                    ColumnFamily cf = ArrayBackedSortedColumns.factory.create(cfMeta);
                     addColumn(cf, buildName(cfMeta, bytes("duration")), elapsed);
                     RowMutation mutation = new RowMutation(TRACE_KS, sessionIdBytes, cf);
                     StorageProxy.mutate(Arrays.asList(mutation), ConsistencyLevel.ANY);
@@ -215,7 +212,7 @@ public class Tracing
             public void runMayThrow() throws Exception
             {
                 CFMetaData cfMeta = CFMetaData.TraceSessionsCf;
-                ColumnFamily cf = ColumnFamily.create(cfMeta);
+                ColumnFamily cf = ArrayBackedSortedColumns.factory.create(cfMeta);
                 addColumn(cf, buildName(cfMeta, bytes("coordinator")), FBUtilities.getBroadcastAddress());
                 addColumn(cf, buildName(cfMeta, bytes("request")), request);
                 addColumn(cf, buildName(cfMeta, bytes("started_at")), started_at);
diff --git a/test/long/org/apache/cassandra/db/LongTableTest.java b/test/long/org/apache/cassandra/db/LongTableTest.java
index a630fca55c..e209b030f7 100644
--- a/test/long/org/apache/cassandra/db/LongTableTest.java
+++ b/test/long/org/apache/cassandra/db/LongTableTest.java
@@ -40,7 +40,7 @@ public class LongTableTest extends SchemaLoader
         for (int i = 1; i < 5000; i += 100)
         {
             RowMutation rm = new RowMutation("Keyspace1", Util.dk("key" + i).key);
-            ColumnFamily cf = ColumnFamily.create("Keyspace1", "Standard1");
+            ColumnFamily cf = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
             for (int j = 0; j < i; j++)
                 cf.addColumn(column("c" + j, "v" + j, 1L));
             rm.add(cf);
diff --git a/test/long/org/apache/cassandra/db/MeteredFlusherTest.java b/test/long/org/apache/cassandra/db/MeteredFlusherTest.java
index 150282f655..bd905e0158 100644
--- a/test/long/org/apache/cassandra/db/MeteredFlusherTest.java
+++ b/test/long/org/apache/cassandra/db/MeteredFlusherTest.java
@@ -51,7 +51,7 @@ public class MeteredFlusherTest extends SchemaLoader
             for (int i = 0; i < 100; i++)
             {
                 RowMutation rm = new RowMutation("Keyspace1", ByteBufferUtil.bytes("key" + j));
-                ColumnFamily cf = ColumnFamily.create("Keyspace1", "_CF" + i);
+                ColumnFamily cf = TreeMapBackedSortedColumns.factory.create("Keyspace1", "_CF" + i);
                 // don't cheat by allocating this outside of the loop; that defeats the purpose of deliberately using lots of memory
                 ByteBuffer value = ByteBuffer.allocate(100000);
                 cf.addColumn(new Column(name, value));
diff --git a/test/unit/org/apache/cassandra/cache/CacheProviderTest.java b/test/unit/org/apache/cassandra/cache/CacheProviderTest.java
index fe0aa7f509..bfd6263f7d 100644
--- a/test/unit/org/apache/cassandra/cache/CacheProviderTest.java
+++ b/test/unit/org/apache/cassandra/cache/CacheProviderTest.java
@@ -32,6 +32,7 @@ import org.apache.cassandra.SchemaLoader;
 import org.apache.cassandra.db.ColumnFamily;
 
 import com.googlecode.concurrentlinkedhashmap.Weighers;
+import org.apache.cassandra.db.TreeMapBackedSortedColumns;
 
 import static org.apache.cassandra.Util.column;
 import static org.junit.Assert.*;
@@ -99,7 +100,7 @@ public class CacheProviderTest extends SchemaLoader
 
     private ColumnFamily createCF()
     {
-        ColumnFamily cf = ColumnFamily.create(tableName, cfName);
+        ColumnFamily cf = TreeMapBackedSortedColumns.factory.create(tableName, cfName);
         cf.addColumn(column("vijay", "great", 1));
         cf.addColumn(column("awesome", "vijay", 1));
         return cf;
diff --git a/test/unit/org/apache/cassandra/db/ArrayBackedSortedColumnsTest.java b/test/unit/org/apache/cassandra/db/ArrayBackedSortedColumnsTest.java
index f2184fe92d..c720d28bd5 100644
--- a/test/unit/org/apache/cassandra/db/ArrayBackedSortedColumnsTest.java
+++ b/test/unit/org/apache/cassandra/db/ArrayBackedSortedColumnsTest.java
@@ -21,7 +21,6 @@ package org.apache.cassandra.db;
  */
 
 
-import java.nio.ByteBuffer;
 import java.util.*;
 
 import org.junit.Test;
@@ -30,12 +29,14 @@ import static org.junit.Assert.*;
 
 import com.google.common.base.Functions;
 
+import org.apache.cassandra.SchemaLoader;
+import org.apache.cassandra.config.CFMetaData;
+import org.apache.cassandra.config.Schema;
 import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.cassandra.db.filter.ColumnSlice;
-import org.apache.cassandra.db.marshal.BytesType;
 import org.apache.cassandra.utils.HeapAllocator;
 
-public class ArrayBackedSortedColumnsTest
+public class ArrayBackedSortedColumnsTest extends SchemaLoader
 {
     @Test
     public void testAdd()
@@ -44,9 +45,14 @@ public class ArrayBackedSortedColumnsTest
         testAddInternal(true);
     }
 
+    private CFMetaData metadata()
+    {
+        return Schema.instance.getCFMetaData("Keyspace1", "Standard1");
+    }
+
     private void testAddInternal(boolean reversed)
     {
-        ISortedColumns map = ArrayBackedSortedColumns.factory().create(BytesType.instance, reversed);
+        ColumnFamily map = ArrayBackedSortedColumns.factory.create(metadata(), reversed);
         int[] values = new int[]{ 1, 2, 2, 3 };
 
         for (int i = 0; i < values.length; ++i)
@@ -67,8 +73,8 @@ public class ArrayBackedSortedColumnsTest
 
     private void testAddAllInternal(boolean reversed)
     {
-        ISortedColumns map = ArrayBackedSortedColumns.factory().create(BytesType.instance, reversed);
-        ISortedColumns map2 = ArrayBackedSortedColumns.factory().create(BytesType.instance, reversed);
+        ColumnFamily map = ArrayBackedSortedColumns.factory.create(metadata(), reversed);
+        ColumnFamily map2 = ArrayBackedSortedColumns.factory.create(metadata(), reversed);
 
         int[] values1 = new int[]{ 1, 3, 5, 6 };
         int[] values2 = new int[]{ 2, 4, 5, 6 };
@@ -99,7 +105,7 @@ public class ArrayBackedSortedColumnsTest
 
     private void testGetCollectionInternal(boolean reversed)
     {
-        ISortedColumns map = ArrayBackedSortedColumns.factory().create(BytesType.instance, reversed);
+        ColumnFamily map = ArrayBackedSortedColumns.factory.create(metadata(), reversed);
         int[] values = new int[]{ 1, 2, 3, 5, 9 };
 
         List<Column> sorted = new ArrayList<Column>();
@@ -115,27 +121,6 @@ public class ArrayBackedSortedColumnsTest
         assertSame(reverseSorted, map.getReverseSortedColumns());
     }
 
-    @Test
-    public void testGetNames()
-    {
-        testGetNamesInternal(false);
-        testGetNamesInternal(true);
-    }
-
-    private void testGetNamesInternal(boolean reversed)
-    {
-        ISortedColumns map = ArrayBackedSortedColumns.factory().create(BytesType.instance, reversed);
-        List<ByteBuffer> names = new ArrayList<ByteBuffer>();
-        int[] values = new int[]{ 1, 2, 3, 5, 9 };
-        for (int v : values)
-            names.add(ByteBufferUtil.bytes(v));
-
-        for (int i = 0; i < values.length; ++i)
-            map.addColumn(new Column(ByteBufferUtil.bytes(values[reversed ? values.length - 1 - i : i])), HeapAllocator.instance);
-
-        assertSame(names, map.getColumnNames());
-    }
-
     @Test
     public void testIterator()
     {
@@ -145,26 +130,20 @@ public class ArrayBackedSortedColumnsTest
 
     private void testIteratorInternal(boolean reversed)
     {
-        ISortedColumns map = ArrayBackedSortedColumns.factory().create(BytesType.instance, reversed);
+        ColumnFamily map = ArrayBackedSortedColumns.factory.create(metadata(), reversed);
 
-        List<ByteBuffer> names = new ArrayList<ByteBuffer>();
         int[] values = new int[]{ 1, 2, 3, 5, 9 };
-        for (int v : values)
-            names.add(ByteBufferUtil.bytes(v));
 
         for (int i = 0; i < values.length; ++i)
             map.addColumn(new Column(ByteBufferUtil.bytes(values[reversed ? values.length - 1 - i : i])), HeapAllocator.instance);
 
-        //assertSame(new int[]{ 3, 5, 9 }, map.iterator(ByteBufferUtil.bytes(3)));
-        //assertSame(new int[]{ 5, 9 }, map.iterator(ByteBufferUtil.bytes(4)));
-
         assertSame(new int[]{ 3, 2, 1 }, map.reverseIterator(new ColumnSlice[]{ new ColumnSlice(ByteBufferUtil.bytes(3), ByteBufferUtil.EMPTY_BYTE_BUFFER) }));
         assertSame(new int[]{ 3, 2, 1 }, map.reverseIterator(new ColumnSlice[]{ new ColumnSlice(ByteBufferUtil.bytes(4), ByteBufferUtil.EMPTY_BYTE_BUFFER) }));
 
         assertSame(map.iterator(), map.iterator(ColumnSlice.ALL_COLUMNS_ARRAY));
     }
 
-    private <T> void assertSame(Collection<T> c1, Collection<T> c2)
+    private <T> void assertSame(Iterable<T> c1, Iterable<T> c2)
     {
         assertSame(c1.iterator(), c2.iterator());
     }
diff --git a/test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java b/test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java
index d35bf821fb..fc744b88f0 100644
--- a/test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java
+++ b/test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java
@@ -726,7 +726,7 @@ public class ColumnFamilyStoreTest extends SchemaLoader
 
     private static void putColsSuper(ColumnFamilyStore cfs, DecoratedKey key, ByteBuffer scfName, Column... cols) throws Throwable
     {
-        ColumnFamily cf = ColumnFamily.create(cfs.table.getName(), cfs.name);
+        ColumnFamily cf = TreeMapBackedSortedColumns.factory.create(cfs.table.getName(), cfs.name);
         for (Column col : cols)
             cf.addColumn(col.withUpdatedName(CompositeType.build(scfName, col.name())));
         RowMutation rm = new RowMutation(cfs.table.getName(), key.key, cf);
@@ -735,7 +735,7 @@ public class ColumnFamilyStoreTest extends SchemaLoader
 
     private static void putColsStandard(ColumnFamilyStore cfs, DecoratedKey key, Column... cols) throws Throwable
     {
-        ColumnFamily cf = ColumnFamily.create(cfs.table.getName(), cfs.name);
+        ColumnFamily cf = TreeMapBackedSortedColumns.factory.create(cfs.table.getName(), cfs.name);
         for (Column col : cols)
             cf.addColumn(col);
         RowMutation rm = new RowMutation(cfs.table.getName(), key.key, cf);
diff --git a/test/unit/org/apache/cassandra/db/ColumnFamilyTest.java b/test/unit/org/apache/cassandra/db/ColumnFamilyTest.java
index 21fa727a02..95caac6256 100644
--- a/test/unit/org/apache/cassandra/db/ColumnFamilyTest.java
+++ b/test/unit/org/apache/cassandra/db/ColumnFamilyTest.java
@@ -24,6 +24,8 @@ import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.util.*;
 
+import com.google.common.collect.Iterables;
+
 import org.apache.cassandra.SchemaLoader;
 import org.junit.Test;
 
@@ -48,7 +50,7 @@ public class ColumnFamilyTest extends SchemaLoader
     {
         ColumnFamily cf;
 
-        cf = ColumnFamily.create("Keyspace1", "Standard1");
+        cf = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
         cf.addColumn(column("C", "v", 1));
         DataOutputBuffer bufOut = new DataOutputBuffer();
         ColumnFamily.serializer.serialize(cf, bufOut, version);
@@ -72,7 +74,7 @@ public class ColumnFamilyTest extends SchemaLoader
         }
 
         // write
-        cf = ColumnFamily.create("Keyspace1", "Standard1");
+        cf = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
         DataOutputBuffer bufOut = new DataOutputBuffer();
         for (String cName : map.navigableKeySet())
         {
@@ -88,13 +90,13 @@ public class ColumnFamilyTest extends SchemaLoader
             ByteBuffer val = cf.getColumn(ByteBufferUtil.bytes(cName)).value();
             assert new String(val.array(),val.position(),val.remaining()).equals(map.get(cName));
         }
-        assert cf.getColumnNames().size() == map.size();
+        assert Iterables.size(cf.getColumnNames()) == map.size();
     }
 
     @Test
     public void testGetColumnCount()
     {
-        ColumnFamily cf = ColumnFamily.create("Keyspace1", "Standard1");
+        ColumnFamily cf = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
 
         cf.addColumn(column("col1", "", 1));
         cf.addColumn(column("col2", "", 2));
@@ -107,7 +109,7 @@ public class ColumnFamilyTest extends SchemaLoader
     @Test
     public void testTimestamp()
     {
-        ColumnFamily cf = ColumnFamily.create("Keyspace1", "Standard1");
+        ColumnFamily cf = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
 
         cf.addColumn(column("col1", "val1", 2));
         cf.addColumn(column("col1", "val2", 2)); // same timestamp, new value
@@ -119,9 +121,9 @@ public class ColumnFamilyTest extends SchemaLoader
     @Test
     public void testMergeAndAdd()
     {
-        ColumnFamily cf_new = ColumnFamily.create("Keyspace1", "Standard1");
-        ColumnFamily cf_old = ColumnFamily.create("Keyspace1", "Standard1");
-        ColumnFamily cf_result = ColumnFamily.create("Keyspace1", "Standard1");
+        ColumnFamily cf_new = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
+        ColumnFamily cf_old = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
+        ColumnFamily cf_result = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
         ByteBuffer val = ByteBufferUtil.bytes("sample value");
         ByteBuffer val2 = ByteBufferUtil.bytes("x value ");
 
@@ -156,8 +158,8 @@ public class ColumnFamilyTest extends SchemaLoader
     {
         long timestamp = System.currentTimeMillis();
         int localDeletionTime = (int) (System.currentTimeMillis() / 1000);
-        
-        ColumnFamily cf = ColumnFamily.create("Keyspace1", "Standard1");
+
+        ColumnFamily cf = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
         cf.delete(new DeletionInfo(timestamp, localDeletionTime));
         ColumnStats stats = cf.getColumnStats();
         assertEquals(timestamp, stats.maxTimestamp);
diff --git a/test/unit/org/apache/cassandra/db/MultitableTest.java b/test/unit/org/apache/cassandra/db/MultitableTest.java
index c22bf0d41e..606af98c28 100644
--- a/test/unit/org/apache/cassandra/db/MultitableTest.java
+++ b/test/unit/org/apache/cassandra/db/MultitableTest.java
@@ -43,12 +43,12 @@ public class MultitableTest extends SchemaLoader
         DecoratedKey dk = Util.dk("keymulti");
         ColumnFamily cf;
 
-        cf = ColumnFamily.create("Keyspace1", "Standard1");
+        cf = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
         cf.addColumn(column("col1", "val1", 1L));
         rm = new RowMutation("Keyspace1", dk.key, cf);
         rm.apply();
 
-        cf = ColumnFamily.create("Keyspace2", "Standard1");
+        cf = TreeMapBackedSortedColumns.factory.create("Keyspace2", "Standard1");
         cf.addColumn(column("col2", "val2", 1L));
         rm = new RowMutation("Keyspace2", dk.key, cf);
         rm.apply();
diff --git a/test/unit/org/apache/cassandra/db/RecoveryManager2Test.java b/test/unit/org/apache/cassandra/db/RecoveryManager2Test.java
index 030e7ba057..0e743f6059 100644
--- a/test/unit/org/apache/cassandra/db/RecoveryManager2Test.java
+++ b/test/unit/org/apache/cassandra/db/RecoveryManager2Test.java
@@ -71,7 +71,7 @@ public class RecoveryManager2Test extends SchemaLoader
 
     private void insertRow(String cfname, String key) throws IOException
     {
-        ColumnFamily cf = ColumnFamily.create("Keyspace1", cfname);
+        ColumnFamily cf = TreeMapBackedSortedColumns.factory.create("Keyspace1", cfname);
         cf.addColumn(column("col1", "val1", 1L));
         RowMutation rm = new RowMutation("Keyspace1", ByteBufferUtil.bytes(key), cf);
         rm.apply();
diff --git a/test/unit/org/apache/cassandra/db/RecoveryManager3Test.java b/test/unit/org/apache/cassandra/db/RecoveryManager3Test.java
index b63be9e3aa..dcc090146c 100644
--- a/test/unit/org/apache/cassandra/db/RecoveryManager3Test.java
+++ b/test/unit/org/apache/cassandra/db/RecoveryManager3Test.java
@@ -48,12 +48,12 @@ public class RecoveryManager3Test extends SchemaLoader
         DecoratedKey dk = Util.dk("keymulti");
         ColumnFamily cf;
 
-        cf = ColumnFamily.create("Keyspace1", "Standard1");
+        cf = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
         cf.addColumn(column("col1", "val1", 1L));
         rm = new RowMutation("Keyspace1", dk.key, cf);
         rm.apply();
 
-        cf = ColumnFamily.create("Keyspace2", "Standard3");
+        cf = TreeMapBackedSortedColumns.factory.create("Keyspace2", "Standard3");
         cf.addColumn(column("col2", "val2", 1L));
         rm = new RowMutation("Keyspace2", dk.key, cf);
         rm.apply();
diff --git a/test/unit/org/apache/cassandra/db/RecoveryManagerTest.java b/test/unit/org/apache/cassandra/db/RecoveryManagerTest.java
index e521e0821b..a98a40181f 100644
--- a/test/unit/org/apache/cassandra/db/RecoveryManagerTest.java
+++ b/test/unit/org/apache/cassandra/db/RecoveryManagerTest.java
@@ -48,12 +48,12 @@ public class RecoveryManagerTest extends SchemaLoader
         DecoratedKey dk = Util.dk("keymulti");
         ColumnFamily cf;
 
-        cf = ColumnFamily.create("Keyspace1", "Standard1");
+        cf = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
         cf.addColumn(column("col1", "val1", 1L));
         rm = new RowMutation("Keyspace1", dk.key, cf);
         rm.apply();
 
-        cf = ColumnFamily.create("Keyspace2", "Standard3");
+        cf = TreeMapBackedSortedColumns.factory.create("Keyspace2", "Standard3");
         cf.addColumn(column("col2", "val2", 1L));
         rm = new RowMutation("Keyspace2", dk.key, cf);
         rm.apply();
@@ -79,7 +79,7 @@ public class RecoveryManagerTest extends SchemaLoader
 
         for (int i = 0; i < 10; ++i)
         {
-            cf = ColumnFamily.create("Keyspace1", "Counter1");
+            cf = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Counter1");
             cf.addColumn(new CounterColumn(ByteBufferUtil.bytes("col"), 1L, 1L));
             rm = new RowMutation("Keyspace1", dk.key, cf);
             rm.apply();
diff --git a/test/unit/org/apache/cassandra/db/RecoveryManagerTruncateTest.java b/test/unit/org/apache/cassandra/db/RecoveryManagerTruncateTest.java
index c4f5be0f52..38b3385d29 100644
--- a/test/unit/org/apache/cassandra/db/RecoveryManagerTruncateTest.java
+++ b/test/unit/org/apache/cassandra/db/RecoveryManagerTruncateTest.java
@@ -47,7 +47,7 @@ public class RecoveryManagerTruncateTest extends SchemaLoader
 		ColumnFamily cf;
 
 		// add a single cell
-		cf = ColumnFamily.create("Keyspace1", "Standard1");
+        cf = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
 		cf.addColumn(column("col1", "val1", 1L));
         rm = new RowMutation("Keyspace1", ByteBufferUtil.bytes("keymulti"), cf);
 		rm.apply();
diff --git a/test/unit/org/apache/cassandra/db/RowTest.java b/test/unit/org/apache/cassandra/db/RowTest.java
index a36fb9e9fd..95d0de5bf9 100644
--- a/test/unit/org/apache/cassandra/db/RowTest.java
+++ b/test/unit/org/apache/cassandra/db/RowTest.java
@@ -25,7 +25,6 @@ import org.junit.Test;
 
 import static junit.framework.Assert.assertEquals;
 import static junit.framework.Assert.fail;
-import org.apache.cassandra.db.marshal.AsciiType;
 import static org.apache.cassandra.Util.column;
 import org.apache.cassandra.utils.ByteBufferUtil;
 
@@ -35,10 +34,10 @@ public class RowTest extends SchemaLoader
     @Test
     public void testDiffColumnFamily()
     {
-        ColumnFamily cf1 = ColumnFamily.create("Keyspace1", "Standard1");
+        ColumnFamily cf1 = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
         cf1.addColumn(column("one", "onev", 0));
 
-        ColumnFamily cf2 = ColumnFamily.create("Keyspace1", "Standard1");
+        ColumnFamily cf2 = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
         DeletionInfo delInfo = new DeletionInfo(0, 0);
         cf2.delete(delInfo);
 
@@ -50,10 +49,10 @@ public class RowTest extends SchemaLoader
     @Test
     public void testResolve()
     {
-        ColumnFamily cf1 = ColumnFamily.create("Keyspace1", "Standard1");
+        ColumnFamily cf1 = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
         cf1.addColumn(column("one", "A", 0));
 
-        ColumnFamily cf2 = ColumnFamily.create("Keyspace1", "Standard1");
+        ColumnFamily cf2 = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
         cf2.addColumn(column("one", "B", 1));
         cf2.addColumn(column("two", "C", 1));
 
diff --git a/test/unit/org/apache/cassandra/db/SerializationsTest.java b/test/unit/org/apache/cassandra/db/SerializationsTest.java
index 5efc15cf33..8c9af0f754 100644
--- a/test/unit/org/apache/cassandra/db/SerializationsTest.java
+++ b/test/unit/org/apache/cassandra/db/SerializationsTest.java
@@ -20,7 +20,6 @@ package org.apache.cassandra.db;
 
 import org.apache.cassandra.AbstractSerializationsTester;
 import org.apache.cassandra.Util;
-import org.apache.cassandra.config.Schema;
 import org.apache.cassandra.db.filter.*;
 import org.apache.cassandra.db.marshal.BytesType;
 import org.apache.cassandra.db.marshal.CompositeType;
@@ -364,8 +363,8 @@ public class SerializationsTest extends AbstractSerializationsTester
         private final ByteBuffer Start = ByteBufferUtil.bytes("Start");
         private final ByteBuffer Stop = ByteBufferUtil.bytes("Stop");
 
-        private final ColumnFamily StandardCf = ColumnFamily.create(KS, StandardCF);
-        private final ColumnFamily SuperCf = ColumnFamily.create(KS, SuperCF);
+        private final ColumnFamily StandardCf = TreeMapBackedSortedColumns.factory.create(KS, StandardCF);
+        private final ColumnFamily SuperCf = TreeMapBackedSortedColumns.factory.create(KS, SuperCF);
 
         private final Row StandardRow = new Row(Util.dk("key0"), StandardCf);
         private final Row SuperRow = new Row(Util.dk("key1"), SuperCf);
diff --git a/test/unit/org/apache/cassandra/db/TableTest.java b/test/unit/org/apache/cassandra/db/TableTest.java
index cb564f7ef8..60274a5b61 100644
--- a/test/unit/org/apache/cassandra/db/TableTest.java
+++ b/test/unit/org/apache/cassandra/db/TableTest.java
@@ -26,6 +26,8 @@ import java.util.*;
 import java.io.IOException;
 import java.util.concurrent.ExecutionException;
 
+import com.google.common.collect.Iterables;
+
 import org.apache.cassandra.config.DatabaseDescriptor;
 
 import org.apache.commons.lang.StringUtils;
@@ -40,7 +42,6 @@ import static org.apache.cassandra.Util.column;
 import static org.apache.cassandra.Util.expiringColumn;
 import static org.apache.cassandra.Util.getBytes;
 import org.apache.cassandra.Util;
-import org.apache.cassandra.db.marshal.Int32Type;
 import org.apache.cassandra.io.sstable.SSTableReader;
 import org.apache.cassandra.utils.ByteBufferUtil;
 
@@ -63,7 +64,7 @@ public class TableTest extends SchemaLoader
         final Table table = Table.open("Keyspace2");
         final ColumnFamilyStore cfStore = table.getColumnFamilyStore("Standard3");
 
-        ColumnFamily cf = ColumnFamily.create("Keyspace2", "Standard3");
+        ColumnFamily cf = TreeMapBackedSortedColumns.factory.create("Keyspace2", "Standard3");
         cf.addColumn(column("col1","val1", 1L));
         RowMutation rm = new RowMutation("Keyspace2", TEST_KEY.key, cf);
         rm.apply();
@@ -93,7 +94,7 @@ public class TableTest extends SchemaLoader
         final Table table = Table.open("Keyspace1");
         final ColumnFamilyStore cfStore = table.getColumnFamilyStore("Standard1");
 
-        ColumnFamily cf = ColumnFamily.create("Keyspace1", "Standard1");
+        ColumnFamily cf = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
         cf.addColumn(column("col1","val1", 1L));
         cf.addColumn(column("col2","val2", 1L));
         cf.addColumn(column("col3","val3", 1L));
@@ -122,7 +123,7 @@ public class TableTest extends SchemaLoader
     	DecoratedKey key = TEST_SLICE_KEY;
     	Table table = Table.open("Keyspace1");
         ColumnFamilyStore cfStore = table.getColumnFamilyStore("Standard1");
-        ColumnFamily cf = ColumnFamily.create("Keyspace1", "Standard1");
+        ColumnFamily cf = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
         // First write "a", "b", "c"
         cf.addColumn(column("a", "val1", 1L));
         cf.addColumn(column("b", "val2", 1L));
@@ -144,7 +145,7 @@ public class TableTest extends SchemaLoader
     public void testGetSliceNoMatch() throws Throwable
     {
         Table table = Table.open("Keyspace1");
-        ColumnFamily cf = ColumnFamily.create("Keyspace1", "Standard2");
+        ColumnFamily cf = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard2");
         cf.addColumn(column("col1", "val1", 1));
         RowMutation rm = new RowMutation("Keyspace1", ByteBufferUtil.bytes("row1000"), cf);
         rm.apply();
@@ -168,7 +169,7 @@ public class TableTest extends SchemaLoader
         final DecoratedKey ROW = Util.dk("row4");
         final NumberFormat fmt = new DecimalFormat("000");
 
-        ColumnFamily cf = ColumnFamily.create("Keyspace1", "Standard1");
+        ColumnFamily cf = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
         // at this rate, we're getting 78-79 cos/block, assuming the blocks are set to be about 4k.
         // so if we go to 300, we'll get at least 4 blocks, which is plenty for testing.
         for (int i = 0; i < 300; i++)
@@ -226,7 +227,7 @@ public class TableTest extends SchemaLoader
 
         for (int i = 0; i < 10; i++)
         {
-            ColumnFamily cf = ColumnFamily.create("Keyspace1", "StandardLong1");
+            ColumnFamily cf = TreeMapBackedSortedColumns.factory.create("Keyspace1", "StandardLong1");
             cf.addColumn(new Column(ByteBufferUtil.bytes((long)i), ByteBufferUtil.EMPTY_BYTE_BUFFER, 0));
             RowMutation rm = new RowMutation("Keyspace1", ROW.key, cf);
             rm.apply();
@@ -236,13 +237,13 @@ public class TableTest extends SchemaLoader
 
         for (int i = 10; i < 20; i++)
         {
-            ColumnFamily cf = ColumnFamily.create("Keyspace1", "StandardLong1");
+            ColumnFamily cf = TreeMapBackedSortedColumns.factory.create("Keyspace1", "StandardLong1");
             cf.addColumn(new Column(ByteBufferUtil.bytes((long)i), ByteBufferUtil.EMPTY_BYTE_BUFFER, 0));
             RowMutation rm = new RowMutation("Keyspace1", ROW.key, cf);
             rm.apply();
 
             cf = cfs.getColumnFamily(ROW, ByteBufferUtil.EMPTY_BYTE_BUFFER, ByteBufferUtil.EMPTY_BYTE_BUFFER, true, 1);
-            assertEquals(1, cf.getColumnNames().size());
+            assertEquals(1, Iterables.size(cf.getColumnNames()));
             assertEquals(i, cf.getColumnNames().iterator().next().getLong());
         }
     }
@@ -269,7 +270,7 @@ public class TableTest extends SchemaLoader
         final ColumnFamilyStore cfStore = table.getColumnFamilyStore("Standard1");
         final DecoratedKey ROW = Util.dk("row1");
 
-        ColumnFamily cf = ColumnFamily.create("Keyspace1", "Standard1");
+        ColumnFamily cf = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
         cf.addColumn(column("col1", "val1", 1L));
         cf.addColumn(column("col3", "val3", 1L));
         cf.addColumn(column("col4", "val4", 1L));
@@ -324,7 +325,7 @@ public class TableTest extends SchemaLoader
         final ColumnFamilyStore cfStore = table.getColumnFamilyStore("Standard1");
         final DecoratedKey ROW = Util.dk("row5");
 
-        ColumnFamily cf = ColumnFamily.create("Keyspace1", "Standard1");
+        ColumnFamily cf = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
         cf.addColumn(column("col1", "val1", 1L));
         cf.addColumn(expiringColumn("col2", "val2", 1L, 60)); // long enough not to be tombstoned
         cf.addColumn(column("col3", "val3", 1L));
@@ -358,7 +359,7 @@ public class TableTest extends SchemaLoader
         final ColumnFamilyStore cfStore = table.getColumnFamilyStore("Standard1");
         final DecoratedKey ROW = Util.dk("row2");
 
-        ColumnFamily cf = ColumnFamily.create("Keyspace1", "Standard1");
+        ColumnFamily cf = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
         cf.addColumn(column("col1", "val1", 1L));
         cf.addColumn(column("col2", "val2", 1L));
         cf.addColumn(column("col3", "val3", 1L));
@@ -369,7 +370,7 @@ public class TableTest extends SchemaLoader
         rm.apply();
         cfStore.forceBlockingFlush();
 
-        cf = ColumnFamily.create("Keyspace1", "Standard1");
+        cf = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
         cf.addColumn(column("col1", "valx", 2L));
         cf.addColumn(column("col2", "valx", 2L));
         cf.addColumn(column("col3", "valx", 2L));
@@ -406,7 +407,7 @@ public class TableTest extends SchemaLoader
         Table table = Table.open("Keyspace1");
         ColumnFamilyStore cfStore = table.getColumnFamilyStore("Standard1");
         DecoratedKey key = Util.dk("row3");
-        ColumnFamily cf = ColumnFamily.create("Keyspace1", "Standard1");
+        ColumnFamily cf = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
         for (int i = 1000; i < 2000; i++)
             cf.addColumn(column("col" + i, ("v" + i), 1L));
         RowMutation rm = new RowMutation("Keyspace1", key.key, cf);
diff --git a/test/unit/org/apache/cassandra/io/LazilyCompactedRowTest.java b/test/unit/org/apache/cassandra/io/LazilyCompactedRowTest.java
index 820565a51b..7e677baac5 100644
--- a/test/unit/org/apache/cassandra/io/LazilyCompactedRowTest.java
+++ b/test/unit/org/apache/cassandra/io/LazilyCompactedRowTest.java
@@ -44,8 +44,6 @@ import org.apache.cassandra.io.util.MappedFileDataInput;
 import org.apache.cassandra.net.MessagingService;
 import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.cassandra.utils.CloseableIterator;
-import org.apache.cassandra.utils.FBUtilities;
-import org.apache.cassandra.utils.UUIDGen;
 
 import static junit.framework.Assert.assertEquals;
 
@@ -118,8 +116,8 @@ public class LazilyCompactedRowTest extends SchemaLoader
             assertEquals(rowSize2 + 8, out2.getLength());
 
             // cf metadata
-            ColumnFamily cf1 = ColumnFamily.create(cfs.metadata);
-            ColumnFamily cf2 = ColumnFamily.create(cfs.metadata);
+            ColumnFamily cf1 = TreeMapBackedSortedColumns.factory.create(cfs.metadata);
+            ColumnFamily cf2 = TreeMapBackedSortedColumns.factory.create(cfs.metadata);
             cf1.delete(DeletionInfo.serializer().deserializeFromSSTable(in1, Descriptor.Version.CURRENT));
             cf2.delete(DeletionInfo.serializer().deserializeFromSSTable(in2, Descriptor.Version.CURRENT));
             assert cf1.deletionInfo().equals(cf2.deletionInfo());
diff --git a/test/unit/org/apache/cassandra/io/sstable/SSTableTest.java b/test/unit/org/apache/cassandra/io/sstable/SSTableTest.java
index 0b505fcb67..d3b3b4bc5d 100644
--- a/test/unit/org/apache/cassandra/io/sstable/SSTableTest.java
+++ b/test/unit/org/apache/cassandra/io/sstable/SSTableTest.java
@@ -40,7 +40,7 @@ public class SSTableTest extends SchemaLoader
         ByteBuffer key = ByteBufferUtil.bytes(Integer.toString(1));
         ByteBuffer cbytes = ByteBuffer.wrap(new byte[1024]);
         new Random().nextBytes(cbytes.array());
-        ColumnFamily cf = ColumnFamily.create("Keyspace1", "Standard1");
+        ColumnFamily cf = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
         cf.addColumn(new Column(cbytes, cbytes));
 
         SortedMap<DecoratedKey, ColumnFamily> map = new TreeMap<DecoratedKey, ColumnFamily>();
@@ -73,7 +73,7 @@ public class SSTableTest extends SchemaLoader
         //for (int i = 100; i < 1000; ++i)
         for (int i = 100; i < 300; ++i)
         {
-            ColumnFamily cf = ColumnFamily.create("Keyspace1", "Standard2");
+            ColumnFamily cf = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard2");
             ByteBuffer bytes = ByteBufferUtil.bytes(("Avinash Lakshman is a good man: " + i));
             cf.addColumn(new Column(bytes, bytes));
             map.put(Util.dk(Integer.toString(i)), cf);
diff --git a/test/unit/org/apache/cassandra/io/sstable/SSTableUtils.java b/test/unit/org/apache/cassandra/io/sstable/SSTableUtils.java
index 157b9dd110..c5c41c398a 100644
--- a/test/unit/org/apache/cassandra/io/sstable/SSTableUtils.java
+++ b/test/unit/org/apache/cassandra/io/sstable/SSTableUtils.java
@@ -23,10 +23,7 @@ import java.io.File;
 import java.io.IOException;
 import java.util.*;
 
-import org.apache.cassandra.db.Column;
-import org.apache.cassandra.db.ColumnFamily;
-import org.apache.cassandra.db.DecoratedKey;
-import org.apache.cassandra.db.DeletionInfo;
+import org.apache.cassandra.db.*;
 import org.apache.cassandra.db.columniterator.OnDiskAtomIterator;
 import org.apache.cassandra.utils.ByteBufferUtil;
 
@@ -41,7 +38,7 @@ public class SSTableUtils
 
     public static ColumnFamily createCF(long mfda, int ldt, Column... cols)
     {
-        ColumnFamily cf = ColumnFamily.create(TABLENAME, CFNAME);
+        ColumnFamily cf = TreeMapBackedSortedColumns.factory.create(TABLENAME, CFNAME);
         cf.delete(new DeletionInfo(mfda, ldt));
         for (Column col : cols)
             cf.addColumn(col);
@@ -165,7 +162,7 @@ public class SSTableUtils
             Map<String, ColumnFamily> map = new HashMap<String, ColumnFamily>();
             for (String key : keys)
             {
-                ColumnFamily cf = ColumnFamily.create(ksname, cfname);
+                ColumnFamily cf = TreeMapBackedSortedColumns.factory.create(ksname, cfname);
                 cf.addColumn(new Column(ByteBufferUtil.bytes(key), ByteBufferUtil.bytes(key), 0));
                 map.put(key, cf);
             }
diff --git a/test/unit/org/apache/cassandra/service/AntiEntropyServiceTestAbstract.java b/test/unit/org/apache/cassandra/service/AntiEntropyServiceTestAbstract.java
index 1cb14a8957..3b14b6472a 100644
--- a/test/unit/org/apache/cassandra/service/AntiEntropyServiceTestAbstract.java
+++ b/test/unit/org/apache/cassandra/service/AntiEntropyServiceTestAbstract.java
@@ -154,7 +154,7 @@ public abstract class AntiEntropyServiceTestAbstract extends SchemaLoader
 
         // add a row
         validator.add(new PrecompactedRow(new DecoratedKey(mid, ByteBufferUtil.bytes("inconceivable!")),
-                                          ColumnFamily.create(Schema.instance.getCFMetaData(tablename, cfname))));
+                                          TreeMapBackedSortedColumns.factory.create(Schema.instance.getCFMetaData(tablename, cfname))));
         validator.completeTree();
 
         // confirm that the tree was validated
diff --git a/test/unit/org/apache/cassandra/service/RowResolverTest.java b/test/unit/org/apache/cassandra/service/RowResolverTest.java
index 1cc9f4f38f..c2e0c1d9c6 100644
--- a/test/unit/org/apache/cassandra/service/RowResolverTest.java
+++ b/test/unit/org/apache/cassandra/service/RowResolverTest.java
@@ -28,6 +28,7 @@ import org.junit.Test;
 import org.apache.cassandra.SchemaLoader;
 import org.apache.cassandra.db.ColumnFamily;
 import org.apache.cassandra.db.DeletionInfo;
+import org.apache.cassandra.db.TreeMapBackedSortedColumns;
 
 import static junit.framework.Assert.*;
 import static org.apache.cassandra.Util.column;
@@ -38,10 +39,10 @@ public class RowResolverTest extends SchemaLoader
     @Test
     public void testResolveSupersetNewer()
     {
-        ColumnFamily cf1 = ColumnFamily.create("Keyspace1", "Standard1");
+        ColumnFamily cf1 = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
         cf1.addColumn(column("c1", "v1", 0));
 
-        ColumnFamily cf2 = ColumnFamily.create("Keyspace1", "Standard1");
+        ColumnFamily cf2 = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
         cf2.addColumn(column("c1", "v2", 1));
 
         ColumnFamily resolved = RowDataResolver.resolveSuperset(Arrays.asList(cf1, cf2));
@@ -53,10 +54,10 @@ public class RowResolverTest extends SchemaLoader
     @Test
     public void testResolveSupersetDisjoint()
     {
-        ColumnFamily cf1 = ColumnFamily.create("Keyspace1", "Standard1");
+        ColumnFamily cf1 = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
         cf1.addColumn(column("c1", "v1", 0));
 
-        ColumnFamily cf2 = ColumnFamily.create("Keyspace1", "Standard1");
+        ColumnFamily cf2 = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
         cf2.addColumn(column("c2", "v2", 1));
 
         ColumnFamily resolved = RowDataResolver.resolveSuperset(Arrays.asList(cf1, cf2));
@@ -68,7 +69,7 @@ public class RowResolverTest extends SchemaLoader
     @Test
     public void testResolveSupersetNullOne()
     {
-        ColumnFamily cf2 = ColumnFamily.create("Keyspace1", "Standard1");
+        ColumnFamily cf2 = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
         cf2.addColumn(column("c2", "v2", 1));
 
         ColumnFamily resolved = RowDataResolver.resolveSuperset(Arrays.asList(null, cf2));
@@ -80,7 +81,7 @@ public class RowResolverTest extends SchemaLoader
     @Test
     public void testResolveSupersetNullTwo()
     {
-        ColumnFamily cf1 = ColumnFamily.create("Keyspace1", "Standard1");
+        ColumnFamily cf1 = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
         cf1.addColumn(column("c1", "v1", 0));
 
         ColumnFamily resolved = RowDataResolver.resolveSuperset(Arrays.asList(cf1, null));
@@ -99,10 +100,10 @@ public class RowResolverTest extends SchemaLoader
     public void testResolveDeleted()
     {
         // one CF with columns timestamped before a delete in another cf
-        ColumnFamily cf1 = ColumnFamily.create("Keyspace1", "Standard1");
+        ColumnFamily cf1 = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
         cf1.addColumn(column("one", "A", 0));
 
-        ColumnFamily cf2 = ColumnFamily.create("Keyspace1", "Standard1");
+        ColumnFamily cf2 = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
         cf2.delete(new DeletionInfo(1L, (int) (System.currentTimeMillis() / 1000)));
 
         ColumnFamily resolved = RowDataResolver.resolveSuperset(Arrays.asList(cf1, cf2));
@@ -117,19 +118,19 @@ public class RowResolverTest extends SchemaLoader
     {
         // deletes and columns with interleaved timestamp, with out of order return sequence
 
-        ColumnFamily cf1 = ColumnFamily.create("Keyspace1", "Standard1");
+        ColumnFamily cf1 = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
         cf1.delete(new DeletionInfo(0L, (int) (System.currentTimeMillis() / 1000)));
 
         // these columns created after the previous deletion
-        ColumnFamily cf2 = ColumnFamily.create("Keyspace1", "Standard1");
+        ColumnFamily cf2 = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
         cf2.addColumn(column("one", "A", 1));
         cf2.addColumn(column("two", "A", 1));
 
         //this column created after the next delete
-        ColumnFamily cf3 = ColumnFamily.create("Keyspace1", "Standard1");
+        ColumnFamily cf3 = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
         cf3.addColumn(column("two", "B", 3));
 
-        ColumnFamily cf4 = ColumnFamily.create("Keyspace1", "Standard1");
+        ColumnFamily cf4 = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
         cf4.delete(new DeletionInfo(2L, (int) (System.currentTimeMillis() / 1000)));
 
         ColumnFamily resolved = RowDataResolver.resolveSuperset(Arrays.asList(cf1, cf2, cf3, cf4));
diff --git a/test/unit/org/apache/cassandra/streaming/StreamingTransferTest.java b/test/unit/org/apache/cassandra/streaming/StreamingTransferTest.java
index 5083e6bb9a..46e0e6c1e6 100644
--- a/test/unit/org/apache/cassandra/streaming/StreamingTransferTest.java
+++ b/test/unit/org/apache/cassandra/streaming/StreamingTransferTest.java
@@ -23,7 +23,6 @@ import static junit.framework.Assert.assertEquals;
 import org.apache.cassandra.OrderedJUnit4ClassRunner;
 import org.apache.cassandra.Util;
 import static org.apache.cassandra.Util.column;
-import static org.apache.cassandra.Util.addMutation;
 
 import java.net.InetAddress;
 import java.sql.Date;
@@ -142,7 +141,7 @@ public class StreamingTransferTest extends SchemaLoader
             public void mutate(String key, String col, long timestamp) throws Exception
             {
                 long val = key.hashCode();
-                ColumnFamily cf = ColumnFamily.create(table.getName(), cfs.name);
+                ColumnFamily cf = TreeMapBackedSortedColumns.factory.create(table.getName(), cfs.name);
                 cf.addColumn(column(col, "v", timestamp));
                 cf.addColumn(new Column(ByteBufferUtil.bytes("birthdate"), ByteBufferUtil.bytes(val), timestamp));
                 RowMutation rm = new RowMutation("Keyspace1", ByteBufferUtil.bytes(key), cf);
@@ -183,8 +182,8 @@ public class StreamingTransferTest extends SchemaLoader
             public void mutate(String key, String col, long timestamp) throws Exception
             {
                 Map<String, ColumnFamily> entries = new HashMap<String, ColumnFamily>();
-                ColumnFamily cf = ColumnFamily.create(cfs.metadata);
-                ColumnFamily cfCleaned = ColumnFamily.create(cfs.metadata);
+                ColumnFamily cf = TreeMapBackedSortedColumns.factory.create(cfs.metadata);
+                ColumnFamily cfCleaned = TreeMapBackedSortedColumns.factory.create(cfs.metadata);
                 CounterContext.ContextState state = CounterContext.ContextState.allocate(4, 1);
                 state.writeElement(CounterId.fromInt(2), 9L, 3L, true);
                 state.writeElement(CounterId.fromInt(4), 4L, 2L);
@@ -330,7 +329,7 @@ public class StreamingTransferTest extends SchemaLoader
         {
             public void mutate(String key, String colName, long timestamp) throws Exception
             {
-                ColumnFamily cf = ColumnFamily.create(table.getName(), cfs.name);
+                ColumnFamily cf = TreeMapBackedSortedColumns.factory.create(table.getName(), cfs.name);
                 cf.addColumn(column(colName, "value", timestamp));
                 cf.addColumn(new Column(ByteBufferUtil.bytes("birthdate"), ByteBufferUtil.bytes(new Date(timestamp).toString()), timestamp));
                 RowMutation rm = new RowMutation("Keyspace1", ByteBufferUtil.bytes(key), cf);
diff --git a/test/unit/org/apache/cassandra/tools/SSTableExportTest.java b/test/unit/org/apache/cassandra/tools/SSTableExportTest.java
index c3a2e20281..acee881b24 100644
--- a/test/unit/org/apache/cassandra/tools/SSTableExportTest.java
+++ b/test/unit/org/apache/cassandra/tools/SSTableExportTest.java
@@ -35,11 +35,7 @@ import org.junit.Test;
 
 import org.apache.cassandra.SchemaLoader;
 import org.apache.cassandra.Util;
-import org.apache.cassandra.db.Column;
-import org.apache.cassandra.db.ColumnFamily;
-import org.apache.cassandra.db.CounterColumn;
-import org.apache.cassandra.db.DeletionInfo;
-import org.apache.cassandra.db.ExpiringColumn;
+import org.apache.cassandra.db.*;
 import org.apache.cassandra.db.filter.QueryFilter;
 import org.apache.cassandra.db.marshal.UTF8Type;
 import org.apache.cassandra.io.sstable.Descriptor;
@@ -62,7 +58,7 @@ public class SSTableExportTest extends SchemaLoader
     public void testEnumeratekeys() throws IOException
     {
         File tempSS = tempSSTableFile("Keyspace1", "Standard1");
-        ColumnFamily cfamily = ColumnFamily.create("Keyspace1", "Standard1");
+        ColumnFamily cfamily = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
         SSTableWriter writer = new SSTableWriter(tempSS.getPath(), 2);
 
         // Add rowA
@@ -95,7 +91,7 @@ public class SSTableExportTest extends SchemaLoader
     public void testExportSimpleCf() throws IOException, ParseException
     {
         File tempSS = tempSSTableFile("Keyspace1", "Standard1");
-        ColumnFamily cfamily = ColumnFamily.create("Keyspace1", "Standard1");
+        ColumnFamily cfamily = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
         SSTableWriter writer = new SSTableWriter(tempSS.getPath(), 2);
 
         int nowInSec = (int)(System.currentTimeMillis() / 1000) + 42; //live for 42 seconds
@@ -150,7 +146,7 @@ public class SSTableExportTest extends SchemaLoader
     public void testRoundTripStandardCf() throws IOException, ParseException
     {
         File tempSS = tempSSTableFile("Keyspace1", "Standard1");
-        ColumnFamily cfamily = ColumnFamily.create("Keyspace1", "Standard1");
+        ColumnFamily cfamily = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
         SSTableWriter writer = new SSTableWriter(tempSS.getPath(), 2);
 
         // Add rowA
@@ -189,7 +185,7 @@ public class SSTableExportTest extends SchemaLoader
     public void testExportCounterCf() throws IOException, ParseException
     {
         File tempSS = tempSSTableFile("Keyspace1", "Counter1");
-        ColumnFamily cfamily = ColumnFamily.create("Keyspace1", "Counter1");
+        ColumnFamily cfamily = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Counter1");
         SSTableWriter writer = new SSTableWriter(tempSS.getPath(), 2);
 
         // Add rowA
@@ -220,7 +216,7 @@ public class SSTableExportTest extends SchemaLoader
     public void testEscapingDoubleQuotes() throws IOException, ParseException
     {
         File tempSS = tempSSTableFile("Keyspace1", "ValuesWithQuotes");
-        ColumnFamily cfamily = ColumnFamily.create("Keyspace1", "ValuesWithQuotes");
+        ColumnFamily cfamily = TreeMapBackedSortedColumns.factory.create("Keyspace1", "ValuesWithQuotes");
         SSTableWriter writer = new SSTableWriter(tempSS.getPath(), 2);
 
         // Add rowA
@@ -252,7 +248,7 @@ public class SSTableExportTest extends SchemaLoader
     {
 
         File tempSS = tempSSTableFile("Keyspace1", "Standard1");
-        ColumnFamily cfamily = ColumnFamily.create("Keyspace1", "Standard1");
+        ColumnFamily cfamily = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
         SSTableWriter writer = new SSTableWriter(tempSS.getPath(), 2);
 
         // Add rowA
diff --git a/test/unit/org/apache/cassandra/tools/SSTableImportTest.java b/test/unit/org/apache/cassandra/tools/SSTableImportTest.java
index a9d770a2b3..2954e54b09 100644
--- a/test/unit/org/apache/cassandra/tools/SSTableImportTest.java
+++ b/test/unit/org/apache/cassandra/tools/SSTableImportTest.java
@@ -32,13 +32,7 @@ import org.junit.Test;
 
 import org.apache.cassandra.SchemaLoader;
 import org.apache.cassandra.Util;
-import org.apache.cassandra.db.Column;
-import org.apache.cassandra.db.ColumnFamily;
-import org.apache.cassandra.db.CounterColumn;
-import org.apache.cassandra.db.DeletedColumn;
-import org.apache.cassandra.db.DeletionInfo;
-import org.apache.cassandra.db.DeletionTime;
-import org.apache.cassandra.db.ExpiringColumn;
+import org.apache.cassandra.db.*;
 import org.apache.cassandra.db.columniterator.OnDiskAtomIterator;
 import org.apache.cassandra.db.filter.QueryFilter;
 import org.apache.cassandra.db.marshal.CompositeType;
@@ -61,7 +55,7 @@ public class SSTableImportTest extends SchemaLoader
         SSTableReader reader = SSTableReader.open(Descriptor.fromFilename(tempSS.getPath()));
         QueryFilter qf = QueryFilter.getIdentityFilter(Util.dk("rowA"), "Standard1");
         OnDiskAtomIterator iter = qf.getSSTableColumnIterator(reader);
-        ColumnFamily cf = iter.getColumnFamily();
+        ColumnFamily cf = cloneForAdditions(iter);
         while (iter.hasNext()) cf.addAtom(iter.next());
         assert cf.getColumn(ByteBufferUtil.bytes("colAA")).value().equals(hexToBytes("76616c4141"));
         assert !(cf.getColumn(ByteBufferUtil.bytes("colAA")) instanceof DeletedColumn);
@@ -71,6 +65,11 @@ public class SSTableImportTest extends SchemaLoader
         assert ((ExpiringColumn)expCol).getTimeToLive() == 42 && expCol.getLocalDeletionTime() == 2000000000;
     }
 
+    private ColumnFamily cloneForAdditions(OnDiskAtomIterator iter)
+    {
+        return iter.getColumnFamily().cloneMeShallow(ArrayBackedSortedColumns.factory, false);
+    }
+
     private String resourcePath(String name) throws URISyntaxException
     {
         // Naive resource.getPath fails on Windows in many cases, for example if there are spaces in the path
@@ -90,7 +89,7 @@ public class SSTableImportTest extends SchemaLoader
         SSTableReader reader = SSTableReader.open(Descriptor.fromFilename(tempSS.getPath()));
         QueryFilter qf = QueryFilter.getIdentityFilter(Util.dk("rowA"), "Standard1");
         OnDiskAtomIterator iter = qf.getSSTableColumnIterator(reader);
-        ColumnFamily cf = iter.getColumnFamily();
+        ColumnFamily cf = cloneForAdditions(iter);
         while (iter.hasNext()) cf.addAtom(iter.next());
         assert cf.getColumn(ByteBufferUtil.bytes("colAA")).value().equals(hexToBytes("76616c4141"));
         assert !(cf.getColumn(ByteBufferUtil.bytes("colAA")) instanceof DeletedColumn);
@@ -110,7 +109,7 @@ public class SSTableImportTest extends SchemaLoader
         // Verify results
         SSTableReader reader = SSTableReader.open(Descriptor.fromFilename(tempSS.getPath()));
         QueryFilter qf = QueryFilter.getIdentityFilter(Util.dk("rowA"), "Super4");
-        ColumnFamily cf = qf.getSSTableColumnIterator(reader).getColumnFamily();
+        ColumnFamily cf = cloneForAdditions(qf.getSSTableColumnIterator(reader));
         qf.collateOnDiskAtom(cf, Collections.singletonList(qf.getSSTableColumnIterator(reader)), Integer.MIN_VALUE);
 
         DeletionTime delTime = cf.deletionInfo().rangeCovering(CompositeType.build(ByteBufferUtil.bytes("superA"))).iterator().next();
@@ -140,7 +139,7 @@ public class SSTableImportTest extends SchemaLoader
         SSTableReader reader = SSTableReader.open(Descriptor.fromFilename(tempSS.getPath()));
         QueryFilter qf = QueryFilter.getIdentityFilter(Util.dk("rowA"), "Standard1");
         OnDiskAtomIterator iter = qf.getSSTableColumnIterator(reader);
-        ColumnFamily cf = iter.getColumnFamily();
+        ColumnFamily cf = cloneForAdditions(iter);
         while (iter.hasNext())
             cf.addAtom(iter.next());
         assert cf.getColumn(ByteBufferUtil.bytes("colAA")).value().equals(hexToBytes("76616c4141"));
@@ -163,7 +162,7 @@ public class SSTableImportTest extends SchemaLoader
         SSTableReader reader = SSTableReader.open(Descriptor.fromFilename(tempSS.getPath()));
         QueryFilter qf = QueryFilter.getIdentityFilter(Util.dk("rowA"), "Standard1");
         OnDiskAtomIterator iter = qf.getSSTableColumnIterator(reader);
-        ColumnFamily cf = iter.getColumnFamily();
+        ColumnFamily cf = cloneForAdditions(iter);
         assertEquals(cf.deletionInfo(), new DeletionInfo(0, 0));
         while (iter.hasNext())
             cf.addAtom(iter.next());
@@ -187,7 +186,7 @@ public class SSTableImportTest extends SchemaLoader
         SSTableReader reader = SSTableReader.open(Descriptor.fromFilename(tempSS.getPath()));
         QueryFilter qf = QueryFilter.getIdentityFilter(Util.dk("rowA"), "Counter1");
         OnDiskAtomIterator iter = qf.getSSTableColumnIterator(reader);
-        ColumnFamily cf = iter.getColumnFamily();
+        ColumnFamily cf = cloneForAdditions(iter);
         while (iter.hasNext()) cf.addAtom(iter.next());
         Column c = cf.getColumn(ByteBufferUtil.bytes("colAA"));
         assert c instanceof CounterColumn: c;
diff --git a/test/unit/org/apache/cassandra/utils/EncodedStreamsTest.java b/test/unit/org/apache/cassandra/utils/EncodedStreamsTest.java
index f93191f42a..bcc5ba6fd8 100644
--- a/test/unit/org/apache/cassandra/utils/EncodedStreamsTest.java
+++ b/test/unit/org/apache/cassandra/utils/EncodedStreamsTest.java
@@ -27,6 +27,7 @@ import java.io.IOException;
 
 import org.apache.cassandra.SchemaLoader;
 import org.apache.cassandra.db.ColumnFamily;
+import org.apache.cassandra.db.TreeMapBackedSortedColumns;
 import org.apache.cassandra.db.TypeSizes;
 import org.apache.cassandra.net.MessagingService;
 import org.apache.cassandra.utils.vint.EncodedDataInputStream;
@@ -96,7 +97,7 @@ public class EncodedStreamsTest extends SchemaLoader
 
     private ColumnFamily createCF()
     {
-        ColumnFamily cf = ColumnFamily.create(tableName, standardCFName);
+        ColumnFamily cf = TreeMapBackedSortedColumns.factory.create(tableName, standardCFName);
         cf.addColumn(column("vijay", "try", 1));
         cf.addColumn(column("to", "be_nice", 1));
         return cf;
@@ -104,7 +105,7 @@ public class EncodedStreamsTest extends SchemaLoader
 
     private ColumnFamily createCounterCF()
     {
-        ColumnFamily cf = ColumnFamily.create(tableName, counterCFName);
+        ColumnFamily cf = TreeMapBackedSortedColumns.factory.create(tableName, counterCFName);
         cf.addColumn(counterColumn("vijay", 1L, 1));
         cf.addColumn(counterColumn("wants", 1000000, 1));
         return cf;
