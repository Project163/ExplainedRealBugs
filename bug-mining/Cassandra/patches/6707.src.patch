diff --git a/src/java/org/apache/cassandra/config/AccordSpec.java b/src/java/org/apache/cassandra/config/AccordSpec.java
index 102ae68b67..39fefbf187 100644
--- a/src/java/org/apache/cassandra/config/AccordSpec.java
+++ b/src/java/org/apache/cassandra/config/AccordSpec.java
@@ -18,10 +18,15 @@
 
 package org.apache.cassandra.config;
 
+import accord.primitives.Routable;
+import accord.primitives.Txn;
+import accord.primitives.TxnId;
 import com.fasterxml.jackson.annotation.JsonIgnore;
 import org.apache.cassandra.journal.Params;
 import org.apache.cassandra.service.consensus.TransactionalMode;
 
+import java.util.concurrent.TimeUnit;
+
 public class AccordSpec
 {
     public volatile boolean enabled = false;
@@ -32,7 +37,16 @@ public class AccordSpec
 
     public volatile OptionaldPositiveInt shard_count = OptionaldPositiveInt.UNDEFINED;
 
-    public volatile DurationSpec.IntMillisecondsBound recover_delay = new DurationSpec.IntMillisecondsBound(1000);
+    // TODO (expected): we should be able to support lower recover delays, at least for txns
+    public volatile DurationSpec.IntMillisecondsBound recover_delay = new DurationSpec.IntMillisecondsBound(5000);
+    public volatile DurationSpec.IntMillisecondsBound range_sync_recover_delay = new DurationSpec.IntMillisecondsBound(10000);
+
+    public long recoveryDelayFor(TxnId txnId, TimeUnit unit)
+    {
+        if (txnId.kind() == Txn.Kind.SyncPoint && txnId.domain() == Routable.Domain.Range)
+            return range_sync_recover_delay.to(unit);
+        return recover_delay.to(unit);
+    }
 
     /**
      * When a barrier transaction is requested how many times to repeat attempting the barrier before giving up
diff --git a/src/java/org/apache/cassandra/schema/Schema.java b/src/java/org/apache/cassandra/schema/Schema.java
index 31a76f33b1..fcfae3f151 100644
--- a/src/java/org/apache/cassandra/schema/Schema.java
+++ b/src/java/org/apache/cassandra/schema/Schema.java
@@ -279,10 +279,15 @@ public final class Schema implements SchemaProvider
     @Override
     public TableMetadata getTableMetadata(TableId id)
     {
-        return ObjectUtils.getFirstNonNull(() -> localKeyspaces.getTableOrViewNullable(id),
-                                           () -> distributedKeyspaces().getTableOrViewNullable(id),
-                                           () -> VirtualKeyspaceRegistry.instance.getTableMetadataNullable(id));
+        TableMetadata metadata = localKeyspaces.getTableOrViewNullable(id);
+        if (metadata != null)
+            return metadata;
 
+        metadata = distributedKeyspaces().getTableOrViewNullable(id);
+        if (metadata != null)
+            return metadata;
+
+        return VirtualKeyspaceRegistry.instance.getTableMetadataNullable(id);
     }
 
     public TableMetadata getTableMetadata(Descriptor descriptor)
diff --git a/src/java/org/apache/cassandra/service/accord/api/AccordAgent.java b/src/java/org/apache/cassandra/service/accord/api/AccordAgent.java
index 441277e757..bf351c323f 100644
--- a/src/java/org/apache/cassandra/service/accord/api/AccordAgent.java
+++ b/src/java/org/apache/cassandra/service/accord/api/AccordAgent.java
@@ -186,7 +186,7 @@ public class AccordAgent implements Agent
 
         // TODO (expected): make this a configurable calculation on normal request latencies (like ContentionStrategy)
         long oneSecond = SECONDS.toMicros(1L);
-        long startTime = mostRecentAttempt.hlc() + DatabaseDescriptor.getAccord().recover_delay.to(MICROSECONDS)
+        long startTime = mostRecentAttempt.hlc() + DatabaseDescriptor.getAccord().recoveryDelayFor(txnId, MICROSECONDS)
                          + (retryCount == 0 ? 0 : random.nextLong(oneSecond << Math.min(retryCount, 4)));
 
         startTime = nonClashingStartTime(startTime, shard == null ? null : shard.nodes, node.id(), oneSecond, random);
diff --git a/src/java/org/apache/cassandra/service/accord/async/AsyncLoader.java b/src/java/org/apache/cassandra/service/accord/async/AsyncLoader.java
index c6c508ebc5..2b1cfa55cc 100644
--- a/src/java/org/apache/cassandra/service/accord/async/AsyncLoader.java
+++ b/src/java/org/apache/cassandra/service/accord/async/AsyncLoader.java
@@ -27,6 +27,7 @@ import accord.utils.async.AsyncChains;
 import accord.utils.async.AsyncResult;
 import accord.utils.async.Observable;
 import com.google.common.annotations.VisibleForTesting;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import org.apache.cassandra.service.accord.*;
@@ -202,30 +203,30 @@ public class AsyncLoader
         return AsyncChains.all(root);
     }
 
-    private AsyncChain<Set<? extends Key>> findOverlappingKeys(Ranges ranges)
+    private AsyncChain<List<? extends Key>> findOverlappingKeys(Ranges ranges)
     {
         if (ranges.isEmpty())
         {
             // During topology changes some shards may be included with empty ranges
-            return AsyncChains.success(Collections.emptySet());
+            return AsyncChains.success(Collections.emptyList());
         }
 
-        List<AsyncChain<Set<PartitionKey>>> chains = new ArrayList<>(ranges.size());
+        List<AsyncChain<List<PartitionKey>>> chains = new ArrayList<>(ranges.size());
         for (Range range : ranges)
             chains.add(findOverlappingKeys(range));
-        return AsyncChains.reduce(chains, (a, b) -> ImmutableSet.<Key>builder().addAll(a).addAll(b).build());
+        return AsyncChains.reduce(chains, (a, b) -> ImmutableList.<Key>builderWithExpectedSize(a.size() + b.size()).addAll(a).addAll(b).build());
     }
 
-    private AsyncChain<Set<PartitionKey>> findOverlappingKeys(Range range)
+    private AsyncChain<List<PartitionKey>> findOverlappingKeys(Range range)
     {
         // save to a variable as java gets confused when `.map` is called on the result of asChain
-        AsyncChain<Set<PartitionKey>> map = Observable.asChain(callback ->
+        AsyncChain<List<PartitionKey>> map = Observable.asChain(callback ->
                                                                AccordKeyspace.findAllKeysBetween(commandStore.id(),
                                                                                                  (AccordRoutingKey) range.start(), range.startInclusive(),
                                                                                                  (AccordRoutingKey) range.end(), range.endInclusive(),
                                                                                                  callback),
-                                                               Collectors.toSet());
-        return map.map(s -> ImmutableSet.<PartitionKey>builder().addAll(s).build());
+                                                               Collectors.toList());
+        return map.map(ImmutableList::copyOf);
     }
 
     @VisibleForTesting
diff --git a/src/java/org/apache/cassandra/service/accord/repair/AccordRepair.java b/src/java/org/apache/cassandra/service/accord/repair/AccordRepair.java
index 51497792cd..02780219d2 100644
--- a/src/java/org/apache/cassandra/service/accord/repair/AccordRepair.java
+++ b/src/java/org/apache/cassandra/service/accord/repair/AccordRepair.java
@@ -125,6 +125,7 @@ public class AccordRepair
         int rangeStepUpdateInterval = ACCORD_REPAIR_RANGE_STEP_UPDATE_INTERVAL.getInt();
         RoutingKey remainingStart = range.start();
         // TODO (expected): repair ranges should have a configurable lower limit of split size so already small repairs aren't broken up into excessively tiny ones
+        // TODO (expected): we should support lower range divisions for accord repair
         BigInteger rangeSize = splitter.sizeOf(range);
         if (rangeStep == null)
         {
diff --git a/test/distributed/org/apache/cassandra/distributed/test/accord/AccordIncrementalRepairTest.java b/test/distributed/org/apache/cassandra/distributed/test/accord/AccordIncrementalRepairTest.java
index f295ce6e1d..e30706a47e 100644
--- a/test/distributed/org/apache/cassandra/distributed/test/accord/AccordIncrementalRepairTest.java
+++ b/test/distributed/org/apache/cassandra/distributed/test/accord/AccordIncrementalRepairTest.java
@@ -148,7 +148,7 @@ public class AccordIncrementalRepairTest extends AccordTestBase
     public static void setupClass() throws Throwable
     {
         CassandraRelevantProperties.ACCORD_AGENT_CLASS.setString(BarrierRecordingAgent.class.getName());
-        setupCluster(opt -> opt.withConfig(conf -> conf.with(Feature.NETWORK, Feature.GOSSIP)), 3);
+        setupCluster(opt -> opt.withConfig(conf -> conf.with(Feature.NETWORK, Feature.GOSSIP).set("accord.recover_delay", "1s")), 3);
 //        setupCluster(opt -> opt, 3);
     }
 
diff --git a/test/distributed/org/apache/cassandra/distributed/test/accord/AccordProgressLogTest.java b/test/distributed/org/apache/cassandra/distributed/test/accord/AccordProgressLogTest.java
index b69f6a6b48..e326f49d25 100644
--- a/test/distributed/org/apache/cassandra/distributed/test/accord/AccordProgressLogTest.java
+++ b/test/distributed/org/apache/cassandra/distributed/test/accord/AccordProgressLogTest.java
@@ -44,7 +44,9 @@ public class AccordProgressLogTest extends TestBaseImpl
     {
         try (Cluster cluster = init(Cluster.build(3)
                                            .withoutVNodes()
-                                           .withConfig(c -> c.with(Feature.NETWORK).set("accord.enabled", "true"))
+                                           .withConfig(c -> c.with(Feature.NETWORK)
+                                                             .set("accord.enabled", "true")
+                                                            .set("accord.recover_delay", "1s"))
                                            .start()))
         {
             cluster.schemaChange("CREATE KEYSPACE ks WITH replication={'class':'SimpleStrategy', 'replication_factor': 3}");
