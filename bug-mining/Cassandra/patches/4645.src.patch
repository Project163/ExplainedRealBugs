diff --git a/CHANGES.txt b/CHANGES.txt
index f2419d6fa4..91a6b31e36 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,6 @@
 3.0.12
+ * Fix cqlsh COPY for dates before 1900 (CASSANDRA-13185)
+
 Merged from 2.2
  * Fix ColumnCounter::countAll behaviour for reverse queries (CASSANDRA-13222)
  * Exceptions encountered calling getSeeds() breaks OTC thread (CASSANDRA-13018)
diff --git a/pylib/cqlshlib/formatting.py b/pylib/cqlshlib/formatting.py
index dcd08da2e4..097b1a77a4 100644
--- a/pylib/cqlshlib/formatting.py
+++ b/pylib/cqlshlib/formatting.py
@@ -246,7 +246,15 @@ def strftime(time_format, seconds, timezone=None):
     ret_dt = datetime_from_timestamp(seconds).replace(tzinfo=UTC())
     if timezone:
         ret_dt = ret_dt.astimezone(timezone)
-    return ret_dt.strftime(time_format)
+    try:
+        return ret_dt.strftime(time_format)
+    except ValueError:
+        # CASSANDRA-13185: if the date cannot be formatted as a string, return a string with the milliseconds
+        # since the epoch. cqlsh does the exact same thing for values below datetime.MINYEAR (1) or above
+        # datetime.MAXYEAR (9999). Some versions of strftime() also have problems for dates between MIN_YEAR and 1900.
+        # cqlsh COPY assumes milliseconds from the epoch if it fails to parse a datetime string, and so it is
+        # able to correctly import timestamps exported as milliseconds since the epoch.
+        return '%d' % (seconds * 1000.0)
 
 
 @formatter_for('Date')
