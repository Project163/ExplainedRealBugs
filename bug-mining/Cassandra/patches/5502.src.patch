diff --git a/src/java/org/apache/cassandra/net/InboundSockets.java b/src/java/org/apache/cassandra/net/InboundSockets.java
index 6fc5f52dcd..93caf85163 100644
--- a/src/java/org/apache/cassandra/net/InboundSockets.java
+++ b/src/java/org/apache/cassandra/net/InboundSockets.java
@@ -63,6 +63,9 @@ class InboundSockets
         // purely to prevent close racing with open
         private boolean closedWithoutOpening;
 
+        // used to prevent racing on close
+        private Future<Void> closeFuture;
+
         /**
          * A group of the open, inbound {@link Channel}s connected to this node. This is mostly interesting so that all of
          * the inbound connections/channels can be closed when the listening socket itself is being closed.
@@ -109,7 +112,9 @@ class InboundSockets
          * Close this socket and any connections created on it. Once closed, this socket may not be re-opened.
          *
          * This may not execute synchronously, so a Future is returned encapsulating its result.
-         * @param shutdownExecutors
+         * @param shutdownExecutors consumer invoked with the internal executor on completion
+         *                          Note that the consumer will only be invoked once per InboundSocket.
+         *                          Subsequent calls to close will not register a callback to different consumers.
          */
         private Future<Void> close(Consumer<? super ExecutorService> shutdownExecutors)
         {
@@ -136,6 +141,13 @@ class InboundSockets
                     return new SucceededFuture<>(GlobalEventExecutor.INSTANCE, null);
                 }
 
+                if (closeFuture != null)
+                {
+                    return closeFuture;
+                }
+
+                closeFuture = done;
+
                 if (listen != null)
                 {
                     close.run();
diff --git a/src/java/org/apache/cassandra/net/OutboundConnection.java b/src/java/org/apache/cassandra/net/OutboundConnection.java
index b0edc0369f..66f14dbb2b 100644
--- a/src/java/org/apache/cassandra/net/OutboundConnection.java
+++ b/src/java/org/apache/cassandra/net/OutboundConnection.java
@@ -110,7 +110,8 @@ public class OutboundConnection
 
     private final OutboundMessageCallbacks callbacks;
     private final OutboundDebugCallbacks debug;
-    private final OutboundMessageQueue queue;
+    @VisibleForTesting
+    final OutboundMessageQueue queue;
     /** the number of bytes we permit to queue to the network without acquiring any shared resource permits */
     private final long pendingCapacityInBytes;
     /** the number of messages and bytes queued for flush to the network,
diff --git a/src/java/org/apache/cassandra/net/OutboundMessageQueue.java b/src/java/org/apache/cassandra/net/OutboundMessageQueue.java
index 3d8bac0371..d7360a0dc7 100644
--- a/src/java/org/apache/cassandra/net/OutboundMessageQueue.java
+++ b/src/java/org/apache/cassandra/net/OutboundMessageQueue.java
@@ -87,6 +87,7 @@ class OutboundMessageQueue
     {
         maybePruneExpired();
         externalQueue.offer(m);
+        // Known race here. See CASSANDRAi-15958
         nextExpirationDeadlineUpdater.accumulateAndGet(this,
                                                        maybeUpdateEarliestExpiresAt(clock.now(), m.expiresAtNanos()),
                                                        Math::min);
diff --git a/test/unit/org/apache/cassandra/net/ConnectionTest.java b/test/unit/org/apache/cassandra/net/ConnectionTest.java
index eb8d867c26..5c637ace9f 100644
--- a/test/unit/org/apache/cassandra/net/ConnectionTest.java
+++ b/test/unit/org/apache/cassandra/net/ConnectionTest.java
@@ -685,9 +685,21 @@ public class ConnectionTest
                         Message<?> message = Message.builder(Verb._TEST_1, noPayload)
                                                     .withExpiresAt(System.nanoTime() + TimeUnit.MILLISECONDS.toNanos(50L))
                                                     .build();
-                        outbound.enqueue(message);
-                        Assert.assertFalse(outbound.isConnected());
-                        Assert.assertEquals(1, outbound.pendingCount());
+                        OutboundMessageQueue queue = outbound.queue;
+                        while (true)
+                        {
+                            try (OutboundMessageQueue.WithLock withLock = queue.lockOrCallback(System.nanoTime(), null))
+                            {
+                                if (withLock != null)
+                                {
+                                    outbound.enqueue(message);
+                                    Assert.assertFalse(outbound.isConnected());
+                                    Assert.assertEquals(1, outbound.pendingCount());
+                                    break;
+                                }
+                            }
+                        }
+
                         CompletableFuture.runAsync(() -> {
                             while (outbound.pendingCount() > 0 && !Thread.interrupted()) {}
                         }).get(10, SECONDS);
