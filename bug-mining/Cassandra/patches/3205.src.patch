diff --git a/CHANGES.txt b/CHANGES.txt
index fbcf460a90..cdfd2483cc 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,6 @@
 2.1.2
+ * Avoid IllegalArgumentException while sorting sstables in
+   IndexSummaryManager (CASSANDRA-8182)
  * Shutdown JVM on file descriptor exhaustion (CASSANDRA-7579)
  * Add 'die' policy for commit log and disk failure (CASSANDRA-7927)
  * Fix installing as service on Windows (CASSANDRA-8115)
diff --git a/src/java/org/apache/cassandra/io/sstable/IndexSummaryManager.java b/src/java/org/apache/cassandra/io/sstable/IndexSummaryManager.java
index e39d75d3b7..cc60b4d0c1 100644
--- a/src/java/org/apache/cassandra/io/sstable/IndexSummaryManager.java
+++ b/src/java/org/apache/cassandra/io/sstable/IndexSummaryManager.java
@@ -262,32 +262,22 @@ public class IndexSummaryManager implements IndexSummaryManagerMBean
         logger.debug("Beginning redistribution of index summaries for {} sstables with memory pool size {} MB; current spaced used is {} MB",
                      nonCompacting.size(), memoryPoolBytes / 1024L / 1024L, total / 1024.0 / 1024.0);
 
+        final Map<SSTableReader, Double> readRates = new HashMap<>(nonCompacting.size());
         double totalReadsPerSec = 0.0;
         for (SSTableReader sstable : nonCompacting)
         {
             if (sstable.readMeter != null)
             {
-                totalReadsPerSec += sstable.readMeter.fifteenMinuteRate();
+                Double readRate = sstable.readMeter.fifteenMinuteRate();
+                totalReadsPerSec += readRate;
+                readRates.put(sstable, readRate);
             }
         }
         logger.trace("Total reads/sec across all sstables in index summary resize process: {}", totalReadsPerSec);
 
         // copy and sort by read rates (ascending)
         List<SSTableReader> sstablesByHotness = new ArrayList<>(nonCompacting);
-        Collections.sort(sstablesByHotness, new Comparator<SSTableReader>()
-        {
-            public int compare(SSTableReader o1, SSTableReader o2)
-            {
-                if (o1.readMeter == null && o2.readMeter == null)
-                    return 0;
-                else if (o1.readMeter == null)
-                    return -1;
-                else if (o2.readMeter == null)
-                    return 1;
-                else
-                    return Double.compare(o1.readMeter.fifteenMinuteRate(), o2.readMeter.fifteenMinuteRate());
-            }
-        });
+        Collections.sort(sstablesByHotness, new ReadRateComparator(readRates));
 
         long remainingBytes = memoryPoolBytes;
         for (SSTableReader sstable : compacting)
@@ -485,4 +475,30 @@ public class IndexSummaryManager implements IndexSummaryManagerMBean
             this.newSamplingLevel = newSamplingLevel;
         }
     }
+
+    /** Utility class for sorting sstables by their read rates. */
+    private static class ReadRateComparator implements Comparator<SSTableReader>
+    {
+        private final Map<SSTableReader, Double> readRates;
+
+        public ReadRateComparator(Map<SSTableReader, Double> readRates)
+        {
+            this.readRates = readRates;
+        }
+
+        @Override
+        public int compare(SSTableReader o1, SSTableReader o2)
+        {
+            Double readRate1 = readRates.get(o1);
+            Double readRate2 = readRates.get(o2);
+            if (readRate1 == null && readRate2 == null)
+                return 0;
+            else if (readRate1 == null)
+                return -1;
+            else if (readRate2 == null)
+                return 1;
+            else
+                return Double.compare(readRate1, readRate2);
+        }
+    }
 }
\ No newline at end of file
