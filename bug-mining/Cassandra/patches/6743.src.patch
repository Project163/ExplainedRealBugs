diff --git a/test/unit/org/apache/cassandra/dht/IPartitionerTest.java b/test/unit/org/apache/cassandra/dht/IPartitionerTest.java
index d2196bdf5a..e531e25da5 100644
--- a/test/unit/org/apache/cassandra/dht/IPartitionerTest.java
+++ b/test/unit/org/apache/cassandra/dht/IPartitionerTest.java
@@ -34,7 +34,6 @@ import org.apache.cassandra.utils.CassandraGenerators;
 import org.apache.cassandra.utils.bytecomparable.ByteComparable;
 import org.apache.cassandra.utils.bytecomparable.ByteSource;
 import org.assertj.core.api.Assertions;
-import org.quicktheories.core.Gen;
 import org.reflections.Reflections;
 import org.reflections.scanners.Scanners;
 import org.reflections.util.ConfigurationBuilder;
@@ -94,9 +93,7 @@ public class IPartitionerTest
     @Test
     public void byteCompareSerde()
     {
-        // make sure to use simplify as local partitioner can have a type that could generate data too large causing this test to be flakey
-        Gen<Token> qt = CassandraGenerators.partitioners().flatMap(p -> CassandraGenerators.token(CassandraGenerators.simplify(p)));
-        qt().forAll(AccordGenerators.fromQT(qt)).check(token -> {
+        qt().forAll(AccordGenerators.fromQT(CassandraGenerators.token())).check(token -> {
             var p = token.getPartitioner();
             var comparable = Objects.requireNonNull(ByteSource.peekable(p.getTokenFactory().asComparableBytes(token, ByteComparable.Version.OSS50)));
             Token read = p.getTokenFactory().fromComparableBytes(comparable, ByteComparable.Version.OSS50);
diff --git a/test/unit/org/apache/cassandra/service/accord/AccordKeyspaceTest.java b/test/unit/org/apache/cassandra/service/accord/AccordKeyspaceTest.java
index 12dacb7762..ee40318180 100644
--- a/test/unit/org/apache/cassandra/service/accord/AccordKeyspaceTest.java
+++ b/test/unit/org/apache/cassandra/service/accord/AccordKeyspaceTest.java
@@ -127,7 +127,7 @@ public class AccordKeyspaceTest extends CQLTester.InMemory
     public void findOverlappingKeys()
     {
         var tableIdGen = fromQT(CassandraGenerators.TABLE_ID_GEN);
-        var partitionGen = fromQT(CassandraGenerators.partitioners()).map(CassandraGenerators::simplify);
+        var partitionGen = fromQT(CassandraGenerators.partitioners());
 
         var sstableFormats = DatabaseDescriptor.getSSTableFormats();
         List<String> sstableFormatNames = new ArrayList<>(sstableFormats.keySet());
@@ -138,7 +138,7 @@ public class AccordKeyspaceTest extends CQLTester.InMemory
                                                      .sorted()
                                                      .collect(Collectors.toList());
 
-        qt().withSeed(3447657054093411240L).check(rs -> {
+        qt().check(rs -> {
             AccordKeyspace.unsafeClear();
             // control SSTable format
             setSelectedSSTableFormat(sstableFormats.get(rs.pick(sstableFormatNames)));
diff --git a/test/unit/org/apache/cassandra/service/accord/serializers/AccordRoutingKeyByteSourceTest.java b/test/unit/org/apache/cassandra/service/accord/serializers/AccordRoutingKeyByteSourceTest.java
index 6a2c329679..9b4f727907 100644
--- a/test/unit/org/apache/cassandra/service/accord/serializers/AccordRoutingKeyByteSourceTest.java
+++ b/test/unit/org/apache/cassandra/service/accord/serializers/AccordRoutingKeyByteSourceTest.java
@@ -49,7 +49,7 @@ public class AccordRoutingKeyByteSourceTest
     @Test
     public void tokenSerde()
     {
-        qt().forAll(fromQT(CassandraGenerators.partitioners().map(CassandraGenerators::simplify).flatMap(CassandraGenerators::token))).check(token -> {
+        qt().forAll(fromQT(CassandraGenerators.token())).check(token -> {
             var serializer = AccordRoutingKeyByteSource.create(token.getPartitioner());
             byte[] minMin = ByteSourceInverse.readBytes(serializer.minMinAsComparableBytes());
             byte[] minMax = ByteSourceInverse.readBytes(serializer.minMaxAsComparableBytes());
diff --git a/test/unit/org/apache/cassandra/service/accord/serializers/DepsSerializersTest.java b/test/unit/org/apache/cassandra/service/accord/serializers/DepsSerializersTest.java
index a983c125c7..58c3f6f948 100644
--- a/test/unit/org/apache/cassandra/service/accord/serializers/DepsSerializersTest.java
+++ b/test/unit/org/apache/cassandra/service/accord/serializers/DepsSerializersTest.java
@@ -32,7 +32,6 @@ import org.apache.cassandra.net.MessagingService;
 import org.apache.cassandra.schema.Schema;
 import org.apache.cassandra.schema.SchemaProvider;
 import org.apache.cassandra.utils.AccordGenerators;
-import org.apache.cassandra.utils.CassandraGenerators;
 import org.mockito.Mockito;
 
 import static accord.utils.Property.qt;
@@ -53,7 +52,7 @@ public class DepsSerializersTest
     {
         DataOutputBuffer buffer = new DataOutputBuffer();
         qt().check(rs -> {
-            IPartitioner partitioner = AccordGenerators.partitioner().map(CassandraGenerators::simplify).next(rs);
+            IPartitioner partitioner = AccordGenerators.partitioner().next(rs);
             Schema.instance = Mockito.mock(SchemaProvider.class);
             DatabaseDescriptor.setPartitionerUnsafe(partitioner);
             Mockito.when(Schema.instance.getExistingTablePartitioner(Mockito.any())).thenReturn(partitioner);
diff --git a/test/unit/org/apache/cassandra/utils/AbstractTypeGenerators.java b/test/unit/org/apache/cassandra/utils/AbstractTypeGenerators.java
index ea9a128233..d44d32d043 100644
--- a/test/unit/org/apache/cassandra/utils/AbstractTypeGenerators.java
+++ b/test/unit/org/apache/cassandra/utils/AbstractTypeGenerators.java
@@ -574,10 +574,11 @@ public final class AbstractTypeGenerators
                                                         .withoutTypeKinds(COUNTER)
                                                         .withoutPrimitive(DecimalType.instance)
                                                         // its ordering is special...
-                                                        .withoutPrimitive(DurationType.instance);
-        // composite requires all elements fit into Short.MAX_VALUE bytes
-        // so try to limit the possible expansion of types
-        return baseline.withCompositeElementGen(new TypeGenBuilder(baseline).withDefaultSizeGen(1).withMaxDepth(1).build())
+                                                        .withoutPrimitive(DurationType.instance)
+                                                        // To make sure all elements fit within Short.MAX_VALUE bytes,
+                                                        // need to limit the possible expansion of types
+                                                        .withDefaultSizeGen(1).withMaxDepth(1);
+        return baseline.withCompositeElementGen(new TypeGenBuilder(baseline).build())
                        .build();
     }
 
diff --git a/test/unit/org/apache/cassandra/utils/CassandraGenerators.java b/test/unit/org/apache/cassandra/utils/CassandraGenerators.java
index 469a486807..2d64efb465 100644
--- a/test/unit/org/apache/cassandra/utils/CassandraGenerators.java
+++ b/test/unit/org/apache/cassandra/utils/CassandraGenerators.java
@@ -84,7 +84,6 @@ import org.apache.cassandra.db.marshal.ByteBufferAccessor;
 import org.apache.cassandra.db.marshal.CompositeType;
 import org.apache.cassandra.db.marshal.CounterColumnType;
 import org.apache.cassandra.db.marshal.EmptyType;
-import org.apache.cassandra.db.marshal.Int32Type;
 import org.apache.cassandra.db.rows.Cell;
 import org.apache.cassandra.db.marshal.UserType;
 import org.apache.cassandra.dht.ByteOrderedPartitioner;
@@ -1494,24 +1493,6 @@ public final class CassandraGenerators
                         .flatMap(SupportedPartitioners::partitioner);
     }
 
-    /**
-     * For {@link LocalPartitioner} it can have a very complex type which can lead to generating data larger than
-     * allowed in a primary key.  If a test needs to filter out those cases, can just
-     * {@code .map(CassandraGenerators::simplify)} to resolve.
-     */
-    public static IPartitioner simplify(IPartitioner partitioner)
-    {
-        // serializers require tokens to fit within 1 << 16, but that makes the test flakey when LocalPartitioner with a nested type is found...
-        if (!(partitioner instanceof LocalPartitioner)) return partitioner;
-        if (!shouldSimplify(partitioner.getTokenValidator())) return partitioner;
-        return new LocalPartitioner(Int32Type.instance);
-    }
-
-    private static boolean shouldSimplify(AbstractType<?> type)
-    {
-        return AbstractTypeGenerators.contains(type, t -> t.isCollection());
-    }
-
     public static Gen<Token> token()
     {
         return partitioners().flatMap(CassandraGenerators::token);
diff --git a/test/unit/org/apache/cassandra/utils/CassandraGeneratorsTest.java b/test/unit/org/apache/cassandra/utils/CassandraGeneratorsTest.java
index 5b024feb25..77043d6338 100644
--- a/test/unit/org/apache/cassandra/utils/CassandraGeneratorsTest.java
+++ b/test/unit/org/apache/cassandra/utils/CassandraGeneratorsTest.java
@@ -47,14 +47,14 @@ public class CassandraGeneratorsTest
     @Test
     public void partitionerToToken()
     {
-        qt().forAll(Gens.random(), toGen(CassandraGenerators.partitioners().map(CassandraGenerators::simplify)))
+        qt().forAll(Gens.random(), toGen(CassandraGenerators.partitioners()))
             .check((rs, p) -> Assertions.assertThat(toGen(CassandraGenerators.token(p)).next(rs)).isNotNull());
     }
 
     @Test
     public void partitionerKeys()
     {
-        qt().forAll(Gens.random(), toGen(CassandraGenerators.partitioners().map(CassandraGenerators::simplify)))
+        qt().forAll(Gens.random(), toGen(CassandraGenerators.partitioners()))
             .check((rs, p) -> Assertions.assertThat(toGen(CassandraGenerators.decoratedKeys(i -> p)).next(rs)).isNotNull());
     }
 
