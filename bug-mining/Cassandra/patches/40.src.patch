diff --git a/src/java/org/apache/cassandra/db/ColumnFamilyStore.java b/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
index 986c803b0e..044ea3d5a6 100644
--- a/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
+++ b/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
@@ -1526,11 +1526,17 @@ public class ColumnFamilyStore implements ColumnFamilyStoreMBean
         return memtable_.get();
     }
 
+    /** not threadsafe.  caller must have lock_ acquired. */
     public Set<String> getSSTableFilenames()
     {
         return Collections.unmodifiableSet(ssTables_);
     }
 
+    public ReentrantReadWriteLock.ReadLock getReadLock()
+    {
+        return lock_.readLock();
+    }
+
     public int getReadCount()
     {
         return readStats_.size();
diff --git a/src/java/org/apache/cassandra/db/Table.java b/src/java/org/apache/cassandra/db/Table.java
index b470fd2ed1..82a456d876 100644
--- a/src/java/org/apache/cassandra/db/Table.java
+++ b/src/java/org/apache/cassandra/db/Table.java
@@ -395,7 +395,7 @@ public class Table
     /* The AnalyticsSource instance which keeps track of statistics reported to Ganglia. */
     private DBAnalyticsSource dbAnalyticsSource_;
     // cache application CFs since Range queries ask for them a _lot_
-    private Set<String> applicationColumnFamilies_;
+    private SortedSet<String> applicationColumnFamilies_;
 
     public static Table open(String table)
     {
@@ -849,11 +849,11 @@ public class Table
         dbAnalyticsSource_.updateWriteStatistics(timeTaken);
     }
 
-    public Set<String> getApplicationColumnFamilies()
+    public SortedSet<String> getApplicationColumnFamilies()
     {
         if (applicationColumnFamilies_ == null)
         {
-            applicationColumnFamilies_ = new HashSet<String>();
+            applicationColumnFamilies_ = new TreeSet<String>();
             for (String cfName : getColumnFamilies())
             {
                 if (DatabaseDescriptor.isApplicationColumnFamily(cfName))
@@ -872,6 +872,26 @@ public class Table
      * @return list of keys between startWith and stopAt
      */
     public List<String> getKeyRange(final String startWith, final String stopAt, int maxResults) throws IOException, ExecutionException, InterruptedException
+    {
+        // TODO we need a better way to keep compactions from stomping on reads than One Big Lock per CF.
+        for (String cfName : getApplicationColumnFamilies())
+        {
+            getColumnFamilyStore(cfName).getReadLock().lock();
+        }
+        try
+        {
+            return getKeyRangeUnsafe(startWith, stopAt, maxResults);
+        }
+        finally
+        {
+            for (String cfName : getApplicationColumnFamilies())
+            {
+                getColumnFamilyStore(cfName).getReadLock().unlock();
+            }
+        }
+    }
+
+    private List<String> getKeyRangeUnsafe(final String startWith, final String stopAt, int maxResults) throws IOException, ExecutionException, InterruptedException
     {
         // (OPP key decoration is a no-op so using the "decorated" comparator against raw keys is fine)
         final Comparator<String> comparator = StorageService.getPartitioner().getDecoratedKeyComparator();
diff --git a/test/unit/org/apache/cassandra/db/OneCompactionTest.java b/test/unit/org/apache/cassandra/db/OneCompactionTest.java
index 297b8a531d..418386bd03 100644
--- a/test/unit/org/apache/cassandra/db/OneCompactionTest.java
+++ b/test/unit/org/apache/cassandra/db/OneCompactionTest.java
@@ -11,17 +11,16 @@ import static junit.framework.Assert.assertEquals;
 
 public class OneCompactionTest
 {
-    @Test
-    public void testOneCompaction() throws IOException, ExecutionException, InterruptedException
+    private void testCompaction(String columnFamilyName, int insertsPerTable) throws IOException, ExecutionException, InterruptedException
     {
         Table table = Table.open("Table1");
-        ColumnFamilyStore store = table.getColumnFamilyStore("Standard1");
+        ColumnFamilyStore store = table.getColumnFamilyStore(columnFamilyName);
 
         Set<String> inserted = new HashSet<String>();
-        for (int j = 0; j < 2; j++) {
+        for (int j = 0; j < insertsPerTable; j++) {
             String key = "0";
             RowMutation rm = new RowMutation("Table1", key);
-            rm.add("Standard1:0", new byte[0], j);
+            rm.add(columnFamilyName + ":0", new byte[0], j);
             rm.apply();
             inserted.add(key);
             store.forceBlockingFlush();
@@ -30,4 +29,16 @@ public class OneCompactionTest
         store.doCompaction(2);
         assertEquals(table.getKeyRange("", "", 10000).size(), inserted.size());
     }
+
+    @Test
+    public void testCompaction1() throws IOException, ExecutionException, InterruptedException
+    {
+        testCompaction("Standard1", 1);
+    }
+
+    @Test
+    public void testCompaction2() throws IOException, ExecutionException, InterruptedException
+    {
+        testCompaction("Standard2", 500);
+    }
 }
