diff --git a/CHANGES.txt b/CHANGES.txt
index 47d85fb160..a2af83b7cc 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 4.0.14
+ * Improve accuracy of memtable heap usage tracking (CASSANDRA-17298)
  * Fix rendering UNSET collection types in query tracing (CASSANDRA-19880)
  * Fix latency reported by ideal consistency level monitoring (CASSANDRA-19651)
  * Use default commitlog settings in test YAMLs (CASSANDRA-19830)
diff --git a/src/java/org/apache/cassandra/db/Columns.java b/src/java/org/apache/cassandra/db/Columns.java
index 88185abf7b..8adce341c9 100644
--- a/src/java/org/apache/cassandra/db/Columns.java
+++ b/src/java/org/apache/cassandra/db/Columns.java
@@ -436,7 +436,7 @@ public class Columns extends AbstractCollection<ColumnMetadata> implements Colle
         if(this == NONE)
             return 0;
 
-        return EMPTY_SIZE;
+        return EMPTY_SIZE + BTree.sizeOfStructureOnHeap(columns);
     }
 
     @Override
diff --git a/src/java/org/apache/cassandra/db/Memtable.java b/src/java/org/apache/cassandra/db/Memtable.java
index b74ac5f63c..510826253d 100644
--- a/src/java/org/apache/cassandra/db/Memtable.java
+++ b/src/java/org/apache/cassandra/db/Memtable.java
@@ -17,6 +17,7 @@
  */
 package org.apache.cassandra.db;
 
+import java.nio.ByteBuffer;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
@@ -55,7 +56,6 @@ import org.apache.cassandra.db.rows.UnfilteredRowIterator;
 import org.apache.cassandra.dht.AbstractBounds;
 import org.apache.cassandra.dht.Bounds;
 import org.apache.cassandra.dht.IncludingExcludingBounds;
-import org.apache.cassandra.dht.Murmur3Partitioner.LongToken;
 import org.apache.cassandra.dht.Range;
 import org.apache.cassandra.index.transactions.UpdateTransaction;
 import org.apache.cassandra.io.sstable.Descriptor;
@@ -65,7 +65,6 @@ import org.apache.cassandra.schema.ColumnMetadata;
 import org.apache.cassandra.schema.SchemaConstants;
 import org.apache.cassandra.schema.TableMetadata;
 import org.apache.cassandra.service.ActiveRepairService;
-import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.cassandra.utils.FBUtilities;
 import org.apache.cassandra.utils.ObjectSizes;
 import org.apache.cassandra.utils.concurrent.OpOrder;
@@ -74,8 +73,10 @@ import org.apache.cassandra.utils.memory.HeapPool;
 import org.apache.cassandra.utils.memory.MemtableAllocator;
 import org.apache.cassandra.utils.memory.MemtableCleaner;
 import org.apache.cassandra.utils.memory.MemtablePool;
+import org.apache.cassandra.utils.memory.NativeAllocator;
 import org.apache.cassandra.utils.memory.NativePool;
 import org.apache.cassandra.utils.memory.SlabPool;
+import org.github.jamm.Unmetered;
 
 public class Memtable implements Comparable<Memtable>
 {
@@ -116,6 +117,7 @@ public class Memtable implements Comparable<Memtable>
 
     private static final int ROW_OVERHEAD_HEAP_SIZE = estimateRowOverhead(Integer.parseInt(System.getProperty("cassandra.memtable_row_overhead_computation_step", "100000")));
 
+    @Unmetered
     private final MemtableAllocator allocator;
     private final AtomicLong liveDataSize = new AtomicLong(0);
     private final AtomicLong currentOperations = new AtomicLong(0);
@@ -148,6 +150,7 @@ public class Memtable implements Comparable<Memtable>
     // to select key range using Token.KeyBound. However put() ensures that we
     // actually only store DecoratedKey.
     private final ConcurrentNavigableMap<PartitionPosition, AtomicBTreePartition> partitions = new ConcurrentSkipListMap<>();
+    @Unmetered
     public final ColumnFamilyStore cfs;
     private final long creationNano = System.nanoTime();
 
@@ -571,15 +574,32 @@ public class Memtable implements Comparable<Memtable>
             Cloner cloner = allocator.cloner(group);
             ConcurrentNavigableMap<PartitionPosition, Object> partitions = new ConcurrentSkipListMap<>();
             final Object val = new Object();
+            final int testBufferSize = 8;
+
             for (int i = 0 ; i < count ; i++)
-                partitions.put(cloner.clone(new BufferDecoratedKey(new LongToken(i), ByteBufferUtil.EMPTY_BYTE_BUFFER)), val);
+                partitions.put(cloner.clone(new BufferDecoratedKey(DatabaseDescriptor.getPartitioner().getRandomToken(), ByteBuffer.allocate(testBufferSize))), val);
             double avgSize = ObjectSizes.measureDeep(partitions) / (double) count;
             rowOverhead = (int) ((avgSize - Math.floor(avgSize)) < 0.05 ? Math.floor(avgSize) : Math.ceil(avgSize));
-            rowOverhead -= ObjectSizes.measureDeep(new LongToken(0));
+            rowOverhead -= DatabaseDescriptor.getPartitioner().getRandomToken().getHeapSize();
             rowOverhead += AtomicBTreePartition.EMPTY_SIZE;
             rowOverhead += AbstractBTreePartition.HOLDER_UNSHARED_HEAP_SIZE;
+            // omitSharedBufferOverhead includes the given number of bytes even for
+            // off-heap buffers, but not for direct memory.
+            if (!(allocator instanceof NativeAllocator))
+            {
+                rowOverhead -= testBufferSize;
+                DecoratedKey clonedKey = cloner.clone(new BufferDecoratedKey(DatabaseDescriptor.getPartitioner().getRandomToken(), ByteBuffer.allocate(testBufferSize)));
+                // if we use a slab allocator the adjustment is 0, if it is unslabbed type the adjustment is byte array heap size
+                long nonSlabAdjustment = ObjectSizes.sizeOnHeapExcludingData(clonedKey.getKey()) - ObjectSizes.measure(clonedKey.getKey());
+                rowOverhead += nonSlabAdjustment;
+            }
+
+
             allocator.setDiscarding();
             allocator.setDiscarded();
+
+            // Decorated key overhead with byte buffer (if needed) is included
+            logger.info("Estimated Memtable row overhead: {}", rowOverhead);
             return rowOverhead;
         }
     }
diff --git a/src/java/org/apache/cassandra/db/partitions/AtomicBTreePartition.java b/src/java/org/apache/cassandra/db/partitions/AtomicBTreePartition.java
index 7b275d0fca..d8684e4e01 100644
--- a/src/java/org/apache/cassandra/db/partitions/AtomicBTreePartition.java
+++ b/src/java/org/apache/cassandra/db/partitions/AtomicBTreePartition.java
@@ -39,6 +39,7 @@ import org.apache.cassandra.utils.concurrent.OpOrder;
 import org.apache.cassandra.utils.memory.Cloner;
 import org.apache.cassandra.utils.memory.HeapCloner;
 import org.apache.cassandra.utils.memory.MemtableAllocator;
+import org.github.jamm.Unmetered;
 
 import com.google.common.annotations.VisibleForTesting;
 
@@ -82,6 +83,7 @@ public final class AtomicBTreePartition extends AbstractBTreePartition
      */
     private volatile int wasteTracker = TRACKER_NEVER_WASTED;
 
+    @Unmetered
     private final MemtableAllocator allocator;
     private volatile Holder ref;
 
diff --git a/src/java/org/apache/cassandra/utils/btree/BTree.java b/src/java/org/apache/cassandra/utils/btree/BTree.java
index 97f5cc0fb5..3a36912786 100644
--- a/src/java/org/apache/cassandra/utils/btree/BTree.java
+++ b/src/java/org/apache/cassandra/utils/btree/BTree.java
@@ -949,6 +949,9 @@ public class BTree
 
     public static long sizeOfStructureOnHeap(Object[] tree)
     {
+        if (tree == EMPTY_LEAF)
+            return 0;
+
         long size = ObjectSizes.sizeOfArray(tree);
         if (isLeaf(tree))
             return size;
diff --git a/test/unit/org/apache/cassandra/cql3/MemtableSizeTest.java b/test/unit/org/apache/cassandra/cql3/MemtableSizeTest.java
deleted file mode 100644
index 7d6c6dd304..0000000000
--- a/test/unit/org/apache/cassandra/cql3/MemtableSizeTest.java
+++ /dev/null
@@ -1,137 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.cassandra.cql3;
-
-import com.google.common.base.Throwables;
-import org.junit.Assert;
-import org.junit.BeforeClass;
-import org.junit.Test;
-
-import org.apache.cassandra.Util;
-import org.apache.cassandra.config.DatabaseDescriptor;
-import org.apache.cassandra.db.ColumnFamilyStore;
-import org.apache.cassandra.db.Keyspace;
-import org.apache.cassandra.db.Memtable;
-import org.apache.cassandra.utils.FBUtilities;
-import org.apache.cassandra.utils.ObjectSizes;
-
-public class MemtableSizeTest extends CQLTester
-{
-    static String keyspace;
-    String table;
-    ColumnFamilyStore cfs;
-
-    int partitions = 50_000;
-    int rowsPerPartition = 4;
-
-    int deletedPartitions = 10_000;
-    int deletedRows = 5_000;
-
-    // must be within 50 bytes per partition of the actual size
-    final int MAX_DIFFERENCE = (partitions + deletedPartitions + deletedRows) * 50;
-
-    @BeforeClass
-    public static void setUp()
-    {
-        CQLTester.setUpClass();
-        CQLTester.prepareServer();
-        CQLTester.disablePreparedReuseForTest();
-        System.err.println("setupClass done.");
-    }
-
-    @Test
-    public void testTruncationReleasesLogSpace()
-    {
-        Util.flakyTest(this::testSize, 2, "Fails occasionally, see CASSANDRA-16684");
-    }
-
-    private void testSize()
-    {
-        try
-        {
-            keyspace = createKeyspace("CREATE KEYSPACE %s with replication = { 'class' : 'SimpleStrategy', 'replication_factor' : 1 } and durable_writes = false");
-            table = createTable(keyspace, "CREATE TABLE %s ( userid bigint, picid bigint, commentid bigint, PRIMARY KEY(userid, picid)) with compression = {'enabled': false}");
-            execute("use " + keyspace + ';');
-
-            String writeStatement = "INSERT INTO " + table + "(userid,picid,commentid)VALUES(?,?,?)";
-
-            cfs = Keyspace.open(keyspace).getColumnFamilyStore(table);
-            cfs.disableAutoCompaction();
-            cfs.forceBlockingFlush();
-
-            long deepSizeBefore = ObjectSizes.measureDeep(cfs.getTracker().getView().getCurrentMemtable());
-            System.out.printf("Memtable deep size before %s\n%n",
-                              FBUtilities.prettyPrintMemory(deepSizeBefore));
-            long i;
-            long limit = partitions;
-            System.out.println("Writing " + partitions + " partitions of " + rowsPerPartition + " rows");
-            for (i = 0; i < limit; ++i)
-            {
-                for (long j = 0; j < rowsPerPartition; ++j)
-                    execute(writeStatement, i, j, i + j);
-            }
-
-            System.out.println("Deleting " + deletedPartitions + " partitions");
-            limit += deletedPartitions;
-            for (; i < limit; ++i)
-            {
-                // no partition exists, but we will create a tombstone
-                execute("DELETE FROM " + table + " WHERE userid = ?", i);
-            }
-
-            System.out.println("Deleting " + deletedRows + " rows");
-            limit += deletedRows;
-            for (; i < limit; ++i)
-            {
-                // no row exists, but we will create a tombstone (and partition)
-                execute("DELETE FROM " + table + " WHERE userid = ? AND picid = ?", i, 0L);
-            }
-
-
-            if (!cfs.getLiveSSTables().isEmpty())
-                System.out.println("Warning: " + cfs.getLiveSSTables().size() + " sstables created.");
-
-            Memtable memtable = cfs.getTracker().getView().getCurrentMemtable();
-            long actualHeap = memtable.getAllocator().onHeap().owns();
-            System.out.printf("Memtable in %s mode: %d ops, %s serialized bytes, %s (%.0f%%) on heap, %s (%.0f%%) off-heap%n",
-                              DatabaseDescriptor.getMemtableAllocationType(),
-                              memtable.getOperations(),
-                              FBUtilities.prettyPrintMemory(memtable.getLiveDataSize()),
-                              FBUtilities.prettyPrintMemory(actualHeap),
-                              100 * memtable.getAllocator().onHeap().ownershipRatio(),
-                              FBUtilities.prettyPrintMemory(memtable.getAllocator().offHeap().owns()),
-                              100 * memtable.getAllocator().offHeap().ownershipRatio());
-
-            long deepSizeAfter = ObjectSizes.measureDeep(memtable);
-            System.out.printf("Memtable deep size %s\n%n",
-                              FBUtilities.prettyPrintMemory(deepSizeAfter));
-
-            long expectedHeap = deepSizeAfter - deepSizeBefore;
-            String message = String.format("Expected heap usage close to %s, got %s.\n",
-                                           FBUtilities.prettyPrintMemory(expectedHeap),
-                                           FBUtilities.prettyPrintMemory(actualHeap));
-            System.out.println(message);
-            Assert.assertTrue(message, Math.abs(actualHeap - expectedHeap) <= MAX_DIFFERENCE);
-        }
-        catch (Throwable throwable)
-        {
-            Throwables.propagate(throwable);
-        }
-    }
-}
\ No newline at end of file
diff --git a/test/unit/org/apache/cassandra/db/memtable/MemtableSizeHeapBuffersTest.java b/test/unit/org/apache/cassandra/db/memtable/MemtableSizeHeapBuffersTest.java
new file mode 100644
index 0000000000..e58b9611df
--- /dev/null
+++ b/test/unit/org/apache/cassandra/db/memtable/MemtableSizeHeapBuffersTest.java
@@ -0,0 +1,47 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.cassandra.db.memtable;
+
+import org.junit.Assert;
+import org.junit.BeforeClass;
+
+import org.apache.cassandra.config.Config;
+import org.apache.cassandra.db.Memtable;
+import org.apache.cassandra.dht.Murmur3Partitioner;
+import org.apache.cassandra.utils.memory.MemtablePool;
+import org.apache.cassandra.utils.memory.SlabPool;
+
+public class MemtableSizeHeapBuffersTest extends MemtableSizeTestBase
+{
+    // Overrides CQLTester.setUpClass to run before it
+    @BeforeClass
+    public static void setUpClass()
+    {
+        setup(Config.MemtableAllocationType.heap_buffers, Murmur3Partitioner.instance);
+    }
+
+    @Override
+    void checkMemtablePool()
+    {
+        MemtablePool memoryPool = Memtable.MEMORY_POOL;
+        logger.info("Memtable pool {} off-heap limit {}", memoryPool, memoryPool.offHeap.limit);
+        Assert.assertTrue(memoryPool instanceof SlabPool);
+        Assert.assertEquals(0, memoryPool.offHeap.limit);
+    }
+}
diff --git a/test/unit/org/apache/cassandra/db/memtable/MemtableSizeOffheapBuffersTest.java b/test/unit/org/apache/cassandra/db/memtable/MemtableSizeOffheapBuffersTest.java
new file mode 100644
index 0000000000..c05d3cdd09
--- /dev/null
+++ b/test/unit/org/apache/cassandra/db/memtable/MemtableSizeOffheapBuffersTest.java
@@ -0,0 +1,47 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.cassandra.db.memtable;
+
+import org.junit.Assert;
+import org.junit.BeforeClass;
+
+import org.apache.cassandra.config.Config;
+import org.apache.cassandra.db.Memtable;
+import org.apache.cassandra.dht.Murmur3Partitioner;
+import org.apache.cassandra.utils.memory.MemtablePool;
+import org.apache.cassandra.utils.memory.SlabPool;
+
+public class MemtableSizeOffheapBuffersTest extends MemtableSizeTestBase
+{
+    // Overrides CQLTester.setUpClass to run before it
+    @BeforeClass
+    public static void setUpClass()
+    {
+        setup(Config.MemtableAllocationType.offheap_buffers, Murmur3Partitioner.instance);
+    }
+
+    @Override
+    void checkMemtablePool()
+    {
+        MemtablePool memoryPool = Memtable.MEMORY_POOL;
+        logger.info("Memtable pool {} off-heap limit {}", memoryPool, memoryPool.offHeap.limit);
+        Assert.assertTrue(memoryPool instanceof SlabPool);
+        Assert.assertTrue(memoryPool.offHeap.limit > 0);
+    }
+}
diff --git a/test/unit/org/apache/cassandra/db/memtable/MemtableSizeOffheapObjectsTest.java b/test/unit/org/apache/cassandra/db/memtable/MemtableSizeOffheapObjectsTest.java
new file mode 100644
index 0000000000..c704acb01a
--- /dev/null
+++ b/test/unit/org/apache/cassandra/db/memtable/MemtableSizeOffheapObjectsTest.java
@@ -0,0 +1,46 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.cassandra.db.memtable;
+
+import org.junit.Assert;
+import org.junit.BeforeClass;
+
+import org.apache.cassandra.config.Config;
+import org.apache.cassandra.db.Memtable;
+import org.apache.cassandra.dht.Murmur3Partitioner;
+import org.apache.cassandra.utils.memory.MemtablePool;
+import org.apache.cassandra.utils.memory.NativePool;
+
+public class MemtableSizeOffheapObjectsTest extends MemtableSizeTestBase
+{
+    // Overrides CQLTester.setUpClass to run before it
+    @BeforeClass
+    public static void setUpClass()
+    {
+        setup(Config.MemtableAllocationType.offheap_objects, Murmur3Partitioner.instance);
+    }
+
+    @Override
+    void checkMemtablePool()
+    {
+        MemtablePool memoryPool = Memtable.MEMORY_POOL;
+        logger.info("Memtable pool {} off-heap limit {}", memoryPool, memoryPool.offHeap.limit);
+        Assert.assertTrue(memoryPool instanceof NativePool);
+    }
+}
diff --git a/test/unit/org/apache/cassandra/db/memtable/MemtableSizeTestBase.java b/test/unit/org/apache/cassandra/db/memtable/MemtableSizeTestBase.java
new file mode 100644
index 0000000000..2d8aa5f7dd
--- /dev/null
+++ b/test/unit/org/apache/cassandra/db/memtable/MemtableSizeTestBase.java
@@ -0,0 +1,198 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.cassandra.db.memtable;
+
+import java.lang.reflect.Field;
+
+import org.junit.Assert;
+import org.junit.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import org.apache.cassandra.ServerTestUtils;
+import org.apache.cassandra.config.Config;
+import org.apache.cassandra.config.DatabaseDescriptor;
+import org.apache.cassandra.cql3.CQLTester;
+import org.apache.cassandra.db.ColumnFamilyStore;
+import org.apache.cassandra.db.Keyspace;
+import org.apache.cassandra.db.Memtable;
+import org.apache.cassandra.dht.IPartitioner;
+import org.apache.cassandra.service.StorageService;
+import org.apache.cassandra.utils.FBUtilities;
+import org.github.jamm.MemoryMeter;
+
+public abstract class MemtableSizeTestBase extends CQLTester
+{
+    static final Logger logger = LoggerFactory.getLogger(MemtableSizeTestBase.class);
+
+    static final int partitions = 50_000;
+    static final int rowsPerPartition = 4;
+
+    static final int deletedPartitions = 10_000;
+    static final int deletedRows = 5_000;
+
+    static final int totalPartitions = partitions + deletedPartitions + deletedRows;
+
+    // Must be within 3% of the real usage. We are actually more precise than this, but the threshold is set higher to
+    // avoid flakes. For on-heap allocators we allow for extra overheads below.
+    final int MAX_DIFFERENCE_PERCENT = 3;
+
+    public static void setup(Config.MemtableAllocationType allocationType, IPartitioner partitioner)
+    {
+        ServerTestUtils.daemonInitialization();
+        try
+        {
+            Field confField = DatabaseDescriptor.class.getDeclaredField("conf");
+            confField.setAccessible(true);
+            Config conf = (Config) confField.get(null);
+            conf.memtable_allocation_type = allocationType;
+            conf.memtable_cleanup_threshold = 0.8f; // give us more space to fit test data without flushing
+        }
+        catch (NoSuchFieldException | IllegalAccessException e)
+        {
+            throw new RuntimeException(e);
+        }
+
+        StorageService.instance.setPartitionerUnsafe(partitioner);
+        CQLTester.prepareServer();
+        logger.info("setupClass done, allocation type {}", allocationType);
+    }
+
+    void checkMemtablePool()
+    {
+        // overridden by instances
+    }
+
+    @Test
+    public void testSize() throws Throwable
+    {
+        // Note: To see a printout of the usage for each object, add .enableDebug() here (most useful with smaller number of
+        // partitions)
+        MemoryMeter meter = new MemoryMeter().withGuessing(MemoryMeter.Guess.FALLBACK_UNSAFE)
+//                                           .enableDebug(100)
+                                             .ignoreKnownSingletons();
+        if (DatabaseDescriptor.getMemtableAllocationType() == Config.MemtableAllocationType.heap_buffers ||
+            DatabaseDescriptor.getMemtableAllocationType() == Config.MemtableAllocationType.offheap_buffers)
+        {
+            // jamm includes capacity for all ByteBuffer sub-clases (HeapByteBuffer and DirectByteBuffer) to deepMeasure result
+            // we need it only when we use HeapByteBuffer because we want to measure heap usage only
+            // we have to use it for DirectByteBuffer too to avoid MemoryMeter traversing through Cleaner references
+            meter = meter.omitSharedBufferOverhead();
+        }
+
+        // Make sure memtables use the correct allocation type, i.e. that setup has worked.
+        // If this fails, make sure the test is not reusing an already-initialized JVM.
+        checkMemtablePool();
+
+        // a prepared statement provides the same RegularAndStaticColumns object to store under AbstractBTreePartition$Holder
+        // meter.mesureDeep counts such shared object only once but the current tracking logic within memtable cannot do it
+        // so to not face the discrepancy we disable prepared statements
+        CQLTester.disablePreparedReuseForTest();
+
+        String keyspace = createKeyspace("CREATE KEYSPACE %s with replication = { 'class' : 'SimpleStrategy', 'replication_factor' : 1 } and durable_writes = false");
+        try
+        {
+            String table = createTable(keyspace, "CREATE TABLE %s ( userid bigint, picid bigint, commentid bigint, PRIMARY KEY(userid, picid))" +
+                                                 " with compression = {'enabled': false}");
+            execute("use " + keyspace + ';');
+
+            String writeStatement = "INSERT INTO " + table + "(userid,picid,commentid)VALUES(?,?,?)";
+            forcePreparedValues();
+
+            ColumnFamilyStore cfs = Keyspace.open(keyspace).getColumnFamilyStore(table);
+            cfs.disableAutoCompaction();
+            cfs.forceBlockingFlush();
+
+            Memtable memtable = cfs.getTracker().getView().getCurrentMemtable();
+            long deepSizeBefore = meter.measureDeep(memtable);
+            logger.info("Memtable deep size before {}", FBUtilities.prettyPrintMemory(deepSizeBefore));
+            long i;
+            long limit = partitions;
+            logger.info("Writing {} partitions of {} rows", partitions, rowsPerPartition);
+            for (i = 0; i < limit; ++i)
+            {
+                for (long j = 0; j < rowsPerPartition; ++j)
+                    execute(writeStatement, i, j, i + j);
+            }
+
+            logger.info("Deleting {} partitions", deletedPartitions);
+            limit += deletedPartitions;
+            for (; i < limit; ++i)
+            {
+                // no partition exists, but we will create a tombstone
+                execute("DELETE FROM " + table + " WHERE userid = ?", i);
+            }
+
+            logger.info("Deleting {} rows", deletedRows);
+            limit += deletedRows;
+            for (; i < limit; ++i)
+            {
+                // no row exists, but we will create a tombstone (and partition)
+                execute("DELETE FROM " + table + " WHERE userid = ? AND picid = ?", i, 0L);
+            }
+
+            Assert.assertSame("Memtable flushed during test. Test was not carried out correctly.",
+                              memtable,
+                              cfs.getTracker().getView().getCurrentMemtable());
+
+            long actualHeap = memtable.getAllocator().onHeap().owns();
+            logger.info(String.format("Memtable in %s mode: %d ops, %s serialized bytes, %s (%.0f%%) on heap, %s (%.0f%%) off-heap",
+                                      DatabaseDescriptor.getMemtableAllocationType(),
+                                      memtable.getOperations(),
+                                      FBUtilities.prettyPrintMemory(memtable.getLiveDataSize()),
+                                      FBUtilities.prettyPrintMemory(actualHeap),
+                                      100 * memtable.getAllocator().onHeap().ownershipRatio(),
+                                      FBUtilities.prettyPrintMemory(memtable.getAllocator().offHeap().owns()),
+                                      100 * memtable.getAllocator().offHeap().ownershipRatio()));
+
+            long deepSizeAfter = meter.measureDeep(memtable);
+            logger.info("Memtable deep size {}", FBUtilities.prettyPrintMemory(deepSizeAfter));
+
+            long expectedHeap = deepSizeAfter - deepSizeBefore;
+            // jamm MemoryMeter 0.3.2 does not allow to measure heap usage for DirectHeapBuffer correctly
+            //   within a bigger object graph (measureDeep).
+            // If omitSharedBufferOverhead is disabled
+            //    it starts to traverse and include heap usage for unpredictable global Cleaner/ReferenceQueue graphs
+            // if omitSharedBufferOverhead is enabled
+            //    it includes direct buffer capacity into the memory usage
+            // so, we have to correct the heap usage measured in the test by subtracting the total size of data within DirectByteBuffer.
+            // We assume that there is no data replacement in the test operations
+            // so all the off-heap memory allocated in direct byte buffer slabs is in-use/visible by traversing Memtable object graph
+            if (DatabaseDescriptor.getMemtableAllocationType() == Config.MemtableAllocationType.offheap_buffers)
+                expectedHeap -= memtable.getAllocator().offHeap().owns();
+
+            long maxDifference = MAX_DIFFERENCE_PERCENT * expectedHeap / 100;
+
+            double deltaPerPartition = (expectedHeap - actualHeap) / (double) totalPartitions;
+            String message = String.format("Expected heap usage close to %s, got %s, %s difference. " +
+                                           "Delta per partition: %.2f bytes",
+                                           FBUtilities.prettyPrintMemory(expectedHeap),
+                                           FBUtilities.prettyPrintMemory(actualHeap),
+                                           FBUtilities.prettyPrintMemory(expectedHeap - actualHeap),
+                                           deltaPerPartition);
+            logger.info(message);
+
+            Assert.assertTrue(message, Math.abs(actualHeap - expectedHeap) <= maxDifference);
+        }
+        finally
+        {
+            execute(String.format("DROP KEYSPACE IF EXISTS %s", keyspace));
+        }
+    }
+}
diff --git a/test/unit/org/apache/cassandra/db/memtable/MemtableSizeUnslabbedTest.java b/test/unit/org/apache/cassandra/db/memtable/MemtableSizeUnslabbedTest.java
new file mode 100644
index 0000000000..22a8a3a33e
--- /dev/null
+++ b/test/unit/org/apache/cassandra/db/memtable/MemtableSizeUnslabbedTest.java
@@ -0,0 +1,46 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.cassandra.db.memtable;
+
+import org.junit.Assert;
+import org.junit.BeforeClass;
+
+import org.apache.cassandra.config.Config;
+import org.apache.cassandra.db.Memtable;
+import org.apache.cassandra.dht.Murmur3Partitioner;
+import org.apache.cassandra.utils.memory.HeapPool;
+import org.apache.cassandra.utils.memory.MemtablePool;
+
+public class MemtableSizeUnslabbedTest extends MemtableSizeTestBase
+{
+    // Overrides CQLTester.setUpClass to run before it
+    @BeforeClass
+    public static void setUpClass()
+    {
+        setup(Config.MemtableAllocationType.unslabbed_heap_buffers, Murmur3Partitioner.instance);
+    }
+
+    @Override
+    void checkMemtablePool()
+    {
+        MemtablePool memoryPool = Memtable.MEMORY_POOL;
+        logger.info("Memtable pool {} off-heap limit {}", memoryPool, memoryPool.offHeap.limit);
+        Assert.assertTrue(memoryPool instanceof HeapPool);
+    }
+}
