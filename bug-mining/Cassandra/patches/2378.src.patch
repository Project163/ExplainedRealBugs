diff --git a/CHANGES.txt b/CHANGES.txt
index 061ad129cd..dcdb01bc80 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -10,6 +10,7 @@
    leveled manifest (CASSANDRA-6093)
  * make sequential nodetool repair the default (CASSANDRA-5950)
  * Add more hooks for compaction strategy implementations (CASSANDRA-6111)
+ * Fix memtable flushing for indexed tables (CASSANDRA-6112)
 Merged from 1.2:
  * Allow estimated memtable size to exceed slab allocator size (CASSANDRA-6078)
  * Start MeteredFlusher earlier to prevent OOM during CL replay (CASSANDRA-6087)
diff --git a/src/java/org/apache/cassandra/db/Memtable.java b/src/java/org/apache/cassandra/db/Memtable.java
index 14ce74ce11..f1bb1a51d4 100644
--- a/src/java/org/apache/cassandra/db/Memtable.java
+++ b/src/java/org/apache/cassandra/db/Memtable.java
@@ -351,7 +351,11 @@ public class Memtable
                         // But it can result in unexpected behaviour where deletes never make it to disk,
                         // as they are lost and so cannot override existing column values. So we only remove deleted columns if there
                         // is a CF level tombstone to ensure the delete makes it into an SSTable.
-                        ColumnFamilyStore.removeDeletedColumnsOnly(cf, Integer.MIN_VALUE);
+                        // We also shouldn't be dropping any columns obsoleted by partition and/or range tombstones in case
+                        // the table has secondary indexes, or else the stale entries wouldn't be cleaned up during compaction,
+                        // and will only be dropped during 2i query read-repair, if at all.
+                        if (!cfs.indexManager.hasIndexes())
+                            ColumnFamilyStore.removeDeletedColumnsOnly(cf, Integer.MIN_VALUE);
                     }
                     writer.append((DecoratedKey)entry.getKey(), cf);
                 }
diff --git a/src/java/org/apache/cassandra/db/compaction/CompactionManager.java b/src/java/org/apache/cassandra/db/compaction/CompactionManager.java
index f3c2011692..317014f68e 100644
--- a/src/java/org/apache/cassandra/db/compaction/CompactionManager.java
+++ b/src/java/org/apache/cassandra/db/compaction/CompactionManager.java
@@ -525,7 +525,7 @@ public class CompactionManager implements CompactionManagerMBean
             return;
         }
 
-        boolean hasIndexes = !cfs.indexManager.getIndexes().isEmpty();
+        boolean hasIndexes = cfs.indexManager.hasIndexes();
         CleanupStrategy cleanupStrategy = CleanupStrategy.get(cfs, ranges, renewer);
 
         for (SSTableReader sstable : sstables)
@@ -623,7 +623,7 @@ public class CompactionManager implements CompactionManagerMBean
     {
         public static CleanupStrategy get(ColumnFamilyStore cfs, Collection<Range<Token>> ranges, CounterId.OneShotRenewer renewer)
         {
-            if (!cfs.indexManager.getIndexes().isEmpty() || cfs.metadata.getDefaultValidator().isCommutative())
+            if (cfs.indexManager.hasIndexes() || cfs.metadata.getDefaultValidator().isCommutative())
                 return new Full(cfs, ranges, renewer);
 
             return new Bounded(cfs, ranges);
diff --git a/src/java/org/apache/cassandra/db/index/SecondaryIndexManager.java b/src/java/org/apache/cassandra/db/index/SecondaryIndexManager.java
index eff9537779..1838c03ecf 100644
--- a/src/java/org/apache/cassandra/db/index/SecondaryIndexManager.java
+++ b/src/java/org/apache/cassandra/db/index/SecondaryIndexManager.java
@@ -376,6 +376,14 @@ public class SecondaryIndexManager
         return indexes;
     }
 
+    /**
+     * @return if there are ANY indexes for this table..
+     */
+    public boolean hasIndexes()
+    {
+        return !indexesByColumn.isEmpty();
+    }
+
     /**
      * @return total current ram size of all indexes
      */
