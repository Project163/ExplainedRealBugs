diff --git a/CHANGES.txt b/CHANGES.txt
index 2313a9de86..8b5c87461a 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,7 +1,7 @@
 0.8-dev
  * avoid double RowMutation serialization on write path (CASSANDRA-1800)
  * adds support for columns that act as incr/decr counters 
-   (CASSANDRA-1072, 1937, 1944, 1936)
+   (CASSANDRA-1072, 1937, 1944, 1936, 2101)
  * make NetworkTopologyStrategy the default (CASSANDRA-1960)
  * configurable internode encryption (CASSANDRA-1567)
  * human readable column names in sstable2json output (CASSANDRA-1933)
diff --git a/interface/cassandra.thrift b/interface/cassandra.thrift
index 886c77ccd9..d4f602186a 100644
--- a/interface/cassandra.thrift
+++ b/interface/cassandra.thrift
@@ -498,6 +498,11 @@ service Cassandra {
     Remove data from the row specified by key at the granularity specified by column_path, and the given timestamp. Note
     that all the values in column_path besides column_path.column_family are truly optional: you can remove the entire
     row by just specifying the ColumnFamily, or you can remove a SuperColumn or a single Column by specifying those levels too.
+
+    Note that counters have limited support for deletes: if you remove
+    a counter, you must wait to issue any following update until the
+    delete has reached all the nodes and all of them have been fully
+    compacted.
    */
   void remove(1:required binary key,
               2:required ColumnPath column_path,
diff --git a/src/java/org/apache/cassandra/db/CounterColumn.java b/src/java/org/apache/cassandra/db/CounterColumn.java
index 5c281b3e53..6b88f8022a 100644
--- a/src/java/org/apache/cassandra/db/CounterColumn.java
+++ b/src/java/org/apache/cassandra/db/CounterColumn.java
@@ -110,28 +110,7 @@ public class CounterColumn extends Column
     {
         assert (column instanceof CounterColumn) || (column instanceof DeletedColumn) : "Wrong class type.";
 
-        if (isMarkedForDelete())
-        {
-            if (column.isMarkedForDelete()) // tombstone + tombstone: keep later tombstone
-            {
-                return timestamp() > column.timestamp() ? this : column;
-            }
-            else // tombstone + live: track last tombstone
-            {
-                if (timestamp() > column.timestamp()) // tombstone > live
-                {
-                    return this;
-                }
-                // tombstone <= live last delete
-                if (timestamp() <= ((CounterColumn)column).timestampOfLastDelete())
-                {
-                    return column;
-                }
-                // tombstone > live last delete
-                return new CounterColumn(column.name(), column.value(), column.timestamp(), timestamp());
-            }
-        }
-        else if (column.isMarkedForDelete()) // live + tombstone: track last tombstone
+        if (column.isMarkedForDelete()) // live + tombstone: track last tombstone
         {
             if (timestamp() < column.timestamp()) // live < tombstone
             {
@@ -145,6 +124,12 @@ public class CounterColumn extends Column
             // live last delete < tombstone
             return new CounterColumn(name(), value(), timestamp(), column.timestamp());
         }
+        // live < live last delete
+        if (timestamp() < ((CounterColumn)column).timestampOfLastDelete())
+            return column;
+        // live last delete > live
+        if (timestampOfLastDelete() > column.timestamp())
+            return this;
         // live + live: merge clocks; update value
         return new CounterColumn(
             name(),
diff --git a/test/unit/org/apache/cassandra/db/CounterColumnTest.java b/test/unit/org/apache/cassandra/db/CounterColumnTest.java
index 8db36b4491..3a477a0732 100644
--- a/test/unit/org/apache/cassandra/db/CounterColumnTest.java
+++ b/test/unit/org/apache/cassandra/db/CounterColumnTest.java
@@ -34,8 +34,7 @@ import org.junit.Test;
 
 import org.apache.cassandra.Util;
 import org.apache.cassandra.db.context.CounterContext;
-import org.apache.cassandra.db.marshal.AbstractCommutativeType;
-import org.apache.cassandra.db.marshal.CounterColumnType;
+import org.apache.cassandra.db.marshal.*;
 import org.apache.cassandra.io.util.DataOutputBuffer;
 import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.cassandra.utils.FBUtilities;
@@ -64,7 +63,11 @@ public class CounterColumnTest
     {
         AbstractCommutativeType type = CounterColumnType.instance;
         long delta = 3L;
-        CounterColumn column = new CounterColumn(ByteBufferUtil.bytes("x"), delta, 1L);
+        CounterUpdateColumn cuc = (CounterUpdateColumn)type.createColumn(
+            ByteBufferUtil.bytes("x"),
+            ByteBufferUtil.bytes(delta),
+            1L);
+        CounterColumn column = cuc.asCounterColumn();
 
         assert delta == column.total();
         assert Arrays.equals(FBUtilities.getLocalAddress().getAddress(), ArrayUtils.subarray(column.value().array(), 0, idLength));
@@ -79,12 +82,14 @@ public class CounterColumnTest
         IColumn right;
         IColumn reconciled;
 
+        ByteBuffer context;
+
         // tombstone + tombstone
         left  = new DeletedColumn(ByteBufferUtil.bytes("x"), 1, 1L);
         right = new DeletedColumn(ByteBufferUtil.bytes("x"), 2, 2L);
 
-        assert left.reconcile(right).timestamp() == right.timestamp();
-        assert right.reconcile(left).timestamp() == right.timestamp();
+        assert left.reconcile(right).getMarkedForDeleteAt() == right.getMarkedForDeleteAt();
+        assert right.reconcile(left).getMarkedForDeleteAt() == right.getMarkedForDeleteAt();
 
         // tombstone > live
         left  = new DeletedColumn(ByteBufferUtil.bytes("x"), 1, 2L);
@@ -112,7 +117,7 @@ public class CounterColumnTest
         assert reconciled.name() == right.name();
         assert reconciled.value() == right.value();
         assert reconciled.timestamp() == right.timestamp();
-        assert ((CounterColumn)reconciled).timestampOfLastDelete() == left.timestamp();
+        assert ((CounterColumn)reconciled).timestampOfLastDelete() == left.getMarkedForDeleteAt();
 
         // live < tombstone
         left  = new CounterColumn(ByteBufferUtil.bytes("x"), 0L, 1L);
@@ -140,36 +145,46 @@ public class CounterColumnTest
         assert reconciled.name() == left.name();
         assert reconciled.value() == left.value();
         assert reconciled.timestamp() == left.timestamp();
-        assert ((CounterColumn)reconciled).timestampOfLastDelete() == right.timestamp();
+        assert ((CounterColumn)reconciled).timestampOfLastDelete() == right.getMarkedForDeleteAt();
 
-        // live + live
+        // live < live last delete
+        left  = new CounterColumn(ByteBufferUtil.bytes("x"), cc.create(FBUtilities.toByteArray(1), 2L, 3L), 1L, Long.MIN_VALUE);
+        right = new CounterColumn(ByteBufferUtil.bytes("x"), cc.create(FBUtilities.toByteArray(1), 1L, 1L), 4L, 3L);
 
-        left = new CounterColumn(ByteBufferUtil.bytes("x"), cc.create(FBUtilities.toByteArray(1), 1L, 1L), 4L);
-        right = new CounterColumn(ByteBufferUtil.bytes("x"), cc.create(FBUtilities.toByteArray(1), 2L, 3L), 1L);
+        assert left.reconcile(right) == right;
+
+        // live last delete > live
+        left  = new CounterColumn(ByteBufferUtil.bytes("x"), cc.create(FBUtilities.toByteArray(1), 2L, 3L), 6L, 5L);
+        right = new CounterColumn(ByteBufferUtil.bytes("x"), cc.create(FBUtilities.toByteArray(1), 1L, 1L), 4L, 3L);
+
+        assert left.reconcile(right) == left;
+
+        // live + live
+        left  = new CounterColumn(ByteBufferUtil.bytes("x"), cc.create(FBUtilities.toByteArray(1), 1L, 1L), 4L, Long.MIN_VALUE);
+        right = new CounterColumn(ByteBufferUtil.bytes("x"), cc.create(FBUtilities.toByteArray(1), 2L, 3L), 1L, Long.MIN_VALUE);
 
         reconciled = left.reconcile(right);
         assert reconciled.name().equals(left.name());
         assert ((CounterColumn)reconciled).total() == 3L;
         assert reconciled.timestamp() == 4L;
 
-        left = reconciled;
-        right = new CounterColumn(ByteBufferUtil.bytes("x"), cc.create(FBUtilities.toByteArray(2), 1L, 5L), 2L);
+        left  = reconciled;
+        right = new CounterColumn(ByteBufferUtil.bytes("x"), cc.create(FBUtilities.toByteArray(2), 1L, 5L), 2L, Long.MIN_VALUE);
 
         reconciled = left.reconcile(right);
-
         assert reconciled.name().equals(left.name());
         assert ((CounterColumn)reconciled).total() == 8L;
         assert reconciled.timestamp() == 4L;
 
-        left = reconciled;
-        right = new CounterColumn(ByteBufferUtil.bytes("x"), cc.create(FBUtilities.toByteArray(2), 2L, 2L), 6L);
+        left  = reconciled;
+        right = new CounterColumn(ByteBufferUtil.bytes("x"), cc.create(FBUtilities.toByteArray(2), 2L, 2L), 6L, Long.MIN_VALUE);
 
         reconciled = left.reconcile(right);
         assert reconciled.name().equals(left.name());
         assert ((CounterColumn)reconciled).total() == 5L;
         assert reconciled.timestamp() == 6L;
 
-        ByteBuffer context = reconciled.value();
+        context = reconciled.value();
         assert 2 * stepLength == context.remaining();
 
         assert  1 == context.getInt(0*stepLength);
