diff --git a/src/java/org/apache/cassandra/db/ColumnFamilyStore.java b/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
index 510fd0d5fc..7a272fd468 100644
--- a/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
+++ b/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
@@ -394,13 +394,19 @@ public final class ColumnFamilyStore implements ColumnFamilyStoreMBean
                              columnFamily_, SSTable.TEMPFILE_MARKER, index);
     }
 
-    void switchMemtable()
+    void switchMemtable(Memtable oldMemtable, CommitLog.CommitLogContext ctx)
     {
         memtableLock_.writeLock().lock();
         try
         {
+            if (oldMemtable.isFrozen())
+            {
+                return;
+            }
             logger_.info(columnFamily_ + " has reached its threshold; switching in a fresh Memtable");
-            getMemtablesPendingFlushNotNull(columnFamily_).add(memtable_); // it's ok for the MT to briefly be both active and pendingFlush
+            oldMemtable.freeze();
+            getMemtablesPendingFlushNotNull(columnFamily_).add(oldMemtable); // it's ok for the MT to briefly be both active and pendingFlush
+            submitFlush(oldMemtable, ctx);
             memtable_ = new Memtable(table_, columnFamily_);
         }
         finally
@@ -423,13 +429,25 @@ public final class ColumnFamilyStore implements ColumnFamilyStoreMBean
 
     public void forceFlush()
     {
-        memtable_.forceflush();
+        if (memtable_.isClean())
+            return;
+
+        CommitLog.CommitLogContext ctx = null;
+        try
+        {
+            ctx = CommitLog.open().getContext();
+        }
+        catch (IOException e)
+        {
+            throw new RuntimeException(e);
+        }
+        switchMemtable(memtable_, ctx);
     }
 
     void forceBlockingFlush() throws IOException, ExecutionException, InterruptedException
     {
         Memtable oldMemtable = getMemtableThreadSafe();
-        oldMemtable.forceflush();
+        forceFlush();
         // block for flush to finish by adding a no-op action to the flush executorservice
         // and waiting for that to finish.  (this works since flush ES is single-threaded.)
         Future f = flusher_.submit(new Runnable()
@@ -463,8 +481,7 @@ public final class ColumnFamilyStore implements ColumnFamilyStoreMBean
         Memtable initialMemtable = getMemtableThreadSafe();
         if (initialMemtable.isThresholdViolated())
         {
-            switchMemtable();
-            initialMemtable.enqueueFlush(cLogCtx);
+            switchMemtable(initialMemtable, cLogCtx);
         }
         memtableLock_.writeLock().lock();
         try
@@ -1284,7 +1301,7 @@ public final class ColumnFamilyStore implements ColumnFamilyStoreMBean
     }
 
     /* Submit memtables to be flushed to disk */
-    public static void submitFlush(final Memtable memtable, final CommitLog.CommitLogContext cLogCtx)
+    private static void submitFlush(final Memtable memtable, final CommitLog.CommitLogContext cLogCtx)
     {
         logger_.info("Enqueuing flush of " + memtable);
         flusher_.submit(new Runnable()
diff --git a/src/java/org/apache/cassandra/db/Memtable.java b/src/java/org/apache/cassandra/db/Memtable.java
index b9637e69e4..d599adf08e 100644
--- a/src/java/org/apache/cassandra/db/Memtable.java
+++ b/src/java/org/apache/cassandra/db/Memtable.java
@@ -121,13 +121,14 @@ public class Memtable implements Comparable<Memtable>
     	return cfName_;
     }
 
-    synchronized void enqueueFlush(CommitLog.CommitLogContext cLogCtx)
+    boolean isFrozen()
     {
-        if (!isFrozen_)
-        {
-            isFrozen_ = true;
-            ColumnFamilyStore.submitFlush(this, cLogCtx);
-        }
+        return isFrozen_;
+    }
+
+    void freeze()
+    {
+        isFrozen_ = true;
     }
 
     /**
@@ -142,27 +143,6 @@ public class Memtable implements Comparable<Memtable>
         resolve(key, columnFamily);
     }
 
-    /*
-     * This version is used to switch memtable and force flush.
-     * Flushing is still done in a separate executor -- forceFlush only blocks
-     * until the flush runnable is queued.
-    */
-    public void forceflush()
-    {
-        if (isClean())
-            return;
-
-        try
-        {
-            Table.open(table_).getColumnFamilyStore(cfName_).switchMemtable();
-            enqueueFlush(CommitLog.open().getContext());
-        }
-        catch (IOException ex)
-        {
-            throw new RuntimeException(ex);
-        }
-    }
-
     /** flush synchronously (in the current thread, not on the executor).
      *  only the recover code should call this. */
     void flushOnRecovery() throws IOException {
