diff --git a/bin/cqlsh b/bin/cqlsh
index 8d98c286b4..65f1003f90 100755
--- a/bin/cqlsh
+++ b/bin/cqlsh
@@ -753,7 +753,7 @@ class Shell(cmd.Cmd):
         key_alias = cfdef.key_alias
         if key_alias is None:
             key_alias = 'KEY'
-        return [key_alias] + [cm.name for cm in cfdef.column_metadata]
+        return [key_alias] + sorted([cm.name for cm in cfdef.column_metadata])
 
     # ===== thrift-dependent parts =====
 
@@ -1625,9 +1625,8 @@ class Shell(cmd.Cmd):
 
     def prep_export_dump(self, ks, cf, columns):
         if columns is None:
-            columnlist = '*'
-        else:
-            columnlist = ', '.join(map(self.cql_protect_name, columns))
+            columns = self.get_column_names(ks, cf)
+        columnlist = ', '.join(map(self.cql_protect_name, columns))
         # this limit is pretty awful. would be better to use row-key-paging, so
         # that the dump could be pretty easily aborted if necessary, but that
         # can be kind of tricky with cql3. Punt for now, until the real cursor
diff --git a/pylib/cqlshlib/cql3handling.py b/pylib/cqlshlib/cql3handling.py
index 50993225cc..a08174196d 100644
--- a/pylib/cqlshlib/cql3handling.py
+++ b/pylib/cqlshlib/cql3handling.py
@@ -811,6 +811,7 @@ class CqlTableDef:
         subtypes = subtypes[:len(self.key_components)]
         keycols = map(self.column_class, self.key_components, subtypes)
         normal_cols = map(self.column_class.from_layout, self.coldefs)
+        normal_cols.sort(key=lambda c: c.name)
         self.columns = keycols + value_cols + normal_cols
 
     def is_counter_col(self, colname):
