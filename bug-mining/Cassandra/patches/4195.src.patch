diff --git a/CHANGES.txt b/CHANGES.txt
index 6e434965d3..e7aa321ce1 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 2.2.6
+ * Dont mark sstables as repairing with sub range repairs (CASSANDRA-11451)
  * Fix use of NullUpdater for 2i during compaction (CASSANDRA-11450)
  * Notify when sstables change after cancelling compaction (CASSANDRA-11373)
  * cqlsh: COPY FROM should check that explicit column names are valid (CASSANDRA-11333)
diff --git a/src/java/org/apache/cassandra/db/compaction/CompactionManager.java b/src/java/org/apache/cassandra/db/compaction/CompactionManager.java
index ca02747dcd..675d3cc5a3 100644
--- a/src/java/org/apache/cassandra/db/compaction/CompactionManager.java
+++ b/src/java/org/apache/cassandra/db/compaction/CompactionManager.java
@@ -1176,12 +1176,15 @@ public class CompactionManager implements CompactionManagerMBean
                 }
             }
 
-            Set<SSTableReader> currentlyRepairing = ActiveRepairService.instance.currentlyRepairing(cfs.metadata.cfId, validator.desc.parentSessionId);
-
-            if (!Sets.intersection(currentlyRepairing, sstablesToValidate).isEmpty())
+            if (prs.isGlobal)
             {
-                logger.error("Cannot start multiple repair sessions over the same sstables");
-                throw new RuntimeException("Cannot start multiple repair sessions over the same sstables");
+                Set<SSTableReader> currentlyRepairing = ActiveRepairService.instance.currentlyRepairing(cfs.metadata.cfId, validator.desc.parentSessionId);
+
+                if (!Sets.intersection(currentlyRepairing, sstablesToValidate).isEmpty())
+                {
+                    logger.error("Cannot start multiple repair sessions over the same sstables");
+                    throw new RuntimeException("Cannot start multiple repair sessions over the same sstables");
+                }
             }
 
             sstables = Refs.tryRef(sstablesToValidate);
@@ -1191,8 +1194,8 @@ public class CompactionManager implements CompactionManagerMBean
                 throw new RuntimeException("Could not reference sstables");
             }
         }
-
-        prs.addSSTables(cfs.metadata.cfId, sstablesToValidate);
+        if (prs.isGlobal)
+            prs.addSSTables(cfs.metadata.cfId, sstablesToValidate);
 
         return sstables;
     }
diff --git a/src/java/org/apache/cassandra/repair/RepairMessageVerbHandler.java b/src/java/org/apache/cassandra/repair/RepairMessageVerbHandler.java
index b8f8b65a81..8a0706ac1b 100644
--- a/src/java/org/apache/cassandra/repair/RepairMessageVerbHandler.java
+++ b/src/java/org/apache/cassandra/repair/RepairMessageVerbHandler.java
@@ -108,16 +108,18 @@ public class RepairMessageVerbHandler implements IVerbHandler<RepairMessage>
                                     new Bounds<>(sstable.first.getToken(), sstable.last.getToken()).intersects(Collections.singleton(repairingRange));
                         }
                     }, true); //ephemeral snapshot, if repair fails, it will be cleaned next startup
-
-                    Set<SSTableReader> currentlyRepairing = ActiveRepairService.instance.currentlyRepairing(cfs.metadata.cfId, desc.parentSessionId);
-                    if (!Sets.intersection(currentlyRepairing, snapshottedSSSTables).isEmpty())
+                    if (ActiveRepairService.instance.getParentRepairSession(desc.parentSessionId).isGlobal)
                     {
-                        // clear snapshot that we just created
-                        cfs.clearSnapshot(desc.sessionId.toString());
-                        logErrorAndSendFailureResponse("Cannot start multiple repair sessions over the same sstables", message.from, id);
-                        return;
+                        Set<SSTableReader> currentlyRepairing = ActiveRepairService.instance.currentlyRepairing(cfs.metadata.cfId, desc.parentSessionId);
+                        if (!Sets.intersection(currentlyRepairing, snapshottedSSSTables).isEmpty())
+                        {
+                            // clear snapshot that we just created
+                            cfs.clearSnapshot(desc.sessionId.toString());
+                            logErrorAndSendFailureResponse("Cannot start multiple repair sessions over the same sstables", message.from, id);
+                            return;
+                        }
+                        ActiveRepairService.instance.getParentRepairSession(desc.parentSessionId).addSSTables(cfs.metadata.cfId, snapshottedSSSTables);
                     }
-                    ActiveRepairService.instance.getParentRepairSession(desc.parentSessionId).addSSTables(cfs.metadata.cfId, snapshottedSSSTables);
                     logger.debug("Enqueuing response to snapshot request {} to {}", desc.sessionId, message.from);
                     MessagingService.instance().sendReply(new MessageOut(MessagingService.Verb.INTERNAL_RESPONSE), id, message.from);
                     break;
diff --git a/src/java/org/apache/cassandra/service/ActiveRepairService.java b/src/java/org/apache/cassandra/service/ActiveRepairService.java
index 9ac118634a..39be051059 100644
--- a/src/java/org/apache/cassandra/service/ActiveRepairService.java
+++ b/src/java/org/apache/cassandra/service/ActiveRepairService.java
@@ -426,7 +426,7 @@ public class ActiveRepairService
         private final Map<UUID, Set<SSTableReader>> sstableMap = new HashMap<>();
         private final long repairedAt;
         public final boolean isIncremental;
-        private final boolean isGlobal;
+        public final boolean isGlobal;
 
         public ParentRepairSession(List<ColumnFamilyStore> columnFamilyStores, Collection<Range<Token>> ranges, boolean isIncremental, boolean isGlobal, long repairedAt)
         {
