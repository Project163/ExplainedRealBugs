diff --git a/CHANGES.txt b/CHANGES.txt
index 04650c1c5b..57bbfcc7ff 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 2.1.6
+ * Ensure truncate without snapshot cannot produce corrupt responses (CASSANDRA-9388) 
  * Consistent error message when a table mixes counter and non-counter
    columns (CASSANDRA-9492)
  * Avoid getting unreadable keys during anticompaction (CASSANDRA-9508)
diff --git a/src/java/org/apache/cassandra/db/ColumnFamilyStore.java b/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
index 5f474768ea..d686e6785f 100644
--- a/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
+++ b/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
@@ -1078,7 +1078,7 @@ public class ColumnFamilyStore implements ColumnFamilyStoreMBean
                 if (memtable.isClean() || truncate)
                 {
                     memtable.cfs.replaceFlushed(memtable, null);
-                    memtable.setDiscarded();
+                    reclaim(memtable);
                     iter.remove();
                 }
             }
@@ -1091,27 +1091,31 @@ public class ColumnFamilyStore implements ColumnFamilyStoreMBean
 
             metric.memtableSwitchCount.inc();
 
-            for (final Memtable memtable : memtables)
+            for (Memtable memtable : memtables)
             {
                 // flush the memtable
                 MoreExecutors.sameThreadExecutor().execute(memtable.flushRunnable());
-
-                // issue a read barrier for reclaiming the memory, and offload the wait to another thread
-                final OpOrder.Barrier readBarrier = readOrdering.newBarrier();
-                readBarrier.issue();
-                reclaimExecutor.execute(new WrappedRunnable()
-                {
-                    public void runMayThrow() throws InterruptedException, ExecutionException
-                    {
-                        readBarrier.await();
-                        memtable.setDiscarded();
-                    }
-                });
+                reclaim(memtable);
             }
 
             // signal the post-flush we've done our work
             postFlush.latch.countDown();
         }
+
+        private void reclaim(final Memtable memtable)
+        {
+            // issue a read barrier for reclaiming the memory, and offload the wait to another thread
+            final OpOrder.Barrier readBarrier = readOrdering.newBarrier();
+            readBarrier.issue();
+            reclaimExecutor.execute(new WrappedRunnable()
+            {
+                public void runMayThrow() throws InterruptedException, ExecutionException
+                {
+                    readBarrier.await();
+                    memtable.setDiscarded();
+                }
+            });
+        }
     }
 
     /**
