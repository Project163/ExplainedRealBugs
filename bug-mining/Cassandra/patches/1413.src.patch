diff --git a/CHANGES.txt b/CHANGES.txt
index eec15835a9..e1fca0c045 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -62,6 +62,8 @@
  * Avoids over-paging during get_count (CASSANDRA-3798)
  * Add new command to rebuild a node without (repair) merkle tree calculations
    (CASSANDRA-3483)
+ * respect not only row cache capacity but caching mode when
+   trying to read data (CASSANDRA-3812)
 
 
 1.0.8
diff --git a/src/java/org/apache/cassandra/db/ColumnFamilyStore.java b/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
index 6ec9c51cd9..65d7c60205 100644
--- a/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
+++ b/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
@@ -1046,9 +1046,8 @@ public class ColumnFamilyStore implements ColumnFamilyStoreMBean
     public ColumnFamily cacheRow(Integer cfId, DecoratedKey decoratedKey)
     {
         CFMetaData.Caching caching = metadata.getCaching();
-
-        if (caching == CFMetaData.Caching.NONE || caching == CFMetaData.Caching.KEYS_ONLY)
-            return null;
+        assert caching == CFMetaData.Caching.ALL || caching == CFMetaData.Caching.ROWS_ONLY
+                : String.format("Row cache is not enabled on column family [" + getColumnFamilyName() + "]");
 
         RowCacheKey key = new RowCacheKey(cfId, decoratedKey);
 
@@ -1078,7 +1077,10 @@ public class ColumnFamilyStore implements ColumnFamilyStoreMBean
         long start = System.nanoTime();
         try
         {
-            if (CacheService.instance.rowCache.getCapacity() == 0)
+            CFMetaData.Caching caching = metadata.getCaching();
+            if (caching == CFMetaData.Caching.NONE
+                || caching == CFMetaData.Caching.KEYS_ONLY
+                || CacheService.instance.rowCache.getCapacity() == 0)
             {
                 ColumnFamily cf = getTopLevelColumns(filter, gcBefore, false);
 
