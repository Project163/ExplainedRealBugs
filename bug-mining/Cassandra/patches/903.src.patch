diff --git a/CHANGES.txt b/CHANGES.txt
index 24b86a9d11..aa91e6a5a9 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -7,6 +7,7 @@
 0.8.0-?
  * faster flushes and compaction from fixing excessively pessimistic 
    rebuffering in BRAF (CASSANDRA-2581)
+ * fix merkle tree splitting exiting early (CASSANDRA-2605)
  
 
 0.8.0-beta2
diff --git a/src/java/org/apache/cassandra/utils/MerkleTree.java b/src/java/org/apache/cassandra/utils/MerkleTree.java
index 716c87a9e2..348f2bd776 100644
--- a/src/java/org/apache/cassandra/utils/MerkleTree.java
+++ b/src/java/org/apache/cassandra/utils/MerkleTree.java
@@ -445,9 +445,15 @@ public class MerkleTree implements Serializable
 
         if (hashable instanceof Leaf)
         {
+            Token midpoint = partitioner.midpoint(pleft, pright);
+
+            // We should not create a non-sensical range where start and end are the same token (this is non-sensical because range are
+            // start exclusive). Note that we shouldn't hit that unless the full range is very small or we are fairly deep
+            if (midpoint.equals(pleft) || midpoint.equals(pright))
+                throw new StopRecursion.TooDeep();
+
             // split
             size++;
-            Token midpoint = partitioner.midpoint(pleft, pright);
             return new Inner(midpoint, new Leaf(), new Leaf());
         }
         // else: node.
@@ -455,12 +461,6 @@ public class MerkleTree implements Serializable
         // recurse on the matching child
         Inner node = (Inner)hashable;
 
-        // FIXME: we are not really 'TooDeep', however we cannot say that the
-        // split was successfull otherwise we could have a chance of infinite
-        // loop given how we split.
-        if (t.equals(node.token) || t.equals(pright))
-            throw new StopRecursion.TooDeep();
-
         if (Range.contains(pleft, node.token, t))
             // left child contains token
             node.lchild(splitHelper(node.lchild, pleft, node.token, inc(depth), t));
