diff --git a/CHANGES.txt b/CHANGES.txt
index 48ffd346b1..deb01503bc 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -67,7 +67,7 @@
  * fix inconsistency of the CLI syntax when {} should be used instead of [{}]
    (CASSANDRA-3119)
  * rename CQL type names to match expected SQL behavior (CASSANDRA-3149, 3031)
- * Arena-based allocation for memtables (CASSANDRA-2252, 3162, 3163)
+ * Arena-based allocation for memtables (CASSANDRA-2252, 3162, 3163, 3168)
  * Default RR chance to 0.1 (CASSANDRA-3169)
 
 
diff --git a/NEWS.txt b/NEWS.txt
index be646ed4c1..4e84792ba6 100644
--- a/NEWS.txt
+++ b/NEWS.txt
@@ -11,6 +11,9 @@ Upgrading
     - CQL types bytea and date were renamed to blob and timestamp, respectively,
       to conform with SQL norms.  CQL type int is now a 4-byte int, not 8
       (which is still available as bigint).
+    - Cassandra 1.0 uses arena allocation to reduce old generation fragmentation.
+      This means there is a minimum overhead of 1MB per ColumnFamily plus
+      1MB per index.
 
 Features
 --------
diff --git a/src/java/org/apache/cassandra/db/Memtable.java b/src/java/org/apache/cassandra/db/Memtable.java
index 7195b2eca7..16bbda0369 100644
--- a/src/java/org/apache/cassandra/db/Memtable.java
+++ b/src/java/org/apache/cassandra/db/Memtable.java
@@ -90,7 +90,7 @@ public class Memtable
     {
         // 25% fudge factor on the base throughput * liveRatio calculation.  (Based on observed
         // pre-slabbing behavior -- not sure what accounts for this. May have changed with introduction of slabbing.)
-        return (long) (currentThroughput.get() * cfs.liveRatio * 1.25) + allocator.size();
+        return (long) (currentThroughput.get() * cfs.liveRatio * 1.25);
     }
 
     public long getSerializedSize()
diff --git a/src/java/org/apache/cassandra/utils/SlabAllocator.java b/src/java/org/apache/cassandra/utils/SlabAllocator.java
index 321bf834c8..596c07e322 100644
--- a/src/java/org/apache/cassandra/utils/SlabAllocator.java
+++ b/src/java/org/apache/cassandra/utils/SlabAllocator.java
@@ -29,6 +29,8 @@ import java.util.concurrent.atomic.AtomicReference;
 import com.google.common.base.Preconditions;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.MapMaker;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * The SlabAllocator is a bump-the-pointer allocator that allocates
@@ -46,24 +48,13 @@ import com.google.common.collect.MapMaker;
  */
 public class SlabAllocator extends Allocator
 {
+    private static Logger logger = LoggerFactory.getLogger(SlabAllocator.class);
+
     private final static int REGION_SIZE = 1024 * 1024;
     private final static int MAX_CLONED_SIZE = 128 * 1024; // bigger than this don't go in the region
 
     private final AtomicReference<Region> currentRegion = new AtomicReference<Region>();
-    private final Collection<Region> filledRegions = Collections.newSetFromMap(new MapMaker().weakKeys().<Region, Boolean>makeMap());
-
-    /** @return Total number of bytes allocated by this allocator. */
-    public long size()
-    {
-        Iterable<Region> regions = filledRegions;
-        if (currentRegion.get() != null)
-            regions = Iterables.concat(regions, Collections.<Region>singleton(currentRegion.get()));
-
-        long total = 0;
-        for (Region region : regions)
-            total += region.size;
-        return total;
-    }
+    private volatile int regionCount;
 
     public ByteBuffer allocate(int size)
     {
@@ -86,22 +77,10 @@ public class SlabAllocator extends Allocator
                 return cloned;
 
             // not enough space!
-            tryRetireRegion(region);
+            currentRegion.compareAndSet(region, null);
         }
     }
     
-    /**
-     * Try to retire the current region if it is still <code>region</code>.
-     * Postcondition is that curRegion.get() != region
-     */
-    private void tryRetireRegion(Region region)
-    {
-        if (currentRegion.compareAndSet(region, null))
-        {
-            filledRegions.add(region);
-        }
-    }
-
     /**
      * Get the current region, or, if there is no current region, allocate a new one
      */
@@ -122,6 +101,8 @@ public class SlabAllocator extends Allocator
             {
                 // we won race - now we need to actually do the expensive allocation step
                 region.init();
+                regionCount++;
+                logger.debug("{} regions now allocated in {}", regionCount, this);
                 return region;
             }
             // someone else won race - that's fine, we'll try to grab theirs
