diff --git a/CHANGES.txt b/CHANGES.txt
index 7faf97f36a..db24da41e9 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -8,6 +8,7 @@
  * (cqlsh) add DESCRIBE COLUMNFAMILIES (CASSANDRA-3586)
  * (cqlsh) format blobs correctly and use colors to improve output
    readability (CASSANDRA-3726)
+ * synchronize BiMap of bootstrapping tokens (CASSANDRA-3417)
 
 
 1.0.7
@@ -156,7 +157,6 @@ Merged from 0.8:
  * cleanup usage of StorageService.setMode() (CASANDRA-3388)
  * Add timing information to cassandra-cli GET/SET/LIST queries (CASSANDRA-3326)
  * Only create one CompressionMetadata object per sstable (CASSANDRA-3427)
- * synchronize BiMap of bootstrapping tokens (CASSANDRA-3417)
  * Avoid large array allocation for compressed chunk offsets (CASSANDRA-3432)
  * fix DecimalType bytebuffer marshalling (CASSANDRA-3421)
  * fix bug that caused first column in per row indexes to be ignored 
diff --git a/src/java/org/apache/cassandra/locator/TokenMetadata.java b/src/java/org/apache/cassandra/locator/TokenMetadata.java
index b64865606b..ebb094bdc6 100644
--- a/src/java/org/apache/cassandra/locator/TokenMetadata.java
+++ b/src/java/org/apache/cassandra/locator/TokenMetadata.java
@@ -109,9 +109,12 @@ public class TokenMetadata
     {
         int n = 0;
         Range sourceRange = getPrimaryRangeFor(getToken(source));
-        for (Token token : bootstrapTokens.keySet())
-            if (sourceRange.contains(token))
-                n++;
+        synchronized (bootstrapTokens)
+        {
+            for (Token token : bootstrapTokens.keySet())
+                if (sourceRange.contains(token))
+                    n++;
+        }
         return n;
     }
 
@@ -606,14 +609,17 @@ public class TokenMetadata
                 }
             }
 
-            if (!bootstrapTokens.isEmpty())
+            synchronized (bootstrapTokens)
             {
-                sb.append("Bootstrapping Tokens:" );
-                sb.append(System.getProperty("line.separator"));
-                for (Map.Entry<Token, InetAddress> entry : bootstrapTokens.entrySet())
+                if (!bootstrapTokens.isEmpty())
                 {
-                    sb.append(entry.getValue() + ":" + entry.getKey());
+                    sb.append("Bootstrapping Tokens:" );
                     sb.append(System.getProperty("line.separator"));
+                    for (Map.Entry<Token, InetAddress> entry : bootstrapTokens.entrySet())
+                    {
+                        sb.append(entry.getValue() + ":" + entry.getKey());
+                        sb.append(System.getProperty("line.separator"));
+                    }
                 }
             }
 
@@ -711,9 +717,20 @@ public class TokenMetadata
      */
     public Map<Token, InetAddress> getTokenToEndpointMap()
     {
-        Map<Token, InetAddress> map = new HashMap<Token, InetAddress>(tokenToEndpointMap.size() + bootstrapTokens.size());
-        map.putAll(tokenToEndpointMap);
-        map.putAll(bootstrapTokens);
-        return map;
+        lock.readLock().lock();
+        try
+        {
+            Map<Token, InetAddress> map = new HashMap<Token, InetAddress>(tokenToEndpointMap.size() + bootstrapTokens.size());
+            map.putAll(tokenToEndpointMap);
+            synchronized (bootstrapTokens)
+            {
+                map.putAll(bootstrapTokens);
+            }
+            return map;
+        }
+        finally
+        {
+            lock.readLock().unlock();
+        }
     }
 }
diff --git a/src/java/org/apache/cassandra/service/StorageService.java b/src/java/org/apache/cassandra/service/StorageService.java
index abe8877a47..9f60e58382 100644
--- a/src/java/org/apache/cassandra/service/StorageService.java
+++ b/src/java/org/apache/cassandra/service/StorageService.java
@@ -1252,14 +1252,17 @@ public class StorageService implements IEndpointStateChangeSubscriber, StorageSe
 
         // For each of the bootstrapping nodes, simply add and remove them one by one to
         // allLeftMetadata and check in between what their ranges would be.
-        for (Map.Entry<Token, InetAddress> entry : bootstrapTokens.entrySet())
+        synchronized (bootstrapTokens)
         {
-            InetAddress endpoint = entry.getValue();
+            for (Map.Entry<Token, InetAddress> entry : bootstrapTokens.entrySet())
+            {
+                InetAddress endpoint = entry.getValue();
 
-            allLeftMetadata.updateNormalToken(entry.getKey(), endpoint);
-            for (Range range : strategy.getAddressRanges(allLeftMetadata).get(endpoint))
-                pendingRanges.put(range, endpoint);
-            allLeftMetadata.removeEndpoint(endpoint);
+                allLeftMetadata.updateNormalToken(entry.getKey(), endpoint);
+                for (Range range : strategy.getAddressRanges(allLeftMetadata).get(endpoint))
+                    pendingRanges.put(range, endpoint);
+                allLeftMetadata.removeEndpoint(endpoint);
+            }
         }
 
         // At this stage pendingRanges has been updated according to leaving and bootstrapping nodes.
