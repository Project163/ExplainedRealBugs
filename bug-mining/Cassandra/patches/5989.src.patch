diff --git a/CHANGES.txt b/CHANGES.txt
index 3e59bc0295..cd1270d125 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,4 +1,5 @@
 4.1
+ * reduce hot-path object allocations required to record local/remote requests against the client request metrics (CASSANDRA-17424)
  * Disallow removing DC from system_auth while nodes are active in the DC (CASSANDRA-17478)
  * Add guardrail for the number of fields per UDT (CASSANDRA-17385)
  * Allow users to change cqlsh history location using env variable (CASSANDRA-17448)
diff --git a/src/java/org/apache/cassandra/service/StorageProxy.java b/src/java/org/apache/cassandra/service/StorageProxy.java
index 99ed347be0..15e9e2d467 100644
--- a/src/java/org/apache/cassandra/service/StorageProxy.java
+++ b/src/java/org/apache/cassandra/service/StorageProxy.java
@@ -833,17 +833,6 @@ public class StorageProxy implements StorageProxyMBean
         });
     }
 
-    private static boolean hasLocalMutation(IMutation mutation)
-    {
-        return canDoLocalRequest(StorageService.instance.getNaturalEndpointsWithPort(mutation.getKeyspaceName(),
-                                                                                     mutation.key().getKey()));
-    }
-
-    private static boolean canDoLocalRequest(List<String> endpoints)
-    {
-        return endpoints.contains(FBUtilities.getBroadcastAddressAndPort().getHostAddressAndPort());
-    }
-
     /**
      * Use this method to have these Mutations applied
      * across all replicas. This method will take care
@@ -869,11 +858,6 @@ public class StorageProxy implements StorageProxyMBean
         {
             for (IMutation mutation : mutations)
             {
-                if (hasLocalMutation(mutation))
-                    writeMetrics.localRequests.mark();
-                else
-                    writeMetrics.remoteRequests.mark();
-
                 if (mutation instanceof CounterMutation)
                     responseHandlers.add(mutateCounter((CounterMutation)mutation, localDataCenter, queryStartNanoTime));
                 else
@@ -1027,11 +1011,6 @@ public class StorageProxy implements StorageProxyMBean
                 // add a handler for each mutation - includes checking availability, but doesn't initiate any writes, yet
                 for (Mutation mutation : mutations)
                 {
-                    if (hasLocalMutation(mutation))
-                        writeMetrics.localRequests.mark();
-                    else
-                        writeMetrics.remoteRequests.mark();
-
                     String keyspaceName = mutation.getKeyspaceName();
                     Token tk = mutation.key().getToken();
                     AbstractReplicationStrategy replicationStrategy = Keyspace.open(keyspaceName).getReplicationStrategy();
@@ -1198,11 +1177,6 @@ public class StorageProxy implements StorageProxyMBean
             // add a handler for each mutation - includes checking availability, but doesn't initiate any writes, yet
             for (Mutation mutation : mutations)
             {
-                if (hasLocalMutation(mutation))
-                    writeMetrics.localRequests.mark();
-                else
-                    writeMetrics.remoteRequests.mark();
-
                 WriteResponseHandlerWrapper wrapper = wrapBatchResponseHandler(mutation,
                                                                                consistency_level,
                                                                                batchConsistencyLevel,
@@ -1369,6 +1343,12 @@ public class StorageProxy implements StorageProxyMBean
         Token tk = mutation.key().getToken();
 
         ReplicaPlan.ForWrite replicaPlan = ReplicaPlans.forWrite(keyspace, consistencyLevel, tk, ReplicaPlans.writeNormal);
+
+        if (replicaPlan.lookup(FBUtilities.getBroadcastAddressAndPort()) != null)
+            writeMetrics.localRequests.mark();
+        else
+            writeMetrics.remoteRequests.mark();
+
         AbstractReplicationStrategy rs = replicaPlan.replicationStrategy();
         AbstractWriteResponseHandler<IMutation> responseHandler = rs.getWriteResponseHandler(replicaPlan, callback, writeType, mutation.hintOnFailure(), queryStartNanoTime);
 
@@ -1388,6 +1368,12 @@ public class StorageProxy implements StorageProxyMBean
         Token tk = mutation.key().getToken();
 
         ReplicaPlan.ForWrite replicaPlan = ReplicaPlans.forWrite(keyspace, consistencyLevel, tk, ReplicaPlans.writeNormal);
+
+        if (replicaPlan.lookup(FBUtilities.getBroadcastAddressAndPort()) != null)
+            writeMetrics.localRequests.mark();
+        else
+            writeMetrics.remoteRequests.mark();
+
         AbstractReplicationStrategy rs = replicaPlan.replicationStrategy();
         AbstractWriteResponseHandler<IMutation> writeHandler = rs.getWriteResponseHandler(replicaPlan, null, writeType, mutation, queryStartNanoTime);
         BatchlogResponseHandler<IMutation> batchHandler = new BatchlogResponseHandler<>(writeHandler, batchConsistencyLevel.blockFor(rs), cleanup, queryStartNanoTime);
@@ -1684,6 +1670,11 @@ public class StorageProxy implements StorageProxyMBean
             // we build this ONLY to perform the sufficiency check that happens on construction
             ReplicaPlans.forWrite(keyspace, cm.consistency(), tk, ReplicaPlans.writeAll);
 
+            // This host isn't a replica, so mark the request as being remote. If this host is a 
+            // replica, applyCounterMutationOnCoordinator() in the branch above will call performWrite(), and 
+            // there we'll mark a local request against the metrics.
+            writeMetrics.remoteRequests.mark();
+
             // Forward the actual update to the chosen leader replica
             AbstractWriteResponseHandler<IMutation> responseHandler = new WriteResponseHandler<>(ReplicaPlans.forForwardingCounterWrite(keyspace, tk, replica),
                                                                                                  WriteType.COUNTER, null, queryStartNanoTime);
@@ -2035,11 +2026,10 @@ public class StorageProxy implements StorageProxyMBean
         {
             reads[i] = AbstractReadExecutor.getReadExecutor(commands.get(i), consistencyLevel, queryStartNanoTime);
 
-            if (canDoLocalRequest(reads[i].getContactedReplicas())) {
+            if (reads[i].hasLocalRead())
                 readMetrics.localRequests.mark();
-            } else {
+            else
                 readMetrics.remoteRequests.mark();
-            }
         }
 
         // sends a data request to the closest replica, and a digest request to the others. If we have a speculating
diff --git a/src/java/org/apache/cassandra/service/reads/AbstractReadExecutor.java b/src/java/org/apache/cassandra/service/reads/AbstractReadExecutor.java
index ea0b06c8f6..5f73bc696d 100644
--- a/src/java/org/apache/cassandra/service/reads/AbstractReadExecutor.java
+++ b/src/java/org/apache/cassandra/service/reads/AbstractReadExecutor.java
@@ -17,9 +17,6 @@
  */
 package org.apache.cassandra.service.reads;
 
-import java.util.List;
-import java.util.stream.Collectors;
-
 import com.google.common.base.Preconditions;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -48,6 +45,7 @@ import org.apache.cassandra.service.StorageProxy.LocalReadRunnable;
 import org.apache.cassandra.service.reads.repair.ReadRepair;
 import org.apache.cassandra.tracing.TraceState;
 import org.apache.cassandra.tracing.Tracing;
+import org.apache.cassandra.utils.FBUtilities;
 
 import static com.google.common.collect.Iterables.all;
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
@@ -210,11 +208,9 @@ public abstract class AbstractReadExecutor
             return new SpeculatingReadExecutor(cfs, command, replicaPlan, queryStartNanoTime);
     }
 
-    public List<String> getContactedReplicas() {
-        return replicaPlan().contacts()
-                            .stream()
-                            .map(r -> r.endpoint().getHostAddress(true))
-                            .collect(Collectors.toList());
+    public boolean hasLocalRead()
+    {
+        return replicaPlan().lookup(FBUtilities.getBroadcastAddressAndPort()) != null;
     }
 
     /**
diff --git a/test/unit/org/apache/cassandra/metrics/ClientRequestMetricsTest.java b/test/unit/org/apache/cassandra/metrics/ClientRequestMetricsTest.java
index e4f9646f67..2982bebec1 100644
--- a/test/unit/org/apache/cassandra/metrics/ClientRequestMetricsTest.java
+++ b/test/unit/org/apache/cassandra/metrics/ClientRequestMetricsTest.java
@@ -20,6 +20,7 @@ package org.apache.cassandra.metrics;
 
 import java.io.IOException;
 
+import org.junit.AfterClass;
 import org.junit.BeforeClass;
 import org.junit.Test;
 
@@ -39,12 +40,10 @@ import static org.junit.Assert.assertEquals;
 
 public class ClientRequestMetricsTest extends SchemaLoader
 {
-    private static EmbeddedCassandraService cassandra;
-
     private static Cluster cluster;
     private static Session session;
 
-    private static String KEYSPACE = "junit";
+    private static final String KEYSPACE = "junit";
     private static final String TABLE = "clientrequestsmetricstest";
 
     private static PreparedStatement writePS;
@@ -60,7 +59,7 @@ public class ClientRequestMetricsTest extends SchemaLoader
     {
         Schema.instance.clear();
 
-        cassandra = new EmbeddedCassandraService();
+        EmbeddedCassandraService cassandra = new EmbeddedCassandraService();
         cassandra.start();
 
         cluster = builder().addContactPoint("127.0.0.1").withPort(DatabaseDescriptor.getNativeTransportPort()).build();
@@ -75,6 +74,12 @@ public class ClientRequestMetricsTest extends SchemaLoader
         readPS = session.prepare("SELECT * FROM " + KEYSPACE + '.' + TABLE + " WHERE id=?;");
         readRangePS = session.prepare("SELECT * FROM " + KEYSPACE + '.' + TABLE + " WHERE id=? AND ord>=? AND ord <= ?;");
     }
+    
+    @AfterClass
+    public static void teardown()
+    {
+        cluster.close();
+    }
 
     @Test
     public void testWriteStatement()
@@ -158,10 +163,10 @@ public class ClientRequestMetricsTest extends SchemaLoader
 
     private static class ClientRequestMetricsContainer
     {
-        private ClientRequestMetrics metrics;
+        private final ClientRequestMetrics metrics;
 
-        private long localRequests;
-        private long remoteRequests;
+        private final long localRequests;
+        private final long remoteRequests;
 
         public ClientRequestMetricsContainer(ClientRequestMetrics clientRequestMetrics)
         {
