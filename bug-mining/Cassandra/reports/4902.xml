<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 23:09:43 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[CASSANDRA-12373] 3.0 breaks CQL compatibility with super columns families</title>
                <link>https://issues.apache.org/jira/browse/CASSANDRA-12373</link>
                <project id="12310865" key="CASSANDRA">Apache Cassandra</project>
                    <description>&lt;p&gt;This is a follow-up to &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-12335&quot; title=&quot;Super columns are broken after upgrading to 3.0 on thrift&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-12335&quot;&gt;&lt;del&gt;CASSANDRA-12335&lt;/del&gt;&lt;/a&gt; to fix the CQL side of super column compatibility.&lt;/p&gt;

&lt;p&gt;The details and a proposed solution can be found in the comments of &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-12335&quot; title=&quot;Super columns are broken after upgrading to 3.0 on thrift&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-12335&quot;&gt;&lt;del&gt;CASSANDRA-12335&lt;/del&gt;&lt;/a&gt; but the crux of the issue is that super column famillies show up differently in CQL in 3.0.x/3.x compared to 2.x, hence breaking backward compatibilty.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12994614">CASSANDRA-12373</key>
            <summary>3.0 breaks CQL compatibility with super columns families</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="10002" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.svg">Normal</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="ifesdjeen">Alex Petrov</assignee>
                                    <reporter username="slebresne">Sylvain Lebresne</reporter>
                        <labels>
                    </labels>
                <created>Wed, 3 Aug 2016 15:16:40 +0000</created>
                <updated>Tue, 14 Oct 2025 12:13:57 +0000</updated>
                            <resolved>Mon, 25 Sep 2017 11:15:42 +0000</resolved>
                                        <fixVersion>3.0.15</fixVersion>
                    <fixVersion>3.11.1</fixVersion>
                    <fixVersion>4.0-alpha1</fixVersion>
                    <fixVersion>4.0</fixVersion>
                                    <component>Legacy/CQL</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>11</watches>
                                                                                                                <comments>
                            <comment id="15555025" author="ifesdjeen" created="Fri, 7 Oct 2016 13:03:35 +0000"  >&lt;p&gt;I&apos;ve started collecting information on what needs to be done. I just want to clarify the behaviour first:&lt;/p&gt;

&lt;p&gt;We would like to change the way schema and the resultset are currently represented (instead of the &lt;tt&gt;&quot;&quot; map&amp;lt;key_type, value_type&amp;gt;&lt;/tt&gt; to two actual columns: &lt;tt&gt;column&amp;lt;number&amp;gt;&lt;/tt&gt; (depending on the current clustering key size) and &lt;tt&gt;value&lt;/tt&gt;, just as it was presented in example in &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-12335&quot; title=&quot;Super columns are broken after upgrading to 3.0 on thrift&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-12335&quot;&gt;&lt;del&gt;CASSANDRA-12335&lt;/del&gt;&lt;/a&gt;, although preserve their internal representation (internally, map type will still be used for storage).&lt;/p&gt;

&lt;p&gt;In CQL terms&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;CREATE TABLE tbl (
	key ascii,
	column1 ascii,
	&quot;&quot; map&amp;lt;&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt;, ascii&amp;gt;,
	PRIMARY KEY (key, column1))
	AND COMPACT STORAGE
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;would return results in form of  &lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt; key          | column1 | column2 | value  |
--------------+---------+---------+--------+
 key1         | val1    | 1       | value1 |
 key1         | val1    | 2       | value2 |
 key1         | val1    | 3       | value3 |
 key1         | val2    | 1       | value1 |
 key1         | val2    | 2       | value2 |
 key1         | val2    | 3       | value3 |
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;(note that &lt;tt&gt;column2&lt;/tt&gt; is not clustering as &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=slebresne&quot; class=&quot;user-hover&quot; rel=&quot;slebresne&quot;&gt;slebresne&lt;/a&gt; described in comment).&lt;/p&gt;

&lt;p&gt;And this kind of special-casing will be valid for both read and write paths.&lt;/p&gt;</comment>
                            <comment id="15568738" author="slebresne" created="Wed, 12 Oct 2016 13:39:49 +0000"  >&lt;blockquote&gt;&lt;p&gt;We would like to change the way schema and the resultset are currently represented&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Actually, we don&apos;t want to touch the schema. That is, to be precise, this ticket shouldn&apos;t change how anything is stored internally, and shouldn&apos;t thus change the schema tables. This does mean that fixing the output of &lt;tt&gt;DESCRIBE&lt;/tt&gt; is actually not a direct part of this ticket, as I believe it&apos;s implemented by the python nowadays. We would however encourage drivers to special case super column familes too so that they expose &lt;tt&gt;tbl&lt;/tt&gt; table of your example as:&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;CREATE TABLE tbl (
        key ascii,
        column1 ascii,
        column2 int,
        value ascii,
        PRIMARY KEY (key, column1, column2)
) WITH COMPACT STORAGE;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;and that&apos;s indeed how we want the table to behave.&lt;br/&gt;
would return results in form of&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;would return results in form of&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes, that&apos;s what we want. But this goes beyond just result-sets, we want the table to behave exactly as if it was the definition from above, namely that we&apos;ll allow queries like&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;INSERT INTO tbl (key, column1, column2, value) VALUES (...);
SELECT value FROM tbl WHERE key = &apos;key1&apos; AND column1 = &apos;val1&apos; AND column2 = 2;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;but we will &lt;b&gt;not&lt;/b&gt; allow&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;INSERT INTO tbl (key, column1, &quot;&quot;) VALUES (....);
SELECT &quot;&quot; FROM tbl WHERE key = &apos;key1&apos; AND column1 = &apos;val1&apos;;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In general though, the best description of what we want this ticket to do is that any CQL query on a super column table should behave in 3.0/3.x &lt;em&gt;exactly&lt;/em&gt; as it behaved in 2.x. Which highlight the fact that we have no CQL tests for super columns, and a first step could be to write a decent coverage and test it on 2.x. And then we get it to work on 3.0/3.x.&lt;/p&gt;

&lt;p&gt;I&apos;ll note that as I said in &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-12335&quot; title=&quot;Super columns are broken after upgrading to 3.0 on thrift&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-12335&quot;&gt;&lt;del&gt;CASSANDRA-12335&lt;/del&gt;&lt;/a&gt;, this means we&apos;ll probably need to intercept INSERT/UPDATE and SELECT (raw) statements on super column table early and basically rewrite them to match the internal representation, plus post-processing result sets. It would be really nice if we could keep all that code reasonably encapsulated too. &lt;/p&gt;</comment>
                            <comment id="15568868" author="ifesdjeen" created="Wed, 12 Oct 2016 14:25:21 +0000"  >&lt;blockquote&gt;&lt;p&gt;Actually, we don&apos;t want to touch the schema.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Right. I&apos;ve tried to fix my wording (you might have seen the edits), but it was still imprecise. &lt;/p&gt;

&lt;p&gt;Thank you for confirming the results format. I&apos;m mostly done with &lt;tt&gt;SELECT&lt;/tt&gt; special-casing, just need to run a bit more tests to make sure that all the cases are covered. Will move to adding &lt;tt&gt;2.x&lt;/tt&gt; tests and then to &lt;tt&gt;INSERT/UPDATE&lt;/tt&gt;.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;It would be really nice if we could keep all that code reasonably encapsulated too.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Gladly, most of time we just need a &lt;tt&gt;ResultSet&lt;/tt&gt;, &lt;tt&gt;Partition&lt;/tt&gt; and &lt;tt&gt;CFMetaData&lt;/tt&gt;, so keeping this code aside should not be a big problem. We could do it similar to &lt;tt&gt;CompactTables&lt;/tt&gt; class.&lt;/p&gt;</comment>
                            <comment id="15568953" author="iamaleksey" created="Wed, 12 Oct 2016 14:57:26 +0000"  >&lt;p&gt;What we want/need to do re:schema is change python- and java- drivers, but that&apos;s about it.&lt;/p&gt;</comment>
                            <comment id="15568968" author="JIRAUSER308715" created="Wed, 12 Oct 2016 15:02:37 +0000"  >&lt;p&gt;Don&apos;t forget the &quot;snapshot&quot; schema changing code.&lt;/p&gt;</comment>
                            <comment id="15571193" author="slebresne" created="Thu, 13 Oct 2016 07:57:22 +0000"  >&lt;blockquote&gt;&lt;p&gt;What we want/need to do re:schema is change python- and java- drivers&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Right, didn&apos;t meant nothing has to be done, just that it wasn&apos;t part of this patch (nor C* really). I&apos;ll mark &quot;client-impacting&quot; in fact, so clients are aware they have something to do here too.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Don&apos;t forget the &quot;snapshot&quot; schema changing code.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Well, that&apos;s kind of an interesting point because there is in fact currently &lt;b&gt;no&lt;/b&gt; way to create a super column table from CQL. That&apos;s kind of on purpose, we do not want people to create them nowadays, we only want to maintain backward compatibility, but it does mean if you need to restore a snapshot of a super column table, you have to currently use thrift. So I don&apos;t known, maybe in the short term saying that we don&apos;t save schema for snapshot at all for super column table is the &quot;most honest&quot; solution.&lt;/p&gt;

&lt;p&gt;But it kind of suggest to me that we should get &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-10857&quot; title=&quot;Allow dropping COMPACT STORAGE flag from tables in 3.X&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-10857&quot;&gt;&lt;del&gt;CASSANDRA-10857&lt;/del&gt;&lt;/a&gt; in ASAP, and then force users to use it on super column tables before upgrading to 4.0. It&apos;s not ideal, but I don&apos;t dragging super columns support forever is a better solution either.&lt;/p&gt;</comment>
                            <comment id="15571299" author="ifesdjeen" created="Thu, 13 Oct 2016 08:43:50 +0000"  >&lt;p&gt;While discussing &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-7190&quot; title=&quot;Add schema to snapshot manifest&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-7190&quot;&gt;&lt;del&gt;CASSANDRA-7190&lt;/del&gt;&lt;/a&gt;, we decided to opt-out from writing custom schema loading format (and tool) and just CQL, so now we can only load things that are &quot;CQL-expressible&quot;. In schema file we do &quot;best effort&quot;, so we say &quot;so here&apos;s what it kind of looks like internally, but there&apos;s actually no way to re-create that in CQL&quot;. We may just leave the schema file &lt;a href=&quot;https://github.com/apache/cassandra/blob/trunk/test/unit/org/apache/cassandra/db/ColumnFamilyStoreCQLHelperTest.java#L680-L691&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;as is&lt;/a&gt; for now.&lt;/p&gt;</comment>
                            <comment id="15585042" author="ifesdjeen" created="Tue, 18 Oct 2016 09:49:25 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=slebresne&quot; class=&quot;user-hover&quot; rel=&quot;slebresne&quot;&gt;slebresne&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=iamaleksey&quot; class=&quot;user-hover&quot; rel=&quot;iamaleksey&quot;&gt;iamaleksey&lt;/a&gt; do we want to support things like materialized views? &lt;/p&gt;

&lt;p&gt;(sorry about modification storm). &lt;/p&gt;</comment>
                            <comment id="15591861" author="ifesdjeen" created="Thu, 20 Oct 2016 13:49:23 +0000"  >&lt;p&gt;I&apos;ve implemented a &lt;em&gt;preliminary&lt;/em&gt; version of the patch (supercolum counters are still in progress):&lt;/p&gt;

&lt;div class=&apos;table-wrap&apos;&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://github.com/ifesdjeen/cassandra/tree/12373-trunk-squashed&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;trunk&lt;/a&gt;&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://cassci.datastax.com/view/Dev/view/ifesdjeen/job/ifesdjeen-12373-trunk-squashed-dtest/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;dtest&lt;/a&gt;&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://cassci.datastax.com/view/Dev/view/ifesdjeen/job/ifesdjeen-12373-trunk-squashed-testall/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;utest&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://github.com/ifesdjeen/cassandra/tree/12373-2.2-squashed&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;2.2&lt;/a&gt;&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://cassci.datastax.com/view/Dev/view/ifesdjeen/job/ifesdjeen-12373-2.2-squashed-dtest/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;dtest&lt;/a&gt;&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://cassci.datastax.com/view/Dev/view/ifesdjeen/job/ifesdjeen-12373-2.2-squashed-testall/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;utest&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://github.com/ifesdjeen/cassandra-dtest/tree/12373&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;dtest patch&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;


&lt;p&gt;Should we include support for filtering, LWTs and materialized views? This is going to be some additional work because of column mappings / making fake columns available everywhere. Since we&apos;re bringing them back mostly to let people migrate to 3.x storage, I&apos;d suggest leaving these three pieces out. What do you think?&lt;/p&gt;</comment>
                            <comment id="15592068" author="iamaleksey" created="Thu, 20 Oct 2016 15:06:24 +0000"  >&lt;blockquote&gt;&lt;p&gt;Should we include support for filtering, LWTs and materialized views?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The minimal requirement is to have the functionality present in 2.1.x/2.2.x restored - for people who migrated their supercolumn-using apps from Thrift to CQL and might already be using certain CQL features with those tables in their code. MVs weren&apos;t part of it, LWT and filtering - not sure.&lt;/p&gt;</comment>
                            <comment id="15592857" author="ifesdjeen" created="Thu, 20 Oct 2016 20:10:20 +0000"  >&lt;p&gt;Thank you. LWTs &lt;a href=&quot;https://github.com/ifesdjeen/cassandra/blob/b769e22899ff09dfaa598270121d3dba07dfebc3/test/unit/org/apache/cassandra/cql3/validation/ThriftIntegrationTest.java#L234-L243&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;didn&apos;t work&lt;/a&gt;, filtering &lt;a href=&quot;https://github.com/ifesdjeen/cassandra/blob/b769e22899ff09dfaa598270121d3dba07dfebc3/test/unit/org/apache/cassandra/cql3/validation/ThriftIntegrationTest.java#L220-L232&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;didn&apos;t work either&lt;/a&gt;, although due to different reasons. I&apos;ll just add SuperColumn-specific error messages then. &lt;/p&gt;</comment>
                            <comment id="15604830" author="ifesdjeen" created="Tue, 25 Oct 2016 09:55:48 +0000"  >&lt;p&gt;I hope I&apos;ve covered all the corner cases. A small note on the implementation: currently I&apos;m using hardcoded column names &lt;tt&gt;column2&lt;/tt&gt; and &lt;tt&gt;value&lt;/tt&gt; for the fake columns. If you think that can lead to some sort of collision or problem, we can try relying on column name generation from &lt;tt&gt;CompactTables&lt;/tt&gt;, although it&apos;s going to be more or less same. These columns are not persisted together with the rest of schema, they&apos;re completely virtual and created during &lt;tt&gt;CFMetadata&lt;/tt&gt; construction.&lt;/p&gt;

&lt;p&gt;As &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=slebresne&quot; class=&quot;user-hover&quot; rel=&quot;slebresne&quot;&gt;slebresne&lt;/a&gt; mentioned, &lt;tt&gt;SelectStatement&lt;/tt&gt;, &lt;tt&gt;UpdateStatement&lt;/tt&gt; and &lt;tt&gt;DeleteStatement&lt;/tt&gt; were modified to special-case supercolumns, converting from map to two columns and reverse.&lt;/p&gt;

&lt;div class=&apos;table-wrap&apos;&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://github.com/ifesdjeen/cassandra/tree/12373-trunk-squashed&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;trunk&lt;/a&gt;&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://cassci.datastax.com/view/Dev/view/ifesdjeen/job/ifesdjeen-12373-trunk-squashed-dtest/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;dtest&lt;/a&gt;&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://cassci.datastax.com/view/Dev/view/ifesdjeen/job/ifesdjeen-12373-trunk-squashed-testall/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;utest&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://github.com/ifesdjeen/cassandra/tree/12373-3.X-squashed&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;3.X&lt;/a&gt;&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://cassci.datastax.com/view/Dev/view/ifesdjeen/job/ifesdjeen-12373-3.X-squashed-dtest/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;dtest&lt;/a&gt;&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://cassci.datastax.com/view/Dev/view/ifesdjeen/job/ifesdjeen-12373-3.X-squashed-testall/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;utest&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://github.com/ifesdjeen/cassandra/tree/12373-2.2-squashed&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;2.2&lt;/a&gt;&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://cassci.datastax.com/view/Dev/view/ifesdjeen/job/ifesdjeen-12373-2.2-squashed-dtest/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;dtest&lt;/a&gt;&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://cassci.datastax.com/view/Dev/view/ifesdjeen/job/ifesdjeen-12373-2.2-squashed-testall/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;utest&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://github.com/ifesdjeen/cassandra-dtest/tree/12373&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;dtest patch&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;
</comment>
                            <comment id="15606191" author="iamaleksey" created="Tue, 25 Oct 2016 19:09:02 +0000"  >&lt;blockquote&gt;&lt;p&gt;These columns are not persisted together with the rest of schema, they&apos;re completely virtual and created during CFMetadata construction.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I do believe that in 2.1 we currently allow renaming these columns in CQL metadata. For users that have switched from Thrift to CQL for their supercolumns and changed from the default names, losing that metadata on upgrade might count as a breaking change.&lt;/p&gt;</comment>
                            <comment id="15606282" author="ifesdjeen" created="Tue, 25 Oct 2016 19:48:00 +0000"  >&lt;p&gt;You&apos;re right, I&apos;ve just checked and it is in fact possible to rename it since it&apos;s not a part of primary key. &lt;br/&gt;
I hope that won&apos;t change the implementation a whole lot, we just need to pick up the columns during initialisation correctly. I&apos;ll run upgrade tests and check what could be the best way.&lt;/p&gt;

&lt;p&gt;Thanks for catching that.&lt;/p&gt;</comment>
                            <comment id="15608436" author="ifesdjeen" created="Wed, 26 Oct 2016 13:19:59 +0000"  >&lt;p&gt;I&apos;ve added a possible fix for that. In order to allow column renames, we have to change &lt;tt&gt;LegacySchemaMigrator&lt;/tt&gt; to pass the columns from older versions in case of supercolumn family. In 3.0, however, they&apos;re removed from &lt;tt&gt;clustering&lt;/tt&gt; and &lt;tt&gt;regular&lt;/tt&gt; and converted back to fake &quot;virtual&quot; columns (with corresponding &lt;tt&gt;KIND&lt;/tt&gt; and name, in order to avoid them popping up in queries. Already upgraded tables will still work, even though their schema doesn&apos;t have the second clustering and compact value columns, as they&apos;re initialised as fake columns if missing.&lt;/p&gt;</comment>
                            <comment id="15693869" author="iamaleksey" created="Thu, 24 Nov 2016 17:35:26 +0000"  >&lt;p&gt;Reviewing this next. Can you please rebase for most recent 3.X, just in case? Cheers.&lt;/p&gt;</comment>
                            <comment id="15701923" author="ifesdjeen" created="Mon, 28 Nov 2016 13:10:52 +0000"  >&lt;p&gt;Rebased all branches, links are updated above.&lt;/p&gt;</comment>
                            <comment id="15761691" author="ifesdjeen" created="Mon, 19 Dec 2016 16:55:20 +0000"  >&lt;p&gt;Previous patch had problems with renames of dense supercf (was a result of my assumption that renames would work &lt;br/&gt;
similar to how they&apos;d normally work in 3.x, although it&apos;s possible to rename all 4 columns in dense supercf and pk parts&lt;br/&gt;
 in sparse). Thanks &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=iamaleksey&quot; class=&quot;user-hover&quot; rel=&quot;iamaleksey&quot;&gt;iamaleksey&lt;/a&gt; for clarifying sparse/dense semantics in the context of super-cf. &lt;/p&gt;

&lt;p&gt;Without renames, it was quite simple to sort out the supercolumn families, since the columns were always purely virtual.&lt;br/&gt;
With renames, it got a bit more difficult and several problems appeared:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;difference between sparse and dense causes trouble during upgrade (since in once case we have multiple&lt;br/&gt;
regular rows, so we can&apos;t add the supercf key to regulars, since we won&apos;t be able to differentiate it later)&lt;/li&gt;
	&lt;li&gt;denseness calculation for supercf (because of the empty name map column) was causing errors during upgrade&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;There were several other smaller things, all covered in the patch.&lt;/p&gt;

&lt;div class=&apos;table-wrap&apos;&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://github.com/ifesdjeen/cassandra/tree/12373-3.X&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;3.X&lt;/a&gt;&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://cassci.datastax.com/view/Dev/view/ifesdjeen/job/ifesdjeen-12373-3.X-dtest/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;dtest&lt;/a&gt;&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://cassci.datastax.com/view/Dev/view/ifesdjeen/job/ifesdjeen-12373-3.X-testall/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;utest&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://github.com/ifesdjeen/cassandra/tree/12373-2.2&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;2.2&lt;/a&gt;&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://cassci.datastax.com/view/Dev/view/ifesdjeen/job/ifesdjeen-12373-2.2-dtest/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;dtest&lt;/a&gt;&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://cassci.datastax.com/view/Dev/view/ifesdjeen/job/ifesdjeen-12373-2.2-testall/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;utest&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://github.com/ifesdjeen/cassandra-dtest/tree/12373&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;dtest patch&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;


&lt;p&gt;I didn&apos;t update trunk because of the &lt;a href=&quot;https://github.com/apache/cassandra/commit/4881d9c308ccd6b5ca70925bf6ebedb70e7705fc&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;4881d9c308ccd6b5ca70925bf6ebedb70e7705fc&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="16024948" author="iamaleksey" created="Thu, 25 May 2017 16:15:56 +0000"  >&lt;p&gt;Tests LGTM, feel free to commit them separately - I think it&apos;d be cleaner this way, anyway.&lt;/p&gt;

&lt;p&gt;Sill thinking through some potential edge cases for the main path on 3.X (to be applied to 3.0.X as well).&lt;/p&gt;

&lt;p&gt;Thanks.&lt;/p&gt;</comment>
                            <comment id="16090121" author="ifesdjeen" created="Mon, 17 Jul 2017 17:23:59 +0000"  >&lt;p&gt;I&apos;ll rebase on top of the latest branches as it seems like the patch has gotten a bit out of date.&lt;/p&gt;</comment>
                            <comment id="16094434" author="ifesdjeen" created="Thu, 20 Jul 2017 09:38:06 +0000"  >&lt;p&gt;Rebased on top of &lt;tt&gt;3.0&lt;/tt&gt; and &lt;tt&gt;3.11&lt;/tt&gt;. Since we&apos;re doing this patch in the preparation for 4.0 where there&apos;ll be no thrift, supercolumnfamiles or compact tables, we do not need a trunk patch (only removing last bits of supercolumnfamilies and compact tables from code if there are any).&lt;/p&gt;

&lt;div class=&apos;table-wrap&apos;&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://github.com/apache/cassandra/compare/cassandra-3.0...ifesdjeen:12373-3.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;3.0&lt;/a&gt;&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://github.com/apache/cassandra/compare/cassandra-3.11...ifesdjeen:12373-3.11&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;3.11&lt;/a&gt;&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://github.com/riptano/cassandra-dtest/compare/master...ifesdjeen:12373&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;dtest&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;


&lt;p&gt;&lt;tt&gt;3.0&lt;/tt&gt; and &lt;tt&gt;3.11&lt;/tt&gt; patches are quite similar but not exactly the same. In 3.0 there are fewer tests (due to the missing features) and there was a difference in &lt;tt&gt;SelectStatement&lt;/tt&gt; since &lt;tt&gt;processPartitions&lt;/tt&gt; is called from two places there. Not sure if we needed to abstract/hide it. &lt;/p&gt;

&lt;p&gt;CI results, including upgrade tests look good.&lt;/p&gt;</comment>
                            <comment id="16137023" author="slebresne" created="Tue, 22 Aug 2017 16:23:51 +0000"  >&lt;p&gt;The general approach lgtm, but I think there is problems around dealing with &apos;dense&apos; versus &apos;non-dense&apos;.&lt;/p&gt;

&lt;p&gt;Those things are a bit complicated however, and frankly under-documented, so allow me first to remind what &apos;dense&apos; and &apos;non dense&apos; mean for super column families (SCF in what follows), to make sure we&apos;re on the same page.&lt;/p&gt;

&lt;p&gt;The first important thing to note is that contrarily to other &lt;tt&gt;COMPACT STORAGE&lt;/tt&gt; tables, the value of the &lt;tt&gt;is_dense&lt;/tt&gt; flag doesn&apos;t impact the internal layout of a SCF, neither in 2.x nor in 3.x. What it does impact however (in 2.x so far at least) is how the SCF is exposed through CQL, and that&apos;s what we&apos;re trying to make work in this ticket (and it must work in the same way than in 2.x) .&lt;/p&gt;

&lt;p&gt;So the definition of being &quot;dense&quot; for a SCF in 2.x is that the user hasn&apos;t added any column in the thrift &lt;tt&gt;column_metadata&lt;/tt&gt; of that SCF. Which equivalently means that &lt;tt&gt;is_dense == true&lt;/tt&gt; if a SCF has no &lt;tt&gt;REGULAR&lt;/tt&gt; columns internally.&lt;/p&gt;

&lt;p&gt;With that defined, the impact on CQL is the following:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;a &quot;dense&quot; SCF having no &lt;tt&gt;REGULAR&lt;/tt&gt; column, CQL exposes each &quot;thrift column&quot; of the SCF as an individual CQL row. So if you take a dense SCF containing something the following (using imaged representation of a thrift SCF here, hopefully it&apos;s clear what I mean):
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;&apos;k&apos; : {
    &apos;sc1&apos; : {
        &apos;a&apos; : 1,
        &apos;b&apos; : 2,
        &apos;c&apos; : 2,
    },
    &apos;sc2&apos;: {
        &apos;b&apos; : &apos;3&apos;
    }
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;then this is exposed in CQL as:&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;key | column1 | column2 | value
----+---------+---------+-------
&apos;k&apos; |   &apos;sc1&apos; |     &apos;a&apos; |     1
&apos;k&apos; |   &apos;sc1&apos; |     &apos;b&apos; |     2
&apos;k&apos; |   &apos;sc1&apos; |     &apos;c&apos; |     2
&apos;k&apos; |   &apos;sc2&apos; |     &apos;b&apos; |     3
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/li&gt;
	&lt;li&gt;a &quot;non dense&quot; SCF however only exposes through CQL the values of &quot;thrift columns&quot; that belong to a defined thrift &lt;tt&gt;column_metadata&lt;/tt&gt;. So considering the same SCF example, but saying that SCF is now non dense because the user has defined {{column_metadata=[
{column_name: b, validation_class: UTF8Type}
&lt;p&gt;]}}, then that SCF will be exposed in CQL as&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;key | column1 | b
----+---------+---
&apos;k&apos; |   &apos;sc1&apos; | 2
&apos;k&apos; |   &apos;sc2&apos; | 3
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Note in particular that any value not associated to a non-declared &lt;tt&gt;column_metadata&lt;/tt&gt; is simply not exposed: it&apos;s there internally, but not accessible through CQL.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I&apos;ll note at this point that the &quot;why&quot; this is done this way is unimportant here, we are way way past changing any of this. This is how things work in 2.x however and the only goal here is to make it work the same way in 3.x so user can upgrade without problems.&lt;/p&gt;


&lt;p&gt;Anyway, back to the patch, I think there is 2 problems:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;the methods in &lt;tt&gt;SuperColumnCompatibility&lt;/tt&gt; don&apos;t seem to handle non-dense super columns properly. Typically, I haven&apos;t actually tested, but from reading the code I believe that for my example above (using the non dense case where &apos;b&apos; is the only defined column) would yield something like:
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;key | column1 | b
----+---------+---
&apos;k&apos; |   &apos;sc1&apos; | 2
&apos;k&apos; |   &apos;sc1&apos; | 2
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;which is, well, not what 2.x does.&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;I believe 3.x hasn&apos;t been setting the &lt;tt&gt;is_dense&lt;/tt&gt; flag so far (which went unnoticed because, as said above, that flag only influence CQL in the case of SCF, and that hasn&apos;t working in 3.x so far). More precisely, I believe all SCF currently have their &lt;tt&gt;is_dense&lt;/tt&gt; flag set to &lt;tt&gt;false&lt;/tt&gt; in 3.x. And while the attached patch correctly fixes this issue &lt;em&gt;for upgrades from 2.x&lt;/em&gt;, it&apos;s too late for cluster already upgraded to 3.x. And that&apos;s unfortunate because if I&apos;m not mistaken, the schema migration process from 3.x has unintentionally erased the information we need to correct that problem. More precisely, the way to recognize a dense SCF in 2.1 is that is has no &lt;tt&gt;REGULAR&lt;/tt&gt; column definitions internally, but dense SCF in 2.1 had a &lt;tt&gt;COMPACT_VALUE&lt;/tt&gt; column definition, and in the 3.x schema migration code, we have converted that to &lt;tt&gt;REGULAR&lt;/tt&gt;. In other words, if on 3.x we have a SCF with a single &lt;tt&gt;REGULAR&lt;/tt&gt; column definition, we cannot really know with certainty if it&apos;s a dense SCF whose &lt;tt&gt;COMPACT_VALUE&lt;/tt&gt; has been converted to a &lt;tt&gt;REGULAR&lt;/tt&gt;, or a genuinely non-dense SCF with a single user-declared definition. I can&apos;t currently think of a good solution to that problem. We can play some guessing game using a few assumptions and hope no user will break those assumptions but I wanted to open up the discussion on that problem before delving into bad solutions in case someone has an actually good solution.&lt;/li&gt;
&lt;/ol&gt;



&lt;p&gt;Other than that, I only have a few very minor remarks:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;I believe the last line of the class javadoc (&quot;On write path, ...&quot;) of &lt;tt&gt;SuperColumnCompatibility&lt;/tt&gt; has been truncated.&lt;/li&gt;
	&lt;li&gt;Hardcoding &quot;column2&quot; and &quot;value&quot; in &lt;tt&gt;SuperColumnCompatibility&lt;/tt&gt; could theoretically clash with some use defined column names. There is code in &lt;tt&gt;CompactTables&lt;/tt&gt; that&apos;s meant to deal with that and it probably make sense to reuse that.&lt;/li&gt;
	&lt;li&gt;Nit: Talking of &lt;tt&gt;CompactTables&lt;/tt&gt;, there is a few super columns related stuffs, maybe it&apos;s worth moving some of that (possibly including the part of the class javadoc that explains SuperColumn) to &lt;tt&gt;SuperColumnCompatibility&lt;/tt&gt; so it&apos;s easier to locate and most super column stuffs are in one place.&lt;/li&gt;
	&lt;li&gt;Nit: I&apos;d probably merge &lt;tt&gt;getSuperCfKeyColumn()&lt;/tt&gt; with &lt;tt&gt;makeSuperCfKeyColumn()&lt;/tt&gt; and &lt;tt&gt;getSuperCfValueColumn()&lt;/tt&gt; with &lt;tt&gt;makeSuperCfValueColumn()&lt;/tt&gt;, as least as far as the &quot;public&quot; API of &lt;tt&gt;SuperColumnFamily&lt;/tt&gt; is concerned (really just to keep things as encapsulated as possible).&lt;/li&gt;
	&lt;li&gt;Nit: Patch adds a few unused imports in &lt;tt&gt;SelectStatement&lt;/tt&gt;.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="16137056" author="JIRAUSER308715" created="Tue, 22 Aug 2017 17:00:26 +0000"  >&lt;blockquote&gt;&lt;p&gt;I&apos;ll note at this point that the &quot;why&quot; this is done this way is unimportant here, we are way way past changing any of this. This is how things work in 2.x however and the only goal here is to make it work the same way in 3.x so user can upgrade without problems.&lt;/p&gt;&lt;/blockquote&gt;


&lt;p&gt;I agree we need to expose these the same way in 3.x, but one thing to remember is that in 2.x non SCF tables worked the same way, but in 3.x we started exposing the defined columns as &quot;static&quot; and the undefined ones as column1/value. Is there a similar way to expose all the data for SCF?&lt;/p&gt;</comment>
                            <comment id="16138350" author="slebresne" created="Wed, 23 Aug 2017 13:39:14 +0000"  >&lt;blockquote&gt;&lt;p&gt;but in 3.x we started exposing the defined columns as &quot;static&quot; and the undefined ones as column1/value.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That&apos;s not exactly true. It&apos;s how we handle CS tables internally, but it&apos;s not how they are exposed. That&apos;s where &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-10857&quot; title=&quot;Allow dropping COMPACT STORAGE flag from tables in 3.X&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-10857&quot;&gt;&lt;del&gt;CASSANDRA-10857&lt;/del&gt;&lt;/a&gt; come in, as it&apos;s goal is exactly to allow exposing that internal layout and this will work for all compact tables, SCF included (and yes, all the data will be exposed this way). &lt;/p&gt;</comment>
                            <comment id="16138397" author="JIRAUSER308715" created="Wed, 23 Aug 2017 14:08:05 +0000"  >&lt;blockquote&gt;&lt;p&gt;That&apos;s where &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-10857&quot; title=&quot;Allow dropping COMPACT STORAGE flag from tables in 3.X&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-10857&quot;&gt;&lt;del&gt;CASSANDRA-10857&lt;/del&gt;&lt;/a&gt; come in, as it&apos;s goal is exactly to allow exposing that internal layout and this will work for all compact tables, SCF included (and yes, all the data will be exposed this way).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/thumbs_up.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="16146940" author="ifesdjeen" created="Wed, 30 Aug 2017 09:20:30 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=slebresne&quot; class=&quot;user-hover&quot; rel=&quot;slebresne&quot;&gt;slebresne&lt;/a&gt; thank you for the review.&lt;/p&gt;

&lt;p&gt;I have fixed the problems with dense/non-dense supercolumns. It looks like from the CQL perspective non-dense SC tables are treated as if they were &quot;normal&quot; tables, since the internal map column isn&apos;t revealed through the CQL operations in any way. Of course, from the thrift perspective this is quite different. While going through the patch I&apos;ve noticed several more problems, namely: &lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;counters were not fully supported (they did work for the reads, however writes were not functional)&lt;/li&gt;
	&lt;li&gt;LWTs were not working&lt;/li&gt;
	&lt;li&gt;&lt;tt&gt;SELECT&lt;/tt&gt; queries with the supercolumn key restriction was working incorrectly&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;There were several more smaller fixes. All these things are now covered with tests. I&apos;ve also updated the patch with your suggestions. Pushed the changes to the &lt;a href=&quot;https://github.com/apache/cassandra/compare/cassandra-3.0...ifesdjeen:12373-3.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;3.0&lt;/a&gt; branch to possibly save some cycles. 3.11 rebase should be relatively easy, with some minor changes. &lt;a href=&quot;https://github.com/apache/cassandra/compare/cassandra-2.2...ifesdjeen:12373-2.2&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;2.2&lt;/a&gt; version of branch contains updated tests to make the comparison with an older version simpler. &lt;/p&gt;</comment>
                            <comment id="16153401" author="slebresne" created="Tue, 5 Sep 2017 09:51:32 +0000"  >&lt;p&gt;Thanks for the update and great job on the much needed additional testing. I think we&apos;re getting there but I still have a bunch of remarks &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;In &lt;tt&gt;CFMetaData&lt;/tt&gt;
	&lt;ul&gt;
		&lt;li&gt;In the ctor, for &lt;tt&gt;isDense&lt;/tt&gt;, we seem to force recomputation for non-SC non-dense tables (which happens to include non-compact tables). I don&apos;t think thats what we want (and the &lt;tt&gt;recalculateIsDense&lt;/tt&gt; is obviously meant only for SC). But for I&apos;m also not 100% sure this work in all upgrade scenario. Typically, if a dense SCF is upgraded to a current 3.x version, I believe it will end up with 2 regular column definition: the first coming from the fact 2.x will have had a &quot;COMPACT_VALUE&quot; column definition, which will become a REGULAR when upgraded, and second being the &quot;super column map&quot; column that is force-added to all SCF. And so that re-computation code will not detect things properly. Note that I haven&apos;t actually tested this tbh so I could be wrong, but this highlight that we really need to be running some SC upgrade dtest both for &lt;tt&gt;2.x &amp;#45;&amp;gt; 3.x+&amp;lt;this patch&amp;gt;&lt;/tt&gt; and &lt;tt&gt;2.x &amp;#45;&amp;gt; current 3.x &amp;#45;&amp;gt; 3.x+&amp;lt;this patch&amp;gt;&lt;/tt&gt; because things are imo too complex to rely on reasoning alone.  Unfortunately, while we were supposed to have a &lt;a href=&quot;https://github.com/apache/cassandra-dtest/blob/master/upgrade_tests/upgrade_supercolumns_test.py&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;SC upgrade dtests&lt;/a&gt;, it appears &lt;a href=&quot;https://github.com/apache/cassandra-dtest/commit/7f47d4d82d6becdb9fd267bd3844d32aee6acdea&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;this commit&lt;/a&gt; has made this test useless by making it (confusingly) not about super column families. So we&apos;ll need to revert that commit somehow and the improve the test to include both dense and sparse SC.&lt;/li&gt;
		&lt;li&gt;In &lt;tt&gt;rebuild()&lt;/tt&gt;, why not move the SC code after &lt;tt&gt;columnMetadata&lt;/tt&gt; has been populated so it can be simplified? Nothing seems to rely on it being done &lt;em&gt;before&lt;/em&gt; &lt;tt&gt;columnMetadata&lt;/tt&gt; is populated.&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;I&apos;m not entirely sure if/how column renaming works for the SC key and value &quot;fake&quot; column (would have assumed &lt;tt&gt;AlterTableStatement&lt;/tt&gt; would need a least a bit of special casing to recognize those &quot;fake&quot; column). It would be nice to add at test to check that renames still work like in 2.2 for those columns.&lt;/li&gt;
	&lt;li&gt;In &lt;tt&gt;UpdateParameters#addCounter&lt;/tt&gt;, not sure the change from &lt;tt&gt;CounterContext#createUpdate&lt;/tt&gt; to &lt;tt&gt;CounterContext#createLocal&lt;/tt&gt; is corret. Probably a bad post-&lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-13691&quot; title=&quot;Fix incorrect [2.1 &amp;lt;&#8212; 3.0] serialization of counter cells with pre-2.1 local shards&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-13691&quot;&gt;&lt;del&gt;CASSANDRA-13691&lt;/del&gt;&lt;/a&gt; rebase?&lt;/li&gt;
	&lt;li&gt;In {{SuperColumnCompatibility}:
	&lt;ul&gt;
		&lt;li&gt;The first line of the javadoc states that it&apos;s only for &quot;dense&quot; SC, but it&apos;s not 100% true as things like &lt;tt&gt;SUPER_COLUMN_MAP_COLUMN&lt;/tt&gt; are used for all SC. And the rest of the javadoc describing the internal layout also applies to all SC. Bit of a detail I suppose, but I&apos;d rephrase things to avoid any confusion.&lt;/li&gt;
		&lt;li&gt;In &lt;tt&gt;getSuperCfKeyColumn&lt;/tt&gt;, not sure what &quot;3.x-created supercolumn family&quot; refers to (is that SC tables created from thrift in 3.x? or SC tables whose schema had been upgraded by a previous 3.x version?) and more importantly, why it would differ in number of clustering columns?&lt;/li&gt;
		&lt;li&gt;I&apos;m confused by the code of &lt;tt&gt;getSuperCfValueColumn&lt;/tt&gt;: dense tables are supposed to have only a single regular column, and &lt;tt&gt;cfm.compactValueColumn()&lt;/tt&gt; is supposed to alias it. So I&apos;m not sure what the loop is trying to do, except basically returning &lt;tt&gt;cfm.compactValueColumn()&lt;/tt&gt;, nor when that loop wouldn&apos;t return (all SC should have the &quot;super column map&quot; internally.  Further, due to what&apos;s above, said loop appears to return a definition whose type is the &lt;tt&gt;MapType&lt;/tt&gt;, while the code following it clearly return a definition whose type is the values of said &lt;tt&gt;MapType&lt;/tt&gt;, so it feels wrong the method would return different kind of types depending on the path taken. I&apos;m most likely missing something since your tests seem to be working, but I&apos;m not sure what.&lt;/li&gt;
		&lt;li&gt;In &lt;tt&gt;processPartition&lt;/tt&gt;:
		&lt;ul&gt;
			&lt;li&gt;There is a typo in a comment, where in &quot;... can&apos;t be change to support inclusive slice ...&quot;, I believe you want &quot;exclusive&quot;.&lt;/li&gt;
			&lt;li&gt;In the &lt;tt&gt;REGULAR&lt;/tt&gt; branch of the &lt;tt&gt;switch&lt;/tt&gt;:
			&lt;ul&gt;
				&lt;li&gt;in the 2nd branch (&lt;tt&gt;else if ...&lt;/tt&gt;), we should use &lt;tt&gt;result.add(cell)&lt;/tt&gt; directly.  Not only does that already handle counters, but more importantly, if we don&apos;t do that, things like &lt;tt&gt;ttl(v)&lt;/tt&gt; will not work on the compact column value.&lt;/li&gt;
				&lt;li&gt;the last &lt;tt&gt;else&lt;/tt&gt; is confusing: by definition we shouldn&apos;t be exposing any other column than the &quot;compact value&quot; column, so that branch should probably not be there (or be an assertion that we shouldn&apos;t get there).&lt;/li&gt;
			&lt;/ul&gt;
			&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
		&lt;li&gt;In the &lt;tt&gt;updates&lt;/tt&gt; loop in &lt;tt&gt;prepareUpdateOperations&lt;/tt&gt;, not sure why the 2 first cases seem to assume that &lt;tt&gt;cfm.isSuperColumnValueColumn(def)&lt;/tt&gt;, but the 3rd case tests it explicitely (but after having assigned &lt;tt&gt;superColumnValue&lt;/tt&gt;).  In general, not sure why the 3rd case looks different from the other 2. Also, I find it a bit hard to follow the mix of &lt;tt&gt;if&lt;/tt&gt; using &lt;tt&gt;continue&lt;/tt&gt; and sometime using &lt;tt&gt;else&lt;/tt&gt;, sometimes not. I&apos;m personally prefer using &lt;tt&gt;else&lt;/tt&gt; when needed and remove all the &lt;tt&gt;continue&lt;/tt&gt;.  Lastly, seems the method could use a check for &lt;tt&gt;superColumnKey != null&lt;/tt&gt;.&lt;/li&gt;
		&lt;li&gt;In &lt;tt&gt;prepareInsertForJSONOperations&lt;/tt&gt;, I believe the 2nd call to &lt;tt&gt;getRawTermForColumn&lt;/tt&gt; is unecessary, you can use the &lt;tt&gt;raw&lt;/tt&gt; for before the &lt;tt&gt;if&lt;/tt&gt;. Further, the overall code of this method feels &lt;em&gt;very&lt;/em&gt; similar to the one in &lt;tt&gt;prepareInsertOperations&lt;/tt&gt;: can we extract the bulk of what&apos;s common? (the loop seems to be operating on a &lt;tt&gt;ColumnDefinition&lt;/tt&gt; and the associated value, so either pass an Iterable&amp;lt;Pair&amp;lt;...&amp;gt;&amp;gt;, or build 2 lists; I don&apos;t think we care about the performance difference here).&lt;/li&gt;
		&lt;li&gt;Nit: &lt;tt&gt;getSuperColumnKeyRelation&lt;/tt&gt; can be private.&lt;/li&gt;
		&lt;li&gt;In &lt;tt&gt;prepareDeleteOperations&lt;/tt&gt;, need to fix the &quot;Maybe not single only&quot; comment. Either &lt;tt&gt;IN&lt;/tt&gt; weren&apos;t suppored for this in 2.x and it&apos;s enough to make sure it&apos;s still refused, or we should support it (note: maybe this is already tested and is something that wan&apos;t allowed in 2.x anyway; if so, let&apos;s updated or remove the comment).&lt;/li&gt;
		&lt;li&gt;Code style and minor nits:
		&lt;ul&gt;
			&lt;li&gt;the 2 lines doing &lt;tt&gt;if (v instanceof AbstractMarker.Raw) boundNames.add(...);&lt;/tt&gt; are done enough time that a simple helper might streamline this.&lt;/li&gt;
			&lt;li&gt;In &lt;tt&gt;rebuildLWTConditions&lt;/tt&gt;, I&apos;d invert the initial &lt;tt&gt;if&lt;/tt&gt; check (making it, imo, easier to read) with a direct return and &quot;de-indent&quot; the bulk of the method. Also, I&apos;d remove the &lt;tt&gt;columnConditions.clear()&lt;/tt&gt;: doesn&apos;t feel useful, and feels weird to do it here (what if we make that collection immutable in future?).&lt;/li&gt;
			&lt;li&gt;In &lt;tt&gt;isSuperColumnMapColumn&lt;/tt&gt;, can replace the first condition by &lt;tt&gt;ColumnDefinition#isRegular&lt;/tt&gt; (not something due to this patch, but a good occasion to simplify).&lt;/li&gt;
			&lt;li&gt;for &apos;if-then-else&apos;, we never use brakets for one of the branch and not another (meaning that we only skip brackets if all of the branches are one-liner). There is violations to that rule in at least &lt;tt&gt;processPartition&lt;/tt&gt;, &lt;tt&gt;getColumnFilter&lt;/tt&gt;, &lt;tt&gt;prepareUpdateOperations&lt;/tt&gt; and &lt;tt&gt;prepareDeleteOperations&lt;/tt&gt;.&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;In &lt;tt&gt;SelectStatement&lt;/tt&gt;, I believe that if you move the &lt;tt&gt;SuperColumnCompatibility#processPartition&lt;/tt&gt; call at the beginning of &lt;tt&gt;SelectStatement#processPartition&lt;/tt&gt;, you&apos;d be able to remove the specific call in &lt;tt&gt;ModificationStatement#buildCasFailureResultSet&lt;/tt&gt; (and generally reduce the changes of misuses).&lt;/li&gt;
	&lt;li&gt;Slightly bummed by the addition of the SC special fields in &lt;tt&gt;StatementRestrictions&lt;/tt&gt;. Can&apos;t we move most of this in &lt;tt&gt;SuperColumnCompatibility#getColumnFilter&lt;/tt&gt;, by extracting things there (tbc, I&apos;m genuninely not sure how easy change that is, and if it&apos;s too convoluted, I&apos;m fine leaving things as they are; I just prefer having a much special casing in &lt;tt&gt;SuperColumnCompatibility&lt;/tt&gt; as possible. I also assume we can&apos;t entirely remove all special casing from &lt;tt&gt;StatementRestrictions&lt;/tt&gt; since we will at least make sure it doesn&apos;t complain about requiring &lt;tt&gt;ALLOW FILTERING&lt;/tt&gt; if we leave the &quot;superColumnKeyColumn&quot; restriciton in)?&lt;/li&gt;
	&lt;li&gt;In &lt;tt&gt;ModificationStatement&lt;/tt&gt; why not directly use &lt;tt&gt;cfm.superCfValueColumn&lt;/tt&gt; instead of looping over &lt;tt&gt;cfm.allColumnsInSeelectOrder()&lt;/tt&gt; to find it?&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="16160985" author="ifesdjeen" created="Mon, 11 Sep 2017 09:36:56 +0000"  >&lt;blockquote&gt;&lt;p&gt;In the ctor, for isDense, we seem to force re-computation for non-SC non-dense tables (which happens to include non-compact tables).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Corrected it. This didn&apos;t cause any trouble (because was checking for an empty name, too), but now we&apos;ll recompute only for the supercolumn ones, which is much better.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;But for I&apos;m also not 100% sure this work in all upgrade scenario.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Thing is the re-computation is necessary only for the upgrade from 2.x -&amp;gt; current 3.x -&amp;gt; 3.x + this patch, in which case we have two clustering columns instead of one just a single &quot;empty&quot; value column, which is a collection. 3.x-created supercolumns are calculated correctly &lt;a href=&quot;https://github.com/apache/cassandra/blob/cassandra-3.0/src/java/org/apache/cassandra/thrift/ThriftConversion.java#L184&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;You are right that some testing in that regard won&apos;t hurt, so I&apos;ve added some 3-step upgrade tests with the scenarios similar to the current one. For the sakes of completeness, I&apos;ve also added a test for current 3.x -created supercolumn families. &lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Unfortunately, while we were supposed to have a SC upgrade dtests&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;ve added some dtests as well as upgrade tests.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I&apos;m not entirely sure if/how column renaming works for the SC key and value &quot;fake&quot; column&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;You&apos;re right: I did leave it off as I thought read/write path is the only support that&apos;s required for migrating off SCF, but adding this is trivial. I&apos;ve added tests for all sorts of renames. However, there is no special-casing done in &lt;tt&gt;AlterStatement&lt;/tt&gt;: &lt;tt&gt;getColumnDefinition&lt;/tt&gt; would return the &quot;fake&quot; columns as well. &lt;tt&gt;removeColumn&lt;/tt&gt; would be a no-op in case of fake columns and adding column would force re-initialisation and the new column would get picked up correctly.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;In UpdateParameters#addCounter, not sure the change from CounterContext#createUpdate to CounterContext#createLocal is corret.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes, sorry, I have overlooked it. &lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;In getSuperCfKeyColumn, not sure what &quot;3.x-created supercolumn family&quot; refers to (is that SC tables created from thrift in 3.x? or SC tables whose schema had been upgraded by a previous 3.x version?) and more importantly, why it would differ in number of clustering columns?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;You are right, SC columns created from Thrift in 3.x. When upgrading from 2.x, you&apos;ll get &lt;tt&gt;column1&lt;/tt&gt; and &lt;tt&gt;column2&lt;/tt&gt; as clustering keys (which they kind of are). When created via thrift in 3.x, &lt;tt&gt;column2&lt;/tt&gt; is entirely virtual (which it kind of is).&#160;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;There is a typo in a comment, where in &quot;... can&apos;t be change to support inclusive slice ...&quot;, I believe you want &quot;exclusive&quot;.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Fixed.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;in the 2nd branch (else if ...), we should use result.add(cell) directly. Not only does that already handle counters, but more importantly, if we don&apos;t do that, things like ttl(v) will not work on the compact column value.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Good point. Fixed.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;the last else is confusing: by definition we shouldn&apos;t be exposing any other column than the &quot;compact value&quot; column, so that branch should probably not be there (or be an assertion that we shouldn&apos;t get there).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;You&apos;re right. This is an artefact of the previous incorrect dense table handling.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;In the updates loop in prepareUpdateOperations, not sure why the 2 first cases seem to assume that cfm.isSuperColumnValueColumn(def), but the 3rd case tests it explicitely (but after having assigned superColumnValue). In general, not sure why the 3rd case looks different from the other 2. Also, I find it a bit hard to follow the mix of if using continue and sometime using else, sometimes not. I&apos;m personally prefer using else when needed and remove all the continue. Lastly, seems the method could use a check for superColumnKey != null.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;ve refactored this method even further. There were many things that were technically correct, but were added on earlier stages, so got there historically. Also, did a bit of further improvements with &lt;tt&gt;collectMarkerSpecifications&lt;/tt&gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;In prepareInsertForJSONOperations, I believe the 2nd call to getRawTermForColumn is unecessary, you can use the raw for before the if. Further, the overall code of this method feels very similar to the one in prepareInsertOperations: can we extract the bulk of what&apos;s common? (the loop seems to be operating on a ColumnDefinition and the associated value, so either pass an Iterable&amp;lt;Pair&amp;lt;...&amp;gt;&amp;gt;, or build 2 lists; I don&apos;t think we care about the performance difference here).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Refactored this part as well.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;In prepareDeleteOperations, need to fix the &quot;Maybe not single only&quot; comment. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think what was meant was &quot;not only &lt;tt&gt;SingleColumnRelation&lt;/tt&gt;&quot;, but this is not true: multi column operations are not allowed. After writing more tests, I did discover that multi-column restrictions were not working properly, so I have added support for them. Also, for IN queries.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;n rebuildLWTConditions, I&apos;d invert the initial if check (making it, imo, easier to read) with a direct return and &quot;de-indent&quot; the bulk of the method. Also, I&apos;d remove the columnConditions.clear(): doesn&apos;t feel useful, and feels weird to do it here (what if we make that collection immutable in future?).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Good point, fixed&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;In isSuperColumnMapColumn, can replace the first condition by ColumnDefinition#isRegular (not something due to this patch, but a good occasion to simplify).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Fixed &lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;In SelectStatement, I believe that if you move the SuperColumnCompatibility#processPartition call at the beginning of SelectStatement#processPartition, you&apos;d be able to remove the specific call in ModificationStatement#buildCasFailureResultSet (and generally reduce the changes of misuses).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Fixed&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;for &apos;if-then-else&apos;, we never use brakets for one of the branch and not another (meaning that we only skip brackets if all of the branches are one-liner). &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I hope I&apos;ve fixed all the instances.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Slightly bummed by the addition of the SC special fields in StatementRestrictions. Can&apos;t we move most of this in SuperColumnCompatibility#getColumnFilter, by extracting things there (tbc, I&apos;m genuninely not sure how easy change that is, and if it&apos;s too convoluted, I&apos;m fine leaving things as they are; I just prefer having a much special casing in SuperColumnCompatibility as possible. I also assume we can&apos;t entirely remove all special casing from StatementRestrictions since we will at least make sure it doesn&apos;t complain about requiring ALLOW FILTERING if we leave the &quot;superColumnKeyColumn&quot; restriciton in)?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I agree this did not look pretty. At the time of writing that felt like it made sense. But after the current refactoring, I had to switch most of the things to restrictions anyways, and there are now more different special cases, so I have opted out for a class that would hold all the restriction special-cases. I&apos;ve added a lot of documentation inline, hope this should suffice. &lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;In ModificationStatement why not directly use cfm.superCfValueColumn instead of looping over cfm.allColumnsInSeelectOrder() to find it?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Good point, simplified that one, too.&lt;/p&gt;


&lt;p&gt;A word on the latest changes in the patch: because we have to support &lt;em&gt;all&lt;/em&gt; &lt;tt&gt;ALTER&lt;/tt&gt; statements that are supported by 2.x, we got a bit more logic in &lt;tt&gt;getSuper(CfKey|Value)Column&lt;/tt&gt; now. Also, rebuild was changed in order to avoid accidentally dropping the fake columns, since we have to make sure they do get persisted. In order to properly interface 2.x nodes, there are several special-cases in &lt;tt&gt;CFMetadata&lt;/tt&gt; to make sure we compose &lt;tt&gt;Selection&lt;/tt&gt; correctly. Another big change is the way &lt;tt&gt;WHERE&lt;/tt&gt; clauses are handled, pretty much everywhere. Biggest reason for it is that previous way (having public variables in &lt;tt&gt;StatementRestrictions&lt;/tt&gt; was too ad-hoc and many use-cases were missing. Now we can correctly remap multi-column restrictions on SC key (both EQ and slice), slice (and EQ) restrictions on the SC key and IN restriction. All of them are handled somewhat differently and some require filtering on the very last stage. Where possible I&apos;ve tried to use collection bounds. &lt;/p&gt;</comment>
                            <comment id="16163085" author="slebresne" created="Tue, 12 Sep 2017 15:03:48 +0000"  >&lt;p&gt;The one main remaining things I&apos;m not sure about is that it seems possible to have different schema (meaning, content of schema tables) for what is essentially the same table, depending on how it was created/upgraded.  Namely, it appears a dense SCF may have 1 or 2 clustering and may or may not have definitions for the so-called super column &quot;key&quot; and &quot;values&quot; columns.&lt;/p&gt;

&lt;p&gt;This makes it hard, at least to me, to reason about things and have confidence it always work as expected. This also feels error prone in the future. Typically, most code is written expecting that &lt;tt&gt;CFMetaData.primaryKeyColumns()&lt;/tt&gt; would always be equals to &lt;tt&gt;CFMetaData.partitionKeyColumns() + CFMetaData.clusteringColumns()&lt;/tt&gt;, but that&apos;s not necessarilly the case here for SCF (and whether it&apos;s the case or not really depend more on how the table was created that the table definition). Note that I&apos;m not saying this particular example is a problem today, I believe it&apos;s not, but I&apos;m worried about how fragile this feel.&lt;/p&gt;

&lt;p&gt;So my preference would be to force things to be more consistent. What I mean here is that I would make it so that:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;in the schema tables, every dense SCF table has 2 &lt;tt&gt;CLUSTERING&lt;/tt&gt; (the 1st &quot;true&quot; clustering, and the 2nd standing for the SC &quot;key&quot; column) and 2 &lt;tt&gt;REGULAR&lt;/tt&gt; definition (the SC &quot;map&quot; and the SC &quot;value&quot; column). Note that I think it&apos;s important we save the &quot;key&quot; column as a &lt;tt&gt;CLUSTERING&lt;/tt&gt; one: otherwise, if both the &quot;key&quot; and &quot;value&quot; column definions are &lt;tt&gt;REGULAR&lt;/tt&gt; (as I think they can be in the current patch), you can&apos;t distinguish which is which later one (and I think that&apos;s a current bug of &lt;tt&gt;SuperColumnCompatibility.getSuperCfKeyColumn&lt;/tt&gt;).&lt;/li&gt;
	&lt;li&gt;but at the level of &lt;tt&gt;CFMetaData&lt;/tt&gt;, we extract the &quot;key&quot; and &quot;value&quot; column to their respective field, but otherwise remove them from &lt;tt&gt;clusteringColumns&lt;/tt&gt; and &lt;tt&gt;partitionColumns&lt;/tt&gt;.&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;Other than, a bunch of other largely minor issues:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;In &lt;tt&gt;CFMetaData.renameColumn()&lt;/tt&gt;, we appear to allow renaming every column for any SCF, including non-dense ones. I don&apos;t think that was allowed in 2.x (renaming non-PK columns of non-dense SCF through CQL) and I suggest maintaining non supporting it. In fact, I don&apos;t think it&apos;s entirely safe in some complex case of users still using thrift and doing schema-changes from it.&lt;/li&gt;
	&lt;li&gt;I don&apos;t think the change in &lt;tt&gt;CFMetaData.makeLegacyDefaultValidator&lt;/tt&gt; is correct. That said, I don&apos;t think the previous code was correct either. If I&apos;m not mistaken, what we should be returning in the SCF case is &lt;tt&gt;((MapType)compactValueColumn().type).valueComparator()&lt;/tt&gt;.&lt;/li&gt;
	&lt;li&gt;In &lt;tt&gt;SuperColumnCompatibility.prepareUpdateOperations&lt;/tt&gt;, after the first loop, I think we should check that &lt;tt&gt;superColumnKey != null&lt;/tt&gt; (and provide a meaningful error message if that&apos;s not the case). I believe otherwise we might NPE when handling the {{Operation}}s created.&lt;/li&gt;
	&lt;li&gt;In &lt;tt&gt;SuperColumnCompatibility.columnNameGenerator&lt;/tt&gt;, I&apos;m not sure I fully understand the reason for always excluding &lt;tt&gt;&quot;column1&quot;&lt;/tt&gt; (despite the comment). Not that it&apos;s really a big deal.&lt;/li&gt;
	&lt;li&gt;In &lt;tt&gt;SuperColumnCompatiblity.SuperColumnRestrictions&lt;/tt&gt;, regarding the different javadoc:
	&lt;ul&gt;
		&lt;li&gt;for the class javadoc, since things are tricky, when saying &quot;the default column names are used&quot;, I think that&apos;s a good place to remind what &quot;column1&quot; and &quot;column2&quot; means, and that both in term of the internal representation, of their CQL exposure, and of the thrift correspondance. Or maybe move such explanation to the &lt;tt&gt;SuperColumnCompatibility&lt;/tt&gt; class javadoc and point to it?&lt;/li&gt;
		&lt;li&gt;for &lt;tt&gt;mutliEQRestriction&lt;/tt&gt; should be &lt;tt&gt;... AND (column1, column2) = (&apos;value1&apos;, 1)&lt;/tt&gt; but it currently uses a &lt;tt&gt;&amp;gt;&lt;/tt&gt;.&lt;/li&gt;
		&lt;li&gt;for &lt;tt&gt;keyInRestriction&lt;/tt&gt;, the &quot;This operation does &lt;em&gt;not&lt;/em&gt; have a direct Thrift counterpart&quot; isn&apos;t true. And In fact, I&apos;m not sure why we have to fetch everything and filter: can&apos;t we just handle this in &lt;tt&gt;getColumnFilter&lt;/tt&gt; by only selecting the map entries we want? Note that the one operation that does not have a Thrift counterpart is &lt;tt&gt;mutliSliceRestriction&lt;/tt&gt; (and, technically, anything operation on strict bounds since Thrift was always inclusive).&lt;/li&gt;
		&lt;li&gt;for &lt;tt&gt;keyEQRestriction&lt;/tt&gt;, I believe &quot;in `getRowFilter`&quot; is supposed to be &quot;in `getColumnFilter`&quot;. Using a &quot;{@link}&quot; probably wouldn&apos;t hurt either &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;.&lt;/li&gt;
		&lt;li&gt;Nit: there is a few typo in those comments (&quot;prece*e*ding&quot; instead of &quot;preceding&quot;, &quot;exlusive&quot;, &quot;enitre&quot;, &quot;... in this case since, since ...&quot;).&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;And a few nitpicks:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;in &lt;tt&gt;MultiColumnRelation&lt;/tt&gt;, both methods have &lt;tt&gt;List&amp;lt;ColumnDefinition&amp;gt; receivers = receivers(cfm)&lt;/tt&gt;, but then in the next line, they call &lt;tt&gt;receivers(cfm)&lt;/tt&gt; instead of just reusing &lt;tt&gt;receivers&lt;/tt&gt;.&lt;/li&gt;
	&lt;li&gt;In &lt;tt&gt;Relation&lt;/tt&gt;, I&apos;d extend the error message to something like &lt;tt&gt;&quot;Unsupported operation (&quot; + this + &quot;) on super column family&quot;&lt;/tt&gt;.&lt;/li&gt;
	&lt;li&gt;Last &lt;tt&gt;else&lt;/tt&gt; of 2nd loop in &lt;tt&gt;SuperColumnCompatibility.prepareUpdateOperations&lt;/tt&gt; could use brackets &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/li&gt;
	&lt;li&gt;In &lt;tt&gt;MultiColumnRestriction.SliceRestriction&lt;/tt&gt;, if my IDE don&apos;t fool me, it appears we don&apos;t need to make &lt;tt&gt;slice&lt;/tt&gt; public anymore.&lt;/li&gt;
	&lt;li&gt;In &lt;tt&gt;StatementRestrictions&lt;/tt&gt;, a few added imports are not needed (including the &lt;tt&gt;NotImplementedException&lt;/tt&gt; one).&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="16166050" author="ifesdjeen" created="Thu, 14 Sep 2017 10:25:37 +0000"  >&lt;p&gt;Thank you for the review and comments.&lt;/p&gt;

&lt;p&gt;I agree that having &lt;tt&gt;column2&lt;/tt&gt; as clustering is better. I&apos;ve tried to move most of the special-casing to &lt;tt&gt;rebuild&lt;/tt&gt; and &lt;tt&gt;SuperColumnCompatibility&lt;/tt&gt;. I think the patch got a bit cleaner thanks to that.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;In CFMetaData.renameColumn(), we appear to allow renaming every column for any SCF, including non-dense ones. I don&apos;t think that was allowed in 2.x (renaming non-PK columns of non-dense SCF through CQL) and I suggest maintaining non supporting it. In fact, I don&apos;t think it&apos;s entirely safe in some complex case of users still using thrift and doing schema-changes from it.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Fixed and added corresponding tests to both 3.0 and 2.2&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I don&apos;t think the change in CFMetaData.makeLegacyDefaultValidator is correct. That said, I don&apos;t think the previous code was correct either. If I&apos;m not mistaken, what we should be returning in the SCF case is ((MapType)compactValueColumn().type).valueComparator().&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I &lt;em&gt;think&lt;/em&gt; it can be simplified even further, since &lt;tt&gt;isCounter&lt;/tt&gt; case will work is because of the &lt;tt&gt;compactValueColumn&lt;/tt&gt; (or map value type) and &lt;tt&gt;isCompact&lt;/tt&gt; call seems to be redundant alltogether.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;In SuperColumnCompatibility.prepareUpdateOperations, after the first loop, I think we should check that superColumnKey != null (and provide a meaningful error message if that&apos;s not the case). I believe otherwise we might NPE when handling the {{Operation}}s created.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Fixed and added a couple more negative tests.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;In SuperColumnCompatibility.columnNameGenerator, I&apos;m not sure I fully understand the reason for always excluding &quot;column1&quot; (despite the comment). Not that it&apos;s really a big deal.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This is still a bit of a problem, although just in one case. When upgrade was done through unpatched 3.x, we end up without &lt;tt&gt;column2&lt;/tt&gt; and &lt;tt&gt;value&lt;/tt&gt; columns. Now, we try renaming &lt;tt&gt;column1&lt;/tt&gt; to &lt;tt&gt;column1_renamed&lt;/tt&gt;, and, because &lt;tt&gt;column2&lt;/tt&gt; is still &quot;virtual&quot; (since it was not renamed), we may end up with &lt;tt&gt;column2&lt;/tt&gt; being called &lt;tt&gt;column1&lt;/tt&gt; because of the defaults without this line. I&apos;d like to point out that renaming &lt;tt&gt;column2&lt;/tt&gt; to &lt;tt&gt;column2&lt;/tt&gt; and &lt;tt&gt;value&lt;/tt&gt; are not allowed even in that case (since all the columns are now in column metadata map).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;for the class javadoc, since things are tricky, when saying &quot;the default column names are used&quot;, I think that&apos;s a good place to remind what &quot;column1&quot; and &quot;column2&quot; means, and that both in term of the internal representation, of their CQL exposure, and of the thrift correspondance. Or maybe move such explanation to the SuperColumnCompatibility class javadoc and point to it?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Improved comments in header and for this inner class. &lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;for mutliEQRestriction should be ... AND (column1, column2) = (&apos;value1&apos;, 1) but it currently uses a &amp;gt;.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Fixed&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;for keyInRestriction, the &quot;This operation does not have a direct Thrift counterpart&quot; isn&apos;t true. And In fact, I&apos;m not sure why we have to fetch everything and filter: can&apos;t we just handle this in getColumnFilter by only selecting the map entries we want? Note that the one operation that does not have a Thrift counterpart is mutliSliceRestriction (and, technically, anything operation on strict bounds since Thrift was always inclusive).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I was under impression that &lt;tt&gt;ColumnFilter.Builder#select&lt;/tt&gt; allows just a single collection constraint. Thanks for catching that. You&apos;re right, we can handle it without any filtering, looks much better now.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Nit: there is a few typo in those comments (&quot;prece*e*ding&quot; instead of &quot;preceding&quot;, &quot;exlusive&quot;, &quot;enitre&quot;, &quot;... in this case since, since ...&quot;).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Fixed these and spell-checked to catch a couple more.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;in MultiColumnRelation, both methods have List&amp;lt;ColumnDefinition&amp;gt; receivers = receivers(cfm), but then in the next line, they call receivers(cfm) instead of just reusing receivers.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Fixed.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;In Relation, I&apos;d extend the error message to something like &quot;Unsupported operation (&quot; + this + &quot;) on super column family&quot;.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Fixed.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Last else of 2nd loop in SuperColumnCompatibility.prepareUpdateOperations could use brackets &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Fixed this an several other ones.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;In MultiColumnRestriction.SliceRestriction, if my IDE don&apos;t fool me, it appears we don&apos;t need to make slice public anymore.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;You&apos;re right. Fixed.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;In StatementRestrictions, a few added imports are not needed (including the NotImplementedException one).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Fixed this and several other cases.&lt;/p&gt;

&lt;div class=&apos;table-wrap&apos;&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://github.com/apache/cassandra/compare/cassandra-3.0...ifesdjeen:12373-3.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;3.0 patch&lt;/a&gt;&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://github.com/apache/cassandra/compare/cassandra-3.11...ifesdjeen:12373-3.11&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;3.11 patch&lt;/a&gt;&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://github.com/apache/cassandra-dtest/compare/master...ifesdjeen:12373&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;dtests&lt;/a&gt;&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://github.com/apache/cassandra/compare/cassandra-2.2...ifesdjeen:12373-2.2&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;2.2 patch&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;


&lt;p&gt;UPDATE: the latest test runs look clean on both branches.&lt;/p&gt;</comment>
                            <comment id="16172132" author="kohlisankalp" created="Tue, 19 Sep 2017 18:28:31 +0000"  >&lt;p&gt;Is this not too late for 3.0? &lt;/p&gt;</comment>
                            <comment id="16172137" author="iamaleksey" created="Tue, 19 Sep 2017 18:30:32 +0000"  >&lt;p&gt;It&apos;s a case of better late than never. It&apos;s also a necessary JIRA to allow to move to 4.0.&lt;/p&gt;</comment>
                            <comment id="16172976" author="slebresne" created="Wed, 20 Sep 2017 10:16:48 +0000"  >&lt;p&gt;Thanks for the changes and you patience on this. My main remaining remark is that I don&apos;t think we should include the SC key and value columns to &lt;tt&gt;partitionColumns&lt;/tt&gt; (in &lt;tt&gt;CFMetaData.rebuild&lt;/tt&gt;).&lt;/p&gt;

&lt;p&gt;&lt;tt&gt;PartitionColumns&lt;/tt&gt; is meant and used for the columns of the internal storage engine, but the SC key and value columns are &quot;fake&quot; columns used for the CQL translation, they will never have values internally, and so should never reach deep in the storage engine.  Which means they shouldn&apos;t be in &lt;tt&gt;PartitionColumns&lt;/tt&gt;. In fact, I suspect that&apos;s why you needed to have special code in &lt;tt&gt;Columns&lt;/tt&gt; and &lt;tt&gt;SerializationHeader&lt;/tt&gt;, which feels wrong because you shouldn&apos;t ever encounter those definitions that deep in the storage engine.&lt;/p&gt;

&lt;p&gt;Don&apos;t get me wrong, I&apos;m sure there may be a few places in the CQL layers where we rely on &lt;tt&gt;CFMetaData.partitionColumns()&lt;/tt&gt; and need those columns, and that&apos;s probably why you did that, but we imo need to identify those places and special case them.&lt;/p&gt;

&lt;p&gt;Related to this (because due to this), I think the change in &lt;tt&gt;ColumnFamilyStoreCQLHelperTest&lt;/tt&gt; is incorrect: it would be appropriate for &lt;tt&gt;ColumnFamilyStoreCQLHelper&lt;/tt&gt; to either display the storage schema (so no &quot;column2&quot; nor &quot;value&quot;), or the CQL one (so no SCF empty-named map), but something is between is not consistent. Anyway, mainly pointing that we really need to remove those columns from &lt;tt&gt;partitionColumns&lt;/tt&gt; and revert the change in &lt;tt&gt;ColumnFamilyStoreCQLHelperTest&lt;/tt&gt;.&lt;/p&gt;


&lt;p&gt;Other than that, only a few minor remarks:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;In &lt;tt&gt;CFMetaData.renameColumn&lt;/tt&gt;, in the case of updating the SC key or value column, I believe we should be updating &lt;tt&gt;columnMetadata&lt;/tt&gt; as well since those columns are listed in it, but that doesn&apos;t seem to be the case (not sure how important it is, it might be a following call to &lt;tt&gt;rebuild&lt;/tt&gt; fixes that in practice, but since the method doesn&apos;t call &lt;tt&gt;rebuild&lt;/tt&gt; itself, probably better to make sure we handle it).&lt;/li&gt;
	&lt;li&gt;In &lt;tt&gt;CFMetaData.makeLegacyDefaultValidator&lt;/tt&gt;, compact tables with counter will now return &lt;tt&gt;BytesType&lt;/tt&gt; instead of &lt;tt&gt;CounterColumnType&lt;/tt&gt;, which is kind of technically incorrect. To be entirely honest, this doesn&apos;t matter currently because that method isn&apos;t ever called for non-compact tables (and at this point, probably never will), but if we&apos;re going to rely on this, I&apos;d rather make it an assertion than returning something somewhat wrong. Personally, I&apos;d just keep the counter special case and move on, as this has nothing to do with this ticket, but if you prefer transforming it to a &lt;tt&gt;assert !isCompactTable()&lt;/tt&gt;, no complain.&lt;/li&gt;
	&lt;li&gt;Nit: in &lt;tt&gt;CFMetaData.renameColumn&lt;/tt&gt;, the comment &quot;SuperColumn tables allow renaming all columns&quot; doesn&apos;t match the code entirely anymore.&lt;/li&gt;
	&lt;li&gt;Nit: in &lt;tt&gt;CassandraServer.makeColumnFilter&lt;/tt&gt;, it would be more readable to just cut the method short if &lt;tt&gt;metadata.isDense()&lt;/tt&gt; before the loop, with maybe a comment explaining why it&apos;s ok to do so (&quot;Dense table only have dynamic columns&quot;).&lt;/li&gt;
	&lt;li&gt;Nit: in &lt;tt&gt;SuperColumnCompatibility.getSuperCfKeyColumn&lt;/tt&gt;, I don&apos;t think the &quot;3.x created supercolumn family&quot; comment is accurate anymore since in &lt;tt&gt;ThriftConversion&lt;/tt&gt; you now add the 2nd clustering column (which, in itself, lgtm). It might be we need to preserve that branch in &lt;tt&gt;SuperColumnCompatibility.getSuperCfKeyColumn&lt;/tt&gt; for some upgrade path, and happy to do so, but should update the comment.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="16173016" author="ifesdjeen" created="Wed, 20 Sep 2017 11:04:01 +0000"  >&lt;blockquote&gt;&lt;p&gt;Thanks for the changes and you patience on this. My main remaining remark is that I don&apos;t think we should include the SC key and value columns to partitionColumns (in CFMetaData.rebuild).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This was surprisingly simple to do.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;In CFMetaData.renameColumn, in the case of updating the SC key or value column, I believe we should be updating columnMetadata as well since those columns are listed in it, but that doesn&apos;t seem to be the case (not sure how important it is, it might be a following call to rebuild fixes that in practice, but since the method doesn&apos;t call rebuild itself, probably better to make sure we handle it).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I can&apos;t see how this can be helpful because of the subsequent &lt;tt&gt;rebuild&lt;/tt&gt; call, but this also doesn&apos;t break anything, so I went ahead and changed it.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;In CFMetaData.makeLegacyDefaultValidator, compact tables with counter will now return BytesType instead of CounterColumnType, which is kind of technically incorrect. To be entirely honest, this doesn&apos;t matter currently because that method isn&apos;t ever called for non-compact tables (and at this point, probably never will), but if we&apos;re going to rely on this, I&apos;d rather make it an assertion than returning something somewhat wrong. Personally, I&apos;d just keep the counter special case and move on, as this has nothing to do with this ticket, but if you prefer transforming it to a assert !isCompactTable(), no complain.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;ve added the &lt;tt&gt;isCounter&lt;/tt&gt; back, no strong opinion here, too.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Nit: in CFMetaData.renameColumn, the comment &quot;SuperColumn tables allow renaming all columns&quot; doesn&apos;t match the code entirely anymore.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yeah, I was implying dense ones, but I don&apos;t think this comment is of much use here anyways.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Nit: in SuperColumnCompatibility.getSuperCfKeyColumn, I don&apos;t think the &quot;3.x created supercolumn family&quot; comment is accurate anymore since in ThriftConversion you now add the 2nd clustering column (which, in itself, lgtm).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It&apos;s still true for pre-12373 3.x thrift-created supercolumn family tables. We&apos;ve discussed this offline shortly: there was no good way to force the table update to make all the table look completely the same, so this is the only place we still have to special-case. I&apos;ve added the &lt;tt&gt;pre 12373&lt;/tt&gt; remark and hope it&apos;s clearer now.&lt;/p&gt;

&lt;div class=&apos;table-wrap&apos;&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://github.com/apache/cassandra/compare/cassandra-3.0...ifesdjeen:12373-3.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;3.0 patch&lt;/a&gt;&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://github.com/apache/cassandra/compare/cassandra-3.11...ifesdjeen:12373-3.11&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;3.11 patch&lt;/a&gt;&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://github.com/apache/cassandra-dtest/compare/master...ifesdjeen:12373&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;dtests&lt;/a&gt;&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://github.com/apache/cassandra/compare/cassandra-2.2...ifesdjeen:12373-2.2&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;2.2 patch&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;


&lt;p&gt;UPDATE: updated and rebased both branches, CI looks good.&lt;/p&gt;</comment>
                            <comment id="16176370" author="slebresne" created="Fri, 22 Sep 2017 12:56:56 +0000"  >&lt;p&gt;Well, that&apos;s a +1 from me. Great job &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ifesdjeen&quot; class=&quot;user-hover&quot; rel=&quot;ifesdjeen&quot;&gt;ifesdjeen&lt;/a&gt; on this not-too-fun issue.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Is this not too late for 3.0?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;As Aleksey says, but I&apos;ll also add that it&apos;s actually fixing a breaking change from 2.x that could prevent some users from updating, so it really should be 3.0.&lt;/p&gt;</comment>
                            <comment id="16176453" author="iamaleksey" created="Fri, 22 Sep 2017 13:53:49 +0000"  >&lt;p&gt;And thanks from me to you both. I had it assigned to me for review for too long and still couldn&apos;t find enough energy to do it. Sorry. It really is unfun - both to implement and to review. &lt;/p&gt;</comment>
                            <comment id="16178679" author="ifesdjeen" created="Mon, 25 Sep 2017 07:46:55 +0000"  >&lt;p&gt;Thank you for the thorough review &amp;amp; patience &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=slebresne&quot; class=&quot;user-hover&quot; rel=&quot;slebresne&quot;&gt;slebresne&lt;/a&gt;, great job on your side. &lt;/p&gt;

&lt;p&gt;Compatibility tests are committed to 2.2 with &lt;a href=&quot;https://github.com/apache/cassandra/commit/c510e001481637e1f74d9ad176f8dc3ab7ebd1e3&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;c510e001481637e1f74d9ad176f8dc3ab7ebd1e3&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Patch itself is committed to 3.0 with &lt;a href=&quot;https://github.com/apache/cassandra/commit/ce8c9b559f48e72cb4488e75211be338d28bdb13&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;ce8c9b559f48e72cb4488e75211be338d28bdb13&lt;/a&gt;, merged up to &lt;a href=&quot;https://github.com/apache/cassandra/commit/4734ce7d94945126e40ec14c8eb2c305e768c6d1&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;3.11&lt;/a&gt; and &lt;a href=&quot;https://github.com/apache/cassandra/commit/974d8fc099c0f426eea2440783b03e35c13fe528&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;trunk&lt;/a&gt; (trunk is merged with -s ours as agreed).&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10001">
                    <name>dependent</name>
                                                                <inwardlinks description="is depended upon by">
                                        <issuelink>
            <issuekey id="12921716">CASSANDRA-10857</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12313920" key="com.atlassian.jira.plugin.system.customfieldtypes:multiuserpicker">
                        <customfieldname>Authors</customfieldname>
                        <customfieldvalues>
                                    <customfieldvalue><![CDATA[ifesdjeen]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12313825" key="com.atlassian.jira.plugin.system.customfieldtypes:cascadingselect">
                        <customfieldname>Bug Category</customfieldname>
                        <customfieldvalues>
                                                    <customfieldvalue key="12982" cascade-level=""><![CDATA[Correctness]]></customfieldvalue>
                                <customfieldvalue key="12988" cascade-level="1"><![CDATA[API / Semantic Implementation]]></customfieldvalue>
            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            8 years, 8 weeks, 1 day ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i31uyv:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_10022" key="com.atlassian.jira.plugin.system.customfieldtypes:userpicker">
                        <customfieldname>Reviewer</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>slebresne</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12313420" key="com.atlassian.jira.plugin.system.customfieldtypes:multiuserpicker">
                        <customfieldname>Reviewers</customfieldname>
                        <customfieldvalues>
                                    <customfieldvalue><![CDATA[slebresne]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12313820" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Severity</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="12962"><![CDATA[Normal]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>