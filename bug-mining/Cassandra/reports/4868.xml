<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 23:09:13 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[CASSANDRA-11500] Obsolete MV entry may not be properly deleted</title>
                <link>https://issues.apache.org/jira/browse/CASSANDRA-11500</link>
                <project id="12310865" key="CASSANDRA">Apache Cassandra</project>
                    <description>&lt;p&gt;When a Materialized View uses a non-PK base table column in its PK, if an update changes that column value, we add the new view entry and remove the old one. When doing that removal, the current code uses the same timestamp than for the liveness info of the new entry, which is the max timestamp for any columns participating to the view PK. This is not correct for the deletion as the old view entry could have other columns with higher timestamp which won&apos;t be deleted as can easily shown by the failing of the following test:&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;CREATE TABLE t (k int PRIMARY KEY, a int, b int);
CREATE MATERIALIZED VIEW mv AS SELECT * FROM t WHERE k IS NOT NULL AND a IS NOT NULL PRIMARY KEY (k, a);

INSERT INTO t(k, a, b) VALUES (1, 1, 1) USING TIMESTAMP 0;
UPDATE t USING TIMESTAMP 4 SET b = 2 WHERE k = 1;
UPDATE t USING TIMESTAMP 2 SET a = 2 WHERE k = 1;

SELECT * FROM mv WHERE k = 1; // This currently return 2 entries, the old (invalid) and the new one
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So the correct timestamp to use for the deletion is the biggest timestamp in the old view entry (which we know since we read the pre-existing base row), and that is what &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-11475&quot; title=&quot;MV code refactor&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-11475&quot;&gt;&lt;del&gt;CASSANDRA-11475&lt;/del&gt;&lt;/a&gt; does (the test above thus doesn&apos;t fail on that branch).&lt;/p&gt;

&lt;p&gt;Unfortunately, even then we can still have problems if further updates requires us to overide the old entry. Consider the following case:&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;CREATE TABLE t (k int PRIMARY KEY, a int, b int);
CREATE MATERIALIZED VIEW mv AS SELECT * FROM t WHERE k IS NOT NULL AND a IS NOT NULL PRIMARY KEY (k, a);

INSERT INTO t(k, a, b) VALUES (1, 1, 1) USING TIMESTAMP 0;
UPDATE t USING TIMESTAMP 10 SET b = 2 WHERE k = 1;
UPDATE t USING TIMESTAMP 2 SET a = 2 WHERE k = 1; // This will delete the entry for a=1 with timestamp 10
UPDATE t USING TIMESTAMP 3 SET a = 1 WHERE k = 1; // This needs to re-insert an entry for a=1 but shouldn&apos;t be deleted by the prior deletion
UPDATE t USING TIMESTAMP 4 SET a = 2 WHERE k = 1; // ... and we can play this game more than once
UPDATE t USING TIMESTAMP 5 SET a = 1 WHERE k = 1;
...
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In a way, this is saying that the &quot;shadowable&quot; deletion mechanism is not general enough: we need to be able to re-insert an entry when a prior one had been deleted before, but we can&apos;t rely on timestamps being strictly bigger on the re-insert. In that sense, this can be though as a similar problem than &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-10965&quot; title=&quot;Shadowable tombstones can continue to shadow view results when timestamps match&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-10965&quot;&gt;&lt;del&gt;CASSANDRA-10965&lt;/del&gt;&lt;/a&gt;, though the solution there of a single flag is not enough since we can have to replace more than once.&lt;/p&gt;

&lt;p&gt;I think the proper solution would be to ship enough information to always be able to decide when a view deletion is shadowed. Which means that both liveness info (for updates) and shadowable deletion would need to ship the timestamp of any base table column that is part the view PK (so &lt;tt&gt;a&lt;/tt&gt; in the example below).  It&apos;s doable (and not that hard really), but it does require a change to the sstable and intra-node protocol, which makes this a bit painful right now.&lt;/p&gt;

&lt;p&gt;But I&apos;ll also note that as &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-1096&quot; title=&quot;Sequential splits causing unbalanced MapReduce load&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-1096&quot;&gt;&lt;del&gt;CASSANDRA-1096&lt;/del&gt;&lt;/a&gt; shows, the timestamp is not even enough since on equal timestamp the value can be the deciding factor. So in theory we&apos;d have to ship the value of those columns (in the case of a deletion at least since we have it in the view PK for updates). That said, on that last problem, my preference would be that we start prioritizing &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-6123&quot; title=&quot;Break timestamp ties consistently for a given user requests&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-6123&quot;&gt;CASSANDRA-6123&lt;/a&gt; seriously so we don&apos;t have to care about conflicting timestamp anymore, which would make this problem go away.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12956115">CASSANDRA-11500</key>
            <summary>Obsolete MV entry may not be properly deleted</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="10002" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.svg">Normal</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="jasonstack">Zhao Yang</assignee>
                                    <reporter username="slebresne">Sylvain Lebresne</reporter>
                        <labels>
                    </labels>
                <created>Tue, 5 Apr 2016 10:11:06 +0000</created>
                <updated>Fri, 15 May 2020 08:03:26 +0000</updated>
                            <resolved>Tue, 5 Sep 2017 07:55:51 +0000</resolved>
                                        <fixVersion>3.0.15</fixVersion>
                    <fixVersion>3.11.1</fixVersion>
                    <fixVersion>4.0-alpha1</fixVersion>
                    <fixVersion>4.0</fixVersion>
                                    <component>Feature/Materialized Views</component>
                        <due></due>
                            <votes>2</votes>
                                    <watches>17</watches>
                                                                                                                <comments>
                            <comment id="16066749" author="jasonstack" created="Wed, 28 Jun 2017 15:49:29 +0000"  >&lt;blockquote&gt;
&lt;p&gt;we need to be able to re-insert an entry when a prior one had been deleted before, but we can&apos;t rely on timestamps being strictly bigger on the re-insert. In that sense, this can be though as a similar problem than &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-10965&quot; title=&quot;Shadowable tombstones can continue to shadow view results when timestamps match&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-10965&quot;&gt;&lt;del&gt;CASSANDRA-10965&lt;/del&gt;&lt;/a&gt;, though the solution there of a single flag is not enough since we can have to replace more than once.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Agreed.&lt;/p&gt;

&lt;p&gt;&lt;del&gt;How about shipping an extra &quot;view-update-time&quot; (`nowInSecond` that view-operation is triggered) per view row.  it will be used to check who&apos;s new when TS ties.&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;del&gt;The `nowInSeconds` could still be the same in certain cases, but rare, similar to &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-1096&quot; title=&quot;Sequential splits causing unbalanced MapReduce load&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-1096&quot;&gt;&lt;del&gt;CASSANDRA-1096&lt;/del&gt;&lt;/a&gt;&lt;/del&gt;&lt;/p&gt;</comment>
                            <comment id="16082241" author="jasonstack" created="Tue, 11 Jul 2017 14:03:05 +0000"  >&lt;h3&gt;&lt;a name=&quot;Relation%3Abase%3Eview&quot;&gt;&lt;/a&gt;Relation: base -&amp;gt; view&lt;/h3&gt;

&lt;p&gt;First of all, I think all of us should agree on what cases view row should exists.&lt;/p&gt;

&lt;p&gt;IMO, there are two main cases:&lt;/p&gt;

&lt;p&gt;1. base pk and view pk are the same (order doesn&apos;t matter) and view has no filter conditions or only conditions on base pk.&lt;br/&gt;
(filter condition mean: &lt;tt&gt;c = 1&lt;/tt&gt; in view&apos;s where clause. filter condition is not a concern here, since no previous view data to be cleared.)&lt;/p&gt;

&lt;p&gt;view row exists if any of following is true:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;a. base row pk has live livenessInfo(timestamp) and base row pk satifies view&apos;s filter conditions if any.&lt;/li&gt;
	&lt;li&gt;b. or one of base row columns selected in view has live timestamp (via update) and base row pk satifies view&apos;s filter conditions if any. this is handled by existing mechanism of liveness and tombstone since all info are included in view row&lt;/li&gt;
	&lt;li&gt;c. or one of base row columns not selected in view has live timestamp (via update) and base row pk satifies view&apos;s filter conditions if any. Those unselected columns&apos; timestamp/ttl/cell-deletion info are not currently stored on view row.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;2. base column used in view pk or view has filter conditions on base non-key column which can also lead to entire view row being wiped.&lt;/p&gt;

&lt;p&gt;view row exists if any of following is true:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;a. base row pk has live livenessInfo(timestamp) &amp;amp;&amp;amp; base column used in view pk is not null but no timestamp &amp;amp;&amp;amp; conditions are satisfied. ( pk having live livenesInfo means it is not deleted by tombstone)&lt;/li&gt;
	&lt;li&gt;b. or base row column in view pk has timestamp (via update) &amp;amp;&amp;amp; conditions are satisfied. eg. if base column used in view pk is TTLed, entire view row should be wiped.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Next thing is to model &quot;view&apos;s tombstone and livenessInfo&quot; to maintain view data based on above cases.&lt;/p&gt;

&lt;h3&gt;&lt;a name=&quot;Previousknownissues%3A&quot;&gt;&lt;/a&gt;Previous known issues: &lt;/h3&gt;
&lt;p&gt;(I might miss some issues, feel free to ping me..)&lt;/p&gt;

&lt;p&gt;ttl&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;view row is not wiped when TTLed on base column used in view pk or TTLed on base non-key column with filter condition&lt;/li&gt;
	&lt;li&gt;cells with same timestamp, merging ttls are not deterministic.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;partial update on base columns not selected in view&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;it results in no view data. because of current update semantics, no view updates are generated&lt;/li&gt;
	&lt;li&gt;corresponding view row&apos; liveness is not depending on liveness of base columns&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;filter conditions or base column used in view pk causes&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;view row is shadowed after a few modification on base column used in view pk if the base non-key column has TS greater than base pk&apos;s ts and view key column&apos;s ts. (as mentioned by sylvain: we need to be able to re-insert an entry when a prior one had been deleted need to be careful to hanlde timestamp tie)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;tombstone merging is not commutative&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;in current code, shadowable tombstone doesn&apos;t co-exist with regular tombstone&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;sstabledump not supporting current shadowable tombstone&lt;/p&gt;

&lt;h3&gt;&lt;a name=&quot;Model&quot;&gt;&lt;/a&gt;Model&lt;/h3&gt;

&lt;p&gt;I can think of two ways to ship all required base column info to view:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;make base columns that are not selected in view as &quot;virtual cell&quot; and store their imestamp/ttl to view without their actual values. so we can reuse current ts/tb/ttl mechanism with additional validation logic to check if a view row is alive.&lt;/li&gt;
	&lt;li&gt;or storing those info on view&apos;s livenessInfo/deletion with addition merge logic to make sure view liveness/deletion are ordered properly even in the case of timestamp tie. It&apos;s like a replacement stragy which uses inserted view row to replace old view row. (In regular table, reconciliation is at cell level. need to research more about the concurrent view update cases, fow now, it looks fine). It also implies that every modification on base, view row will get replaced entirely..&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I will go ahead with &lt;del&gt;second way since there is an existing shadowable tombstone mechanism.&lt;/del&gt;  VirtualCells to avoid changing low level timestamp comparison..&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;    ColumnInfo: &lt;span class=&quot;code-comment&quot;&gt;// generated from base column as it is.
&lt;/span&gt;        0. timestamp
        1. ttl 
        2. localDeletionTime:  could be used to represent tombstone or TTLed depends on &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; there is ttl

        supersedes(): &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; timestamps are different, greater timestamp supersedes; &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; timestamps are same, greater localDeletionTime supersedes.


    Row: &lt;span class=&quot;code-comment&quot;&gt;// VirtualCells(keyOrConditions and unselected) are always merged with another row&apos;s during row merging process
&lt;/span&gt;
        &lt;span class=&quot;code-comment&quot;&gt;// base column that are used in view pk or has filter condition on non-pk column.
&lt;/span&gt;        &lt;span class=&quot;code-comment&quot;&gt;// &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; any column is not live, entire view row is wiped.
&lt;/span&gt;        &lt;span class=&quot;code-comment&quot;&gt;// &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; a column in base is filtered and not selected, it&apos;s stored here.
&lt;/span&gt;        &lt;span class=&quot;code-comment&quot;&gt;// during base modification, &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; a view row is removed due to base-column-in-view-pk or filter-contiions, then no deletion is issue,
&lt;/span&gt;        &lt;span class=&quot;code-comment&quot;&gt;// the virtual cell tombstone is added to Row&apos;s keyOrConditions.
&lt;/span&gt;        2. Map&amp;lt;ColumnIdentifier, ColumnInfo&amp;gt; keyOrConditions; 

        &lt;span class=&quot;code-comment&quot;&gt;// &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; any column is live
&lt;/span&gt;        &lt;span class=&quot;code-comment&quot;&gt;// during base modification, &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; base columns not selected in view is modified, then no deletion is issue,
&lt;/span&gt;        &lt;span class=&quot;code-comment&quot;&gt;// the virtual cell tombstone is added to Row&apos;s keyOrConditions.
&lt;/span&gt;        3. Map&amp;lt;ColumnIdentifier, ColumnInfo&amp;gt; unselected;

        &lt;span class=&quot;code-comment&quot;&gt;// to determina &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; a row is dead
&lt;/span&gt;        isAliveRow():
            &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; any colummn in {{keyOrConditions}} is TTLed or tombstone(dead) or not existed, &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;
            &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; {{timestamp or ttl}} are alive, &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;
            &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; any column in {{unselected}} is alive, &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;
            otherwise check any columns in view row are alive

        merge(Row): 
            &lt;span class=&quot;code-comment&quot;&gt;// merge 3 parts separates
&lt;/span&gt;            a. &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; LivenessInfo/Deletion/Cells are merged as it is
            b. &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; keyOrConditions, merge by comparing ColumnInfo.supersedes()
            c. &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; unselected, same above

    ShadowableDeletion(now removed)
    Row.Deletion(now removed)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;


&lt;h3&gt;&lt;a name=&quot;Examples&quot;&gt;&lt;/a&gt;Examples&lt;/h3&gt;
&lt;p&gt;(&lt;b&gt;&lt;em&gt;TL;DR;&lt;/em&gt;&lt;/b&gt; validate the model using different tests in each issue)&lt;/p&gt;

&lt;p&gt;Reinserting previous deleted view row(11500)&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;CREATE TABLE t (k &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; PRIMARY KEY, a &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt;, b &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt;);
CREATE MATERIALIZED VIEW mv AS SELECT * FROM t WHERE k IS NOT NULL AND a IS NOT NULL PRIMARY KEY (k, a);

{{q1}} INSERT INTO t(k, a, b) VALUES (1, 1, 1) USING TIMESTAMP 0;
{{q2}} UPDATE t USING TIMESTAMP 10 SET b = 2 WHERE k = 1;
{{q3}} UPDATE t USING TIMESTAMP 2 SET a = 2 WHERE k = 1; 
{{q4}} UPDATE t USING TIMESTAMP 3 SET a = 1 WHERE k = 1;

After {{q1}}:
    base: k=1@0, a=1@0, b=1@0    &lt;span class=&quot;code-comment&quot;&gt;// &lt;span class=&quot;code-quote&quot;&gt;&apos;k&apos;&lt;/span&gt; is having value &lt;span class=&quot;code-quote&quot;&gt;&apos;1&apos;&lt;/span&gt; with timestamp &lt;span class=&quot;code-quote&quot;&gt;&apos;0&apos;&lt;/span&gt;
&lt;/span&gt;    view:
        sstable1:  VC(keyOrConditions{a@0}, unselected:{}) (k=1&amp;amp;&amp;amp;a=1)@liveness(ts@0) b=1@0   &lt;span class=&quot;code-comment&quot;&gt;//VC-&amp;gt; virtualCells
&lt;/span&gt;
After {{q2}}:
    base(merged):   (k=1@0, a=1@0, b=2@10)
    view:
        sstable1:   VC(keyOrConditions{a@0}, unselected:{}) (k=1&amp;amp;&amp;amp;a=1)@liveness(ts@0) b=1@0  
        sstable2:   VC(keyOrConditions{a@0}, unselected:{}) (k=1&amp;amp;&amp;amp;a=1)@liveness(no_ts) b=2@10  &lt;span class=&quot;code-comment&quot;&gt;// the VC here could be ommitted since it&apos;s not changed
&lt;/span&gt;        or merged:  VC(keyOrConditions{a@0}, unselected:{}) (k=1&amp;amp;&amp;amp;a=1)@liveness(ts@0) b=2@10

After {{q3}}:
    base(merged):   (k=1@0, a=2@2, b=2@10)
    view:
        sstable1:   VC(keyOrConditions{a@0}, unselected:{}) (k=1&amp;amp;&amp;amp;a=1)@liveness(ts@0) b=1@0 
        sstable2:   VC(keyOrConditions{a@0}, unselected:{}) (k=1&amp;amp;&amp;amp;a=1)@liveness(no_ts) b=2@10  
        sstable3:  
                    VC(keyOrConditions{a@tb0}, unselected:{}) (k=1&amp;amp;&amp;amp;a=1)  &lt;span class=&quot;code-comment&quot;&gt;// row deletion caused by switch_entry
&lt;/span&gt;                    VC(keyOrConditions{a@2}, unselected:{}) (k=1&amp;amp;&amp;amp;a=2)@liveness(ts@0) b=2@10
        or merged: 
                    VC(keyOrConditions{a@tb0}, unselected:{}) (k=1&amp;amp;&amp;amp;a=1) 
                    VC(keyOrConditions{a@2}, unselected:{}) (k=1&amp;amp;&amp;amp;a=2)@liveness(ts@0) b=2@10

After {{q4}}:
    base(merged):   (k=1@0, a=1@3, b=2@10)
    view:
        sstable1:   VC(keyOrConditions{a@0}, unselected:{}) (k=1&amp;amp;&amp;amp;a=1)@liveness(ts@0) b=1@0 
        sstable2:   VC(keyOrConditions{a@0}, unselected:{}) (k=1&amp;amp;&amp;amp;a=1)@liveness(no_ts) b=2@10  
        sstable3:  
                    VC(keyOrConditions{a@tb0}, unselected:{}) (k=1&amp;amp;&amp;amp;a=1)
                    VC(keyOrConditions{a@2}, unselected:{}) (k=1&amp;amp;&amp;amp;a=2)@liveness(ts@0) b=2@10
        sstable4:   
                    VC(keyOrConditions{a@3}, unselected:{}) (k=1&amp;amp;&amp;amp;a=1)@liveness(ts@0) b=2@10
                    VC(keyOrConditions{a@tb2}, unselected:{}) (k=1&amp;amp;&amp;amp;a=2)
        or merged: 
                    VC(keyOrConditions{a@3}, unselected:{}) (k=1&amp;amp;&amp;amp;a=1)@liveness(ts@0) b=2@10
                    VC(keyOrConditions{a@tb2}, unselected:{}) (k=1&amp;amp;&amp;amp;a=2)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;based column used in view key is TTLed (13657)&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;CREATE TABLE t (k &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt;, a &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt;, b &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt;, PRIMARY KEY (k));
CREATE MATERIALIZED VIEW mv AS SELECT * FROM t WHERE k IS NOT NULL AND a IS NOT NULL PRIMARY KEY (a, k);

{{q1}} INSERT INTO t (k) VALUES (1);
{{q2}} UPDATE t USING TTL 5 SET a = 10 WHERE k = 1;
{{q3}} UPDATE t SET b = 100 WHERE k = 1;

After q1:
    base: k=1@t1
    view: no view updates generated because no existing view data

After q2:
    base(merged):  k=1@t1, a=10@(t2, ttl@5)
    view:          VC(keyOrConditions{a:(ts@t2, ttl@5) }, unselected:{}) (k=1&amp;amp;&amp;amp;a=10)@liveness(ts@t1)

After q2:
    base(merged):  k=1@t1, a=10@(t2, ttl@5), b=100@t3
    view:          
        sstable1:  VC(keyOrConditions{a:(ts@t2, ttl@5) }, unselected:{}) (k=1&amp;amp;&amp;amp;a=10)@liveness(ts@t1)
        sstable2:  VC(keyOrConditions{a:(ts@t2, ttl@5) }, unselected:{}) (k=1&amp;amp;&amp;amp;a=10) b=100@t3
        or merged: VC(keyOrConditions{a:(ts@t2, ttl@5) }, unselected:{}) (k=1&amp;amp;&amp;amp;a=10)@liveness(ts@t1) b=100@t3

5 seconds later, view row is considered removed becuase {{keyOrConditions-a}} is TTLed.

&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;


&lt;p&gt;View row expires too fast with unselected base column (13127)&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
CREATE TABLE ks.base (p &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt;, c &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt;, v &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt;, PRIMARY KEY (p, c)); 
CREATE MATERIALIZED VIEW ks.mv AS SELECT p, c FROM base WHERE p IS NOT NULL AND c IS NOT NULL PRIMARY KEY (c, p); 

{{q1}} INSERT INTO ks.base (p, c) VALUES (0, 0) USING TTL 3; 
{{q2}} UPDATE ks.base USING TTL 100 SET v = 0 WHERE p = 0 and c = 0; 

After q1:
    base: (p=0&amp;amp;&amp;amp;c=0)@(ts@t1, ttl@3)
    view: VC(keyOrConditions{}, unselected:{}) (c=p&amp;amp;&amp;amp;p=0)@liveness(ts@t1, ttl@3)

After q2:
    base(merged):    (p=0&amp;amp;&amp;amp;c=0)@(ts@t1, ttl@3) v=0@(ts@t2, ttl@100)
    view: 
        sstable1:    VC(keyOrConditions{}, unselected:{}) (c=p&amp;amp;&amp;amp;p=0)@liveness(ts@t1, ttl@3)
        sstable2:    VC(keyOrConditions{}, unselected:{v@(ts@t2, ttl@100) }) (c=p&amp;amp;&amp;amp;p=0)@liveness(ts@t1, ttl@3)
        or merged:   VC(keyOrConditions{}, unselected:{v@(ts@t2, ttl@100) }) (c=p&amp;amp;&amp;amp;p=0)@liveness(ts@t1, ttl@3)

after 5 second,
    base:  p,c,v-&amp;gt; 0,0,0
    view:  c,p  -&amp;gt; 0,0 because {{unselected has not TTLed column v}}

&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Partial update unselected columns in base (13127)&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;CREATE TABLE base (k &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt;, c &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt;, a &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt;, b &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt;, PRIMARY KEY (k, c));
CREATE MATERIALIZED VIEW mv AS SELECT k,c FROM base WHERE k IS NOT NULL AND c IS NOT NULL PRIMARY KEY (k,c);

{{q1}} UPDATE base USING TIMESTAMP 10 SET b=1 WHERE k=1 AND c=1;
{{q2}} DELETE b FROM base USING TIMESTAMP 11 WHERE k=1 AND c=1;
{{q3}} UPDATE base USING TIMESTAMP 1 SET a=1 WHERE k=1 AND c=1;

After q1:
    base:   (k=1&amp;amp;&amp;amp;c=1),  b=1@10
    view:   VC(keyOrConditions{}, unselected:{b@(ts@10)}) (k=1&amp;amp;&amp;amp;c=1) 

After q2:
    base(merged):   (k=1&amp;amp;&amp;amp;c=1),  b@tombstone(ts@11)
    view:
        sstable1:   VC(keyOrConditions{}, unselected:{b@(ts@10)}) (k=1&amp;amp;&amp;amp;c=1) 
        sstable2:   VC(keyOrConditions{}, unselected:{b@(tb@11)}) (k=1&amp;amp;&amp;amp;c=1) 
        or merged:  VC(keyOrConditions{}, unselected:{b@(tb@11)}) (k=1&amp;amp;&amp;amp;c=1)  &lt;span class=&quot;code-comment&quot;&gt;// no view row
&lt;/span&gt;
After q3:
    base(merged):   (k=1&amp;amp;&amp;amp;c=1),  b@tombstone(ts@11), c=1@1
    view:
        sstable1:   VC(keyOrConditions{}, unselected:{b@(ts@10)}) (k=1&amp;amp;&amp;amp;c=1) 
        sstable2:   VC(keyOrConditions{}, unselected:{b@(tb@11)}) (k=1&amp;amp;&amp;amp;c=1) 
        sstable3:   VC(keyOrConditions{}, unselected:{c@(ts@1)}) (k=1&amp;amp;&amp;amp;c=1)
        or merged:  VC(keyOrConditions{}, unselected:{b@(tb@11), c@(ts@1)}) (k=1&amp;amp;&amp;amp;c=1)  &lt;span class=&quot;code-comment&quot;&gt;// view row a live since one of {{unselected}} is live&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;


&lt;p&gt;merging should be commutative (13409)&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;create table ks.base (p &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; primary key, v1 &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt;, v2 &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt;);
create materialized view ks.my_view as select * from ks.base where p is not &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; and v1 is not &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; primary key (v1, p); 

{{q1}} insert into ks.base (p, v1, v2) values (3, 1, 3) using timestamp 1; 
{{q2}} delete from ks.base using timestamp 2 where p = 3; 
{{q3} insert into ks.base (p, v1) values (3, 1) using timestamp 3;

at the end:
    base(merged): p=3@partition_deletion@2, livenesInfo@3, v1=1
    view:
        sstable1: VC(keyOrConditions{v1:(ts@0) }, unselected:{}) (v1=3&amp;amp;&amp;amp;p=3)@livenes(ts@1), v2=3
        sstable2: (v1=3&amp;amp;&amp;amp;p=3)@tombstone(ts@2)
        sstable3: VC(keyOrConditions{v1:(ts@3) }, unselected:{}) (v1=3&amp;amp;&amp;amp;p=3)@livenes(ts@3, keyOrConditions{v1:(ts@3) }, unselected:{})
        or merged: VC(keyOrConditions{v1:(ts@3) }, unselected:{}) (v1=3&amp;amp;&amp;amp;p=3)@livenes(ts@3, keyOrConditions{v1:(ts@3) }, unselected:{}) @tombstone(ts@2)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;


&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;create table ks.base (p &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; primary key, v1 &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt;, v2 &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt;);
create materialized view ks.my_view as select * from ks.base where p is not &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; and v1 is not &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; primary key (v1, p); 

{{q1}} insert into base (p, v1, v2) values (3, 1, 3) using timestamp 1
{{q2}} update base using timestamp 2 set v2 = &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; where p = 3  
{{q3}} update base using timestamp 3  set v1 = 2 where p = 3 
{{q4}} update base using timestamp 4 set v1 = 1 where p = 3

at the end:
    base(merged): p=3@1, v1=1@4, v2@tombstone(ts@3)
    view:
        sstable1: VC(keyOrConditions{v1:(ts@1) }, unselected:{}) (v1=1&amp;amp;&amp;amp;p=3)@livenes(ts@1), v2=3
        sstable2: (v1=1&amp;amp;&amp;amp;p=3) v2@tombstone(ts@2)   
        sstable3: 
                  VC(keyOrConditions{v1:(tb@1) }, unselected:{}) (v1=1&amp;amp;&amp;amp;p=3)
                  VC(keyOrConditions{v1:(ts@3) }, unselected:{}) (v1=2&amp;amp;&amp;amp;p=3)@livenes(ts@1), v2@tombstone(ts@2)   
        sstable4:
                  VC(keyOrConditions{v1:(ts@4) }, unselected:{}) (v1=1&amp;amp;&amp;amp;p=3)@liveness(ts@1), v2@tombstone(ts@2)
                  VC(keyOrConditions{v1: (tb@3)}, unselected:{}) (v1=2&amp;amp;&amp;amp;p=3) 

        or merged 2&amp;amp;3:        
            sstable1: VC(keyOrConditions{v1:(ts@1) }, unselected:{}) (v1=1&amp;amp;&amp;amp;p=3)@livenes(ts@1), v2=3
            sstable5: 
                    VC(keyOrConditions{v1:(tb@1) }, unselected:{}) (v1=1&amp;amp;&amp;amp;p=3) v2@tombstone(ts@2)   
                    VC(keyOrConditions{v1:(ts@3) }, unselected:{}) (v1=2&amp;amp;&amp;amp;p=3)@livenes(ts@1), v2@tombstone(ts@2)   
            sstable4:
                    VC(keyOrConditions{v1:(ts@4) }, unselected:{}) (v1=1&amp;amp;&amp;amp;p=3)@liveness(ts@1), v2@tombstone(ts@2)
                    VC(keyOrConditions{v1: (tb@3)}, unselected:{}) (v1=2&amp;amp;&amp;amp;p=3)       
        or merged all:
                    VC(keyOrConditions{v1:(ts@4) }, unselected:{}) (v1=1&amp;amp;&amp;amp;p=3)@liveness(ts@1), v2@tombstone(ts@2)
                    VC(keyOrConditions{v1: (tb@3)}, unselected:{}) (v1=2&amp;amp;&amp;amp;p=3) v2@tombstone(ts@2)              
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;create table ks.base (p &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; primary key, v1 &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt;, v2 &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt;);
create materialized view ks.my_view as select * from ks.base where p is not &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; and v1 is not &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; primary key (v1, p); 

{{q1}} insert into base (p, v1, v2) values (3, 1, 3) using timestamp 1
{{q2}} delete from base using timestamp 2 where p = 3 
{{q3}} insert into base (p, v1) values (3, 1) using timestamp 3
{{q4}} update base using timestamp 4 set v1 = 2 where p = 3 &lt;span class=&quot;code-comment&quot;&gt;// will create a shadowable row tombstone &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (v1, p) = (1, 3)
&lt;/span&gt;{{q5}} update base using timestamp 5 set v1 = 1 where p = 3

at the end:
    base(merged): p=3@partition_deletion(ts@2), livenesInfo@3, v1=1@5
    view:
        sstable1: VC(keyOrConditions{v1:(ts@1) }, unselected:{}) (v=1&amp;amp;&amp;amp;p=3)@livenes(ts@1) v2=3
        sstable2: (v=1&amp;amp;&amp;amp;p=3)@tombstone(ts@2)  &lt;span class=&quot;code-comment&quot;&gt;// normal deletion
&lt;/span&gt;        sstable3: VC(keyOrConditions{v1:(ts@3) }, unselected:{}) (v=1&amp;amp;&amp;amp;p=3)@liveness(ts@3)
        sstable4: 
                  VC(keyOrConditions{v1:(tb@3) }, unselected:{}) (v=1&amp;amp;&amp;amp;p=3)
                  VC(keyOrConditions{v1:(ts@4) }, unselected:{}) (v=2&amp;amp;&amp;amp;p=3)@liveness(ts@3)
        sstable5:
                  VC(keyOrConditions{v1:(ts@5) }, unselected:{}) (v=1&amp;amp;&amp;amp;p=3)@liveness(ts@3)
                  VC(keyOrConditions{v1:(tb@4) }, unselected:{}) (v=2&amp;amp;&amp;amp;p=3)
        or merged 2&amp;amp;4:
            sstable1: VC(keyOrConditions{v1:(ts@1) }, unselected:{}) (v=1&amp;amp;&amp;amp;p=3)@livenes(ts@1) v2=3
            sstable3: VC(keyOrConditions{v1:(ts@3) }, unselected:{}) (v=1&amp;amp;&amp;amp;p=3)@liveness(ts@3)
            sstable6: 
                    VC(keyOrConditions{v1:(tb@3) }, unselected:{}) (v=1&amp;amp;&amp;amp;p=3)@tombstone(ts@2)
                    VC(keyOrConditions{v1:(ts@4) }, unselected:{}) (v=2&amp;amp;&amp;amp;p=3)@liveness(ts@3)
            sstable5:
                    VC(keyOrConditions{v1:(ts@5) }, unselected:{}) (v=1&amp;amp;&amp;amp;p=3)@liveness(ts@3)
                    VC(keyOrConditions{v1:(tb@4) }, unselected:{}) (v=2&amp;amp;&amp;amp;p=3)  
            then merged 3&amp;amp;6&amp;amp;5:
                sstable1: VC(keyOrConditions{v1:(ts@1) }, unselected:{}) (v=1&amp;amp;&amp;amp;p=3)@livenes(ts@1) v2=3
                sstable7: 
                        VC(keyOrConditions{v1:(ts@5) }, unselected:{}) (v=1&amp;amp;&amp;amp;p=3)@liveness(ts@3) @tombstone(ts@2)
                        VC(keyOrConditions{v1:(tb@4) }, unselected:{}) (v=2&amp;amp;&amp;amp;p=3)@liveness(ts@3)
                then merged 1&amp;amp;7:
                        VC(keyOrConditions{v1:(ts@5) }, unselected:{}) (v=1&amp;amp;&amp;amp;p=3)@liveness(ts@3) @tombstone(ts@2)
                        VC(keyOrConditions{v1:(tb@4) }, unselected:{}) (v=2&amp;amp;&amp;amp;p=3)@liveness(ts@3)                   
        or merged all:
                  VC(keyOrConditions{v1:(ts@5) }, unselected:{}) (v=1&amp;amp;&amp;amp;p=3)@liveness(ts@3) @tombstone(ts@2)
                  VC(keyOrConditions{v1:(tb@4) }, unselected:{}) (v=2&amp;amp;&amp;amp;p=3)

&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;with filter conditions (13547)&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;CREATE TABLE test.table1 ( id &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt;, name text, enabled &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt;, foo text, PRIMARY KEY (id, name));
CREATE MATERIALIZED VIEW view1 AS SELECT id, name, foo FROM test.table1 WHERE id IS NOT NULL AND name IS NOT NULL AND enabled = TRUE PRIMARY KEY ((name), id);
CREATE MATERIALIZED VIEW view2 AS SELECT * FROM test.table1 WHERE id IS NOT NULL AND name IS NOT NULL AND enabled = TRUE PRIMARY KEY ((name), id);


{{q1}}  INSERT INTO test.table1 (id, name, enabled, foo) VALUES (1, &lt;span class=&quot;code-quote&quot;&gt;&apos;One&apos;&lt;/span&gt;, TRUE, &lt;span class=&quot;code-quote&quot;&gt;&apos;Bar&apos;&lt;/span&gt;);  &lt;span class=&quot;code-comment&quot;&gt;// t1
&lt;/span&gt;{{q2}} UPDATE test.table1 SET enabled = FALSE WHERE id = 1 AND name = &lt;span class=&quot;code-quote&quot;&gt;&apos;One&apos;&lt;/span&gt;;              &lt;span class=&quot;code-comment&quot;&gt;// t2
&lt;/span&gt;{{q3}} UPDATE test.table1 SET enabled = TRUE WHERE id = 1 AND name = &lt;span class=&quot;code-quote&quot;&gt;&apos;One&apos;&lt;/span&gt;;               &lt;span class=&quot;code-comment&quot;&gt;// t3
&lt;/span&gt;
At the end:
    base(merged): (id=1&amp;amp;&amp;amp;name=&lt;span class=&quot;code-quote&quot;&gt;&apos;One&apos;&lt;/span&gt;)@t1, enabled=TRUE@t3, foo=&lt;span class=&quot;code-quote&quot;&gt;&apos;Bar&apos;&lt;/span&gt;
    View1:
        sstable1: VC(keyOrConditions{enabled:(ts@t1) }, unselected:{}) (id=1&amp;amp;&amp;amp;name=&lt;span class=&quot;code-quote&quot;&gt;&apos;One&apos;&lt;/span&gt;)@liveness(ts@t1), foo=&lt;span class=&quot;code-quote&quot;&gt;&apos;bar&apos;&lt;/span&gt;@t1
        sstable2: VC(keyOrConditions{enabled:(tb@t1) }, unselected:{}) (id=1&amp;amp;&amp;amp;name=&lt;span class=&quot;code-quote&quot;&gt;&apos;One&apos;&lt;/span&gt;)
        sstable3: VC(keyOrConditions{enabled:(ts@t3) }, unselected:{}) (id=1&amp;amp;&amp;amp;name=&lt;span class=&quot;code-quote&quot;&gt;&apos;One&apos;&lt;/span&gt;)@liveness(ts@t1), foo=&lt;span class=&quot;code-quote&quot;&gt;&apos;bar&apos;&lt;/span&gt;@t1
        or merged: VC(keyOrConditions{enabled:(ts@t3) }, unselected:{}) (id=1&amp;amp;&amp;amp;name=&lt;span class=&quot;code-quote&quot;&gt;&apos;One&apos;&lt;/span&gt;)@liveness(ts@t1), foo=&lt;span class=&quot;code-quote&quot;&gt;&apos;bar&apos;&lt;/span&gt;@t1
    View2:
        sstable1: VC(keyOrConditions{enabled:(ts@t1) }, unselected:{}) (id=1&amp;amp;&amp;amp;name=&lt;span class=&quot;code-quote&quot;&gt;&apos;One&apos;&lt;/span&gt;)@liveness(ts@t1), enabled=True@t1, foo=&lt;span class=&quot;code-quote&quot;&gt;&apos;bar&apos;&lt;/span&gt;@t1
        sstable2: VC(keyOrConditions{enabled:(tb@t1) }, unselected:{}) (id=1&amp;amp;&amp;amp;name=&lt;span class=&quot;code-quote&quot;&gt;&apos;One&apos;&lt;/span&gt;)
        sstable3: VC(keyOrConditions{enabled:(ts@t3) }, unselected:{}) (id=1&amp;amp;&amp;amp;name=&lt;span class=&quot;code-quote&quot;&gt;&apos;One&apos;&lt;/span&gt;)@liveness(ts@t1), enabled=True@t3, foo=&lt;span class=&quot;code-quote&quot;&gt;&apos;bar&apos;&lt;/span&gt;@t1
        or merged: VC(keyOrConditions{enabled:(ts@t3) }, unselected:{}) (id=1&amp;amp;&amp;amp;name=&lt;span class=&quot;code-quote&quot;&gt;&apos;One&apos;&lt;/span&gt;)@liveness(ts@t1), enabled=True@t3, foo=&lt;span class=&quot;code-quote&quot;&gt;&apos;bar&apos;&lt;/span&gt;@t1
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="16083638" author="fsander" created="Wed, 12 Jul 2017 08:30:39 +0000"  >&lt;p&gt;I also want to through my stuff into the ring right here &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Following up from &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-13657&quot; title=&quot;Materialized Views: Index MV on TTL&amp;#39;ed column produces orphanized view entry if another column keeps entry live&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-13657&quot;&gt;&lt;del&gt;CASSANDRA-13657&lt;/del&gt;&lt;/a&gt; on this, &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-13657?focusedCommentId=16080177&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-16080177&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;my proposal from there&lt;/a&gt; could be adapted to solve this by introducing a &lt;tt&gt;ShortCircuitingRowDeletion&lt;/tt&gt;: A live, sort-circuiting row-deletion supersedes all columns no matter their timestamp. It can only be superseded by a liveness-info with higher timestamp.&lt;/p&gt;

&lt;p&gt;That way, we don&apos;t need to take maximum timestamp of cells anymore for the view-tombstone, which prevents the conflict of this issue.&lt;/p&gt;</comment>
                            <comment id="16089856" author="jasonstack" created="Mon, 17 Jul 2017 13:55:50 +0000"  >&lt;p&gt;I plan to solve: &lt;tt&gt;partial update&lt;/tt&gt;,&lt;tt&gt;ttl&lt;/tt&gt;, &lt;tt&gt;co-existed shadowable tombstone&lt;/tt&gt;, &lt;tt&gt;view timestamp tie&lt;/tt&gt; all inside this ticket using extended shadowable approach(mentioned &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-11500?focusedCommentId=16082241&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-16082241&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;here&lt;/a&gt;). Because all these issues require some storage format changes(extendedFlag), it&apos;s better to fix them and refactor in one commit.&lt;/p&gt;

&lt;p&gt;I will drafrt a patch using &lt;tt&gt;ViewTombstone&lt;/tt&gt; and &lt;tt&gt;ViewLiveness&lt;/tt&gt;.&lt;/p&gt;

&lt;p&gt;Any suggestions would be appreciated.&lt;/p&gt;
</comment>
                            <comment id="16091273" author="kurtg" created="Tue, 18 Jul 2017 08:25:57 +0000"  >&lt;p&gt;Thanks &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jasonstack&quot; class=&quot;user-hover&quot; rel=&quot;jasonstack&quot;&gt;jasonstack&lt;/a&gt;, I think that&apos;s a wise approach to solving the issues. I&apos;ll give it some thought over the next couple days. Worth giving some thought to &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=fsander&quot; class=&quot;user-hover&quot; rel=&quot;fsander&quot;&gt;fsander&lt;/a&gt;&apos;s solution as well, however I think I&apos;m in favour of utilising ShadowableTombstones for the same case. Will give it some serious consideration before ruling anything out however.&lt;/p&gt;

&lt;p&gt;Also, just making a note here that we have to solve the issue raised in &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-10965&quot; title=&quot;Shadowable tombstones can continue to shadow view results when timestamps match&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-10965&quot;&gt;&lt;del&gt;CASSANDRA-10965&lt;/del&gt;&lt;/a&gt; here as well. Pretty sure you&apos;re already addressing this but just saying so it&apos;s written down somewhere. &lt;/p&gt;</comment>
                            <comment id="16094195" author="kurtg" created="Thu, 20 Jul 2017 05:24:08 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jasonstack&quot; class=&quot;user-hover&quot; rel=&quot;jasonstack&quot;&gt;jasonstack&lt;/a&gt; do you have a WIP branch you can link here?&lt;/p&gt;</comment>
                            <comment id="16094231" author="jasonstack" created="Thu, 20 Jul 2017 05:48:18 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=KurtG&quot; class=&quot;user-hover&quot; rel=&quot;KurtG&quot;&gt;KurtG&lt;/a&gt; branch is not yet ready for you to test. but you could have a look at &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-11500?focusedCommentId=16082241&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-16082241&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;proposal&lt;/a&gt; first, see if there is any missing case.&lt;/p&gt;</comment>
                            <comment id="16094252" author="kurtg" created="Thu, 20 Jul 2017 06:20:53 +0000"  >&lt;p&gt;Yep have been, was just hoping there was some code I could pin it to to make things clearer - as I&apos;m sure you&apos;re aware it&apos;s hard to figure out all the edge cases unless you actively try them. Not a big deal, I&apos;ll keep an eye out for when you have a branch ready.&lt;/p&gt;

&lt;p&gt;Your proposal looks good and seems to make sense and cover all the cases I can think of (but there are so many I&apos;m sure I&apos;ve forgotten some). With this change in place would all deletions/deletions in views be represented as a ViewTombstone? My understanding is that you&apos;re essentially combining normal tombstones and shadowables to create the viewtombstone, with a few extra details to catch the edge cases, is that right?&lt;/p&gt;</comment>
                            <comment id="16094272" author="jasonstack" created="Thu, 20 Jul 2017 06:51:03 +0000"  >&lt;p&gt;All livenessInfo or row deletion in MV will be ViewLivenessInfo or ViewDeletion with some extra details to check if view row is still alive.&lt;/p&gt;

&lt;p&gt;Shadowable mechanism is not used..(single flag is not sufficient and in the proposal, we don&apos;t need to bring back the columns shadowed by shadowable-tombstone)&lt;/p&gt;</comment>
                            <comment id="16101603" author="jasonstack" created="Wed, 26 Jul 2017 12:20:30 +0000"  >&lt;p&gt;WIP &lt;a href=&quot;https://github.com/jasonstack/cassandra/commits/CASSANDRA-11500-cell&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;branch&lt;/a&gt; &lt;a href=&quot;https://github.com/riptano/cassandra-dtest/commits/CASSANDRA-11500&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;dtest&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;Changed:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Extra &quot;VirtualCell&quot;(kind of special LivenessInfo for MV) in Row to maintain consistency of view row. It stores: 1. base column used in view PK and base column used in view filter conditions. if any of such column dead, entire view row dead, regardless LivenessInfo or DeletionTime status. or 2. unselected base columns. if any of such column alive, view&apos;s pk should be alive.&lt;/li&gt;
	&lt;li&gt;blocked dropping filter base column&lt;/li&gt;
	&lt;li&gt;fix issue of creating view with token()  filter&lt;/li&gt;
	&lt;li&gt;remove Row.Deletion, it was used to wrap DeletionTime with &quot;Shadowable&quot; flag&lt;/li&gt;
	&lt;li&gt;fix missing partition deletion in view-update&lt;/li&gt;
	&lt;li&gt;for now, ttl on non-frozen collections is not reflected in &quot;VritualCells&quot;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Todo: &lt;br/&gt;
more dtest&lt;/p&gt;</comment>
                            <comment id="16119461" author="pauloricardomg" created="Wed, 9 Aug 2017 06:20:43 +0000"  >&lt;p&gt;The virtual cell proposal is pretty clever and looks like it would solve most outstanding issues, but I&apos;m a bit concerned about adding new structures to the storage engine to deal with materialized-specific issues.&lt;/p&gt;

&lt;p&gt;While I agree we should do if it&apos;s our only choice, we should explore alternatives which reuse existing structures if possible to avoid introducing feature-specific stuff into the storage engine.&lt;/p&gt;

&lt;p&gt;Looking back at the original scenario which motivated this ticket (&lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-11500&quot; title=&quot;Obsolete MV entry may not be properly deleted&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-11500&quot;&gt;&lt;del&gt;CASSANDRA-11500&lt;/del&gt;&lt;/a&gt;):&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;CREATE TABLE t (k int PRIMARY KEY, a int, b int);
CREATE MATERIALIZED VIEW mv AS SELECT * FROM t WHERE k IS NOT NULL AND a IS NOT NULL PRIMARY KEY (k, a);

INSERT INTO t(k, a, b) VALUES (1, 1, 1) USING TIMESTAMP 0;
UPDATE t USING TIMESTAMP 4 SET b = 2 WHERE k = 1;
UPDATE t USING TIMESTAMP 2 SET a = 2 WHERE k = 1;

SELECT * FROM mv WHERE k = 1; // This currently return 2 entries, the old (invalid) and the new one
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;It seems to me that the problem here is applying the definition for standard tables that if a single column is live, then the whole row is live, which does not need to be the case for MV where we can guarantee a view entry will always contain row-level liveness info.&lt;/p&gt;

&lt;p&gt;We could solve this  by introducing a &quot;strict &quot; flag to the row liveness info, which has the following semantic:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;A strict row is only live iff it&apos;s row level liveness info is live, regardless of the liveness of its columns&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Materialized views rows would have this flag set and perform deletions with its max primary key timestamp (instead of max timestamp of all keys), and this would solve the issue above by ensuring the row &lt;tt&gt;(1, 1)@(liveness@0, deleted@2)=(b=2@4)&lt;/tt&gt; would not be live.&lt;/p&gt;

&lt;p&gt;In addition to solving the original problem we would not create the second problem in the ticket description of updates to the view primary key with a smaller timestamp to be shadowed by a shadowable tombstone using the max timestamp of a non-PK column. In this approach the shadowing tombstone mechanism would still be orthogonal to the strict liveness and working as it is today.&lt;/p&gt;

&lt;p&gt;This mechanism alone would not solve all other problems but at least the ones described in this ticket description with minimal change in the storage engine, let&apos;s now go through the other issues to see how we could solve them:&lt;/p&gt;

&lt;p&gt;&lt;b&gt;View row expires too fast with unselected base column (&lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-13127&quot; title=&quot;Materialized Views: View row expires too soon&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-13127&quot;&gt;&lt;del&gt;CASSANDRA-13127&lt;/del&gt;&lt;/a&gt;)&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;From the discussion on &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-13127&quot; title=&quot;Materialized Views: View row expires too soon&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-13127&quot;&gt;&lt;del&gt;CASSANDRA-13127&lt;/del&gt;&lt;/a&gt; it seems like you found and fixed some issues with liveness comparison in addition to no view update being generated when there is an update to an unselected column which seems to solve this issue in addition with the strict row concept above. Even though this will require a read  when updating columns not in the view, the MV user is already expecting to pay an extra price for MVs anyway so it shouldn&apos;t be a problem - if you want performance you can build views manually or use &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-9779&quot; title=&quot;Append-only optimization&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-9779&quot;&gt;CASSANDRA-9779&lt;/a&gt; hopefully when it&apos;s ready. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;based column used in view key is TTLed (&lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-13657&quot; title=&quot;Materialized Views: Index MV on TTL&amp;#39;ed column produces orphanized view entry if another column keeps entry live&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-13657&quot;&gt;&lt;del&gt;CASSANDRA-13657&lt;/del&gt;&lt;/a&gt;)&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;This seems to be fixed by the fix above.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Partial update unselected columns in base (&lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-13127&quot; title=&quot;Materialized Views: View row expires too soon&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-13127&quot;&gt;&lt;del&gt;CASSANDRA-13127&lt;/del&gt;&lt;/a&gt;)&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;This seem to be more of an anomaly of the partial row update semantics which has bad consequences for MVs than a problem with MV itself. 6.0 where thrift is gone is a good occasion to revisit this semantics rather than trying to make MV fit into it.&lt;/p&gt;

&lt;p&gt;Right now, inserting a non-PK column (in the example &lt;tt&gt;UPDATE base USING TIMESTAMP 10 SET b=1 WHERE k=1 AND c=1&lt;/tt&gt;) will create a row (k=1, c=1, b=1)@10 on the end-user perspective (&lt;tt&gt;SELECT * FROM base WHERE k=1 and C=1&lt;/tt&gt;) while internally creating only a column, which destroys the entire row in case the same non-PK column is removed (&lt;tt&gt;DELETE b FROM base USING TIMESTAMP 11 WHERE k=1 AND c=1;&lt;/tt&gt;).&lt;/p&gt;

&lt;p&gt;While this semantics may make sense in a column-oriented world, it&apos;s a tad bizarre in a row oriented world, given we can delete a row by simply unsetting a non-PK column. I think the correct and expected semantic would be: &lt;tt&gt;a column update to a non-existing row will create it&lt;/tt&gt;.&lt;/p&gt;

&lt;p&gt;This semantic is IMO what makes the most sense in a row oriented store and it&apos;s possible to implement it without falling into the unexpected/inconsistent behaviors of &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-6782&quot; title=&quot;setting TTL on some columns seems to expire whole row&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-6782&quot;&gt;&lt;del&gt;CASSANDRA-6782&lt;/del&gt;&lt;/a&gt;/&lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-6668&quot; title=&quot;Inconsistent handling of row expiration using TTL in collections&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-6668&quot;&gt;&lt;del&gt;CASSANDRA-6668&lt;/del&gt;&lt;/a&gt; by adding some kind of &lt;tt&gt;CREATE_IF_NOT_EXISTS&lt;/tt&gt; flag which basically keeps the oldest liveness entry if more than one is found with this flag when merging.&lt;/p&gt;

&lt;p&gt;This semantic change would be the most correct while still preventing this anomaly with MVs due to the current semantic. If you agree we can create another ticket to propose this change.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;merging should be commutative (&lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-13409&quot; title=&quot;Materialized Views: View cells are resurrected&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-13409&quot;&gt;&lt;del&gt;CASSANDRA-13409&lt;/del&gt;&lt;/a&gt;)&lt;/b&gt;&lt;br/&gt;
The second case, represented by &lt;tt&gt;testCellTombstoneAndShadowableTombstones&lt;/tt&gt;, is fixed by &lt;a href=&quot;https://github.com/pauloricardomg/cassandra/commit/1aeb0acbbaad6cc9520af6d1684043a5078eefa7&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;using regular tombstones instead of shadowable tombstones for base table column deletions&lt;/a&gt; (something which was probably overlooked on &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-10261&quot; title=&quot;Materialized Views Timestamp issues&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-10261&quot;&gt;&lt;del&gt;CASSANDRA-10261&lt;/del&gt;&lt;/a&gt;), as suggested on &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-13409&quot; title=&quot;Materialized Views: View cells are resurrected&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-13409&quot;&gt;&lt;del&gt;CASSANDRA-13409&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The first and third case, represented by &lt;tt&gt;testCommutativeRowDeletion&lt;/tt&gt; can probably be fixed on the view update generator by emitting column tombstones for columns not being updated when it&apos;s detected a partial update on a previously deleted row (unless I&apos;m missing something).&lt;/p&gt;

&lt;p&gt;&lt;b&gt;with filter conditions (&lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-13547&quot; title=&quot;Filtered materialized views missing data&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-13547&quot;&gt;&lt;del&gt;CASSANDRA-13547&lt;/del&gt;&lt;/a&gt;)&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;This seems like a genuine bug on the view update generator, already discussed and proposed patch on &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-13547&quot; title=&quot;Filtered materialized views missing data&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-13547&quot;&gt;&lt;del&gt;CASSANDRA-13547&lt;/del&gt;&lt;/a&gt;, of not including the view conditions on the base table select. The second issue discussed there of a column with lower timestamp being wrongly shadowed should be fixed by the strict liveness fix proposed before.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;unselected columns dropped&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;We could still use the virtual cells idea (but probably as an additional flag to the current cell structure) to support this properly, but I&apos;m not sure it makes sense to optimize and add additional storage overhead for this use case so we could maybe just disallow dropping columns on tables with MVs configured altogether (at least initially).&lt;/p&gt;

&lt;p&gt;I hacked a &lt;a href=&quot;https://github.com/pauloricardomg/cassandra/commits/11500-poc&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;strict liveness prototype&lt;/a&gt; on top of the original patch for &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-13127&quot; title=&quot;Materialized Views: View row expires too soon&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-13127&quot;&gt;&lt;del&gt;CASSANDRA-13127&lt;/del&gt;&lt;/a&gt; which seems to fix most tests except the ones not covered above.&lt;/p&gt;

&lt;p&gt;While this still requires changes to the storage engine it&apos;s mostly inclusion of new flags, while other changes would be restricted to the view update generator. I could be easily missing something so please let me know if there are cases or inefficiencies not covered by the suggestions above which I did not consider.&lt;/p&gt;

&lt;p&gt;I think the scope here is quite big, and while I understood your idea was to solve all these issues with a single approach, if there aren&apos;t flaws with the suggestions above (which require less changes in the storage engine) and we decide to go with them, we should probably break up the solution to this as following:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;On this ticket implement the strict liveness idea and test it thoroughly (compaction, tombstone purging etc) including the original patch for &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-13127&quot; title=&quot;Materialized Views: View row expires too soon&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-13127&quot;&gt;&lt;del&gt;CASSANDRA-13127&lt;/del&gt;&lt;/a&gt; (except the shadowable liveness commit which is probably not required)&lt;/li&gt;
	&lt;li&gt;Reopen &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-13409&quot; title=&quot;Materialized Views: View cells are resurrected&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-13409&quot;&gt;&lt;del&gt;CASSANDRA-13409&lt;/del&gt;&lt;/a&gt; to update view generator to generate column tombstones when receiving a partial update for a previously deleted row&lt;/li&gt;
	&lt;li&gt;Reopen &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-13547&quot; title=&quot;Filtered materialized views missing data&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-13547&quot;&gt;&lt;del&gt;CASSANDRA-13547&lt;/del&gt;&lt;/a&gt; to update view generator to include unselected views on base table select (latest patch there should already be good enough I think?)&lt;/li&gt;
	&lt;li&gt;Open a new ticket to deal with dropped unselected columns (either disallow or implement a simplified virtual cell idea to deal with this)&lt;/li&gt;
	&lt;li&gt;Open a new ticket to propose new insert-if-not-exists semantic for column update on non-existing row&lt;/li&gt;
	&lt;li&gt;Open a new ticket to update sstable dump to include new flags and shadowable tombstone&lt;/li&gt;
	&lt;li&gt;In my hacked prototype the frozen collection test is failing, but I didn&apos;t investigate into it, is this something that would be solved by any of the above or is it a different issue? Also please let me know if I forgot to comment on any other case which is not covered above.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="16119823" author="pauloricardomg" created="Wed, 9 Aug 2017 12:40:17 +0000"  >&lt;p&gt;Talking offline with Zhao, it seems like there is still an outstanding case derived from &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-13547&quot; title=&quot;Filtered materialized views missing data&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-13547&quot;&gt;&lt;del&gt;CASSANDRA-13547&lt;/del&gt;&lt;/a&gt; not addressed by the strict liveness suggestion:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-none&quot;&gt;// liveness or deletion using max-timestamp of view-primary-key column in base
base:  (k), a, b, c
view:  (k, a), b, c=1

q1: insert (1,1,1,1) with timestamp 0

    base: liveness=ts@0,  k=1, a=1@0, b=1@0, c=1@0
    view: liveness=ts@0,  (k=1, a=1), b=1@0, c=1@0

q2: update c=1 with timestamp 10 where k = 1  

    base: liveness=ts@0,  k=1, a=1@0, b=1@0, c=1@10
    view: liveness=ts@0,  (k=1, a=1), b=1@0, c=1@10

q3: update c=2 with timestamp 11 where k = 1  

    base: liveness=ts@0,  k=1, a=1@0, b=1@0, c=2@11
    view:
          liveness=ts@0,  (k=1, a=1), b=1@0, c=1@10
          tombstone=ts@0,  (k=1, a=1)

          with strict-liveness flag, view row is dead

q4: update c=1 with timestamp 12 where k = 1  

    base: liveness=ts@0,  k=1, a=1@0, b=1@0, c=1@12
    view:
          liveness=ts@0,  (k=1, a=1), b=1@0, c=1@10
          tombstone=ts@0,  (k=1, a=1)
          liveness=ts@0,  (k=1, a=1), b=1@0, c=1@12
         
          view row should be live..but it&apos;s dead
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;It seems like this scenario where the row liveness depend on a non-view primary key was overlooked by &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-10368&quot; title=&quot;Support Restricting non-PK Cols in Materialized View Select Statements&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-10368&quot;&gt;&lt;del&gt;CASSANDRA-10368&lt;/del&gt;&lt;/a&gt; and seems to be analogous to the problem Tyler discovered on &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-10226&quot; title=&quot;Support multiple non-PK cols in MV clustering key when partition key is shared&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-10226&quot;&gt;CASSANDRA-10226&lt;/a&gt; (but with conditions rather than non-base view primary keys):&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;It seems like when we include multiple non-PK columns in the view PK, we fundamentally have to accept that the view row&apos;s existence depends on multiple timestamps. I propose that we solve this by using a set of timestamps for the row&apos;s LivenessInfo.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The solution proposed on that ticket of keeping multiple deletion and liveness infos per primary key is similar to the virtual cells solution you independently came up (great job!). While I agree that a solution along those lines is the way to go moving forward, that&apos;s a pretty significant change in the storage engine which may introduce unforeseen problems, and would probably be nice to have &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=slebresne&quot; class=&quot;user-hover&quot; rel=&quot;slebresne&quot;&gt;slebresne&lt;/a&gt; blessing given he seems to &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-10226?focusedCommentId=14740391&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-14740391&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;feel strongly&lt;/a&gt; about it and will likely want to chime in.&lt;/p&gt;

&lt;p&gt;I personally think that before introducing disruptive changes to the storage engine and MV machinery to enable relatively new features (in this case, filtering on non-PK columns which didn&apos;t seem to have all of its repercussions considered on &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-10368&quot; title=&quot;Support Restricting non-PK Cols in Materialized View Select Statements&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-10368&quot;&gt;&lt;del&gt;CASSANDRA-10368&lt;/del&gt;&lt;/a&gt;), we should take a conservative approach and spend our energy on stabilizing current MV features.&lt;/p&gt;

&lt;p&gt;In practical terms, I&apos;d suggest going with the simpler strict liveness approach I suggested above to fix the current problems (or any alternative which do not require disruptive changes on the storage engine) and disallow filtering on non-PK while the virtual cells are not implemented - MVs with it already enabled would not be affected but users would be susceptible to the problem above (we could maybe print a warning to inform this).&lt;/p&gt;

&lt;p&gt;After we have current MV features stabilized we can then think of implementing the virtual cell idea to properly enable other features like filtering on non-view PK columns and support multiple non-PK cols in MV clustering key when partition key is shared (&lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-10226&quot; title=&quot;Support multiple non-PK cols in MV clustering key when partition key is shared&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-10226&quot;&gt;CASSANDRA-10226&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Please let me know what do you think.&lt;/p&gt;</comment>
                            <comment id="16124534" author="jasonstack" created="Sat, 12 Aug 2017 10:03:39 +0000"  >&lt;p&gt;Thanks for reviewing and feedback.&lt;/p&gt;

&lt;p&gt;Changing the semantic of MV and revising non-key column filtering feature(&lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-10368&quot; title=&quot;Support Restricting non-PK Cols in Materialized View Select Statements&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-10368&quot;&gt;&lt;del&gt;CASSANDRA-10368&lt;/del&gt;&lt;/a&gt;) will indeed make it easier. It&apos;s a good idea to make a simple non-disruptive change to stabilize basic features and wait for more commiters involved.&lt;/p&gt;

&lt;p&gt;Using an extended flag for &lt;tt&gt;Strict-Liveness&lt;/tt&gt; will allow us to change to future structure easily, either multiple livenessInfos or virtualcells. &lt;/p&gt;

&lt;p&gt;About the &lt;tt&gt;Strict Liveness&lt;/tt&gt; semantic:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;A strict row is only live iff it&apos;s row level liveness info is live, regardless of the liveness of its columns.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;My understanding is: view row is strict iff the view has non-key base row as view pk. When it&apos;s &lt;tt&gt;Strict&lt;/tt&gt;, the view&apos;s row liveness/deletion should use this non-key base column&apos;s timestamp as well as ttl, unless there is a greater row deletion.(It&apos;s like a simplified version of &quot;VirtualCells&quot; which only store metadata for non-key base column in view pk)&lt;/p&gt;

&lt;p&gt;For now, the semantic of MV: &lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;if it&apos;s strict(non-key base row as view pk), the existence of view row is only with its row livenessInfo&lt;/li&gt;
	&lt;li&gt;if it&apos;s not-strict, view row is alive if there is any live selected view columns or live livenessInfo.&lt;/li&gt;
&lt;/ul&gt;


&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;For 13127: 
   Unselected columns has no effect on liveness of view row, &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; now, till we are ready &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; design.
   It cannot be properly supported without disruptive changes, like VirtualCells or multiple livenessInfos.
   The unsupported corner cases: &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; base row is removed after unselected column removal(ttl or cell tombstone), we will have problem keeping the view row alive again by setting smaller or equal timestamp on base livenessInfo or other unselected column. (&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; updating smaller ts on selected column, view row will be alive)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;For 13547:
    It&apos;s necessary to forbid dropping filtered columns from base columns.
    The filtered column part needs to be reconsidered with 10368.
    It cannot be properly supported without disruptive changes, like VirtualCells or multiple livenessInfos
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; 13409:
    As paulo suggested, generating column tombstones when receiving a partial update &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; a previously deleted row might be a non-disruptive solution &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; cell tombstone can co-exist with row deletion which has greater timestamp.

    It is resolved by avoid using shadowable tombstone, use expired livenessInfo instead. We won&apos;t have the problem of resurrecting previous deleted data.
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;PATCH for 11500: &lt;/p&gt;
&lt;div class=&apos;table-wrap&apos;&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; &lt;a href=&quot;https://github.com/jasonstack/cassandra/commits/11500-poc&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;trunk&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; &lt;a href=&quot;https://github.com/riptano/cassandra-dtest/commits/11500-poc&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;dtest&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;


&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;Changes:
1. Removal is shadowable:
   1.1  &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; the non-key base column in view-pk is updated or deleted by partial update or partial delete. &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; non-key column is removed by row deletion, it&apos;s not shadowable.
   1.2 &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; there is no non-key base column in view-pk.
   
   Current shadowable tombstone is not used to avoid the issue of resurrecting deleted cells. We will expired-livenessInfo instead. 

2. It&apos;s strict-liveness iff there is non-key base column in view-pk. The existence of view row is solely base on &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; non-key base column.

3. If there is no non-pk base column in view-pk, the view&lt;span class=&quot;code-quote&quot;&gt;&apos;s liveness/deletion is using max of base livenessIno + unselected column. unselected column&apos;&lt;/span&gt;s ttl is used only when it affects view row liveness. Selected columns won&apos;t contribute to livenessInfo or row deletion.
    * &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; wouldn&apos;t support complex cases as explained above. eg. c/d unselected, update c@10, delete c@11, update d@5. view row should be alive but dead

4. in TableViews.java, the DeletionTracker should be applied even &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; existing has no data, eg. partition-deletion

&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt; </comment>
                            <comment id="16147044" author="pauloricardomg" created="Wed, 30 Aug 2017 10:39:59 +0000"  >&lt;p&gt;Thanks for the update! See follow-up below:&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;My understanding is: view row is strict iff the view has non-key base row as view pk. When it&apos;s Strict, the view&apos;s row liveness/deletion should use this non-key base column&apos;s timestamp as well as ttl, unless there is a greater row deletion.(It&apos;s like a simplified version of &quot;VirtualCells&quot; which only store metadata for non-key base column in view pk)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That&apos;s a good simplification of virtual cells which should allow us to fix the out-of-order update issues with non-base PK column (&lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-11500&quot; title=&quot;Obsolete MV entry may not be properly deleted&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-11500&quot;&gt;&lt;del&gt;CASSANDRA-11500&lt;/del&gt;&lt;/a&gt;,&lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-13657&quot; title=&quot;Materialized Views: Index MV on TTL&amp;#39;ed column produces orphanized view entry if another column keeps entry live&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-13657&quot;&gt;&lt;del&gt;CASSANDRA-13657&lt;/del&gt;&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;I wasn&apos;t very comfortable with our previous approach of enforcing strict liveness during row merge, since it changes a lot of low-level structures/interfaces (like BTreeRow/MergeListener, etc) to enforce a table-level setting. Since we&apos;ll probably get rid of this when doing a proper implementation of virtual cells , I updated &lt;a href=&quot;https://github.com/pauloricardomg/cassandra/commit/2b7b7c8ca79b6ef72c7c92535096c6d1d899ee43&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;on this commit&lt;/a&gt; to perform the filtering during read instead which will give us the same result but with less change in unrelated code. Do you see any problem with this approach?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;this wouldn&apos;t support complex cases as explained above. eg. c/d unselected, update c@10, delete c@11, update d@5. view row should be alive but dead&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Actually this is a bit worst than I initially thought, since unselected deletion can also shadow a previous insert (not only update) so I &lt;a href=&quot;https://github.com/pauloricardomg/cassandra/commit/4200db215bdd6a9338e5d16cc567444537104e4b&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;added&lt;/a&gt; an additional test case to testPartialDeleteUnselectedColumn with this scenario. I also &lt;a href=&quot;https://github.com/pauloricardomg/cassandra/commit/623d5f6d935b57ad3c949206b85206aea15a8844&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;added&lt;/a&gt; a note to both NEWS.txt and to the documentation explaining that it might be unsafe to perform deletion on unselected view column. I created &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-13826&quot; title=&quot;Specialize row structure to support complex Materialized Views liveness&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-13826&quot;&gt;CASSANDRA-13826&lt;/a&gt; to add proper support to this and other cases with storage engine changes.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;If there is no non-pk base column in view-pk, the view&apos;s liveness/deletion is using max of base livenessIno + unselected column. unselected column&apos;s ttl is used only when it affects view row liveness. Selected columns won&apos;t contribute to livenessInfo or row deletion.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;In order to prevent drop of unselected column to keep view row alive, I added a new &lt;a href=&quot;https://github.com/pauloricardomg/cassandra/commit/afef09233a9ee0657104319de4c8a4f76e9ad292&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;commit&lt;/a&gt; disallowing drop of base table columns until we can deal with this properly.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Current shadowable tombstone is not used to avoid the issue of resurrecting deleted cells. We will expired-livenessInfo instead.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;One problem of replacing shadowable tombstones by expired liveness info is that it stores an additional unused ttl field for every shadowed view entry to solve the commutative view deletion problem. In order to avoid this I &lt;a href=&quot;https://github.com/pauloricardomg/cassandra/commit/e0da138ab10f6c0fc014de86fb251e11358d80cc&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;updated the patch&lt;/a&gt; to only use expired ttl when a shadowable tombstone would not work along with an explanation on why that is used since it&apos;s a hack.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;in TableViews.java, the DeletionTracker should be applied even if existing has no data, eg. partition-deletion&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Is this still required after enforcing strict liveness on the &lt;a href=&quot;https://github.com/pauloricardomg/cassandra/commit/2b7b7c8ca79b6ef72c7c92535096c6d1d899ee43#diff-5636ce30e505443b3e24a1a6ba55e476R112&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;PurgeFunction&lt;/a&gt;? I removed this and also &lt;a href=&quot;https://github.com/apache/cassandra/commit/3188feb38fb63c5ca556a8273aadc84571ac1bb6&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;simplified&lt;/a&gt; &lt;tt&gt;ViewUpdateGenerator.deleteOldEntry&lt;/tt&gt; to always use shadowable deletion and it didn&apos;t seem to affect any test. Do you see any other case which could be affected by this?&lt;/p&gt;

&lt;p&gt;Also, as we discussed offline, since we are changing the row liveness/deletion computation when the view has non-key base row as view PK, this means that an older update to this column may not generate a correct shadowable deletion in the view, as shown by the example below:&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;before upgrade

base:  (k=1@5)  a=1@1  b=1@1  c=1@1

view:  (k=1 &amp;amp;&amp;amp; a=1 @5)  b=1@1  c=1@1    (old way of computing livenessInfo timestamp, max of view pk columns)
___________
after upgrade

update a = null @ 1

base:  (k=1@5)  a=null@1  b=1@1  c=1@1

view:
           (k=1 &amp;amp;&amp;amp; a=1 @5)  b=1@1  c=1@1    (old way of computing livenessInfo timestamp, max of view pk columns)
           (k=1 &amp;amp;&amp;amp; a=1 @expired at 1)              (new way of computing livenessInfo timestamp, non-key base column in view pk dominates)
 
           new expired livenessInfo cannot shadow old view row if the removal time is less the previous max
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Even though this should be a pretty unlikely scenario, it would only happen if a missed update that shadows a view PK column arrive after upgrade, which can typically happen after a hint or repair. In order to prevent against this, I added a &lt;a href=&quot;https://github.com/pauloricardomg/cassandra/commit/623d5f6d935b57ad3c949206b85206aea15a8844#diff-4302f2407249672d7845cd58027ff6e9R75&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;note&lt;/a&gt; to the &lt;tt&gt;Upgrading&lt;/tt&gt; section of &lt;tt&gt;NEWS.txt&lt;/tt&gt; explaining about this caveat and that running repair before the upgrade should be sufficient to avoid it.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jasonstack&quot; class=&quot;user-hover&quot; rel=&quot;jasonstack&quot;&gt;jasonstack&lt;/a&gt; I rebased your patch on current trunk and added the above suggestions on top of it, can you take a look and let me know what do you think? Patch and tests available below:&lt;/p&gt;
&lt;div class=&apos;table-wrap&apos;&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;trunk&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;dtest&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://github.com/apache/cassandra/compare/trunk...pauloricardomg:trunk-11500&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;branch&lt;/a&gt;&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://github.com/riptano/cassandra-dtest/compare/master...pauloricardomg:11500&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;branch&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;http://jenkins-cassandra.datastax.lan/view/Dev/view/paulomotta/job/pauloricardomg-trunk-11500-testall/lastCompletedBuild/testReport/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;testall&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;http://jenkins-cassandra.datastax.lan/view/Dev/view/paulomotta/job/pauloricardomg-trunk-11500-dtest/lastCompletedBuild/testReport/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;dtest&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;
</comment>
                            <comment id="16150303" author="jasonstack" created="Fri, 1 Sep 2017 09:50:55 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=pauloricardomg&quot; class=&quot;user-hover&quot; rel=&quot;pauloricardomg&quot;&gt;pauloricardomg&lt;/a&gt; thanks for the feedback &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/thumbs_up.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I wasn&apos;t very comfortable with our previous approach of enforcing strict liveness during row merge, since it changes a lot of low-level structures/interfaces (like BTreeRow/MergeListener, etc) to enforce a table-level setting. Since we&apos;ll probably get rid of this when doing a proper implementation of virtual cells , I updated on this commit to perform the filtering during read instead which will give us the same result but with less change in unrelated code. Do you see any problem with this approach?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;As we discussed offline, we need to make sure the raw data including tombstone, expired liveness are shipped to the coordinator side.  Enforcing strict liveness in &lt;tt&gt;ReadCommand.executeLocally()&lt;/tt&gt; would remove the row before digest or data response. Instead, we add &lt;tt&gt;enforceStrictLiveness&lt;/tt&gt; to &lt;tt&gt;Row.purge&lt;/tt&gt; to get the same result but less interfaces changes for &lt;tt&gt;Row&lt;/tt&gt;.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;One problem of replacing shadowable tombstones by expired liveness info is that it stores an additional unused ttl field for every shadowed view entry to solve the commutative view deletion problem. In order to avoid this I updated the patch to only use expired ttl when a shadowable tombstone would not work along with an explanation on why that is used since it&apos;s a hack&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Shadowable tombstone will be deprecated and use expired livenessInfo if the deletion time is greater than merged-row deletion to avoid uncessary expired livenessInfo.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;in TableViews.java, the DeletionTracker should be applied even if existing has no data, eg. partition-deletion&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It&apos;s tested by  &quot;testRangeDeletionWithFlush()&quot; in ViewTest. Without partition deletion info from deletion tracker, existing row is given as empty and it will resurrect deleted cells.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;In order to prevent against this, I added a note to the Upgrading section of NEWS.txt explaining about this caveat and that running repair before the upgrade should be sufficient to avoid it.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/thumbs_up.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;div class=&apos;table-wrap&apos;&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; source &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; unit &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; [dtest&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; &lt;a href=&quot;https://github.com/jasonstack/cassandra/commits/trunk-11500-squashed&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;trunk&lt;/a&gt; &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  &lt;a href=&quot;https://circleci.com/gh/jasonstack/cassandra/551&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://circleci.com/gh/jasonstack/cassandra/551&lt;/a&gt; &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; secondary_indexes_test.TestPreJoinCallback.resumt_test &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; &lt;a href=&quot;https://github.com/jasonstack/cassandra/commits/CASSANDRA-11500-strict-3.11&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;3.11&lt;/a&gt; &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  &lt;a href=&quot;https://circleci.com/gh/jasonstack/cassandra/557&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://circleci.com/gh/jasonstack/cassandra/557&lt;/a&gt; &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; counter_tests.TestCounters.test_13691 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; &lt;a href=&quot;https://github.com/jasonstack/cassandra/commits/CASSANDRA-11500-strict-3.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;3.0&lt;/a&gt; &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  &lt;a href=&quot;https://circleci.com/gh/jasonstack/cassandra/556&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://circleci.com/gh/jasonstack/cassandra/556&lt;/a&gt;&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  counter_tests.TestCounters.test_13691&lt;br/&gt;
authe_test.TestAuth.sysmtem_auth_ks_is_alterable_test &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; &lt;a href=&quot;https://github.com/riptano/cassandra-dtest/commits/11500-poc&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;dtest&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;


&lt;p&gt;Those failed dtests are not related.&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;Changes:
1. Using expired livenessInfo &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; computed deletion time is greater than merged row deletion. There are only 2 cases:
      a. non-pk base column used in view pk is removed by partial update or partial delete
      b. unselected base column is removed by partial update or partial delete
   
   Current shadowable tombstone is not used to avoid the issue of resurrecting deleted cells. We will expired-livenessInfo and merged base row deletion instead. 

2. It&apos;s strict-liveness iff there is non-key base column in view-pk. The existence of view row is solely base on &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; non-key base column.

3. If there is no non-pk base column in view-pk, the view&lt;span class=&quot;code-quote&quot;&gt;&apos;s liveness/deletion is using max of base livenessIno + unselected column. unselected column&apos;&lt;/span&gt;s ttl is used only when it affects view row liveness. Selected columns won&apos;t contribute to livenessInfo or row deletion.
    * &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; wouldn&apos;t support complex cases as explained above. eg. c/d unselected, update c@10, delete c@11, update d@5. view row should be alive but dead

4. in TableViews.java, the DeletionTracker should be applied even &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; existing has no data, eg. partition-deletion

5. When generating read command to read existing base data, need to query all base columns instead of view&apos;s queried column &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; base and view having same key columns to read unselected column. 
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="16153239" author="pauloricardomg" created="Tue, 5 Sep 2017 07:55:20 +0000"  >&lt;blockquote&gt;&lt;p&gt;As we discussed offline, we need to make sure the raw data including tombstone, expired liveness are shipped to the coordinator side. Enforcing strict liveness in ReadCommand.executeLocally() would remove the row before digest or data response. Instead, we add enforceStrictLiveness to Row.purge to get the same result but less interfaces changes for Row.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Excellent catch, my bad for overlooking this, but gladly you added a new dtest for it: &lt;a href=&quot;https://github.com/apache/cassandra-dtest/commit/6d77ace5361f020ba182072ade9f4ab98025c213#diff-62ba429edee6a4681782f078246c9893R993&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;test_base_column_in_view_pk_complex_timestamp_with_flush&lt;/a&gt;. Enforcing strict liveness during reconciliation on the coordinator is the correct approach to differentiate between non-existing and removed rows via strict liveness. Ideally strict liveness would be a row property but as we saw in the previous version, this requires changes a bunch of other classes and interfaces, so let&apos;s keep it as a flag to Row.purge for now.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Shadowable tombstone will be deprecated and use expired livenessInfo if the deletion time is greater than merged-row deletion to avoid uncessary expired livenessInfo.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;LGTM, this will prevent using expired liveness info in most cases. We should probably remove this as part of &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-13826&quot; title=&quot;Specialize row structure to support complex Materialized Views liveness&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-13826&quot;&gt;CASSANDRA-13826&lt;/a&gt; since we&apos;re overlading ExpiringLivenessInfo for a different purpose but it should be fine for now.&lt;/p&gt;

&lt;p&gt;Final patch and CI results look good and I&apos;m confident we&apos;ve exercised all edge cases properly with unit and dtests. Committed dtests to master as &lt;tt&gt;6d77ace5361f020ba182072ade9f4ab98025c213&lt;/tt&gt;. Commited to cassandra-3.0 branch as &lt;tt&gt;1b36740ebe66b8ed4c3d6cb64eb2419a9279dfbf&lt;/tt&gt; and merged up to cassandra-3.11 and trunk. Great job Zhao!&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Summary of improvements and fixed issues&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;This patch address most outstanding timestamp problems with MVs on the 3.x series without changing the binary or storage protocol. The remaining issues which requires storage engine and binary protocol changes will be addressed on &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-13826&quot; title=&quot;Specialize row structure to support complex Materialized Views liveness&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-13826&quot;&gt;CASSANDRA-13826&lt;/a&gt; on trunk. Below is a summary of the main changes and fixes this patch introduces.&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;* View same PK components as base

* DELETE of selected column should not affect out of order updates (testPartialDeleteSelectedColumn)
* DELETE of unselected column/collection should not affect ordered updates (testUpdateColumnNotInView, testPartialUpdateWithUnselectedCollections - CASSANDRA-13127)
* Unselected columns should keep view row alive when other columns expire (testUnselectedColumnsTTL - CASSANDRA-13127)

* Extra column on view PK

* View row should expire when view PK column expires in base (testUpdateColumnInViewPKWithTTL - CASSANDRA-13657)
* Commutative row deletion (testCommutativeRowDeletion, testCellTombstoneAndShadowableTombstones - CASSANDRA-13409)
* Out of order updates to extra column on view PK (testUpdateWithColumnTimestampBiggerThanPk, testUpdateWithColumnTimestampSmallerThanPk, CASSANDRA-11500)

* Unsupported scenarios

* DELETE of unselected column should not affect out of order updates (testPartialDeleteUnselectedColumn - CASSANDRA-13127 - Added )
* Filtering by non-PK base column (Only on C* 3.11+, disallowed on CASSANDRA-13798)

* Additional MV tests

* testNonBaseColumnInViewPk
* testRangeDeletion
* testStrictLivenessTombstone
* testFrozenCollectionsWithComplexInnerType
* testMVWithDifferentColumns
* testBaseTTLWithSameTimestampTest
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;b&gt;Summary of code changes&lt;/b&gt;&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;1. Using expired livenessInfo if computed deletion time is greater than merged row deletion. There are only 2 cases:
      a. non-pk base column used in view pk is removed by partial update or partial delete
      b. unselected base column is removed by partial update or partial delete
   
   Current shadowable tombstone is not used to avoid the issue of resurrecting deleted cells (CASSANDRA-13049). We will expired-livenessInfo and merged base row deletion instead.

2. It&apos;s strict-liveness iff there is non-key base column in view-pk. The existence of view row is solely base on this non-key base column.

3. If there is no non-base PK column in view-pk, the view&apos;s liveness/deletion is using max of base livenessIno + unselected column. unselected column&apos;s ttl is used only when it affects view row liveness. Selected columns won&apos;t contribute to livenessInfo or row deletion.
    * this wouldn&apos;t support complex cases as explained above. eg. c/d unselected, update c@10, delete c@11, update d@5. view row should be alive but dead - We added a note to NEWS.txt as well as documentation about this unsupported case.
    * since we change the way the deletion timestamp is computed in this case, an older deletion to the non-base PK may not properly shadow a previous view row with a greater timestamp, so repair should be run before upgrade on the base table to ensure deletions are properly generated with the previous approach, or alternatively repair can be run on the views after upgrade (added note to NEWS.txt).

4. in TableViews.java, the DeletionTracker should be applied even if existing has no data, eg. partition-deletion

5. When generating read command to read existing base data, need to query all base columns instead of view&apos;s queried column if base and view having same key columns to read unselected column.

6. Fix handling of timestamp tie on PrimaryKeyLivenessInfo to match the one for cell resolution: on timestamp tie, greater timestamp supersede lower timestamp and TTL supersedes non-TTL (tested on testBaseTTLWithSameTimestampTest).

7. Disallow drop of columns on base tables with MVs because we cannot tell if the dropped column is keeping a view row alive (will be fixed on CASSANDRA-13826)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="16153337" author="jasonstack" created="Tue, 5 Sep 2017 09:13:10 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=pauloricardomg&quot; class=&quot;user-hover&quot; rel=&quot;pauloricardomg&quot;&gt;pauloricardomg&lt;/a&gt; &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/thumbs_up.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; thanks for the feedback, review, improvements.&lt;/p&gt;</comment>
                            <comment id="16154716" author="kurtg" created="Wed, 6 Sep 2017 02:27:04 +0000"  >&lt;p&gt;Looks good. Thanks for all the hard work &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jasonstack&quot; class=&quot;user-hover&quot; rel=&quot;jasonstack&quot;&gt;jasonstack&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=pauloricardomg&quot; class=&quot;user-hover&quot; rel=&quot;pauloricardomg&quot;&gt;pauloricardomg&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="16170065" author="pauloricardomg" created="Mon, 18 Sep 2017 14:11:14 +0000"  >&lt;p&gt;Committed &lt;tt&gt;afc55e8fe103597ef2a663be21828861a4832be7&lt;/tt&gt; and &lt;tt&gt;6220394e84c79e6ef94651fc5e0aa03c12ddd307&lt;/tt&gt; to cassandra-dtest with a minor fix to &lt;tt&gt;test_base_column_in_view_pk_complex_timestamp&lt;/tt&gt; flakiness and minor change to &lt;tt&gt;test_base_column_in_view_pk_complex_timestamp&lt;/tt&gt; to make it work on 3.0.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="12310000">
                    <name>Duplicate</name>
                                            <outwardlinks description="duplicates">
                                        <issuelink>
            <issuekey id="13074220">CASSANDRA-13547</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="13035319">CASSANDRA-13127</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="13061470">CASSANDRA-13409</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is duplicated by">
                                        <issuelink>
            <issuekey id="12927067">CASSANDRA-10965</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="13074220">CASSANDRA-13547</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="13097486">CASSANDRA-13798</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="13098840">CASSANDRA-13832</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="13035319">CASSANDRA-13127</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="13061470">CASSANDRA-13409</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="13084208">CASSANDRA-13657</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="13120890">CASSANDRA-14071</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12313920" key="com.atlassian.jira.plugin.system.customfieldtypes:multiuserpicker">
                        <customfieldname>Authors</customfieldname>
                        <customfieldvalues>
                                    <customfieldvalue><![CDATA[jasonstack]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12313825" key="com.atlassian.jira.plugin.system.customfieldtypes:cascadingselect">
                        <customfieldname>Bug Category</customfieldname>
                        <customfieldvalues>
                                                    <customfieldvalue key="12982" cascade-level=""><![CDATA[Correctness]]></customfieldvalue>
                                <customfieldvalue key="12988" cascade-level="1"><![CDATA[API / Semantic Implementation]]></customfieldvalue>
            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            8 years, 9 weeks, 1 day ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i2vnmn:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_10022" key="com.atlassian.jira.plugin.system.customfieldtypes:userpicker">
                        <customfieldname>Reviewer</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>pauloricardomg</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12313420" key="com.atlassian.jira.plugin.system.customfieldtypes:multiuserpicker">
                        <customfieldname>Reviewers</customfieldname>
                        <customfieldvalues>
                                    <customfieldvalue><![CDATA[pauloricardomg]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12313820" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Severity</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="12962"><![CDATA[Normal]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>