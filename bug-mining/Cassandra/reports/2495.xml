<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 22:41:42 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[CASSANDRA-5519] Reduce index summary memory use for cold sstables</title>
                <link>https://issues.apache.org/jira/browse/CASSANDRA-5519</link>
                <project id="12310865" key="CASSANDRA">Apache Cassandra</project>
                    <description></description>
                <environment></environment>
        <key id="12645053">CASSANDRA-5519</key>
            <summary>Reduce index summary memory use for cold sstables</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="10003" iconUrl="https://issues.apache.org/jira/images/icons/priorities/trivial.svg">Low</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="thobbs">Tom Hobbs</assignee>
                                    <reporter username="jbellis">Jonathan Ellis</reporter>
                        <labels>
                    </labels>
                <created>Sat, 27 Apr 2013 22:03:25 +0000</created>
                <updated>Tue, 16 Apr 2019 09:32:13 +0000</updated>
                            <resolved>Fri, 22 Nov 2013 18:13:25 +0000</resolved>
                                        <fixVersion>2.1 beta1</fixVersion>
                                        <due></due>
                            <votes>0</votes>
                                    <watches>7</watches>
                                                                                                                <comments>
                            <comment id="13726788" author="thobbs" created="Thu, 1 Aug 2013 19:47:17 +0000"  >&lt;p&gt;An initial idea for the implementation:&lt;/p&gt;

&lt;p&gt;Based on the recent (last 15m?) read rate (reads/sec), periodically down-sample the summary for SSTables which fall below the mean rate.  The down-sampling rate could use a sliding scale based on the ratio of the mean to that SSTable&apos;s rate.  As a example basic implementation, keep X% of the samples, where &lt;tt&gt;X = max(25, min(100, 100 * (rate / mean_rate)))&lt;/tt&gt;, so the coldest SSTables keep only 25% of the samples in memory.&lt;/p&gt;

&lt;p&gt;Presenting a way for the user to tune this (other than a simple on/off) is a little trickier.  Perhaps make the min (default 25%) adjustable?  Or start down-sampling at a configurable point (the default is the mean)?  Those could also be automatically adjusted based on memory pressure.&lt;/p&gt;</comment>
                            <comment id="13731589" author="jbellis" created="Wed, 7 Aug 2013 02:41:26 +0000"  >&lt;p&gt;Good start, but it seems a little fragile to me if a bunch of sstables are suddenly warmed up.&lt;/p&gt;

&lt;p&gt;What about this?&lt;/p&gt;

&lt;p&gt;We could define a fixed-size memory pool, similar to what we do for memtables or cache, and allocate it to the sstables proportional to their hotness.  Every 15 minutes (which seems like a lot, maybe hourly?) we recalculate and rebuild the summaries.  Maybe we only rebuild the ones that are X% off of where they should be to make it lighter-weight.  Or if we&apos;re downsampling by more than 2x then we can just resample what we already have in memory instead of rebuilding &quot;correctly.&quot;&lt;/p&gt;</comment>
                            <comment id="13732588" author="thobbs" created="Wed, 7 Aug 2013 19:03:27 +0000"  >&lt;blockquote&gt;&lt;p&gt;We could define a fixed-size memory pool, similar to what we do for memtables or cache, and allocate it to the sstables proportional to their hotness.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It would be hard to describe this in text, so here&apos;s my pythonic psuedocode for distributing the fixed-size memory pool:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;total_reads_per_sec = sum(sstable.reads_per_sec for sstable in sstables)
sstables_to_downsample = set()
leftover_entries = 0
for sstable in sstables:
    allocated_space = total_space * (sstable.reads_per_sec / total_reads_per_sec)
    num_entries = total_space / (SPACE_PER_ENTRY)  # space per entry = token + position + overhead
    if (num_entries &amp;gt; sstable.max_index_summary_entries):
        sstable.num_index_summary_entries = max_index_summary_entries
        leftover_entries = num_entries - sstable.max_index_summary_entries
    else
        sstable.num_index_summary_entries = num_entries
        sstables_to_downsample.add(sstable)

# distribute leftover_entries among sstables_to_downsample based on read rates
# (this probably ends up looking like a recursive or iterative function)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;&lt;p&gt;Maybe we only rebuild the ones that are X% off of where they should be to make it lighter-weight.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That&apos;s a good idea. (I was thinking of using a step function.)  Instead of &quot;X% off of where they should be&quot;, I would more precisely phrase that as &quot;X% away from their previous proportion&quot;.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Or if we&apos;re downsampling by more than 2x then we can just resample what we already have in memory instead of rebuilding &quot;correctly.&quot;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;If you down-sample with a particular pattern, you can always down-sample using just the in-memory points; only up-samples need to read from disk.&lt;/p&gt;

&lt;p&gt;I&apos;m trying to generalize the down-sampling pattern, but the two main points are (assuming 1% granularity):&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;For every 1% you down-sample, the number of points to remove from the in-memory summary is equal to 1% of the original (on-disk) count&lt;/li&gt;
	&lt;li&gt;Each 1% down-sampling run starts at a different offset to evenly space the down-sampling&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;For example, to down-sample from 100% to 99%, you would remove every hundredth point, starting from index 0.  To down-sample from 99% to 98%, you would remove every 99th point, starting from index 50.  To down-sample from 98% to 97%, you would remove every 98th point, starting from index 24 or 74, and so on.&lt;/p&gt;</comment>
                            <comment id="13733593" author="jbellis" created="Thu, 8 Aug 2013 15:21:49 +0000"  >&lt;p&gt;Sounds reasonable.&lt;/p&gt;</comment>
                            <comment id="13802386" author="thobbs" created="Tue, 22 Oct 2013 22:53:12 +0000"  >&lt;p&gt;The attached downsample.py script demonstrates the downsampling algorithm.  It&apos;s a touch complex, but it would be easy to precompute or cache the downsampling patterns if needed.&lt;/p&gt;

&lt;p&gt;An example run with an original index summary size of 16 and a &quot;resolution&quot; of 8, meaning each minimal downsample run will remove 1/8th of the original points.  The top row is the original index summary and each row below that represents one downsampling run:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;~ $ ./downsample.py 16 8
  0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
      1   2   3   4   5   6   7       9  10  11  12  13  14  15
      1   2   3       5   6   7       9  10  11      13  14  15
      1       3       5   6   7       9      11      13  14  15
      1       3       5       7       9      11      13      15
              3       5       7              11      13      15
              3               7              11              15
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="13802408" author="jbellis" created="Tue, 22 Oct 2013 23:20:23 +0000"  >&lt;p&gt;LGTM&lt;/p&gt;</comment>
                            <comment id="13810813" author="thobbs" created="Thu, 31 Oct 2013 22:20:33 +0000"  >&lt;p&gt;How do we want to handle the memory pool not being large enough to accommodate all of the index summaries (even after downsampling)?  Just make it a best-effort?&lt;/p&gt;</comment>
                            <comment id="13820653" author="thobbs" created="Tue, 12 Nov 2013 23:34:17 +0000"  >&lt;p&gt;I need to put this through more thorough testing and benchmarking, but I think it&apos;s at a good point for a preliminary review: &lt;a href=&quot;https://github.com/thobbs/cassandra/compare/CASSANDRA-5519&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/thobbs/cassandra/compare/CASSANDRA-5519&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;A few comments/questions:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;I went with best-effort for the memory pool (if all summaries don&apos;t fit in the allotted space even at the minimum sampling level, there&apos;s nothing we can do about it).  The amount of memory used may also temporarily exceed the limit while building new summaries.&lt;/li&gt;
	&lt;li&gt;There are two new cassandra.yaml options: one for controlling the memory pool size and one for regulating how frequently summaries are resized.  These can also be set through JMX. We could conceivably also make the down/upsample thresholds and the minimum sampling level configurable.  All of these default values are just guesses.&lt;/li&gt;
	&lt;li&gt;I went with a reference counting strategy for free&apos;ing the IndexSummary&apos;s Memory.  This makes the API a bit unpleasant (mostly in SSTR), but it should have low overhead.  A ReadWriteLock might also work well instead of this with a cleaner API; let me know if I should benchmark the two for comparison.&lt;/li&gt;
	&lt;li&gt;I&apos;m triggering the IndexSummaryManager singleton&apos;s initialization in DatabaseDescriptor; this feels wrong, so I&apos;m open to suggestions.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="13821991" author="jbellis" created="Wed, 13 Nov 2013 23:49:01 +0000"  >&lt;p&gt;What is the relationship between BASE_SAMPLING_LEVEL and MIN_SAMPLING_LEVEL with indexInterval?&lt;/p&gt;

&lt;p&gt;How many rows do we get for 5% of a 8GB heap?&lt;/p&gt;

&lt;p&gt;Isn&apos;t it a minor bug to just ignore compacting sstables?  Suggest reducing memory pool to allocate to the uncompacting ones, by the amount allocated to the compacting ones.&lt;/p&gt;

&lt;p&gt;Could we just resample at compaction time instead of dealing with refcounting or locking?  That probably gives up too much of the potential benefits.  But I think we could make it almost as elegant by using the datatracker replace mechanism originally for compaction, to build a new SSTR and swap it in w/o extra concurrency controls.&lt;/p&gt;

&lt;p&gt;Is the idea behind touching it in DD to force the mbean to be loaded, or is there a circular dependency that breaks w/o that?&lt;/p&gt;</comment>
                            <comment id="13822623" author="thobbs" created="Thu, 14 Nov 2013 17:06:25 +0000"  >&lt;blockquote&gt;&lt;p&gt;What is the relationship between BASE_SAMPLING_LEVEL and MIN_SAMPLING_LEVEL with indexInterval?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;tt&gt;BASE/MIN_SAMPLING_LEVEL&lt;/tt&gt; are orthogonal to &lt;tt&gt;indexInterval&lt;/tt&gt;.  &lt;tt&gt;BASE_SAMPLING_LEVEL&lt;/tt&gt; essentially sets the granularity at which you can down/upsample.  &lt;tt&gt;MIN_SAMPLING_LEVEL&lt;/tt&gt; sets a limit on how low you can downsample.  (I&apos;ll note that we could potentially raise &lt;tt&gt;indexInterval&lt;/tt&gt; alongside these changes in order to have more summary entries for hot sstables.)&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;How many rows do we get for 5% of a 8GB heap?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That gives us ~410 MiB to work with.  If we assume the average key length is 8 bytes, each summary entry uses 20 bytes of space, giving us ~21 million summary entries.&lt;/p&gt;

&lt;p&gt;At full sampling, that&apos;s 21MM * 128 = 2.7 billion rows, assuming no overlap across sstables. At minimum sampling, that&apos;s ~11 billion rows.&lt;/p&gt;

&lt;p&gt;If the avg key size is 16 bytes, that drops to ~2 and ~8 billion rows.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Isn&apos;t it a minor bug to just ignore compacting sstables? Suggest reducing memory pool to allocate to the uncompacting ones, by the amount allocated to the compacting ones.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Good point, I agree.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Could we just resample at compaction time instead of dealing with refcounting or locking? That probably gives up too much of the potential benefits.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yeah, that would probably be okay for small sstables that are compacted frequently, but the large sstables would be tuned poorly, and those make up the majority of the memory use.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I think we could make it almost as elegant by using the datatracker replace mechanism originally for compaction, to build a new SSTR and swap it in w/o extra concurrency controls.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That&apos;s a good idea; I think it would be fairly clean.  I&apos;ll give that a shot.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Is the idea behind touching it in DD to force the mbean to be loaded, or is there a circular dependency that breaks w/o that?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Neither the &lt;tt&gt;IndexSummaryManager&lt;/tt&gt; singleton nor the mbean are loaded without that.  No other classes use the &lt;tt&gt;IndexSummaryManager&lt;/tt&gt;,&lt;br/&gt;
so the static fields are never initialized.  (Just importing the classes doesn&apos;t seem to trigger the class loader.)&lt;/p&gt;</comment>
                            <comment id="13823091" author="jbellis" created="Thu, 14 Nov 2013 23:12:05 +0000"  >&lt;p&gt;Pushed my cleanup to &lt;a href=&quot;https://github.com/jbellis/cassandra/commits/5519&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/jbellis/cassandra/commits/5519&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;(Moved the ISM init to StorageService were we have some existing examples of similar.)&lt;/p&gt;</comment>
                            <comment id="13823099" author="jbellis" created="Thu, 14 Nov 2013 23:21:24 +0000"  >&lt;p&gt;Rather than expose MSL directly as a config option, how about changing index_interval to max_index_interval and adding a min_index_interval?  We could compute (as close as possible) MSL from min_index_interval.&lt;/p&gt;

&lt;p&gt;(I don&apos;t think users will need to tune BSL.  128 lets us be accurate to with in 1% which seems totally reasonable to me.)&lt;/p&gt;</comment>
                            <comment id="13823118" author="thobbs" created="Thu, 14 Nov 2013 23:39:04 +0000"  >&lt;p&gt;The cleanup looks good overall, thanks.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Rather than expose MSL directly as a config option, how about changing index_interval to max_index_interval and adding a min_index_interval? We could compute (as close as possible) MSL from min_index_interval.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That sounds good to me.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;(I don&apos;t think users will need to tune BSL. 128 lets us be accurate to with in 1% which seems totally reasonable to me.)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Agreed.&lt;/p&gt;</comment>
                            <comment id="13827060" author="thobbs" created="Tue, 19 Nov 2013 23:00:29 +0000"  >&lt;p&gt;Would it be alright to split the replacement of &lt;tt&gt;index_interval&lt;/tt&gt; by &lt;tt&gt;max_index_interval&lt;/tt&gt; and &lt;tt&gt;min_index_interval&lt;/tt&gt; into another ticket just for sanity&apos;s sake?  It looks like a lot of changes need to be done for that, and they&apos;re independent of the changes for this ticket.&lt;/p&gt;</comment>
                            <comment id="13827100" author="jbellis" created="Tue, 19 Nov 2013 23:39:25 +0000"  >&lt;p&gt;WFM.  What does that leave for this one?&lt;/p&gt;</comment>
                            <comment id="13827108" author="thobbs" created="Tue, 19 Nov 2013 23:44:04 +0000"  >&lt;blockquote&gt;&lt;p&gt;WFM. What does that leave for this one?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I still need to account for spaced used by compacting SSTables, and I&apos;m putting it through some more thorough testing.&lt;/p&gt;</comment>
                            <comment id="13827114" author="thobbs" created="Tue, 19 Nov 2013 23:46:39 +0000"  >&lt;p&gt;Created &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-6379&quot; title=&quot;Replace index_interval with min/max_index_interval&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-6379&quot;&gt;&lt;del&gt;CASSANDRA-6379&lt;/del&gt;&lt;/a&gt; for the &lt;tt&gt;index_interval&lt;/tt&gt; changes.&lt;/p&gt;</comment>
                            <comment id="13829170" author="thobbs" created="Thu, 21 Nov 2013 18:08:52 +0000"  >&lt;p&gt;This should be good for a second round of reviewing.  I opened a pull request against my own repo so that you can comment inline, if you&apos;d like: &lt;a href=&quot;https://github.com/thobbs/cassandra/pull/1&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/thobbs/cassandra/pull/1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Changes since the last review:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;The entire &lt;tt&gt;SSTableReader&lt;/tt&gt; is replaced instead of just the IndexSummary.&lt;/li&gt;
	&lt;li&gt;Space used by compacting SSTables is accounted for&lt;/li&gt;
	&lt;li&gt;Enough extra space is reserved to cover rebuilding the largest summary&lt;/li&gt;
	&lt;li&gt;In order to stay within the memory usage limit on startup, the on-disk Summary is replaced whenever it is resampled.  I increased the threshold for downsampling to make this less frequent.  The alternative would be to always keep the full summary on disk and have a somewhat more complicated startup procedure.  I would appreciate your thoughts on this.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="13829178" author="thobbs" created="Thu, 21 Nov 2013 18:16:54 +0000"  >&lt;p&gt;I should also mention that if you want to test it out, I suggest setting logging to TRACE for o.a.c.io.sstable.IndexSummary manager, &lt;tt&gt;index_summary_capacity_in_mb&lt;/tt&gt; to 1, and &lt;tt&gt;index_summary_resize_interval_in_minutes&lt;/tt&gt; to 1.  That should give you a good picture of what&apos;s going on.&lt;/p&gt;</comment>
                            <comment id="13829201" author="jbellis" created="Thu, 21 Nov 2013 18:37:49 +0000"  >&lt;blockquote&gt;&lt;p&gt;the on-disk Summary is replaced whenever it is resampled&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Good call; startup time is a big pain point for some people and we don&apos;t want to make that worse.&lt;/p&gt;</comment>
                            <comment id="13829374" author="thobbs" created="Thu, 21 Nov 2013 21:32:01 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jbellis&quot; class=&quot;user-hover&quot; rel=&quot;jbellis&quot;&gt;jbellis&lt;/a&gt; Attached patch 5519-v1.txt includes your suggested changes.  (My &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-5519&quot; title=&quot;Reduce index summary memory use for cold sstables&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-5519&quot;&gt;&lt;del&gt;CASSANDRA-5519&lt;/del&gt;&lt;/a&gt; branch is still good, as well.)&lt;/p&gt;</comment>
                            <comment id="13829406" author="jbellis" created="Thu, 21 Nov 2013 22:19:00 +0000"  >&lt;p&gt;I&apos;m pretty sure we can get rid of the isReplaced flag now.&lt;/p&gt;</comment>
                            <comment id="13829417" author="thobbs" created="Thu, 21 Nov 2013 22:34:53 +0000"  >&lt;blockquote&gt;&lt;p&gt;I&apos;m pretty sure we can get rid of the isReplaced flag now.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;We still need it in order to do the proper cleanup on the replaced SSTR once all references are released, unless I&apos;m missing something.&lt;/p&gt;</comment>
                            <comment id="13829475" author="jbellis" created="Thu, 21 Nov 2013 23:36:57 +0000"  >&lt;p&gt;Hmm.  I see two uses of isReplaced:&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;releaseReference, which can be reverted back to trunk form since isReplaced == !isCompacted&lt;/li&gt;
	&lt;li&gt;close, which is only called by snapshot repair (and releaseReference) which will never do any index summary replacements&lt;/li&gt;
&lt;/ol&gt;
</comment>
                            <comment id="13830123" author="thobbs" created="Fri, 22 Nov 2013 17:17:37 +0000"  >&lt;blockquote&gt;&lt;p&gt;releaseReference, which can be reverted back to trunk form since isReplaced == !isCompacted&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;True&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;close, which is only called by snapshot repair (and releaseReference) which will never do any index summary replacements&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;We still need to have different behavior for the &lt;tt&gt;close()&lt;/tt&gt; call by snapshot repair, as it needs to perform the full close even though &lt;tt&gt;isCompacted&lt;/tt&gt; will be false.  While we could add a parameter to close() or define a &lt;tt&gt;closeReplacedReader()&lt;/tt&gt; method, it seems clearer and more future-proof to keep the isReplaced flag.&lt;/p&gt;</comment>
                            <comment id="13830184" author="jbellis" created="Fri, 22 Nov 2013 18:13:25 +0000"  >&lt;p&gt;WFM.  Committed!&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10001">
                    <name>dependent</name>
                                            <outwardlinks description="depends upon">
                                        <issuelink>
            <issuekey id="12644626">CASSANDRA-5515</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is depended upon by">
                                        <issuelink>
            <issuekey id="12680065">CASSANDRA-6379</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12615198" name="5519-v1.txt" size="109461" author="thobbs" created="Thu, 21 Nov 2013 21:32:01 +0000"/>
                            <attachment id="12609747" name="downsample.py" size="2615" author="thobbs" created="Tue, 22 Oct 2013 22:53:12 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12313920" key="com.atlassian.jira.plugin.system.customfieldtypes:multiuserpicker">
                        <customfieldname>Authors</customfieldname>
                        <customfieldvalues>
                                    <customfieldvalue><![CDATA[thobbs]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>325415</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            12 years, 4 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i1k547:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>325760</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_10022" key="com.atlassian.jira.plugin.system.customfieldtypes:userpicker">
                        <customfieldname>Reviewer</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>jbellis</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12313420" key="com.atlassian.jira.plugin.system.customfieldtypes:multiuserpicker">
                        <customfieldname>Reviewers</customfieldname>
                        <customfieldvalues>
                                    <customfieldvalue><![CDATA[jbellis]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12313820" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Severity</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="12961"><![CDATA[Low]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>