<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 22:33:50 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[CASSANDRA-3862] RowCache misses Updates</title>
                <link>https://issues.apache.org/jira/browse/CASSANDRA-3862</link>
                <project id="12310865" key="CASSANDRA">Apache Cassandra</project>
                    <description>&lt;p&gt;While performing stress tests to find any race problems for &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-2864&quot; title=&quot;Alternative Row Cache Implementation&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-2864&quot;&gt;&lt;del&gt;CASSANDRA-2864&lt;/del&gt;&lt;/a&gt; I guess I (re-)found one for the standard on-heap row cache.&lt;/p&gt;

&lt;p&gt;During my stress test I hava lots of threads running with some of them only reading other writing and re-reading the value.&lt;/p&gt;

&lt;p&gt;This seems to happen:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Reader tries to read row A for the first time doing a getTopLevelColumns&lt;/li&gt;
	&lt;li&gt;Row A which is not in the cache yet is updated by Writer. The row is not eagerly read during write (because we want fast writes) so the writer cannot perform a cache update&lt;/li&gt;
	&lt;li&gt;Reader puts the row in the cache which is now missing the update&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I already asked this some time ago on the mailing list but unfortunately didn&apos;t dig after I got no answer since I assumed that I just missed something. In a way I still do but haven&apos;t found any locking mechanism that makes sure that this should not happen.&lt;/p&gt;

&lt;p&gt;The problem can be reproduced with every run of my stress test. When I restart the server the expected column is there. It&apos;s just missing from the cache.&lt;/p&gt;

&lt;p&gt;To test I have created a patch that merges memtables with the row cache. With the patch the problem is gone.&lt;/p&gt;

&lt;p&gt;I can also reproduce in 0.8. Haven&apos;t checked 1.1 but I haven&apos;t found any relevant change their either so I assume the same aplies there.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12541448">CASSANDRA-3862</key>
            <summary>RowCache misses Updates</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="10002" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.svg">Normal</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="slebresne">Sylvain Lebresne</assignee>
                                    <reporter username="doubleday">Daniel Doubleday</reporter>
                        <labels>
                    </labels>
                <created>Mon, 6 Feb 2012 17:17:16 +0000</created>
                <updated>Tue, 16 Apr 2019 09:32:40 +0000</updated>
                            <resolved>Tue, 28 Feb 2012 18:03:19 +0000</resolved>
                                        <fixVersion>1.1.0</fixVersion>
                                        <due></due>
                            <votes>0</votes>
                                    <watches>4</watches>
                                                                                                                <comments>
                            <comment id="13201406" author="doubleday" created="Mon, 6 Feb 2012 17:19:35 +0000"  >&lt;p&gt;Dunno if there&apos;s a better way to do it...&lt;/p&gt;</comment>
                            <comment id="13201436" author="slebresne" created="Mon, 6 Feb 2012 18:04:05 +0000"  >&lt;p&gt;I believe you are absolutely right that this is a bug.&lt;/p&gt;

&lt;p&gt;Unfortunately I don&apos;t think including the memtables during cache reads really solves it. If you miss an update, it won&apos;t ever get added to the cached row, but the update itself will be flushed at some point and thus not be in any memtable anymore.&lt;/p&gt;

&lt;p&gt;One partial solution I see could be that when a read &apos;reads for caching&apos;, it starts adding some sentinel object in the cache for the given row key. That sentinel would need to be an actual (empty) row but marked with the fact it&apos;s only a sentinel. When a write look if the row is cache, if it&apos;s a sentinel we would add the write to the sentinel. Once the read returns and we actually put the row in cache, we would it (atomically) with the content of the sentinel. A read that check the cache and see a sentinel would just skip the cache (and would not put it&apos;s result into the cache). Adapting that to the serializingCache is trivial.&lt;/p&gt;

&lt;p&gt;Unfortunately, this is not perfect because this would screw counters. Though I guess for counters we could do the same thing as we would do for the serializingCache, i.e, if a read that &apos;reads for caching&apos; see that the sentinel is not empty, we would just not cache the result (i.e, a row would be cache only if we are sure no write were done concurrently to the read).&lt;/p&gt;</comment>
                            <comment id="13201499" author="doubleday" created="Mon, 6 Feb 2012 19:32:34 +0000"  >&lt;blockquote&gt;&lt;p&gt;If you miss an update, it won&apos;t ever get added to the cached row, but the update itself will be flushed at some point and thus not be in any memtable anymore.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Very true ...&lt;/p&gt;

&lt;p&gt;How about adopting the strategy we apply with &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-2864&quot; title=&quot;Alternative Row Cache Implementation&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-2864&quot;&gt;&lt;del&gt;CASSANDRA-2864&lt;/del&gt;&lt;/a&gt;:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Writers dont update the cache at all&lt;/li&gt;
	&lt;li&gt;Readers merge cache with memtables&lt;/li&gt;
	&lt;li&gt;Upon flush merge memtables with cache&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="13201519" author="slebresne" created="Mon, 6 Feb 2012 19:58:43 +0000"  >&lt;blockquote&gt;
&lt;p&gt;How about adopting the strategy we apply with &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-2864&quot; title=&quot;Alternative Row Cache Implementation&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-2864&quot;&gt;&lt;del&gt;CASSANDRA-2864&lt;/del&gt;&lt;/a&gt;:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Writers dont update the cache at all&lt;/li&gt;
	&lt;li&gt;Readers merge cache with memtables&lt;/li&gt;
	&lt;li&gt;Upon flush merge memtables with cache&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;The problem with that is that I don&apos;t see how we can make that work for counters at all. I also think it would be nice not having to merge on reads if we can avoid it (even if it&apos;s in-memory, it still uses CPU).&lt;/p&gt;

&lt;p&gt;As a side note, I also suspect it&apos;s not bulletproof in theory, as a memtable could be fully flushed while a &apos;read to be cached&apos; happens and with a bad timing during that, we could still miss an update. Of course, that kind of timing have almost no chance to happen. But in the case where a user triggers a flush manually, a memtable with only a handful of columns could be flushed very quickly, and I suspect the behavior could be observed. However unlikely that is, it&apos;d be better if we can fix this problem once and for all.&lt;/p&gt;

&lt;p&gt;I&apos;ll probably give a shot to my &apos;sentinel&apos; proposal described above, I don&apos;t think it&apos;s too much code.&lt;/p&gt;</comment>
                            <comment id="13201610" author="doubleday" created="Mon, 6 Feb 2012 21:25:41 +0000"  >&lt;p&gt;Hmokay ... don&apos;t want to abuse Jira as an educational forum but maybe as a reward for the bugreport &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; ... are you saying that a reader could see a memtable view where flushing memtables are gone (flushed) and sstables don&apos;t contain the flushed memtables?&lt;/p&gt;

&lt;p&gt;If that&apos;s the case than yes the cache would lose an update. But that what also imply that a read could miss an update without caching being in place at all no?&lt;/p&gt;

&lt;p&gt;Otherwise (and that&apos;s how I read the code) given that the memtable switch will only happen after the merge the reader will read all updates because they are either in (flushing) memtables or in sstables and the cache will be in fact valid.&lt;/p&gt;
</comment>
                            <comment id="13202145" author="slebresne" created="Tue, 7 Feb 2012 07:38:32 +0000"  >&lt;p&gt;To be precise, what I&apos;m saying is that (at least in theory) the following scenario would be possible:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;A read-for-cache read the memtables grabing updates&lt;/li&gt;
	&lt;li&gt;then it start reading the sstables&lt;/li&gt;
	&lt;li&gt;while the previous happens, a new update arrives. The memtable is then flushed and happens to be fully flushed &lt;b&gt;before&lt;/b&gt; our read-for-cache completes.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;In that case, the new update won&apos;t be part of the cached row (ever) because during the flush (when we would merge the memtable to the cache) the row was not in the cache yet. That may seem far fetched but consider a simple implementation of you proposition, where the &apos;upon flush merge memtables with cache&apos; phase happens in the same loop over rows that is used for flushing. It is actually possible for a new write to be &quot;flushed&quot; within a few milliseconds of being received by the node: if the update triggers the memtable threshold &lt;b&gt;and&lt;/b&gt; sorts at the very beginning of the memtable. But don&apos;t get me wrong, it would probably be possible to deal with that problem, but it feels a bit complicated and error prone.&lt;/p&gt;
</comment>
                            <comment id="13202494" author="slebresne" created="Tue, 7 Feb 2012 16:04:07 +0000"  >&lt;p&gt;Patch attached with my &quot;sentinel&quot; idea (The patch is against 1.1 currently). I &lt;b&gt;think&lt;/b&gt; this fixes the problem, and this deal with counters.&lt;/p&gt;</comment>
                            <comment id="13202833" author="doubleday" created="Tue, 7 Feb 2012 21:48:02 +0000"  >&lt;p&gt;Just had a look at it and maybe I got it wrong but:&lt;/p&gt;

&lt;p&gt;CFS.getRawCachedRow returns null for a sentinel and CFS.updateRowCache calls this.&lt;br/&gt;
Isn&apos;t updateRowCache supposed to add changes to the sentinel so that cacheRow can detect the race?&lt;/p&gt;</comment>
                            <comment id="13203615" author="slebresne" created="Wed, 8 Feb 2012 13:58:01 +0000"  >&lt;p&gt;You&apos;re right, thanks for catching that. Attached v2 fixed this (I realized that when we hit the cache during range_slice queries we don&apos;t update the statistics, which I&apos;m not sure is what we want, but it&apos;s unrelated to that issue so haven&apos;t changed it).&lt;/p&gt;</comment>
                            <comment id="13205891" author="jbellis" created="Sat, 11 Feb 2012 00:01:05 +0000"  >&lt;p&gt;Looks to me like we might be able to simplify things by splitting the &quot;initialize row cache&quot; code (which can assume the cache is empty, and does not need a filter) out from the &quot;look up a cached row and cache it if it is not present&quot; method.&lt;/p&gt;

&lt;p&gt;Nit: although not perfect, IMO &quot;getRawCachedRow&quot; is a better method name than &quot;getCachedRowNoStats&quot; &amp;#8211; the important thing to convey is that we&apos;re only inspecting the cache&apos;s contents, not changing them.&lt;/p&gt;</comment>
                            <comment id="13206870" author="slebresne" created="Mon, 13 Feb 2012 13:33:59 +0000"  >&lt;p&gt;Attaching v3. This mostly fix a but of the previous version where sentinels were not handled correctly in cacheRow(). I&apos;ve also switch back to getRawCachedRow.&lt;br/&gt;
I&apos;m not fully sure what you proposed to split exactly, but v3 does split cacheRow() in the hope of increasing clarity. &lt;/p&gt;</comment>
                            <comment id="13207035" author="jbellis" created="Mon, 13 Feb 2012 18:23:58 +0000"  >&lt;p&gt;Attached cleanup patch that applies on top of v3.  Most of the changes are adding docstrings/comments and cleaning up typos.&lt;/p&gt;

&lt;p&gt;A minor change to the code was to make cacheRow take just cfId and filter, removing the redundant filter.key as a parameter.&lt;/p&gt;

&lt;p&gt;I also renamed cacheRow to getThroughCache.  Still not 100% happy with that, but my goal is to make the distinction between readAndCache more obvious.&lt;/p&gt;

&lt;p&gt;Finally, I&apos;ve modified the logic in invalidateCachedRow according to the reasoning in this comment:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;.       // This method is used to (1) drop obsolete entries from a copying cache after the row in question was updated
        // and to (2) make sure we&apos;re not wasting cache space on rows that don&apos;t exist anymore post-compaction.
        // Sentinels complicate this because it means we&apos;ve caught a read thread in the process of loading
        // the cache, and we don&apos;t know (in case 2) if it will do so with rows from before the compaction or after,
        // so we need to loop until the load completes.
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;(I also negated the loop condition, which looked like an oversight.)&lt;/p&gt;</comment>
                            <comment id="13207637" author="slebresne" created="Tue, 14 Feb 2012 11:16:17 +0000"  >&lt;p&gt;The cleanup lgtm.&lt;/p&gt;

&lt;p&gt;For the change to invalidateCacheRow however, I wonder if it&apos;s worth it. By waiting when we found a sentinel, we may have writes waiting on a read to complete, which could involve a non negligible latency spike. On the other side, if we just leave the sentinel in that case, the only risk we take is that a read may end up putting tombstone in the cache that are already expired. But it doesn&apos;t seem like a big deal, especially given that it will very rarely happen.&lt;/p&gt;

&lt;p&gt;But in any case, you&apos;re right about negating the loop condition. &lt;/p&gt;</comment>
                            <comment id="13207713" author="jbellis" created="Tue, 14 Feb 2012 13:52:46 +0000"  >&lt;blockquote&gt;&lt;p&gt;By waiting when we found a sentinel, we may have writes waiting on a read to complete, which could involve a non negligible latency spike&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;You&apos;re right, that&apos;s a worse negative than leaving tombstones in the cache.  I&apos;m fine with changing it back if you update the comments accordingly. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="13208310" author="slebresne" created="Wed, 15 Feb 2012 09:36:51 +0000"  >&lt;p&gt;Actually then handling of the copying patch by the preceding patches is wrong.  When a put arrives and there is a sentinel, the patch does not add the put to the sentinel correctly. But thinking about it, for the copying cache, we should avoid having writes check the current value in the cache, because that have a non-negligible performance impact. What we should do is let invalidate actually invalidate sentinels. The only problem we&apos;re faced with if we do that, is that when a read-for-caching returns, it must make sure his own sentinel hasn&apos;t been invalidated. And in particular it must be careful of the case where the sentinel has been invalidated and another read has set another sentinel.&lt;/p&gt;

&lt;p&gt;Anyway, attaching a v4 (that include the comments cleanups) that choose that strategy instead (and thus is (hopefully) not buggy even in the copying cache case). Note that it means that reads must be able to identify sentinels uniquely (not based on the content), so the code assign a unique ID to sentinel and use that for comparison.&lt;/p&gt;</comment>
                            <comment id="13214046" author="jbellis" created="Wed, 22 Feb 2012 22:19:20 +0000"  >&lt;p&gt;Attached v5 with a simpler approach: for serializing cache, getThroughCache does a classic CAS loop with a sentinel vs the write&apos;s invalidate.&lt;/p&gt;

&lt;p&gt;v5 also adds a containsCachedRow method to CFS so that callers that don&apos;t care about the value don&apos;t force a deserialize in the serializing cache case.&lt;/p&gt;</comment>
                            <comment id="13214482" author="slebresne" created="Thu, 23 Feb 2012 09:11:07 +0000"  >&lt;p&gt;I don&apos;t think v5 works. All sentinels are empty CF, so all sentinels will be equal (in SerializingCache.contentsEqual()). Which means we can have the following sequence of actions:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;a read r1 comes, the cache is empty, it sets sentinel s1 and start reading from disk&lt;/li&gt;
	&lt;li&gt;a write w comes and invalidate s1.&lt;/li&gt;
	&lt;li&gt;a read r2 comes, the cache is (now) empty, it sets sentinel s2 and start reading from disk&lt;/li&gt;
	&lt;li&gt;r1 finish reading from disk having missed w. It&apos;ll do the replace, but since all sentinel are equals this will succeed (even though the current sentinel is the one of the second read) and we&apos;ll end up having missed w.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;That&apos;s the reason of the sentinel IDs of v4.&lt;/p&gt;</comment>
                            <comment id="13214816" author="jbellis" created="Thu, 23 Feb 2012 15:56:28 +0000"  >&lt;p&gt;v6 pulls RCS out to a separate file and adds a uuid version and equals/hashcode methods.  SerializingCacheProvider uses a custom CF serializer that is RCS-aware.  SerializingCache.replace is simplified to use RCS.equals.  CAS loop is extended to non-serializing cache: since cache/write race is extremely rare, I&apos;d rather take the occasional re-read penalty, than increase the overhead of every row in the cache by making them RCS objects permanently.&lt;/p&gt;</comment>
                            <comment id="13215535" author="slebresne" created="Fri, 24 Feb 2012 09:53:22 +0000"  >&lt;p&gt;Remarks on v6:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Since we don&apos;t add stuffs to the sentinel, it has no reason to be a subclass of ColumnFamily. We should probably create a CachedRow class extended by both Sentinel (that would really just be an identifier, no metadata needed) and ColumnFamily and use that as cache values. It&apos;ll be cleaner and more importantly more type safe (a cache lookup won&apos;t be able to ignore by mistake that it could get a sentinel).&lt;/li&gt;
	&lt;li&gt;Not adding stuffs to the sentinel also mean that in getThroughCache the counter special case is not needed anymore.&lt;/li&gt;
	&lt;li&gt;In getThroughCache, if we fail to replace the sentinel, I think we should still better return the data rather than looping and re-reading. Better let the next client read cache the data than getting a crappy latency on the current read.&lt;/li&gt;
	&lt;li&gt;Is it really an improvement to use UUIDs (over an AtomicLong)? I have nothing against UUID per se but it takes twice the space (and we serialize them) and without having benchmarked it, I&apos;m willing to bet are much faster to generate. And let&apos;s be honest, the risk of overflow with an AtomicLong is science-fiction (or to be precise, at 1 millions sentinels created per seconds (which is &lt;b&gt;way&lt;/b&gt; more than we&apos;ll ever see), you&apos;d need more than 100,000 year of uptime to overflow).&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="13216083" author="jbellis" created="Fri, 24 Feb 2012 23:19:24 +0000"  >&lt;p&gt;v7 attached.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Since we don&apos;t add stuffs to the sentinel, it has no reason to be a subclass of ColumnFamily&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;True, but when I tried this I ended up with a LOT of casting cache values to CF.  I think it might be the lesser of evils the way it is.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;the counter special case is not needed anymore&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Updated.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;if we fail to replace the sentinel, I think we should still better return the data rather than looping and re-reading&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Makes sense, updated.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Is it really an improvement to use UUIDs (over an AtomicLong)? &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;d rather have the reduced contention on instantiation than the 8 bytes of space (during the sentinel lifetime &amp;#8211; this goes away once the sentinel is replaced by the data CF).&lt;/p&gt;</comment>
                            <comment id="13217127" author="slebresne" created="Mon, 27 Feb 2012 09:28:38 +0000"  >&lt;ul&gt;
	&lt;li&gt;In SerializingCache, remove misses a &quot;not&quot; in the while condition (this date back from one of my earlier patch). We don&apos;t need that new remove method anymore though so it&apos;s probably as simple to just remove it from the patch.&lt;/li&gt;
	&lt;li&gt;In CFS.getThroughCache, the following line
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;boolean sentinelSuccess = !CacheService.instance.rowCache.putIfAbsent(key, sentinel);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;should not be negated.&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;Also in CFS.getThroughCache, we won&apos;t remove the sentinel if there is an exception during the read. It&apos;s not a big deal but it doesn&apos;t cost much to prevent it from happening.&lt;/li&gt;
&lt;/ul&gt;


&lt;blockquote&gt;&lt;p&gt;True, but when I tried this I ended up with a LOT of casting cache values to CF. I think it might be the lesser of evils the way it is.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;In that case, I think I wouldn&apos;t mind too much casts and I would prefer getting the type safety of knowing that a method that take a ColumnFamily can&apos;t ever get a sentinel (and to make it explicit when you need to care about sentinel or not), but that&apos;s a bit subjective. There would also be some small wins like the fact we wouldn&apos;t need to save the cfId when serializing a sentinel.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I&apos;d rather have the reduced contention on instantiation than the 8 bytes of space&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;My point was that the UUID don&apos;t reduce contention. UUID.randomUUID() uses SecureRandom.nextBytes() that is synchronized (and thus likely entail a much bigger degradation in face of contention than an AtomicLong) and probably a bit CPU intensive. For reference, I did a quick micro-benchmark having 50 threads generating 10,000 ids simultaneously using both methods, using an AtomicLong is two orders of magnitude faster.&lt;/p&gt;</comment>
                            <comment id="13217215" author="jbellis" created="Mon, 27 Feb 2012 15:03:10 +0000"  >&lt;p&gt;v8 attached w/ long sentinel and IRowCacheEntry.&lt;/p&gt;</comment>
                            <comment id="13217231" author="slebresne" created="Mon, 27 Feb 2012 15:49:20 +0000"  >&lt;p&gt;v8 lgtm mostly except for the 3 remarks at the beginning of my previous comment. Added simple patch on top of v8 that does the proposed modifications.&lt;/p&gt;</comment>
                            <comment id="13217254" author="jbellis" created="Mon, 27 Feb 2012 16:17:30 +0000"  >&lt;p&gt;shouldn&apos;t &lt;tt&gt;if (data == null)&lt;/tt&gt; in the finally block be &lt;tt&gt;if (sentinelSuccess &amp;amp;&amp;amp; data == null)&lt;/tt&gt; ?&lt;/p&gt;</comment>
                            <comment id="13217257" author="slebresne" created="Mon, 27 Feb 2012 16:22:03 +0000"  >&lt;p&gt;Oups, you&apos;re right. Patch updated.&lt;/p&gt;</comment>
                            <comment id="13217258" author="jbellis" created="Mon, 27 Feb 2012 16:24:07 +0000"  >&lt;p&gt;+1&lt;/p&gt;</comment>
                            <comment id="13218409" author="slebresne" created="Tue, 28 Feb 2012 18:03:19 +0000"  >&lt;p&gt;Committed, thanks&lt;/p&gt;</comment>
                            <comment id="13406783" author="hudson" created="Wed, 4 Jul 2012 23:16:47 +0000"  >&lt;p&gt;Integrated in Cassandra #1646 (See &lt;a href=&quot;https://builds.apache.org/job/Cassandra/1646/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/Cassandra/1646/&lt;/a&gt;)&lt;br/&gt;
    restore pre-&lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-3862&quot; title=&quot;RowCache misses Updates&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-3862&quot;&gt;&lt;del&gt;CASSANDRA-3862&lt;/del&gt;&lt;/a&gt; approach to removing expired tombstones during compaction (Revision fbb5ec0374e1a5f1b24680f1604b6e9201fb535f)&lt;br/&gt;
fix build - re-add CompactionController.removeDeletedInCache for commit fbb5ec0374e1a5f1b24680f1604b6e9201fb535f restore pre-&lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-3862&quot; title=&quot;RowCache misses Updates&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-3862&quot;&gt;&lt;del&gt;CASSANDRA-3862&lt;/del&gt;&lt;/a&gt; approach to removing expired tombstones during compaction (Revision 086c06ad7fb211de6be877c3c1ea2ee4f86c6d7e)&lt;/p&gt;

&lt;p&gt;     Result = ABORTED&lt;br/&gt;
jbellis : &lt;br/&gt;
Files : &lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;src/java/org/apache/cassandra/db/compaction/CompactionIterable.java&lt;/li&gt;
	&lt;li&gt;CHANGES.txt&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;dbrosius : &lt;br/&gt;
Files : &lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;src/java/org/apache/cassandra/db/compaction/CompactionController.java&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    </comments>
                    <attachments>
                            <attachment id="12515996" name="3862-7.txt" size="25456" author="jbellis" created="Fri, 24 Feb 2012 23:19:24 +0000"/>
                            <attachment id="12514380" name="3862-cleanup.txt" size="9129" author="jbellis" created="Mon, 13 Feb 2012 18:26:22 +0000"/>
                            <attachment id="12513810" name="3862-v2.patch" size="17249" author="slebresne" created="Wed, 8 Feb 2012 13:58:01 +0000"/>
                            <attachment id="12514613" name="3862-v4.patch" size="17991" author="slebresne" created="Wed, 15 Feb 2012 09:36:51 +0000"/>
                            <attachment id="12515652" name="3862-v5.txt" size="24770" author="jbellis" created="Wed, 22 Feb 2012 22:19:20 +0000"/>
                            <attachment id="12515760" name="3862-v6.txt" size="26596" author="jbellis" created="Thu, 23 Feb 2012 16:01:42 +0000"/>
                            <attachment id="12516165" name="3862-v8.txt" size="31972" author="jbellis" created="Mon, 27 Feb 2012 15:03:09 +0000"/>
                            <attachment id="12513625" name="3862.patch" size="12261" author="slebresne" created="Tue, 7 Feb 2012 16:04:07 +0000"/>
                            <attachment id="12514350" name="3862_v3.patch" size="13089" author="slebresne" created="Mon, 13 Feb 2012 13:30:19 +0000"/>
                            <attachment id="12516179" name="3862_v8_addon.txt" size="4966" author="slebresne" created="Mon, 27 Feb 2012 16:22:03 +0000"/>
                            <attachment id="12513452" name="include_memtables_in_rowcache_read.patch" size="7539" author="doubleday" created="Mon, 6 Feb 2012 17:19:35 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>11.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12313920" key="com.atlassian.jira.plugin.system.customfieldtypes:multiuserpicker">
                        <customfieldname>Authors</customfieldname>
                        <customfieldvalues>
                                    <customfieldvalue><![CDATA[slebresne]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>226735</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            13 years, 20 weeks, 5 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i0gp4n:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>95501</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_10022" key="com.atlassian.jira.plugin.system.customfieldtypes:userpicker">
                        <customfieldname>Reviewer</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>jbellis</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12313420" key="com.atlassian.jira.plugin.system.customfieldtypes:multiuserpicker">
                        <customfieldname>Reviewers</customfieldname>
                        <customfieldvalues>
                                    <customfieldvalue><![CDATA[jbellis]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12313820" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Severity</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="12962"><![CDATA[Normal]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>