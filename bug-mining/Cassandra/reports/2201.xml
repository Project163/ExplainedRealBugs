<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 22:38:54 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[CASSANDRA-5149] Respect slice count even if column expire mid-request</title>
                <link>https://issues.apache.org/jira/browse/CASSANDRA-5149</link>
                <project id="12310865" key="CASSANDRA">Apache Cassandra</project>
                    <description>&lt;p&gt;This is a follow-up of &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-5099&quot; title=&quot;Since 1.1, get_count sometimes returns value smaller than actual column count&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-5099&quot;&gt;&lt;del&gt;CASSANDRA-5099&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If a column expire just while a slice query is performed, it is possible for replicas to count said column as live but to have the coordinator seeing it as dead when building the final result. The effect that the query might return strictly less columns that the requested slice count even though there is some live columns matching the slice predicate but not returned in the result.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12627182">CASSANDRA-5149</key>
            <summary>Respect slice count even if column expire mid-request</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="10002" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.svg">Normal</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="aleksey">Aleksey Yeschenko</assignee>
                                    <reporter username="slebresne">Sylvain Lebresne</reporter>
                        <labels>
                    </labels>
                <created>Fri, 11 Jan 2013 15:25:09 +0000</created>
                <updated>Tue, 14 Oct 2025 12:14:00 +0000</updated>
                            <resolved>Tue, 18 Jun 2013 16:16:48 +0000</resolved>
                                        <fixVersion>2.0 beta 1</fixVersion>
                                        <due></due>
                            <votes>0</votes>
                                    <watches>4</watches>
                                                                                                                <comments>
                            <comment id="13551181" author="slebresne" created="Fri, 11 Jan 2013 15:30:33 +0000"  >&lt;p&gt;As said on &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-5099&quot; title=&quot;Since 1.1, get_count sometimes returns value smaller than actual column count&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-5099&quot;&gt;&lt;del&gt;CASSANDRA-5099&lt;/del&gt;&lt;/a&gt;, the only good way to fix this that I can see right now would be to have the coordinator determine an expireBefore value (the current time at the beginning of the request) and use that exclusively during the query to decide whether a query is expired or not (similar to what we do for LazilyCompactedRow but at the scale of the query).&lt;/p&gt;

&lt;p&gt;Unfortunately, this means shipping that expireBefore value to replicas with the query and that implies a inter-node protocol change, which make this only viable for 2.0 now. Hence the &apos;fix version&apos;. Of course if we can find a solution that don&apos;t require protocol change, then great.&lt;/p&gt;</comment>
                            <comment id="13576892" author="jbellis" created="Tue, 12 Feb 2013 18:58:38 +0000"  >&lt;p&gt;What if we forced ExpiringColumn to either Column or DeletedColumn on the reply?&lt;/p&gt;</comment>
                            <comment id="13577457" author="slebresne" created="Wed, 13 Feb 2013 09:55:34 +0000"  >&lt;p&gt;That&apos;s a good idea, I think that would work (at least I don&apos;t see why it wouldn&apos;t right away).&lt;/p&gt;</comment>
                            <comment id="13585937" author="slebresne" created="Mon, 25 Feb 2013 15:44:18 +0000"  >&lt;p&gt;Actually, this is not as free of a lunch as it sound. We cannot really force non-expired ExpiringColumn to Column, because we need to return the expiring time to the client. So in practice, we would need to either add a dontExpire flag for ExpiringColumn or a special Column+TTL column type for just that purpose. Any of those will have impact on the inter-node protocol (and at the column serialization, where we don&apos;t yet handle versions well (because we never really had to)).&lt;/p&gt;

&lt;p&gt;And if that&apos;s not significantly simpler, I think I prefer the expireBefore solution because that feels less hacky to me in that it fixes the issue of having column expire at uncontrolled times more generally (this is also how we deal with it in LazilyCompactedRow).&lt;/p&gt;</comment>
                            <comment id="13586148" author="jbellis" created="Mon, 25 Feb 2013 19:05:58 +0000"  >&lt;p&gt;If it&apos;s fix-for 2.0, can we just omit returning expiration time?&lt;/p&gt;</comment>
                            <comment id="13586181" author="slebresne" created="Mon, 25 Feb 2013 19:26:34 +0000"  >&lt;p&gt;I don&apos;t understand. Why would not returning the expiration time be more ok for 2.0 than 1.2? That is, even in CQL3 it&apos;s possible to query the expiration time of a column.&lt;/p&gt;</comment>
                            <comment id="13586229" author="jbellis" created="Mon, 25 Feb 2013 20:04:41 +0000"  >&lt;p&gt;I have trouble coming up with a use case for it.&lt;/p&gt;</comment>
                            <comment id="13587006" author="slebresne" created="Tue, 26 Feb 2013 10:48:40 +0000"  >&lt;blockquote&gt;&lt;p&gt;I have trouble coming up with a use case for it.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;You mean, for querying the expiration time of a column? My own experience with TTL leads me to believe that anyone using expiring columns will want to query the expiration time at one point or another. I personally had a case where if some TTLed columns were read, we were &quot;extending&quot; the TTL and how long it was extended depended on the current expiration time. Or, on the other end of the spectrum, wanting to update a column value without extending the TTL. I had also a number of case where not all columns had the same TTL, if any, and just knowing if the column was an expiring one was necessary (including but not limited to checking during development that the code was doing what it was supposed to do in terms of setting TTLs).&lt;/p&gt;

&lt;p&gt;Also, if we were to transform expiring column to standard column on read, even ignoring the fact that we wouldn&apos;t be able to return the expiration time to clients, you&apos;d have to be careful about read-repair &quot;cancelling&quot; your TTLs.  &lt;/p&gt;

&lt;p&gt;Besides, as said above, especially if it&apos;s fix-for 2.0 (and so things like &quot;this may require a protocol change&quot; become largely irrelevant), I think normalizing all code on having expiration be based on a time fixed at well know places (like we do for gcBefore really) is the right long term solution.&lt;/p&gt;</comment>
                            <comment id="13649842" author="JIRAUSER308715" created="Mon, 6 May 2013 16:34:28 +0000"  >&lt;p&gt;Does &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-4415&quot; title=&quot;Add cursor API/auto paging to the native CQL protocol&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-4415&quot;&gt;&lt;del&gt;CASSANDRA-4415&lt;/del&gt;&lt;/a&gt; make this a non-issue (as long as it deals with this)?  To me, this might as well just be &quot;won&apos;t fix&quot;, and you have to make the extra query and see if you only get one column back.  I guess there is an edge case where you could just get one column, and there really are more, but its been this way since 0.7, so meh.&lt;/p&gt;</comment>
                            <comment id="13649852" author="slebresne" created="Mon, 6 May 2013 16:46:14 +0000"  >&lt;blockquote&gt;&lt;p&gt;Does &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-4415&quot; title=&quot;Add cursor API/auto paging to the native CQL protocol&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-4415&quot;&gt;&lt;del&gt;CASSANDRA-4415&lt;/del&gt;&lt;/a&gt; make this a non-issue&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I don&apos;t know. I think &quot;we&apos;ll only ever going to return less than asked columns if there is less than asked columns&quot; seems a reasonably semantic to have, and we fail that here with TTL. And even if &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-4415&quot; title=&quot;Add cursor API/auto paging to the native CQL protocol&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-4415&quot;&gt;&lt;del&gt;CASSANDRA-4415&lt;/del&gt;&lt;/a&gt; ends up hiding the problem, it&apos;s still a performance issue, because if you can&apos;t rely on the semantic above, you&apos;ll almost always have to do one more query than would be enough &quot;just to be sure&quot; (which is what getCount() does for thrift today).&lt;/p&gt;

&lt;p&gt;So, without saying this is a big or pressing issue, I&apos;m -1 on &quot;wont fixing it&quot; in the long run.&lt;/p&gt;</comment>
                            <comment id="13668222" author="slebresne" created="Tue, 28 May 2013 10:14:07 +0000"  >&lt;p&gt;Actually, now that I think about it, I think &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-4415&quot; title=&quot;Add cursor API/auto paging to the native CQL protocol&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-4415&quot;&gt;&lt;del&gt;CASSANDRA-4415&lt;/del&gt;&lt;/a&gt; is why I&apos;d really rather have this in 2.0.&lt;/p&gt;

&lt;p&gt;Currently, because of this, when you page a slice query, you cannot trust a given page to return strictly results than you&apos;ve asked only if paging is done, because you could have result expiring mid-request and thus you pretty much can never know if the paging is really done or if some columns expired on you. &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-5099&quot; title=&quot;Since 1.1, get_count sometimes returns value smaller than actual column count&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-5099&quot;&gt;&lt;del&gt;CASSANDRA-5099&lt;/del&gt;&lt;/a&gt; &quot;solves&quot; this by waiting until basically a query return an empty page. However:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;this is really correct. In theory, you could have &lt;b&gt;all&lt;/b&gt; of the columns fetch by the current patch that have expired mid-request, while there&apos;s still some live columns that match what your are trying to page. Granted, with a large enough page size it&apos;s very unlikely but still.&lt;/li&gt;
	&lt;li&gt;this means you&apos;ll &lt;b&gt;always&lt;/b&gt; do one more query (and that&apos;s StorageProxy level queries, it&apos;s not cheap than would be needed if this ticket was fixed. And while having paged get_count being slow don&apos;t really make me shed tears, it bugs me quite a bit more in the context of &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-4415&quot; title=&quot;Add cursor API/auto paging to the native CQL protocol&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-4415&quot;&gt;&lt;del&gt;CASSANDRA-4415&lt;/del&gt;&lt;/a&gt;.&lt;/li&gt;
	&lt;li&gt;this complicate reasoning about the logic for &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-4415&quot; title=&quot;Add cursor API/auto paging to the native CQL protocol&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-4415&quot;&gt;&lt;del&gt;CASSANDRA-4415&lt;/del&gt;&lt;/a&gt; imo. It&apos;s much easier not to have to care about &quot;oh, what if a column expires mid-request, is that ok?&quot;.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;Besides, I don&apos;t think fixing this is very complicated in practice. All we need is ship a &apos;queryServerTimestamp&apos; with the read commands, and carry that down to the Column.isMarkedForDelete() method so it uses that instead of System.currentTimeMillis(). This might end up being a few lines of code to pass this timestamp down as parameter, but it&apos;s pretty trivial changes.&lt;/p&gt;</comment>
                            <comment id="13679220" author="iamaleksey" created="Sun, 9 Jun 2013 23:32:24 +0000"  >&lt;p&gt;There is another method that is affected - ExpiringColumn.create() that returns either a DeletedColumn or an ExpiringColumn instance, called by ColumnSerializer.deserializeColumnBody(). Now, we already do pass expireBefore to it as a parameter (in a limited way) and it&apos;s not (was not) difficult to make it be derived from read requests&apos; timestamp. Except in one case - row cache deserialization. The required modifications go beyond the need for Cache API change and I haven&apos;t found a good way to deal with it.&lt;br/&gt;
Is there any change we actually will get rid of row cache in 2.0?&lt;/p&gt;</comment>
                            <comment id="13679232" author="slebresne" created="Mon, 10 Jun 2013 00:08:07 +0000"  >&lt;p&gt;Can&apos;t we create a version of ExpiringColumn.create() that never transform a DeletedColumn to an ExpiringColumn and use that for cache deserialization (or say do that when expireBefore is negative and pass -1 for expireBefore in the row cache code).&lt;/p&gt;

&lt;p&gt;Because that behavior of ExpiringColumn.create() is really just an optimization. It would be ok to never transform expired columns to deleted ones from a correction point of view.&lt;/p&gt;</comment>
                            <comment id="13679259" author="iamaleksey" created="Mon, 10 Jun 2013 02:06:06 +0000"  >&lt;blockquote&gt;&lt;p&gt;Can&apos;t we create a version of ExpiringColumn.create() that never transform a DeletedColumn to an ExpiringColumn and use that for cache deserialization (or say do that when expireBefore is negative and pass -1 for expireBefore in the row cache code).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That is easy, actually, since you only have to special-case starting at SerializingCacheProvider.deserialize() method. But I&apos;m afraid it&apos;s not enough. That is, special-casing it just for the row cache is not enough, must do the same for sstable deserialization (or remove the optimization entirely), or else a row serialized into the cache as a result of request (a) with timestamp Y might not be the right row for request (b) with timestamp X (&amp;lt; Y) coming out of order if a column expires between X and Y.&lt;/p&gt;

&lt;p&gt;Making ExpiringColumn.create() to never return DeletedColumn instances would be the easiest way to deal with it, but what would impact compaction (and repair), so I suggest making NO expring-&amp;gt;deleted optimization the default behavior, and only enabling it for compaction (incl. validation compaction) (and SSTableExport), or, in other words, special-case it for SSTII only.&lt;/p&gt;</comment>
                            <comment id="13679581" author="slebresne" created="Mon, 10 Jun 2013 15:37:09 +0000"  >&lt;blockquote&gt;&lt;p&gt;But I&apos;m afraid it&apos;s not enough&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;m not sure I understand the case you are talking about. Whether or not ExpiringColumn.create() decides to return a deleted column or not, it still returns a column, so this should have no impact whatsoever on anything timestamp related. I.e. the code will treat an ExpiringColumn that is expired exactly as a deleted column, so it should always be safe to not transform an expired column to a DeletedColumn, even if it&apos;s only in parts of the code.&lt;/p&gt;

&lt;p&gt;But it could be I just don&apos;t understand your example.&lt;/p&gt;</comment>
                            <comment id="13679598" author="iamaleksey" created="Mon, 10 Jun 2013 16:18:03 +0000"  >&lt;p&gt;I wasn&apos;t clear enough. I&apos;m talking about read request timestamps, not column timestamps. And I&apos;m saying that to transfrom is not always correct, in the context of 5149. But &lt;b&gt;not to&lt;/b&gt; transfrom is perfectly all right.&lt;/p&gt;</comment>
                            <comment id="13679642" author="slebresne" created="Mon, 10 Jun 2013 17:14:41 +0000"  >&lt;p&gt;I still don&apos;t see where the problem is. Can you illustrate with a concrete example what is the problem we can run into if we just have Expiring.create() that doesn&apos;t transform in the case of the row cache but do transform based on the &quot;read request timestamp&quot; in all other cases?&lt;/p&gt;</comment>
                            <comment id="13680917" author="iamaleksey" created="Wed, 12 Jun 2013 03:10:43 +0000"  >&lt;p&gt;&lt;a href=&quot;https://github.com/iamaleksey/cassandra/commits/5149&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/iamaleksey/cassandra/commits/5149&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The first patch adds timestamp field to all IReadCommands and makes sure it&apos;s always set appropriately.&lt;/p&gt;

&lt;p&gt;The second patch updates the read path to respect the request timestamp. It also normalizes the argument order for CFS.getRangeSlice() and CFS.search(). This was not necessary, but the order they were in bothered me immensely. The third patch fixes the tests broken by this rearrangement.&lt;/p&gt;

&lt;p&gt;I&apos;ll add some unit tests after the code review.&lt;/p&gt;</comment>
                            <comment id="13683332" author="slebresne" created="Fri, 14 Jun 2013 13:18:43 +0000"  >&lt;p&gt;The overall approach looks good to me, though:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;I&apos;d feel a bit better if we were just removing the isMarkedForDelete() (without arguments) call in Column, so that every caller knows he has to deal with it. It&apos;s otherwise hard to make sure we never call the no-argument version by accident. There&apos;s probably a few other places too (Row for instance) where I&apos;d prefer avoiding having a shortcut calling System.currentTimeMillis().&lt;/li&gt;
	&lt;li&gt;In RowIteratorFactory, I think it would make sense to use the filter timestamp rather than relying on System.currentTimeMillis() for gcBefore.&lt;/li&gt;
	&lt;li&gt;There is possibly a few places where a function takes &apos;gcBefore&apos; and &apos;now&apos;, either directly (collectReducedColumns), or because they have a filter and gcBefore (CFS.filterColumnFamily()). Maybe we could drop the gcBefore and just rely on the timestamp.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="13685616" author="iamaleksey" created="Mon, 17 Jun 2013 14:33:05 +0000"  >&lt;p&gt;Pushed the fourth commit to the same branch.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Removed Column.isMarkedForDelete/0 and most similar methods (including QueryFilter getXFilter helper methods)&lt;/li&gt;
	&lt;li&gt;RowIteratorFactory/System.currentTimeMillis() - done.&lt;/li&gt;
	&lt;li&gt;CFS.filterColumnFamily() was the only place where I could get rid of passing gcBefore explicitly - thanks for catching that. In IDiskAtomFilter.collectReducedColumns() timestamp and gcbefore are sometimes unrelated (with Integer.MIN_VALUE passed as gcBefore, intentionally). Same goes for CFS.collateOnDiskAtom(). Usually it&apos;s either because of either compaction or the row cache.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="13686728" author="slebresne" created="Tue, 18 Jun 2013 13:54:26 +0000"  >&lt;blockquote&gt;&lt;p&gt;In IDiskAtomFilter.collectReducedColumns() timestamp and gcbefore are sometimes unrelated&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Right, forgot about that.&lt;/p&gt;


&lt;p&gt;Last version lgtm, +1.&lt;/p&gt;

&lt;p&gt;A few optional minor nits for the commit:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;In CounterColumn.reconcile (and CounterMutation and ... in fact), we don&apos;t support expiring columns in counter tables so it&apos;s ok to just use say Long.MIN_VALUE (which a comment why).&lt;/li&gt;
	&lt;li&gt;the comment inside DeletedColumn.isMarkedForDelete is obsolete (it&apos;s more confusing that helpful now &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;).&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="13686732" author="iamaleksey" created="Tue, 18 Jun 2013 13:58:36 +0000"  >&lt;p&gt;Thanks!&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;In CounterColumn.reconcile (and CounterMutation and ... in fact), we don&apos;t support expiring columns in counter tables so it&apos;s ok to just use say Long.MIN_VALUE (which a comment why)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I know. Same with Column.getString() - it&apos;s overloaded by ExpiringColumn anyway. I was debating with myself what to use - Long.MIN_VALUE, 0, or just System.currentTimeMillis() where it doesn&apos;t matter, and went with System.currentTimeMillis(). Will change to Long.MIN_VALUE with a comment in both places.&lt;/p&gt;</comment>
                            <comment id="13686884" author="iamaleksey" created="Tue, 18 Jun 2013 16:16:48 +0000"  >&lt;p&gt;Committed.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12313920" key="com.atlassian.jira.plugin.system.customfieldtypes:multiuserpicker">
                        <customfieldname>Authors</customfieldname>
                        <customfieldvalues>
                                    <customfieldvalue><![CDATA[aleksey]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>303951</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            12 years, 23 weeks ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i17h2v:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>251736</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_10022" key="com.atlassian.jira.plugin.system.customfieldtypes:userpicker">
                        <customfieldname>Reviewer</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>slebresne</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12313420" key="com.atlassian.jira.plugin.system.customfieldtypes:multiuserpicker">
                        <customfieldname>Reviewers</customfieldname>
                        <customfieldvalues>
                                    <customfieldvalue><![CDATA[slebresne]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12313820" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Severity</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="12962"><![CDATA[Normal]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>