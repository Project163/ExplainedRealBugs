<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 23:29:48 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[CASSANDRA-19018] An SAI-specific mechanism to ensure consistency isn&apos;t violated for multi-column (i.e. AND) queries at CL &gt; ONE</title>
                <link>https://issues.apache.org/jira/browse/CASSANDRA-19018</link>
                <project id="12310865" key="CASSANDRA">Apache Cassandra</project>
                    <description>&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-19007&quot; title=&quot;Queries with multi-column replica-side filtering can miss rows&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-19007&quot;&gt;CASSANDRA-19007&lt;/a&gt; is going to be where we add a guardrail around filtering/index queries that use intersection/AND over partially updated non-key columns. (ex. Restricting one clustering column and one normal column does not cause a consistency problem, as primary keys cannot be partially updated.) This issue exists to attempt to fix this specifically for SAI in 5.0.x, as Accord will (last I checked) not be available until the 5.1 release.&lt;/p&gt;

&lt;p&gt;The SAI-specific version of the originally reported issue is this:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;try (Cluster cluster = init(Cluster.build(2).withConfig(config -&amp;gt; config.with(GOSSIP).with(NETWORK)).start()))
        {
            cluster.schemaChange(withKeyspace(&quot;CREATE TABLE %s.t (k int PRIMARY KEY, a int, b int)&quot;));
            cluster.schemaChange(withKeyspace(&quot;CREATE INDEX ON %s.t(a) USING &apos;sai&apos;&quot;));
            cluster.schemaChange(withKeyspace(&quot;CREATE INDEX ON %s.t(b) USING &apos;sai&apos;&quot;));

            // insert a split row
            cluster.get(1).executeInternal(withKeyspace(&quot;INSERT INTO %s.t(k, a) VALUES (0, 1)&quot;));
            cluster.get(2).executeInternal(withKeyspace(&quot;INSERT INTO %s.t(k, b) VALUES (0, 2)&quot;));

        // Uncomment this line and test succeeds w/ partial writes completed...
        //cluster.get(1).nodetoolResult(&quot;repair&quot;, KEYSPACE).asserts().success();

            String select = withKeyspace(&quot;SELECT * FROM %s.t WHERE a = 1 AND b = 2&quot;);
            Object[][] initialRows = cluster.coordinator(1).execute(select, ConsistencyLevel.ALL);
            assertRows(initialRows, row(0, 1, 2)); // not found!!
        }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;To make a long story short, the local SAI indexes are hiding local partial matches from the coordinator that would combine there to form full matches. Simple non-index filtering queries also suffer from this problem, but they hide the partial matches in a different way. I&apos;ll outline a possible solution for this in the comments that takes advantage of replica filtering protection and the repaired/unrepaired datasets...and attempts to minimize the amount of extra row data sent to the coordinator.&lt;/p&gt;</description>
                <environment></environment>
        <key id="13557387">CASSANDRA-19018</key>
            <summary>An SAI-specific mechanism to ensure consistency isn&apos;t violated for multi-column (i.e. AND) queries at CL &gt; ONE</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="10002" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.svg">Normal</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="maedhroz">Caleb Rackliffe</assignee>
                                    <reporter username="maedhroz">Caleb Rackliffe</reporter>
                        <labels>
                    </labels>
                <created>Thu, 9 Nov 2023 20:38:14 +0000</created>
                <updated>Thu, 16 Jan 2025 21:21:55 +0000</updated>
                            <resolved>Thu, 29 Feb 2024 21:06:57 +0000</resolved>
                                        <fixVersion>5.0-rc1</fixVersion>
                    <fixVersion>5.0</fixVersion>
                    <fixVersion>5.1</fixVersion>
                                    <component>Consistency/Coordination</component>
                    <component>Feature/SAI</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>6</watches>
                                                    <progress percentage="100">
                                    <originalProgress>
                                                    <row percentage="0" backgroundColor="#89afd7"/>
                                                    <row percentage="100" backgroundColor="transparent"/>
                                            </originalProgress>
                                                    <currentProgress>
                                                    <row percentage="100" backgroundColor="#51a825"/>
                                                    <row percentage="0" backgroundColor="#ec8e00"/>
                                            </currentProgress>
                            </progress>
                                    <aggregateprogress percentage="100">
                                    <originalProgress>
                                                    <row percentage="0" backgroundColor="#89afd7"/>
                                                    <row percentage="100" backgroundColor="transparent"/>
                                            </originalProgress>
                                                    <currentProgress>
                                                    <row percentage="100" backgroundColor="#51a825"/>
                                                    <row percentage="0" backgroundColor="#ec8e00"/>
                                            </currentProgress>
                            </aggregateprogress>
                                            <timeestimate seconds="0">0h</timeestimate>
                            <timespent seconds="41400">11.5h</timespent>
                                <comments>
                            <comment id="17784913" author="adelapena" created="Fri, 10 Nov 2023 12:26:22 +0000"  >&lt;p&gt;I think the query to be run on the unrepaired dataset for an &lt;tt&gt;a=x AND b=y&lt;/tt&gt; query would be something like&#160;&lt;tt&gt;(a=x AND b=y) OR (a=x AND TIMESTAMP(a) &amp;gt; TIMESTAMP(b)) OR (b=y AND TIMESTAMP(b) &amp;gt; TIMESTAMP(a))&lt;/tt&gt;. Note that this isn&apos;t simply asking for null column values because:&lt;br/&gt;
1. explicit nulls aren&apos;t problematic, since they produce a tombstone that overrides any previous values on the other replicas&lt;br/&gt;
2. older non-null values of the unmatched column are problematic because they mean the matched column is a partial write.&lt;/p&gt;

&lt;p&gt;I think this restriction logically works for both SAI/SASI and AF cases. In the case of SAI, probably the timestamps check can be replaced by a posting list of undefined values at the time of writing the sstable.&lt;/p&gt;</comment>
                            <comment id="17786966" author="maedhroz" created="Thu, 16 Nov 2023 23:22:17 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=adelapena&quot; class=&quot;user-hover&quot; rel=&quot;adelapena&quot;&gt;adelapena&lt;/a&gt; End-to-end there are three places where we&apos;ll have to think about filtering. Working backwards: coordinator resoluiton, the local table-level read/query, and the SAI SSTable index queries.&lt;/p&gt;

&lt;p&gt;(Note that we should have sufficient information in the query context to short-circuit this entire process if the query type makes it unnecessary.)&lt;/p&gt;


&lt;p&gt;1.) SSTable-level&lt;/p&gt;

&lt;p&gt;When we have an AND query across two columns, we produce a stream of primary keys for each clause (i.e. one for each column). These streams are the union of all the SSTable index matches for their respective columns, in order. (See &lt;tt&gt;QueryController#getIndexQueryResults()&lt;/tt&gt;) The point where things start to go wrong in the current implementation is when we attempt to AND these two unions/streams together. We assume a repaired view of the row at all times, and so an intersection culls out partial matches that may or may not be needed to resolve a final result at the coordinator. How to fix this?&lt;/p&gt;

&lt;p&gt;The approach we&apos;ve talked about here is, I think, splitting up the &lt;tt&gt;QueryView&lt;/tt&gt; into repaired and un-repaired SSTables (i.e. SSTable indexes). Once this is done, we can query the repaired set and produce the intersection exactly as before. For the un-repaired set, we need to produce primary keys for the partial matches though. We can simply produce a union instead of an intersection here, but we&apos;d be heavily reliant on the un-repaired set being small to keep the number of unnecessarily matched rows minimal. (Trying to optimize this might not be straightforward. Having a special postings list for missing column values might allow for an intersection instead of a union here, but I haven&apos;t thought through all its implications for overall correctness.)&lt;/p&gt;

&lt;p&gt;Indexes on clustering keys are a special case here. Since they must always be present, we should never have to union them together with anything. Even with more than one normal column in the query, their clauses can be OR&apos;d then AND&apos;d together with the clause that touches the clustering key. There are cases where this can whittle down the number of results that pass to the next stage.&lt;/p&gt;

&lt;p&gt;Once we&apos;ve queried both repaired and un-repaired sets, we can union the two streams of primary keys together to move to the next step...&lt;/p&gt;


&lt;p&gt;2.) Table-level&lt;/p&gt;

&lt;p&gt;Once we&apos;ve produced a set of primary keys that may (or may not) be matches, we need to read and filter the rows. If we know we&apos;re potentially dealing w/ partial update reconciliation, we obviously can&apos;t just apply the filter as we do now in &lt;tt&gt;ResultRetriever#applyIndexFilter()&lt;/tt&gt;. Even preserving possible matches from the SAI indexes themselves, we can now again prematurely cull out a match by filtering it out when one of the columns in our AND query is simply missing a value. So what do we need to keep here, as we&apos;re now filtering matches from both the repaired and un-repaired sets?&lt;/p&gt;

&lt;p&gt;(Here&apos;s where the ideas in your previous comment enter...)&lt;/p&gt;

&lt;p&gt;The easiest thing to keep is a row that actually matches all clauses, &lt;tt&gt;a=x AND b=y&lt;/tt&gt;. The easiest thing to throw away, which we do now, is a row delete. After that, all we need to do is make sure we keep partial matches when the timestamps of the normal columns involved in the query aren&apos;t the same. (This is similar to the &lt;tt&gt;(a=x AND b=y) OR (a=x AND TIMESTAMP(a) &amp;gt; TIMESTAMP(b)) OR (b=y AND TIMESTAMP(b) &amp;gt; TIMESTAMP(a))&lt;/tt&gt; suggestion I think.) We might also want to break the matching logic in &lt;tt&gt;FilterTree&lt;/tt&gt; down a bit around this, because we only care about the timestamps of the non-primary key columns. Primary key elements (i.e. for indexed clustering keys) in an AND query can be evaluated first and fail matches before we even look at potentially problematic normal columns.&lt;/p&gt;


&lt;p&gt;3.) Coordinator-level&lt;/p&gt;

&lt;p&gt;This should be the easiest part of this whole project, and looking more at &lt;tt&gt;DataResolver&lt;/tt&gt;, I think the final filtering we need before handing off to the client is already in place in &lt;tt&gt;DataResolver#resolveWithReplicaFilteringProtection()&lt;/tt&gt;. This, like everything else here, needs to be thoroughly tested.&lt;/p&gt;

&lt;p&gt;WDYT?&lt;/p&gt;

&lt;p&gt;Either way, I&apos;m going to start working on a testing framework that tries to cover the whole space around partial updates. (Different consistency levels, interactions of existing data and partial updates, key/static/normal columns, interactions w/ read-repair and normal repair, cases that currently hit RFP, etc.)&lt;/p&gt;</comment>
                            <comment id="17790314" author="maedhroz" created="Tue, 28 Nov 2023 00:38:24 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=mike_tr_adamson&quot; class=&quot;user-hover&quot; rel=&quot;mike_tr_adamson&quot;&gt;mike_tr_adamson&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=adelapena&quot; class=&quot;user-hover&quot; rel=&quot;adelapena&quot;&gt;adelapena&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ifesdjeen&quot; class=&quot;user-hover&quot; rel=&quot;ifesdjeen&quot;&gt;ifesdjeen&lt;/a&gt; Started to get some thoughts down &lt;a href=&quot;https://github.com/apache/cassandra/pull/2935&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;here&lt;/a&gt; on testing approach...&lt;/p&gt;</comment>
                            <comment id="17791710" author="maedhroz" created="Thu, 30 Nov 2023 16:51:28 +0000"  >&lt;p&gt;A minor thing I&apos;ve come across in implementation planning is how to actually have the local secondary index logic know the CL of the user query. This information doesn&apos;t exist anywhere in the &lt;tt&gt;ReadCommand&lt;/tt&gt; at the moment, so it&apos;s likely a new flag will have to be added at &lt;tt&gt;0x10&lt;/tt&gt; to indicate it. (There are many other situation where the query itself will be shaped in a way that allows us to trivially avoid all the new logic in this patch, but sometimes that&apos;s not enough...)&lt;/p&gt;</comment>
                            <comment id="17793145" author="maedhroz" created="Tue, 5 Dec 2023 06:08:55 +0000"  >&lt;p&gt;UPDATE: In the &lt;a href=&quot;https://github.com/apache/cassandra/pull/2935&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;work-in-progress 5.0 branch&lt;/a&gt;, I&apos;ve completed a test matrix that covers over 100 scenarios that hit everything from replica filtering protection to the core issue that spawned this Jira. About 1/3 of the cases will fail without modification, but it&apos;s easy to see how disabling RFP blows things up even worse, especially deletion scenarios. (To disable, just return &lt;tt&gt;false&lt;/tt&gt; from &lt;tt&gt;DataResolver#usesReplicaFilteringProtection()&lt;/tt&gt;).&lt;/p&gt;</comment>
                            <comment id="17794881" author="maedhroz" created="Fri, 8 Dec 2023 23:35:40 +0000"  >&lt;p&gt;For anyone watching, I did a quick thought experiment where I changed the index query itself to use a union rather than intersection key iterator and changed the &lt;tt&gt;FilterTree&lt;/tt&gt; used for post-filtering to evaluate as an OR query in all cases. With replica-filtering protection enabled, 103 of the 104 cases in my new &lt;tt&gt;PartialUpdateHandlingTest&lt;/tt&gt; pass. Without it, there is not coordinator side post-filtering, so almost everything fails, as you might expect. Need to figure out what&apos;s going on w/ that 1 out of 104 that&apos;s failing &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="17799154" author="maedhroz" created="Wed, 20 Dec 2023 19:46:22 +0000"  >&lt;p&gt;Update before the holidays begin...&lt;/p&gt;

&lt;p&gt;I&apos;ve pushed a commit to &lt;a href=&quot;https://github.com/apache/cassandra/pull/2935&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;the PR here&lt;/a&gt; that, though incomplete, is a good start. Here&apos;s an overview:&lt;/p&gt;

&lt;p&gt;1.) &lt;tt&gt;RowFilter&lt;/tt&gt; now has a boolean field that indicates whether or not we allow what I call &quot;strict&quot; filtering at replicas. Essentially, strict filtering is allowed when we have a query at ONE/LOCAL_ONE/NODE_LOCAL, where we simply won&apos;t have to worry about partial updates. This is sent to replicas via a flag during &lt;tt&gt;ReadCommand&lt;/tt&gt; serialization. (This actually could be used by the &lt;tt&gt;RowFilter&lt;/tt&gt; itself for non-indexed plain filtering queries, although I&apos;m not sure if fixing those needs to be a goal for this Jira.)&lt;/p&gt;

&lt;p&gt;2.) With strict filtering allowed, really nothing about SAI query execution changes. When strict filtering is unsafe and therefore disabled, we segregate indexes for repaired and un-repaired SSTables, then do strict filtering on the repaired set, but non-strict (intersections become unions) filtering on the un-repaired set (which includes the Memtableindexes).&lt;/p&gt;

&lt;p&gt;3.) I&apos;ve remove the optimization during index query &quot;view&quot; building around the &quot;most selective&quot; index expression. Any selectivity calculations are inaccurate, since we don&apos;t index deletes. Also, when strict filtering is not allowed, intersecting the combined range for the SSTable indexes of the &quot;most selective&quot; expression is simply not safe. I&apos;m not sure we&apos;ve ever gotten much out of this optimization anyway. (With partition restricted queries and LCS, we&apos;ll already be dealing with a relatively small set of SSTables.)&lt;/p&gt;

&lt;p&gt;4.) Replica filtering protection hard-codes its &lt;tt&gt;RowFilter&lt;/tt&gt; to do strict filtering, as it must, since it happens at the coordinator.&lt;/p&gt;

&lt;p&gt;If I left it in this state, things would be &lt;em&gt;correct&lt;/em&gt;, just very inefficient. There are many cases where we can still do strict filtering for CL &amp;gt; ONE, and the surface area for non-strict filtering needs further shrinking. (ex. Retrieved rows have no timestamp divergence for queried columns, only a single mutable column participates in an AND query, etc.)&lt;/p&gt;

&lt;p&gt;CC &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=adelapena&quot; class=&quot;user-hover&quot; rel=&quot;adelapena&quot;&gt;adelapena&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="17802340" author="maedhroz" created="Wed, 3 Jan 2024 23:01:54 +0000"  >&lt;p&gt;Just pushed &lt;a href=&quot;https://github.com/apache/cassandra/pull/2935/commits/b1d32dd2a446f6f5527cef2a63d440f370cef3ca&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;another commit&lt;/a&gt; that further expands the number of states where strict filtering is, in fact, safe. Next step is to expand the test framework a bit around &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=adelapena&quot; class=&quot;user-hover&quot; rel=&quot;adelapena&quot;&gt;adelapena&lt;/a&gt;&apos;s &lt;a href=&quot;https://github.com/apache/cassandra/pull/2935#discussion_r1425313146&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;initial comments&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;When that is in a good place, I think this will be ready for a real review...&lt;/p&gt;</comment>
                            <comment id="17803362" author="maedhroz" created="Fri, 5 Jan 2024 00:37:17 +0000"  >&lt;p&gt;The &lt;a href=&quot;https://github.com/apache/cassandra/pull/2935&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;5.0 patch&lt;/a&gt; is now ready for review, and I anticipate very little if any change porting forward to trunk. I&apos;ve made comments inline in the PR where there might still be some discussion, but I tried to address the holes in the test matrix &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=adelapena&quot; class=&quot;user-hover&quot; rel=&quot;adelapena&quot;&gt;adelapena&lt;/a&gt; had kindly pointed out.&lt;/p&gt;</comment>
                            <comment id="17803363" author="maedhroz" created="Fri, 5 Jan 2024 00:37:54 +0000"  >&lt;p&gt;I have J11 CI running as well, and I&apos;ll post those results when I have them...&lt;/p&gt;</comment>
                            <comment id="17803386" author="maedhroz" created="Fri, 5 Jan 2024 02:54:22 +0000"  >&lt;p&gt;In terms of scope, the biggest thing I&apos;m worried about right now is the case where we have a non-empty &lt;tt&gt;postIndexQueryFilter()&lt;/tt&gt; which needs to be applied. Right now, I think it may only be safe to apply it when &quot;strict&quot; filtering is allowed.&lt;/p&gt;

&lt;p&gt;Also, I think we have a bug where RFP doesn&apos;t apply non-index-based filters during its post-filtering if we have even a non-tokenizing analyzer.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=adelapena&quot; class=&quot;user-hover&quot; rel=&quot;adelapena&quot;&gt;adelapena&lt;/a&gt; I may need to catch up w/ you on these if/when you have a minute.&lt;/p&gt;

&lt;p&gt;I think I&apos;m going to have to expand the test matrix to look at the post-filter vs. indexed expressions issue at least...&lt;/p&gt;

&lt;p&gt;Part of what brought these things to my attention was &lt;a href=&quot;https://github.com/maedhroz/cassandra/pull/14&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;playing around&lt;/a&gt; w/ a fix based on the patch for this Jira for &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-19007&quot; title=&quot;Queries with multi-column replica-side filtering can miss rows&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-19007&quot;&gt;CASSANDRA-19007&lt;/a&gt; for basic filtering.&lt;/p&gt;</comment>
                            <comment id="17803696" author="maedhroz" created="Fri, 5 Jan 2024 20:21:34 +0000"  >&lt;p&gt;So just to follow up on the &lt;tt&gt;postIndexQueryFilter()&lt;/tt&gt; issue, this looks like it only affects &lt;tt&gt;IN&lt;/tt&gt; and user-defined expressions, where we don&apos;t support conversion to &lt;tt&gt;UnindexedExpression&lt;/tt&gt;. (For other operators, the expression doesn&apos;t actually make it to the post-index filter and is therefor evaluated in &lt;tt&gt;FilterTree&lt;/tt&gt;. I&apos;ve expanded the tests to cover this.) I think we&apos;ll want to support &lt;tt&gt;IN&lt;/tt&gt;, but that can probably happen in a separate Jira.&lt;/p&gt;

&lt;p&gt;The proximate cause of this, I suppose, was &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-18994&quot; title=&quot;SAI range query does not play together with &amp;quot;IN&amp;quot;&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-18994&quot;&gt;&lt;del&gt;CASSANDRA-18994&lt;/del&gt;&lt;/a&gt;...although it didn&apos;t actually work correctly before that either.&lt;/p&gt;</comment>
                            <comment id="17803717" author="maedhroz" created="Fri, 5 Jan 2024 22:52:12 +0000"  >&lt;p&gt;Attached CI results. The only thing I&apos;m not quite sure about is the failure in &lt;tt&gt;TestLargeColumn&lt;/tt&gt;, but I doubt it&apos;s related...&lt;/p&gt;

&lt;p&gt; &lt;span class=&quot;nobr&quot;&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/attachment/13066886/13066886_result_details.tar.gz&quot; title=&quot;result_details.tar.gz attached to CASSANDRA-19018&quot;&gt;result_details.tar.gz&lt;sup&gt;&lt;img class=&quot;rendericon&quot; src=&quot;https://issues.apache.org/jira/images/icons/link_attachment_7.gif&quot; height=&quot;7&quot; width=&quot;7&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/sup&gt;&lt;/a&gt;&lt;/span&gt;  &lt;span class=&quot;nobr&quot;&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/attachment/13066885/13066885_ci_summary.html&quot; title=&quot;ci_summary.html attached to CASSANDRA-19018&quot;&gt;ci_summary.html&lt;sup&gt;&lt;img class=&quot;rendericon&quot; src=&quot;https://issues.apache.org/jira/images/icons/link_attachment_7.gif&quot; height=&quot;7&quot; width=&quot;7&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/sup&gt;&lt;/a&gt;&lt;/span&gt; &lt;/p&gt;</comment>
                            <comment id="17812083" author="maedhroz" created="Mon, 29 Jan 2024 23:17:28 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=adelapena&quot; class=&quot;user-hover&quot; rel=&quot;adelapena&quot;&gt;adelapena&lt;/a&gt; So for giggles, there&apos;s a Harry fuzz test that can reproduce this as well now in &lt;a href=&quot;https://github.com/apache/cassandra/pull/3044&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/cassandra/pull/3044&lt;/a&gt;. (see &lt;tt&gt;MultiNodeSAITest&lt;/tt&gt;) One more thing we can use to validate this when it&apos;s ready to commit.&lt;/p&gt;</comment>
                            <comment id="17812280" author="ifesdjeen" created="Tue, 30 Jan 2024 12:21:34 +0000"  >&lt;p&gt;I am not fully done with my review just yet, but wanted to post some early findings, since they may change the course a bit.&lt;/p&gt;

&lt;p&gt;I&apos;m not sure if we can rely on timestamps to be different for detecting partial updates. Partial updates may have timestamp collisions:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
        &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; (Cluster cluster = init(Cluster.build(2).withConfig(cfg -&amp;gt; cfg.with(NETWORK, GOSSIP)).start()))
        {
            cluster.schemaChange(withKeyspace(&lt;span class=&quot;code-quote&quot;&gt;&quot;CREATE TABLE %s.t (k &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; PRIMARY KEY, a &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt;, b &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt;)&quot;&lt;/span&gt;));
            cluster.schemaChange(withKeyspace(&lt;span class=&quot;code-quote&quot;&gt;&quot;CREATE INDEX ON %s.t(a) USING &lt;span class=&quot;code-quote&quot;&gt;&apos;sai&apos;&lt;/span&gt;&quot;&lt;/span&gt;));
            cluster.schemaChange(withKeyspace(&lt;span class=&quot;code-quote&quot;&gt;&quot;CREATE INDEX ON %s.t(b) USING &lt;span class=&quot;code-quote&quot;&gt;&apos;sai&apos;&lt;/span&gt;&quot;&lt;/span&gt;));
            SAIUtil.waitForIndexQueryable(cluster, KEYSPACE);

            &lt;span class=&quot;code-comment&quot;&gt;// insert a split row
&lt;/span&gt;            cluster.get(1).executeInternal(withKeyspace(&lt;span class=&quot;code-quote&quot;&gt;&quot;INSERT INTO %s.t(k, a, b) VALUES (0, 1, 2) USING TIMESTAMP 1&quot;&lt;/span&gt;));
            cluster.get(2).executeInternal(withKeyspace(&lt;span class=&quot;code-quote&quot;&gt;&quot;INSERT INTO %s.t(k, a, b) VALUES (0, 2, 1) USING TIMESTAMP 1&quot;&lt;/span&gt;));

            &lt;span class=&quot;code-comment&quot;&gt;// Uncomment &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; line and test succeeds w/ partial writes completed...
&lt;/span&gt;            &lt;span class=&quot;code-comment&quot;&gt;// cluster.get(1).nodetoolResult(&lt;span class=&quot;code-quote&quot;&gt;&quot;repair&quot;&lt;/span&gt;, KEYSPACE).asserts().success();
&lt;/span&gt;
            &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; select = withKeyspace(&lt;span class=&quot;code-quote&quot;&gt;&quot;SELECT * FROM %s.t WHERE a = 2 AND b = 2&quot;&lt;/span&gt;);
            &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;[][] initialRows = cluster.coordinator(1).execute(select, ConsistencyLevel.ALL);
            AssertUtils.assertRows(initialRows, AssertUtils.row(0,2,2));
        }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;When reconciled, value 2 will take precedence because of lexicographical conflict resolution. This test will fail with:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
java.lang.AssertionError: 
Expected: [[0, 2, 2]]
Actual: []
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;When repaired, both columns will have value &lt;tt&gt;2&lt;/tt&gt;, and match on the index will get triggered.&lt;/p&gt;

&lt;p&gt;Also, would you be opposed to merging &lt;tt&gt;CQLFilter&lt;/tt&gt; and &lt;tt&gt;RowFilter&lt;/tt&gt;? POC &lt;a href=&quot;https://github.com/ifesdjeen/cassandra/commit/48f60ca8ac6c683854eced602e949259850f638b&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;</comment>
                            <comment id="17812431" author="maedhroz" created="Tue, 30 Jan 2024 17:59:53 +0000"  >&lt;p&gt;I&apos;ll address the easy one first...&lt;/p&gt;

&lt;p&gt;I have no problem merging &lt;tt&gt;CQLFilter&lt;/tt&gt; and &lt;tt&gt;RowFIlter&lt;/tt&gt; as you&apos;ve done it there. &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=adelapena&quot; class=&quot;user-hover&quot; rel=&quot;adelapena&quot;&gt;adelapena&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=blerer&quot; class=&quot;user-hover&quot; rel=&quot;blerer&quot;&gt;blerer&lt;/a&gt;?&lt;/p&gt;</comment>
                            <comment id="17812447" author="maedhroz" created="Tue, 30 Jan 2024 19:15:25 +0000"  >&lt;blockquote&gt;&lt;p&gt;I&apos;m not sure if we can rely on timestamps to be different for detecting partial updates. Partial updates may have timestamp collisions&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;After reproducing locally myself and thinking it over a bit, I think &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ifesdjeen&quot; class=&quot;user-hover&quot; rel=&quot;ifesdjeen&quot;&gt;ifesdjeen&lt;/a&gt; is right. Because we break the ties per-cell, there might not be enough information to correctly do what I&apos;ve got in the patch in &lt;tt&gt;FilterTree#getLocalOperator()&lt;/tt&gt;. Removing this doesn&apos;t mean anything for correctness, but it was a nice optimization in terms of how many results we&apos;d have to send to the coordinator. Trying to think of another way around this, and open to suggestions, although I&apos;m not immediately sure if it&apos;s possible without the row read itself keeping track of ties...&lt;/p&gt;

&lt;p&gt;Actually, even if we were able to keep track of timestamp ties locally, it might not matter. We might have two complete-row mutations w/ the same timestamp hitting different replicas where strict filtering on neither one would produce a match, but a match would exist post-reconciliation. I think I&apos;m just going to have to change &lt;tt&gt;getLocalOperator()&lt;/tt&gt; to downgrade to unions when the coordinator tells us strict filtering isn&apos;t safe.&lt;/p&gt;

&lt;p&gt;I think this also renders moot all of our previous discussion on things like requiring non-partial updates, given it&apos;s possible to break things even with those (in the presence of a timestamp collision).&lt;/p&gt;

&lt;p&gt;CC &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=adelapena&quot; class=&quot;user-hover&quot; rel=&quot;adelapena&quot;&gt;adelapena&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=pkolaczk&quot; class=&quot;user-hover&quot; rel=&quot;pkolaczk&quot;&gt;pkolaczk&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="17812671" author="ifesdjeen" created="Wed, 31 Jan 2024 11:24:13 +0000"  >&lt;p&gt;+1 from my side; added very minor comments resolvable on commit to the PR. Also, I think there is some value in adding the tests for replica filtering protection/timestamp collision and the one above: &lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
    @Test
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void testPartialUpdatesWithTimestampCollision() &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; Throwable
    {
        &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; (Cluster cluster = init(Cluster.build(2).withConfig(cfg -&amp;gt; cfg.with(NETWORK, GOSSIP)).start()))
        {
            cluster.schemaChange(withKeyspace(&lt;span class=&quot;code-quote&quot;&gt;&quot;CREATE TABLE %s.t (k &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; PRIMARY KEY, a &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt;, b &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt;)&quot;&lt;/span&gt;));
            cluster.schemaChange(withKeyspace(&lt;span class=&quot;code-quote&quot;&gt;&quot;CREATE INDEX ON %s.t(a) USING &lt;span class=&quot;code-quote&quot;&gt;&apos;sai&apos;&lt;/span&gt;&quot;&lt;/span&gt;));
            cluster.schemaChange(withKeyspace(&lt;span class=&quot;code-quote&quot;&gt;&quot;CREATE INDEX ON %s.t(b) USING &lt;span class=&quot;code-quote&quot;&gt;&apos;sai&apos;&lt;/span&gt;&quot;&lt;/span&gt;));
            SAIUtil.waitForIndexQueryable(cluster, KEYSPACE);

            &lt;span class=&quot;code-comment&quot;&gt;// insert a split row
&lt;/span&gt;            cluster.get(1).executeInternal(withKeyspace(&lt;span class=&quot;code-quote&quot;&gt;&quot;INSERT INTO %s.t(k, a, b) VALUES (0, 1, 2) USING TIMESTAMP 1&quot;&lt;/span&gt;));
            cluster.get(2).executeInternal(withKeyspace(&lt;span class=&quot;code-quote&quot;&gt;&quot;INSERT INTO %s.t(k, a, b) VALUES (0, 2, 1) USING TIMESTAMP 1&quot;&lt;/span&gt;));
            &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; select = withKeyspace(&lt;span class=&quot;code-quote&quot;&gt;&quot;SELECT * FROM %s.t WHERE a = 2 AND b = 2&quot;&lt;/span&gt;);
            &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;[][] initialRows = cluster.coordinator(1).execute(select, ConsistencyLevel.ALL);
            AssertUtils.assertRows(initialRows, AssertUtils.row(0, 2, 2));
        }
    }

    @Test
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void testPartialUpdatesOneColumn() &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; Throwable
    {
        &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; (Cluster cluster = init(Cluster.build(2).withConfig(cfg -&amp;gt; cfg.with(NETWORK, GOSSIP)).start()))
        {
            cluster.schemaChange(withKeyspace(&lt;span class=&quot;code-quote&quot;&gt;&quot;CREATE TABLE %s.t (k &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; PRIMARY KEY, a &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt;)&quot;&lt;/span&gt;));
            cluster.schemaChange(withKeyspace(&lt;span class=&quot;code-quote&quot;&gt;&quot;CREATE INDEX ON %s.t(a) USING &lt;span class=&quot;code-quote&quot;&gt;&apos;sai&apos;&lt;/span&gt;&quot;&lt;/span&gt;));
            SAIUtil.waitForIndexQueryable(cluster, KEYSPACE);
            cluster.get(1).executeInternal(withKeyspace(&lt;span class=&quot;code-quote&quot;&gt;&quot;INSERT INTO %s.t(k, a) VALUES (0, 1) USING TIMESTAMP 1&quot;&lt;/span&gt;));
            cluster.get(2).executeInternal(withKeyspace(&lt;span class=&quot;code-quote&quot;&gt;&quot;INSERT INTO %s.t(k, a) VALUES (0, 100) USING TIMESTAMP 1&quot;&lt;/span&gt;));
            &lt;span class=&quot;code-comment&quot;&gt;// resolved via replica filtering protection
&lt;/span&gt;            &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;[][] initialRows = cluster.coordinator(1).execute(withKeyspace(&lt;span class=&quot;code-quote&quot;&gt;&quot;SELECT * FROM %s.t WHERE a = 1&quot;&lt;/span&gt;), ConsistencyLevel.ALL);
            AssertUtils.assertRows(initialRows);
        }
    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="17812706" author="adelapena" created="Wed, 31 Jan 2024 13:45:21 +0000"  >&lt;blockquote&gt;&lt;p&gt;I think this also renders moot all of our previous discussion on things like requiring non-partial updates, given it&apos;s possible to break things even with those (in the presence of a timestamp collision).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I agree. It seems we need the new protection mechanism for all queries with CL&amp;gt;1 and multiple restrictions on mutable columns, which is unfortunate. Good catch, &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ifesdjeen&quot; class=&quot;user-hover&quot; rel=&quot;ifesdjeen&quot;&gt;ifesdjeen&lt;/a&gt;.&lt;/p&gt;</comment>
                            <comment id="17812744" author="adelapena" created="Wed, 31 Jan 2024 15:15:55 +0000"  >&lt;blockquote&gt;&lt;p&gt;I have no problem merging&#160;&lt;tt&gt;CQLFilter&lt;/tt&gt;&#160;and&#160;&lt;tt&gt;RowFIlter&lt;/tt&gt;&#160;as you&apos;ve done it there.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Makes sense to me. &lt;tt&gt;CQLFilter&lt;/tt&gt; looks like a useless remainder of a time when there was a &lt;tt&gt;ThriftFilter&lt;/tt&gt; too.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Also, I think there is some value in adding the tests for replica filtering protection/timestamp collision and the one above&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;It would be ideal if the conflicting timestamp cases were parameterized in the same way it&apos;s done for partial updates by the excellent &lt;tt&gt;PartialUpdateHandlingTest&lt;/tt&gt;. Even if we have the parameterized versions of these cases, it could be helpful to keep the two simple examples we have in this ticket because they are very easy to read, and might be handy when trying new cases. For example, the timestamp case looks built by slightly modifying the test in the ticket description.&lt;/p&gt;</comment>
                            <comment id="17813481" author="maedhroz" created="Fri, 2 Feb 2024 04:43:10 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=adelapena&quot; class=&quot;user-hover&quot; rel=&quot;adelapena&quot;&gt;adelapena&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ifesdjeen&quot; class=&quot;user-hover&quot; rel=&quot;ifesdjeen&quot;&gt;ifesdjeen&lt;/a&gt; I think I&apos;ve addressed all outstanding feedback (in a series of individual commits to make review easier). My internal CI runs are clean. Let me know if there&apos;s anything I&apos;ve missed. Thanks!&lt;/p&gt;</comment>
                            <comment id="17813819" author="maedhroz" created="Fri, 2 Feb 2024 20:14:43 +0000"  >&lt;p&gt;While running the new tests on the trunk branch, I stumbled across some interesting failures caused by the changes I made to &lt;tt&gt;RowMapping&lt;/tt&gt; in &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-19278&quot; title=&quot;AND queries involving both static and regular columns can hide matches from Memtable-attached indexes&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-19278&quot;&gt;&lt;del&gt;CASSANDRA-19278&lt;/del&gt;&lt;/a&gt;. I&apos;ve since fixed that and pushed to both &lt;a href=&quot;https://github.com/apache/cassandra/pull/2935/commits&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;5.0&lt;/a&gt; and &lt;a href=&quot;https://github.com/apache/cassandra/pull/3083&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;trunk&lt;/a&gt; PRs.&lt;/p&gt;

&lt;p&gt;(Basically, &lt;tt&gt;PartialUpdateHandlingTest&lt;/tt&gt; pointed out that the key tracking was broken in &lt;tt&gt;RowMapping&lt;/tt&gt; with mixed static and composite partition key element indexes.)&lt;/p&gt;

&lt;p&gt;New CI results from both branches coming soon...&lt;/p&gt;</comment>
                            <comment id="17813855" author="maedhroz" created="Fri, 2 Feb 2024 23:37:30 +0000"  >&lt;p&gt;There is a block of errors in the Python/in-JVM upgrade tests on my end, but those are due to an issue in my CI infrastructure. The upgrade tests aren&apos;t too relevant to this issue either way. Everything else looks fine. I&apos;m going to run the battery of Harry tests we&apos;re working on in &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-18275&quot; title=&quot;Harry model and in-JVM test for partition-restricted 2i queries&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-18275&quot;&gt;&lt;del&gt;CASSANDRA-18275&lt;/del&gt;&lt;/a&gt; against the trunk patch just make sure we have no regressions there...&lt;/p&gt;

&lt;p&gt; &lt;span class=&quot;nobr&quot;&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/attachment/13066887/13066887_ci_summary-1.html&quot; title=&quot;ci_summary-1.html attached to CASSANDRA-19018&quot;&gt;ci_summary-1.html&lt;sup&gt;&lt;img class=&quot;rendericon&quot; src=&quot;https://issues.apache.org/jira/images/icons/link_attachment_7.gif&quot; height=&quot;7&quot; width=&quot;7&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/sup&gt;&lt;/a&gt;&lt;/span&gt; &lt;/p&gt;</comment>
                            <comment id="17813861" author="maedhroz" created="Sat, 3 Feb 2024 00:39:42 +0000"  >&lt;p&gt;Harry testing &lt;a href=&quot;https://github.com/maedhroz/cassandra/pull/15&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;has uncovered&lt;/a&gt; has uncovered some additional problems. One of them might be that when we have a single-node cluster, we don&apos;t need reconciliation, but right now, something like &lt;tt&gt;QUORUM&lt;/tt&gt; will indicate we do.&lt;/p&gt;</comment>
                            <comment id="17813875" author="maedhroz" created="Sat, 3 Feb 2024 07:14:26 +0000"  >&lt;p&gt;I&apos;ve been working in &lt;a href=&quot;https://github.com/maedhroz/cassandra/pull/15&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;the Harry PR&lt;/a&gt;, as it&apos;s just easier to iterate there. As things stabilize, I&apos;ll move them back to the 19018 patches. So far, Harry has pointed out two things:&lt;/p&gt;

&lt;p&gt;1.) If we read at &lt;tt&gt;QUORUM&lt;/tt&gt; or &lt;tt&gt;ALL&lt;/tt&gt; on a single-node cluster, &lt;tt&gt;needsReconciliation()&lt;/tt&gt; will answer in the affirmative, and we&apos;ll revert to the non-strict filtering logic intended for use w/ multiple nodes. This is easy to avoid by setting a sensible read consistency level, and with this, &lt;tt&gt;SingleNodeSAITest&lt;/tt&gt; and &lt;tt&gt;StaticsTortureTest&lt;/tt&gt; make it through extended runs without problems. It might be better to additionally check the replication factor of the keyspace we&apos;re querying to make sure we still do the right thing for &lt;tt&gt;QUORUM&lt;/tt&gt; and &lt;tt&gt;ALL&lt;/tt&gt;. Making this change in &lt;tt&gt;StatementRestriction#getRowFilter()&lt;/tt&gt; also allows these two tests to run without issue.&lt;/p&gt;

&lt;p&gt;2.) &lt;tt&gt;InJvmSutBase&lt;/tt&gt; and therefore &lt;tt&gt;MultiNodeSAITest&lt;/tt&gt; use paging w/ a fetch size of 1. (I&apos;ve changed &lt;tt&gt;PartialUpdateHandlingTest&lt;/tt&gt; to do this too, for reasons that will soon become apparent, although it passes with flying colors still.) In conjunction w/ the new non-strict filtering logic here, there are situations where the strict post-filtering that happens after replica filtering protection eliminates a non-strict match from a replica...but no short read protection occurs. I think this would also occur w/ a LIMIT of 1. I&apos;ve made an attempt at adding short read protection in &lt;tt&gt;DataResolver#resolveWithReplicaFilteringProtection()&lt;/tt&gt;, and this takes &lt;tt&gt;MultiNodeSAITest&lt;/tt&gt; from failing almost immediately (about 10 seconds) to running happily for a minute or two, and eventually failing in a completely different way:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;org.apache.cassandra.harry.model.Model$ValidationException: Found a row while model predicts statics only:
Expected:  rowStateRow(-4270507212538418608L, -9223372036854775808, values(-8292973307042192125L), lts(28972L), values(-8292973307042192125L), lts(28972L))
Actual: resultSetRow(-4270507212538418608L, 3338663292788043269L, statics(-8292973307042192125L), lts(28972L), values(-9223372036854775808L,-8292973307042192125L,-7423979211207825555L), lts(-9223372036854775808L,22376L,22376L))
Query: CompiledStatement{cql=&apos;SELECT pk1, pk2, pk3, ck1, ck2, ck3, s1, v1, v2, v3, writetime(s1), writetime(v1), writetime(v2), writetime(v3) FROM distributed_test_keyspace.tbl1 WHERE pk1 = ? AND pk2 = ? AND pk3 = ? AND v2 = ? AND v3 = ?;&apos;, bindings=1153178704L,&quot;ZHHyABdiABdiABdiABdiABdiygANvtdA1417414080121120318513717714751110139374521458162113150301962217515912023323114324224572725422917410488118183642122461261341782131372397068109145207519610123518824536237251161062231134916218712465938595117240579750159172261719222439136&quot;,27216L,-8292973307042192125L,-7423979211207825555L}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Disabling static column indexing or increasing the fetch/page size to 10,000 rows produces this:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;org.apache.cassandra.harry.model.Model$ValidationException: Returned row state doesn&apos;t match the one predicted by the model:
Expected: -6688467811848818630-4962768465676381896, -4962768465676381896,  ( rowStateRow(5024781677423462809L, -2339751831653719635, values(-6688467811848818630L), lts(19921L), values(-6688467811848818630L,-4962768465676381896L,-4962768465676381896L), lts(264L,264L,7465L), clustering=[ZHHyABdiABdiABdiRwdFaXalaaANFfLo25295481012923054220223105571722471366830351971311472242226817725124121123136771432346020014173159421101258430141229231571772059511915411223222966681181131611075911168145115129138661402092155423321224244801012431697933235232, ZYFiYEUkzcKOhdyazcKOhdyazcKOhdyazcKOhdyazcKOhdyaxSFhHosLPpEzbCrp, 57773], values=[GIzPsPrWJWiYMmxIzNckJdrhiUJHPEmagerzwhAVJyOVBlABXHfIIeyGqyovtyIOxvoNdWCExWChJsmxpsnwWJzRqYZNkjFPsIfJJitGAhNYiuVxGnifddZuxSdVBEqoJhugErHMAHXhvJVGKzOkwCPEQiWhEXDOPpNdszFFSNwoeOtYoNyCYigczgDARnqHVXlRuHDKEjxElPVmNeCUBgzyWKnBjhdHTBnsEDPkIYnGiKMcwhbzPMvmrIebFgKtgGOUcJopINGGKJgYvTkqlAmDMhWlpGqXPgfWWTvlMFeOITwGpsXQdBkpBVUCZxmd72114182, -4962768465676381896, -4962768465676381896]))
Actual:   -6688467811848818630-4962768465676381896, -7423979211207825555,  (resultSetRow(5024781677423462809L, -2339751831653719635L, statics(-6688467811848818630L), lts(19921L), values(-6688467811848818630L,-4962768465676381896L,-7423979211207825555L), lts(264L,264L,264L))).
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In any case, I&apos;ve committed the state of my testing setup and &lt;a href=&quot;https://github.com/maedhroz/cassandra/pull/15/commits/4fc4543b3de3eb131738be0f427a315da315c48a&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;some preliminary fixes&lt;/a&gt; in the &lt;a href=&quot;https://github.com/maedhroz/cassandra/pull/15&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;WIP Harry branch&lt;/a&gt;. It&apos;s possible we&apos;ve identified a completely new failure care here. I&apos;ll have to pick it up Monday. It should be easy to reproduce the problems above though with that branch.&lt;/p&gt;</comment>
                            <comment id="17814134" author="maedhroz" created="Mon, 5 Feb 2024 01:08:36 +0000"  >&lt;p&gt;To make the &quot;short read&quot; problem above more concrete, here&apos;s a pretty easy repro:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;@Test
public void testPartialUpdatesWithShortRead()
{
    CLUSTER.schemaChange(withKeyspace(&quot;CREATE TABLE %s.partial_updates (k int PRIMARY KEY, a int, b int) WITH read_repair = &apos;NONE&apos;&quot;));
    CLUSTER.schemaChange(withKeyspace(&quot;CREATE INDEX ON %s.partial_updates(a) USING &apos;sai&apos;&quot;));
    CLUSTER.schemaChange(withKeyspace(&quot;CREATE INDEX ON %s.partial_updates(b) USING &apos;sai&apos;&quot;));
    SAIUtil.waitForIndexQueryable(CLUSTER, KEYSPACE);

    // insert a split row
    CLUSTER.get(1).executeInternal(withKeyspace(&quot;INSERT INTO %s.partial_updates(k, a) VALUES (0, 1) USING TIMESTAMP 1&quot;));
    CLUSTER.get(2).executeInternal(withKeyspace(&quot;INSERT INTO %s.partial_updates(k, b) VALUES (0, 2) USING TIMESTAMP 2&quot;));


    // insert a split row that only matches on non-strict filtering but is kicked out by RFP
    CLUSTER.get(1).executeInternal(withKeyspace(&quot;INSERT INTO %s.partial_updates(k, a, b) VALUES (1, 4, 2) USING TIMESTAMP 3&quot;));
    CLUSTER.get(2).executeInternal(withKeyspace(&quot;INSERT INTO %s.partial_updates(k, a, b) VALUES (1, 1, 4) USING TIMESTAMP 4&quot;));

    String select = withKeyspace(&quot;SELECT * FROM %s.partial_updates WHERE a = 1 AND b = 2&quot;);
    Iterator&amp;lt;Object[]&amp;gt; initialRows = CLUSTER.coordinator(1).executeWithPaging(select, ConsistencyLevel.ALL, 1);
    assertRows(initialRows, row(0, 1, 2));
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This fails the same way if you bump the page size to 2 and set a &lt;tt&gt;LIMIT 1&lt;/tt&gt;.&lt;/p&gt;</comment>
                            <comment id="17816783" author="maedhroz" created="Mon, 12 Feb 2024 20:24:06 +0000"  >&lt;p&gt;Alright, posting here, although there&apos;s been some Slack discussion. Queries on indexed static columns break RFP, and here&apos;s a simple reproduction, whittled down from a prior Harry test...&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;    @Test
    public void testPartialUpdatesStaticOnly()
    {
        CLUSTER.schemaChange(withKeyspace(&quot;CREATE TABLE %s.partial_updates (k int, c int, s int static, b int, PRIMARY KEY (k, c)) WITH read_repair = &apos;NONE&apos;&quot;));
        CLUSTER.schemaChange(withKeyspace(&quot;CREATE INDEX ON %s.partial_updates(s) USING &apos;sai&apos;&quot;));
        SAIUtil.waitForIndexQueryable(CLUSTER, KEYSPACE);


        // insert a split row
        CLUSTER.get(1).executeInternal(withKeyspace(&quot;INSERT INTO %s.partial_updates(k, s) VALUES (0, 2) USING TIMESTAMP 100&quot;));
        CLUSTER.get(2).executeInternal(withKeyspace(&quot;INSERT INTO %s.partial_updates(k, c, s, b) VALUES (0, 0, 1, 2) USING TIMESTAMP 10&quot;));
        //CLUSTER.get(1).nodetool(&quot;repair&quot;, KEYSPACE); &amp;lt;-- un-comment and everything is fine, of course

        String select = withKeyspace(&quot;SELECT * FROM %s.partial_updates WHERE s = 2&quot;);
        Object[][] initialRows = CLUSTER.coordinator(1).execute(select, ConsistencyLevel.ALL);
        assertRows(initialRows, row(0, 0, 2, 2));
    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Long story short, when RFP has a legitimate static row match from one replica, but no clusterings, and the other replica has no static row match, but does have clusterings that COULD BECOME matches together w/ the static row from the first node, RFP does NOT fetch the entire partition like it&apos;s supposed to from the silent node. This means the only clusterings in the final result will be the ones we might get from the first node. (In my example above, there are none, of course.) I&apos;ve got this test passing by simply fetching the whole partition from the silent replica when the static row isn&apos;t fully resolved by the row merger/merge listener, but there may be a more efficient way.&lt;/p&gt;</comment>
                            <comment id="17817515" author="maedhroz" created="Wed, 14 Feb 2024 20:09:48 +0000"  >&lt;p&gt;I&apos;ve finally narrowed in on a concrete repro for the range tombstone problems...&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;@Test
public void testPartialUpdatesWithDeleteBetween()
{
    CLUSTER.schemaChange(withKeyspace(&quot;CREATE TABLE %s.partial_updates (k int, c int, a int, b int, PRIMARY KEY (k, c)) WITH read_repair = &apos;NONE&apos;&quot;));
    CLUSTER.schemaChange(withKeyspace(&quot;CREATE INDEX ON %s.partial_updates(a) USING &apos;sai&apos;&quot;));
    CLUSTER.schemaChange(withKeyspace(&quot;CREATE INDEX ON %s.partial_updates(b) USING &apos;sai&apos;&quot;));
    SAIUtil.waitForIndexQueryable(CLUSTER, KEYSPACE);

    // insert a split row w/ a range tombstone sandwiched in the middle temporally 
    CLUSTER.get(1).executeInternal(withKeyspace(&quot;INSERT INTO %s.partial_updates(k, c, a) VALUES (0, 1, 1) USING TIMESTAMP 1&quot;));
    CLUSTER.get(2).executeInternal(withKeyspace(&quot;DELETE FROM %s.partial_updates USING TIMESTAMP 2 WHERE k = 0 AND c &amp;gt; 0&quot;));
    CLUSTER.get(2).executeInternal(withKeyspace(&quot;INSERT INTO %s.partial_updates(k, c, b) VALUES (0, 1, 2) USING TIMESTAMP 3&quot;));

    String select = withKeyspace(&quot;SELECT * FROM %s.partial_updates WHERE a = 1 AND b = 2&quot;);
    Object[][] initialRows = CLUSTER.coordinator(1).execute(select, ConsistencyLevel.ALL);
    assertRows(initialRows);  &amp;lt;-- This returns a row when it shouldn&apos;t!
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;tl;dr Because we can degrade intersections to unions inside SAI on unrepaired data, RFP no longer implicitly covers all delete cases without sending range tombstones to the coordinator or identifying silent replicas purely at the row level. In the case above, RFP could be made to work if it identified &quot;silent&quot; columns rather than entire rows. (i.e. It would notice that &quot;a&quot; from node 1 has no corresponding value from node 2, so the response from node 2 needs to be protected. Assuming data isn&apos;t always horrifically out of date, this is likely better than trying to send mostly unnecessary RTs.)&lt;/p&gt;</comment>
                            <comment id="17817823" author="maedhroz" created="Fri, 16 Feb 2024 00:28:52 +0000"  >&lt;p&gt;After resolving several bugs ranging from SAI&apos;s local internals to changes required by non-strict filtering in replica filtering protection, I&apos;ve finally been able to consolidate everything and get stable fuzz testing/Harry runs. (These typically burn in for between 30 minutes and 2 hours on my MBP.) The work in progress had been carried out in &lt;a href=&quot;https://github.com/maedhroz/cassandra/pull/15&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;the WIP Harry branch&lt;/a&gt; (based on the trunk patch for this issue) to make iterating faster, but it has now been moved back as a &lt;a href=&quot;https://github.com/apache/cassandra/pull/3083/commits/5919f3d8c5290b1b61baa43cf0783db5de0d95e1&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;single commit&lt;/a&gt; &lt;a href=&quot;https://github.com/apache/cassandra/pull/3083&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;here&lt;/a&gt; and is ready for review...again &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;CI is in progress, and I&apos;ll have results soon...&lt;/p&gt;

&lt;p&gt;The changes made over the past couple weeks have highlighted even more clearly what this whole issue is about. We&apos;ve had to make changes to make sure distributed filtering/index queries can be correct, but there is conceptually no way to do that without trading away performance that is aligned very closely to the extent to which the data we&apos;re looking at is out-of-sync. When repair is keeping inconsistencies to a minimum, things should go reasonably well, but when large divergences and large quantities of unrepaired data are allowed to persist, there will be pain.&lt;/p&gt;

&lt;p&gt;I think it&apos;s also probably appropriate to note that static columns have become even more dangerous, as matches on static columns can now entail pulling entire partitions through RFP in coordinator space or post-filtering entire partitions locally.&lt;/p&gt;</comment>
                            <comment id="17818592" author="maedhroz" created="Mon, 19 Feb 2024 22:58:44 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=adelapena&quot; class=&quot;user-hover&quot; rel=&quot;adelapena&quot;&gt;adelapena&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ifesdjeen&quot; class=&quot;user-hover&quot; rel=&quot;ifesdjeen&quot;&gt;ifesdjeen&lt;/a&gt; The &lt;a href=&quot;https://github.com/apache/cassandra/pull/2935&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;5.0&lt;/a&gt; and &lt;a href=&quot;https://github.com/apache/cassandra/pull/3083&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;trunk&lt;/a&gt; patches are ready for review again, and I&apos;ll have CI runs attached as well shortly. The only thing I&apos;d say isn&apos;t 100% ready is inline JavaDoc/documentation that will solidify after things are otherwise ready to commit.&lt;/p&gt;

&lt;p&gt;UPDATE: CI results attached. There are some known failures, like &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-19168&quot; title=&quot;Test Failure: VectorUpdateDeleteTest fails with heap_buffers&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-19168&quot;&gt;&lt;del&gt;CASSANDRA-19168&lt;/del&gt;&lt;/a&gt;, and environment-related upgrade test problems, but otherwise, things look pretty good.&lt;/p&gt;</comment>
                            <comment id="17819326" author="adelapena" created="Wed, 21 Feb 2024 16:58:29 +0000"  >&lt;p&gt;The changes look good to me, +1. Here is 5.0 CI with repeated runs for the new and modified tests:&lt;/p&gt;
&lt;div class=&apos;table-wrap&apos;&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;PR&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;CI&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://github.com/apache/cassandra/pull/2935&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;5.0&lt;/a&gt;&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://app.circleci.com/pipelines/github/adelapena/cassandra/3443/workflows/11c238f4-5b28-4a37-a653-1016d9d1dfa1&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;j11&lt;/a&gt; &lt;a href=&quot;https://app.circleci.com/pipelines/github/adelapena/cassandra/3443/workflows/84d857b5-6097-40dd-a276-772b443bf9de&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;j17&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;
</comment>
                            <comment id="17819327" author="maedhroz" created="Wed, 21 Feb 2024 17:02:50 +0000"  >&lt;p&gt;Nice! Looks like Circle more or less confirms what I&apos;m seeing on my CI...clean w/ the exception of &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-19168&quot; title=&quot;Test Failure: VectorUpdateDeleteTest fails with heap_buffers&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-19168&quot;&gt;&lt;del&gt;CASSANDRA-19168&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="17821758" author="maedhroz" created="Wed, 28 Feb 2024 16:40:07 +0000"  >&lt;p&gt;Going to start the squash/rebase/commit process today...&lt;/p&gt;</comment>
                            <comment id="17822303" author="maedhroz" created="Thu, 29 Feb 2024 21:06:57 +0000"  >&lt;p&gt;Committed as &lt;a href=&quot;https://github.com/apache/cassandra/commit/f7984627e7dd5794dabc099f49ecf80ca3631803&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/cassandra/commit/f7984627e7dd5794dabc099f49ecf80ca3631803&lt;/a&gt;&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="12310660">
                    <name>Completes</name>
                                            <outwardlinks description="fixes">
                                        <issuelink>
            <issuekey id="13570959">CASSANDRA-19459</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="13557061">CASSANDRA-19007</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="13603997">CASSANDRA-20189</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12753516">CASSANDRA-8272</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="13556524">CASSANDRA-18994</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="13066887" name="ci_summary-1.html" size="7103" author="maedhroz" created="Tue, 20 Feb 2024 02:48:17 +0000"/>
                            <attachment id="13066885" name="ci_summary.html" size="7096" author="maedhroz" created="Tue, 20 Feb 2024 02:47:57 +0000"/>
                            <attachment id="13066888" name="result_details.tar-1.gz" size="53136163" author="maedhroz" created="Tue, 20 Feb 2024 02:48:25 +0000"/>
                            <attachment id="13066886" name="result_details.tar.gz" size="50948509" author="maedhroz" created="Tue, 20 Feb 2024 02:48:03 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>4.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12313920" key="com.atlassian.jira.plugin.system.customfieldtypes:multiuserpicker">
                        <customfieldname>Authors</customfieldname>
                        <customfieldvalues>
                                    <customfieldvalue><![CDATA[maedhroz]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12313825" key="com.atlassian.jira.plugin.system.customfieldtypes:cascadingselect">
                        <customfieldname>Bug Category</customfieldname>
                        <customfieldvalues>
                                                    <customfieldvalue key="12982" cascade-level=""><![CDATA[Correctness]]></customfieldvalue>
                                <customfieldvalue key="12987" cascade-level="1"><![CDATA[Transient Incorrect Response]]></customfieldvalue>
            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12313821" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Complexity</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="12966"><![CDATA[Challenging]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12313822" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Discovered By</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="12977"><![CDATA[Adhoc Test]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12311120" key="com.pyxis.greenhopper.jira:gh-epic-link">
                        <customfieldname>Epic Link</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>CASSANDRA-18473</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12313922" key="jira.plugin.projectspecificselectfield.jpssf:multicftype">
                        <customfieldname>Impacts</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="13100"><![CDATA[None]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            1 year, 36 weeks, 5 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12313921" key="jira.plugin.projectspecificselectfield.jpssf:multicftype">
                        <customfieldname>Platform</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="13076"><![CDATA[All]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|z1liaw:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12313420" key="com.atlassian.jira.plugin.system.customfieldtypes:multiuserpicker">
                        <customfieldname>Reviewers</customfieldname>
                        <customfieldvalues>
                                    <customfieldvalue><![CDATA[ifesdjeen]]></customfieldvalue>
        <customfieldvalue><![CDATA[adelapena]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12313820" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Severity</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="12963"><![CDATA[Critical]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12311420" key="com.atlassian.jira.plugin.system.customfieldtypes:version">
                        <customfieldname>Since Version</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue id="12353513">5.0-alpha1</customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313924" key="com.atlassian.jira.plugin.system.customfieldtypes:textfield">
                        <customfieldname>Source Control Link</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>&lt;p&gt;&lt;a href=&quot;https://github.com/apache/cassandra/commit/f7984627e7dd5794dabc099f49ecf80ca3631803&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/cassandra/commit/f7984627e7dd5794dabc099f49ecf80ca3631803&lt;/a&gt;&lt;/p&gt;</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12313823" key="com.atlassian.jira.plugin.system.customfieldtypes:textarea">
                        <customfieldname>Test and Documentation Plan</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>&lt;p&gt;New matrix of almost 200 tests that covers both RFP and the newly discovered consistency problems.&lt;/p&gt;</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                </customfields>
    </item>
</channel>
</rss>