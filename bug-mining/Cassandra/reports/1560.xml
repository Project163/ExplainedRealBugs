<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 22:31:20 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[CASSANDRA-4093] schema_* CFs do not respect column comparator which leads to CLI commands failure.</title>
                <link>https://issues.apache.org/jira/browse/CASSANDRA-4093</link>
                <project id="12310865" key="CASSANDRA">Apache Cassandra</project>
                    <description>&lt;p&gt;ColumnDefinition.&lt;/p&gt;
{ascii, utf8, bool, ...}
&lt;p&gt; static methods used to initialize schema_* CFs column_metadata do not respect CF comparator and use ByteBufferUtil.bytes(...) for column names which creates problems in CLI and probably in other places.&lt;/p&gt;

&lt;p&gt;The CompositeType validator throws exception on first column&lt;/p&gt;

&lt;p&gt;String columnName = columnNameValidator.getString(columnDef.name);&lt;/p&gt;

&lt;p&gt;Because it appears the composite type length header is wrong (25455)&lt;/p&gt;

&lt;p&gt;AbstractCompositeType.getWithShortLength&lt;/p&gt;

&lt;p&gt;java.lang.IllegalArgumentException&lt;br/&gt;
	at java.nio.Buffer.limit(Buffer.java:247)&lt;br/&gt;
	at org.apache.cassandra.db.marshal.AbstractCompositeType.getBytes(AbstractCompositeType.java:50)&lt;br/&gt;
	at org.apache.cassandra.db.marshal.AbstractCompositeType.getWithShortLength(AbstractCompositeType.java:59)&lt;br/&gt;
	at org.apache.cassandra.db.marshal.AbstractCompositeType.getString(AbstractCompositeType.java:139)&lt;br/&gt;
	at org.apache.cassandra.cli.CliClient.describeColumnFamily(CliClient.java:2046)&lt;br/&gt;
	at org.apache.cassandra.cli.CliClient.describeKeySpace(CliClient.java:1969)&lt;br/&gt;
	at org.apache.cassandra.cli.CliClient.executeShowKeySpaces(CliClient.java:1574)&lt;/p&gt;

&lt;p&gt;(seen in trunk)&lt;/p&gt;</description>
                <environment></environment>
        <key id="12548388">CASSANDRA-4093</key>
            <summary>schema_* CFs do not respect column comparator which leads to CLI commands failure.</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="10002" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.svg">Normal</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="slebresne">Sylvain Lebresne</assignee>
                                    <reporter username="dbrosius@apache.org">Dave Brosius</reporter>
                        <labels>
                    </labels>
                <created>Tue, 27 Mar 2012 20:59:27 +0000</created>
                <updated>Tue, 16 Apr 2019 09:32:36 +0000</updated>
                            <resolved>Mon, 9 Apr 2012 16:58:41 +0000</resolved>
                                        <fixVersion>1.1.0</fixVersion>
                                    <component>Legacy/Tools</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                                                                <comments>
                            <comment id="13239956" author="xedin" created="Tue, 27 Mar 2012 21:11:15 +0000"  >&lt;p&gt;Can you please provide a simple test-case for this problem? It doesn&apos;t seem to be CLI related but rather CompositeType related problem...&lt;/p&gt;</comment>
                            <comment id="13240057" author="dbrosius@apache.org" created="Tue, 27 Mar 2012 23:28:44 +0000"  >&lt;p&gt;I just created a brand new database directory, went into cli and did&lt;/p&gt;

&lt;p&gt;show keyspaces;&lt;/p&gt;

&lt;p&gt;the output finishes with this: Notice the trailing &apos;null&apos;. That is caused by the exception.&lt;/p&gt;

&lt;p&gt;    ColumnFamily: schema_columnfamilies&lt;br/&gt;
    &quot;ColumnFamily definitions&quot;&lt;br/&gt;
      Key Validation Class: org.apache.cassandra.db.marshal.AsciiType&lt;br/&gt;
      Default column value validator: org.apache.cassandra.db.marshal.BytesType&lt;br/&gt;
      Columns sorted by: org.apache.cassandra.db.marshal.CompositeType(org.apache.cassandra.db.marshal.AsciiType,org.apache.cassandra.db.marshal.AsciiType)&lt;br/&gt;
      GC grace seconds: 10368000&lt;br/&gt;
      Compaction min/max thresholds: 4/32&lt;br/&gt;
      Read repair chance: 0.0&lt;br/&gt;
      DC Local Read repair chance: 0.0&lt;br/&gt;
      Replicate on write: true&lt;br/&gt;
      Caching: KEYS_ONLY&lt;br/&gt;
      Bloom Filter FP chance: default&lt;br/&gt;
      Built indexes: []&lt;br/&gt;
      Column Metadata:&lt;br/&gt;
null&lt;/p&gt;

</comment>
                            <comment id="13240077" author="xedin" created="Wed, 28 Mar 2012 00:26:29 +0000"  >&lt;p&gt;patch makes changes to ColumnDefinition to make it CF comparator aware, CLI `show` and `describe` commands works just as expected but it breaks ColumnFamily related migrations with some weird NPE exceptions.&lt;/p&gt;</comment>
                            <comment id="13241495" author="jbellis" created="Thu, 29 Mar 2012 18:37:16 +0000"  >&lt;p&gt;Hmm, I&apos;m pretty sure that giving CFMetdata column names a composite type header is the wrong solution. I think instead we need to teach cliclient that when you have a composite type comparator, you need to look at column aliases as well as column names to form the composite in question.&lt;/p&gt;</comment>
                            <comment id="13241503" author="xedin" created="Thu, 29 Mar 2012 18:45:57 +0000"  >&lt;p&gt;I don&apos;t get it, if the column names in column_metadata were not serialized using given CF comparator shouldn&apos;t we fix that instead of changing CLI?&lt;/p&gt;</comment>
                            <comment id="13241509" author="jbellis" created="Thu, 29 Mar 2012 18:56:17 +0000"  >&lt;p&gt;No, because when you have column aliases the name in the metadata is a &quot;leaf&quot; name, it&apos;s not supposed to be a full composite name. In other words,&lt;/p&gt;

&lt;p&gt;composite name = (alias name, metadata name)&lt;/p&gt;</comment>
                            <comment id="13241516" author="slebresne" created="Thu, 29 Mar 2012 19:02:44 +0000"  >&lt;p&gt;So the problem is the following: for CQL3, we&apos;ve introduced the fact that when we have a composite comparator, the &apos;name&apos; of a ColumnDefinition refers to the last component of the composite comparator. In other words, one should use the last comparator of the composite comparator to parse the ColumnDefinition name, but the CLI doesn&apos;t know that. So we do need to fix the CLI.&lt;/p&gt;

&lt;p&gt;However, now that I think about this, I realize we may have been a little bit careless when doing that, because the current code basically &lt;b&gt;assumes&lt;/b&gt; that if you have a composite comparator, then ColumnDefinition refers to the last component of those. That may break compatibility for user using composite type today. I&apos;m not sure how many people use composite comparators &lt;b&gt;and&lt;/b&gt; have ColumnDefinition on them, but we probably shouldn&apos;t assume nobody does that.&lt;/p&gt;

&lt;p&gt;So I think to fix that we need to add a new information to ColumnDefinition, which if the comparator of the CF is a composite type, to which component the definition apply (or if it apply to the column name as a whole). Attached a patch that does just that. I&apos;ll note that while we could probably do with a boolean in that case (since currently we only have 2 cases: either the definition apply to the full column name or it applies to the last component), but the full generality of specifying which component exactly the definition apply to will likely be useful if we allow defining secondary index of other parts of the composite (&lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-3680&quot; title=&quot;Add Support for Composite Secondary Indexes&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-3680&quot;&gt;&lt;del&gt;CASSANDRA-3680&lt;/del&gt;&lt;/a&gt;). Note that the patch does fix the CLI following that change.&lt;/p&gt;</comment>
                            <comment id="13241527" author="jbellis" created="Thu, 29 Mar 2012 19:16:49 +0000"  >&lt;blockquote&gt;&lt;p&gt;I&apos;m not sure how many people use composite comparators and have ColumnDefinition on them, but we probably shouldn&apos;t assume nobody does that&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;given that you can&apos;t do that with the cli (as shown here) I think that&apos;s actually a pretty safe assumption.&lt;/p&gt;</comment>
                            <comment id="13241559" author="slebresne" created="Thu, 29 Mar 2012 19:40:06 +0000"  >&lt;blockquote&gt;&lt;p&gt;given that you can&apos;t do that with the cli&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes you can. What the cli doesn&apos;t support is the new-in-1.1 way of interpreting ColumnDefinition for CF having a composite comparator as refering to the last component. It is perfectly possible in pre-1.1 to have a composite comparator and declare a ColumnDefinition. What I&apos;m saying is that currently (i.e without the attached patch), 1.1 breaks compatibility with pre-1.1 for that use case, which is a bad thing.&lt;/p&gt;</comment>
                            <comment id="13241587" author="xedin" created="Thu, 29 Mar 2012 20:05:02 +0000"  >&lt;p&gt;I confirm that CLI works as expected with the patch but I&apos;m not sure that adding new option to the ColumnDef especially because users can simply ignore it without even given it a thought. Feels like we are adding complexity from pure air...&lt;/p&gt;</comment>
                            <comment id="13241786" author="jbellis" created="Thu, 29 Mar 2012 21:21:16 +0000"  >&lt;p&gt;I think we&apos;ll regret the precedent in trying to preserve all the arbitrarily complex things you could do with the old CFMetadata.  It really doesn&apos;t make sense to have a CompositeType as a column name.  Given that, and given that CFMetadata names under &amp;lt;= 1.0 were only useful for validation (and indexes, but we don&apos;t index CTs yet either), I&apos;d rather say &quot;we don&apos;t support that in 1.1+, and if you were doing that, drop the column definition before you upgrade.&quot;&lt;/p&gt;

&lt;p&gt;Optionally, we could auto-drop it for them and log a warning.&lt;/p&gt;</comment>
                            <comment id="13241913" author="xedin" created="Thu, 29 Mar 2012 23:19:40 +0000"  >&lt;p&gt;I like that more than adding &quot;component_index&quot; option which would be easily misconfigured and create a confusion. Right now we should change comparators of the schema_* CFs for that to work and add a check to the ThriftValidation and CQL validations to prevent users from setting CompositeType comparators to the new CFs along side with check when schema is converted to 1.1...&lt;/p&gt;</comment>
                            <comment id="13242144" author="slebresne" created="Fri, 30 Mar 2012 07:51:54 +0000"  >&lt;blockquote&gt;&lt;p&gt;but we don&apos;t index CTs yet either&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That&apos;s not true. We do support indexes on full CT currently (by the mere fact that CompositeType is a fully functional AbstractType). What we don&apos;t support (yet) is indexing on a specific component of a CT.&lt;/p&gt;

&lt;p&gt;Now, we agreed on &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-3782&quot; title=&quot;Secondary indexes support for wide rows in CQL 3.0&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-3782&quot;&gt;&lt;del&gt;CASSANDRA-3782&lt;/del&gt;&lt;/a&gt; that it could sometimes be usefull to index a specific column in a wide row as a way of &apos;tagging&apos; such wide rows (and there is probably other useful use cases). Why would that suddently stop making sense because the name is a composite one?&lt;/p&gt;

&lt;p&gt;So this is supported and this does have some reasonable use cases. As such, I &lt;b&gt;strongly&lt;/b&gt; think that it would be unreasonable to break it (and in that case, auto-dropping the index for people (or even forcing them to do it) would be the worst possible user experience ever). And I even think we should seriously give some though about maintaining that possibility (the ability to index on a full column name) even in CQL3 (which will likely be a simple and logical extension of &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-3792&quot; title=&quot;add type information to new schema_ columnfamilies&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-3792&quot;&gt;&lt;del&gt;CASSANDRA-3792&lt;/del&gt;&lt;/a&gt;).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;trying to preserve all the arbitrarily complex things you could do with the old CFMetadata&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I disagree that this is arbitrary complex. The patch adds the ability to specify for a ColumnDefinition to which component it refers to. If we want to support secondary indexes on specific component of a composite column (which I think is the goal of &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-3680&quot; title=&quot;Add Support for Composite Secondary Indexes&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-3680&quot;&gt;&lt;del&gt;CASSANDRA-3680&lt;/del&gt;&lt;/a&gt;), we&apos;ll have to add that exact information to ColumnDefinition anyway. So I think it&apos;s really adding new and useful flexibility.&lt;/p&gt;</comment>
                            <comment id="13242367" author="jbellis" created="Fri, 30 Mar 2012 14:17:56 +0000"  >&lt;blockquote&gt;&lt;p&gt;we agreed on &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-3782&quot; title=&quot;Secondary indexes support for wide rows in CQL 3.0&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-3782&quot;&gt;&lt;del&gt;CASSANDRA-3782&lt;/del&gt;&lt;/a&gt; that it could sometimes be usefull to index a specific column in a wide row as a way of &apos;tagging&apos; such wide rows &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;But you don&apos;t need to support indexing the CT column itself, to support that use case.  More consistent to have a &quot;tag&quot; sparse column and index that instead.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;really adding new and useful flexibility&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;New, yes; useful? dubious.&lt;/p&gt;

&lt;p&gt;We&apos;ve barely educated people on CQL3 wide rows as it is, now is not a good time to complicate things further.  Let&apos;s take an incremental approach and add such things in response to user demand, should it materialize, instead of adding features &quot;because we can.&quot;&lt;/p&gt;</comment>
                            <comment id="13242388" author="slebresne" created="Fri, 30 Mar 2012 14:40:58 +0000"  >&lt;blockquote&gt;&lt;p&gt;But you don&apos;t need to support indexing the CT column itself, to support that use case. More consistent to have a &quot;tag&quot; sparse column and index that instead.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;But my concern is for backward compatibility. Currently (with 0.8-1.0), you &lt;b&gt;cannot&lt;/b&gt; support this with a tag sparse column that you index because we &lt;b&gt;don&apos;t&lt;/b&gt; support indexing on a component of a CT (even 1.1 doesn&apos;t support it yet). I&apos;m not talking of adding some new possibility that may or may not be useful. I&apos;m saying that if someone is indexing on the CT column itself, which again is currently the &lt;b&gt;only&lt;/b&gt; solution and btw wcan be done with pure thrift that we have swear not to break, then we&apos;ll completely break these users application (and as if that wasn&apos;t bad enough, they won&apos;t even have a correct replacement at the moment).&lt;/p&gt;</comment>
                            <comment id="13242467" author="jbellis" created="Fri, 30 Mar 2012 15:50:19 +0000"  >&lt;p&gt;The thing about backwards-compatibility hacks is you tend to get stuck with them.  I&apos;m okay with any of these alternatives:&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;Add a big huge warning to NEWS that this corner case is not supported to 1.1, but an alternative solution for &quot;tagging&quot; will be supported eventually.  Fail 1.1 startup if such a schema startup is detected and explain the new limitation&lt;/li&gt;
	&lt;li&gt;Wait until we actually have indexes on composite PKs supported to release 1.1&lt;/li&gt;
	&lt;li&gt;Ask users@ if anyone actually has such a use case in production, and go with 1 or 2 based on the responses&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;Here is why I&apos;m willing to go scorched earth on this:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Schema design is &lt;b&gt;the&lt;/b&gt; most difficult thing to explain to new Cassandra users. We&apos;ve made &lt;b&gt;huge&lt;/b&gt; strides towards simplifying this in CQL3 and composite PKs. I don&apos;t think we can afford to dilute this with footnotes about how you can escape hatch back to the old world, dragging in all our old legacy baggage again. Put another way: it&apos;s time to bury &quot;wtf is a supercolumn&quot; once and for all.&lt;/li&gt;
	&lt;li&gt;Of our hundreds of deployments of 0.8 and 1.0, I can live with one or two needing to wait for 1.1.2 or whatever to upgrade.  We have a pretty good feel at this point for commonly used features and this isn&apos;t one of those.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;TLDR: backwards compatibility in this specific case is high cost, low benefit.&lt;/p&gt;</comment>
                            <comment id="13242539" author="slebresne" created="Fri, 30 Mar 2012 16:59:03 +0000"  >&lt;blockquote&gt;&lt;p&gt;The thing about backwards-compatibility hacks is you tend to get stuck with them.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I suppose it depends of ones own definition of a hack, but I really don&apos;t consider this patch as a hack. As soon as we consider CT to be first class citizen, adding the ability to specify to which component a ColumnDefinition applies (which is all the patch does) feels like a rather natural extension to me. And as said, if we decide to allow secondary indexes on any component of a CT, which I though was something we wanted ultimately, we&apos;ll have to add that componentIndex information. So breaking compatibility to avoid adding a simple info to ColumnDefinition that we&apos;ll very likely end up adding anyway later feels like the wrong choice to me.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;We&apos;ve made huge strides towards simplifying this in CQL3 and composite PKs. I don&apos;t think we can afford to dilute this with footnotes about how you can escape hatch back to the old world&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I don&apos;t understand. As of the attached patch, there is 0 footnotes to add to CQL3. Currently it&apos;s pretty much &lt;b&gt;exclusively&lt;/b&gt; a thrift backward-compatibility patch. If you&apos;re referring to me saying that we could later consider allowing index on a full composite in CQL3, then I&apos;m sorry, let&apos;s forget about that for now. This patch does not force us at all to do that.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;dragging in all our old legacy baggage again. Put another way: it&apos;s time to bury &quot;wtf is a supercolumn&quot; once and for all.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I don&apos;t understand what you&apos;re referring to. Again, what this patch does is recognizing that CT are now first class citizen and thus that it makes sense that a ColumnDefinition may refer to any of the component. And while it is true that we don&apos;t &lt;b&gt;yet&lt;/b&gt; use that generalization, it &lt;b&gt;trivially&lt;/b&gt; allows us to support backward compatibility for thrift, hence the idea of doing that generalization now. I don&apos;t see where this patch drag &lt;b&gt;any&lt;/b&gt; old legacy baggage so I&apos;d love to get more precision on what you&apos;re referring to exactly. &lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Of our hundreds of deployments of 0.8 and 1.0, I can live with one or two needing to wait for 1.1.2 or whatever to upgrade.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;But that is &lt;b&gt;not&lt;/b&gt; what will happen. Anyone that use an index on a CT currently won&apos;t be able to upgrade &lt;b&gt;ever&lt;/b&gt;. Because their index will just be not be supported anymore. If they upgrade, C* will crash. Seriously, they will be completely screwed. Their only option will be some complex manual data model migration which will be impossible to do without any downtime for the application (since no version will both support their existing index &lt;b&gt;and&lt;/b&gt; the new possibly-introduced-in-1.2 indexing of the the last component of a CT).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;TLDR: backwards compatibility in this specific case is high cost, low benefit.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I couldn&apos;t disagree more. I still don&apos;t see what this high cost is. I wrote the patch and I just don&apos;t see at all the high cost. The patch is fairly trivial (it&apos;s not small in size but for a good part because it include thrift generated code) and has barely any user side visibility. More precisely, the only visibility it has is on the thrift side, and even then it&apos;s an optional field whose default is the right one for the thrift side. On the other side, the benefit is huge imo because it means we don&apos;t screw up the people that use C* in original ways.&lt;/p&gt;</comment>
                            <comment id="13242576" author="dbrosius@apache.org" created="Fri, 30 Mar 2012 17:35:10 +0000"  >&lt;p&gt;&amp;gt;&amp;gt; Ask users@ if anyone actually has such a use case in production, and go with 1 or 2 based on the responses&lt;/p&gt;

&lt;p&gt;This makes sense to me... it&apos;s possible that this isn&apos;t really an issue.&lt;/p&gt;</comment>
                            <comment id="13242835" author="xedin" created="Fri, 30 Mar 2012 23:07:42 +0000"  >&lt;p&gt;Would users be required to manually set &quot;component_index&quot; at every metadata column they have after update to 1.1 or to rephrase that - when users are going to be &lt;b&gt;required&lt;/b&gt; to set &quot;composite_index&quot; field?&lt;/p&gt;</comment>
                            <comment id="13243120" author="slebresne" created="Sat, 31 Mar 2012 12:07:27 +0000"  >&lt;blockquote&gt;&lt;p&gt;Meaning there will be C* versions which support both?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Only if 1) they use thrift and 2) they ever want to define a ColumnDef that apply to one of the component of a CT. Currently, 2) doesn&apos;t have any interest on the thrift side, except maybe as a preparation if you&apos;re going to switch to cql3.&lt;/p&gt;

&lt;p&gt;In other word, you will never be &lt;b&gt;required&lt;/b&gt; to set the field. &lt;/p&gt;</comment>
                            <comment id="13243139" author="xedin" created="Sat, 31 Mar 2012 13:23:48 +0000"  >&lt;p&gt;If users are never required to set it for everything to work, what is the benefit of adding new field at the first place? &lt;/p&gt;</comment>
                            <comment id="13243146" author="slebresne" created="Sat, 31 Mar 2012 13:47:26 +0000"  >&lt;p&gt;Because the system CFs are using CQL3 style metadata so that we can display them nicely when queried with CQL3. So typically the CLI (or anyone else) needs that info to be able to correctly decode and display the system table definitions.&lt;/p&gt;

&lt;p&gt;Besides, when we add the ability to index the components of a CT, the fact that component_index is exposed through thrift means that the thrift user will be able to use that new functionality, which while probably not a priori is still nice.&lt;/p&gt;

&lt;p&gt;Lastly, the field is useful internally in ColumnDefinition so not adding it to ColumnDef (to say avoid confusing thrift user) would imo be a bit dangerous (it would make using both thrift and CQL3 at the same time difficult, which may be useful for people transitioning to CQL3). Overall I really don&apos;t think adding the new field is such a big deal. It is true that is is currently mildly useful for pure thrift user, but it&apos;s not like it&apos;s something new. All the aliases (key_alias, column_aliases, value_alias) are only useful to CQL3 but yet have been added on the thrift side. This is not really different.&lt;/p&gt;</comment>
                            <comment id="13243161" author="xedin" created="Sat, 31 Mar 2012 14:17:13 +0000"  >&lt;p&gt;Sounds like it wasn&apos;t a good time to make schema_* CFs to use CQL3 style metadata which breaks all other parties and causes half-hacky field (dispute the fact that it is not even useful yet) to be added to the thrift structure just to support correct data display even if that is ambiguous for users how/when to correctly use it...&lt;/p&gt;</comment>
                            <comment id="13243167" author="jbellis" created="Sat, 31 Mar 2012 14:30:10 +0000"  >&lt;blockquote&gt;&lt;p&gt;Sounds like it wasn&apos;t a good time to make schema_* CFs to use CQL3 style metadata &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;m still convinced that part is worth it to be able to query schema information without thrift describe_ methods.&lt;/p&gt;</comment>
                            <comment id="13243169" author="xedin" created="Sat, 31 Mar 2012 14:32:51 +0000"  >&lt;blockquote&gt;&lt;p&gt;I&apos;m still convinced that part is worth it to be able to query schema information without thrift describe_ methods.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Ok but it&apos;s only useful with CQL3 because all others wouldn&apos;t be able to query that correctly like CLI because of the way column metadata is stored right now.&lt;/p&gt;</comment>
                            <comment id="13243171" author="jbellis" created="Sat, 31 Mar 2012 14:33:58 +0000"  >&lt;blockquote&gt;&lt;p&gt;the field is useful internally in ColumnDefinition so not adding it to ColumnDef (to say avoid confusing thrift user) would imo be a bit dangerous &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Here&apos;s what I don&apos;t get.  We&apos;re adding this to support backwards compatibility, and yet we need to change the interface to do it?  Clearly a 0.8 or 1.0 client isn&apos;t going to be aware of this new field.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;All the aliases (key_alias, column_aliases, value_alias) are only useful to CQL3 but yet have been added on the thrift side&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Because we added those before we had cqlsh, so the cli was the only way to configure them.  In retrospect, not a great idea.&lt;/p&gt;</comment>
                            <comment id="13243173" author="jbellis" created="Sat, 31 Mar 2012 14:35:19 +0000"  >&lt;blockquote&gt;&lt;p&gt;Ok but it&apos;s only useful with CQL3 because all others wouldn&apos;t be able to query that correctly like CLI because of the way column metadata is stored right now.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Granted, which is why we need to make the cli aware of column aliases.&lt;/p&gt;</comment>
                            <comment id="13243177" author="xedin" created="Sat, 31 Mar 2012 14:43:35 +0000"  >&lt;blockquote&gt;&lt;p&gt;Granted, which is why we need to make the cli aware of column aliases.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The problem with that it&apos;s not only about CLI it is also about all other possible clients too because users expect comparator to be able to &lt;/p&gt;
{de-}
&lt;p&gt;serialize column names correctly. So we should make it very clear how to work with this type of situation without making any special cases (e.g. for CT).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Because we added those before we had cqlsh, so the cli was the only way to configure them. In retrospect, not a great idea.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I also don&apos;t think that having aliases in Thrift really justifies this situation.&lt;/p&gt;</comment>
                            <comment id="13243179" author="jbellis" created="Sat, 31 Mar 2012 14:52:42 +0000"  >&lt;blockquote&gt;&lt;p&gt;If you&apos;re referring to me saying that we could later consider allowing index on a full composite in CQL3, then I&apos;m sorry, let&apos;s forget about that for now. This patch does not force us at all to do that.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;My problem is that by supporting this misfeature from thrift in the name of backwards compatibility, we&apos;re only pushing the problem into the future: the next step is for someone to say, &quot;you support this in Thrift, so I should be able to do it in CQL too.&quot;  I&apos;d rather just draw a line and say, &quot;allowing this was a bad idea and we don&apos;t support it anymore.&quot;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;while it is true that we don&apos;t yet use that generalization&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;My point is that I&apos;m pretty sure this is a generalization I don&apos;t want to support at all.  This is a case where exposing every detail of your storage engine is a bad idea.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Anyone that use an index on a CT currently won&apos;t be able to upgrade ever&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The upgrade path requires some effort but is conceptually simple:&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;update your application to no longer use the CT column index&lt;/li&gt;
	&lt;li&gt;upgrade&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;(If you respond that updating your application is not acceptable, then why are you bothering to upgrade?  Stay on the stable version that you built against in the first place, there is nothing wrong with that.)&lt;/p&gt;

&lt;p&gt;My claim is that inflicting this on a small handful of users (possibly as small as zero, and I would bet money not more than one) is worth the upside of getting to a clean data model in 1.2 without the distractions of legacy features like this.  The danger is that the longer we preserve features like this, the more potential there is for new users to start using them which makes it more difficult for us to drop them later.  So I&apos;d rather make a clean break now, than drag it out.&lt;/p&gt;

&lt;p&gt;That said, if you are fundamentally opposed to not dropping any feature no matter how obscure without some warning, which I admit is at least a consistent position, I would be okay with supporting this in 1.1 with a clear intention to drop it in 1.2.  (Which would imply to me that we leave the thrift interface alone.)  This would give us a full release to make sure we have alternatives to whatever use cases people may have for the CT index (e.g. indexing the sparse columns for the tag scenario).&lt;/p&gt;</comment>
                            <comment id="13243183" author="jbellis" created="Sat, 31 Mar 2012 15:06:36 +0000"  >&lt;blockquote&gt;&lt;p&gt;The problem with that it&apos;s not only about CLI it is also about all other possible clients too because users expect comparator to be able to {de-}serialize column names correctly&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;But this is only a problem if you&apos;re trying to show the schema for the System keyspace.  (Presumably if you&apos;re using column aliases in your own CFs, you&apos;re using a sufficiently up to date client already.)&lt;/p&gt;

&lt;p&gt;I&apos;m willing to accept that &quot;to introspect the system keyspace, you need to be using a 1.1-aware cli.&quot;&lt;/p&gt;</comment>
                            <comment id="13243189" author="xedin" created="Sat, 31 Mar 2012 15:13:49 +0000"  >&lt;p&gt;Would that assumption still hold when users are going to start creating CFs using CQL3?&lt;/p&gt;</comment>
                            <comment id="13243196" author="jbellis" created="Sat, 31 Mar 2012 15:42:35 +0000"  >&lt;p&gt;&quot;Presumably if you&apos;re using column aliases in your own CFs, you&apos;re using a sufficiently up to date client already.&quot;&lt;/p&gt;

&lt;p&gt;In other words, your upgrade path is&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;upgrade C* to 1.1&lt;/li&gt;
	&lt;li&gt;upgrade cli to 1.1&lt;/li&gt;
	&lt;li&gt;start creating CQL3 CFs&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;In particular, 3 doesn&apos;t work before 1, at which point 2 is trivial.&lt;/p&gt;</comment>
                            <comment id="13243200" author="xedin" created="Sat, 31 Mar 2012 15:53:01 +0000"  >&lt;p&gt;I&apos;m fine fixing it just for CLI then.&lt;/p&gt;</comment>
                            <comment id="13243242" author="slebresne" created="Sat, 31 Mar 2012 17:41:23 +0000"  >&lt;p&gt;Wow, that seems to get so out of proportion and I so don&apos;t understand why.&lt;/p&gt;

&lt;p&gt;What happpened is this: currently (i.e. in all released version), a ColumnDefinition name refers to the CF column name, i.e. one must use the column comparator to decode it. In all currently released version, CompositeType is a normal comparator and that rule applies to it, and for anyone that will use thrift in 1.1+, for all intent and purposes CompositeType will still be a normal comparator like all the other ones and so the natural thing will still be that the ColumDefinition name applies to CT comparator entirely.&lt;/p&gt;

&lt;p&gt;Now when I wrote the CQL3 patch (the initial one), I realised that we needed a new feature, the need to be able to have ColumnDefinitions whose name refers to only one of the component of the CT comparator. And while  we currently only need to refer to the last component (because we don&apos;t yet support secondary indexes on CT), we &lt;b&gt;will&lt;/b&gt; need to have ColumnDefinition whose name refer to &lt;b&gt;any&lt;/b&gt; of the CT components as soon as we support secondary indexes on CT (&lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-3680&quot; title=&quot;Add Support for Composite Secondary Indexes&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-3680&quot;&gt;&lt;del&gt;CASSANDRA-3680&lt;/del&gt;&lt;/a&gt;). In other words, the introduction of composite_index (this patch) is just the first part &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-3680&quot; title=&quot;Add Support for Composite Secondary Indexes&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-3680&quot;&gt;&lt;del&gt;CASSANDRA-3680&lt;/del&gt;&lt;/a&gt;. We &lt;b&gt;will&lt;/b&gt; have to add it soon enough. It is &lt;b&gt;hardly&lt;/b&gt; something added &lt;b&gt;just&lt;/b&gt; for backward compatibility.&lt;/p&gt;

&lt;p&gt;Anyway while I was writting the CQL3 patch, instead of properly handling that new case, I introduced a &lt;b&gt;bug&lt;/b&gt; consisting of changing the behavior of ColumnDefinition for CT so that by default they refer to the last component of the CT, not the comparator itself anymore. I.e. I changed the default behavior to an incompatible one.  I&apos;m sorry I did that, I shouldn&apos;t have and the goal of that patch is to restore the default behavior and introduce a new info to ColumnDefinition to allow switching to the new behavior. Again, I think it is incorrect to say that this patch is just &apos;in the name of backward compatibility&apos;. If I had mistakefully changed the subcolumn comparator of super column to apply to column names instead of super columns names, we wouldn&apos;t call fixing that &apos;supporting a misfeature in the name of backward compatibilty&apos;. But yes, this bug happens to break backward compatibility and I do have a big problem with that part.&lt;/p&gt;

&lt;p&gt;On the thrift side. Yes this does add a new field to ColumnDef. But:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;It&apos;s untrue that column_aliases and value_alias were &apos;added before we had cqlsh&apos;. They would be added in the exact same version as this patch, so I think that using that argument against component_index is unfair.&lt;/li&gt;
	&lt;li&gt;I&apos;m not sure this will be so very confusing to users. Again, for thrift users, CT is a comparator like any other. The confusing thing would be for a ColumnDef to apply to the last component rather than the full CT. Why would CT be suddenly special (again, on the thrift side) and why the last component? It would random and thus confusing. On the contrary, if you have component_index, then you can say that the default is the one you&apos;d expect, i.e the one that apply to all other comparator, but that we&apos;ve added the new ability to make ColumnDef apply to other component.&lt;/li&gt;
	&lt;li&gt;As soon as &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-3680&quot; title=&quot;Add Support for Composite Secondary Indexes&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-3680&quot;&gt;&lt;del&gt;CASSANDRA-3680&lt;/del&gt;&lt;/a&gt; is done, it will be usefull to allow creating secondary indexes on CT component on the thrift side. Why wouldn&apos;t we allow &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-3680&quot; title=&quot;Add Support for Composite Secondary Indexes&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-3680&quot;&gt;&lt;del&gt;CASSANDRA-3680&lt;/del&gt;&lt;/a&gt; on the thrift if it only cost us the addition of a simple int field in ColumnDef?&lt;/li&gt;
&lt;/ol&gt;


&lt;blockquote&gt;
&lt;p&gt;The upgrade path requires some effort but is conceptually simple:&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;update your application to no longer use the CT column index&lt;/li&gt;
	&lt;li&gt;upgrade&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;My problem is that step 1 will be &lt;b&gt;super&lt;/b&gt; painfull. Because before upgrading, you don&apos;t have any reasonable alternative for whatever you were doing with the CT column index (tagging rows for instance). So you have to write manual code to do the same manual indexing. And then you have to write a map reduce job to reconstruct this new manual index for existing rows. In real life situations where you must do that without downtime, it&apos;s a pain in the ass.&lt;/p&gt;

&lt;p&gt;And yes I know, you don&apos;t believe anyone uses that. But I have the weakness to think that we do not know what everyone user is doing. And yes, I have a &lt;b&gt;big&lt;/b&gt; problem with screwing up even 1 user (especially after we&apos;ve said we were serious about not breaking the thrift API). And yes, even if that force us to write a little bit more code now and/or later.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;is worth the upside of getting to a clean data model in 1.2 without the distractions of legacy features like this. The danger is that the longer we preserve features like this, the more potential there is for new users to start using them which makes it more difficult for us to drop them later&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Ok, I understand the argument in principle but in practice what is it we&apos;re talking about?  There is 0 line of specific code to support index on a full CT column name, this is all handled by the current secondary index code transparently.  So worst case scenario, more people use the feature (which btw would suggest it&apos;s vaguely useful). But then adding support in CQL3 would be fairly trivial. The only thing we&apos;d have to add is way to declare those index (again the rest is already handled by generic code), and that would likely be a nature extension of whatever we come up for &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-3782&quot; title=&quot;Secondary indexes support for wide rows in CQL 3.0&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-3782&quot;&gt;&lt;del&gt;CASSANDRA-3782&lt;/del&gt;&lt;/a&gt;. Typically, to reuse one of the proposed syntax on that issue, on top of supporting:&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;CREATE INDEX index_name ON timeline(0);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;we would have to also add support for&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;CREATE INDEX index_name ON timeline(0, &apos;foobar&apos;, 4);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Again, this is hardly making the data mode in 1.2 dirty. Actually I&apos;m not even sure I understand in what way that would hinder the compression of the data model one bit. And again, we don&apos;t &lt;b&gt;have&lt;/b&gt; to support it if we don&apos;t want to. But at least, instead of forcing a painful upgrade on those that were using index on full CT from thrift when &lt;b&gt;we&lt;/b&gt; decide, they would have the option to stay with thrift until they are ready to make the migration ().&lt;/p&gt;

&lt;p&gt;Overall, I completely disagree that this patch will force anything on us in the future and I just don&apos;t see where it make the data model for 1.2 less clean.  I also strongly think we should be more considerate about breaking use cases that people may be using, even if we&apos;re talking very few people.&lt;/p&gt;</comment>
                            <comment id="13247578" author="jbellis" created="Thu, 5 Apr 2012 19:50:54 +0000"  >&lt;blockquote&gt;&lt;p&gt;I&apos;m not sure this will be so very confusing to users.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;What I&apos;m worried about is that it forces us to distinguish between &quot;logical&quot; and &quot;physical&quot; columns again.  I &lt;b&gt;love&lt;/b&gt; that with CQL3 all I have to talk about is CQL columns and not have to dig out my diagrams of mapping CT to logical columns until someone starts to actually dig into the engine code.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;the introduction of composite_index (this patch) is just the first part &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-3680&quot; title=&quot;Add Support for Composite Secondary Indexes&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-3680&quot;&gt;&lt;del&gt;CASSANDRA-3680&lt;/del&gt;&lt;/a&gt;. We will have to add it soon enough. It is hardly something added just for backward compatibility.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I don&apos;t follow at all.  3680 just means we want to be able to create an index on a logical column that is part of a CT under the hood: i.e., exactly the same thing we can already represent with the current-as-of-today CFMetadata.&lt;/p&gt;

&lt;p&gt;I have virtually zero interest in supporting partial indexes as discussed in 3782; RDBMSes have shown pretty conclusively that this is a very niche feature.  Very much in the category of &quot;let&apos;s take our time and add it if it makes sense, not just because we know how to do it.&quot;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;It&apos;s untrue that column_aliases and value_alias were &apos;added before we had cqlsh&apos;. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;You left out key_alias, which is what I was referring to having added in 0.8 well before we had cqlsh.  I can only guess that we added column_aliases and value_aliases to thrift as well for the sake of consistency with that precedent.  As you point out, though, it&apos;s not too late to rip those out and we probably should.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;As soon as &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-3680&quot; title=&quot;Add Support for Composite Secondary Indexes&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-3680&quot;&gt;&lt;del&gt;CASSANDRA-3680&lt;/del&gt;&lt;/a&gt; is done, it will be usefull to allow creating secondary indexes on CT component on the thrift side. Why wouldn&apos;t we allow &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-3680&quot; title=&quot;Add Support for Composite Secondary Indexes&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-3680&quot;&gt;&lt;del&gt;CASSANDRA-3680&lt;/del&gt;&lt;/a&gt; on the thrift if it only cost us the addition of a simple int field in ColumnDef?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Sounds like you&apos;re getting a little ahead of yourself.  Why not add it as part of 3680, should that be something we want to do?  (But as I described above, I don&apos;t think it is.)&lt;/p&gt;</comment>
                            <comment id="13247591" author="jbellis" created="Thu, 5 Apr 2012 20:00:11 +0000"  >&lt;blockquote&gt;&lt;p&gt;What I&apos;m worried about is that it forces us to distinguish between &quot;logical&quot; and &quot;physical&quot; columns again. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That said, you&apos;re probably right that for CQL users this is an implementation detail that they won&apos;t care about.  And Thrift users can carry on with CT definitions to the degree they have or haven&apos;t previously, I suppose.&lt;/p&gt;

&lt;p&gt;But, that doesn&apos;t mean we should gratuitously blur the lines between the two.&lt;/p&gt;

&lt;p&gt;So here is what I propose:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Change ColumnDefinition back to its old behavior.  I guess we&apos;ll need to add the int to allow us to support CQL3 internally, but we don&apos;t need to expose it to thrift yet, if at all.  (Alternatively we could add a cql_column_metadata that supports the new semantics.)&lt;/li&gt;
	&lt;li&gt;Remove column_aliases and value_aliases from Thrift.  They serve no purpose there than to give users a gun with which to shoot themselves in the foot.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="13248393" author="slebresne" created="Fri, 6 Apr 2012 14:31:02 +0000"  >&lt;blockquote&gt;&lt;p&gt;I don&apos;t follow at all. 3680 just means we want to be able to create an index on a logical column that is part of a CT under the hood&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Hum, I though that parts of &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-3680&quot; title=&quot;Add Support for Composite Secondary Indexes&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-3680&quot;&gt;&lt;del&gt;CASSANDRA-3680&lt;/del&gt;&lt;/a&gt; was that say you have&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;CREATE TABLE t (
  rk text,
  k1 text,
  k2 text,
  c1 text,
  c2 text,
  PRIMARY KEY (rk, k1, k2)
);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;then we could allow defining something like:&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;CREATE INDEX ON t(k1);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;(or the same with k2).&lt;/p&gt;

&lt;p&gt;Now truth is I haven&apos;t given a tons of though to this and if that is what you call partial indexes (it&apos;s not exactly the same than &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-3782&quot; title=&quot;Secondary indexes support for wide rows in CQL 3.0&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-3782&quot;&gt;&lt;del&gt;CASSANDRA-3782&lt;/del&gt;&lt;/a&gt;), then maybe it does have little convincing use cases. In which case, fair enough.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;for CQL users this is an implementation detail that they won&apos;t care about. And Thrift users can carry on with CT definitions to the degree they have or haven&apos;t previously&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That&apos;s exactly what I meant &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Alternatively we could add a cql_column_metadata that supports the new semantics&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Not necessarily against the idea but it feels like the integer makes for less special casing internally.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Remove column_aliases and value_aliases from Thrift. They serve no purpose there than to give users a gun with which to shoot themselves in the foot&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;m good with that. There may just be 2 things to be careful with when doing that:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;we probably cannot assume just yet that no user will do a mix of access through thrift and through CQL. We must make sure one doesn&apos;t destroy the CQL metadata while doing a simple column family update from thrift. Shouldn&apos;t be too hard to do though.&lt;/li&gt;
	&lt;li&gt;exposing everything through thrift have the slight advantage that a use may say set a column alias to allow transitioning to CQL3. There is likely better way to probide that though.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Anyway, I&apos;ll update the patch so that it doesn&apos;t expose those and component_index through thrift, and to not return ColumnDefinition when component_index is not null through thrift (so that the cli don&apos;t get confused).&lt;/p&gt;</comment>
                            <comment id="13248399" author="jbellis" created="Fri, 6 Apr 2012 14:43:57 +0000"  >&lt;blockquote&gt;&lt;p&gt;we could allow defining something like &lt;tt&gt;create index on t(k1)&lt;/tt&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Ah, right.  Yes, I suppose there&apos;s no reason not to expose that to Thrift as well.&lt;/p&gt;</comment>
                            <comment id="13248463" author="slebresne" created="Fri, 6 Apr 2012 16:15:01 +0000"  >&lt;p&gt;Attaching 4093_v2. Internally, this is roughtly the same as the previous patch (using componentIndex). However, this patch doesn&apos;t not expose it through thrift and remove column_aliases and value_alias (from thrift) too.&lt;/p&gt;

&lt;p&gt;Note that it completely skip ColumnDefinition whose componentIndex is not null (i.e those created by CQL3) when translating to thrift, which fixes the CLI problem (basically the CLI don&apos;t get back the parts he don&apos;t know how to interpret).&lt;/p&gt;

&lt;p&gt;An additional change is that CFMetaData.apply() make sure that a thrift update won&apos;t wrongfully remove CQL3 only metadata (ie. columnAliases, valueAliases and ColumnDefinition with a non-null componentIndex). In other words, it&apos;s safe to create a column family through CQL3 and later update it with the cli (to avoid foot shooting for those that would be in the middle of transitioning to CQL3 for instance).&lt;/p&gt;

&lt;p&gt;The only small detail is that we &lt;b&gt;need&lt;/b&gt; to backport &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-4037&quot; title=&quot;Move CfDef and KsDef validation to CFMetaData and KSMetaData&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-4037&quot;&gt;&lt;del&gt;CASSANDRA-4037&lt;/del&gt;&lt;/a&gt; to 1.1.0 for this to work (since currently CQL do a toThrift(fromThrift()) dance for schema update (in order to use ThriftValidation)).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Yes, I suppose there&apos;s no reason not to expose that to Thrift as well.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;m actually happy with the idea of v2 of not exposing to thrift what&apos;s not usefull right now. I guess we can go with v2 and expose componentIndex later when it makes sense on the thrift.&lt;/p&gt;</comment>
                            <comment id="13248615" author="jbellis" created="Fri, 6 Apr 2012 19:10:22 +0000"  >&lt;blockquote&gt;&lt;p&gt;I guess we can go with v2 and expose componentIndex later when it makes sense on the thrift.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That&apos;s what I had in mind.&lt;/p&gt;

&lt;p&gt;We should keep dclocal_r_r as parameter 37 in the thrift idl to make it compatible w/ beta clients.&lt;br/&gt;
Otherwsise, +1 on v2 and backport of 4037.&lt;/p&gt;</comment>
                            <comment id="13249964" author="slebresne" created="Mon, 9 Apr 2012 16:58:41 +0000"  >&lt;p&gt;Backported &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-4037&quot; title=&quot;Move CfDef and KsDef validation to CFMetaData and KSMetaData&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-4037&quot;&gt;&lt;del&gt;CASSANDRA-4037&lt;/del&gt;&lt;/a&gt; and committed v2 (with dc_local_rr back at 37). Thanks.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12520482" name="4093.txt" size="54597" author="slebresne" created="Thu, 29 Mar 2012 19:02:44 +0000"/>
                            <attachment id="12521691" name="4093_v2.txt" size="38620" author="slebresne" created="Fri, 6 Apr 2012 16:15:01 +0000"/>
                            <attachment id="12520216" name="CASSANDRA-4093-CD-changes.patch" size="11160" author="xedin" created="Wed, 28 Mar 2012 00:26:29 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>3.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12313920" key="com.atlassian.jira.plugin.system.customfieldtypes:multiuserpicker">
                        <customfieldname>Authors</customfieldname>
                        <customfieldvalues>
                                    <customfieldvalue><![CDATA[slebresne]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>233485</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            13 years, 33 weeks, 1 day ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i0grvz:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>95948</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_10022" key="com.atlassian.jira.plugin.system.customfieldtypes:userpicker">
                        <customfieldname>Reviewer</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>jbellis</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12313420" key="com.atlassian.jira.plugin.system.customfieldtypes:multiuserpicker">
                        <customfieldname>Reviewers</customfieldname>
                        <customfieldvalues>
                                    <customfieldvalue><![CDATA[jbellis]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12313820" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Severity</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="12962"><![CDATA[Normal]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>