<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 23:18:20 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[CASSANDRA-12126] CAS Reads Inconsistencies </title>
                <link>https://issues.apache.org/jira/browse/CASSANDRA-12126</link>
                <project id="12310865" key="CASSANDRA">Apache Cassandra</project>
                    <description>&lt;p&gt;While looking at the CAS code in Cassandra, I found a potential issue with CAS Reads. Here is how it can happen with RF=3&lt;/p&gt;

&lt;p&gt;1) You issue a CAS Write and it fails in the propose phase. A machine replies true to a propose and saves the commit in accepted filed. The other two machines B and C does not get to the accept phase. &lt;/p&gt;

&lt;p&gt;Current state is that machine A has this commit in paxos table as accepted but not committed and B and C does not. &lt;/p&gt;

&lt;p&gt;2) Issue a CAS Read and it goes to only B and C. You wont be able to read the value written in step 1. This step is as if nothing is inflight. &lt;/p&gt;

&lt;p&gt;3) Issue another CAS Read and it goes to A and B. Now we will discover that there is something inflight from A and will propose and commit it with the current ballot. Now we can read the value written in step 1 as part of this CAS read.&lt;/p&gt;

&lt;p&gt;If we skip step 3 and instead run step 4, we will never learn about value written in step 1. &lt;/p&gt;

&lt;p&gt;4. Issue a CAS Write and it involves only B and C. This will succeed and commit a different value than step 1. Step 1 value will never be seen again and was never seen before. &lt;/p&gt;



&lt;p&gt;If you read the Lamport &#8220;paxos made simple&#8221; paper and read section 2.3. It talks about this issue which is how learners can find out if majority of the acceptors have accepted the proposal. &lt;/p&gt;

&lt;p&gt;In step 3, it is correct that we propose the value again since we dont know if it was accepted by majority of acceptors. When we ask majority of acceptors, and more than one acceptors but not majority has something in flight, we have no way of knowing if it is accepted by majority of acceptors. So this behavior is correct. &lt;/p&gt;

&lt;p&gt;However we need to fix step 2, since it caused reads to not be linearizable with respect to writes and other reads. In this case, we know that majority of acceptors have no inflight commit which means we have majority that nothing was accepted by majority. I think we should run a propose step here with empty commit and that will cause write written in step 1 to not be visible ever after. &lt;/p&gt;

&lt;p&gt;With this fix, we will either see data written in step 1 on next serial read or will never see it which is what we want. &lt;/p&gt;</description>
                <environment></environment>
        <key id="12986267">CASSANDRA-12126</key>
            <summary>CAS Reads Inconsistencies </summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="10002" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.svg">Normal</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="slebresne">Sylvain Lebresne</assignee>
                                    <reporter username="kohlisankalp">Sankalp Kohli</reporter>
                        <labels>
                            <label>LWT</label>
                            <label>pull-request-available</label>
                    </labels>
                <created>Fri, 1 Jul 2016 17:46:09 +0000</created>
                <updated>Tue, 14 Oct 2025 12:13:56 +0000</updated>
                            <resolved>Fri, 27 Nov 2020 16:18:29 +0000</resolved>
                                        <fixVersion>3.0.24</fixVersion>
                    <fixVersion>3.11.10</fixVersion>
                    <fixVersion>4.0-beta4</fixVersion>
                    <fixVersion>4.0</fixVersion>
                                    <component>Feature/Lightweight Transactions</component>
                    <component>Legacy/Coordination</component>
                        <due></due>
                            <votes>1</votes>
                                    <watches>28</watches>
                                                    <progress percentage="100">
                                    <originalProgress>
                                                    <row percentage="0" backgroundColor="#89afd7"/>
                                                    <row percentage="100" backgroundColor="transparent"/>
                                            </originalProgress>
                                                    <currentProgress>
                                                    <row percentage="100" backgroundColor="#51a825"/>
                                                    <row percentage="0" backgroundColor="#ec8e00"/>
                                            </currentProgress>
                            </progress>
                                    <aggregateprogress percentage="100">
                                    <originalProgress>
                                                    <row percentage="0" backgroundColor="#89afd7"/>
                                                    <row percentage="100" backgroundColor="transparent"/>
                                            </originalProgress>
                                                    <currentProgress>
                                                    <row percentage="100" backgroundColor="#51a825"/>
                                                    <row percentage="0" backgroundColor="#ec8e00"/>
                                            </currentProgress>
                            </aggregateprogress>
                                            <timeestimate seconds="0">0h</timeestimate>
                            <timespent seconds="1200">20m</timespent>
                                <comments>
                            <comment id="15359380" author="kohlisankalp" created="Fri, 1 Jul 2016 18:05:11 +0000"  >&lt;p&gt;cc &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=slebresne&quot; class=&quot;user-hover&quot; rel=&quot;slebresne&quot;&gt;slebresne&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jbellis&quot; class=&quot;user-hover&quot; rel=&quot;jbellis&quot;&gt;jbellis&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="15362279" author="slebresne" created="Tue, 5 Jul 2016 09:33:51 +0000"  >&lt;p&gt;I &quot;think&quot; you are right that this can happen, and that committing an empty commit on SERIAL reads &quot;should&quot; fix it. Paxos is however subtle enough that I would feel more confident with this if we had a reproduction test first, if only so we can validate whatever patch we come up with. &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jkni&quot; class=&quot;user-hover&quot; rel=&quot;jkni&quot;&gt;jkni&lt;/a&gt; I believe you&apos;ve spend some time on jespen-like tests for paxos, do you think this is something we could use to try to reproduce something like that relatively consistently?&lt;/p&gt;</comment>
                            <comment id="15362602" author="jkni" created="Tue, 5 Jul 2016 15:02:09 +0000"  >&lt;p&gt;Sure - I have Jepsen tests for LWT and a few other similar tests I&apos;ve been building. I haven&apos;t seen an issue like this reproduced through them so far, but I&apos;ll try and see if I can reproduce this reliably. It certainly seems feasible to hit. I definitely think it is a good idea to run any proposed patch through LWT tests for a while.&lt;/p&gt;</comment>
                            <comment id="15362888" author="kohlisankalp" created="Tue, 5 Jul 2016 18:04:32 +0000"  >&lt;p&gt;I was able to repro it in a not so good way &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; Here are the steps&lt;br/&gt;
1. Create a 3 node C* cluster(A,B and C)&lt;br/&gt;
2. Create a keyspace with RF=3 and a simple table&lt;br/&gt;
3. Insert System.exit PaxosState.propose method to simulate a failure in A and B. &lt;br/&gt;
4. Do a CAS Write. Now with this, only C will be able to store the propose and not A and B. &lt;br/&gt;
4. Now bring down machine C and remove the System.exit from A and B and bring them up again. &lt;br/&gt;
5. Do a CAS Read and this will involve only A and B and will not return the data. &lt;br/&gt;
6. Bring down A and bring up C. &lt;br/&gt;
7. Do a CAS Read and you will be able to read the data. &lt;/p&gt;

&lt;p&gt;If we can use some test framework to simulate such failures then that will be better. &lt;/p&gt;</comment>
                            <comment id="15372670" author="spodxx@gmail.com" created="Tue, 12 Jul 2016 10:41:15 +0000"  >&lt;p&gt;Another take on how to test coordination aspects for this ticket would be to make use of the MessagingService mocking classes implemented in &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-12016&quot; title=&quot;Create MessagingService mocking classes&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-12016&quot;&gt;&lt;del&gt;CASSANDRA-12016&lt;/del&gt;&lt;/a&gt;. I&apos;ve created a couple of tests &lt;a href=&quot;https://github.com/spodkowinski/cassandra/tree/WIP-12126/test/unit/org/apache/cassandra/service/paxos&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;here&lt;/a&gt; to get a better idea how this would look like. Although limited to observing the behavior of a single node/state machine, it&apos;s probably more lightweight and easier to implement than doing the same using dtests or Jepsen.&lt;/p&gt;

&lt;p&gt;As of the described edge case, I&apos;d agree with &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=kohlisankalp&quot; class=&quot;user-hover&quot; rel=&quot;kohlisankalp&quot;&gt;kohlisankalp&lt;/a&gt;&apos;s suggestion (if I understood correctly) to do an additional proposal round. However, it would be nice to optimize this a bit so we don&apos;t trigger new proposals for each and every SERIAL read. I did a first implementation for this &lt;a href=&quot;https://github.com/spodkowinski/cassandra/commit/96ec151992f49c773e5af5d85ce69ec87d8b7bc5&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;here&lt;/a&gt; (with &lt;a href=&quot;https://github.com/spodkowinski/cassandra/blob/WIP-12126/test/unit/org/apache/cassandra/service/paxos/CASReadTriggerEmptyProposal.java&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;CASReadTriggerEmptyProposal&lt;/a&gt; as corresponding test) for the sake of discussion. &lt;/p&gt;</comment>
                            <comment id="15960582" author="spodxx@gmail.com" created="Fri, 7 Apr 2017 10:25:26 +0000"  >&lt;p&gt;I&apos;ve now revisited this issue again and took a closer look at the work I&apos;ve done back then months ago (after rebasing on trunk). The patch follows the suggested solution by &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=kohlisankalp&quot; class=&quot;user-hover&quot; rel=&quot;kohlisankalp&quot;&gt;kohlisankalp&lt;/a&gt; by using an empty commit as additional propose step. It also implements an optimization to avoid this step in case no paxos rounds for writing new values have been conducted between serial reads.&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;&lt;a href=&quot;https://github.com/spodkowinski/cassandra/tree/CASSANDRA-12126-trunk&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;CASSANDRA-12126-trunk&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;&lt;a href=&quot;https://circleci.com/gh/spodkowinski/cassandra/5&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;CircleCI results&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Except the actual fix, there&apos;s also a lot of tests included, which I&apos;d hate to throw away, as we&apos;re clearly lacking tests for CAS operations.&lt;/p&gt;</comment>
                            <comment id="15972815" author="jbellis" created="Tue, 18 Apr 2017 14:42:08 +0000"  >&lt;p&gt;I see you outlining two series of steps:&lt;/p&gt;

&lt;p&gt;1 -&amp;gt; 2 -&amp;gt; 3.  The value V from 1 is not seen in 2, but once it is seen in 3 it is always seen.&lt;/p&gt;

&lt;p&gt;1 -&amp;gt; 2 -&amp;gt; 4.  V is never seen.&lt;/p&gt;

&lt;p&gt;It seems to me that both of these maintain linearizability.  What am I missing?&lt;/p&gt;</comment>
                            <comment id="15972861" author="slebresne" created="Tue, 18 Apr 2017 15:01:57 +0000"  >&lt;blockquote&gt;&lt;p&gt;1 -&amp;gt; 2 -&amp;gt; 3. The value V from 1 is not seen in 2, but once it is seen in 3 it is always seen.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;As 1 &quot;completes&quot; before 2, it&apos;s result should be visible by 2 (or not ever) for linearizability (taken in the sense discussed here for instance: &lt;a href=&quot;http://www.bailis.org/blog/linearizability-versus-serializability/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.bailis.org/blog/linearizability-versus-serializability/&lt;/a&gt;). More pragmatically, outside of any theoretical definition, if serial read can&apos;t guarantee they will see any previous operation (even failed one, as long as they returned to the client), then they are not very useful in the first place.&lt;/p&gt;</comment>
                            <comment id="15972883" author="jbellis" created="Tue, 18 Apr 2017 15:08:23 +0000"  >&lt;p&gt;But we stipulated that 1 times out and did not complete.  (If it did complete it would be guaranteed to be visible by any majority of course.)&lt;/p&gt;</comment>
                            <comment id="15972886" author="jbellis" created="Tue, 18 Apr 2017 15:12:50 +0000"  >&lt;p&gt;Bailis:&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;once a write completes, all later reads (where &#8220;later&#8221; is defined by wall-clock start time) should return the value of that write or the value of a later write.&lt;/li&gt;
	&lt;li&gt;Once a read returns a particular value, all later reads should return that value or the value of a later write.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;I think we all agree that our current behavior satisfies (2).  I am saying that we actually also satisfy (1) because the write is not complete until Sankalp&apos;s step 3.&lt;/p&gt;</comment>
                            <comment id="15972890" author="slebresne" created="Tue, 18 Apr 2017 15:16:38 +0000"  >&lt;blockquote&gt;&lt;p&gt;But we stipulated that 1 times out and did not complete.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It completed in the sense that the operation is finished and returned to the client (albeit with a timeout). Don&apos;t get me wrong, theory is blind, so if you want to define than an operation completes only if it &quot;finished and did not timeout&quot; and define linearizability only in term of completing operation (with that definition of completion), then sure, I agree this particular definition of linearizability is not broken by the description of this ticket.&lt;/p&gt;

&lt;p&gt;But how useful is a definition of linearizability that says nothing about operations that timeouts (especially keeping in mind that our implementation is particularly prone to timeouts)?&lt;/p&gt;</comment>
                            <comment id="15972899" author="slebresne" created="Tue, 18 Apr 2017 15:21:03 +0000"  >&lt;blockquote&gt;&lt;p&gt;I am saying that we actually also satisfy (1) because the write is not complete until Sankalp&apos;s step 3.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Your definition of &quot;completion&quot; doesn&apos;t work logically. You&apos;re suggesting (1) only complete when it is visible (in (3)), but linearizabilty is about when operations that complete are visible, so if you define completion as &quot;when it&apos;s visible&quot;, you&apos;re in for trouble.&lt;/p&gt;</comment>
                            <comment id="15973117" author="jbellis" created="Tue, 18 Apr 2017 17:31:11 +0000"  >&lt;p&gt;I&apos;m confused, because it sounds like you&apos;re saying &quot;all operations should be visible once finished.&quot;  Of course that&apos;s not actually what you mean that would require participation from all replicas to finish in-flight requests and not just a majority.  What is the distinction you are proposing?&lt;/p&gt;</comment>
                            <comment id="15974342" author="slebresne" created="Wed, 19 Apr 2017 08:58:18 +0000"  >&lt;blockquote&gt;&lt;p&gt;What is the distinction you are proposing?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Not sure, I think we don&apos;t put the same definitions on operation visibility. What I&apos;m saying is that &quot;if an operation has a visible outcome, then that outcome should be visible (by serial operations) by any subsequent operation (so as soon as the operation returns to the client if you will)&quot;. In particular, if a serial read follows a serial write (meaning that it&apos;s started after the write returned, even with a timeout), then if the write has any effect, the read should see it.&lt;/p&gt;

&lt;p&gt;Note that when you get a timeout on the initial write, you don&apos;t know if the write has been applied or not, but the whole point of a serial read is to be able to unequivocally decide what was that outcome. If we can&apos;t guarantee that, if there is no way to observe if a timed-out write has been applied or not, then I&apos;m not sure how one would use LWT in the first place.&lt;/p&gt;</comment>
                            <comment id="15974834" author="jbellis" created="Wed, 19 Apr 2017 14:56:12 +0000"  >&lt;p&gt;I see.  So you are saying that&lt;/p&gt;

&lt;p&gt;1: Write&lt;br/&gt;
2: Read -&amp;gt; Nothing&lt;br/&gt;
3: Read -&amp;gt; Something&lt;/p&gt;

&lt;p&gt;Is broken because to go from Nothing to Something &lt;span class=&quot;error&quot;&gt;&amp;#91;in a linearized system&amp;#93;&lt;/span&gt; there needs to be a write in between.&lt;/p&gt;</comment>
                            <comment id="15974873" author="slebresne" created="Wed, 19 Apr 2017 15:03:26 +0000"  >&lt;p&gt;Exactly.&lt;/p&gt;</comment>
                            <comment id="16629455" author="jeffreyflukman" created="Wed, 26 Sep 2018 21:55:59 +0000"  >&lt;p&gt;Hi all,&lt;/p&gt;

&lt;p&gt;Our team from UCARE University of Chicago, have been able to reproduce similar manifestation to this bug consistently with our model checker. (Our scenario is different with what &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=kohlisankalp&quot; class=&quot;user-hover&quot; rel=&quot;kohlisankalp&quot;&gt;kohlisankalp&lt;/a&gt;&#160;proposed)&lt;br/&gt;
Here are the workload and scenario of the bug:&lt;/p&gt;

&lt;p&gt;Workload: 3 nodes-cluster, 3 client requests (but no crash event)&lt;/p&gt;

&lt;p&gt;Scenario:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;Start 3-nodes cluster and inject all of 3 client requests to 3 different nodes (node X, Y, Z)&lt;/li&gt;
	&lt;li&gt;Node X sends its prepare messages (ballot number=1) to all nodes and all nodes accept it&lt;/li&gt;
	&lt;li&gt;Node X sends its propose message to itself, causing its inProgress value to be &quot;X&quot;.&lt;/li&gt;
	&lt;li&gt;Node Y sends its prepare messages (ballot number=2) to all nodes.&lt;br/&gt;
This also causes the rest of node&#160;X propose messages to be invalid because its ballot number is smaller than node Y prepare messages.&lt;/li&gt;
	&lt;li&gt;In our scenario, the prepare response messages from node Y and Z comes first before prepare response&#160;message from node X, causing the node Y to unrecognize the state of node&#160;X which already accepted value &quot;X&quot; (step 3).&lt;/li&gt;
	&lt;li&gt;But since our query of client request 2 has an IF, that said IF value_1=&apos;X&apos;, therefore node Y will not continue on sending propose messages to all nodes.&lt;br/&gt;
Up to this point, it means none of the queries&#160;are committed to the server.&lt;/li&gt;
	&lt;li&gt;Node Z now sends its prepare messages to all nodes and all nodes accept it.&lt;/li&gt;
	&lt;li&gt;In our scenario, now the node X returns its response first where it also let node Z knows about its inProgress Value &quot;X&quot;.&lt;br/&gt;
From here, node Z will propose and commit client request-1 (with value &quot;X&quot;) instead of client-request-3.&lt;/li&gt;
	&lt;li&gt;Therefore, we ended up having client&#160;request 1 stored to the server, although client request-3 was the one that is said successful.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;We are ready to assist, if any further information is needed.&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;</comment>
                            <comment id="16629542" author="jjirsa" created="Wed, 26 Sep 2018 23:46:28 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jeffreyflukman&quot; class=&quot;user-hover&quot; rel=&quot;jeffreyflukman&quot;&gt;jeffreyflukman&lt;/a&gt; thanks for this report. Suspect that most of the folks who are interested in this are already cc&apos;d and received an email notification of your response, but explicitly tagging &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=benedict&quot; class=&quot;user-hover&quot; rel=&quot;benedict&quot;&gt;benedict&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=iamaleksey&quot; class=&quot;user-hover&quot; rel=&quot;iamaleksey&quot;&gt;iamaleksey&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=bdeggleston&quot; class=&quot;user-hover&quot; rel=&quot;bdeggleston&quot;&gt;bdeggleston&lt;/a&gt; as people who aren&apos;t yet watching it but may be interested.&lt;/p&gt;

&lt;p&gt;Also, very much interested in the model you mentioned - is that available publicly at this point? &lt;/p&gt;</comment>
                            <comment id="16629685" author="jeffreyflukman" created="Thu, 27 Sep 2018 02:50:42 +0000"  >&lt;p&gt;To complete our scenario, here is the setup for our Cassandra:&lt;br/&gt;
 We run the scenario with Cassandra-v2.0.15.&lt;br/&gt;
 Here is the scheme that we use:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;CREATE KEYSPACE test WITH REPLICATION = {&apos;class&apos;: &apos;SimpleStrategy&apos;, &apos;replication_factor&apos;: 3};&lt;/li&gt;
	&lt;li&gt;CREATE TABLE tests ( name text PRIMARY KEY, owner text, value_1 text, value_2 text, value_3 text);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Here are the queries that we submit:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;client request to node X (1st): UPDATE test.tests SET value_1 = &apos;A&apos; WHERE name = &apos;testing&apos; IF owner = &apos;user_1&apos;;&lt;/li&gt;
	&lt;li&gt;client request to node Y (2nd):&#160;UPDATE test.tests SET value_2 = &apos;B&apos; WHERE name = &apos;testing&apos; IF value_1 = &apos;A&apos;;&lt;/li&gt;
	&lt;li&gt;client request to node Z (3rd):&#160;UPDATE test.tests SET value_3 = &apos;C&apos; WHERE name = &apos;testing&apos; IF value_1 = &apos;A&apos;;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;To confirm, when the bug is manifested, the end result will be: value_1=&apos;A&apos;, value_2=null, value_3=null&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jjirsa&quot; class=&quot;user-hover&quot; rel=&quot;jjirsa&quot;&gt;jjirsa&lt;/a&gt;, regarding our tool, at this point, it is not open for public.&#160;&lt;/p&gt;</comment>
                            <comment id="16629689" author="kohlisankalp" created="Thu, 27 Sep 2018 02:58:40 +0000"  >&lt;p&gt;Why is end result not correct? second and third operation did not succeed because first 1 did not finish? Can you combine the example with the earlier comment please&lt;/p&gt;</comment>
                            <comment id="16629950" author="benedict" created="Thu, 27 Sep 2018 08:44:34 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jeffreyflukman&quot; class=&quot;user-hover&quot; rel=&quot;jeffreyflukman&quot;&gt;jeffreyflukman&lt;/a&gt; it would help if you could explicitly state the client responses returned for each of your operations.  The options are: time out, rejected (condition not met), success (condition met, and mutation applied)&lt;/p&gt;

&lt;p&gt;For completeness, as with&#160;&lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-12438&quot; title=&quot;Data inconsistencies with lightweight transactions, serial reads, and rejoining node&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-12438&quot;&gt;CASSANDRA-12438&lt;/a&gt;, the read queries you are performing, to which nodes, at what point and with&#160;what consistency levels would be helpful to know.  Are you verifying the state with a SERIAL read after the last query, most specifically? &#160;Also,&#160;can&#160;we assume that the state of the table began with &lt;br class=&quot;atl-forced-newline&quot; /&gt;&lt;/p&gt;
{name:&apos;testing&apos;, owner:&apos;user_1&apos;, value1:null, value2:null, value3:null}
&lt;p&gt;&amp;#63;&lt;/p&gt;</comment>
                            <comment id="16630688" author="jeffreyflukman" created="Thu, 27 Sep 2018 16:20:08 +0000"  >&lt;p&gt;During our testing with our model checker, we limit the round of Paxos for each query,&lt;br/&gt;
because if not, it is possible that we get stuck&#160;in a very long sequence of message transactions among the nodes without progressing anywhere. So, what we do is we only execute one round of Paxos for each query.&lt;/p&gt;

&lt;p&gt;To enlight our test and combine our whole story, here is what happened in detail:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;We first prepared the 3 node-cluster with the test.tests table as initial table structure and yes, the initial table began with:
{name:&apos;testing&apos;, owner:&apos;user_1&apos;, value1:null, value2:null, value3:null}&lt;/li&gt;
	&lt;li&gt;Next, we run the model checker that will start the 3 node-cluster.&lt;/li&gt;
	&lt;li&gt;Inject the 3 client requests in order: query 1, then query 2, then query 3.&lt;br/&gt;
This cause query 1 to have ballot number &amp;lt; query 2 ballot number &amp;lt; query 3 ballot number.&lt;/li&gt;
	&lt;li&gt;Now this means, in the beginning, the model checker already see there will be 9 prepare messages in its queue that will be reordered in some way.&lt;/li&gt;
	&lt;li&gt;When the bug is manifested, we ended up having:
	&lt;ul&gt;
		&lt;li&gt;Node X&apos;s prepare messages proceed and all nodes response with true&#160;back to node X.&lt;/li&gt;
		&lt;li&gt;Node X sends its propose message with value_1=&apos;A&apos; to itself first and get a response true as well.&lt;/li&gt;
		&lt;li&gt;At this moment, Node X inProgress value is updated to the proposed value, value_1=&apos;A&apos;&lt;/li&gt;
		&lt;li&gt;But then node Y prepare messages proceed and all nodes response with true back to node Y,&lt;br/&gt;
because prepare messages of node Y have a higher ballot number.&lt;/li&gt;
		&lt;li&gt;But when node Y about to proceed the propose messages it realized that the current data does not fulfill the IF condition, so it does not proceed to propose messages. --&amp;gt; Client request 2 to node Y is therefore rejected&lt;/li&gt;
		&lt;li&gt;Continuing node X propose messages to node Y and Z, both requests are returned with false to node X&lt;/li&gt;
		&lt;li&gt;Now at this point node X should be able to retry the Paxos with a higher ballot number, but since we limit the round of Paxos for each query to one, therefore client request 1 to node X is timed out.&lt;/li&gt;
		&lt;li&gt;Lastly, node Z sends its prepare messages to all nodes, and get response true messages from all nodes,&lt;br/&gt;
because the ballot number is higher as well.&lt;/li&gt;
		&lt;li&gt;At this point, if the node X response message is returned first to node X, what will happen is node Z will realize that node X still has an inProgress value in the process (value_1=&apos;A&apos;). This cause node Z to send propose messages and commit messages but for client request 1 using the current highest ballot number.&lt;br/&gt;
Here we have our first data update saved: value_1=&apos;A&apos;, value_2=null, value_3=null.&lt;/li&gt;
		&lt;li&gt;Back to our constraint of one round Paxos for each query, we ended up not retrying client request-3 because we reached timeout.&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;To sum up:
	&lt;ul&gt;
		&lt;li&gt;client request-1: Timed out&lt;/li&gt;
		&lt;li&gt;client request-2: Rejected&lt;/li&gt;
		&lt;li&gt;client request-3: Timed out&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;There we get an inconsistency between the client side and the server side, where all requests actually failed, but when we read the end result again from all nodes, we get&#160;value_1=&apos;A&apos;, value_2=null, value_3=null.&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;I made a wrong statement at the end of my first comment:&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;9. Therefore, we ended up having client&#160;request 1 stored to the server, although client request-3 was the one that is said successful.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;It should be failed due to timeout.&lt;/p&gt;</comment>
                            <comment id="16630700" author="JIRAUSER308715" created="Thu, 27 Sep 2018 16:30:44 +0000"  >&lt;blockquote&gt;&lt;p&gt;client request-1: Timed out, client request-2: Rejected, client request-3: Timed out&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Given those responses to the queries.  The client side does not know the state of the system without issuing a READ at SERIAL (or doing another INSERT that gets a success which the state can be inferred from).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;There we get an inconsistency between the client side and the server side, where all requests actually failed, but when we read the end result again from all nodes, we get value_1=&apos;A&apos;, value_2=null, value_3=null.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Given the responses you got, there is no inconsistency.  The client received &quot;timed out&quot; exceptions.  A timed out exception means &quot;your query may or may not have been applied, the server doesn&apos;t know, you should retry it if you want to ensure it goes through&quot;.  In this case request-1 was successful, and request-3 failed.  So &lt;tt&gt;value_1=&apos;A&apos;, value_2=null, value_3=null&lt;/tt&gt; is a valid state and not inconsistent.&lt;/p&gt;</comment>
                            <comment id="16630772" author="kohlisankalp" created="Thu, 27 Sep 2018 17:28:37 +0000"  >&lt;p&gt;I agree with &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jjordan&quot; class=&quot;user-hover&quot; rel=&quot;jjordan&quot;&gt;jjordan&lt;/a&gt; that this is a correct response.&#160;&lt;/p&gt;

&lt;p&gt;Also in the future please open a new Jira if it is a different issue.&#160;&lt;/p&gt;</comment>
                            <comment id="16630850" author="jeffreyflukman" created="Thu, 27 Sep 2018 18:15:30 +0000"  >&lt;p&gt;Thank you for your responses,&#160;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jjordan&quot; class=&quot;user-hover&quot; rel=&quot;jjordan&quot;&gt;jjordan&lt;/a&gt;&#160;and &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=kohlisankalp&quot; class=&quot;user-hover&quot; rel=&quot;kohlisankalp&quot;&gt;kohlisankalp&lt;/a&gt;.&lt;br/&gt;
I think you have cleared up some misunderstandings for me (and&#160;our team) where timeout is a &quot;gray area&quot; for the client &lt;br/&gt;
to determine whether a request has been successfully processed.&lt;/p&gt;

&lt;p&gt;One thing that we would like to point out maybe, based on the early discussion in this bug description, quote&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;However we need to fix step 2, since it caused reads to not be linearizable with respect to writes and other reads. In this case, we know that majority of acceptors have no inflight commit which means we have majority that nothing was accepted by majority. I think we should run a propose step here with empty commit and that will cause write written in step 1 to not be visible ever after.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;What we tried to&#160;mimic with our model checker in the beginning actually was this scenario where node Y saw that the majority of nodes do not have inProgress&#160;value, but then suddenly node Z saw that there is an inProgress value from node X and tried to&#160;repair and commit it.&lt;br/&gt;
So, we confirm that we can also see this behavior:&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;2: Read -&amp;gt; Nothing&lt;br/&gt;
3: Read -&amp;gt; Something&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;We read nothing in node Y, yet node Z read something in the next request.&lt;/p&gt;



&lt;p&gt;To sum up, at least, our scenario&#160;explains this behavior: Node Y does not try to repair the Paxos because node X&apos;s prepare response comes last, therefore node Y ignores the node X&apos;s prepare response and based its decision to not repair the Paxos.&lt;br/&gt;
But in node Z&apos;s client request, node Z decides to repair the Paxos based on node X&apos;s existing inProgress value_1=&quot;A&quot; because node X&apos;s prepare response comes early (1st or 2nd). Which cause an inconsistent reaction in some way between node Y and node Z (although this is correct based on the original Paxos algorithm).&lt;/p&gt;


&lt;p&gt;A solution to avoid this inconsistent reactions from these two nodes&#160;maybe is for each node to decide whether to repair a Paxos or not based on the&#160;complete view of the alive nodes, therefore if the response X&apos;s comes last with an inProgress value, node Y will still repair the Paxos.&lt;/p&gt;</comment>
                            <comment id="16631226" author="benedict" created="Fri, 28 Sep 2018 00:56:45 +0000"  >&lt;blockquote&gt;&lt;p&gt;We read nothing in node Y, yet node Z read something in the next request.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I think the problem here is that, at the API level, there isn&apos;t enough information to say that X didn&apos;t simply &apos;occur&apos; &lt;b&gt;after&lt;/b&gt; both Y and Z. That is, unless the rejection of Y occurs after X&apos;s timeout. In this case, it would seem to be an API-visible error, as at the point of timeout the indeterminacy should be fixed. Timeouts should not &#8216;live forever&#8217; as the bogeyman, ready to mess with history.&lt;/p&gt;

&lt;p&gt;I think, though, that the suggested mechanism could result in this.&lt;/p&gt;

&lt;p&gt;Take three nodes (RF=3) A, B and C; and any three CAS operations X, Y and Z such that:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;X and Y can always succeed&lt;/li&gt;
	&lt;li&gt;Z can only succeed if X has succeeded&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Setup:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;Prepare &lt;em&gt;and&lt;/em&gt; Propose X with ballot 1; proposal accepted only by A
	&lt;ul&gt;
		&lt;li&gt;this will be the last and only node&#8217;s proposal acceptance&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;Prepare Y with ballot 2; reach B and C before ballot 1, so they do not accept&lt;/li&gt;
	&lt;li&gt;Now, lock X and Y in battle, always failing to proceed to the propose step before the other reaches the prepare step again&lt;/li&gt;
	&lt;li&gt;X and Y both timeout having failed to cleanly apply&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;Part 2:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;Z is now attempted; it prepares to only B and C, seeing no in-progress proposal&lt;/li&gt;
	&lt;li&gt;As a result, it does not see X; it is rejected, so there is no new proposal/commit&lt;/li&gt;
	&lt;li&gt;Z is attempted&#160;again; this time, A is consulted&lt;/li&gt;
	&lt;li&gt;Suddenly, a wild X appears. From nowhere. &#160;Z succeeds, despite no intervening operations.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;It does seem, in essence, to be an incidence of the bug (or a very similar one) described in the ticket.&lt;/p&gt;</comment>
                            <comment id="16726929" author="aweisberg" created="Fri, 21 Dec 2018 17:38:48 +0000"  >&lt;p&gt;Having reviewed the code I think what Benedict says is correct. The criteria we use for identifying if there is an progress paxos round that needs resolution is incorrect because it assumes we have visibility to all accepted ballots when we only have visibility to a majority.&lt;/p&gt;

&lt;p&gt;I think this optimization can be done correctly, but it&apos;s a bit of surgery. Right now reads do a prepare and modify the promised ballot at each acceptor. If instead we only read the promised ballot from each acceptor then we could check the promised ballot matches the most recent committed ballot. If those are the same we know nothing is in progress because a higher ballot than the most recent accepted/committed ballot has not been promised by a majority which means there can be no lingering accepted ballot since a majority of promises must be collected first.&lt;/p&gt;

&lt;p&gt;If that isn&apos;t the case then we can go ahead and do a prepare + propose to make them match and subsequent reads won&apos;t have to do a propose.&lt;/p&gt;

&lt;p&gt;This may also impact our choice of how many replicas to contact in each phase since we want them to have consistent paxos state so reads can be one roundtrip. I am not sure if we contact them all (like with mutations) or just a majority.&lt;/p&gt;</comment>
                            <comment id="16964198" author="benedict" created="Thu, 31 Oct 2019 16:44:35 +0000"  >&lt;p&gt;It looks like I never noted that IMO the real problem is that we do not serialize the evaluation of a condition if the condition is not met, so other commands are also not serialized wrt the evaluation of such conditions either. &#160;The evaluation of a condition should always be a serialized wrt other events, so we should be agreeing on the conditional operation, and then performing it, not evaluating the condition and then serializing the choice of a new value.&lt;/p&gt;</comment>
                            <comment id="17116578" author="slebresne" created="Tue, 26 May 2020 09:56:07 +0000"  >&lt;p&gt;It definitively doesn&apos;t look good that this messages comes so late, but I feel this is a serious issue of the &lt;tt&gt;SERIAL&lt;/tt&gt;/&lt;tt&gt;LOCAL_SERIAL&lt;/tt&gt; consistency levels since this breaks the basic guarantee they exist to provide, and as such should be fixed all the way down 3.0, and the sooner, the better.&lt;/p&gt;

&lt;p&gt;In an attempt to sum this up quickly, the problem we have here affects both serial reads &lt;em&gt;and&lt;/em&gt; LWT updates that do not apply (whose condition evaluates to &lt;tt&gt;false&lt;/tt&gt;). In both case, while the current code replays &quot;effectively committed&quot; proposals (those whose proposal has been accepted by majority of replica) with &lt;tt&gt;beginAndRepairPaxos&lt;/tt&gt;, neither make proposals of their own, so nothing will prevent a proposal accepted by a minority of replica (say just one) to be later replayed (and thus committed).&lt;/p&gt;

&lt;p&gt;I&apos;ve pushed &lt;a href=&quot;https://github.com/pcmanus/cassandra/commit/3442277905362b38e0d6a2b8170916fcfd18d469&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;2 in-jvm dtests&lt;/a&gt; that demonstrate the issue for both cases (again, serial reads and non-applying updates). They use &quot;filters&quot; to selectively drop messages to make failure consistent but aren&apos;t otherwise very involved.&lt;/p&gt;

&lt;p&gt;As &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=kohlisankalp&quot; class=&quot;user-hover&quot; rel=&quot;kohlisankalp&quot;&gt;kohlisankalp&lt;/a&gt; mentioned initially, the &quot;simplest&quot;[1] way to fix this that I see is to commit an empty update in both cases. Actually committing, which sets the &lt;tt&gt;mostRecentCommit&lt;/tt&gt; value in the Paxos state, ensures that no prior proposal can ever be replayed. I&apos;ve pushed a patch to do so on 3.0/3.11 below (will merge up on 4.0, but wanted to make sure we&apos;re ok on the approach first):&lt;/p&gt;

&lt;div class=&apos;table-wrap&apos;&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;version&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; &lt;a href=&quot;https://github.com/pcmanus/cassandra/commits/C-12126-3.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;3.0&lt;/a&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; &lt;a href=&quot;https://github.com/pcmanus/cassandra/commits/C-12126-3.11&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;3.11&lt;/a&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;


&lt;p&gt;The big downside of this patch however is the performance impact. Currently, a &lt;tt&gt;SERIAL&lt;/tt&gt; read (that finds nothing in progress it needs to replay) is 2 round-trips (a prepare phase, followed by the actual read). With this patch, it is 3 round-trips as we have to propose our empty commit and get acceptance (we don&apos;t really have to wait for responses on the commit though), which will be noticeable for performance sensitive use-cases. Similarly, the performance of LWT that don&apos;t apply will be impacted.&lt;/p&gt;

&lt;p&gt;That said, I don&apos;t seen another approach to fixing this that would be as acceptable for 3.0/3.11 in terms of risks, and imo &apos;slower but correct&apos; beats &apos;faster but broken&apos; any day, so I&apos;m in favor of moving forward with this fix.&lt;/p&gt;

&lt;p&gt;Opinions?&lt;/p&gt;



&lt;p&gt;[1]: I mean by that both the simplicity of the change, but also of validating that this fix the problem at hand without creating new correctness problems.&lt;/p&gt;</comment>
                            <comment id="17117143" author="bdeggleston" created="Tue, 26 May 2020 22:08:47 +0000"  >&lt;p&gt;Agreed that&apos;s the most straightforward way to address both issues (although I&apos;ve only skimmed your patch).&lt;/p&gt;

&lt;p&gt;In 3.x though, and at least for the serial read fix, I think we should include a flag to disable the fix, in case a) there&apos;s a problem with the fix or b) operators would rather trade the performance impact for linearizability for whatever reason.&lt;/p&gt;

&lt;p&gt;There&apos;s also a variant of the non-applying update issue where it&apos;s exposed by a read, not another insert. It would be good to have a test for that as well.&lt;/p&gt;</comment>
                            <comment id="17117172" author="benedict" created="Tue, 26 May 2020 23:31:40 +0000"  >&lt;p&gt;So, a thought has occurred to me: what do we actually claim our consistency properties are for SERIAL? &lt;/p&gt;

&lt;p&gt;My understanding was that we claimed only serializability, in which case I don&apos;t think that strictly speaking this is a bug.  I think it&apos;s only a bug if we claim strict serializability.  However the only docs I can find claiming either are DataStax&apos;s which mixes linearizable up with serializable.&lt;/p&gt;

&lt;p&gt;FWIW, I consider this to be a bug, as we should at least support the more intuitively correct semantics.  But perhaps we should instead introduce a new STRICT_SERIAL consistency level to solve it, and clarify what SERIAL means in our docs?&lt;/p&gt;

&lt;p&gt;I would also be OK with simply claiming strict serializability for SERIAL.  But perhaps this technicality/ambiguity buys us some time and cover to solve the problem without introducing major performance penalties?&lt;/p&gt;

&lt;p&gt;I also have some relevant test cases I will share tomorrow, along with test cases for other correctness failures of LWTs.&lt;/p&gt;</comment>
                            <comment id="17117597" author="benedict" created="Wed, 27 May 2020 09:59:10 +0000"  >&lt;p&gt;I&apos;ve pushed various test cases &lt;a href=&quot;https://github.com/belliottsmith/cassandra/tree/12126-tests-3.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;here&lt;/a&gt; - most of them marked &lt;tt&gt;@Ignore&lt;/tt&gt; because they are known to fail, and won&apos;t be resolved immediately.&lt;/p&gt;</comment>
                            <comment id="17117615" author="slebresne" created="Wed, 27 May 2020 10:21:30 +0000"  >&lt;blockquote&gt;&lt;p&gt;I think we should include a flag to disable the fix&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;The option of having a flag occurred to me, but I rejected it initially because I continue to believe the current behavior is wrong (a moral judgment, I guess) and in principle, having a &quot;please, make my database broken&quot; flag does not feel like a good idea.&lt;/p&gt;

&lt;p&gt;But I reckon that it &lt;em&gt;may&lt;/em&gt; exists advanced users that did noticed the lack of linearizability for reads and effectively built around it knowingly, for which the performance impact may be considered a regression with no upside (but if you sense skepticism on my part when reading that sentence, you&apos;re radar is not completely off).&lt;/p&gt;

&lt;p&gt;And as we&apos;re talking minor upgrade here, I&apos;m amenable to such flag, though I&apos;d prefer making it clear somehow that it is unsafe/risky and something we may remove in the future with no particular warning.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;It would be good to have a test for that as well.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Certainly, good point, I can add the 2 missing interleaving.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;do we actually claim our consistency properties are for SERIAL?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;While our official doc on the matter is certainly lacking (not spelling much guarantee at all afaict, and I&apos;m happy to piggy-back on this ticket to correct that), we&apos;ve always implied linearizability. I have, at least, and I&apos;m sure I can dig up other doing it as well on the mailing list if necessary. We did this both by throwing the linearizable word out from time to time, but also by repeatedly recommending that when a write times out, one needs to issue a SERIAL read to &apos;observe&apos; if that write went through or not (and as an aside, if you can&apos;t rely on either reads or non-applying CAS for that, I&apos;m not even sure how to use LWTs, except maybe for excessively specific cases).&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;perhaps we should instead introduce a new STRICT_SERIAL consistency level&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I&apos;m rather cold on that because, tbh. I think non-strict serializability is a theoretical notion that is useless in practice and that it is something we should not offer. And I&apos;d rather avoid one more &quot;feature&quot; for which we spend our time saying &quot;don&apos;t use it&quot;.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;I&apos;ve pushed various test cases&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Awesome, thanks. I&apos;ll look at integrating those in the branch if you don&apos;t mind.&lt;/p&gt;</comment>
                            <comment id="17117628" author="slebresne" created="Wed, 27 May 2020 10:37:55 +0000"  >&lt;blockquote&gt;&lt;p&gt;I&apos;m amenable to such flag&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Actually, let me rephrase that a bit. I&apos;d &lt;b&gt;really&lt;/b&gt; prefer not adding such flag. If someone is ok with serializability without linearizability, then they can use QUORUM reads, and given how things are implemented, it provides (non-strict) serializability. Granted, for someone that uses SERIAL today, is ok with the lack of linearizability and can&apos;t afford the performance penalty, it&apos;ll require a client side change, which this flag would avoid, so there is not zero value to such flag. But I suspect user fitting that category (knowingly ok with lack of linearizability) is really really small, and we always have to make trade-offs. So in that case I feel adding one more flag, one I consider dangerous, is not worth it. So to clarify, if a consensus appears for such flag, so be it, I&apos;ll add it, but I&apos;m personally not neutral either.&lt;/p&gt;</comment>
                            <comment id="17117652" author="benedict" created="Wed, 27 May 2020 11:03:56 +0000"  >&lt;blockquote&gt;&lt;p&gt;I&apos;m rather cold on that because, tbh. I think non-strict serializability is a theoretical notion that is useless in practice and that it is something we should not offer. And I&apos;d rather avoid one more &quot;feature&quot; for which we spend our time saying &quot;don&apos;t use it&quot;.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yeah, I&apos;m very sympathetic to this view, and have always assumed linearizability with partitions as the object.  I&apos;m just really trying to morally justify providing some time to fix this without any negative repercussions.  &lt;/p&gt;

&lt;p&gt;Either way, we should definitely clarify what we mean by SERIAL in some official project documentation somewhere though.  We probably need to do so in terms of strict serializability as opposed to linearizability, so that it can be consistent with a future in which we support multi-partition transactions (which as a project we really need to deliver in the not-too-distant future).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;non-applying CAS for that&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;FWIW, I think this particular case is a no-brainer; there&apos;s no real cost to strengthening the semantics of non-applying CAS IMO, since users should anticipate their CAS operations will ordinarily take this long.  Whatever the conclusion of our discussion, I think we should apply a fix at least for the non-applying case immediately, and I do not believe any flag to disable this part of the fix is necessary.&lt;/p&gt;

&lt;p&gt;Reads are trickier, because the user will see a significant performance penalty on patch version upgrade.  I&apos;m sympathetic to the view we should just fix the read part immediately, performance regressions be damned.  But we do have other serious consistency violations that should also be fixed.  I think it is worth &lt;em&gt;considering&lt;/em&gt; if we should instead aggressively try to remedy all of the known issues, have a strong verification push, and then roll out all of the changes at-once - including a fix for this that does not regress performance.  It might seem a lot for a patch version, but I&apos;m not sure risk is a concern when we know there are several serious problems today, and have been for years.&lt;/p&gt;

&lt;p&gt;I&apos;m not going to advocate super strongly for either approach, as I don&apos;t think there&apos;s a clear answer, I just want to raise the alternative as an option to expressly consider.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Awesome, thanks. I&apos;ll look at integrating those in the branch if you don&apos;t mind.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Absolutely, that was my intention.&lt;/p&gt;</comment>
                            <comment id="17117833" author="slebresne" created="Wed, 27 May 2020 15:01:26 +0000"  >&lt;blockquote&gt;&lt;p&gt;But we do have other serious consistency violations that should also be fixed.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Could you expand on that?&lt;/p&gt;</comment>
                            <comment id="17117855" author="benedict" created="Wed, 27 May 2020 15:35:17 +0000"  >&lt;p&gt;The test cases I provided demonstrate several consistency violations during range movements.  I&apos;ve just thought of another one, and am writing a test case for it.  Perhaps we could claim that range movements are always (potentially) consistency violations, but they are particularly keenly felt when you claim a linearisable history.&lt;/p&gt;

&lt;p&gt;There are also (more debatably) issues with TTL on &lt;tt&gt;system.paxos&lt;/tt&gt;, particularly when mixed with non-global commit; perhaps we could claim this is the user&apos;s problem, but it&apos;s not clear why we support global consensus that can be lost through local commit, and I don&apos;t think we communicate clearly the consistency implications to not call this a bug.&lt;/p&gt;

&lt;p&gt;Also, mixing LOCAL_SERIAL and SERIAL is entirely unsafe, and even supporting them both is arguably a consistency violation without mechanisms to safely transition from one level to another.&lt;/p&gt;</comment>
                            <comment id="17126937" author="slebresne" created="Fri, 5 Jun 2020 16:43:34 +0000"  >&lt;blockquote&gt;&lt;p&gt;The test cases I provided demonstrate several consistency violations during range movements.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes, sorry I hadn&apos;t read them before commenting. And I certainly agree those are problematic (I was about to open a ticket so it&apos;s tracked, but I&apos;d say &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-15745&quot; title=&quot;Conflicting LWT transactions may be committed during topology change&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-15745&quot;&gt;CASSANDRA-15745&lt;/a&gt; kind of cover those).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;There are also (more debatably) issues with TTL on system.paxos&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Agreed this has always been a weak point. It does feel somewhat separated of other consistency points though, and maybe short term we can just offer a way to override the TTL (with documentation on the tradeoffs involved)?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Also, mixing LOCAL_SERIAL and SERIAL is entirely unsafe&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yeah. I&apos;m not sure how to fix that one without a breaking API change though (namely, limiting their unrestricted use together). It&apos;s not &quot;that&quot; different from the fact we allow unrestricted mixing of serial and non-serial operations.  Which is something I don&apos;t like and I&apos;m happy to discuss moving forward, but imo post-3.X material in the best of cases.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I think it is worth considering if we should instead aggressively try to remedy all of the known issues, have a strong verification push, and then roll out all of the changes at-once - including a fix for this that does not regress performance.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It is certainly an option worth bringing, and thank you for that. I&apos;m not sure how to really know what is the best option though, so I can only offer my current opinion.&lt;/p&gt;

&lt;p&gt;Which is that I feel this issue is a very serious issue. And I don&apos;t mean that in a way that diminishes the seriousness of the other problems you mentioned, I mean that in absolute terms (the range movement issues are also fairly bad imo for instance). But leaving less of our known serious unaddressed feels better than not, so I&apos;d personally prefer fixing that issue ASAP. Basically, I&apos;m worried that waiting for a more all-encompassing fix might take us quite some time, with no absolute guarantee that we&apos;ll be collectively at ease with pushing that to 3.X.&lt;/p&gt;

&lt;p&gt;Anyway, I&apos;d like to move this forward personally. How do we decide if we do?&lt;/p&gt;</comment>
                            <comment id="17130517" author="benedict" created="Wed, 10 Jun 2020 11:05:32 +0000"  >&lt;p&gt;&amp;gt; I&apos;d like to move this forward personally. &lt;/p&gt;

&lt;p&gt;Sure, go for it.&lt;/p&gt;</comment>
                            <comment id="17134239" author="slebresne" created="Fri, 12 Jun 2020 13:55:31 +0000"  >&lt;p&gt;Ok, I&apos;ve rebased the patch against 4.0 and started CI on it all:&lt;/p&gt;
&lt;div class=&apos;table-wrap&apos;&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;branch&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;CI&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://github.com/pcmanus/cassandra/tree/C-12126-3.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;3.0&lt;/a&gt;&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://ci-cassandra.apache.org/job/Cassandra-devbranch/146/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;Run #146&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://github.com/pcmanus/cassandra/tree/C-12126-3.11&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;3.11&lt;/a&gt;&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://ci-cassandra.apache.org/job/Cassandra-devbranch/147/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;Run #147&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://github.com/pcmanus/cassandra/tree/C-12126-4.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;4.0&lt;/a&gt;&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://ci-cassandra.apache.org/job/Cassandra-devbranch/148/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;Run #148&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;


&lt;p&gt;I included a commit to add the flag that disables the new empty commit for SERIAL reads as suggested by &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=bdeggleston&quot; class=&quot;user-hover&quot; rel=&quot;bdeggleston&quot;&gt;bdeggleston&lt;/a&gt; earlier. Still slightly on the fence on the need for such flag, but I call it &quot;unsafe&quot; (&lt;tt&gt;-Dcassandra.unsafe.disable-serial-reads-linearizability&lt;/tt&gt; to be specific) and log a warning when used, so I&apos;m at peace with that.&lt;/p&gt;

&lt;p&gt;I&apos;ll note for future reviewers that while the 3.11 branch is almost a straight away merge up of 3.0, there is a minor differences on the 4.0 branch, namely:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;the added in-jvm dtests needed a few changes to reflect 4.0 changes. To make that easier, I squashed 2 of the commits from the 3.0/3.11 branches, which is why that branch has one less commit.&lt;/li&gt;
	&lt;li&gt;There is a few changes related to the translation of &lt;tt&gt;WriteTimeoutException&lt;/tt&gt; into &lt;tt&gt;CasWriteTimeoutException&lt;/tt&gt; (I pushed it down in some cases). I believe this fixes a minor &quot;bug&quot; where the &quot;contentions&quot; number we returned with &lt;tt&gt;CasWriteTimeoutException&lt;/tt&gt; was potentially inaccurate (namely, if we timed out in &lt;tt&gt;beginRepairAndPaxos&lt;/tt&gt;, contention leading to that exception would be ignored)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I&apos;ll wait on getting usable CI results to officially mark it &apos;ready to review&apos;, but it is in spirit if anyone is burning to look at this.&lt;/p&gt;</comment>
                            <comment id="17135836" author="slebresne" created="Mon, 15 Jun 2020 13:03:33 +0000"  >&lt;p&gt;I&apos;m only semi-sure how to parse Jenkins CI results these days but from what I can tell, all failures are unrelated so marking ready for review.&lt;/p&gt;</comment>
                            <comment id="17138370" author="slebresne" created="Wed, 17 Jun 2020 11:55:46 +0000"  >&lt;p&gt;I noticed that the previous version of the patches wasn&apos;t working in all cases due to an existing quirk of the CAS implementation.&lt;/p&gt;

&lt;p&gt;Namely, accepted updates that were empty were not replayed by &lt;tt&gt;beginAndRepairPaxos&lt;/tt&gt;. Which is a problem for the new empty commits made during serial reads/non-applying CAS. I added tests to show that if the commit messages for those empty commits were lost/delayed, we could still have linearizability violations.&lt;/p&gt;

&lt;p&gt;Now, the logic of not replaying empty updates looks wrong to me. There shouldn&apos;t be anything special about an empty update, and if one is explicitely accepted by a quorum of nodes, we shouldn&apos;t ignore it, or that&apos;s a break of the Paxos algorithm (as kind of can be demonstrated by the tests I added).&lt;/p&gt;

&lt;p&gt;To be clear, that logic was added &lt;b&gt;by me&lt;/b&gt; in &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-6012&quot; title=&quot;CAS does not always correctly replay inProgress rounds&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-6012&quot;&gt;&lt;del&gt;CASSANDRA-6012&lt;/del&gt;&lt;/a&gt; and that was the sole purpose of that ticket. Except that I can&apos;t make sense of my reasoning back then, and since I didn&apos;t included a test to demonstrate the problem I was solving back then (which was wrong, mea culpa), I have to assume that I was just confused (maybe I mixed in my head promised ballots and accepted ones?). Anyway, I think the fix here is simply to remove that bad logic, which fixes the issue, and I included an additional commit for that.&lt;/p&gt;</comment>
                            <comment id="17138439" author="benedict" created="Wed, 17 Jun 2020 13:39:33 +0000"  >&lt;p&gt;So, I&apos;m reasonably sure it cannot be necessary for us to commit an empty proposal, because we do not ever need to witness it.  Either the proposal was agreed by a quorum (and the proposer can report this) but it has no visible effect on future proposals, and does not need to be witnessed by anybody else, or it was not agreed and it does not need to be either proposed again, committed or witnessed by anybody else.&lt;/p&gt;

&lt;p&gt;However we have to be consistent about it: we either need to &lt;em&gt;never&lt;/em&gt; commit them, or &lt;em&gt;always&lt;/em&gt; commit them.&lt;/p&gt;</comment>
                            <comment id="17138455" author="slebresne" created="Wed, 17 Jun 2020 13:53:59 +0000"  >&lt;blockquote&gt;&lt;p&gt;I&apos;m reasonably sure it cannot be necessary for us to commit an empty proposal, because we do not ever need to witness it.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;We may have to be precise. We do not need to &quot;apply&quot; an empty commit, since it&apos;s a no-op, and the patch actually ensures we don&apos;t bother. But &quot;committed&quot; do something else, it update the &quot;mrc&quot; value, and &lt;em&gt;that&lt;/em&gt; needs to be done. Otherwise, if we &lt;em&gt;accept&lt;/em&gt; an empty proposal, yet does not update the &quot;mrc&quot; value, we will not do progress anymore (well, without additional modification to the algorithm that is).&lt;/p&gt;

&lt;p&gt;But I could be misunderstanding what you are suggesting here. I&apos;ll note though, just in case that help, that the logic I&apos;m calling faulty is not the &lt;em&gt;commit&lt;/em&gt; of empty updates (though, as said above, I think it&apos;s necessary for the sake of the mrc value), it&apos;s the fact the don&apos;t replay the &lt;em&gt;proposal&lt;/em&gt; of empty updates. &lt;/p&gt;</comment>
                            <comment id="17138464" author="benedict" created="Wed, 17 Jun 2020 14:10:03 +0000"  >&lt;p&gt;The problem here stems only from the overload of &lt;tt&gt;mostRecentInProgressCommitWithUpdate&lt;/tt&gt;, which (seems to) assume that an empty update is for a higher promise (since the meaning is overloaded in the response message) rather than an &quot;incomplete&quot; proposal. If the empty proposal were to be correctly merged with &lt;tt&gt;mostRecentInProgressCommitWithUpdate&lt;/tt&gt;, it would override the early non-empty incomplete proposal.&lt;/p&gt;

&lt;p&gt;Which is a long-winded way of saying that I am fairly confident there&apos;s no need to update the paxos state table with the &quot;committed&quot; status of this empty proposal so long as it remains in the table &lt;em&gt;as an accepted proposal&lt;/em&gt;, and so long as this accepted proposal continues to override earlier in progress proposals.&lt;/p&gt;</comment>
                            <comment id="17138473" author="slebresne" created="Wed, 17 Jun 2020 14:16:49 +0000"  >&lt;p&gt;I&apos;ll have to apologize, but I don&apos;t understand what you are suggesting.&lt;/p&gt;</comment>
                            <comment id="17138503" author="benedict" created="Wed, 17 Jun 2020 14:40:33 +0000"  >&lt;p&gt;I&apos;m not proposing we do anything different for your patch, just clarifying that this isn&apos;t strictly necessary - it is quite possible to modify the algorithm to never commit empty proposals.  The problem today is that we:&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;&quot;Refresh&quot; a quorum with the MRC if not witnessed by all promisers&lt;/li&gt;
	&lt;li&gt;Filter out empty proposals when deciding if we have an in progress proposal (&lt;tt&gt;mostRecentInProgressCommit&lt;/tt&gt; vs &lt;tt&gt;mostRecentInProgressCommitWithUpdate&lt;/tt&gt;)&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;If instead we did not refresh empty commits, and we did not filter out empty proposals when &lt;em&gt;updating&lt;/em&gt; &lt;tt&gt;mostRecentInProgressCommitWithUpdate&lt;/tt&gt; but did not &lt;em&gt;complete&lt;/em&gt; any empty proposals we found then everything would be fine.&lt;/p&gt;

&lt;p&gt;&lt;tt&gt;mostRecentInProgressCommitWithUpdate&lt;/tt&gt; confuses matters because it is poorly named, and is updated by its naming rather than intent - I think it is &lt;em&gt;meant&lt;/em&gt; to be &lt;tt&gt;mostRecentInProgressProposal&lt;/tt&gt; whereas &lt;tt&gt;mostRecentInProgressCommit&lt;/tt&gt; should be e.g. &lt;tt&gt;mostRecentInProgressPromiseOrProposal&lt;/tt&gt;, and &lt;tt&gt;mostRecentInProgressProposal&lt;/tt&gt; would gain empty proposals as well as non-empty ones, and correctly discount the older in progress proposal that was invalidated by the newer read that did not witness it.&lt;/p&gt;

&lt;p&gt;To be clear, I&apos;m mostly participating in this discussion for my own benefit and for the benefit of future work, not trying to solicit changes to your work.&lt;/p&gt;</comment>
                            <comment id="17138536" author="benedict" created="Wed, 17 Jun 2020 15:02:54 +0000"  >&lt;p&gt;To say it another way: the only purpose of an empty proposal is to poison earlier proposals, and this can be done just as well without moving the proposal to the MRC column in the table.  If we treat it as any other &quot;in progress&quot; proposal for invalidating earlier proposals, then once we reach a quorum we must in future be witnessed alongside any earlier proposals and invalidate them.  If we didn&apos;t reach a quorum, then it doesn&apos;t matter if we are witnessed or not, or if any earlier proposals are invalidated.&lt;/p&gt;
</comment>
                            <comment id="17138578" author="slebresne" created="Wed, 17 Jun 2020 15:38:21 +0000"  >&lt;p&gt;Ok, I understand what you are suggesting now and I agree this should work as well. And it does is more optimal.&lt;/p&gt;

&lt;p&gt;I like to think of our algorithm as &quot;pure Paxos instances&quot; separated by the MRC to tell us when we can forget the previous instance and start a new one.  Committing empty updates as any other updates still fits that mental model, while your suggestion adds a bit of a special case in that it bends the Paxos rules slightly, allowing to sometime ignore a previously accepted value in a promise (when it&apos;s empty). Which is not a criticism, just thinking out loud.  It&apos;s more performant and this is likely worth the slight special casing since it&apos;s not too hard to reason about its correctness.&lt;/p&gt;

&lt;p&gt;I&apos;ll sleep on it and modify to your suggestion tomorrow (which is trivial, just need to massage an appropriate comment to explain it).&lt;/p&gt;</comment>
                            <comment id="17140578" author="slebresne" created="Fri, 19 Jun 2020 14:02:27 +0000"  >&lt;p&gt;Alright, my &quot;tomorrow&quot; is off by 1, but pushed an additional commit to implement the optimization suggested by Benedict above. Restarted CI for good measure.&lt;/p&gt;

&lt;div class=&apos;table-wrap&apos;&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;branch&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;CI&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://github.com/pcmanus/cassandra/tree/C-12126-3.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;3.0&lt;/a&gt;&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://ci-cassandra.apache.org/job/Cassandra-devbranch/155/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;Run #155&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://github.com/pcmanus/cassandra/tree/C-12126-3.11&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;3.11&lt;/a&gt;&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://ci-cassandra.apache.org/job/Cassandra-devbranch/156/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;Run #156&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://github.com/pcmanus/cassandra/tree/C-12126-4.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;4.0&lt;/a&gt;&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://ci-cassandra.apache.org/job/Cassandra-devbranch/157/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;Run #157&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;
</comment>
                            <comment id="17220716" author="blerer" created="Mon, 26 Oct 2020 14:02:55 +0000"  >&lt;p&gt;Sorry, for the delay. The patches looks good.&lt;/p&gt;</comment>
                            <comment id="17226643" author="slebresne" created="Thu, 5 Nov 2020 10:58:56 +0000"  >&lt;p&gt;Thanks for the review. I&apos;ve rebased the branches, but since the last runs were a while ago, I restarted CI runs. I&apos;ll commit if those look clean.&lt;/p&gt;

&lt;div class=&apos;table-wrap&apos;&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;branch&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;CI&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://github.com/pcmanus/cassandra/tree/C-12126-3.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;3.0&lt;/a&gt;&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://ci-cassandra.apache.org/job/Cassandra-devbranch/171/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;Run #171&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://github.com/pcmanus/cassandra/tree/C-12126-3.11&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;3.11&lt;/a&gt;&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://ci-cassandra.apache.org/job/Cassandra-devbranch/172/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;Run #172&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://github.com/pcmanus/cassandra/tree/C-12126-4.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;4.0&lt;/a&gt;&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;https://ci-cassandra.apache.org/job/Cassandra-devbranch/173/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;Run #173&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;
</comment>
                            <comment id="17226668" author="benedict" created="Thu, 5 Nov 2020 11:55:47 +0000"  >&lt;p&gt;So, before we commit this I wanted to share that some experimentation found that this can lead to a significant increase in timeouts, particularly for read-heavy workloads, that previously would not have competed with each other. I think committing this to a patch release is honestly problematic, as it could surprise users with a service outage. At the very least, there should be HUGE warnings in &lt;tt&gt;NEWS.txt&lt;/tt&gt;, but honestly I would prefer to have users opt-in for patch releases.&lt;/p&gt;

&lt;p&gt;As much as I agree that it is problematic to provide the wrong semantics, I think it is also problematic to force a decision between stability and correctness onto our users without their informed and positive consent.&lt;/p&gt;

&lt;p&gt;I hope that I will be able to provide the community with an alternative solution in the near future, without these (and many other existing) pitfalls. However I&apos;m not sure how that should affect this decision.&lt;/p&gt;</comment>
                            <comment id="17226714" author="blerer" created="Thu, 5 Nov 2020 13:17:40 +0000"  >&lt;blockquote&gt;&lt;p&gt;I hope that I will be able to provide the community with an alternative solution in the near future, without these (and many other existing) pitfalls.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=benedict&quot; class=&quot;user-hover&quot; rel=&quot;benedict&quot;&gt;benedict&lt;/a&gt; Few questions regarding your comment:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;What timeframe do you have in mind?&lt;/li&gt;
	&lt;li&gt;Is it a solution only for 4.0 or for all the branches?&lt;/li&gt;
	&lt;li&gt;Can we help you with that?&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="17227354" author="benedict" created="Fri, 6 Nov 2020 11:39:42 +0000"  >&lt;p&gt;To some extent that is all up for debate.&lt;/p&gt;


&lt;p&gt; My plan so far has been to avoid interfering with 4.0 release, so I have been working towards targeting 4.x. This would also permit time to produce documentation and reach out to the list to begin the slow handshake to see if the project wants the work, and in what manner. However, the main body of work is essentially complete, so it is possible that this could be brought forwards if there were appetite.&lt;br/&gt;
 As to target version, it would be possible to target 3.0+, at least for a portion of the work that would encompass this issue, without a great deal of work. The project&apos;s appetite would be the main decider, as it&apos;s a significant body of work.&lt;/p&gt;


&lt;p&gt; The main contribution would be a parallel implementation of the same underlying Paxos algorithm, that is able to run concurrently alongside it (supporting live migration), but with several latency improvements, as well as several fixes to correctness. Alongside this is related work to guarantee linearizability across range movements in the form of modifications to repair, bootstrap, replace etc.&lt;/p&gt;


&lt;p&gt; Related to this work are several patches to wider Cassandra to support automated verification of its correctness, by permitting deterministic simulation of Cassandra clusters with adversarial ordering of events. We have so far simulated billions of transactions to verify its linearizability. I anticipate that this work will be useful for the project&apos;s overall goal of improving quality, but they are themselves quite significant and will require their own discussions around timeline and scope.&lt;/p&gt;</comment>
                            <comment id="17227379" author="blerer" created="Fri, 6 Nov 2020 12:42:48 +0000"  >&lt;p&gt;It seem to me that there are several options here:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;Try to use your proposal for 4.0 if the community has the appetite for it. The main issue there is some potential extra delay for 4.0&lt;/li&gt;
	&lt;li&gt;Do nothing for 4.0. Meaning do not commit the patch. We have lived a long time with that issue and we can probably wait a bit more for a proper solution.&lt;/li&gt;
	&lt;li&gt;Commit the patch as such, fixing the correctness but introducting potentially some performance issue until we release a better solution.&lt;/li&gt;
	&lt;li&gt;Changing the patch to default to the current behavior but allowing people to enable the new one if the correctness is a problem for them.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;May be we should trigger a discussion on the mailing list and see what is other people opinion.&lt;/p&gt;

&lt;p&gt;I can take care of that next week if you think it is a good idea.&lt;/p&gt;</comment>
                            <comment id="17227449" author="benedict" created="Fri, 6 Nov 2020 15:24:13 +0000"  >&lt;p&gt;Yes, that sounds like a great idea, and I really appreciate you offering to take that to the list. I&apos;ll chime in with any necessary details to help inform the decision, but will try not to influence it otherwise. I don&apos;t have a strong opinion about which of those four options we select, except that my experiments do suggest (3) is perhaps dangerous for some of our users. It&apos;s probably a trade-off that should be made with careful business consideration and experimentation by each end user.&lt;/p&gt;

&lt;p&gt;As far as delaying 4.0 is concerned, that&apos;s probably also a matter of community decision-making. We could quite quickly have a patch, that has been reviewed by multiple committers, posted in fairly short order - perhaps before we exit beta. This work will have had much greater validation than the current implementation, but publishing all of this validation work will take longer - likely also achievable before GA, but we might have to invert our process a little. Perhaps this is acceptable, given the balance of correctness and regression we&apos;re considering as an alternative, but given my proximity to the work (and that I also don&apos;t have a strong position either way), I would prefer to let others make that call.&lt;/p&gt;</comment>
                            <comment id="17239769" author="slebresne" created="Fri, 27 Nov 2020 16:18:29 +0000"  >&lt;p&gt;Committed following the dev mailing list discussion. Thanks.&lt;/p&gt;</comment>
                            <comment id="17241218" author="feeblefakie" created="Tue, 1 Dec 2020 02:50:18 +0000"  >&lt;p&gt;&amp;gt; 3) Issue another CAS Read and it goes to A and B. Now we will discover that there is something inflight from A and will propose and commit it with the current ballot. Now we can read the value written in step 1 as part of this CAS read.&lt;/p&gt;

&lt;p&gt;Sorry, I&apos;m not fully sure about the current implementation and how realistic my proposal is but,&lt;/p&gt;

&lt;p&gt;can we read all the replicas to do the read recovery in step 3 to solve the issue?&lt;/p&gt;

&lt;p&gt;It only reads A and B but if we read C as well, we know that the proposal is not accepted by the majority.&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;</comment>
                            <comment id="17241347" author="blerer" created="Tue, 1 Dec 2020 08:40:50 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=feeblefakie&quot; class=&quot;user-hover&quot; rel=&quot;feeblefakie&quot;&gt;feeblefakie&lt;/a&gt; C can be unreachable for different reasons.&lt;/p&gt;</comment>
                            <comment id="17315894" author="vsilgalis" created="Tue, 6 Apr 2021 23:51:46 +0000"  >&lt;p&gt;Just a note that the bug that this fixes usually pops up as the following timeout for people looking for reasons why SERIAL or LOCAL_SERIAL are seeing read timeouts &amp;gt;3.11.10.&#160; Setting the flag to the opt-out option will `fix` it but probably shouldn&apos;t be reading at this level if you run into this.&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
! com.datastax.driver.core.exceptions.ReadTimeoutException: Cassandra timeout during read query at consistency LOCAL_SERIAL (2 responses were required but only 0 replica responded)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12313920" key="com.atlassian.jira.plugin.system.customfieldtypes:multiuserpicker">
                        <customfieldname>Authors</customfieldname>
                        <customfieldvalues>
                                    <customfieldvalue><![CDATA[slebresne]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12313821" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Complexity</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="12965"><![CDATA[Normal]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            4 years, 31 weeks, 6 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i30fzz:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12313420" key="com.atlassian.jira.plugin.system.customfieldtypes:multiuserpicker">
                        <customfieldname>Reviewers</customfieldname>
                        <customfieldvalues>
                                    <customfieldvalue><![CDATA[blerer]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12313820" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Severity</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="12962"><![CDATA[Normal]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12311420" key="com.atlassian.jira.plugin.system.customfieldtypes:version">
                        <customfieldname>Since Version</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue id="12324629">2.0.0</customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313924" key="com.atlassian.jira.plugin.system.customfieldtypes:textfield">
                        <customfieldname>Source Control Link</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>&lt;p&gt;&lt;a href=&quot;https://github.com/apache/cassandra/commit/2d0b16804785660e8515aca9944784fb3733c619&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;3.0&lt;/a&gt;, &lt;a href=&quot;https://github.com/apache/cassandra/commit/080280dc0177da6176dd4ba970e5a35aa7e2a729&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;3.11&lt;/a&gt;, &lt;a href=&quot;https://github.com/apache/cassandra/commit/9a3ca008bad2a7bfa887a&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;4.0&lt;/a&gt;&lt;/p&gt;</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12313823" key="com.atlassian.jira.plugin.system.customfieldtypes:textarea">
                        <customfieldname>Test and Documentation Plan</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>&lt;p&gt;Included in-jvm dtests&lt;/p&gt;</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                </customfields>
    </item>
</channel>
</rss>