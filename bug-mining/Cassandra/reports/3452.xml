<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 22:51:45 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[CASSANDRA-9060] Anticompaction hangs on bloom filter bitset serialization</title>
                <link>https://issues.apache.org/jira/browse/CASSANDRA-9060</link>
                <project id="12310865" key="CASSANDRA">Apache Cassandra</project>
                    <description>&lt;p&gt;I tried running an incremental repair against a 15-node vnode-cluster with roughly 500GB data running on 2.1.3-SNAPSHOT, without performing the suggested migration steps. I manually chose a small range for the repair (using --start/end-token). The actual repair part took almost no time at all, but the anticompactions took a lot of time (not surprisingly).&lt;/p&gt;

&lt;p&gt;Obviously, this might not be the ideal way to run incremental repairs, but I wanted to look into what made the whole process so slow. The results were rather surprising. The majority of the time was spent serializing bloom filters.&lt;/p&gt;

&lt;p&gt;The reason seemed to be two-fold. First, the bloom-filters generated were huge (probably because the original SSTables were large). With a proper migration to incremental repairs, I&apos;m guessing this would not happen. Secondly, however, the bloom filters were being written to the output one byte at a time (with quite a few type-conversions on the way) to transform the little-endian in-memory representation to the big-endian on-disk representation.&lt;/p&gt;

&lt;p&gt;I have implemented a solution where big-endian is used in-memory as well as on-disk, which obviously makes de-/serialization much, much faster. This introduces some slight overhead when checking the bloom filter, but I can&apos;t see how that would be problematic. An obvious alternative would be to still perform the serialization/deserialization using a byte array, but perform the byte-order swap there.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12786310">CASSANDRA-9060</key>
            <summary>Anticompaction hangs on bloom filter bitset serialization</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="10003" iconUrl="https://issues.apache.org/jira/images/icons/priorities/trivial.svg">Low</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="grddev">Gustav Munkby</assignee>
                                    <reporter username="grddev">Gustav Munkby</reporter>
                        <labels>
                    </labels>
                <created>Fri, 27 Mar 2015 19:35:34 +0000</created>
                <updated>Tue, 16 Apr 2019 09:31:16 +0000</updated>
                            <resolved>Wed, 6 May 2015 16:31:15 +0000</resolved>
                                        <fixVersion>2.1.5</fixVersion>
                                        <due></due>
                            <votes>0</votes>
                                    <watches>3</watches>
                                                                                                                <comments>
                            <comment id="14385203" author="benedict" created="Sat, 28 Mar 2015 09:10:44 +0000"  >&lt;p&gt;It looks like the problem is really that we don&apos;t buffer the output. I&apos;m not sure it makes sense to go modifying the BF code itself, when a simpler fix is available.&lt;/p&gt;</comment>
                            <comment id="14385215" author="grddev" created="Sat, 28 Mar 2015 09:56:45 +0000"  >&lt;p&gt;While I find the current logic where data is wrapped/unwrapped into longs a bit confusing, I certainly understand the motivation to keep the changes to a minimum. I&apos;m not knowledgable enough about the Cassandra codebase to figure out the appropriate way to implement this. Right now, the output stream is a DataOutputStreamAndChannel created from a FileOutputStream. Is the appropriate solution to inject a BufferedOutputStream here, or do you mean something completely different?&lt;/p&gt;

&lt;p&gt;Looking back at the bigger problem, I think real problem might be the size of the bloom filters. If I understand CompactionManager.doAntiCompaction right, it seems to size the Bloom Filter given the assumption that we are doing a compaction (rather than an anticompaction). Thus, the expected number of keys is computed as an aggregate over all tables, but in the anticompaction case, the size of &quot;the other&quot; tables should not really matter, right?&lt;/p&gt;</comment>
                            <comment id="14385290" author="benedict" created="Sat, 28 Mar 2015 13:03:37 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-8670&quot; title=&quot;Large columns + NIO memory pooling causes excessive direct memory usage&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-8670&quot;&gt;&lt;del&gt;CASSANDRA-8670&lt;/del&gt;&lt;/a&gt; will give the best option for this, but in the meantime (I think this fix should go into 2.1, personally, since it is trivial and likely to have significant impact - it&apos;s kind of amazing this oversight has gone unnoticed for so long, so thanks for pointing it out). &lt;/p&gt;

&lt;p&gt;Looking at it, I&apos;m not at all convinced by the wrapping/unwrapping of the longs either, since our DataOutput implementations all just convert the writeLong() into a series of write(byte) calls. But the simplest, least invasive solution to this, is to indeed pass a BufferedOutputStream() into a DataOutputStreamPlus, rather than constructing a DataOutputStreamAndChannel. For 2.1 I think we should make this tiny change. &lt;/p&gt;

&lt;p&gt;For 3.0, I think we should wait for &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-8670&quot; title=&quot;Large columns + NIO memory pooling causes excessive direct memory usage&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-8670&quot;&gt;&lt;del&gt;CASSANDRA-8670&lt;/del&gt;&lt;/a&gt; and think through the wrapping/unwrapping of long business, and see if there is a clearer route. Perhaps version bump, so we can simply stream the raw bytes to disk without any conversion, since that makes the most sense - there&apos;s no reason to be flipping bytes whatsoever here, since we always index into the data by byte. If we want to maintain serialization format, we could buffer segments of the filter into a ByteBuffer/Memory object, and use Long.reverseBytes() prior to flushing that buffered data to disk. On reading we could populate the entire bitset, then iterate through reversing the bytes as we go. I would prefer to see the on disk representation match the in-memory though.&lt;/p&gt;

&lt;p&gt;As to the antiCompaction calculation, that isn&apos;t my area but your conclusion seems reasonable to me. Taking a look at the code, it seems we would need to somehow correct for the ratio of each sstable we expect to be on each side of the range, which might lead to one side obtaining a worse than expected fp, with the other obtaining a better. Whereas right now both receive significantly better false positive ratios. I&apos;m not sure how effectively we could better deal with this (at least without a bit more research effort and thought). &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=krummas&quot; class=&quot;user-hover&quot; rel=&quot;krummas&quot;&gt;krummas&lt;/a&gt;?&lt;/p&gt;</comment>
                            <comment id="14385498" author="krummas" created="Sat, 28 Mar 2015 19:37:51 +0000"  >&lt;p&gt;yeah we should fix the bloom filter size estimations before starting the anticompaction&lt;/p&gt;

&lt;p&gt;assigning to me for that&lt;/p&gt;</comment>
                            <comment id="14385735" author="benedict" created="Sun, 29 Mar 2015 12:20:15 +0000"  >&lt;p&gt;I&apos;ve split the slow serialization problem out into &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-9066&quot; title=&quot;BloomFilter serialization is inefficient&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-9066&quot;&gt;&lt;del&gt;CASSANDRA-9066&lt;/del&gt;&lt;/a&gt;, since the problem of anti-compaction mispredicting the number of rows can at worst halve performance, whereas the slow serialization could have an order of magnitude impact. &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=grddev&quot; class=&quot;user-hover&quot; rel=&quot;grddev&quot;&gt;grddev&lt;/a&gt;: do you want to have a stab at that ticket?&lt;/p&gt;</comment>
                            <comment id="14385767" author="grddev" created="Sun, 29 Mar 2015 13:30:46 +0000"  >&lt;p&gt;Regarding the size of the Bloom filters, I think the immediate problem is that they are created to allow room for all keys in all anticompacted tables, whereas anticompactions process one table at a time. I&apos;ve added a patch, which I believe does exactly that. Given that this change is fairly small, I targeted it at 2.1.&lt;/p&gt;

&lt;p&gt;As the keys are going to be distributed over the two resulting tables, in the ideal world we might want to have much smaller bloom filters on either side than what we initially thought. I&apos;m guessing this is a general problem with compactions, but the HyperLogLog cardinality estimators should help in the normal case.&lt;/p&gt;

&lt;p&gt;For the general case of ensuring the Bloom filters are not too large, I can see basically two solutions. Either introduce a scanning phase before the actual compaction, where the size of the bloom filter(s) are calculated. Or reduce the size of the Bloom filter once compaction has completed. The obvious implementation of the latter would be to scan through the compacted index, possibly gated by a comparison of the index size and the bloom filter size.&lt;/p&gt;

&lt;p&gt;I guess scanning through the index could be avoided by making sure that the IndexWriter kept track of multiple Bloom-filters of exponentially growing sizes. That way, once the index is complete, the most appropriate Bloom-filter could be picked and written to disk, discarding the others.&lt;/p&gt;</comment>
                            <comment id="14385804" author="benedict" created="Sun, 29 Mar 2015 15:07:38 +0000"  >&lt;blockquote&gt;&lt;p&gt;I think the immediate problem is that they are created to allow room for all keys in all anticompacted tables, whereas anticompactions process one table at a time&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Thanks. You&apos;re right., and this is definitely something to fix in 2.1&lt;/p&gt;

&lt;p&gt;In this instance we don&apos;t use HLL cardinality estimators, but the index summary, which isn&apos;t probabilistic. What it is, however, is only accurate to a certain granularity. As a first patch your approach reduces the problem to the one I initially assumed it was, i.e. a doubling of required space (instead of &amp;#42;N), but with a small amount of TLC the estimatedKeysForRanges() method could be modified to give a lower bound for the size of both resultant tables (at the moment it can significantly over estimate in some scenarios, but also cannot easily estimate the cardinality of the negation of the range - so we would have to subtract the overestimation, giving an underestimate which is much worse).&lt;/p&gt;

&lt;p&gt;Your patch looks to me to significantly improve the status quo, so I will commit it now, and we can address a slightly improved patch for perhaps 2.1.5&lt;/p&gt;</comment>
                            <comment id="14385821" author="benedict" created="Sun, 29 Mar 2015 15:25:11 +0000"  >&lt;p&gt;I&apos;ve committed your patch to 2.1. 3.0 looks to already behave approximately equivalently to the behaviour introduced by this patch due to the use of HLL cardinality estimation, but both could do with estimating a better lower bound on the occupancy of each side of the result.&lt;/p&gt;</comment>
                            <comment id="14385826" author="benedict" created="Sun, 29 Mar 2015 15:35:28 +0000"  >&lt;p&gt;Filed &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-9068&quot; title=&quot;AntiCompaction should calculate a more accurate lower bound on bloom filter size for each target&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-9068&quot;&gt;CASSANDRA-9068&lt;/a&gt; as a follow up&lt;/p&gt;</comment>
                            <comment id="14386263" author="krummas" created="Mon, 30 Mar 2015 06:21:52 +0000"  >&lt;p&gt;attaching another small tweak to this&lt;/p&gt;</comment>
                            <comment id="14386320" author="grddev" created="Mon, 30 Mar 2015 07:39:07 +0000"  >&lt;p&gt;I might be horribly mistaken, but my reading of estimatedKeysForRanges in SSTableReader is that it is based on the number of keys that are definitely in the range, given the sample in the index summary. Thus the estimate should be guaranteed to be an under-approximation.&lt;/p&gt;

&lt;p&gt;If my understanding above is correct, it seems the repaired table would typically have a too small Bloom filter with the added tweak. Similarly, the unrepaired table will typically have a slightly too big Bloom filter. Given that the Bloom filter is only an optimisation, I&apos;m not sure either of those things really matter that much. I guess it depends on whether any other pieces of the code assume the Bloom-filter sizes to be over- or under sized.&lt;/p&gt;</comment>
                            <comment id="14386417" author="benedict" created="Mon, 30 Mar 2015 08:57:38 +0000"  >&lt;blockquote&gt;&lt;p&gt;If my understanding above is correct, it seems the repaired table would typically have a too small Bloom filter with the added tweak&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Agreed. I filed &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-9068&quot; title=&quot;AntiCompaction should calculate a more accurate lower bound on bloom filter size for each target&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-9068&quot;&gt;CASSANDRA-9068&lt;/a&gt; to address this as a follow up. Depending on how many ranges are provided, and how they overlap with the index summary, it is possible for the over-estimation to yield a value greater than the no-args estimatedKeys(), which I think we should also address (or if we know for sure the range collection provided won&apos;t ever suffer this problem significantly, we could comment this fact).&lt;/p&gt;</comment>
                            <comment id="14530295" author="benedict" created="Wed, 6 May 2015 10:21:00 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=grddev&quot; class=&quot;user-hover&quot; rel=&quot;grddev&quot;&gt;grddev&lt;/a&gt; apologies for dropping the ball on this. it&apos;s a busy time as we ramp up to 3.0, and my workflow ignores tickets I&apos;m reviewing that aren&apos;t marked &apos;Patch Available&apos;. I&apos;ll see if we can get this integrated in the near future; it&apos;s a shame we missed 2.1.5.&lt;/p&gt;</comment>
                            <comment id="14530829" author="benedict" created="Wed, 6 May 2015 16:31:15 +0000"  >&lt;p&gt;It looks like I already committed this, and just forgot to update the ticket. Sorry for the confusion!&lt;/p&gt;</comment>
                            <comment id="14535255" author="aweisberg" created="Fri, 8 May 2015 18:53:45 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=krummas&quot; class=&quot;user-hover&quot; rel=&quot;krummas&quot;&gt;krummas&lt;/a&gt; Did this only happen because of the upgrade or is there a workload/data model we should be testing anti-compaction with?&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12708092" name="0001-another-tweak-to-9060.patch" size="4260" author="marcuse" created="Mon, 30 Mar 2015 06:22:09 +0000"/>
                            <attachment id="12708042" name="2.1-9060-simple.patch" size="2464" author="grddev" created="Sun, 29 Mar 2015 13:29:58 +0000"/>
                            <attachment id="12707861" name="trunk-9060.patch" size="4858" author="grddev" created="Fri, 27 Mar 2015 19:39:20 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>3.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12313920" key="com.atlassian.jira.plugin.system.customfieldtypes:multiuserpicker">
                        <customfieldname>Authors</customfieldname>
                        <customfieldvalues>
                                    <customfieldvalue><![CDATA[grddev]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            10 years, 28 weeks, 4 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i27gxz:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_10022" key="com.atlassian.jira.plugin.system.customfieldtypes:userpicker">
                        <customfieldname>Reviewer</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>benedict</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12313420" key="com.atlassian.jira.plugin.system.customfieldtypes:multiuserpicker">
                        <customfieldname>Reviewers</customfieldname>
                        <customfieldvalues>
                                    <customfieldvalue><![CDATA[benedict]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12313820" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Severity</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="12961"><![CDATA[Low]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>