<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 23:16:06 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[CASSANDRA-8272] 2ndary indexes can return stale data</title>
                <link>https://issues.apache.org/jira/browse/CASSANDRA-8272</link>
                <project id="12310865" key="CASSANDRA">Apache Cassandra</project>
                    <description>&lt;p&gt;When replica return 2ndary index results, it&apos;s possible for a single replica to return a stale result and that result will be sent back to the user, potentially failing the CL contract.&lt;/p&gt;

&lt;p&gt;For instance, consider 3 replicas A, B and C, and the following situation:&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;CREATE TABLE test (k int PRIMARY KEY, v text);
CREATE INDEX ON test(v);
INSERT INTO test(k, v) VALUES (0, &apos;foo&apos;);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;with every replica up to date. Now, suppose that the following queries are done at &lt;tt&gt;QUORUM&lt;/tt&gt;:&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;UPDATE test SET v = &apos;bar&apos; WHERE k = 0;
SELECT * FROM test WHERE v = &apos;foo&apos;;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;then, if A and B acknowledge the insert but C respond to the read before having applied the insert, then the now stale result will be returned (since C will return it and A or B will return nothing).&lt;/p&gt;

&lt;p&gt;A potential solution would be that when we read a tombstone in the index (and provided we make the index inherit the gcGrace of it&apos;s parent CF), instead of skipping that tombstone, we&apos;d insert in the result a corresponding range tombstone.  &lt;/p&gt;</description>
                <environment></environment>
        <key id="12753516">CASSANDRA-8272</key>
            <summary>2ndary indexes can return stale data</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="10002" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.svg">Normal</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="adelapena">Andres de la Pe&#241;a</assignee>
                                    <reporter username="slebresne">Sylvain Lebresne</reporter>
                        <labels>
                            <label>pull-request-available</label>
                    </labels>
                <created>Thu, 6 Nov 2014 21:22:33 +0000</created>
                <updated>Tue, 14 Oct 2025 12:13:56 +0000</updated>
                            <resolved>Fri, 5 Jun 2020 12:27:38 +0000</resolved>
                                        <fixVersion>3.0.21</fixVersion>
                    <fixVersion>3.11.7</fixVersion>
                    <fixVersion>4.0-beta1</fixVersion>
                    <fixVersion>4.0</fixVersion>
                                    <component>Feature/2i Index</component>
                        <due></due>
                            <votes>1</votes>
                                    <watches>18</watches>
                                                    <progress percentage="100">
                                    <originalProgress>
                                                    <row percentage="0" backgroundColor="#89afd7"/>
                                                    <row percentage="100" backgroundColor="transparent"/>
                                            </originalProgress>
                                                    <currentProgress>
                                                    <row percentage="100" backgroundColor="#51a825"/>
                                                    <row percentage="0" backgroundColor="#ec8e00"/>
                                            </currentProgress>
                            </progress>
                                    <aggregateprogress percentage="100">
                                    <originalProgress>
                                                    <row percentage="0" backgroundColor="#89afd7"/>
                                                    <row percentage="100" backgroundColor="transparent"/>
                                            </originalProgress>
                                                    <currentProgress>
                                                    <row percentage="100" backgroundColor="#51a825"/>
                                                    <row percentage="0" backgroundColor="#ec8e00"/>
                                            </currentProgress>
                            </aggregateprogress>
                                            <timeestimate seconds="0">0h</timeestimate>
                            <timespent seconds="25200">7h</timespent>
                                <comments>
                            <comment id="14200985" author="jbellis" created="Thu, 6 Nov 2014 21:41:29 +0000"  >&lt;p&gt;Tagging 2.1.3 rather than earlier based on the reasoning that since this has been around since 2i was added in 0.7 with nobody hitting it in the wild, it must not be a very common occurrence.&lt;/p&gt;</comment>
                            <comment id="15981476" author="adelapena" created="Mon, 24 Apr 2017 16:36:20 +0000"  >&lt;p&gt;If we send a &lt;tt&gt;RangeTombstoneMarker&lt;/tt&gt; each time we find a deleted index entry, the coordinator will be able to discard the false positives returned the stale node. The problem is that read repair will send back the tombstones to the nodes, corrupting not only the index but also the indexed table. Possible solutions could be to disable read repair for index queries or sending a new type of tombstone that read repair would ignore. &lt;/p&gt;

&lt;p&gt;As an alternative solution, the index could return also the rows pointed by the deleted index entries, without any information about the staleness of the index entries, and use &lt;tt&gt;Index.postProcessorFor(ReadCommand)&lt;/tt&gt; to discard those rows that doesn&apos;t satisfy the index expression after reconcilliation. This would solve the consistency problem without any changes in read repair, or in the coordinator in general. The downside is that we should read in the base table, and possibly send, all the rows pointed by deleted index entries satisfying the expression since last gc. &lt;/p&gt;

&lt;p&gt;I&apos;m working in this last approach here:&lt;/p&gt;

&lt;div class=&apos;table-wrap&apos;&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;&lt;a href=&quot;https://github.com/apache/cassandra/compare/cassandra-3.0...adelapena:8272-3.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;3.0&lt;/a&gt;&lt;/th&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;http://cassci.datastax.com/view/Dev/view/adelapena/job/adelapena-8272-3.0-testall/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;utests&lt;/a&gt;&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;http://cassci.datastax.com/view/Dev/view/adelapena/job/adelapena-8272-3.0-dtest/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;dtests&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;


&lt;p&gt;The patch is still uncomplete, I&apos;m posting it just to illustrate the approach. I have not yet added dtests for the scenario described by this ticket, although I&apos;ve tried it manually, and existing dtests pass. &lt;/p&gt;

&lt;p&gt;&lt;tt&gt;PartitionRangeReadCommand&lt;/tt&gt; overrides &lt;tt&gt;ReadCommand.executeInternal(ReadOrderGroup)&lt;/tt&gt; to use the index post-processor, that now is required to let the index clean the stale entries.&lt;/p&gt;</comment>
                            <comment id="15984553" author="adelapena" created="Wed, 26 Apr 2017 10:33:43 +0000"  >&lt;p&gt;And &lt;a href=&quot;https://github.com/riptano/cassandra-dtest/compare/master...adelapena:CASSANDRA-8272&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;here are the dtests&lt;/a&gt; reproducing the problem. They use 2 replicas instead of 3. Updates use consistency &lt;tt&gt;ONE&lt;/tt&gt;, and byteman is used in one of the two nodes to simulate a long latency during index updates. Insertions and selections use consistency &lt;tt&gt;ALL&lt;/tt&gt;.&lt;/p&gt;

&lt;p&gt;Cassandra 2.1 doesn&apos;t use byteman so, if we are going to fix this version, we could either add the byteman dependency to 2.1 or modify &lt;a href=&quot;https://github.com/pcmanus/ccm/blob/master/ccmlib/node.py#L1609&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;the way ccm loads the byteman jars&lt;/a&gt;.&lt;/p&gt;</comment>
                            <comment id="16006245" author="sbtourist" created="Thu, 11 May 2017 11:08:31 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=adelapena&quot; class=&quot;user-hover&quot; rel=&quot;adelapena&quot;&gt;adelapena&lt;/a&gt;, I gave a first review pass and the approach looks sensible, so +1 on that.&lt;/p&gt;

&lt;p&gt;Unfortunately, the problem is actually quite subtle and there are at least a couple cases where it doesn&apos;t fully work.&lt;/p&gt;

&lt;p&gt;First of all, when a &lt;tt&gt;LIMIT&lt;/tt&gt; clause is provided, the query might return no results when there actually are some valid ones: this is because the rows returned as a result of an &quot;index mismatch&quot; are still counted against the limit (by &lt;tt&gt;CQLCounter&lt;/tt&gt;), which means the coordinator might end up with less valid rows than the requested limit, simply because some replicas returned only mismatched rows. Here&apos;s a simple scenario with two nodes:&lt;br/&gt;
1) Write row &lt;tt&gt;key=1,index=1&lt;/tt&gt;.&lt;br/&gt;
2) Write row &lt;tt&gt;key=2,index=1&lt;/tt&gt;.&lt;br/&gt;
3) Shutdown node 2.&lt;br/&gt;
4) Delete column &lt;tt&gt;index&lt;/tt&gt; from row &lt;tt&gt;key=1&lt;/tt&gt;: the delete will go to node 1, while node 2 will miss it.&lt;br/&gt;
5) Restart node 2 (hints need to be disabled).&lt;br/&gt;
6) Query for &lt;tt&gt;index=1&lt;/tt&gt;.&lt;br/&gt;
7) Node 1 will return the first row found, i.e. the &quot;mismatched&quot; one &lt;tt&gt;key=1&lt;/tt&gt;.&lt;br/&gt;
8) Node 2 will return the &quot;missed delete&quot; with &lt;tt&gt;key=1&lt;/tt&gt;.&lt;br/&gt;
9) Coordinator will merge/post-process the rows, realize there&apos;s a mismatch and return no results, while it should have instead returned &lt;tt&gt;key=2&lt;/tt&gt;.&lt;/p&gt;

&lt;p&gt;Second, this patch doesn&apos;t fix filtering; while it&apos;s true we have a different issue for that (&lt;tt&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-8273&quot; title=&quot;Allow filtering queries can return stale data&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-8273&quot;&gt;&lt;del&gt;CASSANDRA-8273&lt;/del&gt;&lt;/a&gt;&lt;/tt&gt;), and while we could argue filtering isn&apos;t exactly a form of indexing, it is still used in conjunction with indexing, and fixing indexing just to have its results invalidated when filtering is applied seems quite confusing to me.&lt;/p&gt;

&lt;p&gt;In the end, I&apos;d suggest the following:&lt;br/&gt;
1) Stick with the current approach! It&apos;s good and I do not think using special tombstones would buy us anything.&lt;br/&gt;
2) Fix the first problem above.&lt;br/&gt;
3) Generalize the approach so we can fix filtering and any other indexing implementation (most notably SASI).&lt;br/&gt;
4) To ease the burden of porting between versions, and given this is not a trivial bug fix at all, I&apos;d also suggest to only apply it to 3.11 onwards.&lt;/p&gt;

&lt;p&gt;Thoughts?&lt;/p&gt;</comment>
                            <comment id="16006297" author="sbtourist" created="Thu, 11 May 2017 11:59:48 +0000"  >&lt;p&gt;One more thing I&apos;m realizing we should fix is paging, which seems broken in a similar way to limiting: that is, if the page size is less than the number of mismatched rows we might end up going through &quot;empty&quot; pages until we get to the valid results.&lt;/p&gt;</comment>
                            <comment id="16006428" author="slebresne" created="Thu, 11 May 2017 13:34:37 +0000"  >&lt;blockquote&gt;&lt;p&gt;1) Stick with the current approach! It&apos;s good and I do not think using special tombstones would buy us anything.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It would solve the &lt;tt&gt;LIMIT&lt;/tt&gt; issue for instance. It&apos;s also theoretically a bit more efficient as won&apos;t ship full rows to the coordinator that it end up discarding.&lt;/p&gt;

&lt;p&gt;Not that I&apos;m suggesting we use special tombstones: thinking about it more I think it&apos;s actually broken in some cases where we delete/re-insert an entry in rapid succession. Basically, the deletion could end up deleting a valid entry post-re-insert if one of the node haven&apos;t seen that re-insert yet.&lt;/p&gt;

&lt;p&gt;Besides, the &lt;tt&gt;LIMIT&lt;/tt&gt; issue isn&apos;t that hard to fix and the performance impact is unlikely big in most cases. But my main point is that on principle we should be careful to look at the whole solution before comparing it to alternatives and deciding which one we &quot;stick with&quot;. I&apos;ve seen simple solutions get pretty messy once you fix all edge cases to the point that it wasn&apos;t the best solution anymore.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;3) Generalize the approach so we can fix filtering&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I wouldn&apos;t make that a requirement to commit this ticket. Filtering is genuinely orthogonal to indexing: it&apos;s as valid to use with and without indexing, and the code for both is mainly orthogonal. It&apos;s in particular not true that fixing this bug will be &quot;invalidated when filtering is applied&quot;, especially when 2i is used but filtering isn&apos;t (hopefully the most common case in production since filtering is what it is).&lt;/p&gt;

&lt;p&gt;Don&apos;t get wrong, both problems are certainly related, in that the underlying problem is that replica can return stale data where up-to-date replica don&apos;t return anything to indicate this is stale.&lt;/p&gt;

&lt;p&gt;But in the indexing cases, we have more information in that we have the index tombstones to know what entries might be stale on another node, so we know &lt;b&gt;a relatively minimal&lt;/b&gt; set of info (rows) to return to &quot;fix&quot; potentially stale entries from other replica.&lt;/p&gt;

&lt;p&gt;In the filtering case, we don&apos;t have similar information to help[1]: the equivalent to the solution from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=adelapena&quot; class=&quot;user-hover&quot; rel=&quot;adelapena&quot;&gt;adelapena&lt;/a&gt;&apos;s patch is to say that when a replica sees a row they should filter out, they still return it in case it may be needed to &quot;fix&quot; a stale replica. But doing so exactly amounts to not doing any filtering replica-side and moving it all server-side, which is what I&apos;m suggesting in &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-8273&quot; title=&quot;Allow filtering queries can return stale data&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-8273&quot;&gt;&lt;del&gt;CASSANDRA-8273&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In other words, this ticket has a mostly-replica-side based solution but the filtering one probably doesn&apos;t. That&apos;s enough difference imo to not wed ourselves to fixing both problems in the same ticket, and to keep discussion around filtering on &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-8273&quot; title=&quot;Allow filtering queries can return stale data&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-8273&quot;&gt;&lt;del&gt;CASSANDRA-8273&lt;/del&gt;&lt;/a&gt; (doesn&apos;t mean we can&apos;t cross-reference of course when appropriate).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;and any other indexing implementation (most notably SASI)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That I agree is something we should consider. Though tbh, I have doubts we can have a solution that is completely index agnostic. What we need is that indexes return any entries that &lt;em&gt;was&lt;/em&gt; recently valid but isn&apos;t anymore (up to gc_grace) so that the result from any replica having the old entry can be properly reconciled and skipped. That has to be something the index implementation itself provides to us, and the best we can do is simply specify that index implementations have to do that to be correct. Though I suspect not all custom index implementations will be able to provided that at all in practice.&lt;/p&gt;

&lt;p&gt;Don&apos;t know about SASI in particular though. I assume it kind of has to keep tombstones for old entries in the first place (not sure how it handles deletes otherwise) and if so, we should certainly update it to implement the new requirement described above.&lt;/p&gt;

&lt;p&gt;There is the question of the &lt;tt&gt;LIMIT&lt;/tt&gt; problem. I think the proper way to fix that is to create a new &lt;tt&gt;DataLimits&lt;/tt&gt; that keep the &lt;tt&gt;RowFilter&lt;/tt&gt; around and that doesn&apos;t count entries that don&apos;t match it (which will have a small cost btw, but I don&apos;t see an easy way out). In which case, any &quot;normal&quot; CQL expression will be covered and that will include SASI for this particular part. For custom expressions however, we currently unfornately have &lt;tt&gt;RowFilter.CustomExpression#isSatisfiedBy()&lt;/tt&gt; always return &lt;tt&gt;true&lt;/tt&gt; currently, so we&apos;d have to make that method abstract and require index using custom expressions to implement it (which is, strictly speaking, a breaking change and implies 4.0 at this point; more on that below).&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;I&apos;d also suggest to only apply it to 3.11 onwards&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;One thing that hasn&apos;t been mentioned is that the fix has impact on upgrades. Namely, in a mixed cluster, some replica will start to return invalid results and if the coordinator isn&apos;t upgraded yet, it won&apos;t filter those, which means we&apos;ll return invalid entries. More precisely, we may return up-to-date data but that doesn&apos;t match the request at all, and I would argue that it&apos;s a more serious problem that the one we&apos;re actually fixing here (returning slightly stale data but that do match the query). Also, during the upgrade window, I suspect it&apos;s much more likely to happen than this bug is in the first place. So I&apos;d argue that during upgrade, the cure is way worst than the disease[2].&lt;/p&gt;

&lt;p&gt;Anyway, that&apos;s a problem to consider and ideally we&apos;d want to avoid it. That does mean we should consider starting to filter entries on index queries coordinator-side in 3.0/3.11 (even though we never return them), and only do the replica-side parts in 4.0, with a fat warning that you need to only upgrade to 4.0 from a 3.X version that has the coordinator-side fix.&lt;/p&gt;

&lt;p&gt;Worth noting that this doesn&apos;t entirely fly for index using custom indexes: we&apos;d need to have them implement the &lt;tt&gt;CustomExpression#isSatistiedBy&lt;/tt&gt; method in 3.X in that scheme since we need it for the coordinator-side filtering as well, but making that method abstract in 3.X is, as said above, a breaking change. So we might want to only make the method abstract in 4.0, but add another fat warning that custom index should consider overriding the method in 3.X so later upgrades are correct (unless the index implementation can&apos;t implement the new requirement I expressed above, in which case they can change nothing and stay about as broken as they are now, which could be a trade-off).&lt;/p&gt;

&lt;p&gt;[1]: we could have it if we were to keep historical values on updates for a while, but that&apos;s a &lt;em&gt;massive&lt;/em&gt; change and is thus a no-go since we&apos;re talking about fixing filtering, which is something we decourage in production in the first place.&lt;br/&gt;
[2]: to the best of my knowledge (and we&apos;ve been aware of this problem for a while, so we&apos;d have likely noticed), no user actually reported this problem. It certainly doesn&apos;t mean that no-one has hit it, and in fact I&apos;m sure some have, but it means it&apos;s rare enough and his consequence mild enough that no-one noticed (or not enough to report it). After all, we only return stale entries for a tiny window and I don&apos;t think user rely on 2i consistency &lt;em&gt;that&lt;/em&gt; seriously (gut guess admitedly).&lt;/p&gt;
</comment>
                            <comment id="16006545" author="sbtourist" created="Thu, 11 May 2017 14:40:29 +0000"  >&lt;blockquote&gt;&lt;p&gt;my main point is that on principle we should be careful to look at the whole solution before comparing it to alternatives and deciding which one we &quot;stick with&quot;. I&apos;ve seen simple solutions get pretty messy once you fix all edge cases to the point that it wasn&apos;t the best solution anymore.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Of course. And I indeed gave some thoughts on my own to the tombstones solution (as I&apos;m sure &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=adelapena&quot; class=&quot;user-hover&quot; rel=&quot;adelapena&quot;&gt;adelapena&lt;/a&gt; did as well), and I&apos;ve found it quite more complex that the current one, with little/no gains in return, and, something I didn&apos;t mention before, not really complete for indexes covering multiple columns, or if we&apos;ll ever want to support multiple indexes per row: in such cases, mixing tombstones and valid column values for all combinations would easily turn into a mess IMHO, while actually returning the row and later post-filter is IMHO cleaner and less error prone. To be noted, we could still &quot;skim&quot; the row when we detect it&apos;s related to a stale entry and only keep the index-related columns (and easily add a merging step in the future for the multiple indexes cases): this would buy us the performance optimization you mentioned above, but I see it slightly error prone and I&apos;d rather go with a functionally complete solution first.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;It&apos;s in particular not true that fixing this bug will be &quot;invalidated when filtering is applied&quot;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I disagree here: if filtering is applied on top of index results, you&apos;ll still get wrong results, which is confusing to me (as a user). I understand filtering is also orthogonal, so what about fixing filtering (that is, moving to coordinator-side filtering) only when indexes are present?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;That &lt;span class=&quot;error&quot;&gt;&amp;#91;fixing other index implementations&amp;#93;&lt;/span&gt; I agree is something we should consider. Though tbh, I have doubts we can have a solution that is completely index agnostic. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Of course. But we can still provide some API (i.e. the &lt;tt&gt;isSatisfiedBy()&lt;/tt&gt; you mentioned) they can leverage. And if we do this kind of work on the SASI-enabled branches, we&apos;ll have two different index implementations to test the goodness of our API.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;One thing that hasn&apos;t been mentioned is that the fix has impact on upgrades. Namely, in a mixed cluster, some replica will start to return invalid results and if the coordinator isn&apos;t upgraded yet, it won&apos;t filter those, which means we&apos;ll return invalid entries.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Excellent point! And definitely something to avoid.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;That does mean we should consider starting to filter entries on index queries coordinator-side in 3.0/3.11 (even though we never return them), and only do the replica-side parts in 4.0, with a fat warning that you need to only upgrade to 4.0 from a 3.X version that has the coordinator-side fix.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Mmmhhhh ... clunky. And error prone as the 3.X code would be probably untestable. Couldn&apos;t the replica detect the coordinator version and return results accordingly?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Worth noting that this doesn&apos;t entirely fly for index using custom indexes: we&apos;d need to have them implement the CustomExpression#isSatistiedBy method in 3.X in that scheme since we need it for the coordinator-side filtering as well, but making that method abstract in 3.X is, as said above, a breaking change.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;m not sure I get why you &lt;em&gt;have to&lt;/em&gt; make that abstract: I think it&apos;s fine to leave it as it is and warn users they&apos;ll have to override it on upgrade if they want consistent results. And for those implementations that can&apos;t implement it, we should maybe add a &lt;tt&gt;isConsistent&lt;/tt&gt; predicate to disable &quot;consistent filtering&quot; altogether.&lt;/p&gt;</comment>
                            <comment id="16006896" author="adelapena" created="Thu, 11 May 2017 17:57:08 +0000"  >&lt;p&gt;Indeed, both returning entries that were recently valid but aren&apos;t anymore and checking if the custom expressions are still valid after reconcilliation is something that should be done by index implementations. Also, some implementations could not be able or even not be interested on doing so.&lt;/p&gt;

&lt;p&gt;Regarding the &lt;tt&gt;LIMIT&lt;/tt&gt; problem, the new &lt;tt&gt;DataLimits&lt;/tt&gt; suggested by &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=slebresne&quot; class=&quot;user-hover&quot; rel=&quot;slebresne&quot;&gt;slebresne&lt;/a&gt; could be provided by a new method &lt;tt&gt;Index#getPostIndexQueryLimits&lt;/tt&gt;, similar to the existing &lt;a href=&quot;https://github.com/apache/cassandra/blob/trunk/src/java/org/apache/cassandra/index/Index.java#L341&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;&lt;tt&gt;Index#getPostIndexQueryFilter&lt;/tt&gt;&lt;/a&gt;. Alternatively, we might just disable the limits at &lt;a href=&quot;https://github.com/apache/cassandra/blob/trunk/src/java/org/apache/cassandra/db/ReadCommand.java#L371&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;&lt;tt&gt;ReadCommand#executeLocally&lt;/tt&gt;&lt;/a&gt; and &lt;a href=&quot;https://github.com/apache/cassandra/blob/trunk/src/java/org/apache/cassandra/service/DataResolver.java#L79&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;&lt;tt&gt;DataResolver#resolve&lt;/tt&gt;&lt;/a&gt; for index queries, and let the indexes take care of restricting the limits at search time. This way the index implementations wouldn&apos;t require to specify a &lt;tt&gt;CustomExpression#isSatistiedBy&lt;/tt&gt; implementation, they would discard the stale entries with their post processor, which could also be used for other things, like sorting.&lt;/p&gt;</comment>
                            <comment id="16007801" author="slebresne" created="Fri, 12 May 2017 08:43:09 +0000"  >&lt;blockquote&gt;&lt;p&gt;I disagree here: if filtering is applied on top of index results, you&apos;ll still get wrong results&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It&apos;s possible, but not at all guarantee since the index and filtering will apply to different columns. But that&apos;s almost beside the point as my point is that even solving only the indexing will still avoid bugs for some people (at the very least the ones that don&apos;t use filtering over indexing at all), so if we can&apos;t get agreement on how to fix the filtering, I don&apos;t think we should hold the indexing fix.&lt;/p&gt;

&lt;p&gt;But mostly, I just want us to have the &lt;em&gt;discussion&lt;/em&gt; around filtering in &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-8273&quot; title=&quot;Allow filtering queries can return stale data&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-8273&quot;&gt;&lt;del&gt;CASSANDRA-8273&lt;/del&gt;&lt;/a&gt; to avoid mixing things up, but If we can agree on moving filtering server-side there quickly, then I&apos;m totally fine doing that and the indexing in a single patch if we prefer.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;what about fixing filtering (that is, moving to coordinator-side filtering) only when indexes are present?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Well, that kind of already get into the territory of whether we&apos;re ok with moving filtering coordinator-side. In fact, I don&apos;t think having filtering applied on top of indexing or not change in any way that discussion. Again though, I&apos;m not at all against fixing both issues, I just prefer discussing the two different (though related) problems separately.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;But we can still provide some API (i.e. the &lt;tt&gt;isSatisfiedBy()&lt;/tt&gt; you mentioned) they can leverage.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;If you&apos;re making a general point, then sure. Otherwise, I&apos;m not sure what else you have in mind (and as I said I don&apos;t see what more we can do) so feel free to share.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Mmmhhhh ... clunky. And error prone as the 3.X code would be probably untestable. Couldn&apos;t the replica detect the coordinator version and return results accordingly?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;We can do anything, but everything version-related is currently wired to the messaging protocol version, which can&apos;t currently change in minor versions, so we&apos;d have to rely on the version exchanged through gossip in a way we never have, so with risks associated (typically potential races between when we actually get that version and where we use it). Plus it  would mean quite a bit of (fairly ugly) changes to pass the version where we need it. All that in a minor release. I doubt it&apos;s a good idea in practice in this context.&lt;/p&gt;

&lt;p&gt;On the flip-side, we do have quite a bit of prior experience adding stuffs to minor releases to fix future major upgrade. I don&apos;t disagree it&apos;s clunky, mind you, but better the devil you know...&lt;/p&gt;

&lt;p&gt;I don&apos;t see why it would be untestable though: we can test the added filtering doesn&apos;t break anything in 3.x and we can totally test upgrades.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;for index using custom indexes: we&apos;d need to have them implement the &lt;tt&gt;CustomExpression#isSatistiedBy&lt;/tt&gt; method&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I was a bit too quick here, it&apos;s actually not that simple, because &lt;tt&gt;CustomExpression&lt;/tt&gt; are created directly from the parser and don&apos;t depend on whatever index use them, so we can&apos;t have them override/implement it. That said, we do know which index it&apos;s use with when we create one so we could change things a bit so index do provide us with their own concrete implementation &lt;tt&gt;CustomExpression&lt;/tt&gt;, it&apos;s just a tiny bit more involved that I made is sound to be.&lt;/p&gt;</comment>
                            <comment id="16007899" author="slebresne" created="Fri, 12 May 2017 09:56:40 +0000"  >&lt;p&gt;I hadn&apos;t really looked at the patch before, but I think we can and should make most things index agnostic here. In particular, I don&apos;t think we should use &lt;tt&gt;Index#postProcessorFor&lt;/tt&gt; for the coordinator-side filtering. What I would do instead is modify &lt;tt&gt;PartitionRangeReadCommand#ReconcialiationProcessing&lt;/tt&gt; to be:&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;public PartitionIterator postReconciliationProcessing(PartitionIterator result)
{
    ColumnFamilyStore cfs = Keyspace.open(metadata().keyspace).getColumnFamilyStore(metadata().name);
    Index index = getIndex(cfs);
    if (index == null)
        return result;

    // Indexes on replica can return results that don&apos;t match the query but are necessary
    // to avoid stale entries from other nodes (see #8272) so we should filter those out
    // now. Then we apply any index specific post-processor.
    RowFilter indexFilter = index.getIndexQueryFilter(rowFilter());
    return index.postProcessorFor(this)
                .apply(indexFilter.filter(result, metadata(), nowInSec()), this);
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;where we&apos;d just need to add a &lt;tt&gt;Index#getIndexQueryFilter&lt;/tt&gt; that would be the exact inverse of &lt;tt&gt;Index#getPostIndexQueryFilter&lt;/tt&gt; (and so this can be simply implemented as a default method that subtract from its input anything from &lt;tt&gt;Index#getPostIndexQueryFilter&lt;/tt&gt;).&lt;/p&gt;

&lt;p&gt;The reason I&apos;m advocating this is two-fold:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;it&apos;s simpler in that it&apos;s done once generically instead of being re-implemented by each index implementation; and as index already expose everything we need to do this, no reason to have them do it &quot;manually&quot;.&lt;/li&gt;
	&lt;li&gt;probably more importantly, if we do decide to move all filtering coordinator-side in &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-8273&quot; title=&quot;Allow filtering queries can return stale data&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-8273&quot;&gt;&lt;del&gt;CASSANDRA-8273&lt;/del&gt;&lt;/a&gt; (which I do believe is the right thing to do), we&apos;d just have to modify (and actually simplify) that method slightly to
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;public PartitionIterator postReconciliationProcessing(PartitionIterator result)
{
    result = rowFilter().filter(result, metadata(), nowInSec());
    ColumnFamilyStore cfs = Keyspace.open(metadata().keyspace).getColumnFamilyStore(metadata().name);
    Index index = getIndex(cfs);
    if (index == null) ? result : index.postProcessorFor(this).apply(result, this);
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;which is imo kind of neat conceptually.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;It is true that doing so does mean we need indexes to implement &lt;tt&gt;CustomExpression#isSatisfiedBy&lt;/tt&gt;, which as I mention in my previous comment requires a slight refactor, but I&apos;d argue that this is something we absolutely should do anyway (and should have done before). It&apos;s wrong that this method is currently basically broken for custom expressions: sure we currently happen to not use it in that case, but it&apos;s not future-proof at all and it&apos;s that kind of tribal knowledge (&quot;you should make sure to not use &lt;tt&gt;Expression#isSatisfiedBy&lt;/tt&gt; or anything that uses it if there is &lt;tt&gt;CustomExpression&lt;/tt&gt; involved&quot;) that makes the code hard to work with.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;could be provided by a new method &lt;tt&gt;Index#getPostIndexQueryLimits&lt;/tt&gt;, similar to the existing &lt;tt&gt;Index#getPostIndexQueryFilter&lt;/tt&gt;.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That&apos;d work, though we really don&apos;t need indexes to implement it, we can use the &lt;tt&gt;Index#getIndexQueryFilter&lt;/tt&gt; from above. And so maybe we don&apos;t need to add a new method to &lt;tt&gt;Index&lt;/tt&gt;, and instead just add a &lt;tt&gt;DataLimits#withFiltering(RowFilter)&lt;/tt&gt; method (that given a &lt;tt&gt;DataLimits&lt;/tt&gt;, create a new one that only count rows that match the provided &lt;tt&gt;RowFilter&lt;/tt&gt;) and directly use that with the result of &lt;tt&gt;Index#getIndexQueryFilter&lt;/tt&gt; when we need it.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Alternatively, we might just disable the limits at &lt;tt&gt;ReadCommand#executeLocally&lt;/tt&gt; and &lt;tt&gt;DataResolver#resolve&lt;/tt&gt; for index queries, and let the indexes take care of restricting the limits at search time&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;ll admit I&apos;m kind of opposed to that. There is always cases where we need to be able to count stuffs post-query so not being able to do so with index queries would be clunky, if not properly a blocker. For instance, I suspect it&apos;ll break paging without quite a bit of special casing. Another example would be the row cache, where we do some stuffs around counting that just wouldn&apos;t work in that case (don&apos;t get me wrong, we don&apos;t use row cache for 2i today, I&apos;m just trying to illustrate that we&apos;d lose flexibility for future developments).&lt;/p&gt;

&lt;p&gt;Further, it took some care in &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-8099&quot; title=&quot;Refactor and modernize the storage engine&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-8099&quot;&gt;&lt;del&gt;CASSANDRA-8099&lt;/del&gt;&lt;/a&gt; to cleanly separate the counting of results from the actual producer of data but that imo simplified and cleaned thinks up, and I&apos;d hate to start breaking that kind of &quot;abstraction&quot;.&lt;/p&gt;</comment>
                            <comment id="16008026" author="sbtourist" created="Fri, 12 May 2017 12:09:27 +0000"  >&lt;blockquote&gt;&lt;p&gt;I just want us to have the discussion around filtering in &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-8273&quot; title=&quot;Allow filtering queries can return stale data&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-8273&quot;&gt;&lt;del&gt;CASSANDRA-8273&lt;/del&gt;&lt;/a&gt; to avoid mixing things up, but If we can agree on moving filtering server-side there quickly, then I&apos;m totally fine doing that and the indexing in a single patch if we prefer.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;m fine with moving filtering server side, and I&apos;m fine with dealing with it on either issues provided we eventually address &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-8273&quot; title=&quot;Allow filtering queries can return stale data&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-8273&quot;&gt;&lt;del&gt;CASSANDRA-8273&lt;/del&gt;&lt;/a&gt; straight away.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;If you&apos;re making a general point &lt;span class=&quot;error&quot;&gt;&amp;#91;about API&amp;#93;&lt;/span&gt;, then sure.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes, I&apos;m making a general point. Also see below.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;we&apos;d have to rely on the version exchanged through gossip in a way we never have, so with risks associated &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Alright, I don&apos;t have enough knowledge to provide a proper risk assessment on my own, so I&apos;m fine with the previously proposed &quot;split&quot; patch.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I think we can and should make most things index agnostic here&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Totally agree here, and that&apos;s what I meant when saying we should make it work with all index implementations and devise APIs to leverage. I agree we should move away from using &lt;tt&gt;Index#postProcessorFor&lt;/tt&gt;, and I agree we should keep the counting outside the index implementation (again, as it will be useful to all index implementations), but I&apos;ll leave the actual implementation details to &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=adelapena&quot; class=&quot;user-hover&quot; rel=&quot;adelapena&quot;&gt;adelapena&lt;/a&gt; and discuss once we&apos;ve got a first cut.&lt;/p&gt;

&lt;p&gt;So here&apos;s my take away about how we should move forward:&lt;br/&gt;
1) Provide a first patch based on 3.11 to fix the coordinator side.&lt;br/&gt;
2) Provide a second patch based on trunk to fix both coordinator and replica side (we could address this first, review, and backport the coordinator side once in agreement).&lt;br/&gt;
3) Discuss filtering in &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-8273&quot; title=&quot;Allow filtering queries can return stale data&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-8273&quot;&gt;&lt;del&gt;CASSANDRA-8273&lt;/del&gt;&lt;/a&gt; and eventually address it here (this patch is getting quite meaty already, but OTOH &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-8273&quot; title=&quot;Allow filtering queries can return stale data&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-8273&quot;&gt;&lt;del&gt;CASSANDRA-8273&lt;/del&gt;&lt;/a&gt; will require a split approach too, so we might want to make our life easier and do everything in one place).&lt;/p&gt;

&lt;p&gt;Thoughts?&lt;/p&gt;</comment>
                            <comment id="16010354" author="adelapena" created="Mon, 15 May 2017 11:33:39 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sbtourist&quot; class=&quot;user-hover&quot; rel=&quot;sbtourist&quot;&gt;sbtourist&lt;/a&gt;, the proposed steps look good to me. &lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=slebresne&quot; class=&quot;user-hover&quot; rel=&quot;slebresne&quot;&gt;slebresne&lt;/a&gt;, now I see that ignoring the limit before post processing has implications that I didn&apos;t take into account and that make it a bad idea which I retract. The reasoning behind trying to discard the &quot;tombstone&quot; rows using the post processor instead of the expression is that there could exist implementations where doing so could have a negative impact of performance, especially if they are already using the post processor for sorting or any other stuff. But, thinking it better, these implementations can rely on other methods to mitigate the performance cost of re-evaluating all the expression if the only requirement is to just discard tombstones.&lt;/p&gt;

&lt;p&gt;Regarding making &lt;tt&gt;RowFilter.CustomExpression#isSatisfiedBy()&lt;/tt&gt; abstract, we could provide a new &lt;tt&gt;Index#customExpressionFor(CFMetaData, ByteBuffer)&lt;/tt&gt; method to let the index provide the custom expression implementation. This new method could have a default implementation returning a new &lt;tt&gt;RowFilter.CustomExpression&lt;/tt&gt; with the same behaviour that we currently have, that is, an &lt;tt&gt;#isSatisfiedBy()&lt;/tt&gt; implementation that always returns &lt;tt&gt;true&lt;/tt&gt;. This way, for 3.x we&apos;ll keep compatibility while allowing custom index implementors that don&apos;t require incremental upgrades to implement the coordinator side of this bugfix. Then, for trunk, we could either remove the &lt;tt&gt;Index#customExpressionFor(CFMetaData cfm, ByteBuffer value)&lt;/tt&gt; implementation or keep it as an ease for index implementations not interested in or able of implementing the coordinator side part of this. &lt;a href=&quot;https://github.com/adelapena/cassandra/commit/34d3c7d0759c253d2b780b80e140930dc05cd591&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;Here&lt;/a&gt; is a draft patch showing the approach.&lt;/p&gt;

&lt;p&gt;What do you think?&lt;/p&gt;</comment>
                            <comment id="16010420" author="slebresne" created="Mon, 15 May 2017 12:34:41 +0000"  >&lt;p&gt;Looks good to me.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;for trunk, we could either remove the &lt;tt&gt;Index#customExpressionFor(CFMetaData cfm, ByteBuffer value)&lt;/tt&gt; implementation or keep it as an ease for index implementations not interested in or able of implementing the coordinator side part of this. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;For what it&apos;s worth, I&apos;d really remove it. The default we&apos;re providing is just broken for any sensible index implementation, and have a default implementation that is intrinsically broken is wrong. Sure, so far we haven&apos;t relied on that implementation, and with this ticket we would rely on it in a particular case only, but all this isn&apos;t very future proof. And there is no real cost to asking custom index to implement it: worst case, they can just making it always return true themselves if they so wish, but at least they do it while being plainly aware that it&apos;s dodgy and could brake things in the future.&lt;/p&gt;</comment>
                            <comment id="16010605" author="sbtourist" created="Mon, 15 May 2017 14:27:22 +0000"  >&lt;blockquote&gt;&lt;p&gt;Here is a draft patch showing the approach.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Excellent, I like it too.&lt;/p&gt;</comment>
                            <comment id="16019835" author="adelapena" created="Mon, 22 May 2017 17:06:21 +0000"  >&lt;p&gt;It seems that for guaranteeing consistency the replicas should send &lt;b&gt;all&lt;/b&gt; the rows with a matching obsolete entry in the index. The number of rows to be sent can be quite large in large clusters, so this could have an appreciable impact in performance. &lt;/p&gt;

&lt;p&gt;However, this mechanism is not required when read consistency level is ONE, which I suspect is the most commonly used consistency level for 2i use cases. So, as a performance improvement, we could keep filtering on the replica side when CL=ONE. &lt;/p&gt;

&lt;p&gt;I think we could pass the consistency level (or a boolean indicating if CL=ONE) to the &lt;tt&gt;Index#searcherFor&lt;/tt&gt; method, in such a way that the index implementation would be expected to provide only not-stale results if CL=ONE, and either stale or not-stale results if CL&amp;gt;ONE. It could be cleaner to keep this logic out of the index implementations, but they are in the best position to efficiently apply replica-side filtering at CL=ONE, because they can possibly use their underlying index structures to simply don&apos;t read the stale results instead of just skipping them.&lt;/p&gt;

&lt;p&gt;WDYT? Does it make any sense?&lt;/p&gt;</comment>
                            <comment id="16020052" author="slebresne" created="Mon, 22 May 2017 19:32:01 +0000"  >&lt;p&gt;I can refer you to &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-8273?focusedCommentId=16007964&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-16007964&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;my comment on 8273&lt;/a&gt; on that aspect since it&apos;s largely the same aspect, but the short version is that you are right, but at the same time 1) anyone caring about performance should probably use token-aware clients and that make such CL.ONE optimization not really needed, 2) we actually don&apos;t ship the consistency with &lt;tt&gt;ReadCommand&lt;/tt&gt; to replicas, so such optimization cannot be done before 4.0 at best (it requires a protocol change) and 3) the reason why this ticket is &quot;easier&quot; than &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-8723&quot; title=&quot;Cassandra 2.1.2 Memory issue - java process memory usage continuously increases until process is killed by OOM killer&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-8723&quot;&gt;&lt;del&gt;CASSANDRA-8723&lt;/del&gt;&lt;/a&gt; is that we will likely not transfer &lt;em&gt;that&lt;/em&gt; much additional rows: we&apos;ll only sent row that use to be valid entries for the query but aren&apos;t anymore and this since less than gc_grace, which, except maybe for very specific cases, is unlikely for represent a huge overhead for any particular query.&lt;/p&gt;

&lt;p&gt;Anyway, not really opposing such optimization, but given it&apos;s not useful if you follow performance best practices and given it&apos;s a tiny bit more involved than it sounds (and it adds a bit of complexity to the code after all by creating a special case), I&apos;d be happy focusing on correction here and leaving that to a follow-up. &lt;/p&gt;</comment>
                            <comment id="16020056" author="JIRAUSER308715" created="Mon, 22 May 2017 19:34:55 +0000"  >&lt;p&gt;While I agree it is an edge case, we need to make sure a 2i query doesn&apos;t OOM someones node because they just did a mass delete.  So we should make sure we at the very least use the current tombstone overwhelming thresholds when reading these values.&lt;/p&gt;</comment>
                            <comment id="16020417" author="maedhroz" created="Mon, 22 May 2017 23:46:55 +0000"  >&lt;p&gt;+1 on making replicas aware of the CL in 4.0&lt;/p&gt;

&lt;p&gt;In terms of what to do about very large sets of &quot;no longer valid&quot; matches, I agree we shouldn&apos;t allow ourselves to OOM the node, but what&apos;s more, we should fail the query outright if we breach the &quot;threshold&quot;.&lt;/p&gt;</comment>
                            <comment id="16020797" author="adelapena" created="Tue, 23 May 2017 08:24:58 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=slebresne&quot; class=&quot;user-hover&quot; rel=&quot;slebresne&quot;&gt;slebresne&lt;/a&gt;, I think the optimization could also be useful even if you use token-aware clients. Some index implementations could do faster local searches in the underlying index structure if they know that they have to skip stale entries, provided that the staleness status is one of the indexed dimensions. Additionally, we wouldn&apos;t require to read the base table rows pointed by the stale entries.&lt;/p&gt;</comment>
                            <comment id="16020827" author="slebresne" created="Tue, 23 May 2017 08:48:59 +0000"  >&lt;blockquote&gt;&lt;p&gt;Some index implementations could do faster local searches in the underlying index structure if they know that they have to skip stale entries&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Maybe, but again this is pushing more details to the index implementation in a way that becomes a bit black box for us, and 1) I feel this make things more complex overall and 2) I fear about this beating us back in the future. So even if I was to do that optimization of moving filtering to the replica on CL.ONE, I&apos;d still prefer keeping it index-independent.&lt;/p&gt;

&lt;p&gt;Don&apos;t get me wrong, this is largely personal opinion I&apos;m expressing here. I &lt;em&gt;prefer&lt;/em&gt; keeping things simpler, asking from custom index a behavior that is as simple, consistent and as generic as possible (so with as little special case as possible). As said above, I&apos;m not convinced the amount of stale entries we&apos;ll end up dealing with in practice will be really big (again, that&apos;s where this mainly differs from &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-8273&quot; title=&quot;Allow filtering queries can return stale data&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-8273&quot;&gt;&lt;del&gt;CASSANDRA-8273&lt;/del&gt;&lt;/a&gt; imo), so I can&apos;t shake the feeling that all this would be premature optimization. Or to put it more bluntly, I&apos;m ok with the trade-off of removing a few hypothetical and edge case opportunity for optimization from custom index implementations for the benefit of keeping our code and the general custom index contract simpler and more maintainable.&lt;/p&gt;

&lt;p&gt;Note that I&apos;m distinguishing the two level of 1) moving the filtering replica-side for CL.ONE and 2) actually pushing to the index implementation the responsibility of said replica-side CL.ONE filtering. I do kind of feel both are a bit premature optimizations as far as this ticket goes tbh, but I don&apos;t mind 1) so much, while I&apos;m a bit more wary of 2) for the reasons expressed above.&lt;/p&gt;</comment>
                            <comment id="16027834" author="adelapena" created="Sun, 28 May 2017 14:34:57 +0000"  >&lt;p&gt;&lt;a href=&quot;https://github.com/apache/cassandra/compare/cassandra-3.11...adelapena:cc6b762714942e3470daff4b815d3c311f16d856&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;Here&lt;/a&gt; I&apos;m working on the patch for 3.11. The row filter-aware data limits is not yet finished, thus there are several tests failing, but I think it could be useful to give an idea of the approach:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Index interface has a new &lt;tt&gt;Index#getIndexQueryFilter(RowFilter)&lt;/tt&gt; method, intended to return a row filter with only the expressions served by the index. It has a default implementation that returns the opposite to the already existent &lt;tt&gt;Index#getPostIndexQueryFilter&lt;/tt&gt;.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Unfortunately, SASI don&apos;t return results satisfying the row filter, because &lt;tt&gt;LIKE&lt;/tt&gt; operator implementation doesn&apos;t take into account tokenization. So for now &lt;tt&gt;SASIIndex#getIndexQueryFilter&lt;/tt&gt; returns an empty filter.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Index interface has a new &lt;tt&gt;Index#customExpressionFor(CFMetaData, ByteBuffer)&lt;/tt&gt; method to provide a custom expression implementation. The default implementation returns a &lt;tt&gt;CustomExpression&lt;/tt&gt; which &lt;tt&gt;isSatisfiedBy&lt;/tt&gt; method returns always &lt;tt&gt;true&lt;/tt&gt; to keep compatibility. &lt;tt&gt;RowFilter.CustomExpression&lt;/tt&gt; class is modified to be abstract, and it has a builder method that requests the specific implementation to the target index.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;&lt;tt&gt;PartitionRangeReadCommand#postReconciliationProcessing&lt;/tt&gt; has been moved to &lt;tt&gt;ReadCommand#postReconciliationProcessing&lt;/tt&gt;. Now it removes all the rows not satisfying  &lt;tt&gt;Index#getIndexQueryFilter&lt;/tt&gt; before calling to &lt;tt&gt;Index#postProcessorFor&lt;/tt&gt;, and it is called by all read queries &lt;tt&gt;#execute&lt;/tt&gt; and &lt;tt&gt;#executeInternal&lt;/tt&gt; methods implementations.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;&lt;tt&gt;DataLimits&lt;/tt&gt; has a new method &lt;tt&gt;newCounter(int, boolean, RowFilter, CFMetaData)&lt;/tt&gt; that returns a new row filter-aware &lt;tt&gt;DataLimits.Counter&lt;/tt&gt;. This counter, which is a transformation, should include in the results (but not count) all the rows that don&apos;t satisfy the row filter. So, when a row filter is specified, &lt;tt&gt;DataLimits.Counter&lt;/tt&gt; is a not stopping transformation because all the rows not satisfying the filter shouldn&apos;t be filtered, although they are not counted.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Both &lt;tt&gt;DataResolver#resolve&lt;/tt&gt; and &lt;tt&gt;ReadQuery#executeInternal&lt;/tt&gt; implementations apply a &lt;tt&gt;DataLimits.Counter&lt;/tt&gt; transformation using the filter provided by &lt;tt&gt;Index#getIndexQueryFilter&lt;/tt&gt;.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;&lt;tt&gt;CustomIndexTest#coordinatorSideFilteringTest&lt;/tt&gt; contains several tests using a custom index implementation that uses pure coordinator-side filtering.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=slebresne&quot; class=&quot;user-hover&quot; rel=&quot;slebresne&quot;&gt;slebresne&lt;/a&gt;, is it in line with what you suggested? Any recommendation for the row filter-aware &lt;tt&gt;DataLimits&lt;/tt&gt;?&lt;/p&gt;</comment>
                            <comment id="16028128" author="slebresne" created="Mon, 29 May 2017 08:10:47 +0000"  >&lt;p&gt;Yes, that&apos;s generally what I had in mind, thanks!&lt;/p&gt;

&lt;p&gt;For the row-filter aware counter however, I don&apos;t think we can aford to have it not be a stopping transformation: we very much rely on that stopping to not OOM nodes (and generally read the whole database on a read), whether it be for user limits or paging. I&apos;m not sure I understand why stopping it a concern in this case however?&lt;/p&gt;

&lt;p&gt;As an aside, had a very very quick scan of the patch, and I&apos;ll also note that in &lt;tt&gt;StorageProxy&lt;/tt&gt; and &lt;tt&gt;SinglePartitionReadCommand.Group.executeInternal&lt;/tt&gt;, using only the post-processor of the 1st command would break if the index actually makes assumption based on the command it&apos;s passed on, so it feels dodgy and I think we sould make sure it&apos;s applied to each command result individually.&lt;/p&gt;</comment>
                            <comment id="16029457" author="adelapena" created="Tue, 30 May 2017 14:11:31 +0000"  >&lt;blockquote&gt;&lt;p&gt;For the row-filter aware counter however, I don&apos;t think we can aford to have it not be a stopping transformation: we very much rely on that stopping to not OOM nodes (and generally read the whole database on a read), whether it be for user limits or paging. I&apos;m not sure I understand why stopping it a concern in this case however?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;If I understand it right, the idea is to have a &lt;tt&gt;DataLimits&lt;/tt&gt; (associated to a &lt;tt&gt;RowFilter&lt;/tt&gt;) that doesn&apos;t filter nor count rows that don&apos;t satisfy the filter. Any possible deleted index entry from a replica could be required to discard the possible stale results of another replica, so they shouldn&apos;t be filtered by &lt;tt&gt;DataLimits&lt;/tt&gt;. So, if the query limit requires &lt;tt&gt;n&lt;/tt&gt; rows, we should return not more than &lt;tt&gt;n&lt;/tt&gt; rows satisfying the filter, and &lt;b&gt;all&lt;/b&gt; the rows not satisfying the index but being pointed by a deleted index entry. Is this correct? If so, we can&apos;t stop reading when we have &lt;tt&gt;n&lt;/tt&gt; rows satisfying the filter, we should keep reading the all the remaining rows pointed by deleted index entries, independently of the limit and with the subsequent impact on performance.&lt;/p&gt;</comment>
                            <comment id="16030870" author="slebresne" created="Wed, 31 May 2017 09:10:33 +0000"  >&lt;blockquote&gt;&lt;p&gt;So, if the query limit requires n rows, we should return not more than &lt;tt&gt;n&lt;/tt&gt; rows satisfying the filter, and &lt;b&gt;all&lt;/b&gt; the rows not satisfying the index but being pointed by a deleted index entry.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;No, I don&apos;t think we have to return &lt;b&gt;all&lt;/b&gt; the rows not satisfying the index. I believe only returning those that are &lt;b&gt;before&lt;/b&gt; the &lt;tt&gt;n&lt;/tt&gt; th &quot;valid&quot; entry is enough. I don&apos;t think it&apos;s different from how we handle tombstones here: we don&apos;t return all tombstones, just the ones before the &lt;tt&gt;n&lt;/tt&gt; th live results.&lt;/p&gt;

&lt;p&gt;Note that both with those new &quot;invalid&quot; entries and with tombstones, it&apos;s possible that post-resolution on the coordinator we end up being short on results. That is, a &quot;valid&quot; result from A is canceled by a tombstone/&quot;invalid&quot; result of B and vice-versa and we end up with less results than requested. But that&apos;s where the short-read protection from &lt;tt&gt;DataResolver&lt;/tt&gt; kicks in.&lt;/p&gt;</comment>
                            <comment id="16039285" author="adelapena" created="Tue, 6 Jun 2017 17:19:19 +0000"  >&lt;p&gt;Here is a new version of the patch for 3.11 and trunk:&lt;/p&gt;

&lt;div class=&apos;table-wrap&apos;&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;&lt;a href=&quot;https://github.com/apache/cassandra/compare/cassandra-3.11...adelapena:454617607063bfb554b841f0d891798404faf0b1&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;3.11&lt;/a&gt;&lt;/th&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;http://cassci.datastax.com/view/Dev/view/adelapena/job/adelapena-8272-3.11-testall/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;utests&lt;/a&gt;&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;http://cassci.datastax.com/view/Dev/view/adelapena/job/adelapena-8272-3.11-dtest/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;dtests&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;&lt;a href=&quot;https://github.com/apache/cassandra/compare/trunk...adelapena:1416d9b082d7f93b187cbf67abd9a917735c4804&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;trunk&lt;/a&gt;&lt;/th&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;http://cassci.datastax.com/view/Dev/view/adelapena/job/adelapena-8272-trunk-testall/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;utests&lt;/a&gt;&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;http://cassci.datastax.com/view/Dev/view/adelapena/job/adelapena-8272-trunk-dtest/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;dtests&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;


&lt;blockquote&gt;&lt;p&gt;No, I don&apos;t think we have to return all the rows not satisfying the index. I believe only returning those that are before the &lt;tt&gt;n&lt;/tt&gt; th &quot;valid&quot; entry is enough. I don&apos;t think it&apos;s different from how we handle tombstones here: we don&apos;t return all tombstones, just the ones before the &lt;tt&gt;n&lt;/tt&gt; th live results.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Note that both with those new &quot;invalid&quot; entries and with tombstones, it&apos;s possible that post-resolution on the coordinator we end up being short on results. That is, a &quot;valid&quot; result from A is canceled by a tombstone/&quot;invalid&quot; result of B and vice-versa and we end up with less results than requested. But that&apos;s where the short-read protection from &lt;tt&gt;DataResolver&lt;/tt&gt; kicks in.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Indeed, short-read protection solves the problem, so I have left the &lt;tt&gt;DataLimits.Counter&lt;/tt&gt; as a stopping transformation. I have added &lt;a href=&quot;https://github.com/adelapena/cassandra-dtest/blob/CASSANDRA-8272/secondary_indexes_test.py#L1205-L1343&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;some dtests&lt;/a&gt; checking these scenarios with indexes.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;As an aside, had a very very quick scan of the patch, and I&apos;ll also note that in &lt;tt&gt;StorageProxy&lt;/tt&gt; and &lt;tt&gt;SinglePartitionReadCommand.Group.executeInternal&lt;/tt&gt;, using only the post-processor of the 1st command would break if the index actually makes assumption based on the command it&apos;s passed on, so it feels dodgy and I think we sould make sure it&apos;s applied to each command result individually.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes, it is dodgy. I have changed it to apply the post processing to each command in the group. &lt;/p&gt;

&lt;p&gt;As we said, the patch for 3.11 only contains the changes in the coordinator side. I have added &lt;a href=&quot;https://github.com/adelapena/cassandra/blob/8272-3.11/test/unit/org/apache/cassandra/index/CustomIndexTest.java#L804-L871&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;a test&lt;/a&gt; in &lt;tt&gt;CustomIndexTest&lt;/tt&gt; that uses &lt;a href=&quot;https://github.com/adelapena/cassandra/blob/8272-3.11/test/unit/org/apache/cassandra/index/CustomIndexTest.java#L1180-L1256&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;a custom index implementation&lt;/a&gt; to validate coordinator side filtering.&lt;/p&gt;

&lt;p&gt;The patch for trunk also modifies regular secondary indexes to send stale rows. SASI don&apos;t uses the mechanism because of the aforementioned problem with expressions evaluation and text analysis, I think we should fix this in a separate ticket.&lt;/p&gt;

&lt;p&gt;Please let me know what do you think.&lt;/p&gt;</comment>
                            <comment id="16042891" author="adelapena" created="Thu, 8 Jun 2017 15:46:00 +0000"  >&lt;p&gt;It seems that there were some thrift-related dtests failing in the patch for 3.11. While fixing them I have realized that Thrift commands send only the fetched columns, so they may not send the queried columns that are required to apply the index filter in the coordinator side. The indexed column value are actually fetched but filtered &lt;a href=&quot;https://github.com/apache/cassandra/blob/cassandra-3.11/src/java/org/apache/cassandra/index/internal/keys/KeysSearcher.java#L182-L193&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;here&lt;/a&gt; since &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-11523&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;CASSANDRA-11523&lt;/a&gt;. So we could just move this filter to the coordinator-side, probably to &lt;a href=&quot;https://github.com/adelapena/cassandra/blob/8272-3.11/src/java/org/apache/cassandra/db/ReadCommand.java#L447-L464&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;ReadCommand#postReconciliationProcessing&lt;/a&gt;. &lt;/p&gt;

&lt;p&gt;However, I think that if we do such replica-side change we would end having the same problem with upgrades that prevents us to apply the full solution to 3.x. That is, not-upgraded replicas could send rows without the indexed-but-not-fetched columns to an upgraded coordinator that would reject them. Complementary, upgraded replicas could send rows including the indexed-but-not-fetched columns to not-upgraded coordinators that would return them without applying the row filter. Probably we could also have problematic scenarios during reconciliation. &lt;/p&gt;

&lt;p&gt;Here is a fixed patch that just skips coordinator-side filtering of index results for Thrift commands:&lt;/p&gt;

&lt;div class=&apos;table-wrap&apos;&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;&lt;a href=&quot;https://github.com/apache/cassandra/compare/cassandra-3.11...adelapena:82b122b1ce5b172e11b4be7f02fdb7581bd28291&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;3.11&lt;/a&gt;&lt;/th&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;http://cassci.datastax.com/view/Dev/view/adelapena/job/adelapena-8272-3.11-testall/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;utests&lt;/a&gt;&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;http://cassci.datastax.com/view/Dev/view/adelapena/job/adelapena-8272-3.11-dtest/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;dtests&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;&lt;a href=&quot;https://github.com/apache/cassandra/compare/trunk...adelapena:1416d9b082d7f93b187cbf67abd9a917735c4804&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;trunk&lt;/a&gt;&lt;/th&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;http://cassci.datastax.com/view/Dev/view/adelapena/job/adelapena-8272-trunk-testall/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;utests&lt;/a&gt;&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;a href=&quot;http://cassci.datastax.com/view/Dev/view/adelapena/job/adelapena-8272-trunk-dtest/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;dtests&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;


&lt;p&gt;This means that not included index implementations couldn&apos;t benefit from our consistency fix when using Thrift. Included index implementations weren&apos;t going to do so anyway because we are not going to apply the replica side of the fix in 3.x.&lt;/p&gt;

&lt;p&gt;No news for trunk.&lt;/p&gt;

&lt;p&gt;What do you think? Is it acceptable to don&apos;t apply the changes to Thrift commands?&lt;/p&gt;</comment>
                            <comment id="16509475" author="adelapena" created="Tue, 12 Jun 2018 10:37:41 +0000"  >&lt;p&gt;I have rebased the patch for trunk &lt;a href=&quot;https://github.com/adelapena/cassandra/commit/20e89ae19735eb731b103e2c479da44c207d1cf1&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;here&lt;/a&gt;.&#160;Rebased dtests can be found &lt;a href=&quot;https://github.com/adelapena/cassandra-dtest/commit/39d21f2a8a8d80b8842703c58c77289f8b644112&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The main differences with the previous patch version are the removal of Thrift stuff (which makes things easier) and the refactor of &lt;tt&gt;ReadCommand&lt;/tt&gt;/&lt;tt&gt;ReadQuery&lt;/tt&gt; introduced by &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-7622&quot; title=&quot;Implement virtual tables&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-7622&quot;&gt;&lt;del&gt;CASSANDRA-7622&lt;/del&gt;&lt;/a&gt;. For the latter, I have placed &lt;tt&gt;postReconciliationProcessing&lt;/tt&gt; at &lt;tt&gt;ReadCommand&lt;/tt&gt; level since it is related to &lt;tt&gt;StorageProxy&lt;/tt&gt; and reconciliation, whereas &lt;tt&gt;ReadQuery&lt;/tt&gt; doesn&apos;t seem to require this kind of reconciliation.&lt;/p&gt;

&lt;p&gt;It is worth remembering that the patch doesn&apos;t support rolling upgrades since not-updated coordinators won&apos;t be discard the stale rows sent by updated replicas. I think we don&apos;t need the patch for 3.11, which was a refactor that didn&apos;t solve the consistency problem to don&apos;t break rolling upgrades in a non-major version. &lt;/p&gt;

&lt;p&gt;The patch doesn&apos;t update SASI to use the new mechanism, so it still behaves the old way. To benefit from this fix, it would need to provide an &lt;a href=&quot;https://github.com/adelapena/cassandra/blob/20e89ae19735eb731b103e2c479da44c207d1cf1/src/java/org/apache/cassandra/index/Index.java#L368-L381&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;&lt;tt&gt;Index.getIndexQueryFilter&lt;/tt&gt;&lt;/a&gt; implementation able to deal with analyzed values. I think that we could do it in a separate ticket to keep things simple.&lt;/p&gt;

&lt;p&gt;I ran the updated patch on our internal CI. There are not failures for the unit tests and the failing dtests are not related to the change.&lt;/p&gt;</comment>
                            <comment id="16539153" author="adelapena" created="Tue, 10 Jul 2018 19:41:00 +0000"  >&lt;p&gt;I have just rebased &lt;a href=&quot;https://github.com/adelapena/cassandra/commit/07e228824fb0e4ea04bf0b1ed11b347ce654f02a&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;the patch&lt;/a&gt;&#160;with some fixes for indexes on static columns. I have also added a&#160;few extra checks&#160;to &lt;a href=&quot;https://github.com/apache/cassandra-dtest/compare/master...adelapena:CASSANDRA-8272&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;the dtests&lt;/a&gt;.&lt;/p&gt;</comment>
                            <comment id="17066670" author="adelapena" created="Wed, 25 Mar 2020 13:22:51 +0000"  >&lt;p&gt;It seems that there are some cases missed by the previous index tombstone based approach, &lt;br/&gt;
 which is when the replica with the most recent version of a column has never seen the previous versions of that column that might be in other replicas, for example:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
CREATE TABLE t (k &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; PRIMARY KEY, v text);
CREATE INDEX ON t(v);
INSERT INTO t(k, v) VALUES (0, &lt;span class=&quot;code-quote&quot;&gt;&apos;old&apos;&lt;/span&gt;) USING TIMESTAMP 1;  &lt;span class=&quot;code-comment&quot;&gt;// Only node 1 gets it
&lt;/span&gt;INSERT INTO t(k, v) VALUES (0, &lt;span class=&quot;code-quote&quot;&gt;&apos;&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt;&apos;&lt;/span&gt;) USING TIMESTAMP 2;  &lt;span class=&quot;code-comment&quot;&gt;// Only node 2 gets it
&lt;/span&gt;SELECT * FROM t WHERE v = &lt;span class=&quot;code-quote&quot;&gt;&apos;old&apos;&lt;/span&gt;; &lt;span class=&quot;code-comment&quot;&gt;// node 1 returns a stale result!&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The attached PR proposes a different approach that is similar to short read protection, and also fixes &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-8273&quot; title=&quot;Allow filtering queries can return stale data&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-8273&quot;&gt;&lt;del&gt;CASSANDRA-8273&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;When there is replica-side protection, we materialize and cache the query results, using a merge listener to take note of the primary keys of rows that doesn&apos;t have a response for any of the involved replicas. We know that those silent replicas might have a more recent version of the row that hasn&apos;t been included because it doesn&apos;t satisfy the filter. Once we have identified and collected those potentially stale rows, we ask for that rows to the silent replicas, with &lt;tt&gt;SinglePartitionReadCommand&lt;/tt&gt; s that don&apos;t use any filtering. Then, we complete the cached filtered results with the responses from the silent replicas, apply the row filter, and we are ready to go.&lt;/p&gt;

&lt;p&gt;Another advantage of this approach over the previous one is that coordinators containing the fix can work with replicas that don&apos;t contain the fix.&lt;/p&gt;

&lt;p&gt;A particular problem is that SASI results don&apos;t satisfy the requested row filter when an analyzer is used. This is something that we should fix so the expressions could delegate their evaluation to the specific indexImplementation. I think this is not specially problematic but I think that it should be done in a separate follow up ticket. By now, the fix just skips replica filtering protection when SASI is used, keeping the old behaviour.&lt;/p&gt;

&lt;p&gt;I&apos;m attaching a PR for 3.11 and I&apos;m working on the PR for trunk. The dtest PR is updated to include the new cases and queries using filtering instead of indexes.&lt;/p&gt;

&lt;p&gt;Since this is a bug fix involving wrong query results, I think it would be great if we could ship it in 4.0.&lt;/p&gt;</comment>
                            <comment id="17070902" author="adelapena" created="Mon, 30 Mar 2020 11:33:19 +0000"  >&lt;p&gt;The PRs for both 3.11 and trunk are ready, CI is &lt;a href=&quot;https://circleci.com/workflow-run/a936c3c7-18a2-40fc-82bb-d50da360757f&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;here&lt;/a&gt; and &lt;a href=&quot;https://circleci.com/workflow-run/7a22486a-9917-40be-ac9d-fdd2b5d3e354&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;</comment>
                            <comment id="17112315" author="blerer" created="Wed, 20 May 2020 14:56:46 +0000"  >&lt;p&gt;The patch LGTM. &lt;/p&gt;</comment>
                            <comment id="17112538" author="jasonstack" created="Wed, 20 May 2020 18:59:47 +0000"  >&lt;p&gt;The patch looks really good.  Left some minor comments in the PR: I think we need to disable `ReplicaFilteringProtection` on transient replicas where repaired data are removed purposely to reduce storage requirement to avoid unnecessary RFP.&lt;/p&gt;</comment>
                            <comment id="17124677" author="maedhroz" created="Wed, 3 Jun 2020 07:14:53 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=adelapena&quot; class=&quot;user-hover&quot; rel=&quot;adelapena&quot;&gt;adelapena&lt;/a&gt;&#160;Given that &lt;tt&gt;TestRepair.test_dead_sync_initiator&lt;/tt&gt;&#160;had already failed during &lt;a href=&quot;https://ci-cassandra.apache.org/view/all/job/Cassandra-devbranch-dtest/126/parameters/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;CASSANDRA-13606 development&lt;/a&gt;, it looks like this will be ready to commit once we revert the CircleCI branch changes?&lt;/p&gt;</comment>
                            <comment id="17126726" author="adelapena" created="Fri, 5 Jun 2020 12:23:28 +0000"  >&lt;p&gt;Committed to &lt;tt&gt;cassandra-3.0&lt;/tt&gt; as &lt;a href=&quot;https://github.com/apache/cassandra/commit/dd255ffa07d0263521a1ca863fc2192db19bc04c&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;dd255ffa07d0263521a1ca863fc2192db19bc04c&lt;/a&gt; and merged up to &lt;tt&gt;cassandra-3.11&lt;/tt&gt; and &lt;tt&gt;trunk&lt;/tt&gt;.&lt;/p&gt;

&lt;p&gt;Dtests committed as &lt;a href=&quot;https://github.com/apache/cassandra-dtest/commit/68f05b02842ccf4b2859d35a057d3be77d3313ab&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;68f05b02842ccf4b2859d35a057d3be77d3313ab&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Thanks for the reviews.&lt;/p&gt;</comment>
                            <comment id="17127665" author="jasonstack" created="Sun, 7 Jun 2020 14:17:30 +0000"  >&lt;p&gt;Created &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-15861&quot; title=&quot;Mutating sstable component may race with entire-sstable-streaming(ZCS) causing checksum validation failure&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-15861&quot;&gt;&lt;del&gt;CASSANDRA-15861&lt;/del&gt;&lt;/a&gt; for &quot;TestRepair.test_dead_sync_initiator&quot; failure. TL;DR: entire-sstable-streaming requires immutable on-disk files but STATS metadata can be mutated causing file size recorded in streaming component manifest to be different from actual transferred file.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="12310000">
                    <name>Duplicate</name>
                                                                <inwardlinks description="is duplicated by">
                                        <issuelink>
            <issuekey id="12753517">CASSANDRA-8273</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="12310560">
                    <name>Problem/Incident</name>
                                            <outwardlinks description="causes">
                                        <issuelink>
            <issuekey id="13344050">CASSANDRA-16311</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="13557061">CASSANDRA-19007</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="13557387">CASSANDRA-19018</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="13314106">CASSANDRA-15907</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="13314513">CASSANDRA-15910</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12753517">CASSANDRA-8273</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="10001">
                    <name>dependent</name>
                                                                <inwardlinks description="is depended upon by">
                                        <issuelink>
            <issuekey id="13062342">CASSANDRA-13423</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12313920" key="com.atlassian.jira.plugin.system.customfieldtypes:multiuserpicker">
                        <customfieldname>Authors</customfieldname>
                        <customfieldvalues>
                                    <customfieldvalue><![CDATA[adelapena]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12313825" key="com.atlassian.jira.plugin.system.customfieldtypes:cascadingselect">
                        <customfieldname>Bug Category</customfieldname>
                        <customfieldvalues>
                                                    <customfieldvalue key="12982" cascade-level=""><![CDATA[Correctness]]></customfieldvalue>
                                <customfieldvalue key="12987" cascade-level="1"><![CDATA[Transient Incorrect Response]]></customfieldvalue>
            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            5 years, 23 weeks, 2 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i222sn:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12313420" key="com.atlassian.jira.plugin.system.customfieldtypes:multiuserpicker">
                        <customfieldname>Reviewers</customfieldname>
                        <customfieldvalues>
                                    <customfieldvalue><![CDATA[blerer]]></customfieldvalue>
        <customfieldvalue><![CDATA[maedhroz]]></customfieldvalue>
        <customfieldvalue><![CDATA[jasonstack]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12313820" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Severity</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="12962"><![CDATA[Normal]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12311420" key="com.atlassian.jira.plugin.system.customfieldtypes:version">
                        <customfieldname>Since Version</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue id="12313861">0.3</customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313924" key="com.atlassian.jira.plugin.system.customfieldtypes:textfield">
                        <customfieldname>Source Control Link</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>&lt;p&gt;&lt;a href=&quot;https://github.com/apache/cassandra/commit/dd255ffa07d0263521a1ca863fc2192db19bc04c&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/cassandra/commit/dd255ffa07d0263521a1ca863fc2192db19bc04c&lt;/a&gt;&lt;/p&gt;</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>