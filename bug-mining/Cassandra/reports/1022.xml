<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 22:22:03 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[CASSANDRA-2816] Repair doesn&apos;t synchronize merkle tree creation properly</title>
                <link>https://issues.apache.org/jira/browse/CASSANDRA-2816</link>
                <project id="12310865" key="CASSANDRA">Apache Cassandra</project>
                    <description>&lt;p&gt;Being a little slow, I just realized after having opened &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-2811&quot; title=&quot;Repair doesn&amp;#39;t stagger flushes&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-2811&quot;&gt;&lt;del&gt;CASSANDRA-2811&lt;/del&gt;&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-2815&quot; title=&quot;Bad timing in repair can transfer data it is not suppose to &quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-2815&quot;&gt;&lt;del&gt;CASSANDRA-2815&lt;/del&gt;&lt;/a&gt; that there is a more general problem with repair.&lt;/p&gt;

&lt;p&gt;When a repair is started, it will send a number of merkle tree to its neighbor as well as himself and assume for correction that the building of those trees will be started on every node roughly at the same time (if not, we end up comparing data snapshot at different time and will thus mistakenly repair a lot of useless data). This is bogus for many reasons:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Because validation compaction runs on the same executor that other compaction, the start of the validation on the different node is subject to other compactions. 0.8 mitigates this in a way by being multi-threaded (and thus there is less change to be blocked a long time by a long running compaction), but the compaction executor being bounded, its still a problem)&lt;/li&gt;
	&lt;li&gt;if you run a nodetool repair without arguments, it will repair every CFs. As a consequence it will generate lots of merkle tree requests and all of those requests will be issued at the same time. Because even in 0.8 the compaction executor is bounded, some of those validations will end up being queued behind the first ones. Even assuming that the different validation are submitted in the same order on each node (which isn&apos;t guaranteed either), there is no guarantee that on all nodes, the first validation will take the same time, hence desynchronizing the queued ones.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Overall, it is important for the precision of repair that for a given CF and range (which is the unit at which trees are computed), we make sure that all node will start the validation at the same time (or, since we can&apos;t do magic, as close as possible).&lt;/p&gt;

&lt;p&gt;One (reasonably simple) proposition to fix this would be to have repair schedule validation compactions across nodes one by one (i.e, one CF/range at a time), waiting for all nodes to return their tree before submitting the next request. Then on each node, we should make sure that the node will start the validation compaction as soon as requested. For that, we probably want to have a specific executor for validation compaction and:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;either we fail the whole repair whenever one node is not able to execute the validation compaction right away (because no thread are available right away).&lt;/li&gt;
	&lt;li&gt;we simply tell the user that if he start too many repairs in parallel, he may start seeing some of those repairing more data than it should.&lt;/li&gt;
&lt;/ul&gt;
</description>
                <environment></environment>
        <key id="12511343">CASSANDRA-2816</key>
            <summary>Repair doesn&apos;t synchronize merkle tree creation properly</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="10002" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.svg">Normal</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="slebresne">Sylvain Lebresne</assignee>
                                    <reporter username="slebresne">Sylvain Lebresne</reporter>
                        <labels>
                            <label>repair</label>
                    </labels>
                <created>Thu, 23 Jun 2011 11:35:30 +0000</created>
                <updated>Tue, 16 Apr 2019 09:32:56 +0000</updated>
                            <resolved>Thu, 21 Jul 2011 11:13:13 +0000</resolved>
                                        <fixVersion>0.8.2</fixVersion>
                                        <due></due>
                            <votes>3</votes>
                                    <watches>4</watches>
                                                                                                                <comments>
                            <comment id="13053820" author="jbellis" created="Thu, 23 Jun 2011 12:40:12 +0000"  >&lt;p&gt;I guess a dedicated validation executor is ok as long as it still obeys the global &quot;compaction&quot; i/o limit.&lt;/p&gt;</comment>
                            <comment id="13054233" author="stuhood" created="Fri, 24 Jun 2011 04:27:16 +0000"  >&lt;p&gt;I&apos;m a fan of the snapshotting immediately after receiving the request approach. In general, polishing our snapshot support to allow for this kind of usecase is likely to open up other interesting possibilities.&lt;/p&gt;</comment>
                            <comment id="13054237" author="jbellis" created="Fri, 24 Jun 2011 04:45:27 +0000"  >&lt;p&gt;Supporting actual live-reading of snapshotted sstables is a little more than &quot;polishing.&quot; It would be cool, but I wouldn&apos;t want it to block fixing repair.&lt;/p&gt;</comment>
                            <comment id="13054289" author="scode" created="Fri, 24 Jun 2011 07:41:16 +0000"  >&lt;p&gt;I&apos;ve thought about this problem too, and it is really significant for some use-cases. Again because so few writes are needed in order to trigger large amounts of data being sent given the merklee tree granularity.&lt;/p&gt;

&lt;p&gt;While I&apos;m all for a fixing it by e.g. more immediate snapshotting, I would like to raise the issue that repairs overall have pretty significant side-effects; particularly ones that can self-magnify and cause further problems. Beyond the obvious &quot;it does disk I/O&quot; and &quot;It uses CPU&quot;, we have:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Over-repair due to merklee tree granularity can cause jumps in CF sizes, killing cache locality&lt;/li&gt;
	&lt;li&gt;Combine that with concurrent repairs then repairing the &quot;size-jumped&quot; set of sstables and you can magnify that effect on other nodes causing huge size increases.&lt;/li&gt;
	&lt;li&gt;Up to recently, mixing large and small cf:s was a significant problem if you wanted to have different frequencies and different gc grace times, due to one repair blocking on another. But fixes to this and the other JIRA about concurrency, might disable the &quot;fix&quot; for that that was concurrent compaction - so back to square one.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I guess overall, it seems very easy to shoot yourself in the foot with repair.&lt;/p&gt;

&lt;p&gt;Any opinions on &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-2699&quot; title=&quot;continuous incremental anti-entropy&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-2699&quot;&gt;&lt;del&gt;CASSANDRA-2699&lt;/del&gt;&lt;/a&gt; for longer term changes to repair?&lt;/p&gt;
</comment>
                            <comment id="13054297" author="slebresne" created="Fri, 24 Jun 2011 07:55:14 +0000"  >&lt;p&gt;I&apos;m not sure what you mean by &quot;snapshotting immediately&quot; or &quot;polishing our snapshot support&quot;, but one approach that I think is equivalent to that (or maybe that is what you meant by &apos;snapshotting&apos;) would be to grab references to the sstables at the very beginning for each request and use those all throughout the repair. This has however a problem: this means we retain sstables from being deleted during repair, including sstables that are compacted in the meantime. Because repair can take a while, this will be bad. This will also require changes to the wire protocol (because we&apos;ll need a way to indicate during streaming the set of sstables to consider), and since we&apos;ve kind of decided to not do that in minor releases (at least until we&apos;ve discussed that), this means this cannot be released quickly. Which is bad, because I&apos;m pretty sure this is a good part of the reason why some people with big data sets have had huge pain with repair.&lt;/p&gt;

&lt;p&gt;Scheduling the validation one by one avoids those problems. In theory this means we&apos;ll do less work in parallel, but in practice I doubt this is a big since the goal is probably to have repair have less impact on the node rather than more. It will also make this more easy to reason about.&lt;/p&gt;</comment>
                            <comment id="13054460" author="slebresne" created="Fri, 24 Jun 2011 14:05:20 +0000"  >&lt;p&gt;Attaching patch against 0.8. The patch implements the idea of scheduling the merkle tree requests one by one, to make sure the tree are started as close as possible of &quot;the same time&quot;. This also put validation compaction in their own executor (to avoid them to be queued up behind standard compactions). That specific executor is created with 2 core threads, to allow for Peter&apos;s use case of wanting to do multiple repairs at the same time. That is, by default, you can do 2 repairs involving the same node and be ok. More and you may experience crappy precision in repair. The new concurrent_validators parameter is exposed in case some would want more that 2. That being said, regular compactions and validations are not separated for everything and in particular throttling is shared.&lt;/p&gt;

&lt;p&gt;As far as I can test, this successfully fixes the problems from &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-2811&quot; title=&quot;Repair doesn&amp;#39;t stagger flushes&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-2811&quot;&gt;&lt;del&gt;CASSANDRA-2811&lt;/del&gt;&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-2815&quot; title=&quot;Bad timing in repair can transfer data it is not suppose to &quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-2815&quot;&gt;&lt;del&gt;CASSANDRA-2815&lt;/del&gt;&lt;/a&gt;. This also don&apos;t change anything on the on-wire protocol side, so I think we can target that for 0.8.2.&lt;/p&gt;
</comment>
                            <comment id="13054841" author="terjem" created="Sat, 25 Jun 2011 09:03:45 +0000"  >&lt;p&gt;This sounds very interesting.&lt;/p&gt;

&lt;p&gt;We have also spotted very noticable issues with full GCs when the merkle trees are passed around. Hopefully this could fix that too.&lt;/p&gt;

&lt;p&gt;I will see if I can get this patch tested somewhere if it is ready for that.&lt;/p&gt;

&lt;p&gt;On a side topic, given the importance of getting tombstones properly synchronized within GCGraceSeconds, would it be an potential interesting idea to separate tombstones in different sstables to reduce the need to scan the whole dataset very frequently in the first place?&lt;/p&gt;

&lt;p&gt;Another thought may be to make compaction deterministic or synchronized by a master across nodes so for older data, all we needed was to compare pre-stored md5s of how whole sstables? &lt;/p&gt;

&lt;p&gt;That is, while keeping the masterless design for updates, we could consider a master based design for how older data is being organized by the compactor. so it would be much easier to verify that &quot;old&quot; data is the same without any large regular scans and that data is really the same after big compactions etc.&lt;/p&gt;</comment>
                            <comment id="13055421" author="slebresne" created="Mon, 27 Jun 2011 09:24:55 +0000"  >&lt;blockquote&gt;&lt;p&gt;We have also spotted very noticable issues with full GCs when the merkle trees are passed around. Hopefully this could fix that too.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This do make sure that we don&apos;t do multiple validation at the same time and that we keep a small number of merkle tree in memory at the same time. So I suppose this could help on the GC side. But overall I don&apos;t know if I am too optimistic about that, in part because I&apos;m not sure what causes your issues. But this can&apos;t hurt on that side at least.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I will see if I can get this patch tested somewhere if it is ready for that.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I believe it should be ready for that.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;would it be an potential interesting idea to separate tombstones in different sstables.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The thing is that some tombstones may be irrelevant become some update supersedes it (this is specially true of row tombstones). Hence basing a repair on tombstone only may transfer irrelevant data. I suppose it may depend on the use case this will be more or less a big deal. Also, this means that a read will be impacted in that we will often have to hit twice as many sstables. Given that it&apos;s not a crazy idea either to want to repair data regularly (if only for durability guarantee), I don&apos;t know if it is worth the trouble (we would have to separate tombstones from data at flush time, we&apos;ll have to maintain the two separate set of data/tombstone sstables, etc...).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;make compaction deterministic or synchronized by a master across nodes&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Pretty sure we want to avoid going to a master architecture for everything if we can. Having master means that failure handling is more difficult (think network partition for instance) and require leader election and such, and the whole point of the fully distribution of Cassandra is to avoid those. Even without consider those, synchronizing compaction means synchronizing flush somehow and you want to be precise if you&apos;re going to use whole sstable md5s, which will be hard and quite probably inefficient.&lt;/p&gt;</comment>
                            <comment id="13055455" author="terjem" created="Mon, 27 Jun 2011 10:36:34 +0000"  >&lt;p&gt;I don&apos;t know what causes GC when doing repairs either, but fire off repair on a few nodes with 100 million docs/node and there is a reasonable chance that a node here and there will log messages about reducing cache sizes due to memory pressure (I am not really sure it is a good idea to do this at all, reducing caches during stress rarely improves anything) or full GC.&lt;/p&gt;

&lt;p&gt;The thought about the master controlled compaction would not really affect network splits etc.&lt;/p&gt;

&lt;p&gt;Reconciliation after a network split is really as complex with or without a master. We need to get back to a state where all the nodes have the same data anyway which is a complex task anyway.&lt;/p&gt;

&lt;p&gt;This is more a consideration of the fact that we do not necessarily need to live in quorum based world during compaction and we are free to use alternative approaches in the compaction without changing read/write path or affecting availability. Master selection is not really a problem here. Start compaction, talk to other nodes with the same token ranges, select a leader. &lt;/p&gt;

&lt;p&gt;Does not even have to be the same master every time and could consider if we could make compaction part of a background read repair to reduce the amount of times we need to read/write data. &lt;/p&gt;

&lt;p&gt;For instance, if we can verify that the oldest/biggest sstables is 100% in sync with data on other replicas when it is compacted (why not do it during compaction when we go through the data anyway rather than later?),can we use that info to optimize the scans done during repairs by only using data in sstables with data received after some checkpoint in time as the starting point for the consistency check?&lt;/p&gt;</comment>
                            <comment id="13055493" author="jbellis" created="Mon, 27 Jun 2011 12:21:22 +0000"  >&lt;blockquote&gt;&lt;p&gt;I am not really sure it is a good idea to do this at all, reducing caches during stress rarely improves anything&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;(This is on by default because the most common cause of OOMing is people configuring their caches too large.)&lt;/p&gt;

&lt;p&gt;It sounds odd to me that repair would balloon memory usage dramatically.  Do you have monitoring graphs that show the difference in heap usage between &quot;normal&quot; and &quot;repair in progress?&quot;&lt;/p&gt;</comment>
                            <comment id="13057339" author="terjem" created="Wed, 29 Jun 2011 16:42:57 +0000"  >&lt;p&gt;This is what heap looks like when GC start slowing things down so much that even gossip gets delayed long enough for nodes to be down for some seconds.&lt;/p&gt;

&lt;p&gt;  num     #instances         #bytes  class name&lt;br/&gt;
----------------------------------------------&lt;br/&gt;
   1:       9453188      453753024  java.nio.HeapByteBuffer&lt;br/&gt;
   2:      10081546      392167064  [B&lt;br/&gt;
   3:       7616875      243740000  org.apache.cassandra.db.Column&lt;br/&gt;
   4:       9739914      233757936  java.util.concurrent.ConcurrentSkipListMap$Node&lt;br/&gt;
   5:       4131938       99166512  java.util.concurrent.ConcurrentSkipListMap$Index&lt;br/&gt;
   6:       1549230       49575360  org.apache.cassandra.db.DeletedColumn&lt;/p&gt;

&lt;p&gt;I guess this really ends up maybe being the mix of everything going on in total and all the reading and writing that may occur when repair runs (valiadation compactions, streaming, normal compactions and regular traffic all at the same time and maybe many CFs at the same time).&lt;/p&gt;

&lt;p&gt;However, I have suspected for some time that our young size was a bit on the small side and after increasing it and giving the heap a few more GB to work with, it seems like things are behaving quite a bit better.&lt;/p&gt;

&lt;p&gt;I mentioned issues with this patch when testing for &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-2521&quot; title=&quot;Move away from Phantom References for Compaction/Memtable&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-2521&quot;&gt;&lt;del&gt;CASSANDRA-2521&lt;/del&gt;&lt;/a&gt;. That was a problem caused by me. Was playing around with git for the first time and I manage to apply 2816 to a different branch than the one I used for testing.... &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/sad.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;My appologies. &lt;/p&gt;

&lt;p&gt;Initial testing with that corrected looks a lot better for my small scale test case, but I noticed one time where I deleted an sstable and restarted. It did not get repaired (repair scanned but did nothing).&lt;/p&gt;

&lt;p&gt;Not entirely sure what to make out of that, I then tested to delete another sstable and repair started running.&lt;/p&gt;

&lt;p&gt;I will test more over the next days. &lt;/p&gt;</comment>
                            <comment id="13059445" author="terjem" created="Mon, 4 Jul 2011 14:02:46 +0000"  >&lt;p&gt;Things definitely seems to be improved overall, but weird things still happens.&lt;/p&gt;

&lt;p&gt;So... 12 node cluster, this is maybe ugly, I know, but start repair on all of them.&lt;br/&gt;
Most nodes are fine, but one goes crazy. Disk use is now 3-4 times what it was before the repair started, and it does not seem to be done yet.&lt;/p&gt;

&lt;p&gt;I have really no idea if this is the case, but I am getting the hunch that this node has ended up streaming out some of the data it is getting in. Would this be possible?&lt;/p&gt;</comment>
                            <comment id="13059459" author="slebresne" created="Mon, 4 Jul 2011 14:30:28 +0000"  >&lt;blockquote&gt;&lt;p&gt;So... 12 node cluster, this is maybe ugly, I know, but start repair on all of them.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Is it started on all of them ? If so, this is &quot;kind of&quot; expected in the sense that the patch assumes that each node does not do more than 2 repairs (for any column family) at the same time (this is configurable through the new concurrent_validators option, but it&apos;s probably better to stick to 2 and stagger the repair). If you do more than that (that is, if you did repair on all node at the same time and RF&amp;gt;2), then we&apos;re back on our old demons.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I have really no idea if this is the case, but I am getting the hunch that this node has ended up streaming out some of the data it is getting in. Would this be possible?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Not really. That is, it could be that you create a merkle tree on some data and once you start streaming you, you&apos;re picking up data that was just streamed to you and wasn&apos;t there when computing the tree. This patch is suppose to fixes this in parts, but this can still happen if you do repairs in parallel on neighboring nodes. However, you shouldn&apos;t get into a situation where 2 nodes stream forever because they pick up what is just streamed to them for instance, because what is streaming is determined at the very beginning of the streaming session.&lt;/p&gt;

&lt;p&gt;So my first question would be, was all those repair started in parallel. If yes, you shall not do this &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;. &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-2606&quot; title=&quot;Expose through JMX the ability to repair only the primary range&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-2606&quot;&gt;&lt;del&gt;CASSANDRA-2606&lt;/del&gt;&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-2610&quot; title=&quot;Have the repair of a range repair *all* the replica for that range&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-2610&quot;&gt;&lt;del&gt;CASSANDRA-2610&lt;/del&gt;&lt;/a&gt; are here to help making the repair of a full cluster much easier (and efficient), but right now it&apos;s more about getting patch in one at a time.&lt;br/&gt;
If the repairs were started one at a time in a rolling fashion, then we do have a unknown problem somewhere.&lt;/p&gt;</comment>
                            <comment id="13059485" author="terjem" created="Mon, 4 Jul 2011 15:37:17 +0000"  >&lt;p&gt;Cool!&lt;/p&gt;

&lt;p&gt;Then you confirmed what I have sort of believed for a while, but my understanding of code has been a bit in conflict with:&lt;br/&gt;
&lt;a href=&quot;http://wiki.apache.org/cassandra/Operations&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://wiki.apache.org/cassandra/Operations&lt;/a&gt;&lt;br/&gt;
which says:&lt;br/&gt;
&quot;It is safe to run repair against multiple machines at the same time, but to minimize the impact on your application workload it is recommended to wait for it to complete on one node before invoking it against the next.&quot;&lt;/p&gt;

&lt;p&gt;I have always read that as &quot;if you have the HW, go for it!&quot;&lt;/p&gt;

&lt;p&gt;May I change to:&lt;br/&gt;
&quot;It is safe to run repair against multiple machines at the same time. However, to minimize the amount of data transferred during a repair, careful synchronization is required between the nodes taking part of the repair. &lt;/p&gt;

&lt;p&gt;This is difficult to do if nodes with the same data replicas runs repair at the same time and doing so can in extreme cases generate excessive transfers of data. &lt;/p&gt;

&lt;p&gt;Improvements is being worked on, but for now, avoid scheduling repair on several nodes with replicas of the same data at the same time.&quot;&lt;/p&gt;
</comment>
                            <comment id="13059636" author="terjem" created="Mon, 4 Jul 2011 23:18:36 +0000"  >&lt;p&gt;Regardless of change of documentation however, I don&apos;t think it should be possible to actually trigger a scenario like this in the first place.&lt;/p&gt;

&lt;p&gt;The system should protect the user from that.&lt;/p&gt;

&lt;p&gt;I also noticed that in this case, we have RF3. The node which is going somewhat crazy is number &quot;6&quot;, however during the repair, it does log that it talks compares and streams data with node 4, 5, 7 and 8.&lt;/p&gt;

&lt;p&gt;Seems like a couple of nodes too many?&lt;/p&gt;</comment>
                            <comment id="13059637" author="terjem" created="Mon, 4 Jul 2011 23:18:36 +0000"  >&lt;p&gt;Regardless of change of documentation however, I don&apos;t think it should be possible to actually trigger a scenario like this in the first place.&lt;/p&gt;

&lt;p&gt;The system should protect the user from that.&lt;/p&gt;

&lt;p&gt;I also noticed that in this case, we have RF3. The node which is going somewhat crazy is number &quot;6&quot;, however during the repair, it does log that it talks compares and streams data with node 4, 5, 7 and 8.&lt;/p&gt;

&lt;p&gt;Seems like a couple of nodes too many?&lt;/p&gt;</comment>
                            <comment id="13059643" author="jbellis" created="Tue, 5 Jul 2011 00:05:38 +0000"  >&lt;blockquote&gt;&lt;p&gt;May I change to&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Sure.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;The system should protect the user from that&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;m not sure that in a p2p design we can posit an omniscient &quot;the system.&quot;&lt;/p&gt;</comment>
                            <comment id="13059655" author="terjem" created="Tue, 5 Jul 2011 01:23:06 +0000"  >&lt;blockquote&gt;&lt;p&gt;I&apos;m not sure that in a p2p design we can posit an omniscient &quot;the system.&quot;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Is that a philosophical statement? &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;As Cassandra, at least for now, is a p2p network with fairly clearly defined boundaries, I will continue calling it a &quot;system&quot; for now &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;However, looking at it from the p2p viewpoint, the user potentially have no clue about where replicas are stored and given this, it may be impossible for the user to issue repair manually on more than one node at a time without getting in trouble. Given a large enough p2p setup, it would also be non-trivial to actually schedule a complete repair without ending up with 2 or more repairs running on the same replica set.&lt;/p&gt;

&lt;p&gt;Since Cassandra do no checkpoint the synchronization so it is forced to rescan everything on every repair, repairs easily take so long that you are forced to run it on several nodes at a time if you are going to manage to finish repairing all nodes in 10 days...&lt;/p&gt;

&lt;p&gt;Anyway, this is way outside the scope of this jira &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="13059658" author="terjem" created="Tue, 5 Jul 2011 02:07:40 +0000"  >&lt;blockquote&gt;&lt;p&gt;I also noticed that in this case, we have RF3. The node which is going somewhat crazy is number &quot;6&quot;, however during the repair, it does log that it talks compares and streams data with node 4, 5, 7 and 8.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This is maybe correct. Node 7 will replicate to node 6 and 8 so 6 and 8 would share data.&lt;/p&gt;

&lt;p&gt;So, to make things safe, even with this patch, every 4th node can run repair at the same time if RF=3?, but you still need to run repair on each of those 4 nodes to make sure it is all repaired?&lt;/p&gt;

&lt;p&gt;As for the comment I made earlier.&lt;/p&gt;

&lt;p&gt;To me, it looks like if the repair start triggering transfers on a large scale, the file the node get streamed in will not be streamed out, but this may get compacted before the repair finished and the compacted file I suspect gets streamed out and the repair just never finishe&lt;/p&gt;</comment>
                            <comment id="13059962" author="jbellis" created="Tue, 5 Jul 2011 15:42:38 +0000"  >&lt;blockquote&gt;&lt;p&gt;The patch implements the idea of scheduling the merkle tree requests one by one, to make sure the tree are started as close as possible of &quot;the same time&quot;. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Can you point out where this happens in AES?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;This also put validation compaction in their own executor (to avoid them to be queued up behind standard compactions). That specific executor is created with 2 core threads, to allow for Peter&apos;s use case of wanting to do multiple repairs at the same time. That is, by default, you can do 2 repairs involving the same node and be ok&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That feels like the wrong default to me.  I think you can make a case for one (minimal interference with the rest of the system) or unlimited (no weird &quot;cliff&quot; to catch the unwary repair operator).  But two is weird. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="13059991" author="slebresne" created="Tue, 5 Jul 2011 16:32:29 +0000"  >&lt;blockquote&gt;&lt;p&gt;Can you point out where this happens in AES?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Mostly in AES.rendezvous and AES.RepairSession. Basically, RepairSession creates a queue of jobs, a job representing the repair of a given column family (for a given range, but that comes from the session itself). AES.rendezvous is then call for each received merkleTree. It waits to have all the merkeTree for the first job in the queue. When that is done, it dequeue the job (computing the merkle tree differences and scheduling streaming accordingly) and send the tree request for the next job in the queue.&lt;br/&gt;
Moreover, in StorageService.forceTableRepair(), when scheduling the repair for all the ranges of the node, we actually start the session for the first range and wait for all the &quot;jobs&quot; for this range to be done before starting the next session.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;That feels like the wrong default to me. I think you can make a case for one (minimal interference with the rest of the system) or unlimited (no weird &quot;cliff&quot; to catch the unwary repair operator). But two is weird.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Well the rational was the following one: if you set it to two, then you&apos;re saying that as soon as you start 2 repairs in parallel, they will start being inaccurate. But as Peter was suggesting (maybe in another ticket but anyway), if you have huge CF and tiny ones, it&apos;s nice to be able to repair on the tiny ones while a repair on the huge one(s) is running. Now, making it unlimited feels dangerous, because if you do so, it means that if the use start a lot of repair, all the validation compaction will start right away. This will kill the cluster (at least a few nodes if all those repair were started on the same node). It sounded better to have degraded precision for repair in those cases rather than basically killing the nodes. Maybe 2 or 4 may be a better default than 2, but 1 is a bit limited and unlimited is clearly much too dangerous.&lt;/p&gt;</comment>
                            <comment id="13064874" author="jbellis" created="Wed, 13 Jul 2011 21:30:21 +0000"  >&lt;blockquote&gt;&lt;p&gt;making it unlimited feels dangerous, because if you do so, it means that if the use start a lot of repair, all the validation compaction will start right away&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;But the easy solution is &quot;don&apos;t do that.&quot;&lt;/p&gt;

&lt;p&gt;By setting a finite number greater than one, you have to restart machines when you realize &quot;oh, I want to have 3 simultaneous now.&quot;&lt;/p&gt;

&lt;p&gt;I&apos;d rather keep it simple: make it unbounded, no configuration settings.  If you ignore the instructions to only run one repair at once, then either you know what you&apos;re doing (maybe you have SSDs) or you will find out very quickly and never do it again. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="13064898" author="scode" created="Wed, 13 Jul 2011 21:57:30 +0000"  >&lt;p&gt;I&apos;m kinda +1 on the simple version w/o bounds but not too fussy since I can obviously set it very high for my use case. In any case, the most important part for mixed small/large type of situation is that concurrent repair is possible, even if configuration changes are needed.&lt;/p&gt;</comment>
                            <comment id="13067011" author="jbellis" created="Mon, 18 Jul 2011 13:09:59 +0000"  >&lt;blockquote&gt;&lt;p&gt;I&apos;m kinda +1 on the simple version w/o bounds&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Me too.  +1 with that change.&lt;/p&gt;</comment>
                            <comment id="13067019" author="jbellis" created="Mon, 18 Jul 2011 13:24:09 +0000"  >&lt;p&gt;(I&apos;ll go ahead and submit a version with that change.)&lt;/p&gt;</comment>
                            <comment id="13067051" author="jbellis" created="Mon, 18 Jul 2011 14:26:49 +0000"  >&lt;p&gt;rebased and switched to unbounded executor for validations.&lt;/p&gt;

&lt;p&gt;tests do not compile but I believe that was already the case w/ v1 &amp;#8211; not sure what to do with blockUntilRunning, which was removed.&lt;/p&gt;</comment>
                            <comment id="13068254" author="slebresne" created="Wed, 20 Jul 2011 10:05:25 +0000"  >&lt;blockquote&gt;&lt;p&gt;rebased&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;You rebased it against trunk while the fix version is still 0.8.2. I agree that this feel a bigger change that what we would want for a minor release, but repair is really a major pain point for users. And to tell the truth, it&apos;s worth in 0.8 than it is in 0.7 because even though the problem this patch solves exists in 0.7 as well, the splitting into range of repair made for 0.8 exacerbate those problems. Moreover this patch is fairly well delimited in what it changes, and it don&apos;t make any change to the wire protocol or anything that would make upgrades a problem. So I&apos;m actually in favor of taking the small risk of pushing that in 0.8.2 (and be very vigilant to test repair extensively before the release). So for now, attaching a rebase with tests fixed against 0.8.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;and switched to unbounded executor for validations.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Ok, I realize that I&apos;m not sure I understand what you mean by unbounded executor. In you rebased version, the ValidationExecutor apparently use the first constructor of DebuggableThreadPoolExecutor that will construct a mono-threaded executor, which is not what we want. Sure the queue of the executor will be unbounded, but if that was the problem, there was a misunderstanding, because the queue has always been unbounded, even in my initial patch. What concurrent_validators was dealing with is the number of core threads. And we need multiple core threads if we want to allow multiple concurrent repairs to work correctly.&lt;/p&gt;

&lt;p&gt;Now the idea behind a default of 2 for the core threads was because I see a reason to want 2 concurrent repairs, but I don&apos;t see a very good reason to want more (and it&apos;s configurable if someone really need more). I&apos;m glad to say it&apos;s not a marvelous default and the patch I&apos;ve just attached used the same default than concurrent_compactors which is maybe less &quot;random&quot;. Now we could have an executor with unbounded threads, that spawn a thread if needed making sure we never queue validation compaction, but that seems a little bit dangerous to me. It seems more reasonable to me to have a (configurable) reasonable number of threads and let validation queue up if the user start more than that number of concurrent repair (which will impact the precision of those repair, but it would be the user fault and it&apos;s a better way to deal with such fault than starting an unreasonable number of validation compaction that will starve memory (on likely more than one node btw)). But if you still think that it&apos;s better to have an unbounded number of threads, I won&apos;t fight over this.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;tests do not compile but I believe that was already the case w/ v1&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes, I completely forgot to update the unit tests, sorry. Attached patch fixes those.&lt;/p&gt;</comment>
                            <comment id="13068492" author="jbellis" created="Wed, 20 Jul 2011 17:11:43 +0000"  >&lt;p&gt;v4 attached against 0.8 with a corrected uncapped validation executor.&lt;/p&gt;</comment>
                            <comment id="13068508" author="slebresne" created="Wed, 20 Jul 2011 17:45:56 +0000"  >&lt;p&gt;I think that if we don&apos;t want validation executor of v4 to ever queue tasks (which is what we need), then we need the executor queue to be a bounded queue of size 0 (i.e. that doesn&apos;t accept element). Indeed, as per the documentation of ThreadPoolExecutor:&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;If corePoolSize or more threads are running, the Executor always prefers queuing a request rather than adding a new thread.
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt; </comment>
                            <comment id="13068523" author="jbellis" created="Wed, 20 Jul 2011 18:08:00 +0000"  >&lt;p&gt;You&apos;re right.  v5 attached.&lt;/p&gt;</comment>
                            <comment id="13068907" author="slebresne" created="Thu, 21 Jul 2011 11:12:09 +0000"  >&lt;p&gt;Alright, v5 looks good to me. Committed, thanks.&lt;/p&gt;</comment>
                            <comment id="13068953" author="hudson" created="Thu, 21 Jul 2011 12:31:54 +0000"  >&lt;p&gt;Integrated in Cassandra-0.8 #231 (See &lt;a href=&quot;https://builds.apache.org/job/Cassandra-0.8/231/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/Cassandra-0.8/231/&lt;/a&gt;)&lt;br/&gt;
    Properly synchronize merkle tree computation&lt;br/&gt;
patch by slebresne; reviewed by jbellis for &lt;a href=&quot;https://issues.apache.org/jira/browse/CASSANDRA-2816&quot; title=&quot;Repair doesn&amp;#39;t synchronize merkle tree creation properly&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CASSANDRA-2816&quot;&gt;&lt;del&gt;CASSANDRA-2816&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;slebresne : &lt;a href=&quot;http://svn.apache.org/viewcvs.cgi/?root=Apache-SVN&amp;amp;view=rev&amp;amp;rev=1149121&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://svn.apache.org/viewcvs.cgi/?root=Apache-SVN&amp;amp;view=rev&amp;amp;rev=1149121&lt;/a&gt;&lt;br/&gt;
Files : &lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;/cassandra/branches/cassandra-0.8/test/unit/org/apache/cassandra/service/AntiEntropyServiceTestAbstract.java&lt;/li&gt;
	&lt;li&gt;/cassandra/branches/cassandra-0.8/src/java/org/apache/cassandra/service/AntiEntropyService.java&lt;/li&gt;
	&lt;li&gt;/cassandra/branches/cassandra-0.8/CHANGES.txt&lt;/li&gt;
	&lt;li&gt;/cassandra/branches/cassandra-0.8/conf/cassandra.yaml&lt;/li&gt;
	&lt;li&gt;/cassandra/branches/cassandra-0.8/src/java/org/apache/cassandra/service/StorageService.java&lt;/li&gt;
	&lt;li&gt;/cassandra/branches/cassandra-0.8/src/java/org/apache/cassandra/concurrent/DebuggableThreadPoolExecutor.java&lt;/li&gt;
	&lt;li&gt;/cassandra/branches/cassandra-0.8/src/java/org/apache/cassandra/db/compaction/CompactionManager.java&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    </comments>
                    <attachments>
                            <attachment id="12483711" name="0001-Schedule-merkle-tree-request-one-by-one.patch" size="34723" author="slebresne" created="Fri, 24 Jun 2011 14:05:20 +0000"/>
                            <attachment id="12486871" name="2816-v2.txt" size="35742" author="jbellis" created="Mon, 18 Jul 2011 14:26:49 +0000"/>
                            <attachment id="12487185" name="2816-v4.txt" size="37094" author="jbellis" created="Wed, 20 Jul 2011 17:11:42 +0000"/>
                            <attachment id="12487191" name="2816-v5.txt" size="37222" author="jbellis" created="Wed, 20 Jul 2011 18:08:00 +0000"/>
                            <attachment id="12487133" name="2816_0.8_v3.patch" size="40012" author="slebresne" created="Wed, 20 Jul 2011 10:05:25 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>5.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12313920" key="com.atlassian.jira.plugin.system.customfieldtypes:multiuserpicker">
                        <customfieldname>Authors</customfieldname>
                        <customfieldvalues>
                                    <customfieldvalue><![CDATA[slebresne]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>20845</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            14 years, 18 weeks, 5 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i0gdmv:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>93639</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_10022" key="com.atlassian.jira.plugin.system.customfieldtypes:userpicker">
                        <customfieldname>Reviewer</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>jbellis</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12313420" key="com.atlassian.jira.plugin.system.customfieldtypes:multiuserpicker">
                        <customfieldname>Reviewers</customfieldname>
                        <customfieldvalues>
                                    <customfieldvalue><![CDATA[jbellis]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12313820" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Severity</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="12962"><![CDATA[Normal]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>