{"url":"https://api.github.com/repos/dotnet/efcore/issues/36464","repository_url":"https://api.github.com/repos/dotnet/efcore","labels_url":"https://api.github.com/repos/dotnet/efcore/issues/36464/labels{/name}","comments_url":"https://api.github.com/repos/dotnet/efcore/issues/36464/comments","events_url":"https://api.github.com/repos/dotnet/efcore/issues/36464/events","html_url":"https://github.com/dotnet/efcore/issues/36464","id":3274517458,"node_id":"I_kwDOAPaMMs7DLSvS","number":36464,"title":"Utf8JsonReaderManager leaks memory via reference to IDiagnosticsLogger<DbLoggerCategory.Query>","user":{"login":"christiaanderidder","id":1276085,"node_id":"MDQ6VXNlcjEyNzYwODU=","avatar_url":"https://avatars.githubusercontent.com/u/1276085?v=4","gravatar_id":"","url":"https://api.github.com/users/christiaanderidder","html_url":"https://github.com/christiaanderidder","followers_url":"https://api.github.com/users/christiaanderidder/followers","following_url":"https://api.github.com/users/christiaanderidder/following{/other_user}","gists_url":"https://api.github.com/users/christiaanderidder/gists{/gist_id}","starred_url":"https://api.github.com/users/christiaanderidder/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/christiaanderidder/subscriptions","organizations_url":"https://api.github.com/users/christiaanderidder/orgs","repos_url":"https://api.github.com/users/christiaanderidder/repos","events_url":"https://api.github.com/users/christiaanderidder/events{/privacy}","received_events_url":"https://api.github.com/users/christiaanderidder/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[{"id":130861068,"node_id":"MDU6TGFiZWwxMzA4NjEwNjg=","url":"https://api.github.com/repos/dotnet/efcore/labels/area-perf","name":"area-perf","color":"5319e7","default":false,"description":""},{"id":936619505,"node_id":"MDU6TGFiZWw5MzY2MTk1MDU=","url":"https://api.github.com/repos/dotnet/efcore/labels/customer-reported","name":"customer-reported","color":"a4a5f9","default":false,"description":""},{"id":1017558838,"node_id":"MDU6TGFiZWwxMDE3NTU4ODM4","url":"https://api.github.com/repos/dotnet/efcore/labels/Servicing-approved","name":"Servicing-approved","color":"048708","default":false,"description":""},{"id":3281025791,"node_id":"MDU6TGFiZWwzMjgxMDI1Nzkx","url":"https://api.github.com/repos/dotnet/efcore/labels/priority-bug","name":"priority-bug","color":"1E3932","default":false,"description":"Issues which requires API breaks and have bigger impact hence should be fixed earlier in the release"},{"id":9022438466,"node_id":"LA_kwDOAPaMMs8AAAACGcd8Qg","url":"https://api.github.com/repos/dotnet/efcore/labels/rc-2","name":"rc-2","color":"ACB3D7","default":false,"description":""}],"state":"closed","locked":false,"assignee":{"login":"roji","id":1862641,"node_id":"MDQ6VXNlcjE4NjI2NDE=","avatar_url":"https://avatars.githubusercontent.com/u/1862641?v=4","gravatar_id":"","url":"https://api.github.com/users/roji","html_url":"https://github.com/roji","followers_url":"https://api.github.com/users/roji/followers","following_url":"https://api.github.com/users/roji/following{/other_user}","gists_url":"https://api.github.com/users/roji/gists{/gist_id}","starred_url":"https://api.github.com/users/roji/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/roji/subscriptions","organizations_url":"https://api.github.com/users/roji/orgs","repos_url":"https://api.github.com/users/roji/repos","events_url":"https://api.github.com/users/roji/events{/privacy}","received_events_url":"https://api.github.com/users/roji/received_events","type":"User","user_view_type":"public","site_admin":false},"assignees":[{"login":"roji","id":1862641,"node_id":"MDQ6VXNlcjE4NjI2NDE=","avatar_url":"https://avatars.githubusercontent.com/u/1862641?v=4","gravatar_id":"","url":"https://api.github.com/users/roji","html_url":"https://github.com/roji","followers_url":"https://api.github.com/users/roji/followers","following_url":"https://api.github.com/users/roji/following{/other_user}","gists_url":"https://api.github.com/users/roji/gists{/gist_id}","starred_url":"https://api.github.com/users/roji/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/roji/subscriptions","organizations_url":"https://api.github.com/users/roji/orgs","repos_url":"https://api.github.com/users/roji/repos","events_url":"https://api.github.com/users/roji/events{/privacy}","received_events_url":"https://api.github.com/users/roji/received_events","type":"User","user_view_type":"public","site_admin":false}],"milestone":null,"comments":4,"created_at":"2025-07-29T18:05:36Z","updated_at":"2025-09-15T09:53:32Z","closed_at":"2025-09-15T09:53:27Z","author_association":"NONE","type":{"id":1092402,"node_id":"IT_kwDOAIt-yc4AEKsy","name":"Bug","description":"An unexpected problem or behavior","color":"red","created_at":"2024-01-25T11:45:43Z","updated_at":"2024-07-26T10:20:14Z","is_enabled":true},"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"### Bug description\n\nWe have a long running hosted worker that performs batch processing operations and noticed that it leaks memory. After investigation the leak happens because entries in the compiled query cache capture change tracker data via IDiagnosticsLogger<DbLoggerCategory.Query>.\n\nThe leak shows a similar path as reported in https://github.com/dotnet/efcore/issues/21016\n\nAfter investigation the logs seem to be pointing to Utf8JsonReaderManager.QueryLogger being captured as a constant value in the cached expression, causing the change tracker data to end up in the query cache:\n```\n jsonReaderManager = new Utf8JsonReaderManager(\n    jsonReader, \n    [LIFTABLE Constant: DiagnosticsLogger<Query> | Resolver: c => c.Dependencies.QueryLogger]\n);\n```\n\nA dotMemory snapshot shows how the query cache for the `LeakyEntity` query retains a reference to the unrelated `UnrelatedEntity`.\n\n<img width=\"1036\" height=\"743\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/000eed77-1726-4bd5-a315-1204949c588b\" />\n\nAttached reproduction code requires running `dotnet ef migrations add InitialCreate` first. Problem was observed in production for SqlServer, but can be reproduced using Sqlite\n\n\n### Your code\n\n```csharp\nusing System.ComponentModel.DataAnnotations;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\n\nawait Setup();\nawait TriggerLeak();\n\n// Wait for memory snapshot\nConsole.ReadLine();\n\nreturn;\n\nstatic async Task Setup()\n{\n    await using var db = new LeakDbContext(false);\n    await db.Database.EnsureDeletedAsync();\n    await db.Database.MigrateAsync();\n    \n    db.LeakyEntities.Add(new LeakyEntity { Id = 1, JsonData = new JsonData { Author = \"John Doe\" } });\n    db.UnrelatedEntities.Add(new UnrelatedEntity { Id = 1, Content = \"ABC\" });\n    db.UnrelatedEntities.Add(new UnrelatedEntity { Id = 2, Content = \"123\" });\n    \n    await db.SaveChangesAsync();\n    \n    GC.Collect(GC.MaxGeneration, GCCollectionMode.Forced, true, true);\n}\n\nstatic async Task TriggerLeak()\n{\n    await using var db2 = new LeakDbContext(true);\n    \n    // This will cache the query for the leaky entity, which contains a reference to the change tracker\n    var leakyEntities = await db2.LeakyEntities.ToListAsync();\n    // This will fetch unrelated entities which will be tracked in the change tracker and therefore leaked\n    var unrelatedEntities = await db2.UnrelatedEntities.ToListAsync();\n    \n    // Clean up to show we are leaking\n    GC.Collect(GC.MaxGeneration, GCCollectionMode.Forced, true, true);\n}\n\npublic class LeakDbContext : DbContext\n{\n    private readonly bool _enableLog;\n    public DbSet<LeakyEntity> LeakyEntities { get; set; }\n    public DbSet<UnrelatedEntity> UnrelatedEntities { get; set; }\n\n    public LeakDbContext() : this(false) { }\n    public LeakDbContext(bool enableLog) => _enableLog = enableLog;\n\n    protected override void OnConfiguring(DbContextOptionsBuilder options)\n        => options.UseSqlite($\"Data Source={Path.Join(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), \"ef-core-leak.db\")}\")\n            .LogTo(Console.WriteLine, _enableLog ? LogLevel.Trace : LogLevel.None);\n\n    protected override void OnModelCreating(ModelBuilder modelBuilder)\n        => modelBuilder.Entity<LeakyEntity>().OwnsOne(p => p.JsonData, b => b.ToJson());\n}\n\npublic class LeakyEntity\n{\n    public int Id { get; init; }\n    public required JsonData JsonData { get; init; }\n}\n\npublic class UnrelatedEntity\n{\n    public int Id { get; init; }\n    [MaxLength(200)] public required string Content { get; init; }\n}\n\npublic class JsonData\n{\n    [MaxLength(200)] public required string Author { get; init; }\n}\n```\n\n### Stack traces\n\n```text\ndbug: 29/07/2025 20:03:41.547 CoreEventId.ContextInitialized[10403] (Microsoft.EntityFrameworkCore.Infrastructure) \n      Entity Framework Core 9.0.7 initialized 'LeakDbContext' using provider 'Microsoft.EntityFrameworkCore.Sqlite:9.0.7' with options: None\ndbug: 29/07/2025 20:03:41.569 CoreEventId.QueryCompilationStarting[10111] (Microsoft.EntityFrameworkCore.Query) \n      Compiling query expression: \n      'DbSet<LeakyEntity>()'\ndbug: 29/07/2025 20:03:41.582 CoreEventId.NavigationBaseIncluded[10112] (Microsoft.EntityFrameworkCore.Query) \n      Including navigation: 'LeakyEntity.JsonData'.\ndbug: 29/07/2025 20:03:41.746 CoreEventId.QueryExecutionPlanned[10107] (Microsoft.EntityFrameworkCore.Query) \n      Generated query execution expression: \n      'queryContext => SingleQueryingEnumerable.Create<LeakyEntity>(\n          relationalQueryContext: (RelationalQueryContext)queryContext, \n          relationalCommandResolver: parameters => [LIFTABLE Constant: RelationalCommandCache.QueryExpression(\n              Client Projections:\n                  0 -> Dictionary<IProperty, int> { [Property: LeakyEntity.Id (int) Required PK AfterSave:Throw ValueGenerated.OnAdd, 0] }\n                  1 -> JsonProjectionInfo\n              SELECT l.Id, l.JsonData -> \n              FROM LeakyEntities AS l) | Resolver: c => new RelationalCommandCache(\n              c.Dependencies.MemoryCache, \n              c.RelationalDependencies.QuerySqlGeneratorFactory, \n              c.RelationalDependencies.RelationalParameterBasedSqlProcessorFactory, \n              Client Projections:\n                  0 -> Dictionary<IProperty, int> { [Property: LeakyEntity.Id (int) Required PK AfterSave:Throw ValueGenerated.OnAdd, 0] }\n                  1 -> JsonProjectionInfo\n              SELECT l.Id, l.JsonData -> \n              FROM LeakyEntities AS l, \n              False, \n              new HashSet<string>(\n                  new string[]{ }, \n                  StringComparer.Ordinal\n              )\n          )].GetRelationalCommandTemplate(parameters), \n          readerColumns: null, \n          shaper: (queryContext, dataReader, resultContext, resultCoordinator) => \n          {\n              LeakyEntity entity;\n              Stream jsonStream;\n              JsonReaderData jsonReader;\n              Utf8JsonReaderManager jsonReaderManager;\n              object[] currentKeyValues;\n              entity = \n              {\n                  MaterializationContext materializationContext1;\n                  IEntityType entityType1;\n                  LeakyEntity instance1;\n                  InternalEntityEntry entry1;\n                  bool hasNullKey1;\n                  materializationContext1 = new MaterializationContext(\n                      [LIFTABLE Constant: ValueBuffer | Resolver: _ => (object)ValueBuffer.Empty], \n                      queryContext.Context\n                  );\n                  instance1 = default(LeakyEntity);\n                  entry1 = queryContext.TryGetEntry(\n                      key: [LIFTABLE Constant: Key: LeakyEntity.Id PK | Resolver: c => c.Dependencies.Model.FindEntityType(\"LeakyEntity\").FindPrimaryKey()], \n                      keyValues: new object[]{ (object)dataReader.GetInt32(0) }, \n                      throwOnNullKey: True, \n                      hasNullKey: hasNullKey1);\n                  !(hasNullKey1) ? entry1 != default(InternalEntityEntry) ? \n                  {\n                      entityType1 = entry1.EntityType;\n                      return instance1 = (LeakyEntity)entry1.Entity;\n                  } : \n                  {\n                      ISnapshot shadowSnapshot1;\n                      shadowSnapshot1 = [LIFTABLE Constant: Snapshot | Resolver: _ => Snapshot.Empty];\n                      entityType1 = [LIFTABLE Constant: EntityType: LeakyEntity | Resolver: namelessParameter{0} => namelessParameter{0}.Dependencies.Model.FindEntityType(\"LeakyEntity\")];\n                      instance1 = switch (entityType1)\n                      {\n                          case [LIFTABLE Constant: EntityType: LeakyEntity | Resolver: namelessParameter{1} => namelessParameter{1}.Dependencies.Model.FindEntityType(\"LeakyEntity\")]: \n                              {\n                                  return \n                                  {\n                                      LeakyEntity instance;\n                                      instance = new LeakyEntity();\n                                      instance.<Id>k__BackingField = dataReader.GetInt32(0);\n                                      (instance is IInjectableService) ? ((IInjectableService)instance).Injected(\n                                          context: materializationContext1.Context, \n                                          entity: instance, \n                                          queryTrackingBehavior: TrackAll, \n                                          structuralType: [LIFTABLE Constant: EntityType: LeakyEntity | Resolver: namelessParameter{2} => namelessParameter{2}.Dependencies.Model.FindEntityType(\"LeakyEntity\")]) : default(void);\n                                      return instance;\n                                  }}\n                          default: \n                              default(LeakyEntity)\n                      }\n                      ;\n                      entry1 = entityType1 == default(IEntityType) ? default(InternalEntityEntry) : queryContext.StartTracking(\n                          entityType: entityType1, \n                          entity: instance1, \n                          snapshot: shadowSnapshot1);\n                      return instance1;\n                  } : default(void);\n                  return instance1;\n              };\n              jsonStream = dataReader.IsDBNull(1) ? default(MemoryStream) : new MemoryStream(Encoding.UTF8.GetBytes(dataReader.GetString(1)));\n              jsonReader = jsonStream == default(MemoryStream) ? default(JsonReaderData) : new JsonReaderData(jsonStream);\n              jsonReader != default(JsonReaderData) ? \n              {\n                  jsonReaderManager = new Utf8JsonReaderManager(\n                      jsonReader, \n                      [LIFTABLE Constant: DiagnosticsLogger<Query> | Resolver: c => c.Dependencies.QueryLogger]\n                  );\n                  jsonReaderManager.MoveNext();\n                  jsonReaderManager.CaptureState();\n              } : default(void);\n              currentKeyValues = new object[]{ (object)dataReader.GetInt32(0) };\n              ShaperProcessingExpressionVisitor.IncludeJsonEntityReference<LeakyEntity, JsonData>(\n                  queryContext: queryContext, \n                  keyPropertyValues: currentKeyValues, \n                  jsonReaderData: jsonReader, \n                  entity: entity, \n                  innerShaper: (queryContext, namelessParameter{3}, namelessParameter{4}) => \n                  {\n                      JsonData entityShaperMaterializer;\n                      return entityShaperMaterializer = \n                      {\n                          MaterializationContext materializationContext2;\n                          IEntityType entityType2;\n                          JsonData instance2;\n                          InternalEntityEntry entry2;\n                          bool hasNullKey2;\n                          materializationContext2 = new MaterializationContext(\n                              [LIFTABLE Constant: ValueBuffer | Resolver: _ => (object)ValueBuffer.Empty], \n                              queryContext.Context\n                          );\n                          instance2 = default(JsonData);\n                          entry2 = queryContext.TryGetEntry(\n                              key: [LIFTABLE Constant: Key: JsonData.LeakyEntityId PK | Resolver: c => c.Dependencies.Model.FindEntityType(\"JsonData\").FindPrimaryKey()], \n                              keyValues: new object[]{ namelessParameter{3}[0] }, \n                              throwOnNullKey: False, \n                              hasNullKey: hasNullKey2);\n                          !(hasNullKey2) ? \n                          {\n                              bool entityAlreadyTracked;\n                              ISnapshot shadowSnapshot2;\n                              entityAlreadyTracked = False;\n                              shadowSnapshot2 = [LIFTABLE Constant: Snapshot | Resolver: _ => Snapshot.Empty];\n                              entityType2 = [LIFTABLE Constant: EntityType: JsonData Owned | Resolver: namelessParameter{5} => namelessParameter{5}.Dependencies.Model.FindEntityType(\"JsonData\")];\n                              entry2 != default(InternalEntityEntry) ? \n                              {\n                                  entityType2 = entry2.EntityType;\n                                  instance2 = (JsonData)entry2.Entity;\n                                  entityAlreadyTracked = True;\n                              } : default(void);\n                              instance2 = \n                              {\n                                  Utf8JsonReaderManager jsonReaderManager;\n                                  JsonTokenType tokenType;\n                                  JsonData instance;\n                                  string namelessParameter{6};\n                                  jsonReaderManager = new Utf8JsonReaderManager(\n                                      namelessParameter{4}, \n                                      [LIFTABLE Constant: DiagnosticsLogger<Query> | Resolver: c => c.Dependencies.QueryLogger]\n                                  );\n                                  tokenType = jsonReaderManager.CurrentReader.TokenType;\n                                  Loop(Break: done Continue: )\n                                  {\n                                      {\n                                          tokenType = jsonReaderManager.MoveNext();\n                                          switch (tokenType)\n                                          {\n                                              case PropertyName: \n                                                  jsonReaderManager.CurrentReader.ValueTextEquals((ReadOnlySpan<byte>)Encoding.UTF8.GetBytes(\"Author\")\n                                                      .AsSpan()) ? \n                                                  {\n                                                      jsonReaderManager.MoveNext();\n                                                      namelessParameter{6} = (string)[LIFTABLE Constant: JsonStringReaderWriter | Resolver: c => c.Dependencies.Model.FindEntityType(\"JsonData\").FindProperty(\"Author\").GetJsonValueReaderWriter() ?? c.Dependencies.Model.FindEntityType(\"JsonData\").FindProperty(\"Author\").GetTypeMapping().JsonValueReaderWriter].FromJsonTyped(\n                                                          manager: jsonReaderManager, \n                                                          existingObject: default(object));\n                                                  } : default(void)\n                                              case EndObject: \n                                                  Goto(break done)\n                                              default: \n                                                  {\n                                                      jsonReaderManager.Skip();\n                                                  }\n                                          }\n                                      }}\n                                  jsonReaderManager.CaptureState();\n                                  !(entityAlreadyTracked) ? shadowSnapshot2 = (ISnapshot)new Snapshot<int>((int)namelessParameter{3}[0]) : default(void);\n                                  entityAlreadyTracked ? \n                                  {\n                                      instance = instance2;\n                                  } : \n                                  {\n                                      instance = new JsonData();\n                                      instance.<Author>k__BackingField = namelessParameter{6};\n                                      (instance is IInjectableService) ? ((IInjectableService)instance).Injected(\n                                          context: materializationContext2.Context, \n                                          entity: instance, \n                                          queryTrackingBehavior: TrackAll, \n                                          structuralType: [LIFTABLE Constant: EntityType: JsonData Owned | Resolver: namelessParameter{7} => namelessParameter{7}.Dependencies.Model.FindEntityType(\"JsonData\")]) : default(void);\n                                  };\n                                  return instance;\n                              };\n                              !(entityAlreadyTracked || entityType2 == default(IEntityType)) ? \n                              {\n                                  queryContext.StartTracking(\n                                      entityType: entityType2, \n                                      entity: instance2, \n                                      snapshot: shadowSnapshot2);\n                              } : default(void);\n                          } : default(void);\n                          return instance2;\n                      };\n                  }, \n                  fixup: (namelessParameter{8}, namelessParameter{9}) => \n                  {\n                      return namelessParameter{8}.<JsonData>k__BackingField = namelessParameter{9};\n                  }, \n                  trackingQuery: True);\n              return entity;\n          }, \n          contextType: LeakDbContext, \n          standAloneStateManager: False, \n          detailedErrorsEnabled: False, \n          threadSafetyChecksEnabled: True)'\ndbug: 29/07/2025 20:03:41.761 RelationalEventId.ConnectionCreating[20005] (Microsoft.EntityFrameworkCore.Database.Connection) \n      Creating DbConnection.\ndbug: 29/07/2025 20:03:41.762 RelationalEventId.ConnectionCreated[20006] (Microsoft.EntityFrameworkCore.Database.Connection) \n      Created DbConnection. (0ms).\ndbug: 29/07/2025 20:03:41.762 RelationalEventId.ConnectionOpening[20000] (Microsoft.EntityFrameworkCore.Database.Connection) \n      Opening connection to database 'main' on server '/Users/christiaan-ce/Library/Application Support/ef-core-leak.db'.\ndbug: 29/07/2025 20:03:41.763 RelationalEventId.ConnectionOpened[20001] (Microsoft.EntityFrameworkCore.Database.Connection) \n      Opened connection to database 'main' on server '/Users/christiaan-ce/Library/Application Support/ef-core-leak.db'.\ndbug: 29/07/2025 20:03:41.763 RelationalEventId.CommandCreating[20103] (Microsoft.EntityFrameworkCore.Database.Command) \n      Creating DbCommand for 'ExecuteReader'.\ndbug: 29/07/2025 20:03:41.764 RelationalEventId.CommandCreated[20104] (Microsoft.EntityFrameworkCore.Database.Command) \n      Created DbCommand for 'ExecuteReader' (0ms).\ndbug: 29/07/2025 20:03:41.764 RelationalEventId.CommandInitialized[20106] (Microsoft.EntityFrameworkCore.Database.Command) \n      Initialized DbCommand for 'ExecuteReader' (1ms).\ndbug: 29/07/2025 20:03:41.766 RelationalEventId.CommandExecuting[20100] (Microsoft.EntityFrameworkCore.Database.Command) \n      Executing DbCommand [Parameters=[], CommandType='Text', CommandTimeout='30']\n      SELECT \"l\".\"Id\", \"l\".\"JsonData\"\n      FROM \"LeakyEntities\" AS \"l\"\ninfo: 29/07/2025 20:03:41.774 RelationalEventId.CommandExecuted[20101] (Microsoft.EntityFrameworkCore.Database.Command) \n      Executed DbCommand (2ms) [Parameters=[], CommandType='Text', CommandTimeout='30']\n      SELECT \"l\".\"Id\", \"l\".\"JsonData\"\n      FROM \"LeakyEntities\" AS \"l\"\ndbug: 29/07/2025 20:03:41.777 CoreEventId.StartedTracking[10806] (Microsoft.EntityFrameworkCore.ChangeTracking) \n      Context 'LeakDbContext' started tracking 'LeakyEntity' entity. Consider using 'DbContextOptionsBuilder.EnableSensitiveDataLogging' to see key values.\ndbug: 29/07/2025 20:03:41.788 CoreEventId.ReferenceChangeDetected[10805] (Microsoft.EntityFrameworkCore.ChangeTracking) \n      The navigation 'LeakyEntity.JsonData' was detected as changed. Consider using 'DbContextOptionsBuilder.EnableSensitiveDataLogging' to see key values.\ndbug: 29/07/2025 20:03:41.789 CoreEventId.StartedTracking[10806] (Microsoft.EntityFrameworkCore.ChangeTracking) \n      Context 'LeakDbContext' started tracking 'JsonData' entity. Consider using 'DbContextOptionsBuilder.EnableSensitiveDataLogging' to see key values.\ndbug: 29/07/2025 20:03:41.789 RelationalEventId.DataReaderClosing[20301] (Microsoft.EntityFrameworkCore.Database.Command) \n      Closing data reader to 'main' on server '/Users/christiaan-ce/Library/Application Support/ef-core-leak.db'.\ndbug: 29/07/2025 20:03:41.791 RelationalEventId.DataReaderDisposing[20300] (Microsoft.EntityFrameworkCore.Database.Command) \n      A data reader for 'main' on server '/Users/christiaan-ce/Library/Application Support/ef-core-leak.db' is being disposed after spending 15ms reading results.\ndbug: 29/07/2025 20:03:41.791 RelationalEventId.ConnectionClosing[20002] (Microsoft.EntityFrameworkCore.Database.Connection) \n      Closing connection to database 'main' on server '/Users/christiaan-ce/Library/Application Support/ef-core-leak.db'.\ndbug: 29/07/2025 20:03:41.791 RelationalEventId.ConnectionClosed[20003] (Microsoft.EntityFrameworkCore.Database.Connection) \n      Closed connection to database 'main' on server '/Users/christiaan-ce/Library/Application Support/ef-core-leak.db' (0ms).\ndbug: 29/07/2025 20:03:41.791 CoreEventId.QueryCompilationStarting[10111] (Microsoft.EntityFrameworkCore.Query) \n      Compiling query expression: \n      'DbSet<UnrelatedEntity>()'\ndbug: 29/07/2025 20:03:41.793 CoreEventId.QueryExecutionPlanned[10107] (Microsoft.EntityFrameworkCore.Query) \n      Generated query execution expression: \n      'queryContext => SingleQueryingEnumerable.Create<UnrelatedEntity>(\n          relationalQueryContext: (RelationalQueryContext)queryContext, \n          relationalCommandResolver: parameters => [LIFTABLE Constant: RelationalCommandCache.QueryExpression(\n              Projection Mapping:\n                  EmptyProjectionMember -> Dictionary<IProperty, int> { [Property: UnrelatedEntity.Id (int) Required PK AfterSave:Throw ValueGenerated.OnAdd, 0], [Property: UnrelatedEntity.Content (string) Required MaxLength(200), 1] }\n              SELECT u.Id, u.Content\n              FROM UnrelatedEntities AS u) | Resolver: c => new RelationalCommandCache(\n              c.Dependencies.MemoryCache, \n              c.RelationalDependencies.QuerySqlGeneratorFactory, \n              c.RelationalDependencies.RelationalParameterBasedSqlProcessorFactory, \n              Projection Mapping:\n                  EmptyProjectionMember -> Dictionary<IProperty, int> { [Property: UnrelatedEntity.Id (int) Required PK AfterSave:Throw ValueGenerated.OnAdd, 0], [Property: UnrelatedEntity.Content (string) Required MaxLength(200), 1] }\n              SELECT u.Id, u.Content\n              FROM UnrelatedEntities AS u, \n              False, \n              new HashSet<string>(\n                  new string[]{ }, \n                  StringComparer.Ordinal\n              )\n          )].GetRelationalCommandTemplate(parameters), \n          readerColumns: null, \n          shaper: (queryContext, dataReader, resultContext, resultCoordinator) => \n          {\n              UnrelatedEntity entity;\n              entity = \n              {\n                  MaterializationContext materializationContext1;\n                  IEntityType entityType1;\n                  UnrelatedEntity instance1;\n                  InternalEntityEntry entry1;\n                  bool hasNullKey1;\n                  materializationContext1 = new MaterializationContext(\n                      [LIFTABLE Constant: ValueBuffer | Resolver: _ => (object)ValueBuffer.Empty], \n                      queryContext.Context\n                  );\n                  instance1 = default(UnrelatedEntity);\n                  entry1 = queryContext.TryGetEntry(\n                      key: [LIFTABLE Constant: Key: UnrelatedEntity.Id PK | Resolver: c => c.Dependencies.Model.FindEntityType(\"UnrelatedEntity\").FindPrimaryKey()], \n                      keyValues: new object[]{ (object)dataReader.GetInt32(0) }, \n                      throwOnNullKey: True, \n                      hasNullKey: hasNullKey1);\n                  !(hasNullKey1) ? entry1 != default(InternalEntityEntry) ? \n                  {\n                      entityType1 = entry1.EntityType;\n                      return instance1 = (UnrelatedEntity)entry1.Entity;\n                  } : \n                  {\n                      ISnapshot shadowSnapshot1;\n                      shadowSnapshot1 = [LIFTABLE Constant: Snapshot | Resolver: _ => Snapshot.Empty];\n                      entityType1 = [LIFTABLE Constant: EntityType: UnrelatedEntity | Resolver: namelessParameter{0} => namelessParameter{0}.Dependencies.Model.FindEntityType(\"UnrelatedEntity\")];\n                      instance1 = switch (entityType1)\n                      {\n                          case [LIFTABLE Constant: EntityType: UnrelatedEntity | Resolver: namelessParameter{1} => namelessParameter{1}.Dependencies.Model.FindEntityType(\"UnrelatedEntity\")]: \n                              {\n                                  return \n                                  {\n                                      UnrelatedEntity instance;\n                                      instance = new UnrelatedEntity();\n                                      instance.<Id>k__BackingField = dataReader.GetInt32(0);\n                                      instance.<Content>k__BackingField = dataReader.GetString(1);\n                                      (instance is IInjectableService) ? ((IInjectableService)instance).Injected(\n                                          context: materializationContext1.Context, \n                                          entity: instance, \n                                          queryTrackingBehavior: TrackAll, \n                                          structuralType: [LIFTABLE Constant: EntityType: UnrelatedEntity | Resolver: namelessParameter{2} => namelessParameter{2}.Dependencies.Model.FindEntityType(\"UnrelatedEntity\")]) : default(void);\n                                      return instance;\n                                  }}\n                          default: \n                              default(UnrelatedEntity)\n                      }\n                      ;\n                      entry1 = entityType1 == default(IEntityType) ? default(InternalEntityEntry) : queryContext.StartTracking(\n                          entityType: entityType1, \n                          entity: instance1, \n                          snapshot: shadowSnapshot1);\n                      return instance1;\n                  } : default(void);\n                  return instance1;\n              };\n              return entity;\n          }, \n          contextType: LeakDbContext, \n          standAloneStateManager: False, \n          detailedErrorsEnabled: False, \n          threadSafetyChecksEnabled: True)'\ndbug: 29/07/2025 20:03:41.795 RelationalEventId.ConnectionOpening[20000] (Microsoft.EntityFrameworkCore.Database.Connection) \n      Opening connection to database 'main' on server '/Users/christiaan-ce/Library/Application Support/ef-core-leak.db'.\ndbug: 29/07/2025 20:03:41.795 RelationalEventId.ConnectionOpened[20001] (Microsoft.EntityFrameworkCore.Database.Connection) \n      Opened connection to database 'main' on server '/Users/christiaan-ce/Library/Application Support/ef-core-leak.db'.\ndbug: 29/07/2025 20:03:41.795 RelationalEventId.CommandCreating[20103] (Microsoft.EntityFrameworkCore.Database.Command) \n      Creating DbCommand for 'ExecuteReader'.\ndbug: 29/07/2025 20:03:41.795 RelationalEventId.CommandCreated[20104] (Microsoft.EntityFrameworkCore.Database.Command) \n      Created DbCommand for 'ExecuteReader' (0ms).\ndbug: 29/07/2025 20:03:41.795 RelationalEventId.CommandInitialized[20106] (Microsoft.EntityFrameworkCore.Database.Command) \n      Initialized DbCommand for 'ExecuteReader' (0ms).\ndbug: 29/07/2025 20:03:41.795 RelationalEventId.CommandExecuting[20100] (Microsoft.EntityFrameworkCore.Database.Command) \n      Executing DbCommand [Parameters=[], CommandType='Text', CommandTimeout='30']\n      SELECT \"u\".\"Id\", \"u\".\"Content\"\n      FROM \"UnrelatedEntities\" AS \"u\"\ninfo: 29/07/2025 20:03:41.795 RelationalEventId.CommandExecuted[20101] (Microsoft.EntityFrameworkCore.Database.Command) \n      Executed DbCommand (0ms) [Parameters=[], CommandType='Text', CommandTimeout='30']\n      SELECT \"u\".\"Id\", \"u\".\"Content\"\n      FROM \"UnrelatedEntities\" AS \"u\"\ndbug: 29/07/2025 20:03:41.795 CoreEventId.StartedTracking[10806] (Microsoft.EntityFrameworkCore.ChangeTracking) \n      Context 'LeakDbContext' started tracking 'UnrelatedEntity' entity. Consider using 'DbContextOptionsBuilder.EnableSensitiveDataLogging' to see key values.\ndbug: 29/07/2025 20:03:41.795 CoreEventId.StartedTracking[10806] (Microsoft.EntityFrameworkCore.ChangeTracking) \n      Context 'LeakDbContext' started tracking 'UnrelatedEntity' entity. Consider using 'DbContextOptionsBuilder.EnableSensitiveDataLogging' to see key values.\ndbug: 29/07/2025 20:03:41.795 RelationalEventId.DataReaderClosing[20301] (Microsoft.EntityFrameworkCore.Database.Command) \n      Closing data reader to 'main' on server '/Users/christiaan-ce/Library/Application Support/ef-core-leak.db'.\ndbug: 29/07/2025 20:03:41.795 RelationalEventId.DataReaderDisposing[20300] (Microsoft.EntityFrameworkCore.Database.Command) \n      A data reader for 'main' on server '/Users/christiaan-ce/Library/Application Support/ef-core-leak.db' is being disposed after spending 0ms reading results.\ndbug: 29/07/2025 20:03:41.795 RelationalEventId.ConnectionClosing[20002] (Microsoft.EntityFrameworkCore.Database.Connection) \n      Closing connection to database 'main' on server '/Users/christiaan-ce/Library/Application Support/ef-core-leak.db'.\ndbug: 29/07/2025 20:03:41.795 RelationalEventId.ConnectionClosed[20003] (Microsoft.EntityFrameworkCore.Database.Connection) \n      Closed connection to database 'main' on server '/Users/christiaan-ce/Library/Application Support/ef-core-leak.db' (0ms).\ndbug: 29/07/2025 20:03:41.798 CoreEventId.ContextDisposed[10407] (Microsoft.EntityFrameworkCore.Infrastructure) \n      'LeakDbContext' disposed.\ndbug: 29/07/2025 20:03:41.799 RelationalEventId.ConnectionDisposing[20007] (Microsoft.EntityFrameworkCore.Database.Connection) \n      Disposing connection to database 'main' on server '/Users/christiaan-ce/Library/Application Support/ef-core-leak.db'.\ndbug: 29/07/2025 20:03:41.799 RelationalEventId.ConnectionDisposed[20008] (Microsoft.EntityFrameworkCore.Database.Connection) \n      Disposed connection to database 'main' on server '/Users/christiaan-ce/Library/Application Support/ef-core-leak.db' (0ms\n```\n\n### Verbose output\n\n```text\n\n```\n\n### EF Core version\n\n9.0.7\n\n### Database provider\n\nMicrosoft.EntityFramework.SqlServer\n\n### Target framework\n\n.NET 9.0\n\n### Operating system\n\nAlpine linux, macOS\n\n### IDE\n\nRider 2025.2","closed_by":{"login":"roji","id":1862641,"node_id":"MDQ6VXNlcjE4NjI2NDE=","avatar_url":"https://avatars.githubusercontent.com/u/1862641?v=4","gravatar_id":"","url":"https://api.github.com/users/roji","html_url":"https://github.com/roji","followers_url":"https://api.github.com/users/roji/followers","following_url":"https://api.github.com/users/roji/following{/other_user}","gists_url":"https://api.github.com/users/roji/gists{/gist_id}","starred_url":"https://api.github.com/users/roji/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/roji/subscriptions","organizations_url":"https://api.github.com/users/roji/orgs","repos_url":"https://api.github.com/users/roji/repos","events_url":"https://api.github.com/users/roji/events{/privacy}","received_events_url":"https://api.github.com/users/roji/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/dotnet/efcore/issues/36464/reactions","total_count":1,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":1},"timeline_url":"https://api.github.com/repos/dotnet/efcore/issues/36464/timeline","performed_via_github_app":null,"state_reason":"completed"}