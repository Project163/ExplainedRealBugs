diff --git a/src/EFCore.Relational/Migrations/HistoryRepository.cs b/src/EFCore.Relational/Migrations/HistoryRepository.cs
index 3c1c1b2304..9aa9d933f9 100644
--- a/src/EFCore.Relational/Migrations/HistoryRepository.cs
+++ b/src/EFCore.Relational/Migrations/HistoryRepository.cs
@@ -219,8 +219,7 @@ async Task<bool> IHistoryRepository.CreateIfNotExistsAsync(CancellationToken can
     private IReadOnlyList<MigrationCommand> GetCreateIfNotExistsCommands()
         => Dependencies.MigrationsSqlGenerator.Generate([new SqlOperation
         {
-            Sql = GetCreateIfNotExistsScript(),
-            SuppressTransaction = true
+            Sql = GetCreateIfNotExistsScript()
         }]);
 
     /// <summary>
diff --git a/test/EFCore.Relational.Specification.Tests/Migrations/MigrationsInfrastructureTestBase.cs b/test/EFCore.Relational.Specification.Tests/Migrations/MigrationsInfrastructureTestBase.cs
index a00f1c6798..da798d5387 100644
--- a/test/EFCore.Relational.Specification.Tests/Migrations/MigrationsInfrastructureTestBase.cs
+++ b/test/EFCore.Relational.Specification.Tests/Migrations/MigrationsInfrastructureTestBase.cs
@@ -285,6 +285,62 @@ public virtual async Task Can_apply_second_migration_in_parallel_async()
             x => Assert.Equal("00000000000002_Migration2", x.MigrationId));
     }
 
+    [ConditionalFact]
+    public virtual void Can_apply_two_migrations_in_transaction()
+    {
+        using var db = Fixture.CreateContext();
+        db.Database.EnsureDeleted();
+        GiveMeSomeTime(db);
+        db.GetService<IRelationalDatabaseCreator>().Create();
+
+        var strategy = db.Database.CreateExecutionStrategy();
+        strategy.Execute(() =>
+        {
+            using var transaction = db.Database.BeginTransaction();
+            var migrator = db.GetService<IMigrator>();
+            migrator.Migrate("Migration1");
+            migrator.Migrate("Migration2");
+
+            var history = db.GetService<IHistoryRepository>();
+            Assert.Collection(
+                history.GetAppliedMigrations(),
+                x => Assert.Equal("00000000000001_Migration1", x.MigrationId),
+                x => Assert.Equal("00000000000002_Migration2", x.MigrationId));
+        });
+
+        Assert.Equal(
+            LogLevel.Warning,
+            Fixture.TestSqlLoggerFactory.Log.First(l => l.Id == RelationalEventId.MigrationsUserTransactionWarning).Level);
+    }
+
+    [ConditionalFact]
+    public virtual async Task Can_apply_two_migrations_in_transaction_async()
+    {
+        using var db = Fixture.CreateContext();
+        await db.Database.EnsureDeletedAsync();
+        await GiveMeSomeTimeAsync(db);
+        await db.GetService<IRelationalDatabaseCreator>().CreateAsync();
+
+        var strategy = db.Database.CreateExecutionStrategy();
+        await strategy.ExecuteAsync(async () =>
+        {
+            using var transaction = db.Database.BeginTransactionAsync();
+            var migrator = db.GetService<IMigrator>();
+            await migrator.MigrateAsync("Migration1");
+            await migrator.MigrateAsync("Migration2");
+
+            var history = db.GetService<IHistoryRepository>();
+            Assert.Collection(
+                await history.GetAppliedMigrationsAsync(),
+                x => Assert.Equal("00000000000001_Migration1", x.MigrationId),
+                x => Assert.Equal("00000000000002_Migration2", x.MigrationId));
+        });
+
+        Assert.Equal(
+            LogLevel.Warning,
+            Fixture.TestSqlLoggerFactory.Log.First(l => l.Id == RelationalEventId.MigrationsUserTransactionWarning).Level);
+    }
+
     [ConditionalFact]
     public virtual async Task Can_generate_no_migration_script()
     {
@@ -549,6 +605,7 @@ public override DbContextOptionsBuilder AddOptions(DbContextOptionsBuilder build
                 e => e
                     .Log(RelationalEventId.PendingModelChangesWarning)
                     .Log(RelationalEventId.NonTransactionalMigrationOperationWarning)
+                    .Log(RelationalEventId.MigrationsUserTransactionWarning)
             );
 
     protected override bool ShouldLogCategory(string logCategory)
diff --git a/test/EFCore.Relational.Tests/Migrations/MigrationCommandExecutorTest.cs b/test/EFCore.Relational.Tests/Migrations/MigrationCommandExecutorTest.cs
index f1ca15a4b7..6f491c81db 100644
--- a/test/EFCore.Relational.Tests/Migrations/MigrationCommandExecutorTest.cs
+++ b/test/EFCore.Relational.Tests/Migrations/MigrationCommandExecutorTest.cs
@@ -122,16 +122,14 @@ public async Task Executes_transaction_suppressed_migration_commands_in_user_tra
                 Assert.Equal(
                     RelationalStrings.TransactionSuppressedMigrationInUserTransaction,
                     (await Assert.ThrowsAsync<NotSupportedException>(
-                        async ()
-                            => await migrationCommandExecutor.ExecuteNonQueryAsync(commandList, fakeConnection))).Message);
+                        async () => await migrationCommandExecutor.ExecuteNonQueryAsync(commandList, fakeConnection))).Message);
             }
             else
             {
                 Assert.Equal(
                     RelationalStrings.TransactionSuppressedMigrationInUserTransaction,
                     Assert.Throws<NotSupportedException>(
-                        ()
-                            => migrationCommandExecutor.ExecuteNonQuery(commandList, fakeConnection)).Message);
+                        () => migrationCommandExecutor.ExecuteNonQuery(commandList, fakeConnection)).Message);
             }
 
             tx.Rollback();
diff --git a/test/EFCore.Specification.Tests/CustomConvertersTestBase.cs b/test/EFCore.Specification.Tests/CustomConvertersTestBase.cs
index 5dffaf88d9..a94b718bf9 100644
--- a/test/EFCore.Specification.Tests/CustomConvertersTestBase.cs
+++ b/test/EFCore.Specification.Tests/CustomConvertersTestBase.cs
@@ -1184,8 +1184,8 @@ protected override void OnModelCreating(ModelBuilder modelBuilder, DbContext con
                     b.Property(e => e.ByteArray5)
                         .HasConversion(
                             new ValueConverter<byte[], byte[]>(
-                                v => v.Reverse().Concat(new byte[] { 4, 20 }).ToArray(),
-                                v => v.Reverse().Skip(2).ToArray()),
+                                v => ((IEnumerable<byte>)v).Reverse().Concat(new byte[] { 4, 20 }).ToArray(),
+                                v => ((IEnumerable<byte>)v).Reverse().Skip(2).ToArray()),
                             bytesComparer)
                         .HasMaxLength(7);
 
