diff --git a/src/EFCore.Design/Design/DbContextActivator.cs b/src/EFCore.Design/Design/DbContextActivator.cs
index c7ab7df090..df991d569d 100644
--- a/src/EFCore.Design/Design/DbContextActivator.cs
+++ b/src/EFCore.Design/Design/DbContextActivator.cs
@@ -43,12 +43,11 @@ public static class DbContextActivator
     {
         Check.NotNull(contextType, nameof(contextType));
 
-        EF.IsDesignTime = true;
-
         return new DbContextOperations(
                 new OperationReporter(reportHandler),
                 contextType.Assembly,
                 startupAssembly ?? contextType.Assembly,
+                project: "",
                 projectDir: "",
                 rootNamespace: null,
                 language: "C#",
diff --git a/src/EFCore.Design/Design/DesignTimeServiceCollectionExtensions.cs b/src/EFCore.Design/Design/DesignTimeServiceCollectionExtensions.cs
index ce83a43ec3..23ddac443c 100644
--- a/src/EFCore.Design/Design/DesignTimeServiceCollectionExtensions.cs
+++ b/src/EFCore.Design/Design/DesignTimeServiceCollectionExtensions.cs
@@ -3,6 +3,7 @@
 
 using Microsoft.EntityFrameworkCore.Design.Internal;
 using Microsoft.EntityFrameworkCore.Migrations.Internal;
+using Microsoft.EntityFrameworkCore.Query.Design;
 using Microsoft.EntityFrameworkCore.Query.Internal;
 using Microsoft.EntityFrameworkCore.Scaffolding.Internal;
 
@@ -54,6 +55,8 @@ public static class DesignTimeServiceCollectionExtensions
                     .TryAddSingleton<ICompiledModelCodeGenerator, CSharpRuntimeModelCodeGenerator>()
                     .TryAddSingleton<ICompiledModelCodeGeneratorSelector, CompiledModelCodeGeneratorSelector>()
                     .TryAddSingleton<ICompiledModelScaffolder, CompiledModelScaffolder>()
+                    .TryAddSingleton<IPrecompiledQueryCodeGenerator, PrecompiledQueryCodeGenerator>()
+                    .TryAddSingleton<IPrecompiledQueryCodeGeneratorSelector, PrecompiledQueryCodeGeneratorSelector>()
                     .TryAddSingleton<IDesignTimeConnectionStringResolver>(
                         new DesignTimeConnectionStringResolver(applicationServiceProviderAccessor))
                     .TryAddSingleton<IPluralizer, HumanizerPluralizer>()
diff --git a/src/EFCore.Design/Design/Internal/DbContextOperations.cs b/src/EFCore.Design/Design/Internal/DbContextOperations.cs
index 8e250ed0f2..57a720e98a 100644
--- a/src/EFCore.Design/Design/Internal/DbContextOperations.cs
+++ b/src/EFCore.Design/Design/Internal/DbContextOperations.cs
@@ -1,8 +1,20 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using System.IO;
+using System.Text;
+using Microsoft.Build.Locator;
+using Microsoft.CodeAnalysis;
+using Microsoft.CodeAnalysis.Editing;
+using Microsoft.CodeAnalysis.Formatting;
+using Microsoft.CodeAnalysis.MSBuild;
+using Microsoft.CodeAnalysis.Simplification;
 using Microsoft.EntityFrameworkCore.Infrastructure.Internal;
 using Microsoft.EntityFrameworkCore.Internal;
+using Microsoft.EntityFrameworkCore.Metadata.Internal;
+using Microsoft.EntityFrameworkCore.Query.Design;
+using Microsoft.EntityFrameworkCore.Query.Internal;
+using Microsoft.EntityFrameworkCore.Scaffolding.Internal;
 
 namespace Microsoft.EntityFrameworkCore.Design.Internal;
 
@@ -17,6 +29,7 @@ public class DbContextOperations
     private readonly IOperationReporter _reporter;
     private readonly Assembly _assembly;
     private readonly Assembly _startupAssembly;
+    private readonly string _project;
     private readonly string _projectDir;
     private readonly string? _rootNamespace;
     private readonly string? _language;
@@ -35,6 +48,7 @@ public class DbContextOperations
         IOperationReporter reporter,
         Assembly assembly,
         Assembly startupAssembly,
+        string project,
         string projectDir,
         string? rootNamespace,
         string? language,
@@ -44,6 +58,7 @@ public class DbContextOperations
             reporter,
             assembly,
             startupAssembly,
+            project,
             projectDir,
             rootNamespace,
             language,
@@ -63,6 +78,7 @@ public class DbContextOperations
         IOperationReporter reporter,
         Assembly assembly,
         Assembly startupAssembly,
+        string project,
         string projectDir,
         string? rootNamespace,
         string? language,
@@ -73,6 +89,7 @@ public class DbContextOperations
         _reporter = reporter;
         _assembly = assembly;
         _startupAssembly = startupAssembly;
+        _project = project;
         _projectDir = projectDir;
         _rootNamespace = rootNamespace;
         _language = language;
@@ -117,13 +134,88 @@ public virtual string ScriptDbContext(string? contextType)
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    public virtual IReadOnlyList<string> Optimize(string? outputDir, string? modelNamespace, string? contextTypeName, string? suffix)
+    public virtual IReadOnlyList<string> Optimize(
+        string? outputDir, string? modelNamespace, string? contextTypeName, string? suffix, bool scaffoldModel, bool precompileQueries)
     {
-        using var context = CreateContext(contextTypeName);
-        var contextType = context.GetType();
+        var optimizeAllInAssembly = contextTypeName == "*";
+        var contexts = optimizeAllInAssembly ? CreateAllContexts() : [CreateContext(contextTypeName)];
+
+        MSBuildLocator.RegisterDefaults();
+
+        List<string> generatedFiles = [];
+        HashSet<string> generatedFileNames = [];
+        foreach (var context in contexts)
+        {
+            using (context)
+            {
+                Optimize(
+                    outputDir,
+                    modelNamespace,
+                    suffix,
+                    scaffoldModel,
+                    precompileQueries,
+                    context,
+                    optimizeAllInAssembly,
+                    generatedFiles,
+                    generatedFileNames);
+            }
+        }
+
+        return generatedFiles;
+    }
 
+    private void Optimize(
+        string? outputDir,
+        string? modelNamespace,
+        string? suffix,
+        bool scaffoldModel,
+        bool precompileQueries,
+        DbContext context,
+        bool optimizeAllInAssembly,
+        List<string> generatedFiles,
+        HashSet<string> generatedFileNames)
+    {
+        var contextType = context.GetType();
         var services = _servicesBuilder.Build(context);
-        var scaffolder = services.GetRequiredService<ICompiledModelScaffolder>();
+
+        IReadOnlyDictionary<MemberInfo, QualifiedName>? memberAccessReplacements = null;
+
+        if (scaffoldModel
+            && (!optimizeAllInAssembly || contextType.Assembly == _assembly))
+        {
+            generatedFiles.AddRange(ScaffoldCompiledModel(outputDir, modelNamespace, context, suffix, services, generatedFileNames));
+            if (precompileQueries)
+            {
+                memberAccessReplacements = ((IRuntimeModel)context.GetService<IDesignTimeModel>().Model).GetUnsafeAccessors();
+            }
+        }
+
+        if (precompileQueries)
+        {
+            generatedFiles.AddRange(PrecompileQueries(
+                outputDir,
+                context,
+                suffix,
+                services,
+                memberAccessReplacements ?? ((IRuntimeModel)context.Model).GetUnsafeAccessors(),
+                generatedFileNames));
+        }
+    }
+
+    private IReadOnlyList<string> ScaffoldCompiledModel(
+        string? outputDir,
+        string? modelNamespace,
+        DbContext context,
+        string? suffix,
+        IServiceProvider services,
+        ISet<string> generatedFileNames)
+    {
+        var contextType = context.GetType();
+        if (contextType.Assembly != _assembly)
+        {
+            _reporter.WriteWarning(DesignStrings.ContextAssemblyMismatch(
+                _assembly.GetName().Name, contextType.ShortDisplayName(), contextType.Assembly.GetName().Name));
+        }
 
         if (outputDir == null)
         {
@@ -139,6 +231,8 @@ public virtual IReadOnlyList<string> Optimize(string? outputDir, string? modelNa
 
         outputDir = Path.GetFullPath(Path.Combine(_projectDir, outputDir));
 
+        var scaffolder = services.GetRequiredService<ICompiledModelScaffolder>();
+
         var finalModelNamespace = modelNamespace ?? GetNamespaceFromOutputPath(outputDir) ?? "";
 
         var scaffoldedFiles = scaffolder.ScaffoldModel(
@@ -150,7 +244,8 @@ public virtual IReadOnlyList<string> Optimize(string? outputDir, string? modelNa
                 ModelNamespace = finalModelNamespace,
                 Language = _language,
                 UseNullableReferenceTypes = _nullable,
-                Suffix = suffix
+                Suffix = suffix,
+                GeneratedFileNames = generatedFileNames
             });
 
         var fullName = contextType.ShortDisplayName() + "Model";
@@ -170,6 +265,84 @@ public virtual IReadOnlyList<string> Optimize(string? outputDir, string? modelNa
         return scaffoldedFiles;
     }
 
+    private IReadOnlyList<string> PrecompileQueries(string? outputDir, DbContext context, string? suffix, IServiceProvider services, IReadOnlyDictionary<MemberInfo, QualifiedName> memberAccessReplacements, ISet<string> generatedFileNames)
+    {
+        outputDir = Path.GetFullPath(Path.Combine(_projectDir, outputDir ?? "Generated"));
+
+        // TODO: pass through properties
+        var workspace = MSBuildWorkspace.Create();
+        workspace.LoadMetadataForReferencedProjects = true;
+        var project = workspace.OpenProjectAsync(_project).GetAwaiter().GetResult();
+        if (!project.SupportsCompilation)
+        {
+            throw new NotSupportedException(DesignStrings.UncompilableProject(_project));
+        }
+        var compilation = project.GetCompilationAsync().GetAwaiter().GetResult()!;
+        var errorDiagnostics = compilation.GetDiagnostics().Where(d => d.Severity == DiagnosticSeverity.Error).ToArray();
+        if (errorDiagnostics.Any())
+        {
+            var errorBuilder = new StringBuilder();
+            errorBuilder.AppendLine(DesignStrings.CompilationErrors);
+            foreach (var diagnostic in errorDiagnostics)
+            {
+                errorBuilder.AppendLine(diagnostic.ToString());
+            }
+
+            throw new InvalidOperationException(errorBuilder.ToString());
+        }
+
+        var syntaxGenerator = SyntaxGenerator.GetGenerator(
+            workspace, _language == "VB" ? LanguageNames.VisualBasic : _language ?? LanguageNames.CSharp);
+
+        var precompiledQueryCodeGenerator = services.GetRequiredService<IPrecompiledQueryCodeGeneratorSelector>().Select(_language);
+
+        var precompilationErrors = new List<PrecompiledQueryCodeGenerator.QueryPrecompilationError>();
+        var generatedFiles = precompiledQueryCodeGenerator.GeneratePrecompiledQueries(
+            compilation,
+            syntaxGenerator,
+            context,
+            memberAccessReplacements,
+            precompilationErrors,
+            generatedFileNames,
+            assembly: _assembly,
+            suffix);
+
+        if (precompilationErrors.Count > 0)
+        {
+            var errorBuilder = new StringBuilder();
+            errorBuilder.AppendLine(DesignStrings.QueryPrecompilationErrors);
+            foreach (var error in precompilationErrors)
+            {
+                errorBuilder.AppendLine(error.ToString());
+            }
+
+            throw new InvalidOperationException(errorBuilder.ToString());
+        }
+
+        var writtenFiles = new List<string>();
+        foreach (var generatedFile in generatedFiles)
+        {
+            generatedFile.Code = FormatCode(project, generatedFile).GetAwaiter().GetResult().ToString()!;
+        }
+
+        return CompiledModelScaffolder.WriteFiles(generatedFiles, outputDir);
+
+        static async Task<object> FormatCode(Project project, ScaffoldedFile generatedFile)
+        {
+            var document = project.AddDocument("_EfGeneratedInterceptors.cs", generatedFile.Code);
+
+            // Run the simplifier to e.g. get rid of unneeded parentheses
+            var syntaxRoot = (await document.GetSyntaxRootAsync().ConfigureAwait(false))!;
+            var annotatedDocument = document.WithSyntaxRoot(syntaxRoot.WithAdditionalAnnotations(Simplifier.Annotation));
+            document = await Simplifier.ReduceAsync(annotatedDocument, optionSet: null).ConfigureAwait(false);
+            document = await Formatter.FormatAsync(document, options: null).ConfigureAwait(false);
+
+            var finalSyntaxTree = (await document.GetSyntaxTreeAsync().ConfigureAwait(false))!;
+            var finalText = await finalSyntaxTree.GetTextAsync().ConfigureAwait(false);
+            return finalText;
+        }
+    }
+
     private string? GetNamespaceFromOutputPath(string directoryPath)
     {
         var subNamespace = SubnamespaceFromOutputPath(_projectDir, directoryPath);
@@ -208,7 +381,28 @@ public virtual IReadOnlyList<string> Optimize(string? outputDir, string? modelNa
     /// </summary>
     public virtual DbContext CreateContext(string? contextType)
     {
-        var contextPair = FindContextType(contextType);
+        EF.IsDesignTime = true;
+        return CreateContext(contextType, FindContextType(contextType));
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual IEnumerable<DbContext> CreateAllContexts()
+    {
+        EF.IsDesignTime = true;
+        var types = FindContextTypes();
+        foreach (var contextPair in types)
+        {
+            yield return CreateContext(null, contextPair);
+        }
+    }
+
+    private DbContext CreateContext(string? contextType, KeyValuePair<Type, Func<DbContext>> contextPair)
+    {
         var factory = contextPair.Value;
         try
         {
diff --git a/src/EFCore.Design/Design/Internal/MigrationsOperations.cs b/src/EFCore.Design/Design/Internal/MigrationsOperations.cs
index 53fa083c0d..e6f314769e 100644
--- a/src/EFCore.Design/Design/Internal/MigrationsOperations.cs
+++ b/src/EFCore.Design/Design/Internal/MigrationsOperations.cs
@@ -47,6 +47,7 @@ public class MigrationsOperations
             reporter,
             assembly,
             startupAssembly,
+            project: "",
             projectDir,
             rootNamespace,
             language,
diff --git a/src/EFCore.Design/Design/OperationExecutor.cs b/src/EFCore.Design/Design/OperationExecutor.cs
index 1f2f82bd7a..70953d2bc8 100644
--- a/src/EFCore.Design/Design/OperationExecutor.cs
+++ b/src/EFCore.Design/Design/OperationExecutor.cs
@@ -16,6 +16,7 @@ namespace Microsoft.EntityFrameworkCore.Design;
 /// </remarks>
 public class OperationExecutor : MarshalByRefObject
 {
+    private readonly string _project;
     private readonly string _projectDir;
     private readonly string _targetAssemblyName;
     private readonly string _startupTargetAssemblyName;
@@ -38,6 +39,7 @@ public class OperationExecutor : MarshalByRefObject
     ///     <para>The arguments supported by <paramref name="args" /> are:</para>
     ///     <para><c>targetName</c>--The assembly name of the target project.</para>
     ///     <para><c>startupTargetName</c>--The assembly name of the startup project.</para>
+    ///     <para><c>project</c>--The target project.</para>
     ///     <para><c>projectDir</c>--The target project's root directory.</para>
     ///     <para><c>rootNamespace</c>--The target project's root namespace.</para>
     ///     <para><c>language</c>--The programming language to be used to generate classes.</para>
@@ -54,6 +56,7 @@ public OperationExecutor(IOperationReportHandler reportHandler, IDictionary args
         _reporter = new OperationReporter(reportHandler);
         _targetAssemblyName = (string)args["targetName"]!;
         _startupTargetAssemblyName = (string)args["startupTargetName"]!;
+        _project = (string)args["project"]!;
         _projectDir = (string)args["projectDir"]!;
         _rootNamespace = (string?)args["rootNamespace"];
         _language = (string?)args["language"];
@@ -121,6 +124,7 @@ public virtual DbContextOperations ContextOperations
                 _reporter,
                 Assembly,
                 StartupAssembly,
+                _project,
                 _projectDir,
                 _rootNamespace,
                 _language,
@@ -503,7 +507,7 @@ public class GetMigrations : OperationBase
     }
 
     /// <summary>
-    ///     Represents an operation to generate a compiled model from the DbContext.
+    ///     Represents an operation to generate optimized code for a DbContext.
     /// </summary>
     public class OptimizeContext : OperationBase
     {
@@ -513,8 +517,11 @@ public class OptimizeContext : OperationBase
         /// <remarks>
         ///     <para>The arguments supported by <paramref name="args" /> are:</para>
         ///     <para><c>outputDir</c>--The directory to put files in. Paths are relative to the project directory.</para>
-        ///     <para><c>modelNamespace</c>--Specify to override the namespace of the generated model.</para>
-        ///     <para><c>contextType</c>--The <see cref="DbContext" /> to use.</para>
+        ///     <para><c>modelNamespace</c>--The namespace of the generated model.</para>
+        ///     <para><c>contextType</c>--The <see cref="DbContext" /> type to use.</para>
+        ///     <para><c>suffix</c>--The suffix to add to all the generated files.</para>
+        ///     <para><c>scaffoldModel</c>--Whether to generate a compiled model from the DbContext.</para>
+        ///     <para><c>precompileQueries</c>--Whether to generate code for precompiled queries.</para>
         /// </remarks>
         /// <param name="executor">The operation executor.</param>
         /// <param name="resultHandler">The <see cref="IOperationResultHandler" />.</param>
@@ -532,13 +539,15 @@ public class OptimizeContext : OperationBase
             var modelNamespace = (string?)args["modelNamespace"];
             var contextType = (string?)args["contextType"];
             var suffix = (string?)args["suffix"];
+            var scaffoldModel = (bool)(args["scaffoldModel"] ?? true);
+            var precompileQueries = (bool)(args["precompileQueries"] ?? false);
 
-            Execute(() => executor.OptimizeContextImpl(outputDir, modelNamespace, contextType, suffix));
+            Execute(() => executor.OptimizeContextImpl(outputDir, modelNamespace, contextType, suffix, scaffoldModel, precompileQueries));
         }
     }
-
-    private IReadOnlyList<string> OptimizeContextImpl(string? outputDir, string? modelNamespace, string? contextType, string? suffix)
-        => ContextOperations.Optimize(outputDir, modelNamespace, contextType, suffix);
+    private IReadOnlyList<string> OptimizeContextImpl(
+        string? outputDir, string? modelNamespace, string? contextType, string? suffix, bool scaffoldModel, bool precompileQueries)
+        => ContextOperations.Optimize(outputDir, modelNamespace, contextType, suffix, scaffoldModel, precompileQueries);
 
     /// <summary>
     ///     Represents an operation to scaffold a <see cref="DbContext" /> and entity types for a database.
diff --git a/src/EFCore.Design/Properties/DesignStrings.Designer.cs b/src/EFCore.Design/Properties/DesignStrings.Designer.cs
index 1054ed2b67..52142c48ce 100644
--- a/src/EFCore.Design/Properties/DesignStrings.Designer.cs
+++ b/src/EFCore.Design/Properties/DesignStrings.Designer.cs
@@ -101,6 +101,12 @@ public static string CannotGenerateTypeQualifiedMethodCall
         public static string CircularBaseClassDependency
             => GetString("CircularBaseClassDependency");
 
+        /// <summary>
+        ///     Compilation failed with errors:
+        /// </summary>
+        public static string CompilationErrors
+            => GetString("CompilationErrors");
+
         /// <summary>
         ///     A compilation must be loaded.
         /// </summary>
@@ -169,6 +175,15 @@ public static string ConflictingContextAndMigrationName(object? name)
         public static string ConnectionDescription
             => GetString("ConnectionDescription");
 
+        /// <summary>
+        ///     Your target project '{assembly}' doesn't match the assembly containing '{contextType}' - '{contextAssembly}'. This is not recommended as it will cause the compiled model to not be discovered automatically.
+        ///     Consider changing your target project to the DbContext project by using the Package Manager Console's Default project drop-down list, by executing "dotnet ef" from the directory containing the DbContext project or by supplying it with the '--project' option.
+        /// </summary>
+        public static string ContextAssemblyMismatch(object? assembly, object? contextType, object? contextAssembly)
+            => string.Format(
+                GetString("ContextAssemblyMismatch", nameof(assembly), nameof(contextType), nameof(contextAssembly)),
+                assembly, contextType, contextAssembly);
+
         /// <summary>
         ///     The context class name '{contextClassName}' is not a valid C# identifier.
         /// </summary>
@@ -461,6 +476,12 @@ public static string MultipleContextsWithQualifiedName(object? name)
                 GetString("MultipleContextsWithQualifiedName", nameof(name)),
                 name);
 
+        /// <summary>
+        ///     Could not find symbol for anonymous object creation initializer:
+        /// </summary>
+        public static string NoAnonymousSymbol
+            => GetString("NoAnonymousSymbol");
+
         /// <summary>
         ///     Don't colorize output.
         /// </summary>
@@ -627,6 +648,12 @@ public static string ProviderReturnedNullModel(object? providerTypeName)
         public static string QueryComprehensionSyntaxNotSupportedInPrecompiledQueries
             => GetString("QueryComprehensionSyntaxNotSupportedInPrecompiledQueries");
 
+        /// <summary>
+        ///     Query precompilation failed with errors:
+        /// </summary>
+        public static string QueryPrecompilationErrors
+            => GetString("QueryPrecompilationErrors");
+
         /// <summary>
         ///     No files were generated in directory '{outputDirectoryName}'. The following file(s) already exist(s) and must be made writeable to continue: {readOnlyFiles}.
         /// </summary>
@@ -715,6 +742,14 @@ public static string UnableToScaffoldIndexMissingProperty(object? indexName, obj
                 GetString("UnableToScaffoldIndexMissingProperty", nameof(indexName), nameof(columnNames)),
                 indexName, columnNames);
 
+        /// <summary>
+        ///     The project '{project}' does not support compilation.
+        /// </summary>
+        public static string UncompilableProject(object? project)
+            => string.Format(
+                GetString("UncompilableProject", nameof(project)),
+                project);
+
         /// <summary>
         ///     Unhandled enum value '{enumValue}'.
         /// </summary>
diff --git a/src/EFCore.Design/Properties/DesignStrings.resx b/src/EFCore.Design/Properties/DesignStrings.resx
index 902e4b9807..5029ecbe9c 100644
--- a/src/EFCore.Design/Properties/DesignStrings.resx
+++ b/src/EFCore.Design/Properties/DesignStrings.resx
@@ -1,17 +1,17 @@
 ï»¿<?xml version="1.0" encoding="utf-8"?>
 <root>
-  <!--
-    Microsoft ResX Schema
-
+  <!-- 
+    Microsoft ResX Schema 
+    
     Version 2.0
-
-    The primary goals of this format is to allow a simple XML format
-    that is mostly human readable. The generation and parsing of the
-    various data types are done through the TypeConverter classes
+    
+    The primary goals of this format is to allow a simple XML format 
+    that is mostly human readable. The generation and parsing of the 
+    various data types are done through the TypeConverter classes 
     associated with the data types.
-
+    
     Example:
-
+    
     ... ado.net/XML headers & schema ...
     <resheader name="resmimetype">text/microsoft-resx</resheader>
     <resheader name="version">2.0</resheader>
@@ -26,36 +26,36 @@
         <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
         <comment>This is a comment</comment>
     </data>
-
-    There are any number of "resheader" rows that contain simple
+                
+    There are any number of "resheader" rows that contain simple 
     name/value pairs.
-
-    Each data row contains a name, and value. The row also contains a
-    type or mimetype. Type corresponds to a .NET class that support
-    text/value conversion through the TypeConverter architecture.
-    Classes that don't support this are serialized and stored with the
+    
+    Each data row contains a name, and value. The row also contains a 
+    type or mimetype. Type corresponds to a .NET class that support 
+    text/value conversion through the TypeConverter architecture. 
+    Classes that don't support this are serialized and stored with the 
     mimetype set.
-
-    The mimetype is used for serialized objects, and tells the
-    ResXResourceReader how to depersist the object. This is currently not
+    
+    The mimetype is used for serialized objects, and tells the 
+    ResXResourceReader how to depersist the object. This is currently not 
     extensible. For a given mimetype the value must be set accordingly:
-
-    Note - application/x-microsoft.net.object.binary.base64 is the format
-    that the ResXResourceWriter will generate, however the reader can
+    
+    Note - application/x-microsoft.net.object.binary.base64 is the format 
+    that the ResXResourceWriter will generate, however the reader can 
     read any of the formats listed below.
-
+    
     mimetype: application/x-microsoft.net.object.binary.base64
-    value   : The object must be serialized with
+    value   : The object must be serialized with 
             : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
             : and then encoded with base64 encoding.
-
+    
     mimetype: application/x-microsoft.net.object.soap.base64
-    value   : The object must be serialized with
+    value   : The object must be serialized with 
             : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
             : and then encoded with base64 encoding.
 
     mimetype: application/x-microsoft.net.object.bytearray.base64
-    value   : The object must be serialized into a byte array
+    value   : The object must be serialized into a byte array 
             : using a System.ComponentModel.TypeConverter
             : and then encoded with base64 encoding.
     -->
@@ -150,6 +150,9 @@
   <data name="CircularBaseClassDependency" xml:space="preserve">
     <value>You cannot add a migration with the name 'Migration'.</value>
   </data>
+  <data name="CompilationErrors" xml:space="preserve">
+    <value>Compilation failed with errors:</value>
+  </data>
   <data name="CompilationMustBeLoaded" xml:space="preserve">
     <value>A compilation must be loaded.</value>
   </data>
@@ -177,6 +180,10 @@
   <data name="ConnectionDescription" xml:space="preserve">
     <value>The connection string to the database. Defaults to the one specified in AddDbContext or OnConfiguring.</value>
   </data>
+  <data name="ContextAssemblyMismatch" xml:space="preserve">
+    <value>Your target project '{assembly}' doesn't match the assembly containing '{contextType}' - '{contextAssembly}'. This is not recommended as it will cause the compiled model to not be discovered automatically.
+Consider changing your target project to the DbContext project by using the Package Manager Console's Default project drop-down list, by executing "dotnet ef" from the directory containing the DbContext project or by supplying it with the '--project' option.</value>
+  </data>
   <data name="ContextClassNotValidCSharpIdentifier" xml:space="preserve">
     <value>The context class name '{contextClassName}' is not a valid C# identifier.</value>
   </data>
@@ -296,6 +303,9 @@ Change your target project to the migrations project by using the Package Manage
   <data name="MultipleContextsWithQualifiedName" xml:space="preserve">
     <value>More than one DbContext named '{name}' was found. Specify which one to use by providing its fully qualified name using its exact case.</value>
   </data>
+  <data name="NoAnonymousSymbol" xml:space="preserve">
+    <value>Could not find symbol for anonymous object creation initializer:</value>
+  </data>
   <data name="NoColorDescription" xml:space="preserve">
     <value>Don't colorize output.</value>
   </data>
@@ -368,6 +378,9 @@ Change your target project to the migrations project by using the Package Manage
   <data name="QueryComprehensionSyntaxNotSupportedInPrecompiledQueries" xml:space="preserve">
     <value>LINQ query comprehension syntax is currently not supported in precompiled queries.</value>
   </data>
+  <data name="QueryPrecompilationErrors" xml:space="preserve">
+    <value>Query precompilation failed with errors:</value>
+  </data>
   <data name="ReadOnlyFiles" xml:space="preserve">
     <value>No files were generated in directory '{outputDirectoryName}'. The following file(s) already exist(s) and must be made writeable to continue: {readOnlyFiles}.</value>
   </data>
@@ -405,6 +418,9 @@ Change your target project to the migrations project by using the Package Manage
   <data name="UnableToScaffoldIndexMissingProperty" xml:space="preserve">
     <value>Unable to scaffold the index '{indexName}'. The following columns could not be scaffolded: {columnNames}.</value>
   </data>
+  <data name="UncompilableProject" xml:space="preserve">
+    <value>The project '{project}' does not support compilation.</value>
+  </data>
   <data name="UnhandledEnumValue" xml:space="preserve">
     <value>Unhandled enum value '{enumValue}'.</value>
   </data>
diff --git a/src/EFCore.Design/Query/Design/IPrecompiledQueryCodeGenerator.cs b/src/EFCore.Design/Query/Design/IPrecompiledQueryCodeGenerator.cs
new file mode 100644
index 0000000000..7d77995577
--- /dev/null
+++ b/src/EFCore.Design/Query/Design/IPrecompiledQueryCodeGenerator.cs
@@ -0,0 +1,45 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Diagnostics.CodeAnalysis;
+using Microsoft.CodeAnalysis;
+using Microsoft.CodeAnalysis.Editing;
+using Microsoft.EntityFrameworkCore.Design.Internal;
+using static Microsoft.EntityFrameworkCore.Query.Internal.PrecompiledQueryCodeGenerator;
+
+namespace Microsoft.EntityFrameworkCore.Migrations.Design;
+
+/// <summary>
+///     Used to generate code for precompiled queries.
+/// </summary>
+/// <remarks>
+///     See <see href="https://aka.ms/efcore-docs-compiled-models">EF Core compiled models</see>, and
+///     <see href="https://aka.ms/efcore-docs-design-time-services">EF Core design-time services</see> for more information and examples.
+/// </remarks>
+[Experimental(EFDiagnostics.PrecompiledQueryExperimental)]
+public interface IPrecompiledQueryCodeGenerator : ILanguageBasedService
+{
+    /// <summary>
+    ///     Generates the precompiled queries code.
+    /// </summary>
+    /// <param name="compilation">The compilation.</param>
+    /// <param name="syntaxGenerator">The syntax generator.</param>
+    /// <param name="dbContext">The context.</param>
+    /// <param name="memberAccessReplacements">The member access replacements.</param>
+    /// <param name="precompilationErrors">A list that will contain precompilation errors.</param>
+    /// <param name="generatedFileNames">The set of file names generated so far.</param>
+    /// <param name="assembly">The assembly corresponding to the provided compilation.</param>
+    /// <param name="suffix">The suffix to attach to the name of all the generated files.</param>
+    /// <param name="cancellationToken">The cancellation token.</param>
+    /// <returns>The files containing precompiled queries code.</returns>
+    IReadOnlyList<ScaffoldedFile> GeneratePrecompiledQueries(
+        Compilation compilation,
+        SyntaxGenerator syntaxGenerator,
+        DbContext dbContext,
+        IReadOnlyDictionary<MemberInfo, QualifiedName> memberAccessReplacements,
+        List<QueryPrecompilationError> precompilationErrors,
+        ISet<string> generatedFileNames,
+        Assembly? assembly = null,
+        string? suffix = null,
+        CancellationToken cancellationToken = default);
+}
diff --git a/src/EFCore.Design/Query/Design/IPrecompiledQueryCodeGeneratorSelector.cs b/src/EFCore.Design/Query/Design/IPrecompiledQueryCodeGeneratorSelector.cs
new file mode 100644
index 0000000000..9a6e840722
--- /dev/null
+++ b/src/EFCore.Design/Query/Design/IPrecompiledQueryCodeGeneratorSelector.cs
@@ -0,0 +1,24 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Diagnostics.CodeAnalysis;
+
+namespace Microsoft.EntityFrameworkCore.Query.Design;
+
+/// <summary>
+///     Selects an <see cref="IPrecompiledQueryCodeGenerator" /> service for a given programming language.
+/// </summary>
+/// <remarks>
+///     See <see href="https://aka.ms/efcore-docs-compiled-models">EF Core compiled models</see>, and
+///     <see href="https://aka.ms/efcore-docs-design-time-services">EF Core design-time services</see> for more information and examples.
+/// </remarks>
+[Experimental(EFDiagnostics.PrecompiledQueryExperimental)]
+public interface IPrecompiledQueryCodeGeneratorSelector
+{
+    /// <summary>
+    ///     Selects an <see cref="IPrecompiledQueryCodeGenerator" /> service for a given programming language.
+    /// </summary>
+    /// <param name="language">The programming language.</param>
+    /// <returns>The <see cref="IPrecompiledQueryCodeGenerator" />.</returns>
+    IPrecompiledQueryCodeGenerator Select(string? language);
+}
diff --git a/src/EFCore.Design/Query/Internal/CSharpToLinqTranslator.cs b/src/EFCore.Design/Query/Internal/CSharpToLinqTranslator.cs
index e029d9ad72..57f9cceb76 100644
--- a/src/EFCore.Design/Query/Internal/CSharpToLinqTranslator.cs
+++ b/src/EFCore.Design/Query/Internal/CSharpToLinqTranslator.cs
@@ -135,8 +135,7 @@ public override Expression VisitAnonymousObjectCreationExpression(AnonymousObjec
         // At least for EF's purposes, it doesn't matter, so we build a placeholder.
         if (_semanticModel.GetSymbolInfo(anonymousObjectCreation).Symbol is not IMethodSymbol constructorSymbol)
         {
-            throw new InvalidOperationException(
-                "Could not find symbol for anonymous object creation initializer: " + anonymousObjectCreation);
+            throw new InvalidOperationException(DesignStrings.NoAnonymousSymbol + " " + anonymousObjectCreation);
         }
 
         var anonymousType = ResolveType(constructorSymbol.ContainingType);
diff --git a/src/EFCore.Design/Query/Internal/PrecompiledQueryCodeGenerator.cs b/src/EFCore.Design/Query/Internal/PrecompiledQueryCodeGenerator.cs
index 91d67afa60..d8884f59b8 100644
--- a/src/EFCore.Design/Query/Internal/PrecompiledQueryCodeGenerator.cs
+++ b/src/EFCore.Design/Query/Internal/PrecompiledQueryCodeGenerator.cs
@@ -7,6 +7,8 @@
 using Microsoft.CodeAnalysis.CSharp;
 using Microsoft.CodeAnalysis.CSharp.Syntax;
 using Microsoft.CodeAnalysis.Editing;
+using Microsoft.EntityFrameworkCore.Design.Internal;
+using Microsoft.EntityFrameworkCore.Scaffolding.Internal;
 
 namespace Microsoft.EntityFrameworkCore.Query.Internal;
 
@@ -16,7 +18,7 @@ namespace Microsoft.EntityFrameworkCore.Query.Internal;
 ///     any release. You should only use it directly in your code with extreme caution and knowing that
 ///     doing so can result in application failures when updating to a new Entity Framework Core release.
 /// </summary>
-public class PrecompiledQueryCodeGenerator
+public class PrecompiledQueryCodeGenerator : IPrecompiledQueryCodeGenerator
 {
     private readonly QueryLocator _queryLocator;
     private readonly CSharpToLinqTranslator _csharpToLinqTranslator;
@@ -24,17 +26,21 @@ public class PrecompiledQueryCodeGenerator
     private SyntaxGenerator _g = null!;
     private IQueryCompiler _queryCompiler = null!;
     private ExpressionTreeFuncletizer _funcletizer = null!;
-    private LinqToCSharpSyntaxTranslator _linqToCSharpTranslator = null!;
+    private RuntimeModelLinqToCSharpSyntaxTranslator _linqToCSharpTranslator = null!;
     private LiftableConstantProcessor _liftableConstantProcessor = null!;
 
     private Symbols _symbols;
 
-    private readonly HashSet<string> _namespaces = new();
-    private readonly HashSet<MethodDeclarationSyntax> _unsafeAccessors = new();
+    private readonly HashSet<string> _namespaces = [];
+    private IReadOnlyDictionary<MemberInfo, QualifiedName> _memberAccessReplacements = new Dictionary<MemberInfo, QualifiedName>();
+    private readonly HashSet<MethodDeclarationSyntax> _unsafeAccessors = [];
     private readonly IndentedStringBuilder _code = new();
 
     private const string InterceptorsNamespace = "Microsoft.EntityFrameworkCore.GeneratedInterceptors";
 
+    /// <inheritdoc/>
+    public string? Language => "C#";
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -53,25 +59,30 @@ public PrecompiledQueryCodeGenerator()
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    public virtual IReadOnlyList<GeneratedInterceptorFile> GeneratePrecompiledQueries(
+    public virtual IReadOnlyList<ScaffoldedFile> GeneratePrecompiledQueries(
         Compilation compilation,
         SyntaxGenerator syntaxGenerator,
         DbContext dbContext,
+        IReadOnlyDictionary<MemberInfo, QualifiedName> memberAccessReplacements,
         List<QueryPrecompilationError> precompilationErrors,
+        ISet<string> generatedFileNames,
         Assembly? additionalAssembly = null,
+        string? suffix = null,
         CancellationToken cancellationToken = default)
     {
         _queryLocator.Initialize(compilation);
         _symbols = Symbols.Load(compilation);
         _g = syntaxGenerator;
-        _linqToCSharpTranslator = new LinqToCSharpSyntaxTranslator(_g);
+        _linqToCSharpTranslator = new RuntimeModelLinqToCSharpSyntaxTranslator(_g);
+        _memberAccessReplacements = memberAccessReplacements;
         _liftableConstantProcessor = new LiftableConstantProcessor(null!);
         _queryCompiler = dbContext.GetService<IQueryCompiler>();
         _unsafeAccessors.Clear();
+        var contextType = dbContext.GetType();
         _funcletizer = new ExpressionTreeFuncletizer(
             dbContext.Model,
             dbContext.GetService<IEvaluatableExpressionFilter>(),
-            dbContext.GetType(),
+            contextType,
             generateContextAccessors: false,
             dbContext.GetService<IDiagnosticsLogger<DbLoggerCategory.Query>>());
 
@@ -79,7 +90,7 @@ public PrecompiledQueryCodeGenerator()
         _csharpToLinqTranslator.Load(compilation, dbContext, additionalAssembly);
 
         // TODO: Ignore our auto-generated code! Also compiled model, generated code (comment, filename...?).
-        var generatedSyntaxTrees = new List<GeneratedInterceptorFile>();
+        var generatedFiles = new List<ScaffoldedFile>();
         foreach (var syntaxTree in compilation.SyntaxTrees)
         {
             if (_queryLocator.LocateQueries(syntaxTree, precompilationErrors, cancellationToken) is not { Count: > 0 } locatedQueries)
@@ -88,15 +99,21 @@ public PrecompiledQueryCodeGenerator()
             }
 
             var semanticModel = compilation.GetSemanticModel(syntaxTree);
-            var generatedSyntaxTree = ProcessSyntaxTreeAsync(
-                syntaxTree, semanticModel, locatedQueries, precompilationErrors, cancellationToken);
-            if (generatedSyntaxTree is not null)
+            var generatedFile = ProcessSyntaxTree(
+                syntaxTree,
+                semanticModel,
+                locatedQueries,
+                precompilationErrors,
+                "." + contextType.ShortDisplayName() + (suffix ?? ".g"),
+                generatedFileNames,
+                cancellationToken);
+            if (generatedFile is not null)
             {
-                generatedSyntaxTrees.Add(generatedSyntaxTree);
+                generatedFiles.Add(generatedFile);
             }
         }
 
-        return generatedSyntaxTrees;
+        return generatedFiles;
     }
 
     /// <summary>
@@ -105,11 +122,13 @@ public PrecompiledQueryCodeGenerator()
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    protected virtual GeneratedInterceptorFile? ProcessSyntaxTreeAsync(
+    protected virtual ScaffoldedFile? ProcessSyntaxTree(
         SyntaxTree syntaxTree,
         SemanticModel semanticModel,
         IReadOnlyList<InvocationExpressionSyntax> locatedQueries,
         List<QueryPrecompilationError> precompilationErrors,
+        string suffix,
+        ISet<string> generatedFileNames,
         CancellationToken cancellationToken)
     {
         var queriesPrecompiledInFile = 0;
@@ -287,11 +306,15 @@ namespace System.Runtime.CompilerServices
         public InterceptsLocationAttribute(string filePath, int line, int column) { }
     }
 }
-""");
-
-        return new(
-            $"{Path.GetFileNameWithoutExtension(syntaxTree.FilePath)}.EFInterceptors.g{Path.GetExtension(syntaxTree.FilePath)}",
-            _code.ToString());
+"""
+        );
+
+        var name = Uniquifier.Uniquify(
+            Path.GetFileNameWithoutExtension(syntaxTree.FilePath),
+            generatedFileNames,
+            ".EFInterceptors" + suffix + Path.GetExtension(syntaxTree.FilePath),
+            CompiledModelScaffolder.MaxFileNameLength);
+        return new(name, _code.ToString());
     }
 
     /// <summary>
@@ -473,7 +496,7 @@ when namedReturnType2.AllInterfaces.Prepend(namedReturnType2)
         // Output the interceptor method signature preceded by the [InterceptsLocation] attribute.
         var startPosition = operatorSyntax.SyntaxTree.GetLineSpan(memberAccessSyntax.Name.Span, cancellationToken).StartLinePosition;
         var interceptorName = $"Query{queryNum}_{memberAccessSyntax.Name}{operatorNum}";
-        code.AppendLine($"""[InterceptsLocation("{operatorSyntax.SyntaxTree.FilePath}", {startPosition.Line + 1}, {startPosition.Character + 1})]""");
+        code.AppendLine($"""[InterceptsLocation(@"{operatorSyntax.SyntaxTree.FilePath.Replace("\"","\"\"")}", {startPosition.Line + 1}, {startPosition.Character + 1})]""");
         GenerateInterceptorMethodSignature();
         code.AppendLine("{").IncrementIndent();
 
@@ -749,7 +772,7 @@ void ProcessCapturedVariables()
                                 var collectedNamespaces = new HashSet<string>();
                                 var unsafeAccessors = new HashSet<MethodDeclarationSyntax>();
                                 var roslynPathSegment = _linqToCSharpTranslator.TranslateExpression(
-                                    linqPathSegment, constantReplacements: null, collectedNamespaces, unsafeAccessors);
+                                    linqPathSegment, constantReplacements: null, _memberAccessReplacements, collectedNamespaces, unsafeAccessors);
 
                                 var variableName = capturedVariablesPathTree.ExpressionType.Name;
                                 variableName = char.ToLower(variableName[0]) + variableName[1..^"Expression".Length] + ++variableCounter;
@@ -869,7 +892,7 @@ void ProcessCapturedVariables()
         foreach (var liftedConstant in _liftableConstantProcessor.LiftedConstants)
         {
             var variableValueSyntax = _linqToCSharpTranslator.TranslateExpression(
-                liftedConstant.Expression, constantReplacements: null, namespaces, unsafeAccessors);
+                liftedConstant.Expression, constantReplacements: null, _memberAccessReplacements, namespaces, unsafeAccessors);
             // code.AppendLine($"{liftedConstant.Parameter.Type.Name} {liftedConstant.Parameter.Name} = {variableValueSyntax.NormalizeWhitespace().ToFullString()};");
             code.AppendLine($"var {liftedConstant.Parameter.Name} = {variableValueSyntax.NormalizeWhitespace().ToFullString()};");
         }
@@ -878,6 +901,7 @@ void ProcessCapturedVariables()
             (AnonymousFunctionExpressionSyntax)_linqToCSharpTranslator.TranslateExpression(
                 queryExecutorAfterLiftingExpression,
                 constantReplacements: null,
+                _memberAccessReplacements,
                 namespaces,
                 unsafeAccessors);
 
@@ -1125,11 +1149,4 @@ private INamedTypeSymbol GetTypeSymbolOrThrow(string fullyQualifiedMetadataName)
             => _compilation.GetTypeByMetadataName(fullyQualifiedMetadataName)
                 ?? throw new InvalidOperationException("Could not find type symbol for: " + fullyQualifiedMetadataName);
     }
-
-    /// <summary>
-    ///     A generated file containing LINQ operator interceptors.
-    /// </summary>
-    /// <param name="Path">The path of the generated file.</param>
-    /// <param name="Code">The code of the generated file.</param>
-    public sealed record GeneratedInterceptorFile(string Path, string Code);
 }
diff --git a/src/EFCore.Design/Query/Internal/PrecompiledQueryCodeGeneratorSelector.cs b/src/EFCore.Design/Query/Internal/PrecompiledQueryCodeGeneratorSelector.cs
new file mode 100644
index 0000000000..62d4796cfc
--- /dev/null
+++ b/src/EFCore.Design/Query/Internal/PrecompiledQueryCodeGeneratorSelector.cs
@@ -0,0 +1,29 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.EntityFrameworkCore.Design.Internal;
+using Microsoft.EntityFrameworkCore.Query.Design;
+
+namespace Microsoft.EntityFrameworkCore.Query.Internal;
+
+/// <summary>
+///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+///     any release. You should only use it directly in your code with extreme caution and knowing that
+///     doing so can result in application failures when updating to a new Entity Framework Core release.
+/// </summary>
+public class PrecompiledQueryCodeGeneratorSelector :
+    LanguageBasedSelector<IPrecompiledQueryCodeGenerator>,
+    IPrecompiledQueryCodeGeneratorSelector
+{
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public PrecompiledQueryCodeGeneratorSelector(IEnumerable<IPrecompiledQueryCodeGenerator> services)
+        : base(services)
+    {
+    }
+}
diff --git a/src/EFCore.Design/Query/Internal/QueryLocator.cs b/src/EFCore.Design/Query/Internal/QueryLocator.cs
index 6b2ee65b40..e8a0c13a33 100644
--- a/src/EFCore.Design/Query/Internal/QueryLocator.cs
+++ b/src/EFCore.Design/Query/Internal/QueryLocator.cs
@@ -294,7 +294,7 @@ bool IsDbContextType(ITypeSymbol typeSymbol)
             {
                 while (true)
                 {
-                    // TODO: Check for the user's specific DbContext type
+                    // TODO: Check for the user's specific DbContext type #33866
                     if (typeSymbol.Equals(_symbols.DbContext, SymbolEqualityComparer.Default))
                     {
                         return true;
diff --git a/src/EFCore.Design/Query/Internal/RuntimeModelLinqToCSharpSyntaxTranslator.cs b/src/EFCore.Design/Query/Internal/RuntimeModelLinqToCSharpSyntaxTranslator.cs
index 2ab5978e82..def66e6c68 100644
--- a/src/EFCore.Design/Query/Internal/RuntimeModelLinqToCSharpSyntaxTranslator.cs
+++ b/src/EFCore.Design/Query/Internal/RuntimeModelLinqToCSharpSyntaxTranslator.cs
@@ -9,7 +9,6 @@
 using Microsoft.CodeAnalysis.Editing;
 using Microsoft.EntityFrameworkCore.ChangeTracking.Internal;
 using Microsoft.EntityFrameworkCore.Design.Internal;
-using Microsoft.EntityFrameworkCore.Internal;
 using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;
 
 namespace Microsoft.EntityFrameworkCore.Query.Internal;
diff --git a/src/EFCore.Design/Scaffolding/CompiledModelCodeGenerationOptions.cs b/src/EFCore.Design/Scaffolding/CompiledModelCodeGenerationOptions.cs
index 42ce349616..409565d74a 100644
--- a/src/EFCore.Design/Scaffolding/CompiledModelCodeGenerationOptions.cs
+++ b/src/EFCore.Design/Scaffolding/CompiledModelCodeGenerationOptions.cs
@@ -37,4 +37,10 @@ public class CompiledModelCodeGenerationOptions
     /// </summary>
     /// <value> The suffix to attach to the name of all the generated files. </value>
     public virtual string? Suffix { get; set; }
+
+    /// <summary>
+    ///     Gets or sets the set of file names generated so far.
+    /// </summary>
+    /// <value> The file names generated so far. </value>
+    public virtual ISet<string> GeneratedFileNames { get; set; } = new HashSet<string>();
 }
diff --git a/src/EFCore.Design/Scaffolding/Internal/CSharpModelGenerator.cs b/src/EFCore.Design/Scaffolding/Internal/CSharpModelGenerator.cs
index 785b79cb43..a2eb3f45bf 100644
--- a/src/EFCore.Design/Scaffolding/Internal/CSharpModelGenerator.cs
+++ b/src/EFCore.Design/Scaffolding/Internal/CSharpModelGenerator.cs
@@ -80,12 +80,10 @@ public override string Language
         var resultingFiles = new ScaffoldedModel
         {
             ContextFile = new ScaffoldedFile
-            {
-                Path = options.ContextDir != null
+                (options.ContextDir != null
                     ? Path.Combine(options.ContextDir, dbContextFileName)
                     : dbContextFileName,
-                Code = generatedCode
-            }
+             generatedCode)
         };
 
         foreach (var entityType in model.GetEntityTypes())
@@ -106,8 +104,7 @@ public override string Language
 
             // output EntityType poco .cs file
             var entityTypeFileName = entityType.Name + host.Extension;
-            resultingFiles.AdditionalFiles.Add(
-                new ScaffoldedFile { Path = entityTypeFileName, Code = generatedCode });
+            resultingFiles.AdditionalFiles.Add(new ScaffoldedFile(entityTypeFileName, generatedCode));
         }
 
         return resultingFiles;
diff --git a/src/EFCore.Design/Scaffolding/Internal/CSharpRuntimeModelCodeGenerator.cs b/src/EFCore.Design/Scaffolding/Internal/CSharpRuntimeModelCodeGenerator.cs
index 9eca5abf10..2224c1ffd7 100644
--- a/src/EFCore.Design/Scaffolding/Internal/CSharpRuntimeModelCodeGenerator.cs
+++ b/src/EFCore.Design/Scaffolding/Internal/CSharpRuntimeModelCodeGenerator.cs
@@ -66,31 +66,37 @@ public virtual string Language
         var scaffoldedFiles = new List<ScaffoldedFile>();
 
         var assemblyAttributesCode = CreateAssemblyAttributes(options.ModelNamespace, options.ContextType, nullable);
-        var assemblyInfoFileName = options.ContextType.ShortDisplayName() + AssemblyAttributesSuffix + FileExtension;
-        scaffoldedFiles.Add(new ScaffoldedFile { Path = assemblyInfoFileName, Code = assemblyAttributesCode });
+        var assemblyInfoFileName = Uniquify(options.ContextType.ShortDisplayName() + AssemblyAttributesSuffix, options);
+        scaffoldedFiles.Add(new(assemblyInfoFileName, assemblyAttributesCode));
 
         var modelCode = CreateModel(options.ModelNamespace, options.ContextType, nullable);
-        var modelFileName = options.ContextType.ShortDisplayName() + ModelSuffix + FileExtension;
-        scaffoldedFiles.Add(new ScaffoldedFile { Path = modelFileName, Code = modelCode });
+        var modelFileName = Uniquify(options.ContextType.ShortDisplayName() + ModelSuffix, options);
+        scaffoldedFiles.Add(new(modelFileName, modelCode));
 
         var configurationClassNames = new Dictionary<ITypeBase, string>();
         var modelBuilderCode = CreateModelBuilder(
             model, options.ModelNamespace, options.ContextType, configurationClassNames, nullable);
-        var modelBuilderFileName = options.ContextType.ShortDisplayName() + ModelBuilderSuffix + FileExtension;
-        scaffoldedFiles.Add(new ScaffoldedFile { Path = modelBuilderFileName, Code = modelBuilderCode });
+        var modelBuilderFileName = Uniquify(options.ContextType.ShortDisplayName() + ModelBuilderSuffix, options);
+        scaffoldedFiles.Add(new(modelBuilderFileName, modelBuilderCode));
 
         foreach (var entityType in model.GetEntityTypesInHierarchicalOrder())
         {
-            var generatedCode = GenerateEntityType(
-                entityType, options.ModelNamespace, configurationClassNames, nullable);
+            var generatedCode = GenerateEntityType(entityType, options.ModelNamespace, configurationClassNames, nullable);
 
-            var entityTypeFileName = configurationClassNames[entityType] + FileExtension;
-            scaffoldedFiles.Add(new ScaffoldedFile { Path = entityTypeFileName, Code = generatedCode });
+            var entityTypeFileName = Uniquify(configurationClassNames[entityType], options);
+            scaffoldedFiles.Add(new(entityTypeFileName, generatedCode));
         }
 
         return scaffoldedFiles;
     }
 
+    private string Uniquify(string name, CompiledModelCodeGenerationOptions options)
+        => Uniquifier.Uniquify(
+            name,
+            options.GeneratedFileNames,
+            (options.Suffix ?? "") + FileExtension,
+            CompiledModelScaffolder.MaxFileNameLength);
+
     private static string GenerateHeader(SortedSet<string> namespaces, string currentNamespace, bool nullable)
     {
         for (var i = 0; i < currentNamespace.Length; i++)
@@ -2267,7 +2273,6 @@ private void Create(ITrigger trigger, CSharpRuntimeAnnotationCodeGeneratorParame
 
             var runtimeType = (IRuntimeEntityType)entityType;
 
-            // TODO
             var unsafeAccessors = new HashSet<string>();
 
             var originalValuesFactory = OriginalValuesFactoryFactory.Instance.CreateExpression(runtimeType);
@@ -2334,6 +2339,9 @@ private void Create(ITrigger trigger, CSharpRuntimeAnnotationCodeGeneratorParame
 
             CreateAnnotations(entityType, _annotationCodeGenerator.Generate, parameters);
 
+            // TODO: Output any additional unsafe accessors
+            Check.DebugAssert(unsafeAccessors.Count == 0, "Generated unsafe accessors not handled");
+
             mainBuilder
                 .AppendLine()
                 .AppendLine("Customize(runtimeEntityType);");
diff --git a/src/EFCore.Design/Scaffolding/Internal/CompiledModelScaffolder.cs b/src/EFCore.Design/Scaffolding/Internal/CompiledModelScaffolder.cs
index 95884bd6b7..aaf7d61d90 100644
--- a/src/EFCore.Design/Scaffolding/Internal/CompiledModelScaffolder.cs
+++ b/src/EFCore.Design/Scaffolding/Internal/CompiledModelScaffolder.cs
@@ -15,6 +15,14 @@ namespace Microsoft.EntityFrameworkCore.Scaffolding.Internal;
 /// </summary>
 public class CompiledModelScaffolder : ICompiledModelScaffolder
 {
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public static readonly int MaxFileNameLength = 255;
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -45,62 +53,46 @@ public CompiledModelScaffolder(ICompiledModelCodeGeneratorSelector modelCodeGene
         string outputDir,
         CompiledModelCodeGenerationOptions options)
     {
-        var codeGenerator = ModelCodeGeneratorSelector.Select(options);
-
-        var scaffoldedModel = codeGenerator.GenerateModel(model, options);
-
-        if (options.Suffix != null)
-        {
-            foreach (var file in scaffoldedModel)
-            {
-                file.Path = file.Path.Insert(file.Path.LastIndexOf('.'), options.Suffix);
-            }
-        }
-
-        CheckOutputFiles(scaffoldedModel, outputDir);
-
-        Directory.CreateDirectory(outputDir);
-
-        var savedFiles = new List<string>();
-        foreach (var file in scaffoldedModel)
-        {
-            var filePath = Path.Combine(outputDir, file.Path);
-            File.WriteAllText(filePath, file.Code, Encoding.UTF8);
-            savedFiles.Add(filePath);
-        }
-
-        return savedFiles;
+        var scaffoldedModel = ModelCodeGeneratorSelector.Select(options).GenerateModel(model, options);
+        return WriteFiles(scaffoldedModel, outputDir);
     }
 
-    private static void CheckOutputFiles(
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public static IReadOnlyList<string> WriteFiles(
         IReadOnlyCollection<ScaffoldedFile> scaffoldedModel,
         string outputDir)
     {
+        Directory.CreateDirectory(outputDir);
         var paths = scaffoldedModel.Select(f => f.Path).ToList();
 
-        var existingFiles = new List<string>();
         var readOnlyFiles = new List<string>();
-        foreach (var path in paths)
+        var savedFiles = new List<string>();
+        foreach (var file in scaffoldedModel)
         {
-            var fullPath = Path.Combine(outputDir, path);
+            var fullPath = Path.Combine(outputDir, file.Path);
 
-            if (File.Exists(fullPath))
+            if (File.Exists(fullPath)
+                && File.GetAttributes(fullPath).HasFlag(FileAttributes.ReadOnly))
             {
-                existingFiles.Add(path);
-
-                if (File.GetAttributes(fullPath).HasFlag(FileAttributes.ReadOnly))
-                {
-                    readOnlyFiles.Add(path);
-                }
+                readOnlyFiles.Add(file.Path);
+            }
+            else
+            {
+                File.WriteAllText(fullPath, file.Code, Encoding.UTF8);
+                savedFiles.Add(fullPath);
             }
         }
 
-        if (readOnlyFiles.Count != 0)
-        {
-            throw new OperationException(
+        return readOnlyFiles.Count != 0
+            ? throw new OperationException(
                 DesignStrings.ReadOnlyFiles(
                     outputDir,
-                    string.Join(CultureInfo.CurrentCulture.TextInfo.ListSeparator, readOnlyFiles)));
-        }
+                    string.Join(CultureInfo.CurrentCulture.TextInfo.ListSeparator, readOnlyFiles)))
+            : (IReadOnlyList<string>)savedFiles;
     }
 }
diff --git a/src/EFCore.Design/Scaffolding/Internal/TextTemplatingModelGenerator.cs b/src/EFCore.Design/Scaffolding/Internal/TextTemplatingModelGenerator.cs
index 937bbd157f..bd42bfd960 100644
--- a/src/EFCore.Design/Scaffolding/Internal/TextTemplatingModelGenerator.cs
+++ b/src/EFCore.Design/Scaffolding/Internal/TextTemplatingModelGenerator.cs
@@ -137,13 +137,11 @@ public override ScaffoldedModel GenerateModel(IModel model, ModelCodeGenerationO
         var dbContextFileName = options.ContextName + host.Extension;
         var resultingFiles = new ScaffoldedModel
         {
-            ContextFile = new ScaffoldedFile
-            {
-                Path = options.ContextDir != null
+            ContextFile = new ScaffoldedFile(
+                options.ContextDir != null
                     ? Path.Combine(options.ContextDir, dbContextFileName)
                     : dbContextFileName,
-                Code = generatedCode
-            }
+                generatedCode)
         };
 
         var entityTypeTemplate = Path.Combine(options.ProjectDir!, TemplatesDirectory, EntityTypeTemplate);
@@ -181,7 +179,7 @@ public override ScaffoldedModel GenerateModel(IModel model, ModelCodeGenerationO
 
                     var entityTypeFileName = entityType.Name + entityTypeExtension;
                     resultingFiles.AdditionalFiles.Add(
-                        new ScaffoldedFile { Path = entityTypeFileName, Code = generatedCode });
+                        new ScaffoldedFile(entityTypeFileName,  generatedCode));
                 }
             }
             finally
@@ -225,13 +223,11 @@ public override ScaffoldedModel GenerateModel(IModel model, ModelCodeGenerationO
 
                     var configurationFileName = entityType.Name + "Configuration" + configurationExtension;
                     resultingFiles.AdditionalFiles.Add(
-                        new ScaffoldedFile
-                        {
-                            Path = options.ContextDir != null
+                        new ScaffoldedFile(
+                            options.ContextDir != null
                                 ? Path.Combine(options.ContextDir, configurationFileName)
                                 : configurationFileName,
-                            Code = generatedCode
-                        });
+                            generatedCode));
                 }
             }
             finally
diff --git a/src/EFCore.Design/Scaffolding/ScaffoldedFile.cs b/src/EFCore.Design/Scaffolding/ScaffoldedFile.cs
index 8e88571489..8ec3272a54 100644
--- a/src/EFCore.Design/Scaffolding/ScaffoldedFile.cs
+++ b/src/EFCore.Design/Scaffolding/ScaffoldedFile.cs
@@ -6,17 +6,22 @@ namespace Microsoft.EntityFrameworkCore.Scaffolding;
 /// <summary>
 ///     Represents a scaffolded file.
 /// </summary>
-public class ScaffoldedFile
+/// <remarks>
+///     Constructs a new instance of <see cref="ScaffoldedFile" />.
+/// </remarks>
+/// <param name="path">The path.</param>
+/// <param name="code">The scaffolded code</param>
+public class ScaffoldedFile(string path, string code)
 {
     /// <summary>
     ///     Gets or sets the path.
     /// </summary>
     /// <value> The path. </value>
-    public virtual string Path { get; set; } = null!;
+    public virtual string Path { get; set; } = path;
 
     /// <summary>
     ///     Gets or sets the scaffolded code.
     /// </summary>
     /// <value> The scaffolded code. </value>
-    public virtual string Code { get; set; } = null!;
+    public virtual string Code { get; set; } = code;
 }
diff --git a/src/EFCore.Relational/Metadata/Conventions/RelationalRuntimeModelConvention.cs b/src/EFCore.Relational/Metadata/Conventions/RelationalRuntimeModelConvention.cs
index 906c473e43..519f3adbda 100644
--- a/src/EFCore.Relational/Metadata/Conventions/RelationalRuntimeModelConvention.cs
+++ b/src/EFCore.Relational/Metadata/Conventions/RelationalRuntimeModelConvention.cs
@@ -1,7 +1,6 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System.Reflection.Emit;
 using Microsoft.EntityFrameworkCore.Metadata.Internal;
 
 namespace Microsoft.EntityFrameworkCore.Metadata.Conventions;
diff --git a/src/EFCore.Tasks/Tasks/Internal/OperationTaskBase.cs b/src/EFCore.Tasks/Tasks/Internal/OperationTaskBase.cs
index a7108649eb..6862e2fe70 100644
--- a/src/EFCore.Tasks/Tasks/Internal/OperationTaskBase.cs
+++ b/src/EFCore.Tasks/Tasks/Internal/OperationTaskBase.cs
@@ -51,6 +51,11 @@ public abstract class OperationTaskBase : Build.Utilities.ToolTask
     /// </summary>
     public ITaskItem? DataDir { get; set; }
 
+    /// <summary>
+    ///    The target project.
+    /// </summary>
+    public ITaskItem? Project { get; set; }
+
     /// <summary>
     ///    The project directory.
     /// </summary>
@@ -197,6 +202,12 @@ protected override string GenerateCommandLineCommands()
             args.Add(Path.ChangeExtension(StartupAssembly.ItemSpec, ".dll"));
         }
 
+        if (Project != null)
+        {
+            args.Add("--project");
+            args.Add(Project.ItemSpec);
+        }
+
         if (ProjectDir != null)
         {
             args.Add("--project-dir");
diff --git a/src/EFCore.Tasks/Tasks/OptimizeDbContext.cs b/src/EFCore.Tasks/Tasks/OptimizeDbContext.cs
index 879af90b8f..da98cd1e4c 100644
--- a/src/EFCore.Tasks/Tasks/OptimizeDbContext.cs
+++ b/src/EFCore.Tasks/Tasks/OptimizeDbContext.cs
@@ -13,9 +13,9 @@ namespace Microsoft.EntityFrameworkCore.Tasks;
 public class OptimizeDbContext : OperationTaskBase
 {
     /// <summary>
-    ///     The name of the target DbContext.
+    ///     The type of the target DbContext.
     /// </summary>
-    public string? DbContextName { get; set; }
+    public string? DbContextType { get; set; }
 
     /// <summary>
     ///     The namespace to use for the generated classes.
@@ -27,6 +27,16 @@ public class OptimizeDbContext : OperationTaskBase
     /// </summary>
     public ITaskItem? OutputDir { get; set; }
 
+    /// <summary>
+    ///     Don't generate a compiled model.
+    /// </summary>
+    public bool NoScaffold { get; set; }
+
+    /// <summary>
+    ///     Generate precompiled queries.
+    /// </summary>
+    public bool PrecompileQueries { get; set; }
+
     /// <summary>
     ///     Generated files that should be include in the build.
     /// </summary>
@@ -55,11 +65,21 @@ public override bool Execute()
                 AdditionalArguments.Add(targetNamespace);
             }
 
-            var dbContextName = MsBuildUtilities.TrimAndGetNullForEmpty(DbContextName);
-            if(dbContextName != null)
+            var dbContextType = MsBuildUtilities.TrimAndGetNullForEmpty(DbContextType);
+            if (dbContextType != null)
             {
                 AdditionalArguments.Add("--context");
-                AdditionalArguments.Add(dbContextName);
+                AdditionalArguments.Add(dbContextType);
+            }
+
+            if (NoScaffold)
+            {
+                AdditionalArguments.Add("--no-scaffold");
+            }
+
+            if (PrecompileQueries)
+            {
+                AdditionalArguments.Add("--precompile-queries");
             }
 
             AdditionalArguments.Add("--suffix");
diff --git a/src/EFCore.Tasks/buildTransitive/Microsoft.EntityFrameworkCore.Tasks.props b/src/EFCore.Tasks/buildTransitive/Microsoft.EntityFrameworkCore.Tasks.props
index 9f7c1d34aa..9602541798 100644
--- a/src/EFCore.Tasks/buildTransitive/Microsoft.EntityFrameworkCore.Tasks.props
+++ b/src/EFCore.Tasks/buildTransitive/Microsoft.EntityFrameworkCore.Tasks.props
@@ -4,8 +4,10 @@
     <_TaskTargetFramework Condition="'$(MSBuildRuntimeType)' == 'core'">net8.0</_TaskTargetFramework>
     <_TaskTargetFramework Condition="'$(MSBuildRuntimeType)' != 'core'">net472</_TaskTargetFramework>
     <_EFCustomTasksAssembly>$([MSBuild]::NormalizePath($(MSBuildThisFileDirectory), '..\tasks\$(_TaskTargetFramework)\$(MSBuildThisFileName).dll'))</_EFCustomTasksAssembly>
-    <EFOptimizeContext Condition="'$(EFOptimizeContext)'==''">false</EFOptimizeContext>
+    <EFScaffoldModelStage Condition="'$(EFScaffoldModelStage)'==''">publish</EFScaffoldModelStage>
+    <EFPrecompileQueriesStage Condition="'$(EFPrecompileQueriesStage)'==''">publish</EFPrecompileQueriesStage>
     <EFStartupProject Condition="'$(EFStartupProject)'==''">$(MSBuildProjectFullPath)</EFStartupProject>
+    <DbContextType Condition="'$(DbContextType)'==''">*</DbContextType>
   </PropertyGroup>
 
   <UsingTask TaskName="$(MSBuildThisFileName).OptimizeDbContext" AssemblyFile="$(_EFCustomTasksAssembly)"/>
diff --git a/src/EFCore.Tasks/buildTransitive/Microsoft.EntityFrameworkCore.Tasks.targets b/src/EFCore.Tasks/buildTransitive/Microsoft.EntityFrameworkCore.Tasks.targets
index 922dbf4b4c..438631eb09 100644
--- a/src/EFCore.Tasks/buildTransitive/Microsoft.EntityFrameworkCore.Tasks.targets
+++ b/src/EFCore.Tasks/buildTransitive/Microsoft.EntityFrameworkCore.Tasks.targets
@@ -2,9 +2,11 @@
 <Project ToolsVersion="17.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
 
   <PropertyGroup>
-    <_FullOutputPath>$([MSBuild]::NormalizePath($(MSBuildProjectDirectory), '$(OutputPath)'))</_FullOutputPath>
-    <_FullIntermediateOutputPath>$([MSBuild]::NormalizePath($(MSBuildProjectDirectory), '$(IntermediateOutputPath)'))</_FullIntermediateOutputPath>
-    <EFGeneratedSourcesFile Condition="'$(EFGeneratedSourcesFile)' == ''">$(_FullIntermediateOutputPath)$(AssemblyName).EFGeneratedSources.txt</EFGeneratedSourcesFile>
+    <_FullOutputPath>$([MSBuild]::NormalizePath('$(MSBuildProjectDirectory)', '$(OutputPath)'))</_FullOutputPath>
+    <_FullIntermediateOutputPath>$([MSBuild]::NormalizePath('$(MSBuildProjectDirectory)', '$(IntermediateOutputPath)'))</_FullIntermediateOutputPath>
+    <_FullIntermediateOutputPath Condition="'$(AppendRuntimeIdentifierToOutputPath)' == 'true' And '$(RuntimeIdentifier)' != '' And '$(_UsingDefaultRuntimeIdentifier)' != 'true' And '$(UseArtifactsIntermediateOutput)' != 'true'">$([MSBuild]::NormalizePath('$(_FullIntermediateOutputPath)', '../'))</_FullIntermediateOutputPath>
+    <EFGeneratedSourcesBuildFile Condition="'$(EFGeneratedSourcesBuildFile)' == ''">$(_FullIntermediateOutputPath)$(AssemblyName).EFGeneratedSources.Build.txt</EFGeneratedSourcesBuildFile>
+    <EFGeneratedSourcesPublishFile Condition="'$(EFGeneratedSourcesPublishFile)' == ''">$(_FullIntermediateOutputPath)$(AssemblyName).EFGeneratedSources.Publish.txt</EFGeneratedSourcesPublishFile>
     <EFProjectsToOptimizePath Condition="'$(EFProjectsToOptimizePath)' == ''">$(_FullIntermediateOutputPath)EFProjectsToOptimize\</EFProjectsToOptimizePath>
     <_AssemblyFullName>$(_FullOutputPath)$(AssemblyName).dll</_AssemblyFullName>
     <CoreCompileDependsOn>$(CoreCompileDependsOn);_EFPrepareForCompile</CoreCompileDependsOn>
@@ -14,10 +16,52 @@
     <_AssemblyFullName>$(_FullOutputPath)$(AssemblyName).exe</_AssemblyFullName>
   </PropertyGroup>
 
+  <!-- Usage:
+  For the compiled model and precompiled queries to be generated when publishing with $(PublishAOT) set to true the only action needed is to reference Microsoft.EntityFrameworkCore.Tasks from all projects containing a derived DbContext or a query.
+  For solutions where specifying the startup project is necessary, $(EFStartupProject) should be set.
+$(EFOptimizeContext) can be set to true to enable code generation outside of NativeAOT.
+$(EFScaffoldModelStage) and $(EFPrecompileQueriesStage) can be set to either publish or build to control at what stage will the code be generated. Any other value will disable the corresponding generation (in case the code is generated manually using dotnet ef dbcontext optimize)
+If there's more than one context and $(DbContextType) is not set, then the compiled model will be generated for all of them.
+$(EFTargetNamespace) and $(EFOutputDir) can be used to further fine-tune the generation.
+  -->
+
+  <!--Implementation details:
+  For Build:
+
+1. _EFReadGeneratedFilesList and _EFProcessGeneratedFiles add the files generated previously to @(Compile) to make incremental build work.
+2. If compilation needs to be performed again then _EFPrepareForCompile removes the previously generated files from @(Compile) as they are probably outdated. And if EFOptimizeContext is true it also calls _EFRegisterProjectToOptimize on the startup project to mark the current project for optimization. Startup project could also be the same as the project containing the derived DbContext, but if it's not the tooling needs the compiled startup assembly to be able to generate code for any other project.
+3. If any project was marked then _EFGenerateFilesAfterBuild in the startup project calls _EFGenerateFiles which in turn calls OptimizeDbContext on the marked projects.
+4. OptimizeDbContext generates NativeAOT-compatible code and writes the list of generated files for _EFReadGeneratedFilesList to read when recompiling.
+
+For Publish:
+
+1. If PublishAOT is true _EFPrepareDependenciesForPublishAOT in the startup project invokes _EFPrepareForPublish on all dependencies to mark them for optimization even if they don't set EFOptimizeContext to true. Otherwise _EFPrepareForPublish runs on the projects before Publish.
+2. If any project was marked then _EFGenerateFilesBeforePublish in the startup project calls _EFGenerateFiles and the rest is similar to the Build flow.
+  -->
+
+  <Target Name="_EFGenerateFilesAfterBuild"
+        AfterTargets="Build"
+        Condition="Exists($(EFProjectsToOptimizePath)) And '$(_EFGenerationStage)'==''">
+    <MSBuild Projects="$(MSBuildProjectFullPath)"
+             Targets="_EFGenerateFiles"
+             BuildInParallel="$(BuildInParallel)"
+             ContinueOnError="$(ContinueOnError)"
+             Properties="Configuration=$(Configuration);Platform=$(Platform);_EFGenerationStage=build" />
+  </Target>
+
+  <Target Name="_EFGenerateFilesBeforePublish"
+        AfterTargets="GetCopyToPublishDirectoryItems"
+        BeforeTargets="GeneratePublishDependencyFile"
+        Condition="Exists($(EFProjectsToOptimizePath)) And '$(_EFGenerationStage)'==''">
+    <MSBuild Projects="$(MSBuildProjectFullPath)"
+             Targets="_EFGenerateFiles"
+             BuildInParallel="$(BuildInParallel)"
+             ContinueOnError="$(ContinueOnError)"
+             Properties="Configuration=$(Configuration);Platform=$(Platform);_EFGenerationStage=publish" />
+  </Target>
+
   <!-- Invokes OptimizeDbContext on projects that had changes since the last time they were optimized -->
-  <Target Name="_EFGenerateFiles"
-          AfterTargets="Build"
-          Condition="Exists($(EFProjectsToOptimizePath))">
+  <Target Name="_EFGenerateFiles">
     <ItemGroup>
       <_EFProjectsToOptimizeFiles Include="$(EFProjectsToOptimizePath)*.*" />
     </ItemGroup>
@@ -31,14 +75,16 @@
     <!-- The startup assembly used for file generation should be compiled without using AOT mode -->
     <MSBuild Projects="$(MSBuildProjectFullPath)"
              Targets="Build"
-             BuildInParallel="true"
+             BuildInParallel="$(BuildInParallel)"
+             ContinueOnError="$(ContinueOnError)"
              Condition="'$(PublishAot)'=='true'"
-             Properties="Configuration=$(Configuration);Platform=$(Platform);EFOptimizeContext=false;PublishAot=false" />
+             Properties="Configuration=$(Configuration);Platform=$(Platform);PublishAot=false;_EFGenerationStage=$(_EFGenerationStage)" />
 
     <MSBuild Projects="@(_EFProjectsToOptimize)"
              Targets="OptimizeDbContext"
-             BuildInParallel="true"
-             Properties="Configuration=$(Configuration);Platform=$(Platform);EFOptimizeContext=false;EFStartupAssembly=$(_AssemblyFullName)" />
+             BuildInParallel="$(BuildInParallel)"
+             ContinueOnError="$(ContinueOnError)"
+             Properties="Configuration=$(Configuration);Platform=$(Platform);EFStartupAssembly=$(_AssemblyFullName);_EFGenerationStage=$(_EFGenerationStage)" />
 
     <ItemGroup>
       <_EFProjectsToOptimize Remove="$(MSBuildProjectFullPath)" />
@@ -47,25 +93,24 @@
     <!-- This assumes that the optimized projects are dependencies, so the current project needs to be recompiled too -->
     <MSBuild Projects="$(MSBuildProjectFullPath)"
              Targets="Build"
-             BuildInParallel="true"
+             BuildInParallel="$(BuildInParallel)"
+             ContinueOnError="$(ContinueOnError)"
              Condition="@(_EFProjectsToOptimize->Count()) &gt; 0"
-             Properties="Configuration=$(Configuration);Platform=$(Platform);EFOptimizeContext=false" />
+             Properties="Configuration=$(Configuration);Platform=$(Platform);_EFGenerationStage=$(_EFGenerationStage)" />
   </Target>
 
-  <Target Name="OptimizeDbContext"
-          Inputs="$(_AssemblyFullName)"
-          Outputs="$(EFGeneratedSourcesFile)"
-          Returns="$(_EFGeneratedFiles)">
+  <Target Name="OptimizeDbContext">
     <PropertyGroup>
       <EFRootNamespace Condition="'$(EFRootNamespace)'==''">$(RootNamespace)</EFRootNamespace>
       <EFRootNamespace Condition="'$(EFRootNamespace)'==''">$(AssemblyName)</EFRootNamespace>
       <EFTargetNamespace Condition="'$(EFTargetNamespace)'==''">$(EFRootNamespace)</EFTargetNamespace>
       <EFOutputDir Condition="'$(EFOutputDir)'==''">$(_FullIntermediateOutputPath)</EFOutputDir>
-      <EFNullable>false</EFNullable>
-    </PropertyGroup>
-
-    <PropertyGroup Condition="'$(Nullable)'=='enable' Or '$(Nullable)'=='annotations'">
-      <EFNullable>true</EFNullable>
+      <_EFNoScaffold>true</_EFNoScaffold>
+      <_EFNoScaffold Condition="'$(_EFGenerationStage)'=='$(EFScaffoldModelStage)'">false</_EFNoScaffold>
+      <_EFPrecompileQueries>false</_EFPrecompileQueries>
+      <_EFPrecompileQueries Condition="'$(_EFGenerationStage)'=='$(EFPrecompileQueriesStage)'">true</_EFPrecompileQueries>
+      <EFNullable Condition="'$(Nullable)'=='enable' Or '$(Nullable)'=='annotations'">true</EFNullable>
+      <EFNullable Condition="'$(EFNullable)'==''">false</EFNullable>
     </PropertyGroup>
 
     <OptimizeDbContext Assembly="$(_AssemblyFullName)"
@@ -73,28 +118,50 @@
                        ProjectAssetsFile="$(ProjectAssetsFile)"
                        RuntimeFrameworkVersion="$(RuntimeFrameworkVersion)"
                        TargetFrameworkMoniker="$(TargetFrameworkMoniker)"
-                       DbContextName="$(DbContextName)"
+                       DbContextType="$(DbContextType)"
                        RootNamespace="$(EFRootNamespace)"
                        TargetNamespace="$(EFTargetNamespace)"
                        Language="$(Language)"
                        Nullable="$(EFNullable)"
                        OutputDir="$(EFOutputDir)"
-                       ProjectDir="$(MSBuildProjectDirectory)">
+                       Project="$(MSBuildProjectFullPath)"
+                       ProjectDir="$(MSBuildProjectDirectory)"
+                       NoScaffold="$(_EFNoScaffold)"
+                       PrecompileQueries="$(_EFPrecompileQueries)"
+                       Condition="'$(_EFNoScaffold)'=='false' Or '$(_EFPrecompileQueries)'=='true'">
       <Output TaskParameter="GeneratedFiles" PropertyName="_EFGeneratedFiles" />
     </OptimizeDbContext>
 
-    <Delete Files="$(EFGeneratedSourcesFile)" />
+    <Delete Files="$(EFGeneratedSourcesBuildFile)"
+            Condition="'$(_EFGenerationStage)'=='build'"/>
+    <Delete Files="$(EFGeneratedSourcesPublishFile)"
+            Condition="'$(_EFGenerationStage)'=='publish'"/>
 
     <CallTarget Targets="Build"/>
 
-    <WriteLinesToFile File="$(EFGeneratedSourcesFile)" Lines="$(_EFGeneratedFiles)"/>
+    <WriteLinesToFile File="$(EFGeneratedSourcesBuildFile)"
+                      Lines="$(_EFGeneratedFiles)"
+                      Condition="'$(_EFGenerationStage)'=='build'"/>
+    <WriteLinesToFile File="$(EFGeneratedSourcesPublishFile)"
+                      Lines="$(_EFGeneratedFiles)"
+                      Condition="'$(_EFGenerationStage)'=='publish'"/>
   </Target>
 
-  <!-- Read the previously generated files if the files weren't regenerated -->
+  <Target Name="_EFValidateProperties"
+          BeforeTargets="CoreCompile">
+    <Error Condition="'$(EFScaffoldModelStage)'=='publish' And '$(EFPrecompileQueriesStage)'=='build'"
+           Text="If %24(EFScaffoldModelStage) is set to 'publish' then %24(EFPrecompileQueriesStage) must also be set to 'publish'."/>
+  </Target>
+
+  <!-- Read the previously generated files -->
   <Target Name="_EFReadGeneratedFilesList"
-          BeforeTargets="_EFProcessGeneratedFiles;_EFCleanupGeneratedFiles"
-          Condition="'$(EFOptimizeContext)'=='true' And Exists($(EFGeneratedSourcesFile))">
-    <ReadLinesFromFile File="$(EFGeneratedSourcesFile)">
+          BeforeTargets="_EFProcessGeneratedFiles;_EFCleanGeneratedFiles">
+    <ReadLinesFromFile File="$(EFGeneratedSourcesBuildFile)"
+                       Condition="Exists($(EFGeneratedSourcesBuildFile))">
+      <Output TaskParameter="Lines" ItemName="_ReadGeneratedFiles"/>
+    </ReadLinesFromFile>
+    <ReadLinesFromFile File="$(EFGeneratedSourcesPublishFile)"
+                       Condition="Exists($(EFGeneratedSourcesPublishFile))">
       <Output TaskParameter="Lines" ItemName="_ReadGeneratedFiles"/>
     </ReadLinesFromFile>
 
@@ -111,11 +178,11 @@
     </ItemGroup>
   </Target>
 
-  <!-- Removes the outdated generated files from compilation and registers this project for optimization
+  <!-- Removes the outdated generated files from compilation and registers this project for after-compile optimization
        This target has the same Inputs and Outputs as CoreCompile to run only if CoreCompile isn't going to be skipped -->
   <Target Name="_EFPrepareForCompile"
           DependsOnTargets="_EFProcessGeneratedFiles"
-          Condition="'$(EFOptimizeContext)'=='true'"
+          Condition="'$(_EFGenerationStage)'==''"
           Inputs="$(MSBuildAllProjects);
                   @(Compile);
                   @(_CoreCompileResourceInputs);
@@ -144,11 +211,39 @@
       <Compile Remove="@(_EFGeneratedFiles)" />
     </ItemGroup>
 
+    <Delete Files="$(EFGeneratedSourcesBuildFile)" />
+    <Delete Files="$(EFGeneratedSourcesPublishFile)" />
+
     <MSBuild Projects="$(EFStartupProject)"
              Targets="_EFRegisterProjectToOptimize"
+             Condition="'$(EFOptimizeContext)'=='true' And ('$(EFScaffoldModelStage)'=='build' Or '$(EFPrecompileQueriesStage)'=='build')"
              Properties="Configuration=$(Configuration);Platform=$(Platform);_EFProjectToOptimize=$(MSBuildProjectFullPath)" />
   </Target>
 
+  <!-- Registers this project for before-publish optimization -->
+  <Target Name="_EFPrepareForPublish"
+          BeforeTargets="GetCopyToPublishDirectoryItems"
+          Condition="'$(_EFGenerationStage)'=='' And ('$(EFScaffoldModelStage)'=='publish' Or '$(EFPrecompileQueriesStage)'=='publish') And ('$(EFOptimizeContext)'=='true' Or ('$(EFOptimizeContext)'=='' And ('$(_EFPublishAOT)'=='true' Or '$(PublishAOT)'=='true')))">
+    <MSBuild Projects="$(EFStartupProject)"
+             Targets="_EFRegisterProjectToOptimize"
+             Properties="Configuration=$(Configuration);Platform=$(Platform);_EFProjectToOptimize=$(MSBuildProjectFullPath)" />
+  </Target>
+
+  <!-- Go through the dependencies to check whether they need code generated for Native AOT -->
+  <Target Name="_EFPrepareDependenciesForPublishAOT"
+          BeforeTargets="GetCopyToPublishDirectoryItems"
+          Condition="'$(PublishAOT)'=='true' And '$(_EFGenerationStage)'=='' and '@(_MSBuildProjectReferenceExistent)' != ''">
+    <MSBuild
+      Projects="@(_MSBuildProjectReferenceExistent)"
+      Targets="_EFPrepareForPublish"
+      BuildInParallel="$(BuildInParallel)"
+      Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration);%(_MSBuildProjectReferenceExistent.SetPlatform);%(_MSBuildProjectReferenceExistent.SetTargetFramework);_EFPublishAOT=true"
+      Condition="'%(_MSBuildProjectReferenceExistent.BuildReference)' == 'true' and '@(ProjectReferenceWithConfiguration)' != '' "
+      ContinueOnError="$(ContinueOnError)"
+      SkipNonexistentTargets="true"
+      RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)$(_GlobalPropertiesToRemoveFromProjectReferences)"/>
+  </Target>
+
   <Target Name="_EFRegisterProjectToOptimize">
     <PropertyGroup>
       <_ProjectName>$([System.IO.Path]::GetFileName('$(_EFProjectToOptimize)'))</_ProjectName>
@@ -159,7 +254,8 @@
 
   <Target Name="_EFCleanGeneratedFiles" AfterTargets="Clean">
     <Delete Files="@(_EFGeneratedFiles)" />
-    <Delete Files="$(EFGeneratedSourcesFile)" />
+    <Delete Files="$(EFGeneratedSourcesBuildFile)" />
+    <Delete Files="$(EFGeneratedSourcesPublishFile)" />
     <RemoveDir Directories="$(EFProjectsToOptimizePath)" />
   </Target>
 
diff --git a/src/EFCore/Infrastructure/DbContextModelAttribute.cs b/src/EFCore/Infrastructure/DbContextModelAttribute.cs
index 229f30ec03..095e4d3df0 100644
--- a/src/EFCore/Infrastructure/DbContextModelAttribute.cs
+++ b/src/EFCore/Infrastructure/DbContextModelAttribute.cs
@@ -1,6 +1,8 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using System.Diagnostics.CodeAnalysis;
+
 namespace Microsoft.EntityFrameworkCore.Infrastructure;
 
 /// <summary>
@@ -22,7 +24,9 @@ public sealed class DbContextModelAttribute : Attribute
     /// </summary>
     /// <param name="contextType">The associated context.</param>
     /// <param name="modelType">The compiled model.</param>
-    public DbContextModelAttribute(Type contextType, Type modelType)
+    public DbContextModelAttribute(
+        [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicProperties)] Type contextType,
+        [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicProperties)] Type modelType)
     {
         Check.NotNull(contextType, nameof(contextType));
 
diff --git a/src/EFCore/Infrastructure/Uniquifier.cs b/src/EFCore/Infrastructure/Uniquifier.cs
index 7d13f35487..c3449a9e2e 100644
--- a/src/EFCore/Infrastructure/Uniquifier.cs
+++ b/src/EFCore/Infrastructure/Uniquifier.cs
@@ -26,16 +26,7 @@ public static class Uniquifier
         string currentIdentifier,
         IReadOnlyDictionary<string, T> otherIdentifiers,
         int maxLength)
-    {
-        var finalIdentifier = Truncate(currentIdentifier, maxLength);
-        var suffix = 1;
-        while (otherIdentifiers.ContainsKey(finalIdentifier))
-        {
-            finalIdentifier = Truncate(currentIdentifier, maxLength, suffix++);
-        }
-
-        return finalIdentifier;
-    }
+        => Uniquify(currentIdentifier, otherIdentifiers, s => s, maxLength);
 
     /// <summary>
     ///     Creates a unique identifier by appending a number to the given string.
@@ -63,6 +54,30 @@ public static class Uniquifier
         return finalIdentifier;
     }
 
+    /// <summary>
+    ///     Creates a unique identifier by appending a number to the given string.
+    /// </summary>
+    /// <param name="currentIdentifier">The base identifier.</param>
+    /// <param name="otherIdentifiers">A dictionary where the identifier will be used as part of the key.</param>
+    /// <param name="suffix">An optional suffix to add after the uniquifier.</param>
+    /// <param name="maxLength">The maximum length of the identifier.</param>
+    /// <returns>A unique identifier.</returns>
+    public static string Uniquify(
+        string currentIdentifier,
+        ISet<string> otherIdentifiers,
+        string? suffix,
+        int maxLength)
+    {
+        var finalIdentifier = Truncate(currentIdentifier, maxLength, suffix);
+        var uniquifier = 1;
+        while (otherIdentifiers.Contains(finalIdentifier))
+        {
+            finalIdentifier = Truncate(currentIdentifier, maxLength, suffix, uniquifier++);
+        }
+
+        return finalIdentifier;
+    }
+
     /// <summary>
     ///     Ensures the given identifier is shorter than the given length by removing the extra characters from the end.
     /// </summary>
@@ -71,9 +86,24 @@ public static class Uniquifier
     /// <param name="uniquifier">An optional number that will be appended to the identifier.</param>
     /// <returns>The shortened identifier.</returns>
     public static string Truncate(string identifier, int maxLength, int? uniquifier = null)
+        => Truncate(identifier, maxLength, null, uniquifier);
+
+    /// <summary>
+    ///     Ensures the given identifier is shorter than the given length by removing the extra characters from the end.
+    /// </summary>
+    /// <param name="identifier">The identifier to shorten.</param>
+    /// <param name="maxLength">The maximum length of the identifier.</param>
+    /// <param name="suffix">An optional suffix to add after the uniquifier.</param>
+    /// <param name="uniquifier">An optional number that will be appended to the identifier.</param>
+    /// <returns>The shortened identifier.</returns>
+    public static string Truncate(string identifier, int maxLength, string? suffix, int? uniquifier = null)
     {
-        var uniquifierLength = GetLength(uniquifier);
+        var uniquifierLength = GetLength(uniquifier) + (suffix?.Length ?? 0);
         var maxNameLength = maxLength - uniquifierLength;
+        if (maxNameLength <= 0)
+        {
+            throw new ArgumentException(nameof(maxLength));
+        }
 
         var builder = new StringBuilder();
         if (identifier.Length <= maxNameLength)
@@ -91,6 +121,8 @@ public static string Truncate(string identifier, int maxLength, int? uniquifier
             builder.Append(uniquifier.Value);
         }
 
+        builder.Append(suffix);
+
         return builder.ToString();
     }
 
diff --git a/src/EFCore/Metadata/Internal/IRuntimeModel.cs b/src/EFCore/Metadata/Internal/IRuntimeModel.cs
index 960e254aec..32a5c57049 100644
--- a/src/EFCore/Metadata/Internal/IRuntimeModel.cs
+++ b/src/EFCore/Metadata/Internal/IRuntimeModel.cs
@@ -42,37 +42,35 @@ public interface IRuntimeModel : IModel
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    IReadOnlyDictionary<MemberInfo, QualifiedName>? GetUnsafeAccessors()
+    IReadOnlyDictionary<MemberInfo, QualifiedName> GetUnsafeAccessors()
     {
-        var accessorsAnnotation = FindRuntimeAnnotation(CoreAnnotationNames.UnsafeAccessors);
-        if (accessorsAnnotation != null)
-        {
-            return accessorsAnnotation.Value as IReadOnlyDictionary<MemberInfo, QualifiedName>;
-        }
+        return GetOrAddRuntimeAnnotationValue(CoreAnnotationNames.UnsafeAccessors, m => GetAccessors(m!), this);
 
-        var accessors = new Dictionary<MemberInfo, QualifiedName>();
-        foreach (var entityType in GetEntityTypes())
+        static IReadOnlyDictionary<MemberInfo, QualifiedName> GetAccessors(IRuntimeModel model)
         {
-            AddPropertyAccessors(entityType, accessors);
-
-            foreach (var property in entityType.GetDeclaredServiceProperties())
+            var accessors = new Dictionary<MemberInfo, QualifiedName>();
+            foreach (var entityType in model.GetEntityTypes())
             {
-                AddAccessors(property, accessors);
-            }
+                AddPropertyAccessors(entityType, accessors);
 
-            foreach (var navigation in entityType.GetDeclaredNavigations())
-            {
-                AddAccessors(navigation, accessors);
-            }
+                foreach (var property in entityType.GetDeclaredServiceProperties())
+                {
+                    AddAccessors(property, accessors);
+                }
 
-            foreach (var navigation in entityType.GetDeclaredSkipNavigations())
-            {
-                AddAccessors(navigation, accessors);
+                foreach (var navigation in entityType.GetDeclaredNavigations())
+                {
+                    AddAccessors(navigation, accessors);
+                }
+
+                foreach (var navigation in entityType.GetDeclaredSkipNavigations())
+                {
+                    AddAccessors(navigation, accessors);
+                }
             }
-        }
 
-        SetRuntimeAnnotation(CoreAnnotationNames.UnsafeAccessors, accessors);
-        return accessors;
+            return accessors;
+        }
 
         static void AddPropertyAccessors(ITypeBase structuralType, Dictionary<MemberInfo, QualifiedName> accessors)
         {
diff --git a/src/dotnet-ef/Project.cs b/src/dotnet-ef/Project.cs
index 4b92336489..2d2fc218d6 100644
--- a/src/dotnet-ef/Project.cs
+++ b/src/dotnet-ef/Project.cs
@@ -153,7 +153,7 @@ bool FileMatches()
         };
     }
 
-    public void Build()
+    public void Build(IEnumerable<string>? additionalArgs)
     {
         var args = new List<string> { "build" };
 
@@ -184,6 +184,10 @@ public void Build()
         args.Add("/verbosity:quiet");
         args.Add("/nologo");
         args.Add("/p:PublishAot=false"); // Avoid NativeAOT warnings
+        if (additionalArgs != null)
+        {
+            args.AddRange(additionalArgs);
+        }
 
         var exitCode = Exe.Run("dotnet", args, handleOutput: Reporter.WriteVerbose);
         if (exitCode != 0)
diff --git a/src/dotnet-ef/Properties/Resources.Designer.cs b/src/dotnet-ef/Properties/Resources.Designer.cs
index 19262f5934..9166068036 100644
--- a/src/dotnet-ef/Properties/Resources.Designer.cs
+++ b/src/dotnet-ef/Properties/Resources.Designer.cs
@@ -289,6 +289,14 @@ public static string MigrationsScriptDescription
         public static string MigrationToDescription
             => GetString("MigrationToDescription");
 
+        /// <summary>
+        ///     Option '--{requiredOption}' must be specified if '--{conditionalOption}' is used.
+        /// </summary>
+        public static string MissingConditionalOption(object? requiredOption, object? conditionalOption)
+            => string.Format(
+                GetString("MissingConditionalOption", nameof(requiredOption), nameof(conditionalOption)),
+                requiredOption, conditionalOption);
+
         /// <summary>
         ///     More than one project was found in the current working directory. Use the --project option.
         /// </summary>
@@ -369,6 +377,12 @@ public static string NoProjectInDirectory(object? projectDir)
                 GetString("NoProjectInDirectory", nameof(projectDir)),
                 projectDir);
 
+        /// <summary>
+        ///     Don't generate a compiled model.
+        /// </summary>
+        public static string NoScaffoldDescription
+            => GetString("NoScaffoldDescription");
+
         /// <summary>
         ///     Don't generate SQL transaction statements.
         /// </summary>
@@ -387,6 +401,18 @@ public static string OutputDescription
         public static string OutputDirDescription
             => GetString("OutputDirDescription");
 
+        /// <summary>
+        ///     Generate precompiled queries.
+        /// </summary>
+        public static string PrecompileQueriesDescription
+            => GetString("PrecompileQueriesDescription");
+
+        /// <summary>
+        ///     Query precompilation is an experimental feature and should be used with caution.
+        /// </summary>
+        public static string PrecompileQueriesWarning
+            => GetString("PrecompileQueriesWarning");
+
         /// <summary>
         ///     Prefix output with level.
         /// </summary>
diff --git a/src/dotnet-ef/Properties/Resources.resx b/src/dotnet-ef/Properties/Resources.resx
index f932fb8d4e..7b9f580a4c 100644
--- a/src/dotnet-ef/Properties/Resources.resx
+++ b/src/dotnet-ef/Properties/Resources.resx
@@ -252,6 +252,9 @@
   <data name="MigrationToDescription" xml:space="preserve">
     <value>The target migration. Defaults to the last migration.</value>
   </data>
+  <data name="MissingConditionalOption" xml:space="preserve">
+    <value>Option '--{requiredOption}' must be specified if '--{conditionalOption}' is used.</value>
+  </data>
   <data name="MultipleProjects" xml:space="preserve">
     <value>More than one project was found in the current working directory. Use the --project option.</value>
   </data>
@@ -288,6 +291,9 @@
   <data name="NoProjectInDirectory" xml:space="preserve">
     <value>No project was found in directory '{projectDir}'.</value>
   </data>
+  <data name="NoScaffoldDescription" xml:space="preserve">
+    <value>Don't generate a compiled model.</value>
+  </data>
   <data name="NoTransactionsDescription" xml:space="preserve">
     <value>Don't generate SQL transaction statements.</value>
   </data>
@@ -297,6 +303,12 @@
   <data name="OutputDirDescription" xml:space="preserve">
     <value>The directory to put files in. Paths are relative to the project directory.</value>
   </data>
+  <data name="PrecompileQueriesDescription" xml:space="preserve">
+    <value>Generate precompiled queries.</value>
+  </data>
+  <data name="PrecompileQueriesWarning" xml:space="preserve">
+    <value>Query precompilation is an experimental feature and should be used with caution.</value>
+  </data>
   <data name="PrefixDescription" xml:space="preserve">
     <value>Prefix output with level.</value>
   </data>
diff --git a/src/dotnet-ef/RootCommand.cs b/src/dotnet-ef/RootCommand.cs
index 7a4de0f2e2..aa03475a11 100644
--- a/src/dotnet-ef/RootCommand.cs
+++ b/src/dotnet-ef/RootCommand.cs
@@ -1,6 +1,7 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using System.Diagnostics;
 using System.Reflection;
 using System.Runtime.Versioning;
 using System.Text.Json;
@@ -79,7 +80,9 @@ protected override int Execute(string[] _)
         if (!_noBuild!.HasValue())
         {
             Reporter.WriteInformation(Resources.BuildStarted);
-            startupProject.Build();
+            var skipOptimization = _args!.Count > 2
+                && _args[0] == "dbcontext" && _args[1] == "optimize" && !_args.Any(a => a == "--no-scaffold");
+            startupProject.Build(skipOptimization ? new[] { "/p:EFOptimizeContext=false" } : null);
             Reporter.WriteInformation(Resources.BuildSucceeded);
         }
 
diff --git a/src/ef/AppDomainOperationExecutor.cs b/src/ef/AppDomainOperationExecutor.cs
index b51bffa921..a918005b05 100644
--- a/src/ef/AppDomainOperationExecutor.cs
+++ b/src/ef/AppDomainOperationExecutor.cs
@@ -23,6 +23,7 @@ internal class AppDomainOperationExecutor : OperationExecutorBase
         public AppDomainOperationExecutor(
             string assembly,
             string? startupAssembly,
+            string? project,
             string? projectDir,
             string? dataDirectory,
             string? rootNamespace,
@@ -30,7 +31,7 @@ internal class AppDomainOperationExecutor : OperationExecutorBase
             bool nullable,
             string[] remainingArguments,
             IOperationReportHandler reportHandler)
-            : base(assembly, startupAssembly, projectDir, rootNamespace, language, nullable, remainingArguments, reportHandler)
+            : base(assembly, startupAssembly, project, projectDir, rootNamespace, language, nullable, remainingArguments, reportHandler)
         {
             var info = new AppDomainSetup { ApplicationBase = AppBasePath };
 
@@ -77,6 +78,7 @@ internal class AppDomainOperationExecutor : OperationExecutorBase
                     {
                         { "targetName", AssemblyFileName },
                         { "startupTargetName", StartupAssemblyFileName },
+                        { "project", Project },
                         { "projectDir", ProjectDirectory },
                         { "rootNamespace", RootNamespace },
                         { "language", Language },
diff --git a/src/ef/Commands/DbContextOptimizeCommand.Configure.cs b/src/ef/Commands/DbContextOptimizeCommand.Configure.cs
index a1ac859e3b..5cc1d77a61 100644
--- a/src/ef/Commands/DbContextOptimizeCommand.Configure.cs
+++ b/src/ef/Commands/DbContextOptimizeCommand.Configure.cs
@@ -11,6 +11,8 @@ internal partial class DbContextOptimizeCommand : ContextCommandBase
     private CommandOption? _outputDir;
     private CommandOption? _namespace;
     private CommandOption? _suffix;
+    private CommandOption? _noScaffold;
+    private CommandOption? _precompileQueries;
 
     public override void Configure(CommandLineApplication command)
     {
@@ -19,6 +21,8 @@ public override void Configure(CommandLineApplication command)
         _outputDir = command.Option("-o|--output-dir <PATH>", Resources.OutputDirDescription);
         _namespace = command.Option("-n|--namespace <NAMESPACE>", Resources.NamespaceDescription);
         _suffix = command.Option("--suffix <SUFFIX>", Resources.SuffixDescription);
+        _noScaffold = command.Option("--no-scaffold", Resources.NoScaffoldDescription);
+        _precompileQueries = command.Option("--precompile-queries", Resources.PrecompileQueriesDescription);
 
         base.Configure(command);
     }
diff --git a/src/ef/Commands/DbContextOptimizeCommand.cs b/src/ef/Commands/DbContextOptimizeCommand.cs
index c2dc6d6cdb..39144f5b78 100644
--- a/src/ef/Commands/DbContextOptimizeCommand.cs
+++ b/src/ef/Commands/DbContextOptimizeCommand.cs
@@ -9,6 +9,22 @@ namespace Microsoft.EntityFrameworkCore.Tools.Commands;
 // ReSharper disable once ArrangeTypeModifiers
 internal partial class DbContextOptimizeCommand
 {
+    protected override void Validate()
+    {
+        base.Validate();
+
+        if (_noScaffold!.HasValue()
+            && !_precompileQueries!.HasValue())
+        {
+            throw new CommandException(Resources.MissingConditionalOption(_precompileQueries.LongName, _noScaffold.LongName));
+        }
+
+        if (_precompileQueries!.HasValue())
+        {
+            Reporter.WriteWarning(Resources.PrecompileQueriesWarning);
+        }
+    }
+
     protected override int Execute(string[] args)
     {
         if (new SemanticVersionComparer().Compare(EFCoreVersion, "6.0.0") < 0)
@@ -21,7 +37,9 @@ protected override int Execute(string[] args)
             _outputDir!.Value(),
             _namespace!.Value(),
             Context!.Value(),
-            _suffix!.Value());
+            _suffix!.Value() ?? "",
+            !_noScaffold!.HasValue(),
+            _precompileQueries!.HasValue());
 
         ReportResults(result);
 
diff --git a/src/ef/Commands/MigrationsBundleCommand.cs b/src/ef/Commands/MigrationsBundleCommand.cs
index 5e8dd3b660..4b6271f279 100644
--- a/src/ef/Commands/MigrationsBundleCommand.cs
+++ b/src/ef/Commands/MigrationsBundleCommand.cs
@@ -1,9 +1,6 @@
 ï»¿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System;
-using System.Collections.Generic;
-using System.IO;
 using Microsoft.EntityFrameworkCore.Internal;
 using Microsoft.EntityFrameworkCore.Tools.Generators;
 using Microsoft.EntityFrameworkCore.Tools.Properties;
diff --git a/src/ef/Commands/ProjectCommandBase.cs b/src/ef/Commands/ProjectCommandBase.cs
index 14be3fb7eb..5c8ab7c978 100644
--- a/src/ef/Commands/ProjectCommandBase.cs
+++ b/src/ef/Commands/ProjectCommandBase.cs
@@ -89,6 +89,7 @@ protected IOperationExecutor CreateExecutor(string[] remainingArguments)
                     return new AppDomainOperationExecutor(
                         Assembly!.Value()!,
                         StartupAssembly!.Value(),
+                        Project!.Value(),
                         _projectDir!.Value(),
                         _dataDir!.Value(),
                         _rootNamespace!.Value(),
@@ -127,6 +128,7 @@ protected IOperationExecutor CreateExecutor(string[] remainingArguments)
                 return new ReflectionOperationExecutor(
                     Assembly!.Value()!,
                     StartupAssembly!.Value(),
+                    Project!.Value(),
                     _projectDir!.Value(),
                     _dataDir!.Value(),
                     _rootNamespace!.Value(),
diff --git a/src/ef/IOperationExecutor.cs b/src/ef/IOperationExecutor.cs
index 8a5bb9e60a..644a938ba7 100644
--- a/src/ef/IOperationExecutor.cs
+++ b/src/ef/IOperationExecutor.cs
@@ -14,7 +14,8 @@ internal interface IOperationExecutor : IDisposable
     IDictionary GetContextInfo(string? name);
     void UpdateDatabase(string? migration, string? connectionString, string? contextType);
     IEnumerable<IDictionary> GetContextTypes();
-    IEnumerable<string> OptimizeContext(string? outputDir, string? modelNamespace, string? contextType, string? suffix);
+    IEnumerable<string> OptimizeContext(
+        string? outputDir, string? modelNamespace, string? contextType, string? suffix, bool scaffoldModel, bool precompileQueries);
 
     IDictionary ScaffoldContext(
         string provider,
diff --git a/src/ef/OperationExecutorBase.cs b/src/ef/OperationExecutorBase.cs
index e25f397f35..53c910449e 100644
--- a/src/ef/OperationExecutorBase.cs
+++ b/src/ef/OperationExecutorBase.cs
@@ -19,6 +19,7 @@ internal abstract class OperationExecutorBase : IOperationExecutor
     protected string AssemblyFileName { get; set; }
     protected string StartupAssemblyFileName { get; set; }
     protected string ProjectDirectory { get; }
+    protected string Project { get; }
     protected string RootNamespace { get; }
     protected string? Language { get; }
     protected bool Nullable { get; }
@@ -27,6 +28,7 @@ internal abstract class OperationExecutorBase : IOperationExecutor
     protected OperationExecutorBase(
         string assembly,
         string? startupAssembly,
+        string? project,
         string? projectDir,
         string? rootNamespace,
         string? language,
@@ -43,6 +45,7 @@ internal abstract class OperationExecutorBase : IOperationExecutor
             Path.Combine(Directory.GetCurrentDirectory(), Path.GetDirectoryName(startupAssembly ?? assembly)!));
 
         RootNamespace = rootNamespace ?? AssemblyFileName;
+        Project = project ?? "";
         ProjectDirectory = projectDir ?? Directory.GetCurrentDirectory();
         Language = language;
         Nullable = nullable;
@@ -140,7 +143,8 @@ public void UpdateDatabase(string? migration, string? connectionString, string?
     public IEnumerable<IDictionary> GetContextTypes()
         => InvokeOperation<IEnumerable<IDictionary>>("GetContextTypes");
 
-    public IEnumerable<string> OptimizeContext(string? outputDir, string? modelNamespace, string? contextType, string? suffix)
+    public IEnumerable<string> OptimizeContext(
+        string? outputDir, string? modelNamespace, string? contextType, string? suffix, bool scaffoldModel, bool precompileQueries)
         => InvokeOperation<IEnumerable<string>>(
             "OptimizeContext",
             new Dictionary<string, object?>
@@ -148,7 +152,9 @@ public IEnumerable<string> OptimizeContext(string? outputDir, string? modelNames
                 ["outputDir"] = outputDir,
                 ["modelNamespace"] = modelNamespace,
                 ["contextType"] = contextType,
-                ["suffix"] = suffix
+                ["suffix"] = suffix,
+                ["scaffoldModel"] = scaffoldModel,
+                ["precompileQueries"] = precompileQueries
             });
 
     public IDictionary ScaffoldContext(
diff --git a/src/ef/Properties/Resources.Designer.cs b/src/ef/Properties/Resources.Designer.cs
index 8f233d9165..94c955124e 100644
--- a/src/ef/Properties/Resources.Designer.cs
+++ b/src/ef/Properties/Resources.Designer.cs
@@ -381,6 +381,14 @@ public static string MissingArgument(object? arg)
                 GetString("MissingArgument", nameof(arg)),
                 arg);
 
+        /// <summary>
+        ///     Option '--{requiredOption}' must be specified if '--{conditionalOption}' is used.
+        /// </summary>
+        public static string MissingConditionalOption(object? requiredOption, object? conditionalOption)
+            => string.Format(
+                GetString("MissingConditionalOption", nameof(requiredOption), nameof(conditionalOption)),
+                requiredOption, conditionalOption);
+
         /// <summary>
         ///     Missing required option '--{option}'.
         /// </summary>
@@ -425,6 +433,12 @@ public static string NoMigrations
         public static string NoPluralizeDescription
             => GetString("NoPluralizeDescription");
 
+        /// <summary>
+        ///     Don't generate a compiled model.
+        /// </summary>
+        public static string NoScaffoldDescription
+            => GetString("NoScaffoldDescription");
+
         /// <summary>
         ///     Don't generate SQL transaction statements.
         /// </summary>
@@ -469,6 +483,18 @@ public static string Pending
         public static string PendingUnknown
             => GetString("PendingUnknown");
 
+        /// <summary>
+        ///     Generate precompiled queries.
+        /// </summary>
+        public static string PrecompileQueriesDescription
+            => GetString("PrecompileQueriesDescription");
+
+        /// <summary>
+        ///     Query precompilation is an experimental feature and should be used with caution.
+        /// </summary>
+        public static string PrecompileQueriesWarning
+            => GetString("PrecompileQueriesWarning");
+
         /// <summary>
         ///     Prefix output with level.
         /// </summary>
diff --git a/src/ef/Properties/Resources.resx b/src/ef/Properties/Resources.resx
index 6f5f760c8a..f0b1798190 100644
--- a/src/ef/Properties/Resources.resx
+++ b/src/ef/Properties/Resources.resx
@@ -288,6 +288,9 @@
   <data name="MissingArgument" xml:space="preserve">
     <value>Missing required argument '{arg}'.</value>
   </data>
+  <data name="MissingConditionalOption" xml:space="preserve">
+    <value>Option '--{requiredOption}' must be specified if '--{conditionalOption}' is used.</value>
+  </data>
   <data name="MissingOption" xml:space="preserve">
     <value>Missing required option '--{option}'.</value>
   </data>
@@ -309,6 +312,9 @@
   <data name="NoPluralizeDescription" xml:space="preserve">
     <value>Don't use the pluralizer.</value>
   </data>
+  <data name="NoScaffoldDescription" xml:space="preserve">
+    <value>Don't generate a compiled model.</value>
+  </data>
   <data name="NoTransactionsDescription" xml:space="preserve">
     <value>Don't generate SQL transaction statements.</value>
   </data>
@@ -330,6 +336,12 @@
   <data name="PendingUnknown" xml:space="preserve">
     <value>Pending status not shown. Unable to determine which migrations have been applied. This can happen when your project uses a version of Entity Framework Core lower than 5.0.0 or when an error occurs while accessing the database.</value>
   </data>
+  <data name="PrecompileQueriesDescription" xml:space="preserve">
+    <value>Generate precompiled queries.</value>
+  </data>
+  <data name="PrecompileQueriesWarning" xml:space="preserve">
+    <value>Query precompilation is an experimental feature and should be used with caution.</value>
+  </data>
   <data name="PrefixDescription" xml:space="preserve">
     <value>Prefix output with level.</value>
   </data>
diff --git a/src/ef/ReflectionOperationExecutor.cs b/src/ef/ReflectionOperationExecutor.cs
index 9e3d8f05b6..a8cd7306bc 100644
--- a/src/ef/ReflectionOperationExecutor.cs
+++ b/src/ef/ReflectionOperationExecutor.cs
@@ -21,6 +21,7 @@ internal class ReflectionOperationExecutor : OperationExecutorBase
     public ReflectionOperationExecutor(
         string assembly,
         string? startupAssembly,
+        string? project,
         string? projectDir,
         string? dataDirectory,
         string? rootNamespace,
@@ -28,7 +29,7 @@ internal class ReflectionOperationExecutor : OperationExecutorBase
         bool nullable,
         string[] remainingArguments,
         IOperationReportHandler reportHandler)
-        : base(assembly, startupAssembly, projectDir, rootNamespace, language, nullable, remainingArguments, reportHandler)
+        : base(assembly, startupAssembly, project, projectDir, rootNamespace, language, nullable, remainingArguments, reportHandler)
     {
         var reporter = new OperationReporter(reportHandler);
         var configurationFile = (startupAssembly ?? assembly) + ".config";
@@ -63,6 +64,7 @@ internal class ReflectionOperationExecutor : OperationExecutorBase
             {
                 { "targetName", AssemblyFileName },
                 { "startupTargetName", StartupAssemblyFileName },
+                { "project", Project },
                 { "projectDir", ProjectDirectory },
                 { "rootNamespace", RootNamespace },
                 { "language", Language },
diff --git a/test/EFCore.Design.Tests/Design/Internal/DbContextOperationsTest.cs b/test/EFCore.Design.Tests/Design/Internal/DbContextOperationsTest.cs
index 6ecc6b10a8..5a086d6127 100644
--- a/test/EFCore.Design.Tests/Design/Internal/DbContextOperationsTest.cs
+++ b/test/EFCore.Design.Tests/Design/Internal/DbContextOperationsTest.cs
@@ -30,6 +30,7 @@ public void Can_pass_null_args()
             new TestOperationReporter(),
             assembly,
             assembly,
+            project: "",
             projectDir: "",
             rootNamespace: null,
             language: "C#",
@@ -46,6 +47,7 @@ public void CreateContext_uses_exact_factory_method()
             new TestOperationReporter(),
             assembly,
             assembly,
+            project: "",
             projectDir: "",
             rootNamespace: null,
             language: "C#",
@@ -60,6 +62,28 @@ public void CreateContext_uses_exact_factory_method()
         Assert.Equal(nameof(DerivedContext), derivedContext.FactoryUsed);
     }
 
+    [ConditionalFact]
+    public void CreateAllContexts_creates_all_contexts()
+    {
+        var assembly = MockAssembly.Create(typeof(BaseContext), typeof(DerivedContext), typeof(HierarchyContextFactory));
+        var operations = new TestDbContextOperations(
+            new TestOperationReporter(),
+            assembly,
+            assembly,
+            project: "",
+            projectDir: "",
+            rootNamespace: null,
+            language: "C#",
+            nullable: false,
+            args: [],
+            new TestAppServiceProviderFactory(assembly));
+
+        var contexts = operations.CreateAllContexts().ToList();
+        Assert.Collection(contexts,
+            c => Assert.Equal(nameof(BaseContext), Assert.IsType<BaseContext>(c).FactoryUsed),
+            c => Assert.Equal(nameof(DerivedContext), Assert.IsType<DerivedContext>(c).FactoryUsed));
+    }
+
     [ConditionalFact]
     public void GetContextInfo_returns_correct_info()
     {
@@ -164,6 +188,7 @@ private static TestDbContextOperations CreateOperations(Type testProgramType)
             new TestOperationReporter(),
             assembly,
             assembly,
+            project: "",
             projectDir: "",
             rootNamespace: null,
             language: "C#",
@@ -176,8 +201,7 @@ private static TestWebHost CreateWebHost(Func<DbContextOptionsBuilder, DbContext
         => new(
             new ServiceCollection()
                 .AddDbContext<TestContext>(
-                    b =>
-                        configureProvider(b.EnableServiceProviderCaching(false)))
+                    b => configureProvider(b.EnableServiceProviderCaching(false)))
                 .BuildServiceProvider(validateScopes: true));
 
     private class TestContext : DbContext
diff --git a/test/EFCore.Design.Tests/Scaffolding/Internal/ReverseEngineerScaffolderTest.cs b/test/EFCore.Design.Tests/Scaffolding/Internal/ReverseEngineerScaffolderTest.cs
index 98a1c799f3..b68565921b 100644
--- a/test/EFCore.Design.Tests/Scaffolding/Internal/ReverseEngineerScaffolderTest.cs
+++ b/test/EFCore.Design.Tests/Scaffolding/Internal/ReverseEngineerScaffolderTest.cs
@@ -19,8 +19,8 @@ public void Save_works()
         var scaffolder = CreateScaffolder();
         var scaffoldedModel = new ScaffoldedModel
         {
-            ContextFile = new ScaffoldedFile { Path = Path.Combine("..", "Data", "TestContext.cs"), Code = "// TestContext" },
-            AdditionalFiles = { new ScaffoldedFile { Path = "TestEntity.cs", Code = "// TestEntity" } }
+            ContextFile = new ScaffoldedFile(Path.Combine("..", "Data", "TestContext.cs"), "// TestContext"),
+            AdditionalFiles = { new ScaffoldedFile("TestEntity.cs", "// TestEntity") }
         };
 
         var result = scaffolder.Save(
@@ -51,8 +51,8 @@ public void Save_throws_when_existing_files()
         var scaffolder = CreateScaffolder();
         var scaffoldedModel = new ScaffoldedModel
         {
-            ContextFile = new ScaffoldedFile { Path = "TestContext.cs", Code = "// TestContext" },
-            AdditionalFiles = { new ScaffoldedFile { Path = "TestEntity.cs", Code = "// TestEntity" } }
+            ContextFile = new ScaffoldedFile("TestContext.cs", "// TestContext"),
+            AdditionalFiles = { new ScaffoldedFile("TestEntity.cs", "// TestEntity") }
         };
 
         var ex = Assert.Throws<OperationException>(
@@ -73,7 +73,7 @@ public void Save_works_when_overwriteFiles()
         File.WriteAllText(path, "// Old");
 
         var scaffolder = CreateScaffolder();
-        var scaffoldedModel = new ScaffoldedModel { ContextFile = new ScaffoldedFile { Path = "Test.cs", Code = "// Test" } };
+        var scaffoldedModel = new ScaffoldedModel { ContextFile = new ScaffoldedFile("Test.cs", "// Test") };
 
         var result = scaffolder.Save(scaffoldedModel, directory.Path, overwriteFiles: true);
 
@@ -99,8 +99,8 @@ public void Save_throws_when_readonly_files()
             var scaffolder = CreateScaffolder();
             var scaffoldedModel = new ScaffoldedModel
             {
-                ContextFile = new ScaffoldedFile { Path = "TestContext.cs", Code = "// TestContext" },
-                AdditionalFiles = { new ScaffoldedFile { Path = "TestEntity.cs", Code = "// TestEntity" } }
+                ContextFile = new ScaffoldedFile("TestContext.cs", "// TestContext"),
+                AdditionalFiles = { new ScaffoldedFile("TestEntity.cs", "// TestEntity") }
             };
 
             var ex = Assert.Throws<OperationException>(
diff --git a/test/EFCore.Design.Tests/TestUtilities/TestDbContextOperations.cs b/test/EFCore.Design.Tests/TestUtilities/TestDbContextOperations.cs
index 551bd8938c..6c089e0e62 100644
--- a/test/EFCore.Design.Tests/TestUtilities/TestDbContextOperations.cs
+++ b/test/EFCore.Design.Tests/TestUtilities/TestDbContextOperations.cs
@@ -9,9 +9,10 @@ public class TestDbContextOperations(
     IOperationReporter reporter,
     Assembly assembly,
     Assembly startupAssembly,
+    string project,
     string projectDir,
     string rootNamespace,
     string language,
     bool nullable,
     string[] args,
-    AppServiceProviderFactory appServicesFactory) : DbContextOperations(reporter, assembly, startupAssembly, projectDir, rootNamespace, language, nullable, args, appServicesFactory);
+    AppServiceProviderFactory appServicesFactory) : DbContextOperations(reporter, assembly, startupAssembly, project, projectDir, rootNamespace, language, nullable, args, appServicesFactory);
diff --git a/test/EFCore.Relational.Specification.Tests/Scaffolding/CompiledModelRelationalTestBase.cs b/test/EFCore.Relational.Specification.Tests/Scaffolding/CompiledModelRelationalTestBase.cs
index 182f3f9e90..ab7962f62b 100644
--- a/test/EFCore.Relational.Specification.Tests/Scaffolding/CompiledModelRelationalTestBase.cs
+++ b/test/EFCore.Relational.Specification.Tests/Scaffolding/CompiledModelRelationalTestBase.cs
@@ -1226,10 +1226,8 @@ public virtual Task Dynamic_schema()
             },
             additionalSourceFiles:
             [
-                new()
-                {
-                    Path = "DbContextModelCustomizer.cs",
-                    Code = """
+                new("DbContextModelCustomizer.cs",
+                    """
 using Microsoft.EntityFrameworkCore.Metadata;
 
 namespace TestNamespace;
@@ -1302,8 +1300,7 @@ private static void Customize(RuntimeTypeBase entityType)
         }
     }
 }
-"""
-                }
+""")
             ]);
 
     public class SpatialTypes : AbstractBase;
diff --git a/test/EFCore.Relational.Specification.Tests/TestUtilities/PrecompiledQueryTestHelpers.cs b/test/EFCore.Relational.Specification.Tests/TestUtilities/PrecompiledQueryTestHelpers.cs
index 928c97253a..e6a7cd3e0e 100644
--- a/test/EFCore.Relational.Specification.Tests/TestUtilities/PrecompiledQueryTestHelpers.cs
+++ b/test/EFCore.Relational.Specification.Tests/TestUtilities/PrecompiledQueryTestHelpers.cs
@@ -10,6 +10,7 @@
 using Microsoft.CodeAnalysis;
 using Microsoft.CodeAnalysis.CSharp;
 using Microsoft.CodeAnalysis.Editing;
+using Microsoft.EntityFrameworkCore.Design.Internal;
 using Microsoft.EntityFrameworkCore.Query.Internal;
 using Microsoft.Extensions.Caching.Memory;
 
@@ -95,7 +96,7 @@ public static async Task Test(DbContextOptions dbContextOptions)
             _metadataReferences,
             new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary, nullableContextOptions: NullableContextOptions.Enable));
 
-        IReadOnlyList<PrecompiledQueryCodeGenerator.GeneratedInterceptorFile>? generatedFiles = null;
+        IReadOnlyList<ScaffoldedFile>? generatedFiles = null;
 
         try
         {
@@ -114,7 +115,7 @@ public static async Task Test(DbContextOptions dbContextOptions)
                 // Perform precompilation
                 var precompilationErrors = new List<PrecompiledQueryCodeGenerator.QueryPrecompilationError>();
                 generatedFiles = precompiledQueryCodeGenerator.GeneratePrecompiledQueries(
-                    compilation, syntaxGenerator, dbContext, precompilationErrors, additionalAssembly: assembly);
+                    compilation, syntaxGenerator, dbContext, memberAccessReplacements: new Dictionary<MemberInfo, QualifiedName>(), precompilationErrors, new HashSet<string>(), additionalAssembly: assembly);
 
                 if (errorAsserter is null)
                 {
diff --git a/test/EFCore.Specification.Tests/Scaffolding/CompiledModelTestBase.cs b/test/EFCore.Specification.Tests/Scaffolding/CompiledModelTestBase.cs
index 4d6c01e4c9..9aa7a729f1 100644
--- a/test/EFCore.Specification.Tests/Scaffolding/CompiledModelTestBase.cs
+++ b/test/EFCore.Specification.Tests/Scaffolding/CompiledModelTestBase.cs
@@ -47,10 +47,8 @@ public virtual Task SimpleModel()
             options: new CompiledModelCodeGenerationOptions { UseNullableReferenceTypes = true },
             additionalSourceFiles:
             [
-                new()
-                {
-                    Path = "DbContextModelStub.cs",
-                    Code = """
+                new("DbContextModelStub.cs",
+                    """
 using Microsoft.EntityFrameworkCore.Metadata;
 using static TestNamespace.DbContextModel.Dummy;
 
@@ -67,8 +65,7 @@ public static class Dummy
         }
     }
 }
-"""
-                }
+""")
             ],
             assertAssembly: assembly =>
             {
@@ -586,7 +583,7 @@ public virtual Task ComplexTypes()
             AssertComplexTypes,
             c =>
             {
-                // #33828
+                // Blocked by https://github.com/dotnet/runtime/issues/102792
                 //c.Set<PrincipalDerived<DependentBase<byte?>>>().Add(
                 //    new PrincipalDerived<DependentBase<byte?>>
                 //    {
