diff --git a/src/EFCore.Relational/Query/SqlExpressions/SelectExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/SelectExpression.cs
index b466aba6cb..6866dd176e 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/SelectExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/SelectExpression.cs
@@ -4224,6 +4224,16 @@ List<T> VisitList<T>(List<T> list, bool inPlace, out bool changed)
             return this;
         }
 
+        if (predicate is SqlConstantExpression { Value: true })
+        {
+            predicate = null;
+        }
+
+        if (having is SqlConstantExpression { Value: true })
+        {
+            having = null;
+        }
+
         var projectionMapping = new Dictionary<ProjectionMember, Expression>();
         foreach (var (projectionMember, expression) in _projectionMapping)
         {
diff --git a/src/EFCore.Relational/Query/SqlNullabilityProcessor.cs b/src/EFCore.Relational/Query/SqlNullabilityProcessor.cs
index 407826342f..be395e188a 100644
--- a/src/EFCore.Relational/Query/SqlNullabilityProcessor.cs
+++ b/src/EFCore.Relational/Query/SqlNullabilityProcessor.cs
@@ -17,7 +17,7 @@ namespace Microsoft.EntityFrameworkCore.Query;
 ///         not used in application code.
 ///     </para>
 /// </summary>
-public class SqlNullabilityProcessor
+public class SqlNullabilityProcessor : ExpressionVisitor
 {
     private readonly List<ColumnExpression> _nonNullableColumns;
     private readonly List<ColumnExpression> _nullValueColumns;
@@ -80,49 +80,13 @@ public class SqlNullabilityProcessor
         _nullValueColumns.Clear();
         ParameterValues = parameterValues;
 
-        var result = queryExpression switch
-        {
-            SelectExpression selectExpression => (Expression)Visit(selectExpression),
-            DeleteExpression deleteExpression => deleteExpression.Update(deleteExpression.Table, Visit(deleteExpression.SelectExpression)),
-            UpdateExpression updateExpression => VisitUpdate(updateExpression),
-            _ => throw new InvalidOperationException(),
-        };
+        var result = Visit(queryExpression);
 
         canCache = _canCache;
 
         return result;
     }
 
-    private UpdateExpression VisitUpdate(UpdateExpression updateExpression)
-    {
-        var selectExpression = Visit(updateExpression.SelectExpression);
-        List<ColumnValueSetter>? columnValueSetters = null;
-        for (var (i, n) = (0, updateExpression.ColumnValueSetters.Count); i < n; i++)
-        {
-            var columnValueSetter = updateExpression.ColumnValueSetters[i];
-            var newValue = Visit(columnValueSetter.Value, out _);
-            if (columnValueSetters != null)
-            {
-                columnValueSetters.Add(new ColumnValueSetter(columnValueSetter.Column, newValue));
-            }
-            else if (!ReferenceEquals(newValue, columnValueSetter.Value))
-            {
-                columnValueSetters = new List<ColumnValueSetter>(n);
-                for (var j = 0; j < i; j++)
-                {
-                    columnValueSetters.Add(updateExpression.ColumnValueSetters[j]);
-                }
-
-                columnValueSetters.Add(new ColumnValueSetter(columnValueSetter.Column, newValue));
-            }
-        }
-
-        return selectExpression != updateExpression.SelectExpression
-            || columnValueSetters != null
-                ? updateExpression.Update(selectExpression, columnValueSetters ?? updateExpression.ColumnValueSetters)
-                : updateExpression;
-    }
-
     /// <summary>
     ///     Marks the select expression being processed as cannot be cached.
     /// </summary>
@@ -136,35 +100,20 @@ protected virtual void DoNotCache()
     protected virtual void AddNonNullableColumn(ColumnExpression columnExpression)
         => _nonNullableColumns.Add(columnExpression);
 
-    /// <summary>
-    ///     Visits a <see cref="TableExpressionBase" />.
-    /// </summary>
-    /// <param name="tableExpressionBase">A table expression base to visit.</param>
-    /// <returns>An optimized table expression base.</returns>
-    protected virtual TableExpressionBase Visit(TableExpressionBase tableExpressionBase)
+    /// <inheritdoc />
+    protected override Expression VisitExtension(Expression node)
     {
-        switch (tableExpressionBase)
+        switch (node)
         {
-            case CrossApplyExpression crossApplyExpression:
-                return crossApplyExpression.Update(Visit(crossApplyExpression.Table));
-
-            case CrossJoinExpression crossJoinExpression:
-                return crossJoinExpression.Update(Visit(crossJoinExpression.Table));
+            case SqlExpression sqlExpression:
+                return Visit(sqlExpression, allowOptimizedExpansion: false, out _);
 
-            case ExceptExpression exceptExpression:
-            {
-                var source1 = Visit(exceptExpression.Source1);
-                var source2 = Visit(exceptExpression.Source2);
-
-                return exceptExpression.Update(source1, source2);
-            }
-
-            case FromSqlExpression fromSqlExpression:
-                return fromSqlExpression;
+            case SelectExpression select:
+                return Visit(select);
 
             case InnerJoinExpression innerJoinExpression:
             {
-                var newTable = Visit(innerJoinExpression.Table);
+                var newTable = VisitAndConvert(innerJoinExpression.Table, nameof(VisitExtension));
                 var newJoinPredicate = ProcessJoinPredicate(innerJoinExpression.JoinPredicate);
 
                 return IsTrue(newJoinPredicate)
@@ -172,234 +121,92 @@ protected virtual TableExpressionBase Visit(TableExpressionBase tableExpressionB
                     : innerJoinExpression.Update(newTable, newJoinPredicate);
             }
 
-            case IntersectExpression intersectExpression:
-            {
-                var source1 = Visit(intersectExpression.Source1);
-                var source2 = Visit(intersectExpression.Source2);
-
-                return intersectExpression.Update(source1, source2);
-            }
-
             case LeftJoinExpression leftJoinExpression:
             {
-                var newTable = Visit(leftJoinExpression.Table);
+                var newTable = VisitAndConvert(leftJoinExpression.Table, nameof(VisitExtension));
                 var newJoinPredicate = ProcessJoinPredicate(leftJoinExpression.JoinPredicate);
 
                 return leftJoinExpression.Update(newTable, newJoinPredicate);
             }
 
-            case OuterApplyExpression outerApplyExpression:
-                return outerApplyExpression.Update(Visit(outerApplyExpression.Table));
-
-            case ValuesExpression valuesExpression:
+            case ValuesExpression { ValuesParameter: SqlParameterExpression valuesParameter } valuesExpression:
             {
-                switch (valuesExpression)
-                {
-                    case { RowValues: not null }:
-                        RowValueExpression[]? newRowValues = null;
-                        for (var i = 0; i < valuesExpression.RowValues.Count; i++)
-                        {
-                            var rowValue = valuesExpression.RowValues[i];
-                            var newRowValue = (RowValueExpression)VisitRowValue(rowValue, allowOptimizedExpansion: false, out _);
-
-                            if (newRowValue != rowValue && newRowValues is null)
-                            {
-                                newRowValues = new RowValueExpression[valuesExpression.RowValues.Count];
-                                for (var j = 0; j < i; j++)
-                                {
-                                    newRowValues[j] = valuesExpression.RowValues[j];
-                                }
-                            }
-
-                            if (newRowValues is not null)
-                            {
-                                newRowValues[i] = newRowValue;
-                            }
-                        }
-
-                        return newRowValues is not null
-                            ? valuesExpression.Update(newRowValues)
-                            : valuesExpression;
-
-                    case { ValuesParameter: SqlParameterExpression valuesParameter }:
-                        DoNotCache();
-                        Check.DebugAssert(valuesParameter.TypeMapping is not null, "valuesParameter.TypeMapping is not null");
-                        Check.DebugAssert(
-                            valuesParameter.TypeMapping.ElementTypeMapping is not null,
-                            "valuesParameter.TypeMapping.ElementTypeMapping is not null");
-                        var typeMapping = (RelationalTypeMapping)valuesParameter.TypeMapping.ElementTypeMapping;
-                        var values = (IEnumerable?)ParameterValues[valuesParameter.Name] ?? Array.Empty<object>();
-
-                        var processedValues = new List<RowValueExpression>();
-                        foreach (var value in values)
-                        {
-                            processedValues.Add(
-                                new RowValueExpression(
-                                [
-                                    _sqlExpressionFactory.Constant(value, value?.GetType() ?? typeof(object), typeMapping)
-                                ]));
-                        }
-
-                        return processedValues is not []
-                            ? valuesExpression.Update(processedValues)
-                            : valuesExpression;
-
-                    default:
-                        throw new UnreachableException();
-                }
-            }
-
-            case SelectExpression selectExpression:
-                return Visit(selectExpression);
+                DoNotCache();
+                Check.DebugAssert(valuesParameter.TypeMapping is not null, "valuesParameter.TypeMapping is not null");
+                Check.DebugAssert(
+                    valuesParameter.TypeMapping.ElementTypeMapping is not null,
+                    "valuesParameter.TypeMapping.ElementTypeMapping is not null");
+                var typeMapping = (RelationalTypeMapping)valuesParameter.TypeMapping.ElementTypeMapping;
+                var values = (IEnumerable?)ParameterValues[valuesParameter.Name] ?? Array.Empty<object>();
 
-            case TableValuedFunctionExpression tableValuedFunctionExpression:
-            {
-                var arguments = new List<SqlExpression>();
-                foreach (var argument in tableValuedFunctionExpression.Arguments)
+                var processedValues = new List<RowValueExpression>();
+                foreach (var value in values)
                 {
-                    arguments.Add(Visit(argument, out _));
+                    processedValues.Add(
+                        new RowValueExpression(
+                        [
+                            _sqlExpressionFactory.Constant(value, value?.GetType() ?? typeof(object), typeMapping)
+                        ]));
                 }
 
-                return tableValuedFunctionExpression.Update(arguments);
+                return processedValues is not []
+                    ? valuesExpression.Update(processedValues)
+                    : valuesExpression;
             }
 
-            case TableExpression tableExpression:
-                return tableExpression;
+            default:
+                return base.VisitExtension(node);
+        }
 
-            case UnionExpression unionExpression:
+        SqlExpression ProcessJoinPredicate(SqlExpression predicate)
+        {
+            switch (predicate)
             {
-                var source1 = Visit(unionExpression.Source1);
-                var source2 = Visit(unionExpression.Source2);
+                case SqlBinaryExpression { OperatorType: ExpressionType.Equal } binary:
+                    var left = Visit(binary.Left, allowOptimizedExpansion: true, out var leftNullable);
+                    var right = Visit(binary.Right, allowOptimizedExpansion: true, out var rightNullable);
+
+                    var result = OptimizeComparison(
+                        binary.Update(left, right),
+                        left,
+                        right,
+                        leftNullable,
+                        rightNullable,
+                        out _);
 
-                return unionExpression.Update(source1, source2);
-            }
+                    return result;
 
-            default:
-                throw new InvalidOperationException(
-                    RelationalStrings.UnhandledExpressionInVisitor(
-                        tableExpressionBase, tableExpressionBase.GetType(), nameof(SqlNullabilityProcessor)));
+                case SqlBinaryExpression { OperatorType:
+                    ExpressionType.AndAlso
+                    or ExpressionType.NotEqual
+                    or ExpressionType.GreaterThan
+                    or ExpressionType.GreaterThanOrEqual
+                    or ExpressionType.LessThan
+                    or ExpressionType.LessThanOrEqual } binary:
+                    return Visit(binary, allowOptimizedExpansion: true, out _);
+
+                default:
+                    throw new InvalidOperationException(
+                        RelationalStrings.UnhandledExpressionInVisitor(predicate, predicate.GetType(), nameof(SqlNullabilityProcessor)));
+            }
         }
     }
 
-    /// <summary>
-    ///     Visits a <see cref="SelectExpression" />.
-    /// </summary>
-    /// <param name="selectExpression">A select expression to visit.</param>
-    /// <returns>An optimized select expression.</returns>
-    protected virtual SelectExpression Visit(SelectExpression selectExpression)
-        => Visit(selectExpression, visitProjection: true);
-
     /// <summary>
     ///     Visits a <see cref="SelectExpression" />.
     /// </summary>
     /// <param name="selectExpression">A select expression to visit.</param>
     /// <param name="visitProjection">Allows skipping visiting the projection, for when it will be visited outside.</param>
     /// <returns>An optimized select expression.</returns>
-    protected virtual SelectExpression Visit(SelectExpression selectExpression, bool visitProjection)
+    protected virtual SelectExpression Visit(SelectExpression selectExpression, bool visitProjection = true)
     {
-        var projections = (List<ProjectionExpression>)selectExpression.Projection;
-        if (visitProjection)
-        {
-            for (var i = 0; i < selectExpression.Projection.Count; i++)
-            {
-                var item = selectExpression.Projection[i];
-                var projection = item.Update(Visit(item.Expression, out _));
-                if (projection != item
-                    && projections == selectExpression.Projection)
-                {
-                    projections = [];
-                    for (var j = 0; j < i; j++)
-                    {
-                        projections.Add(selectExpression.Projection[j]);
-                    }
-                }
-
-                if (projections != selectExpression.Projection)
-                {
-                    projections.Add(projection);
-                }
-            }
-        }
-
-        var tables = (List<TableExpressionBase>)selectExpression.Tables;
-        for (var i = 0; i < selectExpression.Tables.Count; i++)
-        {
-            var item = selectExpression.Tables[i];
-            var table = Visit(item);
-            if (table != item
-                && tables == selectExpression.Tables)
-            {
-                tables = [];
-                for (var j = 0; j < i; j++)
-                {
-                    tables.Add(selectExpression.Tables[j]);
-                }
-            }
-
-            if (tables != selectExpression.Tables)
-            {
-                tables.Add(table);
-            }
-        }
-
+        var tables = this.VisitAndConvert(selectExpression.Tables);
         var predicate = Visit(selectExpression.Predicate, allowOptimizedExpansion: true, out _);
-
-        if (IsTrue(predicate))
-        {
-            predicate = null;
-        }
-
-        var groupBy = (List<SqlExpression>)selectExpression.GroupBy;
-        for (var i = 0; i < selectExpression.GroupBy.Count; i++)
-        {
-            var item = selectExpression.GroupBy[i];
-            var groupingKey = Visit(item, out _);
-            if (groupingKey != item
-                && groupBy == selectExpression.GroupBy)
-            {
-                groupBy = [];
-                for (var j = 0; j < i; j++)
-                {
-                    groupBy.Add(selectExpression.GroupBy[j]);
-                }
-            }
-
-            if (groupBy != selectExpression.GroupBy)
-            {
-                groupBy.Add(groupingKey);
-            }
-        }
-
+        var groupBy = this.VisitAndConvert(selectExpression.GroupBy);
         var having = Visit(selectExpression.Having, allowOptimizedExpansion: true, out _);
-
-        if (IsTrue(having))
-        {
-            having = null;
-        }
-
-        var orderings = (List<OrderingExpression>)selectExpression.Orderings;
-        for (var i = 0; i < selectExpression.Orderings.Count; i++)
-        {
-            var item = selectExpression.Orderings[i];
-            var ordering = item.Update(Visit(item.Expression, out _));
-            if (ordering != item
-                && orderings == selectExpression.Orderings)
-            {
-                orderings = [];
-                for (var j = 0; j < i; j++)
-                {
-                    orderings.Add(selectExpression.Orderings[j]);
-                }
-            }
-
-            if (orderings != selectExpression.Orderings)
-            {
-                orderings.Add(ordering);
-            }
-        }
-
+        var projections = visitProjection ? this.VisitAndConvert(selectExpression.Projection) : selectExpression.Projection;
+        var orderings = this.VisitAndConvert(selectExpression.Orderings);
         var offset = Visit(selectExpression.Offset, out _);
-
         var limit = Visit(selectExpression.Limit, out _);
 
         return selectExpression.Update(tables, predicate, groupBy, having, projections, orderings, offset, limit);
@@ -1156,33 +963,13 @@ SqlExpression GenerateNotNullCheck(SqlExpression operand)
         bool allowOptimizedExpansion,
         out bool nullable)
     {
-        SqlExpression[]? newValues = null;
-
-        for (var i = 0; i < rowValueExpression.Values.Count; i++)
-        {
-            var value = rowValueExpression.Values[i];
-
-            // Note that we disallow optimized expansion, since the null vs. false distinction does matter inside the row's values
-            var newValue = Visit(value, allowOptimizedExpansion: false, out _);
-            if (newValue != value && newValues is null)
-            {
-                newValues = new SqlExpression[rowValueExpression.Values.Count];
-                for (var j = 0; j < i; j++)
-                {
-                    newValues[j] = rowValueExpression.Values[j];
-                }
-            }
-
-            if (newValues is not null)
-            {
-                newValues[i] = newValue;
-            }
-        }
+        // Note that we disallow optimized expansion, since the null vs. false distinction does matter inside the row's values
+        var newValues = this.VisitAndConvert(rowValueExpression.Values);
 
         // The row value expression itself can never be null
         nullable = false;
 
-        return rowValueExpression.Update(newValues ?? rowValueExpression.Values);
+        return rowValueExpression.Update(newValues);
     }
 
     /// <summary>
@@ -1663,41 +1450,6 @@ private void RestoreNullValueColumnsList(int counter)
         }
     }
 
-    private SqlExpression ProcessJoinPredicate(SqlExpression predicate)
-    {
-        if (predicate is SqlBinaryExpression sqlBinaryExpression)
-        {
-            if (sqlBinaryExpression.OperatorType == ExpressionType.Equal)
-            {
-                var left = Visit(sqlBinaryExpression.Left, allowOptimizedExpansion: true, out var leftNullable);
-                var right = Visit(sqlBinaryExpression.Right, allowOptimizedExpansion: true, out var rightNullable);
-
-                var result = OptimizeComparison(
-                    sqlBinaryExpression.Update(left, right),
-                    left,
-                    right,
-                    leftNullable,
-                    rightNullable,
-                    out _);
-
-                return result;
-            }
-
-            if (sqlBinaryExpression.OperatorType is ExpressionType.AndAlso
-                or ExpressionType.NotEqual
-                or ExpressionType.GreaterThan
-                or ExpressionType.GreaterThanOrEqual
-                or ExpressionType.LessThan
-                or ExpressionType.LessThanOrEqual)
-            {
-                return Visit(sqlBinaryExpression, allowOptimizedExpansion: true, out _);
-            }
-        }
-
-        throw new InvalidOperationException(
-            RelationalStrings.UnhandledExpressionInVisitor(predicate, predicate.GetType(), nameof(SqlNullabilityProcessor)));
-    }
-
     private SqlExpression OptimizeComparison(
         SqlBinaryExpression sqlBinaryExpression,
         SqlExpression left,
diff --git a/test/EFCore.SqlServer.FunctionalTests/Query/PrimitiveCollectionsQuerySqlServer160Test.cs b/test/EFCore.SqlServer.FunctionalTests/Query/PrimitiveCollectionsQuerySqlServer160Test.cs
index a42b4ac42f..c47c00cf86 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Query/PrimitiveCollectionsQuerySqlServer160Test.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Query/PrimitiveCollectionsQuerySqlServer160Test.cs
@@ -782,7 +782,7 @@ public override async Task Parameter_collection_null_Contains(bool async)
 FROM [PrimitiveCollectionsEntity] AS [p]
 WHERE [p].[Int] IN (
     SELECT [i].[value]
-    FROM OPENJSON(NULL) AS [i]
+    FROM OPENJSON(NULL) WITH ([value] int '$') AS [i]
 )
 """);
     }
diff --git a/test/EFCore.SqlServer.FunctionalTests/Query/PrimitiveCollectionsQuerySqlServerTest.cs b/test/EFCore.SqlServer.FunctionalTests/Query/PrimitiveCollectionsQuerySqlServerTest.cs
index de05c4c379..3575a954aa 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Query/PrimitiveCollectionsQuerySqlServerTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Query/PrimitiveCollectionsQuerySqlServerTest.cs
@@ -805,7 +805,7 @@ public override async Task Parameter_collection_null_Contains(bool async)
 FROM [PrimitiveCollectionsEntity] AS [p]
 WHERE [p].[Int] IN (
     SELECT [i].[value]
-    FROM OPENJSON(NULL) AS [i]
+    FROM OPENJSON(NULL) WITH ([value] int '$') AS [i]
 )
 """);
     }
diff --git a/test/EFCore.SqlServer.FunctionalTests/Query/QueryFilterFuncletizationSqlServerTest.cs b/test/EFCore.SqlServer.FunctionalTests/Query/QueryFilterFuncletizationSqlServerTest.cs
index fed02c6815..6f5be4c633 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Query/QueryFilterFuncletizationSqlServerTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Query/QueryFilterFuncletizationSqlServerTest.cs
@@ -100,7 +100,7 @@ public override void DbContext_list_is_parameterized()
 FROM [ListFilter] AS [l]
 WHERE [l].[Tenant] IN (
     SELECT [e].[value]
-    FROM OPENJSON(NULL) AS [e]
+    FROM OPENJSON(NULL) WITH ([value] int '$') AS [e]
 )
 """,
             //
