diff --git a/src/EFCore.Relational/Query/SqlExpressions/SelectExpression.Helper.cs b/src/EFCore.Relational/Query/SqlExpressions/SelectExpression.Helper.cs
index 0ddc121b01..82031d038d 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/SelectExpression.Helper.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/SelectExpression.Helper.cs
@@ -432,6 +432,26 @@ private sealed class CloningExpressionVisitor(SqlAliasManager? sqlAliasManager,
                 case ColumnExpression column when _tableAliasMap.TryGetValue(column.TableAlias, out var newTableAlias):
                     return new ColumnExpression(column.Name, newTableAlias, column.Type, column.TypeMapping, column.IsNullable);
 
+                case StructuralTypeProjectionExpression:
+                    var result = (StructuralTypeProjectionExpression)base.Visit(expression);
+
+                    // TableMap aliases are not stored in form of expression so we need to update them manually
+                    var tableMapChanged = false;
+                    var newTableMap = result.TableMap.ToDictionary(x => x.Key, x => x.Value);
+                    foreach (var (oldAlias, newAlias) in _tableAliasMap)
+                    {
+                        var match = newTableMap.FirstOrDefault(x => x.Value == oldAlias).Key;
+                        if (match != null)
+                        {
+                            newTableMap[match] = newAlias;
+                            tableMapChanged = true;
+                        }
+                    }
+
+                    return tableMapChanged
+                        ? result.UpdateTableMap(newTableMap)
+                        : result;
+
                 default:
                     return base.Visit(expression);
             }
diff --git a/src/EFCore.Relational/Query/StructuralTypeProjectionExpression.cs b/src/EFCore.Relational/Query/StructuralTypeProjectionExpression.cs
index ff33d49109..764b5b3a3b 100644
--- a/src/EFCore.Relational/Query/StructuralTypeProjectionExpression.cs
+++ b/src/EFCore.Relational/Query/StructuralTypeProjectionExpression.cs
@@ -298,11 +298,11 @@ public virtual StructuralTypeProjectionExpression UpdateEntityType(IEntityType d
             case RelationalAnnotationNames.TpcMappingStrategy:
             case RelationalAnnotationNames.TptMappingStrategy:
                 newTableMap = new Dictionary<ITableBase, string>();
-                foreach (var (table, tableReferenceExpression) in TableMap)
+                foreach (var (table, tableAlias) in TableMap)
                 {
                     if (table.EntityTypeMappings.Any(m => m.TypeBase == derivedType))
                     {
-                        newTableMap.Add(table, tableReferenceExpression);
+                        newTableMap.Add(table, tableAlias);
                     }
                 }
 
@@ -331,6 +331,17 @@ public virtual StructuralTypeProjectionExpression UpdateEntityType(IEntityType d
             derivedType, propertyExpressionMap, ownedNavigationMap, complexPropertyCache, newTableMap ?? TableMap, IsNullable, discriminatorExpression);
     }
 
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    [EntityFrameworkInternal]
+    public virtual StructuralTypeProjectionExpression UpdateTableMap(IReadOnlyDictionary<ITableBase, string> newTableMap)
+        => new StructuralTypeProjectionExpression(
+            StructuralType, _propertyExpressionMap, _ownedNavigationMap, _complexPropertyCache, newTableMap, IsNullable, DiscriminatorExpression);
+
     /// <summary>
     ///     Binds a property with this structural type projection to get the SQL representation.
     /// </summary>
diff --git a/test/EFCore.Specification.Tests/Query/ComplexTypeQueryTestBase.cs b/test/EFCore.Specification.Tests/Query/ComplexTypeQueryTestBase.cs
index ae38af60bf..ce123c49aa 100644
--- a/test/EFCore.Specification.Tests/Query/ComplexTypeQueryTestBase.cs
+++ b/test/EFCore.Specification.Tests/Query/ComplexTypeQueryTestBase.cs
@@ -814,6 +814,13 @@ public virtual Task Same_complex_type_projected_twice_with_pushdown_as_part_of_a
                 AssertEqual(e.Complex?.Two, a.Complex?.Two);
             });
 
+    [ConditionalTheory]
+    [MemberData(nameof(IsAsyncData))]
+    public virtual Task Entity_with_complex_type_with_group_by_and_first(bool async)
+        => AssertQuery(
+            async,
+            ss => ss.Set<Customer>().GroupBy(x => x.Id).Select(x => x.First()));
+
     protected DbContext CreateContext()
         => Fixture.CreateContext();
 }
diff --git a/test/EFCore.SqlServer.FunctionalTests/Query/ComplexTypeQuerySqlServerTest.cs b/test/EFCore.SqlServer.FunctionalTests/Query/ComplexTypeQuerySqlServerTest.cs
index 56719f73de..ab36999cff 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Query/ComplexTypeQuerySqlServerTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Query/ComplexTypeQuerySqlServerTest.cs
@@ -1129,6 +1129,29 @@ public override async Task Same_complex_type_projected_twice_with_pushdown_as_pa
         AssertSql("");
     }
 
+    public override async Task Entity_with_complex_type_with_group_by_and_first(bool async)
+    {
+        await base.Entity_with_complex_type_with_group_by_and_first(async);
+
+        AssertSql(
+"""
+SELECT [c3].[Id], [c3].[Name], [c3].[BillingAddress_AddressLine1], [c3].[BillingAddress_AddressLine2], [c3].[BillingAddress_Tags], [c3].[BillingAddress_ZipCode], [c3].[BillingAddress_Country_Code], [c3].[BillingAddress_Country_FullName], [c3].[ShippingAddress_AddressLine1], [c3].[ShippingAddress_AddressLine2], [c3].[ShippingAddress_Tags], [c3].[ShippingAddress_ZipCode], [c3].[ShippingAddress_Country_Code], [c3].[ShippingAddress_Country_FullName]
+FROM (
+    SELECT [c].[Id]
+    FROM [Customer] AS [c]
+    GROUP BY [c].[Id]
+) AS [c1]
+LEFT JOIN (
+    SELECT [c2].[Id], [c2].[Name], [c2].[BillingAddress_AddressLine1], [c2].[BillingAddress_AddressLine2], [c2].[BillingAddress_Tags], [c2].[BillingAddress_ZipCode], [c2].[BillingAddress_Country_Code], [c2].[BillingAddress_Country_FullName], [c2].[ShippingAddress_AddressLine1], [c2].[ShippingAddress_AddressLine2], [c2].[ShippingAddress_Tags], [c2].[ShippingAddress_ZipCode], [c2].[ShippingAddress_Country_Code], [c2].[ShippingAddress_Country_FullName]
+    FROM (
+        SELECT [c0].[Id], [c0].[Name], [c0].[BillingAddress_AddressLine1], [c0].[BillingAddress_AddressLine2], [c0].[BillingAddress_Tags], [c0].[BillingAddress_ZipCode], [c0].[BillingAddress_Country_Code], [c0].[BillingAddress_Country_FullName], [c0].[ShippingAddress_AddressLine1], [c0].[ShippingAddress_AddressLine2], [c0].[ShippingAddress_Tags], [c0].[ShippingAddress_ZipCode], [c0].[ShippingAddress_Country_Code], [c0].[ShippingAddress_Country_FullName], ROW_NUMBER() OVER(PARTITION BY [c0].[Id] ORDER BY [c0].[Id]) AS [row]
+        FROM [Customer] AS [c0]
+    ) AS [c2]
+    WHERE [c2].[row] <= 1
+) AS [c3] ON [c1].[Id] = [c3].[Id]
+""");
+    }
+
     [ConditionalFact]
     public virtual void Check_all_tests_overridden()
         => TestHelpers.AssertAllMethodsOverridden(GetType());
diff --git a/test/EFCore.Sqlite.FunctionalTests/Query/ComplexTypeQuerySqliteTest.cs b/test/EFCore.Sqlite.FunctionalTests/Query/ComplexTypeQuerySqliteTest.cs
index af256a93e2..17b6b9dba4 100644
--- a/test/EFCore.Sqlite.FunctionalTests/Query/ComplexTypeQuerySqliteTest.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/Query/ComplexTypeQuerySqliteTest.cs
@@ -1012,6 +1012,29 @@ public override async Task Same_complex_type_projected_twice_with_pushdown_as_pa
             (await Assert.ThrowsAsync<InvalidOperationException>(
                 () => base.Same_complex_type_projected_twice_with_pushdown_as_part_of_another_projection(async))).Message);
 
+    public override async Task Entity_with_complex_type_with_group_by_and_first(bool async)
+    {
+        await base.Entity_with_complex_type_with_group_by_and_first(async);
+
+        AssertSql(
+"""
+SELECT "c3"."Id", "c3"."Name", "c3"."BillingAddress_AddressLine1", "c3"."BillingAddress_AddressLine2", "c3"."BillingAddress_Tags", "c3"."BillingAddress_ZipCode", "c3"."BillingAddress_Country_Code", "c3"."BillingAddress_Country_FullName", "c3"."ShippingAddress_AddressLine1", "c3"."ShippingAddress_AddressLine2", "c3"."ShippingAddress_Tags", "c3"."ShippingAddress_ZipCode", "c3"."ShippingAddress_Country_Code", "c3"."ShippingAddress_Country_FullName"
+FROM (
+    SELECT "c"."Id"
+    FROM "Customer" AS "c"
+    GROUP BY "c"."Id"
+) AS "c1"
+LEFT JOIN (
+    SELECT "c2"."Id", "c2"."Name", "c2"."BillingAddress_AddressLine1", "c2"."BillingAddress_AddressLine2", "c2"."BillingAddress_Tags", "c2"."BillingAddress_ZipCode", "c2"."BillingAddress_Country_Code", "c2"."BillingAddress_Country_FullName", "c2"."ShippingAddress_AddressLine1", "c2"."ShippingAddress_AddressLine2", "c2"."ShippingAddress_Tags", "c2"."ShippingAddress_ZipCode", "c2"."ShippingAddress_Country_Code", "c2"."ShippingAddress_Country_FullName"
+    FROM (
+        SELECT "c0"."Id", "c0"."Name", "c0"."BillingAddress_AddressLine1", "c0"."BillingAddress_AddressLine2", "c0"."BillingAddress_Tags", "c0"."BillingAddress_ZipCode", "c0"."BillingAddress_Country_Code", "c0"."BillingAddress_Country_FullName", "c0"."ShippingAddress_AddressLine1", "c0"."ShippingAddress_AddressLine2", "c0"."ShippingAddress_Tags", "c0"."ShippingAddress_ZipCode", "c0"."ShippingAddress_Country_Code", "c0"."ShippingAddress_Country_FullName", ROW_NUMBER() OVER(PARTITION BY "c0"."Id" ORDER BY "c0"."Id") AS "row"
+        FROM "Customer" AS "c0"
+    ) AS "c2"
+    WHERE "c2"."row" <= 1
+) AS "c3" ON "c1"."Id" = "c3"."Id"
+""");
+    }
+
     [ConditionalFact]
     public virtual void Check_all_tests_overridden()
         => TestHelpers.AssertAllMethodsOverridden(GetType());
