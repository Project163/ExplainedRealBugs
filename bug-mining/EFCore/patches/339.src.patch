diff --git a/src/EFCore/ChangeTracking/Internal/ValueGenerationManager.cs b/src/EFCore/ChangeTracking/Internal/ValueGenerationManager.cs
index 0c45b3779e..4df08a5dc6 100644
--- a/src/EFCore/ChangeTracking/Internal/ValueGenerationManager.cs
+++ b/src/EFCore/ChangeTracking/Internal/ValueGenerationManager.cs
@@ -96,18 +96,7 @@ public virtual bool Generate(InternalEntityEntry entry, bool includePrimaryKey =
         //TODO: Handle complex properties
         foreach (var property in entry.EntityType.GetValueGeneratingProperties())
         {
-            if (entry.HasExplicitValue(property)
-                || (!includePrimaryKey
-                    && property.IsPrimaryKey()))
-            {
-                continue;
-            }
-
             var valueGenerator = GetValueGenerator(property);
-
-            var generatedValue = valueGenerator.Next(entityEntry);
-            var temporary = valueGenerator.GeneratesTemporaryValues;
-
             if (valueGenerator.GeneratesStableValues)
             {
                 hasStableValues = true;
@@ -117,6 +106,16 @@ public virtual bool Generate(InternalEntityEntry entry, bool includePrimaryKey =
                 hasNonStableValues = true;
             }
 
+            if (entry.HasExplicitValue(property)
+                || (!includePrimaryKey
+                    && property.IsPrimaryKey()))
+            {
+                continue;
+            }
+
+            var generatedValue = valueGenerator.Next(entityEntry);
+            var temporary = valueGenerator.GeneratesTemporaryValues;
+
             Log(entry, property, generatedValue, temporary);
 
             SetGeneratedValue(entry, property, generatedValue, temporary);
@@ -155,17 +154,7 @@ private void Log(InternalEntityEntry entry, IProperty property, object? generate
         var hasNonStableValues = false;
         foreach (var property in entry.EntityType.GetValueGeneratingProperties())
         {
-            if (entry.HasExplicitValue(property)
-                || (!includePrimaryKey
-                    && property.IsPrimaryKey()))
-            {
-                continue;
-            }
-
             var valueGenerator = GetValueGenerator(property);
-            var generatedValue = await valueGenerator.NextAsync(entityEntry, cancellationToken).ConfigureAwait(false);
-            var temporary = valueGenerator.GeneratesTemporaryValues;
-
             if (valueGenerator.GeneratesStableValues)
             {
                 hasStableValues = true;
@@ -175,6 +164,16 @@ private void Log(InternalEntityEntry entry, IProperty property, object? generate
                 hasNonStableValues = true;
             }
 
+            if (entry.HasExplicitValue(property)
+                || (!includePrimaryKey
+                    && property.IsPrimaryKey()))
+            {
+                continue;
+            }
+
+            var generatedValue = await valueGenerator.NextAsync(entityEntry, cancellationToken).ConfigureAwait(false);
+            var temporary = valueGenerator.GeneratesTemporaryValues;
+
             Log(entry, property, generatedValue, temporary);
 
             SetGeneratedValue(
diff --git a/test/EFCore.Relational.Tests/Update/ModificationCommandComparerTest.cs b/test/EFCore.Relational.Tests/Update/ModificationCommandComparerTest.cs
index 868f3fbacd..ca2c79130d 100644
--- a/test/EFCore.Relational.Tests/Update/ModificationCommandComparerTest.cs
+++ b/test/EFCore.Relational.Tests/Update/ModificationCommandComparerTest.cs
@@ -167,6 +167,7 @@ private void Compare_returns_0_only_for_entries_that_have_same_key_values_generi
 
         var keyProperty = entityType.AddProperty("Id", typeof(T));
         keyProperty.IsNullable = false;
+        keyProperty.ValueGenerated = ValueGenerated.Never;
         entityType.SetPrimaryKey(keyProperty);
 
         var model = modelBuilder.FinalizeModel();
diff --git a/test/EFCore.Specification.Tests/GraphUpdates/GraphUpdatesTestBase.cs b/test/EFCore.Specification.Tests/GraphUpdates/GraphUpdatesTestBase.cs
index e19494b8a7..c5d87862f9 100644
--- a/test/EFCore.Specification.Tests/GraphUpdates/GraphUpdatesTestBase.cs
+++ b/test/EFCore.Specification.Tests/GraphUpdates/GraphUpdatesTestBase.cs
@@ -1,6 +1,7 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using System.Collections.Concurrent;
 using System.ComponentModel;
 using System.ComponentModel.DataAnnotations;
 using System.ComponentModel.DataAnnotations.Schema;
@@ -586,6 +587,47 @@ protected override void OnModelCreating(ModelBuilder modelBuilder, DbContext con
                     b.OwnsMany(e => e.OptionalChildren).OwnsMany(e => e.Children);
                     b.OwnsMany(e => e.RequiredChildren).OwnsMany(e => e.Children);
                 });
+
+            modelBuilder.Entity<ParentEntity32084>()
+                .HasOne(x => x.Child)
+                .WithOne()
+                .HasForeignKey<ChildBaseEntity32084>(x => x.ParentId);
+
+            modelBuilder.Entity<ChildEntity32084>();
+
+            modelBuilder.Entity<StableParent32084>(
+                b =>
+                {
+                    b.HasOne(x => x.Child).WithOne().HasForeignKey<StableChild32084>(x => x.ParentId);
+                    b.Property(e => e.Id).HasValueGenerator<StableGuidGenerator>();
+                });
+
+            modelBuilder.Entity<StableChild32084>(
+                b =>
+                {
+                    b.Property(e => e.Id).HasValueGenerator<StableGuidGenerator>();
+                });
+
+            modelBuilder.Entity<SneakyUncle32084>(
+                b =>
+                {
+                    b.HasOne(x => x.Brother).WithOne().HasForeignKey<SneakyUncle32084>(x => x.BrotherId);
+                    b.Property(e => e.Id).HasValueGenerator<StableGuidGenerator>();
+                });
+        }
+
+        private class StableGuidGenerator : ValueGenerator<Guid>
+        {
+            private readonly ConcurrentDictionary<object, Guid> _guids = new(ReferenceEqualityComparer.Instance);
+
+            public override Guid Next(EntityEntry entry)
+                => _guids.GetOrAdd(entry.Entity, _ => Guid.NewGuid());
+
+            public override bool GeneratesTemporaryValues
+                => false;
+
+            public override bool GeneratesStableValues
+                => true;
         }
 
         protected virtual object CreateFullGraph()
@@ -4341,6 +4383,114 @@ protected class Beetroot2 : Parsnip2
     {
     }
 
+    protected class ParentEntity32084 : NotifyingEntity
+    {
+        private Guid _id;
+        private ChildBaseEntity32084 _child;
+
+        public Guid Id
+        {
+            get => _id;
+            set => SetWithNotify(value, ref _id);
+        }
+
+        public ChildBaseEntity32084 Child
+        {
+            get => _child;
+            set => SetWithNotify(value, ref _child);
+        }
+    }
+
+    protected abstract class ChildBaseEntity32084 : NotifyingEntity
+    {
+        private Guid _id;
+        private Guid _parentId;
+
+        public Guid Id
+        {
+            get => _id;
+            set => SetWithNotify(value, ref _id);
+        }
+
+        public Guid ParentId
+        {
+            get => _parentId;
+            set => SetWithNotify(value, ref _parentId);
+        }
+    }
+
+    protected class ChildEntity32084 : ChildBaseEntity32084
+    {
+        private string _childValue;
+
+        public string ChildValue
+        {
+            get => _childValue;
+            set => SetWithNotify(value, ref _childValue);
+        }
+    }
+
+    protected class StableParent32084 : NotifyingEntity
+    {
+        private Guid _id;
+        private StableChild32084 _child;
+
+        public Guid Id
+        {
+            get => _id;
+            set => SetWithNotify(value, ref _id);
+        }
+
+        public StableChild32084 Child
+        {
+            get => _child;
+            set => SetWithNotify(value, ref _child);
+        }
+    }
+
+    protected class StableChild32084 : NotifyingEntity
+    {
+        private Guid _id;
+        private Guid _parentId;
+
+        public Guid Id
+        {
+            get => _id;
+            set => SetWithNotify(value, ref _id);
+        }
+
+        public Guid ParentId
+        {
+            get => _parentId;
+            set => SetWithNotify(value, ref _parentId);
+        }
+    }
+
+    protected class SneakyUncle32084 : NotifyingEntity
+    {
+        private Guid _id;
+        private Guid? _brotherId;
+        private StableParent32084 _brother;
+
+        public Guid Id
+        {
+            get => _id;
+            set => SetWithNotify(value, ref _id);
+        }
+
+        public Guid? BrotherId
+        {
+            get => _brotherId;
+            set => SetWithNotify(value, ref _brotherId);
+        }
+
+        public StableParent32084 Brother
+        {
+            get => _brother;
+            set => SetWithNotify(value, ref _brother);
+        }
+    }
+
     protected class NotifyingEntity : INotifyPropertyChanging, INotifyPropertyChanged
     {
         protected void SetWithNotify<T>(T value, ref T field, [CallerMemberName] string propertyName = "")
diff --git a/test/EFCore.Specification.Tests/GraphUpdates/GraphUpdatesTestBaseMiscellaneous.cs b/test/EFCore.Specification.Tests/GraphUpdates/GraphUpdatesTestBaseMiscellaneous.cs
index 1615ace95e..81a79caa46 100644
--- a/test/EFCore.Specification.Tests/GraphUpdates/GraphUpdatesTestBaseMiscellaneous.cs
+++ b/test/EFCore.Specification.Tests/GraphUpdates/GraphUpdatesTestBaseMiscellaneous.cs
@@ -2120,4 +2120,175 @@ public virtual Task Shadow_skip_navigation_in_base_class_is_handled(bool async)
                 Assert.Equal(1, entities.Count);
                 Assert.Equal(nameof(Lettuce2), context.Entry(entities[0]).Property<string>("Discriminator").CurrentValue);
             });
+
+    [ConditionalTheory] // Issue #32084
+    [InlineData(false, false)]
+    [InlineData(true, false)]
+    [InlineData(false, true)]
+    [InlineData(true, true)]
+    public virtual Task Mark_explicitly_set_dependent_appropriately_with_any_inheritance_and_stable_generator(bool async, bool useAdd)
+    {
+        var parentId = Guid.NewGuid();
+        var childId = Guid.NewGuid();
+
+        return ExecuteWithStrategyInTransactionAsync(
+            async context =>
+            {
+                if (async)
+                {
+                    await context.AddAsync(new ParentEntity32084 { Id = parentId });
+                    await context.SaveChangesAsync();
+                }
+                else
+                {
+                    context.Add(new ParentEntity32084 { Id = parentId });
+                    context.SaveChanges();
+                }
+            },
+            async context =>
+            {
+                var parent = async
+                    ? await context.FindAsync<ParentEntity32084>(parentId)
+                    : context.Find<ParentEntity32084>(parentId);
+
+                var child = new ChildEntity32084
+                {
+                    Id = childId,
+                    ParentId = parent!.Id,
+                    ChildValue = "test value"
+                };
+
+                if (useAdd)
+                {
+                    _ = async ? await context.AddAsync(child) : context.Add(child);
+                }
+                else
+                {
+                    parent.Child = child;
+                    context.ChangeTracker.DetectChanges();
+                }
+
+                Assert.Equal(2, context.ChangeTracker.Entries().Count());
+                Assert.Equal(EntityState.Unchanged, context.Entry(parent).State);
+
+                if (useAdd) // If we call Add explicitly, then the key value is forced to Added
+                {
+                    Assert.Equal(EntityState.Added, context.Entry(child).State);
+                    _ = async ? await context.SaveChangesAsync() : context.SaveChanges();
+                }
+                else
+                {
+                    Assert.Equal(EntityState.Modified, context.Entry(child).State);
+                    await Assert.ThrowsAsync<DbUpdateConcurrencyException>(
+                        async () => _ = async ? await context.SaveChangesAsync() : context.SaveChanges());
+                }
+            });
+    }
+
+    [ConditionalTheory] // Issue #32084
+    [InlineData(false, false)]
+    [InlineData(true, false)]
+    [InlineData(false, true)]
+    [InlineData(true, true)]
+    public virtual Task Mark_explicitly_set_stable_dependent_appropriately(bool async, bool useAdd)
+    {
+        var parentId = Guid.NewGuid();
+        var childId = Guid.NewGuid();
+
+        return ExecuteWithStrategyInTransactionAsync(
+            async context =>
+            {
+                if (async)
+                {
+                    await context.AddAsync(new StableParent32084 { Id = parentId });
+                    await context.SaveChangesAsync();
+                }
+                else
+                {
+                    context.Add(new StableParent32084 { Id = parentId });
+                    context.SaveChanges();
+                }
+            },
+            async context =>
+            {
+                var parent = async
+                    ? await context.FindAsync<StableParent32084>(parentId)
+                    : context.Find<StableParent32084>(parentId);
+
+                var child = new StableChild32084()
+                {
+                    Id = childId, ParentId = parent!.Id,
+                };
+
+                if (useAdd)
+                {
+                    _ = async ? await context.AddAsync(child) : context.Add(child);
+                }
+                else
+                {
+                    parent.Child = child;
+                    context.ChangeTracker.DetectChanges();
+                }
+
+                Assert.Equal(EntityState.Unchanged, context.Entry(parent).State);
+                Assert.Equal(2, context.ChangeTracker.Entries().Count());
+                Assert.Equal(EntityState.Added, context.Entry(child).State);
+
+                _ = async ? await context.SaveChangesAsync() : context.SaveChanges();
+            });
+    }
+
+    [ConditionalTheory] // Issue #32084
+    [InlineData(false, false)]
+    [InlineData(true, false)]
+    [InlineData(false, true)]
+    [InlineData(true, true)]
+    public virtual Task Mark_explicitly_set_stable_dependent_appropriately_when_deep_in_graph(bool async, bool useAdd)
+    {
+        var parentId = Guid.NewGuid();
+        var childId = Guid.NewGuid();
+        var brotherId = Guid.NewGuid();
+
+        return ExecuteWithStrategyInTransactionAsync(
+            async context =>
+            {
+                if (async)
+                {
+                    await context.AddAsync(new SneakyUncle32084 { Id = brotherId });
+                    await context.SaveChangesAsync();
+                }
+                else
+                {
+                    context.Add(new SneakyUncle32084 { Id = brotherId });
+                    context.SaveChanges();
+                }
+            },
+            async context =>
+            {
+                var brother = async
+                    ? (await context.FindAsync<SneakyUncle32084>(brotherId))!
+                    : context.Find<SneakyUncle32084>(brotherId)!;
+
+                var child = new StableChild32084 { Id = childId };
+                var parent = new StableParent32084 { Id = parentId, Child = child };
+
+                if (useAdd)
+                {
+                    brother.BrotherId = parentId;
+                    _ = async ? await context.AddAsync(parent) : context.Add(parent);
+                }
+                else
+                {
+                    brother.Brother = parent;
+                    context.ChangeTracker.DetectChanges();
+                }
+
+                Assert.Equal(3, context.ChangeTracker.Entries().Count());
+                Assert.Equal(EntityState.Modified, context.Entry(brother).State);
+                Assert.Equal(EntityState.Added, context.Entry(parent).State);
+                Assert.Equal(EntityState.Added, context.Entry(child).State);
+
+                _ = async ? await context.SaveChangesAsync() : context.SaveChanges();
+            });
+    }
 }
diff --git a/test/EFCore.SqlServer.FunctionalTests/GraphUpdates/GraphUpdatesSqlServerOwnedTest.cs b/test/EFCore.SqlServer.FunctionalTests/GraphUpdates/GraphUpdatesSqlServerOwnedTest.cs
index 1a27875c53..9bca5f95b3 100644
--- a/test/EFCore.SqlServer.FunctionalTests/GraphUpdates/GraphUpdatesSqlServerOwnedTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/GraphUpdates/GraphUpdatesSqlServerOwnedTest.cs
@@ -14,6 +14,18 @@ public GraphUpdatesSqlServerOwnedTest(SqlServerFixture fixture)
     public override Task Update_root_by_collection_replacement_of_inserted_first_level(bool async)
         => Task.CompletedTask;
 
+    // No owned types
+    public override Task Mark_explicitly_set_dependent_appropriately_with_any_inheritance_and_stable_generator(bool async, bool useAdd)
+        => Task.CompletedTask;
+
+    // No owned types
+    public override Task Mark_explicitly_set_stable_dependent_appropriately(bool async, bool useAdd)
+        => Task.CompletedTask;
+
+    // No owned types
+    public override Task Mark_explicitly_set_stable_dependent_appropriately_when_deep_in_graph(bool async, bool useAdd)
+        => Task.CompletedTask;
+
     // No owned types
     public override Task Update_root_by_collection_replacement_of_deleted_first_level(bool async)
         => Task.CompletedTask;
diff --git a/test/EFCore.SqlServer.FunctionalTests/GraphUpdates/GraphUpdatesSqlServerTptIdentityTest.cs b/test/EFCore.SqlServer.FunctionalTests/GraphUpdates/GraphUpdatesSqlServerTptIdentityTest.cs
index 4075838a92..73d19cb297 100644
--- a/test/EFCore.SqlServer.FunctionalTests/GraphUpdates/GraphUpdatesSqlServerTptIdentityTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/GraphUpdates/GraphUpdatesSqlServerTptIdentityTest.cs
@@ -73,6 +73,9 @@ protected override void OnModelCreating(ModelBuilder modelBuilder, DbContext con
             modelBuilder.Entity<Poost>().ToTable(nameof(Poost));
             modelBuilder.Entity<Bloog>().ToTable(nameof(Bloog));
             modelBuilder.Entity<Produce>().ToTable(nameof(Produce));
+            modelBuilder.Entity<ParentEntity32084>().ToTable(nameof(ParentEntity32084));
+            modelBuilder.Entity<ChildBaseEntity32084>().ToTable(nameof(ChildBaseEntity32084));
+            modelBuilder.Entity<ChildEntity32084>().ToTable(nameof(ChildEntity32084));
         }
     }
 }
diff --git a/test/EFCore.Tests/ChangeTracking/ChangeTrackerTest.cs b/test/EFCore.Tests/ChangeTracking/ChangeTrackerTest.cs
index 1dc54a9170..db1a4355ce 100644
--- a/test/EFCore.Tests/ChangeTracking/ChangeTrackerTest.cs
+++ b/test/EFCore.Tests/ChangeTracking/ChangeTrackerTest.cs
@@ -2299,17 +2299,17 @@ protected internal override void OnModelCreating(ModelBuilder modelBuilder)
             modelBuilder
                 .Entity<Cat>()
                 .Property(e => e.Id)
-                .HasValueGenerator<InMemoryIntegerValueGenerator<int>>();
+                .HasValueGenerator((_, __) => new ResettableValueGenerator());
 
             modelBuilder
                 .Entity<Hat>()
                 .Property(e => e.Id)
-                .HasValueGenerator<InMemoryIntegerValueGenerator<int>>();
+                .HasValueGenerator((_, __) => new ResettableValueGenerator());
 
             modelBuilder.Entity<Mat>(
                 b =>
                 {
-                    b.Property(e => e.Id).HasValueGenerator<InMemoryIntegerValueGenerator<int>>();
+                    b.Property(e => e.Id).HasValueGenerator((_, __) => new ResettableValueGenerator());
                     b.HasMany(e => e.Cats)
                         .WithMany(e => e.Mats)
                         .UsingEntity<CatMat>(
