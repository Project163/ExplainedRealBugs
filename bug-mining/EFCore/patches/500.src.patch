diff --git a/src/EFCore.Design/Query/Internal/PrecompiledQueryCodeGenerator.cs b/src/EFCore.Design/Query/Internal/PrecompiledQueryCodeGenerator.cs
index 52a3752053..cde91a000a 100644
--- a/src/EFCore.Design/Query/Internal/PrecompiledQueryCodeGenerator.cs
+++ b/src/EFCore.Design/Query/Internal/PrecompiledQueryCodeGenerator.cs
@@ -1066,10 +1066,10 @@ or nameof(EntityFrameworkQueryableExtensions.ToListAsync)
                         method.GetParameters()[1].ParameterType.GenericTypeArguments[0].GenericTypeArguments[1])),
 
             // ExecuteDelete/Update behave just like other scalar-returning operators
-            nameof(RelationalQueryableExtensions.ExecuteDeleteAsync) when method.DeclaringType == typeof(RelationalQueryableExtensions)
-                => RewriteToSync(typeof(RelationalQueryableExtensions).GetMethod(nameof(RelationalQueryableExtensions.ExecuteDelete))),
-            nameof(RelationalQueryableExtensions.ExecuteUpdateAsync) when method.DeclaringType == typeof(RelationalQueryableExtensions)
-                => RewriteToSync(typeof(RelationalQueryableExtensions).GetMethod(nameof(RelationalQueryableExtensions.ExecuteUpdate))),
+            nameof(EntityFrameworkQueryableExtensions.ExecuteDeleteAsync) when method.DeclaringType == typeof(EntityFrameworkQueryableExtensions)
+                => RewriteToSync(typeof(EntityFrameworkQueryableExtensions).GetMethod(nameof(EntityFrameworkQueryableExtensions.ExecuteDelete))),
+            nameof(EntityFrameworkQueryableExtensions.ExecuteUpdateAsync) when method.DeclaringType == typeof(EntityFrameworkQueryableExtensions)
+                => RewriteToSync(typeof(EntityFrameworkQueryableExtensions).GetMethod(nameof(EntityFrameworkQueryableExtensions.ExecuteUpdate))),
 
             // In the regular case (sync terminating operator which needs to stay in the query tree), simply compose the terminating
             // operator over the penultimate and return that.
diff --git a/src/EFCore.Design/Query/Internal/QueryLocator.cs b/src/EFCore.Design/Query/Internal/QueryLocator.cs
index e8a0c13a33..aa2ed59524 100644
--- a/src/EFCore.Design/Query/Internal/QueryLocator.cs
+++ b/src/EFCore.Design/Query/Internal/QueryLocator.cs
@@ -174,11 +174,11 @@ or nameof(EntityFrameworkQueryableExtensions.SumAsync)
                     or nameof(EntityFrameworkQueryableExtensions.ForEachAsync)
                     when IsOnEfQueryableExtensions():
 
-                case nameof(RelationalQueryableExtensions.ExecuteDelete)
-                    or nameof(RelationalQueryableExtensions.ExecuteUpdate)
-                    or nameof(RelationalQueryableExtensions.ExecuteDeleteAsync)
-                    or nameof(RelationalQueryableExtensions.ExecuteUpdateAsync)
-                    when IsOnEfRelationalQueryableExtensions():
+                case nameof(EntityFrameworkQueryableExtensions.ExecuteDelete)
+                    or nameof(EntityFrameworkQueryableExtensions.ExecuteUpdate)
+                    or nameof(EntityFrameworkQueryableExtensions.ExecuteDeleteAsync)
+                    or nameof(EntityFrameworkQueryableExtensions.ExecuteUpdateAsync)
+                    when IsOnEfQueryableExtensions():
                     if (ProcessQueryCandidate(invocation))
                     {
                         return;
@@ -202,9 +202,6 @@ bool IsOnQueryable()
         bool IsOnEfQueryableExtensions()
             => IsOnTypeSymbol(_symbols.EfQueryableExtensions);
 
-        bool IsOnEfRelationalQueryableExtensions()
-            => IsOnTypeSymbol(_symbols.EfRelationalQueryableExtensions);
-
         bool IsOnTypeSymbol(ITypeSymbol typeSymbol)
             => _semanticModel.GetSymbolInfo(invocation, _cancellationToken).Symbol is IMethodSymbol methodSymbol
                 && methodSymbol.ContainingType.OriginalDefinition.Equals(typeSymbol, SymbolEqualityComparer.Default);
@@ -342,7 +339,6 @@ private bool IsDbSet(ITypeSymbol typeSymbol)
         public readonly INamedTypeSymbol IEnumerableOfT;
         public readonly INamedTypeSymbol Queryable;
         public readonly INamedTypeSymbol EfQueryableExtensions;
-        public readonly INamedTypeSymbol EfRelationalQueryableExtensions;
         // ReSharper restore InconsistentNaming
 
         private Symbols(Compilation compilation)
@@ -358,7 +354,6 @@ private Symbols(Compilation compilation)
             IEnumerableOfT = GetTypeSymbolOrThrow("System.Collections.Generic.IEnumerable`1");
             Queryable = GetTypeSymbolOrThrow("System.Linq.Queryable");
             EfQueryableExtensions = GetTypeSymbolOrThrow("Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions");
-            EfRelationalQueryableExtensions = GetTypeSymbolOrThrow("Microsoft.EntityFrameworkCore.RelationalQueryableExtensions");
         }
 
         public static Symbols Load(Compilation compilation)
diff --git a/src/EFCore.Relational/Extensions/RelationalQueryableExtensions.cs b/src/EFCore.Relational/Extensions/RelationalQueryableExtensions.cs
index 502c8c8ca9..f9b69bcf54 100644
--- a/src/EFCore.Relational/Extensions/RelationalQueryableExtensions.cs
+++ b/src/EFCore.Relational/Extensions/RelationalQueryableExtensions.cs
@@ -272,115 +272,4 @@ public static DbCommand CreateDbCommand(this IQueryable source)
         = typeof(RelationalQueryableExtensions).GetTypeInfo().GetDeclaredMethod(nameof(AsSplitQuery))!;
 
     #endregion
-
-    #region ExecuteDelete
-
-    /// <summary>
-    ///     Deletes all database rows for the entity instances which match the LINQ query from the database.
-    /// </summary>
-    /// <remarks>
-    ///     <para>
-    ///         This operation executes immediately against the database, rather than being deferred until
-    ///         <see cref="DbContext.SaveChanges()" /> is called. It also does not interact with the EF change tracker in any way:
-    ///         entity instances which happen to be tracked when this operation is invoked aren't taken into account, and aren't updated
-    ///         to reflect the changes.
-    ///     </para>
-    ///     <para>
-    ///         See <see href="https://aka.ms/efcore-docs-bulk-operations">Executing bulk operations with EF Core</see>
-    ///         for more information and examples.
-    ///     </para>
-    /// </remarks>
-    /// <param name="source">The source query.</param>
-    /// <returns>The total number of rows deleted in the database.</returns>
-    public static int ExecuteDelete<TSource>(this IQueryable<TSource> source)
-        => source.Provider.Execute<int>(Expression.Call(ExecuteDeleteMethodInfo.MakeGenericMethod(typeof(TSource)), source.Expression));
-
-    /// <summary>
-    ///     Asynchronously deletes database rows for the entity instances which match the LINQ query from the database.
-    /// </summary>
-    /// <remarks>
-    ///     <para>
-    ///         This operation executes immediately against the database, rather than being deferred until
-    ///         <see cref="DbContext.SaveChanges()" /> is called. It also does not interact with the EF change tracker in any way:
-    ///         entity instances which happen to be tracked when this operation is invoked aren't taken into account, and aren't updated
-    ///         to reflect the changes.
-    ///     </para>
-    ///     <para>
-    ///         See <see href="https://aka.ms/efcore-docs-bulk-operations">Executing bulk operations with EF Core</see>
-    ///         for more information and examples.
-    ///     </para>
-    /// </remarks>
-    /// <param name="source">The source query.</param>
-    /// <param name="cancellationToken">A <see cref="CancellationToken" /> to observe while waiting for the task to complete.</param>
-    /// <returns>The total number of rows deleted in the database.</returns>
-    public static Task<int> ExecuteDeleteAsync<TSource>(this IQueryable<TSource> source, CancellationToken cancellationToken = default)
-        => source.Provider is IAsyncQueryProvider provider
-            ? provider.ExecuteAsync<Task<int>>(
-                Expression.Call(ExecuteDeleteMethodInfo.MakeGenericMethod(typeof(TSource)), source.Expression), cancellationToken)
-            : throw new InvalidOperationException(CoreStrings.IQueryableProviderNotAsync);
-
-    internal static readonly MethodInfo ExecuteDeleteMethodInfo
-        = typeof(RelationalQueryableExtensions).GetTypeInfo().GetDeclaredMethod(nameof(ExecuteDelete))!;
-
-    #endregion
-
-    #region ExecuteUpdate
-
-    /// <summary>
-    ///     Updates all database rows for the entity instances which match the LINQ query from the database.
-    /// </summary>
-    /// <remarks>
-    ///     <para>
-    ///         This operation executes immediately against the database, rather than being deferred until
-    ///         <see cref="DbContext.SaveChanges()" /> is called. It also does not interact with the EF change tracker in any way:
-    ///         entity instances which happen to be tracked when this operation is invoked aren't taken into account, and aren't updated
-    ///         to reflect the changes.
-    ///     </para>
-    ///     <para>
-    ///         See <see href="https://aka.ms/efcore-docs-bulk-operations">Executing bulk operations with EF Core</see>
-    ///         for more information and examples.
-    ///     </para>
-    /// </remarks>
-    /// <param name="source">The source query.</param>
-    /// <param name="setPropertyCalls">A collection of set property statements specifying properties to update.</param>
-    /// <returns>The total number of rows updated in the database.</returns>
-    public static int ExecuteUpdate<TSource>(
-        this IQueryable<TSource> source,
-        Expression<Func<SetPropertyCalls<TSource>, SetPropertyCalls<TSource>>> setPropertyCalls)
-        => source.Provider.Execute<int>(
-            Expression.Call(ExecuteUpdateMethodInfo.MakeGenericMethod(typeof(TSource)), source.Expression, setPropertyCalls));
-
-    /// <summary>
-    ///     Asynchronously updates database rows for the entity instances which match the LINQ query from the database.
-    /// </summary>
-    /// <remarks>
-    ///     <para>
-    ///         This operation executes immediately against the database, rather than being deferred until
-    ///         <see cref="DbContext.SaveChanges()" /> is called. It also does not interact with the EF change tracker in any way:
-    ///         entity instances which happen to be tracked when this operation is invoked aren't taken into account, and aren't updated
-    ///         to reflect the changes.
-    ///     </para>
-    ///     <para>
-    ///         See <see href="https://aka.ms/efcore-docs-bulk-operations">Executing bulk operations with EF Core</see>
-    ///         for more information and examples.
-    ///     </para>
-    /// </remarks>
-    /// <param name="source">The source query.</param>
-    /// <param name="setPropertyCalls">A collection of set property statements specifying properties to update.</param>
-    /// <param name="cancellationToken">A <see cref="CancellationToken" /> to observe while waiting for the task to complete.</param>
-    /// <returns>The total number of rows updated in the database.</returns>
-    public static Task<int> ExecuteUpdateAsync<TSource>(
-        this IQueryable<TSource> source,
-        Expression<Func<SetPropertyCalls<TSource>, SetPropertyCalls<TSource>>> setPropertyCalls,
-        CancellationToken cancellationToken = default)
-        => source.Provider is IAsyncQueryProvider provider
-            ? provider.ExecuteAsync<Task<int>>(
-                Expression.Call(
-                    ExecuteUpdateMethodInfo.MakeGenericMethod(typeof(TSource)), source.Expression, setPropertyCalls), cancellationToken)
-            : throw new InvalidOperationException(CoreStrings.IQueryableProviderNotAsync);
-
-    internal static readonly MethodInfo ExecuteUpdateMethodInfo
-        = typeof(RelationalQueryableExtensions).GetTypeInfo().GetDeclaredMethod(nameof(ExecuteUpdate))!;
-
-    #endregion
 }
diff --git a/src/EFCore.Relational/Properties/RelationalStrings.Designer.cs b/src/EFCore.Relational/Properties/RelationalStrings.Designer.cs
index b174634a21..817c3f92fa 100644
--- a/src/EFCore.Relational/Properties/RelationalStrings.Designer.cs
+++ b/src/EFCore.Relational/Properties/RelationalStrings.Designer.cs
@@ -1413,14 +1413,6 @@ public static string NonConstantOrParameterAsInExpressionValue(object? type)
         public static string NoneRelationalTypeMappingOnARelationalTypeMappingSource
             => GetString("NoneRelationalTypeMappingOnARelationalTypeMappingSource");
 
-        /// <summary>
-        ///     The LINQ expression '{expression}' could not be translated. Additional information: {details} See https://go.microsoft.com/fwlink/?linkid=2101038 for more information.
-        /// </summary>
-        public static string NonQueryTranslationFailedWithDetails(object? expression, object? details)
-            => string.Format(
-                GetString("NonQueryTranslationFailedWithDetails", nameof(expression), nameof(details)),
-                expression, details);
-
         /// <summary>
         ///     Cannot set 'IsNullable' on DbFunction '{functionName}' since the function does not represent a scalar function.
         /// </summary>
@@ -1619,12 +1611,6 @@ public static string SetOperationsRequireAtLeastOneSideWithValidTypeMapping(obje
                 GetString("SetOperationsRequireAtLeastOneSideWithValidTypeMapping", nameof(setOperationType)),
                 setOperationType);
 
-        /// <summary>
-        ///     The SetProperty&lt;TProperty&gt; method can only be used within 'ExecuteUpdate' method.
-        /// </summary>
-        public static string SetPropertyMethodInvoked
-            => GetString("SetPropertyMethodInvoked");
-
         /// <summary>
         ///     This LINQ query is being executed in split-query mode, and the SQL shown is for the first query to be executed. Additional queries may also be executed depending on the results of the first query.
         /// </summary>
diff --git a/src/EFCore.Relational/Properties/RelationalStrings.resx b/src/EFCore.Relational/Properties/RelationalStrings.resx
index 1e7a548235..a3e8dae1fe 100644
--- a/src/EFCore.Relational/Properties/RelationalStrings.resx
+++ b/src/EFCore.Relational/Properties/RelationalStrings.resx
@@ -1,17 +1,17 @@
 ï»¿<?xml version="1.0" encoding="utf-8"?>
 <root>
-  <!-- 
-    Microsoft ResX Schema 
-    
+  <!--
+    Microsoft ResX Schema
+
     Version 2.0
-    
-    The primary goals of this format is to allow a simple XML format 
-    that is mostly human readable. The generation and parsing of the 
-    various data types are done through the TypeConverter classes 
+
+    The primary goals of this format is to allow a simple XML format
+    that is mostly human readable. The generation and parsing of the
+    various data types are done through the TypeConverter classes
     associated with the data types.
-    
+
     Example:
-    
+
     ... ado.net/XML headers & schema ...
     <resheader name="resmimetype">text/microsoft-resx</resheader>
     <resheader name="version">2.0</resheader>
@@ -26,36 +26,36 @@
         <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
         <comment>This is a comment</comment>
     </data>
-                
-    There are any number of "resheader" rows that contain simple 
+
+    There are any number of "resheader" rows that contain simple
     name/value pairs.
-    
-    Each data row contains a name, and value. The row also contains a 
-    type or mimetype. Type corresponds to a .NET class that support 
-    text/value conversion through the TypeConverter architecture. 
-    Classes that don't support this are serialized and stored with the 
+
+    Each data row contains a name, and value. The row also contains a
+    type or mimetype. Type corresponds to a .NET class that support
+    text/value conversion through the TypeConverter architecture.
+    Classes that don't support this are serialized and stored with the
     mimetype set.
-    
-    The mimetype is used for serialized objects, and tells the 
-    ResXResourceReader how to depersist the object. This is currently not 
+
+    The mimetype is used for serialized objects, and tells the
+    ResXResourceReader how to depersist the object. This is currently not
     extensible. For a given mimetype the value must be set accordingly:
-    
-    Note - application/x-microsoft.net.object.binary.base64 is the format 
-    that the ResXResourceWriter will generate, however the reader can 
+
+    Note - application/x-microsoft.net.object.binary.base64 is the format
+    that the ResXResourceWriter will generate, however the reader can
     read any of the formats listed below.
-    
+
     mimetype: application/x-microsoft.net.object.binary.base64
-    value   : The object must be serialized with 
+    value   : The object must be serialized with
             : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
             : and then encoded with base64 encoding.
-    
+
     mimetype: application/x-microsoft.net.object.soap.base64
-    value   : The object must be serialized with 
+    value   : The object must be serialized with
             : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
             : and then encoded with base64 encoding.
 
     mimetype: application/x-microsoft.net.object.bytearray.base64
-    value   : The object must be serialized into a byte array 
+    value   : The object must be serialized into a byte array
             : using a System.ComponentModel.TypeConverter
             : and then encoded with base64 encoding.
     -->
@@ -957,9 +957,6 @@
   <data name="NoneRelationalTypeMappingOnARelationalTypeMappingSource" xml:space="preserve">
     <value>'FindMapping' was called on a 'RelationalTypeMappingSource' with a non-relational 'TypeMappingInfo'.</value>
   </data>
-  <data name="NonQueryTranslationFailedWithDetails" xml:space="preserve">
-    <value>The LINQ expression '{expression}' could not be translated. Additional information: {details} See https://go.microsoft.com/fwlink/?linkid=2101038 for more information.</value>
-  </data>
   <data name="NonScalarFunctionCannotBeNullable" xml:space="preserve">
     <value>Cannot set 'IsNullable' on DbFunction '{functionName}' since the function does not represent a scalar function.</value>
   </data>
@@ -1041,9 +1038,6 @@
   <data name="SetOperationsRequireAtLeastOneSideWithValidTypeMapping" xml:space="preserve">
     <value>A set operation '{setOperationType}' requires valid type mapping for at least one of its sides.</value>
   </data>
-  <data name="SetPropertyMethodInvoked" xml:space="preserve">
-    <value>The SetProperty&lt;TProperty&gt; method can only be used within 'ExecuteUpdate' method.</value>
-  </data>
   <data name="SplitQueryString" xml:space="preserve">
     <value>This LINQ query is being executed in split-query mode, and the SQL shown is for the first query to be executed. Additional queries may also be executed depending on the results of the first query.</value>
   </data>
diff --git a/src/EFCore.Relational/Properties/TypeForwards.cs b/src/EFCore.Relational/Properties/TypeForwards.cs
index 7312e1c35c..8121602abd 100644
--- a/src/EFCore.Relational/Properties/TypeForwards.cs
+++ b/src/EFCore.Relational/Properties/TypeForwards.cs
@@ -6,3 +6,4 @@
 [assembly: TypeForwardedTo(typeof(AttributeCodeFragment))]
 [assembly: TypeForwardedTo(typeof(MethodCallCodeFragment))]
 [assembly: TypeForwardedTo(typeof(NestedClosureCodeFragment))]
+[assembly: TypeForwardedTo(typeof(SetPropertyCalls<>))]
diff --git a/src/EFCore.Relational/Query/QuerySqlGenerator.cs b/src/EFCore.Relational/Query/QuerySqlGenerator.cs
index 36a605bdab..af7ed7eebe 100644
--- a/src/EFCore.Relational/Query/QuerySqlGenerator.cs
+++ b/src/EFCore.Relational/Query/QuerySqlGenerator.cs
@@ -203,7 +203,8 @@ protected override Expression VisitDelete(DeleteExpression deleteExpression)
         }
 
         throw new InvalidOperationException(
-            RelationalStrings.ExecuteOperationWithUnsupportedOperatorInSqlGeneration(nameof(RelationalQueryableExtensions.ExecuteDelete)));
+            RelationalStrings.ExecuteOperationWithUnsupportedOperatorInSqlGeneration(
+                nameof(EntityFrameworkQueryableExtensions.ExecuteDelete)));
     }
 
     /// <summary>
@@ -1540,7 +1541,8 @@ void LiftPredicate(TableExpressionBase joinTable)
         }
 
         throw new InvalidOperationException(
-            RelationalStrings.ExecuteOperationWithUnsupportedOperatorInSqlGeneration(nameof(RelationalQueryableExtensions.ExecuteUpdate)));
+            RelationalStrings.ExecuteOperationWithUnsupportedOperatorInSqlGeneration(
+                nameof(EntityFrameworkQueryableExtensions.ExecuteUpdate)));
     }
 
     /// <summary>
diff --git a/src/EFCore.Relational/Query/RelationalQueryableMethodTranslatingExpressionVisitor.ExecuteDelete.cs b/src/EFCore.Relational/Query/RelationalQueryableMethodTranslatingExpressionVisitor.ExecuteDelete.cs
index 0d7ddc8037..a21bdaf7ba 100644
--- a/src/EFCore.Relational/Query/RelationalQueryableMethodTranslatingExpressionVisitor.ExecuteDelete.cs
+++ b/src/EFCore.Relational/Query/RelationalQueryableMethodTranslatingExpressionVisitor.ExecuteDelete.cs
@@ -9,13 +9,8 @@ namespace Microsoft.EntityFrameworkCore.Query;
 
 public partial class RelationalQueryableMethodTranslatingExpressionVisitor
 {
-    /// <summary>
-    ///     Translates <see cref="RelationalQueryableExtensions.ExecuteDelete{TSource}(IQueryable{TSource})" /> method
-    ///     over the given source.
-    /// </summary>
-    /// <param name="source">The shaped query on which the operator is applied.</param>
-    /// <returns>The non query after translation.</returns>
-    protected virtual NonQueryExpression? TranslateExecuteDelete(ShapedQueryExpression source)
+    /// <inheritdoc />
+    protected override NonQueryExpression? TranslateExecuteDelete(ShapedQueryExpression source)
     {
         source = source.UpdateShaperExpression(new IncludePruner().Visit(source.ShaperExpression));
 
@@ -29,7 +24,8 @@ public partial class RelationalQueryableMethodTranslatingExpressionVisitor
         if (mappingStrategy == RelationalAnnotationNames.TptMappingStrategy)
         {
             AddTranslationErrorDetails(
-                RelationalStrings.ExecuteOperationOnTPT(nameof(RelationalQueryableExtensions.ExecuteDelete), entityType.DisplayName()));
+                RelationalStrings.ExecuteOperationOnTPT(
+                    nameof(EntityFrameworkQueryableExtensions.ExecuteDelete), entityType.DisplayName()));
             return null;
         }
 
@@ -38,7 +34,8 @@ public partial class RelationalQueryableMethodTranslatingExpressionVisitor
         {
             // We allow TPC is it is leaf type
             AddTranslationErrorDetails(
-                RelationalStrings.ExecuteOperationOnTPC(nameof(RelationalQueryableExtensions.ExecuteDelete), entityType.DisplayName()));
+                RelationalStrings.ExecuteOperationOnTPC(
+                    nameof(EntityFrameworkQueryableExtensions.ExecuteDelete), entityType.DisplayName()));
             return null;
         }
 
@@ -46,7 +43,7 @@ public partial class RelationalQueryableMethodTranslatingExpressionVisitor
         {
             AddTranslationErrorDetails(
                 RelationalStrings.ExecuteOperationOnEntitySplitting(
-                    nameof(RelationalQueryableExtensions.ExecuteDelete), entityType.DisplayName()));
+                    nameof(EntityFrameworkQueryableExtensions.ExecuteDelete), entityType.DisplayName()));
             return null;
         }
 
@@ -97,7 +94,7 @@ static bool AreOtherNonOwnedEntityTypesInTheTable(IEntityType rootType, ITableBa
         {
             AddTranslationErrorDetails(
                 RelationalStrings.ExecuteOperationOnKeylessEntityTypeWithUnsupportedOperator(
-                    nameof(RelationalQueryableExtensions.ExecuteDelete),
+                    nameof(EntityFrameworkQueryableExtensions.ExecuteDelete),
                     entityType.DisplayName()));
             return null;
         }
diff --git a/src/EFCore.Relational/Query/RelationalQueryableMethodTranslatingExpressionVisitor.ExecuteUpdate.cs b/src/EFCore.Relational/Query/RelationalQueryableMethodTranslatingExpressionVisitor.ExecuteUpdate.cs
index 0caec315c1..b627332a27 100644
--- a/src/EFCore.Relational/Query/RelationalQueryableMethodTranslatingExpressionVisitor.ExecuteUpdate.cs
+++ b/src/EFCore.Relational/Query/RelationalQueryableMethodTranslatingExpressionVisitor.ExecuteUpdate.cs
@@ -14,22 +14,8 @@ public partial class RelationalQueryableMethodTranslatingExpressionVisitor
     private static readonly MethodInfo ParameterValueExtractorMethod =
         typeof(RelationalSqlTranslatingExpressionVisitor).GetTypeInfo().GetDeclaredMethod(nameof(ParameterValueExtractor))!;
 
-    /// <summary>
-    ///     Translates
-    ///     <see
-    ///         cref="RelationalQueryableExtensions.ExecuteUpdate{TSource}(IQueryable{TSource}, Expression{Func{SetPropertyCalls{TSource}, SetPropertyCalls{TSource}}})" />
-    ///     method
-    ///     over the given source.
-    /// </summary>
-    /// <param name="source">The shaped query on which the operator is applied.</param>
-    /// <param name="setPropertyCalls">
-    ///     The lambda expression containing
-    ///     <see
-    ///         cref="SetPropertyCalls{TSource}.SetProperty{TProperty}(Func{TSource, TProperty}, Func{TSource, TProperty})" />
-    ///     statements.
-    /// </param>
-    /// <returns>The non query after translation.</returns>
-    protected virtual NonQueryExpression? TranslateExecuteUpdate(ShapedQueryExpression source, LambdaExpression setPropertyCalls)
+    /// <inheritdoc />
+    protected override NonQueryExpression? TranslateExecuteUpdate(ShapedQueryExpression source, LambdaExpression setPropertyCalls)
     {
         // Our source may have IncludeExpressions because of owned entities or auto-include; unwrap these, as they're meaningless for
         // ExecuteUpdate's lambdas. Note that we don't currently support updates across tables.
@@ -62,7 +48,7 @@ public partial class RelationalQueryableMethodTranslatingExpressionVisitor
         {
             AddTranslationErrorDetails(
                 RelationalStrings.ExecuteOperationOnTPC(
-                    nameof(RelationalQueryableExtensions.ExecuteUpdate), tpcTablesExpression.EntityType.DisplayName()));
+                    nameof(EntityFrameworkQueryableExtensions.ExecuteUpdate), tpcTablesExpression.EntityType.DisplayName()));
             return null;
         }
 
@@ -423,7 +409,7 @@ when parameter.Name.StartsWith(QueryCompilationContext.QueryParameterPrefix, Str
             {
                 AddTranslationErrorDetails(
                     RelationalStrings.ExecuteOperationOnKeylessEntityTypeWithUnsupportedOperator(
-                        nameof(RelationalQueryableExtensions.ExecuteUpdate),
+                        nameof(EntityFrameworkQueryableExtensions.ExecuteUpdate),
                         entityType.DisplayName()));
                 return null;
             }
diff --git a/src/EFCore.Relational/Query/RelationalQueryableMethodTranslatingExpressionVisitor.cs b/src/EFCore.Relational/Query/RelationalQueryableMethodTranslatingExpressionVisitor.cs
index 2011513635..f2e9c167e7 100644
--- a/src/EFCore.Relational/Query/RelationalQueryableMethodTranslatingExpressionVisitor.cs
+++ b/src/EFCore.Relational/Query/RelationalQueryableMethodTranslatingExpressionVisitor.cs
@@ -230,31 +230,6 @@ when entityQueryRootExpression.GetType() == typeof(EntityQueryRootExpression)
     protected override Expression VisitMethodCall(MethodCallExpression methodCallExpression)
     {
         var method = methodCallExpression.Method;
-        if (method.DeclaringType == typeof(RelationalQueryableExtensions))
-        {
-            var source = Visit(methodCallExpression.Arguments[0]);
-            if (source is ShapedQueryExpression shapedQueryExpression)
-            {
-                var genericMethod = method.IsGenericMethod ? method.GetGenericMethodDefinition() : null;
-                switch (method.Name)
-                {
-                    case nameof(RelationalQueryableExtensions.ExecuteDelete)
-                        when genericMethod == RelationalQueryableExtensions.ExecuteDeleteMethodInfo:
-                        return TranslateExecuteDelete(shapedQueryExpression)
-                            ?? throw new InvalidOperationException(
-                                RelationalStrings.NonQueryTranslationFailedWithDetails(
-                                    methodCallExpression.Print(), TranslationErrorDetails));
-
-                    case nameof(RelationalQueryableExtensions.ExecuteUpdate)
-                        when genericMethod == RelationalQueryableExtensions.ExecuteUpdateMethodInfo:
-                        return TranslateExecuteUpdate(shapedQueryExpression, methodCallExpression.Arguments[1].UnwrapLambdaFromQuote())
-                            ?? throw new InvalidOperationException(
-                                RelationalStrings.NonQueryTranslationFailedWithDetails(
-                                    methodCallExpression.Print(), TranslationErrorDetails));
-                }
-            }
-        }
-
         var translated = base.VisitMethodCall(methodCallExpression);
 
         // For Contains over a collection parameter, if the provider hasn't implemented TranslateCollection (e.g. OPENJSON on SQL
diff --git a/src/EFCore.SqlServer/Query/Internal/SqlServerQuerySqlGenerator.cs b/src/EFCore.SqlServer/Query/Internal/SqlServerQuerySqlGenerator.cs
index 717d31dad4..b33dac3340 100644
--- a/src/EFCore.SqlServer/Query/Internal/SqlServerQuerySqlGenerator.cs
+++ b/src/EFCore.SqlServer/Query/Internal/SqlServerQuerySqlGenerator.cs
@@ -95,7 +95,8 @@ protected override Expression VisitDelete(DeleteExpression deleteExpression)
         }
 
         throw new InvalidOperationException(
-            RelationalStrings.ExecuteOperationWithUnsupportedOperatorInSqlGeneration(nameof(RelationalQueryableExtensions.ExecuteDelete)));
+            RelationalStrings.ExecuteOperationWithUnsupportedOperatorInSqlGeneration(
+                nameof(EntityFrameworkQueryableExtensions.ExecuteDelete)));
     }
 
     /// <summary>
@@ -169,7 +170,8 @@ protected override Expression VisitUpdate(UpdateExpression updateExpression)
         }
 
         throw new InvalidOperationException(
-            RelationalStrings.ExecuteOperationWithUnsupportedOperatorInSqlGeneration(nameof(RelationalQueryableExtensions.ExecuteUpdate)));
+            RelationalStrings.ExecuteOperationWithUnsupportedOperatorInSqlGeneration(
+                nameof(EntityFrameworkQueryableExtensions.ExecuteUpdate)));
     }
 
     /// <summary>
diff --git a/src/EFCore/Extensions/EntityFrameworkQueryableExtensions.cs b/src/EFCore/Extensions/EntityFrameworkQueryableExtensions.cs
index 3dbcaed6b2..665b828fbe 100644
--- a/src/EFCore/Extensions/EntityFrameworkQueryableExtensions.cs
+++ b/src/EFCore/Extensions/EntityFrameworkQueryableExtensions.cs
@@ -2912,8 +2912,8 @@ IEnumerator IEnumerable.GetEnumerator()
     /// </exception>
     public static IQueryable<T> TagWithCallSite<T>(
         this IQueryable<T> source,
-        [NotParameterized][CallerFilePath] string? filePath = null,
-        [NotParameterized][CallerLineNumber] int lineNumber = 0)
+        [NotParameterized] [CallerFilePath] string? filePath = null,
+        [NotParameterized] [CallerLineNumber] int lineNumber = 0)
         => source.Provider is EntityQueryProvider
             ? source.Provider.CreateQuery<T>(
                 Expression.Call(
@@ -3266,4 +3266,115 @@ await foreach (var element in source.AsAsyncEnumerable().WithCancellation(cancel
             operatorMethodInfo, source, (Expression?)null, cancellationToken);
 
     #endregion
+
+    #region ExecuteDelete
+
+    /// <summary>
+    ///     Deletes all database rows for the entity instances which match the LINQ query from the database.
+    /// </summary>
+    /// <remarks>
+    ///     <para>
+    ///         This operation executes immediately against the database, rather than being deferred until
+    ///         <see cref="DbContext.SaveChanges()" /> is called. It also does not interact with the EF change tracker in any way:
+    ///         entity instances which happen to be tracked when this operation is invoked aren't taken into account, and aren't updated
+    ///         to reflect the changes.
+    ///     </para>
+    ///     <para>
+    ///         See <see href="https://aka.ms/efcore-docs-bulk-operations">Executing bulk operations with EF Core</see>
+    ///         for more information and examples.
+    ///     </para>
+    /// </remarks>
+    /// <param name="source">The source query.</param>
+    /// <returns>The total number of rows deleted in the database.</returns>
+    public static int ExecuteDelete<TSource>(this IQueryable<TSource> source)
+        => source.Provider.Execute<int>(Expression.Call(ExecuteDeleteMethodInfo.MakeGenericMethod(typeof(TSource)), source.Expression));
+
+    /// <summary>
+    ///     Asynchronously deletes database rows for the entity instances which match the LINQ query from the database.
+    /// </summary>
+    /// <remarks>
+    ///     <para>
+    ///         This operation executes immediately against the database, rather than being deferred until
+    ///         <see cref="DbContext.SaveChanges()" /> is called. It also does not interact with the EF change tracker in any way:
+    ///         entity instances which happen to be tracked when this operation is invoked aren't taken into account, and aren't updated
+    ///         to reflect the changes.
+    ///     </para>
+    ///     <para>
+    ///         See <see href="https://aka.ms/efcore-docs-bulk-operations">Executing bulk operations with EF Core</see>
+    ///         for more information and examples.
+    ///     </para>
+    /// </remarks>
+    /// <param name="source">The source query.</param>
+    /// <param name="cancellationToken">A <see cref="CancellationToken" /> to observe while waiting for the task to complete.</param>
+    /// <returns>The total number of rows deleted in the database.</returns>
+    public static Task<int> ExecuteDeleteAsync<TSource>(this IQueryable<TSource> source, CancellationToken cancellationToken = default)
+        => source.Provider is IAsyncQueryProvider provider
+            ? provider.ExecuteAsync<Task<int>>(
+                Expression.Call(ExecuteDeleteMethodInfo.MakeGenericMethod(typeof(TSource)), source.Expression), cancellationToken)
+            : throw new InvalidOperationException(CoreStrings.IQueryableProviderNotAsync);
+
+    internal static readonly MethodInfo ExecuteDeleteMethodInfo
+        = typeof(EntityFrameworkQueryableExtensions).GetTypeInfo().GetDeclaredMethod(nameof(ExecuteDelete))!;
+
+    #endregion
+
+    #region ExecuteUpdate
+
+    /// <summary>
+    ///     Updates all database rows for the entity instances which match the LINQ query from the database.
+    /// </summary>
+    /// <remarks>
+    ///     <para>
+    ///         This operation executes immediately against the database, rather than being deferred until
+    ///         <see cref="DbContext.SaveChanges()" /> is called. It also does not interact with the EF change tracker in any way:
+    ///         entity instances which happen to be tracked when this operation is invoked aren't taken into account, and aren't updated
+    ///         to reflect the changes.
+    ///     </para>
+    ///     <para>
+    ///         See <see href="https://aka.ms/efcore-docs-bulk-operations">Executing bulk operations with EF Core</see>
+    ///         for more information and examples.
+    ///     </para>
+    /// </remarks>
+    /// <param name="source">The source query.</param>
+    /// <param name="setPropertyCalls">A collection of set property statements specifying properties to update.</param>
+    /// <returns>The total number of rows updated in the database.</returns>
+    public static int ExecuteUpdate<TSource>(
+        this IQueryable<TSource> source,
+        Expression<Func<SetPropertyCalls<TSource>, SetPropertyCalls<TSource>>> setPropertyCalls)
+        => source.Provider.Execute<int>(
+            Expression.Call(ExecuteUpdateMethodInfo.MakeGenericMethod(typeof(TSource)), source.Expression, setPropertyCalls));
+
+    /// <summary>
+    ///     Asynchronously updates database rows for the entity instances which match the LINQ query from the database.
+    /// </summary>
+    /// <remarks>
+    ///     <para>
+    ///         This operation executes immediately against the database, rather than being deferred until
+    ///         <see cref="DbContext.SaveChanges()" /> is called. It also does not interact with the EF change tracker in any way:
+    ///         entity instances which happen to be tracked when this operation is invoked aren't taken into account, and aren't updated
+    ///         to reflect the changes.
+    ///     </para>
+    ///     <para>
+    ///         See <see href="https://aka.ms/efcore-docs-bulk-operations">Executing bulk operations with EF Core</see>
+    ///         for more information and examples.
+    ///     </para>
+    /// </remarks>
+    /// <param name="source">The source query.</param>
+    /// <param name="setPropertyCalls">A collection of set property statements specifying properties to update.</param>
+    /// <param name="cancellationToken">A <see cref="CancellationToken" /> to observe while waiting for the task to complete.</param>
+    /// <returns>The total number of rows updated in the database.</returns>
+    public static Task<int> ExecuteUpdateAsync<TSource>(
+        this IQueryable<TSource> source,
+        Expression<Func<SetPropertyCalls<TSource>, SetPropertyCalls<TSource>>> setPropertyCalls,
+        CancellationToken cancellationToken = default)
+        => source.Provider is IAsyncQueryProvider provider
+            ? provider.ExecuteAsync<Task<int>>(
+                Expression.Call(
+                    ExecuteUpdateMethodInfo.MakeGenericMethod(typeof(TSource)), source.Expression, setPropertyCalls), cancellationToken)
+            : throw new InvalidOperationException(CoreStrings.IQueryableProviderNotAsync);
+
+    internal static readonly MethodInfo ExecuteUpdateMethodInfo
+        = typeof(EntityFrameworkQueryableExtensions).GetTypeInfo().GetDeclaredMethod(nameof(ExecuteUpdate))!;
+
+    #endregion
 }
diff --git a/src/EFCore/Properties/CoreStrings.Designer.cs b/src/EFCore/Properties/CoreStrings.Designer.cs
index 317fe454ff..d190abe69e 100644
--- a/src/EFCore/Properties/CoreStrings.Designer.cs
+++ b/src/EFCore/Properties/CoreStrings.Designer.cs
@@ -1140,6 +1140,14 @@ public static string ErrorMaterializingPropertyInvalidCast(object? entityType, o
                 GetString("ErrorMaterializingPropertyInvalidCast", nameof(entityType), nameof(property), nameof(expectedType), nameof(actualType)),
                 entityType, property, expectedType, actualType);
 
+        /// <summary>
+        ///     The methods '{methodName}' and '{asyncMethodName}' are not supported by the current database provider. Please contact the publisher of the database provider for more information.
+        /// </summary>
+        public static string ExecuteQueriesNotSupported(object? methodName, object? asyncMethodName)
+            => string.Format(
+                GetString("ExecuteQueriesNotSupported", nameof(methodName), nameof(asyncMethodName)),
+                methodName, asyncMethodName);
+
         /// <summary>
         ///     The configured execution strategy '{strategy}' does not support user-initiated transactions. Use the execution strategy returned by '{getExecutionStrategyMethod}' to execute all the operations in the transaction as a retriable unit.
         /// </summary>
@@ -2137,6 +2145,14 @@ public static string NonIndexerEntityType(object? property, object? entityType,
                 GetString("NonIndexerEntityType", nameof(property), nameof(entityType), nameof(type)),
                 property, entityType, type);
 
+        /// <summary>
+        ///     The LINQ expression '{expression}' could not be translated. Additional information: {details} See https://go.microsoft.com/fwlink/?linkid=2101038 for more information.
+        /// </summary>
+        public static string NonQueryTranslationFailedWithDetails(object? expression, object? details)
+            => string.Format(
+                GetString("NonQueryTranslationFailedWithDetails", nameof(expression), nameof(details)),
+                expression, details);
+
         /// <summary>
         ///     The collection type '{2_collectionType}' being used for navigation '{1_entityType}.{0_navigation}' does not implement 'INotifyCollectionChanged'. Any entity type configured to use the '{changeTrackingStrategy}' change tracking strategy must use collections that implement 'INotifyCollectionChanged'. Consider using 'ObservableCollection&lt;T&gt;' for this.
         /// </summary>
@@ -2907,6 +2923,12 @@ public static string ServiceProviderConfigRemoved(object? key)
         public static string SetOperationWithDifferentIncludesInOperands
             => GetString("SetOperationWithDifferentIncludesInOperands");
 
+        /// <summary>
+        ///     The SetProperty&lt;TProperty&gt; method can only be used within 'ExecuteUpdate' method.
+        /// </summary>
+        public static string SetPropertyMethodInvoked
+            => GetString("SetPropertyMethodInvoked");
+
         /// <summary>
         ///     The shared-type entity type '{entityType}' cannot have a base type.
         /// </summary>
diff --git a/src/EFCore/Properties/CoreStrings.resx b/src/EFCore/Properties/CoreStrings.resx
index eb2d6b4c5a..d271b9fec1 100644
--- a/src/EFCore/Properties/CoreStrings.resx
+++ b/src/EFCore/Properties/CoreStrings.resx
@@ -546,6 +546,9 @@
   <data name="ErrorMaterializingPropertyInvalidCast" xml:space="preserve">
     <value>An error occurred while reading a database value for property '{entityType}.{property}'. The expected type was '{expectedType}' but the actual value was of type '{actualType}'.</value>
   </data>
+  <data name="ExecuteQueriesNotSupported" xml:space="preserve">
+    <value>The methods '{methodName}' and '{asyncMethodName}' are not supported by the current database provider. Please contact the publisher of the database provider for more information. </value>
+  </data>
   <data name="ExecutionStrategyExistingTransaction" xml:space="preserve">
     <value>The configured execution strategy '{strategy}' does not support user-initiated transactions. Use the execution strategy returned by '{getExecutionStrategyMethod}' to execute all the operations in the transaction as a retriable unit.</value>
   </data>
@@ -1258,6 +1261,9 @@
   <data name="NonNotifyingCollection" xml:space="preserve">
     <value>The collection type '{2_collectionType}' being used for navigation '{1_entityType}.{0_navigation}' does not implement 'INotifyCollectionChanged'. Any entity type configured to use the '{changeTrackingStrategy}' change tracking strategy must use collections that implement 'INotifyCollectionChanged'. Consider using 'ObservableCollection&lt;T&gt;' for this.</value>
   </data>
+  <data name="NonQueryTranslationFailedWithDetails" xml:space="preserve">
+    <value>The LINQ expression '{expression}' could not be translated. Additional information: {details} See https://go.microsoft.com/fwlink/?linkid=2101038 for more information.</value>
+  </data>
   <data name="NonUniqueRequiredDependentForeignKey" xml:space="preserve">
     <value>The foreign key {foreignKeyProperties} on the entity type '{declaringEntityType}' cannot have a required dependent end since it is not unique.</value>
   </data>
@@ -1558,6 +1564,9 @@
   <data name="SetOperationWithDifferentIncludesInOperands" xml:space="preserve">
     <value>Unable to translate set operation since both operands have different 'Include' operations. Consider having same 'Include' applied on both sides.</value>
   </data>
+  <data name="SetPropertyMethodInvoked" xml:space="preserve">
+    <value>The SetProperty&lt;TProperty&gt; method can only be used within 'ExecuteUpdate' method.</value>
+  </data>
   <data name="SharedTypeDerivedType" xml:space="preserve">
     <value>The shared-type entity type '{entityType}' cannot have a base type.</value>
   </data>
diff --git a/src/EFCore/Query/Internal/NavigationExpandingExpressionVisitor.cs b/src/EFCore/Query/Internal/NavigationExpandingExpressionVisitor.cs
index 45b85cf096..f7e8de8764 100644
--- a/src/EFCore/Query/Internal/NavigationExpandingExpressionVisitor.cs
+++ b/src/EFCore/Query/Internal/NavigationExpandingExpressionVisitor.cs
@@ -555,6 +555,13 @@ protected override Expression VisitMethodCall(MethodCallExpression methodCallExp
                             thenInclude: false,
                             setLoaded: false);
 
+                    // Handled by relational/provider even though method is on `EntityFrameworkQueryableExtensions`
+                    case nameof(EntityFrameworkQueryableExtensions.ExecuteDelete):
+                    case nameof(EntityFrameworkQueryableExtensions.ExecuteDeleteAsync):
+                    case nameof(EntityFrameworkQueryableExtensions.ExecuteUpdate):
+                    case nameof(EntityFrameworkQueryableExtensions.ExecuteUpdateAsync):
+                        return ProcessUnknownMethod(methodCallExpression);
+
                     case nameof(Queryable.GroupBy)
                         when genericMethod == QueryableMethods.GroupByWithKeySelector:
                         return ProcessGroupBy(
diff --git a/src/EFCore/Query/QueryableMethodTranslatingExpressionVisitor.cs b/src/EFCore/Query/QueryableMethodTranslatingExpressionVisitor.cs
index 7f48d4d655..4b33dfe631 100644
--- a/src/EFCore/Query/QueryableMethodTranslatingExpressionVisitor.cs
+++ b/src/EFCore/Query/QueryableMethodTranslatingExpressionVisitor.cs
@@ -138,6 +138,32 @@ protected override Expression VisitExtension(Expression extensionExpression)
     protected override Expression VisitMethodCall(MethodCallExpression methodCallExpression)
     {
         var method = methodCallExpression.Method;
+
+        if (method.DeclaringType == typeof(EntityFrameworkQueryableExtensions))
+        {
+            var source = Visit(methodCallExpression.Arguments[0]);
+            if (source is ShapedQueryExpression shapedQueryExpression)
+            {
+                var genericMethod = method.IsGenericMethod ? method.GetGenericMethodDefinition() : null;
+                switch (method.Name)
+                {
+                    case nameof(EntityFrameworkQueryableExtensions.ExecuteDelete)
+                        when genericMethod == EntityFrameworkQueryableExtensions.ExecuteDeleteMethodInfo:
+                        return TranslateExecuteDelete(shapedQueryExpression)
+                            ?? throw new InvalidOperationException(
+                                CoreStrings.NonQueryTranslationFailedWithDetails(
+                                    methodCallExpression.Print(), TranslationErrorDetails));
+
+                    case nameof(EntityFrameworkQueryableExtensions.ExecuteUpdate)
+                        when genericMethod == EntityFrameworkQueryableExtensions.ExecuteUpdateMethodInfo:
+                        return TranslateExecuteUpdate(shapedQueryExpression, methodCallExpression.Arguments[1].UnwrapLambdaFromQuote())
+                            ?? throw new InvalidOperationException(
+                                CoreStrings.NonQueryTranslationFailedWithDetails(
+                                    methodCallExpression.Print(), TranslationErrorDetails));
+                }
+            }
+        }
+
         if (method.DeclaringType == typeof(Queryable)
             || method.DeclaringType == typeof(QueryableExtensions))
         {
@@ -1000,4 +1026,39 @@ protected virtual Expression MarkShaperNullable(Expression shaperExpression)
         => null;
 
     #endregion Queryable collection support
+
+    #region ExecuteUpdate/ExecuteDelete
+
+    /// <summary>
+    ///     Translates <see cref="EntityFrameworkQueryableExtensions.ExecuteDelete{TSource}(IQueryable{TSource})" /> method
+    ///     over the given source.
+    /// </summary>
+    /// <param name="source">The shaped query on which the operator is applied.</param>
+    /// <returns>The non query after translation.</returns>
+    protected virtual Expression? TranslateExecuteDelete(ShapedQueryExpression source)
+        => throw new InvalidOperationException(
+            CoreStrings.ExecuteQueriesNotSupported(
+                nameof(EntityFrameworkQueryableExtensions.ExecuteDelete), nameof(EntityFrameworkQueryableExtensions.ExecuteDeleteAsync)));
+
+    /// <summary>
+    ///     Translates
+    ///     <see
+    ///         cref="EntityFrameworkQueryableExtensions.ExecuteUpdate{TSource}(IQueryable{TSource}, Expression{Func{SetPropertyCalls{TSource}, SetPropertyCalls{TSource}}})" />
+    ///     method
+    ///     over the given source.
+    /// </summary>
+    /// <param name="source">The shaped query on which the operator is applied.</param>
+    /// <param name="setPropertyCalls">
+    ///     The lambda expression containing
+    ///     <see
+    ///         cref="SetPropertyCalls{TSource}.SetProperty{TProperty}(Func{TSource, TProperty}, Func{TSource, TProperty})" />
+    ///     statements.
+    /// </param>
+    /// <returns>The non query after translation.</returns>
+    protected virtual Expression? TranslateExecuteUpdate(ShapedQueryExpression source, LambdaExpression setPropertyCalls)
+        => throw new InvalidOperationException(
+            CoreStrings.ExecuteQueriesNotSupported(
+                nameof(EntityFrameworkQueryableExtensions.ExecuteUpdate), nameof(EntityFrameworkQueryableExtensions.ExecuteUpdateAsync)));
+
+    #endregion ExecuteUpdate/ExecuteDelete
 }
diff --git a/src/EFCore.Relational/Query/SetPropertyCalls.cs b/src/EFCore/Query/SetPropertyCalls.cs
similarity index 95%
rename from src/EFCore.Relational/Query/SetPropertyCalls.cs
rename to src/EFCore/Query/SetPropertyCalls.cs
index 6508452059..d525aa8184 100644
--- a/src/EFCore.Relational/Query/SetPropertyCalls.cs
+++ b/src/EFCore/Query/SetPropertyCalls.cs
@@ -40,7 +40,7 @@ private SetPropertyCalls()
     public SetPropertyCalls<TSource> SetProperty<TProperty>(
         Func<TSource, TProperty> propertyExpression,
         Func<TSource, TProperty> valueExpression)
-        => throw new InvalidOperationException(RelationalStrings.SetPropertyMethodInvoked);
+        => throw new InvalidOperationException(CoreStrings.SetPropertyMethodInvoked);
 
     /// <summary>
     ///     Specifies a property and corresponding value it should be updated to in ExecuteUpdate method.
@@ -55,7 +55,7 @@ private SetPropertyCalls()
     public SetPropertyCalls<TSource> SetProperty<TProperty>(
         Func<TSource, TProperty> propertyExpression,
         TProperty valueExpression)
-        => throw new InvalidOperationException(RelationalStrings.SetPropertyMethodInvoked);
+        => throw new InvalidOperationException(CoreStrings.SetPropertyMethodInvoked);
 
     #region Hidden System.Object members
 
diff --git a/test/EFCore.InMemory.FunctionalTests/InMemoryComplianceTest.cs b/test/EFCore.InMemory.FunctionalTests/InMemoryComplianceTest.cs
index 666a22e8a8..51e6af0b2a 100644
--- a/test/EFCore.InMemory.FunctionalTests/InMemoryComplianceTest.cs
+++ b/test/EFCore.InMemory.FunctionalTests/InMemoryComplianceTest.cs
@@ -1,6 +1,8 @@
 ï»¿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using Microsoft.EntityFrameworkCore.BulkUpdates;
+
 namespace Microsoft.EntityFrameworkCore;
 
 public class InMemoryComplianceTest : ComplianceTestBase
@@ -16,6 +18,12 @@ public class InMemoryComplianceTest : ComplianceTestBase
         typeof(StoreGeneratedTestBase<>),
         typeof(ConferencePlannerTestBase<>),
         typeof(ManyToManyQueryTestBase<>),
+        typeof(ComplexTypeBulkUpdatesTestBase<>),
+        typeof(BulkUpdatesTestBase<>),
+        typeof(FiltersInheritanceBulkUpdatesTestBase<>),
+        typeof(InheritanceBulkUpdatesTestBase<>),
+        typeof(NonSharedModelBulkUpdatesTestBase),
+        typeof(NorthwindBulkUpdatesTestBase<>),
     };
 
     protected override Assembly TargetAssembly { get; } = typeof(InMemoryComplianceTest).Assembly;
diff --git a/test/EFCore.Relational.Specification.Tests/BulkUpdates/ComplexTypeBulkUpdatesRelationalFixtureBase.cs b/test/EFCore.Relational.Specification.Tests/BulkUpdates/ComplexTypeBulkUpdatesRelationalFixtureBase.cs
new file mode 100644
index 0000000000..8337d339a0
--- /dev/null
+++ b/test/EFCore.Relational.Specification.Tests/BulkUpdates/ComplexTypeBulkUpdatesRelationalFixtureBase.cs
@@ -0,0 +1,26 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.EntityFrameworkCore.BulkUpdates;
+
+#nullable disable
+
+public abstract class ComplexTypeBulkUpdatesRelationalFixtureBase : ComplexTypeBulkUpdatesFixtureBase, ITestSqlLoggerFactory
+{
+    public override void UseTransaction(DatabaseFacade facade, IDbContextTransaction transaction)
+        => facade.UseTransaction(transaction.GetDbTransaction());
+
+    public new RelationalTestStore TestStore
+        => (RelationalTestStore)base.TestStore;
+
+    public TestSqlLoggerFactory TestSqlLoggerFactory
+        => (TestSqlLoggerFactory)ListLoggerFactory;
+
+    public override DbContextOptionsBuilder AddOptions(DbContextOptionsBuilder builder)
+        => base.AddOptions(builder).ConfigureWarnings(
+                c => c.Log(RelationalEventId.QueryPossibleUnintendedUseOfEqualsWarning))
+            .EnableDetailedErrors();
+
+    protected override bool ShouldLogCategory(string logCategory)
+        => logCategory == DbLoggerCategory.Query.Name;
+}
diff --git a/test/EFCore.Relational.Specification.Tests/BulkUpdates/ComplexTypeBulkUpdatesRelationalTestBase.cs b/test/EFCore.Relational.Specification.Tests/BulkUpdates/ComplexTypeBulkUpdatesRelationalTestBase.cs
new file mode 100644
index 0000000000..72edb03335
--- /dev/null
+++ b/test/EFCore.Relational.Specification.Tests/BulkUpdates/ComplexTypeBulkUpdatesRelationalTestBase.cs
@@ -0,0 +1,35 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.EntityFrameworkCore.BulkUpdates;
+
+#nullable disable
+
+public abstract class ComplexTypeBulkUpdatesRelationalTestBase<TFixture> : ComplexTypeBulkUpdatesTestBase<TFixture>
+    where TFixture : ComplexTypeBulkUpdatesRelationalFixtureBase, new()
+{
+    protected ComplexTypeBulkUpdatesRelationalTestBase(TFixture fixture, ITestOutputHelper testOutputHelper)
+        : base(fixture)
+    {
+        ClearLog();
+        Fixture.TestSqlLoggerFactory.SetTestOutputHelper(testOutputHelper);
+    }
+
+    public override Task Delete_complex_type(bool async)
+        => AssertTranslationFailed(
+            RelationalStrings.ExecuteDeleteOnNonEntityType,
+            () => base.Delete_complex_type(async));
+
+    public override Task Update_projected_complex_type_via_OrderBy_Skip(bool async)
+        => AssertTranslationFailed(
+            RelationalStrings.ExecuteUpdateSubqueryNotSupportedOverComplexTypes("Customer.ShippingAddress#Address"),
+            () => base.Update_projected_complex_type_via_OrderBy_Skip(async));
+
+    protected static async Task AssertTranslationFailed(string details, Func<Task> query)
+        => Assert.Contains(
+            CoreStrings.NonQueryTranslationFailedWithDetails("", details)[21..],
+            (await Assert.ThrowsAsync<InvalidOperationException>(query)).Message);
+
+    private void ClearLog()
+        => Fixture.TestSqlLoggerFactory.Clear();
+}
diff --git a/test/EFCore.Relational.Specification.Tests/BulkUpdates/FiltersInheritanceBulkUpdatesRelationalTestBase.cs b/test/EFCore.Relational.Specification.Tests/BulkUpdates/FiltersInheritanceBulkUpdatesRelationalTestBase.cs
new file mode 100644
index 0000000000..ca28343d38
--- /dev/null
+++ b/test/EFCore.Relational.Specification.Tests/BulkUpdates/FiltersInheritanceBulkUpdatesRelationalTestBase.cs
@@ -0,0 +1,48 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.EntityFrameworkCore.TestModels.InheritanceModel;
+
+namespace Microsoft.EntityFrameworkCore.BulkUpdates;
+
+#nullable disable
+
+public abstract class FiltersInheritanceBulkUpdatesRelationalTestBase<TFixture> : FiltersInheritanceBulkUpdatesTestBase<TFixture>
+    where TFixture : InheritanceBulkUpdatesRelationalFixtureBase, new()
+{
+    protected FiltersInheritanceBulkUpdatesRelationalTestBase(TFixture fixture, ITestOutputHelper testOutputHelper)
+        : base(fixture)
+    {
+        ClearLog();
+        Fixture.TestSqlLoggerFactory.SetTestOutputHelper(testOutputHelper);
+    }
+
+    [ConditionalTheory]
+    [MemberData(nameof(IsAsyncData))]
+    public virtual Task Delete_where_keyless_entity_mapped_to_sql_query(bool async)
+        => AssertTranslationFailed(
+            RelationalStrings.ExecuteOperationOnKeylessEntityTypeWithUnsupportedOperator("ExecuteDelete", "EagleQuery"),
+            () => AssertDelete(
+                async,
+                ss => ss.Set<EagleQuery>().Where(e => e.CountryId > 0),
+                rowsAffectedCount: 1));
+
+    [ConditionalTheory]
+    [MemberData(nameof(IsAsyncData))]
+    public virtual Task Update_where_keyless_entity_mapped_to_sql_query(bool async)
+        => AssertTranslationFailed(
+            RelationalStrings.ExecuteOperationOnKeylessEntityTypeWithUnsupportedOperator("ExecuteUpdate", "EagleQuery"),
+            () => AssertUpdate(
+                async,
+                ss => ss.Set<EagleQuery>().Where(e => e.CountryId > 0),
+                e => e,
+                s => s.SetProperty(e => e.Name, "Eagle"),
+                rowsAffectedCount: 1));
+
+    protected static async Task AssertTranslationFailed(string details, Func<Task> query)
+        => Assert.Contains(
+            CoreStrings.NonQueryTranslationFailedWithDetails("", details)[21..],
+            (await Assert.ThrowsAsync<InvalidOperationException>(query)).Message);
+
+    protected abstract void ClearLog();
+}
diff --git a/test/EFCore.Relational.Specification.Tests/BulkUpdates/InheritanceBulkUpdatesRelationalFixtureBase.cs b/test/EFCore.Relational.Specification.Tests/BulkUpdates/InheritanceBulkUpdatesRelationalFixtureBase.cs
new file mode 100644
index 0000000000..8517405afb
--- /dev/null
+++ b/test/EFCore.Relational.Specification.Tests/BulkUpdates/InheritanceBulkUpdatesRelationalFixtureBase.cs
@@ -0,0 +1,26 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.EntityFrameworkCore.BulkUpdates;
+
+#nullable disable
+
+public abstract class InheritanceBulkUpdatesRelationalFixtureBase : InheritanceBulkUpdatesFixtureBase, ITestSqlLoggerFactory
+{
+    public override void UseTransaction(DatabaseFacade facade, IDbContextTransaction transaction)
+        => facade.UseTransaction(transaction.GetDbTransaction());
+
+    public new RelationalTestStore TestStore
+        => (RelationalTestStore)base.TestStore;
+
+    public TestSqlLoggerFactory TestSqlLoggerFactory
+        => (TestSqlLoggerFactory)ListLoggerFactory;
+
+    public override DbContextOptionsBuilder AddOptions(DbContextOptionsBuilder builder)
+        => base.AddOptions(builder).ConfigureWarnings(
+                c => c.Log(RelationalEventId.QueryPossibleUnintendedUseOfEqualsWarning))
+            .EnableDetailedErrors();
+
+    protected override bool ShouldLogCategory(string logCategory)
+        => logCategory == DbLoggerCategory.Query.Name;
+}
diff --git a/test/EFCore.Relational.Specification.Tests/BulkUpdates/InheritanceBulkUpdatesRelationalTestBase.cs b/test/EFCore.Relational.Specification.Tests/BulkUpdates/InheritanceBulkUpdatesRelationalTestBase.cs
new file mode 100644
index 0000000000..5e0856e869
--- /dev/null
+++ b/test/EFCore.Relational.Specification.Tests/BulkUpdates/InheritanceBulkUpdatesRelationalTestBase.cs
@@ -0,0 +1,49 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.EntityFrameworkCore.TestModels.InheritanceModel;
+
+namespace Microsoft.EntityFrameworkCore.BulkUpdates;
+
+#nullable disable
+
+public abstract class InheritanceBulkUpdatesRelationalTestBase<TFixture> : InheritanceBulkUpdatesTestBase<TFixture>
+    where TFixture : InheritanceBulkUpdatesRelationalFixtureBase, new()
+{
+    protected InheritanceBulkUpdatesRelationalTestBase(TFixture fixture, ITestOutputHelper testOutputHelper)
+        : base(fixture)
+    {
+        ClearLog();
+        Fixture.TestSqlLoggerFactory.SetTestOutputHelper(testOutputHelper);
+    }
+
+    [ConditionalTheory]
+    [MemberData(nameof(IsAsyncData))]
+    public virtual Task Delete_where_keyless_entity_mapped_to_sql_query(bool async)
+        => AssertTranslationFailed(
+            RelationalStrings.ExecuteOperationOnKeylessEntityTypeWithUnsupportedOperator("ExecuteDelete", "EagleQuery"),
+            () => AssertDelete(
+                async,
+                ss => ss.Set<EagleQuery>().Where(e => e.CountryId > 0),
+                rowsAffectedCount: 1));
+
+    [ConditionalTheory]
+    [MemberData(nameof(IsAsyncData))]
+    public virtual Task Update_where_keyless_entity_mapped_to_sql_query(bool async)
+        => AssertTranslationFailed(
+            RelationalStrings.ExecuteOperationOnKeylessEntityTypeWithUnsupportedOperator("ExecuteUpdate", "EagleQuery"),
+            () => AssertUpdate(
+                async,
+                ss => ss.Set<EagleQuery>().Where(e => e.CountryId > 0),
+                e => e,
+                s => s.SetProperty(e => e.Name, "Eagle"),
+                rowsAffectedCount: 1));
+
+    protected static async Task AssertTranslationFailed(string details, Func<Task> query)
+        => Assert.Contains(
+            CoreStrings.NonQueryTranslationFailedWithDetails("", details)[21..],
+            (await Assert.ThrowsAsync<InvalidOperationException>(query)).Message);
+
+    protected virtual void ClearLog()
+        => Fixture.TestSqlLoggerFactory.Clear();
+}
diff --git a/test/EFCore.Relational.Specification.Tests/BulkUpdates/NonSharedModelBulkUpdatesRelationalTestBase.cs b/test/EFCore.Relational.Specification.Tests/BulkUpdates/NonSharedModelBulkUpdatesRelationalTestBase.cs
new file mode 100644
index 0000000000..c3dc5ad63d
--- /dev/null
+++ b/test/EFCore.Relational.Specification.Tests/BulkUpdates/NonSharedModelBulkUpdatesRelationalTestBase.cs
@@ -0,0 +1,104 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.EntityFrameworkCore.BulkUpdates;
+
+#nullable disable
+
+public abstract class NonSharedModelBulkUpdatesRelationalTestBase : NonSharedModelBulkUpdatesTestBase
+{
+    protected override string StoreName
+        => "NonSharedModelBulkUpdatesTests";
+
+    [ConditionalTheory]
+    [MemberData(nameof(IsAsyncData))]
+    public virtual async Task Delete_aggregate_root_when_table_sharing_with_non_owned_throws(bool async)
+    {
+        var contextFactory = await InitializeAsync<Context28671>(
+            onModelCreating: mb =>
+            {
+                mb.Entity<Owner>().HasOne<OtherReference>().WithOne().HasForeignKey<OtherReference>(e => e.Id);
+                mb.Entity<OtherReference>().ToTable(nameof(Owner));
+            });
+
+        await AssertTranslationFailedWithDetails(
+            () => AssertDelete(
+                async, contextFactory.CreateContext,
+                context => context.Set<Owner>(), rowsAffectedCount: 0),
+            RelationalStrings.ExecuteDeleteOnTableSplitting(nameof(Owner)));
+    }
+    [ConditionalTheory]
+    [MemberData(nameof(IsAsyncData))]
+    public virtual async Task Update_main_table_in_entity_with_entity_splitting(bool async)
+    {
+        var contextFactory = await InitializeAsync<DbContext>(
+            onModelCreating: mb => mb.Entity<Blog>()
+                .ToTable("Blogs")
+                .SplitToTable(
+                    "BlogsPart1", tb =>
+                    {
+                        tb.Property(b => b.Title);
+                        tb.Property(b => b.Rating);
+                    }),
+            seed: async context =>
+            {
+                context.Set<Blog>().Add(new Blog { Title = "SomeBlog" });
+                await context.SaveChangesAsync();
+            });
+
+        await AssertUpdate(
+            async,
+            contextFactory.CreateContext,
+            ss => ss.Set<Blog>(),
+            s => s.SetProperty(b => b.CreationTimestamp, b => new DateTime(2020, 1, 1)),
+            rowsAffectedCount: 1);
+    }
+
+    [ConditionalTheory]
+    [MemberData(nameof(IsAsyncData))]
+    public virtual async Task Update_non_main_table_in_entity_with_entity_splitting(bool async)
+    {
+        var contextFactory = await InitializeAsync<DbContext>(
+            onModelCreating: mb => mb.Entity<Blog>()
+                .ToTable("Blogs")
+                .SplitToTable(
+                    "BlogsPart1", tb =>
+                    {
+                        tb.Property(b => b.Title);
+                        tb.Property(b => b.Rating);
+                    }),
+            seed: async context =>
+            {
+                context.Set<Blog>().Add(new Blog { Title = "SomeBlog" });
+                await context.SaveChangesAsync();
+            });
+
+        await AssertUpdate(
+            async,
+            contextFactory.CreateContext,
+            ss => ss.Set<Blog>(),
+            s => s
+                .SetProperty(b => b.Title, b => b.Rating.ToString())
+                .SetProperty(b => b.Rating, b => b.Title!.Length),
+            rowsAffectedCount: 1);
+    }
+
+    #region HelperMethods
+
+    protected static async Task AssertTranslationFailedWithDetails(Func<Task> query, string details)
+        => Assert.Contains(
+            CoreStrings.NonQueryTranslationFailedWithDetails("", details)[21..],
+            (await Assert.ThrowsAsync<InvalidOperationException>(query))
+            .Message);
+
+    public override void UseTransaction(DatabaseFacade facade, IDbContextTransaction transaction)
+        => facade.UseTransaction(transaction.GetDbTransaction());
+
+    protected TestSqlLoggerFactory TestSqlLoggerFactory
+        => (TestSqlLoggerFactory)ListLoggerFactory;
+
+    protected void ClearLog()
+        => TestSqlLoggerFactory.Clear();
+
+    #endregion
+}
diff --git a/test/EFCore.Relational.Specification.Tests/BulkUpdates/NorthwindBulkUpdatesRelationalFixture.cs b/test/EFCore.Relational.Specification.Tests/BulkUpdates/NorthwindBulkUpdatesRelationalFixture.cs
new file mode 100644
index 0000000000..3ea28305a1
--- /dev/null
+++ b/test/EFCore.Relational.Specification.Tests/BulkUpdates/NorthwindBulkUpdatesRelationalFixture.cs
@@ -0,0 +1,27 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.EntityFrameworkCore.BulkUpdates;
+
+#nullable disable
+
+public abstract class NorthwindBulkUpdatesRelationalFixture<TModelCustomizer> : NorthwindBulkUpdatesFixture<TModelCustomizer>, ITestSqlLoggerFactory
+    where TModelCustomizer : ITestModelCustomizer, new()
+{
+    public new RelationalTestStore TestStore
+        => (RelationalTestStore)base.TestStore;
+
+    public TestSqlLoggerFactory TestSqlLoggerFactory
+        => (TestSqlLoggerFactory)ListLoggerFactory;
+
+    public override DbContextOptionsBuilder AddOptions(DbContextOptionsBuilder builder)
+        => base.AddOptions(builder).ConfigureWarnings(
+                c => c.Log(RelationalEventId.QueryPossibleUnintendedUseOfEqualsWarning))
+            .EnableDetailedErrors();
+
+    protected override bool ShouldLogCategory(string logCategory)
+        => logCategory == DbLoggerCategory.Query.Name;
+
+    public override void UseTransaction(DatabaseFacade facade, IDbContextTransaction transaction)
+        => facade.UseTransaction(transaction.GetDbTransaction());
+}
diff --git a/test/EFCore.Relational.Specification.Tests/BulkUpdates/NorthwindBulkUpdatesRelationalTestBase.cs b/test/EFCore.Relational.Specification.Tests/BulkUpdates/NorthwindBulkUpdatesRelationalTestBase.cs
new file mode 100644
index 0000000000..8d19ed1b15
--- /dev/null
+++ b/test/EFCore.Relational.Specification.Tests/BulkUpdates/NorthwindBulkUpdatesRelationalTestBase.cs
@@ -0,0 +1,117 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.EntityFrameworkCore.TestModels.Northwind;
+
+namespace Microsoft.EntityFrameworkCore.BulkUpdates;
+
+#nullable disable
+
+public abstract class NorthwindBulkUpdatesRelationalTestBase<TFixture> : NorthwindBulkUpdatesTestBase<TFixture>
+    where TFixture : NorthwindBulkUpdatesRelationalFixture<NoopModelCustomizer>, new()
+{
+    protected NorthwindBulkUpdatesRelationalTestBase(TFixture fixture, ITestOutputHelper testOutputHelper)
+        : base(fixture)
+    {
+        ClearLog();
+        Fixture.TestSqlLoggerFactory.SetTestOutputHelper(testOutputHelper);
+    }
+
+    public override Task Delete_non_entity_projection(bool async)
+        => AssertTranslationFailed(
+            RelationalStrings.ExecuteDeleteOnNonEntityType,
+            () => base.Delete_non_entity_projection(async));
+
+    public override Task Delete_non_entity_projection_2(bool async)
+        => AssertTranslationFailed(
+            RelationalStrings.ExecuteDeleteOnNonEntityType,
+            () => base.Delete_non_entity_projection_2(async));
+
+    public override Task Delete_non_entity_projection_3(bool async)
+        => AssertTranslationFailed(
+            RelationalStrings.ExecuteDeleteOnNonEntityType,
+            () => base.Delete_non_entity_projection_3(async));
+
+    public virtual Task Delete_FromSql_converted_to_subquery(bool async)
+        => TestHelpers.ExecuteWithStrategyInTransactionAsync(
+            () => Fixture.CreateContext(),
+            (facade, transaction) => Fixture.UseTransaction(facade, transaction),
+            async context =>
+            {
+                var queryable = context.Set<OrderDetail>().FromSqlRaw(
+                    NormalizeDelimitersInRawString(
+                        @"SELECT [OrderID], [ProductID], [UnitPrice], [Quantity], [Discount]
+FROM [Order Details]
+WHERE [OrderID] < 10300"));
+
+                if (async)
+                {
+                    await queryable.ExecuteDeleteAsync();
+                }
+                else
+                {
+                    queryable.ExecuteDelete();
+                }
+            });
+
+    public override Task Update_without_property_to_set_throws(bool async)
+        => AssertTranslationFailed(
+            RelationalStrings.NoSetPropertyInvocation,
+            () => base.Update_without_property_to_set_throws(async));
+
+    public override Task Update_with_invalid_lambda_throws(bool async)
+        => AssertTranslationFailed(
+            RelationalStrings.InvalidArgumentToExecuteUpdate,
+            () => base.Update_with_invalid_lambda_throws(async));
+
+    public override Task Update_with_invalid_lambda_in_set_property_throws(bool async)
+        => AssertTranslationFailed(
+            RelationalStrings.InvalidPropertyInSetProperty(
+                new ExpressionPrinter().PrintExpression((OrderDetail e) => e.MaybeScalar(e => e.OrderID))),
+            () => base.Update_with_invalid_lambda_in_set_property_throws(async));
+
+    public override Task Update_multiple_tables_throws(bool async)
+        => AssertTranslationFailed(
+            RelationalStrings.MultipleTablesInExecuteUpdate("c => c.Customer.ContactName", "c => c.e.OrderDate"),
+            () => base.Update_multiple_tables_throws(async));
+
+    public override Task Update_unmapped_property_throws(bool async)
+        => AssertTranslationFailed(
+            RelationalStrings.InvalidPropertyInSetProperty("c => c.IsLondon"),
+            () => base.Update_unmapped_property_throws(async));
+
+    [ConditionalTheory]
+    [MemberData(nameof(IsAsyncData))]
+    public virtual Task Update_FromSql_set_constant(bool async)
+        => TestHelpers.ExecuteWithStrategyInTransactionAsync(
+            () => Fixture.CreateContext(),
+            (facade, transaction) => Fixture.UseTransaction(facade, transaction),
+            async context =>
+            {
+                var queryable = context.Set<Customer>().FromSqlRaw(
+                    NormalizeDelimitersInRawString(
+                        @"SELECT [Region], [PostalCode], [Phone], [Fax], [CustomerID], [Country], [ContactTitle], [ContactName], [CompanyName], [City], [Address]
+FROM [Customers]
+WHERE [CustomerID] LIKE 'A%'"));
+
+                if (async)
+                {
+                    await queryable.ExecuteUpdateAsync(s => s.SetProperty(c => c.ContactName, "Updated"));
+                }
+                else
+                {
+                    queryable.ExecuteUpdate(s => s.SetProperty(c => c.ContactName, "Updated"));
+                }
+            });
+
+    protected static async Task AssertTranslationFailed(string details, Func<Task> query)
+        => Assert.Contains(
+            CoreStrings.NonQueryTranslationFailedWithDetails("", details)[21..],
+            (await Assert.ThrowsAsync<InvalidOperationException>(query)).Message);
+
+    protected string NormalizeDelimitersInRawString(string sql)
+        => Fixture.TestStore.NormalizeDelimitersInRawString(sql);
+
+    protected virtual void ClearLog()
+        => Fixture.TestSqlLoggerFactory.Clear();
+}
diff --git a/test/EFCore.Relational.Specification.Tests/BulkUpdates/TPCFiltersInheritanceBulkUpdatesTestBase.cs b/test/EFCore.Relational.Specification.Tests/BulkUpdates/TPCFiltersInheritanceBulkUpdatesTestBase.cs
index 001f6301af..e838bdda9c 100644
--- a/test/EFCore.Relational.Specification.Tests/BulkUpdates/TPCFiltersInheritanceBulkUpdatesTestBase.cs
+++ b/test/EFCore.Relational.Specification.Tests/BulkUpdates/TPCFiltersInheritanceBulkUpdatesTestBase.cs
@@ -5,16 +5,10 @@ namespace Microsoft.EntityFrameworkCore.BulkUpdates;
 
 #nullable disable
 
-public abstract class TPCFiltersInheritanceBulkUpdatesTestBase<TFixture> : FiltersInheritanceBulkUpdatesTestBase<TFixture>
+public abstract class TPCFiltersInheritanceBulkUpdatesTestBase<TFixture>(TFixture fixture, ITestOutputHelper testOutputHelper)
+    : FiltersInheritanceBulkUpdatesRelationalTestBase<TFixture>(fixture, testOutputHelper)
     where TFixture : TPCInheritanceBulkUpdatesFixture, new()
 {
-    protected TPCFiltersInheritanceBulkUpdatesTestBase(TFixture fixture, ITestOutputHelper testOutputHelper)
-        : base(fixture)
-    {
-        ClearLog();
-        Fixture.TestSqlLoggerFactory.SetTestOutputHelper(testOutputHelper);
-    }
-
     // Keyless entities are mapped as TPH only
     public override Task Delete_where_keyless_entity_mapped_to_sql_query(bool async)
         => Task.CompletedTask;
diff --git a/test/EFCore.Relational.Specification.Tests/BulkUpdates/TPCInheritanceBulkUpdatesFixture.cs b/test/EFCore.Relational.Specification.Tests/BulkUpdates/TPCInheritanceBulkUpdatesFixture.cs
index cbcd81f436..e7d6bbbe2d 100644
--- a/test/EFCore.Relational.Specification.Tests/BulkUpdates/TPCInheritanceBulkUpdatesFixture.cs
+++ b/test/EFCore.Relational.Specification.Tests/BulkUpdates/TPCInheritanceBulkUpdatesFixture.cs
@@ -7,14 +7,11 @@ namespace Microsoft.EntityFrameworkCore.BulkUpdates;
 
 #nullable disable
 
-public abstract class TPCInheritanceBulkUpdatesFixture : InheritanceBulkUpdatesFixtureBase, ITestSqlLoggerFactory
+public abstract class TPCInheritanceBulkUpdatesFixture : InheritanceBulkUpdatesRelationalFixtureBase
 {
     protected override string StoreName
         => "TPCInheritanceBulkUpdatesTest";
 
-    public TestSqlLoggerFactory TestSqlLoggerFactory
-        => (TestSqlLoggerFactory)ListLoggerFactory;
-
     public override bool HasDiscriminator
         => false;
 
diff --git a/test/EFCore.Relational.Specification.Tests/BulkUpdates/TPCInheritanceBulkUpdatesTestBase.cs b/test/EFCore.Relational.Specification.Tests/BulkUpdates/TPCInheritanceBulkUpdatesTestBase.cs
index ba35a7c8dd..2a847ac5cc 100644
--- a/test/EFCore.Relational.Specification.Tests/BulkUpdates/TPCInheritanceBulkUpdatesTestBase.cs
+++ b/test/EFCore.Relational.Specification.Tests/BulkUpdates/TPCInheritanceBulkUpdatesTestBase.cs
@@ -5,11 +5,11 @@ namespace Microsoft.EntityFrameworkCore.BulkUpdates;
 
 #nullable disable
 
-public abstract class TPCInheritanceBulkUpdatesTestBase<TFixture> : InheritanceBulkUpdatesTestBase<TFixture>
+public abstract class TPCInheritanceBulkUpdatesTestBase<TFixture> : InheritanceBulkUpdatesRelationalTestBase<TFixture>
     where TFixture : TPCInheritanceBulkUpdatesFixture, new()
 {
     protected TPCInheritanceBulkUpdatesTestBase(TFixture fixture, ITestOutputHelper testOutputHelper)
-        : base(fixture)
+        : base(fixture, testOutputHelper)
     {
         ClearLog();
         Fixture.TestSqlLoggerFactory.SetTestOutputHelper(testOutputHelper);
diff --git a/test/EFCore.Relational.Specification.Tests/BulkUpdates/TPHInheritanceBulkUpdatesFixture.cs b/test/EFCore.Relational.Specification.Tests/BulkUpdates/TPHInheritanceBulkUpdatesFixture.cs
index a38b366ecd..5e0cac5e5e 100644
--- a/test/EFCore.Relational.Specification.Tests/BulkUpdates/TPHInheritanceBulkUpdatesFixture.cs
+++ b/test/EFCore.Relational.Specification.Tests/BulkUpdates/TPHInheritanceBulkUpdatesFixture.cs
@@ -7,14 +7,11 @@ namespace Microsoft.EntityFrameworkCore.BulkUpdates;
 
 #nullable disable
 
-public abstract class TPHInheritanceBulkUpdatesFixture : InheritanceBulkUpdatesFixtureBase, ITestSqlLoggerFactory
+public abstract class TPHInheritanceBulkUpdatesFixture : InheritanceBulkUpdatesRelationalFixtureBase
 {
     protected override string StoreName
         => "TPHInheritanceBulkUpdatesTest";
 
-    public TestSqlLoggerFactory TestSqlLoggerFactory
-        => (TestSqlLoggerFactory)ListLoggerFactory;
-
     // #31378
     public override bool EnableComplexTypes
         => false;
diff --git a/test/EFCore.Relational.Specification.Tests/BulkUpdates/TPHInheritanceBulkUpdatesTestBase.cs b/test/EFCore.Relational.Specification.Tests/BulkUpdates/TPHInheritanceBulkUpdatesTestBase.cs
index 5c12d13923..3069013473 100644
--- a/test/EFCore.Relational.Specification.Tests/BulkUpdates/TPHInheritanceBulkUpdatesTestBase.cs
+++ b/test/EFCore.Relational.Specification.Tests/BulkUpdates/TPHInheritanceBulkUpdatesTestBase.cs
@@ -5,11 +5,6 @@ namespace Microsoft.EntityFrameworkCore.BulkUpdates;
 
 #nullable disable
 
-public abstract class TPHInheritanceBulkUpdatesTestBase<TFixture> : InheritanceBulkUpdatesTestBase<TFixture>
-    where TFixture : InheritanceBulkUpdatesFixtureBase, new()
-{
-    protected TPHInheritanceBulkUpdatesTestBase(TFixture fixture)
-        : base(fixture)
-    {
-    }
-}
+public abstract class TPHInheritanceBulkUpdatesTestBase<TFixture>(TFixture fixture, ITestOutputHelper testOutputHelper)
+    : InheritanceBulkUpdatesRelationalTestBase<TFixture>(fixture, testOutputHelper)
+    where TFixture : InheritanceBulkUpdatesRelationalFixtureBase, new();
diff --git a/test/EFCore.Relational.Specification.Tests/BulkUpdates/TPTFiltersInheritanceBulkUpdatesTestBase.cs b/test/EFCore.Relational.Specification.Tests/BulkUpdates/TPTFiltersInheritanceBulkUpdatesTestBase.cs
index 82dff763d9..0d54fee9c1 100644
--- a/test/EFCore.Relational.Specification.Tests/BulkUpdates/TPTFiltersInheritanceBulkUpdatesTestBase.cs
+++ b/test/EFCore.Relational.Specification.Tests/BulkUpdates/TPTFiltersInheritanceBulkUpdatesTestBase.cs
@@ -5,16 +5,10 @@ namespace Microsoft.EntityFrameworkCore.BulkUpdates;
 
 #nullable disable
 
-public abstract class TPTFiltersInheritanceBulkUpdatesTestBase<TFixture> : FiltersInheritanceBulkUpdatesTestBase<TFixture>
+public abstract class TPTFiltersInheritanceBulkUpdatesTestBase<TFixture>(TFixture fixture, ITestOutputHelper testOutputHelper)
+    : FiltersInheritanceBulkUpdatesRelationalTestBase<TFixture>(fixture, testOutputHelper)
     where TFixture : TPTInheritanceBulkUpdatesFixture, new()
 {
-    protected TPTFiltersInheritanceBulkUpdatesTestBase(TFixture fixture, ITestOutputHelper testOutputHelper)
-        : base(fixture)
-    {
-        ClearLog();
-        Fixture.TestSqlLoggerFactory.SetTestOutputHelper(testOutputHelper);
-    }
-
     // Keyless entities are mapped as TPH only
     public override Task Delete_where_keyless_entity_mapped_to_sql_query(bool async)
         => Task.CompletedTask;
diff --git a/test/EFCore.Relational.Specification.Tests/BulkUpdates/TPTInheritanceBulkUpdatesFixture.cs b/test/EFCore.Relational.Specification.Tests/BulkUpdates/TPTInheritanceBulkUpdatesFixture.cs
index 98c89d228e..7a2a4795dc 100644
--- a/test/EFCore.Relational.Specification.Tests/BulkUpdates/TPTInheritanceBulkUpdatesFixture.cs
+++ b/test/EFCore.Relational.Specification.Tests/BulkUpdates/TPTInheritanceBulkUpdatesFixture.cs
@@ -7,14 +7,11 @@ namespace Microsoft.EntityFrameworkCore.BulkUpdates;
 
 #nullable disable
 
-public abstract class TPTInheritanceBulkUpdatesFixture : InheritanceBulkUpdatesFixtureBase, ITestSqlLoggerFactory
+public abstract class TPTInheritanceBulkUpdatesFixture : InheritanceBulkUpdatesRelationalFixtureBase
 {
     protected override string StoreName
         => "TPTInheritanceBulkUpdatesTest";
 
-    public TestSqlLoggerFactory TestSqlLoggerFactory
-        => (TestSqlLoggerFactory)ListLoggerFactory;
-
     public override bool HasDiscriminator
         => false;
 
diff --git a/test/EFCore.Relational.Specification.Tests/BulkUpdates/TPTInheritanceBulkUpdatesTestBase.cs b/test/EFCore.Relational.Specification.Tests/BulkUpdates/TPTInheritanceBulkUpdatesTestBase.cs
index 0d527401e3..f6a8c22ad6 100644
--- a/test/EFCore.Relational.Specification.Tests/BulkUpdates/TPTInheritanceBulkUpdatesTestBase.cs
+++ b/test/EFCore.Relational.Specification.Tests/BulkUpdates/TPTInheritanceBulkUpdatesTestBase.cs
@@ -5,11 +5,11 @@ namespace Microsoft.EntityFrameworkCore.BulkUpdates;
 
 #nullable disable
 
-public abstract class TPTInheritanceBulkUpdatesTestBase<TFixture> : InheritanceBulkUpdatesTestBase<TFixture>
+public abstract class TPTInheritanceBulkUpdatesTestBase<TFixture> : InheritanceBulkUpdatesRelationalTestBase<TFixture>
     where TFixture : TPTInheritanceBulkUpdatesFixture, new()
 {
     protected TPTInheritanceBulkUpdatesTestBase(TFixture fixture, ITestOutputHelper testOutputHelper)
-        : base(fixture)
+        : base(fixture, testOutputHelper)
     {
         Fixture.TestSqlLoggerFactory.SetTestOutputHelper(testOutputHelper);
         ClearLog();
diff --git a/test/EFCore.Relational.Specification.Tests/EntitySplittingTestBase.cs b/test/EFCore.Relational.Specification.Tests/EntitySplittingTestBase.cs
index 2303856c50..353419c20e 100644
--- a/test/EFCore.Relational.Specification.Tests/EntitySplittingTestBase.cs
+++ b/test/EFCore.Relational.Specification.Tests/EntitySplittingTestBase.cs
@@ -51,7 +51,7 @@ public virtual async Task ExecuteDelete_throws_for_entity_splitting(bool async)
             CreateContext,
             UseTransaction,
             async context => Assert.Contains(
-                RelationalStrings.NonQueryTranslationFailedWithDetails(
+                CoreStrings.NonQueryTranslationFailedWithDetails(
                     "", RelationalStrings.ExecuteOperationOnEntitySplitting("ExecuteDelete", "MeterReading"))[21..],
                 (await Assert.ThrowsAsync<InvalidOperationException>(
                     async () =>
diff --git a/test/EFCore.Relational.Specification.Tests/TableSplittingTestBase.cs b/test/EFCore.Relational.Specification.Tests/TableSplittingTestBase.cs
index 293a1cec9a..04bec022b5 100644
--- a/test/EFCore.Relational.Specification.Tests/TableSplittingTestBase.cs
+++ b/test/EFCore.Relational.Specification.Tests/TableSplittingTestBase.cs
@@ -768,7 +768,7 @@ public virtual async Task ExecuteDelete_throws_for_table_sharing(bool async)
             CreateContext,
             UseTransaction,
             async context => Assert.Contains(
-                RelationalStrings.NonQueryTranslationFailedWithDetails(
+                CoreStrings.NonQueryTranslationFailedWithDetails(
                     "", RelationalStrings.ExecuteDeleteOnTableSplitting("Vehicles"))[21..],
                 (await Assert.ThrowsAsync<InvalidOperationException>(
                     async () =>
diff --git a/test/EFCore.Relational.Specification.Tests/BulkUpdates/BulkUpdatesTestBase.cs b/test/EFCore.Specification.Tests/BulkUpdates/BulkUpdatesTestBase.cs
similarity index 84%
rename from test/EFCore.Relational.Specification.Tests/BulkUpdates/BulkUpdatesTestBase.cs
rename to test/EFCore.Specification.Tests/BulkUpdates/BulkUpdatesTestBase.cs
index f0b5d8834b..8b53b43414 100644
--- a/test/EFCore.Relational.Specification.Tests/BulkUpdates/BulkUpdatesTestBase.cs
+++ b/test/EFCore.Specification.Tests/BulkUpdates/BulkUpdatesTestBase.cs
@@ -38,9 +38,4 @@ protected virtual Expression RewriteServerQueryExpression(Expression serverQuery
         Action<IReadOnlyList<TEntity>, IReadOnlyList<TEntity>> asserter = null)
         where TResult : class
         => BulkUpdatesAsserter.AssertUpdate(async, query, entitySelector, setPropertyCalls, rowsAffectedCount, asserter);
-
-    protected static async Task AssertTranslationFailed(string details, Func<Task> query)
-        => Assert.Contains(
-            RelationalStrings.NonQueryTranslationFailedWithDetails("", details)[21..],
-            (await Assert.ThrowsAsync<InvalidOperationException>(query)).Message);
 }
diff --git a/test/EFCore.Relational.Specification.Tests/BulkUpdates/ComplexTypeBulkUpdatesFixtureBase.cs b/test/EFCore.Specification.Tests/BulkUpdates/ComplexTypeBulkUpdatesFixtureBase.cs
similarity index 63%
rename from test/EFCore.Relational.Specification.Tests/BulkUpdates/ComplexTypeBulkUpdatesFixtureBase.cs
rename to test/EFCore.Specification.Tests/BulkUpdates/ComplexTypeBulkUpdatesFixtureBase.cs
index f77cc45158..fc2c434262 100644
--- a/test/EFCore.Relational.Specification.Tests/BulkUpdates/ComplexTypeBulkUpdatesFixtureBase.cs
+++ b/test/EFCore.Specification.Tests/BulkUpdates/ComplexTypeBulkUpdatesFixtureBase.cs
@@ -5,11 +5,10 @@ namespace Microsoft.EntityFrameworkCore.BulkUpdates;
 
 #nullable disable
 
-public abstract class ComplexTypeBulkUpdatesFixtureBase : ComplexTypeQueryRelationalFixtureBase, IBulkUpdatesFixtureBase
+public abstract class ComplexTypeBulkUpdatesFixtureBase : ComplexTypeQueryFixtureBase, IBulkUpdatesFixtureBase
 {
     protected override string StoreName
         => "ComplexTypeBulkUpdatesTest";
 
-    public void UseTransaction(DatabaseFacade facade, IDbContextTransaction transaction)
-        => facade.UseTransaction(transaction.GetDbTransaction());
+    public abstract void UseTransaction(DatabaseFacade facade, IDbContextTransaction transaction);
 }
diff --git a/test/EFCore.Relational.Specification.Tests/BulkUpdates/ComplexTypeBulkUpdatesTestBase.cs b/test/EFCore.Specification.Tests/BulkUpdates/ComplexTypeBulkUpdatesTestBase.cs
similarity index 85%
rename from test/EFCore.Relational.Specification.Tests/BulkUpdates/ComplexTypeBulkUpdatesTestBase.cs
rename to test/EFCore.Specification.Tests/BulkUpdates/ComplexTypeBulkUpdatesTestBase.cs
index 10d6cda20f..9c5224e2fa 100644
--- a/test/EFCore.Relational.Specification.Tests/BulkUpdates/ComplexTypeBulkUpdatesTestBase.cs
+++ b/test/EFCore.Specification.Tests/BulkUpdates/ComplexTypeBulkUpdatesTestBase.cs
@@ -7,15 +7,26 @@ namespace Microsoft.EntityFrameworkCore.BulkUpdates;
 
 #nullable disable
 
-public abstract class ComplexTypeBulkUpdatesTestBase<TFixture> : BulkUpdatesTestBase<TFixture>
+public abstract class ComplexTypeBulkUpdatesTestBase<TFixture>(TFixture fixture) : BulkUpdatesTestBase<TFixture>(fixture)
     where TFixture : ComplexTypeBulkUpdatesFixtureBase, new()
 {
-    protected ComplexTypeBulkUpdatesTestBase(TFixture fixture, ITestOutputHelper testOutputHelper)
-        : base(fixture)
-    {
-        ClearLog();
-        Fixture.TestSqlLoggerFactory.SetTestOutputHelper(testOutputHelper);
-    }
+    [ConditionalTheory]
+    [MemberData(nameof(IsAsyncData))]
+    public virtual Task Delete_complex_type(bool async)
+        => AssertDelete(
+            async,
+            ss => ss.Set<Customer>().Select(c => c.ShippingAddress),
+            rowsAffectedCount: 0);
+
+    [ConditionalTheory]
+    [MemberData(nameof(IsAsyncData))]
+    public virtual Task Update_projected_complex_type_via_OrderBy_Skip(bool async)
+        => AssertUpdate(
+            async,
+            ss => ss.Set<Customer>().Select(c => c.ShippingAddress).OrderBy(a => a.ZipCode).Skip(1),
+            a => a,
+            s => s.SetProperty(c => c.ZipCode, 12345),
+            rowsAffectedCount: 3);
 
     [ConditionalTheory]
     [MemberData(nameof(IsAsyncData))]
@@ -25,16 +36,6 @@ public virtual Task Delete_entity_type_with_complex_type(bool async)
             ss => ss.Set<Customer>().Where(e => e.Name == "Monty Elias"),
             rowsAffectedCount: 1);
 
-    [ConditionalTheory]
-    [MemberData(nameof(IsAsyncData))]
-    public virtual Task Delete_complex_type_throws(bool async)
-        => AssertTranslationFailed(
-            RelationalStrings.ExecuteDeleteOnNonEntityType,
-            () => AssertDelete(
-                async,
-                ss => ss.Set<Customer>().Select(c => c.ShippingAddress),
-                rowsAffectedCount: 0));
-
     [ConditionalTheory]
     [MemberData(nameof(IsAsyncData))]
     public virtual Task Update_property_inside_complex_type(bool async)
@@ -96,18 +97,6 @@ public virtual Task Update_multiple_projected_complex_types_via_anonymous_type(b
                 .SetProperty(x => x.BillingAddress.ZipCode, 54321),
             rowsAffectedCount: 3);
 
-    [ConditionalTheory]
-    [MemberData(nameof(IsAsyncData))]
-    public virtual Task Update_projected_complex_type_via_OrderBy_Skip_throws(bool async)
-        => AssertTranslationFailed(
-            RelationalStrings.ExecuteUpdateSubqueryNotSupportedOverComplexTypes("Customer.ShippingAddress#Address"),
-            () => AssertUpdate(
-                async,
-                ss => ss.Set<Customer>().Select(c => c.ShippingAddress).OrderBy(a => a.ZipCode).Skip(1),
-                a => a,
-                s => s.SetProperty(c => c.ZipCode, 12345),
-                rowsAffectedCount: 3));
-
     [ConditionalTheory]
     [MemberData(nameof(IsAsyncData))]
     public virtual Task Update_complex_type_to_parameter(bool async)
@@ -222,7 +211,4 @@ public virtual Task Update_collection_inside_complex_type(bool async)
             c => c,
             s => s.SetProperty(x => x.ShippingAddress.Tags, new List<string> { "new_tag1", "new_tag2" }),
             rowsAffectedCount: 3);
-
-    private void ClearLog()
-        => Fixture.TestSqlLoggerFactory.Clear();
 }
diff --git a/test/EFCore.Relational.Specification.Tests/BulkUpdates/FiltersInheritanceBulkUpdatesTestBase.cs b/test/EFCore.Specification.Tests/BulkUpdates/FiltersInheritanceBulkUpdatesTestBase.cs
similarity index 85%
rename from test/EFCore.Relational.Specification.Tests/BulkUpdates/FiltersInheritanceBulkUpdatesTestBase.cs
rename to test/EFCore.Specification.Tests/BulkUpdates/FiltersInheritanceBulkUpdatesTestBase.cs
index 4f9f3b323a..9a753835de 100644
--- a/test/EFCore.Relational.Specification.Tests/BulkUpdates/FiltersInheritanceBulkUpdatesTestBase.cs
+++ b/test/EFCore.Specification.Tests/BulkUpdates/FiltersInheritanceBulkUpdatesTestBase.cs
@@ -87,16 +87,6 @@ public virtual Task Delete_GroupBy_Where_Select_First_3(bool async)
                     .Where(g => g.Count() < 3).Select(g => g.First()).Any(i => i == e)),
             rowsAffectedCount: 1);
 
-    [ConditionalTheory]
-    [MemberData(nameof(IsAsyncData))]
-    public virtual Task Delete_where_keyless_entity_mapped_to_sql_query(bool async)
-        => AssertTranslationFailed(
-            RelationalStrings.ExecuteOperationOnKeylessEntityTypeWithUnsupportedOperator("ExecuteDelete", "EagleQuery"),
-            () => AssertDelete(
-                async,
-                ss => ss.Set<EagleQuery>().Where(e => e.CountryId > 0),
-                rowsAffectedCount: 1));
-
     [ConditionalTheory]
     [MemberData(nameof(IsAsyncData))]
     public virtual Task Update_base_type(bool async)
@@ -180,18 +170,4 @@ public virtual Task Update_where_using_hierarchy_derived(bool async)
             e => e,
             s => s.SetProperty(e => e.Name, "Monovia"),
             rowsAffectedCount: 1);
-
-    [ConditionalTheory]
-    [MemberData(nameof(IsAsyncData))]
-    public virtual Task Update_where_keyless_entity_mapped_to_sql_query(bool async)
-        => AssertTranslationFailed(
-            RelationalStrings.ExecuteOperationOnKeylessEntityTypeWithUnsupportedOperator("ExecuteUpdate", "EagleQuery"),
-            () => AssertUpdate(
-                async,
-                ss => ss.Set<EagleQuery>().Where(e => e.CountryId > 0),
-                e => e,
-                s => s.SetProperty(e => e.Name, "Eagle"),
-                rowsAffectedCount: 1));
-
-    protected abstract void ClearLog();
 }
diff --git a/test/EFCore.Relational.Specification.Tests/BulkUpdates/IBulkUpdatesFixtureBase.cs b/test/EFCore.Specification.Tests/BulkUpdates/IBulkUpdatesFixtureBase.cs
similarity index 100%
rename from test/EFCore.Relational.Specification.Tests/BulkUpdates/IBulkUpdatesFixtureBase.cs
rename to test/EFCore.Specification.Tests/BulkUpdates/IBulkUpdatesFixtureBase.cs
diff --git a/test/EFCore.Relational.Specification.Tests/BulkUpdates/InheritanceBulkUpdatesFixtureBase.cs b/test/EFCore.Specification.Tests/BulkUpdates/InheritanceBulkUpdatesFixtureBase.cs
similarity index 83%
rename from test/EFCore.Relational.Specification.Tests/BulkUpdates/InheritanceBulkUpdatesFixtureBase.cs
rename to test/EFCore.Specification.Tests/BulkUpdates/InheritanceBulkUpdatesFixtureBase.cs
index 24f40dbdc7..f8841a46d8 100644
--- a/test/EFCore.Relational.Specification.Tests/BulkUpdates/InheritanceBulkUpdatesFixtureBase.cs
+++ b/test/EFCore.Specification.Tests/BulkUpdates/InheritanceBulkUpdatesFixtureBase.cs
@@ -15,6 +15,5 @@ public override DbContextOptionsBuilder AddOptions(DbContextOptionsBuilder build
                     CoreEventId.MappedPropertyIgnoredWarning,
                     CoreEventId.MappedNavigationIgnoredWarning));
 
-    public void UseTransaction(DatabaseFacade facade, IDbContextTransaction transaction)
-        => facade.UseTransaction(transaction.GetDbTransaction());
+    public abstract void UseTransaction(DatabaseFacade facade, IDbContextTransaction transaction);
 }
diff --git a/test/EFCore.Relational.Specification.Tests/BulkUpdates/InheritanceBulkUpdatesTestBase.cs b/test/EFCore.Specification.Tests/BulkUpdates/InheritanceBulkUpdatesTestBase.cs
similarity index 84%
rename from test/EFCore.Relational.Specification.Tests/BulkUpdates/InheritanceBulkUpdatesTestBase.cs
rename to test/EFCore.Specification.Tests/BulkUpdates/InheritanceBulkUpdatesTestBase.cs
index 5682f4c5a0..195b23bd23 100644
--- a/test/EFCore.Relational.Specification.Tests/BulkUpdates/InheritanceBulkUpdatesTestBase.cs
+++ b/test/EFCore.Specification.Tests/BulkUpdates/InheritanceBulkUpdatesTestBase.cs
@@ -7,14 +7,9 @@ namespace Microsoft.EntityFrameworkCore.BulkUpdates;
 
 #nullable disable
 
-public abstract class InheritanceBulkUpdatesTestBase<TFixture> : BulkUpdatesTestBase<TFixture>
+public abstract class InheritanceBulkUpdatesTestBase<TFixture>(TFixture fixture) : BulkUpdatesTestBase<TFixture>(fixture)
     where TFixture : InheritanceBulkUpdatesFixtureBase, new()
 {
-    protected InheritanceBulkUpdatesTestBase(TFixture fixture)
-        : base(fixture)
-    {
-    }
-
     [ConditionalTheory]
     [MemberData(nameof(IsAsyncData))]
     public virtual Task Delete_where_hierarchy(bool async)
@@ -87,16 +82,6 @@ public virtual Task Delete_GroupBy_Where_Select_First_3(bool async)
                     .Where(g => g.Count() < 3).Select(g => g.First()).Any(i => i == e)),
             rowsAffectedCount: 2);
 
-    [ConditionalTheory]
-    [MemberData(nameof(IsAsyncData))]
-    public virtual Task Delete_where_keyless_entity_mapped_to_sql_query(bool async)
-        => AssertTranslationFailed(
-            RelationalStrings.ExecuteOperationOnKeylessEntityTypeWithUnsupportedOperator("ExecuteDelete", "EagleQuery"),
-            () => AssertDelete(
-                async,
-                ss => ss.Set<EagleQuery>().Where(e => e.CountryId > 0),
-                rowsAffectedCount: 1));
-
     [ConditionalTheory]
     [MemberData(nameof(IsAsyncData))]
     public virtual Task Update_base_type(bool async)
@@ -181,18 +166,6 @@ public virtual Task Update_where_using_hierarchy_derived(bool async)
             s => s.SetProperty(e => e.Name, "Monovia"),
             rowsAffectedCount: 1);
 
-    [ConditionalTheory]
-    [MemberData(nameof(IsAsyncData))]
-    public virtual Task Update_where_keyless_entity_mapped_to_sql_query(bool async)
-        => AssertTranslationFailed(
-            RelationalStrings.ExecuteOperationOnKeylessEntityTypeWithUnsupportedOperator("ExecuteUpdate", "EagleQuery"),
-            () => AssertUpdate(
-                async,
-                ss => ss.Set<EagleQuery>().Where(e => e.CountryId > 0),
-                e => e,
-                s => s.SetProperty(e => e.Name, "Eagle"),
-                rowsAffectedCount: 1));
-
     [ConditionalTheory]
     [MemberData(nameof(IsAsyncData))]
     public virtual Task Update_with_interface_in_property_expression(bool async)
@@ -212,7 +185,4 @@ public virtual Task Update_with_interface_in_EF_Property_in_property_expression(
             e => e,
             // ReSharper disable once RedundantCast
             s => s.SetProperty(c => EF.Property<int>((ISugary)c, nameof(ISugary.SugarGrams)), 0),
-            rowsAffectedCount: 1);
-
-    protected abstract void ClearLog();
-}
+            rowsAffectedCount: 1);}
diff --git a/test/EFCore.Relational.Specification.Tests/BulkUpdates/NonSharedModelBulkUpdatesTestBase.cs b/test/EFCore.Specification.Tests/BulkUpdates/NonSharedModelBulkUpdatesTestBase.cs
similarity index 77%
rename from test/EFCore.Relational.Specification.Tests/BulkUpdates/NonSharedModelBulkUpdatesTestBase.cs
rename to test/EFCore.Specification.Tests/BulkUpdates/NonSharedModelBulkUpdatesTestBase.cs
index 3863718e20..c5cca8e633 100644
--- a/test/EFCore.Relational.Specification.Tests/BulkUpdates/NonSharedModelBulkUpdatesTestBase.cs
+++ b/test/EFCore.Specification.Tests/BulkUpdates/NonSharedModelBulkUpdatesTestBase.cs
@@ -42,24 +42,6 @@ public virtual async Task Delete_aggregate_root_when_table_sharing_with_owned(bo
             context => context.Set<Owner>(), rowsAffectedCount: 0);
     }
 
-    [ConditionalTheory]
-    [MemberData(nameof(IsAsyncData))]
-    public virtual async Task Delete_aggregate_root_when_table_sharing_with_non_owned_throws(bool async)
-    {
-        var contextFactory = await InitializeAsync<Context28671>(
-            onModelCreating: mb =>
-            {
-                mb.Entity<Owner>().HasOne<OtherReference>().WithOne().HasForeignKey<OtherReference>(e => e.Id);
-                mb.Entity<OtherReference>().ToTable(nameof(Owner));
-            });
-
-        await AssertTranslationFailedWithDetails(
-            () => AssertDelete(
-                async, contextFactory.CreateContext,
-                context => context.Set<Owner>(), rowsAffectedCount: 0),
-            RelationalStrings.ExecuteDeleteOnTableSplitting(nameof(Owner)));
-    }
-
     [ConditionalTheory] // #33937, #33946
     [MemberData(nameof(IsAsyncData))]
     public virtual async Task Replace_ColumnExpression_in_column_setter(bool async)
@@ -186,62 +168,6 @@ public virtual async Task Update_owned_and_non_owned_properties_with_table_shari
             rowsAffectedCount: 0);
     }
 
-    [ConditionalTheory]
-    [MemberData(nameof(IsAsyncData))]
-    public virtual async Task Update_main_table_in_entity_with_entity_splitting(bool async)
-    {
-        var contextFactory = await InitializeAsync<DbContext>(
-            onModelCreating: mb => mb.Entity<Blog>()
-                .ToTable("Blogs")
-                .SplitToTable(
-                    "BlogsPart1", tb =>
-                    {
-                        tb.Property(b => b.Title);
-                        tb.Property(b => b.Rating);
-                    }),
-            seed: async context =>
-            {
-                context.Set<Blog>().Add(new Blog { Title = "SomeBlog" });
-                await context.SaveChangesAsync();
-            });
-
-        await AssertUpdate(
-            async,
-            contextFactory.CreateContext,
-            ss => ss.Set<Blog>(),
-            s => s.SetProperty(b => b.CreationTimestamp, b => new DateTime(2020, 1, 1)),
-            rowsAffectedCount: 1);
-    }
-
-    [ConditionalTheory]
-    [MemberData(nameof(IsAsyncData))]
-    public virtual async Task Update_non_main_table_in_entity_with_entity_splitting(bool async)
-    {
-        var contextFactory = await InitializeAsync<DbContext>(
-            onModelCreating: mb => mb.Entity<Blog>()
-                .ToTable("Blogs")
-                .SplitToTable(
-                    "BlogsPart1", tb =>
-                    {
-                        tb.Property(b => b.Title);
-                        tb.Property(b => b.Rating);
-                    }),
-            seed: async context =>
-            {
-                context.Set<Blog>().Add(new Blog { Title = "SomeBlog" });
-                await context.SaveChangesAsync();
-            });
-
-        await AssertUpdate(
-            async,
-            contextFactory.CreateContext,
-            ss => ss.Set<Blog>(),
-            s => s
-                .SetProperty(b => b.Title, b => b.Rating.ToString())
-                .SetProperty(b => b.Rating, b => b.Title!.Length),
-            rowsAffectedCount: 1);
-    }
-
     [ConditionalTheory]
     [MemberData(nameof(IsAsyncData))]
     public virtual async Task Delete_entity_with_auto_include(bool async)
@@ -414,20 +340,7 @@ public class Post
                 Assert.Equal(rowsAffectedCount, result);
             });
 
-    protected static async Task AssertTranslationFailedWithDetails(Func<Task> query, string details)
-        => Assert.Contains(
-            RelationalStrings.NonQueryTranslationFailedWithDetails("", details)[21..],
-            (await Assert.ThrowsAsync<InvalidOperationException>(query))
-            .Message);
-
-    public void UseTransaction(DatabaseFacade facade, IDbContextTransaction transaction)
-        => facade.UseTransaction(transaction.GetDbTransaction());
-
-    protected TestSqlLoggerFactory TestSqlLoggerFactory
-        => (TestSqlLoggerFactory)ListLoggerFactory;
-
-    protected void ClearLog()
-        => TestSqlLoggerFactory.Clear();
+    public abstract void UseTransaction(DatabaseFacade facade, IDbContextTransaction transaction);
 
     #endregion
 }
diff --git a/test/EFCore.Relational.Specification.Tests/BulkUpdates/NorthwindBulkUpdatesFixture.cs b/test/EFCore.Specification.Tests/BulkUpdates/NorthwindBulkUpdatesFixture.cs
similarity index 67%
rename from test/EFCore.Relational.Specification.Tests/BulkUpdates/NorthwindBulkUpdatesFixture.cs
rename to test/EFCore.Specification.Tests/BulkUpdates/NorthwindBulkUpdatesFixture.cs
index f6bd8eba4a..238f0ec591 100644
--- a/test/EFCore.Relational.Specification.Tests/BulkUpdates/NorthwindBulkUpdatesFixture.cs
+++ b/test/EFCore.Specification.Tests/BulkUpdates/NorthwindBulkUpdatesFixture.cs
@@ -5,13 +5,12 @@ namespace Microsoft.EntityFrameworkCore.BulkUpdates;
 
 #nullable disable
 
-public abstract class NorthwindBulkUpdatesFixture<TModelCustomizer> : NorthwindQueryRelationalFixture<TModelCustomizer>,
+public abstract class NorthwindBulkUpdatesFixture<TModelCustomizer> : NorthwindQueryFixtureBase<TModelCustomizer>,
     IBulkUpdatesFixtureBase
     where TModelCustomizer : ITestModelCustomizer, new()
 {
     protected override string StoreName
         => "BulkUpdatesNorthwind";
 
-    public void UseTransaction(DatabaseFacade facade, IDbContextTransaction transaction)
-        => facade.UseTransaction(transaction.GetDbTransaction());
+    public abstract void UseTransaction(DatabaseFacade facade, IDbContextTransaction transaction);
 }
diff --git a/test/EFCore.Relational.Specification.Tests/BulkUpdates/NorthwindBulkUpdatesTestBase.cs b/test/EFCore.Specification.Tests/BulkUpdates/NorthwindBulkUpdatesTestBase.cs
similarity index 87%
rename from test/EFCore.Relational.Specification.Tests/BulkUpdates/NorthwindBulkUpdatesTestBase.cs
rename to test/EFCore.Specification.Tests/BulkUpdates/NorthwindBulkUpdatesTestBase.cs
index b013d393c5..50750b0913 100644
--- a/test/EFCore.Relational.Specification.Tests/BulkUpdates/NorthwindBulkUpdatesTestBase.cs
+++ b/test/EFCore.Specification.Tests/BulkUpdates/NorthwindBulkUpdatesTestBase.cs
@@ -7,15 +7,88 @@ namespace Microsoft.EntityFrameworkCore.BulkUpdates;
 
 #nullable disable
 
-public abstract class NorthwindBulkUpdatesTestBase<TFixture> : BulkUpdatesTestBase<TFixture>
+public abstract class NorthwindBulkUpdatesTestBase<TFixture>(TFixture fixture) : BulkUpdatesTestBase<TFixture>(fixture)
     where TFixture : NorthwindBulkUpdatesFixture<NoopModelCustomizer>, new()
 {
-    protected NorthwindBulkUpdatesTestBase(TFixture fixture, ITestOutputHelper testOutputHelper)
-        : base(fixture)
-    {
-        ClearLog();
-        Fixture.TestSqlLoggerFactory.SetTestOutputHelper(testOutputHelper);
-    }
+    [ConditionalTheory]
+    [MemberData(nameof(IsAsyncData))]
+    public virtual Task Delete_non_entity_projection(bool async)
+        => AssertDelete(
+            async,
+            ss => ss.Set<OrderDetail>().Where(od => od.OrderID < 10250).Select(e => e.ProductID),
+            rowsAffectedCount: 0);
+
+    [ConditionalTheory]
+    [MemberData(nameof(IsAsyncData))]
+    public virtual Task Delete_non_entity_projection_2(bool async)
+        => AssertDelete(
+            async,
+            ss => ss.Set<OrderDetail>().Where(od => od.OrderID < 10250)
+                .Select(e => new OrderDetail { OrderID = e.OrderID, ProductID = e.ProductID }),
+            rowsAffectedCount: 0);
+
+    [ConditionalTheory]
+    [MemberData(nameof(IsAsyncData))]
+    public virtual Task Delete_non_entity_projection_3(bool async)
+        => AssertDelete(
+            async,
+            ss => ss.Set<OrderDetail>().Where(od => od.OrderID < 10250)
+                .Select(e => new { OrderDetail = e, e.ProductID }),
+            rowsAffectedCount: 0);
+
+    [ConditionalTheory]
+    [MemberData(nameof(IsAsyncData))]
+    public virtual Task Update_without_property_to_set_throws(bool async)
+        => AssertUpdate(
+            async,
+            ss => ss.Set<OrderDetail>().Where(od => od.OrderID < 10250),
+            e => e,
+            s => s,
+            rowsAffectedCount: 0);
+
+    [ConditionalTheory]
+    [MemberData(nameof(IsAsyncData))]
+    public virtual Task Update_with_invalid_lambda_throws(bool async)
+        => AssertUpdate(
+            async,
+            ss => ss.Set<OrderDetail>().Where(od => od.OrderID < 10250),
+            e => e,
+            s => s.Maybe(e => e),
+            rowsAffectedCount: 0);
+
+    [ConditionalTheory]
+    [MemberData(nameof(IsAsyncData))]
+    public virtual Task Update_with_invalid_lambda_in_set_property_throws(bool async)
+        => AssertUpdate(
+            async,
+            ss => ss.Set<OrderDetail>().Where(od => od.OrderID < 10250),
+            e => e,
+            s => s.SetProperty(e => e.MaybeScalar(e => e.OrderID), 10300),
+            rowsAffectedCount: 0);
+
+    [ConditionalTheory]
+    [MemberData(nameof(IsAsyncData))]
+    public virtual Task Update_multiple_tables_throws(bool async)
+        => AssertUpdate(
+            async,
+            ss => ss.Set<Order>()
+                .Where(o => o.CustomerID.StartsWith("F"))
+                .Select(e => new { e, e.Customer }),
+            e => e.Customer,
+            s => s
+                .SetProperty(c => c.Customer.ContactName, "Name")
+                .SetProperty(c => c.e.OrderDate, new DateTime(2020, 1, 1)),
+            rowsAffectedCount: 0);
+
+    [ConditionalTheory]
+    [MemberData(nameof(IsAsyncData))]
+    public virtual Task Update_unmapped_property_throws(bool async)
+        => AssertUpdate(
+            async,
+            ss => ss.Set<Customer>().Where(c => c.CustomerID.StartsWith("F")),
+            e => e,
+            s => s.SetProperty(c => c.IsLondon, true),
+            rowsAffectedCount: 0);
 
     [ConditionalTheory]
     [MemberData(nameof(IsAsyncData))]
@@ -242,62 +315,6 @@ public virtual Task Delete_Except(bool async)
                 .Except(ss.Set<OrderDetail>().Where(od => od.OrderID > 11250)),
             rowsAffectedCount: 5);
 
-    [ConditionalTheory]
-    [MemberData(nameof(IsAsyncData))]
-    public virtual Task Delete_non_entity_projection(bool async)
-        => AssertTranslationFailed(
-            RelationalStrings.ExecuteDeleteOnNonEntityType,
-            () => AssertDelete(
-                async,
-                ss => ss.Set<OrderDetail>().Where(od => od.OrderID < 10250).Select(e => e.ProductID),
-                rowsAffectedCount: 0));
-
-    [ConditionalTheory]
-    [MemberData(nameof(IsAsyncData))]
-    public virtual Task Delete_non_entity_projection_2(bool async)
-        => AssertTranslationFailed(
-            RelationalStrings.ExecuteDeleteOnNonEntityType,
-            () => AssertDelete(
-                async,
-                ss => ss.Set<OrderDetail>().Where(od => od.OrderID < 10250)
-                    .Select(e => new OrderDetail { OrderID = e.OrderID, ProductID = e.ProductID }),
-                rowsAffectedCount: 0));
-
-    [ConditionalTheory]
-    [MemberData(nameof(IsAsyncData))]
-    public virtual Task Delete_non_entity_projection_3(bool async)
-        => AssertTranslationFailed(
-            RelationalStrings.ExecuteDeleteOnNonEntityType,
-            () => AssertDelete(
-                async,
-                ss => ss.Set<OrderDetail>().Where(od => od.OrderID < 10250)
-                    .Select(e => new { OrderDetail = e, e.ProductID }),
-                rowsAffectedCount: 0));
-
-    [ConditionalTheory]
-    [MemberData(nameof(IsAsyncData))]
-    public virtual Task Delete_FromSql_converted_to_subquery(bool async)
-        => TestHelpers.ExecuteWithStrategyInTransactionAsync(
-            () => Fixture.CreateContext(),
-            (facade, transaction) => Fixture.UseTransaction(facade, transaction),
-            async context =>
-            {
-                var queryable = context.Set<OrderDetail>().FromSqlRaw(
-                    NormalizeDelimitersInRawString(
-                        @"SELECT [OrderID], [ProductID], [UnitPrice], [Quantity], [Discount]
-FROM [Order Details]
-WHERE [OrderID] < 10300"));
-
-                if (async)
-                {
-                    await queryable.ExecuteDeleteAsync();
-                }
-                else
-                {
-                    queryable.ExecuteDelete();
-                }
-            });
-
     [ConditionalTheory]
     [MemberData(nameof(IsAsyncData))]
     public virtual Task Delete_Where_optional_navigation_predicate(bool async)
@@ -719,30 +736,6 @@ public virtual Task Update_Where_set_null(bool async)
             rowsAffectedCount: 8,
             (b, a) => Assert.All(a, c => Assert.Null(c.ContactName)));
 
-    [ConditionalTheory]
-    [MemberData(nameof(IsAsyncData))]
-    public virtual Task Update_without_property_to_set_throws(bool async)
-        => AssertTranslationFailed(
-            RelationalStrings.NoSetPropertyInvocation,
-            () => AssertUpdate(
-                async,
-                ss => ss.Set<OrderDetail>().Where(od => od.OrderID < 10250),
-                e => e,
-                s => s,
-                rowsAffectedCount: 0));
-
-    [ConditionalTheory]
-    [MemberData(nameof(IsAsyncData))]
-    public virtual Task Update_with_invalid_lambda_throws(bool async)
-        => AssertTranslationFailed(
-            RelationalStrings.InvalidArgumentToExecuteUpdate,
-            () => AssertUpdate(
-                async,
-                ss => ss.Set<OrderDetail>().Where(od => od.OrderID < 10250),
-                e => e,
-                s => s.Maybe(e => e),
-                rowsAffectedCount: 0));
-
     [ConditionalTheory]
     [MemberData(nameof(IsAsyncData))]
     public virtual Task Update_Where_multiple_set(bool async)
@@ -762,47 +755,6 @@ public virtual Task Update_Where_multiple_set(bool async)
                 }));
     }
 
-    [ConditionalTheory]
-    [MemberData(nameof(IsAsyncData))]
-    public virtual Task Update_with_invalid_lambda_in_set_property_throws(bool async)
-        => AssertTranslationFailed(
-            RelationalStrings.InvalidPropertyInSetProperty(
-                new ExpressionPrinter().PrintExpression((OrderDetail e) => e.MaybeScalar(e => e.OrderID))),
-            () => AssertUpdate(
-                async,
-                ss => ss.Set<OrderDetail>().Where(od => od.OrderID < 10250),
-                e => e,
-                s => s.SetProperty(e => e.MaybeScalar(e => e.OrderID), 10300),
-                rowsAffectedCount: 0));
-
-    [ConditionalTheory]
-    [MemberData(nameof(IsAsyncData))]
-    public virtual Task Update_multiple_tables_throws(bool async)
-        => AssertTranslationFailed(
-            RelationalStrings.MultipleTablesInExecuteUpdate("c => c.Customer.ContactName", "c => c.e.OrderDate"),
-            () => AssertUpdate(
-                async,
-                ss => ss.Set<Order>()
-                    .Where(o => o.CustomerID.StartsWith("F"))
-                    .Select(e => new { e, e.Customer }),
-                e => e.Customer,
-                s => s
-                    .SetProperty(c => c.Customer.ContactName, "Name")
-                    .SetProperty(c => c.e.OrderDate, new DateTime(2020, 1, 1)),
-                rowsAffectedCount: 0));
-
-    [ConditionalTheory]
-    [MemberData(nameof(IsAsyncData))]
-    public virtual Task Update_unmapped_property_throws(bool async)
-        => AssertTranslationFailed(
-            RelationalStrings.InvalidPropertyInSetProperty("c => c.IsLondon"),
-            () => AssertUpdate(
-                async,
-                ss => ss.Set<Customer>().Where(c => c.CustomerID.StartsWith("F")),
-                e => e,
-                s => s.SetProperty(c => c.IsLondon, true),
-                rowsAffectedCount: 0));
-
     [ConditionalTheory]
     [MemberData(nameof(IsAsyncData))]
     public virtual Task Update_Union_set_constant(bool async)
@@ -973,30 +925,6 @@ select new
             rowsAffectedCount: 8,
             (b, a) => Assert.All(a, c => Assert.Equal("Updated", c.ContactName)));
 
-    [ConditionalTheory]
-    [MemberData(nameof(IsAsyncData))]
-    public virtual Task Update_FromSql_set_constant(bool async)
-        => TestHelpers.ExecuteWithStrategyInTransactionAsync(
-            () => Fixture.CreateContext(),
-            (facade, transaction) => Fixture.UseTransaction(facade, transaction),
-            async context =>
-            {
-                var queryable = context.Set<Customer>().FromSqlRaw(
-                    NormalizeDelimitersInRawString(
-                        @"SELECT [Region], [PostalCode], [Phone], [Fax], [CustomerID], [Country], [ContactTitle], [ContactName], [CompanyName], [City], [Address]
-FROM [Customers]
-WHERE [CustomerID] LIKE 'A%'"));
-
-                if (async)
-                {
-                    await queryable.ExecuteUpdateAsync(s => s.SetProperty(c => c.ContactName, "Updated"));
-                }
-                else
-                {
-                    queryable.ExecuteUpdate(s => s.SetProperty(c => c.ContactName, "Updated"));
-                }
-            });
-
     [ConditionalTheory]
     [MemberData(nameof(IsAsyncData))]
     public virtual Task Update_Where_SelectMany_subquery_set_null(bool async)
@@ -1058,10 +986,4 @@ public virtual Task Update_with_two_inner_joins(bool async)
             s => s.SetProperty(od => od.Quantity, 1),
             rowsAffectedCount: 228,
             (b, a) => Assert.All(a, od => Assert.Equal(1, od.Quantity)));
-
-    protected string NormalizeDelimitersInRawString(string sql)
-        => Fixture.TestStore.NormalizeDelimitersInRawString(sql);
-
-    protected virtual void ClearLog()
-        => Fixture.TestSqlLoggerFactory.Clear();
 }
diff --git a/test/EFCore.Specification.Tests/TestUtilities/BulkUpdatesAsserter.cs b/test/EFCore.Specification.Tests/TestUtilities/BulkUpdatesAsserter.cs
new file mode 100644
index 0000000000..c03cecd912
--- /dev/null
+++ b/test/EFCore.Specification.Tests/TestUtilities/BulkUpdatesAsserter.cs
@@ -0,0 +1,65 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+#nullable disable
+using Microsoft.EntityFrameworkCore.BulkUpdates;
+
+namespace Microsoft.EntityFrameworkCore.TestUtilities;
+
+public class BulkUpdatesAsserter(IBulkUpdatesFixtureBase queryFixture, Func<Expression, Expression> rewriteServerQueryExpression)
+{
+    private readonly Func<DbContext> _contextCreator = queryFixture.GetContextCreator();
+    private readonly Action<DatabaseFacade, IDbContextTransaction> _useTransaction = queryFixture.GetUseTransaction();
+    private readonly Func<DbContext, ISetSource> _setSourceCreator = queryFixture.GetSetSourceCreator();
+    private readonly Func<Expression, Expression> _rewriteServerQueryExpression = rewriteServerQueryExpression;
+    private readonly IReadOnlyDictionary<Type, object> _entitySorters = queryFixture.EntitySorters ?? new Dictionary<Type, object>();
+
+    public Task AssertDelete<TResult>(
+        bool async,
+        Func<ISetSource, IQueryable<TResult>> query,
+        int rowsAffectedCount)
+        => TestHelpers.ExecuteWithStrategyInTransactionAsync(
+            _contextCreator, _useTransaction,
+            async context =>
+            {
+                var processedQuery = RewriteServerQuery(query(_setSourceCreator(context)));
+
+                var result = async
+                    ? await processedQuery.ExecuteDeleteAsync()
+                    : processedQuery.ExecuteDelete();
+
+                Assert.Equal(rowsAffectedCount, result);
+            });
+
+    public Task AssertUpdate<TResult, TEntity>(
+        bool async,
+        Func<ISetSource, IQueryable<TResult>> query,
+        Expression<Func<TResult, TEntity>> entitySelector,
+        Expression<Func<SetPropertyCalls<TResult>, SetPropertyCalls<TResult>>> setPropertyCalls,
+        int rowsAffectedCount,
+        Action<IReadOnlyList<TEntity>, IReadOnlyList<TEntity>> asserter)
+        where TResult : class
+        => TestHelpers.ExecuteWithStrategyInTransactionAsync(
+            _contextCreator, _useTransaction,
+            async context =>
+            {
+                var elementSorter = (Func<TEntity, object>)_entitySorters[typeof(TEntity)];
+
+                var processedQuery = RewriteServerQuery(query(_setSourceCreator(context)));
+
+                var before = processedQuery.AsNoTracking().Select(entitySelector).OrderBy(elementSorter).ToList();
+
+                var result = async
+                    ? await processedQuery.ExecuteUpdateAsync(setPropertyCalls)
+                    : processedQuery.ExecuteUpdate(setPropertyCalls);
+
+                Assert.Equal(rowsAffectedCount, result);
+
+                var after = processedQuery.AsNoTracking().Select(entitySelector).OrderBy(elementSorter).ToList();
+
+                asserter?.Invoke(before, after);
+            });
+
+    private IQueryable<T> RewriteServerQuery<T>(IQueryable<T> query)
+        => query.Provider.CreateQuery<T>(_rewriteServerQueryExpression(query.Expression));
+}
diff --git a/test/EFCore.SqlServer.FunctionalTests/BulkUpdates/ComplexTypeBulkUpdatesSqlServerTest.cs b/test/EFCore.SqlServer.FunctionalTests/BulkUpdates/ComplexTypeBulkUpdatesSqlServerTest.cs
index 4ad3392a46..1c719aa04e 100644
--- a/test/EFCore.SqlServer.FunctionalTests/BulkUpdates/ComplexTypeBulkUpdatesSqlServerTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/BulkUpdates/ComplexTypeBulkUpdatesSqlServerTest.cs
@@ -5,7 +5,7 @@ namespace Microsoft.EntityFrameworkCore.BulkUpdates;
 
 #nullable disable
 
-public class ComplexTypeBulkUpdatesSqlServerTest(ComplexTypeBulkUpdatesSqlServerTest.ComplexTypeBulkUpdatesSqlServerFixture fixture, ITestOutputHelper testOutputHelper) : ComplexTypeBulkUpdatesTestBase<
+public class ComplexTypeBulkUpdatesSqlServerTest(ComplexTypeBulkUpdatesSqlServerTest.ComplexTypeBulkUpdatesSqlServerFixture fixture, ITestOutputHelper testOutputHelper) : ComplexTypeBulkUpdatesRelationalTestBase<
     ComplexTypeBulkUpdatesSqlServerTest.ComplexTypeBulkUpdatesSqlServerFixture>(fixture, testOutputHelper)
 {
     public override async Task Delete_entity_type_with_complex_type(bool async)
@@ -20,9 +20,9 @@ public override async Task Delete_entity_type_with_complex_type(bool async)
 """);
     }
 
-    public override async Task Delete_complex_type_throws(bool async)
+    public override async Task Delete_complex_type(bool async)
     {
-        await base.Delete_complex_type_throws(async);
+        await base.Delete_complex_type(async);
 
         AssertSql();
     }
@@ -93,9 +93,9 @@ public override async Task Update_multiple_projected_complex_types_via_anonymous
 """);
     }
 
-    public override async Task Update_projected_complex_type_via_OrderBy_Skip_throws(bool async)
+    public override async Task Update_projected_complex_type_via_OrderBy_Skip(bool async)
     {
-        await base.Update_projected_complex_type_via_OrderBy_Skip_throws(async);
+        await base.Update_projected_complex_type_via_OrderBy_Skip(async);
 
         AssertExecuteUpdateSql();
     }
@@ -241,7 +241,7 @@ private void AssertSql(params string[] expected)
     protected void ClearLog()
         => Fixture.TestSqlLoggerFactory.Clear();
 
-    public class ComplexTypeBulkUpdatesSqlServerFixture : ComplexTypeBulkUpdatesFixtureBase
+    public class ComplexTypeBulkUpdatesSqlServerFixture : ComplexTypeBulkUpdatesRelationalFixtureBase
     {
         protected override ITestStoreFactory TestStoreFactory
             => SqlServerTestStoreFactory.Instance;
diff --git a/test/EFCore.SqlServer.FunctionalTests/BulkUpdates/NonSharedModelBulkUpdatesSqlServerTest.cs b/test/EFCore.SqlServer.FunctionalTests/BulkUpdates/NonSharedModelBulkUpdatesSqlServerTest.cs
index e973a55ab3..81b06f363b 100644
--- a/test/EFCore.SqlServer.FunctionalTests/BulkUpdates/NonSharedModelBulkUpdatesSqlServerTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/BulkUpdates/NonSharedModelBulkUpdatesSqlServerTest.cs
@@ -5,7 +5,7 @@ namespace Microsoft.EntityFrameworkCore.BulkUpdates;
 
 #nullable disable
 
-public class NonSharedModelBulkUpdatesSqlServerTest : NonSharedModelBulkUpdatesTestBase
+public class NonSharedModelBulkUpdatesSqlServerTest : NonSharedModelBulkUpdatesRelationalTestBase
 {
     protected override ITestStoreFactory TestStoreFactory
         => SqlServerTestStoreFactory.Instance;
diff --git a/test/EFCore.SqlServer.FunctionalTests/BulkUpdates/NorthwindBulkUpdatesSqlServerFixture.cs b/test/EFCore.SqlServer.FunctionalTests/BulkUpdates/NorthwindBulkUpdatesSqlServerFixture.cs
index 0bec7c67a2..f59376bb3c 100644
--- a/test/EFCore.SqlServer.FunctionalTests/BulkUpdates/NorthwindBulkUpdatesSqlServerFixture.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/BulkUpdates/NorthwindBulkUpdatesSqlServerFixture.cs
@@ -7,7 +7,7 @@ namespace Microsoft.EntityFrameworkCore.BulkUpdates;
 
 #nullable disable
 
-public class NorthwindBulkUpdatesSqlServerFixture<TModelCustomizer> : NorthwindBulkUpdatesFixture<TModelCustomizer>
+public class NorthwindBulkUpdatesSqlServerFixture<TModelCustomizer> : NorthwindBulkUpdatesRelationalFixture<TModelCustomizer>
     where TModelCustomizer : ITestModelCustomizer, new()
 {
     protected override ITestStoreFactory TestStoreFactory
diff --git a/test/EFCore.SqlServer.FunctionalTests/BulkUpdates/NorthwindBulkUpdatesSqlServerTest.cs b/test/EFCore.SqlServer.FunctionalTests/BulkUpdates/NorthwindBulkUpdatesSqlServerTest.cs
index dc962065b0..27dd771956 100644
--- a/test/EFCore.SqlServer.FunctionalTests/BulkUpdates/NorthwindBulkUpdatesSqlServerTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/BulkUpdates/NorthwindBulkUpdatesSqlServerTest.cs
@@ -7,7 +7,7 @@ namespace Microsoft.EntityFrameworkCore.BulkUpdates;
 
 public class NorthwindBulkUpdatesSqlServerTest(
     NorthwindBulkUpdatesSqlServerFixture<NoopModelCustomizer> fixture,
-    ITestOutputHelper testOutputHelper) : NorthwindBulkUpdatesTestBase<NorthwindBulkUpdatesSqlServerFixture<NoopModelCustomizer>>(fixture, testOutputHelper)
+    ITestOutputHelper testOutputHelper) : NorthwindBulkUpdatesRelationalTestBase<NorthwindBulkUpdatesSqlServerFixture<NoopModelCustomizer>>(fixture, testOutputHelper)
 {
     [ConditionalFact]
     public virtual void Check_all_tests_overridden()
diff --git a/test/EFCore.SqlServer.FunctionalTests/BulkUpdates/TPHFiltersInheritanceBulkUpdatesSqlServerTest.cs b/test/EFCore.SqlServer.FunctionalTests/BulkUpdates/TPHFiltersInheritanceBulkUpdatesSqlServerTest.cs
index 49231367e1..1972ddd341 100644
--- a/test/EFCore.SqlServer.FunctionalTests/BulkUpdates/TPHFiltersInheritanceBulkUpdatesSqlServerTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/BulkUpdates/TPHFiltersInheritanceBulkUpdatesSqlServerTest.cs
@@ -5,18 +5,12 @@ namespace Microsoft.EntityFrameworkCore.BulkUpdates;
 
 #nullable disable
 
-public class TPHFiltersInheritanceBulkUpdatesSqlServerTest : FiltersInheritanceBulkUpdatesTestBase<
-    TPHFiltersInheritanceBulkUpdatesSqlServerFixture>
+public class TPHFiltersInheritanceBulkUpdatesSqlServerTest(
+    TPHFiltersInheritanceBulkUpdatesSqlServerFixture fixture,
+    ITestOutputHelper testOutputHelper)
+    : FiltersInheritanceBulkUpdatesRelationalTestBase<
+        TPHFiltersInheritanceBulkUpdatesSqlServerFixture>(fixture, testOutputHelper)
 {
-    public TPHFiltersInheritanceBulkUpdatesSqlServerTest(
-        TPHFiltersInheritanceBulkUpdatesSqlServerFixture fixture,
-        ITestOutputHelper testOutputHelper)
-        : base(fixture)
-    {
-        ClearLog();
-        Fixture.TestSqlLoggerFactory.SetTestOutputHelper(testOutputHelper);
-    }
-
     [ConditionalFact]
     public virtual void Check_all_tests_overridden()
         => TestHelpers.AssertAllMethodsOverridden(GetType());
diff --git a/test/EFCore.SqlServer.FunctionalTests/BulkUpdates/TPHInheritanceBulkUpdatesSqlServerTest.cs b/test/EFCore.SqlServer.FunctionalTests/BulkUpdates/TPHInheritanceBulkUpdatesSqlServerTest.cs
index 15cd8e98c3..abf70551a6 100644
--- a/test/EFCore.SqlServer.FunctionalTests/BulkUpdates/TPHInheritanceBulkUpdatesSqlServerTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/BulkUpdates/TPHInheritanceBulkUpdatesSqlServerTest.cs
@@ -5,17 +5,11 @@ namespace Microsoft.EntityFrameworkCore.BulkUpdates;
 
 #nullable disable
 
-public class TPHInheritanceBulkUpdatesSqlServerTest : TPHInheritanceBulkUpdatesTestBase<TPHInheritanceBulkUpdatesSqlServerFixture>
+public class TPHInheritanceBulkUpdatesSqlServerTest(
+    TPHInheritanceBulkUpdatesSqlServerFixture fixture,
+    ITestOutputHelper testOutputHelper)
+    : TPHInheritanceBulkUpdatesTestBase<TPHInheritanceBulkUpdatesSqlServerFixture>(fixture, testOutputHelper)
 {
-    public TPHInheritanceBulkUpdatesSqlServerTest(
-        TPHInheritanceBulkUpdatesSqlServerFixture fixture,
-        ITestOutputHelper testOutputHelper)
-        : base(fixture)
-    {
-        ClearLog();
-        Fixture.TestSqlLoggerFactory.SetTestOutputHelper(testOutputHelper);
-    }
-
     [ConditionalFact]
     public virtual void Check_all_tests_overridden()
         => TestHelpers.AssertAllMethodsOverridden(GetType());
diff --git a/test/EFCore.Sqlite.FunctionalTests/BulkUpdates/ComplexTypeBulkUpdatesSqliteTest.cs b/test/EFCore.Sqlite.FunctionalTests/BulkUpdates/ComplexTypeBulkUpdatesSqliteTest.cs
index 6269958610..8b6bccba5b 100644
--- a/test/EFCore.Sqlite.FunctionalTests/BulkUpdates/ComplexTypeBulkUpdatesSqliteTest.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/BulkUpdates/ComplexTypeBulkUpdatesSqliteTest.cs
@@ -5,10 +5,10 @@ namespace Microsoft.EntityFrameworkCore.BulkUpdates;
 
 #nullable disable
 
-public class ComplexTypeBulkUpdatesSqliteTest(ComplexTypeBulkUpdatesSqliteTest.ComplexTypeBulkUpdatesSqliteFixture fixture, ITestOutputHelper testOutputHelper) : ComplexTypeBulkUpdatesTestBase<
+public class ComplexTypeBulkUpdatesSqliteTest(ComplexTypeBulkUpdatesSqliteTest.ComplexTypeBulkUpdatesSqliteFixture fixture, ITestOutputHelper testOutputHelper) : ComplexTypeBulkUpdatesRelationalTestBase<
     ComplexTypeBulkUpdatesSqliteTest.ComplexTypeBulkUpdatesSqliteFixture>(fixture, testOutputHelper)
 {
-    public class ComplexTypeBulkUpdatesSqliteFixture : ComplexTypeBulkUpdatesFixtureBase
+    public class ComplexTypeBulkUpdatesSqliteFixture : ComplexTypeBulkUpdatesRelationalFixtureBase
     {
         protected override ITestStoreFactory TestStoreFactory
             => SqliteTestStoreFactory.Instance;
diff --git a/test/EFCore.Sqlite.FunctionalTests/BulkUpdates/NonSharedModelBulkUpdatesSqliteTest.cs b/test/EFCore.Sqlite.FunctionalTests/BulkUpdates/NonSharedModelBulkUpdatesSqliteTest.cs
index 6809d2912e..52763b754a 100644
--- a/test/EFCore.Sqlite.FunctionalTests/BulkUpdates/NonSharedModelBulkUpdatesSqliteTest.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/BulkUpdates/NonSharedModelBulkUpdatesSqliteTest.cs
@@ -7,7 +7,7 @@ namespace Microsoft.EntityFrameworkCore.BulkUpdates;
 
 #nullable disable
 
-public class NonSharedModelBulkUpdatesSqliteTest : NonSharedModelBulkUpdatesTestBase
+public class NonSharedModelBulkUpdatesSqliteTest : NonSharedModelBulkUpdatesRelationalTestBase
 {
     protected override ITestStoreFactory TestStoreFactory
         => SqliteTestStoreFactory.Instance;
diff --git a/test/EFCore.Sqlite.FunctionalTests/BulkUpdates/NorthwindBulkUpdatesSqliteFixture.cs b/test/EFCore.Sqlite.FunctionalTests/BulkUpdates/NorthwindBulkUpdatesSqliteFixture.cs
index 2ddb4cc6ef..9c63144fe5 100644
--- a/test/EFCore.Sqlite.FunctionalTests/BulkUpdates/NorthwindBulkUpdatesSqliteFixture.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/BulkUpdates/NorthwindBulkUpdatesSqliteFixture.cs
@@ -7,7 +7,7 @@ namespace Microsoft.EntityFrameworkCore.BulkUpdates;
 
 #nullable disable
 
-public class NorthwindBulkUpdatesSqliteFixture<TModelCustomizer> : NorthwindBulkUpdatesFixture<TModelCustomizer>
+public class NorthwindBulkUpdatesSqliteFixture<TModelCustomizer> : NorthwindBulkUpdatesRelationalFixture<TModelCustomizer>
     where TModelCustomizer : ITestModelCustomizer, new()
 {
     protected override ITestStoreFactory TestStoreFactory
diff --git a/test/EFCore.Sqlite.FunctionalTests/BulkUpdates/NorthwindBulkUpdatesSqliteTest.cs b/test/EFCore.Sqlite.FunctionalTests/BulkUpdates/NorthwindBulkUpdatesSqliteTest.cs
index 39516e4e8b..b9d24ca735 100644
--- a/test/EFCore.Sqlite.FunctionalTests/BulkUpdates/NorthwindBulkUpdatesSqliteTest.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/BulkUpdates/NorthwindBulkUpdatesSqliteTest.cs
@@ -9,7 +9,7 @@ namespace Microsoft.EntityFrameworkCore.BulkUpdates;
 
 public class NorthwindBulkUpdatesSqliteTest(
     NorthwindBulkUpdatesSqliteFixture<NoopModelCustomizer> fixture,
-    ITestOutputHelper testOutputHelper) : NorthwindBulkUpdatesTestBase<NorthwindBulkUpdatesSqliteFixture<NoopModelCustomizer>>(fixture, testOutputHelper)
+    ITestOutputHelper testOutputHelper) : NorthwindBulkUpdatesRelationalTestBase<NorthwindBulkUpdatesSqliteFixture<NoopModelCustomizer>>(fixture, testOutputHelper)
 {
     [ConditionalFact]
     public virtual void Check_all_tests_overridden()
diff --git a/test/EFCore.Sqlite.FunctionalTests/BulkUpdates/TPHFiltersInheritanceBulkUpdatesSqliteTest.cs b/test/EFCore.Sqlite.FunctionalTests/BulkUpdates/TPHFiltersInheritanceBulkUpdatesSqliteTest.cs
index 9ab20e3d02..0546ac8b6e 100644
--- a/test/EFCore.Sqlite.FunctionalTests/BulkUpdates/TPHFiltersInheritanceBulkUpdatesSqliteTest.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/BulkUpdates/TPHFiltersInheritanceBulkUpdatesSqliteTest.cs
@@ -5,18 +5,12 @@ namespace Microsoft.EntityFrameworkCore.BulkUpdates;
 
 #nullable disable
 
-public class TPHFiltersInheritanceBulkUpdatesSqliteTest : FiltersInheritanceBulkUpdatesTestBase<
-    TPHFiltersInheritanceBulkUpdatesSqliteFixture>
+public class TPHFiltersInheritanceBulkUpdatesSqliteTest(
+    TPHFiltersInheritanceBulkUpdatesSqliteFixture fixture,
+    ITestOutputHelper testOutputHelper)
+    : FiltersInheritanceBulkUpdatesRelationalTestBase<
+        TPHFiltersInheritanceBulkUpdatesSqliteFixture>(fixture, testOutputHelper)
 {
-    public TPHFiltersInheritanceBulkUpdatesSqliteTest(
-        TPHFiltersInheritanceBulkUpdatesSqliteFixture fixture,
-        ITestOutputHelper testOutputHelper)
-        : base(fixture)
-    {
-        ClearLog();
-        Fixture.TestSqlLoggerFactory.SetTestOutputHelper(testOutputHelper);
-    }
-
     [ConditionalFact]
     public virtual void Check_all_tests_overridden()
         => TestHelpers.AssertAllMethodsOverridden(GetType());
diff --git a/test/EFCore.Sqlite.FunctionalTests/BulkUpdates/TPHInheritanceBulkUpdatesSqliteTest.cs b/test/EFCore.Sqlite.FunctionalTests/BulkUpdates/TPHInheritanceBulkUpdatesSqliteTest.cs
index b712ab1119..ceb88407b3 100644
--- a/test/EFCore.Sqlite.FunctionalTests/BulkUpdates/TPHInheritanceBulkUpdatesSqliteTest.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/BulkUpdates/TPHInheritanceBulkUpdatesSqliteTest.cs
@@ -5,17 +5,11 @@ namespace Microsoft.EntityFrameworkCore.BulkUpdates;
 
 #nullable disable
 
-public class TPHInheritanceBulkUpdatesSqliteTest : TPHInheritanceBulkUpdatesTestBase<TPHInheritanceBulkUpdatesSqliteFixture>
+public class TPHInheritanceBulkUpdatesSqliteTest(
+    TPHInheritanceBulkUpdatesSqliteFixture fixture,
+    ITestOutputHelper testOutputHelper)
+    : TPHInheritanceBulkUpdatesTestBase<TPHInheritanceBulkUpdatesSqliteFixture>(fixture, testOutputHelper)
 {
-    public TPHInheritanceBulkUpdatesSqliteTest(
-        TPHInheritanceBulkUpdatesSqliteFixture fixture,
-        ITestOutputHelper testOutputHelper)
-        : base(fixture)
-    {
-        ClearLog();
-        Fixture.TestSqlLoggerFactory.SetTestOutputHelper(testOutputHelper);
-    }
-
     [ConditionalFact]
     public virtual void Check_all_tests_overridden()
         => TestHelpers.AssertAllMethodsOverridden(GetType());
diff --git a/test/EFCore.Tests/Query/QueryProviderTest.cs b/test/EFCore.Tests/Query/QueryProviderTest.cs
index 082ad4bf03..44de09533f 100644
--- a/test/EFCore.Tests/Query/QueryProviderTest.cs
+++ b/test/EFCore.Tests/Query/QueryProviderTest.cs
@@ -5,6 +5,29 @@ namespace Microsoft.EntityFrameworkCore.Query;
 
 public class QueryProviderTest
 {
+    [ConditionalFact]
+    public async Task ExecuteUpdate_and_ExecuteDelete_throw_when_provider_does_not_implement()
+    {
+        using var context = new TestContext();
+        var set = context.TestEntities;
+
+        Assert.Equal(
+            CoreStrings.ExecuteQueriesNotSupported("ExecuteUpdate", "ExecuteUpdateAsync"),
+            Assert.Throws<InvalidOperationException>(() => set.ExecuteUpdate(s => s.SetProperty(e => e.Id, 1))).Message);
+
+        Assert.Equal(
+            CoreStrings.ExecuteQueriesNotSupported("ExecuteUpdate", "ExecuteUpdateAsync"),
+            (await Assert.ThrowsAsync<InvalidOperationException>(() => set.ExecuteUpdateAsync(s => s.SetProperty(e => e.Id, 1)))).Message);
+
+        Assert.Equal(
+            CoreStrings.ExecuteQueriesNotSupported("ExecuteDelete", "ExecuteDeleteAsync"),
+            Assert.Throws<InvalidOperationException>(() => set.ExecuteDelete()).Message);
+
+        Assert.Equal(
+            CoreStrings.ExecuteQueriesNotSupported("ExecuteDelete", "ExecuteDeleteAsync"),
+            (await Assert.ThrowsAsync<InvalidOperationException>(() => set.ExecuteDeleteAsync())).Message);
+    }
+
     [ConditionalFact]
     public void Non_generic_ExecuteQuery_does_not_throw()
     {
