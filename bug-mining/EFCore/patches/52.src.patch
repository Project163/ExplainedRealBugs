diff --git a/src/EFCore.Design/Migrations/Design/CSharpSnapshotGenerator.cs b/src/EFCore.Design/Migrations/Design/CSharpSnapshotGenerator.cs
index 1bb73c7538..98f1c51809 100644
--- a/src/EFCore.Design/Migrations/Design/CSharpSnapshotGenerator.cs
+++ b/src/EFCore.Design/Migrations/Design/CSharpSnapshotGenerator.cs
@@ -316,80 +316,103 @@ string GenerateEntityTypeBuilderName()
         ISequence sequence,
         IndentedStringBuilder stringBuilder)
     {
-        stringBuilder
-            .AppendLine()
+        var sequenceBuilderNameBuilder = new StringBuilder();
+        sequenceBuilderNameBuilder
             .Append(modelBuilderName)
             .Append(".HasSequence");
 
         if (sequence.Type != Sequence.DefaultClrType)
         {
-            stringBuilder
+            sequenceBuilderNameBuilder
                 .Append("<")
                 .Append(Code.Reference(sequence.Type))
                 .Append(">");
         }
 
-        stringBuilder
+        sequenceBuilderNameBuilder
             .Append("(")
             .Append(Code.Literal(sequence.Name));
 
         if (!string.IsNullOrEmpty(sequence.Schema)
             && sequence.Model.GetDefaultSchema() != sequence.Schema)
         {
-            stringBuilder
+            sequenceBuilderNameBuilder
                 .Append(", ")
                 .Append(Code.Literal(sequence.Schema));
         }
 
-        stringBuilder.Append(")");
+        sequenceBuilderNameBuilder.Append(")");
+        var sequenceBuilderName = sequenceBuilderNameBuilder.ToString();
 
-        using (stringBuilder.Indent())
+        stringBuilder
+            .AppendLine()
+            .Append(sequenceBuilderName);
+
+        // Note that GenerateAnnotations below does the corresponding decrement
+        stringBuilder.IncrementIndent();
+
+        if (sequence.StartValue != Sequence.DefaultStartValue)
         {
-            if (sequence.StartValue != Sequence.DefaultStartValue)
-            {
-                stringBuilder
-                    .AppendLine()
-                    .Append(".StartsAt(")
-                    .Append(Code.Literal(sequence.StartValue))
-                    .Append(")");
-            }
+            stringBuilder
+                .AppendLine()
+                .Append(".StartsAt(")
+                .Append(Code.Literal(sequence.StartValue))
+                .Append(")");
+        }
 
-            if (sequence.IncrementBy != Sequence.DefaultIncrementBy)
-            {
-                stringBuilder
-                    .AppendLine()
-                    .Append(".IncrementsBy(")
-                    .Append(Code.Literal(sequence.IncrementBy))
-                    .Append(")");
-            }
+        if (sequence.IncrementBy != Sequence.DefaultIncrementBy)
+        {
+            stringBuilder
+                .AppendLine()
+                .Append(".IncrementsBy(")
+                .Append(Code.Literal(sequence.IncrementBy))
+                .Append(")");
+        }
 
-            if (sequence.MinValue != Sequence.DefaultMinValue)
-            {
-                stringBuilder
-                    .AppendLine()
-                    .Append(".HasMin(")
-                    .Append(Code.Literal(sequence.MinValue))
-                    .Append(")");
-            }
+        if (sequence.MinValue != Sequence.DefaultMinValue)
+        {
+            stringBuilder
+                .AppendLine()
+                .Append(".HasMin(")
+                .Append(Code.Literal(sequence.MinValue))
+                .Append(")");
+        }
 
-            if (sequence.MaxValue != Sequence.DefaultMaxValue)
-            {
-                stringBuilder
-                    .AppendLine()
-                    .Append(".HasMax(")
-                    .Append(Code.Literal(sequence.MaxValue))
-                    .Append(")");
-            }
+        if (sequence.MaxValue != Sequence.DefaultMaxValue)
+        {
+            stringBuilder
+                .AppendLine()
+                .Append(".HasMax(")
+                .Append(Code.Literal(sequence.MaxValue))
+                .Append(")");
+        }
 
-            if (sequence.IsCyclic != Sequence.DefaultIsCyclic)
-            {
-                stringBuilder
-                    .AppendLine()
-                    .Append(".IsCyclic()");
-            }
+        if (sequence.IsCyclic != Sequence.DefaultIsCyclic)
+        {
+            stringBuilder
+                .AppendLine()
+                .Append(".IsCyclic()");
         }
 
-        stringBuilder.AppendLine(";");
+        GenerateSequenceAnnotations(sequenceBuilderName, sequence, stringBuilder);
+    }
+
+    /// <summary>
+    ///     Generates code for sequence annotations.
+    /// </summary>
+    /// <param name="sequenceBuilderName">The name of the sequence builder variable.</param>
+    /// <param name="sequence">The sequence.</param>
+    /// <param name="stringBuilder">The builder code is added to.</param>
+    protected virtual void GenerateSequenceAnnotations(
+        string sequenceBuilderName,
+        ISequence sequence,
+        IndentedStringBuilder stringBuilder)
+    {
+        var annotations = Dependencies.AnnotationCodeGenerator
+            .FilterIgnoredAnnotations(sequence.GetAnnotations())
+            .ToDictionary(a => a.Name, a => a);
+        
+        GenerateAnnotations(sequenceBuilderName, sequence, stringBuilder, annotations, inChainedCall: true);
     }
 
     /// <summary>
@@ -849,7 +872,7 @@ protected virtual void GenerateKeyAnnotations(string keyBuilderName, IKey key, I
             annotations.Remove(isExcludedAnnotation.Name);
         }
 
-        var hasTriggers = entityType.GetTriggers().Any();
+        var hasTriggers = entityType.GetTriggers().Any(t => t.TableName == tableName! && t.TableSchema == schema);
         var hasOverrides = table != null
             && entityType.GetProperties().Select(p => p.FindOverrides(table.Value)).Any(o => o != null);
         var requiresTableBuilder = isExcludedFromMigrations
@@ -889,8 +912,7 @@ protected virtual void GenerateKeyAnnotations(string keyBuilderName, IKey key, I
 
                     if (hasTriggers)
                     {
-                        stringBuilder.AppendLine();
-                        GenerateTriggers("t", entityType, stringBuilder);
+                        GenerateTriggers("t", entityType, tableName!, schema, stringBuilder);
                     }
 
                     if (hasOverrides)
@@ -914,13 +936,14 @@ protected virtual void GenerateKeyAnnotations(string keyBuilderName, IKey key, I
     {
         foreach (var fragment in entityType.GetMappingFragments(StoreObjectType.Table))
         {
+            var table = fragment.StoreObject;
             stringBuilder
                 .AppendLine()
                 .Append(entityTypeBuilderName)
                 .Append(".SplitToTable(")
-                .Append(Code.UnknownLiteral(fragment.StoreObject.Name))
+                .Append(Code.UnknownLiteral(table.Name))
                 .Append(", ")
-                .Append(Code.UnknownLiteral(fragment.StoreObject.Schema))
+                .Append(Code.UnknownLiteral(table.Schema))
                 .AppendLine(", t =>");
 
             using (stringBuilder.Indent())
@@ -929,7 +952,9 @@ protected virtual void GenerateKeyAnnotations(string keyBuilderName, IKey key, I
 
                 using (stringBuilder.Indent())
                 {
-                    GenerateOverrides("t", entityType, fragment.StoreObject, stringBuilder);
+                    GenerateTriggers("t", entityType, table.Name, table.Schema, stringBuilder);
+                    GenerateOverrides("t", entityType, table, stringBuilder);
+                    GenerateEntityTypeMappingFragmentAnnotations("t", fragment, stringBuilder);
                 }
 
                 stringBuilder
@@ -1025,6 +1050,7 @@ private void GenerateViewMapping(string entityTypeBuilderName, IEntityType entit
                 using (stringBuilder.Indent())
                 {
                     GenerateOverrides("v", entityType, fragment.StoreObject, stringBuilder);
+                    GenerateEntityTypeMappingFragmentAnnotations("v", fragment, stringBuilder);
                 }
 
                 stringBuilder
@@ -1034,6 +1060,26 @@ private void GenerateViewMapping(string entityTypeBuilderName, IEntityType entit
         }
     }
 
+    /// <summary>
+    ///     Generates code for mapping fragment annotations.
+    /// </summary>
+    /// <param name="tableBuilderName">The name of the table builder variable.</param>
+    /// <param name="fragment">The mapping fragment.</param>
+    /// <param name="stringBuilder">The builder code is added to.</param>
+    protected virtual void GenerateEntityTypeMappingFragmentAnnotations(
+        string tableBuilderName,
+        IEntityTypeMappingFragment fragment,
+        IndentedStringBuilder stringBuilder)
+    {
+        var annotations = Dependencies.AnnotationCodeGenerator
+            .FilterIgnoredAnnotations(fragment.GetAnnotations())
+            .ToDictionary(a => a.Name, a => a);
+        if (annotations.Count > 0)
+        {
+            GenerateAnnotations(tableBuilderName, fragment, stringBuilder, annotations, inChainedCall: false);
+        }
+    }
+
     /// <summary>
     ///     Generates code for <see cref="ICheckConstraint" /> objects.
     /// </summary>
@@ -1137,14 +1183,23 @@ private void GenerateViewMapping(string entityTypeBuilderName, IEntityType entit
     /// </summary>
     /// <param name="tableBuilderName">The name of the table builder variable.</param>
     /// <param name="entityType">The entity type.</param>
+    /// <param name="table">The table name.</param>
+    /// <param name="schema">The table schema.</param>
     /// <param name="stringBuilder">The builder code is added to.</param>
     protected virtual void GenerateTriggers(
         string tableBuilderName,
         IEntityType entityType,
+        string table,
+        string? schema,
         IndentedStringBuilder stringBuilder)
     {
         foreach (var trigger in entityType.GetTriggers())
         {
+            if (trigger.TableName != table || trigger.TableSchema != schema)
+            {
+                continue;
+            }
+
             GenerateTrigger(tableBuilderName, trigger, stringBuilder);
         }
     }
@@ -1161,13 +1216,14 @@ private void GenerateViewMapping(string entityTypeBuilderName, IEntityType entit
         IndentedStringBuilder stringBuilder)
     {
         var triggerBuilderName = $"{tableBuilderName}.HasTrigger({Code.Literal(trigger.ModelName)})";
-        stringBuilder.Append(triggerBuilderName);
+        stringBuilder
+            .AppendLine()
+            .Append(triggerBuilderName);
 
         // Note that GenerateAnnotations below does the corresponding decrement
         stringBuilder.IncrementIndent();
 
-        if (trigger.Name != null
-            && trigger.Name != (trigger.GetDefaultName() ?? trigger.ModelName))
+        if (trigger.Name != trigger.GetDefaultName()!)
         {
             stringBuilder
                 .AppendLine()
diff --git a/src/EFCore.Design/Scaffolding/Internal/CSharpDbContextGenerator.cs b/src/EFCore.Design/Scaffolding/Internal/CSharpDbContextGenerator.cs
index 41cbee2abb..45f5999c6b 100644
--- a/src/EFCore.Design/Scaffolding/Internal/CSharpDbContextGenerator.cs
+++ b/src/EFCore.Design/Scaffolding/Internal/CSharpDbContextGenerator.cs
@@ -433,57 +433,63 @@ private void GenerateEntityType(IEntityType entityType)
             {
                 _builder.AppendLine();
 
-                _builder.Append($"{EntityLambdaIdentifier}.{nameof(RelationalEntityTypeBuilderExtensions.ToTable)}(tb => ");
+                _builder.AppendLine($"{EntityLambdaIdentifier}.{nameof(RelationalEntityTypeBuilderExtensions.ToTable)}(tb =>");
 
-                // Note: no trigger annotation support as of yet
-
-                if (triggers.Length == 1)
-                {
-                    var trigger = triggers[0];
-                    if (trigger.Name is not null)
-                    {
-                        _builder.AppendLine($"tb.HasTrigger({_code.Literal(trigger.Name)}));");
-                    }
-                }
-                else
+                using (_builder.Indent())
                 {
-                    _builder.AppendLine("{");
-
-                    using (_builder.Indent())
+                    _builder.Append("{");
+                    foreach (var trigger in entityType.GetTriggers().Where(t => t.Name is not null))
                     {
-                        foreach (var trigger in entityType.GetTriggers().Where(t => t.Name is not null))
-                        {
-                            _builder.AppendLine($"tb.HasTrigger({_code.Literal(trigger.Name!)});");
-                        }
+                        GenerateTrigger("tb", trigger);
                     }
-
                     _builder.AppendLine("});");
                 }
+
             }
         }
     }
 
-    private void AppendMultiLineFluentApi(IEntityType entityType, IList<string> lines)
+    private void GenerateTrigger(string tableBuilderName, ITrigger trigger)
+    {
+        var lines = new List<string> { $".HasTrigger({_code.Literal(trigger.Name!)})" };
+        
+        var annotations = _annotationCodeGenerator
+            .FilterIgnoredAnnotations(trigger.GetAnnotations())
+            .ToDictionary(a => a.Name, a => a);
+
+        _annotationCodeGenerator.RemoveAnnotationsHandledByConventions(trigger, annotations);
+
+        GenerateAnnotations(trigger, annotations, lines);
+        
+        AppendMultiLineFluentApi(null, lines, tableBuilderName);
+    }
+
+    private void AppendMultiLineFluentApi(IEntityType? entityType, IList<string> lines, string? builderName = null)
     {
         if (lines.Count <= 0)
         {
             return;
         }
 
-        InitializeEntityTypeBuilder(entityType);
+        if (entityType != null)
+        {
+            InitializeEntityTypeBuilder(entityType);
+        }
 
         using (_builder.Indent())
         {
-            _builder.AppendLine();
-
-            _builder.Append(EntityLambdaIdentifier + lines[0]);
+            _builder
+                .AppendLine()
+                .Append(builderName ?? EntityLambdaIdentifier)
+                .Append(lines[0]);
 
             using (_builder.Indent())
             {
                 foreach (var line in lines.Skip(1))
                 {
-                    _builder.AppendLine();
-                    _builder.Append(line);
+                    _builder
+                        .AppendLine()
+                        .Append(line);
                 }
             }
 
diff --git a/src/EFCore.Relational/Design/AnnotationCodeGenerator.cs b/src/EFCore.Relational/Design/AnnotationCodeGenerator.cs
index 3e80ae0dc5..44ce844029 100644
--- a/src/EFCore.Relational/Design/AnnotationCodeGenerator.cs
+++ b/src/EFCore.Relational/Design/AnnotationCodeGenerator.cs
@@ -157,6 +157,12 @@ public virtual void RemoveAnnotationsHandledByConventions(IModel model, IDiction
         RemoveConventionalAnnotationsHelper(entityType, annotations, IsHandledByConvention);
     }
 
+    /// <inheritdoc />
+    public virtual void RemoveAnnotationsHandledByConventions(
+        IEntityTypeMappingFragment fragment,
+        IDictionary<string, IAnnotation> annotations)
+        => RemoveConventionalAnnotationsHelper(fragment, annotations, IsHandledByConvention);
+
     /// <inheritdoc />
     public virtual void RemoveAnnotationsHandledByConventions(
         IProperty property,
@@ -185,6 +191,25 @@ public virtual void RemoveAnnotationsHandledByConventions(IKey key, IDictionary<
     public virtual void RemoveAnnotationsHandledByConventions(IIndex index, IDictionary<string, IAnnotation> annotations)
         => RemoveConventionalAnnotationsHelper(index, annotations, IsHandledByConvention);
 
+    /// <inheritdoc />
+    public virtual void RemoveAnnotationsHandledByConventions(
+        ICheckConstraint checkConstraint, IDictionary<string, IAnnotation> annotations)
+        => RemoveConventionalAnnotationsHelper(checkConstraint, annotations, IsHandledByConvention);
+
+    /// <inheritdoc />
+    public virtual void RemoveAnnotationsHandledByConventions(ITrigger trigger, IDictionary<string, IAnnotation> annotations)
+        => RemoveConventionalAnnotationsHelper(trigger, annotations, IsHandledByConvention);
+
+    /// <inheritdoc />
+    public virtual void RemoveAnnotationsHandledByConventions(
+        IRelationalPropertyOverrides overrides, IDictionary<string, IAnnotation> annotations)
+        => RemoveConventionalAnnotationsHelper(overrides, annotations, IsHandledByConvention);
+
+    /// <inheritdoc />
+    public virtual void RemoveAnnotationsHandledByConventions(
+        ISequence sequence, IDictionary<string, IAnnotation> annotations)
+        => RemoveConventionalAnnotationsHelper(sequence, annotations, IsHandledByConvention);
+
     /// <inheritdoc />
     public virtual IReadOnlyList<MethodCallCodeFragment> GenerateFluentApiCalls(
         IModel model,
@@ -244,6 +269,18 @@ public virtual void RemoveAnnotationsHandledByConventions(IIndex index, IDiction
         return methodCallCodeFragments;
     }
 
+    /// <inheritdoc />
+    public virtual IReadOnlyList<MethodCallCodeFragment> GenerateFluentApiCalls(
+        IEntityTypeMappingFragment fragment,
+        IDictionary<string, IAnnotation> annotations)
+    {
+        var methodCallCodeFragments = new List<MethodCallCodeFragment>();
+
+        methodCallCodeFragments.AddRange(GenerateFluentApiCallsHelper(fragment, annotations, GenerateFluentApi));
+
+        return methodCallCodeFragments;
+    }
+
     /// <inheritdoc />
     public virtual IReadOnlyList<MethodCallCodeFragment> GenerateFluentApiCalls(
         IProperty property,
@@ -371,6 +408,54 @@ public virtual void RemoveAnnotationsHandledByConventions(IIndex index, IDiction
         return methodCallCodeFragments;
     }
 
+    /// <inheritdoc />
+    public virtual IReadOnlyList<MethodCallCodeFragment> GenerateFluentApiCalls(
+        ICheckConstraint checkConstraint,
+        IDictionary<string, IAnnotation> annotations)
+    {
+        var methodCallCodeFragments = new List<MethodCallCodeFragment>();
+
+        methodCallCodeFragments.AddRange(GenerateFluentApiCallsHelper(checkConstraint, annotations, GenerateFluentApi));
+
+        return methodCallCodeFragments;
+    }
+
+    /// <inheritdoc />
+    public virtual IReadOnlyList<MethodCallCodeFragment> GenerateFluentApiCalls(
+        ITrigger trigger,
+        IDictionary<string, IAnnotation> annotations)
+    {
+        var methodCallCodeFragments = new List<MethodCallCodeFragment>();
+
+        methodCallCodeFragments.AddRange(GenerateFluentApiCallsHelper(trigger, annotations, GenerateFluentApi));
+
+        return methodCallCodeFragments;
+    }
+
+    /// <inheritdoc />
+    public virtual IReadOnlyList<MethodCallCodeFragment> GenerateFluentApiCalls(
+        IRelationalPropertyOverrides overrides,
+        IDictionary<string, IAnnotation> annotations)
+    {
+        var methodCallCodeFragments = new List<MethodCallCodeFragment>();
+
+        methodCallCodeFragments.AddRange(GenerateFluentApiCallsHelper(overrides, annotations, GenerateFluentApi));
+
+        return methodCallCodeFragments;
+    }
+
+    /// <inheritdoc />
+    public virtual IReadOnlyList<MethodCallCodeFragment> GenerateFluentApiCalls(
+        ISequence sequence,
+        IDictionary<string, IAnnotation> annotations)
+    {
+        var methodCallCodeFragments = new List<MethodCallCodeFragment>();
+
+        methodCallCodeFragments.AddRange(GenerateFluentApiCallsHelper(sequence, annotations, GenerateFluentApi));
+
+        return methodCallCodeFragments;
+    }
+
     /// <inheritdoc />
     public virtual IReadOnlyList<AttributeCodeFragment> GenerateDataAnnotationAttributes(
         IEntityType entityType,
@@ -434,6 +519,19 @@ protected virtual bool IsHandledByConvention(IModel model, IAnnotation annotatio
     protected virtual bool IsHandledByConvention(IEntityType entityType, IAnnotation annotation)
         => false;
 
+    /// <summary>
+    ///     Checks if the given <paramref name="annotation" /> is handled by convention when
+    ///     applied to the given <paramref name="fragment" />.
+    /// </summary>
+    /// <remarks>
+    ///     The default implementation always returns <see langword="false" />.
+    /// </remarks>
+    /// <param name="fragment">The <see cref="IEntityTypeMappingFragment" />.</param>
+    /// <param name="annotation">The <see cref="IAnnotation" />.</param>
+    /// <returns><see langword="false" />.</returns>
+    protected virtual bool IsHandledByConvention(IEntityTypeMappingFragment fragment, IAnnotation annotation)
+        => false;
+
     /// <summary>
     ///     Checks if the given <paramref name="annotation" /> is handled by convention when
     ///     applied to the given <paramref name="key" />.
@@ -486,6 +584,58 @@ protected virtual bool IsHandledByConvention(IForeignKey foreignKey, IAnnotation
     protected virtual bool IsHandledByConvention(IIndex index, IAnnotation annotation)
         => false;
 
+    /// <summary>
+    ///     Checks if the given <paramref name="annotation" /> is handled by convention when
+    ///     applied to the given <paramref name="checkConstraint" />.
+    /// </summary>
+    /// <remarks>
+    ///     The default implementation always returns <see langword="false" />.
+    /// </remarks>
+    /// <param name="checkConstraint">The <see cref="ICheckConstraint" />.</param>
+    /// <param name="annotation">The <see cref="IAnnotation" />.</param>
+    /// <returns><see langword="false" />.</returns>
+    protected virtual bool IsHandledByConvention(ICheckConstraint checkConstraint, IAnnotation annotation)
+        => false;
+
+    /// <summary>
+    ///     Checks if the given <paramref name="annotation" /> is handled by convention when
+    ///     applied to the given <paramref name="trigger" />.
+    /// </summary>
+    /// <remarks>
+    ///     The default implementation always returns <see langword="false" />.
+    /// </remarks>
+    /// <param name="trigger">The <see cref="ITrigger" />.</param>
+    /// <param name="annotation">The <see cref="IAnnotation" />.</param>
+    /// <returns><see langword="false" />.</returns>
+    protected virtual bool IsHandledByConvention(ITrigger trigger, IAnnotation annotation)
+        => false;
+
+    /// <summary>
+    ///     Checks if the given <paramref name="annotation" /> is handled by convention when
+    ///     applied to the given <paramref name="overrides" />.
+    /// </summary>
+    /// <remarks>
+    ///     The default implementation always returns <see langword="false" />.
+    /// </remarks>
+    /// <param name="overrides">The <see cref="IRelationalPropertyOverrides" />.</param>
+    /// <param name="annotation">The <see cref="IAnnotation" />.</param>
+    /// <returns><see langword="false" />.</returns>
+    protected virtual bool IsHandledByConvention(IRelationalPropertyOverrides overrides, IAnnotation annotation)
+        => false;
+
+    /// <summary>
+    ///     Checks if the given <paramref name="annotation" /> is handled by convention when
+    ///     applied to the given <paramref name="sequence" />.
+    /// </summary>
+    /// <remarks>
+    ///     The default implementation always returns <see langword="false" />.
+    /// </remarks>
+    /// <param name="sequence">The <see cref="ISequence" />.</param>
+    /// <param name="annotation">The <see cref="IAnnotation" />.</param>
+    /// <returns><see langword="false" />.</returns>
+    protected virtual bool IsHandledByConvention(ISequence sequence, IAnnotation annotation)
+        => false;
+
     /// <summary>
     ///     Returns a fluent API call for the given <paramref name="annotation" />, or <see langword="null" />
     ///     if no fluent API call exists for it.
@@ -512,6 +662,19 @@ protected virtual bool IsHandledByConvention(IIndex index, IAnnotation annotatio
     protected virtual MethodCallCodeFragment? GenerateFluentApi(IEntityType entityType, IAnnotation annotation)
         => null;
 
+    /// <summary>
+    ///     Returns a fluent API call for the given <paramref name="annotation" />, or <see langword="null" />
+    ///     if no fluent API call exists for it.
+    /// </summary>
+    /// <remarks>
+    ///     The default implementation always returns <see langword="null" />.
+    /// </remarks>
+    /// <param name="fragment">The <see cref="IEntityTypeMappingFragment" />.</param>
+    /// <param name="annotation">The <see cref="IAnnotation" />.</param>
+    /// <returns><see langword="null" />.</returns>
+    protected virtual MethodCallCodeFragment? GenerateFluentApi(IEntityTypeMappingFragment fragment, IAnnotation annotation)
+        => null;
+
     /// <summary>
     ///     Returns a fluent API call for the given <paramref name="annotation" />, or <see langword="null" />
     ///     if no fluent API call exists for it.
@@ -590,6 +753,58 @@ protected virtual bool IsHandledByConvention(IIndex index, IAnnotation annotatio
     protected virtual MethodCallCodeFragment? GenerateFluentApi(IIndex index, IAnnotation annotation)
         => null;
 
+    /// <summary>
+    ///     Returns a fluent API call for the given <paramref name="annotation" />, or <see langword="null" />
+    ///     if no fluent API call exists for it.
+    /// </summary>
+    /// <remarks>
+    ///     The default implementation always returns <see langword="null" />.
+    /// </remarks>
+    /// <param name="checkConstraint">The <see cref="ICheckConstraint" />.</param>
+    /// <param name="annotation">The <see cref="IAnnotation" />.</param>
+    /// <returns><see langword="null" />.</returns>
+    protected virtual MethodCallCodeFragment? GenerateFluentApi(ICheckConstraint checkConstraint, IAnnotation annotation)
+        => null;
+
+    /// <summary>
+    ///     Returns a fluent API call for the given <paramref name="annotation" />, or <see langword="null" />
+    ///     if no fluent API call exists for it.
+    /// </summary>
+    /// <remarks>
+    ///     The default implementation always returns <see langword="null" />.
+    /// </remarks>
+    /// <param name="trigger">The <see cref="ITrigger" />.</param>
+    /// <param name="annotation">The <see cref="IAnnotation" />.</param>
+    /// <returns><see langword="null" />.</returns>
+    protected virtual MethodCallCodeFragment? GenerateFluentApi(ITrigger trigger, IAnnotation annotation)
+        => null;
+
+    /// <summary>
+    ///     Returns a fluent API call for the given <paramref name="annotation" />, or <see langword="null" />
+    ///     if no fluent API call exists for it.
+    /// </summary>
+    /// <remarks>
+    ///     The default implementation always returns <see langword="null" />.
+    /// </remarks>
+    /// <param name="overrides">The <see cref="IRelationalPropertyOverrides" />.</param>
+    /// <param name="annotation">The <see cref="IAnnotation" />.</param>
+    /// <returns><see langword="null" />.</returns>
+    protected virtual MethodCallCodeFragment? GenerateFluentApi(IRelationalPropertyOverrides overrides, IAnnotation annotation)
+        => null;
+
+    /// <summary>
+    ///     Returns a fluent API call for the given <paramref name="annotation" />, or <see langword="null" />
+    ///     if no fluent API call exists for it.
+    /// </summary>
+    /// <remarks>
+    ///     The default implementation always returns <see langword="null" />.
+    /// </remarks>
+    /// <param name="sequence">The <see cref="ISequence" />.</param>
+    /// <param name="annotation">The <see cref="IAnnotation" />.</param>
+    /// <returns><see langword="null" />.</returns>
+    protected virtual MethodCallCodeFragment? GenerateFluentApi(ISequence sequence, IAnnotation annotation)
+        => null;
+
     /// <summary>
     ///     Returns a data annotation attribute code fragment for the given <paramref name="annotation" />,
     ///     or <see langword="null" /> if no data annotation exists for it.
diff --git a/src/EFCore.Relational/Design/IAnnotationCodeGenerator.cs b/src/EFCore.Relational/Design/IAnnotationCodeGenerator.cs
index 68b9fd1739..87fdb3aa92 100644
--- a/src/EFCore.Relational/Design/IAnnotationCodeGenerator.cs
+++ b/src/EFCore.Relational/Design/IAnnotationCodeGenerator.cs
@@ -48,6 +48,16 @@ void RemoveAnnotationsHandledByConventions(IEntityType entity, IDictionary<strin
     {
     }
 
+    /// <summary>
+    ///     Removes annotation whose configuration is already applied by convention, and do not need to be
+    ///     specified explicitly.
+    /// </summary>
+    /// <param name="fragment">The entity mapping fragment to which the annotations are applied.</param>
+    /// <param name="annotations">The set of annotations from which to remove the conventional ones.</param>
+    void RemoveAnnotationsHandledByConventions(IEntityTypeMappingFragment fragment, IDictionary<string, IAnnotation> annotations)
+    {
+    }
+
     /// <summary>
     ///     Removes annotation whose configuration is already applied by convention, and do not need to be
     ///     specified explicitly.
@@ -118,6 +128,16 @@ void RemoveAnnotationsHandledByConventions(IRelationalPropertyOverrides override
     {
     }
 
+    /// <summary>
+    ///     Removes annotation whose configuration is already applied by convention, and do not need to be
+    ///     specified explicitly.
+    /// </summary>
+    /// <param name="sequence">The sequence to which the annotations are applied.</param>
+    /// <param name="annotations">The set of annotations from which to remove the conventional ones.</param>
+    void RemoveAnnotationsHandledByConventions(ISequence sequence, IDictionary<string, IAnnotation> annotations)
+    {
+    }
+
     /// <summary>
     ///     For the given annotations which have corresponding fluent API calls, returns those fluent API calls
     ///     and removes the annotations.
@@ -136,6 +156,10 @@ void RemoveAnnotationsHandledByConventions(IAnnotatable annotatable, IDictionary
                 RemoveAnnotationsHandledByConventions(entityType, annotations);
                 return;
 
+            case IEntityTypeMappingFragment fragment:
+                RemoveAnnotationsHandledByConventions(fragment, annotations);
+                return;
+            
             case IProperty property:
                 RemoveAnnotationsHandledByConventions(property, annotations);
                 return;
@@ -172,6 +196,10 @@ void RemoveAnnotationsHandledByConventions(IAnnotatable annotatable, IDictionary
                 RemoveAnnotationsHandledByConventions(overrides, annotations);
                 return;
 
+            case ISequence sequence:
+                RemoveAnnotationsHandledByConventions(sequence, annotations);
+                return;
+
             default:
                 throw new ArgumentException(RelationalStrings.UnhandledAnnotatableType(annotatable.GetType()));
         }
@@ -199,6 +227,17 @@ void RemoveAnnotationsHandledByConventions(IAnnotatable annotatable, IDictionary
         IDictionary<string, IAnnotation> annotations)
         => Array.Empty<MethodCallCodeFragment>();
 
+    /// <summary>
+    ///     For the given annotations which have corresponding fluent API calls, returns those fluent API calls
+    ///     and removes the annotations.
+    /// </summary>
+    /// <param name="fragment">The entity mapping fragment to which the annotations are applied.</param>
+    /// <param name="annotations">The set of annotations from which to generate fluent API calls.</param>
+    IReadOnlyList<MethodCallCodeFragment> GenerateFluentApiCalls(
+        IEntityTypeMappingFragment fragment,
+        IDictionary<string, IAnnotation> annotations)
+        => Array.Empty<MethodCallCodeFragment>();
+
     /// <summary>
     ///     For the given annotations which have corresponding fluent API calls, returns those fluent API calls
     ///     and removes the annotations.
@@ -298,6 +337,17 @@ void RemoveAnnotationsHandledByConventions(IAnnotatable annotatable, IDictionary
         IDictionary<string, IAnnotation> annotations)
         => Array.Empty<MethodCallCodeFragment>();
 
+    /// <summary>
+    ///     For the given annotations which have corresponding fluent API calls, returns those fluent API calls
+    ///     and removes the annotations.
+    /// </summary>
+    /// <param name="sequence">The sequence to which the annotations are applied.</param>
+    /// <param name="annotations">The set of annotations from which to generate fluent API calls.</param>
+    IReadOnlyList<MethodCallCodeFragment> GenerateFluentApiCalls(
+        ISequence sequence,
+        IDictionary<string, IAnnotation> annotations)
+        => Array.Empty<MethodCallCodeFragment>();
+
     /// <summary>
     ///     For the given annotations which have corresponding fluent API calls, returns those fluent API calls
     ///     and removes the annotations.
@@ -309,7 +359,9 @@ IReadOnlyList<MethodCallCodeFragment> GenerateFluentApiCalls(IAnnotatable annota
         {
             IModel model => GenerateFluentApiCalls(model, annotations),
             IEntityType entityType => GenerateFluentApiCalls(entityType, annotations),
+            IEntityTypeMappingFragment fragment => GenerateFluentApiCalls(fragment, annotations),
             IProperty property => GenerateFluentApiCalls(property, annotations),
+            IRelationalPropertyOverrides overrides => GenerateFluentApiCalls(overrides, annotations),
             IKey key => GenerateFluentApiCalls(key, annotations),
             IForeignKey foreignKey => GenerateFluentApiCalls(foreignKey, annotations),
             INavigation navigation => GenerateFluentApiCalls(navigation, annotations),
@@ -317,7 +369,7 @@ IReadOnlyList<MethodCallCodeFragment> GenerateFluentApiCalls(IAnnotatable annota
             IIndex index => GenerateFluentApiCalls(index, annotations),
             ICheckConstraint checkConstraint => GenerateFluentApiCalls(checkConstraint, annotations),
             ITrigger trigger => GenerateFluentApiCalls(trigger, annotations),
-            IRelationalPropertyOverrides overrides => GenerateFluentApiCalls(overrides, annotations),
+            ISequence sequence => GenerateFluentApiCalls(sequence, annotations),
 
             _ => throw new ArgumentException(RelationalStrings.UnhandledAnnotatableType(annotatable.GetType()))
         };
diff --git a/src/EFCore.Relational/Design/Internal/RelationalCSharpRuntimeAnnotationCodeGenerator.cs b/src/EFCore.Relational/Design/Internal/RelationalCSharpRuntimeAnnotationCodeGenerator.cs
index 99233db8e2..867ba686d7 100644
--- a/src/EFCore.Relational/Design/Internal/RelationalCSharpRuntimeAnnotationCodeGenerator.cs
+++ b/src/EFCore.Relational/Design/Internal/RelationalCSharpRuntimeAnnotationCodeGenerator.cs
@@ -385,7 +385,7 @@ public override void Generate(IEntityType entityType, CSharpRuntimeAnnotationCod
 
         CreateAnnotations(
             fragment,
-            GenerateOverrides,
+            Generate,
             parameters with { TargetName = overrideVariable });
 
         mainBuilder.Append(fragmentsVariable).Append(".Add(");
@@ -396,6 +396,14 @@ public override void Generate(IEntityType entityType, CSharpRuntimeAnnotationCod
             .Append(overrideVariable).AppendLine(");");
     }
 
+    /// <summary>
+    ///     Generates code to create the given annotations.
+    /// </summary>
+    /// <param name="fragment">The fragment to which the annotations are applied.</param>
+    /// <param name="parameters">Additional parameters used during code generation.</param>
+    public virtual void Generate(IEntityTypeMappingFragment fragment, CSharpRuntimeAnnotationCodeGeneratorParameters parameters)
+        => GenerateSimpleAnnotations(parameters);
+
     private void Create(ITrigger trigger, string triggersVariable, CSharpRuntimeAnnotationCodeGeneratorParameters parameters)
     {
         var code = Dependencies.CSharpHelper;
@@ -500,7 +508,7 @@ public override void Generate(IProperty property, CSharpRuntimeAnnotationCodeGen
 
         CreateAnnotations(
             overrides,
-            GenerateOverrides,
+            Generate,
             parameters with { TargetName = overrideVariable });
 
         mainBuilder.Append(overridesVariable).Append(".Add(");
@@ -516,7 +524,7 @@ public override void Generate(IProperty property, CSharpRuntimeAnnotationCodeGen
     /// </summary>
     /// <param name="overrides">The property overrides to which the annotations are applied.</param>
     /// <param name="parameters">Additional parameters used during code generation.</param>
-    public virtual void GenerateOverrides(IAnnotatable overrides, CSharpRuntimeAnnotationCodeGeneratorParameters parameters)
+    public virtual void Generate(IRelationalPropertyOverrides overrides, CSharpRuntimeAnnotationCodeGeneratorParameters parameters)
         => GenerateSimpleAnnotations(parameters);
 
     /// <inheritdoc />
diff --git a/src/EFCore.Relational/Extensions/RelationalEntityTypeExtensions.cs b/src/EFCore.Relational/Extensions/RelationalEntityTypeExtensions.cs
index bef4f64ea7..c17b3127d6 100644
--- a/src/EFCore.Relational/Extensions/RelationalEntityTypeExtensions.cs
+++ b/src/EFCore.Relational/Extensions/RelationalEntityTypeExtensions.cs
@@ -1075,7 +1075,7 @@ public static IEnumerable<IEntityTypeMappingFragment> GetMappingFragments(this I
     public static IMutableEntityTypeMappingFragment? RemoveMappingFragment(
         this IMutableEntityType entityType,
         in StoreObjectIdentifier storeObject)
-        => EntityTypeMappingFragment.Remove(entityType, storeObject, ConfigurationSource.Explicit);
+        => EntityTypeMappingFragment.Remove(entityType, storeObject);
 
     /// <summary>
     ///     <para>
@@ -1088,17 +1088,14 @@ public static IEnumerable<IEntityTypeMappingFragment> GetMappingFragments(this I
     /// </summary>
     /// <param name="entityType">The entity type.</param>
     /// <param name="storeObject">The identifier of a table-like store object.</param>
-    /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
     /// <returns>
     ///     The removed <see cref="IConventionEntityTypeMappingFragment" /> or <see langword="null" />
     ///     if no overrides for the given store object were found or the existing overrides were configured from a higher source.
     /// </returns>
     public static IConventionEntityTypeMappingFragment? RemoveMappingFragment(
         this IConventionEntityType entityType,
-        in StoreObjectIdentifier storeObject,
-        bool fromDataAnnotation = false)
-        => EntityTypeMappingFragment.Remove((IMutableEntityType)entityType, storeObject,
-            fromDataAnnotation ? ConfigurationSource.DataAnnotation : ConfigurationSource.Convention);
+        in StoreObjectIdentifier storeObject)
+        => EntityTypeMappingFragment.Remove((IMutableEntityType)entityType, storeObject);
 
     /// <summary>
     ///     Gets the foreign keys for the given entity type that point to other entity types
diff --git a/src/EFCore.Relational/Extensions/RelationalPropertyExtensions.cs b/src/EFCore.Relational/Extensions/RelationalPropertyExtensions.cs
index 7dff017dcc..e14f264d4a 100644
--- a/src/EFCore.Relational/Extensions/RelationalPropertyExtensions.cs
+++ b/src/EFCore.Relational/Extensions/RelationalPropertyExtensions.cs
@@ -51,7 +51,7 @@ public static string GetColumnName(this IReadOnlyProperty property)
     /// <returns>The name of the column to which the property is mapped.</returns>
     public static string? GetColumnName(this IReadOnlyProperty property, in StoreObjectIdentifier storeObject)
     {
-        var overrides = RelationalPropertyOverrides.Find(property, storeObject);
+        var overrides = property.FindOverrides(storeObject);
         if (overrides?.ColumnNameOverridden == true)
         {
             return overrides.ColumnName;
@@ -294,8 +294,7 @@ public static void SetColumnName(this IMutableProperty property, string? name)
     public static ConfigurationSource? GetColumnNameConfigurationSource(
         this IConventionProperty property,
         in StoreObjectIdentifier storeObject)
-        => ((IConventionRelationalPropertyOverrides?)RelationalPropertyOverrides.Find(property, storeObject))
-            ?.GetColumnNameConfigurationSource();
+        => property.FindOverrides(storeObject)?.GetColumnNameConfigurationSource();
 
     /// <summary>
     ///     Returns the order of the column this property is mapped to.
@@ -1440,6 +1439,36 @@ public static RelationalTypeMapping GetRelationalTypeMapping(this IReadOnlyPrope
     public static IEnumerable<IReadOnlyRelationalPropertyOverrides> GetOverrides(this IReadOnlyProperty property)
         => RelationalPropertyOverrides.Get(property) ?? Enumerable.Empty<IReadOnlyRelationalPropertyOverrides>();
 
+    /// <summary>
+    ///     <para>
+    ///         Returns all the property facet overrides.
+    ///     </para>
+    ///     <para>
+    ///         This method is typically used by database providers (and other extensions). It is generally
+    ///         not used in application code.
+    ///     </para>
+    /// </summary>
+    /// <param name="property">The property.</param>
+    /// <returns>The property facet overrides.</returns>
+    public static IEnumerable<IMutableRelationalPropertyOverrides> GetOverrides(this IMutableProperty property)
+        => ((IEnumerable<IMutableRelationalPropertyOverrides>?)RelationalPropertyOverrides.Get(property))
+        ?? Enumerable.Empty<IMutableRelationalPropertyOverrides>();
+
+    /// <summary>
+    ///     <para>
+    ///         Returns all the property facet overrides.
+    ///     </para>
+    ///     <para>
+    ///         This method is typically used by database providers (and other extensions). It is generally
+    ///         not used in application code.
+    ///     </para>
+    /// </summary>
+    /// <param name="property">The property.</param>
+    /// <returns>The property facet overrides.</returns>
+    public static IEnumerable<IConventionRelationalPropertyOverrides> GetOverrides(this IConventionProperty property)
+        => ((IEnumerable<IConventionRelationalPropertyOverrides>?)RelationalPropertyOverrides.Get(property))
+        ?? Enumerable.Empty<IConventionRelationalPropertyOverrides>();
+
     /// <summary>
     ///     <para>
     ///         Returns all the property facet overrides.
@@ -1452,7 +1481,7 @@ public static IEnumerable<IReadOnlyRelationalPropertyOverrides> GetOverrides(thi
     /// <param name="property">The property.</param>
     /// <returns>The property facet overrides.</returns>
     public static IEnumerable<IRelationalPropertyOverrides> GetOverrides(this IProperty property)
-        => RelationalPropertyOverrides.Get(property)?.Cast<IRelationalPropertyOverrides>()
+        => ((IEnumerable<IRelationalPropertyOverrides>?)RelationalPropertyOverrides.Get(property))
         ?? Enumerable.Empty<IRelationalPropertyOverrides>();
 
     /// <summary>
@@ -1472,6 +1501,40 @@ public static IEnumerable<IRelationalPropertyOverrides> GetOverrides(this IPrope
         in StoreObjectIdentifier storeObject)
         => RelationalPropertyOverrides.Find(property, storeObject);
 
+    /// <summary>
+    ///     <para>
+    ///         Returns the property facet overrides for a particular table-like store object.
+    ///     </para>
+    ///     <para>
+    ///         This method is typically used by database providers (and other extensions). It is generally
+    ///         not used in application code.
+    ///     </para>
+    /// </summary>
+    /// <param name="property">The property.</param>
+    /// <param name="storeObject">The identifier of the table-like store object containing the column.</param>
+    /// <returns>An object that stores property facet overrides.</returns>
+    public static IMutableRelationalPropertyOverrides? FindOverrides(
+        this IMutableProperty property,
+        in StoreObjectIdentifier storeObject)
+        => (IMutableRelationalPropertyOverrides?)RelationalPropertyOverrides.Find(property, storeObject);
+
+    /// <summary>
+    ///     <para>
+    ///         Returns the property facet overrides for a particular table-like store object.
+    ///     </para>
+    ///     <para>
+    ///         This method is typically used by database providers (and other extensions). It is generally
+    ///         not used in application code.
+    ///     </para>
+    /// </summary>
+    /// <param name="property">The property.</param>
+    /// <param name="storeObject">The identifier of the table-like store object containing the column.</param>
+    /// <returns>An object that stores property facet overrides.</returns>
+    public static IConventionRelationalPropertyOverrides? FindOverrides(
+        this IConventionProperty property,
+        in StoreObjectIdentifier storeObject)
+        => (IConventionRelationalPropertyOverrides?)RelationalPropertyOverrides.Find(property, storeObject);
+
     /// <summary>
     ///     <para>
     ///         Returns the property facet overrides for a particular table-like store object.
@@ -1544,7 +1607,7 @@ public static IEnumerable<IRelationalPropertyOverrides> GetOverrides(this IPrope
     public static IMutableRelationalPropertyOverrides? RemoveOverrides(
         this IMutableProperty property,
         in StoreObjectIdentifier storeObject)
-        => RelationalPropertyOverrides.Remove(property, storeObject, ConfigurationSource.Explicit);
+        => RelationalPropertyOverrides.Remove(property, storeObject);
 
     /// <summary>
     ///     <para>
@@ -1557,17 +1620,14 @@ public static IEnumerable<IRelationalPropertyOverrides> GetOverrides(this IPrope
     /// </summary>
     /// <param name="property">The property.</param>
     /// <param name="storeObject">The identifier of a table-like store object.</param>
-    /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
     /// <returns>
     ///     The removed <see cref="IConventionRelationalPropertyOverrides" /> or <see langword="null" />
     ///     if no overrides for the given store object were found or the existing overrides were configured from a higher source.
     /// </returns>
     public static IConventionRelationalPropertyOverrides? RemoveOverrides(
         this IConventionProperty property,
-        in StoreObjectIdentifier storeObject,
-        bool fromDataAnnotation = false)
-        => RelationalPropertyOverrides.Remove((IMutableProperty)property, storeObject,
-            fromDataAnnotation ? ConfigurationSource.DataAnnotation : ConfigurationSource.Convention);
+        in StoreObjectIdentifier storeObject)
+        => RelationalPropertyOverrides.Remove((IMutableProperty)property, storeObject);
 
     /// <summary>
     ///     <para>
diff --git a/src/EFCore.Relational/Infrastructure/RelationalModelValidator.cs b/src/EFCore.Relational/Infrastructure/RelationalModelValidator.cs
index 722d9e77eb..d8bb74f0d5 100644
--- a/src/EFCore.Relational/Infrastructure/RelationalModelValidator.cs
+++ b/src/EFCore.Relational/Infrastructure/RelationalModelValidator.cs
@@ -1864,8 +1864,10 @@ protected override bool IsRedundant(IForeignKey foreignKey)
                         RelationalStrings.TriggerOnUnmappedEntityType(trigger.ModelName, entityType.DisplayName()));
                 }
 
-                if ((trigger.TableName != tableName)
-                    || (trigger.TableSchema is not null && trigger.TableSchema != tableSchema))
+                if ((trigger.TableName != tableName
+                    || trigger.TableSchema != tableSchema)
+                    && entityType.GetMappingFragments(StoreObjectType.Table)
+                        .All(f => trigger.TableName != f.StoreObject.Name || trigger.TableSchema != f.StoreObject.Schema))
                 {
                     throw new InvalidOperationException(
                         RelationalStrings.TriggerWithMismatchedTable(
diff --git a/src/EFCore.Relational/Metadata/Builders/ColumnBuilder.cs b/src/EFCore.Relational/Metadata/Builders/ColumnBuilder.cs
index 484e6fd5e7..a8979453ae 100644
--- a/src/EFCore.Relational/Metadata/Builders/ColumnBuilder.cs
+++ b/src/EFCore.Relational/Metadata/Builders/ColumnBuilder.cs
@@ -62,6 +62,23 @@ public virtual ColumnBuilder HasColumnName(string? name)
         return this;
     }
 
+    /// <summary>
+    ///     Adds or updates an annotation on the property for a specific table.
+    ///     If an annotation with the key specified in <paramref name="annotation" />
+    ///     already exists, its value will be updated.
+    /// </summary>
+    /// <param name="annotation">The key of the annotation to be added or updated.</param>
+    /// <param name="value">The value to be stored in the annotation.</param>
+    /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
+    public virtual ColumnBuilder HasAnnotation(string annotation, object? value)
+    {
+        Check.NotEmpty(annotation, nameof(annotation));
+
+        InternalOverrides.Builder.HasAnnotation(annotation, value, ConfigurationSource.Explicit);
+
+        return this;
+    }
+
     PropertyBuilder IInfrastructure<PropertyBuilder>.Instance => PropertyBuilder;
 
     #region Hidden System.Object members
diff --git a/src/EFCore.Relational/Metadata/Builders/ColumnBuilder`.cs b/src/EFCore.Relational/Metadata/Builders/ColumnBuilder`.cs
index 51e666742a..d51269971e 100644
--- a/src/EFCore.Relational/Metadata/Builders/ColumnBuilder`.cs
+++ b/src/EFCore.Relational/Metadata/Builders/ColumnBuilder`.cs
@@ -34,6 +34,17 @@ private PropertyBuilder<TProperty> PropertyBuilder
     /// <returns>The same builder instance so that multiple calls can be chained.</returns>
     public new virtual ColumnBuilder<TProperty> HasColumnName(string? name)
         => (ColumnBuilder<TProperty>)base.HasColumnName(name);
+    
+    /// <summary>
+    ///     Adds or updates an annotation on the property for a specific table.
+    ///     If an annotation with the key specified in <paramref name="annotation" />
+    ///     already exists, its value will be updated.
+    /// </summary>
+    /// <param name="annotation">The key of the annotation to be added or updated.</param>
+    /// <param name="value">The value to be stored in the annotation.</param>
+    /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
+    public new virtual ColumnBuilder<TProperty> HasAnnotation(string annotation, object? value)
+        => (ColumnBuilder<TProperty>)base.HasAnnotation(annotation, value);
 
     PropertyBuilder<TProperty> IInfrastructure<PropertyBuilder<TProperty>>.Instance => PropertyBuilder;
 }
diff --git a/src/EFCore.Relational/Metadata/Builders/IConventionEntityTypeMappingFragmentBuilder.cs b/src/EFCore.Relational/Metadata/Builders/IConventionEntityTypeMappingFragmentBuilder.cs
new file mode 100644
index 0000000000..40e7453da6
--- /dev/null
+++ b/src/EFCore.Relational/Metadata/Builders/IConventionEntityTypeMappingFragmentBuilder.cs
@@ -0,0 +1,18 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.EntityFrameworkCore.Metadata.Builders;
+
+/// <summary>
+///     Provides a simple API for configuring a <see cref="IConventionEntityTypeMappingFragment" />.
+/// </summary>
+/// <remarks>
+///     See <see href="https://aka.ms/efcore-docs-conventions">Model building conventions</see> for more information and examples.
+/// </remarks>
+public interface IConventionEntityTypeMappingFragmentBuilder : IConventionAnnotatableBuilder
+{
+    /// <summary>
+    ///     The fragment being configured.
+    /// </summary>
+    new IConventionEntityTypeMappingFragment Metadata { get; }
+}
diff --git a/src/EFCore.Relational/Metadata/Builders/IConventionRelationalPropertyOverridesBuilder.cs b/src/EFCore.Relational/Metadata/Builders/IConventionRelationalPropertyOverridesBuilder.cs
new file mode 100644
index 0000000000..8f445de4d1
--- /dev/null
+++ b/src/EFCore.Relational/Metadata/Builders/IConventionRelationalPropertyOverridesBuilder.cs
@@ -0,0 +1,18 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.EntityFrameworkCore.Metadata.Builders;
+
+/// <summary>
+///     Provides a simple API for configuring a <see cref="IConventionRelationalPropertyOverrides" />.
+/// </summary>
+/// <remarks>
+///     See <see href="https://aka.ms/efcore-docs-conventions">Model building conventions</see> for more information and examples.
+/// </remarks>
+public interface IConventionRelationalPropertyOverridesBuilder : IConventionAnnotatableBuilder
+{
+    /// <summary>
+    ///     The overrides being configured.
+    /// </summary>
+    new IConventionRelationalPropertyOverrides Metadata { get; }
+}
diff --git a/src/EFCore.Relational/Metadata/Builders/OwnedNavigationSplitTableBuilder.cs b/src/EFCore.Relational/Metadata/Builders/OwnedNavigationSplitTableBuilder.cs
index 7e7f7596b1..04cbba7bcd 100644
--- a/src/EFCore.Relational/Metadata/Builders/OwnedNavigationSplitTableBuilder.cs
+++ b/src/EFCore.Relational/Metadata/Builders/OwnedNavigationSplitTableBuilder.cs
@@ -24,7 +24,7 @@ public OwnedNavigationSplitTableBuilder(in StoreObjectIdentifier storeObject, Ow
         Check.DebugAssert(storeObject.StoreObjectType == StoreObjectType.Table,
             "StoreObjectType should be Table, not " + storeObject.StoreObjectType);
 
-        MappingFragment = EntityTypeMappingFragment.GetOrCreate(
+        InternalMappingFragment = EntityTypeMappingFragment.GetOrCreate(
             ownedNavigationBuilder.OwnedEntityType, storeObject, ConfigurationSource.Explicit);
         OwnedNavigationBuilder = ownedNavigationBuilder;
     }
@@ -39,10 +39,19 @@ public OwnedNavigationSplitTableBuilder(in StoreObjectIdentifier storeObject, Ow
     /// </summary>
     public virtual string? Schema => MappingFragment.StoreObject.Schema;
 
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    [EntityFrameworkInternal]
+    protected virtual EntityTypeMappingFragment InternalMappingFragment { get; }
+
     /// <summary>
     ///     The mapping fragment being configured.
     /// </summary>
-    public virtual IMutableEntityTypeMappingFragment MappingFragment { get; }
+    public virtual IMutableEntityTypeMappingFragment MappingFragment => InternalMappingFragment;
 
     private OwnedNavigationBuilder OwnedNavigationBuilder { get; }
 
@@ -96,6 +105,22 @@ public virtual ColumnBuilder Property(string propertyName)
     public virtual ColumnBuilder<TProperty> Property<TProperty>(string propertyName)
         => new(MappingFragment.StoreObject, OwnedNavigationBuilder.Property<TProperty>(propertyName));
 
+    /// <summary>
+    ///     Adds or updates an annotation on the table. If an annotation with the key specified in <paramref name="annotation" />
+    ///     already exists, its value will be updated.
+    /// </summary>
+    /// <param name="annotation">The key of the annotation to be added or updated.</param>
+    /// <param name="value">The value to be stored in the annotation.</param>
+    /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
+    public virtual OwnedNavigationSplitTableBuilder HasAnnotation(string annotation, object? value)
+    {
+        Check.NotEmpty(annotation, nameof(annotation));
+
+        InternalMappingFragment.Builder.HasAnnotation(annotation, value, ConfigurationSource.Explicit);
+
+        return this;
+    }
+
     OwnedNavigationBuilder IInfrastructure<OwnedNavigationBuilder>.Instance => OwnedNavigationBuilder;
 
     #region Hidden System.Object members
diff --git a/src/EFCore.Relational/Metadata/Builders/OwnedNavigationSplitTableBuilder``.cs b/src/EFCore.Relational/Metadata/Builders/OwnedNavigationSplitTableBuilder``.cs
index ee02ff954c..a747d19bc1 100644
--- a/src/EFCore.Relational/Metadata/Builders/OwnedNavigationSplitTableBuilder``.cs
+++ b/src/EFCore.Relational/Metadata/Builders/OwnedNavigationSplitTableBuilder``.cs
@@ -55,6 +55,17 @@ public class OwnedNavigationSplitTableBuilder<TOwnerEntity, TDependentEntity> :
     public virtual ColumnBuilder<TProperty> Property<TProperty>(Expression<Func<TDependentEntity, TProperty>> propertyExpression)
         => new(MappingFragment.StoreObject, OwnedNavigationBuilder.Property(propertyExpression));
 
+    /// <summary>
+    ///     Adds or updates an annotation on the table. If an annotation with the key specified in <paramref name="annotation" />
+    ///     already exists, its value will be updated.
+    /// </summary>
+    /// <param name="annotation">The key of the annotation to be added or updated.</param>
+    /// <param name="value">The value to be stored in the annotation.</param>
+    /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
+    public new virtual OwnedNavigationSplitTableBuilder<TOwnerEntity, TDependentEntity> HasAnnotation(
+        string annotation, object? value)
+        => (OwnedNavigationSplitTableBuilder<TOwnerEntity, TDependentEntity>)base.HasAnnotation(annotation, value);
+
     OwnedNavigationBuilder<TOwnerEntity, TDependentEntity> IInfrastructure<OwnedNavigationBuilder<TOwnerEntity, TDependentEntity>>.Instance
         => OwnedNavigationBuilder;
 }
diff --git a/src/EFCore.Relational/Metadata/Builders/SequenceBuilder.cs b/src/EFCore.Relational/Metadata/Builders/SequenceBuilder.cs
index 6ad456007a..2a0d2e0646 100644
--- a/src/EFCore.Relational/Metadata/Builders/SequenceBuilder.cs
+++ b/src/EFCore.Relational/Metadata/Builders/SequenceBuilder.cs
@@ -114,6 +114,22 @@ public virtual SequenceBuilder IsCyclic(bool cyclic = true)
         return this;
     }
 
+    /// <summary>
+    ///     Adds or updates an annotation on the sequence. If an annotation with the key specified in <paramref name="annotation" />
+    ///     already exists, its value will be updated.
+    /// </summary>
+    /// <param name="annotation">The key of the annotation to be added or updated.</param>
+    /// <param name="value">The value to be stored in the annotation.</param>
+    /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
+    public virtual SequenceBuilder HasAnnotation(string annotation, object? value)
+    {
+        Check.NotEmpty(annotation, nameof(annotation));
+
+        Builder.HasAnnotation(annotation, value, ConfigurationSource.Explicit);
+
+        return this;
+    }
+
     #region Hidden System.Object members
 
     /// <summary>
diff --git a/src/EFCore.Relational/Metadata/Builders/SplitTableBuilder.cs b/src/EFCore.Relational/Metadata/Builders/SplitTableBuilder.cs
index b9f1cf14db..b5dc8eb4d2 100644
--- a/src/EFCore.Relational/Metadata/Builders/SplitTableBuilder.cs
+++ b/src/EFCore.Relational/Metadata/Builders/SplitTableBuilder.cs
@@ -24,7 +24,7 @@ public SplitTableBuilder(in StoreObjectIdentifier storeObject, EntityTypeBuilder
         Check.DebugAssert(storeObject.StoreObjectType == StoreObjectType.Table,
             "StoreObjectType should be Table, not " + storeObject.StoreObjectType);
 
-        MappingFragment = EntityTypeMappingFragment.GetOrCreate(
+        InternalMappingFragment = EntityTypeMappingFragment.GetOrCreate(
             entityTypeBuilder.Metadata, storeObject, ConfigurationSource.Explicit);
         EntityTypeBuilder = entityTypeBuilder;
     }
@@ -38,11 +38,20 @@ public SplitTableBuilder(in StoreObjectIdentifier storeObject, EntityTypeBuilder
     ///     The specified table schema.
     /// </summary>
     public virtual string? Schema => MappingFragment.StoreObject.Schema;
-    
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    [EntityFrameworkInternal]
+    protected virtual EntityTypeMappingFragment InternalMappingFragment { get; }
+
     /// <summary>
     ///     The mapping fragment being configured.
     /// </summary>
-    public virtual IMutableEntityTypeMappingFragment MappingFragment { get; }
+    public virtual IMutableEntityTypeMappingFragment MappingFragment => InternalMappingFragment;
 
     private EntityTypeBuilder EntityTypeBuilder { get; }
 
@@ -96,6 +105,22 @@ public virtual ColumnBuilder Property(string propertyName)
     public virtual ColumnBuilder<TProperty> Property<TProperty>(string propertyName)
         => new(MappingFragment.StoreObject, EntityTypeBuilder.Property<TProperty>(propertyName));
 
+    /// <summary>
+    ///     Adds or updates an annotation on the table. If an annotation with the key specified in <paramref name="annotation" />
+    ///     already exists, its value will be updated.
+    /// </summary>
+    /// <param name="annotation">The key of the annotation to be added or updated.</param>
+    /// <param name="value">The value to be stored in the annotation.</param>
+    /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
+    public virtual SplitTableBuilder HasAnnotation(string annotation, object? value)
+    {
+        Check.NotEmpty(annotation, nameof(annotation));
+
+        InternalMappingFragment.Builder.HasAnnotation(annotation, value, ConfigurationSource.Explicit);
+
+        return this;
+    }
+
     EntityTypeBuilder IInfrastructure<EntityTypeBuilder>.Instance => EntityTypeBuilder;
 
     #region Hidden System.Object members
diff --git a/src/EFCore.Relational/Metadata/Builders/SplitTableBuilder`.cs b/src/EFCore.Relational/Metadata/Builders/SplitTableBuilder`.cs
index 6d02e378b2..6a244425e4 100644
--- a/src/EFCore.Relational/Metadata/Builders/SplitTableBuilder`.cs
+++ b/src/EFCore.Relational/Metadata/Builders/SplitTableBuilder`.cs
@@ -47,5 +47,15 @@ public new virtual SplitTableBuilder<TEntity> ExcludeFromMigrations(bool exclude
     public virtual ColumnBuilder<TProperty> Property<TProperty>(Expression<Func<TEntity, TProperty>> propertyExpression)
         => new(MappingFragment.StoreObject, EntityTypeBuilder.Property(propertyExpression));
 
+    /// <summary>
+    ///     Adds or updates an annotation on the table. If an annotation with the key specified in <paramref name="annotation" />
+    ///     already exists, its value will be updated.
+    /// </summary>
+    /// <param name="annotation">The key of the annotation to be added or updated.</param>
+    /// <param name="value">The value to be stored in the annotation.</param>
+    /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
+    public new virtual SplitTableBuilder<TEntity> HasAnnotation(string annotation, object? value)
+        => (SplitTableBuilder<TEntity>)base.HasAnnotation(annotation, value);
+
     EntityTypeBuilder<TEntity> IInfrastructure<EntityTypeBuilder<TEntity>>.Instance => EntityTypeBuilder;
 }
diff --git a/src/EFCore.Relational/Metadata/Conventions/CheckConstraintConvention.cs b/src/EFCore.Relational/Metadata/Conventions/CheckConstraintConvention.cs
index 6c05c901dc..f99b58c260 100644
--- a/src/EFCore.Relational/Metadata/Conventions/CheckConstraintConvention.cs
+++ b/src/EFCore.Relational/Metadata/Conventions/CheckConstraintConvention.cs
@@ -144,7 +144,7 @@ public class CheckConstraintConvention : IEntityTypeBaseTypeChangedConvention, I
                 foreach (var checkConstraintToBeDetached in checkConstraintsToBeDetached)
                 {
                     var baseCheckConstraint = baseCheckConstraints[checkConstraintToBeDetached.ModelName];
-                    CheckConstraint.Attach(checkConstraintToBeDetached, baseCheckConstraint);
+                    CheckConstraint.MergeInto(checkConstraintToBeDetached, baseCheckConstraint);
 
                     checkConstraintToBeDetached.EntityType.RemoveCheckConstraint(checkConstraintToBeDetached.ModelName);
                 }
diff --git a/src/EFCore.Relational/Metadata/Conventions/EntitySplittingConvention.cs b/src/EFCore.Relational/Metadata/Conventions/EntitySplittingConvention.cs
index ee8e4fc30d..78ac818063 100644
--- a/src/EFCore.Relational/Metadata/Conventions/EntitySplittingConvention.cs
+++ b/src/EFCore.Relational/Metadata/Conventions/EntitySplittingConvention.cs
@@ -1,16 +1,18 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using Microsoft.EntityFrameworkCore.Metadata.Internal;
+
 namespace Microsoft.EntityFrameworkCore.Metadata.Conventions;
 
 /// <summary>
-///     A convention that creates linking relationships for entity splitting.
+///     A convention that creates linking relationships for entity splitting and manages the mapping fragments.
 /// </summary>
 /// <remarks>
 ///     See <see href="https://aka.ms/efcore-docs-conventions">Model building conventions</see> and
 ///     <see href="https://aka.ms/efcore-docs-inheritance">Entity type hierarchy mapping</see> for more information and examples.
 /// </remarks>
-public class EntitySplittingConvention : IModelFinalizingConvention
+public class EntitySplittingConvention : IModelFinalizingConvention, IEntityTypeAddedConvention
 {
     /// <summary>
     ///     Creates a new instance of <see cref="EntitySplittingConvention" />.
@@ -35,6 +37,45 @@ public class EntitySplittingConvention : IModelFinalizingConvention
     /// </summary>
     protected virtual RelationalConventionSetBuilderDependencies RelationalDependencies { get; }
 
+    /// <inheritdoc />
+    public virtual void ProcessEntityTypeAdded(
+        IConventionEntityTypeBuilder entityTypeBuilder,
+        IConventionContext<IConventionEntityTypeBuilder> context)
+    {
+        var entityType = entityTypeBuilder.Metadata;
+        if (!entityType.HasSharedClrType)
+        {
+            return;
+        }
+
+        List<IConventionEntityTypeMappingFragment>? fragmentsToReattach = null;
+        foreach (var fragment in entityType.GetMappingFragments())
+        {
+            if (fragment.EntityType == entityType)
+            {
+                continue;
+            }
+
+            fragmentsToReattach ??= new();
+
+            fragmentsToReattach.Add(fragment);
+        }
+
+        if (fragmentsToReattach == null)
+        {
+            return;
+        }
+
+        foreach (var fragment in fragmentsToReattach)
+        {
+            var removedFragment = entityType.RemoveMappingFragment(fragment.StoreObject);
+            if (removedFragment != null)
+            {
+                EntityTypeMappingFragment.Attach(entityType, removedFragment);
+            }
+        }
+    }
+
     /// <inheritdoc />
     public virtual void ProcessModelFinalizing(
         IConventionModelBuilder modelBuilder,
diff --git a/src/EFCore.Relational/Metadata/Conventions/Infrastructure/RelationalConventionSetBuilder.cs b/src/EFCore.Relational/Metadata/Conventions/Infrastructure/RelationalConventionSetBuilder.cs
index a14ff223ec..33d2dfcb62 100644
--- a/src/EFCore.Relational/Metadata/Conventions/Infrastructure/RelationalConventionSetBuilder.cs
+++ b/src/EFCore.Relational/Metadata/Conventions/Infrastructure/RelationalConventionSetBuilder.cs
@@ -64,13 +64,15 @@ public override ConventionSet CreateConventionSet()
         conventionSet.PropertyAddedConventions.Add(relationalColumnAttributeConvention);
         conventionSet.PropertyAddedConventions.Add(relationalCommentAttributeConvention);
 
+        var tableNameFromDbSetConvention = new TableNameFromDbSetConvention(Dependencies, RelationalDependencies);
+        var entitySplittingConvention = new EntitySplittingConvention(Dependencies, RelationalDependencies);
         var checkConstraintConvention = new CheckConstraintConvention(Dependencies, RelationalDependencies);
         var triggerConvention = new TriggerConvention(Dependencies, RelationalDependencies);
-        var tableNameFromDbSetConvention = new TableNameFromDbSetConvention(Dependencies, RelationalDependencies);
         conventionSet.EntityTypeAddedConventions.Add(new RelationalTableAttributeConvention(Dependencies, RelationalDependencies));
         conventionSet.EntityTypeAddedConventions.Add(
             new RelationalTableCommentAttributeConvention(Dependencies, RelationalDependencies));
         conventionSet.EntityTypeAddedConventions.Add(tableNameFromDbSetConvention);
+        conventionSet.EntityTypeAddedConventions.Add(entitySplittingConvention);
         conventionSet.EntityTypeAddedConventions.Add(checkConstraintConvention);
         conventionSet.EntityTypeAddedConventions.Add(triggerConvention);
 
@@ -93,6 +95,8 @@ public override ConventionSet CreateConventionSet()
 
         ReplaceConvention(conventionSet.ForeignKeyRemovedConventions, valueGenerationConvention);
 
+        conventionSet.PropertyAddedConventions.Add(new PropertyOverridesConvention(Dependencies, RelationalDependencies));
+
         conventionSet.PropertyFieldChangedConventions.Add(relationalColumnAttributeConvention);
         conventionSet.PropertyFieldChangedConventions.Add(relationalCommentAttributeConvention);
 
@@ -112,7 +116,7 @@ public override ConventionSet CreateConventionSet()
         conventionSet.ModelFinalizingConventions.Add(dbFunctionAttributeConvention);
         conventionSet.ModelFinalizingConventions.Add(tableNameFromDbSetConvention);
         conventionSet.ModelFinalizingConventions.Add(storeGenerationConvention);
-        conventionSet.ModelFinalizingConventions.Add(new EntitySplittingConvention(Dependencies, RelationalDependencies));
+        conventionSet.ModelFinalizingConventions.Add(entitySplittingConvention);
         conventionSet.ModelFinalizingConventions.Add(new EntityTypeHierarchyMappingConvention(Dependencies, RelationalDependencies));
         conventionSet.ModelFinalizingConventions.Add(new SequenceUniquificationConvention(Dependencies, RelationalDependencies));
         conventionSet.ModelFinalizingConventions.Add(new SharedTableConvention(Dependencies, RelationalDependencies));
diff --git a/src/EFCore.Relational/Metadata/Conventions/PropertyOverridesConvention.cs b/src/EFCore.Relational/Metadata/Conventions/PropertyOverridesConvention.cs
new file mode 100644
index 0000000000..706897b4ce
--- /dev/null
+++ b/src/EFCore.Relational/Metadata/Conventions/PropertyOverridesConvention.cs
@@ -0,0 +1,78 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.EntityFrameworkCore.Metadata.Internal;
+
+namespace Microsoft.EntityFrameworkCore.Metadata.Conventions;
+
+/// <summary>
+///     A convention that ensures that the declaring property is current for the property overrides.
+/// </summary>
+/// <remarks>
+///     See <see href="https://aka.ms/efcore-docs-conventions">Model building conventions</see> and
+///     <see href="https://aka.ms/efcore-docs-inheritance">Entity type hierarchy mapping</see> for more information and examples.
+/// </remarks>
+public class PropertyOverridesConvention : IPropertyAddedConvention
+{
+    /// <summary>
+    ///     Creates a new instance of <see cref="PropertyOverridesConvention" />.
+    /// </summary>
+    /// <param name="dependencies">Parameter object containing dependencies for this convention.</param>
+    /// <param name="relationalDependencies"> Parameter object containing relational dependencies for this convention.</param>
+    public PropertyOverridesConvention(
+        ProviderConventionSetBuilderDependencies dependencies,
+        RelationalConventionSetBuilderDependencies relationalDependencies)
+    {
+        Dependencies = dependencies;
+        RelationalDependencies = relationalDependencies;
+    }
+
+    /// <summary>
+    ///     Dependencies for this service.
+    /// </summary>
+    protected virtual ProviderConventionSetBuilderDependencies Dependencies { get; }
+
+    /// <summary>
+    ///     Relational provider-specific dependencies for this service.
+    /// </summary>
+    protected virtual RelationalConventionSetBuilderDependencies RelationalDependencies { get; }
+
+    /// <inheritdoc />
+    public virtual void ProcessPropertyAdded(
+        IConventionPropertyBuilder propertyBuilder,
+        IConventionContext<IConventionPropertyBuilder> context)
+    {
+        var property = propertyBuilder.Metadata;
+        if (!property.DeclaringEntityType.HasSharedClrType)
+        {
+            return;
+        }
+
+        List<IConventionRelationalPropertyOverrides>? overridesToReattach = null;
+        foreach (var overrides in property.GetOverrides())
+        {
+            if (overrides.Property == property)
+            {
+                continue;
+            }
+
+            overridesToReattach ??= new();
+
+            overridesToReattach.Add(overrides);
+        }
+
+        if (overridesToReattach == null)
+        {
+            return;
+        }
+
+        foreach (var overrides in overridesToReattach)
+        {
+            var removedOverrides = property.RemoveOverrides(overrides.StoreObject);
+            if (removedOverrides != null)
+            {
+                RelationalPropertyOverrides.Attach(property, removedOverrides);
+            }
+        }
+    }
+}
diff --git a/src/EFCore.Relational/Metadata/Conventions/TriggerConvention.cs b/src/EFCore.Relational/Metadata/Conventions/TriggerConvention.cs
index 01cd41333e..fd2ed5f937 100644
--- a/src/EFCore.Relational/Metadata/Conventions/TriggerConvention.cs
+++ b/src/EFCore.Relational/Metadata/Conventions/TriggerConvention.cs
@@ -49,14 +49,14 @@ public class TriggerConvention : IEntityTypeBaseTypeChangedConvention, IEntityTy
         }
 
         List<IConventionTrigger>? triggersToReattach = null;
-        foreach (var trigger in entityType.GetTriggers())
+        foreach (var trigger in entityType.GetDeclaredTriggers())
         {
             if (trigger.EntityType == entityType)
             {
                 continue;
             }
 
-            triggersToReattach ??= new List<IConventionTrigger>();
+            triggersToReattach ??= new();
 
             triggersToReattach.Add(trigger);
         }
@@ -71,7 +71,7 @@ public class TriggerConvention : IEntityTypeBaseTypeChangedConvention, IEntityTy
             var removedTrigger = entityType.RemoveTrigger(trigger.ModelName);
             if (removedTrigger != null)
             {
-                Trigger.MergeInto(entityType, removedTrigger);
+                Trigger.Attach(entityType, removedTrigger);
             }
         }
     }
diff --git a/src/EFCore.Relational/Metadata/ICheckConstraint.cs b/src/EFCore.Relational/Metadata/ICheckConstraint.cs
index d353cfe9c8..3814c656be 100644
--- a/src/EFCore.Relational/Metadata/ICheckConstraint.cs
+++ b/src/EFCore.Relational/Metadata/ICheckConstraint.cs
@@ -1,8 +1,6 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System.Text;
-
 namespace Microsoft.EntityFrameworkCore.Metadata;
 
 /// <summary>
@@ -17,41 +15,4 @@ public interface ICheckConstraint : IReadOnlyCheckConstraint, IAnnotatable
     ///     Gets the entity type on which this check constraint is defined.
     /// </summary>
     new IEntityType EntityType { get; }
-
-    /// <summary>
-    ///     <para>
-    ///         Creates a human-readable representation of the given metadata.
-    ///     </para>
-    ///     <para>
-    ///         Warning: Do not rely on the format of the returned string.
-    ///         It is designed for debugging only and may change arbitrarily between releases.
-    ///     </para>
-    /// </summary>
-    /// <param name="options">Options for generating the string.</param>
-    /// <param name="indent">The number of indent spaces to use before each new line.</param>
-    /// <returns>A human-readable representation.</returns>
-    string ToDebugString(MetadataDebugStringOptions options = MetadataDebugStringOptions.ShortDefault, int indent = 0)
-    {
-        var builder = new StringBuilder();
-        var indentString = new string(' ', indent);
-
-        builder
-            .Append(indentString)
-            .Append("Check: ");
-
-        builder.Append(ModelName)
-            .Append(" \"")
-            .Append(Sql)
-            .Append('"');
-
-        if ((options & MetadataDebugStringOptions.SingleLine) == 0)
-        {
-            if ((options & MetadataDebugStringOptions.IncludeAnnotations) != 0)
-            {
-                builder.Append(AnnotationsToDebugString(indent: indent + 2));
-            }
-        }
-
-        return builder.ToString();
-    }
 }
diff --git a/src/EFCore.Relational/Metadata/IConventionEntityTypeMappingFragment.cs b/src/EFCore.Relational/Metadata/IConventionEntityTypeMappingFragment.cs
index fb7553795f..ff3f453c23 100644
--- a/src/EFCore.Relational/Metadata/IConventionEntityTypeMappingFragment.cs
+++ b/src/EFCore.Relational/Metadata/IConventionEntityTypeMappingFragment.cs
@@ -16,6 +16,12 @@ public interface IConventionEntityTypeMappingFragment : IReadOnlyEntityTypeMappi
     /// </summary>
     new IConventionEntityType EntityType { get; }
 
+    /// <summary>
+    ///     Gets the builder that can be used to configure this fragment.
+    /// </summary>
+    /// <exception cref="InvalidOperationException">If the fragment has been removed from the model.</exception>
+    new IConventionEntityTypeMappingFragmentBuilder Builder { get; }
+
     /// <summary>
     ///     Returns the configuration source for this fragment.
     /// </summary>
diff --git a/src/EFCore.Relational/Metadata/IConventionRelationalPropertyOverrides.cs b/src/EFCore.Relational/Metadata/IConventionRelationalPropertyOverrides.cs
index 4122aa0517..fff6a25c68 100644
--- a/src/EFCore.Relational/Metadata/IConventionRelationalPropertyOverrides.cs
+++ b/src/EFCore.Relational/Metadata/IConventionRelationalPropertyOverrides.cs
@@ -16,6 +16,12 @@ public interface IConventionRelationalPropertyOverrides : IReadOnlyRelationalPro
     /// </summary>
     new IConventionProperty Property { get; }
 
+    /// <summary>
+    ///     Gets the builder that can be used to configure this function.
+    /// </summary>
+    /// <exception cref="InvalidOperationException">If the function has been removed from the model.</exception>
+    new IConventionRelationalPropertyOverridesBuilder Builder { get; }
+
     /// <summary>
     ///     Returns the configuration source for these overrides.
     /// </summary>
diff --git a/src/EFCore.Relational/Metadata/IReadOnlyCheckConstraint.cs b/src/EFCore.Relational/Metadata/IReadOnlyCheckConstraint.cs
index a9f2f81120..02036b2fe6 100644
--- a/src/EFCore.Relational/Metadata/IReadOnlyCheckConstraint.cs
+++ b/src/EFCore.Relational/Metadata/IReadOnlyCheckConstraint.cs
@@ -1,6 +1,8 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using System.Text;
+
 namespace Microsoft.EntityFrameworkCore.Metadata;
 
 /// <summary>
@@ -57,4 +59,47 @@ public interface IReadOnlyCheckConstraint : IReadOnlyAnnotatable
     ///     Gets the constraint sql used in a check constraint in the database.
     /// </summary>
     string Sql { get; }
+
+    /// <summary>
+    ///     <para>
+    ///         Creates a human-readable representation of the given metadata.
+    ///     </para>
+    ///     <para>
+    ///         Warning: Do not rely on the format of the returned string.
+    ///         It is designed for debugging only and may change arbitrarily between releases.
+    ///     </para>
+    /// </summary>
+    /// <param name="options">Options for generating the string.</param>
+    /// <param name="indent">The number of indent spaces to use before each new line.</param>
+    /// <returns>A human-readable representation.</returns>
+    string ToDebugString(MetadataDebugStringOptions options = MetadataDebugStringOptions.ShortDefault, int indent = 0)
+    {
+        var builder = new StringBuilder();
+        var indentString = new string(' ', indent);
+
+        builder
+            .Append(indentString)
+            .Append("Check: ");
+
+        builder.Append(ModelName);
+        if (Name != ModelName)
+        {
+            builder.Append('*');
+        }
+
+        builder
+            .Append(" \"")
+            .Append(Sql)
+            .Append('"');
+
+        if ((options & MetadataDebugStringOptions.SingleLine) == 0)
+        {
+            if ((options & MetadataDebugStringOptions.IncludeAnnotations) != 0)
+            {
+                builder.Append(AnnotationsToDebugString(indent: indent + 2));
+            }
+        }
+
+        return builder.ToString();
+    }
 }
diff --git a/src/EFCore.Relational/Metadata/IReadOnlyDbFunction.cs b/src/EFCore.Relational/Metadata/IReadOnlyDbFunction.cs
index 100532fc9c..f7c1371521 100644
--- a/src/EFCore.Relational/Metadata/IReadOnlyDbFunction.cs
+++ b/src/EFCore.Relational/Metadata/IReadOnlyDbFunction.cs
@@ -119,6 +119,11 @@ string ToDebugString(MetadataDebugStringOptions options = MetadataDebugStringOpt
 
         builder.Append(Name);
 
+        if (Name != ModelName)
+        {
+            builder.Append('*');
+        }
+
         if ((options & MetadataDebugStringOptions.SingleLine) == 0)
         {
             var parameters = Parameters.ToList();
diff --git a/src/EFCore.Relational/Metadata/IReadOnlyEntityTypeMappingFragment.cs b/src/EFCore.Relational/Metadata/IReadOnlyEntityTypeMappingFragment.cs
index ae79f90cfa..591f6e5529 100644
--- a/src/EFCore.Relational/Metadata/IReadOnlyEntityTypeMappingFragment.cs
+++ b/src/EFCore.Relational/Metadata/IReadOnlyEntityTypeMappingFragment.cs
@@ -1,6 +1,8 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using System.Text;
+
 namespace Microsoft.EntityFrameworkCore.Metadata;
 
 /// <summary>
@@ -26,4 +28,42 @@ public interface IReadOnlyEntityTypeMappingFragment : IReadOnlyAnnotatable
     /// </summary>
     /// <returns>A value indicating whether the associated table is ignored by Migrations.</returns>
     bool? IsTableExcludedFromMigrations { get; }
+
+    /// <summary>
+    ///     <para>
+    ///         Creates a human-readable representation of the given metadata.
+    ///     </para>
+    ///     <para>
+    ///         Warning: Do not rely on the format of the returned string.
+    ///         It is designed for debugging only and may change arbitrarily between releases.
+    ///     </para>
+    /// </summary>
+    /// <param name="options">Options for generating the string.</param>
+    /// <param name="indent">The number of indent spaces to use before each new line.</param>
+    /// <returns>A human-readable representation.</returns>
+    string ToDebugString(MetadataDebugStringOptions options = MetadataDebugStringOptions.ShortDefault, int indent = 0)
+    {
+        var builder = new StringBuilder();
+        var indentString = new string(' ', indent);
+
+        builder
+            .Append(indentString)
+            .Append("Fragment: ")
+            .Append(StoreObject.DisplayName());
+
+        if (IsTableExcludedFromMigrations == true)
+        {
+            builder.Append("ExcludedFromMigrations");
+        }
+
+        if ((options & MetadataDebugStringOptions.SingleLine) == 0)
+        {
+            if ((options & MetadataDebugStringOptions.IncludeAnnotations) != 0)
+            {
+                builder.Append(AnnotationsToDebugString(indent: indent + 2));
+            }
+        }
+
+        return builder.ToString();
+    }
 }
diff --git a/src/EFCore.Relational/Metadata/IReadOnlyRelationalPropertyOverrides.cs b/src/EFCore.Relational/Metadata/IReadOnlyRelationalPropertyOverrides.cs
index 76f806bcf4..5fe8987bf9 100644
--- a/src/EFCore.Relational/Metadata/IReadOnlyRelationalPropertyOverrides.cs
+++ b/src/EFCore.Relational/Metadata/IReadOnlyRelationalPropertyOverrides.cs
@@ -1,6 +1,8 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using System.Text;
+
 namespace Microsoft.EntityFrameworkCore.Metadata;
 
 /// <summary>
@@ -30,4 +32,43 @@ public interface IReadOnlyRelationalPropertyOverrides : IReadOnlyAnnotatable
     ///     Gets a value indicating whether the column name is overriden.
     /// </summary>
     bool ColumnNameOverridden { get; }
+
+    /// <summary>
+    ///     <para>
+    ///         Creates a human-readable representation of the given metadata.
+    ///     </para>
+    ///     <para>
+    ///         Warning: Do not rely on the format of the returned string.
+    ///         It is designed for debugging only and may change arbitrarily between releases.
+    ///     </para>
+    /// </summary>
+    /// <param name="options">Options for generating the string.</param>
+    /// <param name="indent">The number of indent spaces to use before each new line.</param>
+    /// <returns>A human-readable representation.</returns>
+    string ToDebugString(MetadataDebugStringOptions options = MetadataDebugStringOptions.ShortDefault, int indent = 0)
+    {
+        var builder = new StringBuilder();
+        var indentString = new string(' ', indent);
+
+        builder
+            .Append(indentString)
+            .Append("Override: ")
+            .Append(StoreObject.DisplayName());
+
+        if (ColumnNameOverridden)
+        {
+            builder.Append(" ColumnName: ")
+                .Append(ColumnName);
+        }
+
+        if ((options & MetadataDebugStringOptions.SingleLine) == 0)
+        {
+            if ((options & MetadataDebugStringOptions.IncludeAnnotations) != 0)
+            {
+                builder.Append(AnnotationsToDebugString(indent: indent + 2));
+            }
+        }
+
+        return builder.ToString();
+    }
 }
diff --git a/src/EFCore.Relational/Metadata/IReadOnlyTrigger.cs b/src/EFCore.Relational/Metadata/IReadOnlyTrigger.cs
index 9b27689154..a03fdff0e6 100644
--- a/src/EFCore.Relational/Metadata/IReadOnlyTrigger.cs
+++ b/src/EFCore.Relational/Metadata/IReadOnlyTrigger.cs
@@ -1,6 +1,8 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using System.Text;
+
 namespace Microsoft.EntityFrameworkCore.Metadata;
 
 /// <summary>
@@ -67,4 +69,53 @@ public interface IReadOnlyTrigger : IReadOnlyAnnotatable
     ///     Gets the entity type on which this trigger is defined.
     /// </summary>
     IReadOnlyEntityType EntityType { get; }
+
+    /// <summary>
+    ///     <para>
+    ///         Creates a human-readable representation of the given metadata.
+    ///     </para>
+    ///     <para>
+    ///         Warning: Do not rely on the format of the returned string.
+    ///         It is designed for debugging only and may change arbitrarily between releases.
+    ///     </para>
+    /// </summary>
+    /// <param name="options">Options for generating the string.</param>
+    /// <param name="indent">The number of indent spaces to use before each new line.</param>
+    /// <returns>A human-readable representation.</returns>
+    string ToDebugString(MetadataDebugStringOptions options = MetadataDebugStringOptions.ShortDefault, int indent = 0)
+    {
+        var builder = new StringBuilder();
+        var indentString = new string(' ', indent);
+
+        builder
+            .Append(indentString)
+            .Append("Trigger: ")
+            .Append(ModelName);
+
+        if (Name != ModelName)
+        {
+            builder.Append('*');
+        }
+
+        builder.Append(" ");
+
+        if (TableSchema != null)
+        {
+            builder
+                .Append('.')
+                .Append(TableSchema);
+        }
+
+        builder.Append(TableName);
+
+        if ((options & MetadataDebugStringOptions.SingleLine) == 0)
+        {
+            if ((options & MetadataDebugStringOptions.IncludeAnnotations) != 0)
+            {
+                builder.Append(AnnotationsToDebugString(indent: indent + 2));
+            }
+        }
+
+        return builder.ToString();
+    }
 }
diff --git a/src/EFCore.Relational/Metadata/ITableMapping.cs b/src/EFCore.Relational/Metadata/ITableMapping.cs
index bc9c6fa382..71bceeb10a 100644
--- a/src/EFCore.Relational/Metadata/ITableMapping.cs
+++ b/src/EFCore.Relational/Metadata/ITableMapping.cs
@@ -48,13 +48,36 @@ string ToDebugString(MetadataDebugStringOptions options = MetadataDebugStringOpt
             builder.Append("TableMapping: ");
         }
 
-        builder.Append(EntityType.Name).Append(" - ");
+        builder
+            .Append(EntityType.Name)
+            .Append(" - ")
+            .Append(Table.Name);
 
-        builder.Append(Table.Name);
+        builder.Append(" ");
+        if (!IncludesDerivedTypes)
+        {
+            builder.Append("!");
+        }
+        builder.Append("IncludesDerivedTypes");
+
+        if (IsSharedTablePrincipal != null)
+        {
+            builder.Append(" ");
+            if (!IsSharedTablePrincipal.Value)
+            {
+                builder.Append("!");
+            }
+            builder.Append("IsSharedTablePrincipal");
+        }
 
-        if (IncludesDerivedTypes)
+        if (IsSplitEntityTypePrincipal != null)
         {
-            builder.Append(" IncludesDerivedTypes");
+            builder.Append(" ");
+            if (!IsSplitEntityTypePrincipal.Value)
+            {
+                builder.Append("!");
+            }
+            builder.Append("IsSplitEntityTypePrincipal");
         }
 
         if (!singleLine && (options & MetadataDebugStringOptions.IncludeAnnotations) != 0)
diff --git a/src/EFCore.Relational/Metadata/ITrigger.cs b/src/EFCore.Relational/Metadata/ITrigger.cs
index 75434b0c9d..ab5eee6ec5 100644
--- a/src/EFCore.Relational/Metadata/ITrigger.cs
+++ b/src/EFCore.Relational/Metadata/ITrigger.cs
@@ -1,8 +1,6 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System.Text;
-
 namespace Microsoft.EntityFrameworkCore.Metadata;
 
 /// <summary>
@@ -24,35 +22,7 @@ public interface ITrigger : IReadOnlyTrigger, IAnnotatable
     new IEntityType EntityType { get; }
 
     /// <summary>
-    ///     <para>
-    ///         Creates a human-readable representation of the given metadata.
-    ///     </para>
-    ///     <para>
-    ///         Warning: Do not rely on the format of the returned string.
-    ///         It is designed for debugging only and may change arbitrarily between releases.
-    ///     </para>
+    ///     Gets the database name of the trigger.
     /// </summary>
-    /// <param name="options">Options for generating the string.</param>
-    /// <param name="indent">The number of indent spaces to use before each new line.</param>
-    /// <returns>A human-readable representation.</returns>
-    string ToDebugString(MetadataDebugStringOptions options = MetadataDebugStringOptions.ShortDefault, int indent = 0)
-    {
-        var builder = new StringBuilder();
-        var indentString = new string(' ', indent);
-
-        builder
-            .Append(indentString)
-            .Append("Trigger: ")
-            .Append(ModelName);
-
-        if ((options & MetadataDebugStringOptions.SingleLine) == 0)
-        {
-            if ((options & MetadataDebugStringOptions.IncludeAnnotations) != 0)
-            {
-                builder.Append(AnnotationsToDebugString(indent: indent + 2));
-            }
-        }
-
-        return builder.ToString();
-    }
+    new string Name { get; }
 }
diff --git a/src/EFCore.Relational/Metadata/Internal/CheckConstraint.cs b/src/EFCore.Relational/Metadata/Internal/CheckConstraint.cs
index e21dc834c6..91cdf62e3f 100644
--- a/src/EFCore.Relational/Metadata/Internal/CheckConstraint.cs
+++ b/src/EFCore.Relational/Metadata/Internal/CheckConstraint.cs
@@ -169,7 +169,7 @@ public static void Attach(IConventionEntityType entityType, IConventionCheckCons
             detachedCheckConstraint.Sql,
             detachedCheckConstraint.GetConfigurationSource());
 
-        Attach(detachedCheckConstraint, newCheckConstraint);
+        MergeInto(detachedCheckConstraint, newCheckConstraint);
     }
 
     /// <summary>
@@ -178,7 +178,7 @@ public static void Attach(IConventionEntityType entityType, IConventionCheckCons
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    public static void Attach(IConventionCheckConstraint detachedCheckConstraint, IConventionCheckConstraint existingCheckConstraint)
+    public static void MergeInto(IConventionCheckConstraint detachedCheckConstraint, IConventionCheckConstraint existingCheckConstraint)
     {
         var nameConfigurationSource = detachedCheckConstraint.GetNameConfigurationSource();
         if (nameConfigurationSource != null)
@@ -416,6 +416,18 @@ public virtual void UpdateConfigurationSource(ConfigurationSource configurationS
     public override string ToString()
         => ((ICheckConstraint)this).ToDebugString(MetadataDebugStringOptions.SingleLineDefault);
 
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    [EntityFrameworkInternal]
+    public virtual DebugView DebugView
+        => new(
+            () => ((ICheckConstraint)this).ToDebugString(),
+            () => ((ICheckConstraint)this).ToDebugString(MetadataDebugStringOptions.LongDefault));
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
diff --git a/src/EFCore.Relational/Metadata/Internal/DbFunction.cs b/src/EFCore.Relational/Metadata/Internal/DbFunction.cs
index 6ddcf2fea6..2c76de5e50 100644
--- a/src/EFCore.Relational/Metadata/Internal/DbFunction.cs
+++ b/src/EFCore.Relational/Metadata/Internal/DbFunction.cs
@@ -651,6 +651,18 @@ public virtual IReadOnlyList<DbFunctionParameter> Parameters
     public override string ToString()
         => ((IDbFunction)this).ToDebugString(MetadataDebugStringOptions.SingleLineDefault);
 
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    [EntityFrameworkInternal]
+    public virtual DebugView DebugView
+        => new(
+            () => ((IDbFunction)this).ToDebugString(),
+            () => ((IDbFunction)this).ToDebugString(MetadataDebugStringOptions.LongDefault));
+
     /// <inheritdoc />
     IConventionDbFunctionBuilder IConventionDbFunction.Builder
     {
diff --git a/src/EFCore.Relational/Metadata/Internal/EntityTypeMappingFragment.cs b/src/EFCore.Relational/Metadata/Internal/EntityTypeMappingFragment.cs
index fbe0f4e214..8bd2318131 100644
--- a/src/EFCore.Relational/Metadata/Internal/EntityTypeMappingFragment.cs
+++ b/src/EFCore.Relational/Metadata/Internal/EntityTypeMappingFragment.cs
@@ -16,10 +16,11 @@ public class EntityTypeMappingFragment :
     IConventionEntityTypeMappingFragment
 {
     private bool? _isTableExcludedFromMigrations;
+    private InternalEntityTypeMappingFragmentBuilder? _builder;
 
     private ConfigurationSource _configurationSource;
     private ConfigurationSource? _isTableExcludedFromMigrationsConfigurationSource;
-    
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -34,8 +35,39 @@ public class EntityTypeMappingFragment :
         EntityType = entityType;
         StoreObject = storeObject;
         _configurationSource = configurationSource;
+        _builder = new InternalEntityTypeMappingFragmentBuilder(this, ((IConventionModel)entityType.Model).Builder);
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual InternalEntityTypeMappingFragmentBuilder Builder
+    {
+        [DebuggerStepThrough]
+        get => _builder ?? throw new InvalidOperationException(CoreStrings.ObjectRemovedFromModel);
     }
 
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual bool IsInModel
+        => _builder is not null;
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual void SetRemovedFromModel()
+        => _builder = null;
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -79,6 +111,44 @@ public virtual ConfigurationSource GetConfigurationSource()
     public virtual void UpdateConfigurationSource(ConfigurationSource configurationSource)
         => _configurationSource = configurationSource.Max(_configurationSource);
 
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public static void Attach(IConventionEntityType entityType, IConventionEntityTypeMappingFragment detachedFragment)
+    {
+        var newFragment = GetOrCreate(
+            (IMutableEntityType)entityType,
+            detachedFragment.StoreObject,
+            detachedFragment.GetConfigurationSource());
+
+        MergeInto(detachedFragment, newFragment);
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public static EntityTypeMappingFragment MergeInto(
+        IConventionEntityTypeMappingFragment detachedFragment, IConventionEntityTypeMappingFragment existingFragment)
+    {
+        var isTableExcludedFromMigrationsConfigurationSource = detachedFragment.GetIsTableExcludedFromMigrationsConfigurationSource();
+        if (isTableExcludedFromMigrationsConfigurationSource != null)
+        {
+            existingFragment = ((InternalEntityTypeMappingFragmentBuilder)existingFragment.Builder).ExcludeTableFromMigrations(
+                detachedFragment.IsTableExcludedFromMigrations, isTableExcludedFromMigrationsConfigurationSource.Value)
+                !.Metadata;
+        }
+
+        return ((InternalEntityTypeMappingFragmentBuilder)existingFragment.Builder)
+            .MergeAnnotationsFrom((EntityTypeMappingFragment)detachedFragment)
+                .Metadata;
+    }
+
     /// <inheritdoc />
     public virtual bool? IsTableExcludedFromMigrations
     {
@@ -98,7 +168,7 @@ public virtual void UpdateConfigurationSource(ConfigurationSource configurationS
         {
             return null;
         }
-        
+
         _isTableExcludedFromMigrations = excluded;
         _isTableExcludedFromMigrationsConfigurationSource =
             excluded == null
@@ -160,7 +230,7 @@ public virtual void UpdateConfigurationSource(ConfigurationSource configurationS
         var fragment = fragments.Find(storeObject);
         if (fragment == null)
         {
-            fragment = new (entityType, storeObject, configurationSource);
+            fragment = new(entityType, storeObject, configurationSource);
             fragments.Add(storeObject, fragment);
         }
         else
@@ -170,7 +240,7 @@ public virtual void UpdateConfigurationSource(ConfigurationSource configurationS
 
         return fragment;
     }
-    
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -179,8 +249,7 @@ public virtual void UpdateConfigurationSource(ConfigurationSource configurationS
     /// </summary>
     public static EntityTypeMappingFragment? Remove(
         IMutableEntityType entityType,
-        in StoreObjectIdentifier storeObject,
-        ConfigurationSource configurationSource)
+        in StoreObjectIdentifier storeObject)
     {
         var fragments = (StoreObjectDictionary<EntityTypeMappingFragment>?)
             entityType[RelationalAnnotationNames.MappingFragments];
@@ -195,23 +264,40 @@ public virtual void UpdateConfigurationSource(ConfigurationSource configurationS
             return null;
         }
 
-        if (configurationSource.Overrides(fragment.GetConfigurationSource()))
-        {
-            fragments.Remove(storeObject);
-
-            return fragment;
-        }
+        fragments.Remove(storeObject);
+        fragment.SetRemovedFromModel();
 
-        return null;
+        return fragment;
     }
 
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public override string ToString()
+        => ((IEntityTypeMappingFragment)this).ToDebugString(MetadataDebugStringOptions.SingleLineDefault);
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    [EntityFrameworkInternal]
+    public virtual DebugView DebugView
+        => new(
+            () => ((IEntityTypeMappingFragment)this).ToDebugString(),
+            () => ((IEntityTypeMappingFragment)this).ToDebugString(MetadataDebugStringOptions.LongDefault));
+
     /// <inheritdoc />
     IEntityType IEntityTypeMappingFragment.EntityType
     {
         [DebuggerStepThrough]
         get => (IEntityType)EntityType;
     }
-    
+
     /// <inheritdoc />
     IMutableEntityType IMutableEntityTypeMappingFragment.EntityType
     {
@@ -229,5 +315,15 @@ IConventionEntityType IConventionEntityTypeMappingFragment.EntityType
     bool? IConventionEntityTypeMappingFragment.SetIsTableExcludedFromMigrations(bool? excluded, bool fromDataAnnotation)
         => SetIsTableExcludedFromMigrations(excluded, fromDataAnnotation ? ConfigurationSource.DataAnnotation : ConfigurationSource.Convention);
 
-    bool? IReadOnlyEntityTypeMappingFragment.IsTableExcludedFromMigrations => IsTableExcludedFromMigrations;
+    bool? IReadOnlyEntityTypeMappingFragment.IsTableExcludedFromMigrations
+    {
+        [DebuggerStepThrough]
+        get => IsTableExcludedFromMigrations;
+    }
+
+    IConventionEntityTypeMappingFragmentBuilder IConventionEntityTypeMappingFragment.Builder
+    {
+        [DebuggerStepThrough]
+        get => Builder;
+    }
 }
diff --git a/src/EFCore.Relational/Metadata/Internal/InternalCheckConstraintBuilder.cs b/src/EFCore.Relational/Metadata/Internal/InternalCheckConstraintBuilder.cs
index 727c1147f2..5ef202fa24 100644
--- a/src/EFCore.Relational/Metadata/Internal/InternalCheckConstraintBuilder.cs
+++ b/src/EFCore.Relational/Metadata/Internal/InternalCheckConstraintBuilder.cs
@@ -123,7 +123,7 @@ public virtual bool CanSetName(string? name, ConfigurationSource configurationSo
             {
                 foreach (var detachedCheckConstraint in detachedCheckConstraints)
                 {
-                    CheckConstraint.Attach(detachedCheckConstraint, constraint);
+                    CheckConstraint.MergeInto(detachedCheckConstraint, constraint);
                 }
             }
         }
diff --git a/src/EFCore.Relational/Metadata/Internal/InternalEntityTypeMappingFragmentBuilder.cs b/src/EFCore.Relational/Metadata/Internal/InternalEntityTypeMappingFragmentBuilder.cs
new file mode 100644
index 0000000000..ce48ddd90f
--- /dev/null
+++ b/src/EFCore.Relational/Metadata/Internal/InternalEntityTypeMappingFragmentBuilder.cs
@@ -0,0 +1,65 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.EntityFrameworkCore.Metadata.Internal;
+
+/// <summary>
+///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+///     any release. You should only use it directly in your code with extreme caution and knowing that
+///     doing so can result in application failures when updating to a new Entity Framework Core release.
+/// </summary>
+public class InternalEntityTypeMappingFragmentBuilder :
+    AnnotatableBuilder<EntityTypeMappingFragment, IConventionModelBuilder>,
+    IConventionEntityTypeMappingFragmentBuilder
+{
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public InternalEntityTypeMappingFragmentBuilder(
+        EntityTypeMappingFragment fragment, IConventionModelBuilder modelBuilder)
+        : base(fragment, modelBuilder)
+    {
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual InternalEntityTypeMappingFragmentBuilder? ExcludeTableFromMigrations(
+        bool? excludedFromMigrations,
+        ConfigurationSource configurationSource)
+    {
+        if (!CanExcludeTableFromMigrations(excludedFromMigrations, configurationSource))
+        {
+            return null;
+        }
+
+        Metadata.SetIsTableExcludedFromMigrations(excludedFromMigrations, configurationSource);
+        return this;
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual bool CanExcludeTableFromMigrations(
+        bool? excludedFromMigrations,
+        ConfigurationSource configurationSource)
+        => configurationSource.Overrides(Metadata.GetIsTableExcludedFromMigrationsConfigurationSource())
+            || Metadata.IsTableExcludedFromMigrations == excludedFromMigrations;
+
+    /// <inheritdoc />
+    IConventionEntityTypeMappingFragment IConventionEntityTypeMappingFragmentBuilder.Metadata
+    {
+        [DebuggerStepThrough]
+        get => Metadata;
+    }
+}
diff --git a/src/EFCore.Relational/Metadata/Internal/InternalRelationalPropertyOverridesBuilder.cs b/src/EFCore.Relational/Metadata/Internal/InternalRelationalPropertyOverridesBuilder.cs
new file mode 100644
index 0000000000..3b5e1caaf3
--- /dev/null
+++ b/src/EFCore.Relational/Metadata/Internal/InternalRelationalPropertyOverridesBuilder.cs
@@ -0,0 +1,66 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.EntityFrameworkCore.Metadata.Internal;
+
+/// <summary>
+///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+///     any release. You should only use it directly in your code with extreme caution and knowing that
+///     doing so can result in application failures when updating to a new Entity Framework Core release.
+/// </summary>
+public class InternalRelationalPropertyOverridesBuilder :
+    AnnotatableBuilder<RelationalPropertyOverrides, IConventionModelBuilder>,
+    IConventionRelationalPropertyOverridesBuilder
+{
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public InternalRelationalPropertyOverridesBuilder(
+        RelationalPropertyOverrides overrides, IConventionModelBuilder modelBuilder)
+        : base(overrides, modelBuilder)
+    {
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual InternalRelationalPropertyOverridesBuilder? HasColumnName(
+        string? name,
+        ConfigurationSource configurationSource)
+    {
+        if (!CanSetColumnName(name, configurationSource))
+        {
+            return null;
+        }
+
+        Metadata.SetColumnName(name, configurationSource);
+        
+        return this;
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual bool CanSetColumnName(
+        string? name,
+        ConfigurationSource configurationSource)
+        => configurationSource.Overrides(Metadata.GetColumnNameConfigurationSource())
+            || Metadata.ColumnName == name;
+
+    /// <inheritdoc />
+    IConventionRelationalPropertyOverrides IConventionRelationalPropertyOverridesBuilder.Metadata
+    {
+        [DebuggerStepThrough]
+        get => Metadata;
+    }
+}
diff --git a/src/EFCore.Relational/Metadata/Internal/InternalTriggerBuilder.cs b/src/EFCore.Relational/Metadata/Internal/InternalTriggerBuilder.cs
index 2a1850f060..7c38a61978 100644
--- a/src/EFCore.Relational/Metadata/Internal/InternalTriggerBuilder.cs
+++ b/src/EFCore.Relational/Metadata/Internal/InternalTriggerBuilder.cs
@@ -66,7 +66,8 @@ public virtual bool CanSetName(string? name, ConfigurationSource configurationSo
         var trigger = entityType.FindTrigger(name);
         if (trigger != null)
         {
-            if (trigger.TableName == tableName && trigger.TableSchema == tableSchema)
+            if ((tableName == null && tableSchema == null)
+                || (trigger.TableName == tableName && trigger.TableSchema == tableSchema))
             {
                 ((Trigger)trigger).UpdateConfigurationSource(configurationSource);
                 return trigger;
@@ -83,14 +84,14 @@ public virtual bool CanSetName(string? name, ConfigurationSource configurationSo
         {
             foreach (var derivedType in entityType.GetDerivedTypes())
             {
-                var derivedTrigger =
-                    (IConventionTrigger?)Trigger.FindDeclaredTrigger(derivedType, name);
+                var derivedTrigger = (IConventionTrigger?)Trigger.FindDeclaredTrigger(derivedType, name);
                 if (derivedTrigger == null)
                 {
                     continue;
                 }
 
-                if ((derivedTrigger.TableName != tableName || derivedTrigger.TableSchema != tableSchema)
+                if ((tableName != null || tableSchema != null)
+                    && (derivedTrigger.TableName != tableName || derivedTrigger.TableSchema != tableSchema)
                     && !configurationSource.Overrides(derivedTrigger.GetConfigurationSource()))
                 {
                     return null;
@@ -139,6 +140,12 @@ public virtual bool CanSetName(string? name, ConfigurationSource configurationSo
         string? tableSchema,
         ConfigurationSource configurationSource)
     {
+        if (tableName == null
+            && tableSchema == null)
+        {
+            return true;
+        }
+
         if (entityType.FindTrigger(name) is IConventionTrigger trigger)
         {
             return (trigger.TableName == tableName
diff --git a/src/EFCore.Relational/Metadata/Internal/RelationalModel.cs b/src/EFCore.Relational/Metadata/Internal/RelationalModel.cs
index 6bce5b2c86..d01f84c046 100644
--- a/src/EFCore.Relational/Metadata/Internal/RelationalModel.cs
+++ b/src/EFCore.Relational/Metadata/Internal/RelationalModel.cs
@@ -970,7 +970,8 @@ private static void PopulateTableConfiguration(Table table, bool designTime)
                 }
             }
 
-            foreach (var trigger in entityType.GetTriggers())
+            // Triggers cannot be inherited
+            foreach (var trigger in entityType.GetDeclaredTriggers())
             {
                 var name = trigger.GetName(storeObject);
                 if (name == null)
@@ -979,7 +980,7 @@ private static void PopulateTableConfiguration(Table table, bool designTime)
                 }
 
                 Check.DebugAssert(trigger.TableName == table.Name, "Mismatch in trigger table name");
-                Check.DebugAssert(trigger.TableSchema is null || trigger.TableSchema == table.Schema, "Mismatch in trigger table schema");
+                Check.DebugAssert(trigger.TableSchema == table.Schema, "Mismatch in trigger table schema");
 
                 if (!table.Triggers.ContainsKey(name))
                 {
diff --git a/src/EFCore.Relational/Metadata/Internal/RelationalPropertyOverrides.cs b/src/EFCore.Relational/Metadata/Internal/RelationalPropertyOverrides.cs
index 8058c2ab17..aeec0461e2 100644
--- a/src/EFCore.Relational/Metadata/Internal/RelationalPropertyOverrides.cs
+++ b/src/EFCore.Relational/Metadata/Internal/RelationalPropertyOverrides.cs
@@ -16,6 +16,7 @@ public class RelationalPropertyOverrides :
     IRelationalPropertyOverrides
 {
     private string? _columnName;
+    private InternalRelationalPropertyOverridesBuilder? _builder;
 
     private ConfigurationSource _configurationSource;
     private ConfigurationSource? _columnNameConfigurationSource;
@@ -34,6 +35,8 @@ public class RelationalPropertyOverrides :
         Property = property;
         StoreObject = storeObject;
         _configurationSource = configurationSource;
+        _builder = new InternalRelationalPropertyOverridesBuilder(
+            this, ((IConventionModel)property.DeclaringEntityType.Model).Builder);
     }
 
     /// <summary>
@@ -60,6 +63,74 @@ public class RelationalPropertyOverrides :
     /// </summary>
     public override bool IsReadOnly
         => ((Annotatable)Property).IsReadOnly;
+    
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual InternalRelationalPropertyOverridesBuilder Builder
+    {
+        [DebuggerStepThrough]
+        get => _builder ?? throw new InvalidOperationException(CoreStrings.ObjectRemovedFromModel);
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual bool IsInModel
+        => _builder is not null;
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual void SetRemovedFromModel()
+        => _builder = null;
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public static void Attach(IConventionProperty property, IConventionRelationalPropertyOverrides detachedOverrides)
+    {
+        var newOverrides = GetOrCreate(
+            (IMutableProperty)property,
+            detachedOverrides.StoreObject,
+            detachedOverrides.GetConfigurationSource());
+
+        MergeInto(detachedOverrides, newOverrides);
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public static RelationalPropertyOverrides MergeInto(
+        IConventionRelationalPropertyOverrides detachedOverrides, IConventionRelationalPropertyOverrides existingOverrides)
+    {
+        var columnNameConfigurationSource = detachedOverrides.GetColumnNameConfigurationSource();
+        if (columnNameConfigurationSource != null)
+        {
+            existingOverrides = ((InternalRelationalPropertyOverridesBuilder)existingOverrides.Builder)
+                .HasColumnName(detachedOverrides.ColumnName, columnNameConfigurationSource.Value)
+                !.Metadata;
+        }
+
+        return ((InternalRelationalPropertyOverridesBuilder)existingOverrides.Builder)
+            .MergeAnnotationsFrom((RelationalPropertyOverrides)detachedOverrides)
+                .Metadata;
+    }
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
@@ -206,8 +277,7 @@ private bool RemoveColumnNameOverride(ConfigurationSource configurationSource)
     /// </summary>
     public static RelationalPropertyOverrides? Remove(
         IMutableProperty property,
-        in StoreObjectIdentifier storeObject,
-        ConfigurationSource configurationSource)
+        in StoreObjectIdentifier storeObject)
     {
         var tableOverrides = (StoreObjectDictionary<RelationalPropertyOverrides>?)
             property[RelationalAnnotationNames.RelationalOverrides];
@@ -222,16 +292,33 @@ private bool RemoveColumnNameOverride(ConfigurationSource configurationSource)
             return null;
         }
 
-        if (configurationSource.Overrides(overrides.GetConfigurationSource()))
-        {
-            tableOverrides.Remove(storeObject);
+        tableOverrides.Remove(storeObject);
+        overrides.SetRemovedFromModel();
 
-            return overrides;
-        }
-
-        return null;
+        return overrides;
     }
 
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public override string ToString()
+        => ((IRelationalPropertyOverrides)this).ToDebugString(MetadataDebugStringOptions.SingleLineDefault);
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    [EntityFrameworkInternal]
+    public virtual DebugView DebugView
+        => new(
+            () => ((IRelationalPropertyOverrides)this).ToDebugString(),
+            () => ((IRelationalPropertyOverrides)this).ToDebugString(MetadataDebugStringOptions.LongDefault));
+
     /// <inheritdoc />
     IProperty IRelationalPropertyOverrides.Property
     {
@@ -253,6 +340,13 @@ IConventionProperty IConventionRelationalPropertyOverrides.Property
         get => (IConventionProperty)Property;
     }
 
+    /// <inheritdoc />
+    IConventionRelationalPropertyOverridesBuilder IConventionRelationalPropertyOverrides.Builder
+    {
+        [DebuggerStepThrough]
+        get => Builder;
+    }
+
     string? IConventionRelationalPropertyOverrides.SetColumnName(string? name, bool fromDataAnnotation)
         => SetColumnName(name, fromDataAnnotation ? ConfigurationSource.DataAnnotation : ConfigurationSource.Convention);
 
diff --git a/src/EFCore.Relational/Metadata/Internal/Trigger.cs b/src/EFCore.Relational/Metadata/Internal/Trigger.cs
index 58600cb3db..40807b0871 100644
--- a/src/EFCore.Relational/Metadata/Internal/Trigger.cs
+++ b/src/EFCore.Relational/Metadata/Internal/Trigger.cs
@@ -159,7 +159,7 @@ public static IEnumerable<IReadOnlyTrigger> GetTriggers(IReadOnlyEntityType enti
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    public static void MergeInto(IConventionEntityType entityType, IConventionTrigger detachedTrigger)
+    public static void Attach(IConventionEntityType entityType, IConventionTrigger detachedTrigger)
     {
         var newTrigger = new Trigger(
             (IMutableEntityType)entityType,
@@ -257,22 +257,11 @@ public virtual void SetRemovedFromModel()
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
     public virtual string? GetName(in StoreObjectIdentifier storeObject)
-    {
-        if (storeObject.StoreObjectType != StoreObjectType.Table)
-        {
-            return null;
-        }
-
-        foreach (var containingType in EntityType.GetDerivedTypesInclusive())
-        {
-            if (StoreObjectIdentifier.Create(containingType, storeObject.StoreObjectType) == storeObject)
-            {
-                return _name ?? ((IReadOnlyTrigger)this).GetDefaultName(storeObject);
-            }
-        }
-
-        return null;
-    }
+        => storeObject.StoreObjectType == StoreObjectType.Table
+                && TableName == storeObject.Name
+                && TableSchema == storeObject.Schema
+            ? _name ?? ((IReadOnlyTrigger)this).GetDefaultName(storeObject)
+            : null;
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
@@ -346,7 +335,7 @@ public virtual string TableName
     /// </summary>
     public virtual string? TableSchema
     {
-        get => _tableSchema;
+        get => _tableSchema ?? EntityType.GetSchema();
         set => SetTableSchema(value, ConfigurationSource.Explicit);
     }
 
@@ -406,6 +395,18 @@ public virtual void UpdateConfigurationSource(ConfigurationSource configurationS
     public override string ToString()
         => ((ITrigger)this).ToDebugString(MetadataDebugStringOptions.SingleLineDefault);
 
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    [EntityFrameworkInternal]
+    public virtual DebugView DebugView
+        => new(
+            () => ((ITrigger)this).ToDebugString(),
+            () => ((ITrigger)this).ToDebugString(MetadataDebugStringOptions.LongDefault));
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -442,6 +443,18 @@ IEntityType ITrigger.EntityType
         get => (IEntityType)EntityType;
     }
 
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    string ITrigger.Name
+    {
+        [DebuggerStepThrough]
+        get => Name!;
+    }
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
diff --git a/src/EFCore.Relational/Metadata/RuntimeEntityTypeMappingFragment.cs b/src/EFCore.Relational/Metadata/RuntimeEntityTypeMappingFragment.cs
index ccd5d23150..15e0ae4c66 100644
--- a/src/EFCore.Relational/Metadata/RuntimeEntityTypeMappingFragment.cs
+++ b/src/EFCore.Relational/Metadata/RuntimeEntityTypeMappingFragment.cs
@@ -43,6 +43,22 @@ public class RuntimeEntityTypeMappingFragment : AnnotatableBase, IEntityTypeMapp
     /// <inheritdoc />
     public virtual bool? IsTableExcludedFromMigrations => (bool?)this[RelationalAnnotationNames.IsTableExcludedFromMigrations];
 
+    /// <inheritdoc />
+    public override string ToString()
+        => ((IEntityTypeMappingFragment)this).ToDebugString(MetadataDebugStringOptions.SingleLineDefault);
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    [EntityFrameworkInternal]
+    public virtual DebugView DebugView
+        => new(
+            () => ((IEntityTypeMappingFragment)this).ToDebugString(),
+            () => ((IEntityTypeMappingFragment)this).ToDebugString(MetadataDebugStringOptions.LongDefault));
+
     /// <inheritdoc />
     IEntityType IEntityTypeMappingFragment.EntityType
     {
diff --git a/src/EFCore.Relational/Metadata/RuntimeRelationalPropertyOverrides.cs b/src/EFCore.Relational/Metadata/RuntimeRelationalPropertyOverrides.cs
index 224554159e..43f8fb1110 100644
--- a/src/EFCore.Relational/Metadata/RuntimeRelationalPropertyOverrides.cs
+++ b/src/EFCore.Relational/Metadata/RuntimeRelationalPropertyOverrides.cs
@@ -40,6 +40,22 @@ public class RuntimeRelationalPropertyOverrides : AnnotatableBase, IRelationalPr
     /// <inheritdoc />
     public virtual StoreObjectIdentifier StoreObject { get; }
 
+    /// <inheritdoc />
+    public override string ToString()
+        => ((IRelationalPropertyOverrides)this).ToDebugString(MetadataDebugStringOptions.SingleLineDefault);
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    [EntityFrameworkInternal]
+    public virtual DebugView DebugView
+        => new(
+            () => ((IRelationalPropertyOverrides)this).ToDebugString(),
+            () => ((IRelationalPropertyOverrides)this).ToDebugString(MetadataDebugStringOptions.LongDefault));
+
     /// <inheritdoc />
     IProperty IRelationalPropertyOverrides.Property
     {
diff --git a/src/EFCore.Relational/Metadata/RuntimeTrigger.cs b/src/EFCore.Relational/Metadata/RuntimeTrigger.cs
index ed95ba9e6e..e5ad7097b4 100644
--- a/src/EFCore.Relational/Metadata/RuntimeTrigger.cs
+++ b/src/EFCore.Relational/Metadata/RuntimeTrigger.cs
@@ -20,7 +20,7 @@ public class RuntimeTrigger : AnnotatableBase, ITrigger
     public RuntimeTrigger(
         RuntimeEntityType entityType,
         string modelName,
-        string? name,
+        string name,
         string tableName,
         string? tableSchema)
     {
@@ -37,11 +37,15 @@ public class RuntimeTrigger : AnnotatableBase, ITrigger
     /// <summary>
     ///     Gets the database name of the trigger.
     /// </summary>
-    public virtual string? Name { get; }
+    public virtual string Name { get; }
 
     /// <inheritdoc />
     public virtual string? GetName(in StoreObjectIdentifier storeObject)
-        => Name;
+        => storeObject.StoreObjectType == StoreObjectType.Table
+                && TableName == storeObject.Name
+                && TableSchema == storeObject.Schema
+            ? Name
+            : null;
 
     /// <inheritdoc />
     public virtual string TableName { get; }
@@ -52,6 +56,22 @@ public class RuntimeTrigger : AnnotatableBase, ITrigger
     /// <inheritdoc />
     public virtual IEntityType EntityType { get; }
 
+    /// <inheritdoc />
+    public override string ToString()
+        => ((ITrigger)this).ToDebugString(MetadataDebugStringOptions.SingleLineDefault);
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    [EntityFrameworkInternal]
+    public virtual DebugView DebugView
+        => new(
+            () => ((ITrigger)this).ToDebugString(),
+            () => ((ITrigger)this).ToDebugString(MetadataDebugStringOptions.LongDefault));
+
     /// <inheritdoc />
     IReadOnlyEntityType IReadOnlyTrigger.EntityType
         => EntityType;
diff --git a/src/EFCore.SqlServer/Design/Internal/SqlServerAnnotationCodeGenerator.cs b/src/EFCore.SqlServer/Design/Internal/SqlServerAnnotationCodeGenerator.cs
index c26efe1b24..2f6cf549ec 100644
--- a/src/EFCore.SqlServer/Design/Internal/SqlServerAnnotationCodeGenerator.cs
+++ b/src/EFCore.SqlServer/Design/Internal/SqlServerAnnotationCodeGenerator.cs
@@ -176,6 +176,13 @@ public SqlServerAnnotationCodeGenerator(AnnotationCodeGeneratorDependencies depe
         return fragments;
     }
 
+    /// <inheritdoc />
+    public override IReadOnlyList<MethodCallCodeFragment> GenerateFluentApiCalls(
+        IRelationalPropertyOverrides overrides, IDictionary<String, IAnnotation> annotations)
+    {
+        return base.GenerateFluentApiCalls(overrides, annotations);
+    }
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
diff --git a/src/EFCore.SqlServer/Design/Internal/SqlServerCSharpRuntimeAnnotationCodeGenerator.cs b/src/EFCore.SqlServer/Design/Internal/SqlServerCSharpRuntimeAnnotationCodeGenerator.cs
index c1552ade2f..67a61fdf33 100644
--- a/src/EFCore.SqlServer/Design/Internal/SqlServerCSharpRuntimeAnnotationCodeGenerator.cs
+++ b/src/EFCore.SqlServer/Design/Internal/SqlServerCSharpRuntimeAnnotationCodeGenerator.cs
@@ -106,4 +106,17 @@ public override void Generate(IEntityType entityType, CSharpRuntimeAnnotationCod
 
         base.Generate(entityType, parameters);
     }
+
+    /// <inheritdoc />
+    public override void Generate(IRelationalPropertyOverrides overrides, CSharpRuntimeAnnotationCodeGeneratorParameters parameters)
+    {
+        if (!parameters.IsRuntime)
+        {
+            var annotations = parameters.Annotations;
+            annotations.Remove(SqlServerAnnotationNames.IdentityIncrement);
+            annotations.Remove(SqlServerAnnotationNames.IdentitySeed);
+        }
+        
+        base.Generate(overrides, parameters);
+    }
 }
diff --git a/src/EFCore.SqlServer/Extensions/SqlServerPropertyBuilderExtensions.cs b/src/EFCore.SqlServer/Extensions/SqlServerPropertyBuilderExtensions.cs
index 5bf965a51d..ee6a0003c0 100644
--- a/src/EFCore.SqlServer/Extensions/SqlServerPropertyBuilderExtensions.cs
+++ b/src/EFCore.SqlServer/Extensions/SqlServerPropertyBuilderExtensions.cs
@@ -183,6 +183,32 @@ public static class SqlServerPropertyBuilderExtensions
         int increment = 1)
         => propertyBuilder.UseIdentityColumn((long)seed, increment);
 
+    /// <summary>
+    ///     Configures the key column to use the SQL Server IDENTITY feature to generate values for new entities,
+    ///     when targeting SQL Server. This method sets the property to be <see cref="ValueGenerated.OnAdd" />.
+    /// </summary>
+    /// <remarks>
+    ///     See <see href="https://aka.ms/efcore-docs-modeling">Modeling entity types and relationships</see>, and
+    ///     <see href="https://aka.ms/efcore-docs-sqlserver">Accessing SQL Server and SQL Azure databases with EF Core</see>
+    ///     for more information and examples.
+    /// </remarks>
+    /// <param name="columnBuilder">The builder for the column being configured.</param>
+    /// <param name="seed">The value that is used for the very first row loaded into the table.</param>
+    /// <param name="increment">The incremental value that is added to the identity value of the previous row that was loaded.</param>
+    /// <returns>The same builder instance so that multiple calls can be chained.</returns>
+    public static ColumnBuilder UseIdentityColumn(
+        this ColumnBuilder columnBuilder,
+        long seed = 1,
+        int increment = 1)
+    {
+        var overrides = columnBuilder.Overrides;
+        overrides.SetValueGenerationStrategy(SqlServerValueGenerationStrategy.IdentityColumn);
+        overrides.SetIdentitySeed(seed);
+        overrides.SetIdentityIncrement(increment);
+
+        return columnBuilder;
+    }
+
     /// <summary>
     ///     Configures the key property to use the SQL Server IDENTITY feature to generate values for new entities,
     ///     when targeting SQL Server. This method sets the property to be <see cref="ValueGenerated.OnAdd" />.
@@ -223,6 +249,26 @@ public static class SqlServerPropertyBuilderExtensions
         int increment = 1)
         => (PropertyBuilder<TProperty>)UseIdentityColumn((PropertyBuilder)propertyBuilder, (long)seed, increment);
 
+    /// <summary>
+    ///     Configures the key column to use the SQL Server IDENTITY feature to generate values for new entities,
+    ///     when targeting SQL Server. This method sets the property to be <see cref="ValueGenerated.OnAdd" />.
+    /// </summary>
+    /// <remarks>
+    ///     See <see href="https://aka.ms/efcore-docs-modeling">Modeling entity types and relationships</see>, and
+    ///     <see href="https://aka.ms/efcore-docs-sqlserver">Accessing SQL Server and SQL Azure databases with EF Core</see>
+    ///     for more information and examples.
+    /// </remarks>
+    /// <typeparam name="TProperty">The type of the property being configured.</typeparam>
+    /// <param name="columnBuilder">The builder for the column being configured.</param>
+    /// <param name="seed">The value that is used for the very first row loaded into the table.</param>
+    /// <param name="increment">The incremental value that is added to the identity value of the previous row that was loaded.</param>
+    /// <returns>The same builder instance so that multiple calls can be chained.</returns>
+    public static ColumnBuilder<TProperty> UseIdentityColumn<TProperty>(
+        this ColumnBuilder<TProperty> columnBuilder,
+        long seed = 1,
+        int increment = 1)
+        => (ColumnBuilder<TProperty>)UseIdentityColumn((ColumnBuilder)columnBuilder, seed, increment);
+
     /// <summary>
     ///     Configures the seed for SQL Server IDENTITY.
     /// </summary>
@@ -252,6 +298,37 @@ public static class SqlServerPropertyBuilderExtensions
         return null;
     }
 
+    /// <summary>
+    ///     Configures the seed for SQL Server IDENTITY for a particular table.
+    /// </summary>
+    /// <remarks>
+    ///     See <see href="https://aka.ms/efcore-docs-modeling">Modeling entity types and relationships</see>, and
+    ///     <see href="https://aka.ms/efcore-docs-sqlserver">Accessing SQL Server and SQL Azure databases with EF Core</see>
+    ///     for more information and examples.
+    /// </remarks>
+    /// <param name="propertyBuilder">The builder for the property being configured.</param>
+    /// <param name="seed">The value that is used for the very first row loaded into the table.</param>
+    /// <param name="storeObject">The table identifier.</param>
+    /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
+    /// <returns>
+    ///     The same builder instance if the configuration was applied,
+    ///     <see langword="null" /> otherwise.
+    /// </returns>
+    public static IConventionPropertyBuilder? HasIdentityColumnSeed(
+        this IConventionPropertyBuilder propertyBuilder,
+        long? seed,
+        in StoreObjectIdentifier storeObject,
+        bool fromDataAnnotation = false)
+    {
+        if (propertyBuilder.CanSetIdentityColumnSeed(seed, storeObject, fromDataAnnotation))
+        {
+            propertyBuilder.Metadata.SetIdentitySeed(seed, storeObject, fromDataAnnotation);
+            return propertyBuilder;
+        }
+
+        return null;
+    }
+
     /// <summary>
     ///     Returns a value indicating whether the given value can be set as the seed for SQL Server IDENTITY.
     /// </summary>
@@ -270,6 +347,32 @@ public static class SqlServerPropertyBuilderExtensions
         bool fromDataAnnotation = false)
         => propertyBuilder.CanSetAnnotation(SqlServerAnnotationNames.IdentitySeed, seed, fromDataAnnotation);
 
+    /// <summary>
+    ///     Returns a value indicating whether the given value can be set as the seed for SQL Server IDENTITY
+    ///     for a particular table.
+    /// </summary>
+    /// <remarks>
+    ///     See <see href="https://aka.ms/efcore-docs-modeling">Modeling entity types and relationships</see>, and
+    ///     <see href="https://aka.ms/efcore-docs-sqlserver">Accessing SQL Server and SQL Azure databases with EF Core</see>
+    ///     for more information and examples.
+    /// </remarks>
+    /// <param name="propertyBuilder">The builder for the property being configured.</param>
+    /// <param name="seed">The value that is used for the very first row loaded into the table.</param>
+    /// <param name="storeObject">The table identifier.</param>
+    /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
+    /// <returns><see langword="true" /> if the given value can be set as the seed for SQL Server IDENTITY.</returns>
+    public static bool CanSetIdentityColumnSeed(
+        this IConventionPropertyBuilder propertyBuilder,
+        long? seed,
+        in StoreObjectIdentifier storeObject,
+        bool fromDataAnnotation = false)
+        => propertyBuilder.Metadata.FindOverrides(storeObject)?.Builder
+            .CanSetAnnotation(
+                SqlServerAnnotationNames.IdentitySeed,
+                seed,
+                fromDataAnnotation)
+            ?? true;
+
     /// <summary>
     ///     Configures the increment for SQL Server IDENTITY.
     /// </summary>
@@ -299,6 +402,37 @@ public static class SqlServerPropertyBuilderExtensions
         return null;
     }
 
+    /// <summary>
+    ///     Configures the increment for SQL Server IDENTITY for a particular table.
+    /// </summary>
+    /// <remarks>
+    ///     See <see href="https://aka.ms/efcore-docs-modeling">Modeling entity types and relationships</see>, and
+    ///     <see href="https://aka.ms/efcore-docs-sqlserver">Accessing SQL Server and SQL Azure databases with EF Core</see>
+    ///     for more information and examples.
+    /// </remarks>
+    /// <param name="propertyBuilder">The builder for the property being configured.</param>
+    /// <param name="increment">The incremental value that is added to the identity value of the previous row that was loaded.</param> 
+    /// <param name="storeObject">The table identifier.</param>
+    /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
+    /// <returns>
+    ///     The same builder instance if the configuration was applied,
+    ///     <see langword="null" /> otherwise.
+    /// </returns>
+    public static IConventionPropertyBuilder? HasIdentityColumnIncrement(
+        this IConventionPropertyBuilder propertyBuilder,
+        int? increment,
+        in StoreObjectIdentifier storeObject,
+        bool fromDataAnnotation = false)
+    {
+        if (propertyBuilder.CanSetIdentityColumnIncrement(increment, storeObject, fromDataAnnotation))
+        {
+            propertyBuilder.Metadata.SetIdentityIncrement(increment, storeObject, fromDataAnnotation);
+            return propertyBuilder;
+        }
+
+        return null;
+    }
+
     /// <summary>
     ///     Returns a value indicating whether the given value can be set as the increment for SQL Server IDENTITY.
     /// </summary>
@@ -317,6 +451,32 @@ public static class SqlServerPropertyBuilderExtensions
         bool fromDataAnnotation = false)
         => propertyBuilder.CanSetAnnotation(SqlServerAnnotationNames.IdentityIncrement, increment, fromDataAnnotation);
 
+    /// <summary>
+    ///     Returns a value indicating whether the given value can be set as the increment for SQL Server IDENTITY
+    ///     for a particular table.
+    /// </summary>
+    /// <remarks>
+    ///     See <see href="https://aka.ms/efcore-docs-modeling">Modeling entity types and relationships</see>, and
+    ///     <see href="https://aka.ms/efcore-docs-sqlserver">Accessing SQL Server and SQL Azure databases with EF Core</see>
+    ///     for more information and examples.
+    /// </remarks>
+    /// <param name="propertyBuilder">The builder for the property being configured.</param>
+    /// <param name="increment">The incremental value that is added to the identity value of the previous row that was loaded.</param>
+    /// <param name="storeObject">The table identifier.</param>
+    /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
+    /// <returns><see langword="true" /> if the given value can be set as the default increment for SQL Server IDENTITY.</returns>
+    public static bool CanSetIdentityColumnIncrement(
+        this IConventionPropertyBuilder propertyBuilder,
+        int? increment,
+        in StoreObjectIdentifier storeObject,
+        bool fromDataAnnotation = false)
+        => propertyBuilder.Metadata.FindOverrides(storeObject)?.Builder
+            .CanSetAnnotation(
+                SqlServerAnnotationNames.IdentityIncrement,
+                increment,
+                fromDataAnnotation)
+            ?? true;
+
     /// <summary>
     ///     Configures the value generation strategy for the key property, when targeting SQL Server.
     /// </summary>
@@ -358,6 +518,43 @@ public static class SqlServerPropertyBuilderExtensions
         return null;
     }
 
+    /// <summary>
+    ///     Configures the value generation strategy for the key property, when targeting SQL Server for a particular table.
+    /// </summary>
+    /// <remarks>
+    ///     See <see href="https://aka.ms/efcore-docs-modeling">Modeling entity types and relationships</see>, and
+    ///     <see href="https://aka.ms/efcore-docs-sqlserver">Accessing SQL Server and SQL Azure databases with EF Core</see>
+    ///     for more information and examples.
+    /// </remarks>
+    /// <param name="propertyBuilder">The builder for the property being configured.</param>
+    /// <param name="valueGenerationStrategy">The value generation strategy.</param>
+    /// <param name="storeObject">The table identifier.</param>
+    /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
+    /// <returns>
+    ///     The same builder instance if the configuration was applied,
+    ///     <see langword="null" /> otherwise.
+    /// </returns>
+    public static IConventionPropertyBuilder? HasValueGenerationStrategy(
+        this IConventionPropertyBuilder propertyBuilder,
+        SqlServerValueGenerationStrategy? valueGenerationStrategy,
+        in StoreObjectIdentifier storeObject,
+        bool fromDataAnnotation = false)
+    {
+        if (propertyBuilder.CanSetValueGenerationStrategy(valueGenerationStrategy, storeObject, fromDataAnnotation))
+        {
+            propertyBuilder.Metadata.SetValueGenerationStrategy(valueGenerationStrategy, storeObject, fromDataAnnotation);
+            if (valueGenerationStrategy != SqlServerValueGenerationStrategy.IdentityColumn)
+            {
+                propertyBuilder.HasIdentityColumnSeed(null, storeObject, fromDataAnnotation);
+                propertyBuilder.HasIdentityColumnIncrement(null, storeObject, fromDataAnnotation);
+            }
+
+            return propertyBuilder;
+        }
+
+        return null;
+    }
+
     /// <summary>
     ///     Returns a value indicating whether the given value can be set as the value generation strategy.
     /// </summary>
@@ -379,6 +576,33 @@ public static class SqlServerPropertyBuilderExtensions
             && propertyBuilder.CanSetAnnotation(
                 SqlServerAnnotationNames.ValueGenerationStrategy, valueGenerationStrategy, fromDataAnnotation);
 
+    /// <summary>
+    ///     Returns a value indicating whether the given value can be set as the value generation strategy for a particular table.
+    /// </summary>
+    /// <remarks>
+    ///     See <see href="https://aka.ms/efcore-docs-modeling">Modeling entity types and relationships</see>, and
+    ///     <see href="https://aka.ms/efcore-docs-sqlserver">Accessing SQL Server and SQL Azure databases with EF Core</see>
+    ///     for more information and examples.
+    /// </remarks>
+    /// <param name="propertyBuilder">The builder for the property being configured.</param>
+    /// <param name="valueGenerationStrategy">The value generation strategy.</param>
+    /// <param name="storeObject">The table identifier.</param>
+    /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
+    /// <returns><see langword="true" /> if the given value can be set as the default value generation strategy.</returns>
+    public static bool CanSetValueGenerationStrategy(
+        this IConventionPropertyBuilder propertyBuilder,
+        SqlServerValueGenerationStrategy? valueGenerationStrategy,
+        in StoreObjectIdentifier storeObject,
+        bool fromDataAnnotation = false)
+        => (valueGenerationStrategy == null
+                || SqlServerPropertyExtensions.IsCompatibleWithValueGeneration(propertyBuilder.Metadata))
+            && (propertyBuilder.Metadata.FindOverrides(storeObject)?.Builder
+                .CanSetAnnotation(
+                    SqlServerAnnotationNames.ValueGenerationStrategy,
+                    valueGenerationStrategy,
+                    fromDataAnnotation)
+                ?? true);
+
     /// <summary>
     ///     Configures whether the property's column is created as sparse when targeting SQL Server.
     /// </summary>
diff --git a/src/EFCore.SqlServer/Extensions/SqlServerPropertyExtensions.cs b/src/EFCore.SqlServer/Extensions/SqlServerPropertyExtensions.cs
index 2cfa3f3d20..ec60455e0e 100644
--- a/src/EFCore.SqlServer/Extensions/SqlServerPropertyExtensions.cs
+++ b/src/EFCore.SqlServer/Extensions/SqlServerPropertyExtensions.cs
@@ -231,6 +231,12 @@ public static void SetHiLoSequenceSchema(this IMutableProperty property, string?
             throw new InvalidOperationException(CoreStrings.RuntimeModelMissingData);
         }
 
+        var @override = property.FindOverrides(storeObject)?.FindAnnotation(SqlServerAnnotationNames.IdentitySeed);
+        if (@override != null)
+        {
+            return (long?)@override.Value;
+        }
+
         var annotation = property.FindAnnotation(SqlServerAnnotationNames.IdentitySeed);
         if (annotation is not null)
         {
@@ -246,6 +252,16 @@ public static void SetHiLoSequenceSchema(this IMutableProperty property, string?
             : sharedProperty.GetIdentitySeed(storeObject);
     }
 
+    /// <summary>
+    ///     Returns the identity seed.
+    /// </summary>
+    /// <param name="overrides">The property overrides.</param>
+    /// <returns>The identity seed.</returns>
+    public static long? GetIdentitySeed(this IReadOnlyRelationalPropertyOverrides overrides)
+        => overrides is RuntimeRelationalPropertyOverrides
+            ? throw new InvalidOperationException(CoreStrings.RuntimeModelMissingData)
+            : (long?)overrides.FindAnnotation(SqlServerAnnotationNames.IdentitySeed)?.Value;
+
     /// <summary>
     ///     Sets the identity seed.
     /// </summary>
@@ -276,6 +292,56 @@ public static void SetIdentitySeed(this IMutableProperty property, long? seed)
         return seed;
     }
 
+    /// <summary>
+    ///     Sets the identity seed for a particular table.
+    /// </summary>
+    /// <param name="property">The property.</param>
+    /// <param name="seed">The value to set.</param>
+    /// <param name="storeObject">The identifier of the table containing the column.</param>
+    public static void SetIdentitySeed(
+        this IMutableProperty property,
+        long? seed,
+        in StoreObjectIdentifier storeObject)
+        => property.GetOrCreateOverrides(storeObject)
+            .SetIdentitySeed(seed);
+
+    /// <summary>
+    ///     Sets the identity seed for a particular table.
+    /// </summary>
+    /// <param name="property">The property.</param>
+    /// <param name="seed">The value to set.</param>
+    /// <param name="storeObject">The identifier of the table containing the column.</param>
+    /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
+    /// <returns>The configured value.</returns>
+    public static long? SetIdentitySeed(
+        this IConventionProperty property,
+        long? seed,
+        in StoreObjectIdentifier storeObject,
+        bool fromDataAnnotation = false)
+        => property.GetOrCreateOverrides(storeObject, fromDataAnnotation)
+            .SetIdentitySeed(seed, fromDataAnnotation);
+
+    /// <summary>
+    ///     Sets the identity seed for a particular table.
+    /// </summary>
+    /// <param name="overrides">The property overrides.</param>
+    /// <param name="seed">The value to set.</param>
+    public static void SetIdentitySeed(this IMutableRelationalPropertyOverrides overrides, long? seed)
+        => overrides.SetOrRemoveAnnotation(SqlServerAnnotationNames.IdentitySeed, seed);
+
+    /// <summary>
+    ///     Sets the identity seed for a particular table.
+    /// </summary>
+    /// <param name="overrides">The property overrides.</param>
+    /// <param name="seed">The value to set.</param>
+    /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
+    /// <returns>The configured value.</returns>
+    public static long? SetIdentitySeed(
+        this IConventionRelationalPropertyOverrides overrides,
+        long? seed,
+        bool fromDataAnnotation = false)
+        => (long?)overrides.SetOrRemoveAnnotation(SqlServerAnnotationNames.IdentitySeed, seed, fromDataAnnotation)?.Value;
+
     /// <summary>
     ///     Returns the <see cref="ConfigurationSource" /> for the identity seed.
     /// </summary>
@@ -284,6 +350,26 @@ public static void SetIdentitySeed(this IMutableProperty property, long? seed)
     public static ConfigurationSource? GetIdentitySeedConfigurationSource(this IConventionProperty property)
         => property.FindAnnotation(SqlServerAnnotationNames.IdentitySeed)?.GetConfigurationSource();
 
+    /// <summary>
+    ///     Returns the <see cref="ConfigurationSource" /> for the identity seed for a particular table.
+    /// </summary>
+    /// <param name="property">The property.</param>
+    /// <param name="storeObject">The identifier of the table containing the column.</param>
+    /// <returns>The <see cref="ConfigurationSource" /> for the identity seed.</returns>
+    public static ConfigurationSource? GetIdentitySeedConfigurationSource(
+        this IConventionProperty property,
+        in StoreObjectIdentifier storeObject)
+        => property.FindOverrides(storeObject)?.GetIdentitySeedConfigurationSource();
+
+    /// <summary>
+    ///     Returns the <see cref="ConfigurationSource" /> for the identity seed for a particular table.
+    /// </summary>
+    /// <param name="overrides">The property overrides.</param>
+    /// <returns>The <see cref="ConfigurationSource" /> for the identity seed.</returns>
+    public static ConfigurationSource? GetIdentitySeedConfigurationSource(
+        this IConventionRelationalPropertyOverrides overrides)
+        => overrides.FindAnnotation(SqlServerAnnotationNames.IdentitySeed)?.GetConfigurationSource();
+
     /// <summary>
     ///     Returns the identity increment.
     /// </summary>
@@ -308,6 +394,12 @@ public static void SetIdentitySeed(this IMutableProperty property, long? seed)
             throw new InvalidOperationException(CoreStrings.RuntimeModelMissingData);
         }
 
+        var @override = property.FindOverrides(storeObject)?.FindAnnotation(SqlServerAnnotationNames.IdentityIncrement);
+        if (@override != null)
+        {
+            return (int?)@override.Value;
+        }
+
         var annotation = property.FindAnnotation(SqlServerAnnotationNames.IdentityIncrement);
         if (annotation != null)
         {
@@ -320,6 +412,16 @@ public static void SetIdentitySeed(this IMutableProperty property, long? seed)
             : sharedProperty.GetIdentityIncrement(storeObject);
     }
 
+    /// <summary>
+    ///     Returns the identity increment.
+    /// </summary>
+    /// <param name="overrides">The property overrides.</param>
+    /// <returns>The identity increment.</returns>
+    public static int? GetIdentityIncrement(this IReadOnlyRelationalPropertyOverrides overrides)
+        => overrides is RuntimeRelationalPropertyOverrides
+            ? throw new InvalidOperationException(CoreStrings.RuntimeModelMissingData)
+            : (int?)overrides.FindAnnotation(SqlServerAnnotationNames.IdentityIncrement)?.Value;
+
     /// <summary>
     ///     Sets the identity increment.
     /// </summary>
@@ -341,14 +443,61 @@ public static void SetIdentityIncrement(this IMutableProperty property, int? inc
         this IConventionProperty property,
         int? increment,
         bool fromDataAnnotation = false)
-    {
-        property.SetOrRemoveAnnotation(
+        => (int?)property.SetOrRemoveAnnotation(
             SqlServerAnnotationNames.IdentityIncrement,
             increment,
-            fromDataAnnotation);
+            fromDataAnnotation)?.Value;
 
-        return increment;
-    }
+    /// <summary>
+    ///     Sets the identity increment for a particular table.
+    /// </summary>
+    /// <param name="property">The property.</param>
+    /// <param name="increment">The value to set.</param>
+    /// <param name="storeObject">The identifier of the table containing the column.</param>
+    public static void SetIdentityIncrement(
+        this IMutableProperty property,
+        int? increment,
+        in StoreObjectIdentifier storeObject)
+        => property.GetOrCreateOverrides(storeObject)
+            .SetIdentityIncrement(increment);
+
+    /// <summary>
+    ///     Sets the identity increment for a particular table.
+    /// </summary>
+    /// <param name="property">The property.</param>
+    /// <param name="increment">The value to set.</param>
+    /// <param name="storeObject">The identifier of the table containing the column.</param>
+    /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
+    /// <returns>The configured value.</returns>
+    public static int? SetIdentityIncrement(
+        this IConventionProperty property,
+        int? increment,
+        in StoreObjectIdentifier storeObject,
+        bool fromDataAnnotation = false)
+        => property.GetOrCreateOverrides(storeObject, fromDataAnnotation)
+            .SetIdentityIncrement(increment, fromDataAnnotation);
+
+    /// <summary>
+    ///     Sets the identity increment for a particular table.
+    /// </summary>
+    /// <param name="overrides">The property overrides.</param>
+    /// <param name="increment">The value to set.</param>
+    public static void SetIdentityIncrement(this IMutableRelationalPropertyOverrides overrides, int? increment)
+        => overrides.SetOrRemoveAnnotation(SqlServerAnnotationNames.IdentityIncrement, increment);
+
+    /// <summary>
+    ///     Sets the identity increment for a particular table.
+    /// </summary>
+    /// <param name="overrides">The property overrides.</param>
+    /// <param name="increment">The value to set.</param>
+    /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
+    /// <returns>The configured value.</returns>
+    public static int? SetIdentityIncrement(
+        this IConventionRelationalPropertyOverrides overrides,
+        int? increment,
+        bool fromDataAnnotation = false)
+        => (int?)overrides.SetOrRemoveAnnotation(SqlServerAnnotationNames.IdentityIncrement, increment, fromDataAnnotation)
+            ?.Value;
 
     /// <summary>
     ///     Returns the <see cref="ConfigurationSource" /> for the identity increment.
@@ -358,6 +507,26 @@ public static void SetIdentityIncrement(this IMutableProperty property, int? inc
     public static ConfigurationSource? GetIdentityIncrementConfigurationSource(this IConventionProperty property)
         => property.FindAnnotation(SqlServerAnnotationNames.IdentityIncrement)?.GetConfigurationSource();
 
+    /// <summary>
+    ///     Returns the <see cref="ConfigurationSource" /> for the identity increment for a particular table.
+    /// </summary>
+    /// <param name="property">The property.</param>
+    /// <param name="storeObject">The identifier of the table containing the column.</param>
+    /// <returns>The <see cref="ConfigurationSource" /> for the identity increment.</returns>
+    public static ConfigurationSource? GetIdentityIncrementConfigurationSource(
+        this IConventionProperty property,
+        in StoreObjectIdentifier storeObject)
+        => property.FindOverrides(storeObject)?.GetIdentityIncrementConfigurationSource();
+
+    /// <summary>
+    ///     Returns the <see cref="ConfigurationSource" /> for the identity increment for a particular table.
+    /// </summary>
+    /// <param name="overrides">The property overrides.</param>
+    /// <returns>The <see cref="ConfigurationSource" /> for the identity increment.</returns>
+    public static ConfigurationSource? GetIdentityIncrementConfigurationSource(
+        this IConventionRelationalPropertyOverrides overrides)
+        => overrides.FindAnnotation(SqlServerAnnotationNames.IdentityIncrement)?.GetConfigurationSource();
+
     /// <summary>
     ///     Returns the <see cref="SqlServerValueGenerationStrategy" /> to use for the property.
     /// </summary>
@@ -405,6 +574,12 @@ public static SqlServerValueGenerationStrategy GetValueGenerationStrategy(this I
         in StoreObjectIdentifier storeObject,
         ITypeMappingSource? typeMappingSource)
     {
+        var @override = property.FindOverrides(storeObject)?.FindAnnotation(SqlServerAnnotationNames.ValueGenerationStrategy);
+        if (@override != null)
+        {
+            return (SqlServerValueGenerationStrategy?)@override.Value ?? SqlServerValueGenerationStrategy.None;
+        }
+        
         var annotation = property.FindAnnotation(SqlServerAnnotationNames.ValueGenerationStrategy);
         if (annotation?.Value != null
             && StoreObjectIdentifier.Create(property.DeclaringEntityType, storeObject.StoreObjectType) == storeObject)
@@ -455,6 +630,19 @@ public static SqlServerValueGenerationStrategy GetValueGenerationStrategy(this I
         return defaultStategy;
     }
 
+    /// <summary>
+    ///     Returns the <see cref="SqlServerValueGenerationStrategy" /> to use for the property.
+    /// </summary>
+    /// <remarks>
+    ///     If no strategy is set for the property, then the strategy to use will be taken from the <see cref="IModel" />.
+    /// </remarks>
+    /// <param name="overrides">The property overrides.</param>
+    /// <returns>The strategy, or <see cref="SqlServerValueGenerationStrategy.None" /> if none was set.</returns>
+    public static SqlServerValueGenerationStrategy? GetValueGenerationStrategy(
+        this IReadOnlyRelationalPropertyOverrides overrides)
+        => (SqlServerValueGenerationStrategy?)overrides.FindAnnotation(SqlServerAnnotationNames.ValueGenerationStrategy)
+            ?.Value;
+
     private static SqlServerValueGenerationStrategy GetDefaultValueGenerationStrategy(IReadOnlyProperty property)
     {
         var modelStrategy = property.DeclaringEntityType.Model.GetValueGenerationStrategy();
@@ -517,9 +705,71 @@ private static SqlServerValueGenerationStrategy GetDefaultValueGenerationStrateg
     {
         CheckValueGenerationStrategy(property, value);
 
-        property.SetOrRemoveAnnotation(SqlServerAnnotationNames.ValueGenerationStrategy, value, fromDataAnnotation);
+        return (SqlServerValueGenerationStrategy?)property.SetOrRemoveAnnotation(
+            SqlServerAnnotationNames.ValueGenerationStrategy, value, fromDataAnnotation)
+            ?.Value;
+    }
+
+    /// <summary>
+    ///     Sets the <see cref="SqlServerValueGenerationStrategy" /> to use for the property for a particular table.
+    /// </summary>
+    /// <param name="property">The property.</param>
+    /// <param name="value">The strategy to use.</param>
+    /// <param name="storeObject">The identifier of the table containing the column.</param>
+    public static void SetValueGenerationStrategy(
+        this IMutableProperty property,
+        SqlServerValueGenerationStrategy? value,
+        in StoreObjectIdentifier storeObject)
+        => property.GetOrCreateOverrides(storeObject)
+            .SetValueGenerationStrategy(value);
+
+    /// <summary>
+    ///     Sets the <see cref="SqlServerValueGenerationStrategy" /> to use for the property for a particular table.
+    /// </summary>
+    /// <param name="property">The property.</param>
+    /// <param name="value">The strategy to use.</param>
+    /// <param name="storeObject">The identifier of the table containing the column.</param>
+    /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
+    /// <returns>The configured value.</returns>
+    public static SqlServerValueGenerationStrategy? SetValueGenerationStrategy(
+        this IConventionProperty property,
+        SqlServerValueGenerationStrategy? value,
+        in StoreObjectIdentifier storeObject,
+        bool fromDataAnnotation = false)
+        => property.GetOrCreateOverrides(storeObject, fromDataAnnotation)
+            .SetValueGenerationStrategy(value, fromDataAnnotation);
+
+    /// <summary>
+    ///     Sets the <see cref="SqlServerValueGenerationStrategy" /> to use for the property for a particular table.
+    /// </summary>
+    /// <param name="overrides">The property overrides.</param>
+    /// <param name="value">The strategy to use.</param>
+    public static void SetValueGenerationStrategy(
+        this IMutableRelationalPropertyOverrides overrides,
+        SqlServerValueGenerationStrategy? value)
+    {
+        CheckValueGenerationStrategy(overrides.Property, value);
+
+        overrides.SetOrRemoveAnnotation(SqlServerAnnotationNames.ValueGenerationStrategy, value);
+    }
+
+    /// <summary>
+    ///     Sets the <see cref="SqlServerValueGenerationStrategy" /> to use for the property for a particular table.
+    /// </summary>
+    /// <param name="overrides">The property overrides.</param>
+    /// <param name="value">The strategy to use.</param>
+    /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
+    /// <returns>The configured value.</returns>
+    public static SqlServerValueGenerationStrategy? SetValueGenerationStrategy(
+        this IConventionRelationalPropertyOverrides overrides,
+        SqlServerValueGenerationStrategy? value,
+        bool fromDataAnnotation = false)
+    {
+        CheckValueGenerationStrategy(overrides.Property, value);
 
-        return value;
+        return (SqlServerValueGenerationStrategy?)overrides.SetOrRemoveAnnotation(
+                SqlServerAnnotationNames.ValueGenerationStrategy, value, fromDataAnnotation)
+            ?.Value;
     }
 
     private static void CheckValueGenerationStrategy(IReadOnlyProperty property, SqlServerValueGenerationStrategy? value)
@@ -555,6 +805,26 @@ private static void CheckValueGenerationStrategy(IReadOnlyProperty property, Sql
         this IConventionProperty property)
         => property.FindAnnotation(SqlServerAnnotationNames.ValueGenerationStrategy)?.GetConfigurationSource();
 
+    /// <summary>
+    ///     Returns the <see cref="ConfigurationSource" /> for the <see cref="SqlServerValueGenerationStrategy" /> for a particular table.
+    /// </summary>
+    /// <param name="property">The property.</param>
+    /// <param name="storeObject">The identifier of the table containing the column.</param>
+    /// <returns>The <see cref="ConfigurationSource" /> for the <see cref="SqlServerValueGenerationStrategy" />.</returns>
+    public static ConfigurationSource? GetValueGenerationStrategyConfigurationSource(
+        this IConventionProperty property,
+        in StoreObjectIdentifier storeObject)
+        => property.FindOverrides(storeObject)?.GetValueGenerationStrategyConfigurationSource();
+
+    /// <summary>
+    ///     Returns the <see cref="ConfigurationSource" /> for the <see cref="SqlServerValueGenerationStrategy" /> for a particular table.
+    /// </summary>
+    /// <param name="overrides">The property overrides.</param>
+    /// <returns>The <see cref="ConfigurationSource" /> for the <see cref="SqlServerValueGenerationStrategy" />.</returns>
+    public static ConfigurationSource? GetValueGenerationStrategyConfigurationSource(
+        this IConventionRelationalPropertyOverrides overrides)
+        => overrides.FindAnnotation(SqlServerAnnotationNames.ValueGenerationStrategy)?.GetConfigurationSource();
+
     /// <summary>
     ///     Returns a value indicating whether the property is compatible with any <see cref="SqlServerValueGenerationStrategy" />.
     /// </summary>
@@ -566,10 +836,9 @@ public static bool IsCompatibleWithValueGeneration(IReadOnlyProperty property)
             ?? property.FindTypeMapping()?.Converter;
 
         var type = (valueConverter?.ProviderClrType ?? property.ClrType).UnwrapNullableType();
-
-        return (type.IsInteger()
+        return type.IsInteger()
             || type.IsEnum
-            || type == typeof(decimal));
+            || type == typeof(decimal);
     }
 
     private static bool IsCompatibleWithValueGeneration(
diff --git a/src/EFCore.SqlServer/Metadata/Conventions/SqlServerRuntimeModelConvention.cs b/src/EFCore.SqlServer/Metadata/Conventions/SqlServerRuntimeModelConvention.cs
index 2f0deede3c..76fb8b3bc9 100644
--- a/src/EFCore.SqlServer/Metadata/Conventions/SqlServerRuntimeModelConvention.cs
+++ b/src/EFCore.SqlServer/Metadata/Conventions/SqlServerRuntimeModelConvention.cs
@@ -29,13 +29,7 @@ public class SqlServerRuntimeModelConvention : RelationalRuntimeModelConvention
     {
     }
 
-    /// <summary>
-    ///     Updates the model annotations that will be set on the read-only object.
-    /// </summary>
-    /// <param name="annotations">The annotations to be processed.</param>
-    /// <param name="model">The source model.</param>
-    /// <param name="runtimeModel">The target model that will contain the annotations.</param>
-    /// <param name="runtime">Indicates whether the given annotations are runtime annotations.</param>
+    /// <inheritdoc />
     protected override void ProcessModelAnnotations(
         Dictionary<string, object?> annotations,
         IModel model,
@@ -54,13 +48,7 @@ public class SqlServerRuntimeModelConvention : RelationalRuntimeModelConvention
         }
     }
 
-    /// <summary>
-    ///     Updates the property annotations that will be set on the read-only object.
-    /// </summary>
-    /// <param name="annotations">The annotations to be processed.</param>
-    /// <param name="property">The source property.</param>
-    /// <param name="runtimeProperty">The target property that will contain the annotations.</param>
-    /// <param name="runtime">Indicates whether the given annotations are runtime annotations.</param>
+    /// <inheritdoc />
     protected override void ProcessPropertyAnnotations(
         Dictionary<string, object?> annotations,
         IProperty property,
@@ -82,13 +70,23 @@ public class SqlServerRuntimeModelConvention : RelationalRuntimeModelConvention
         }
     }
 
-    /// <summary>
-    ///     Updates the index annotations that will be set on the read-only object.
-    /// </summary>
-    /// <param name="annotations">The annotations to be processed.</param>
-    /// <param name="index">The source index.</param>
-    /// <param name="runtimeIndex">The target index that will contain the annotations.</param>
-    /// <param name="runtime">Indicates whether the given annotations are runtime annotations.</param>
+    /// <inheritdoc />
+    protected override void ProcessPropertyOverridesAnnotations(
+        Dictionary<string, object?> annotations,
+        IRelationalPropertyOverrides propertyOverrides,
+        RuntimeRelationalPropertyOverrides runtimePropertyOverrides,
+        bool runtime)
+    {
+        base.ProcessPropertyOverridesAnnotations(annotations, propertyOverrides, runtimePropertyOverrides, runtime);
+        
+        if (!runtime)
+        {
+            annotations.Remove(SqlServerAnnotationNames.IdentityIncrement);
+            annotations.Remove(SqlServerAnnotationNames.IdentitySeed);
+        }
+    }
+
+    /// <inheritdoc />
     protected override void ProcessIndexAnnotations(
         Dictionary<string, object?> annotations,
         IIndex index,
@@ -106,13 +104,7 @@ public class SqlServerRuntimeModelConvention : RelationalRuntimeModelConvention
         }
     }
 
-    /// <summary>
-    ///     Updates the key annotations that will be set on the read-only object.
-    /// </summary>
-    /// <param name="annotations">The annotations to be processed.</param>
-    /// <param name="key">The source key.</param>
-    /// <param name="runtimeKey">The target key that will contain the annotations.</param>
-    /// <param name="runtime">Indicates whether the given annotations are runtime annotations.</param>
+    /// <inheritdoc />
     protected override void ProcessKeyAnnotations(
         IDictionary<string, object?> annotations,
         IKey key,
@@ -127,13 +119,7 @@ public class SqlServerRuntimeModelConvention : RelationalRuntimeModelConvention
         }
     }
 
-    /// <summary>
-    ///     Updates the entity type annotations that will be set on the read-only object.
-    /// </summary>
-    /// <param name="annotations">The annotations to be processed.</param>
-    /// <param name="entityType">The source entity type.</param>
-    /// <param name="runtimeEntityType">The target entity type that will contain the annotations.</param>
-    /// <param name="runtime">Indicates whether the given annotations are runtime annotations.</param>
+    /// <inheritdoc />
     protected override void ProcessEntityTypeAnnotations(
         IDictionary<string, object?> annotations,
         IEntityType entityType,
diff --git a/src/EFCore.SqlServer/Update/Internal/SqlServerUpdateSqlGenerator.cs b/src/EFCore.SqlServer/Update/Internal/SqlServerUpdateSqlGenerator.cs
index c5c3624ee2..ed30a2eb3d 100644
--- a/src/EFCore.SqlServer/Update/Internal/SqlServerUpdateSqlGenerator.cs
+++ b/src/EFCore.SqlServer/Update/Internal/SqlServerUpdateSqlGenerator.cs
@@ -846,5 +846,5 @@ private static bool HasAnyTriggers(IReadOnlyModificationCommand command)
         // Data seeding doesn't provide any entries, so we we don't know if the table has triggers; assume it does to generate SQL
         // that works everywhere.
         => command.Entries.Count == 0
-            || command.Entries[0].EntityType.Model.GetRelationalModel().FindTable(command.TableName, command.Schema)!.Triggers.Any();
+            || command.Table!.Triggers.Any();
 }
diff --git a/src/EFCore/Infrastructure/AnnotatableBuilder.cs b/src/EFCore/Infrastructure/AnnotatableBuilder.cs
index 5b857ca90f..0889d2eadf 100644
--- a/src/EFCore/Infrastructure/AnnotatableBuilder.cs
+++ b/src/EFCore/Infrastructure/AnnotatableBuilder.cs
@@ -71,7 +71,10 @@ protected AnnotatableBuilder(TMetadata metadata, TModelBuilder modelBuilder)
                 return this;
             }
 
-            if (!CanSetAnnotationValue(existingAnnotation, value, configurationSource, canOverrideSameSource))
+            var existingConfigurationSource = existingAnnotation.GetConfigurationSource();
+            if (!configurationSource.Overrides(existingConfigurationSource)
+                || (configurationSource == existingConfigurationSource
+                    && !canOverrideSameSource))
             {
                 return null;
             }
@@ -170,7 +173,7 @@ public virtual bool CanRemoveAnnotation(string name, ConfigurationSource configu
     ///     Copies all the explicitly configured annotations from the given object overwriting any existing ones.
     /// </summary>
     /// <param name="annotatable">The object to copy annotations from.</param>
-    public virtual void MergeAnnotationsFrom(TMetadata annotatable)
+    public virtual AnnotatableBuilder<TMetadata, TModelBuilder> MergeAnnotationsFrom(TMetadata annotatable)
         => MergeAnnotationsFrom(annotatable, ConfigurationSource.Explicit);
 
     /// <summary>
@@ -178,20 +181,24 @@ public virtual void MergeAnnotationsFrom(TMetadata annotatable)
     /// </summary>
     /// <param name="annotatable">The object to copy annotations from.</param>
     /// <param name="minimalConfigurationSource">The minimum configuration source for an annotation to be copied.</param>
-    public virtual void MergeAnnotationsFrom(TMetadata annotatable, ConfigurationSource minimalConfigurationSource)
+    public virtual AnnotatableBuilder<TMetadata, TModelBuilder> MergeAnnotationsFrom(
+        TMetadata annotatable, ConfigurationSource minimalConfigurationSource)
     {
+        var builder = this;
         foreach (var annotation in annotatable.GetAnnotations())
         {
             var configurationSource = annotation.GetConfigurationSource();
             if (configurationSource.Overrides(minimalConfigurationSource))
             {
-                HasAnnotation(
+                builder = builder.HasAnnotation(
                     annotation.Name,
                     annotation.Value,
                     configurationSource,
-                    canOverrideSameSource: false);
+                    canOverrideSameSource: false) ?? builder;
             }
         }
+
+        return builder;
     }
 
     /// <inheritdoc />
diff --git a/src/EFCore/Infrastructure/ConventionAnnotatable.cs b/src/EFCore/Infrastructure/ConventionAnnotatable.cs
index f4fd65eeeb..188128ad3c 100644
--- a/src/EFCore/Infrastructure/ConventionAnnotatable.cs
+++ b/src/EFCore/Infrastructure/ConventionAnnotatable.cs
@@ -56,6 +56,7 @@ public override void SetAnnotation(string name, object? value)
     /// <param name="name">The key of the annotation to be added.</param>
     /// <param name="value">The value to be stored in the annotation.</param>
     /// <param name="configurationSource">The configuration source of the annotation to be set.</param>
+    /// <returns>The new annotation.</returns>
     public virtual ConventionAnnotation? SetAnnotation(
         string name,
         object? value,
@@ -77,11 +78,14 @@ public override void SetAnnotation(string name, object? value)
     }
 
     /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    ///     Sets the annotation with given key and value on this object using given configuration source.
+    ///     Removes the existing annotation if an annotation with the specified name already exists and
+    ///     <paramref name="value"/> is <see langword="null"/>.
     /// </summary>
+    /// <param name="name">The key of the annotation to be added.</param>
+    /// <param name="value">The value to be stored in the annotation.</param>
+    /// <param name="configurationSource">The configuration source of the annotation to be set.</param>
+    /// <returns>The new annotation.</returns>
     public virtual ConventionAnnotation? SetOrRemoveAnnotation(
         string name,
         object? value,
diff --git a/src/EFCore/Metadata/Conventions/ForeignKeyPropertyDiscoveryConvention.cs b/src/EFCore/Metadata/Conventions/ForeignKeyPropertyDiscoveryConvention.cs
index 85155be219..795e1a2adf 100644
--- a/src/EFCore/Metadata/Conventions/ForeignKeyPropertyDiscoveryConvention.cs
+++ b/src/EFCore/Metadata/Conventions/ForeignKeyPropertyDiscoveryConvention.cs
@@ -409,7 +409,9 @@ public ForeignKeyPropertyDiscoveryConvention(ProviderConventionSetBuilderDepende
             var referencedProperty = propertiesToReference[i];
             var property = TryGetProperty(
                 dependentEntityType,
-                baseName, referencedProperty.Name);
+                baseName,
+                referencedProperty.Name,
+                matchImplicitProperties: propertiesToReference.Count != 1);
 
             if (property == null)
             {
@@ -420,13 +422,21 @@ public ForeignKeyPropertyDiscoveryConvention(ProviderConventionSetBuilderDepende
             foreignKeyProperties[i] = property;
         }
 
+        if (matchFound
+            && foreignKeyProperties.Length != 1
+            && foreignKeyProperties.All(p => p.IsImplicitlyCreated()
+                && ConfigurationSource.Convention.Overrides(p.GetConfigurationSource())))
+        {
+            return false;
+        }
+        
         if (!matchFound
             && propertiesToReference.Count == 1
             && baseName.Length > 0)
         {
             var property = TryGetProperty(
                 dependentEntityType,
-                baseName, "Id");
+                baseName, "Id", matchImplicitProperties: false);
 
             if (property != null)
             {
@@ -504,11 +514,13 @@ public ForeignKeyPropertyDiscoveryConvention(ProviderConventionSetBuilderDepende
         return true;
     }
 
-    private static IConventionProperty? TryGetProperty(IConventionEntityType entityType, string prefix, string suffix)
+    private static IConventionProperty? TryGetProperty(
+        IConventionEntityType entityType, string prefix, string suffix, bool matchImplicitProperties)
     {
         foreach (var property in entityType.GetProperties())
         {
             if ((!property.IsImplicitlyCreated()
+                    || matchImplicitProperties
                     || !ConfigurationSource.Convention.Overrides(property.GetConfigurationSource()))
                 && property.Name.Length == prefix.Length + suffix.Length
                 && property.Name.StartsWith(prefix, StringComparison.OrdinalIgnoreCase)
diff --git a/test/EFCore.Design.Tests/Migrations/ModelSnapshotSqlServerTest.cs b/test/EFCore.Design.Tests/Migrations/ModelSnapshotSqlServerTest.cs
index 1385e3b7c3..3645ca93e4 100644
--- a/test/EFCore.Design.Tests/Migrations/ModelSnapshotSqlServerTest.cs
+++ b/test/EFCore.Design.Tests/Migrations/ModelSnapshotSqlServerTest.cs
@@ -668,11 +668,14 @@ public virtual void Entity_splitting_is_stored_in_snapshot_with_tables()
                         b.Property<int>("Shadow").HasColumnName("Shadow");
                         b.ToTable("Order", tb =>
                         {
+                            tb.Property(e => e.Id).UseIdentityColumn(2, 3).HasAnnotation("fii", "arr");
                             tb.Property("Shadow");
                         });
                         b.SplitToTable("SplitOrder", sb =>
                         {
                             sb.Property("Shadow");
+                            sb.HasTrigger("splitTrigger").HasAnnotation("oof", "rab");
+                            sb.HasAnnotation("foo", "bar");
                         });
 
                         b.OwnsOne(p => p.OrderBillingDetails, od =>
@@ -725,12 +728,23 @@ public virtual void Entity_splitting_is_stored_in_snapshot_with_tables()
 
                     b.ToTable(""Order"", null, t =>
                         {
+                            t.Property(""Id"")
+                                .HasAnnotation(""fii"", ""arr"")
+                                .HasAnnotation(""SqlServer:IdentityIncrement"", 3)
+                                .HasAnnotation(""SqlServer:IdentitySeed"", 2L)
+                                .HasAnnotation(""SqlServer:ValueGenerationStrategy"", SqlServerValueGenerationStrategy.IdentityColumn);
+
                             t.Property(""Shadow"");
                         });
 
                     b.SplitToTable(""SplitOrder"", null, t =>
                         {
+                            t.HasTrigger(""splitTrigger"")
+                                .HasAnnotation(""oof"", ""rab"");
+
                             t.Property(""Shadow"");
+
+                            t.HasAnnotation(""foo"", ""bar"");
                         });
                 });
 
@@ -852,6 +866,17 @@ public virtual void Entity_splitting_is_stored_in_snapshot_with_tables()
                 var orderEntityType = model.FindEntityType(typeof(Order));
                 Assert.Equal(nameof(Order), orderEntityType.GetTableName());
 
+                var id = orderEntityType.FindProperty("Id");
+                Assert.Equal(SqlServerValueGenerationStrategy.IdentityColumn, id.GetValueGenerationStrategy());
+                Assert.Equal(1, id.GetIdentitySeed());
+                Assert.Equal(1, id.GetIdentityIncrement());
+
+                var overrides = id.FindOverrides(StoreObjectIdentifier.Create(orderEntityType, StoreObjectType.Table).Value)!;
+                Assert.Equal(SqlServerValueGenerationStrategy.IdentityColumn, overrides.GetValueGenerationStrategy());
+                Assert.Equal(2, overrides.GetIdentitySeed());
+                Assert.Equal(3, overrides.GetIdentityIncrement());
+                Assert.Equal("arr", overrides["fii"]);
+
                 var billingOwnership = orderEntityType.FindNavigation(nameof(Order.OrderBillingDetails))
                     .ForeignKey;
                 var billingEntityType = billingOwnership.DeclaringEntityType;
@@ -884,6 +909,12 @@ public virtual void Entity_splitting_is_stored_in_snapshot_with_tables()
                 var splitTable = relationalModel.FindTable(fragment.StoreObject.Name, fragment.StoreObject.Schema);
                 Assert.Equal(new[] { billingEntityType, orderEntityType },
                     splitTable.FindColumn("Shadow").PropertyMappings.Select(m => m.TableMapping.EntityType));
+                Assert.Equal("bar", fragment["foo"]);
+
+                var trigger = orderEntityType.GetTriggers().Single();
+                Assert.Equal(splitTable.Name, trigger.TableName);
+                Assert.Equal(splitTable.Schema, trigger.TableSchema);
+                Assert.Equal("rab", trigger["oof"]);
 
                 var billingFragment = billingEntityType.GetMappingFragments().Single();
                 var billingTable = relationalModel.FindTable(billingFragment.StoreObject.Name, billingFragment.StoreObject.Schema);
@@ -1133,7 +1164,8 @@ public virtual void Sequence_is_stored_in_snapshot_as_fluent_api()
                     .HasMin(1)
                     .HasMax(3)
                     .IncrementsBy(2)
-                    .IsCyclic();
+                    .IsCyclic()
+                    .HasAnnotation("foo", "bar");
             },
             AddBoilerPlate(
                 GetHeading()
@@ -1143,10 +1175,19 @@ public virtual void Sequence_is_stored_in_snapshot_as_fluent_api()
                 .IncrementsBy(2)
                 .HasMin(1L)
                 .HasMax(3L)
-                .IsCyclic();"),
-            o =>
+                .IsCyclic()
+                .HasAnnotation(""foo"", ""bar"");"),
+            model =>
             {
-                Assert.Equal(5, o.GetAnnotations().Count());
+                Assert.Equal(5, model.GetAnnotations().Count());
+                
+                var sequence = model.GetSequences().Single();
+                Assert.Equal(2, sequence.StartValue);
+                Assert.Equal(1, sequence.MinValue);
+                Assert.Equal(3, sequence.MaxValue);
+                Assert.Equal(2, sequence.IncrementBy);
+                Assert.True(sequence.IsCyclic);
+                Assert.Equal("bar", sequence["foo"]);
             });
 
     [ConditionalFact]
@@ -1308,6 +1349,7 @@ public virtual void Triggers_and_ExcludeFromMigrations_are_stored_in_snapshot()
                             t.ExcludeFromMigrations();
 
                             t.HasTrigger(""SomeTrigger1"");
+
                             t.HasTrigger(""SomeTrigger2"");
                         });
                 });"),
diff --git a/test/EFCore.Design.Tests/Scaffolding/Internal/CSharpDbContextGeneratorTest.cs b/test/EFCore.Design.Tests/Scaffolding/Internal/CSharpDbContextGeneratorTest.cs
index 9f88365b5a..0265be6861 100644
--- a/test/EFCore.Design.Tests/Scaffolding/Internal/CSharpDbContextGeneratorTest.cs
+++ b/test/EFCore.Design.Tests/Scaffolding/Internal/CSharpDbContextGeneratorTest.cs
@@ -1252,10 +1252,12 @@ protected override void OnModelCreating(ModelBuilder modelBuilder)
             {
                 entity.Property(e => e.Id).UseIdentityColumn();
 
-                entity.ToTable(tb => {
-                    tb.HasTrigger(""Trigger1"");
-                    tb.HasTrigger(""Trigger2"");
-                });
+                entity.ToTable(tb =>
+                    {
+                        tb.HasTrigger(""Trigger1"");
+
+                        tb.HasTrigger(""Trigger2"");
+                    });
             });
 
             OnModelCreatingPartial(modelBuilder);
diff --git a/test/EFCore.Design.Tests/Scaffolding/Internal/CSharpRuntimeModelCodeGeneratorTest.cs b/test/EFCore.Design.Tests/Scaffolding/Internal/CSharpRuntimeModelCodeGeneratorTest.cs
index ef23e7ee37..e7bb3a7ec0 100644
--- a/test/EFCore.Design.Tests/Scaffolding/Internal/CSharpRuntimeModelCodeGeneratorTest.cs
+++ b/test/EFCore.Design.Tests/Scaffolding/Internal/CSharpRuntimeModelCodeGeneratorTest.cs
@@ -1208,8 +1208,18 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType? ba
                 ""PrincipalBaseId"",
                 typeof(long),
                 propertyAccessMode: PropertyAccessMode.Field,
+                valueGenerated: ValueGenerated.OnAdd,
                 afterSaveBehavior: PropertySaveBehavior.Throw);
-            principalBaseId.AddAnnotation(""SqlServer:ValueGenerationStrategy"", SqlServerValueGenerationStrategy.None);
+            var overrides = new StoreObjectDictionary<RuntimeRelationalPropertyOverrides>();
+            var principalBaseIdPrincipalBase = new RuntimeRelationalPropertyOverrides(
+                principalBaseId,
+                StoreObjectIdentifier.Table(""PrincipalBase"", ""mySchema""),
+                false,
+                null);
+            principalBaseIdPrincipalBase.AddAnnotation(""SqlServer:ValueGenerationStrategy"", SqlServerValueGenerationStrategy.IdentityColumn);
+            overrides.Add(StoreObjectIdentifier.Table(""PrincipalBase"", ""mySchema""), principalBaseIdPrincipalBase);
+            principalBaseId.AddAnnotation(""Relational:RelationalOverrides"", overrides);
+            principalBaseId.AddAnnotation(""SqlServer:ValueGenerationStrategy"", SqlServerValueGenerationStrategy.IdentityColumn);
 
             var principalBaseAlternateId = runtimeEntityType.AddProperty(
                 ""PrincipalBaseAlternateId"",
@@ -1226,14 +1236,14 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType? ba
                 fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField(""<Details>k__BackingField"", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 propertyAccessMode: PropertyAccessMode.Field,
                 nullable: true);
-            var overrides = new StoreObjectDictionary<RuntimeRelationalPropertyOverrides>();
+            var overrides0 = new StoreObjectDictionary<RuntimeRelationalPropertyOverrides>();
             var detailsDetails = new RuntimeRelationalPropertyOverrides(
                 details,
                 StoreObjectIdentifier.Table(""Details"", null),
                 false,
                 null);
-            overrides.Add(StoreObjectIdentifier.Table(""Details"", null), detailsDetails);
-            details.AddAnnotation(""Relational:RelationalOverrides"", overrides);
+            overrides0.Add(StoreObjectIdentifier.Table(""Details"", null), detailsDetails);
+            details.AddAnnotation(""Relational:RelationalOverrides"", overrides0);
             details.AddAnnotation(""SqlServer:ValueGenerationStrategy"", SqlServerValueGenerationStrategy.None);
 
             var number = runtimeEntityType.AddProperty(
@@ -1883,11 +1893,25 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
                         CoreStrings.RuntimeModelMissingData,
                         Assert.Throws<InvalidOperationException>(() => referenceOwnedType.GetNavigationAccessMode()).Message);
 
+                    var principalTable = StoreObjectIdentifier.Create(referenceOwnedType, StoreObjectType.Table).Value;
+
+                    var ownedId = referenceOwnedType.FindProperty("PrincipalBaseId");
+                    Assert.True(ownedId.IsPrimaryKey());
+                    Assert.Equal(
+                        SqlServerValueGenerationStrategy.IdentityColumn,
+                        principalId.GetValueGenerationStrategy(principalTable));
+                    Assert.Equal(
+                        CoreStrings.RuntimeModelMissingData,
+                        Assert.Throws<InvalidOperationException>(() => principalId.GetIdentityIncrement(principalTable)).Message);
+                    Assert.Equal(
+                        CoreStrings.RuntimeModelMissingData,
+                        Assert.Throws<InvalidOperationException>(() => principalId.GetIdentitySeed(principalTable)).Message);
+
                     var ownedFragment = referenceOwnedType.GetMappingFragments().Single();
                     Assert.Equal(nameof(OwnedType.Details),
                         referenceOwnedType.FindProperty(nameof(OwnedType.Details)).GetColumnName(ownedFragment.StoreObject));
                     Assert.Null(referenceOwnedType.FindProperty(nameof(OwnedType.Details))
-                        .GetColumnName(StoreObjectIdentifier.Create(referenceOwnedType, StoreObjectType.Table).Value));
+                        .GetColumnName(principalTable));
 
                     var referenceOwnership = referenceOwnedNavigation.ForeignKey;
                     Assert.Empty(referenceOwnership.GetAnnotations());
@@ -2195,6 +2219,9 @@ protected override void OnModelCreating(ModelBuilder modelBuilder)
                                 ob.HasChangeTrackingStrategy(ChangeTrackingStrategy.ChangingAndChangedNotificationsWithOriginalValues);
                                 ob.UsePropertyAccessMode(PropertyAccessMode.Field);
 
+                                ob.ToTable("PrincipalBase", "mySchema",
+                                    t => t.Property("PrincipalBaseId").UseIdentityColumn(2, 3));
+
                                 ob.SplitToTable("Details", s => s.Property(e => e.Details));
                             });
 
diff --git a/test/EFCore.Relational.Tests/Metadata/RelationalBuilderExtensionsTest.cs b/test/EFCore.Relational.Tests/Metadata/RelationalBuilderExtensionsTest.cs
index 30d27f5130..82a36d3e51 100644
--- a/test/EFCore.Relational.Tests/Metadata/RelationalBuilderExtensionsTest.cs
+++ b/test/EFCore.Relational.Tests/Metadata/RelationalBuilderExtensionsTest.cs
@@ -568,6 +568,7 @@ public void Base_check_constraint_overrides_derived_one()
 
         var derivedBuilder = modelBuilder.Entity(typeof(Splow), ConfigurationSource.Convention);
         IReadOnlyEntityType derivedEntityType = derivedBuilder.Metadata;
+        derivedBuilder.HasBaseType((EntityType)null, ConfigurationSource.DataAnnotation);
 
         Assert.NotNull(
             derivedBuilder.HasCheckConstraint("Splew", "s < p", fromDataAnnotation: true)
@@ -581,17 +582,13 @@ public void Base_check_constraint_overrides_derived_one()
         Assert.False(derivedBuilder.CanHaveCheckConstraint("Splew", "s > p"));
         Assert.True(derivedBuilder.CanHaveCheckConstraint("Splot", "s > p"));
 
+        Assert.Null(derivedBuilder.HasCheckConstraint("Splew", "s > p"));
+        Assert.Equal("s < p", derivedEntityType.GetCheckConstraints().Single().Sql);
+
         var baseBuilder = modelBuilder.Entity(typeof(Splot), ConfigurationSource.DataAnnotation);
         IReadOnlyEntityType baseEntityType = baseBuilder.Metadata;
-
-        Assert.True(baseBuilder.CanHaveCheckConstraint("Splew", "s < p"));
-        Assert.True(baseBuilder.CanHaveCheckConstraint("Splew", "s > p", fromDataAnnotation: true));
-        Assert.False(baseBuilder.CanHaveCheckConstraint("Splew", "s > p"));
-        Assert.True(baseBuilder.CanHaveCheckConstraint("Splot", "s > p"));
-
-        Assert.Null(baseBuilder.HasCheckConstraint("Splew", "s > p"));
+        Assert.Null(derivedEntityType.BaseType);
         Assert.Empty(baseEntityType.GetCheckConstraints());
-        Assert.Equal("s < p", derivedEntityType.GetCheckConstraints().Single().Sql);
 
         Assert.NotNull(
             baseBuilder.HasCheckConstraint("Splew", "s < p", fromDataAnnotation: true)
@@ -600,7 +597,7 @@ public void Base_check_constraint_overrides_derived_one()
         Assert.Equal("s < p", baseEntityType.GetCheckConstraints().Single().Sql);
         Assert.Equal("CK_Splot", baseEntityType.GetCheckConstraints().Single().Name);
 
-        derivedBuilder.HasBaseType((EntityType)baseEntityType, ConfigurationSource.Convention);
+        Assert.NotNull(derivedBuilder.HasBaseType((EntityType)baseEntityType, ConfigurationSource.DataAnnotation));
 
         Assert.Null(
             baseBuilder.HasCheckConstraint("Splew", "s < p", fromDataAnnotation: true)
@@ -776,31 +773,36 @@ public void Base_trigger_overrides_derived_one_after_base_is_set()
         IReadOnlyEntityType derivedEntityType = derivedBuilder.Metadata;
 
         Assert.NotNull(
-            derivedBuilder.HasTrigger("Splew", "Table1", "dbo", fromDataAnnotation: true)
+            derivedBuilder.HasTrigger("Splew", nameof(Splow), null, fromDataAnnotation: true)
                 .HasName("Splow_Trigger", fromDataAnnotation: true));
         Assert.Equal("Splew", derivedEntityType.GetTriggers().Single().ModelName);
-        Assert.Equal("Table1", derivedEntityType.GetTriggers().Single().TableName);
+        Assert.Equal(nameof(Splow), derivedEntityType.GetTriggers().Single().TableName);
         Assert.Equal("Splow_Trigger", derivedEntityType.GetTriggers().Single().Name);
+        Assert.Equal("Splow_Trigger", derivedEntityType.GetTriggers().Single()
+            .GetName(StoreObjectIdentifier.Create(derivedEntityType, StoreObjectType.Table).Value));
 
         var baseBuilder = modelBuilder.Entity(typeof(Splot), ConfigurationSource.Convention);
         IReadOnlyEntityType baseEntityType = baseBuilder.Metadata;
         Assert.Null(derivedEntityType.BaseType);
 
         Assert.NotNull(
-            baseBuilder.HasTrigger("Splew", "Table1", "dbo", fromDataAnnotation: true)
+            baseBuilder.HasTrigger("Splew", nameof(Splot), null, fromDataAnnotation: true)
                 .HasName("Splot_Trigger", fromDataAnnotation: true));
         Assert.Equal("Splew", baseEntityType.GetTriggers().Single().ModelName);
-        Assert.Equal("Table1", baseEntityType.GetTriggers().Single().TableName);
+        Assert.Equal(nameof(Splot), baseEntityType.GetTriggers().Single().TableName);
         Assert.Equal("Splot_Trigger", baseEntityType.GetTriggers().Single().Name);
 
         Assert.NotNull(derivedBuilder.HasBaseType((EntityType)baseEntityType, ConfigurationSource.DataAnnotation));
 
+        Assert.Null(baseBuilder.HasTrigger("Splew", "Table1", "dbo"));
         Assert.Null(
-            baseBuilder.HasTrigger("Splew", "Table1", "dbo", fromDataAnnotation: true)
+            baseBuilder.HasTrigger("Splew", nameof(Splot), null, fromDataAnnotation: true)
                 .HasName("Splew_Trigger"));
         Assert.Equal("Splew", baseEntityType.GetTriggers().Single().ModelName);
-        Assert.Equal("Table1", baseEntityType.GetTriggers().Single().TableName);
+        Assert.Equal(nameof(Splot), baseEntityType.GetTriggers().Single().TableName);
         Assert.Equal("Splot_Trigger", baseEntityType.GetTriggers().Single().Name);
+        Assert.Equal("Splot_Trigger", baseEntityType.GetTriggers().Single()
+            .GetName(StoreObjectIdentifier.Create(baseEntityType, StoreObjectType.Table).Value));
         Assert.Empty(derivedEntityType.GetDeclaredTriggers());
         Assert.Same(baseEntityType.GetTriggers().Single(), derivedEntityType.GetTriggers().Single());
     }
diff --git a/test/EFCore.Relational.Tests/ModelBuilding/RelationalModelBuilderTest.cs b/test/EFCore.Relational.Tests/ModelBuilding/RelationalModelBuilderTest.cs
index 908599ab78..b9c4b25fcc 100644
--- a/test/EFCore.Relational.Tests/ModelBuilding/RelationalModelBuilderTest.cs
+++ b/test/EFCore.Relational.Tests/ModelBuilding/RelationalModelBuilderTest.cs
@@ -166,6 +166,132 @@ public abstract class RelationalManyToManyTestBase : ManyToManyTestBase
 
     public abstract class RelationalOwnedTypesTestBase : OwnedTypesTestBase
     {
+        [ConditionalFact]
+        public virtual void Can_use_table_splitting_with_owned_reference()
+        {
+            var modelBuilder = CreateModelBuilder();
+
+            modelBuilder.Ignore<AnotherBookLabel>();
+            modelBuilder.Ignore<SpecialBookLabel>();
+            modelBuilder.Ignore<BookDetails>();
+
+            modelBuilder.Entity<Book>().OwnsOne(
+                b => b.Label, lb =>
+                {
+                    lb.Ignore(l => l.Book);
+                    lb.Property<string>("ShadowProp");
+                    
+                    lb.SplitToTable("BookLabelDetails", s =>
+                    {
+                        var propertyBuilder = s.Property(o => o.Id);
+                        var columnBuilder = propertyBuilder.HasColumnName("bid");
+                        if (columnBuilder is IInfrastructure<ColumnBuilder<int>> genericBuilder)
+                        {
+                            Assert.IsType<PropertyBuilder<int>>(genericBuilder.Instance.GetInfrastructure<PropertyBuilder<int>>());
+                            Assert.IsAssignableFrom<IMutableRelationalPropertyOverrides>(genericBuilder.GetInfrastructure().Overrides);
+                        }
+                        else
+                        {
+                            var nonGenericBuilder = (IInfrastructure<ColumnBuilder>)columnBuilder;
+                            Assert.IsAssignableFrom<PropertyBuilder>(nonGenericBuilder.Instance.GetInfrastructure());
+                            Assert.IsAssignableFrom<IMutableRelationalPropertyOverrides>(nonGenericBuilder.Instance.Overrides);
+                        }
+                    });
+                });
+            modelBuilder.Entity<Book>()
+                .OwnsOne(b => b.AlternateLabel);
+
+            var model = modelBuilder.Model;
+
+            Assert.Equal(2, model.GetEntityTypes().Count(e => e.ClrType == typeof(BookLabel)));
+            Assert.Equal(3, model.GetEntityTypes().Count());
+
+            var book = model.FindEntityType(typeof(Book))!;
+            var bookOwnership1 = book.FindNavigation(nameof(Book.Label))!.ForeignKey;
+            var bookOwnership2 = book.FindNavigation(nameof(Book.AlternateLabel))!.ForeignKey;
+            Assert.NotSame(bookOwnership1.DeclaringEntityType, bookOwnership2.DeclaringEntityType);
+
+            var splitTable = StoreObjectIdentifier.Table("BookLabelDetails");
+            var fragment = bookOwnership1.DeclaringEntityType.GetMappingFragments().Single();
+            Assert.Same(fragment, bookOwnership1.DeclaringEntityType.FindMappingFragment(splitTable));
+            Assert.Same(fragment, bookOwnership1.DeclaringEntityType.GetMappingFragments(StoreObjectType.Table).Single());
+
+            Assert.True(((IConventionEntityTypeMappingFragment)fragment).IsInModel);
+            Assert.Same(bookOwnership1.DeclaringEntityType, fragment.EntityType);
+
+            var bookId = bookOwnership1.DeclaringEntityType.FindProperty(nameof(BookLabel.Id))!;
+            Assert.Equal("Id", bookId.GetColumnName());
+            Assert.Null(bookId.GetColumnName(StoreObjectIdentifier.Table("Book")));
+            Assert.Equal("bid", bookId.GetColumnName(splitTable));
+
+            var overrides = bookId.GetOverrides().Single();
+            Assert.Same(overrides, bookId.FindOverrides(splitTable));
+            Assert.True(((IConventionRelationalPropertyOverrides)overrides).IsInModel);
+            Assert.Same(bookId, overrides.Property);
+
+            var readOnlyModel = modelBuilder.FinalizeModel();
+
+            Assert.Equal(2, readOnlyModel.GetEntityTypes().Count(e => e.ClrType == typeof(BookLabel)));
+            Assert.Equal(3, readOnlyModel.GetEntityTypes().Count());
+        }
+
+        [ConditionalFact]
+        public virtual void Can_use_view_splitting_with_owned_collection()
+        {
+            var modelBuilder = CreateModelBuilder();
+
+            modelBuilder.Ignore<Product>();
+            modelBuilder.Entity<Customer>().OwnsMany(
+                c => c.Orders,
+                r =>
+                {
+                    r.Ignore(o => o.OrderCombination);
+                    r.Ignore(o => o.Details);
+                    r.Property<string>("ShadowProp");
+
+                    r.ToView("Order");
+                    r.SplitToView("OrderDetails", s =>
+                    {
+                        var propertyBuilder = s.Property(o => o.AnotherCustomerId);
+                        var columnBuilder = propertyBuilder.HasColumnName("cid");
+                        if (columnBuilder is IInfrastructure<ViewColumnBuilder<Guid>> genericBuilder)
+                        {
+                            Assert.IsType<PropertyBuilder<Guid>>(genericBuilder.Instance.GetInfrastructure<PropertyBuilder<Guid>>());
+                            Assert.IsAssignableFrom<IMutableRelationalPropertyOverrides>(genericBuilder.GetInfrastructure().Overrides);
+                        }
+                        else
+                        {
+                            var nonGenericBuilder = (IInfrastructure<ViewColumnBuilder>)columnBuilder;
+                            Assert.IsAssignableFrom<PropertyBuilder>(nonGenericBuilder.Instance.GetInfrastructure());
+                            Assert.IsAssignableFrom<IMutableRelationalPropertyOverrides>(nonGenericBuilder.Instance.Overrides);
+                        }
+                    });
+                });
+
+            var model = modelBuilder.FinalizeModel();
+
+            var ownership = model.FindEntityType(typeof(Customer))!.FindNavigation(nameof(Customer.Orders))!.ForeignKey;
+            var owned = ownership.DeclaringEntityType;
+            Assert.True(ownership.IsOwnership);
+
+            var splitView = StoreObjectIdentifier.View("OrderDetails");
+            var fragment = owned.GetMappingFragments().Single();
+            Assert.Same(fragment, owned.FindMappingFragment(splitView));
+            Assert.Same(fragment, owned.GetMappingFragments(StoreObjectType.View).Single());
+
+            Assert.True(((IConventionEntityTypeMappingFragment)fragment).IsInModel);
+            Assert.Same(owned, fragment.EntityType);
+
+            var anotherCustomerId = owned.FindProperty(nameof(Order.AnotherCustomerId))!;
+            Assert.Equal("AnotherCustomerId", anotherCustomerId.GetColumnName());
+            Assert.Null(anotherCustomerId.GetColumnName(StoreObjectIdentifier.View("Order")));
+            Assert.Equal("cid", anotherCustomerId.GetColumnName(splitView));
+
+            var overrides = anotherCustomerId.GetOverrides().Single();
+            Assert.Same(overrides, anotherCustomerId.FindOverrides(splitView));
+            Assert.True(((IConventionRelationalPropertyOverrides)overrides).IsInModel);
+            Assert.Same(anotherCustomerId, overrides.Property);
+        }
     }
 
     public abstract class TestTableBuilder<TEntity>
