diff --git a/src/EFCore.Cosmos/Infrastructure/Internal/CosmosModelValidator.cs b/src/EFCore.Cosmos/Infrastructure/Internal/CosmosModelValidator.cs
index 6bd55b7a81..1bb4f718ae 100644
--- a/src/EFCore.Cosmos/Infrastructure/Internal/CosmosModelValidator.cs
+++ b/src/EFCore.Cosmos/Infrastructure/Internal/CosmosModelValidator.cs
@@ -342,6 +342,29 @@ public override void Validate(IModel model, IDiagnosticsLogger<DbLoggerCategory.
         }
     }
 
+    /// <summary>
+    ///     Validates the mapping/configuration of mutable in the model.
+    /// </summary>
+    /// <param name="model">The model to validate.</param>
+    /// <param name="logger">The logger to use.</param>
+    protected override void ValidateNoMutableKeys(
+        IModel model,
+        IDiagnosticsLogger<DbLoggerCategory.Model.Validation> logger)
+    {
+        foreach (var entityType in model.GetEntityTypes())
+        {
+            foreach (var key in entityType.GetDeclaredKeys())
+            {
+                var mutableProperty = key.Properties.FirstOrDefault(p => p.ValueGenerated.HasFlag(ValueGenerated.OnUpdate));
+                if (mutableProperty != null
+                    && !mutableProperty.IsOrdinalKeyProperty())
+                {
+                    throw new InvalidOperationException(CoreStrings.MutableKeyProperty(mutableProperty.Name));
+                }
+            }
+        }
+    }
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
diff --git a/src/EFCore.Cosmos/Metadata/Conventions/CosmosValueGenerationConvention.cs b/src/EFCore.Cosmos/Metadata/Conventions/CosmosValueGenerationConvention.cs
index eab5eb6146..50ddd2f2a2 100644
--- a/src/EFCore.Cosmos/Metadata/Conventions/CosmosValueGenerationConvention.cs
+++ b/src/EFCore.Cosmos/Metadata/Conventions/CosmosValueGenerationConvention.cs
@@ -78,11 +78,11 @@ public class CosmosValueGenerationConvention :
             {
                 var pk = property.FindContainingPrimaryKey();
                 if (pk != null
-                    && !ownership.Properties.Contains(property)
+                    && !property.IsForeignKey()
                     && pk.Properties.Count == ownership.Properties.Count + 1
                     && ownership.Properties.All(fkProperty => pk.Properties.Contains(fkProperty)))
                 {
-                    return base.GetValueGenerated(property);
+                    return ValueGenerated.OnAddOrUpdate;
                 }
             }
         }
diff --git a/src/EFCore.Cosmos/Metadata/Internal/CosmosPropertyExtensions.cs b/src/EFCore.Cosmos/Metadata/Internal/CosmosPropertyExtensions.cs
index 74424e05fa..9faad7252f 100644
--- a/src/EFCore.Cosmos/Metadata/Internal/CosmosPropertyExtensions.cs
+++ b/src/EFCore.Cosmos/Metadata/Internal/CosmosPropertyExtensions.cs
@@ -27,6 +27,6 @@ public static bool IsOrdinalKeyProperty(this IReadOnlyProperty property)
             && key.Properties.Count > 1
             && !property.IsForeignKey()
             && property.ClrType == typeof(int)
-            && property.ValueGenerated == ValueGenerated.OnAdd;
+            && (property.ValueGenerated & ValueGenerated.OnAdd) != 0;
     }
 }
diff --git a/src/EFCore.Cosmos/Update/Internal/DocumentSource.cs b/src/EFCore.Cosmos/Update/Internal/DocumentSource.cs
index 18e8dedcd5..d479da1caa 100644
--- a/src/EFCore.Cosmos/Update/Internal/DocumentSource.cs
+++ b/src/EFCore.Cosmos/Update/Internal/DocumentSource.cs
@@ -120,13 +120,20 @@ public virtual JObject CreateDocument(IUpdateEntry entry, int? ordinal)
             }
             else
             {
+                SetTemporaryOrdinals(entry, fk, embeddedValue);
+
+#pragma warning disable EF1001 // Internal EF Core API usage.
+                // #16707
+                var stateManager = ((InternalEntityEntry)entry).StateManager;
+#pragma warning restore EF1001 // Internal EF Core API usage.
+
                 var embeddedOrdinal = 1;
                 var array = new JArray();
                 foreach (var dependent in (IEnumerable)embeddedValue)
                 {
 #pragma warning disable EF1001 // Internal EF Core API usage.
                     // #16707
-                    var dependentEntry = ((InternalEntityEntry)entry).StateManager.TryGetEntry(dependent, fk.DeclaringEntityType)!;
+                    var dependentEntry = stateManager.TryGetEntry(dependent, fk.DeclaringEntityType)!;
                     array.Add(_database.GetDocumentSource(dependentEntry.EntityType).CreateDocument(dependentEntry, embeddedOrdinal));
 #pragma warning restore EF1001 // Internal EF Core API usage.
                     embeddedOrdinal++;
@@ -157,13 +164,17 @@ public virtual JObject CreateDocument(IUpdateEntry entry, int? ordinal)
     public virtual JObject? UpdateDocument(JObject document, IUpdateEntry entry, int? ordinal)
     {
         var anyPropertyUpdated = false;
-#pragma warning disable EF1001 // Internal EF Core API usage.
-        // #16707
-        var stateManager = ((InternalEntityEntry)entry).StateManager;
-#pragma warning restore EF1001 // Internal EF Core API usage.
         foreach (var property in entry.EntityType.GetProperties())
         {
+            if (ordinal != null
+                && entry.HasTemporaryValue(property)
+                && property.IsOrdinalKeyProperty())
+            {
+                entry.SetStoreGeneratedValue(property, ordinal.Value);
+            }
+
             if (entry.EntityState == EntityState.Added
+                || entry.SharedIdentityEntry != null
                 || entry.IsModified(property))
             {
                 var storeName = property.GetJsonPropertyName();
@@ -173,13 +184,6 @@ public virtual JObject CreateDocument(IUpdateEntry entry, int? ordinal)
                     anyPropertyUpdated = true;
                 }
             }
-
-            if (ordinal != null
-                && entry.HasTemporaryValue(property)
-                && property.IsOrdinalKeyProperty())
-            {
-                entry.SetStoreGeneratedValue(property, ordinal.Value);
-            }
         }
 
         foreach (var ownedNavigation in entry.EntityType.GetNavigations())
@@ -207,12 +211,8 @@ public virtual JObject CreateDocument(IUpdateEntry entry, int? ordinal)
             {
 #pragma warning disable EF1001 // Internal EF Core API usage.
                 // #16707
-                var embeddedEntry = ((InternalEntityEntry)entry).StateManager.TryGetEntry(embeddedValue, fk.DeclaringEntityType);
+                var embeddedEntry = ((InternalEntityEntry)entry).StateManager.TryGetEntry(embeddedValue, fk.DeclaringEntityType)!;
 #pragma warning restore EF1001 // Internal EF Core API usage.
-                if (embeddedEntry == null)
-                {
-                    continue;
-                }
 
                 var embeddedDocument = embeddedDocumentSource.GetCurrentDocument(embeddedEntry);
                 embeddedDocument = embeddedDocument != null
@@ -227,64 +227,21 @@ public virtual JObject CreateDocument(IUpdateEntry entry, int? ordinal)
             }
             else
             {
-                var embeddedOrdinal = 1;
-                var ordinalKeyProperty = FindOrdinalKeyProperty(fk.DeclaringEntityType);
-                if (ordinalKeyProperty != null)
-                {
-                    var shouldSetTemporaryKeys = false;
-                    foreach (var dependent in (IEnumerable)embeddedValue)
-                    {
-#pragma warning disable EF1001 // Internal EF Core API usage.
-                        // #16707
-                        var embeddedEntry = stateManager.TryGetEntry(dependent, fk.DeclaringEntityType);
-                        if (embeddedEntry == null)
-                        {
-                            continue;
-                        }
-
-                        if ((int)embeddedEntry.GetCurrentValue(ordinalKeyProperty)! != embeddedOrdinal)
-                        {
-                            shouldSetTemporaryKeys = true;
-                            break;
-                        }
-#pragma warning restore EF1001 // Internal EF Core API usage.
+                SetTemporaryOrdinals(entry, fk, embeddedValue);
 
-                        embeddedOrdinal++;
-                    }
-
-                    if (shouldSetTemporaryKeys)
-                    {
-                        var temporaryOrdinal = -1;
-                        foreach (var dependent in (IEnumerable)embeddedValue)
-                        {
 #pragma warning disable EF1001 // Internal EF Core API usage.
-                            // #16707
-                            var embeddedEntry = stateManager.TryGetEntry(dependent, fk.DeclaringEntityType);
-                            if (embeddedEntry == null)
-                            {
-                                continue;
-                            }
-
-                            embeddedEntry.SetTemporaryValue(ordinalKeyProperty, temporaryOrdinal, setModified: false);
+                // #16707
+                var stateManager = ((InternalEntityEntry)entry).StateManager;
 #pragma warning restore EF1001 // Internal EF Core API usage.
 
-                            temporaryOrdinal--;
-                        }
-                    }
-                }
-
-                embeddedOrdinal = 1;
+                var embeddedOrdinal = 1;
                 var array = new JArray();
                 foreach (var dependent in (IEnumerable)embeddedValue)
                 {
 #pragma warning disable EF1001 // Internal EF Core API usage.
                     // #16707
-                    var embeddedEntry = ((InternalEntityEntry)entry).StateManager.TryGetEntry(dependent, fk.DeclaringEntityType);
+                    var embeddedEntry = stateManager.TryGetEntry(dependent, fk.DeclaringEntityType)!;
 #pragma warning restore EF1001 // Internal EF Core API usage.
-                    if (embeddedEntry == null)
-                    {
-                        continue;
-                    }
 
                     var embeddedDocument = embeddedDocumentSource.GetCurrentDocument(embeddedEntry);
                     embeddedDocument = embeddedDocument != null
@@ -303,10 +260,58 @@ public virtual JObject CreateDocument(IUpdateEntry entry, int? ordinal)
         return anyPropertyUpdated ? document : null;
     }
 
+    private static void SetTemporaryOrdinals(
+        IUpdateEntry entry,
+        IForeignKey fk,
+        object embeddedValue)
+    {
+        var embeddedOrdinal = 1;
+        var ordinalKeyProperty = FindOrdinalKeyProperty(fk.DeclaringEntityType);
+        if (ordinalKeyProperty != null)
+        {
+#pragma warning disable EF1001 // Internal EF Core API usage.
+            // #16707
+            var stateManager = ((InternalEntityEntry)entry).StateManager;
+#pragma warning restore EF1001 // Internal EF Core API usage.
+            var shouldSetTemporaryKeys = false;
+            foreach (var dependent in (IEnumerable)embeddedValue)
+            {
+#pragma warning disable EF1001 // Internal EF Core API usage.
+                // #16707
+                var embeddedEntry = stateManager.TryGetEntry(dependent, fk.DeclaringEntityType)!;
+
+                if ((int)embeddedEntry.GetCurrentValue(ordinalKeyProperty)! != embeddedOrdinal
+                    && !embeddedEntry.HasTemporaryValue(ordinalKeyProperty))
+                {
+                    shouldSetTemporaryKeys = true;
+                    break;
+                }
+#pragma warning restore EF1001 // Internal EF Core API usage.
+
+                embeddedOrdinal++;
+            }
+
+            if (shouldSetTemporaryKeys)
+            {
+                var temporaryOrdinal = -1;
+                foreach (var dependent in (IEnumerable)embeddedValue)
+                {
+#pragma warning disable EF1001 // Internal EF Core API usage.
+                    // #16707
+                    var embeddedEntry = stateManager.TryGetEntry(dependent, fk.DeclaringEntityType)!;
+
+                    embeddedEntry.SetTemporaryValue(ordinalKeyProperty, temporaryOrdinal, setModified: false);
+#pragma warning restore EF1001 // Internal EF Core API usage.
+
+                    temporaryOrdinal--;
+                }
+            }
+        }
+    }
+
     private static IProperty? FindOrdinalKeyProperty(IEntityType entityType)
         => entityType.FindPrimaryKey()!.Properties.FirstOrDefault(
-            p =>
-                p.GetJsonPropertyName().Length == 0 && p.IsOrdinalKeyProperty());
+            p => p.GetJsonPropertyName().Length == 0 && p.IsOrdinalKeyProperty());
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
diff --git a/src/EFCore.Relational/Extensions/Internal/RelationalPropertyInternalExtensions.cs b/src/EFCore.Relational/Extensions/Internal/RelationalPropertyInternalExtensions.cs
index e1cfe82d4e..904292a95b 100644
--- a/src/EFCore.Relational/Extensions/Internal/RelationalPropertyInternalExtensions.cs
+++ b/src/EFCore.Relational/Extensions/Internal/RelationalPropertyInternalExtensions.cs
@@ -1,4 +1,4 @@
-ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
 namespace Microsoft.EntityFrameworkCore.Metadata.Internal;
@@ -21,7 +21,6 @@ public static bool IsOrdinalKeyProperty(this IReadOnlyProperty property)
         => property.FindContainingPrimaryKey() is IReadOnlyKey key
             && key.Properties.Count > 1
             && !property.IsForeignKey()
-            && property.IsShadowProperty()
             && property.ClrType == typeof(int)
             && property.GetJsonPropertyName() == null;
 }
diff --git a/src/EFCore.Relational/Infrastructure/RelationalModelValidator.cs b/src/EFCore.Relational/Infrastructure/RelationalModelValidator.cs
index bccb4c1cb7..5bc046911d 100644
--- a/src/EFCore.Relational/Infrastructure/RelationalModelValidator.cs
+++ b/src/EFCore.Relational/Infrastructure/RelationalModelValidator.cs
@@ -720,6 +720,29 @@ static bool IsNotNullAndFalse(object? value)
             }
         }
     }
+    
+    /// <summary>
+    ///     Validates the mapping/configuration of mutable in the model.
+    /// </summary>
+    /// <param name="model">The model to validate.</param>
+    /// <param name="logger">The logger to use.</param>
+    protected override void ValidateNoMutableKeys(
+        IModel model,
+        IDiagnosticsLogger<DbLoggerCategory.Model.Validation> logger)
+    {
+        foreach (var entityType in model.GetEntityTypes())
+        {
+            foreach (var key in entityType.GetDeclaredKeys())
+            {
+                var mutableProperty = key.Properties.FirstOrDefault(p => p.ValueGenerated.HasFlag(ValueGenerated.OnUpdate));
+                if (mutableProperty != null
+                    && !mutableProperty.IsOrdinalKeyProperty())
+                {
+                    throw new InvalidOperationException(CoreStrings.MutableKeyProperty(mutableProperty.Name));
+                }
+            }
+        }
+    }
 
     /// <summary>
     ///     Validates the mapping/configuration of shared tables in the model.
diff --git a/src/EFCore.Relational/Metadata/Conventions/RelationalValueGenerationConvention.cs b/src/EFCore.Relational/Metadata/Conventions/RelationalValueGenerationConvention.cs
index 0513a28717..98468aba16 100644
--- a/src/EFCore.Relational/Metadata/Conventions/RelationalValueGenerationConvention.cs
+++ b/src/EFCore.Relational/Metadata/Conventions/RelationalValueGenerationConvention.cs
@@ -186,9 +186,9 @@ public class RelationalValueGenerationConvention :
             : table.Name != null
                 ? GetValueGenerated(property, table)
                 : property.DeclaringEntityType.IsMappedToJson()
-                && !property.DeclaringEntityType.FindOwnership()!.IsUnique
-                && property.IsOrdinalKeyProperty()
-                    ? ValueGenerated.OnAdd
+                    && !property.DeclaringEntityType.FindOwnership()!.IsUnique
+                    && property.IsOrdinalKeyProperty()
+                    ? ValueGenerated.OnAddOrUpdate
                     : property.GetMappedStoreObjects(StoreObjectType.InsertStoredProcedure).Any()
                         ? GetValueGenerated((IReadOnlyProperty)property)
                         : null;
diff --git a/src/EFCore/ChangeTracking/Internal/InternalEntityEntry.cs b/src/EFCore/ChangeTracking/Internal/InternalEntityEntry.cs
index e4fc0bfc9e..ae03f45f7f 100644
--- a/src/EFCore/ChangeTracking/Internal/InternalEntityEntry.cs
+++ b/src/EFCore/ChangeTracking/Internal/InternalEntityEntry.cs
@@ -963,13 +963,7 @@ public bool CollectionContains(INavigationBase navigationBase, object value)
         }
 
         var collection = GetOrCreateShadowCollection(navigationBase);
-        if (!collectionAccessor.ContainsStandalone(collection, value))
-        {
-            collectionAccessor.AddStandalone(collection, value);
-            return true;
-        }
-
-        return false;
+        return collectionAccessor.AddStandalone(collection, value);
     }
 
     /// <summary>
diff --git a/src/EFCore/ChangeTracking/Internal/NavigationFixer.cs b/src/EFCore/ChangeTracking/Internal/NavigationFixer.cs
index d86ac82d24..34b4dc6285 100644
--- a/src/EFCore/ChangeTracking/Internal/NavigationFixer.cs
+++ b/src/EFCore/ChangeTracking/Internal/NavigationFixer.cs
@@ -525,8 +525,11 @@ var targetDependentEntry
                     foreach (InternalEntityEntry dependentEntry in stateManager
                                  .GetDependentsUsingRelationshipSnapshot(entry, foreignKey).ToList())
                     {
+                        if (dependentEntry.EntityState == EntityState.Deleted)
+                        {
+                            continue;
+                        }
                         SetForeignKeyProperties(dependentEntry, entry, foreignKey, setModified: true, fromQuery: false);
-                        UndeleteDependent(dependentEntry, entry);
                     }
 
                     if (foreignKey.IsOwnership)
diff --git a/test/EFCore.Cosmos.FunctionalTests/EmbeddedDocumentsTest.cs b/test/EFCore.Cosmos.FunctionalTests/EmbeddedDocumentsTest.cs
index ff8218b703..0f9ad72c16 100644
--- a/test/EFCore.Cosmos.FunctionalTests/EmbeddedDocumentsTest.cs
+++ b/test/EFCore.Cosmos.FunctionalTests/EmbeddedDocumentsTest.cs
@@ -97,8 +97,10 @@ public virtual async Task Can_attach_owner_with_dependents()
         }
     }
 
-    [ConditionalFact]
-    public virtual async Task Can_manipulate_embedded_collections()
+    [ConditionalTheory]
+    [InlineData(false)]
+    [InlineData(true)]
+    public virtual async Task Can_manipulate_embedded_collections(bool useIds)
     {
         var options = Fixture.CreateOptions(seed: false);
 
@@ -111,27 +113,62 @@ public virtual async Task Can_manipulate_embedded_collections()
         using (var context = new EmbeddedTransportationContext(options))
         {
             context.Add(new Person { Id = 1 });
-            var note1 = new Note { Content = "First note" };
-            var note2 = new Note { Content = "Second note" };
             existingAddress1Person2 = new Address
             {
                 Street = "Second",
-                City = "Village",
-                Notes = new List<Note> { note1, note2 }
+                City = "Village"
+            };
+            if (useIds)
+            {
+                existingAddress1Person2.IdNotes = new List<NoteWithId>
+                {
+                    new NoteWithId { Content = "First note" },
+                    new NoteWithId { Content = "Second note" }
+                };
+            }
+            else
+            {
+                existingAddress1Person2.Notes = new List<Note>
+                {
+                    new Note { Content = "First note" },
+                    new Note { Content = "Second note" }
+                };
+            }
+
+            var existingAddress2Person2 = new Address
+            {
+                Street = "First",
+                City = "Village"
             };
-            context.Add(new Person { Id = 2, Addresses = new List<Address> { existingAddress1Person2 } });
+            context.Add(new Person { Id = 2, Addresses = new List<Address> { existingAddress1Person2, existingAddress2Person2 } });
             existingAddress1Person3 = new Address
             {
                 Street = "First",
                 City = "City",
-                AddressTitle = new AddressTitle { Title = "P3 Shipping" }
+                AddressTitle = new AddressTitle { Title = "P3 Shipping" },
             };
+            if (useIds)
+            {
+                existingAddress1Person3.IdNotes = new List<NoteWithId>
+                {
+                    new NoteWithId { Id = 2, Content = "First City note" }
+                };
+            }
+            else
+            {
+                existingAddress1Person3.Notes = new List<Note>
+                {
+                    new Note { Content = "First City note" }
+                };
+            }
+
             existingAddress2Person3 = new Address
             {
                 Street = "Second",
                 City = "City",
                 AddressTitle = new AddressTitle { Title = "P3 Billing" }
             };
+
             context.Add(new Person { Id = 3, Addresses = new List<Address> { existingAddress1Person3, existingAddress2Person3 } });
 
             await context.SaveChangesAsync();
@@ -140,10 +177,18 @@ public virtual async Task Can_manipulate_embedded_collections()
 
             Assert.Empty(people[0].Addresses);
 
-            Assert.Equal(1, people[1].Addresses.Count);
+            Assert.Equal(2, people[1].Addresses.Count);
             Assert.Same(existingAddress1Person2, people[1].Addresses.First());
+            Assert.Same(existingAddress2Person2, people[1].Addresses.Last());
 
-            Assert.Equal(2, existingAddress1Person2.Notes.Count);
+            if (useIds)
+            {
+                Assert.Equal(2, existingAddress1Person2.IdNotes.Count);
+            }
+            else
+            {
+                Assert.Equal(2, existingAddress1Person2.Notes.Count);
+            }
             Assert.Same(existingAddress1Person3, people[2].Addresses.First());
             Assert.Same(existingAddress2Person3, people[2].Addresses.Last());
 
@@ -167,19 +212,40 @@ public virtual async Task Can_manipulate_embedded_collections()
             {
                 Street = "Another",
                 City = "Village",
-                AddressTitle = new AddressTitle { Title = "P2" },
-                Notes = existingAddress1Person2.Notes
+                AddressTitle = new AddressTitle { Title = "P2" }
             };
-            people[1].Addresses.Clear();
+            if (useIds)
+            {
+                addedAddress2.IdNotes = existingAddress1Person2.IdNotes;
+            }
+            else
+            {
+                addedAddress2.Notes = existingAddress1Person2.Notes;
+            }
+
+            people[1].Addresses.Remove(people[1].Addresses.First());
             people[1].Addresses.Add(addedAddress2);
 
             addedAddress3 = new Address
             {
                 Street = "Another",
                 City = "City",
-                AddressTitle = new AddressTitle { Title = "P3 Alternative" },
-                Notes = new List<Note> { new() { Content = "Another note" } }
+                AddressTitle = new AddressTitle { Title = "P3 Alternative" }
             };
+            if (useIds)
+            {
+                addedAddress3.IdNotes = new List<NoteWithId>
+                {
+                    new NoteWithId { Id = -1, Content = "Another note" }
+                };
+            }
+            else
+            {
+                addedAddress3.Notes = new List<Note>
+                {
+                    new Note { Content = "Another note" }
+                };
+            }
 
             var existingFirstAddressEntry = context.Entry(people[2].Addresses.First());
 
@@ -190,12 +256,35 @@ public virtual async Task Can_manipulate_embedded_collections()
 
             existingFirstAddressEntry.Property<JObject>("__jObject").IsModified = true;
 
-            var existingLastAddress = people[2].Addresses.Last();
-            people[2].Addresses.Remove(existingLastAddress);
+            existingAddress1Person3 = people[2].Addresses.First();
+            existingAddress2Person3 = people[2].Addresses.Last();
+            people[2].Addresses.Remove(existingAddress2Person3);
             people[2].Addresses.Add(addedAddress3);
-            people[2].Addresses.Add(existingLastAddress);
+            people[2].Addresses.Add(existingAddress2Person3);
+
+            if (useIds)
+            {
+                existingAddress1Person3.IdNotes = new List<NoteWithId>
+                {
+                    new NoteWithId { Id = 1, Content = "Some City note" }
+                };
+            }
+            else
+            {
+                existingAddress1Person3.Notes = new List<Note>
+                {
+                    new Note { Content = "Some City note" }
+                };
+            }
 
-            existingLastAddress.Notes.Add(new Note { Content = "City note" });
+            if (useIds)
+            {
+                existingAddress2Person3.IdNotes.Add(new NoteWithId { Id = 4, Content = "City note" });
+            }
+            else
+            {
+                existingAddress2Person3.Notes.Add(new Note { Content = "City note" });
+            }
 
             await context.SaveChangesAsync();
 
@@ -215,17 +304,36 @@ async Task AssertState(EmbeddedTransportationContext context)
             Assert.Equal("Town", firstAddress.City);
             Assert.Equal("P1", firstAddress.AddressTitle.Title);
             Assert.Empty(firstAddress.Notes);
+            Assert.Empty(firstAddress.IdNotes);
 
             var addresses = people[1].Addresses.ToList();
-            Assert.Single(addresses);
+            Assert.Equal(2, addresses.Count);
 
-            Assert.Equal("Another", addresses[0].Street);
+            Assert.Equal("First", addresses[0].Street);
             Assert.Equal("Village", addresses[0].City);
-            Assert.Equal("P2", addresses[0].AddressTitle.Title);
-            var notes = addresses[0].Notes;
-            Assert.Equal(2, notes.Count);
-            Assert.Equal("First note", notes.First().Content);
-            Assert.Equal("Second note", notes.Last().Content);
+            Assert.Null(addresses[0].AddressTitle);
+            Assert.Empty(addresses[0].Notes);
+            Assert.Empty(addresses[0].IdNotes);
+
+            Assert.Equal("Another", addresses[1].Street);
+            Assert.Equal("Village", addresses[1].City);
+            Assert.Equal("P2", addresses[1].AddressTitle.Title);
+            if (useIds)
+            {
+                var notes = addresses[1].IdNotes;
+                Assert.Equal(2, notes.Count);
+                Assert.Equal(1, notes.First().Id);
+                Assert.Equal("First note", notes.First().Content);
+                Assert.Equal(2, notes.Last().Id);
+                Assert.Equal("Second note", notes.Last().Content);
+            }
+            else
+            {
+                var notes = addresses[1].Notes;
+                Assert.Equal(2, notes.Count);
+                Assert.Equal("First note", notes.First().Content);
+                Assert.Equal("Second note", notes.Last().Content);
+            }
 
             addresses = people[2].Addresses.ToList();
             Assert.Equal(3, addresses.Count);
@@ -233,26 +341,55 @@ async Task AssertState(EmbeddedTransportationContext context)
             Assert.Equal("First", addresses[0].Street);
             Assert.Equal("City", addresses[0].City);
             Assert.Equal("P3 Shipping", addresses[0].AddressTitle.Title);
+            if (useIds)
+            {
+                Assert.Equal(1, addresses[0].IdNotes.Count);
+                Assert.Equal(1, addresses[0].IdNotes.First().Id);
+                Assert.Equal("Some City note", addresses[0].IdNotes.First().Content);
+            }
+            else
+            {
+                Assert.Equal(1, addresses[0].Notes.Count);
+                Assert.Equal("Some City note", addresses[0].Notes.First().Content);
+            }
 
             var existingAddressEntry = context.Entry(addresses[0]);
 
             var addressJson = existingAddressEntry.Property<JObject>("__jObject").CurrentValue;
 
             Assert.Equal("First", addressJson[nameof(Address.Street)]);
-            Assert.Equal(5, addressJson.Count);
+            Assert.Equal(6, addressJson.Count);
             Assert.Equal(2, addressJson["unmappedId"]);
 
             Assert.Equal("Another", addresses[1].Street);
             Assert.Equal("City", addresses[1].City);
             Assert.Equal("P3 Alternative", addresses[1].AddressTitle.Title);
-            Assert.Equal(1, addresses[1].Notes.Count);
-            Assert.Equal("Another note", addresses[1].Notes.First().Content);
+            if (useIds)
+            {
+                Assert.Equal(1, addresses[1].IdNotes.Count);
+                Assert.Equal(1, addresses[1].IdNotes.First().Id);
+                Assert.Equal("Another note", addresses[1].IdNotes.First().Content);
+            }
+            else
+            {
+                Assert.Equal(1, addresses[1].Notes.Count);
+                Assert.Equal("Another note", addresses[1].Notes.First().Content);
+            }
 
             Assert.Equal("Second", addresses[2].Street);
             Assert.Equal("City", addresses[2].City);
             Assert.Equal("P3 Billing", addresses[2].AddressTitle.Title);
-            Assert.Equal(1, addresses[2].Notes.Count);
-            Assert.Equal("City note", addresses[2].Notes.First().Content);
+            if (useIds)
+            {
+                Assert.Equal(1, addresses[2].IdNotes.Count);
+                Assert.Equal(1, addresses[2].IdNotes.First().Id);
+                Assert.Equal("City note", addresses[2].IdNotes.First().Content);
+            }
+            else
+            {
+                Assert.Equal(1, addresses[2].Notes.Count);
+                Assert.Equal("City note", addresses[2].Notes.First().Content);
+            }
         }
     }
 
@@ -590,7 +727,6 @@ protected override void OnModelCreating(ModelBuilder modelBuilder)
                     {
                         b.ToJsonProperty("Stored Addresses");
                         b.OwnsOne(a => a.AddressTitle).Property(a => a.Title).HasValueGenerator<TitleGenerator>().IsRequired();
-                        b.OwnsMany(a => a.Notes);
                     }));
         }
     }
@@ -611,7 +747,7 @@ private abstract class PersonBase
 
     private class Person : PersonBase
     {
-        public ICollection<Address> Addresses { get; set; } = new HashSet<Address>();
+        public ICollection<Address> Addresses { get; set; } = new List<Address>();
     }
 
     public class Address
@@ -619,7 +755,8 @@ public class Address
         public string Street { get; set; }
         public string City { get; set; }
         public AddressTitle AddressTitle { get; set; }
-        public ICollection<Note> Notes { get; set; } = new HashSet<Note>();
+        public ICollection<Note> Notes { get; set; } = new List<Note>();
+        public ICollection<NoteWithId> IdNotes { get; set; } = new List<NoteWithId>();
     }
 
     public class AddressTitle
@@ -631,4 +768,10 @@ public class Note
     {
         public string Content { get; set; }
     }
+
+    public class NoteWithId
+    {
+        public int Id { get; set; }
+        public string Content { get; set; }
+    }
 }
diff --git a/test/EFCore.Design.Tests/Migrations/ModelSnapshotSqlServerTest.cs b/test/EFCore.Design.Tests/Migrations/ModelSnapshotSqlServerTest.cs
index fb261d6306..f53c8d08d7 100644
--- a/test/EFCore.Design.Tests/Migrations/ModelSnapshotSqlServerTest.cs
+++ b/test/EFCore.Design.Tests/Migrations/ModelSnapshotSqlServerTest.cs
@@ -3712,6 +3712,7 @@ public virtual void Owned_types_mapped_to_json_are_stored_in_snapshot()
                                                 .HasColumnType(""int"");
 
                                             b3.Property<int>(""Id"")
+                                                .ValueGeneratedOnAdd()
                                                 .HasColumnType(""int"");
 
                                             b3.Property<string>(""Name"")
