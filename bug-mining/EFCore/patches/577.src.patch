diff --git a/src/EFCore.Cosmos/Query/Internal/CosmosProjectionBindingExpressionVisitor.cs b/src/EFCore.Cosmos/Query/Internal/CosmosProjectionBindingExpressionVisitor.cs
index 8013c16389..750957cbdd 100644
--- a/src/EFCore.Cosmos/Query/Internal/CosmosProjectionBindingExpressionVisitor.cs
+++ b/src/EFCore.Cosmos/Query/Internal/CosmosProjectionBindingExpressionVisitor.cs
@@ -114,22 +114,16 @@ public virtual Expression Translate(SelectExpression selectExpression, Expressio
                 case ConstantExpression:
                     return expression;
 
-                case ParameterExpression parameterExpression:
-                    if (_collectionShaperMapping.ContainsKey(parameterExpression))
-                    {
-                        return parameterExpression;
-                    }
-
-                    if (parameterExpression.Name?.StartsWith(QueryCompilationContext.QueryParameterPrefix, StringComparison.Ordinal)
-                        == true)
-                    {
-                        return Expression.Call(
-                            GetParameterValueMethodInfo.MakeGenericMethod(parameterExpression.Type),
-                            QueryCompilationContext.QueryContextParameter,
-                            Expression.Constant(parameterExpression.Name));
-                    }
+                case QueryParameterExpression queryParameter:
+                    return Expression.Call(
+                        GetParameterValueMethodInfo.MakeGenericMethod(queryParameter.Type),
+                        QueryCompilationContext.QueryContextParameter,
+                        Expression.Constant(queryParameter.Name));
 
-                    throw new InvalidOperationException(CoreStrings.TranslationFailed(parameterExpression.Print()));
+                case ParameterExpression parameterExpression:
+                    return _collectionShaperMapping.ContainsKey(parameterExpression)
+                        ? parameterExpression
+                        : throw new InvalidOperationException(CoreStrings.TranslationFailed(parameterExpression.Print()));
 
                 case MaterializeCollectionNavigationExpression:
                     return base.Visit(expression);
diff --git a/src/EFCore.Cosmos/Query/Internal/CosmosQueryRootProcessor.cs b/src/EFCore.Cosmos/Query/Internal/CosmosQueryRootProcessor.cs
index c1e56ee984..4099874742 100644
--- a/src/EFCore.Cosmos/Query/Internal/CosmosQueryRootProcessor.cs
+++ b/src/EFCore.Cosmos/Query/Internal/CosmosQueryRootProcessor.cs
@@ -38,7 +38,7 @@ protected override bool ShouldConvertToInlineQueryRoot(Expression expression)
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    protected override bool ShouldConvertToParameterQueryRoot(ParameterExpression parameterExpression)
+    protected override bool ShouldConvertToParameterQueryRoot(QueryParameterExpression parameterExpression)
         => true;
 
     /// <inheritdoc />
diff --git a/src/EFCore.Cosmos/Query/Internal/CosmosQuerySqlGenerator.cs b/src/EFCore.Cosmos/Query/Internal/CosmosQuerySqlGenerator.cs
index 67b1437208..9e9c8151d2 100644
--- a/src/EFCore.Cosmos/Query/Internal/CosmosQuerySqlGenerator.cs
+++ b/src/EFCore.Cosmos/Query/Internal/CosmosQuerySqlGenerator.cs
@@ -383,8 +383,8 @@ protected override Expression VisitFromSql(FromSqlExpression fromSqlExpression)
 
         switch (fromSqlExpression.Arguments)
         {
-            case ParameterExpression { Name: not null } parameterExpression
-                when _parameterValues.TryGetValue(parameterExpression.Name, out var parameterValue)
+            case QueryParameterExpression queryParameter
+                when _parameterValues.TryGetValue(queryParameter.Name, out var parameterValue)
                 && parameterValue is object[] parameterValues:
             {
                 substitutions = new string[parameterValues.Length];
diff --git a/src/EFCore.Cosmos/Query/Internal/CosmosQueryableMethodTranslatingExpressionVisitor.cs b/src/EFCore.Cosmos/Query/Internal/CosmosQueryableMethodTranslatingExpressionVisitor.cs
index 51a417cddc..833b1100da 100644
--- a/src/EFCore.Cosmos/Query/Internal/CosmosQueryableMethodTranslatingExpressionVisitor.cs
+++ b/src/EFCore.Cosmos/Query/Internal/CosmosQueryableMethodTranslatingExpressionVisitor.cs
@@ -122,9 +122,9 @@ public override Expression Translate(Expression expression)
             if (arguments is not
                 [
                     _, // source
-                    ParameterExpression maxItemCount,
-                    ParameterExpression continuationToken,
-                    ParameterExpression responseContinuationTokenLimitInKb,
+                    QueryParameterExpression maxItemCount,
+                    QueryParameterExpression continuationToken,
+                    QueryParameterExpression responseContinuationTokenLimitInKb,
                     _ // cancellation token
                 ]
                 || _sqlTranslator.Translate(maxItemCount) is not SqlParameterExpression translatedMaxItemCount
@@ -1496,18 +1496,14 @@ protected override ShapedQueryExpression TranslateSelect(ShapedQueryExpression s
     /// </summary>
     protected override ShapedQueryExpression? TranslateParameterQueryRoot(ParameterQueryRootExpression parameterQueryRootExpression)
     {
-        var parameter = parameterQueryRootExpression.ParameterExpression;
-        if (parameter.Name?.StartsWith(QueryCompilationContext.QueryParameterPrefix, StringComparison.Ordinal) != true)
-        {
-            return null;
-        }
+        var queryParameter = parameterQueryRootExpression.QueryParameterExpression;
 
         // TODO: Temporary hack - need to perform proper derivation of the array type mapping from the element (e.g. for
         // value conversion). #34026.
         var elementClrType = parameterQueryRootExpression.ElementType;
         var arrayTypeMapping = _typeMappingSource.FindMapping(typeof(IEnumerable<>).MakeGenericType(elementClrType));
         var elementTypeMapping = _typeMappingSource.FindMapping(elementClrType)!;
-        var sqlParameterExpression = new SqlParameterExpression(parameter.Name, parameter.Type, arrayTypeMapping);
+        var sqlParameterExpression = new SqlParameterExpression(queryParameter.Name, queryParameter.Type, arrayTypeMapping);
 
         var sourceAlias = _aliasManager.GenerateSourceAlias(sqlParameterExpression.Name.TrimStart('_'));
         var select = SelectExpression.CreateForCollection(
diff --git a/src/EFCore.Cosmos/Query/Internal/CosmosSqlTranslatingExpressionVisitor.cs b/src/EFCore.Cosmos/Query/Internal/CosmosSqlTranslatingExpressionVisitor.cs
index 470c226371..02329b5b82 100644
--- a/src/EFCore.Cosmos/Query/Internal/CosmosSqlTranslatingExpressionVisitor.cs
+++ b/src/EFCore.Cosmos/Query/Internal/CosmosSqlTranslatingExpressionVisitor.cs
@@ -344,6 +344,9 @@ protected override Expression VisitExtension(Expression extensionExpression)
             case SqlExpression:
                 return extensionExpression;
 
+            case QueryParameterExpression queryParameter:
+                return new SqlParameterExpression(queryParameter.Name, queryParameter.Type, null);
+
             case StructuralTypeShaperExpression shaper:
                 return new EntityReferenceExpression(shaper);
 
@@ -787,9 +790,7 @@ protected override Expression VisitNewArray(NewArrayExpression newArrayExpressio
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
     protected override Expression VisitParameter(ParameterExpression parameterExpression)
-        => parameterExpression.Name?.StartsWith(QueryCompilationContext.QueryParameterPrefix, StringComparison.Ordinal) == true
-            ? new SqlParameterExpression(parameterExpression.Name, parameterExpression.Type, null)
-            : QueryCompilationContext.NotTranslatedExpression;
+        => QueryCompilationContext.NotTranslatedExpression;
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
@@ -1029,8 +1030,7 @@ private bool TryRewriteContainsEntity(Expression source, Expression item, [NotNu
                 rewrittenSource = Expression.Constant(propertyValueList);
                 break;
 
-            case SqlParameterExpression sqlParameterExpression
-                when sqlParameterExpression.Name.StartsWith(QueryCompilationContext.QueryParameterPrefix, StringComparison.Ordinal):
+            case SqlParameterExpression sqlParameterExpression:
                 var lambda = Expression.Lambda(
                     Expression.Call(
                         ParameterListValueExtractorMethod.MakeGenericMethod(entityType.ClrType, property.ClrType.MakeNullable()),
@@ -1156,8 +1156,7 @@ private Expression CreatePropertyAccessExpression(Expression target, IProperty p
                 return Expression.Constant(
                     property.GetGetter().GetClrValue(sqlConstantExpression.Value!), property.ClrType.MakeNullable());
 
-            case SqlParameterExpression sqlParameterExpression
-                when sqlParameterExpression.Name.StartsWith(QueryCompilationContext.QueryParameterPrefix, StringComparison.Ordinal):
+            case SqlParameterExpression sqlParameterExpression:
                 var lambda = Expression.Lambda(
                     Expression.Call(
                         ParameterValueExtractorMethod.MakeGenericMethod(property.ClrType.MakeNullable()),
diff --git a/src/EFCore.InMemory/Query/Internal/InMemoryExpressionTranslatingExpressionVisitor.cs b/src/EFCore.InMemory/Query/Internal/InMemoryExpressionTranslatingExpressionVisitor.cs
index 6234496a5f..660d0c7999 100644
--- a/src/EFCore.InMemory/Query/Internal/InMemoryExpressionTranslatingExpressionVisitor.cs
+++ b/src/EFCore.InMemory/Query/Internal/InMemoryExpressionTranslatingExpressionVisitor.cs
@@ -479,24 +479,25 @@ protected override Expression VisitConditional(ConditionalExpression conditional
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
     protected override Expression VisitExtension(Expression extensionExpression)
-    {
-        switch (extensionExpression)
+        => extensionExpression switch
         {
-            case EntityProjectionExpression:
-            case StructuralTypeReferenceExpression:
-                return extensionExpression;
+            EntityProjectionExpression or StructuralTypeReferenceExpression
+                => extensionExpression,
 
-            case StructuralTypeShaperExpression shaper:
-                return new StructuralTypeReferenceExpression(shaper);
+            QueryParameterExpression queryParameter
+                => Expression.Call(
+                    GetParameterValueMethodInfo.MakeGenericMethod(queryParameter.Type),
+                    QueryCompilationContext.QueryContextParameter,
+                    Expression.Constant(queryParameter.Name)),
 
-            case ProjectionBindingExpression projectionBindingExpression:
-                return ((InMemoryQueryExpression)projectionBindingExpression.QueryExpression)
-                    .GetProjection(projectionBindingExpression);
+            StructuralTypeShaperExpression shaper
+                => new StructuralTypeReferenceExpression(shaper),
 
-            default:
-                return QueryCompilationContext.NotTranslatedExpression;
-        }
-    }
+            ProjectionBindingExpression projectionBindingExpression
+                => ((InMemoryQueryExpression)projectionBindingExpression.QueryExpression).GetProjection(projectionBindingExpression),
+
+            _ => QueryCompilationContext.NotTranslatedExpression
+        };
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
@@ -988,17 +989,7 @@ protected override Expression VisitNewArray(NewArrayExpression newArrayExpressio
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
     protected override Expression VisitParameter(ParameterExpression parameterExpression)
-    {
-        if (parameterExpression.Name?.StartsWith(QueryCompilationContext.QueryParameterPrefix, StringComparison.Ordinal) == true)
-        {
-            return Expression.Call(
-                GetParameterValueMethodInfo.MakeGenericMethod(parameterExpression.Type),
-                QueryCompilationContext.QueryContextParameter,
-                Expression.Constant(parameterExpression.Name));
-        }
-
-        throw new InvalidOperationException(CoreStrings.TranslationFailed(parameterExpression.Print()));
-    }
+        => throw new InvalidOperationException(CoreStrings.TranslationFailed(parameterExpression.Print()));
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
diff --git a/src/EFCore.Relational/Query/Internal/FromSqlParameterExpandingExpressionVisitor.cs b/src/EFCore.Relational/Query/Internal/FromSqlParameterExpandingExpressionVisitor.cs
index 28e90b28c1..496907494f 100644
--- a/src/EFCore.Relational/Query/Internal/FromSqlParameterExpandingExpressionVisitor.cs
+++ b/src/EFCore.Relational/Query/Internal/FromSqlParameterExpandingExpressionVisitor.cs
@@ -92,9 +92,9 @@ public class FromSqlParameterExpandingExpressionVisitor : ExpressionVisitor
 
         switch (fromSql.Arguments)
         {
-            case ParameterExpression parameterExpression:
+            case QueryParameterExpression queryParameter:
                 // parameter value will never be null. It could be empty object?[]
-                var parameterValues = (object?[])_parametersValues[parameterExpression.Name!]!;
+                var parameterValues = (object?[])_parametersValues[queryParameter.Name]!;
                 _canCache = false;
 
                 var subParameters = new List<IRelationalParameter>(parameterValues.Length);
@@ -127,7 +127,7 @@ public class FromSqlParameterExpandingExpressionVisitor : ExpressionVisitor
                 }
 
                 return _visitedFromSqlExpressions[fromSql] = fromSql.Update(
-                    Expression.Constant(new CompositeRelationalParameter(parameterExpression.Name!, subParameters)));
+                    Expression.Constant(new CompositeRelationalParameter(queryParameter.Name!, subParameters)));
 
             case ConstantExpression { Value: object?[] existingValues }:
             {
@@ -158,7 +158,7 @@ public class FromSqlParameterExpandingExpressionVisitor : ExpressionVisitor
             }
 
             default:
-                Check.DebugFail("FromSql.Arguments must be Constant/ParameterExpression");
+                Check.DebugFail("FromSql.Arguments must be Constant/QueryParameterExpression");
                 return null;
         }
 
diff --git a/src/EFCore.Relational/Query/Internal/RelationalCommandCache.cs b/src/EFCore.Relational/Query/Internal/RelationalCommandCache.cs
index c4edba62a4..a29886eb9d 100644
--- a/src/EFCore.Relational/Query/Internal/RelationalCommandCache.cs
+++ b/src/EFCore.Relational/Query/Internal/RelationalCommandCache.cs
@@ -34,14 +34,13 @@ public class RelationalCommandCache : IPrintableExpression
         IQuerySqlGeneratorFactory querySqlGeneratorFactory,
         IRelationalParameterBasedSqlProcessorFactory relationalParameterBasedSqlProcessorFactory,
         Expression queryExpression,
-        bool useRelationalNulls,
-        IReadOnlySet<string> parametersToConstantize)
+        bool useRelationalNulls)
     {
         _memoryCache = memoryCache;
         _querySqlGeneratorFactory = querySqlGeneratorFactory;
         _queryExpression = queryExpression;
         _relationalParameterBasedSqlProcessor = relationalParameterBasedSqlProcessorFactory.Create(
-            new RelationalParameterBasedSqlProcessorParameters(useRelationalNulls, parametersToConstantize));
+            new RelationalParameterBasedSqlProcessorParameters(useRelationalNulls));
     }
 
     /// <summary>
diff --git a/src/EFCore.Relational/Query/Internal/RelationalProjectionBindingExpressionVisitor.cs b/src/EFCore.Relational/Query/Internal/RelationalProjectionBindingExpressionVisitor.cs
index b20e8213c7..dc2831a8d5 100644
--- a/src/EFCore.Relational/Query/Internal/RelationalProjectionBindingExpressionVisitor.cs
+++ b/src/EFCore.Relational/Query/Internal/RelationalProjectionBindingExpressionVisitor.cs
@@ -111,14 +111,14 @@ public virtual Expression Translate(SelectExpression selectExpression, Expressio
                     case ConstantExpression:
                         return expression;
 
+                    case QueryParameterExpression queryParameterExpression:
+                        return Expression.Call(
+                            GetParameterValueMethodInfo.MakeGenericMethod(queryParameterExpression.Type),
+                            QueryCompilationContext.QueryContextParameter,
+                            Expression.Constant(queryParameterExpression.Name));
+
                     case ParameterExpression parameterExpression:
-                        return parameterExpression.Name?.StartsWith(QueryCompilationContext.QueryParameterPrefix, StringComparison.Ordinal)
-                            == true
-                                ? Expression.Call(
-                                    GetParameterValueMethodInfo.MakeGenericMethod(parameterExpression.Type),
-                                    QueryCompilationContext.QueryContextParameter,
-                                    Expression.Constant(parameterExpression.Name))
-                                : throw new InvalidOperationException(CoreStrings.TranslationFailed(parameterExpression.Print()));
+                        throw new InvalidOperationException(CoreStrings.TranslationFailed(parameterExpression.Print()));
 
                     case ProjectionBindingExpression projectionBindingExpression:
                         return _selectExpression.GetProjection(projectionBindingExpression) switch
diff --git a/src/EFCore.Relational/Query/Internal/RelationalQueryCompilationContextFactory.cs b/src/EFCore.Relational/Query/Internal/RelationalQueryCompilationContextFactory.cs
index 3528e534c1..d2de95c9c8 100644
--- a/src/EFCore.Relational/Query/Internal/RelationalQueryCompilationContextFactory.cs
+++ b/src/EFCore.Relational/Query/Internal/RelationalQueryCompilationContextFactory.cs
@@ -53,7 +53,6 @@ public virtual QueryCompilationContext Create(bool async)
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
     [Experimental(EFDiagnostics.PrecompiledQueryExperimental)]
-    public virtual QueryCompilationContext CreatePrecompiled(bool async, IReadOnlySet<string> nonNullableReferenceTypeParameters)
-        => new RelationalQueryCompilationContext(
-            Dependencies, RelationalDependencies, async, precompiling: true, nonNullableReferenceTypeParameters);
+    public virtual QueryCompilationContext CreatePrecompiled(bool async)
+        => new RelationalQueryCompilationContext(Dependencies, RelationalDependencies, async, precompiling: true);
 }
diff --git a/src/EFCore.Relational/Query/RelationalParameterBasedSqlProcessorParameters.cs b/src/EFCore.Relational/Query/RelationalParameterBasedSqlProcessorParameters.cs
index efbe9d7416..e4e87ee1d0 100644
--- a/src/EFCore.Relational/Query/RelationalParameterBasedSqlProcessorParameters.cs
+++ b/src/EFCore.Relational/Query/RelationalParameterBasedSqlProcessorParameters.cs
@@ -13,20 +13,11 @@ public sealed record RelationalParameterBasedSqlProcessorParameters
     /// </summary>
     public bool UseRelationalNulls { get; init; }
 
-    /// <summary>
-    ///     A collection of parameter names to constantize.
-    /// </summary>
-    public IReadOnlySet<string> ParametersToConstantize { get; init; }
-
     /// <summary>
     ///     Creates a new instance of <see cref="RelationalParameterBasedSqlProcessorParameters" />.
     /// </summary>
     /// <param name="useRelationalNulls">A value indicating if relational nulls should be used.</param>
-    /// <param name="parametersToConstantize">A collection of parameter names to constantize.</param>
     [EntityFrameworkInternal]
-    public RelationalParameterBasedSqlProcessorParameters(bool useRelationalNulls, IReadOnlySet<string> parametersToConstantize)
-    {
-        UseRelationalNulls = useRelationalNulls;
-        ParametersToConstantize = parametersToConstantize;
-    }
+    public RelationalParameterBasedSqlProcessorParameters(bool useRelationalNulls)
+        => UseRelationalNulls = useRelationalNulls;
 }
diff --git a/src/EFCore.Relational/Query/RelationalQueryCompilationContext.cs b/src/EFCore.Relational/Query/RelationalQueryCompilationContext.cs
index 30fb6e152b..682a0ce30c 100644
--- a/src/EFCore.Relational/Query/RelationalQueryCompilationContext.cs
+++ b/src/EFCore.Relational/Query/RelationalQueryCompilationContext.cs
@@ -26,7 +26,7 @@ public class RelationalQueryCompilationContext : QueryCompilationContext
         QueryCompilationContextDependencies dependencies,
         RelationalQueryCompilationContextDependencies relationalDependencies,
         bool async)
-        : this(dependencies, relationalDependencies, async, precompiling: false, nonNullableReferenceTypeParameters: null)
+        : this(dependencies, relationalDependencies, async, precompiling: false)
     {
     }
 
@@ -37,15 +37,13 @@ public class RelationalQueryCompilationContext : QueryCompilationContext
     /// <param name="relationalDependencies">Parameter object containing relational dependencies for this class.</param>
     /// <param name="async">A bool value indicating whether it is for async query.</param>
     /// <param name="precompiling">Indicates whether the query is being precompiled.</param>
-    /// <param name="nonNullableReferenceTypeParameters">Names of parameters which have non-nullable reference types.</param>
     [Experimental(EFDiagnostics.PrecompiledQueryExperimental)]
     public RelationalQueryCompilationContext(
         QueryCompilationContextDependencies dependencies,
         RelationalQueryCompilationContextDependencies relationalDependencies,
         bool async,
-        bool precompiling,
-        IReadOnlySet<string>? nonNullableReferenceTypeParameters)
-        : base(dependencies, async, precompiling, nonNullableReferenceTypeParameters)
+        bool precompiling)
+        : base(dependencies, async, precompiling)
     {
         RelationalDependencies = relationalDependencies;
         QuerySplittingBehavior = RelationalOptionsExtension.Extract(ContextOptions).QuerySplittingBehavior;
diff --git a/src/EFCore.Relational/Query/RelationalQueryRootProcessor.cs b/src/EFCore.Relational/Query/RelationalQueryRootProcessor.cs
index 09f740ccab..266fab7ccd 100644
--- a/src/EFCore.Relational/Query/RelationalQueryRootProcessor.cs
+++ b/src/EFCore.Relational/Query/RelationalQueryRootProcessor.cs
@@ -33,11 +33,11 @@ protected override bool ShouldConvertToInlineQueryRoot(Expression expression)
         => true;
 
     /// <summary>
-    ///     Indicates that a <see cref="ParameterExpression" /> can be converted to a <see cref="ParameterQueryRootExpression" />;
+    ///     Indicates that a <see cref="QueryParameterExpression" /> can be converted to a <see cref="ParameterQueryRootExpression" />;
     ///     the latter will end up in <see cref="RelationalQueryableMethodTranslatingExpressionVisitor.TranslatePrimitiveCollection" /> for
     ///     translation to a provider-specific SQL expansion mechanism, e.g. <c>OPENJSON</c> on SQL Server.
     /// </summary>
-    protected override bool ShouldConvertToParameterQueryRoot(ParameterExpression parameterExpression)
+    protected override bool ShouldConvertToParameterQueryRoot(QueryParameterExpression queryParameterExpression)
         => true;
 
     /// <inheritdoc />
diff --git a/src/EFCore.Relational/Query/RelationalQueryableMethodTranslatingExpressionVisitor.ExecuteUpdate.cs b/src/EFCore.Relational/Query/RelationalQueryableMethodTranslatingExpressionVisitor.ExecuteUpdate.cs
index 5657fd6e6f..af8d612ffb 100644
--- a/src/EFCore.Relational/Query/RelationalQueryableMethodTranslatingExpressionVisitor.ExecuteUpdate.cs
+++ b/src/EFCore.Relational/Query/RelationalQueryableMethodTranslatingExpressionVisitor.ExecuteUpdate.cs
@@ -305,9 +305,7 @@ Expression Core(Expression target, IProperty property)
                                     : property.GetGetter().GetClrValue(constantExpression.Value),
                                 property.ClrType.MakeNullable());
 
-                        case SqlParameterExpression parameterExpression
-                            when parameterExpression.Name.StartsWith(
-                                QueryCompilationContext.QueryParameterPrefix, StringComparison.Ordinal):
+                        case SqlParameterExpression parameterExpression:
                         {
                             var lambda = Expression.Lambda(
                                 Expression.Call(
@@ -319,8 +317,7 @@ Expression Core(Expression target, IProperty property)
                                 QueryCompilationContext.QueryContextParameter);
 
                             var newParameterName =
-                                $"{ExecuteUpdateRuntimeParameterPrefix}"
-                                + $"{parameterExpression.Name[QueryCompilationContext.QueryParameterPrefix.Length..]}_{property.Name}";
+                                $"{ExecuteUpdateRuntimeParameterPrefix}{parameterExpression.Name[QueryCompilationContext.QueryParameterPrefix.Length..]}_{property.Name}";
 
                             return _queryCompilationContext.RegisterRuntimeParameter(newParameterName, lambda);
                         }
@@ -337,8 +334,7 @@ Expression Core(Expression target, IProperty property)
                                 QueryCompilationContext.QueryContextParameter);
 
                             var newParameterName =
-                                $"{ExecuteUpdateRuntimeParameterPrefix}"
-                                + $"{chainExpression.ParameterExpression.Name![QueryCompilationContext.QueryParameterPrefix.Length..]}_{property.Name}";
+                                $"{ExecuteUpdateRuntimeParameterPrefix}{chainExpression.ParameterExpression.Name[QueryCompilationContext.QueryParameterPrefix.Length..]}_{property.Name}";
 
                             return _queryCompilationContext.RegisterRuntimeParameter(newParameterName, lambda);
                         }
@@ -368,7 +364,6 @@ Expression Core(Expression target, IComplexProperty complexProperty)
                             complexProperty.ClrType.MakeNullable()),
 
                         SqlParameterExpression parameter
-                            when parameter.Name.StartsWith(QueryCompilationContext.QueryParameterPrefix, StringComparison.Ordinal)
                             => new ParameterBasedComplexPropertyChainExpression(parameter, complexProperty),
 
                         StructuralTypeShaperExpression
diff --git a/src/EFCore.Relational/Query/RelationalQueryableMethodTranslatingExpressionVisitor.cs b/src/EFCore.Relational/Query/RelationalQueryableMethodTranslatingExpressionVisitor.cs
index cbae0a268f..ca96957f49 100644
--- a/src/EFCore.Relational/Query/RelationalQueryableMethodTranslatingExpressionVisitor.cs
+++ b/src/EFCore.Relational/Query/RelationalQueryableMethodTranslatingExpressionVisitor.cs
@@ -240,8 +240,8 @@ protected override Expression VisitMethodCall(MethodCallExpression methodCallExp
             && method.GetGenericMethodDefinition() == QueryableMethods.Contains
             && methodCallExpression.Arguments[0] is ParameterQueryRootExpression parameterSource
             && TranslateExpression(methodCallExpression.Arguments[1]) is SqlExpression item
-            && _sqlTranslator.Visit(parameterSource.ParameterExpression) is SqlParameterExpression sqlParameterExpression
-            && !QueryCompilationContext.ParametersToNotConstantize.Contains(sqlParameterExpression.Name))
+            && _sqlTranslator.Visit(parameterSource.QueryParameterExpression) is SqlParameterExpression sqlParameterExpression
+            && !parameterSource.QueryParameterExpression.ShouldNotBeConstantized)
         {
             var inExpression = _sqlExpressionFactory.In(item, sqlParameterExpression);
             var selectExpression = new SelectExpression(inExpression, _sqlAliasManager);
@@ -288,8 +288,8 @@ JsonScalarExpression jsonScalar
     /// <inheritdoc />
     protected override ShapedQueryExpression? TranslateParameterQueryRoot(ParameterQueryRootExpression parameterQueryRootExpression)
     {
-        var sqlParameterExpression =
-            _sqlTranslator.Visit(parameterQueryRootExpression.ParameterExpression) as SqlParameterExpression;
+        var queryParameter = parameterQueryRootExpression.QueryParameterExpression;
+        var sqlParameterExpression = _sqlTranslator.Visit(queryParameter) as SqlParameterExpression;
 
         Check.DebugAssert(sqlParameterExpression is not null, "sqlParameterExpression is not null");
 
@@ -297,9 +297,9 @@ JsonScalarExpression jsonScalar
             .ParameterizedCollectionTranslationMode;
 
         var tableAlias = _sqlAliasManager.GenerateTableAlias(sqlParameterExpression.Name.TrimStart('_'));
-        if (QueryCompilationContext.ParametersToConstantize.Contains(sqlParameterExpression.Name)
+        if (queryParameter.ShouldBeConstantized
             || (primitiveCollectionsBehavior == ParameterizedCollectionTranslationMode.Constantize
-                && !QueryCompilationContext.ParametersToNotConstantize.Contains(sqlParameterExpression.Name)))
+                && !queryParameter.ShouldNotBeConstantized))
         {
             var valuesExpression = new ValuesExpression(
                 tableAlias,
diff --git a/src/EFCore.Relational/Query/RelationalShapedQueryCompilingExpressionVisitor.cs b/src/EFCore.Relational/Query/RelationalShapedQueryCompilingExpressionVisitor.cs
index 2250db9b03..ea11f3b5dd 100644
--- a/src/EFCore.Relational/Query/RelationalShapedQueryCompilingExpressionVisitor.cs
+++ b/src/EFCore.Relational/Query/RelationalShapedQueryCompilingExpressionVisitor.cs
@@ -14,7 +14,6 @@ namespace Microsoft.EntityFrameworkCore.Query;
 /// <inheritdoc />
 public partial class RelationalShapedQueryCompilingExpressionVisitor : ShapedQueryCompilingExpressionVisitor
 {
-    private readonly IReadOnlySet<string> _parametersToConstantize;
     private readonly Type _contextType;
     private readonly ISet<string> _tags;
     private readonly bool _threadSafetyChecksEnabled;
@@ -53,11 +52,9 @@ public partial class RelationalShapedQueryCompilingExpressionVisitor : ShapedQue
     {
         RelationalDependencies = relationalDependencies;
 
-        _parametersToConstantize = (IReadOnlySet<string>)QueryCompilationContext.ParametersToConstantize;
-
         _relationalParameterBasedSqlProcessor =
             relationalDependencies.RelationalParameterBasedSqlProcessorFactory.Create(
-                new RelationalParameterBasedSqlProcessorParameters(_useRelationalNulls, _parametersToConstantize));
+                new RelationalParameterBasedSqlProcessorParameters(_useRelationalNulls));
         _querySqlGeneratorFactory = relationalDependencies.QuerySqlGeneratorFactory;
 
         _contextType = queryCompilationContext.ContextType;
@@ -500,8 +497,7 @@ private Expression CreateRelationalCommandResolverExpression(Expression queryExp
             RelationalDependencies.QuerySqlGeneratorFactory,
             RelationalDependencies.RelationalParameterBasedSqlProcessorFactory,
             queryExpression,
-            _useRelationalNulls,
-            _parametersToConstantize);
+            _useRelationalNulls);
 
         var commandLiftableConstant = RelationalDependencies.RelationalLiftableConstantFactory.CreateLiftableConstant(
             relationalCommandCache,
@@ -734,10 +730,6 @@ Expression GenerateRelationalCommandExpression(IReadOnlyDictionary<string, objec
                 typeof(RelationalShapedQueryCompilingExpressionVisitorDependencies).GetProperty(
                     nameof(RelationalShapedQueryCompilingExpressionVisitorDependencies.RelationalParameterBasedSqlProcessorFactory))!;
 
-            var newHashSetExpression = New(
-                _hashSetConstructor,
-                NewArrayInit(typeof(string), _parametersToConstantize.Select(Constant)),
-                MakeMemberAccess(null, _stringComparerOrdinalProperty));
             var contextParameter = Parameter(typeof(RelationalMaterializerLiftableConstantContext), "c");
             return
                 Lambda<Func<RelationalMaterializerLiftableConstantContext, object>>(
@@ -753,8 +745,7 @@ Expression GenerateRelationalCommandExpression(IReadOnlyDictionary<string, objec
                             MakeMemberAccess(contextParameter, _relationalDependenciesProperty),
                             _relationalDependenciesRelationalParameterBasedSqlProcessorFactoryProperty),
                         Constant(queryExpression),
-                        Constant(_useRelationalNulls),
-                        newHashSetExpression),
+                        Constant(_useRelationalNulls)),
                     contextParameter);
         }
     }
diff --git a/src/EFCore.Relational/Query/RelationalSqlTranslatingExpressionVisitor.cs b/src/EFCore.Relational/Query/RelationalSqlTranslatingExpressionVisitor.cs
index be1d116516..9d26798ead 100644
--- a/src/EFCore.Relational/Query/RelationalSqlTranslatingExpressionVisitor.cs
+++ b/src/EFCore.Relational/Query/RelationalSqlTranslatingExpressionVisitor.cs
@@ -503,6 +503,22 @@ protected override Expression VisitExtension(Expression extensionExpression)
             case JsonQueryExpression:
                 return extensionExpression;
 
+            case QueryParameterExpression queryParameter:
+                // If we're precompiling a query, nullability information about reference type parameters has been extracted by the
+                // funcletizer and stored on the query compilation context; use that information when creating the SqlParameterExpression.
+                if (queryParameter.IsNonNullableReferenceType)
+                {
+                    Check.DebugAssert(
+                        _queryCompilationContext.IsPrecompiling,
+                        "Parameters can only be known to has non-nullable reference types in query precompilation.");
+                    return new SqlParameterExpression(
+                        queryParameter.Name, queryParameter.Type, nullable: false, queryParameter.ShouldBeConstantized, typeMapping: null);
+                }
+
+                return new SqlParameterExpression(
+                    queryParameter.Name, queryParameter.Type, queryParameter.Type.IsNullableType(), queryParameter.ShouldBeConstantized,
+                    typeMapping: null);
+
             case StructuralTypeShaperExpression shaper:
                 return new StructuralTypeReferenceExpression(shaper);
 
@@ -584,7 +600,7 @@ protected override Expression VisitExtension(Expression extensionExpression)
             // that we can translate queryable operators over it (query root in subquery context), but in normal SQL translation context
             // we just unwrap the query root expression to get the parameter out.
             case ParameterQueryRootExpression queryableParameterQueryRootExpression:
-                return Visit(queryableParameterQueryRootExpression.ParameterExpression);
+                return Visit(queryableParameterQueryRootExpression.QueryParameterExpression);
 
             default:
                 return QueryCompilationContext.NotTranslatedExpression;
@@ -977,24 +993,7 @@ protected override Expression VisitNewArray(NewArrayExpression newArrayExpressio
 
     /// <inheritdoc />
     protected override Expression VisitParameter(ParameterExpression parameterExpression)
-    {
-        if (parameterExpression.Name?.StartsWith(QueryCompilationContext.QueryParameterPrefix, StringComparison.Ordinal) == true)
-        {
-            // If we're precompiling a query, nullability information about reference type parameters has been extracted by the
-            // funcletizer and stored on the query compilation context; use that information when creating the SqlParameterExpression.
-            if (_queryCompilationContext.NonNullableReferenceTypeParameters.Contains(parameterExpression.Name))
-            {
-                Check.DebugAssert(
-                    _queryCompilationContext.IsPrecompiling,
-                    "Parameters can only be known to has non-nullable reference types in query precompilation.");
-                return new SqlParameterExpression(parameterExpression.Name, parameterExpression.Type, typeMapping: null, nullable: false);
-            }
-
-            return new SqlParameterExpression(parameterExpression.Name, parameterExpression.Type, typeMapping: null);
-        }
-
-        throw new InvalidOperationException(CoreStrings.TranslationFailed(parameterExpression.Print()));
-    }
+        => throw new InvalidOperationException(CoreStrings.TranslationFailed(parameterExpression.Print()));
 
     /// <inheritdoc />
     protected override Expression VisitTypeBinary(TypeBinaryExpression typeBinaryExpression)
@@ -1680,8 +1679,7 @@ private bool TryRewriteContainsEntity(Expression source, Expression item, [NotNu
                 rewrittenSource = Expression.Constant(propertyValueList);
                 break;
 
-            case SqlParameterExpression sqlParameterExpression
-                when sqlParameterExpression.Name.StartsWith(QueryCompilationContext.QueryParameterPrefix, StringComparison.Ordinal):
+            case SqlParameterExpression sqlParameterExpression:
                 var lambda = Expression.Lambda(
                     Expression.Call(
                         ParameterListValueExtractorMethod.MakeGenericMethod(entityType.ClrType, property.ClrType.MakeNullable()),
@@ -1691,8 +1689,7 @@ private bool TryRewriteContainsEntity(Expression source, Expression item, [NotNu
                     QueryCompilationContext.QueryContextParameter);
 
                 var newParameterName =
-                    $"{RuntimeParameterPrefix}"
-                    + $"{sqlParameterExpression.Name[QueryCompilationContext.QueryParameterPrefix.Length..]}_{property.Name}";
+                    $"{RuntimeParameterPrefix}{sqlParameterExpression.Name[QueryCompilationContext.QueryParameterPrefix.Length..]}_{property.Name}";
 
                 rewrittenSource = _queryCompilationContext.RegisterRuntimeParameter(newParameterName, lambda);
                 break;
@@ -1995,8 +1992,7 @@ private Expression CreatePropertyAccessExpression(Expression target, IProperty p
                         : property.GetGetter().GetClrValue(sqlConstantExpression.Value),
                     property.ClrType.MakeNullable());
 
-            case SqlParameterExpression sqlParameterExpression
-                when sqlParameterExpression.Name.StartsWith(QueryCompilationContext.QueryParameterPrefix, StringComparison.Ordinal):
+            case SqlParameterExpression sqlParameterExpression:
             {
                 var lambda = Expression.Lambda(
                     Expression.Call(
@@ -2008,8 +2004,7 @@ private Expression CreatePropertyAccessExpression(Expression target, IProperty p
                     QueryCompilationContext.QueryContextParameter);
 
                 var newParameterName =
-                    $"{RuntimeParameterPrefix}"
-                    + $"{sqlParameterExpression.Name[QueryCompilationContext.QueryParameterPrefix.Length..]}_{property.Name}";
+                    $"{RuntimeParameterPrefix}{sqlParameterExpression.Name[QueryCompilationContext.QueryParameterPrefix.Length..]}_{property.Name}";
 
                 return _queryCompilationContext.RegisterRuntimeParameter(newParameterName, lambda);
             }
@@ -2057,7 +2052,6 @@ private Expression CreateComplexPropertyAccessExpression(Expression target, ICom
                 complexProperty.ClrType.MakeNullable()),
 
             SqlParameterExpression sqlParameterExpression
-                when sqlParameterExpression.Name.StartsWith(QueryCompilationContext.QueryParameterPrefix, StringComparison.Ordinal)
                 => new ParameterBasedComplexPropertyChainExpression(sqlParameterExpression, complexProperty),
 
             MemberInitExpression memberInitExpression
diff --git a/src/EFCore.Relational/Query/SqlExpressions/FromSqlExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/FromSqlExpression.cs
index 5273cc1e65..adc7ea78e6 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/FromSqlExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/FromSqlExpression.cs
@@ -14,8 +14,8 @@ namespace Microsoft.EntityFrameworkCore.Query.SqlExpressions;
 /// </summary>
 public class FromSqlExpression : TableExpressionBase, ITableBasedExpression
 {
-    private static ConstructorInfo? _quotingConstructor;
-    private static MethodInfo? _constantExpressionFactoryMethod, _parameterExpressionFactoryMethod;
+    private static ConstructorInfo? _quotingConstructor, _queryParameterConstructor;
+    private static MethodInfo? _constantExpressionFactoryMethod;
 
     /// <summary>
     ///     Creates a new instance of the <see cref="FromSqlExpression" /> class.
@@ -130,13 +130,12 @@ Arguments switch
                         typeof(object),
                         arguments.Select(a => (Expression)Call(_constantExpressionFactoryMethod, Constant(a))).ToArray()),
 
-                ParameterExpression parameter
-                    when parameter.Type == typeof(object[])
-                    => Call(
-                        _parameterExpressionFactoryMethod ??= typeof(Expression).GetMethod(
-                            nameof(Parameter), [typeof(Type), typeof(string)])!,
-                        Constant(typeof(object[])),
-                        Constant(parameter.Name, typeof(string))),
+                QueryParameterExpression queryParameter
+                    when queryParameter.Type == typeof(object[])
+                    => New(
+                        _queryParameterConstructor ??= typeof(QueryParameterExpression).GetConstructor([typeof(string), typeof(Type)])!,
+                        Constant(queryParameter.Name, typeof(string)),
+                        Constant(typeof(object[]))),
 
                 _ => throw new UnreachableException() // TODO: Confirm
             },
diff --git a/src/EFCore.Relational/Query/SqlExpressions/SqlParameterExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/SqlParameterExpression.cs
index 7c0c58e2b8..a58c0a7648 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/SqlParameterExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/SqlParameterExpression.cs
@@ -17,7 +17,7 @@ public sealed class SqlParameterExpression : SqlExpression
     /// <param name="type">The <see cref="Type" /> of the expression.</param>
     /// <param name="typeMapping">The <see cref="RelationalTypeMapping" /> associated with the expression.</param>
     public SqlParameterExpression(string name, Type type, RelationalTypeMapping? typeMapping)
-        : this(name, type.UnwrapNullableType(), type.IsNullableType(), typeMapping)
+        : this(name, type.UnwrapNullableType(), type.IsNullableType(), shouldBeConstantized: false, typeMapping)
     {
     }
 
@@ -27,12 +27,14 @@ public SqlParameterExpression(string name, Type type, RelationalTypeMapping? typ
     /// <param name="name">The parameter name.</param>
     /// <param name="type">The <see cref="Type" /> of the expression.</param>
     /// <param name="nullable">Whether this parameter can have null values.</param>
+    /// <param name="shouldBeConstantized">Whether the user has indicated that this query parameter should be inlined as a constant.</param>
     /// <param name="typeMapping">The <see cref="RelationalTypeMapping" /> associated with the expression.</param>
-    public SqlParameterExpression(string name, Type type, bool nullable, RelationalTypeMapping? typeMapping)
+    public SqlParameterExpression(string name, Type type, bool nullable, bool shouldBeConstantized, RelationalTypeMapping? typeMapping)
         : base(type.UnwrapNullableType(), typeMapping)
     {
         Name = name;
         IsNullable = nullable;
+        ShouldBeConstantized = shouldBeConstantized;
     }
 
     /// <summary>
@@ -45,13 +47,18 @@ public SqlParameterExpression(string name, Type type, bool nullable, RelationalT
     /// </summary>
     public bool IsNullable { get; }
 
+    /// <summary>
+    ///     Whether the user has indicated that this query parameter should be inlined as a constant.
+    /// </summary>
+    public bool ShouldBeConstantized { get; }
+
     /// <summary>
     ///     Applies supplied type mapping to this expression.
     /// </summary>
     /// <param name="typeMapping">A relational type mapping to apply.</param>
     /// <returns>A new expression which has supplied type mapping.</returns>
     public SqlExpression ApplyTypeMapping(RelationalTypeMapping? typeMapping)
-        => new SqlParameterExpression(Name, Type, IsNullable, typeMapping);
+        => new SqlParameterExpression(Name, Type, IsNullable, ShouldBeConstantized, typeMapping);
 
     /// <inheritdoc />
     protected override Expression VisitChildren(ExpressionVisitor visitor)
diff --git a/src/EFCore.Relational/Query/SqlNullabilityProcessor.cs b/src/EFCore.Relational/Query/SqlNullabilityProcessor.cs
index be395e188a..a05a69773f 100644
--- a/src/EFCore.Relational/Query/SqlNullabilityProcessor.cs
+++ b/src/EFCore.Relational/Query/SqlNullabilityProcessor.cs
@@ -35,7 +35,6 @@ public class SqlNullabilityProcessor : ExpressionVisitor
     {
         Dependencies = dependencies;
         UseRelationalNulls = parameters.UseRelationalNulls;
-        ParametersToConstantize = parameters.ParametersToConstantize;
 
         _sqlExpressionFactory = dependencies.SqlExpressionFactory;
         _nonNullableColumns = [];
@@ -53,11 +52,6 @@ public class SqlNullabilityProcessor : ExpressionVisitor
     /// </summary>
     protected virtual bool UseRelationalNulls { get; }
 
-    /// <summary>
-    ///     A collection of parameter names to constantize.
-    /// </summary>
-    protected virtual IReadOnlySet<string> ParametersToConstantize { get; }
-
     /// <summary>
     ///     Dictionary of current parameter values in use.
     /// </summary>
@@ -1333,9 +1327,10 @@ SqlExpression AddNullConcatenationProtection(SqlExpression argument, RelationalT
                 sqlParameterExpression.TypeMapping);
         }
 
-        if (ParametersToConstantize.Contains(sqlParameterExpression.Name))
+        if (sqlParameterExpression.ShouldBeConstantized)
         {
             DoNotCache();
+
             return _sqlExpressionFactory.Constant(
                 parameterValue,
                 sqlParameterExpression.Type,
diff --git a/src/EFCore.SqlServer/Query/Internal/SqlServerQueryCompilationContext.cs b/src/EFCore.SqlServer/Query/Internal/SqlServerQueryCompilationContext.cs
index 1b5abdfcbe..4a9516c2f1 100644
--- a/src/EFCore.SqlServer/Query/Internal/SqlServerQueryCompilationContext.cs
+++ b/src/EFCore.SqlServer/Query/Internal/SqlServerQueryCompilationContext.cs
@@ -27,8 +27,7 @@ public class SqlServerQueryCompilationContext : RelationalQueryCompilationContex
         bool async,
         bool multipleActiveResultSetsEnabled)
         : this(
-            dependencies, relationalDependencies, async, multipleActiveResultSetsEnabled, precompiling: false,
-            nonNullableReferenceTypeParameters: null)
+            dependencies, relationalDependencies, async, multipleActiveResultSetsEnabled, precompiling: false)
         => _multipleActiveResultSetsEnabled = multipleActiveResultSetsEnabled;
 
     /// <summary>
@@ -43,9 +42,8 @@ public class SqlServerQueryCompilationContext : RelationalQueryCompilationContex
         RelationalQueryCompilationContextDependencies relationalDependencies,
         bool async,
         bool multipleActiveResultSetsEnabled,
-        bool precompiling,
-        IReadOnlySet<string>? nonNullableReferenceTypeParameters)
-        : base(dependencies, relationalDependencies, async, precompiling, nonNullableReferenceTypeParameters)
+        bool precompiling)
+        : base(dependencies, relationalDependencies, async, precompiling)
         => _multipleActiveResultSetsEnabled = multipleActiveResultSetsEnabled;
 
     /// <summary>
diff --git a/src/EFCore.SqlServer/Query/Internal/SqlServerQueryCompilationContextFactory.cs b/src/EFCore.SqlServer/Query/Internal/SqlServerQueryCompilationContextFactory.cs
index ea4b25e331..4e151d17ed 100644
--- a/src/EFCore.SqlServer/Query/Internal/SqlServerQueryCompilationContextFactory.cs
+++ b/src/EFCore.SqlServer/Query/Internal/SqlServerQueryCompilationContextFactory.cs
@@ -59,8 +59,7 @@ public virtual QueryCompilationContext Create(bool async)
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
     [Experimental(EFDiagnostics.PrecompiledQueryExperimental)]
-    public virtual QueryCompilationContext CreatePrecompiled(bool async, IReadOnlySet<string> nonNullableReferenceTypeParameters)
+    public virtual QueryCompilationContext CreatePrecompiled(bool async)
         => new SqlServerQueryCompilationContext(
-            Dependencies, RelationalDependencies, async, _sqlServerConnection.IsMultipleActiveResultSetsEnabled, precompiling: true,
-            nonNullableReferenceTypeParameters);
+            Dependencies, RelationalDependencies, async, _sqlServerConnection.IsMultipleActiveResultSetsEnabled, precompiling: true);
 }
diff --git a/src/EFCore.SqlServer/Query/Internal/SqlServerSqlTranslatingExpressionVisitor.cs b/src/EFCore.SqlServer/Query/Internal/SqlServerSqlTranslatingExpressionVisitor.cs
index 416fa2c69e..c0a7d72d43 100644
--- a/src/EFCore.SqlServer/Query/Internal/SqlServerSqlTranslatingExpressionVisitor.cs
+++ b/src/EFCore.SqlServer/Query/Internal/SqlServerSqlTranslatingExpressionVisitor.cs
@@ -312,7 +312,7 @@ methodType switch
 
                         // Azure Synapse does not support ESCAPE clause in LIKE
                         // fallback to translation like with column/expression
-                        string s when _sqlServerSingletonOptions.EngineType == SqlServerEngineType.AzureSynapse
+                        string when _sqlServerSingletonOptions.EngineType is SqlServerEngineType.AzureSynapse
                             => TranslateWithoutLike(patternIsNonEmptyConstantString: true),
 
                         string s => _sqlExpressionFactory.Like(
@@ -334,11 +334,10 @@ methodType switch
                     return true;
                 }
 
+                // Azure Synapse does not support ESCAPE clause in LIKE
+                // fall through to translation like with column/expression
                 case SqlParameterExpression patternParameter
-                    when patternParameter.Name.StartsWith(QueryCompilationContext.QueryParameterPrefix, StringComparison.Ordinal)
-                        // Azure Synapse does not support ESCAPE clause in LIKE
-                        // fall through to translation like with column/expression
-                        && _sqlServerSingletonOptions.EngineType != SqlServerEngineType.AzureSynapse:
+                    when _sqlServerSingletonOptions.EngineType is not SqlServerEngineType.AzureSynapse:
                 {
                     // The pattern is a parameter, register a runtime parameter that will contain the rewritten LIKE pattern, where
                     // all special characters have been escaped.
diff --git a/src/EFCore.Sqlite.Core/Query/Internal/SqliteQueryCompilationContext.cs b/src/EFCore.Sqlite.Core/Query/Internal/SqliteQueryCompilationContext.cs
index b369169141..a2d13ab7ca 100644
--- a/src/EFCore.Sqlite.Core/Query/Internal/SqliteQueryCompilationContext.cs
+++ b/src/EFCore.Sqlite.Core/Query/Internal/SqliteQueryCompilationContext.cs
@@ -23,7 +23,7 @@ public class SqliteQueryCompilationContext : RelationalQueryCompilationContext
         QueryCompilationContextDependencies dependencies,
         RelationalQueryCompilationContextDependencies relationalDependencies,
         bool async)
-        : this(dependencies, relationalDependencies, async, precompiling: false, nonNullableReferenceTypeParameters: null)
+        : this(dependencies, relationalDependencies, async, precompiling: false)
     {
     }
 
@@ -38,9 +38,8 @@ public class SqliteQueryCompilationContext : RelationalQueryCompilationContext
         QueryCompilationContextDependencies dependencies,
         RelationalQueryCompilationContextDependencies relationalDependencies,
         bool async,
-        bool precompiling,
-        IReadOnlySet<string>? nonNullableReferenceTypeParameters)
-        : base(dependencies, relationalDependencies, async, precompiling, nonNullableReferenceTypeParameters)
+        bool precompiling)
+        : base(dependencies, relationalDependencies, async, precompiling)
     {
     }
 
diff --git a/src/EFCore.Sqlite.Core/Query/Internal/SqliteQueryCompilationContextFactory.cs b/src/EFCore.Sqlite.Core/Query/Internal/SqliteQueryCompilationContextFactory.cs
index 9c3ceab20e..362253532d 100644
--- a/src/EFCore.Sqlite.Core/Query/Internal/SqliteQueryCompilationContextFactory.cs
+++ b/src/EFCore.Sqlite.Core/Query/Internal/SqliteQueryCompilationContextFactory.cs
@@ -52,7 +52,6 @@ public QueryCompilationContext Create(bool async)
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
     [Experimental(EFDiagnostics.PrecompiledQueryExperimental)]
-    public virtual QueryCompilationContext CreatePrecompiled(bool async, IReadOnlySet<string> nonNullableReferenceTypeParameters)
-        => new SqliteQueryCompilationContext(
-            Dependencies, RelationalDependencies, async, precompiling: true, nonNullableReferenceTypeParameters);
+    public virtual QueryCompilationContext CreatePrecompiled(bool async)
+        => new SqliteQueryCompilationContext(Dependencies, RelationalDependencies, async, precompiling: true);
 }
diff --git a/src/EFCore.Sqlite.Core/Query/Internal/SqliteSqlTranslatingExpressionVisitor.cs b/src/EFCore.Sqlite.Core/Query/Internal/SqliteSqlTranslatingExpressionVisitor.cs
index 1e46177de7..48aa49e1c2 100644
--- a/src/EFCore.Sqlite.Core/Query/Internal/SqliteSqlTranslatingExpressionVisitor.cs
+++ b/src/EFCore.Sqlite.Core/Query/Internal/SqliteSqlTranslatingExpressionVisitor.cs
@@ -322,8 +322,7 @@ protected override Expression VisitMethodCall(MethodCallExpression methodCallExp
                     return true;
                 }
 
-                case SqlParameterExpression patternParameter
-                    when patternParameter.Name.StartsWith(QueryCompilationContext.QueryParameterPrefix, StringComparison.Ordinal):
+                case SqlParameterExpression patternParameter:
                 {
                     // The pattern is a parameter, register a runtime parameter that will contain the rewritten LIKE pattern, where
                     // all special characters have been escaped.
diff --git a/src/EFCore/Query/IQueryCompilationContextFactory.cs b/src/EFCore/Query/IQueryCompilationContextFactory.cs
index 8c095016a0..83f9c5d732 100644
--- a/src/EFCore/Query/IQueryCompilationContextFactory.cs
+++ b/src/EFCore/Query/IQueryCompilationContextFactory.cs
@@ -33,9 +33,8 @@ public interface IQueryCompilationContextFactory
     ///     Creates a new <see cref="QueryCompilationContext" />.
     /// </summary>
     /// <param name="async">Specifies whether the query is async.</param>
-    /// <param name="nonNullableReferenceTypeParameters">Names of parameters which have non-nullable reference types.</param>
     /// <returns>The created query compilation context.</returns>
     [Experimental(EFDiagnostics.PrecompiledQueryExperimental)]
-    QueryCompilationContext CreatePrecompiled(bool async, IReadOnlySet<string> nonNullableReferenceTypeParameters)
+    QueryCompilationContext CreatePrecompiled(bool async)
         => throw new InvalidOperationException(CoreStrings.PrecompiledQueryNotSupported);
 }
diff --git a/src/EFCore/Query/Internal/CompiledQueryBase.cs b/src/EFCore/Query/Internal/CompiledQueryBase.cs
index 179fee35b3..a23d808b66 100644
--- a/src/EFCore/Query/Internal/CompiledQueryBase.cs
+++ b/src/EFCore/Query/Internal/CompiledQueryBase.cs
@@ -83,9 +83,7 @@ protected CompiledQueryBase(LambdaExpression queryExpression)
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    protected abstract Func<QueryContext, TResult> CreateCompiledQuery(
-        IQueryCompiler queryCompiler,
-        Expression expression);
+    protected abstract Func<QueryContext, TResult> CreateCompiledQuery(IQueryCompiler queryCompiler, Expression expression);
 
     private void EnsureExecutor(TContext context)
         => NonCapturingLazyInitializer.EnsureInitialized(
@@ -101,23 +99,14 @@ private void EnsureExecutor(TContext context)
                 return new ExecutorAndModel(t.CreateCompiledQuery(queryCompiler, expression), c.Model);
             });
 
-    private sealed class QueryExpressionRewriter(
-        TContext context,
-        IReadOnlyCollection<ParameterExpression> parameters)
-        : ExpressionVisitor
+    private sealed class QueryExpressionRewriter(TContext context, IReadOnlyCollection<ParameterExpression> parameters) : ExpressionVisitor
     {
         protected override Expression VisitParameter(ParameterExpression parameterExpression)
-        {
-            if (typeof(TContext).IsAssignableFrom(parameterExpression.Type))
-            {
-                return Expression.Constant(context);
-            }
-
-            return parameters.Contains(parameterExpression)
-                ? Expression.Parameter(
-                    parameterExpression.Type,
-                    QueryCompilationContext.QueryParameterPrefix + parameterExpression.Name)
-                : parameterExpression;
-        }
+            => typeof(TContext).IsAssignableFrom(parameterExpression.Type)
+                ? Expression.Constant(context)
+                : parameters.Contains(parameterExpression)
+                    ? new QueryParameterExpression(
+                        QueryCompilationContext.QueryParameterPrefix + parameterExpression.Name, parameterExpression.Type)
+                    : parameterExpression;
     }
 }
diff --git a/src/EFCore/Query/Internal/ExpressionTreeFuncletizer.cs b/src/EFCore/Query/Internal/ExpressionTreeFuncletizer.cs
index d301f12df1..1486ce9013 100644
--- a/src/EFCore/Query/Internal/ExpressionTreeFuncletizer.cs
+++ b/src/EFCore/Query/Internal/ExpressionTreeFuncletizer.cs
@@ -75,7 +75,7 @@ public class ExpressionTreeFuncletizer : ExpressionVisitor
     ///     A cache of tree fragments that have already been parameterized, along with their parameter. This allows us to reuse the same
     ///     query parameter twice when the same captured variable is referenced in the query.
     /// </summary>
-    private readonly Dictionary<Expression, Expression> _parameterizedValues = new(ExpressionEqualityComparer.Instance);
+    private readonly Dictionary<Expression, QueryParameterExpression> _parameterizedValues = new(ExpressionEqualityComparer.Instance);
 
     /// <summary>
     ///     Used only when evaluating arbitrary QueryRootExpressions (specifically SqlQueryRootExpression), to force any evaluatable nested
@@ -92,7 +92,6 @@ public class ExpressionTreeFuncletizer : ExpressionVisitor
     private IQueryProvider? _currentQueryProvider;
     private State _state;
     private IParameterValues _parameterValues = null!;
-    private HashSet<string>? _nonNullableReferenceTypeParameters;
 
     private readonly IModel _model;
     private readonly ContextParameterReplacer _contextParameterReplacer;
@@ -155,15 +154,7 @@ public class ExpressionTreeFuncletizer : ExpressionVisitor
         IParameterValues parameterValues,
         bool parameterize,
         bool clearParameterizedValues)
-    {
-        var result = ExtractParameters(
-            expression, parameterValues, parameterize, clearParameterizedValues, precompiledQuery: false,
-            out var nonNullableReferenceTypeParameters);
-        Check.DebugAssert(
-            nonNullableReferenceTypeParameters.Count == 0,
-            "Non-nullable reference type parameters can only be detected when precompiling.");
-        return result;
-    }
+        => ExtractParameters(expression, parameterValues, parameterize, clearParameterizedValues, precompiledQuery: false);
 
     /// <summary>
     ///     Processes an expression tree, extracting parameters and evaluating evaluatable fragments as part of the pass.
@@ -181,8 +172,7 @@ public class ExpressionTreeFuncletizer : ExpressionVisitor
         IParameterValues parameterValues,
         bool parameterize,
         bool clearParameterizedValues,
-        bool precompiledQuery,
-        out IReadOnlySet<string> nonNullableReferenceTypeParameters)
+        bool precompiledQuery)
     {
         Reset(clearParameterizedValues);
         _parameterValues = parameterValues;
@@ -200,8 +190,6 @@ public class ExpressionTreeFuncletizer : ExpressionVisitor
             root = ProcessEvaluatableRoot(root, ref state);
         }
 
-        nonNullableReferenceTypeParameters = _nonNullableReferenceTypeParameters ?? EmptyStringSet;
-
         return root;
     }
 
@@ -632,34 +620,46 @@ protected override Expression VisitDefault(DefaultExpression node)
     /// </summary>
     protected override Expression VisitExtension(Expression extension)
     {
-        if (extension is QueryRootExpression queryRoot)
+        switch (extension)
         {
-            var queryProvider = queryRoot.QueryProvider;
-            if (_currentQueryProvider == null)
+            case QueryRootExpression queryRoot:
             {
-                _currentQueryProvider = queryProvider;
-            }
-            else if (!ReferenceEquals(queryProvider, _currentQueryProvider))
-            {
-                throw new InvalidOperationException(CoreStrings.ErrorInvalidQueryable);
-            }
+                var queryProvider = queryRoot.QueryProvider;
+                if (_currentQueryProvider == null)
+                {
+                    _currentQueryProvider = queryProvider;
+                }
+                else if (!ReferenceEquals(queryProvider, _currentQueryProvider))
+                {
+                    throw new InvalidOperationException(CoreStrings.ErrorInvalidQueryable);
+                }
 
-            // Visit after detaching query provider since custom query roots can have additional components
-            extension = queryRoot.DetachQueryProvider();
+                // Visit after detaching query provider since custom query roots can have additional components
+                extension = queryRoot.DetachQueryProvider();
+
+                // The following is somewhat hacky. We're going to visit the query root's children via VisitChildren - this is primarily for
+                // FromSqlQueryRootExpression. Since the query root itself is never evaluatable, its children should all be handled as
+                // evaluatable roots - we set _evaluateRoot and do that in Visit.
+                // In addition, FromSqlQueryRootExpression's Arguments need to be a parameter rather than constant, so we set _inLambda to
+                // make that happen (quite hacky, but was done this way in the old ParameterExtractingEV as well). Think about a better way.
+                _evaluateRoot = true;
+                var parentInLambda = _inLambda;
+                _inLambda = false;
+                var visitedExtension = base.VisitExtension(extension);
+                _evaluateRoot = false;
+                _inLambda = parentInLambda;
+                _state = State.NoEvaluatability;
+                return visitedExtension;
+            }
 
-            // The following is somewhat hacky. We're going to visit the query root's children via VisitChildren - this is primarily for
-            // FromSqlQueryRootExpression. Since the query root itself is never evaluatable, its children should all be handled as
-            // evaluatable roots - we set _evaluateRoot and do that in Visit.
-            // In addition, FromSqlQueryRootExpression's Arguments need to be a parameter rather than constant, so we set _inLambda to
-            // make that happen (quite hacky, but was done this way in the old ParameterExtractingEV as well). Think about a better way.
-            _evaluateRoot = true;
-            var parentInLambda = _inLambda;
-            _inLambda = false;
-            var visitedExtension = base.VisitExtension(extension);
-            _evaluateRoot = false;
-            _inLambda = parentInLambda;
-            _state = State.NoEvaluatability;
-            return visitedExtension;
+            // In regular queries, query parameters are represented as captured variables, i.e. member accesses over a ConstantExpression
+            // referencing the closure type (see VisitConstant).
+            // However, compiled queries work differently, and their query parameters are actual ParameterExpressions that correspond to the
+            // compiled query lambda parameters. These are replaced with QueryParameterExpression in CompiledQueryBase, so we need to handle
+            // those here.
+            case QueryParameterExpression queryParameter:
+                _state = State.NoEvaluatability;
+                return queryParameter;
         }
 
         return base.VisitExtension(extension);
@@ -1875,14 +1875,14 @@ private static StateType CombineStateTypes(StateType stateType1, StateType state
 
         if (evaluateAsParameter)
         {
-            if (_parameterizedValues.TryGetValue(evaluatableRoot, out var cachedParameter))
+            if (_parameterizedValues.TryGetValue(evaluatableRoot, out var cachedQueryParameter))
             {
                 // We're here when the same captured variable (or other fragment) is referenced more than once in the query; we want to
                 // use the same query parameter rather than sending it twice.
                 // Note that in path calculation (precompiled query), we don't have to do anything, as the path only needs to be returned
                 // once.
                 state = State.NoEvaluatability;
-                return cachedParameter;
+                return cachedQueryParameter;
             }
 
             if (_calculatingPath)
@@ -1911,17 +1911,19 @@ private static StateType CombineStateTypes(StateType stateType1, StateType state
             // TODO: This currently only knows about the NRT status of a directly captured variable, but not the NRT status of any
             // TODO: larger expression composed on top of a captured variable (e.g. Where(b => b.Name == foo + "Bla"))
             // TODO: This would require bubbling nullability information up the tree via State.
-            if (_precompiledQuery
+            var isNonNullableReferenceType =
+                _precompiledQuery
                 && !evaluatableRoot.Type.IsValueType
-                && evaluatableRoot is MemberExpression { Member: IParameterNullabilityInfo { IsNonNullableReferenceType: true } })
-            {
-                _nonNullableReferenceTypeParameters ??= [];
-                _nonNullableReferenceTypeParameters.Add(parameterName);
-            }
+                && evaluatableRoot is MemberExpression { Member: IParameterNullabilityInfo { IsNonNullableReferenceType: true } };
 
             _parameterValues.AddParameter(parameterName, value);
 
-            return _parameterizedValues[evaluatableRoot] = Parameter(evaluatableRoot.Type, parameterName);
+            return _parameterizedValues[evaluatableRoot] = new QueryParameterExpression(
+                parameterName,
+                evaluatableRoot.Type,
+                shouldBeConstantized: false,
+                shouldNotBeConstantized: false,
+                isNonNullableReferenceType);
         }
 
         // Evaluate as constant
diff --git a/src/EFCore/Query/Internal/NavigationExpandingExpressionVisitor.cs b/src/EFCore/Query/Internal/NavigationExpandingExpressionVisitor.cs
index f7e8de8764..829ccec8d1 100644
--- a/src/EFCore/Query/Internal/NavigationExpandingExpressionVisitor.cs
+++ b/src/EFCore/Query/Internal/NavigationExpandingExpressionVisitor.cs
@@ -212,7 +212,7 @@ protected override Expression VisitExtension(Expression extensionExpression)
                     // TODO: filter into the QueryCompilationContext.NonNullableReferenceTypeParameters
                     var processedDefiningQueryBody = _funcletizer.ExtractParameters(
                         definingQuery.Body, _parameters, parameterize: false, clearParameterizedValues: false,
-                        _queryCompilationContext.IsPrecompiling, out var nonNullableReferenceTypeParameters);
+                        _queryCompilationContext.IsPrecompiling);
                     processedDefiningQueryBody = _queryTranslationPreprocessor.NormalizeQueryableMethod(processedDefiningQueryBody);
                     processedDefiningQueryBody = _nullCheckRemovingExpressionVisitor.Visit(processedDefiningQueryBody);
                     processedDefiningQueryBody =
@@ -1766,7 +1766,7 @@ private Expression ApplyQueryFilter(IEntityType entityType, NavigationExpansionE
                     // TODO: filter into the QueryCompilationContext.NonNullableReferenceTypeParameters
                     filterPredicate = (LambdaExpression)_funcletizer.ExtractParameters(
                         filterPredicate, _parameters, parameterize: false, clearParameterizedValues: false,
-                        _queryCompilationContext.IsPrecompiling, out var nonNullableReferenceTypeParameters);
+                        _queryCompilationContext.IsPrecompiling);
                     filterPredicate = (LambdaExpression)_queryTranslationPreprocessor.NormalizeQueryableMethod(filterPredicate);
 
                     // We need to do entity equality, but that requires a full method call on a query root to properly flow the
diff --git a/src/EFCore/Query/Internal/QueryCompilationContextFactory.cs b/src/EFCore/Query/Internal/QueryCompilationContextFactory.cs
index 8a2670c0c0..b11e67319a 100644
--- a/src/EFCore/Query/Internal/QueryCompilationContextFactory.cs
+++ b/src/EFCore/Query/Internal/QueryCompilationContextFactory.cs
@@ -43,6 +43,6 @@ public virtual QueryCompilationContext Create(bool async)
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
     [Experimental(EFDiagnostics.PrecompiledQueryExperimental)]
-    public virtual QueryCompilationContext CreatePrecompiled(bool async, IReadOnlySet<string> nonNullableReferenceTypeParameters)
-        => new(Dependencies, async, precompiling: true, nonNullableReferenceTypeParameters);
+    public virtual QueryCompilationContext CreatePrecompiled(bool async)
+        => new(Dependencies, async, precompiling: true);
 }
diff --git a/src/EFCore/Query/Internal/QueryCompiler.cs b/src/EFCore/Query/Internal/QueryCompiler.cs
index 724990671f..950c7bebde 100644
--- a/src/EFCore/Query/Internal/QueryCompiler.cs
+++ b/src/EFCore/Query/Internal/QueryCompiler.cs
@@ -137,10 +137,9 @@ var compiledQuery
     {
         query = new ExpressionTreeFuncletizer(_model, _evaluatableExpressionFilter, _contextType, generateContextAccessors: false, _logger)
             .ExtractParameters(
-                query, _queryContextFactory.Create(), parameterize: true, clearParameterizedValues: true, precompiledQuery: true,
-                out var nonNullableReferenceTypeParameters);
+                query, _queryContextFactory.Create(), parameterize: true, clearParameterizedValues: true, precompiledQuery: true);
 
-        return _database.CompileQueryExpression<TResult>(query, async, nonNullableReferenceTypeParameters);
+        return _database.CompileQueryExpression<TResult>(query, async);
     }
 
     /// <summary>
diff --git a/src/EFCore/Query/Internal/QueryableMethodNormalizingExpressionVisitor.cs b/src/EFCore/Query/Internal/QueryableMethodNormalizingExpressionVisitor.cs
index aae8897fda..4e272125cd 100644
--- a/src/EFCore/Query/Internal/QueryableMethodNormalizingExpressionVisitor.cs
+++ b/src/EFCore/Query/Internal/QueryableMethodNormalizingExpressionVisitor.cs
@@ -124,16 +124,18 @@ protected override Expression VisitMethodCall(MethodCallExpression methodCallExp
                         throw new InvalidOperationException(CoreStrings.EFConstantNotSupported);
                     }
 
-                    var parameterExpression = (ParameterExpression)Visit(methodCallExpression.Arguments[0]);
-                    _queryCompilationContext.ParametersToConstantize.Add(parameterExpression.Name!);
-                    return parameterExpression;
+                    var queryParameter = (QueryParameterExpression)Visit(methodCallExpression.Arguments[0]);
+                    return new QueryParameterExpression(
+                        queryParameter.Name, queryParameter.Type, shouldBeConstantized: true, shouldNotBeConstantized: false,
+                        queryParameter.IsNonNullableReferenceType);
                 }
 
                 case nameof(EF.Parameter):
                 {
-                    var parameterExpression = (ParameterExpression)Visit(methodCallExpression.Arguments[0]);
-                    _queryCompilationContext.ParametersToNotConstantize.Add(parameterExpression.Name!);
-                    return parameterExpression;
+                    var queryParameter = (QueryParameterExpression)Visit(methodCallExpression.Arguments[0]);
+                    return new QueryParameterExpression(
+                        queryParameter.Name, queryParameter.Type, shouldBeConstantized: false, shouldNotBeConstantized: true,
+                        queryParameter.IsNonNullableReferenceType);
                 }
             }
         }
@@ -936,8 +938,7 @@ protected override Expression VisitMethodCall(MethodCallExpression methodCallExp
 
         protected override Expression VisitParameter(ParameterExpression parameterExpression)
         {
-            if (_allowedParameters.Contains(parameterExpression)
-                || parameterExpression.Name?.StartsWith(QueryCompilationContext.QueryParameterPrefix, StringComparison.Ordinal) == true)
+            if (_allowedParameters.Contains(parameterExpression))
             {
                 return parameterExpression;
             }
@@ -953,5 +954,8 @@ protected override Expression VisitParameter(ParameterExpression parameterExpres
 
             return base.VisitParameter(parameterExpression);
         }
+
+        protected override Expression VisitExtension(Expression node)
+            => node is QueryParameterExpression ? node : base.VisitExtension(node);
     }
 }
diff --git a/src/EFCore/Query/ParameterQueryRootExpression.cs b/src/EFCore/Query/ParameterQueryRootExpression.cs
index ffb2ad27ca..3d7c4454c3 100644
--- a/src/EFCore/Query/ParameterQueryRootExpression.cs
+++ b/src/EFCore/Query/ParameterQueryRootExpression.cs
@@ -15,47 +15,47 @@ namespace Microsoft.EntityFrameworkCore.Query;
 public class ParameterQueryRootExpression : QueryRootExpression
 {
     /// <summary>
-    ///     The parameter expression representing the values for this query root.
+    ///     The query parameter expression representing the values for this query root.
     /// </summary>
-    public virtual ParameterExpression ParameterExpression { get; }
+    public virtual QueryParameterExpression QueryParameterExpression { get; }
 
     /// <summary>
     ///     Creates a new instance of the <see cref="ParameterQueryRootExpression" /> class.
     /// </summary>
     /// <param name="asyncQueryProvider">The query provider associated with this query root.</param>
     /// <param name="elementType">The values that this query root represents.</param>
-    /// <param name="parameterExpression">The parameter expression representing the values for this query root.</param>
+    /// <param name="queryParameterExpression">The parameter expression representing the values for this query root.</param>
     public ParameterQueryRootExpression(
         IAsyncQueryProvider asyncQueryProvider,
         Type elementType,
-        ParameterExpression parameterExpression)
+        QueryParameterExpression queryParameterExpression)
         : base(asyncQueryProvider, elementType)
-        => ParameterExpression = parameterExpression;
+        => QueryParameterExpression = queryParameterExpression;
 
     /// <summary>
     ///     Creates a new instance of the <see cref="ParameterQueryRootExpression" /> class.
     /// </summary>
     /// <param name="elementType">The values that this query root represents.</param>
-    /// <param name="parameterExpression">The parameter expression representing the values for this query root.</param>
-    public ParameterQueryRootExpression(Type elementType, ParameterExpression parameterExpression)
+    /// <param name="queryParameterExpression">The query parameter expression representing the values for this query root.</param>
+    public ParameterQueryRootExpression(Type elementType, QueryParameterExpression queryParameterExpression)
         : base(elementType)
-        => ParameterExpression = parameterExpression;
+        => QueryParameterExpression = queryParameterExpression;
 
     /// <inheritdoc />
     public override Expression DetachQueryProvider()
-        => new ParameterQueryRootExpression(ElementType, ParameterExpression);
+        => new ParameterQueryRootExpression(ElementType, QueryParameterExpression);
 
     /// <inheritdoc />
     protected override Expression VisitChildren(ExpressionVisitor visitor)
     {
-        var parameterExpression = (ParameterExpression)visitor.Visit(ParameterExpression);
+        var queryParameter = (QueryParameterExpression)visitor.Visit(QueryParameterExpression);
 
-        return parameterExpression == ParameterExpression
+        return queryParameter == QueryParameterExpression
             ? this
-            : new ParameterQueryRootExpression(ElementType, parameterExpression);
+            : new ParameterQueryRootExpression(ElementType, queryParameter);
     }
 
     /// <inheritdoc />
     protected override void Print(ExpressionPrinter expressionPrinter)
-        => expressionPrinter.Visit(ParameterExpression);
+        => expressionPrinter.Visit(QueryParameterExpression);
 }
diff --git a/src/EFCore/Query/QueryCompilationContext.cs b/src/EFCore/Query/QueryCompilationContext.cs
index 651cefa134..6349e740b9 100644
--- a/src/EFCore/Query/QueryCompilationContext.cs
+++ b/src/EFCore/Query/QueryCompilationContext.cs
@@ -53,31 +53,6 @@ public class QueryCompilationContext
     /// </summary>
     public static readonly Expression NotTranslatedExpression = new NotTranslatedExpressionType();
 
-    /// <summary>
-    ///     <para>
-    ///         Names of parameters on which <see cref="EF.Constant{T}" /> was used. Such parameters are later transformed into constants.
-    ///     </para>
-    ///     <para>
-    ///         This property is typically used by database providers (and other extensions). It is generally
-    ///         not used in application code.
-    ///     </para>
-    /// </summary>
-    public virtual ISet<string> ParametersToConstantize { get; } = new HashSet<string>(StringComparer.Ordinal);
-
-    /// <summary>
-    ///     <para>
-    ///         Names of parameters on which <see cref="EF.Parameter{T}" /> was used. Such parameters are later not transformed into
-    ///         constants even when parameterized collection constantization is configured as the default.
-    ///     </para>
-    ///     <para>
-    ///         This property is typically used by database providers (and other extensions). It is generally
-    ///         not used in application code.
-    ///     </para>
-    /// </summary>
-    public virtual ISet<string> ParametersToNotConstantize { get; } = new HashSet<string>(StringComparer.Ordinal);
-
-    private static readonly IReadOnlySet<string> EmptySet = new HashSet<string>();
-
     private readonly IQueryTranslationPreprocessorFactory _queryTranslationPreprocessorFactory;
     private readonly IQueryableMethodTranslatingExpressionVisitorFactory _queryableMethodTranslatingExpressionVisitorFactory;
     private readonly IQueryTranslationPostprocessorFactory _queryTranslationPostprocessorFactory;
@@ -93,10 +68,8 @@ public class QueryCompilationContext
     /// </summary>
     /// <param name="dependencies">Parameter object containing dependencies for this class.</param>
     /// <param name="async">A bool value indicating whether it is for async query.</param>
-    public QueryCompilationContext(
-        QueryCompilationContextDependencies dependencies,
-        bool async)
-        : this(dependencies, async, precompiling: false, nonNullableReferenceTypeParameters: null)
+    public QueryCompilationContext(QueryCompilationContextDependencies dependencies, bool async)
+        : this(dependencies, async, precompiling: false)
     {
     }
 
@@ -106,13 +79,8 @@ public class QueryCompilationContext
     /// <param name="dependencies">Parameter object containing dependencies for this class.</param>
     /// <param name="async">A bool value indicating whether it is for async query.</param>
     /// <param name="precompiling">Indicates whether the query is being precompiled.</param>
-    /// <param name="nonNullableReferenceTypeParameters">Names of parameters which have non-nullable reference types.</param>
     [Experimental(EFDiagnostics.PrecompiledQueryExperimental)]
-    public QueryCompilationContext(
-        QueryCompilationContextDependencies dependencies,
-        bool async,
-        bool precompiling,
-        IReadOnlySet<string>? nonNullableReferenceTypeParameters)
+    public QueryCompilationContext(QueryCompilationContextDependencies dependencies, bool async, bool precompiling)
     {
         Dependencies = dependencies;
         IsAsync = async;
@@ -123,7 +91,6 @@ public class QueryCompilationContext
         ContextOptions = dependencies.ContextOptions;
         ContextType = dependencies.ContextType;
         Logger = dependencies.Logger;
-        NonNullableReferenceTypeParameters = nonNullableReferenceTypeParameters ?? EmptySet;
 
         _queryTranslationPreprocessorFactory = dependencies.QueryTranslationPreprocessorFactory;
         _queryableMethodTranslatingExpressionVisitorFactory = dependencies.QueryableMethodTranslatingExpressionVisitorFactory;
@@ -192,12 +159,6 @@ public class QueryCompilationContext
     /// </summary>
     public virtual Type ContextType { get; }
 
-    /// <summary>
-    ///     Names of parameters which have non-nullable reference types.
-    /// </summary>
-    [Experimental(EFDiagnostics.PrecompiledQueryExperimental)]
-    public virtual IReadOnlySet<string> NonNullableReferenceTypeParameters { get; }
-
     /// <summary>
     ///     Adds a tag to <see cref="Tags" />.
     /// </summary>
@@ -273,7 +234,7 @@ public virtual bool SupportsPrecompiledQuery
     ///     A lambda must be provided, which will extract the parameter's value from the QueryContext every time
     ///     the query is executed.
     /// </summary>
-    public virtual ParameterExpression RegisterRuntimeParameter(string name, LambdaExpression valueExtractor)
+    public virtual QueryParameterExpression RegisterRuntimeParameter(string name, LambdaExpression valueExtractor)
     {
         var valueExtractorBody = valueExtractor.Body;
         if (SupportsPrecompiledQuery)
@@ -292,7 +253,7 @@ public virtual ParameterExpression RegisterRuntimeParameter(string name, LambdaE
         _runtimeParameters ??= new Dictionary<string, LambdaExpression>();
 
         _runtimeParameters[name] = valueExtractor;
-        return Expression.Parameter(valueExtractor.ReturnType, name);
+        return new QueryParameterExpression(name, valueExtractor.ReturnType);
     }
 
     private Expression InsertRuntimeParameters(Expression query)
diff --git a/src/EFCore/Query/QueryParameterExpression.cs b/src/EFCore/Query/QueryParameterExpression.cs
new file mode 100644
index 0000000000..39dfb95431
--- /dev/null
+++ b/src/EFCore/Query/QueryParameterExpression.cs
@@ -0,0 +1,103 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Diagnostics.CodeAnalysis;
+using Microsoft.EntityFrameworkCore.Query.Internal;
+
+namespace Microsoft.EntityFrameworkCore.Query;
+
+/// <summary>
+///     Represents a parameter external to the query, which may have different values across different executions of the same query.
+///     This is created by <see cref="ExpressionTreeFuncletizer" /> for closure captured variables, and in relational, is translated to
+///     <c>SqlParameterExpression</c>
+/// </summary>
+public class QueryParameterExpression : Expression, IPrintableExpression
+{
+    /// <summary>
+    ///     Creates a new instance of the <see cref="QueryRootExpression" /> class with associated query provider.
+    /// </summary>
+    public QueryParameterExpression(string name, Type type)
+        : this(name, type, shouldBeConstantized: false, shouldNotBeConstantized: false, isNonNullableReferenceType: false)
+    {
+    }
+
+    /// <summary>
+    ///     Creates a new instance of the <see cref="QueryRootExpression" /> class with associated query provider.
+    /// </summary>
+    public QueryParameterExpression(string name, Type type, bool shouldBeConstantized, bool shouldNotBeConstantized)
+        : this(name, type, shouldBeConstantized, shouldNotBeConstantized, isNonNullableReferenceType: false)
+    {
+    }
+
+    /// <summary>
+    ///     Creates a new instance of the <see cref="QueryRootExpression" /> class with associated query provider.
+    /// </summary>
+    [Experimental(EFDiagnostics.PrecompiledQueryExperimental)]
+    public QueryParameterExpression(string name, Type type, bool shouldBeConstantized, bool shouldNotBeConstantized, bool isNonNullableReferenceType)
+    {
+        Name = name;
+        Type = type;
+        ShouldBeConstantized = shouldBeConstantized;
+        ShouldNotBeConstantized = shouldNotBeConstantized;
+        IsNonNullableReferenceType = isNonNullableReferenceType;
+    }
+
+    /// <summary>
+    ///     The name of the query parameter.
+    /// </summary>
+    public virtual string Name { get; }
+
+    /// <summary>
+    ///     The static type of the expression that this <see cref="Expression" /> represents.
+    /// </summary>
+    public override Type Type { get; }
+
+    // TODO: Naming. Also consider changing inline/not-inline to a three-value enum
+
+    /// <summary>
+    ///     Whether this query parameter's type is a non-nullable reference type.
+    /// </summary>
+    [Experimental(EFDiagnostics.PrecompiledQueryExperimental)]
+    public virtual bool IsNonNullableReferenceType { get; }
+
+    /// <summary>
+    ///     Whether the user has indicated that this query parameter should be inlined as a constant.
+    /// </summary>
+    public virtual bool ShouldBeConstantized { get; }
+
+    /// <summary>
+    ///     Whether the user has indicated that this query parameter shouldn't be inlined as a constant.
+    /// </summary>
+    public virtual bool ShouldNotBeConstantized { get; }
+
+    /// <inheritdoc />
+    public override ExpressionType NodeType
+        => ExpressionType.Extension;
+
+    /// <inheritdoc />
+    protected override Expression VisitChildren(ExpressionVisitor visitor)
+        => this;
+
+    /// <inheritdoc />
+    public void Print(ExpressionPrinter expressionPrinter)
+        // => expressionPrinter.Append("@").Append(Name);
+        => expressionPrinter.Append(Name);
+
+    /// <inheritdoc />
+    public override bool Equals(object? obj)
+        => obj != null
+            && (ReferenceEquals(this, obj)
+                || obj is QueryParameterExpression queryParameterExpression
+                && Equals(queryParameterExpression));
+
+    private bool Equals(QueryParameterExpression queryParameterExpression)
+        => Name == queryParameterExpression.Name
+            && Type == queryParameterExpression.Type
+            && ShouldBeConstantized == queryParameterExpression.ShouldBeConstantized
+            && ShouldNotBeConstantized == queryParameterExpression.ShouldNotBeConstantized
+            && IsNonNullableReferenceType == queryParameterExpression.IsNonNullableReferenceType;
+
+    /// <inheritdoc />
+    public override int GetHashCode()
+        => HashCode.Combine(Name, Type, ShouldBeConstantized, ShouldNotBeConstantized, IsNonNullableReferenceType);
+}
diff --git a/src/EFCore/Query/QueryRootProcessor.cs b/src/EFCore/Query/QueryRootProcessor.cs
index ec87a57f35..34a645d35c 100644
--- a/src/EFCore/Query/QueryRootProcessor.cs
+++ b/src/EFCore/Query/QueryRootProcessor.cs
@@ -103,21 +103,17 @@ private Expression VisitQueryRootCandidate(Expression expression, Type elementCl
 
                 goto default;
 
-            case NewArrayExpression newArrayExpression
-                when ShouldConvertToInlineQueryRoot(newArrayExpression):
-                return new InlineQueryRootExpression(newArrayExpression.Expressions, elementClrType);
-
-            case ParameterExpression parameterExpression
-                when parameterExpression.Name?.StartsWith(QueryCompilationContext.QueryParameterPrefix, StringComparison.Ordinal)
-                == true
-                && ShouldConvertToParameterQueryRoot(parameterExpression):
-                return new ParameterQueryRootExpression(parameterExpression.Type.GetSequenceType(), parameterExpression);
-
-            case ListInitExpression listInitExpression
-                when listInitExpression.Type.TryGetElementType(typeof(IList<>)) is not null
-                && listInitExpression.Initializers.All(x => x.Arguments.Count == 1)
-                && ShouldConvertToInlineQueryRoot(listInitExpression):
-                return new InlineQueryRootExpression(listInitExpression.Initializers.Select(x => x.Arguments[0]).ToList(), elementClrType);
+            case NewArrayExpression newArray when ShouldConvertToInlineQueryRoot(newArray):
+                return new InlineQueryRootExpression(newArray.Expressions, elementClrType);
+
+            case QueryParameterExpression queryParameter when ShouldConvertToParameterQueryRoot(queryParameter):
+                return new ParameterQueryRootExpression(queryParameter.Type.GetSequenceType(), queryParameter);
+
+            case ListInitExpression listInit
+                when listInit.Type.TryGetElementType(typeof(IList<>)) is not null
+                && listInit.Initializers.All(x => x.Arguments.Count == 1)
+                && ShouldConvertToInlineQueryRoot(listInit):
+                return new InlineQueryRootExpression(listInit.Initializers.Select(x => x.Arguments[0]).ToList(), elementClrType);
 
             default:
                 return Visit(expression);
@@ -132,9 +128,10 @@ protected virtual bool ShouldConvertToInlineQueryRoot(Expression expression)
         => false;
 
     /// <summary>
-    ///     Determines whether a <see cref="ParameterExpression" /> should be converted to a <see cref="ParameterQueryRootExpression" />.
+    ///     Determines whether a <see cref="QueryParameterExpression" /> should be converted to a
+    ///     <see cref="ParameterQueryRootExpression" />.
     /// </summary>
-    /// <param name="parameterExpression">The parameter expression that's a candidate for conversion to a query root.</param>
-    protected virtual bool ShouldConvertToParameterQueryRoot(ParameterExpression parameterExpression)
+    /// <param name="queryParameterExpression">The query parameter expression that's a candidate for conversion to a query root.</param>
+    protected virtual bool ShouldConvertToParameterQueryRoot(QueryParameterExpression queryParameterExpression)
         => false;
 }
diff --git a/src/EFCore/Storage/Database.cs b/src/EFCore/Storage/Database.cs
index 6941247ec3..ebdcd0b891 100644
--- a/src/EFCore/Storage/Database.cs
+++ b/src/EFCore/Storage/Database.cs
@@ -69,11 +69,8 @@ protected Database(DatabaseDependencies dependencies)
 
     /// <inheritdoc />
     [Experimental(EFDiagnostics.PrecompiledQueryExperimental)]
-    public virtual Expression<Func<QueryContext, TResult>> CompileQueryExpression<TResult>(
-        Expression query,
-        bool async,
-        IReadOnlySet<string> nonNullableReferenceTypeParameters)
+    public virtual Expression<Func<QueryContext, TResult>> CompileQueryExpression<TResult>(Expression query, bool async)
         => Dependencies.QueryCompilationContextFactory
-            .CreatePrecompiled(async, nonNullableReferenceTypeParameters)
+            .CreatePrecompiled(async)
             .CreateQueryExecutorExpression<TResult>(query);
 }
diff --git a/src/EFCore/Storage/IDatabase.cs b/src/EFCore/Storage/IDatabase.cs
index ce0c1d974a..69ee1952b1 100644
--- a/src/EFCore/Storage/IDatabase.cs
+++ b/src/EFCore/Storage/IDatabase.cs
@@ -63,12 +63,8 @@ public interface IDatabase
     /// </summary>
     /// <typeparam name="TResult">The type of query result.</typeparam>
     /// <param name="query">The query to compile.</param>
-    /// <param name="nonNullableReferenceTypeParameters">Names of parameters which have non-nullable reference types..</param>
     /// <param name="async">A value indicating whether this is an async query.</param>
     /// <returns>An expression tree which can be used to execute the query.</returns>
     [Experimental(EFDiagnostics.PrecompiledQueryExperimental)]
-    Expression<Func<QueryContext, TResult>> CompileQueryExpression<TResult>(
-        Expression query,
-        bool async,
-        IReadOnlySet<string> nonNullableReferenceTypeParameters);
+    Expression<Func<QueryContext, TResult>> CompileQueryExpression<TResult>(Expression query, bool async);
 }
