diff --git a/src/EFCore.SqlServer/DataCompressionType.cs b/src/EFCore.SqlServer/DataCompressionType.cs
new file mode 100644
index 0000000000..058f8f0567
--- /dev/null
+++ b/src/EFCore.SqlServer/DataCompressionType.cs
@@ -0,0 +1,29 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+// ReSharper disable once CheckNamespace
+namespace Microsoft.EntityFrameworkCore;
+
+/// <summary>
+///     Indicates type of data compression used on a index.
+/// </summary>
+/// <remarks>
+///     See <see href="https://docs.microsoft.com/sql/relational-databases/data-compression">Data Compression</see> for more information on data compression.
+/// </remarks>
+public enum DataCompressionType
+{
+    /// <summary>
+    ///     Index is not compressed.
+    /// </summary>
+    None,
+
+    /// <summary>
+    ///     Index is compressed by using row compression.
+    /// </summary>
+    Row,
+
+    /// <summary>
+    ///     Index is compressed by using page compression.
+    /// </summary>
+    Page
+}
diff --git a/src/EFCore.SqlServer/Design/Internal/SqlServerAnnotationCodeGenerator.cs b/src/EFCore.SqlServer/Design/Internal/SqlServerAnnotationCodeGenerator.cs
index bb46a3e6be..a1b3180f38 100644
--- a/src/EFCore.SqlServer/Design/Internal/SqlServerAnnotationCodeGenerator.cs
+++ b/src/EFCore.SqlServer/Design/Internal/SqlServerAnnotationCodeGenerator.cs
@@ -79,6 +79,14 @@ public class SqlServerAnnotationCodeGenerator : AnnotationCodeGenerator
         = typeof(SqlServerIndexBuilderExtensions).GetRuntimeMethod(
             nameof(SqlServerIndexBuilderExtensions.HasFillFactor), new[] { typeof(IndexBuilder), typeof(int) })!;
 
+    private static readonly MethodInfo IndexIsSortedInTempDbInfo
+    = typeof(SqlServerIndexBuilderExtensions).GetRuntimeMethod(
+        nameof(SqlServerIndexBuilderExtensions.IsSortedInTempDb), new[] { typeof(IndexBuilder), typeof(bool) })!;
+
+    private static readonly MethodInfo IndexUseDataCompressionInfo
+    = typeof(SqlServerIndexBuilderExtensions).GetRuntimeMethod(
+        nameof(SqlServerIndexBuilderExtensions.UseDataCompression), new[] { typeof(IndexBuilder), typeof(DataCompressionType) })!;
+
     private static readonly MethodInfo KeyIsClusteredMethodInfo
         = typeof(SqlServerKeyBuilderExtensions).GetRuntimeMethod(
             nameof(SqlServerKeyBuilderExtensions.IsClustered), new[] { typeof(KeyBuilder), typeof(bool) })!;
@@ -341,6 +349,8 @@ protected override bool IsHandledByConvention(IProperty property, IAnnotation an
 
             SqlServerAnnotationNames.Include => new MethodCallCodeFragment(IndexIncludePropertiesMethodInfo, annotation.Value),
             SqlServerAnnotationNames.FillFactor => new MethodCallCodeFragment(IndexHasFillFactorMethodInfo, annotation.Value),
+            SqlServerAnnotationNames.SortedInTempDb => new MethodCallCodeFragment(IndexIsSortedInTempDbInfo, annotation.Value),
+            SqlServerAnnotationNames.DataCompression => new MethodCallCodeFragment(IndexUseDataCompressionInfo, annotation.Value),
 
             _ => null
         };
diff --git a/src/EFCore.SqlServer/Design/Internal/SqlServerCSharpRuntimeAnnotationCodeGenerator.cs b/src/EFCore.SqlServer/Design/Internal/SqlServerCSharpRuntimeAnnotationCodeGenerator.cs
index 793eb75ca0..7b1b13d36d 100644
--- a/src/EFCore.SqlServer/Design/Internal/SqlServerCSharpRuntimeAnnotationCodeGenerator.cs
+++ b/src/EFCore.SqlServer/Design/Internal/SqlServerCSharpRuntimeAnnotationCodeGenerator.cs
@@ -104,6 +104,8 @@ public override void Generate(IIndex index, CSharpRuntimeAnnotationCodeGenerator
             annotations.Remove(SqlServerAnnotationNames.CreatedOnline);
             annotations.Remove(SqlServerAnnotationNames.Include);
             annotations.Remove(SqlServerAnnotationNames.FillFactor);
+            annotations.Remove(SqlServerAnnotationNames.SortedInTempDb);
+            annotations.Remove(SqlServerAnnotationNames.DataCompression);
         }
 
         base.Generate(index, parameters);
@@ -119,6 +121,8 @@ public override void Generate(ITableIndex index, CSharpRuntimeAnnotationCodeGene
             annotations.Remove(SqlServerAnnotationNames.CreatedOnline);
             annotations.Remove(SqlServerAnnotationNames.Include);
             annotations.Remove(SqlServerAnnotationNames.FillFactor);
+            annotations.Remove(SqlServerAnnotationNames.SortedInTempDb);
+            annotations.Remove(SqlServerAnnotationNames.DataCompression);
         }
 
         base.Generate(index, parameters);
diff --git a/src/EFCore.SqlServer/Extensions/SqlServerIndexBuilderExtensions.cs b/src/EFCore.SqlServer/Extensions/SqlServerIndexBuilderExtensions.cs
index d0ef0e1922..c5030dc497 100644
--- a/src/EFCore.SqlServer/Extensions/SqlServerIndexBuilderExtensions.cs
+++ b/src/EFCore.SqlServer/Extensions/SqlServerIndexBuilderExtensions.cs
@@ -391,4 +391,176 @@ public static IndexBuilder HasFillFactor(this IndexBuilder indexBuilder, int fil
         int? fillFactor,
         bool fromDataAnnotation = false)
         => indexBuilder.CanSetAnnotation(SqlServerAnnotationNames.FillFactor, fillFactor, fromDataAnnotation);
+
+    /// <summary>
+    ///     Configures whether the index is created with sort in tempdb option when targeting SQL Server.
+    /// </summary>
+    /// <remarks>
+    ///     See <see href="https://aka.ms/efcore-docs-modeling">Modeling entity types and relationships</see>, and
+    ///     <see href="https://aka.ms/efcore-docs-sqlserver">Accessing SQL Server and SQL Azure databases with EF Core</see>
+    ///     for more information and examples.
+    /// </remarks>
+    /// <param name="indexBuilder">The builder for the index being configured.</param>
+    /// <param name="sortedInTempDb">A value indicating whether the index is created with sort in tempdb option.</param>
+    /// <returns>A builder to further configure the index.</returns>
+    public static IndexBuilder IsSortedInTempDb(this IndexBuilder indexBuilder, bool sortedInTempDb = true)
+    {
+        indexBuilder.Metadata.SetIsSortedInTempDb(sortedInTempDb);
+
+        return indexBuilder;
+    }
+
+    /// <summary>
+    ///     Configures whether the index is created with sort in tempdb option when targeting SQL Server.
+    /// </summary>
+    /// <remarks>
+    ///     See <see href="https://aka.ms/efcore-docs-modeling">Modeling entity types and relationships</see>, and
+    ///     <see href="https://aka.ms/efcore-docs-sqlserver">Accessing SQL Server and SQL Azure databases with EF Core</see>
+    ///     for more information and examples.
+    /// </remarks>
+    /// <param name="indexBuilder">The builder for the index being configured.</param>
+    /// <param name="sortedInTempDb">A value indicating whether the index is created with sort in tempdb option.</param>
+    /// <returns>A builder to further configure the index.</returns>
+    public static IndexBuilder<TEntity> IsSortedInTempDb<TEntity>(
+        this IndexBuilder<TEntity> indexBuilder,
+        bool sortedInTempDb = true)
+        => (IndexBuilder<TEntity>)IsSortedInTempDb((IndexBuilder)indexBuilder, sortedInTempDb);
+
+    /// <summary>
+    ///     Configures whether the index is created with sort in tempdb option when targeting SQL Server.
+    /// </summary>
+    /// <remarks>
+    ///     See <see href="https://aka.ms/efcore-docs-modeling">Modeling entity types and relationships</see>, and
+    ///     <see href="https://aka.ms/efcore-docs-sqlserver">Accessing SQL Server and SQL Azure databases with EF Core</see>
+    ///     for more information and examples.
+    /// </remarks>
+    /// <param name="indexBuilder">The builder for the index being configured.</param>
+    /// <param name="sortedInTempDb">A value indicating whether the index is created with sort in tempdb option.</param>
+    /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
+    /// <returns>
+    ///     The same builder instance if the configuration was applied,
+    ///     <see langword="null" /> otherwise.
+    /// </returns>
+    public static IConventionIndexBuilder? IsSortedInTempDb(
+        this IConventionIndexBuilder indexBuilder,
+        bool? sortedInTempDb,
+        bool fromDataAnnotation = false)
+    {
+        if (indexBuilder.CanSetIsSortedInTempDb(sortedInTempDb, fromDataAnnotation))
+        {
+            indexBuilder.Metadata.SetIsSortedInTempDb(sortedInTempDb, fromDataAnnotation);
+
+            return indexBuilder;
+        }
+
+        return null;
+    }
+
+    /// <summary>
+    ///     Returns a value indicating whether the index can be configured with sort in tempdb option when targeting SQL Server.
+    /// </summary>
+    /// <remarks>
+    ///     See <see href="https://aka.ms/efcore-docs-modeling">Modeling entity types and relationships</see>, and
+    ///     <see href="https://aka.ms/efcore-docs-sqlserver">Accessing SQL Server and SQL Azure databases with EF Core</see>
+    ///     for more information and examples.
+    /// </remarks>
+    /// <param name="indexBuilder">The builder for the index being configured.</param>
+    /// <param name="sortedInTempDb">A value indicating whether the index is created with sort in tempdb option.</param>
+    /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
+    /// <returns>
+    ///     The same builder instance if the configuration was applied,
+    ///     <see langword="null" /> otherwise.
+    /// </returns>
+    /// <returns><see langword="true" /> if the index can be configured with sort in tempdb option when targeting SQL Server.</returns>
+    public static bool CanSetIsSortedInTempDb(
+        this IConventionIndexBuilder indexBuilder,
+        bool? sortedInTempDb,
+        bool fromDataAnnotation = false)
+        => indexBuilder.CanSetAnnotation(SqlServerAnnotationNames.SortedInTempDb, sortedInTempDb, fromDataAnnotation);
+
+    /// <summary>
+    ///     Configures whether the index is created with data compression option when targeting SQL Server.
+    /// </summary>
+    /// <remarks>
+    ///     See <see href="https://aka.ms/efcore-docs-modeling">Modeling entity types and relationships</see>, and
+    ///     <see href="https://aka.ms/efcore-docs-sqlserver">Accessing SQL Server and SQL Azure databases with EF Core</see>
+    ///     for more information and examples.
+    /// </remarks>
+    /// <param name="indexBuilder">The builder for the index being configured.</param>
+    /// <param name="dataCompressionType">A value indicating the data compression option to be used.</param>
+    /// <returns>A builder to further configure the index.</returns>
+    public static IndexBuilder UseDataCompression(this IndexBuilder indexBuilder, DataCompressionType dataCompressionType)
+    {
+        indexBuilder.Metadata.SetDataCompression(dataCompressionType);
+
+        return indexBuilder;
+    }
+
+    /// <summary>
+    ///     Configures whether the index is created with data compression option when targeting SQL Server.
+    /// </summary>
+    /// <remarks>
+    ///     See <see href="https://aka.ms/efcore-docs-modeling">Modeling entity types and relationships</see>, and
+    ///     <see href="https://aka.ms/efcore-docs-sqlserver">Accessing SQL Server and SQL Azure databases with EF Core</see>
+    ///     for more information and examples.
+    /// </remarks>
+    /// <param name="indexBuilder">The builder for the index being configured.</param>
+    /// <param name="dataCompressionType">A value indicating the data compression option to be used.</param>
+    /// <returns>A builder to further configure the index.</returns>
+    public static IndexBuilder<TEntity> UseDataCompression<TEntity>(
+        this IndexBuilder<TEntity> indexBuilder,
+        DataCompressionType dataCompressionType)
+        => (IndexBuilder<TEntity>)UseDataCompression((IndexBuilder)indexBuilder, dataCompressionType);
+
+    /// <summary>
+    ///     Configures whether the index is created with data compression option when targeting SQL Server.
+    /// </summary>
+    /// <remarks>
+    ///     See <see href="https://aka.ms/efcore-docs-modeling">Modeling entity types and relationships</see>, and
+    ///     <see href="https://aka.ms/efcore-docs-sqlserver">Accessing SQL Server and SQL Azure databases with EF Core</see>
+    ///     for more information and examples.
+    /// </remarks>
+    /// <param name="indexBuilder">The builder for the index being configured.</param>
+    /// <param name="dataCompressionType">A value indicating the data compression option to be used.</param>
+    /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
+    /// <returns>
+    ///     The same builder instance if the configuration was applied,
+    ///     <see langword="null" /> otherwise.
+    /// </returns>
+    public static IConventionIndexBuilder? UseDataCompression(
+        this IConventionIndexBuilder indexBuilder,
+        DataCompressionType? dataCompressionType,
+        bool fromDataAnnotation = false)
+    {
+        if (indexBuilder.CanSetDataCompression(dataCompressionType, fromDataAnnotation))
+        {
+            indexBuilder.Metadata.SetDataCompression(dataCompressionType, fromDataAnnotation);
+
+            return indexBuilder;
+        }
+
+        return null;
+    }
+
+    /// <summary>
+    ///     Returns a value indicating whether the index can be configured with data compression option when targeting SQL Server.
+    /// </summary>
+    /// <remarks>
+    ///     See <see href="https://aka.ms/efcore-docs-modeling">Modeling entity types and relationships</see>, and
+    ///     <see href="https://aka.ms/efcore-docs-sqlserver">Accessing SQL Server and SQL Azure databases with EF Core</see>
+    ///     for more information and examples.
+    /// </remarks>
+    /// <param name="indexBuilder">The builder for the index being configured.</param>
+    /// <param name="dataCompressionType">A value indicating the data compression option to be used.</param>
+    /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
+    /// <returns>
+    ///     The same builder instance if the configuration was applied,
+    ///     <see langword="null" /> otherwise.
+    /// </returns>
+    /// <returns><see langword="true" /> if the index can be configured with data compression option when targeting SQL Server.</returns>
+    public static bool CanSetDataCompression(
+        this IConventionIndexBuilder indexBuilder,
+        DataCompressionType? dataCompressionType,
+        bool fromDataAnnotation = false)
+        => indexBuilder.CanSetAnnotation(SqlServerAnnotationNames.DataCompression, dataCompressionType, fromDataAnnotation);
 }
diff --git a/src/EFCore.SqlServer/Extensions/SqlServerIndexExtensions.cs b/src/EFCore.SqlServer/Extensions/SqlServerIndexExtensions.cs
index 6d47396a9b..591e7ba1e1 100644
--- a/src/EFCore.SqlServer/Extensions/SqlServerIndexExtensions.cs
+++ b/src/EFCore.SqlServer/Extensions/SqlServerIndexExtensions.cs
@@ -297,4 +297,136 @@ public static void SetFillFactor(this IMutableIndex index, int? fillFactor)
     /// <returns>The <see cref="ConfigurationSource" /> for whether the index uses the fill factor.</returns>
     public static ConfigurationSource? GetFillFactorConfigurationSource(this IConventionIndex index)
         => index.FindAnnotation(SqlServerAnnotationNames.FillFactor)?.GetConfigurationSource();
+
+    /// <summary>
+    ///     Returns a value indicating whether the index is sorted in tempdb.
+    /// </summary>
+    /// <param name="index">The index.</param>
+    /// <returns><see langword="true" /> if the index is sorted in tempdb.</returns>
+    public static bool? GetIsSortedInTempDb(this IReadOnlyIndex index)
+        => (index is RuntimeIndex)
+            ? throw new InvalidOperationException(CoreStrings.RuntimeModelMissingData)
+            : (bool?)index[SqlServerAnnotationNames.SortedInTempDb];
+
+    /// <summary>
+    ///     Returns a value indicating whether the index is sorted in tempdb.
+    /// </summary>
+    /// <param name="index">The index.</param>
+    /// <param name="storeObject">The identifier of the store object.</param>
+    /// <returns><see langword="true" /> if the index is sorted in tempdb.</returns>
+    public static bool? GetIsSortedInTempDb(this IReadOnlyIndex index, in StoreObjectIdentifier storeObject)
+    {
+        if (index is RuntimeIndex)
+        {
+            throw new InvalidOperationException(CoreStrings.RuntimeModelMissingData);
+        }
+
+        var annotation = index.FindAnnotation(SqlServerAnnotationNames.SortedInTempDb);
+        if (annotation != null)
+        {
+            return (bool?)annotation.Value;
+        }
+
+        var sharedTableRootIndex = index.FindSharedObjectRootIndex(storeObject);
+        return sharedTableRootIndex?.GetIsSortedInTempDb(storeObject);
+    }
+
+    /// <summary>
+    ///     Sets a value indicating whether the index is sorted in tempdb.
+    /// </summary>
+    /// <param name="index">The index.</param>
+    /// <param name="sortedInTempDb">The value to set.</param>
+    public static void SetIsSortedInTempDb(this IMutableIndex index, bool? sortedInTempDb)
+        => index.SetAnnotation(
+            SqlServerAnnotationNames.SortedInTempDb,
+            sortedInTempDb);
+
+    /// <summary>
+    ///     Sets a value indicating whether the index is sorted in tempdb.
+    /// </summary>
+    /// <param name="index">The index.</param>
+    /// <param name="sortedInTempDb">The value to set.</param>
+    /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
+    /// <returns>The configured value.</returns>
+    public static bool? SetIsSortedInTempDb(
+        this IConventionIndex index,
+        bool? sortedInTempDb,
+        bool fromDataAnnotation = false)
+        => (bool?)index.SetAnnotation(
+            SqlServerAnnotationNames.SortedInTempDb,
+            sortedInTempDb,
+            fromDataAnnotation)?.Value;
+
+    /// <summary>
+    ///     Returns the <see cref="ConfigurationSource" /> for whether the index is sorted in tempdb.
+    /// </summary>
+    /// <param name="index">The index.</param>
+    /// <returns>The <see cref="ConfigurationSource" /> for whether the index is sorted in tempdb.</returns>
+    public static ConfigurationSource? GetIsSortedInTempDbConfigurationSource(this IConventionIndex index)
+        => index.FindAnnotation(SqlServerAnnotationNames.SortedInTempDb)?.GetConfigurationSource();
+
+    /// <summary>
+    ///     Returns the data compression that the index uses.
+    /// </summary>
+    /// <param name="index">The index.</param>
+    /// <returns>The data compression that the index uses</returns>
+    public static DataCompressionType? GetDataCompression(this IReadOnlyIndex index)
+        => (index is RuntimeIndex)
+            ? throw new InvalidOperationException(CoreStrings.RuntimeModelMissingData)
+            : (DataCompressionType?)index[SqlServerAnnotationNames.DataCompression];
+
+    /// <summary>
+    ///     Returns the data compression that the index uses.
+    /// </summary>
+    /// <param name="index">The index.</param>
+    /// <param name="storeObject">The identifier of the store object.</param>
+    /// <returns>The data compression that the index uses</returns>
+    public static DataCompressionType? GetDataCompression(this IReadOnlyIndex index, in StoreObjectIdentifier storeObject)
+    {
+        if (index is RuntimeIndex)
+        {
+            throw new InvalidOperationException(CoreStrings.RuntimeModelMissingData);
+        }
+
+        var annotation = index.FindAnnotation(SqlServerAnnotationNames.DataCompression);
+        if (annotation != null)
+        {
+            return (DataCompressionType?)annotation.Value;
+        }
+
+        var sharedTableRootIndex = index.FindSharedObjectRootIndex(storeObject);
+        return sharedTableRootIndex?.GetDataCompression(storeObject);
+    }
+
+    /// <summary>
+    ///     Sets a value indicating the data compression the index uses.
+    /// </summary>
+    /// <param name="index">The index.</param>
+    /// <param name="dataCompression">The value to set.</param>
+    public static void SetDataCompression(this IMutableIndex index, DataCompressionType? dataCompression) => index.SetAnnotation(
+            SqlServerAnnotationNames.DataCompression,
+            dataCompression);
+
+    /// <summary>
+    ///     Sets a value indicating the data compression the index uses.
+    /// </summary>
+    /// <param name="index">The index.</param>
+    /// <param name="dataCompression">The value to set.</param>
+    /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
+    /// <returns>The configured value.</returns>
+    public static DataCompressionType? SetDataCompression(
+        this IConventionIndex index,
+        DataCompressionType? dataCompression,
+        bool fromDataAnnotation = false) => (DataCompressionType?)index.SetAnnotation(
+            SqlServerAnnotationNames.DataCompression,
+            dataCompression,
+            fromDataAnnotation)?.Value;
+
+    /// <summary>
+    ///     Returns the <see cref="ConfigurationSource" /> for the data compression the index uses.
+    /// </summary>
+    /// <param name="index">The index.</param>
+    /// <returns>The <see cref="ConfigurationSource" /> for the data compression the index uses.</returns>
+    public static ConfigurationSource? GetDataCompressionConfigurationSource(this IConventionIndex index)
+        => index.FindAnnotation(SqlServerAnnotationNames.DataCompression)?.GetConfigurationSource();
 }
diff --git a/src/EFCore.SqlServer/Metadata/Conventions/SqlServerRuntimeModelConvention.cs b/src/EFCore.SqlServer/Metadata/Conventions/SqlServerRuntimeModelConvention.cs
index b64397045a..6a8c04f778 100644
--- a/src/EFCore.SqlServer/Metadata/Conventions/SqlServerRuntimeModelConvention.cs
+++ b/src/EFCore.SqlServer/Metadata/Conventions/SqlServerRuntimeModelConvention.cs
@@ -101,6 +101,8 @@ public class SqlServerRuntimeModelConvention : RelationalRuntimeModelConvention
             annotations.Remove(SqlServerAnnotationNames.CreatedOnline);
             annotations.Remove(SqlServerAnnotationNames.Include);
             annotations.Remove(SqlServerAnnotationNames.FillFactor);
+            annotations.Remove(SqlServerAnnotationNames.SortedInTempDb);
+            annotations.Remove(SqlServerAnnotationNames.DataCompression);
         }
     }
 
diff --git a/src/EFCore.SqlServer/Metadata/Internal/SqlServerAnnotationNames.cs b/src/EFCore.SqlServer/Metadata/Internal/SqlServerAnnotationNames.cs
index 8bf33226c2..4352a29ab4 100644
--- a/src/EFCore.SqlServer/Metadata/Internal/SqlServerAnnotationNames.cs
+++ b/src/EFCore.SqlServer/Metadata/Internal/SqlServerAnnotationNames.cs
@@ -51,6 +51,22 @@ public static class SqlServerAnnotationNames
     /// </summary>
     public const string FillFactor = Prefix + "FillFactor";
 
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public const string SortedInTempDb = Prefix + "SortInTempDb";
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public const string DataCompression = Prefix + "DataCompression";
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
diff --git a/src/EFCore.SqlServer/Metadata/Internal/SqlServerAnnotationProvider.cs b/src/EFCore.SqlServer/Metadata/Internal/SqlServerAnnotationProvider.cs
index 40ed99df85..54d27c68c7 100644
--- a/src/EFCore.SqlServer/Metadata/Internal/SqlServerAnnotationProvider.cs
+++ b/src/EFCore.SqlServer/Metadata/Internal/SqlServerAnnotationProvider.cs
@@ -203,6 +203,16 @@ public override IEnumerable<IAnnotation> For(ITableIndex index, bool designTime)
         {
             yield return new Annotation(SqlServerAnnotationNames.FillFactor, fillFactor);
         }
+
+        if (modelIndex.GetIsSortedInTempDb(table) is bool isSortedInTempDb)
+        {
+            yield return new Annotation(SqlServerAnnotationNames.SortedInTempDb, isSortedInTempDb);
+        }
+
+        if (modelIndex.GetDataCompression(table) is DataCompressionType dataCompressionType)
+        {
+            yield return new Annotation(SqlServerAnnotationNames.DataCompression, dataCompressionType);
+        }
     }
 
     /// <summary>
diff --git a/src/EFCore.SqlServer/Metadata/Internal/SqlServerIndexExtensions.cs b/src/EFCore.SqlServer/Metadata/Internal/SqlServerIndexExtensions.cs
index 49f2189148..369a26a0db 100644
--- a/src/EFCore.SqlServer/Metadata/Internal/SqlServerIndexExtensions.cs
+++ b/src/EFCore.SqlServer/Metadata/Internal/SqlServerIndexExtensions.cs
@@ -100,6 +100,40 @@ public static class SqlServerIndexExtensions
             return false;
         }
 
+        if (index.GetIsSortedInTempDb() != duplicateIndex.GetIsSortedInTempDb())
+        {
+            if (shouldThrow)
+            {
+                throw new InvalidOperationException(
+                    SqlServerStrings.DuplicateIndexSortInTempDbMismatch(
+                        index.DisplayName(),
+                        index.DeclaringEntityType.DisplayName(),
+                        duplicateIndex.DisplayName(),
+                        duplicateIndex.DeclaringEntityType.DisplayName(),
+                        index.DeclaringEntityType.GetSchemaQualifiedTableName(),
+                        index.GetDatabaseName(storeObject)));
+            }
+
+            return false;
+        }
+
+        if (index.GetDataCompression() != duplicateIndex.GetDataCompression())
+        {
+            if (shouldThrow)
+            {
+                throw new InvalidOperationException(
+                    SqlServerStrings.DuplicateIndexDataCompressionMismatch(
+                        index.DisplayName(),
+                        index.DeclaringEntityType.DisplayName(),
+                        duplicateIndex.DisplayName(),
+                        duplicateIndex.DeclaringEntityType.DisplayName(),
+                        index.DeclaringEntityType.GetSchemaQualifiedTableName(),
+                        index.GetDatabaseName(storeObject)));
+            }
+
+            return false;
+        }
+
         return true;
 
         static bool SameColumnNames(IReadOnlyIndex index, IReadOnlyIndex duplicateIndex, StoreObjectIdentifier storeObject)
diff --git a/src/EFCore.SqlServer/Migrations/SqlServerMigrationsSqlGenerator.cs b/src/EFCore.SqlServer/Migrations/SqlServerMigrationsSqlGenerator.cs
index 03a02ec72e..3d9f370dc2 100644
--- a/src/EFCore.SqlServer/Migrations/SqlServerMigrationsSqlGenerator.cs
+++ b/src/EFCore.SqlServer/Migrations/SqlServerMigrationsSqlGenerator.cs
@@ -1851,6 +1851,27 @@ private static void IndexWithOptions(CreateIndexOperation operation, MigrationCo
             options.Add("ONLINE = ON");
         }
 
+        if (operation[SqlServerAnnotationNames.SortedInTempDb] is bool isSortedInTempDb && isSortedInTempDb)
+        {
+            options.Add("SORT_IN_TEMPDB = ON");
+        }
+
+        if (operation[SqlServerAnnotationNames.DataCompression] is DataCompressionType dataCompressionType)
+        {
+            switch (dataCompressionType)
+            {
+                case DataCompressionType.None:
+                    options.Add("DATA_COMPRESSION = NONE");
+                    break;
+                case DataCompressionType.Row:
+                    options.Add("DATA_COMPRESSION = ROW");
+                    break;
+                case DataCompressionType.Page:
+                    options.Add("DATA_COMPRESSION = PAGE");
+                    break;
+            }
+        }
+
         if (options.Count > 0)
         {
             builder
diff --git a/src/EFCore.SqlServer/Properties/SqlServerStrings.Designer.cs b/src/EFCore.SqlServer/Properties/SqlServerStrings.Designer.cs
index 22c3a3a7fe..a36445d186 100644
--- a/src/EFCore.SqlServer/Properties/SqlServerStrings.Designer.cs
+++ b/src/EFCore.SqlServer/Properties/SqlServerStrings.Designer.cs
@@ -99,6 +99,14 @@ public static string DuplicateIndexClusteredMismatch(object? index1, object? ent
                 GetString("DuplicateIndexClusteredMismatch", nameof(index1), nameof(entityType1), nameof(index2), nameof(entityType2), nameof(table), nameof(indexName)),
                 index1, entityType1, index2, entityType2, table, indexName);
 
+        /// <summary>
+        ///     The indexes {index1} on '{entityType1}' and {index2} on '{entityType2}' are both mapped to '{table}.{indexName}', but have different data compression configurations.
+        /// </summary>
+        public static string DuplicateIndexDataCompressionMismatch(object? index1, object? entityType1, object? index2, object? entityType2, object? table, object? indexName)
+            => string.Format(
+                GetString("DuplicateIndexDataCompressionMismatch", nameof(index1), nameof(entityType1), nameof(index2), nameof(entityType2), nameof(table), nameof(indexName)),
+                index1, entityType1, index2, entityType2, table, indexName);
+
         /// <summary>
         ///     The indexes {index1} on '{entityType1}' and {index2} on '{entityType2}' are both mapped to '{table}.{indexName}', but have different fill factor configurations.
         /// </summary>
@@ -123,6 +131,14 @@ public static string DuplicateIndexOnlineMismatch(object? index1, object? entity
                 GetString("DuplicateIndexOnlineMismatch", nameof(index1), nameof(entityType1), nameof(index2), nameof(entityType2), nameof(table), nameof(indexName)),
                 index1, entityType1, index2, entityType2, table, indexName);
 
+        /// <summary>
+        ///     The indexes {index1} on '{entityType1}' and {index2} on '{entityType2}' are both mapped to '{table}.{indexName}', but have different sort in tempdb configurations.
+        /// </summary>
+        public static string DuplicateIndexSortInTempDbMismatch(object? index1, object? entityType1, object? index2, object? entityType2, object? table, object? indexName)
+            => string.Format(
+                GetString("DuplicateIndexSortInTempDbMismatch", nameof(index1), nameof(entityType1), nameof(index2), nameof(entityType2), nameof(table), nameof(indexName)),
+                index1, entityType1, index2, entityType2, table, indexName);
+
         /// <summary>
         ///     The keys {key1} on '{entityType1}' and {key2} on '{entityType2}' are both mapped to '{table}.{keyName}', but have different clustering configurations.
         /// </summary>
diff --git a/src/EFCore.SqlServer/Properties/SqlServerStrings.resx b/src/EFCore.SqlServer/Properties/SqlServerStrings.resx
index beb38d33c4..59c92b4e2b 100644
--- a/src/EFCore.SqlServer/Properties/SqlServerStrings.resx
+++ b/src/EFCore.SqlServer/Properties/SqlServerStrings.resx
@@ -156,6 +156,12 @@
   <data name="DuplicateIndexOnlineMismatch" xml:space="preserve">
     <value>The indexes {index1} on '{entityType1}' and {index2} on '{entityType2}' are both mapped to '{table}.{indexName}', but have different online configurations.</value>
   </data>
+  <data name="DuplicateIndexSortInTempDbMismatch" xml:space="preserve">
+    <value>The indexes {index1} on '{entityType1}' and {index2} on '{entityType2}' are both mapped to '{table}.{indexName}', but have different sort in tempdb configurations.</value>
+  </data>
+  <data name="DuplicateIndexDataCompressionMismatch" xml:space="preserve">
+    <value>The indexes {index1} on '{entityType1}' and {index2} on '{entityType2}' are both mapped to '{table}.{indexName}', but have different data compression configurations.</value>
+  </data>
   <data name="DuplicateKeyMismatchedClustering" xml:space="preserve">
     <value>The keys {key1} on '{entityType1}' and {key2} on '{entityType2}' are both mapped to '{table}.{keyName}', but have different clustering configurations.</value>
   </data>
diff --git a/test/EFCore.Design.Tests/Migrations/ModelSnapshotSqlServerTest.cs b/test/EFCore.Design.Tests/Migrations/ModelSnapshotSqlServerTest.cs
index e8d7423f23..b57455d4e9 100644
--- a/test/EFCore.Design.Tests/Migrations/ModelSnapshotSqlServerTest.cs
+++ b/test/EFCore.Design.Tests/Migrations/ModelSnapshotSqlServerTest.cs
@@ -6209,6 +6209,117 @@ public virtual void IndexAttribute_IncludeProperties_generated_without_fluent_ap
                 Assert.Equal("Name", Assert.Single(index.GetIncludeProperties()));
             });
 
+    [ConditionalFact]
+    public virtual void IndexAttribute_HasFillFactor_is_stored_in_snapshot()
+        => Test(
+            builder => builder.Entity<EntityWithStringProperty>(
+                x =>
+                {
+                    x.HasIndex(e => e.Id).HasFillFactor(29);
+                }),
+            AddBoilerPlate(
+                GetHeading() +
+"""
+            modelBuilder.Entity("Microsoft.EntityFrameworkCore.Migrations.ModelSnapshotSqlServerTest+EntityWithStringProperty", b =>
+                {
+                    b.Property<int>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("int");
+
+                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));
+
+                    b.Property<string>("Name")
+                        .HasColumnType("nvarchar(max)");
+
+                    b.HasKey("Id");
+
+                    b.HasIndex("Id");
+
+                    SqlServerIndexBuilderExtensions.HasFillFactor(b.HasIndex("Id"), 29);
+
+                    b.ToTable("EntityWithStringProperty", "DefaultSchema");
+                });
+"""),
+            model =>
+            {
+                var index = model.GetEntityTypes().First().GetIndexes().First();
+                Assert.Equal(29, index.GetFillFactor());
+            });
+
+    [ConditionalFact]
+    public virtual void IndexAttribute_UseDataCompression_is_stored_in_snapshot()
+        => Test(
+            builder => builder.Entity<EntityWithStringProperty>(
+                x =>
+                {
+                    x.HasIndex(e => e.Id).UseDataCompression(DataCompressionType.Row);
+                }),
+            AddBoilerPlate(
+                GetHeading() +
+"""
+            modelBuilder.Entity("Microsoft.EntityFrameworkCore.Migrations.ModelSnapshotSqlServerTest+EntityWithStringProperty", b =>
+                {
+                    b.Property<int>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("int");
+
+                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));
+
+                    b.Property<string>("Name")
+                        .HasColumnType("nvarchar(max)");
+
+                    b.HasKey("Id");
+
+                    b.HasIndex("Id");
+
+                    SqlServerIndexBuilderExtensions.UseDataCompression(b.HasIndex("Id"), DataCompressionType.Row);
+
+                    b.ToTable("EntityWithStringProperty", "DefaultSchema");
+                });
+"""),
+            model =>
+            {
+                var index = model.GetEntityTypes().First().GetIndexes().First();
+                Assert.Equal(DataCompressionType.Row, index.GetDataCompression());
+            });
+
+    [ConditionalFact]
+    public virtual void IndexAttribute_IsSortedInTempDb_is_stored_in_snapshot()
+        => Test(
+            builder => builder.Entity<EntityWithStringProperty>(
+                x =>
+                {
+                    x.HasIndex(e => e.Id).IsSortedInTempDb(true);
+                }),
+            AddBoilerPlate(
+                GetHeading() +
+"""
+            modelBuilder.Entity("Microsoft.EntityFrameworkCore.Migrations.ModelSnapshotSqlServerTest+EntityWithStringProperty", b =>
+                {
+                    b.Property<int>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("int");
+
+                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));
+
+                    b.Property<string>("Name")
+                        .HasColumnType("nvarchar(max)");
+
+                    b.HasKey("Id");
+
+                    b.HasIndex("Id");
+
+                    SqlServerIndexBuilderExtensions.IsSortedInTempDb(b.HasIndex("Id"), true);
+
+                    b.ToTable("EntityWithStringProperty", "DefaultSchema");
+                });
+"""),
+            model =>
+            {
+                var index = model.GetEntityTypes().First().GetIndexes().First();
+                Assert.True(index.GetIsSortedInTempDb());
+            });
+
     #endregion
 
     #region ForeignKey
diff --git a/test/EFCore.Design.Tests/Scaffolding/Internal/CSharpRuntimeModelCodeGeneratorTest.cs b/test/EFCore.Design.Tests/Scaffolding/Internal/CSharpRuntimeModelCodeGeneratorTest.cs
index b4cb8aaa38..3083acf1f1 100644
--- a/test/EFCore.Design.Tests/Scaffolding/Internal/CSharpRuntimeModelCodeGeneratorTest.cs
+++ b/test/EFCore.Design.Tests/Scaffolding/Internal/CSharpRuntimeModelCodeGeneratorTest.cs
@@ -14827,6 +14827,14 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
                     Assert.Equal(
                         CoreStrings.RuntimeModelMissingData,
                         Assert.Throws<InvalidOperationException>(() => alternateIndex.GetIncludeProperties()).Message);
+                    Assert.Null(alternateIndex[SqlServerAnnotationNames.SortedInTempDb]);
+                    Assert.Equal(
+                        CoreStrings.RuntimeModelMissingData,
+                        Assert.Throws<InvalidOperationException>(() => alternateIndex.GetIsSortedInTempDb()).Message);
+                    Assert.Null(alternateIndex[SqlServerAnnotationNames.DataCompression]);
+                    Assert.Equal(
+                        CoreStrings.RuntimeModelMissingData,
+                        Assert.Throws<InvalidOperationException>(() => alternateIndex.GetDataCompression()).Message);
 
                     Assert.Equal(new[] { alternateIndex }, principalBaseId.GetContainingIndexes());
 
@@ -15045,7 +15053,9 @@ protected override void OnModelCreating(ModelBuilder modelBuilder)
                             .HasFilter("AlternateId <> NULL")
                             .IsCreatedOnline()
                             .HasFillFactor(40)
-                            .IncludeProperties(e => e.Id);
+                            .IncludeProperties(e => e.Id)
+                            .IsSortedInTempDb()
+                            .UseDataCompression(DataCompressionType.Page);
                     });
 
                 modelBuilder.Entity<PrincipalDerived<DependentBase<byte?>>>(
diff --git a/test/EFCore.SqlServer.FunctionalTests/Migrations/MigrationsSqlServerTest.cs b/test/EFCore.SqlServer.FunctionalTests/Migrations/MigrationsSqlServerTest.cs
index fed07e2f34..af9d4fedb2 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Migrations/MigrationsSqlServerTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Migrations/MigrationsSqlServerTest.cs
@@ -2225,6 +2225,105 @@ public virtual async Task Create_index_unique_with_include_filter_and_fillfactor
 """);
     }
 
+    [ConditionalFact]
+    public virtual async Task Create_index_unique_with_include_fillfactor_and_sortintempdb()
+    {
+        await Test(
+            builder => builder.Entity(
+                "People", e =>
+                {
+                    e.Property<int>("Id");
+                    e.Property<string>("FirstName");
+                    e.Property<string>("LastName");
+                    e.Property<string>("Name").IsRequired();
+                }),
+            builder => { },
+            builder => builder.Entity("People").HasIndex("Name")
+                .IsUnique()
+                .IncludeProperties("FirstName", "LastName")
+                .HasFillFactor(75)
+                .IsSortedInTempDb(),
+            model =>
+            {
+                var table = Assert.Single(model.Tables);
+                var index = Assert.Single(table.Indexes);
+                Assert.True(index.IsUnique);
+                Assert.Null(index.Filter);
+                Assert.Equal(1, index.Columns.Count);
+                Assert.Contains(table.Columns.Single(c => c.Name == "Name"), index.Columns);
+                var includedColumns = (IReadOnlyList<string>?)index[SqlServerAnnotationNames.Include];
+                Assert.Null(includedColumns);
+                Assert.Equal(75, index[SqlServerAnnotationNames.FillFactor]);
+                Assert.Null(index[SqlServerAnnotationNames.SortedInTempDb]);
+            });
+
+        AssertSql(
+"""
+DECLARE @var0 sysname;
+SELECT @var0 = [d].[name]
+FROM [sys].[default_constraints] [d]
+INNER JOIN [sys].[columns] [c] ON [d].[parent_column_id] = [c].[column_id] AND [d].[parent_object_id] = [c].[object_id]
+WHERE ([d].[parent_object_id] = OBJECT_ID(N'[People]') AND [c].[name] = N'Name');
+IF @var0 IS NOT NULL EXEC(N'ALTER TABLE [People] DROP CONSTRAINT [' + @var0 + '];');
+ALTER TABLE [People] ALTER COLUMN [Name] nvarchar(450) NOT NULL;
+""",
+//
+"""
+CREATE UNIQUE INDEX [IX_People_Name] ON [People] ([Name]) INCLUDE ([FirstName], [LastName]) WITH (FILLFACTOR = 75, SORT_IN_TEMPDB = ON);
+""");
+    }
+
+    [ConditionalTheory]
+    [InlineData(DataCompressionType.None, "NONE")]
+    [InlineData(DataCompressionType.Row, "ROW")]
+    [InlineData(DataCompressionType.Page, "PAGE")]
+    public virtual async Task Create_index_unique_with_include_sortintempdb_and_datacompression(DataCompressionType dataCompression, string dataCompressionSql)
+    {
+        await Test(
+            builder => builder.Entity(
+                "People", e =>
+                {
+                    e.Property<int>("Id");
+                    e.Property<string>("FirstName");
+                    e.Property<string>("LastName");
+                    e.Property<string>("Name").IsRequired();
+                }),
+            builder => { },
+            builder => builder.Entity("People").HasIndex("Name")
+                .IsUnique()
+                .IncludeProperties("FirstName", "LastName")
+                .IsSortedInTempDb()
+                .UseDataCompression(dataCompression),
+            model =>
+            {
+                var table = Assert.Single(model.Tables);
+                var index = Assert.Single(table.Indexes);
+                Assert.True(index.IsUnique);
+                Assert.Null(index.Filter);
+                Assert.Equal(1, index.Columns.Count);
+                Assert.Contains(table.Columns.Single(c => c.Name == "Name"), index.Columns);
+                var includedColumns = (IReadOnlyList<string>?)index[SqlServerAnnotationNames.Include];
+                Assert.Null(includedColumns);
+                Assert.Null(index[SqlServerAnnotationNames.SortedInTempDb]);
+                Assert.Null(index[SqlServerAnnotationNames.DataCompression]);
+            });
+
+        AssertSql(
+"""
+DECLARE @var0 sysname;
+SELECT @var0 = [d].[name]
+FROM [sys].[default_constraints] [d]
+INNER JOIN [sys].[columns] [c] ON [d].[parent_column_id] = [c].[column_id] AND [d].[parent_object_id] = [c].[object_id]
+WHERE ([d].[parent_object_id] = OBJECT_ID(N'[People]') AND [c].[name] = N'Name');
+IF @var0 IS NOT NULL EXEC(N'ALTER TABLE [People] DROP CONSTRAINT [' + @var0 + '];');
+ALTER TABLE [People] ALTER COLUMN [Name] nvarchar(450) NOT NULL;
+""",
+//
+$"""
+CREATE UNIQUE INDEX [IX_People_Name] ON [People] ([Name]) INCLUDE ([FirstName], [LastName]) WITH (SORT_IN_TEMPDB = ON, DATA_COMPRESSION = {dataCompressionSql});
+""");
+    }
+
     [ConditionalFact]
     [SqlServerCondition(SqlServerCondition.SupportsMemoryOptimized)]
     public virtual async Task Create_index_memoryOptimized_unique_nullable()
diff --git a/test/EFCore.SqlServer.FunctionalTests/Migrations/SqlServerMigrationsSqlGeneratorTest.cs b/test/EFCore.SqlServer.FunctionalTests/Migrations/SqlServerMigrationsSqlGeneratorTest.cs
index e53c068bb0..856732091d 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Migrations/SqlServerMigrationsSqlGeneratorTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Migrations/SqlServerMigrationsSqlGeneratorTest.cs
@@ -29,6 +29,49 @@ public void CreateIndexOperation_unique_online()
 """);
     }
 
+    [ConditionalFact]
+    public void CreateIndexOperation_unique_sortintempdb()
+    {
+        Generate(
+            new CreateIndexOperation
+            {
+                Name = "IX_People_Name",
+                Table = "People",
+                Schema = "dbo",
+                Columns = new[] { "FirstName", "LastName" },
+                IsUnique = true,
+                [SqlServerAnnotationNames.SortedInTempDb] = true
+            });
+
+        AssertSql(
+"""
+CREATE UNIQUE INDEX [IX_People_Name] ON [dbo].[People] ([FirstName], [LastName]) WHERE [FirstName] IS NOT NULL AND [LastName] IS NOT NULL WITH (SORT_IN_TEMPDB = ON);
+""");
+    }
+
+    [ConditionalTheory]
+    [InlineData(DataCompressionType.None, "NONE")]
+    [InlineData(DataCompressionType.Row, "ROW")]
+    [InlineData(DataCompressionType.Page, "PAGE")]
+    public void CreateIndexOperation_unique_datacompression(DataCompressionType dataCompression, string dataCompressionSql)
+    {
+        Generate(
+            new CreateIndexOperation
+            {
+                Name = "IX_People_Name",
+                Table = "People",
+                Schema = "dbo",
+                Columns = new[] { "FirstName", "LastName" },
+                IsUnique = true,
+                [SqlServerAnnotationNames.DataCompression] = dataCompression
+            });
+
+        AssertSql(
+$"""
+CREATE UNIQUE INDEX [IX_People_Name] ON [dbo].[People] ([FirstName], [LastName]) WHERE [FirstName] IS NOT NULL AND [LastName] IS NOT NULL WITH (DATA_COMPRESSION = {dataCompressionSql});
+""");
+    }
+
     [ConditionalFact]
     public virtual void AddColumnOperation_identity_legacy()
     {
diff --git a/test/EFCore.SqlServer.Tests/Infrastructure/SqlServerModelValidatorTest.cs b/test/EFCore.SqlServer.Tests/Infrastructure/SqlServerModelValidatorTest.cs
index 0e2c71e859..eb028b7c29 100644
--- a/test/EFCore.SqlServer.Tests/Infrastructure/SqlServerModelValidatorTest.cs
+++ b/test/EFCore.SqlServer.Tests/Infrastructure/SqlServerModelValidatorTest.cs
@@ -402,6 +402,38 @@ public virtual void Detects_duplicate_index_names_within_hierarchy_differently_o
             modelBuilder);
     }
 
+    [ConditionalFact]
+    public virtual void Detects_duplicate_index_names_within_hierarchy_different_sort_in_tempdb()
+    {
+        var modelBuilder = CreateConventionModelBuilder();
+        modelBuilder.Entity<Animal>();
+        modelBuilder.Entity<Cat>().HasIndex(c => c.Name).HasDatabaseName("IX_Animal_Name");
+        modelBuilder.Entity<Dog>().HasIndex(d => d.Name).HasDatabaseName("IX_Animal_Name").IsSortedInTempDb();
+
+        VerifyError(
+            SqlServerStrings.DuplicateIndexSortInTempDbMismatch(
+                "{'" + nameof(Dog.Name) + "'}", nameof(Dog),
+                "{'" + nameof(Cat.Name) + "'}", nameof(Cat),
+                nameof(Animal), "IX_Animal_Name"),
+            modelBuilder);
+    }
+
+    [ConditionalFact]
+    public virtual void Detects_duplicate_index_names_within_hierarchy_different_data_compression()
+    {
+        var modelBuilder = CreateConventionModelBuilder();
+        modelBuilder.Entity<Animal>();
+        modelBuilder.Entity<Cat>().HasIndex(c => c.Name).HasDatabaseName("IX_Animal_Name");
+        modelBuilder.Entity<Dog>().HasIndex(d => d.Name).HasDatabaseName("IX_Animal_Name").UseDataCompression(DataCompressionType.Page);
+
+        VerifyError(
+            SqlServerStrings.DuplicateIndexDataCompressionMismatch(
+                "{'" + nameof(Dog.Name) + "'}", nameof(Dog),
+                "{'" + nameof(Cat.Name) + "'}", nameof(Cat),
+                nameof(Animal), "IX_Animal_Name"),
+            modelBuilder);
+    }
+
     [ConditionalFact]
     public virtual void Detects_duplicate_index_names_within_hierarchy_with_different_different_include()
     {
diff --git a/test/EFCore.SqlServer.Tests/Metadata/SqlServerBuilderExtensionsTest.cs b/test/EFCore.SqlServer.Tests/Metadata/SqlServerBuilderExtensionsTest.cs
index 96614ca705..08390ed516 100644
--- a/test/EFCore.SqlServer.Tests/Metadata/SqlServerBuilderExtensionsTest.cs
+++ b/test/EFCore.SqlServer.Tests/Metadata/SqlServerBuilderExtensionsTest.cs
@@ -1078,6 +1078,72 @@ public void Throws_if_attempt_to_set_fillfactor_with_argument_out_of_range(int f
             });
     }
 
+    [ConditionalFact]
+    public void Can_set_index_with_sortintempdb()
+    {
+        var modelBuilder = CreateConventionModelBuilder();
+
+        modelBuilder
+            .Entity<Customer>()
+            .HasIndex(e => e.Name)
+            .IsSortedInTempDb();
+
+        var index = modelBuilder.Model.FindEntityType(typeof(Customer)).GetIndexes().Single();
+
+        Assert.True(index.GetIsSortedInTempDb());
+    }
+
+    [ConditionalFact]
+    public void Can_set_index_with_sortintempdb_non_generic()
+    {
+        var modelBuilder = CreateConventionModelBuilder();
+
+        modelBuilder
+            .Entity(typeof(Customer))
+            .HasIndex("Name")
+            .IsSortedInTempDb();
+
+        var index = modelBuilder.Model.FindEntityType(typeof(Customer)).GetIndexes().Single();
+
+        Assert.True(index.GetIsSortedInTempDb());
+    }
+
+    [ConditionalTheory]
+    [InlineData(DataCompressionType.None)]
+    [InlineData(DataCompressionType.Row)]
+    [InlineData(DataCompressionType.Page)]
+    public void Can_set_index_with_datacompression(DataCompressionType dataCompression)
+    {
+        var modelBuilder = CreateConventionModelBuilder();
+
+        modelBuilder
+            .Entity<Customer>()
+            .HasIndex(e => e.Name)
+            .UseDataCompression(dataCompression);
+
+        var index = modelBuilder.Model.FindEntityType(typeof(Customer)).GetIndexes().Single();
+
+        Assert.Equal(dataCompression, index.GetDataCompression());
+    }
+
+    [ConditionalTheory]
+    [InlineData(DataCompressionType.None)]
+    [InlineData(DataCompressionType.Row)]
+    [InlineData(DataCompressionType.Page)]
+    public void Can_set_index_with_datacompression_non_generic(DataCompressionType dataCompression)
+    {
+        var modelBuilder = CreateConventionModelBuilder();
+
+        modelBuilder
+            .Entity(typeof(Customer))
+            .HasIndex("Name")
+            .UseDataCompression(dataCompression);
+
+        var index = modelBuilder.Model.FindEntityType(typeof(Customer)).GetIndexes().Single();
+
+        Assert.Equal(dataCompression, index.GetDataCompression());
+    }
+
     #region UseSqlOutputClause
 
     [ConditionalFact]
diff --git a/test/EFCore.SqlServer.Tests/Migrations/SqlServerModelDifferTest.cs b/test/EFCore.SqlServer.Tests/Migrations/SqlServerModelDifferTest.cs
index b99f98fdc9..4171dac604 100644
--- a/test/EFCore.SqlServer.Tests/Migrations/SqlServerModelDifferTest.cs
+++ b/test/EFCore.SqlServer.Tests/Migrations/SqlServerModelDifferTest.cs
@@ -1390,4 +1390,241 @@ public void Rebuild_index_with_different_fillfactor_value()
 
                 Assert.Equal(90, annotationValue);
             });
+
+    [ConditionalFact]
+    public void Dont_rebuild_index_with_unchanged_sortintempdb_option()
+        => Execute(
+            source => source
+                .Entity(
+                    "Address",
+                    x =>
+                    {
+                        x.Property<int>("Id");
+                        x.Property<string>("Zip");
+                        x.Property<string>("City");
+                        x.HasIndex("Zip")
+                            .IsSortedInTempDb();
+                    }),
+            target => target
+                .Entity(
+                    "Address",
+                    x =>
+                    {
+                        x.Property<int>("Id");
+                        x.Property<string>("Zip");
+                        x.Property<string>("City");
+                        x.HasIndex("Zip")
+                            .IsSortedInTempDb();
+                    }),
+            operations => Assert.Equal(0, operations.Count));
+
+    [ConditionalFact]
+    public void Rebuild_index_when_changing_sortintempdb_option()
+        => Execute(
+            _ => { },
+            source => source
+                .Entity(
+                    "Address",
+                    x =>
+                    {
+                        x.Property<int>("Id");
+                        x.Property<string>("Zip");
+                        x.Property<string>("City");
+                        x.Property<string>("Street");
+                        x.HasIndex("Zip");
+                    }),
+            target => target
+                .Entity(
+                    "Address",
+                    x =>
+                    {
+                        x.Property<int>("Id");
+                        x.Property<string>("Zip");
+                        x.Property<string>("City");
+                        x.Property<string>("Street");
+                        x.HasIndex("Zip")
+                            .IsSortedInTempDb();
+                    }),
+            upOps =>
+            {
+                Assert.Equal(2, upOps.Count);
+
+                var operation1 = Assert.IsType<DropIndexOperation>(upOps[0]);
+                Assert.Equal("Address", operation1.Table);
+                Assert.Equal("IX_Address_Zip", operation1.Name);
+
+                Assert.Empty(operation1.GetAnnotations());
+
+                var operation2 = Assert.IsType<CreateIndexOperation>(upOps[1]);
+                Assert.Equal("Address", operation1.Table);
+                Assert.Equal("IX_Address_Zip", operation1.Name);
+
+                var annotation = operation2.GetAnnotation(SqlServerAnnotationNames.SortedInTempDb);
+                Assert.NotNull(annotation);
+
+                var annotationValue = Assert.IsType<bool>(annotation.Value);
+                Assert.True(annotationValue);
+            },
+            downOps =>
+            {
+                Assert.Equal(2, downOps.Count);
+
+                var operation1 = Assert.IsType<DropIndexOperation>(downOps[0]);
+                Assert.Equal("Address", operation1.Table);
+                Assert.Equal("IX_Address_Zip", operation1.Name);
+
+                Assert.Empty(operation1.GetAnnotations());
+
+                var operation2 = Assert.IsType<CreateIndexOperation>(downOps[1]);
+                Assert.Equal("Address", operation1.Table);
+                Assert.Equal("IX_Address_Zip", operation1.Name);
+
+                Assert.Empty(operation2.GetAnnotations());
+            });
+
+    [ConditionalTheory]
+    [InlineData(DataCompressionType.None)]
+    [InlineData(DataCompressionType.Row)]
+    [InlineData(DataCompressionType.Page)]
+    public void Dont_rebuild_index_with_unchanged_datacompression_option(DataCompressionType dataCompression)
+        => Execute(
+            source => source
+                .Entity(
+                    "Address",
+                    x =>
+                    {
+                        x.Property<int>("Id");
+                        x.Property<string>("Zip");
+                        x.Property<string>("City");
+                        x.HasIndex("Zip")
+                            .UseDataCompression(dataCompression);
+                    }),
+            target => target
+                .Entity(
+                    "Address",
+                    x =>
+                    {
+                        x.Property<int>("Id");
+                        x.Property<string>("Zip");
+                        x.Property<string>("City");
+                        x.HasIndex("Zip")
+                            .UseDataCompression(dataCompression);
+                    }),
+            operations => Assert.Equal(0, operations.Count));
+
+    [ConditionalTheory]
+    [InlineData(DataCompressionType.None)]
+    [InlineData(DataCompressionType.Row)]
+    [InlineData(DataCompressionType.Page)]
+    public void Rebuild_index_when_adding_datacompression_option(DataCompressionType dataCompression)
+    => Execute(
+        _ => { },
+        source => source
+            .Entity(
+                "Address",
+                x =>
+                {
+                    x.Property<int>("Id");
+                    x.Property<string>("Zip");
+                    x.Property<string>("City");
+                    x.Property<string>("Street");
+                    x.HasIndex("Zip");
+                }),
+        target => target
+            .Entity(
+                "Address",
+                x =>
+                {
+                    x.Property<int>("Id");
+                    x.Property<string>("Zip");
+                    x.Property<string>("City");
+                    x.Property<string>("Street");
+                    x.HasIndex("Zip")
+                        .UseDataCompression(dataCompression);
+                }),
+        upOps =>
+        {
+            Assert.Equal(2, upOps.Count);
+
+            var operation1 = Assert.IsType<DropIndexOperation>(upOps[0]);
+            Assert.Equal("Address", operation1.Table);
+            Assert.Equal("IX_Address_Zip", operation1.Name);
+
+            Assert.Empty(operation1.GetAnnotations());
+
+            var operation2 = Assert.IsType<CreateIndexOperation>(upOps[1]);
+            Assert.Equal("Address", operation1.Table);
+            Assert.Equal("IX_Address_Zip", operation1.Name);
+
+            var annotation = operation2.GetAnnotation(SqlServerAnnotationNames.DataCompression);
+            Assert.NotNull(annotation);
+
+            var annotationValue = Assert.IsType<DataCompressionType>(annotation.Value);
+            Assert.Equal(dataCompression, annotationValue);
+        },
+        downOps =>
+        {
+            Assert.Equal(2, downOps.Count);
+
+            var operation1 = Assert.IsType<DropIndexOperation>(downOps[0]);
+            Assert.Equal("Address", operation1.Table);
+            Assert.Equal("IX_Address_Zip", operation1.Name);
+
+            Assert.Empty(operation1.GetAnnotations());
+
+            var operation2 = Assert.IsType<CreateIndexOperation>(downOps[1]);
+            Assert.Equal("Address", operation1.Table);
+            Assert.Equal("IX_Address_Zip", operation1.Name);
+
+            Assert.Empty(operation2.GetAnnotations());
+        });
+
+    [ConditionalFact]
+    public void Rebuild_index_with_different_datacompression_value()
+        => Execute(
+            source => source
+                .Entity(
+                    "Address",
+                    x =>
+                    {
+                        x.Property<int>("Id");
+                        x.Property<string>("Zip");
+                        x.Property<string>("City");
+                        x.Property<string>("Street");
+                        x.HasIndex("Zip")
+                            .UseDataCompression(DataCompressionType.Row);
+                    }),
+            target => target
+                .Entity(
+                    "Address",
+                    x =>
+                    {
+                        x.Property<int>("Id");
+                        x.Property<string>("Zip");
+                        x.Property<string>("City");
+                        x.Property<string>("Street");
+                        x.HasIndex("Zip")
+                            .UseDataCompression(DataCompressionType.Page);
+                    }),
+            operations =>
+            {
+                Assert.Equal(2, operations.Count);
+
+                var operation1 = Assert.IsType<DropIndexOperation>(operations[0]);
+                Assert.Equal("Address", operation1.Table);
+                Assert.Equal("IX_Address_Zip", operation1.Name);
+
+                Assert.Empty(operation1.GetAnnotations());
+
+                var operation2 = Assert.IsType<CreateIndexOperation>(operations[1]);
+                Assert.Equal("Address", operation1.Table);
+                Assert.Equal("IX_Address_Zip", operation1.Name);
+
+                var annotation = operation2.GetAnnotation(SqlServerAnnotationNames.DataCompression);
+                Assert.NotNull(annotation);
+
+                var annotationValue = Assert.IsType<DataCompressionType>(annotation.Value);
+
+                Assert.Equal(DataCompressionType.Page, annotationValue);
+            });
 }
