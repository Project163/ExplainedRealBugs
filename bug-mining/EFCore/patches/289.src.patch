diff --git a/src/EFCore.Relational/Extensions/RelationalForeignKeyExtensions.cs b/src/EFCore.Relational/Extensions/RelationalForeignKeyExtensions.cs
index c8f14ee203..43f9310f28 100644
--- a/src/EFCore.Relational/Extensions/RelationalForeignKeyExtensions.cs
+++ b/src/EFCore.Relational/Extensions/RelationalForeignKeyExtensions.cs
@@ -213,12 +213,9 @@ public static IEnumerable<IForeignKeyConstraint> GetMappedConstraints(this IFore
     {
         var entityType = foreignKey.DeclaringEntityType;
         var primaryKey = entityType.FindPrimaryKey();
-        if (primaryKey == null || entityType.IsMappedToJson())
-        {
-            return false;
-        }
-
-        if (!foreignKey.PrincipalKey.IsPrimaryKey()
+        if (primaryKey == null
+            || entityType.IsMappedToJson()
+            || !foreignKey.PrincipalKey.IsPrimaryKey()
             || foreignKey.PrincipalEntityType.IsAssignableFrom(foreignKey.DeclaringEntityType)
             || !foreignKey.Properties.SequenceEqual(primaryKey.Properties)
             || !IsMapped(foreignKey, storeObject))
diff --git a/src/EFCore.Relational/Extensions/RelationalPropertyExtensions.cs b/src/EFCore.Relational/Extensions/RelationalPropertyExtensions.cs
index 157dc23d82..97ba303a91 100644
--- a/src/EFCore.Relational/Extensions/RelationalPropertyExtensions.cs
+++ b/src/EFCore.Relational/Extensions/RelationalPropertyExtensions.cs
@@ -57,9 +57,24 @@ public static string GetColumnName(this IReadOnlyProperty property)
             return overrides.ColumnName;
         }
 
-        if (storeObject.StoreObjectType != StoreObjectType.Function
-            && storeObject.StoreObjectType != StoreObjectType.SqlQuery)
+        if (!ShouldBeMapped(property, storeObject))
         {
+            return null;
+        }
+
+        var columnAnnotation = property.FindAnnotation(RelationalAnnotationNames.ColumnName);
+        return columnAnnotation != null
+            ? (string?)columnAnnotation.Value
+            : GetDefaultColumnName(property, storeObject);
+
+        static bool ShouldBeMapped(IReadOnlyProperty property, in StoreObjectIdentifier storeObject)
+        {
+            if (storeObject.StoreObjectType == StoreObjectType.Function
+                || storeObject.StoreObjectType == StoreObjectType.SqlQuery)
+            {
+                return true;
+            }
+
             if (property.IsPrimaryKey())
             {
                 var tableFound = false;
@@ -81,72 +96,68 @@ public static string GetColumnName(this IReadOnlyProperty property)
 
                 if (!tableFound)
                 {
-                    return null;
+                    return false;
                 }
             }
             else
             {
                 var declaringEntityType = property.DeclaringType.ContainingEntityType;
-                if (declaringEntityType.GetMappingStrategy() != RelationalAnnotationNames.TpcMappingStrategy)
+                if (declaringEntityType.GetMappingStrategy() == RelationalAnnotationNames.TpcMappingStrategy)
+                {
+                    return true;
+                }
+
+                var declaringStoreObject = StoreObjectIdentifier.Create(property.DeclaringType, storeObject.StoreObjectType);
+                if (declaringStoreObject == null)
                 {
-                    var declaringStoreObject = StoreObjectIdentifier.Create(property.DeclaringType, storeObject.StoreObjectType);
-                    if (declaringStoreObject == null)
+                    var tableFound = false;
+                    var queue = new Queue<IReadOnlyEntityType>();
+                    queue.Enqueue(declaringEntityType);
+                    while (queue.Count > 0 && !tableFound)
                     {
-                        var tableFound = false;
-                        var queue = new Queue<IReadOnlyEntityType>();
-                        queue.Enqueue(declaringEntityType);
-                        while (queue.Count > 0 && !tableFound)
+                        foreach (var containingType in queue.Dequeue().GetDirectlyDerivedTypes())
                         {
-                            foreach (var containingType in queue.Dequeue().GetDirectlyDerivedTypes())
+                            declaringStoreObject = StoreObjectIdentifier.Create(containingType, storeObject.StoreObjectType);
+                            if (declaringStoreObject == null)
                             {
-                                declaringStoreObject = StoreObjectIdentifier.Create(containingType, storeObject.StoreObjectType);
-                                if (declaringStoreObject == null)
-                                {
-                                    queue.Enqueue(containingType);
-                                    continue;
-                                }
-
-                                if (declaringStoreObject == storeObject)
-                                {
-                                    tableFound = true;
-                                    break;
-                                }
+                                queue.Enqueue(containingType);
+                                continue;
                             }
-                        }
 
-                        if (!tableFound)
-                        {
-                            return null;
-                        }
-                    }
-                    else
-                    {
-                        var fragments = property.DeclaringType.GetMappingFragments(storeObject.StoreObjectType).ToList();
-                        if (fragments.Count > 0)
-                        {
-                            if (overrides == null
-                                && (declaringStoreObject != storeObject
-                                    || fragments.Any(f => property.FindOverrides(f.StoreObject) != null)))
+                            if (declaringStoreObject == storeObject)
                             {
-                                return null;
+                                tableFound = true;
+                                break;
                             }
                         }
-                        else if (declaringStoreObject != storeObject)
+                    }
+
+                    if (!tableFound)
+                    {
+                        return false;
+                    }
+                }
+                else
+                {
+                    var fragments = property.DeclaringType.GetMappingFragments(storeObject.StoreObjectType).ToList();
+                    if (fragments.Count > 0)
+                    {
+                        if (property.FindOverrides(storeObject) == null
+                            && (declaringStoreObject != storeObject
+                                || fragments.Any(f => property.FindOverrides(f.StoreObject) != null)))
                         {
-                            return null;
+                            return false;
                         }
                     }
+                    else if (declaringStoreObject != storeObject)
+                    {
+                        return false;
+                    }
                 }
             }
-        }
 
-        var columnAnnotation = property.FindAnnotation(RelationalAnnotationNames.ColumnName);
-        if (columnAnnotation != null)
-        {
-            return (string?)columnAnnotation.Value;
+            return true;
         }
-
-        return GetDefaultColumnName(property, storeObject);
     }
 
     /// <summary>
diff --git a/src/EFCore.Relational/Metadata/Internal/RelationalEntityTypeExtensions.cs b/src/EFCore.Relational/Metadata/Internal/RelationalEntityTypeExtensions.cs
index e7bc003915..9e6364bc83 100644
--- a/src/EFCore.Relational/Metadata/Internal/RelationalEntityTypeExtensions.cs
+++ b/src/EFCore.Relational/Metadata/Internal/RelationalEntityTypeExtensions.cs
@@ -28,38 +28,46 @@ public static class RelationalEntityTypeExtensions
     public static IEnumerable<IForeignKey> FindDeclaredReferencingRowInternalForeignKeys(
         this IEntityType entityType,
         StoreObjectIdentifier storeObject)
+        => entityType.IsMappedToJson()
+            ? Enumerable.Empty<IForeignKey>()
+            : entityType.GetDeclaredReferencingForeignKeys().Where(fk => fk.IsRowInternal(storeObject));
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public static bool IsMainFragment(
+        this IReadOnlyTypeBase type,
+        StoreObjectIdentifier storeObject)
     {
-        if (entityType.IsMappedToJson())
+        var storeObjectType = storeObject.StoreObjectType;
+        var declaredStoreObject = StoreObjectIdentifier.Create(type, storeObjectType);
+        if (declaredStoreObject != null)
         {
-            yield break;
+            return storeObject == declaredStoreObject;
         }
 
-        foreach (var foreignKey in entityType.GetDeclaredReferencingForeignKeys())
+        if (storeObjectType is StoreObjectType.Function or StoreObjectType.SqlQuery)
         {
-            var dependentPrimaryKey = foreignKey.DeclaringEntityType.FindPrimaryKey();
-            if (dependentPrimaryKey == null)
-            {
-                yield break;
-            }
+            return false;
+        }
+
+        if (type is not IReadOnlyEntityType entityType)
+        {
+            return false;
+        }
 
-            if (!foreignKey.PrincipalKey.IsPrimaryKey()
-                || foreignKey.PrincipalEntityType.IsAssignableFrom(foreignKey.DeclaringEntityType)
-                || !foreignKey.Properties.SequenceEqual(dependentPrimaryKey.Properties)
-                || !IsMapped(foreignKey, storeObject))
+        foreach (var derivedType in entityType.GetDirectlyDerivedTypes())
+        {
+            if (IsMainFragment(derivedType, storeObject))
             {
-                continue;
+                return true;
             }
-
-            yield return foreignKey;
         }
 
-        static bool IsMapped(IReadOnlyForeignKey foreignKey, StoreObjectIdentifier storeObject)
-            => (StoreObjectIdentifier.Create(foreignKey.DeclaringEntityType, storeObject.StoreObjectType) == storeObject
-                    || foreignKey.DeclaringEntityType.GetMappingFragments(storeObject.StoreObjectType)
-                        .Any(f => f.StoreObject == storeObject))
-                && (StoreObjectIdentifier.Create(foreignKey.PrincipalEntityType, storeObject.StoreObjectType) == storeObject
-                    || foreignKey.PrincipalEntityType.GetMappingFragments(storeObject.StoreObjectType)
-                        .Any(f => f.StoreObject == storeObject));
+        return false;
     }
 
     /// <summary>
diff --git a/src/EFCore.Relational/Metadata/Internal/RelationalForeignKeyExtensions.cs b/src/EFCore.Relational/Metadata/Internal/RelationalForeignKeyExtensions.cs
index 590c6673f9..c0aa47110c 100644
--- a/src/EFCore.Relational/Metadata/Internal/RelationalForeignKeyExtensions.cs
+++ b/src/EFCore.Relational/Metadata/Internal/RelationalForeignKeyExtensions.cs
@@ -233,6 +233,20 @@ public static class RelationalForeignKeyExtensions
             return null;
         }
 
+        if (foreignKey.PrincipalEntityType.GetMappingStrategy() == RelationalAnnotationNames.TpcMappingStrategy
+            && foreignKey.PrincipalEntityType.GetDerivedTypes().Any(et => StoreObjectIdentifier.Create(et, StoreObjectType.Table) != null))
+        {
+            logger?.ForeignKeyTpcPrincipalWarning((IForeignKey)foreignKey);
+            return null;
+        }
+
+        if (storeObject == principalStoreObject
+            && propertyNames.SequenceEqual(principalPropertyNames))
+        {
+            // Redundant FK
+            return null;
+        }
+
         var rootForeignKey = foreignKey;
 
         // Limit traversal to avoid getting stuck in a cycle (validation will throw for these later)
@@ -274,35 +288,23 @@ public static class RelationalForeignKeyExtensions
             rootForeignKey = linkedForeignKey;
         }
 
-        if (foreignKey.PrincipalEntityType.GetMappingStrategy() == RelationalAnnotationNames.TpcMappingStrategy
-            && foreignKey.PrincipalEntityType.GetDerivedTypes().Any(et => StoreObjectIdentifier.Create(et, StoreObjectType.Table) != null))
-        {
-            logger?.ForeignKeyTpcPrincipalWarning((IForeignKey)foreignKey);
-            return null;
-        }
-
-        if (storeObject == principalStoreObject
-            && propertyNames.SequenceEqual(principalPropertyNames))
-        {
-            // Redundant FK
-            return null;
-        }
-
+        var onDependentMainFragment = foreignKey.DeclaringEntityType.IsMainFragment(storeObject);
+        var onPrincipalMainFragment = foreignKey.PrincipalEntityType.IsMainFragment(principalStoreObject);
         if (foreignKey.PrincipalKey.IsPrimaryKey()
             && foreignKey.DeclaringEntityType.FindPrimaryKey() is IKey pk
             && foreignKey.Properties.SequenceEqual(pk.Properties))
         {
             if (!foreignKey.PrincipalEntityType.IsAssignableFrom(foreignKey.DeclaringEntityType)
-                && (StoreObjectIdentifier.Create(foreignKey.DeclaringEntityType, StoreObjectType.Table) != storeObject
-                    || StoreObjectIdentifier.Create(foreignKey.PrincipalEntityType, StoreObjectType.Table) != principalStoreObject)
+                && (!onDependentMainFragment
+                    || !onPrincipalMainFragment)
                 && ShareAnyFragments(foreignKey.DeclaringEntityType, foreignKey.PrincipalEntityType))
             {
-                // Row-internal FK
+                // Only create table-sharing linking FKs between the main fragments
                 return null;
             }
 
             if (foreignKey.PrincipalEntityType == foreignKey.DeclaringEntityType
-                && StoreObjectIdentifier.Create(foreignKey.PrincipalEntityType, StoreObjectType.Table) != principalStoreObject)
+                && !onPrincipalMainFragment)
             {
                 // Only create entity-splitting linking FKs to the main fragment
                 return null;
@@ -310,12 +312,12 @@ public static class RelationalForeignKeyExtensions
         }
 
         if (foreignKey.DeclaringEntityType.GetMappingStrategy() == RelationalAnnotationNames.TptMappingStrategy
-            && StoreObjectIdentifier.Create(foreignKey.DeclaringEntityType, StoreObjectType.Table) != storeObject
+            && !onDependentMainFragment
             && foreignKey.DeclaringEntityType.FindPrimaryKey() is IKey primaryKey
             && foreignKey.Properties.SequenceEqual(primaryKey.Properties))
         {
             // The identifying FK constraint is needed to be created only on the table that corresponds
-            // to the declaring entity type
+            // to the least derived mapped entity type
             return null;
         }
 
@@ -331,10 +333,44 @@ public static class RelationalForeignKeyExtensions
         return Uniquifier.Truncate(baseName, foreignKey.DeclaringEntityType.Model.GetMaxIdentifierLength());
 
         static bool ShareAnyFragments(IReadOnlyEntityType entityType1, IReadOnlyEntityType entityType2)
-            => new[] { StoreObjectIdentifier.Create(entityType1, StoreObjectType.Table)!.Value }
-                .Concat(entityType1.GetMappingFragments(StoreObjectType.Table).Select(f => f.StoreObject))
-                .Intersect(
-                    new[] { StoreObjectIdentifier.Create(entityType2, StoreObjectType.Table)!.Value }
-                        .Concat(entityType2.GetMappingFragments(StoreObjectType.Table).Select(f => f.StoreObject))).Any();
+        {
+            var commonTables = GetMappedStoreObjects(entityType1, StoreObjectType.Table);
+            commonTables.IntersectWith(GetMappedStoreObjects(entityType2, StoreObjectType.Table));
+            return commonTables.Any();
+        }
+
+        static HashSet<StoreObjectIdentifier> GetMappedStoreObjects(
+            IReadOnlyTypeBase type,
+            StoreObjectType storeObjectType)
+            => AddMappedStoreObjects(type, storeObjectType, new HashSet<StoreObjectIdentifier>());
+
+        static HashSet<StoreObjectIdentifier> AddMappedStoreObjects(
+            IReadOnlyTypeBase type,
+            StoreObjectType storeObjectType,
+            HashSet<StoreObjectIdentifier> storeObjects)
+        {
+            var mainStoreObject = StoreObjectIdentifier.Create(type, storeObjectType);
+            if (mainStoreObject != null)
+            {
+                storeObjects.Add(mainStoreObject.Value);
+                storeObjects.UnionWith(type.GetMappingFragments(StoreObjectType.Table).Select(f => f.StoreObject));
+                return storeObjects;
+            }
+
+            if (storeObjectType is StoreObjectType.Function or StoreObjectType.SqlQuery)
+            {
+                return storeObjects;
+            }
+
+            if (type is IReadOnlyEntityType entityType)
+            {
+                foreach (var derivedType in entityType.GetDirectlyDerivedTypes())
+                {
+                    AddMappedStoreObjects(derivedType, storeObjectType, storeObjects);
+                }
+            }
+
+            return storeObjects;
+        }
     }
 }
diff --git a/src/EFCore.Relational/Update/Internal/CommandBatchPreparer.cs b/src/EFCore.Relational/Update/Internal/CommandBatchPreparer.cs
index 5461a3d863..aa65fe6afa 100644
--- a/src/EFCore.Relational/Update/Internal/CommandBatchPreparer.cs
+++ b/src/EFCore.Relational/Update/Internal/CommandBatchPreparer.cs
@@ -215,58 +215,33 @@ public CommandBatchPreparer(CommandBatchPreparerDependencies dependencies)
                 continue;
             }
 
-            var foundMapping = false;
+            using var sharedIdentityTableMappings =
+                entry.SharedIdentityEntry != null
+                    && entry.SharedIdentityEntry.EntityState == EntityState.Deleted
+                    ? entry.SharedIdentityEntry.EntityType.GetTableMappings().GetEnumerator()
+                    : null;
 
+            var foundMapping = false;
             foreach (var tableMapping in entry.EntityType.GetTableMappings())
             {
-                var sprocMapping = entry.EntityState switch
-                {
-                    EntityState.Added => tableMapping.InsertStoredProcedureMapping,
-                    EntityState.Modified => tableMapping.UpdateStoredProcedureMapping,
-                    EntityState.Deleted => tableMapping.DeleteStoredProcedureMapping,
-
-                    _ => throw new ArgumentOutOfRangeException("Unexpected entry.EntityState: " + entry.EntityState)
-                };
-
-                var table = tableMapping.Table;
-
-                IModificationCommand command;
-                var isMainEntry = true;
-                if (table.IsShared)
+                if (sharedIdentityTableMappings != null
+                    && sharedIdentityTableMappings.MoveNext()
+                    && sharedIdentityTableMappings.Current.Table != tableMapping.Table)
                 {
-                    Check.DebugAssert(sprocMapping is null, "Shared table with sproc mapping");
-
-                    sharedTablesCommandsMap ??= new Dictionary<(string Name, string? Schema), SharedTableEntryMap<IModificationCommand>>();
-
-                    var tableKey = (table.Name, table.Schema);
-                    if (!sharedTablesCommandsMap.TryGetValue(tableKey, out var sharedCommandsMap))
-                    {
-                        sharedCommandsMap = new SharedTableEntryMap<IModificationCommand>(table, updateAdapter);
-                        sharedTablesCommandsMap.Add(tableKey, sharedCommandsMap);
-                    }
-
-                    command = sharedCommandsMap.GetOrAddValue(
-                        entry,
-                        (t, comparer) => Dependencies.ModificationCommandFactory.CreateModificationCommand(
-                            new ModificationCommandParameters(
-                                t, _sensitiveLoggingEnabled, _detailedErrorsEnabled, comparer, generateParameterName,
-                                Dependencies.UpdateLogger)));
-                    isMainEntry = sharedCommandsMap.IsMainEntry(entry);
-                }
-                else
-                {
-                    command = Dependencies.ModificationCommandFactory.CreateModificationCommand(
-                        new ModificationCommandParameters(
-                            table, sprocMapping?.StoreStoredProcedure, _sensitiveLoggingEnabled, _detailedErrorsEnabled,
-                            comparer: null, generateParameterName, Dependencies.UpdateLogger));
+                    ProcessEntry(entry.SharedIdentityEntry!, sharedIdentityTableMappings.Current, commands, updateAdapter, generateParameterName, ref sharedTablesCommandsMap);
                 }
 
-                command.AddEntry(entry, isMainEntry);
-                commands.Add(command);
+                ProcessEntry(entry, tableMapping, commands, updateAdapter, generateParameterName, ref sharedTablesCommandsMap);
 
                 foundMapping = true;
             }
 
+            while (sharedIdentityTableMappings != null
+                    && sharedIdentityTableMappings.MoveNext())
+            {
+                ProcessEntry(entry.SharedIdentityEntry!, sharedIdentityTableMappings.Current, commands, updateAdapter, generateParameterName, ref sharedTablesCommandsMap);
+            }
+
             if (!foundMapping)
             {
                 throw new InvalidOperationException(RelationalStrings.ReadonlyEntitySaved(entry.EntityType.DisplayName()));
@@ -279,6 +254,60 @@ public CommandBatchPreparer(CommandBatchPreparerDependencies dependencies)
         }
 
         return commands;
+
+        void ProcessEntry(
+            IUpdateEntry entry,
+            ITableMapping tableMapping,
+            List<IModificationCommand> commands,
+            IUpdateAdapter updateAdapter,
+            Func<string> generateParameterName,
+            ref Dictionary<(string Name, string? Schema), SharedTableEntryMap<IModificationCommand>>? sharedTablesCommandsMap)
+        {
+            var sprocMapping = entry.EntityState switch
+            {
+                EntityState.Added => tableMapping.InsertStoredProcedureMapping,
+                EntityState.Modified => tableMapping.UpdateStoredProcedureMapping,
+                EntityState.Deleted => tableMapping.DeleteStoredProcedureMapping,
+
+                _ => throw new ArgumentOutOfRangeException("Unexpected entry.EntityState: " + entry.EntityState)
+            };
+
+            var table = tableMapping.Table;
+
+            IModificationCommand command;
+            var isMainEntry = true;
+            if (table.IsShared)
+            {
+                Check.DebugAssert(sprocMapping is null, "Shared table with sproc mapping");
+
+                sharedTablesCommandsMap ??= new Dictionary<(string Name, string? Schema), SharedTableEntryMap<IModificationCommand>>();
+
+                var tableKey = (table.Name, table.Schema);
+                if (!sharedTablesCommandsMap.TryGetValue(tableKey, out var sharedCommandsMap))
+                {
+                    sharedCommandsMap = new SharedTableEntryMap<IModificationCommand>(table, updateAdapter);
+                    sharedTablesCommandsMap.Add(tableKey, sharedCommandsMap);
+                }
+
+                command = sharedCommandsMap.GetOrAddValue(
+                    entry,
+                    (t, comparer) => Dependencies.ModificationCommandFactory.CreateModificationCommand(
+                        new ModificationCommandParameters(
+                            t, _sensitiveLoggingEnabled, _detailedErrorsEnabled, comparer, generateParameterName,
+                            Dependencies.UpdateLogger)));
+                isMainEntry = sharedCommandsMap.IsMainEntry(entry);
+            }
+            else
+            {
+                command = Dependencies.ModificationCommandFactory.CreateModificationCommand(
+                    new ModificationCommandParameters(
+                        table, sprocMapping?.StoreStoredProcedure, _sensitiveLoggingEnabled, _detailedErrorsEnabled,
+                        comparer: null, generateParameterName, Dependencies.UpdateLogger));
+            }
+
+            command.AddEntry(entry, isMainEntry);
+            commands.Add(command);
+        }
     }
 
     private static void AddUnchangedSharingEntries(
diff --git a/src/EFCore/Metadata/Internal/PropertyListComparer.cs b/src/EFCore/Metadata/Internal/PropertyListComparer.cs
index 290308c6f2..c886631555 100644
--- a/src/EFCore/Metadata/Internal/PropertyListComparer.cs
+++ b/src/EFCore/Metadata/Internal/PropertyListComparer.cs
@@ -86,7 +86,7 @@ public int GetHashCode(IReadOnlyList<IReadOnlyProperty> obj)
         var hash = new HashCode();
         for (var i = 0; i < obj.Count; i++)
         {
-            hash.Add(obj[i]);
+            hash.Add(obj[i].Name);
         }
 
         return hash.ToHashCode();
diff --git a/test/EFCore.SqlServer.FunctionalTests/UpdatesSqlServerTPCTest.cs b/test/EFCore.SqlServer.FunctionalTests/UpdatesSqlServerTPCTest.cs
index b234e3da84..6a30451d9f 100644
--- a/test/EFCore.SqlServer.FunctionalTests/UpdatesSqlServerTPCTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/UpdatesSqlServerTPCTest.cs
@@ -110,7 +110,7 @@ protected override void OnModelCreating(ModelBuilder modelBuilder, DbContext con
             base.OnModelCreating(modelBuilder, context);
 
             modelBuilder.Entity<Category>().UseTpcMappingStrategy();
-            // modelBuilder.Entity<GiftObscurer>().UseTpcMappingStrategy(); Issue #29874
+            modelBuilder.Entity<GiftObscurer>().UseTpcMappingStrategy();
             modelBuilder.Entity<LiftObscurer>().UseTpcMappingStrategy();
         }
     }
diff --git a/test/EFCore.SqlServer.FunctionalTests/UpdatesSqlServerTPTTest.cs b/test/EFCore.SqlServer.FunctionalTests/UpdatesSqlServerTPTTest.cs
index 9756e302a2..b06c3a8e31 100644
--- a/test/EFCore.SqlServer.FunctionalTests/UpdatesSqlServerTPTTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/UpdatesSqlServerTPTTest.cs
@@ -14,10 +14,6 @@ public UpdatesSqlServerTPTTest(UpdatesSqlServerTPTFixture fixture, ITestOutputHe
     {
     }
 
-    [ConditionalTheory(Skip = "Issue #29874. Skipped because the database is in a bad state, but the test may or may not fail.")]
-    public override Task Can_change_type_of_pk_to_pk_dependent_by_replacing_with_new_dependent(bool async)
-        => Task.CompletedTask;
-
     public override void Save_with_shared_foreign_key()
     {
         base.Save_with_shared_foreign_key();
