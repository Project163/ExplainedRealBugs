diff --git a/src/EFCore.SqlServer/Infrastructure/Internal/ISqlServerSingletonOptions.cs b/src/EFCore.SqlServer/Infrastructure/Internal/ISqlServerSingletonOptions.cs
index d5bee2ee72..1f96dec0eb 100644
--- a/src/EFCore.SqlServer/Infrastructure/Internal/ISqlServerSingletonOptions.cs
+++ b/src/EFCore.SqlServer/Infrastructure/Internal/ISqlServerSingletonOptions.cs
@@ -50,4 +50,12 @@ public interface ISqlServerSingletonOptions : ISingletonOptions
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
     public bool SupportsJsonFunctions { get; }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public bool SupportsJsonType { get; }
 }
diff --git a/src/EFCore.SqlServer/Infrastructure/Internal/SqlServerSingletonOptions.cs b/src/EFCore.SqlServer/Infrastructure/Internal/SqlServerSingletonOptions.cs
index 9e572d824c..98c5f8727e 100644
--- a/src/EFCore.SqlServer/Infrastructure/Internal/SqlServerSingletonOptions.cs
+++ b/src/EFCore.SqlServer/Infrastructure/Internal/SqlServerSingletonOptions.cs
@@ -50,12 +50,31 @@ public class SqlServerSingletonOptions : ISqlServerSingletonOptions
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    public virtual bool SupportsJsonFunctions =>
-        (EngineType == SqlServerEngineType.SqlServer && SqlServerCompatibilityLevel >= 130)
-        ||
-        (EngineType == SqlServerEngineType.AzureSql && AzureSqlCompatibilityLevel >= 130)
-        ||
-        (EngineType == SqlServerEngineType.AzureSynapse);
+    public virtual bool SupportsJsonFunctions
+        => EngineType switch
+        {
+            SqlServerEngineType.SqlServer => SqlServerCompatibilityLevel >= 130,
+            SqlServerEngineType.AzureSql => AzureSqlCompatibilityLevel >= 130,
+            SqlServerEngineType.AzureSynapse => true,
+            SqlServerEngineType.Unknown => false, // TODO: We shouldn't observe Unknown here, #36477
+            _ => throw new UnreachableException()
+        };
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual bool SupportsJsonType
+        => EngineType switch
+        {
+            SqlServerEngineType.SqlServer => SqlServerCompatibilityLevel >= 170,
+            SqlServerEngineType.AzureSql => AzureSqlCompatibilityLevel >= 170,
+            SqlServerEngineType.AzureSynapse => false,
+            SqlServerEngineType.Unknown => false, // TODO: We shouldn't observe Unknown here, #36477
+            _ => throw new UnreachableException()
+        };
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
diff --git a/src/EFCore.SqlServer/Query/Internal/SqlServerJsonPostprocessor.cs b/src/EFCore.SqlServer/Query/Internal/SqlServerJsonPostprocessor.cs
index 57e9ad1a36..3c155b6213 100644
--- a/src/EFCore.SqlServer/Query/Internal/SqlServerJsonPostprocessor.cs
+++ b/src/EFCore.SqlServer/Query/Internal/SqlServerJsonPostprocessor.cs
@@ -218,6 +218,9 @@ public Expression Process(Expression expression)
                     jsonScalarExpression.IsNullable);
             }
 
+            // TODO: With the new RETURNING clause the following should not longer be needed - but support for varbinary
+            // isn't there yet. See #36474.
+
             // Some SQL Server types cannot be reliably parsed with JSON_VALUE(): binary/varbinary are encoded in base64 in the JSON,
             // but JSON_VALUE() returns a string and there's no SQL Server function to parse base64. However, OPENJSON/WITH does do base64
             // decoding.
diff --git a/src/EFCore.SqlServer/Query/Internal/SqlServerQuerySqlGenerator.cs b/src/EFCore.SqlServer/Query/Internal/SqlServerQuerySqlGenerator.cs
index fe67d7b285..15dae0ff73 100644
--- a/src/EFCore.SqlServer/Query/Internal/SqlServerQuerySqlGenerator.cs
+++ b/src/EFCore.SqlServer/Query/Internal/SqlServerQuerySqlGenerator.cs
@@ -522,26 +522,58 @@ protected override Expression VisitJsonScalar(JsonScalarExpression jsonScalarExp
             return jsonScalarExpression;
         }
 
-        if (jsonScalarExpression.TypeMapping is SqlServerStructuralJsonTypeMapping
-            || jsonScalarExpression.TypeMapping?.ElementTypeMapping is not null)
+        // Hack: we currently use JsonScalarExpression to represent both JSON_VALUE and JSON_QUERY in the SQL tree
+        // (see #36392), so we need to differentiate between the two here.
+        // We use JSON_QUERY() to project out sub-documents, so either when the result is a structural type,
+        // or when it is a primitive collection (array).
+        var jsonQuery = jsonScalarExpression.TypeMapping is SqlServerStructuralJsonTypeMapping
+            || jsonScalarExpression.TypeMapping?.ElementTypeMapping is not null;
+
+        // SQL Server 2025 introduced the RETURNING clause for JSON_VALUE: JSON_VALUE(json, '$.foo' RETURNING int).
+        // This is better than adding a cast, as this:
+        // 1. Allows us to get the desired type directly (potentially more efficient, possibly index usage too)
+        // 2. Supports big strings (otherwise JSON_VALUE always returns nvarchar(4000))
+        // 3. Can do JSON-specific decoding (e.g. base64 for varbinary)
+        // Note that RETURNING is only (currently) supported over the json type (not nvarchar(max)).
+        // Note that we don't need to check the compatibility level - if the json type is being used, then RETURNING is supported.
+        var useJsonValueReturningClause = !jsonQuery && jsonScalarExpression.Json.TypeMapping?.StoreType is "json"
+            // Temporarily disabling for Azure SQL, which doesn't yet support RETURNING; this should get removed for 10 (see #36460).
+            && _sqlServerSingletonOptions.EngineType is not SqlServerEngineType.AzureSql;
+
+        // For JSON_VALUE(), if we can use the RETURNING clause, always do that.
+        // Otherwise, JSON_VALUE always returns nvarchar(4000) (https://learn.microsoft.com/sql/t-sql/functions/json-value-transact-sql),
+        // so we cast the result to the expected type - except if it's a string (since the cast interferes with indexes over
+        // the JSON property).
+        var useWrappingCast = !jsonQuery && !useJsonValueReturningClause && jsonScalarExpression.TypeMapping is not StringTypeMapping;
+
+        if (jsonQuery)
         {
             Sql.Append("JSON_QUERY(");
         }
         else
         {
-            // JSON_VALUE always returns nvarchar(4000) (https://learn.microsoft.com/sql/t-sql/functions/json-value-transact-sql),
-            // so we cast the result to the expected type - except if it's a string (since the cast interferes with indexes over
-            // the JSON property).
-            Sql.Append(jsonScalarExpression.TypeMapping is StringTypeMapping ? "JSON_VALUE(" : "CAST(JSON_VALUE(");
+            if (useWrappingCast)
+            {
+                Sql.Append("CAST(");
+            }
+
+            Sql.Append("JSON_VALUE(");
         }
 
         Visit(jsonScalarExpression.Json);
 
         Sql.Append(", ");
         GenerateJsonPath(jsonScalarExpression.Path);
+
+        if (useJsonValueReturningClause)
+        {
+            Sql.Append(" RETURNING ");
+            Sql.Append(jsonScalarExpression.TypeMapping!.StoreType);
+        }
+
         Sql.Append(")");
 
-        if (jsonScalarExpression.TypeMapping is not SqlServerStructuralJsonTypeMapping and not StringTypeMapping)
+        if (useWrappingCast)
         {
             Sql.Append(" AS ");
             Sql.Append(jsonScalarExpression.TypeMapping!.StoreType);
diff --git a/src/EFCore.SqlServer/Storage/Internal/SqlServerTypeMappingSource.cs b/src/EFCore.SqlServer/Storage/Internal/SqlServerTypeMappingSource.cs
index 18dc0254bf..2449906081 100644
--- a/src/EFCore.SqlServer/Storage/Internal/SqlServerTypeMappingSource.cs
+++ b/src/EFCore.SqlServer/Storage/Internal/SqlServerTypeMappingSource.cs
@@ -217,13 +217,7 @@ static SqlServerTypeMappingSource()
         // ReSharper restore CoVariantArrayConversion
     }
 
-    private readonly bool _isJsonTypeSupported = sqlServerSingletonOptions.EngineType switch
-    {
-        SqlServerEngineType.SqlServer => sqlServerSingletonOptions.SqlServerCompatibilityLevel >= 170,
-        SqlServerEngineType.AzureSql => sqlServerSingletonOptions.AzureSqlCompatibilityLevel >= 170,
-        SqlServerEngineType.AzureSynapse => false,
-        _ => false
-    };
+    private readonly bool _isJsonTypeSupported = sqlServerSingletonOptions.SupportsJsonType;
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
diff --git a/test/EFCore.SqlServer.FunctionalTests/Query/Relationships/ComplexJson/ComplexJsonCollectionSqlServerTest.cs b/test/EFCore.SqlServer.FunctionalTests/Query/Relationships/ComplexJson/ComplexJsonCollectionSqlServerTest.cs
index b79021e995..1d2639b677 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Query/Relationships/ComplexJson/ComplexJsonCollectionSqlServerTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Query/Relationships/ComplexJson/ComplexJsonCollectionSqlServerTest.cs
@@ -124,12 +124,24 @@ public override async Task Index_constant()
         // ElementAt (making a Select()), this interferes with our translation. See #36335.
         await Assert.ThrowsAsync<EqualException>(() => base.Index_constant());
 
-        AssertSql(
-            """
+        if (Fixture.UsingJsonType)
+        {
+            AssertSql(
+                """
+SELECT [r].[Id], [r].[Name], [r].[OptionalRelated], [r].[RelatedCollection], [r].[RequiredRelated]
+FROM [RootEntity] AS [r]
+WHERE JSON_VALUE([r].[RelatedCollection], '$[0]' RETURNING int) = 8
+""");
+        }
+        else
+        {
+            AssertSql(
+                """
 SELECT [r].[Id], [r].[Name], [r].[OptionalRelated], [r].[RelatedCollection], [r].[RequiredRelated]
 FROM [RootEntity] AS [r]
 WHERE CAST(JSON_VALUE([r].[RelatedCollection], '$[0]') AS int) = 8
 """);
+        }
     }
 
     public override async Task Index_parameter()
@@ -138,14 +150,28 @@ public override async Task Index_parameter()
         // ElementAt (making a Select()), this interferes with our translation. See #36335.
         await Assert.ThrowsAsync<EqualException>(() => base.Index_parameter());
 
-        AssertSql(
-            """
+        if (Fixture.UsingJsonType)
+        {
+            AssertSql(
+                 """
+@i='?' (DbType = Int32)
+
+SELECT [r].[Id], [r].[Name], [r].[OptionalRelated], [r].[RelatedCollection], [r].[RequiredRelated]
+FROM [RootEntity] AS [r]
+WHERE JSON_VALUE([r].[RelatedCollection], '$[' + CAST(@i AS nvarchar(max)) + ']' RETURNING int) = 8
+""");
+        }
+        else
+        {
+           AssertSql(
+               """
 @i='?' (DbType = Int32)
 
 SELECT [r].[Id], [r].[Name], [r].[OptionalRelated], [r].[RelatedCollection], [r].[RequiredRelated]
 FROM [RootEntity] AS [r]
 WHERE CAST(JSON_VALUE([r].[RelatedCollection], '$[' + CAST(@i AS nvarchar(max)) + ']') AS int) = 8
 """);
+        }
     }
 
     public override async Task Index_column()
@@ -154,24 +180,48 @@ public override async Task Index_column()
         // ElementAt (making a Select()), this interferes with our translation. See #36335.
         await Assert.ThrowsAsync<EqualException>(() => base.Index_column());
 
-        AssertSql(
-            """
+        if (Fixture.UsingJsonType)
+        {
+            AssertSql(
+                """
+SELECT [r].[Id], [r].[Name], [r].[OptionalRelated], [r].[RelatedCollection], [r].[RequiredRelated]
+FROM [RootEntity] AS [r]
+WHERE JSON_VALUE([r].[RelatedCollection], '$[' + CAST([r].[Id] - 1 AS nvarchar(max)) + ']' RETURNING int) = 8
+""");
+        }
+        else
+        {
+            AssertSql(
+                """
 SELECT [r].[Id], [r].[Name], [r].[OptionalRelated], [r].[RelatedCollection], [r].[RequiredRelated]
 FROM [RootEntity] AS [r]
 WHERE CAST(JSON_VALUE([r].[RelatedCollection], '$[' + CAST([r].[Id] - 1 AS nvarchar(max)) + ']') AS int) = 8
 """);
+        }
     }
 
     public override async Task Index_out_of_bounds()
     {
         await base.Index_out_of_bounds();
 
-        AssertSql(
-            """
+        if (Fixture.UsingJsonType)
+        {
+            AssertSql(
+                """
+SELECT [r].[Id], [r].[Name], [r].[OptionalRelated], [r].[RelatedCollection], [r].[RequiredRelated]
+FROM [RootEntity] AS [r]
+WHERE JSON_VALUE([r].[RelatedCollection], '$[9999]' RETURNING int) = 8
+""");
+        }
+        else
+        {
+            AssertSql(
+                """
 SELECT [r].[Id], [r].[Name], [r].[OptionalRelated], [r].[RelatedCollection], [r].[RequiredRelated]
 FROM [RootEntity] AS [r]
 WHERE CAST(JSON_VALUE([r].[RelatedCollection], '$[9999]') AS int) = 8
 """);
+        }
     }
 
     #endregion Index
diff --git a/test/EFCore.SqlServer.FunctionalTests/Query/Relationships/ComplexJson/ComplexJsonMiscellaneousSqlServerTest.cs b/test/EFCore.SqlServer.FunctionalTests/Query/Relationships/ComplexJson/ComplexJsonMiscellaneousSqlServerTest.cs
index a2cf1d47fe..ed47de5230 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Query/Relationships/ComplexJson/ComplexJsonMiscellaneousSqlServerTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Query/Relationships/ComplexJson/ComplexJsonMiscellaneousSqlServerTest.cs
@@ -12,36 +12,72 @@ public override async Task Where_related_property()
     {
         await base.Where_related_property();
 
-        AssertSql(
-            """
+        if (Fixture.UsingJsonType)
+        {
+            AssertSql(
+                """
+SELECT [r].[Id], [r].[Name], [r].[OptionalRelated], [r].[RelatedCollection], [r].[RequiredRelated]
+FROM [RootEntity] AS [r]
+WHERE JSON_VALUE([r].[RequiredRelated], '$.Int' RETURNING int) = 8
+""");
+        }
+        else
+        {
+           AssertSql(
+                """
 SELECT [r].[Id], [r].[Name], [r].[OptionalRelated], [r].[RelatedCollection], [r].[RequiredRelated]
 FROM [RootEntity] AS [r]
 WHERE CAST(JSON_VALUE([r].[RequiredRelated], '$.Int') AS int) = 8
 """);
+        }
     }
 
     public override async Task Where_optional_related_property()
     {
         await base.Where_optional_related_property();
 
-        AssertSql(
-            """
+        if (Fixture.UsingJsonType)
+        {
+            AssertSql(
+                """
+SELECT [r].[Id], [r].[Name], [r].[OptionalRelated], [r].[RelatedCollection], [r].[RequiredRelated]
+FROM [RootEntity] AS [r]
+WHERE JSON_VALUE([r].[OptionalRelated], '$.Int' RETURNING int) = 8
+""");
+        }
+        else
+        {
+            AssertSql(
+                """
 SELECT [r].[Id], [r].[Name], [r].[OptionalRelated], [r].[RelatedCollection], [r].[RequiredRelated]
 FROM [RootEntity] AS [r]
 WHERE CAST(JSON_VALUE([r].[OptionalRelated], '$.Int') AS int) = 8
 """);
+        }
     }
 
     public override async Task Where_nested_related_property()
     {
         await base.Where_nested_related_property();
 
-        AssertSql(
-            """
+        if (Fixture.UsingJsonType)
+        {
+            AssertSql(
+                """
+SELECT [r].[Id], [r].[Name], [r].[OptionalRelated], [r].[RelatedCollection], [r].[RequiredRelated]
+FROM [RootEntity] AS [r]
+WHERE JSON_VALUE([r].[RequiredRelated], '$.RequiredNested.Int' RETURNING int) = 8
+""");
+        }
+        else
+        {
+            AssertSql(
+                """
 SELECT [r].[Id], [r].[Name], [r].[OptionalRelated], [r].[RelatedCollection], [r].[RequiredRelated]
 FROM [RootEntity] AS [r]
 WHERE CAST(JSON_VALUE([r].[RequiredRelated], '$.RequiredNested.Int') AS int) = 8
 """);
+        }
     }
 
     #endregion Simple filters
diff --git a/test/EFCore.SqlServer.FunctionalTests/Query/Relationships/ComplexJson/ComplexJsonProjectionSqlServerTest.cs b/test/EFCore.SqlServer.FunctionalTests/Query/Relationships/ComplexJson/ComplexJsonProjectionSqlServerTest.cs
index bae189c2dd..fcb5ec2720 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Query/Relationships/ComplexJson/ComplexJsonProjectionSqlServerTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Query/Relationships/ComplexJson/ComplexJsonProjectionSqlServerTest.cs
@@ -23,44 +23,88 @@ public override async Task Select_property_on_required_related(QueryTrackingBeha
     {
         await base.Select_property_on_required_related(queryTrackingBehavior);
 
-        AssertSql(
-            """
+        if (Fixture.UsingJsonType)
+        {
+            AssertSql(
+                """
+SELECT JSON_VALUE([r].[RequiredRelated], '$.String' RETURNING nvarchar(max))
+FROM [RootEntity] AS [r]
+""");
+        }
+        else
+        {
+            AssertSql(
+                """
 SELECT JSON_VALUE([r].[RequiredRelated], '$.String')
 FROM [RootEntity] AS [r]
 """);
+        }
     }
 
     public override async Task Select_property_on_optional_related(QueryTrackingBehavior queryTrackingBehavior)
     {
         await base.Select_property_on_optional_related(queryTrackingBehavior);
 
-        AssertSql(
-            """
+        if (Fixture.UsingJsonType)
+        {
+            AssertSql(
+                """
+SELECT JSON_VALUE([r].[OptionalRelated], '$.String' RETURNING nvarchar(max))
+FROM [RootEntity] AS [r]
+""");
+        }
+        else
+        {
+            AssertSql(
+                """
 SELECT JSON_VALUE([r].[OptionalRelated], '$.String')
 FROM [RootEntity] AS [r]
 """);
+        }
     }
 
     public override async Task Select_value_type_property_on_null_related_throws(QueryTrackingBehavior queryTrackingBehavior)
     {
         await base.Select_value_type_property_on_null_related_throws(queryTrackingBehavior);
 
-        AssertSql(
-            """
+        if (Fixture.UsingJsonType)
+        {
+            AssertSql(
+                """
+SELECT JSON_VALUE([r].[OptionalRelated], '$.Int' RETURNING int)
+FROM [RootEntity] AS [r]
+""");
+        }
+        else
+        {
+            AssertSql(
+                """
 SELECT CAST(JSON_VALUE([r].[OptionalRelated], '$.Int') AS int)
 FROM [RootEntity] AS [r]
 """);
+        }
     }
 
     public override async Task Select_nullable_value_type_property_on_null_related(QueryTrackingBehavior queryTrackingBehavior)
     {
         await base.Select_nullable_value_type_property_on_null_related(queryTrackingBehavior);
 
-        AssertSql(
-            """
+        if (Fixture.UsingJsonType)
+        {
+            AssertSql(
+                """
+SELECT JSON_VALUE([r].[OptionalRelated], '$.Int' RETURNING int)
+FROM [RootEntity] AS [r]
+""");
+        }
+        else
+        {
+            AssertSql(
+                """
 SELECT CAST(JSON_VALUE([r].[OptionalRelated], '$.Int') AS int)
 FROM [RootEntity] AS [r]
 """);
+        }
     }
 
     #endregion Simple properties
diff --git a/test/EFCore.SqlServer.FunctionalTests/Query/Relationships/ComplexJson/ComplexJsonSqlServerFixture.cs b/test/EFCore.SqlServer.FunctionalTests/Query/Relationships/ComplexJson/ComplexJsonSqlServerFixture.cs
index b3a12a2f4a..875d699b38 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Query/Relationships/ComplexJson/ComplexJsonSqlServerFixture.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Query/Relationships/ComplexJson/ComplexJsonSqlServerFixture.cs
@@ -10,7 +10,7 @@ protected override ITestStoreFactory TestStoreFactory
 
     // When testing against SQL Server 2025 or later, set the compatibility level to 170 to use the json type instead of nvarchar(max).
     public override DbContextOptionsBuilder AddOptions(DbContextOptionsBuilder builder)
-        => UsingJsonType
+        => TestEnvironment.SqlServerMajorVersion >= 17
             ? builder.UseSqlServer(o => o.UseCompatibilityLevel(170))
             : builder;
 
