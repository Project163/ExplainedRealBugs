diff --git a/EFCore.Relational.slnf b/EFCore.Relational.slnf
index 1021d7668e..d62c17dfd8 100644
--- a/EFCore.Relational.slnf
+++ b/EFCore.Relational.slnf
@@ -8,6 +8,8 @@
       "src\\EFCore.InMemory\\EFCore.InMemory.csproj",
       "src\\EFCore.Proxies\\EFCore.Proxies.csproj",
       "src\\EFCore.Relational\\EFCore.Relational.csproj",
+      "src\\EFCore.SqlServer.Abstractions\\EFCore.SqlServer.Abstractions.csproj",
+      "src\\EFCore.SqlServer.HierarchyId\\EFCore.SqlServer.HierarchyId.csproj",
       "src\\EFCore.SqlServer.NTS\\EFCore.SqlServer.NTS.csproj",
       "src\\EFCore.SqlServer\\EFCore.SqlServer.csproj",
       "src\\EFCore.Sqlite.Core\\EFCore.Sqlite.Core.csproj",
@@ -22,12 +24,13 @@
       "test\\EFCore.Design.Tests\\EFCore.Design.Tests.csproj",
       "test\\EFCore.InMemory.FunctionalTests\\EFCore.InMemory.FunctionalTests.csproj",
       "test\\EFCore.InMemory.Tests\\EFCore.InMemory.Tests.csproj",
-      "test\\EFCore.OData.FunctionalTests\\EFCore.OData.FunctionalTests.csproj",	  
+      "test\\EFCore.OData.FunctionalTests\\EFCore.OData.FunctionalTests.csproj",
       "test\\EFCore.Proxies.Tests\\EFCore.Proxies.Tests.csproj",
       "test\\EFCore.Relational.Specification.Tests\\EFCore.Relational.Specification.Tests.csproj",
       "test\\EFCore.Relational.Tests\\EFCore.Relational.Tests.csproj",
       "test\\EFCore.Specification.Tests\\EFCore.Specification.Tests.csproj",
       "test\\EFCore.SqlServer.FunctionalTests\\EFCore.SqlServer.FunctionalTests.csproj",
+      "test\\EFCore.SqlServer.HierarchyId.Tests\\EFCore.SqlServer.HierarchyId.Tests.csproj",
       "test\\EFCore.SqlServer.Tests\\EFCore.SqlServer.Tests.csproj",
       "test\\EFCore.Sqlite.FunctionalTests\\EFCore.Sqlite.FunctionalTests.csproj",
       "test\\EFCore.Sqlite.Tests\\EFCore.Sqlite.Tests.csproj",
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index 4e18c22f89..c6dc8fd67d 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -37,6 +37,10 @@
       <Uri>https://github.com/dotnet/runtime</Uri>
       <Sha>5b71f85ee12fd60b00502bc2c201f6fa7d1f5963</Sha>
     </Dependency>
+    <Dependency Name="System.Text.Json" Version="8.0.0-preview.3.23170.1">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha>5b71f85ee12fd60b00502bc2c201f6fa7d1f5963</Sha>
+    </Dependency>
   </ProductDependencies>
   <ToolsetDependencies>
     <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="8.0.0-beta.23168.1">
diff --git a/eng/Versions.props b/eng/Versions.props
index b6e00d6296..6f8866c299 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -24,6 +24,7 @@
     <MicrosoftExtensionsDependencyModelVersion>8.0.0-preview.3.23170.1</MicrosoftExtensionsDependencyModelVersion>
     <MicrosoftExtensionsHostFactoryResolverSourcesVersion>8.0.0-preview.3.23170.1</MicrosoftExtensionsHostFactoryResolverSourcesVersion>
     <MicrosoftExtensionsLoggingVersion>8.0.0-preview.3.23170.1</MicrosoftExtensionsLoggingVersion>
+    <SystemTextJsonVersion>8.0.0-preview.3.23170.1</SystemTextJsonVersion>
   </PropertyGroup>
   <PropertyGroup Label="Dependencies from dotnet/arcade">
     <MicrosoftDotNetBuildTasksTemplatingVersion>8.0.0-beta.23168.1</MicrosoftDotNetBuildTasksTemplatingVersion>
diff --git a/src/EFCore.Design/Design/Internal/CSharpHelper.cs b/src/EFCore.Design/Design/Internal/CSharpHelper.cs
index 9f32a8ac4f..09a87702ad 100644
--- a/src/EFCore.Design/Design/Internal/CSharpHelper.cs
+++ b/src/EFCore.Design/Design/Internal/CSharpHelper.cs
@@ -1077,12 +1077,18 @@ private bool HandleExpression(Expression expression, StringBuilder builder, bool
 
                 return true;
             case ExpressionType.Convert:
-                builder
-                    .Append('(')
-                    .Append(Reference(expression.Type, fullName: true))
-                    .Append(')');
+            {
+                var unaryExpression = (UnaryExpression)expression;
+                if (unaryExpression.Method?.Name != "op_Implicit")
+                {
+                    builder
+                        .Append('(')
+                        .Append(Reference(expression.Type, fullName: true))
+                        .Append(')');
+                }
 
-                return HandleExpression(((UnaryExpression)expression).Operand, builder);
+                return HandleExpression(unaryExpression.Operand, builder);
+            }
             case ExpressionType.New:
                 builder
                     .Append("new ")
diff --git a/src/EFCore.SqlServer.Abstractions/EFCore.SqlServer.Abstractions.csproj b/src/EFCore.SqlServer.Abstractions/EFCore.SqlServer.Abstractions.csproj
index a62ea8f849..0a63e98053 100644
--- a/src/EFCore.SqlServer.Abstractions/EFCore.SqlServer.Abstractions.csproj
+++ b/src/EFCore.SqlServer.Abstractions/EFCore.SqlServer.Abstractions.csproj
@@ -1,4 +1,4 @@
-<Project Sdk="Microsoft.NET.Sdk">
+﻿<Project Sdk="Microsoft.NET.Sdk">
 
   <PropertyGroup>
     <TargetFramework>netstandard2.1</TargetFramework>
@@ -17,6 +17,7 @@
 
   <ItemGroup>
     <PackageReference Include="Microsoft.SqlServer.Types" Version="160.1000.6" />
+    <PackageReference Include="System.Text.Json" Version="$(SystemTextJsonVersion)" />
   </ItemGroup>
 
 </Project>
diff --git a/src/EFCore.SqlServer.Abstractions/HierarchyId.cs b/src/EFCore.SqlServer.Abstractions/HierarchyId.cs
index ec4f4867bb..131b0e858b 100644
--- a/src/EFCore.SqlServer.Abstractions/HierarchyId.cs
+++ b/src/EFCore.SqlServer.Abstractions/HierarchyId.cs
@@ -2,6 +2,8 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System.Diagnostics.CodeAnalysis;
+using System.Text.Json.Serialization;
+using Microsoft.EntityFrameworkCore.Internal;
 using Microsoft.SqlServer.Types;
 
 namespace Microsoft.EntityFrameworkCore;
@@ -9,11 +11,33 @@ namespace Microsoft.EntityFrameworkCore;
 /// <summary>
 /// Represents a position in a hierarchical structure, specifying depth and breadth.
 /// </summary>
-public class HierarchyId : IComparable
+[JsonConverter(typeof(HierarchyIdJsonConverter))]
+public class HierarchyId : IComparable<HierarchyId>
 {
-    private SqlHierarchyId _value;
+    private readonly SqlHierarchyId _value;
 
-    private HierarchyId(SqlHierarchyId value)
+    /// <summary>
+    /// Initializes a new instance of the<see cref="HierarchyId"/> class. Equivalent to <see cref="GetRoot"/>.
+    /// </summary>
+    public HierarchyId()
+        : this(SqlHierarchyId.GetRoot())
+    {
+    }
+
+    /// <summary>
+    /// Initializes a new instance of the<see cref="HierarchyId"/> class. Equivalent to <see cref="Parse"/>.
+    /// </summary>
+    /// <param name="value">The string representation of the node.</param>
+    public HierarchyId(string value)
+        : this(SqlHierarchyId.Parse(value))
+    {
+    }
+
+    /// <summary>
+    /// Initializes a new instance of the<see cref="HierarchyId"/> class.
+    /// </summary>
+    /// <param name="value">The <see cref="SqlHierarchyId"/> representation of the node.</param>
+    public HierarchyId(SqlHierarchyId value)
     {
         if (value.IsNull)
         {
@@ -28,7 +52,7 @@ private HierarchyId(SqlHierarchyId value)
     /// </summary>
     /// <returns>The root node of the hierarchy.</returns>
     public static HierarchyId GetRoot()
-        => new HierarchyId(SqlHierarchyId.GetRoot());
+        => ((HierarchyId?)SqlHierarchyId.GetRoot())!;
 
     /// <summary>
     /// Converts the canonical string representation of a node to a <see cref="HierarchyId"/> value.
@@ -37,42 +61,17 @@ public static HierarchyId GetRoot()
     /// <returns>A <see cref="HierarchyId"/> value.</returns>
     [return: NotNullIfNotNull(nameof(input))]
     public static HierarchyId? Parse(string? input)
-        => Wrap(SqlHierarchyId.Parse(input));
-
-    /// <summary>
-    /// Reads a <see cref="HierarchyId"/> value from the specified reader.
-    /// </summary>
-    /// <param name="reader">The reader.</param>
-    /// <returns>A <see cref="HierarchyId"/> value.</returns>
-    public static HierarchyId? Read(BinaryReader reader)
-    {
-        var hid = new SqlHierarchyId();
-        hid.Read(reader);
-        return Wrap(hid);
-    }
-
-    /// <summary>
-    /// Writes this <see cref="HierarchyId"/> value to the specified writer.
-    /// </summary>
-    /// <param name="writer">The writer.</param>
-    public void Write(BinaryWriter writer)
-    {
-        _value.Write(writer);
-    }
+        => (HierarchyId?)SqlHierarchyId.Parse(input);
 
     /// <inheritdoc/>
-    public int CompareTo(object? obj)
-        => _value.CompareTo(
-            obj is HierarchyId or null
-                ? Unwrap((HierarchyId?)obj)
-                : obj);
+    public virtual int CompareTo(HierarchyId? other)
+        => _value.CompareTo((SqlHierarchyId)other);
 
     /// <inheritdoc/>
-    public override bool Equals(object? obj)
-        => _value.Equals(
-                obj is HierarchyId other
-                    ? other._value
-                    : obj);
+    public override bool Equals(object? other)
+        => other is HierarchyId or null
+            ? Equals((SqlHierarchyId)(HierarchyId?)other)
+            : _value.Equals(other);
 
     /// <summary>
     /// Gets the node <paramref name="n"/> levels up the hierarchical tree.
@@ -80,17 +79,25 @@ public override bool Equals(object? obj)
     /// <param name="n">The number of levels to ascend in the hierarchy.</param>
     /// <returns>A <see cref="HierarchyId"/> value representing the <paramref name="n"/>th ancestor of this node or null if <paramref name="n"/> is greater than <see cref="GetLevel"/>.</returns>
     /// <exception cref="ArgumentOutOfRangeException"><paramref name="n"/> is negative.</exception>
-    public HierarchyId GetAncestor(int n)
-        => Wrap(_value.GetAncestor(n))!;
+    public virtual HierarchyId? GetAncestor(int n)
+        => (HierarchyId?)_value.GetAncestor(n);
+
+    /// <summary>
+    /// Gets a value for a new descendant node that is greater than <paramref name="child"/>.
+    /// </summary>
+    /// <param name="child">The lower bound. Use the last descendant to ensure the new value doesn't conflict with existing children. Can be null.</param>
+    /// <returns>A new <see cref="HierarchyId"/> value.</returns>
+    public virtual HierarchyId GetDescendant(HierarchyId? child)
+        => GetDescendant(child, null);
 
     /// <summary>
-    /// Gets the value of a descendant node that is greater than <paramref name="child1"/> and less than <paramref name="child2"/>.
+    /// Gets a value for a new descendant node that is greater than <paramref name="child1"/> and less than <paramref name="child2"/>. Use to insert a new node between two existing children.
     /// </summary>
     /// <param name="child1">The lower bound.</param>
     /// <param name="child2">The upper bound.</param>
-    /// <returns>A <see cref="HierarchyId"/> value.</returns>
-    public HierarchyId GetDescendant(HierarchyId? child1, HierarchyId? child2)
-        => Wrap(_value.GetDescendant(Unwrap(child1), Unwrap(child2)))!;
+    /// <returns>A new <see cref="HierarchyId"/> value.</returns>
+    public virtual HierarchyId GetDescendant(HierarchyId? child1, HierarchyId? child2)
+        => ((HierarchyId?)_value.GetDescendant(child1, child2))!;
 
     /// <inheritdoc/>
     public override int GetHashCode()
@@ -100,8 +107,8 @@ public override int GetHashCode()
     /// Gets the level of this node in the hierarchical tree.
     /// </summary>
     /// <returns>The depth of this node. The root node is level 0.</returns>
-    public short GetLevel()
-        => _value.GetLevel().Value;
+    public virtual short GetLevel()
+        => (short)_value.GetLevel();
 
     /// <summary>
     /// Gets a value representing the location of a new node that has a path from <paramref name="newRoot"/> equal to the path from <paramref name="oldRoot"/> to this, effectively moving this to the new location.
@@ -109,18 +116,21 @@ public short GetLevel()
     /// <param name="oldRoot">An ancestor of this node specifying the endpoint of the path segment to be moved.</param>
     /// <param name="newRoot">The node that represents the new ancestor.</param>
     /// <returns>A <see cref="HierarchyId"/> value or null if <paramref name="oldRoot"/> or <paramref name="newRoot"/> is null.</returns>
-    public HierarchyId? GetReparentedValue(HierarchyId? oldRoot, HierarchyId? newRoot)
-        => Wrap(_value.GetReparentedValue(Unwrap(oldRoot), Unwrap(newRoot)));
+    public virtual HierarchyId? GetReparentedValue(HierarchyId? oldRoot, HierarchyId? newRoot)
+        => (HierarchyId?)_value.GetReparentedValue(oldRoot, newRoot);
 
     /// <summary>
     /// Gets a value indicating whether this node is a descendant of <paramref name="parent"/>.
     /// </summary>
     /// <param name="parent">The parent to test against.</param>
     /// <returns>True if this node is in the sub-tree rooted at <paramref name="parent"/>; otherwise false.</returns>
-    public bool IsDescendantOf(HierarchyId? parent)
-        => _value.IsDescendantOf(Unwrap(parent)).IsTrue;
+    public virtual bool IsDescendantOf(HierarchyId? parent)
+        => _value.IsDescendantOf(parent).IsTrue;
 
-    /// <inheritdoc/>
+    /// <summary>
+    /// Returns the canonical string representation of a node.
+    /// </summary>
+    /// <returns>The string representation of a node.</returns>
     public override string ToString()
         => _value.ToString();
 
@@ -131,12 +141,7 @@ public override string ToString()
     /// <param name="hid2">The second node to compare.</param>
     /// <returns>True if <paramref name="hid1"/> and <paramref name="hid2"/> are equal; otherwise, false.</returns>
     public static bool operator ==(HierarchyId? hid1, HierarchyId? hid2)
-    {
-        var sh1 = Unwrap(hid1);
-        var sh2 = Unwrap(hid2);
-
-        return sh1.IsNull == sh2.IsNull && sh1.CompareTo(sh2) == 0;
-    }
+        => ((SqlHierarchyId)hid1).CompareTo(hid2) == 0;
 
     /// <summary>
     /// Evaluates whether two nodes are unequal.
@@ -145,12 +150,7 @@ public override string ToString()
     /// <param name="hid2">The second node to compare.</param>
     /// <returns>True if <paramref name="hid1"/> and <paramref name="hid2"/> are unequal; otherwise, false.</returns>
     public static bool operator !=(HierarchyId? hid1, HierarchyId? hid2)
-    {
-        var sh1 = Unwrap(hid1);
-        var sh2 = Unwrap(hid2);
-
-        return sh1.IsNull != sh2.IsNull || sh1.CompareTo(sh2) != 0;
-    }
+        => ((SqlHierarchyId)hid1).CompareTo(hid2) != 0;
 
     /// <summary>
     /// Evaluates whether one node is less than another.
@@ -159,12 +159,7 @@ public override string ToString()
     /// <param name="hid2">The second node to compare.</param>
     /// <returns>True if <paramref name="hid1"/> is less than <paramref name="hid2"/>; otherwise, false.</returns>
     public static bool operator <(HierarchyId? hid1, HierarchyId? hid2)
-    {
-        var sh1 = Unwrap(hid1);
-        var sh2 = Unwrap(hid2);
-
-        return !sh1.IsNull && !sh2.IsNull && sh1.CompareTo(sh2) < 0;
-    }
+        => ((SqlHierarchyId)hid1).CompareTo(hid2) < 0;
 
     /// <summary>
     /// Evaluates whether one node is greater than another.
@@ -173,12 +168,7 @@ public override string ToString()
     /// <param name="hid2">The second node to compare.</param>
     /// <returns>True if <paramref name="hid1"/> is greater than <paramref name="hid2"/>; otherwise, false.</returns>
     public static bool operator >(HierarchyId? hid1, HierarchyId? hid2)
-    {
-        var sh1 = Unwrap(hid1);
-        var sh2 = Unwrap(hid2);
-
-        return !sh1.IsNull && !sh2.IsNull && sh1.CompareTo(sh2) > 0;
-    }
+        => ((SqlHierarchyId)hid1).CompareTo(hid2) > 0;
 
     /// <summary>
     /// Evaluates whether one node is less than or equal to another.
@@ -187,12 +177,7 @@ public override string ToString()
     /// <param name="hid2">The second node to compare.</param>
     /// <returns>True if <paramref name="hid1"/> is less than or equal to <paramref name="hid2"/>; otherwise, false.</returns>
     public static bool operator <=(HierarchyId? hid1, HierarchyId? hid2)
-    {
-        var sh1 = Unwrap(hid1);
-        var sh2 = Unwrap(hid2);
-
-        return !sh1.IsNull && !sh2.IsNull && sh1.CompareTo(sh2) <= 0;
-    }
+        => ((SqlHierarchyId)hid1).CompareTo(hid2) <= 0;
 
     /// <summary>
     /// Evaluates whether one node is greater than or equal to another.
@@ -201,16 +186,21 @@ public override string ToString()
     /// <param name="hid2">The second node to compare.</param>
     /// <returns>True if <paramref name="hid1"/> is greater than or equal to <paramref name="hid2"/>; otherwise, false.</returns>
     public static bool operator >=(HierarchyId? hid1, HierarchyId? hid2)
-    {
-        var sh1 = Unwrap(hid1);
-        var sh2 = Unwrap(hid2);
+        => ((SqlHierarchyId)hid1).CompareTo(hid2) >= 0;
 
-        return !sh1.IsNull && !sh2.IsNull && sh1.CompareTo(sh2) >= 0;
-    }
-
-    private static SqlHierarchyId Unwrap(HierarchyId? value)
+    /// <summary>
+    /// Converts a <see cref="HierarchyId"/> value to a <see cref="SqlHierarchyId"/> value.
+    /// </summary>
+    /// <param name="value">The <see cref="HierarchyId"/> value.</param>
+    /// <returns>The underlying <see cref="SqlHierarchyId"/> value.</returns>
+    public static implicit operator SqlHierarchyId(HierarchyId? value)
         => value?._value ?? SqlHierarchyId.Null;
 
-    private static HierarchyId? Wrap(SqlHierarchyId value)
+    /// <summary>
+    /// Converts a <see cref="SqlHierarchyId"/> value to a <see cref="HierarchyId"/> value.
+    /// </summary>
+    /// <param name="value">The <see cref="SqlHierarchyId"/> value.</param>
+    /// <returns>A new <see cref="HierarchyId"/> value.</returns>
+    public static explicit operator HierarchyId?(SqlHierarchyId value)
         => value.IsNull ? null : new HierarchyId(value);
 }
diff --git a/src/EFCore.SqlServer.Abstractions/Internal/HierarchyIdJsonConverter.cs b/src/EFCore.SqlServer.Abstractions/Internal/HierarchyIdJsonConverter.cs
new file mode 100644
index 0000000000..43a1d3d4ff
--- /dev/null
+++ b/src/EFCore.SqlServer.Abstractions/Internal/HierarchyIdJsonConverter.cs
@@ -0,0 +1,22 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Text.Json;
+using System.Text.Json.Serialization;
+
+namespace Microsoft.EntityFrameworkCore.Internal;
+
+internal class HierarchyIdJsonConverter : JsonConverter<HierarchyId>
+{
+    public override HierarchyId? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
+    {
+        var value = reader.GetString();
+
+        return value is null
+            ? null
+            : HierarchyId.Parse(value);
+    }
+
+    public override void Write(Utf8JsonWriter writer, HierarchyId? value, JsonSerializerOptions options)
+        => writer.WriteStringValue(value?.ToString());
+}
diff --git a/src/EFCore.SqlServer.HierarchyId/Infrastructure/Internal/SqlServerHierarchyIdOptionsExtension.cs b/src/EFCore.SqlServer.HierarchyId/Infrastructure/Internal/SqlServerHierarchyIdOptionsExtension.cs
index 47905aa9f5..59ab22b3b2 100644
--- a/src/EFCore.SqlServer.HierarchyId/Infrastructure/Internal/SqlServerHierarchyIdOptionsExtension.cs
+++ b/src/EFCore.SqlServer.HierarchyId/Infrastructure/Internal/SqlServerHierarchyIdOptionsExtension.cs
@@ -28,7 +28,7 @@ public class SqlServerHierarchyIdOptionsExtension : IDbContextOptionsExtension
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    public DbContextOptionsExtensionInfo Info
+    public virtual DbContextOptionsExtensionInfo Info
         => _info ??= new ExtensionInfo(this);
 
     /// <summary>
diff --git a/src/EFCore.SqlServer.HierarchyId/Query/Internal/SqlServerHierarchyIdMethodTranslator.cs b/src/EFCore.SqlServer.HierarchyId/Query/Internal/SqlServerHierarchyIdMethodTranslator.cs
index 3c697523fa..cb2a8f909c 100644
--- a/src/EFCore.SqlServer.HierarchyId/Query/Internal/SqlServerHierarchyIdMethodTranslator.cs
+++ b/src/EFCore.SqlServer.HierarchyId/Query/Internal/SqlServerHierarchyIdMethodTranslator.cs
@@ -3,7 +3,6 @@
 
 using Microsoft.EntityFrameworkCore.Query;
 using Microsoft.EntityFrameworkCore.Query.SqlExpressions;
-using Microsoft.EntityFrameworkCore.SqlServer.Storage.Internal;
 using Microsoft.EntityFrameworkCore.Storage;
 
 namespace Microsoft.EntityFrameworkCore.SqlServer.Query.Internal;
@@ -16,22 +15,16 @@ namespace Microsoft.EntityFrameworkCore.SqlServer.Query.Internal;
 /// </summary>
 public class SqlServerHierarchyIdMethodTranslator : IMethodCallTranslator
 {
-    private static readonly IDictionary<MethodInfo, string> _methodToFunctionName = new Dictionary<MethodInfo, string>
+    private static readonly Dictionary<MethodInfo, string> _methodToFunctionName = new Dictionary<MethodInfo, string>
     {
         // instance methods
         { typeof(HierarchyId).GetRuntimeMethod(nameof(HierarchyId.GetAncestor), new[] { typeof(int) })!, "GetAncestor" },
-        {
-            typeof(HierarchyId).GetRuntimeMethod(nameof(HierarchyId.GetDescendant), new[] { typeof(HierarchyId), typeof(HierarchyId) })!,
-            "GetDescendant"
-        },
+        { typeof(HierarchyId).GetRuntimeMethod(nameof(HierarchyId.GetDescendant), new[] { typeof(HierarchyId) })!, "GetDescendant" },
+        { typeof(HierarchyId).GetRuntimeMethod(nameof(HierarchyId.GetDescendant), new[] { typeof(HierarchyId), typeof(HierarchyId) })!, "GetDescendant" },
         { typeof(HierarchyId).GetRuntimeMethod(nameof(HierarchyId.GetLevel), Type.EmptyTypes)!, "GetLevel" },
-        {
-            typeof(HierarchyId).GetRuntimeMethod(
-                nameof(HierarchyId.GetReparentedValue), new[] { typeof(HierarchyId), typeof(HierarchyId) })!,
-            "GetReparentedValue"
-        },
+        { typeof(HierarchyId).GetRuntimeMethod(nameof(HierarchyId.GetReparentedValue), new[] { typeof(HierarchyId), typeof(HierarchyId) })!, "GetReparentedValue" },
         { typeof(HierarchyId).GetRuntimeMethod(nameof(HierarchyId.IsDescendantOf), new[] { typeof(HierarchyId) })!, "IsDescendantOf" },
-        { typeof(object).GetRuntimeMethod(nameof(HierarchyId.ToString), Type.EmptyTypes)!, "ToString" },
+        { typeof(object).GetRuntimeMethod(nameof(ToString), Type.EmptyTypes)!, "ToString" },
 
         // static methods
         { typeof(HierarchyId).GetRuntimeMethod(nameof(HierarchyId.GetRoot), Type.EmptyTypes)!, "hierarchyid::GetRoot" },
@@ -61,73 +54,76 @@ public class SqlServerHierarchyIdMethodTranslator : IMethodCallTranslator
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    public SqlExpression? Translate(
+    public virtual SqlExpression? Translate(
         SqlExpression? instance,
         MethodInfo method,
         IReadOnlyList<SqlExpression> arguments,
         IDiagnosticsLogger<DbLoggerCategory.Query> logger)
     {
-        // instance is null for static methods like Parse
-        const string storeType = SqlServerHierarchyIdTypeMappingSourcePlugin.SqlServerTypeName;
-        var callingType = instance?.Type ?? method.DeclaringType;
-        if (typeof(HierarchyId).IsAssignableFrom(callingType)
+        if ((instance?.Type ?? method.DeclaringType) == typeof(HierarchyId)
             && _methodToFunctionName.TryGetValue(method, out var functionName))
         {
-            var typeMappedArguments = new List<SqlExpression>();
-            foreach (var argument in arguments)
+            var candidates = arguments.Where(a => a.Type == typeof(HierarchyId));
+            if (instance is not null)
+            {
+                candidates = candidates.Prepend(instance);
+            }
+
+            var typeMapping = ExpressionExtensions.InferTypeMapping(candidates.ToArray())
+                ?? _typeMappingSource.FindMapping(typeof(HierarchyId))!;
+
+            var newArguments = new List<SqlExpression>();
+            for (var i = 0; i < arguments.Count; i++)
             {
-                var argumentTypeMapping = typeof(HierarchyId).IsAssignableFrom(argument.Type)
-                    ? _typeMappingSource.FindMapping(argument.Type, storeType)
-                    : _typeMappingSource.FindMapping(argument.Type);
-                var mappedArgument = _sqlExpressionFactory.ApplyTypeMapping(argument, argumentTypeMapping);
-                typeMappedArguments.Add(mappedArgument);
+                var argument = arguments[i];
+
+                if (argument.Type == typeof(HierarchyId))
+                {
+                    if (argument is SqlConstantExpression constant
+                        && constant.Value is HierarchyId hierarchyId)
+                    {
+                        argument = _sqlExpressionFactory.Fragment($"'{hierarchyId}'");
+                    }
+
+                    argument = _sqlExpressionFactory.ApplyTypeMapping(argument, typeMapping);
+                }
+
+                newArguments.Add(argument);
             }
 
-            var resultTypeMapping = typeof(HierarchyId).IsAssignableFrom(method.ReturnType)
-                ? _typeMappingSource.FindMapping(method.ReturnType, storeType)
-                : _typeMappingSource.FindMapping(method.ReturnType);
+            if (functionName == "GetDescendant"
+                && newArguments.Count == 1)
+            {
+                newArguments.Add(_sqlExpressionFactory.Constant(null, typeof(HierarchyId)));
+            }
 
-            if (instance != null)
+            if (instance is not null)
             {
-                var instanceMapping = _typeMappingSource.FindMapping(instance.Type, storeType);
-                instance = _sqlExpressionFactory.ApplyTypeMapping(instance, instanceMapping);
+                if (instance.Type == typeof(HierarchyId))
+                {
+                    instance = _sqlExpressionFactory.ApplyTypeMapping(instance, typeMapping);
+                }
 
                 return _sqlExpressionFactory.Function(
                     instance,
                     functionName,
-                    Simplify(arguments),
+                    newArguments,
                     nullable: true,
                     instancePropagatesNullability: true,
-                    argumentsPropagateNullability: arguments.Select(a => true),
+                    argumentsPropagateNullability: newArguments.Select(a => true),
                     method.ReturnType,
-                    resultTypeMapping);
+                    method.ReturnType == typeof(HierarchyId) ? typeMapping : null);
             }
 
             return _sqlExpressionFactory.Function(
                 functionName,
-                Simplify(arguments),
+                newArguments,
                 nullable: true,
-                argumentsPropagateNullability: arguments.Select(a => true),
+                argumentsPropagateNullability: newArguments.Select(a => true),
                 method.ReturnType,
-                resultTypeMapping);
+                method.ReturnType == typeof(HierarchyId) ? typeMapping : null);
         }
 
         return null;
     }
-
-    private IEnumerable<SqlExpression> Simplify(IEnumerable<SqlExpression> arguments)
-    {
-        foreach (var argument in arguments)
-        {
-            if (argument is SqlConstantExpression constant
-                && constant.Value is HierarchyId hierarchyId)
-            {
-                yield return _sqlExpressionFactory.Fragment($"'{hierarchyId}'");
-            }
-            else
-            {
-                yield return argument;
-            }
-        }
-    }
 }
diff --git a/src/EFCore.SqlServer.HierarchyId/Storage/Internal/SqlServerHierarchyIdTypeMapping.cs b/src/EFCore.SqlServer.HierarchyId/Storage/Internal/SqlServerHierarchyIdTypeMapping.cs
index d346691b10..4c8af78e50 100644
--- a/src/EFCore.SqlServer.HierarchyId/Storage/Internal/SqlServerHierarchyIdTypeMapping.cs
+++ b/src/EFCore.SqlServer.HierarchyId/Storage/Internal/SqlServerHierarchyIdTypeMapping.cs
@@ -3,10 +3,8 @@
 
 using System.Data;
 using System.Data.Common;
-using System.Data.SqlTypes;
 using System.Linq.Expressions;
 using Microsoft.Data.SqlClient;
-using Microsoft.EntityFrameworkCore.Query;
 using Microsoft.EntityFrameworkCore.SqlServer.Storage.ValueConversion.Internal;
 using Microsoft.EntityFrameworkCore.Storage;
 
@@ -20,36 +18,27 @@ namespace Microsoft.EntityFrameworkCore.SqlServer.Storage.Internal;
 /// </summary>
 public class SqlServerHierarchyIdTypeMapping : RelationalTypeMapping
 {
-    private static readonly MethodInfo _getSqlBytes
-        = typeof(SqlDataReader).GetRuntimeMethod(nameof(SqlDataReader.GetSqlBytes), new[] { typeof(int) })!;
+    private const string HierarchyIdFormatConst = "hierarchyid::Parse('{0}')";
 
-    private static readonly MethodInfo _parseHierarchyId
-        = typeof(HierarchyId).GetRuntimeMethod(nameof(HierarchyId.Parse), new[] { typeof(string) })!;
+    private static readonly ConstructorInfo _hierarchyIdConstructor
+        = typeof(HierarchyId).GetConstructor(new[] { typeof(string) })!;
 
     private static readonly SqlServerHierarchyIdValueConverter _valueConverter = new();
 
-    private static Action<DbParameter, SqlDbType>? _sqlDbTypeSetter;
-    private static Action<DbParameter, string>? _udtTypeNameSetter;
-
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    public SqlServerHierarchyIdTypeMapping(string storeType, Type clrType)
-        : base(CreateRelationalTypeMappingParameters(storeType, clrType))
-    {
-    }
-
-    private static RelationalTypeMappingParameters CreateRelationalTypeMappingParameters(string storeType, Type clrType)
+    public SqlServerHierarchyIdTypeMapping(string storeType)
+        : this(
+              new RelationalTypeMappingParameters(
+                  new CoreTypeMappingParameters(
+                      typeof(HierarchyId),
+                      _valueConverter),
+                  storeType))
     {
-        return new RelationalTypeMappingParameters(
-            new CoreTypeMappingParameters(
-                clrType: clrType,
-                converter: null //this gets the generatecodeliteral to run
-            ),
-            storeType);
     }
 
     /// <summary>
@@ -71,9 +60,7 @@ protected SqlServerHierarchyIdTypeMapping(RelationalTypeMappingParameters parame
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
     protected override RelationalTypeMapping Clone(RelationalTypeMappingParameters parameters)
-    {
-        return new SqlServerHierarchyIdTypeMapping(parameters);
-    }
+        => new SqlServerHierarchyIdTypeMapping(parameters);
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
@@ -83,28 +70,9 @@ protected override RelationalTypeMapping Clone(RelationalTypeMappingParameters p
     /// </summary>
     protected override void ConfigureParameter(DbParameter parameter)
     {
-        var type = parameter.GetType();
-        LazyInitializer.EnsureInitialized(ref _sqlDbTypeSetter, () => CreateSqlDbTypeAccessor(type));
-        LazyInitializer.EnsureInitialized(ref _udtTypeNameSetter, () => CreateUdtTypeNameAccessor(type));
-
-        if (parameter.Value == DBNull.Value)
-        {
-            parameter.Value = SqlBytes.Null;
-        }
-
-        _sqlDbTypeSetter(parameter, SqlDbType.Udt);
-        _udtTypeNameSetter(parameter, StoreType);
-    }
-
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public override MethodInfo GetDataReaderMethod()
-    {
-        return _getSqlBytes;
+        var sqlParameter = (SqlParameter)parameter;
+        sqlParameter.SqlDbType = SqlDbType.Udt;
+        sqlParameter.UdtTypeName = StoreType;
     }
 
     /// <summary>
@@ -114,12 +82,9 @@ public override MethodInfo GetDataReaderMethod()
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
     public override Expression GenerateCodeLiteral(object value)
-    {
-        return Expression.Call(
-            _parseHierarchyId,
-            Expression.Constant(value.ToString(), typeof(string))
-        );
-    }
+        => Expression.New(
+            _hierarchyIdConstructor,
+            Expression.Constant(((HierarchyId)value).ToString()));
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
@@ -127,93 +92,6 @@ public override Expression GenerateCodeLiteral(object value)
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    protected override string GenerateNonNullSqlLiteral(object value)
-    {
-        //this appears to only be called when using the update-database
-        //command, and the value is already a hierarchyid
-        return $"'{value}'";
-    }
-
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public override DbParameter CreateParameter(
-        DbCommand command,
-        string name,
-        object? value,
-        bool? nullable = null,
-        ParameterDirection direction = ParameterDirection.Input)
-    {
-        var parameter = command.CreateParameter();
-        parameter.Direction = ParameterDirection.Input;
-        parameter.ParameterName = name;
-
-        if (Converter != null)
-        {
-            value = Converter.ConvertToProvider(value);
-        }
-
-        parameter.Value = value is null
-            ? DBNull.Value
-            : _valueConverter.ConvertToProvider(value);
-
-        if (nullable.HasValue)
-        {
-            parameter.IsNullable = nullable.Value;
-        }
-
-        ConfigureParameter(parameter);
-
-        return parameter;
-    }
-
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public override Expression CustomizeDataReaderExpression(Expression expression)
-    {
-        if (expression.Type != _valueConverter.ProviderClrType)
-        {
-            expression = Expression.Convert(expression, _valueConverter.ProviderClrType);
-        }
-
-        return ReplacingExpressionVisitor.Replace(
-            _valueConverter.ConvertFromProviderExpression.Parameters.Single(),
-            expression,
-            _valueConverter.ConvertFromProviderExpression.Body);
-    }
-
-    private static Action<DbParameter, SqlDbType> CreateSqlDbTypeAccessor(Type paramType)
-    {
-        var paramParam = Expression.Parameter(typeof(DbParameter), "parameter");
-        var valueParam = Expression.Parameter(typeof(SqlDbType), "value");
-
-        return Expression.Lambda<Action<DbParameter, SqlDbType>>(
-            Expression.Call(
-                Expression.Convert(paramParam, paramType),
-                paramType.GetProperty("SqlDbType")!.SetMethod!,
-                valueParam),
-            paramParam,
-            valueParam).Compile();
-    }
-
-    private static Action<DbParameter, string> CreateUdtTypeNameAccessor(Type paramType)
-    {
-        var paramParam = Expression.Parameter(typeof(DbParameter), "parameter");
-        var valueParam = Expression.Parameter(typeof(string), "value");
-
-        return Expression.Lambda<Action<DbParameter, string>>(
-            Expression.Call(
-                Expression.Convert(paramParam, paramType),
-                paramType.GetProperty("UdtTypeName")!.SetMethod!,
-                valueParam),
-            paramParam,
-            valueParam).Compile();
-    }
+    protected override string SqlLiteralFormatString
+        => HierarchyIdFormatConst;
 }
diff --git a/src/EFCore.SqlServer.HierarchyId/Storage/Internal/SqlServerHierarchyIdTypeMappingSourcePlugin.cs b/src/EFCore.SqlServer.HierarchyId/Storage/Internal/SqlServerHierarchyIdTypeMappingSourcePlugin.cs
index b2fb980a0b..16a9e60475 100644
--- a/src/EFCore.SqlServer.HierarchyId/Storage/Internal/SqlServerHierarchyIdTypeMappingSourcePlugin.cs
+++ b/src/EFCore.SqlServer.HierarchyId/Storage/Internal/SqlServerHierarchyIdTypeMappingSourcePlugin.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using Microsoft.EntityFrameworkCore.Storage;
+using Microsoft.SqlServer.Types;
 
 namespace Microsoft.EntityFrameworkCore.SqlServer.Storage.Internal;
 
@@ -13,13 +14,8 @@ namespace Microsoft.EntityFrameworkCore.SqlServer.Storage.Internal;
 /// </summary>
 public class SqlServerHierarchyIdTypeMappingSourcePlugin : IRelationalTypeMappingSourcePlugin
 {
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public const string SqlServerTypeName = "hierarchyid";
+    private readonly SqlServerHierarchyIdTypeMapping _hierarchyId = new("hierarchyid");
+    private readonly SqlServerSqlHierarchyIdTypeMapping _sqlHierarchyId = new("hierarchyid");
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
@@ -32,9 +28,29 @@ public class SqlServerHierarchyIdTypeMappingSourcePlugin : IRelationalTypeMappin
         var clrType = mappingInfo.ClrType;
         var storeTypeName = mappingInfo.StoreTypeName;
 
-        return typeof(HierarchyId).IsAssignableFrom(clrType)
-            || SqlServerTypeName.Equals(storeTypeName, StringComparison.OrdinalIgnoreCase)
-                ? new SqlServerHierarchyIdTypeMapping(SqlServerTypeName, clrType ?? typeof(HierarchyId))
-                : null;
+        if (string.Equals(storeTypeName, "hierarchyid", StringComparison.OrdinalIgnoreCase))
+        {
+            if (clrType is null
+                || clrType == typeof(HierarchyId))
+            {
+                return _hierarchyId;
+            }
+            else if (clrType == typeof(SqlHierarchyId))
+            {
+                return _sqlHierarchyId;
+            }
+
+            return null;
+        }
+        else if (clrType == typeof(HierarchyId))
+        {
+            return _hierarchyId;
+        }
+        else if (clrType == typeof(SqlHierarchyId))
+        {
+            return _sqlHierarchyId;
+        }
+
+        return null;
     }
 }
diff --git a/src/EFCore.SqlServer.HierarchyId/Storage/Internal/SqlServerSqlHierarchyIdTypeMapping.cs b/src/EFCore.SqlServer.HierarchyId/Storage/Internal/SqlServerSqlHierarchyIdTypeMapping.cs
new file mode 100644
index 0000000000..a863601b29
--- /dev/null
+++ b/src/EFCore.SqlServer.HierarchyId/Storage/Internal/SqlServerSqlHierarchyIdTypeMapping.cs
@@ -0,0 +1,74 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Data.SqlTypes;
+using System.Linq.Expressions;
+using Microsoft.EntityFrameworkCore.Storage;
+using Microsoft.SqlServer.Types;
+
+namespace Microsoft.EntityFrameworkCore.SqlServer.Storage.Internal;
+
+/// <summary>
+///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+///     any release. You should only use it directly in your code with extreme caution and knowing that
+///     doing so can result in application failures when updating to a new Entity Framework Core release.
+/// </summary>
+public class SqlServerSqlHierarchyIdTypeMapping : RelationalTypeMapping
+{
+    private const string SqlHierarchyIdFormatConst = "hierarchyid::Parse('{0}')";
+
+    private static readonly MethodInfo _sqlHierarchyIdParseMethod
+        = typeof(SqlHierarchyId).GetRuntimeMethod(nameof(SqlHierarchyId.Parse), new[] { typeof(SqlString) })!;
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public SqlServerSqlHierarchyIdTypeMapping(string storeType)
+        : base(storeType, typeof(SqlHierarchyId))
+    {
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    protected SqlServerSqlHierarchyIdTypeMapping(RelationalTypeMappingParameters parameters)
+        : base(parameters)
+    {
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    protected override string SqlLiteralFormatString
+        => SqlHierarchyIdFormatConst;
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    protected override RelationalTypeMapping Clone(RelationalTypeMappingParameters parameters)
+        => new SqlServerSqlHierarchyIdTypeMapping(parameters);
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public override Expression GenerateCodeLiteral(object value)
+        => Expression.Call(
+            _sqlHierarchyIdParseMethod,
+            Expression.Convert(Expression.Constant(((SqlHierarchyId)value).ToString()), typeof(SqlString)));
+}
diff --git a/src/EFCore.SqlServer.HierarchyId/Storage/ValueConversion/Internal/SqlServerHierarchyIdValueConverter.cs b/src/EFCore.SqlServer.HierarchyId/Storage/ValueConversion/Internal/SqlServerHierarchyIdValueConverter.cs
index 7edd8eabdd..73b3b9154c 100644
--- a/src/EFCore.SqlServer.HierarchyId/Storage/ValueConversion/Internal/SqlServerHierarchyIdValueConverter.cs
+++ b/src/EFCore.SqlServer.HierarchyId/Storage/ValueConversion/Internal/SqlServerHierarchyIdValueConverter.cs
@@ -1,8 +1,8 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System.Data.SqlTypes;
 using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
+using Microsoft.SqlServer.Types;
 
 namespace Microsoft.EntityFrameworkCore.SqlServer.Storage.ValueConversion.Internal;
 
@@ -12,7 +12,7 @@ namespace Microsoft.EntityFrameworkCore.SqlServer.Storage.ValueConversion.Intern
 ///     any release. You should only use it directly in your code with extreme caution and knowing that
 ///     doing so can result in application failures when updating to a new Entity Framework Core release.
 /// </summary>
-public class SqlServerHierarchyIdValueConverter : ValueConverter<HierarchyId, SqlBytes>
+public class SqlServerHierarchyIdValueConverter : ValueConverter<HierarchyId?, SqlHierarchyId>
 {
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
@@ -25,20 +25,9 @@ public SqlServerHierarchyIdValueConverter()
     {
     }
 
-    private static SqlBytes ToProvider(HierarchyId hid)
-    {
-        using var memory = new MemoryStream();
-        using var writer = new BinaryWriter(memory);
-
-        hid.Write(writer);
-        return new SqlBytes(memory.ToArray());
-    }
+    private static SqlHierarchyId ToProvider(HierarchyId? value)
+        => (SqlHierarchyId)value;
 
-    private static HierarchyId FromProvider(SqlBytes bytes)
-    {
-        using var memory = new MemoryStream(bytes.Value);
-        using var reader = new BinaryReader(memory);
-
-        return HierarchyId.Read(reader)!;
-    }
+    private static HierarchyId? FromProvider(SqlHierarchyId value)
+        => (HierarchyId?)value;
 }
diff --git a/test/EFCore.SqlServer.HierarchyId.Tests/HierarchyIdJsonConverterTest.cs b/test/EFCore.SqlServer.HierarchyId.Tests/HierarchyIdJsonConverterTest.cs
new file mode 100644
index 0000000000..67dc499034
--- /dev/null
+++ b/test/EFCore.SqlServer.HierarchyId.Tests/HierarchyIdJsonConverterTest.cs
@@ -0,0 +1,26 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Text.Json;
+using Xunit;
+
+namespace Microsoft.EntityFrameworkCore.SqlServer;
+
+public class HierarchyIdJsonConverterTest
+{
+    [ConditionalFact]
+    public void Read_works()
+        => Assert.Equal("/1/", JsonSerializer.Deserialize<HierarchyId>("\"/1/\"").ToString());
+
+    [ConditionalFact]
+    public void Read_works_when_null()
+        => Assert.Null(JsonSerializer.Deserialize<HierarchyId>("null"));
+
+    [ConditionalFact]
+    public void Write_works()
+        => Assert.Equal("\"/1/\"", JsonSerializer.Serialize(new HierarchyId("/1/")));
+
+    [ConditionalFact]
+    public void Write_works_when_null()
+        => Assert.Equal("null", JsonSerializer.Serialize<HierarchyId>(null));
+}
diff --git a/test/EFCore.SqlServer.HierarchyId.Tests/NullabilityTests.cs b/test/EFCore.SqlServer.HierarchyId.Tests/NullabilityTests.cs
index 4a2069871e..74edf9a0f2 100644
--- a/test/EFCore.SqlServer.HierarchyId.Tests/NullabilityTests.cs
+++ b/test/EFCore.SqlServer.HierarchyId.Tests/NullabilityTests.cs
@@ -13,9 +13,9 @@ public void Null_against_null()
         Assert.True(null == (HierarchyId)null);
         Assert.False(null != (HierarchyId)null);
         Assert.False(null > (HierarchyId)null);
-        Assert.False(null >= (HierarchyId)null);
+        Assert.True(null >= (HierarchyId)null);
         Assert.False(null < (HierarchyId)null);
-        Assert.False(null <= (HierarchyId)null);
+        Assert.True(null <= (HierarchyId)null);
     }
 
     [ConditionalFact]
@@ -28,17 +28,17 @@ public void Null_against_nonNull()
         Assert.True(hid != null);
         Assert.True(null != hid);
 
-        Assert.False(hid > null);
+        Assert.True(hid > null);
         Assert.False(null > hid);
 
-        Assert.False(hid >= null);
+        Assert.True(hid >= null);
         Assert.False(null >= hid);
 
         Assert.False(hid < null);
-        Assert.False(null < hid);
+        Assert.True(null < hid);
 
         Assert.False(hid <= null);
-        Assert.False(null <= hid);
+        Assert.True(null <= hid);
     }
 
     [ConditionalFact]
diff --git a/test/EFCore.SqlServer.HierarchyId.Tests/QueryTests.cs b/test/EFCore.SqlServer.HierarchyId.Tests/QueryTests.cs
index 943f0a2104..c8594f3612 100644
--- a/test/EFCore.SqlServer.HierarchyId.Tests/QueryTests.cs
+++ b/test/EFCore.SqlServer.HierarchyId.Tests/QueryTests.cs
@@ -49,6 +49,21 @@ public void IsDescendantOf_can_translate()
         Assert.All(results, b => Assert.True(b));
     }
 
+    [ConditionalFact]
+    public void IsDescendantOf_can_translate_when_constant()
+    {
+        var results = (from p in _db.Patriarchy
+                       where p.Id.GetLevel() == 1
+                       select new HierarchyId("/1/1/11.1/").IsDescendantOf(p.Id)).ToList();
+
+        Assert.Equal(
+            Condense(
+                @"SELECT hierarchyid::Parse('/1/1/11.1/').IsDescendantOf([p].[Id]) FROM [Patriarchy] AS [p] WHERE [p].[Id].GetLevel() = CAST(1 AS smallint)"),
+            Condense(_db.Sql));
+
+        Assert.All(results, b => Assert.True(b));
+    }
+
     [ConditionalFact]
     public void GetAncestor_0_can_translate()
     {
@@ -133,6 +148,20 @@ public void GetDescendent_can_translate()
         Assert.Equal(new[] { HierarchyId.Parse("/1/") }, results);
     }
 
+    [ConditionalFact]
+    public void GetDescendent_can_translate_when_one_argument()
+    {
+        var results = (from p in _db.Patriarchy
+                       where p.Id.GetLevel() == 0
+                       select p.Id.GetDescendant(null)).ToList();
+
+        Assert.Equal(
+            Condense(@"SELECT [p].[Id].GetDescendant(NULL, NULL) FROM [Patriarchy] AS [p] WHERE [p].[Id].GetLevel() = CAST(0 AS smallint)"),
+            Condense(_db.Sql));
+
+        Assert.Equal(new[] { HierarchyId.Parse("/1/") }, results);
+    }
+
     [ConditionalFact]
     public void HierarchyId_can_be_sent_as_parameter()
     {
@@ -141,7 +170,7 @@ public void HierarchyId_can_be_sent_as_parameter()
                        select p.Name).ToList();
 
         Assert.Equal(
-            Condense(@"SELECT [p].[Name] FROM [Patriarchy] AS [p] WHERE [p].[Id] = '/1/'"),
+            Condense(@"SELECT [p].[Name] FROM [Patriarchy] AS [p] WHERE [p].[Id] = hierarchyid::Parse('/1/')"),
             Condense(_db.Sql));
 
         Assert.Equal(new[] { "Isaac" }, results);
@@ -155,7 +184,7 @@ public void Converted_HierarchyId_can_be_sent_as_parameter()
                        select p.Name).ToList();
 
         Assert.Equal(
-            Condense(@"SELECT [c].[Name] FROM [ConvertedPatriarchy] AS [c] WHERE [c].[HierarchyId] = '/1/'"),
+            Condense(@"SELECT [c].[Name] FROM [ConvertedPatriarchy] AS [c] WHERE [c].[HierarchyId] = hierarchyid::Parse('/1/')"),
             Condense(_db.Sql));
 
         Assert.Equal(new[] { "Isaac" }, results);
@@ -252,7 +281,7 @@ public void HierarchyId_get_ancestor_of_level_is_root()
                        select p.Name).ToList();
 
         Assert.Equal(
-            Condense(@"SELECT [p].[Name] FROM [Patriarchy] AS [p] WHERE [p].[Id].GetAncestor(CAST([p].[Id].GetLevel() AS int)) = '/'"),
+            Condense(@"SELECT [p].[Name] FROM [Patriarchy] AS [p] WHERE [p].[Id].GetAncestor(CAST([p].[Id].GetLevel() AS int)) = hierarchyid::Parse('/')"),
             Condense(_db.Sql));
 
         var all = (from p in _db.Patriarchy
@@ -272,7 +301,7 @@ where isaac.IsDescendantOf(p.Id)
 
         Assert.Equal(
             """
-            @__isaac_0='?' (Size = 1) (DbType = Object)
+            @__isaac_0='?' (DbType = Object)
 
             SELECT [p].[Name]
             FROM [Patriarchy] AS [p]
@@ -320,7 +349,7 @@ public void Parse_can_translate()
                        select HierarchyId.Parse(p.Id.ToString())).ToList();
 
         Assert.Equal(
-            Condense(@"SELECT hierarchyid::Parse([p].[Id].ToString()) FROM [Patriarchy] AS [p] WHERE [p].[Id] = '/'"),
+            Condense(@"SELECT hierarchyid::Parse([p].[Id].ToString()) FROM [Patriarchy] AS [p] WHERE [p].[Id] = hierarchyid::Parse('/')"),
             Condense(_db.Sql));
 
         Assert.Equal(new[] { HierarchyId.Parse("/") }, results);
diff --git a/test/EFCore.SqlServer.HierarchyId.Tests/SqlServerAbstractionsApiConsistencyTest.cs b/test/EFCore.SqlServer.HierarchyId.Tests/SqlServerAbstractionsApiConsistencyTest.cs
new file mode 100644
index 0000000000..1bcd4d8216
--- /dev/null
+++ b/test/EFCore.SqlServer.HierarchyId.Tests/SqlServerAbstractionsApiConsistencyTest.cs
@@ -0,0 +1,26 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Reflection;
+using Microsoft.Extensions.DependencyInjection;
+
+namespace Microsoft.EntityFrameworkCore;
+
+public class SqlServerAbstractionsApiConsistencyTest : ApiConsistencyTestBase<SqlServerAbstractionsApiConsistencyTest.SqlServerAbstractionsApiConsistencyFixture>
+{
+    public SqlServerAbstractionsApiConsistencyTest(SqlServerAbstractionsApiConsistencyFixture fixture)
+        : base(fixture)
+    {
+    }
+
+    protected override void AddServices(ServiceCollection serviceCollection)
+    {
+    }
+
+    protected override Assembly TargetAssembly
+        => typeof(HierarchyId).Assembly;
+
+    public class SqlServerAbstractionsApiConsistencyFixture : ApiConsistencyFixtureBase
+    {
+    }
+}
diff --git a/test/EFCore.SqlServer.HierarchyId.Tests/SqlServerHierarchyIdApiConsistencyTest.cs b/test/EFCore.SqlServer.HierarchyId.Tests/SqlServerHierarchyIdApiConsistencyTest.cs
new file mode 100644
index 0000000000..ba5170b134
--- /dev/null
+++ b/test/EFCore.SqlServer.HierarchyId.Tests/SqlServerHierarchyIdApiConsistencyTest.cs
@@ -0,0 +1,30 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Reflection;
+using Microsoft.Extensions.DependencyInjection;
+
+namespace Microsoft.EntityFrameworkCore;
+
+public class SqlServerHierarchyIdApiConsistencyTest : ApiConsistencyTestBase<SqlServerHierarchyIdApiConsistencyTest.SqlServerHierarchyIdApiConsistencyFixture>
+{
+    public SqlServerHierarchyIdApiConsistencyTest(SqlServerHierarchyIdApiConsistencyFixture fixture)
+        : base(fixture)
+    {
+    }
+
+    protected override void AddServices(ServiceCollection serviceCollection)
+        => serviceCollection.AddEntityFrameworkSqlServerHierarchyId();
+
+    protected override Assembly TargetAssembly
+        => typeof(SqlServerHierarchyIdServiceCollectionExtensions).Assembly;
+
+    public class SqlServerHierarchyIdApiConsistencyFixture : ApiConsistencyFixtureBase
+    {
+        public override HashSet<Type> FluentApiTypes { get; } = new()
+        {
+            typeof(SqlServerHierarchyIdDbContextOptionsBuilderExtensions),
+            typeof(SqlServerHierarchyIdServiceCollectionExtensions)
+        };
+    }
+}
diff --git a/test/EFCore.SqlServer.HierarchyId.Tests/Test/Models/Migrations/AnonymousArraySeedContext.cs b/test/EFCore.SqlServer.HierarchyId.Tests/Test/Models/Migrations/AnonymousArraySeedContext.cs
index 2ea2780dff..4c1de1c553 100644
--- a/test/EFCore.SqlServer.HierarchyId.Tests/Test/Models/Migrations/AnonymousArraySeedContext.cs
+++ b/test/EFCore.SqlServer.HierarchyId.Tests/Test/Models/Migrations/AnonymousArraySeedContext.cs
@@ -46,8 +46,8 @@ protected override void OnModelCreating(ModelBuilder modelBuilder)
 
     public override string GetExpectedMigrationCode(string migrationName, string rootNamespace)
     {
-        return $@"using Microsoft.EntityFrameworkCore;
-using Microsoft.EntityFrameworkCore.Migrations;
+        return $@"using Microsoft.EntityFrameworkCore.Migrations;
+using Microsoft.SqlServer.Types;
 
 #nullable disable
 
@@ -66,7 +66,7 @@ protected override void Up(MigrationBuilder migrationBuilder)
                 columns: table => new
                 {{
                     Id = table.Column<int>(type: ""int"", nullable: false),
-                    HierarchyId = table.Column<{nameof(HierarchyId)}>(type: ""hierarchyid"", nullable: true),
+                    HierarchyId = table.Column<SqlHierarchyId>(type: ""hierarchyid"", nullable: true),
                     Name = table.Column<string>(type: ""nvarchar(max)"", nullable: true)
                 }},
                 constraints: table =>
@@ -78,7 +78,7 @@ protected override void Up(MigrationBuilder migrationBuilder)
                 name: ""{nameof(TestModels)}"",
                 columns: table => new
                 {{
-                    {nameof(Patriarch.Id)} = table.Column<{nameof(HierarchyId)}>(type: ""hierarchyid"", nullable: false),
+                    {nameof(Patriarch.Id)} = table.Column<SqlHierarchyId>(type: ""hierarchyid"", nullable: false),
                     {nameof(Patriarch.Name)} = table.Column<string>(type: ""nvarchar(max)"", nullable: true)
                 }},
                 constraints: table =>
@@ -91,9 +91,9 @@ protected override void Up(MigrationBuilder migrationBuilder)
                 columns: new[] {{ ""Id"", ""HierarchyId"", ""Name"" }},
                 values: new object[,]
                 {{
-                    {{ 1, Microsoft.EntityFrameworkCore.HierarchyId.Parse(""/""), ""Eddard Stark"" }},
-                    {{ 2, Microsoft.EntityFrameworkCore.HierarchyId.Parse(""/1/""), ""Robb Stark"" }},
-                    {{ 3, Microsoft.EntityFrameworkCore.HierarchyId.Parse(""/2/""), ""Jon Snow"" }}
+                    {{ 1, Microsoft.SqlServer.Types.SqlHierarchyId.Parse(""/""), ""Eddard Stark"" }},
+                    {{ 2, Microsoft.SqlServer.Types.SqlHierarchyId.Parse(""/1/""), ""Robb Stark"" }},
+                    {{ 3, Microsoft.SqlServer.Types.SqlHierarchyId.Parse(""/2/""), ""Jon Snow"" }}
                 }});
 
             migrationBuilder.InsertData(
@@ -101,9 +101,9 @@ protected override void Up(MigrationBuilder migrationBuilder)
                 columns: new[] {{ ""Id"", ""Name"" }},
                 values: new object[,]
                 {{
-                    {{ Microsoft.EntityFrameworkCore.HierarchyId.Parse(""/""), ""Eddard Stark"" }},
-                    {{ Microsoft.EntityFrameworkCore.HierarchyId.Parse(""/1/""), ""Robb Stark"" }},
-                    {{ Microsoft.EntityFrameworkCore.HierarchyId.Parse(""/2/""), ""Jon Snow"" }}
+                    {{ Microsoft.SqlServer.Types.SqlHierarchyId.Parse(""/""), ""Eddard Stark"" }},
+                    {{ Microsoft.SqlServer.Types.SqlHierarchyId.Parse(""/1/""), ""Robb Stark"" }},
+                    {{ Microsoft.SqlServer.Types.SqlHierarchyId.Parse(""/2/""), ""Jon Snow"" }}
                 }});
         }}
 
@@ -128,6 +128,7 @@ public override string GetExpectedSnapshotCode(string rootNamespace)
 using Microsoft.EntityFrameworkCore.Infrastructure;
 using {ThisType.Namespace};
 using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
+using Microsoft.SqlServer.Types;
 
 #nullable disable
 
@@ -160,27 +161,27 @@ protected override void BuildModel(ModelBuilder modelBuilder)
                         new
                         {{
                             Id = 1,
-                            HierarchyId = Microsoft.EntityFrameworkCore.HierarchyId.Parse(""/""),
+                            HierarchyId = Microsoft.SqlServer.Types.SqlHierarchyId.Parse(""/""),
                             Name = ""Eddard Stark""
                         }},
                         new
                         {{
                             Id = 2,
-                            HierarchyId = Microsoft.EntityFrameworkCore.HierarchyId.Parse(""/1/""),
+                            HierarchyId = Microsoft.SqlServer.Types.SqlHierarchyId.Parse(""/1/""),
                             Name = ""Robb Stark""
                         }},
                         new
                         {{
                             Id = 3,
-                            HierarchyId = Microsoft.EntityFrameworkCore.HierarchyId.Parse(""/2/""),
+                            HierarchyId = Microsoft.SqlServer.Types.SqlHierarchyId.Parse(""/2/""),
                             Name = ""Jon Snow""
                         }});
                 }});
 
             modelBuilder.Entity(""{ModelType1.FullName}"", b =>
                 {{
-                    b.Property<{nameof(HierarchyId)}>(""{nameof(Patriarch.Id)}"")
-                        .HasColumnType(""{SqlServerHierarchyIdTypeMappingSourcePlugin.SqlServerTypeName}"");
+                    b.Property<SqlHierarchyId>(""{nameof(Patriarch.Id)}"")
+                        .HasColumnType(""hierarchyid"");
 
                     b.Property<string>(""{nameof(Patriarch.Name)}"")
                         .HasColumnType(""nvarchar(max)"");
@@ -192,17 +193,17 @@ protected override void BuildModel(ModelBuilder modelBuilder)
                     b.HasData(
                         new
                         {{
-                            {nameof(Patriarch.Id)} = Microsoft.EntityFrameworkCore.HierarchyId.Parse(""/""),
+                            {nameof(Patriarch.Id)} = Microsoft.SqlServer.Types.SqlHierarchyId.Parse(""/""),
                             {nameof(Patriarch.Name)} = ""Eddard Stark""
                         }},
                         new
                         {{
-                            {nameof(Patriarch.Id)} = Microsoft.EntityFrameworkCore.HierarchyId.Parse(""/1/""),
+                            {nameof(Patriarch.Id)} = Microsoft.SqlServer.Types.SqlHierarchyId.Parse(""/1/""),
                             {nameof(Patriarch.Name)} = ""Robb Stark""
                         }},
                         new
                         {{
-                            {nameof(Patriarch.Id)} = Microsoft.EntityFrameworkCore.HierarchyId.Parse(""/2/""),
+                            {nameof(Patriarch.Id)} = Microsoft.SqlServer.Types.SqlHierarchyId.Parse(""/2/""),
                             {nameof(Patriarch.Name)} = ""Jon Snow""
                         }});
                 }});
diff --git a/test/EFCore.SqlServer.HierarchyId.Tests/Test/Models/Migrations/TypedArraySeedContext.cs b/test/EFCore.SqlServer.HierarchyId.Tests/Test/Models/Migrations/TypedArraySeedContext.cs
index d9e28718ac..6d19e79ee9 100644
--- a/test/EFCore.SqlServer.HierarchyId.Tests/Test/Models/Migrations/TypedArraySeedContext.cs
+++ b/test/EFCore.SqlServer.HierarchyId.Tests/Test/Models/Migrations/TypedArraySeedContext.cs
@@ -46,8 +46,8 @@ protected override void OnModelCreating(ModelBuilder modelBuilder)
 
     public override string GetExpectedMigrationCode(string migrationName, string rootNamespace)
     {
-        return $@"using Microsoft.EntityFrameworkCore;
-using Microsoft.EntityFrameworkCore.Migrations;
+        return $@"using Microsoft.EntityFrameworkCore.Migrations;
+using Microsoft.SqlServer.Types;
 
 #nullable disable
 
@@ -66,7 +66,7 @@ protected override void Up(MigrationBuilder migrationBuilder)
                 columns: table => new
                 {{
                     {nameof(ConvertedPatriarch.Id)} = table.Column<int>(type: ""int"", nullable: false),
-                    {nameof(ConvertedPatriarch.HierarchyId)} = table.Column<{nameof(HierarchyId)}>(type: ""hierarchyid"", nullable: true),
+                    {nameof(ConvertedPatriarch.HierarchyId)} = table.Column<SqlHierarchyId>(type: ""hierarchyid"", nullable: true),
                     {nameof(ConvertedPatriarch.Name)} = table.Column<string>(type: ""nvarchar(max)"", nullable: true)
                 }},
                 constraints: table =>
@@ -78,7 +78,7 @@ protected override void Up(MigrationBuilder migrationBuilder)
                 name: ""{nameof(TestModels)}"",
                 columns: table => new
                 {{
-                    {nameof(Patriarch.Id)} = table.Column<{nameof(HierarchyId)}>(type: ""hierarchyid"", nullable: false),
+                    {nameof(Patriarch.Id)} = table.Column<SqlHierarchyId>(type: ""hierarchyid"", nullable: false),
                     {nameof(Patriarch.Name)} = table.Column<string>(type: ""nvarchar(max)"", nullable: true)
                 }},
                 constraints: table =>
@@ -91,9 +91,9 @@ protected override void Up(MigrationBuilder migrationBuilder)
                 columns: new[] {{ ""Id"", ""HierarchyId"", ""Name"" }},
                 values: new object[,]
                 {{
-                    {{ 1, {typeof(HierarchyId).FullName}.Parse(""/""), ""Eddard Stark"" }},
-                    {{ 2, {typeof(HierarchyId).FullName}.Parse(""/1/""), ""Robb Stark"" }},
-                    {{ 3, {typeof(HierarchyId).FullName}.Parse(""/2/""), ""Jon Snow"" }}
+                    {{ 1, Microsoft.SqlServer.Types.SqlHierarchyId.Parse(""/""), ""Eddard Stark"" }},
+                    {{ 2, Microsoft.SqlServer.Types.SqlHierarchyId.Parse(""/1/""), ""Robb Stark"" }},
+                    {{ 3, Microsoft.SqlServer.Types.SqlHierarchyId.Parse(""/2/""), ""Jon Snow"" }}
                 }});
 
             migrationBuilder.InsertData(
@@ -101,9 +101,9 @@ protected override void Up(MigrationBuilder migrationBuilder)
                 columns: new[] {{ ""Id"", ""Name"" }},
                 values: new object[,]
                 {{
-                    {{ {typeof(HierarchyId).FullName}.Parse(""/""), ""Eddard Stark"" }},
-                    {{ {typeof(HierarchyId).FullName}.Parse(""/1/""), ""Robb Stark"" }},
-                    {{ {typeof(HierarchyId).FullName}.Parse(""/2/""), ""Jon Snow"" }}
+                    {{ Microsoft.SqlServer.Types.SqlHierarchyId.Parse(""/""), ""Eddard Stark"" }},
+                    {{ Microsoft.SqlServer.Types.SqlHierarchyId.Parse(""/1/""), ""Robb Stark"" }},
+                    {{ Microsoft.SqlServer.Types.SqlHierarchyId.Parse(""/2/""), ""Jon Snow"" }}
                 }});
         }}
 
@@ -128,6 +128,7 @@ public override string GetExpectedSnapshotCode(string rootNamespace)
 using Microsoft.EntityFrameworkCore.Infrastructure;
 using {ThisType.Namespace};
 using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
+using Microsoft.SqlServer.Types;
 
 #nullable disable
 
@@ -160,27 +161,27 @@ protected override void BuildModel(ModelBuilder modelBuilder)
                         new
                         {{
                             Id = 1,
-                            HierarchyId = Microsoft.EntityFrameworkCore.HierarchyId.Parse(""/""),
+                            HierarchyId = Microsoft.SqlServer.Types.SqlHierarchyId.Parse(""/""),
                             Name = ""Eddard Stark""
                         }},
                         new
                         {{
                             Id = 2,
-                            HierarchyId = Microsoft.EntityFrameworkCore.HierarchyId.Parse(""/1/""),
+                            HierarchyId = Microsoft.SqlServer.Types.SqlHierarchyId.Parse(""/1/""),
                             Name = ""Robb Stark""
                         }},
                         new
                         {{
                             Id = 3,
-                            HierarchyId = Microsoft.EntityFrameworkCore.HierarchyId.Parse(""/2/""),
+                            HierarchyId = Microsoft.SqlServer.Types.SqlHierarchyId.Parse(""/2/""),
                             Name = ""Jon Snow""
                         }});
                 }});
 
             modelBuilder.Entity(""{ModelType1.FullName}"", b =>
                 {{
-                    b.Property<{nameof(HierarchyId)}>(""{nameof(Patriarch.Id)}"")
-                        .HasColumnType(""{SqlServerHierarchyIdTypeMappingSourcePlugin.SqlServerTypeName}"");
+                    b.Property<SqlHierarchyId>(""{nameof(Patriarch.Id)}"")
+                        .HasColumnType(""hierarchyid"");
 
                     b.Property<string>(""{nameof(Patriarch.Name)}"")
                         .HasColumnType(""nvarchar(max)"");
@@ -192,17 +193,17 @@ protected override void BuildModel(ModelBuilder modelBuilder)
                     b.HasData(
                         new
                         {{
-                            {nameof(Patriarch.Id)} = Microsoft.EntityFrameworkCore.HierarchyId.Parse(""/""),
+                            {nameof(Patriarch.Id)} = Microsoft.SqlServer.Types.SqlHierarchyId.Parse(""/""),
                             {nameof(Patriarch.Name)} = ""Eddard Stark""
                         }},
                         new
                         {{
-                            {nameof(Patriarch.Id)} = Microsoft.EntityFrameworkCore.HierarchyId.Parse(""/1/""),
+                            {nameof(Patriarch.Id)} = Microsoft.SqlServer.Types.SqlHierarchyId.Parse(""/1/""),
                             {nameof(Patriarch.Name)} = ""Robb Stark""
                         }},
                         new
                         {{
-                            {nameof(Patriarch.Id)} = Microsoft.EntityFrameworkCore.HierarchyId.Parse(""/2/""),
+                            {nameof(Patriarch.Id)} = Microsoft.SqlServer.Types.SqlHierarchyId.Parse(""/2/""),
                             {nameof(Patriarch.Name)} = ""Jon Snow""
                         }});
                 }});
diff --git a/test/EFCore.SqlServer.HierarchyId.Tests/TypeMappingTests.cs b/test/EFCore.SqlServer.HierarchyId.Tests/TypeMappingTests.cs
index c756affa5c..627c0f45d2 100644
--- a/test/EFCore.SqlServer.HierarchyId.Tests/TypeMappingTests.cs
+++ b/test/EFCore.SqlServer.HierarchyId.Tests/TypeMappingTests.cs
@@ -29,8 +29,8 @@ public void Maps_hierarchyid_column()
     {
         var mapping = CreateMapper().FindMapping(
             new RelationalTypeMappingInfo(
-                storeTypeName: SqlServerHierarchyIdTypeMappingSourcePlugin.SqlServerTypeName,
-                storeTypeNameBase: SqlServerHierarchyIdTypeMappingSourcePlugin.SqlServerTypeName,
+                storeTypeName: "hierarchyid",
+                storeTypeNameBase: "hierarchyid",
                 unicode: null,
                 size: null,
                 precision: null,
