diff --git a/src/EFCore.Cosmos/Query/Internal/Translators/CosmosStringMethodTranslator.cs b/src/EFCore.Cosmos/Query/Internal/Translators/CosmosStringMethodTranslator.cs
index 845409fdc9..a9d0b80b5f 100644
--- a/src/EFCore.Cosmos/Query/Internal/Translators/CosmosStringMethodTranslator.cs
+++ b/src/EFCore.Cosmos/Query/Internal/Translators/CosmosStringMethodTranslator.cs
@@ -13,31 +13,52 @@ namespace Microsoft.EntityFrameworkCore.Cosmos.Query.Internal;
 /// </summary>
 public class CosmosStringMethodTranslator(ISqlExpressionFactory sqlExpressionFactory) : IMethodCallTranslator
 {
-    private static readonly MethodInfo IndexOfMethodInfo
+    private static readonly MethodInfo IndexOfMethodInfoString
         = typeof(string).GetRuntimeMethod(nameof(string.IndexOf), [typeof(string)])!;
 
-    private static readonly MethodInfo IndexOfMethodInfoWithStartingPosition
+    private static readonly MethodInfo IndexOfMethodInfoChar
+        = typeof(string).GetRuntimeMethod(nameof(string.IndexOf), [typeof(char)])!;
+
+    private static readonly MethodInfo IndexOfMethodInfoWithStartingPositionString
         = typeof(string).GetRuntimeMethod(nameof(string.IndexOf), [typeof(string), typeof(int)])!;
 
-    private static readonly MethodInfo ReplaceMethodInfo
+    private static readonly MethodInfo IndexOfMethodInfoWithStartingPositionChar
+        = typeof(string).GetRuntimeMethod(nameof(string.IndexOf), [typeof(char), typeof(int)])!;
+
+    private static readonly MethodInfo ReplaceMethodInfoString
         = typeof(string).GetRuntimeMethod(nameof(string.Replace), [typeof(string), typeof(string)])!;
 
-    private static readonly MethodInfo ContainsMethodInfo
+    private static readonly MethodInfo ReplaceMethodInfoChar
+        = typeof(string).GetRuntimeMethod(nameof(string.Replace), [typeof(char), typeof(char)])!;
+
+    private static readonly MethodInfo ContainsMethodInfoString
         = typeof(string).GetRuntimeMethod(nameof(string.Contains), [typeof(string)])!;
 
-    private static readonly MethodInfo ContainsWithStringComparisonMethodInfo
+    private static readonly MethodInfo ContainsMethodInfoChar
+        = typeof(string).GetRuntimeMethod(nameof(string.Contains), [typeof(char)])!;
+
+    private static readonly MethodInfo ContainsWithStringComparisonMethodInfoString
         = typeof(string).GetRuntimeMethod(nameof(string.Contains), [typeof(string), typeof(StringComparison)])!;
 
-    private static readonly MethodInfo StartsWithMethodInfo
+    private static readonly MethodInfo ContainsWithStringComparisonMethodInfoChar
+        = typeof(string).GetRuntimeMethod(nameof(string.Contains), [typeof(char), typeof(StringComparison)])!;
+
+    private static readonly MethodInfo StartsWithMethodInfoString
         = typeof(string).GetRuntimeMethod(nameof(string.StartsWith), [typeof(string)])!;
 
-    private static readonly MethodInfo StartsWithWithStringComparisonMethodInfo
+    private static readonly MethodInfo StartsWithMethodInfoChar
+        = typeof(string).GetRuntimeMethod(nameof(string.StartsWith), [typeof(char)])!;
+
+    private static readonly MethodInfo StartsWithWithStringComparisonMethodInfoString
         = typeof(string).GetRuntimeMethod(nameof(string.StartsWith), [typeof(string), typeof(StringComparison)])!;
 
-    private static readonly MethodInfo EndsWithMethodInfo
+    private static readonly MethodInfo EndsWithMethodInfoString
         = typeof(string).GetRuntimeMethod(nameof(string.EndsWith), [typeof(string)])!;
 
-    private static readonly MethodInfo EndsWithWithStringComparisonMethodInfo
+    private static readonly MethodInfo EndsWithMethodInfoChar
+        = typeof(string).GetRuntimeMethod(nameof(string.EndsWith), [typeof(char)])!;
+
+    private static readonly MethodInfo EndsWithWithStringComparisonMethodInfoString
         = typeof(string).GetRuntimeMethod(nameof(string.EndsWith), [typeof(string), typeof(StringComparison)])!;
 
     private static readonly MethodInfo ToLowerMethodInfo
@@ -109,27 +130,27 @@ public class CosmosStringMethodTranslator(ISqlExpressionFactory sqlExpressionFac
     {
         if (instance != null)
         {
-            if (IndexOfMethodInfo.Equals(method))
+            if (IndexOfMethodInfoString.Equals(method) || IndexOfMethodInfoChar.Equals(method))
             {
                 return TranslateSystemFunction("INDEX_OF", typeof(int), instance, arguments[0]);
             }
 
-            if (IndexOfMethodInfoWithStartingPosition.Equals(method))
+            if (IndexOfMethodInfoWithStartingPositionString.Equals(method) || IndexOfMethodInfoWithStartingPositionChar.Equals(method))
             {
                 return TranslateSystemFunction("INDEX_OF", typeof(int), instance, arguments[0], arguments[1]);
             }
 
-            if (ReplaceMethodInfo.Equals(method))
+            if (ReplaceMethodInfoString.Equals(method) || ReplaceMethodInfoChar.Equals(method))
             {
                 return TranslateSystemFunction("REPLACE", method.ReturnType, instance, arguments[0], arguments[1]);
             }
 
-            if (ContainsMethodInfo.Equals(method))
+            if (ContainsMethodInfoString.Equals(method) || ContainsMethodInfoChar.Equals(method))
             {
                 return TranslateSystemFunction("CONTAINS", typeof(bool), instance, arguments[0]);
             }
 
-            if (ContainsWithStringComparisonMethodInfo.Equals(method))
+            if (ContainsWithStringComparisonMethodInfoString.Equals(method) || ContainsWithStringComparisonMethodInfoChar.Equals(method))
             {
                 if (arguments[1] is SqlConstantExpression { Value: StringComparison comparisonType })
                 {
@@ -150,12 +171,12 @@ public class CosmosStringMethodTranslator(ISqlExpressionFactory sqlExpressionFac
                 return null;
             }
 
-            if (StartsWithMethodInfo.Equals(method))
+            if (StartsWithMethodInfoString.Equals(method) || StartsWithMethodInfoChar.Equals(method))
             {
                 return TranslateSystemFunction("STARTSWITH", typeof(bool), instance, arguments[0]);
             }
 
-            if (StartsWithWithStringComparisonMethodInfo.Equals(method))
+            if (StartsWithWithStringComparisonMethodInfoString.Equals(method))
             {
                 if (arguments[1] is SqlConstantExpression { Value: StringComparison comparisonType })
                 {
@@ -176,12 +197,12 @@ public class CosmosStringMethodTranslator(ISqlExpressionFactory sqlExpressionFac
                 return null;
             }
 
-            if (EndsWithMethodInfo.Equals(method))
+            if (EndsWithMethodInfoString.Equals(method) || EndsWithMethodInfoChar.Equals(method))
             {
                 return TranslateSystemFunction("ENDSWITH", typeof(bool), instance, arguments[0]);
             }
 
-            if (EndsWithWithStringComparisonMethodInfo.Equals(method))
+            if (EndsWithWithStringComparisonMethodInfoString.Equals(method))
             {
                 if (arguments[1] is SqlConstantExpression { Value: StringComparison comparisonType })
                 {
diff --git a/src/EFCore.SqlServer/Query/Internal/SqlServerSqlTranslatingExpressionVisitor.cs b/src/EFCore.SqlServer/Query/Internal/SqlServerSqlTranslatingExpressionVisitor.cs
index c0a7d72d43..8e4edd47f0 100644
--- a/src/EFCore.SqlServer/Query/Internal/SqlServerSqlTranslatingExpressionVisitor.cs
+++ b/src/EFCore.SqlServer/Query/Internal/SqlServerSqlTranslatingExpressionVisitor.cs
@@ -53,15 +53,24 @@ public class SqlServerSqlTranslatingExpressionVisitor : RelationalSqlTranslating
             ExpressionType.Modulo
         ];
 
-    private static readonly MethodInfo StringStartsWithMethodInfo
+    private static readonly MethodInfo StringStartsWithMethodInfoString
         = typeof(string).GetRuntimeMethod(nameof(string.StartsWith), [typeof(string)])!;
 
-    private static readonly MethodInfo StringEndsWithMethodInfo
+    private static readonly MethodInfo StringStartsWithMethodInfoChar
+        = typeof(string).GetRuntimeMethod(nameof(string.StartsWith), [typeof(char)])!;
+
+    private static readonly MethodInfo StringEndsWithMethodInfoString
         = typeof(string).GetRuntimeMethod(nameof(string.EndsWith), [typeof(string)])!;
 
-    private static readonly MethodInfo StringContainsMethodInfo
+    private static readonly MethodInfo StringEndsWithMethodInfoChar
+        = typeof(string).GetRuntimeMethod(nameof(string.EndsWith), [typeof(char)])!;
+
+    private static readonly MethodInfo StringContainsMethodInfoString
         = typeof(string).GetRuntimeMethod(nameof(string.Contains), [typeof(string)])!;
 
+    private static readonly MethodInfo StringContainsMethodInfoChar
+        = typeof(string).GetRuntimeMethod(nameof(string.Contains), [typeof(char)])!;
+
     private static readonly MethodInfo StringJoinMethodInfo
         = typeof(string).GetRuntimeMethod(nameof(string.Join), [typeof(string), typeof(string[])])!;
 
@@ -187,21 +196,21 @@ protected override Expression VisitMethodCall(MethodCallExpression methodCallExp
                 methodCallExpression.Type);
         }
 
-        if (method == StringStartsWithMethodInfo
+        if ((method == StringStartsWithMethodInfoString || method == StringStartsWithMethodInfoChar)
             && TryTranslateStartsEndsWithContains(
                 methodCallExpression.Object!, methodCallExpression.Arguments[0], StartsEndsWithContains.StartsWith, out var translation1))
         {
             return translation1;
         }
 
-        if (method == StringEndsWithMethodInfo
+        if ((method == StringEndsWithMethodInfoString || method == StringEndsWithMethodInfoChar)
             && TryTranslateStartsEndsWithContains(
                 methodCallExpression.Object!, methodCallExpression.Arguments[0], StartsEndsWithContains.EndsWith, out var translation2))
         {
             return translation2;
         }
 
-        if (method == StringContainsMethodInfo
+        if ((method == StringContainsMethodInfoString || method == StringContainsMethodInfoChar)
             && TryTranslateStartsEndsWithContains(
                 methodCallExpression.Object!, methodCallExpression.Arguments[0], StartsEndsWithContains.Contains, out var translation3))
         {
@@ -328,6 +337,32 @@ methodType switch
                                 }),
                             _sqlExpressionFactory.Constant(LikeEscapeString)),
 
+                        char s when !IsLikeWildChar(s)
+                            => _sqlExpressionFactory.Like(
+                                translatedInstance,
+                                _sqlExpressionFactory.Constant(
+                                    methodType switch
+                                    {
+                                        StartsEndsWithContains.StartsWith => s + "%",
+                                        StartsEndsWithContains.EndsWith => "%" + s,
+                                        StartsEndsWithContains.Contains => $"%{s}%",
+
+                                        _ => throw new ArgumentOutOfRangeException(nameof(methodType), methodType, null)
+                                    })),
+
+                        char s => _sqlExpressionFactory.Like(
+                            translatedInstance,
+                            _sqlExpressionFactory.Constant(
+                                methodType switch
+                                {
+                                    StartsEndsWithContains.StartsWith => LikeEscapeChar + s + "%",
+                                    StartsEndsWithContains.EndsWith => "%" + LikeEscapeChar + s,
+                                    StartsEndsWithContains.Contains => $"%{LikeEscapeChar}{s}%",
+
+                                    _ => throw new ArgumentOutOfRangeException(nameof(methodType), methodType, null)
+                                }),
+                            _sqlExpressionFactory.Constant(LikeEscapeString)),
+
                         _ => throw new UnreachableException()
                     };
 
@@ -463,6 +498,22 @@ SqlExpression CharIndexGreaterThanZero()
                 _ => throw new ArgumentOutOfRangeException(nameof(methodType), methodType, null)
             },
 
+            char s when !IsLikeWildChar(s) => methodType switch
+            {
+                StartsEndsWithContains.StartsWith => s + "%",
+                StartsEndsWithContains.EndsWith => "%" + s,
+                StartsEndsWithContains.Contains => $"%{s}%",
+                _ => throw new ArgumentOutOfRangeException(nameof(methodType), methodType, null)
+            },
+
+            char s => methodType switch
+            {
+                StartsEndsWithContains.StartsWith => LikeEscapeChar + s + "%",
+                StartsEndsWithContains.EndsWith => "%" + LikeEscapeChar + s,
+                StartsEndsWithContains.Contains => $"%{LikeEscapeChar}{s}%",
+                _ => throw new ArgumentOutOfRangeException(nameof(methodType), methodType, null)
+            },
+
             _ => throw new UnreachableException()
         };
 
diff --git a/src/EFCore.SqlServer/Query/Internal/Translators/SqlServerStringMethodTranslator.cs b/src/EFCore.SqlServer/Query/Internal/Translators/SqlServerStringMethodTranslator.cs
index 6d0a410bb7..db7c88a1e0 100644
--- a/src/EFCore.SqlServer/Query/Internal/Translators/SqlServerStringMethodTranslator.cs
+++ b/src/EFCore.SqlServer/Query/Internal/Translators/SqlServerStringMethodTranslator.cs
@@ -3,6 +3,7 @@
 
 using Microsoft.EntityFrameworkCore.Query.SqlExpressions;
 using Microsoft.EntityFrameworkCore.SqlServer.Infrastructure.Internal;
+using CharTypeMapping = Microsoft.EntityFrameworkCore.Storage.CharTypeMapping;
 using ExpressionExtensions = Microsoft.EntityFrameworkCore.Query.ExpressionExtensions;
 
 // ReSharper disable once CheckNamespace
@@ -16,15 +17,24 @@ namespace Microsoft.EntityFrameworkCore.SqlServer.Query.Internal;
 /// </summary>
 public class SqlServerStringMethodTranslator : IMethodCallTranslator
 {
-    private static readonly MethodInfo IndexOfMethodInfo
+    private static readonly MethodInfo IndexOfMethodInfoString
         = typeof(string).GetRuntimeMethod(nameof(string.IndexOf), [typeof(string)])!;
 
-    private static readonly MethodInfo IndexOfMethodInfoWithStartingPosition
+    private static readonly MethodInfo IndexOfMethodInfoChar
+        = typeof(string).GetRuntimeMethod(nameof(string.IndexOf), [typeof(char)])!;
+
+    private static readonly MethodInfo IndexOfMethodInfoWithStartingPositionString
         = typeof(string).GetRuntimeMethod(nameof(string.IndexOf), [typeof(string), typeof(int)])!;
 
-    private static readonly MethodInfo ReplaceMethodInfo
+    private static readonly MethodInfo IndexOfMethodInfoWithStartingPositionChar
+        = typeof(string).GetRuntimeMethod(nameof(string.IndexOf), [typeof(char), typeof(int)])!;
+
+    private static readonly MethodInfo ReplaceMethodInfoString
         = typeof(string).GetRuntimeMethod(nameof(string.Replace), [typeof(string), typeof(string)])!;
 
+    private static readonly MethodInfo ReplaceMethodInfoChar
+        = typeof(string).GetRuntimeMethod(nameof(string.Replace), [typeof(char), typeof(char)])!;
+
     private static readonly MethodInfo ToLowerMethodInfo
         = typeof(string).GetRuntimeMethod(nameof(string.ToLower), Type.EmptyTypes)!;
 
@@ -115,25 +125,25 @@ public SqlServerStringMethodTranslator(ISqlExpressionFactory sqlExpressionFactor
     {
         if (instance != null)
         {
-            if (IndexOfMethodInfo.Equals(method))
+            if (IndexOfMethodInfoString.Equals(method) || IndexOfMethodInfoChar.Equals(method))
             {
                 return TranslateIndexOf(instance, method, arguments[0], null);
             }
 
-            if (IndexOfMethodInfoWithStartingPosition.Equals(method))
+            if (IndexOfMethodInfoWithStartingPositionString.Equals(method) || IndexOfMethodInfoWithStartingPositionChar.Equals(method))
             {
                 return TranslateIndexOf(instance, method, arguments[0], arguments[1]);
             }
 
-            if (ReplaceMethodInfo.Equals(method))
+            if (ReplaceMethodInfoString.Equals(method) || ReplaceMethodInfoChar.Equals(method))
             {
                 var firstArgument = arguments[0];
                 var secondArgument = arguments[1];
                 var stringTypeMapping = ExpressionExtensions.InferTypeMapping(instance, firstArgument, secondArgument);
 
                 instance = _sqlExpressionFactory.ApplyTypeMapping(instance, stringTypeMapping);
-                firstArgument = _sqlExpressionFactory.ApplyTypeMapping(firstArgument, stringTypeMapping);
-                secondArgument = _sqlExpressionFactory.ApplyTypeMapping(secondArgument, stringTypeMapping);
+                firstArgument = _sqlExpressionFactory.ApplyTypeMapping(firstArgument, firstArgument.Type == typeof(char) ? CharTypeMapping.Default : stringTypeMapping);
+                secondArgument = _sqlExpressionFactory.ApplyTypeMapping(secondArgument, secondArgument.Type == typeof(char) ? CharTypeMapping.Default : stringTypeMapping);
 
                 return _sqlExpressionFactory.Function(
                     "REPLACE",
@@ -323,7 +333,8 @@ public SqlServerStringMethodTranslator(ISqlExpressionFactory sqlExpressionFactor
         SqlExpression? startIndex)
     {
         var stringTypeMapping = ExpressionExtensions.InferTypeMapping(instance, searchExpression)!;
-        searchExpression = _sqlExpressionFactory.ApplyTypeMapping(searchExpression, stringTypeMapping);
+        searchExpression = _sqlExpressionFactory.ApplyTypeMapping(searchExpression, searchExpression.Type == typeof(char) ? CharTypeMapping.Default : stringTypeMapping);
+
         instance = _sqlExpressionFactory.ApplyTypeMapping(instance, stringTypeMapping);
 
         var charIndexArguments = new List<SqlExpression> { searchExpression, instance };
diff --git a/src/EFCore.Sqlite.Core/Query/Internal/SqliteSqlTranslatingExpressionVisitor.cs b/src/EFCore.Sqlite.Core/Query/Internal/SqliteSqlTranslatingExpressionVisitor.cs
index 48aa49e1c2..0d04114979 100644
--- a/src/EFCore.Sqlite.Core/Query/Internal/SqliteSqlTranslatingExpressionVisitor.cs
+++ b/src/EFCore.Sqlite.Core/Query/Internal/SqliteSqlTranslatingExpressionVisitor.cs
@@ -19,12 +19,18 @@ public class SqliteSqlTranslatingExpressionVisitor : RelationalSqlTranslatingExp
     private readonly QueryCompilationContext _queryCompilationContext;
     private readonly ISqlExpressionFactory _sqlExpressionFactory;
 
-    private static readonly MethodInfo StringStartsWithMethodInfo
+    private static readonly MethodInfo StringStartsWithMethodInfoString
         = typeof(string).GetRuntimeMethod(nameof(string.StartsWith), [typeof(string)])!;
 
-    private static readonly MethodInfo StringEndsWithMethodInfo
+    private static readonly MethodInfo StringStartsWithMethodInfoChar
+        = typeof(string).GetRuntimeMethod(nameof(string.StartsWith), [typeof(char)])!;
+
+    private static readonly MethodInfo StringEndsWithMethodInfoString
         = typeof(string).GetRuntimeMethod(nameof(string.EndsWith), [typeof(string)])!;
 
+    private static readonly MethodInfo StringEndsWithMethodInfoChar
+        = typeof(string).GetRuntimeMethod(nameof(string.EndsWith), [typeof(char)])!;
+
     private static readonly MethodInfo EscapeLikePatternParameterMethod =
         typeof(SqliteSqlTranslatingExpressionVisitor).GetTypeInfo().GetDeclaredMethod(nameof(ConstructLikePatternParameter))!;
 
@@ -255,14 +261,14 @@ protected override Expression VisitMethodCall(MethodCallExpression methodCallExp
     {
         var method = methodCallExpression.Method;
 
-        if (method == StringStartsWithMethodInfo
+        if ((method == StringStartsWithMethodInfoString || method == StringStartsWithMethodInfoChar)
             && TryTranslateStartsEndsWith(
                 methodCallExpression.Object!, methodCallExpression.Arguments[0], startsWith: true, out var translation1))
         {
             return translation1;
         }
 
-        if (method == StringEndsWithMethodInfo
+        if ((method == StringEndsWithMethodInfoString || method == StringEndsWithMethodInfoChar)
             && TryTranslateStartsEndsWith(
                 methodCallExpression.Object!, methodCallExpression.Arguments[0], startsWith: false, out var translation2))
         {
@@ -316,6 +322,15 @@ protected override Expression VisitMethodCall(MethodCallExpression methodCallExp
                                 translatedInstance,
                                 _sqlExpressionFactory.Constant(startsWith ? s + '%' : '%' + s)),
 
+                        char s => IsLikeWildChar(s)
+                            ? _sqlExpressionFactory.Like(
+                                translatedInstance,
+                                _sqlExpressionFactory.Constant(startsWith ? LikeEscapeString + s  + "%" : '%' + LikeEscapeString + s),
+                                _sqlExpressionFactory.Constant(LikeEscapeString))
+                            : _sqlExpressionFactory.Like(
+                                translatedInstance,
+                                _sqlExpressionFactory.Constant(startsWith ? s + "%" : "%" + s)),
+
                         _ => throw new UnreachableException()
                     };
 
@@ -443,6 +458,10 @@ protected override Expression VisitMethodCall(MethodCallExpression methodCallExp
 
             string s => startsWith ? EscapeLikePattern(s) + '%' : '%' + EscapeLikePattern(s),
 
+            char s when IsLikeWildChar(s )=> startsWith ? LikeEscapeString + s + '%' : '%' + LikeEscapeString + s,
+
+            char s => startsWith ? s + "%" : "%" + s,
+
             _ => throw new UnreachableException()
         };
 
diff --git a/src/EFCore.Sqlite.Core/Query/Internal/Translators/SqliteStringMethodTranslator.cs b/src/EFCore.Sqlite.Core/Query/Internal/Translators/SqliteStringMethodTranslator.cs
index bc38e4af19..7297982a0e 100644
--- a/src/EFCore.Sqlite.Core/Query/Internal/Translators/SqliteStringMethodTranslator.cs
+++ b/src/EFCore.Sqlite.Core/Query/Internal/Translators/SqliteStringMethodTranslator.cs
@@ -15,12 +15,24 @@ namespace Microsoft.EntityFrameworkCore.Sqlite.Query.Internal;
 /// </summary>
 public class SqliteStringMethodTranslator : IMethodCallTranslator
 {
-    private static readonly MethodInfo IndexOfMethodInfo
+    private static readonly MethodInfo IndexOfMethodInfoString
         = typeof(string).GetRuntimeMethod(nameof(string.IndexOf), [typeof(string)])!;
 
-    private static readonly MethodInfo ReplaceMethodInfo
+    private static readonly MethodInfo IndexOfMethodInfoChar
+        = typeof(string).GetRuntimeMethod(nameof(string.IndexOf), [typeof(char)])!;
+
+    private static readonly MethodInfo IndexOfMethodInfoWithStartingPositionString
+        = typeof(string).GetRuntimeMethod(nameof(string.IndexOf), [typeof(string), typeof(int)])!;
+
+    private static readonly MethodInfo IndexOfMethodInfoWithStartingPositionChar
+        = typeof(string).GetRuntimeMethod(nameof(string.IndexOf), [typeof(char), typeof(int)])!;
+
+    private static readonly MethodInfo ReplaceMethodInfoString
         = typeof(string).GetRuntimeMethod(nameof(string.Replace), [typeof(string), typeof(string)])!;
 
+    private static readonly MethodInfo ReplaceMethodInfoChar
+        = typeof(string).GetRuntimeMethod(nameof(string.Replace), [typeof(char), typeof(char)])!;
+
     private static readonly MethodInfo ToLowerMethodInfo
         = typeof(string).GetRuntimeMethod(nameof(string.ToLower), Type.EmptyTypes)!;
 
@@ -65,8 +77,10 @@ public class SqliteStringMethodTranslator : IMethodCallTranslator
     private static readonly MethodInfo TrimMethodInfoWithCharArrayArg
         = typeof(string).GetRuntimeMethod(nameof(string.Trim), [typeof(char[])])!;
 
-    private static readonly MethodInfo ContainsMethodInfo
+    private static readonly MethodInfo ContainsMethodInfoString
         = typeof(string).GetRuntimeMethod(nameof(string.Contains), [typeof(string)])!;
+    private static readonly MethodInfo ContainsMethodInfoChar
+        = typeof(string).GetRuntimeMethod(nameof(string.Contains), [typeof(char)])!;
 
     private static readonly MethodInfo FirstOrDefaultMethodInfoWithoutArgs
         = typeof(Enumerable).GetRuntimeMethods().Single(
@@ -103,7 +117,7 @@ public SqliteStringMethodTranslator(ISqlExpressionFactory sqlExpressionFactory)
     {
         if (instance != null)
         {
-            if (IndexOfMethodInfo.Equals(method))
+            if (IndexOfMethodInfoString.Equals(method) || IndexOfMethodInfoChar.Equals(method))
             {
                 var argument = arguments[0];
                 var stringTypeMapping = ExpressionExtensions.InferTypeMapping(instance, argument);
@@ -114,7 +128,7 @@ public SqliteStringMethodTranslator(ISqlExpressionFactory sqlExpressionFactory)
                         new[]
                         {
                             _sqlExpressionFactory.ApplyTypeMapping(instance, stringTypeMapping),
-                            _sqlExpressionFactory.ApplyTypeMapping(argument, stringTypeMapping)
+                            _sqlExpressionFactory.ApplyTypeMapping(argument, argument.Type == typeof(char) ? CharTypeMapping.Default : stringTypeMapping)
                         },
                         nullable: true,
                         argumentsPropagateNullability: Statics.TrueArrays[2],
@@ -122,7 +136,35 @@ public SqliteStringMethodTranslator(ISqlExpressionFactory sqlExpressionFactory)
                     _sqlExpressionFactory.Constant(1));
             }
 
-            if (ReplaceMethodInfo.Equals(method))
+            if (IndexOfMethodInfoWithStartingPositionString.Equals(method) || IndexOfMethodInfoWithStartingPositionChar.Equals(method))
+            {
+                var argument = arguments[0];
+                var stringTypeMapping = ExpressionExtensions.InferTypeMapping(instance, argument);
+                instance = _sqlExpressionFactory.Function(
+                    "substr",
+                    new[] { instance, _sqlExpressionFactory.Add(arguments[1], _sqlExpressionFactory.Constant(1)) },
+                    nullable: true,
+                    argumentsPropagateNullability: Statics.TrueArrays[2],
+                    method.ReturnType,
+                    instance.TypeMapping);
+
+                return _sqlExpressionFactory.Add(
+                    _sqlExpressionFactory.Subtract(
+                        _sqlExpressionFactory.Function(
+                            "instr",
+                            new[]
+                            {
+                                _sqlExpressionFactory.ApplyTypeMapping(instance, stringTypeMapping),
+                                _sqlExpressionFactory.ApplyTypeMapping(argument, argument.Type == typeof(char) ? CharTypeMapping.Default : stringTypeMapping)
+                            },
+                            nullable: true,
+                            argumentsPropagateNullability: Statics.TrueArrays[2],
+                            method.ReturnType),
+                        _sqlExpressionFactory.Constant(1)),
+                    arguments[1]);
+            }
+
+            if (ReplaceMethodInfoString.Equals(method) || ReplaceMethodInfoChar.Equals(method))
             {
                 var firstArgument = arguments[0];
                 var secondArgument = arguments[1];
@@ -133,8 +175,8 @@ public SqliteStringMethodTranslator(ISqlExpressionFactory sqlExpressionFactory)
                     new[]
                     {
                         _sqlExpressionFactory.ApplyTypeMapping(instance, stringTypeMapping),
-                        _sqlExpressionFactory.ApplyTypeMapping(firstArgument, stringTypeMapping),
-                        _sqlExpressionFactory.ApplyTypeMapping(secondArgument, stringTypeMapping)
+                        _sqlExpressionFactory.ApplyTypeMapping(firstArgument, firstArgument.Type == typeof(char) ? CharTypeMapping.Default : stringTypeMapping),
+                        _sqlExpressionFactory.ApplyTypeMapping(secondArgument, secondArgument.Type == typeof(char) ? CharTypeMapping.Default : stringTypeMapping)
                     },
                     nullable: true,
                     argumentsPropagateNullability: Statics.TrueArrays[3],
@@ -197,13 +239,13 @@ public SqliteStringMethodTranslator(ISqlExpressionFactory sqlExpressionFactory)
                 return ProcessTrimMethod(instance, arguments, "trim");
             }
 
-            if (ContainsMethodInfo.Equals(method))
+            if (ContainsMethodInfoString.Equals(method) || ContainsMethodInfoChar.Equals(method))
             {
                 var pattern = arguments[0];
                 var stringTypeMapping = ExpressionExtensions.InferTypeMapping(instance, pattern);
 
                 instance = _sqlExpressionFactory.ApplyTypeMapping(instance, stringTypeMapping);
-                pattern = _sqlExpressionFactory.ApplyTypeMapping(pattern, stringTypeMapping);
+                pattern = _sqlExpressionFactory.ApplyTypeMapping(pattern, pattern.Type == typeof(char) ? CharTypeMapping.Default : stringTypeMapping);
 
                 return
                     _sqlExpressionFactory.GreaterThan(
diff --git a/test/EFCore.Cosmos.FunctionalTests/Query/Translations/StringTranslationsCosmosTest.cs b/test/EFCore.Cosmos.FunctionalTests/Query/Translations/StringTranslationsCosmosTest.cs
index 3f9b73ecd4..195b9e1670 100644
--- a/test/EFCore.Cosmos.FunctionalTests/Query/Translations/StringTranslationsCosmosTest.cs
+++ b/test/EFCore.Cosmos.FunctionalTests/Query/Translations/StringTranslationsCosmosTest.cs
@@ -168,6 +168,20 @@ public override Task IndexOf(bool async)
 SELECT VALUE c
 FROM root c
 WHERE (INDEX_OF(c["String"], "eattl") != -1)
+""");
+            });
+
+    public override Task IndexOf_Char(bool async)
+        => Fixture.NoSyncTest(
+            async, async a =>
+            {
+                await base.IndexOf_Char(a);
+
+                AssertSql(
+                    """
+SELECT VALUE c
+FROM root c
+WHERE (INDEX_OF(c["String"], "e") != -1)
 """);
             });
 
@@ -195,6 +209,22 @@ public override Task IndexOf_with_one_parameter_arg(bool async)
                     """
 @pattern=?
 
+SELECT VALUE c
+FROM root c
+WHERE (INDEX_OF(c["String"], @pattern) = 1)
+""");
+            });
+
+    public override Task IndexOf_with_one_parameter_arg_char(bool async)
+        => Fixture.NoSyncTest(
+            async, async a =>
+            {
+                await base.IndexOf_with_one_parameter_arg_char(a);
+
+                AssertSql(
+                    """
+@pattern=?
+
 SELECT VALUE c
 FROM root c
 WHERE (INDEX_OF(c["String"], @pattern) = 1)
@@ -212,6 +242,20 @@ public override Task IndexOf_with_constant_starting_position(bool async)
 SELECT VALUE c
 FROM root c
 WHERE ((LENGTH(c["String"]) > 2) AND (INDEX_OF(c["String"], "e", 2) = 6))
+""");
+            });
+
+    public override Task IndexOf_with_constant_starting_position_char(bool async)
+        => Fixture.NoSyncTest(
+            async, async a =>
+            {
+                await base.IndexOf_with_constant_starting_position_char(a);
+
+                AssertSql(
+                    """
+SELECT VALUE c
+FROM root c
+WHERE ((LENGTH(c["String"]) > 2) AND (INDEX_OF(c["String"], "e", 2) = 6))
 """);
             });
 
@@ -225,6 +269,22 @@ public override Task IndexOf_with_parameter_starting_position(bool async)
                     """
 @start=?
 
+SELECT VALUE c
+FROM root c
+WHERE ((LENGTH(c["String"]) > 2) AND (INDEX_OF(c["String"], "e", @start) = 6))
+""");
+            });
+
+    public override Task IndexOf_with_parameter_starting_position_char(bool async)
+        => Fixture.NoSyncTest(
+            async, async a =>
+            {
+                await base.IndexOf_with_parameter_starting_position_char(a);
+
+                AssertSql(
+                    """
+@start=?
+
 SELECT VALUE c
 FROM root c
 WHERE ((LENGTH(c["String"]) > 2) AND (INDEX_OF(c["String"], "e", @start) = 6))
@@ -252,6 +312,20 @@ public override Task Replace(bool async)
 SELECT VALUE c
 FROM root c
 WHERE (REPLACE(c["String"], "Sea", "Rea") = "Reattle")
+""");
+            });
+
+    public override Task Replace_Char(bool async)
+        => Fixture.NoSyncTest(
+            async, async a =>
+            {
+                await base.Replace_Char(a);
+
+                AssertSql(
+                    """
+SELECT VALUE c
+FROM root c
+WHERE (REPLACE(c["String"], "S", "R") = "Reattle")
 """);
             });
 
@@ -440,6 +514,20 @@ public override Task StartsWith_Literal(bool async)
 SELECT VALUE c
 FROM root c
 WHERE STARTSWITH(c["String"], "Se")
+""");
+            });
+
+    public override Task StartsWith_Literal_Char(bool async)
+        => Fixture.NoSyncTest(
+            async, async a =>
+            {
+                await base.StartsWith_Literal_Char(a);
+
+                AssertSql(
+                    """
+SELECT VALUE c
+FROM root c
+WHERE STARTSWITH(c["String"], "S")
 """);
             });
 
@@ -453,6 +541,22 @@ public override Task StartsWith_Parameter(bool async)
                     """
 @pattern=?
 
+SELECT VALUE c
+FROM root c
+WHERE STARTSWITH(c["String"], @pattern)
+""");
+            });
+
+    public override Task StartsWith_Parameter_Char(bool async)
+        => Fixture.NoSyncTest(
+            async, async a =>
+            {
+                await base.StartsWith_Parameter_Char(a);
+
+                AssertSql(
+                    """
+@pattern=?
+
 SELECT VALUE c
 FROM root c
 WHERE STARTSWITH(c["String"], @pattern)
@@ -525,6 +629,20 @@ public override Task EndsWith_Literal(bool async)
 SELECT VALUE c
 FROM root c
 WHERE ENDSWITH(c["String"], "le")
+""");
+            });
+
+    public override Task EndsWith_Literal_Char(bool async)
+        => Fixture.NoSyncTest(
+            async, async a =>
+            {
+                await base.EndsWith_Literal_Char(a);
+
+                AssertSql(
+                    """
+SELECT VALUE c
+FROM root c
+WHERE ENDSWITH(c["String"], "e")
 """);
             });
 
@@ -538,6 +656,22 @@ public override Task EndsWith_Parameter(bool async)
                     """
 @pattern=?
 
+SELECT VALUE c
+FROM root c
+WHERE ENDSWITH(c["String"], @pattern)
+""");
+            });
+
+    public override Task EndsWith_Parameter_Char(bool async)
+        => Fixture.NoSyncTest(
+            async, async a =>
+            {
+                await base.EndsWith_Parameter_Char(a);
+
+                AssertSql(
+                    """
+@pattern=?
+
 SELECT VALUE c
 FROM root c
 WHERE ENDSWITH(c["String"], @pattern)
@@ -613,6 +747,20 @@ WHERE CONTAINS(c["String"], "eattl")
 """);
             });
 
+    public override Task Contains_Literal_Char(bool async)
+        => Fixture.NoSyncTest(
+            async, async a =>
+            {
+                await base.Contains_Literal_Char(a);
+
+                AssertSql(
+                    """
+    SELECT VALUE c
+    FROM root c
+    WHERE CONTAINS(c["String"], "e")
+    """);
+            });
+
     public override Task Contains_Column(bool async)
         => Fixture.NoSyncTest(
             async, async a =>
diff --git a/test/EFCore.Specification.Tests/Query/Translations/StringTranslationsTestBase.cs b/test/EFCore.Specification.Tests/Query/Translations/StringTranslationsTestBase.cs
index 5360768ac3..9f3e9fcc20 100644
--- a/test/EFCore.Specification.Tests/Query/Translations/StringTranslationsTestBase.cs
+++ b/test/EFCore.Specification.Tests/Query/Translations/StringTranslationsTestBase.cs
@@ -125,6 +125,17 @@ public virtual Task IndexOf(bool async)
                 ss => ss.Set<BasicTypesEntity>().Where(b => b.String.IndexOf("Eattl") != -1),
                 ss => ss.Set<BasicTypesEntity>().Where(b => b.String.IndexOf("Eattl", StringComparison.OrdinalIgnoreCase) != -1));
 
+    [ConditionalTheory]
+    [MemberData(nameof(IsAsyncData))]
+    public virtual Task IndexOf_Char(bool async)
+        => IsCaseSensitive
+            ? AssertQuery(
+                async,
+                ss => ss.Set<BasicTypesEntity>().Where(b => b.String.IndexOf('e') != -1))
+            : AssertQuery(
+                async,
+                ss => ss.Set<BasicTypesEntity>().Where(b => b.String.IndexOf('e') != -1));
+
     [ConditionalTheory]
     [MemberData(nameof(IsAsyncData))]
     public virtual Task IndexOf_with_empty_string(bool async)
@@ -156,6 +167,29 @@ public virtual Task IndexOf_with_one_parameter_arg(bool async)
         }
     }
 
+    [ConditionalTheory]
+    [MemberData(nameof(IsAsyncData))]
+    public virtual Task IndexOf_with_one_parameter_arg_char(bool async)
+    {
+        if (IsCaseSensitive)
+        {
+            var pattern = 'e';
+
+            return AssertQuery(
+                async,
+                ss => ss.Set<BasicTypesEntity>().Where(b => b.String.IndexOf(pattern) == 1));
+        }
+        else
+        {
+            var pattern = 'e';
+
+            return AssertQuery(
+                async,
+                ss => ss.Set<BasicTypesEntity>().Where(b => b.String.IndexOf(pattern) == 1),
+                ss => ss.Set<BasicTypesEntity>().Where(b => b.String.IndexOf(pattern, StringComparison.OrdinalIgnoreCase) == 1));
+        }
+    }
+
     [ConditionalTheory]
     [MemberData(nameof(IsAsyncData))]
     public virtual Task IndexOf_with_constant_starting_position(bool async)
@@ -163,6 +197,13 @@ public virtual Task IndexOf_with_constant_starting_position(bool async)
             async,
             ss => ss.Set<BasicTypesEntity>().Where(b => b.String.Length > 2 && b.String.IndexOf("e", 2) == 6));
 
+    [ConditionalTheory]
+    [MemberData(nameof(IsAsyncData))]
+    public virtual Task IndexOf_with_constant_starting_position_char(bool async)
+        => AssertQuery(
+            async,
+            ss => ss.Set<BasicTypesEntity>().Where(b => b.String.Length > 2 && b.String.IndexOf('e', 2) == 6));
+
 #pragma warning disable CA1866 // Use 'string.Method(char)' instead of 'string.Method(string)' for string with single char
     [ConditionalTheory]
     [MemberData(nameof(IsAsyncData))]
@@ -183,6 +224,22 @@ public virtual Task IndexOf_with_parameter_starting_position(bool async)
     }
 #pragma warning restore CA1866
 
+    [ConditionalTheory]
+    [MemberData(nameof(IsAsyncData))]
+    public virtual Task IndexOf_with_parameter_starting_position_char(bool async)
+    {
+        var start = 2;
+
+        return IsCaseSensitive
+            ? AssertQuery(
+                async,
+                ss => ss.Set<BasicTypesEntity>().Where(b => b.String.Length > 2 && b.String.IndexOf('e', start) == 6))
+            : AssertQuery(
+                async,
+                ss => ss.Set<BasicTypesEntity>().Where(
+                    b => b.String.Length > 2 && b.String.IndexOf('e', start) == 6));
+    }
+
     [ConditionalTheory]
     [MemberData(nameof(IsAsyncData))]
     public virtual Task IndexOf_after_ToString(bool async)
@@ -213,6 +270,13 @@ public virtual Task Replace(bool async)
             ss => ss.Set<BasicTypesEntity>().Where(b => b.String.Replace("sea", "rea") == "reattle"),
             ss => ss.Set<BasicTypesEntity>().Where(b => b.String.Replace("sea", "rea", StringComparison.OrdinalIgnoreCase) == "reattle"));
 
+    [ConditionalTheory]
+    [MemberData(nameof(IsAsyncData))]
+    public virtual Task Replace_Char(bool async)
+        => AssertQuery(
+            async,
+            ss => ss.Set<BasicTypesEntity>().Where(b => b.String.Replace('S', 'R') == "Reattle"));
+
     [ConditionalTheory]
     [MemberData(nameof(IsAsyncData))]
     public virtual Task Replace_with_empty_string(bool async)
@@ -353,6 +417,18 @@ public virtual Task StartsWith_Literal(bool async)
                 ss => ss.Set<BasicTypesEntity>().Where(b => b.String.StartsWith("se")),
                 ss => ss.Set<BasicTypesEntity>().Where(b => b.String.StartsWith("se", StringComparison.OrdinalIgnoreCase)));
 
+    [ConditionalTheory]
+    [MemberData(nameof(IsAsyncData))]
+    public virtual Task StartsWith_Literal_Char(bool async)
+        => IsCaseSensitive
+            ? AssertQuery(
+                async,
+                ss => ss.Set<BasicTypesEntity>().Where(b => b.String.StartsWith('S')))
+            : AssertQuery(
+                async,
+                ss => ss.Set<BasicTypesEntity>().Where(b => b.String.StartsWith('S')),
+                ss => ss.Set<BasicTypesEntity>().Where(b => b.String.StartsWith('S')));
+
     [ConditionalTheory]
     [MemberData(nameof(IsAsyncData))]
     public virtual Task StartsWith_Parameter(bool async)
@@ -376,6 +452,29 @@ public virtual Task StartsWith_Parameter(bool async)
         }
     }
 
+    [ConditionalTheory]
+    [MemberData(nameof(IsAsyncData))]
+    public virtual Task StartsWith_Parameter_Char(bool async)
+    {
+        if (IsCaseSensitive)
+        {
+            var pattern = 'S';
+
+            return AssertQuery(
+                async,
+                ss => ss.Set<BasicTypesEntity>().Where(b => b.String.StartsWith(pattern)));
+        }
+        else
+        {
+            var pattern = 'S';
+
+            return AssertQuery(
+                async,
+                ss => ss.Set<BasicTypesEntity>().Where(b => b.String.StartsWith(pattern)),
+                ss => ss.Set<BasicTypesEntity>().Where(b => b.String.StartsWith(pattern)));
+        }
+    }
+
     [ConditionalTheory]
     [MemberData(nameof(IsAsyncData))]
     public virtual Task StartsWith_Column(bool async)
@@ -442,6 +541,17 @@ public virtual Task EndsWith_Literal(bool async)
                 ss => ss.Set<BasicTypesEntity>().Where(b => b.String.EndsWith("Le")),
                 ss => ss.Set<BasicTypesEntity>().Where(b => b.String.EndsWith("Le", StringComparison.OrdinalIgnoreCase)));
 
+    [ConditionalTheory]
+    [MemberData(nameof(IsAsyncData))]
+    public virtual Task EndsWith_Literal_Char(bool async)
+        => IsCaseSensitive
+            ? AssertQuery(
+                async,
+                ss => ss.Set<BasicTypesEntity>().Where(b => b.String.EndsWith('e')))
+            : AssertQuery(
+                async,
+                ss => ss.Set<BasicTypesEntity>().Where(b => b.String.EndsWith('e')));
+
     [ConditionalTheory]
     [MemberData(nameof(IsAsyncData))]
     public virtual Task EndsWith_Parameter(bool async)
@@ -465,6 +575,29 @@ public virtual Task EndsWith_Parameter(bool async)
         }
     }
 
+    [ConditionalTheory]
+    [MemberData(nameof(IsAsyncData))]
+    public virtual Task EndsWith_Parameter_Char(bool async)
+    {
+        if (IsCaseSensitive)
+        {
+            var pattern = 'e';
+
+            return AssertQuery(
+                async,
+                ss => ss.Set<BasicTypesEntity>().Where(b => b.String.EndsWith(pattern)));
+        }
+        else
+        {
+            var pattern = 'e';
+
+            return AssertQuery(
+                async,
+                ss => ss.Set<BasicTypesEntity>().Where(b => b.String.EndsWith(pattern)),
+                ss => ss.Set<BasicTypesEntity>().Where(b => b.String.EndsWith(pattern)));
+        }
+    }
+
     [ConditionalTheory]
     [MemberData(nameof(IsAsyncData))]
     public virtual Task EndsWith_Column(bool async)
@@ -531,6 +664,18 @@ public virtual Task Contains_Literal(bool async)
                 ss => ss.Set<BasicTypesEntity>().Where(b => b.String.Contains("Eattl")),
                 ss => ss.Set<BasicTypesEntity>().Where(b => b.String.Contains("Eattl", StringComparison.OrdinalIgnoreCase)));
 
+    [ConditionalTheory]
+    [MemberData(nameof(IsAsyncData))]
+    public virtual Task Contains_Literal_Char(bool async)
+        => IsCaseSensitive
+            ? AssertQuery(
+                async,
+                ss => ss.Set<BasicTypesEntity>().Where(b => b.String.Contains('e')))
+            : AssertQuery(
+                async,
+                ss => ss.Set<BasicTypesEntity>().Where(b => b.String.Contains('e')),
+                ss => ss.Set<BasicTypesEntity>().Where(b => b.String.Contains('e')));
+
     [ConditionalTheory]
     [MemberData(nameof(IsAsyncData))]
     public virtual async Task Contains_Column(bool async)
diff --git a/test/EFCore.SqlServer.FunctionalTests/Query/Translations/StringTranslationsSqlServerTest.cs b/test/EFCore.SqlServer.FunctionalTests/Query/Translations/StringTranslationsSqlServerTest.cs
index c645f16d37..3681a4e4f5 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Query/Translations/StringTranslationsSqlServerTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Query/Translations/StringTranslationsSqlServerTest.cs
@@ -137,6 +137,18 @@ public override async Task IndexOf(bool async)
 """);
     }
 
+    public override async Task IndexOf_Char(bool async)
+    {
+        await base.IndexOf_Char(async);
+
+        AssertSql(
+            """
+SELECT [b].[Id], [b].[Bool], [b].[Byte], [b].[ByteArray], [b].[DateOnly], [b].[DateTime], [b].[DateTimeOffset], [b].[Decimal], [b].[Double], [b].[Enum], [b].[FlagsEnum], [b].[Float], [b].[Guid], [b].[Int], [b].[Long], [b].[Short], [b].[String], [b].[TimeOnly], [b].[TimeSpan]
+FROM [BasicTypesEntities] AS [b]
+WHERE CAST(CHARINDEX('e', [b].[String]) AS int) - 1 <> -1
+""");
+    }
+
     public override async Task IndexOf_with_empty_string(bool async)
     {
         await base.IndexOf_with_empty_string(async);
@@ -156,6 +168,24 @@ public override async Task IndexOf_with_one_parameter_arg(bool async)
             """
 @pattern='Eattl' (Size = 4000)
 
+SELECT [b].[Id], [b].[Bool], [b].[Byte], [b].[ByteArray], [b].[DateOnly], [b].[DateTime], [b].[DateTimeOffset], [b].[Decimal], [b].[Double], [b].[Enum], [b].[FlagsEnum], [b].[Float], [b].[Guid], [b].[Int], [b].[Long], [b].[Short], [b].[String], [b].[TimeOnly], [b].[TimeSpan]
+FROM [BasicTypesEntities] AS [b]
+WHERE CAST(CHARINDEX(@pattern, [b].[String]) AS int) - CASE
+    WHEN @pattern = N'' THEN 0
+    ELSE 1
+END = 1
+""");
+
+    }
+
+    public override async Task IndexOf_with_one_parameter_arg_char(bool async)
+    {
+        await base.IndexOf_with_one_parameter_arg_char(async);
+
+        AssertSql(
+            """
+@pattern='e' (Size = 1) (DbType = String)
+
 SELECT [b].[Id], [b].[Bool], [b].[Byte], [b].[ByteArray], [b].[DateOnly], [b].[DateTime], [b].[DateTimeOffset], [b].[Decimal], [b].[Double], [b].[Enum], [b].[FlagsEnum], [b].[Float], [b].[Guid], [b].[Int], [b].[Long], [b].[Short], [b].[String], [b].[TimeOnly], [b].[TimeSpan]
 FROM [BasicTypesEntities] AS [b]
 WHERE CAST(CHARINDEX(@pattern, [b].[String]) AS int) - CASE
@@ -178,6 +208,18 @@ public override async Task IndexOf_with_constant_starting_position(bool async)
 """);
     }
 
+    public override async Task IndexOf_with_constant_starting_position_char(bool async)
+    {
+        await base.IndexOf_with_constant_starting_position_char(async);
+
+        AssertSql(
+            """
+SELECT [b].[Id], [b].[Bool], [b].[Byte], [b].[ByteArray], [b].[DateOnly], [b].[DateTime], [b].[DateTimeOffset], [b].[Decimal], [b].[Double], [b].[Enum], [b].[FlagsEnum], [b].[Float], [b].[Guid], [b].[Int], [b].[Long], [b].[Short], [b].[String], [b].[TimeOnly], [b].[TimeSpan]
+FROM [BasicTypesEntities] AS [b]
+WHERE CAST(LEN([b].[String]) AS int) > 2 AND CAST(CHARINDEX('e', [b].[String], 3) AS int) - 1 = 6
+""");
+    }
+
     public override async Task IndexOf_with_parameter_starting_position(bool async)
     {
         await base.IndexOf_with_parameter_starting_position(async);
@@ -192,6 +234,20 @@ public override async Task IndexOf_with_parameter_starting_position(bool async)
 """);
     }
 
+    public override async Task IndexOf_with_parameter_starting_position_char(bool async)
+    {
+        await base.IndexOf_with_parameter_starting_position_char(async);
+
+        AssertSql(
+            """
+@start='2'
+
+SELECT [b].[Id], [b].[Bool], [b].[Byte], [b].[ByteArray], [b].[DateOnly], [b].[DateTime], [b].[DateTimeOffset], [b].[Decimal], [b].[Double], [b].[Enum], [b].[FlagsEnum], [b].[Float], [b].[Guid], [b].[Int], [b].[Long], [b].[Short], [b].[String], [b].[TimeOnly], [b].[TimeSpan]
+FROM [BasicTypesEntities] AS [b]
+WHERE CAST(LEN([b].[String]) AS int) > 2 AND CAST(CHARINDEX('e', [b].[String], @start + 1) AS int) - 1 = 6
+""");
+    }
+
     public override async Task IndexOf_after_ToString(bool async)
     {
         await base.IndexOf_after_ToString(async);
@@ -235,6 +291,18 @@ public override async Task Replace(bool async)
 """);
     }
 
+    public override async Task Replace_Char(bool async)
+    {
+        await base.Replace_Char(async);
+
+        AssertSql(
+            """
+SELECT [b].[Id], [b].[Bool], [b].[Byte], [b].[ByteArray], [b].[DateOnly], [b].[DateTime], [b].[DateTimeOffset], [b].[Decimal], [b].[Double], [b].[Enum], [b].[FlagsEnum], [b].[Float], [b].[Guid], [b].[Int], [b].[Long], [b].[Short], [b].[String], [b].[TimeOnly], [b].[TimeSpan]
+FROM [BasicTypesEntities] AS [b]
+WHERE REPLACE([b].[String], 'S', 'R') = N'Reattle'
+""");
+    }
+
     public override async Task Replace_with_empty_string(bool async)
     {
         await base.Replace_with_empty_string(async);
@@ -435,6 +503,18 @@ public override async Task StartsWith_Literal(bool async)
 """);
     }
 
+    public override async Task StartsWith_Literal_Char(bool async)
+    {
+        await base.StartsWith_Literal_Char(async);
+
+        AssertSql(
+            """
+SELECT [b].[Id], [b].[Bool], [b].[Byte], [b].[ByteArray], [b].[DateOnly], [b].[DateTime], [b].[DateTimeOffset], [b].[Decimal], [b].[Double], [b].[Enum], [b].[FlagsEnum], [b].[Float], [b].[Guid], [b].[Int], [b].[Long], [b].[Short], [b].[String], [b].[TimeOnly], [b].[TimeSpan]
+FROM [BasicTypesEntities] AS [b]
+WHERE [b].[String] LIKE N'S%'
+""");
+    }
+
     public override async Task StartsWith_Parameter(bool async)
     {
         await base.StartsWith_Parameter(async);
@@ -443,6 +523,20 @@ public override async Task StartsWith_Parameter(bool async)
             """
 @pattern_startswith='se%' (Size = 4000)
 
+SELECT [b].[Id], [b].[Bool], [b].[Byte], [b].[ByteArray], [b].[DateOnly], [b].[DateTime], [b].[DateTimeOffset], [b].[Decimal], [b].[Double], [b].[Enum], [b].[FlagsEnum], [b].[Float], [b].[Guid], [b].[Int], [b].[Long], [b].[Short], [b].[String], [b].[TimeOnly], [b].[TimeSpan]
+FROM [BasicTypesEntities] AS [b]
+WHERE [b].[String] LIKE @pattern_startswith ESCAPE N'\'
+""");
+    }
+
+    public override async Task StartsWith_Parameter_Char(bool async)
+    {
+        await base.StartsWith_Parameter_Char(async);
+
+        AssertSql(
+            """
+@pattern_startswith='S%' (Size = 4000)
+
 SELECT [b].[Id], [b].[Bool], [b].[Byte], [b].[ByteArray], [b].[DateOnly], [b].[DateTime], [b].[DateTimeOffset], [b].[Decimal], [b].[Double], [b].[Enum], [b].[FlagsEnum], [b].[Float], [b].[Guid], [b].[Int], [b].[Long], [b].[Short], [b].[String], [b].[TimeOnly], [b].[TimeSpan]
 FROM [BasicTypesEntities] AS [b]
 WHERE [b].[String] LIKE @pattern_startswith ESCAPE N'\'
@@ -498,6 +592,18 @@ public override async Task EndsWith_Literal(bool async)
 """);
     }
 
+    public override async Task EndsWith_Literal_Char(bool async)
+    {
+        await base.EndsWith_Literal_Char(async);
+
+        AssertSql(
+            """
+SELECT [b].[Id], [b].[Bool], [b].[Byte], [b].[ByteArray], [b].[DateOnly], [b].[DateTime], [b].[DateTimeOffset], [b].[Decimal], [b].[Double], [b].[Enum], [b].[FlagsEnum], [b].[Float], [b].[Guid], [b].[Int], [b].[Long], [b].[Short], [b].[String], [b].[TimeOnly], [b].[TimeSpan]
+FROM [BasicTypesEntities] AS [b]
+WHERE [b].[String] LIKE N'%e'
+""");
+    }
+
     public override async Task EndsWith_Parameter(bool async)
     {
         await base.EndsWith_Parameter(async);
@@ -506,6 +612,20 @@ public override async Task EndsWith_Parameter(bool async)
             """
 @pattern_endswith='%LE' (Size = 4000)
 
+SELECT [b].[Id], [b].[Bool], [b].[Byte], [b].[ByteArray], [b].[DateOnly], [b].[DateTime], [b].[DateTimeOffset], [b].[Decimal], [b].[Double], [b].[Enum], [b].[FlagsEnum], [b].[Float], [b].[Guid], [b].[Int], [b].[Long], [b].[Short], [b].[String], [b].[TimeOnly], [b].[TimeSpan]
+FROM [BasicTypesEntities] AS [b]
+WHERE [b].[String] LIKE @pattern_endswith ESCAPE N'\'
+""");
+    }
+
+    public override async Task EndsWith_Parameter_Char(bool async)
+    {
+        await base.EndsWith_Parameter_Char(async);
+
+        AssertSql(
+            """
+@pattern_endswith='%e' (Size = 4000)
+
 SELECT [b].[Id], [b].[Bool], [b].[Byte], [b].[ByteArray], [b].[DateOnly], [b].[DateTime], [b].[DateTimeOffset], [b].[Decimal], [b].[Double], [b].[Enum], [b].[FlagsEnum], [b].[Float], [b].[Guid], [b].[Int], [b].[Long], [b].[Short], [b].[String], [b].[TimeOnly], [b].[TimeSpan]
 FROM [BasicTypesEntities] AS [b]
 WHERE [b].[String] LIKE @pattern_endswith ESCAPE N'\'
@@ -568,6 +688,20 @@ public override async Task Contains_Literal(bool async)
 """);
     }
 
+    public override async Task Contains_Literal_Char(bool async)
+    {
+        await AssertQuery(
+            async,
+            ss => ss.Set<BasicTypesEntity>().Where(c => c.String.Contains('e')));
+
+        AssertSql(
+            """
+SELECT [b].[Id], [b].[Bool], [b].[Byte], [b].[ByteArray], [b].[DateOnly], [b].[DateTime], [b].[DateTimeOffset], [b].[Decimal], [b].[Double], [b].[Enum], [b].[FlagsEnum], [b].[Float], [b].[Guid], [b].[Int], [b].[Long], [b].[Short], [b].[String], [b].[TimeOnly], [b].[TimeSpan]
+FROM [BasicTypesEntities] AS [b]
+WHERE [b].[String] LIKE N'%e%'
+""");
+    }
+
     public override async Task Contains_Column(bool async)
     {
         await base.Contains_Column(async);
diff --git a/test/EFCore.Sqlite.FunctionalTests/Query/Translations/StringTranslationsSqliteTest.cs b/test/EFCore.Sqlite.FunctionalTests/Query/Translations/StringTranslationsSqliteTest.cs
index 58a5dc22eb..d5b76fa942 100644
--- a/test/EFCore.Sqlite.FunctionalTests/Query/Translations/StringTranslationsSqliteTest.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/Query/Translations/StringTranslationsSqliteTest.cs
@@ -134,6 +134,18 @@ public override async Task IndexOf(bool async)
 """);
     }
 
+    public override async Task IndexOf_Char(bool async)
+    {
+        await base.IndexOf_Char(async);
+
+        AssertSql(
+            """
+SELECT "b"."Id", "b"."Bool", "b"."Byte", "b"."ByteArray", "b"."DateOnly", "b"."DateTime", "b"."DateTimeOffset", "b"."Decimal", "b"."Double", "b"."Enum", "b"."FlagsEnum", "b"."Float", "b"."Guid", "b"."Int", "b"."Long", "b"."Short", "b"."String", "b"."TimeOnly", "b"."TimeSpan"
+FROM "BasicTypesEntities" AS "b"
+WHERE instr("b"."String", 'e') - 1 <> -1
+""");
+    }
+
     public override async Task IndexOf_with_empty_string(bool async)
     {
         await base.IndexOf_with_empty_string(async);
@@ -160,11 +172,71 @@ public override async Task IndexOf_with_one_parameter_arg(bool async)
 """);
     }
 
-    public override Task IndexOf_with_constant_starting_position(bool async)
-        => AssertTranslationFailed(() => base.IndexOf_with_constant_starting_position(async));
+    public override async Task IndexOf_with_one_parameter_arg_char(bool async)
+    {
+        await base.IndexOf_with_one_parameter_arg_char(async);
+
+        AssertSql(
+            """
+@pattern='e' (DbType = String)
+
+SELECT "b"."Id", "b"."Bool", "b"."Byte", "b"."ByteArray", "b"."DateOnly", "b"."DateTime", "b"."DateTimeOffset", "b"."Decimal", "b"."Double", "b"."Enum", "b"."FlagsEnum", "b"."Float", "b"."Guid", "b"."Int", "b"."Long", "b"."Short", "b"."String", "b"."TimeOnly", "b"."TimeSpan"
+FROM "BasicTypesEntities" AS "b"
+WHERE instr("b"."String", @pattern) - 1 = 1
+""");
+    }
+
+    public override async Task IndexOf_with_constant_starting_position(bool async)
+    {
+        await base.IndexOf_with_constant_starting_position(async);
+
+        AssertSql(
+            """
+SELECT "b"."Id", "b"."Bool", "b"."Byte", "b"."ByteArray", "b"."DateOnly", "b"."DateTime", "b"."DateTimeOffset", "b"."Decimal", "b"."Double", "b"."Enum", "b"."FlagsEnum", "b"."Float", "b"."Guid", "b"."Int", "b"."Long", "b"."Short", "b"."String", "b"."TimeOnly", "b"."TimeSpan"
+FROM "BasicTypesEntities" AS "b"
+WHERE length("b"."String") > 2 AND (instr(substr("b"."String", 2 + 1), 'e') - 1) + 2 = 6
+""");
+    }
+
+    public override async Task IndexOf_with_constant_starting_position_char(bool async)
+    {
+        await base.IndexOf_with_constant_starting_position_char(async);
+
+        AssertSql(
+            """
+SELECT "b"."Id", "b"."Bool", "b"."Byte", "b"."ByteArray", "b"."DateOnly", "b"."DateTime", "b"."DateTimeOffset", "b"."Decimal", "b"."Double", "b"."Enum", "b"."FlagsEnum", "b"."Float", "b"."Guid", "b"."Int", "b"."Long", "b"."Short", "b"."String", "b"."TimeOnly", "b"."TimeSpan"
+FROM "BasicTypesEntities" AS "b"
+WHERE length("b"."String") > 2 AND (instr(substr("b"."String", 2 + 1), 'e') - 1) + 2 = 6
+""");
+    }
 
-    public override Task IndexOf_with_parameter_starting_position(bool async)
-        => AssertTranslationFailed(() => base.IndexOf_with_parameter_starting_position(async));
+    public override async  Task IndexOf_with_parameter_starting_position(bool async)
+    {
+        await base.IndexOf_with_parameter_starting_position(async);
+
+        AssertSql(
+            """
+@start='2'
+
+SELECT "b"."Id", "b"."Bool", "b"."Byte", "b"."ByteArray", "b"."DateOnly", "b"."DateTime", "b"."DateTimeOffset", "b"."Decimal", "b"."Double", "b"."Enum", "b"."FlagsEnum", "b"."Float", "b"."Guid", "b"."Int", "b"."Long", "b"."Short", "b"."String", "b"."TimeOnly", "b"."TimeSpan"
+FROM "BasicTypesEntities" AS "b"
+WHERE length("b"."String") > 2 AND (instr(substr("b"."String", @start + 1), 'e') - 1) + @start = 6
+""");
+    }
+
+    public override async Task IndexOf_with_parameter_starting_position_char(bool async)
+    {
+        await base.IndexOf_with_parameter_starting_position_char(async);
+
+        AssertSql(
+            """
+@start='2'
+
+SELECT "b"."Id", "b"."Bool", "b"."Byte", "b"."ByteArray", "b"."DateOnly", "b"."DateTime", "b"."DateTimeOffset", "b"."Decimal", "b"."Double", "b"."Enum", "b"."FlagsEnum", "b"."Float", "b"."Guid", "b"."Int", "b"."Long", "b"."Short", "b"."String", "b"."TimeOnly", "b"."TimeSpan"
+FROM "BasicTypesEntities" AS "b"
+WHERE length("b"."String") > 2 AND (instr(substr("b"."String", @start + 1), 'e') - 1) + @start = 6
+""");
+    }
 
     public override async Task IndexOf_after_ToString(bool async)
     {
@@ -206,6 +278,18 @@ public override async Task Replace(bool async)
 """);
     }
 
+    public override async Task Replace_Char(bool async)
+    {
+        await base.Replace_Char(async);
+
+        AssertSql(
+            """
+SELECT "b"."Id", "b"."Bool", "b"."Byte", "b"."ByteArray", "b"."DateOnly", "b"."DateTime", "b"."DateTimeOffset", "b"."Decimal", "b"."Double", "b"."Enum", "b"."FlagsEnum", "b"."Float", "b"."Guid", "b"."Int", "b"."Long", "b"."Short", "b"."String", "b"."TimeOnly", "b"."TimeSpan"
+FROM "BasicTypesEntities" AS "b"
+WHERE replace("b"."String", 'S', 'R') = 'Reattle'
+""");
+    }
+
     public override async Task Replace_with_empty_string(bool async)
     {
         await base.Replace_with_empty_string(async);
@@ -395,6 +479,18 @@ public override async Task StartsWith_Literal(bool async)
 """);
     }
 
+    public override async Task StartsWith_Literal_Char(bool async)
+    {
+        await base.StartsWith_Literal_Char(async);
+
+        AssertSql(
+            """
+SELECT "b"."Id", "b"."Bool", "b"."Byte", "b"."ByteArray", "b"."DateOnly", "b"."DateTime", "b"."DateTimeOffset", "b"."Decimal", "b"."Double", "b"."Enum", "b"."FlagsEnum", "b"."Float", "b"."Guid", "b"."Int", "b"."Long", "b"."Short", "b"."String", "b"."TimeOnly", "b"."TimeSpan"
+FROM "BasicTypesEntities" AS "b"
+WHERE "b"."String" LIKE 'S%'
+""");
+    }
+
     public override async Task StartsWith_Parameter(bool async)
     {
         await base.StartsWith_Parameter(async);
@@ -403,6 +499,20 @@ public override async Task StartsWith_Parameter(bool async)
             """
 @pattern_startswith='Se%' (Size = 3)
 
+SELECT "b"."Id", "b"."Bool", "b"."Byte", "b"."ByteArray", "b"."DateOnly", "b"."DateTime", "b"."DateTimeOffset", "b"."Decimal", "b"."Double", "b"."Enum", "b"."FlagsEnum", "b"."Float", "b"."Guid", "b"."Int", "b"."Long", "b"."Short", "b"."String", "b"."TimeOnly", "b"."TimeSpan"
+FROM "BasicTypesEntities" AS "b"
+WHERE "b"."String" LIKE @pattern_startswith ESCAPE '\'
+""");
+    }
+
+    public override async Task StartsWith_Parameter_Char(bool async)
+    {
+        await base.StartsWith_Parameter_Char(async);
+
+        AssertSql(
+            """
+@pattern_startswith='S%' (Size = 2)
+
 SELECT "b"."Id", "b"."Bool", "b"."Byte", "b"."ByteArray", "b"."DateOnly", "b"."DateTime", "b"."DateTimeOffset", "b"."Decimal", "b"."Double", "b"."Enum", "b"."FlagsEnum", "b"."Float", "b"."Guid", "b"."Int", "b"."Long", "b"."Short", "b"."String", "b"."TimeOnly", "b"."TimeSpan"
 FROM "BasicTypesEntities" AS "b"
 WHERE "b"."String" LIKE @pattern_startswith ESCAPE '\'
@@ -458,6 +568,18 @@ public override async Task EndsWith_Literal(bool async)
 """);
     }
 
+    public override async Task EndsWith_Literal_Char(bool async)
+    {
+        await base.EndsWith_Literal_Char(async);
+
+        AssertSql(
+            """
+SELECT "b"."Id", "b"."Bool", "b"."Byte", "b"."ByteArray", "b"."DateOnly", "b"."DateTime", "b"."DateTimeOffset", "b"."Decimal", "b"."Double", "b"."Enum", "b"."FlagsEnum", "b"."Float", "b"."Guid", "b"."Int", "b"."Long", "b"."Short", "b"."String", "b"."TimeOnly", "b"."TimeSpan"
+FROM "BasicTypesEntities" AS "b"
+WHERE "b"."String" LIKE '%e'
+""");
+    }
+
     public override async Task EndsWith_Parameter(bool async)
     {
         await base.EndsWith_Parameter(async);
@@ -466,6 +588,20 @@ public override async Task EndsWith_Parameter(bool async)
             """
 @pattern_endswith='%le' (Size = 3)
 
+SELECT "b"."Id", "b"."Bool", "b"."Byte", "b"."ByteArray", "b"."DateOnly", "b"."DateTime", "b"."DateTimeOffset", "b"."Decimal", "b"."Double", "b"."Enum", "b"."FlagsEnum", "b"."Float", "b"."Guid", "b"."Int", "b"."Long", "b"."Short", "b"."String", "b"."TimeOnly", "b"."TimeSpan"
+FROM "BasicTypesEntities" AS "b"
+WHERE "b"."String" LIKE @pattern_endswith ESCAPE '\'
+""");
+    }
+
+    public override async Task EndsWith_Parameter_Char(bool async)
+    {
+        await base.EndsWith_Parameter_Char(async);
+
+        AssertSql(
+            """
+@pattern_endswith='%e' (Size = 2)
+
 SELECT "b"."Id", "b"."Bool", "b"."Byte", "b"."ByteArray", "b"."DateOnly", "b"."DateTime", "b"."DateTimeOffset", "b"."Decimal", "b"."Double", "b"."Enum", "b"."FlagsEnum", "b"."Float", "b"."Guid", "b"."Int", "b"."Long", "b"."Short", "b"."String", "b"."TimeOnly", "b"."TimeSpan"
 FROM "BasicTypesEntities" AS "b"
 WHERE "b"."String" LIKE @pattern_endswith ESCAPE '\'
@@ -521,6 +657,18 @@ public override async Task Contains_Literal(bool async)
 """);
     }
 
+    public override async Task Contains_Literal_Char(bool async)
+    {
+        await base.Contains_Literal_Char(async);
+
+        AssertSql(
+            """
+SELECT "b"."Id", "b"."Bool", "b"."Byte", "b"."ByteArray", "b"."DateOnly", "b"."DateTime", "b"."DateTimeOffset", "b"."Decimal", "b"."Double", "b"."Enum", "b"."FlagsEnum", "b"."Float", "b"."Guid", "b"."Int", "b"."Long", "b"."Short", "b"."String", "b"."TimeOnly", "b"."TimeSpan"
+FROM "BasicTypesEntities" AS "b"
+WHERE instr("b"."String", 'e') > 0
+""");
+    }
+
     public override async Task Contains_Column(bool async)
     {
         await base.Contains_Column(async);
