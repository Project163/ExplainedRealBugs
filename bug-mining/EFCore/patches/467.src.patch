diff --git a/src/EFCore.Relational/Query/RelationalShapedQueryCompilingExpressionVisitor.ShaperProcessingExpressionVisitor.cs b/src/EFCore.Relational/Query/RelationalShapedQueryCompilingExpressionVisitor.ShaperProcessingExpressionVisitor.cs
index 2b2c9ec49a..27d8b701ea 100644
--- a/src/EFCore.Relational/Query/RelationalShapedQueryCompilingExpressionVisitor.ShaperProcessingExpressionVisitor.cs
+++ b/src/EFCore.Relational/Query/RelationalShapedQueryCompilingExpressionVisitor.ShaperProcessingExpressionVisitor.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System.Diagnostics.CodeAnalysis;
+using System.Text;
 using System.Text.Encodings.Web;
 using System.Text.Json;
 using Microsoft.EntityFrameworkCore.ChangeTracking.Internal;
@@ -78,6 +79,18 @@ public sealed partial class ShaperProcessingExpressionVisitor : ExpressionVisito
         private static readonly MethodInfo Utf8JsonReaderValueTextEqualsMethod
             = typeof(Utf8JsonReader).GetMethod(nameof(Utf8JsonReader.ValueTextEquals), [typeof(ReadOnlySpan<byte>)])!;
 
+        private static readonly PropertyInfo EncodingUtf8Property
+            = typeof(Encoding).GetProperty(nameof(Encoding.UTF8))!;
+
+        private static readonly MethodInfo Utf8GetBytesMethod
+            = typeof(Encoding).GetMethod(nameof(Encoding.GetBytes), [typeof(string)])!;
+
+        private static readonly MethodInfo ByteArrayAsSpanMethod = typeof(MemoryExtensions).GetMethods()
+            .Where(x => x.Name == nameof(MemoryExtensions.AsSpan) && x.GetGenericArguments().Count() == 1)
+            .Select(x => new { x, prms = x.GetParameters() })
+            .Where(x => x.prms.Count() == 1 && x.prms[0].ParameterType.IsArray)
+            .Single().x.MakeGenericMethod(typeof(byte));
+
         private static readonly MethodInfo Utf8JsonReaderTrySkipMethod
             = typeof(Utf8JsonReader).GetMethod(nameof(Utf8JsonReader.TrySkip), [])!;
 
@@ -1929,20 +1942,14 @@ void ProcessFixup(IDictionary<string, LambdaExpression> fixupMap)
                                     managerVariable,
                                     Utf8JsonReaderManagerCurrentReaderField),
                                 Utf8JsonReaderValueTextEqualsMethod,
-                                Property(
-                                    _liftableConstantFactory.CreateLiftableConstant(
-                                        JsonEncodedText.Encode(jsonPropertyName),
-                                        Lambda<Func<MaterializerLiftableConstantContext, object>>(
-                                            Convert(
-                                                Call(
-                                                    JsonEncodedTextEncodeMethod,
-                                                    Constant(jsonPropertyName),
-                                                    Default(typeof(JavaScriptEncoder))),
-                                                typeof(object)),
-                                            Parameter(typeof(MaterializerLiftableConstantContext), "_")),
-                                        jsonPropertyName + "EncodedProperty",
-                                        typeof(JsonEncodedText)),
-                                    JsonEncodedTextEncodedUtf8BytesProperty)));
+                                Convert(
+                                    Call(
+                                        ByteArrayAsSpanMethod,
+                                        Call(
+                                            Property(null, EncodingUtf8Property),
+                                            Utf8GetBytesMethod,
+                                            Constant(jsonPropertyName))),
+                                    typeof(ReadOnlySpan<>).MakeGenericType(typeof(byte)))));
 
                         var propertyVariable = Variable(valueBufferTryReadValueMethodToProcess.Type);
 
@@ -1974,20 +1981,14 @@ void ProcessFixup(IDictionary<string, LambdaExpression> fixupMap)
                                     managerVariable,
                                     Utf8JsonReaderManagerCurrentReaderField),
                                 Utf8JsonReaderValueTextEqualsMethod,
-                                Property(
-                                    _liftableConstantFactory.CreateLiftableConstant(
-                                        JsonEncodedText.Encode(innerShaperMapElementKey),
-                                        Lambda<Func<MaterializerLiftableConstantContext, object>>(
-                                            Convert(
-                                                Call(
-                                                    JsonEncodedTextEncodeMethod,
-                                                    Constant(innerShaperMapElementKey),
-                                                    Default(typeof(JavaScriptEncoder))),
-                                                typeof(object)),
-                                            Parameter(typeof(MaterializerLiftableConstantContext), "_")),
-                                        innerShaperMapElementKey + "EncodedNavigation",
-                                        typeof(JsonEncodedText)),
-                                    JsonEncodedTextEncodedUtf8BytesProperty)));
+                                Convert(
+                                    Call(
+                                        ByteArrayAsSpanMethod,
+                                        Call(
+                                            Property(null, EncodingUtf8Property),
+                                            Utf8GetBytesMethod,
+                                            Constant(innerShaperMapElementKey))),
+                                    typeof(ReadOnlySpan<>).MakeGenericType(typeof(byte)))));
 
                         var propertyVariable = Variable(innerShaperMapElement.Value.Type);
                         finalBlockVariables.Add(propertyVariable);
diff --git a/src/EFCore.Relational/Storage/ISqlGenerationHelper.cs b/src/EFCore.Relational/Storage/ISqlGenerationHelper.cs
index 2d04644751..f21d743b1a 100644
--- a/src/EFCore.Relational/Storage/ISqlGenerationHelper.cs
+++ b/src/EFCore.Relational/Storage/ISqlGenerationHelper.cs
@@ -118,6 +118,13 @@ public interface ISqlGenerationHelper
     /// <param name="schema">The schema of the identifier.</param>
     void DelimitIdentifier(StringBuilder builder, string name, string? schema);
 
+    /// <summary>
+    ///     Writes the delimited SQL representation of an element in a JSON path.
+    /// </summary>
+    /// <param name="pathElement">The JSON path element to delimit.</param>
+    /// <returns>The generated string.</returns>
+    public string DelimitJsonPathElement(string pathElement);
+
     /// <summary>
     ///     Generates a SQL comment.
     /// </summary>
diff --git a/src/EFCore.Relational/Storage/RelationalSqlGenerationHelper.cs b/src/EFCore.Relational/Storage/RelationalSqlGenerationHelper.cs
index 68b0638f1e..7587795925 100644
--- a/src/EFCore.Relational/Storage/RelationalSqlGenerationHelper.cs
+++ b/src/EFCore.Relational/Storage/RelationalSqlGenerationHelper.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System.Text;
+using System.Text.Json;
 
 namespace Microsoft.EntityFrameworkCore.Storage;
 
@@ -180,6 +181,32 @@ public virtual void DelimitIdentifier(StringBuilder builder, string name, string
         DelimitIdentifier(builder, name);
     }
 
+    /// <summary>
+    ///     Generates the escaped SQL representation of an identifier (column name, table name, etc.).
+    /// </summary>
+    /// <param name="identifier">The identifier to be escaped.</param>
+    /// <returns>The generated string.</returns>
+    public virtual string EscapeJsonPathElement(string identifier)
+        => JsonEncodedText.Encode(identifier).Value;
+
+    /// <summary>
+    ///     Writes the delimited SQL representation of an element in a JSON path.
+    /// </summary>
+    /// <param name="pathElement">The JSON path element to delimit.</param>
+    /// <returns>The generated string.</returns>
+    public virtual string DelimitJsonPathElement(string pathElement)
+    {
+        for (var i = 0; i < pathElement.Length; i++)
+        {
+            if (!char.IsAsciiLetterOrDigit(pathElement[i]))
+            {
+                return $"\"{EscapeJsonPathElement(pathElement)}\"";
+            }
+        }
+
+        return pathElement;
+    }
+
     /// <summary>
     ///     Generates a SQL comment.
     /// </summary>
diff --git a/src/EFCore.SqlServer/Query/Internal/SqlServerQuerySqlGenerator.cs b/src/EFCore.SqlServer/Query/Internal/SqlServerQuerySqlGenerator.cs
index 82caeed721..6894a9bc45 100644
--- a/src/EFCore.SqlServer/Query/Internal/SqlServerQuerySqlGenerator.cs
+++ b/src/EFCore.SqlServer/Query/Internal/SqlServerQuerySqlGenerator.cs
@@ -506,7 +506,7 @@ private void GenerateJsonPath(IReadOnlyList<PathSegment> path)
             switch (pathSegment)
             {
                 case { PropertyName: string propertyName }:
-                    Sql.Append(".").Append(propertyName);
+                    Sql.Append(".").Append(Dependencies.SqlGenerationHelper.DelimitJsonPathElement(propertyName));
                     break;
 
                 case { ArrayIndex: SqlExpression arrayIndex }:
diff --git a/src/EFCore.Sqlite.Core/Query/Internal/SqliteQuerySqlGenerator.cs b/src/EFCore.Sqlite.Core/Query/Internal/SqliteQuerySqlGenerator.cs
index 086592d5c3..ad1c62dc00 100644
--- a/src/EFCore.Sqlite.Core/Query/Internal/SqliteQuerySqlGenerator.cs
+++ b/src/EFCore.Sqlite.Core/Query/Internal/SqliteQuerySqlGenerator.cs
@@ -225,7 +225,7 @@ protected override Expression VisitJsonScalar(JsonScalarExpression jsonScalarExp
                 case { PropertyName: string propertyName }:
                     if (inJsonpathString)
                     {
-                        Sql.Append(".").Append(propertyName);
+                        Sql.Append(".").Append(Dependencies.SqlGenerationHelper.DelimitJsonPathElement(propertyName));
                         continue;
                     }
 
@@ -234,11 +234,11 @@ protected override Expression VisitJsonScalar(JsonScalarExpression jsonScalarExp
                     // No need to start a $. JSONPATH string if we're the last segment or the next segment isn't a constant
                     if (isLast || path[i + 1] is { ArrayIndex: not null and not SqlConstantExpression })
                     {
-                        Sql.Append("'").Append(propertyName).Append("'");
+                        Sql.Append("'").Append(Dependencies.SqlGenerationHelper.DelimitJsonPathElement(propertyName)).Append("'");
                         continue;
                     }
 
-                    Sql.Append("'$.").Append(propertyName);
+                    Sql.Append("'$.").Append(Dependencies.SqlGenerationHelper.DelimitJsonPathElement(propertyName));
                     inJsonpathString = true;
                     continue;
 
diff --git a/test/EFCore.Relational.Specification.Tests/TestModels/JsonQuery/JsonOwnedCustomNameBranch.cs b/test/EFCore.Relational.Specification.Tests/TestModels/JsonQuery/JsonOwnedCustomNameBranch.cs
index 89437bee6a..6bd4c969b5 100644
--- a/test/EFCore.Relational.Specification.Tests/TestModels/JsonQuery/JsonOwnedCustomNameBranch.cs
+++ b/test/EFCore.Relational.Specification.Tests/TestModels/JsonQuery/JsonOwnedCustomNameBranch.cs
@@ -12,6 +12,6 @@ public class JsonOwnedCustomNameBranch
     [JsonPropertyName("CustomDate")]
     public DateTime Date { get; set; }
 
-    [JsonPropertyName("CustomFraction")]
+    [JsonPropertyName("ユニコーンFraction一角獣")]
     public double Fraction { get; set; }
 }
diff --git a/test/EFCore.Relational.Specification.Tests/TestModels/JsonQuery/JsonOwnedCustomNameRoot.cs b/test/EFCore.Relational.Specification.Tests/TestModels/JsonQuery/JsonOwnedCustomNameRoot.cs
index 0969513316..e13543932e 100644
--- a/test/EFCore.Relational.Specification.Tests/TestModels/JsonQuery/JsonOwnedCustomNameRoot.cs
+++ b/test/EFCore.Relational.Specification.Tests/TestModels/JsonQuery/JsonOwnedCustomNameRoot.cs
@@ -12,13 +12,12 @@ public class JsonOwnedCustomNameRoot
     [JsonPropertyName("CustomName")]
     public string Name { get; set; }
 
-    [JsonPropertyName("CustomNumber")]
     public int Number { get; set; }
 
     [JsonPropertyName("CustomEnum")]
     public JsonEnum Enum { get; set; }
 
-    [JsonPropertyName("CustomOwnedReferenceBranch")]
+    [JsonPropertyName("Custom#OwnedReferenceBranch`-=[]\\;',./~!@#$%^&*()_+{}|:\"<>?独角兽π獨角獸")]
     public JsonOwnedCustomNameBranch OwnedReferenceBranch { get; set; }
 
     [JsonPropertyName("CustomOwnedCollectionBranch")]
diff --git a/test/EFCore.SqlServer.FunctionalTests/Query/JsonQuerySqlServerTest.cs b/test/EFCore.SqlServer.FunctionalTests/Query/JsonQuerySqlServerTest.cs
index a911cfc08c..8bb4e1ad36 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Query/JsonQuerySqlServerTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Query/JsonQuerySqlServerTest.cs
@@ -429,8 +429,8 @@ public override async Task Custom_naming_projection_owned_reference(bool async)
         await base.Custom_naming_projection_owned_reference(async);
 
         AssertSql(
-            """
-SELECT JSON_QUERY([j].[json_reference_custom_naming], '$.CustomOwnedReferenceBranch'), [j].[Id]
+"""
+SELECT JSON_QUERY([j].[json_reference_custom_naming], '$."Custom#OwnedReferenceBranch\u0060-=[]\\;\u0027,./~!@#$%^\u0026*()_\u002B{}|:\u0022\u003C\u003E?\u72EC\u89D2\u517D\u03C0\u7368\u89D2\u7378"'), [j].[Id]
 FROM [JsonEntitiesCustomNaming] AS [j]
 """);
     }
@@ -452,8 +452,8 @@ public override async Task Custom_naming_projection_owned_scalar(bool async)
         await base.Custom_naming_projection_owned_scalar(async);
 
         AssertSql(
-            """
-SELECT CAST(JSON_VALUE([j].[json_reference_custom_naming], '$.CustomOwnedReferenceBranch.CustomFraction') AS float)
+"""
+SELECT CAST(JSON_VALUE([j].[json_reference_custom_naming], '$."Custom#OwnedReferenceBranch\u0060-=[]\\;\u0027,./~!@#$%^\u0026*()_\u002B{}|:\u0022\u003C\u003E?\u72EC\u89D2\u517D\u03C0\u7368\u89D2\u7378"."\u30E6\u30CB\u30B3\u30FC\u30F3Fraction\u4E00\u89D2\u7363"') AS float)
 FROM [JsonEntitiesCustomNaming] AS [j]
 """);
     }
@@ -463,8 +463,8 @@ public override async Task Custom_naming_projection_everything(bool async)
         await base.Custom_naming_projection_everything(async);
 
         AssertSql(
-            """
-SELECT [j].[Id], [j].[Title], [j].[json_collection_custom_naming], [j].[json_reference_custom_naming], [j].[json_reference_custom_naming], JSON_QUERY([j].[json_reference_custom_naming], '$.CustomOwnedReferenceBranch'), [j].[json_collection_custom_naming], JSON_QUERY([j].[json_reference_custom_naming], '$.CustomOwnedCollectionBranch'), JSON_VALUE([j].[json_reference_custom_naming], '$.CustomName'), CAST(JSON_VALUE([j].[json_reference_custom_naming], '$.CustomOwnedReferenceBranch.CustomFraction') AS float)
+"""
+SELECT [j].[Id], [j].[Title], [j].[json_collection_custom_naming], [j].[json_reference_custom_naming], [j].[json_reference_custom_naming], JSON_QUERY([j].[json_reference_custom_naming], '$."Custom#OwnedReferenceBranch\u0060-=[]\\;\u0027,./~!@#$%^\u0026*()_\u002B{}|:\u0022\u003C\u003E?\u72EC\u89D2\u517D\u03C0\u7368\u89D2\u7378"'), [j].[json_collection_custom_naming], JSON_QUERY([j].[json_reference_custom_naming], '$.CustomOwnedCollectionBranch'), JSON_VALUE([j].[json_reference_custom_naming], '$.CustomName'), CAST(JSON_VALUE([j].[json_reference_custom_naming], '$."Custom#OwnedReferenceBranch\u0060-=[]\\;\u0027,./~!@#$%^\u0026*()_\u002B{}|:\u0022\u003C\u003E?\u72EC\u89D2\u517D\u03C0\u7368\u89D2\u7378"."\u30E6\u30CB\u30B3\u30FC\u30F3Fraction\u4E00\u89D2\u7363"') AS float)
 FROM [JsonEntitiesCustomNaming] AS [j]
 """);
     }
diff --git a/test/EFCore.Sqlite.FunctionalTests/Query/JsonQuerySqliteTest.cs b/test/EFCore.Sqlite.FunctionalTests/Query/JsonQuerySqliteTest.cs
index f793dd3f47..9383c4f2e1 100644
--- a/test/EFCore.Sqlite.FunctionalTests/Query/JsonQuerySqliteTest.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/Query/JsonQuerySqliteTest.cs
@@ -413,6 +413,39 @@ public override async Task Json_collection_index_in_projection_using_untranslata
             message);
     }
 
+    public override async Task Custom_naming_projection_everything(bool async)
+    {
+        await base.Custom_naming_projection_everything(async);
+
+        AssertSql(
+            """
+SELECT "j"."Id", "j"."Title", "j"."json_collection_custom_naming", "j"."json_reference_custom_naming", "j"."json_reference_custom_naming", "j"."json_reference_custom_naming" ->> '"Custom#OwnedReferenceBranch\u0060-=[]\\;\u0027,./~!@#$%^\u0026*()_\u002B{}|:\u0022\u003C\u003E?\u72EC\u89D2\u517D\u03C0\u7368\u89D2\u7378"', "j"."json_collection_custom_naming", "j"."json_reference_custom_naming" ->> 'CustomOwnedCollectionBranch', "j"."json_reference_custom_naming" ->> 'CustomName', "j"."json_reference_custom_naming" ->> '$."Custom#OwnedReferenceBranch\u0060-=[]\\;\u0027,./~!@#$%^\u0026*()_\u002B{}|:\u0022\u003C\u003E?\u72EC\u89D2\u517D\u03C0\u7368\u89D2\u7378"."\u30E6\u30CB\u30B3\u30FC\u30F3Fraction\u4E00\u89D2\u7363"'
+FROM "JsonEntitiesCustomNaming" AS "j"
+""");
+    }
+
+    public override async Task Custom_naming_projection_owned_scalar(bool async)
+    {
+        await base.Custom_naming_projection_owned_scalar(async);
+
+        AssertSql(
+            """
+SELECT "j"."json_reference_custom_naming" ->> '$."Custom#OwnedReferenceBranch\u0060-=[]\\;\u0027,./~!@#$%^\u0026*()_\u002B{}|:\u0022\u003C\u003E?\u72EC\u89D2\u517D\u03C0\u7368\u89D2\u7378"."\u30E6\u30CB\u30B3\u30FC\u30F3Fraction\u4E00\u89D2\u7363"'
+FROM "JsonEntitiesCustomNaming" AS "j"
+""");
+    }
+
+    public override async Task Custom_naming_projection_owned_reference(bool async)
+    {
+        await base.Custom_naming_projection_owned_reference(async);
+
+        AssertSql(
+            """
+SELECT "j"."json_reference_custom_naming" ->> '"Custom#OwnedReferenceBranch\u0060-=[]\\;\u0027,./~!@#$%^\u0026*()_\u002B{}|:\u0022\u003C\u003E?\u72EC\u89D2\u517D\u03C0\u7368\u89D2\u7378"', "j"."Id"
+FROM "JsonEntitiesCustomNaming" AS "j"
+""");
+    }
+
     private void AssertSql(params string[] expected)
         => Fixture.TestSqlLoggerFactory.AssertBaseline(expected);
 }
