diff --git a/test/EFCore.SqlServer.FunctionalTests/Query/AdHocJsonQuerySqlServerJsonTypeTest.cs b/test/EFCore.SqlServer.FunctionalTests/Query/AdHocJsonQuerySqlServerJsonTypeTest.cs
index 89509e4de9..29b25af1e8 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Query/AdHocJsonQuerySqlServerJsonTypeTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Query/AdHocJsonQuerySqlServerJsonTypeTest.cs
@@ -53,6 +53,13 @@ public override Task Try_project_collection_but_JSON_is_entity()
     public override Task Try_project_reference_but_JSON_is_collection()
         => Assert.ThrowsAsync<ThrowsException>(base.Try_project_reference_but_JSON_is_collection);
 
+    // When using the SQL Server json type, we use JSON_VALUE() with the RETURNING clause to parse the JSON property value
+    // into the correct type (int in this case); since we (currently) use lax mode, if the format isn't correct as here
+    // (text instead of int), we get NULL out (strict mode would throw, see #36802 about possibly switching to that).
+    // And since the enum properties are required in the model, this causes "Nullable object must have a value" to be thrown.
+    public override Task Read_enum_property_with_legacy_values(bool async)
+        => Assert.ThrowsAsync<InvalidOperationException>(() => base.Read_enum_property_with_legacy_values_core(async));
+
     protected override string StoreName
         => "AdHocJsonQueryJsonTypeTest";
 
diff --git a/test/EFCore.SqlServer.FunctionalTests/Query/AdHocJsonQuerySqlServerTest.cs b/test/EFCore.SqlServer.FunctionalTests/Query/AdHocJsonQuerySqlServerTest.cs
index 7505a4293b..cda74c7d13 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Query/AdHocJsonQuerySqlServerTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Query/AdHocJsonQuerySqlServerTest.cs
@@ -1,6 +1,19 @@
 ï»¿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using Microsoft.Data.SqlClient;
+
 namespace Microsoft.EntityFrameworkCore.Query;
 
-public class AdHocJsonQuerySqlServerTest(NonSharedFixture fixture) : AdHocJsonQuerySqlServerTestBase(fixture);
+public class AdHocJsonQuerySqlServerTest(NonSharedFixture fixture) : AdHocJsonQuerySqlServerTestBase(fixture)
+{
+    public override async Task Read_enum_property_with_legacy_values(bool async)
+    {
+        var exception = await Assert.ThrowsAsync<SqlException>(() => base.Read_enum_property_with_legacy_values_core(async));
+
+        // When using legacy nvarchar(max) to store JSON, we add a CAST() node to convert the text coming out of JSON_VALUE()
+        // to the appropriate type (int in this case); if the format isn't correct as here (text instead of int),
+        // we get: Conversion failed when converting the nvarchar value '...' to data type int
+        Assert.Equal(245, exception.Number);
+    }
+}
diff --git a/test/EFCore.SqlServer.FunctionalTests/Query/AdHocJsonQuerySqlServerTestBase.cs b/test/EFCore.SqlServer.FunctionalTests/Query/AdHocJsonQuerySqlServerTestBase.cs
index 8fb5520899..eb2234f88b 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Query/AdHocJsonQuerySqlServerTestBase.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Query/AdHocJsonQuerySqlServerTestBase.cs
@@ -444,30 +444,33 @@ protected override async Task SeedBadJsonProperties(ContextBadJsonProperties ctx
 
     #region EnumLegacyValues
 
-    [ConditionalTheory(Skip = "#36626"), MemberData(nameof(IsAsyncData))]
-    public virtual async Task Read_enum_property_with_legacy_values(bool async)
+    [ConditionalTheory, MemberData(nameof(IsAsyncData))]
+    public abstract Task Read_enum_property_with_legacy_values(bool async);
+
+    protected virtual async Task Read_enum_property_with_legacy_values_core(bool async)
     {
         var contextFactory = await InitializeAsync<DbContext>(
             onModelCreating: BuildModelEnumLegacyValues,
             onConfiguring: b => b.ConfigureWarnings(ConfigureWarnings),
             seed: SeedEnumLegacyValues);
 
-        using (var context = contextFactory.CreateContext())
+        using var context = contextFactory.CreateContext();
+
+        var query = context.Set<MyEntityEnumLegacyValues>().Select(x => new
+        {
+            x.Reference.IntEnum,
+            x.Reference.ByteEnum,
+            x.Reference.LongEnum,
+            x.Reference.NullableEnum
+        });
+
+        if (async)
+        {
+            await query.ToListAsync();
+        }
+        else
         {
-            var query = context.Set<MyEntityEnumLegacyValues>().Select(x => new
-            {
-                x.Reference.IntEnum,
-                x.Reference.ByteEnum,
-                x.Reference.LongEnum,
-                x.Reference.NullableEnum
-            });
-
-            var exception = async
-                ? await (Assert.ThrowsAsync<SqlException>(() => query.ToListAsync()))
-                : Assert.Throws<SqlException>(() => query.ToList());
-
-            // Conversion failed when converting the nvarchar value '...' to data type int
-            Assert.Equal(245, exception.Number);
+            query.ToList();
         }
     }
 
