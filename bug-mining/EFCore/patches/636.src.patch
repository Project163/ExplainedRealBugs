diff --git a/src/EFCore.Relational/Metadata/Internal/JsonColumn.cs b/src/EFCore.Relational/Metadata/Internal/JsonColumn.cs
index 3ad9900707..1035416730 100644
--- a/src/EFCore.Relational/Metadata/Internal/JsonColumn.cs
+++ b/src/EFCore.Relational/Metadata/Internal/JsonColumn.cs
@@ -36,7 +36,7 @@ public class JsonColumn : Column, IColumn
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
     protected override RelationalTypeMapping GetDefaultStoreTypeMapping()
-        => (RelationalTypeMapping)Table.Model.Model.GetModelDependencies().TypeMappingSource.FindMapping(typeof(JsonElement))!;
+        => (RelationalTypeMapping)Table.Model.Model.GetModelDependencies().TypeMappingSource.FindMapping(typeof(JsonTypePlaceholder))!;
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
diff --git a/src/EFCore.Relational/Metadata/Internal/JsonColumnBase.cs b/src/EFCore.Relational/Metadata/Internal/JsonColumnBase.cs
index 3209bf64e7..acc1bf09fe 100644
--- a/src/EFCore.Relational/Metadata/Internal/JsonColumnBase.cs
+++ b/src/EFCore.Relational/Metadata/Internal/JsonColumnBase.cs
@@ -36,5 +36,5 @@ public class JsonColumnBase : ColumnBase<ColumnMappingBase>
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
     protected override RelationalTypeMapping GetDefaultStoreTypeMapping()
-        => (RelationalTypeMapping)Table.Model.Model.GetModelDependencies().TypeMappingSource.FindMapping(typeof(JsonElement))!;
+        => (RelationalTypeMapping)Table.Model.Model.GetModelDependencies().TypeMappingSource.FindMapping(typeof(JsonTypePlaceholder))!;
 }
diff --git a/src/EFCore.Relational/Metadata/Internal/JsonViewColumn.cs b/src/EFCore.Relational/Metadata/Internal/JsonViewColumn.cs
index 77c327332e..4b57ad45b7 100644
--- a/src/EFCore.Relational/Metadata/Internal/JsonViewColumn.cs
+++ b/src/EFCore.Relational/Metadata/Internal/JsonViewColumn.cs
@@ -36,5 +36,5 @@ public class JsonViewColumn : ViewColumn, IViewColumn
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
     protected override RelationalTypeMapping GetDefaultStoreTypeMapping()
-        => (RelationalTypeMapping)Table.Model.Model.GetModelDependencies().TypeMappingSource.FindMapping(typeof(JsonElement))!;
+        => (RelationalTypeMapping)Table.Model.Model.GetModelDependencies().TypeMappingSource.FindMapping(typeof(JsonTypePlaceholder))!;
 }
diff --git a/src/EFCore.Relational/Metadata/Internal/RelationalModel.cs b/src/EFCore.Relational/Metadata/Internal/RelationalModel.cs
index 8e2294fe40..27709772f4 100644
--- a/src/EFCore.Relational/Metadata/Internal/RelationalModel.cs
+++ b/src/EFCore.Relational/Metadata/Internal/RelationalModel.cs
@@ -582,7 +582,7 @@ private static IEnumerable<ITableMapping> GetTableMappings(ITypeBase typeBase)
         {
             Check.DebugAssert(tableBase.FindColumn(containerColumnName) == null, $"Table does not have column '{containerColumnName}'.");
 
-            var jsonColumnTypeMapping = relationalTypeMappingSource.FindMapping(typeof(JsonElement), storeTypeName: containerColumnType)!;
+            var jsonColumnTypeMapping = relationalTypeMappingSource.FindMapping(typeof(JsonTypePlaceholder), storeTypeName: containerColumnType)!;
             var jsonColumn = createColumn(containerColumnName, containerColumnType, tableBase, jsonColumnTypeMapping);
             tableBase.Columns.Add(containerColumnName, jsonColumn);
             jsonColumn.IsNullable = !ownership.IsRequiredDependent || !ownership.IsUnique;
diff --git a/src/EFCore.Relational/Storage/JsonTypeMapping.cs b/src/EFCore.Relational/Storage/JsonTypeMapping.cs
index 289bd85144..9a14f340ba 100644
--- a/src/EFCore.Relational/Storage/JsonTypeMapping.cs
+++ b/src/EFCore.Relational/Storage/JsonTypeMapping.cs
@@ -2,13 +2,12 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System.Data;
-using System.Text.Json;
 
 namespace Microsoft.EntityFrameworkCore.Storage;
 
 /// <summary>
 ///     <para>
-///         Represents the mapping between a <see cref="JsonElement" /> type and a database type.
+///         Represents the mapping between a JSON object and a database type.
 ///     </para>
 ///     <para>
 ///         This type is typically used by database providers (and other extensions). It is generally
diff --git a/src/EFCore.Relational/Storage/JsonTypePlaceholder.cs b/src/EFCore.Relational/Storage/JsonTypePlaceholder.cs
new file mode 100644
index 0000000000..027ee3465d
--- /dev/null
+++ b/src/EFCore.Relational/Storage/JsonTypePlaceholder.cs
@@ -0,0 +1,14 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.EntityFrameworkCore.Storage;
+
+/// <summary>
+/// A type representing CLR type of the JsonTypeMapping.
+/// </summary>
+public sealed class JsonTypePlaceholder
+{
+    private JsonTypePlaceholder()
+    {
+    }
+}
diff --git a/src/EFCore.SqlServer/Storage/Internal/SqlServerOwnedJsonTypeMapping.cs b/src/EFCore.SqlServer/Storage/Internal/SqlServerOwnedJsonTypeMapping.cs
index 6bd4cfeffb..801ac04475 100644
--- a/src/EFCore.SqlServer/Storage/Internal/SqlServerOwnedJsonTypeMapping.cs
+++ b/src/EFCore.SqlServer/Storage/Internal/SqlServerOwnedJsonTypeMapping.cs
@@ -45,7 +45,7 @@ public class SqlServerOwnedJsonTypeMapping : JsonTypeMapping
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
     public SqlServerOwnedJsonTypeMapping(string storeType)
-        : base(storeType, typeof(JsonElement), System.Data.DbType.String)
+        : base(storeType, typeof(JsonTypePlaceholder), System.Data.DbType.String)
     {
     }
 
diff --git a/src/EFCore.SqlServer/Storage/Internal/SqlServerTypeMappingSource.cs b/src/EFCore.SqlServer/Storage/Internal/SqlServerTypeMappingSource.cs
index 50d50413c2..b89cfbc9f6 100644
--- a/src/EFCore.SqlServer/Storage/Internal/SqlServerTypeMappingSource.cs
+++ b/src/EFCore.SqlServer/Storage/Internal/SqlServerTypeMappingSource.cs
@@ -3,7 +3,6 @@
 
 using System.Collections;
 using System.Data;
-using System.Text.Json;
 
 namespace Microsoft.EntityFrameworkCore.SqlServer.Storage.Internal;
 
@@ -239,7 +238,7 @@ static SqlServerTypeMappingSource()
         var clrType = mappingInfo.ClrType;
         var storeTypeName = mappingInfo.StoreTypeName;
 
-        if (clrType == typeof(JsonElement))
+        if (clrType == typeof(JsonTypePlaceholder))
         {
             return storeTypeName == "json"
                 ? SqlServerOwnedJsonTypeMapping.OwnedJsonTypeDefault
diff --git a/src/EFCore.Sqlite.Core/Storage/Internal/SqliteJsonTypeMapping.cs b/src/EFCore.Sqlite.Core/Storage/Internal/SqliteJsonTypeMapping.cs
index 2b40d34a55..51925eb4d9 100644
--- a/src/EFCore.Sqlite.Core/Storage/Internal/SqliteJsonTypeMapping.cs
+++ b/src/EFCore.Sqlite.Core/Storage/Internal/SqliteJsonTypeMapping.cs
@@ -39,7 +39,7 @@ public class SqliteJsonTypeMapping : JsonTypeMapping
     /// </summary>
     /// <param name="storeType">The name of the database type.</param>
     public SqliteJsonTypeMapping(string storeType)
-        : base(storeType, typeof(JsonElement), System.Data.DbType.String)
+        : base(storeType, typeof(JsonTypePlaceholder), System.Data.DbType.String)
     {
     }
 
diff --git a/src/EFCore.Sqlite.Core/Storage/Internal/SqliteTypeMappingSource.cs b/src/EFCore.Sqlite.Core/Storage/Internal/SqliteTypeMappingSource.cs
index 8e9e80978f..2cdc07fefe 100644
--- a/src/EFCore.Sqlite.Core/Storage/Internal/SqliteTypeMappingSource.cs
+++ b/src/EFCore.Sqlite.Core/Storage/Internal/SqliteTypeMappingSource.cs
@@ -83,7 +83,7 @@ public class SqliteTypeMappingSource : RelationalTypeMappingSource
         { typeof(double), Real },
         { typeof(float), new FloatTypeMapping(RealTypeName) },
         { typeof(Guid), SqliteGuidTypeMapping.Default },
-        { typeof(JsonElement), SqliteJsonTypeMapping.Default }
+        { typeof(JsonTypePlaceholder), SqliteJsonTypeMapping.Default }
     };
 
     private readonly Dictionary<string, RelationalTypeMapping> _storeTypeMappings = new(StringComparer.OrdinalIgnoreCase)
diff --git a/test/EFCore.Relational.Specification.Tests/Query/AdHocMiscellaneousQueryRelationalTestBase.cs b/test/EFCore.Relational.Specification.Tests/Query/AdHocMiscellaneousQueryRelationalTestBase.cs
index 2002239b4b..574e8e2959 100644
--- a/test/EFCore.Relational.Specification.Tests/Query/AdHocMiscellaneousQueryRelationalTestBase.cs
+++ b/test/EFCore.Relational.Specification.Tests/Query/AdHocMiscellaneousQueryRelationalTestBase.cs
@@ -4,6 +4,7 @@
 #nullable disable
 
 using System.ComponentModel.DataAnnotations.Schema;
+using System.Text.Json;
 using NameSpace1;
 
 namespace Microsoft.EntityFrameworkCore.Query
@@ -239,6 +240,32 @@ public static DateTime Modify(DateTime date)
 
         #endregion
 
+        #region 34752
+
+        [ConditionalFact]
+        public virtual async Task Mapping_JsonElement_property_throws_a_meaningful_exception()
+        {
+            var message = (await Assert.ThrowsAsync<InvalidOperationException>(
+                () => InitializeAsync<Context34752>())).Message;
+
+            Assert.Equal(
+                CoreStrings.PropertyNotAdded(nameof(Context34752.Entity), nameof(Context34752.Entity.Json), nameof(JsonElement)),
+                message);
+        }
+
+        protected class Context34752(DbContextOptions options) : DbContext(options)
+        {
+            public DbSet<Entity> Entities { get; set; }
+
+            public class Entity
+            {
+                public int Id { get; set; }
+                public JsonElement Json { get; set; }
+            }
+        }
+
+        #endregion
+
         #region Inlined redacting
 
         protected abstract DbContextOptionsBuilder SetTranslateParameterizedCollectionsToConstants(DbContextOptionsBuilder optionsBuilder);
diff --git a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/DbContextModelBuilder.cs b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/DbContextModelBuilder.cs
index 77a88d2d54..012b81141f 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/DbContextModelBuilder.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/DbContextModelBuilder.cs
@@ -1,12 +1,12 @@
 // <auto-generated />
 using System;
 using System.Collections.Generic;
-using System.Text.Json;
 using Microsoft.EntityFrameworkCore;
 using Microsoft.EntityFrameworkCore.Infrastructure;
 using Microsoft.EntityFrameworkCore.Metadata;
 using Microsoft.EntityFrameworkCore.Metadata.Internal;
 using Microsoft.EntityFrameworkCore.Migrations;
+using Microsoft.EntityFrameworkCore.Storage;
 using Microsoft.EntityFrameworkCore.Update.Internal;
 
 #pragma warning disable 219, 612, 618
@@ -2258,10 +2258,10 @@ private IRelationalModel CreateRelationalModel()
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("ManyOwned", manyOwnedColumn);
-            manyOwnedColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<JsonElement>(manyOwnedColumn);
+            manyOwnedColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<JsonTypePlaceholder>(manyOwnedColumn);
             var ownedColumn = new JsonColumn("Owned", "nvarchar(max)", principalBaseTable);
             principalBaseTable.Columns.Add("Owned", ownedColumn);
-            ownedColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<JsonElement>(ownedColumn);
+            ownedColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<JsonTypePlaceholder>(ownedColumn);
             var refTypeArrayColumn = new Column("RefTypeArray", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
diff --git a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/DbContextModelBuilder.cs b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/DbContextModelBuilder.cs
index 358b107b0d..20ada7f7fb 100644
--- a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/DbContextModelBuilder.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/DbContextModelBuilder.cs
@@ -1,12 +1,12 @@
 // <auto-generated />
 using System;
 using System.Collections.Generic;
-using System.Text.Json;
 using Microsoft.EntityFrameworkCore;
 using Microsoft.EntityFrameworkCore.Infrastructure;
 using Microsoft.EntityFrameworkCore.Metadata;
 using Microsoft.EntityFrameworkCore.Metadata.Internal;
 using Microsoft.EntityFrameworkCore.Migrations;
+using Microsoft.EntityFrameworkCore.Storage;
 using Microsoft.EntityFrameworkCore.Update.Internal;
 using NetTopologySuite.Geometries;
 
@@ -2325,10 +2325,10 @@ private IRelationalModel CreateRelationalModel()
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("ManyOwned", manyOwnedColumn);
-            manyOwnedColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<JsonElement>(manyOwnedColumn);
+            manyOwnedColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<JsonTypePlaceholder>(manyOwnedColumn);
             var ownedColumn = new JsonColumn("Owned", "TEXT", principalBaseTable);
             principalBaseTable.Columns.Add("Owned", ownedColumn);
-            ownedColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<JsonElement>(ownedColumn);
+            ownedColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<JsonTypePlaceholder>(ownedColumn);
             var pointColumn0 = new Column("Point", "geometry", principalBaseTable)
             {
                 IsNullable = true
