diff --git a/src/EFCore/Infrastructure/Internal/ConcurrencyDetector.cs b/src/EFCore/Infrastructure/Internal/ConcurrencyDetector.cs
index 4800df47bf..c63ae66064 100644
--- a/src/EFCore/Infrastructure/Internal/ConcurrencyDetector.cs
+++ b/src/EFCore/Infrastructure/Internal/ConcurrencyDetector.cs
@@ -12,8 +12,8 @@ namespace Microsoft.EntityFrameworkCore.Infrastructure.Internal;
 public class ConcurrencyDetector : IConcurrencyDetector
 {
     private int _inCriticalSection;
-    private static readonly AsyncLocal<bool> ThreadHasLock = new();
-    private int _refCount;
+    private static readonly AsyncLocal<int> ThreadAcquiredLocksCount = new();
+    private int _currentContextRefCount;
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
@@ -25,17 +25,14 @@ public virtual ConcurrencyDetectorCriticalSectionDisposer EnterCriticalSection()
     {
         if (Interlocked.CompareExchange(ref _inCriticalSection, 1, 0) == 1)
         {
-            if (!ThreadHasLock.Value)
+            if (ThreadAcquiredLocksCount.Value == 0)
             {
                 throw new InvalidOperationException(CoreStrings.ConcurrentMethodInvocation);
             }
         }
-        else
-        {
-            ThreadHasLock.Value = true;
-        }
 
-        _refCount++;
+        ThreadAcquiredLocksCount.Value++;
+        _currentContextRefCount++;
         return new ConcurrencyDetectorCriticalSectionDisposer(this);
     }
 
@@ -49,9 +46,9 @@ public virtual void ExitCriticalSection()
     {
         Check.DebugAssert(_inCriticalSection == 1, "Expected to be in a critical section");
 
-        if (--_refCount == 0)
+        ThreadAcquiredLocksCount.Value--;
+        if (--_currentContextRefCount == 0)
         {
-            ThreadHasLock.Value = false;
             _inCriticalSection = 0;
         }
     }
diff --git a/test/EFCore.Tests/Infrastructure/Internal/ConcurrencyDetectorTest.cs b/test/EFCore.Tests/Infrastructure/Internal/ConcurrencyDetectorTest.cs
new file mode 100644
index 0000000000..d78fdf75a4
--- /dev/null
+++ b/test/EFCore.Tests/Infrastructure/Internal/ConcurrencyDetectorTest.cs
@@ -0,0 +1,115 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.EntityFrameworkCore.Infrastructure.Internal;
+
+public class ConcurrencyDetectorTest
+{
+    [ConditionalFact]
+    public void MultipleContextOnSameThread_Should_Success()
+    {
+        var preparingContext = new Context();
+
+        var customer = new Customer
+        {
+            FirstName = "John",
+            LastName = "Doe"
+        };
+
+        preparingContext.Customers.Add(customer);
+        preparingContext.SaveChanges();
+
+        var order = new Order
+        {
+            CustomerId = customer.CustomerId,
+            OrderDate = DateTime.Now
+        };
+
+        preparingContext.Orders.Add(order);
+        preparingContext.SaveChanges();
+
+        var context  = new Context();
+
+        var exception = Record.Exception(() => context.Orders.Select(o => new { Date = o.OrderDate, Name = GetCustomer(o.OrderId, context) }).ToArray());
+
+        Assert.Null(exception);
+    }
+
+    // method imitates the procedure of loading entities into the cache within a separate context and then retrieves them by attaching them to the original context.
+    private static Customer GetCustomer(int orderId, Context originalCtx)
+    {
+        var context = new Context();
+        var orders = context.Orders.ToArray();
+        var order = orders.First(o => o.OrderId == orderId);
+
+        context.Entry(order).State = EntityState.Detached;
+        context.Dispose();
+
+        var orderCopy = new Order(originalCtx.GetService<ILazyLoader>())
+        {
+            OrderId = order.OrderId,
+            OrderDate = order.OrderDate,
+            CustomerId = order.CustomerId
+        };
+
+        var entity = originalCtx.Attach(orderCopy);
+
+        entity.State = EntityState.Unchanged;
+
+        return orderCopy.Customer;
+    }
+
+    private class Context : DbContext
+    {
+        protected internal override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
+            => optionsBuilder
+                .UseInMemoryDatabase(nameof(ConcurrencyDetectorTest));
+
+        protected internal override void OnModelCreating(ModelBuilder modelBuilder)
+        {
+            modelBuilder.Entity<Customer>().HasKey(c => c.CustomerId);
+            modelBuilder.Entity<Order>().HasKey(o => o.OrderId);
+
+            modelBuilder.Entity<Order>()
+                .HasOne(o => o.Customer)
+                .WithMany(c => c.Orders)
+                .HasForeignKey(o => o.CustomerId);
+        }
+
+        public DbSet<Customer> Customers { get; set; }
+        public DbSet<Order> Orders { get; set; }
+    }
+
+    public class Customer
+    {
+        public int CustomerId { get; set; }
+        public string FirstName { get; set; }
+        public string LastName { get; set; }
+        public virtual ICollection<Order> Orders { get; set; }
+    }
+
+    public class Order
+    {
+        private readonly ILazyLoader _lazyLoader;
+        private Customer _customer;
+
+        public Order()
+        {
+        }
+
+        public Order(ILazyLoader lazyLoader)
+        {
+            _lazyLoader = lazyLoader;
+        }
+
+        public int OrderId { get; set; }
+        public DateTime OrderDate { get; set; }
+        public int CustomerId { get; set; }
+
+        public Customer Customer
+        {
+            get => _lazyLoader.Load(this, ref _customer);
+            set => _customer = value;
+        }
+    }
+}
