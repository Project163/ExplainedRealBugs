diff --git a/src/EFCore/Diagnostics/IQueryExpressionInterceptor.cs b/src/EFCore/Diagnostics/IQueryExpressionInterceptor.cs
index f9c1bcbb13..24f8b64ba6 100644
--- a/src/EFCore/Diagnostics/IQueryExpressionInterceptor.cs
+++ b/src/EFCore/Diagnostics/IQueryExpressionInterceptor.cs
@@ -20,7 +20,7 @@ namespace Microsoft.EntityFrameworkCore.Diagnostics;
 ///         See <see href="https://aka.ms/efcore-docs-interceptors">EF Core interceptors</see> for more information and examples.
 ///     </para>
 /// </remarks>
-public interface IQueryExpressionInterceptor : IInterceptor
+public interface IQueryExpressionInterceptor : ISingletonInterceptor
 {
     /// <summary>
     ///     Called with the LINQ expression tree for a query before it is compiled.
diff --git a/test/EFCore.Cosmos.FunctionalTests/QueryExpressionInterceptionWithDiagnosticsCosmosTest.cs b/test/EFCore.Cosmos.FunctionalTests/QueryExpressionInterceptionWithDiagnosticsCosmosTest.cs
index b83b0d918f..01c69c5c3e 100644
--- a/test/EFCore.Cosmos.FunctionalTests/QueryExpressionInterceptionWithDiagnosticsCosmosTest.cs
+++ b/test/EFCore.Cosmos.FunctionalTests/QueryExpressionInterceptionWithDiagnosticsCosmosTest.cs
@@ -10,14 +10,17 @@ public class QueryExpressionInterceptionWithDiagnosticsCosmosTest(
     : QueryExpressionInterceptionTestBase(fixture),
         IClassFixture<QueryExpressionInterceptionWithDiagnosticsCosmosTest.InterceptionCosmosFixture>
 {
-    public override Task Intercept_query_passively(bool async, bool inject)
-        => CosmosTestHelpers.Instance.NoSyncTest(async, a => base.Intercept_query_passively(a, inject));
+    public override Task Intercept_query_passively(bool async)
+        => CosmosTestHelpers.Instance.NoSyncTest(async, a => base.Intercept_query_passively(a));
 
-    public override Task Intercept_query_with_multiple_interceptors(bool async, bool inject)
-        => CosmosTestHelpers.Instance.NoSyncTest(async, a => base.Intercept_query_with_multiple_interceptors(a, inject));
+    public override Task Intercept_query_with_multiple_interceptors(bool async)
+        => CosmosTestHelpers.Instance.NoSyncTest(async, a => base.Intercept_query_with_multiple_interceptors(a));
 
-    public override Task Intercept_to_change_query_expression(bool async, bool inject)
-        => CosmosTestHelpers.Instance.NoSyncTest(async, a => base.Intercept_to_change_query_expression(a, inject));
+    public override Task Intercept_to_change_query_expression(bool async)
+        => CosmosTestHelpers.Instance.NoSyncTest(async, a => base.Intercept_to_change_query_expression(a));
+
+    public override Task Interceptor_does_not_leak_across_contexts(bool async)
+        => CosmosTestHelpers.Instance.NoSyncTest(async, a => base.Interceptor_does_not_leak_across_contexts(a));
 
     public class InterceptionCosmosFixture : InterceptionFixtureBase
     {
diff --git a/test/EFCore.InMemory.FunctionalTests/QueryExpressionInterceptionInMemoryTestBase.cs b/test/EFCore.InMemory.FunctionalTests/QueryExpressionInterceptionInMemoryTestBase.cs
index eac5eeb054..6c8358dabb 100644
--- a/test/EFCore.InMemory.FunctionalTests/QueryExpressionInterceptionInMemoryTestBase.cs
+++ b/test/EFCore.InMemory.FunctionalTests/QueryExpressionInterceptionInMemoryTestBase.cs
@@ -7,6 +7,9 @@ public abstract class QueryExpressionInterceptionInMemoryTestBase(
     QueryExpressionInterceptionInMemoryTestBase.InterceptionInMemoryFixtureBase fixture)
     : QueryExpressionInterceptionTestBase(fixture)
 {
+    public override Task Interceptor_does_not_leak_across_contexts(bool async)
+        => Task.CompletedTask;
+
     public override async Task<UniverseContext> SeedAsync(UniverseContext context)
     {
         await base.SeedAsync(context);
diff --git a/test/EFCore.Specification.Tests/QueryExpressionInterceptionTestBase.cs b/test/EFCore.Specification.Tests/QueryExpressionInterceptionTestBase.cs
index d02c1ec7f9..32fb767da1 100644
--- a/test/EFCore.Specification.Tests/QueryExpressionInterceptionTestBase.cs
+++ b/test/EFCore.Specification.Tests/QueryExpressionInterceptionTestBase.cs
@@ -9,55 +9,43 @@ public abstract class QueryExpressionInterceptionTestBase(InterceptionTestBase.I
     : InterceptionTestBase(fixture)
 {
     [ConditionalTheory]
-    [InlineData(false, false)]
-    [InlineData(true, false)]
-    [InlineData(false, true)]
-    [InlineData(true, true)]
-    public virtual async Task Intercept_query_passively(bool async, bool inject)
+    [MemberData(nameof(IsAsyncData))]
+    public virtual async Task Intercept_query_passively(bool async)
     {
-        var (context, interceptor) = await CreateContextAsync<TestQueryExpressionInterceptor>(inject);
+        var (context, interceptor) = await CreateContextAsync<TestQueryExpressionInterceptor>(inject: true);
 
         using var _ = context;
 
         var query = context.Set<Singularity>().Where(e => e.Type == "Black Hole");
-        var results = async ? await query.ToListAsync() : query.ToList();
+        var result = async ? await query.SingleAsync() : query.Single();
 
-        Assert.Single(results);
-        Assert.Equal("Black Hole", results[0].Type);
+        Assert.Equal("Black Hole", result.Type);
 
         AssertNormalOutcome(context, interceptor);
 
-        Assert.Contains(@".Where(e => e.Type == ""Black Hole"")", interceptor.QueryExpression);
+        Assert.Contains(""".Where(e => e.Type == "Black Hole")""", interceptor.QueryExpression);
     }
 
     [ConditionalTheory]
-    [InlineData(false, false)]
-    [InlineData(true, false)]
-    [InlineData(false, true)]
-    [InlineData(true, true)]
-    public virtual async Task Intercept_query_with_multiple_interceptors(bool async, bool inject)
+    [MemberData(nameof(IsAsyncData))]
+    public virtual async Task Intercept_query_with_multiple_interceptors(bool async)
     {
         var interceptor1 = new TestQueryExpressionInterceptor();
         var interceptor2 = new QueryChangingExpressionInterceptor();
-        var interceptor3 = new TestQueryExpressionInterceptor();
-        var interceptor4 = new TestQueryExpressionInterceptor();
 
         using var context = await CreateContextAsync(
-            new IInterceptor[] { new TestQueryExpressionInterceptor(), interceptor1, interceptor2 },
-            new IInterceptor[] { interceptor3, interceptor4, new TestQueryExpressionInterceptor() });
+            appInterceptor: null,
+            [interceptor1, interceptor2]);
 
         using var listener = Fixture.SubscribeToDiagnosticListener(context.ContextId);
 
         var query = context.Set<Singularity>().Where(e => e.Type == "Bing Bang");
-        var results = async ? await query.ToListAsync() : query.ToList();
+        var result = async ? await query.SingleAsync() : query.Single();
 
-        Assert.Single(results);
-        Assert.Equal("Bing Bang", results[0].Type);
+        Assert.Equal("Bing Bang", result.Type);
 
         AssertNormalOutcome(context, interceptor1);
         AssertNormalOutcome(context, interceptor2);
-        AssertNormalOutcome(context, interceptor3);
-        AssertNormalOutcome(context, interceptor4);
 
         listener.AssertEventsInOrder(
             CoreEventId.QueryCompilationStarting.Name,
@@ -67,25 +55,48 @@ public virtual async Task Intercept_query_with_multiple_interceptors(bool async,
     }
 
     [ConditionalTheory]
-    [InlineData(false, false)]
-    [InlineData(true, false)]
-    [InlineData(false, true)]
-    [InlineData(true, true)]
-    public virtual async Task Intercept_to_change_query_expression(bool async, bool inject)
+    [MemberData(nameof(IsAsyncData))]
+    public virtual async Task Intercept_to_change_query_expression(bool async)
     {
-        var (context, interceptor) = await CreateContextAsync<QueryChangingExpressionInterceptor>(inject);
+        var (context, interceptor) = await CreateContextAsync<QueryChangingExpressionInterceptor>(inject: true);
 
         using var _ = context;
 
         var query = context.Set<Singularity>().Where(e => e.Type == "Black Hole");
-        var results = async ? await query.ToListAsync() : query.ToList();
+        var result = async ? await query.SingleAsync() : query.Single();
 
-        Assert.Single(results);
-        Assert.Equal("Bing Bang", results[0].Type);
+        Assert.Equal("Bing Bang", result.Type);
 
         AssertNormalOutcome(context, interceptor);
 
-        Assert.Contains(@".Where(e => e.Type == ""Bing Bang"")", interceptor.QueryExpression);
+        Assert.Contains(""".Where(e => e.Type == "Bing Bang")""", interceptor.QueryExpression);
+    }
+
+    [ConditionalTheory]
+    [MemberData(nameof(IsAsyncData))]
+    public virtual async Task Interceptor_does_not_leak_across_contexts(bool async)
+    {
+        // Create one context with QueryChangingExpressionInterceptor, and another with TestQueryExpressionInterceptor (which is a no-op).
+        // Note that we don't use the regular suite infra for creating the contexts, as that creates separate service providers for each
+        // one, but that's exactly what we want to test here.
+        using var context1 = new UniverseContext(
+            Fixture.AddOptions(
+                Fixture.TestStore.AddProviderOptions(
+                    new DbContextOptionsBuilder<DbContext>().AddInterceptors(new QueryChangingExpressionInterceptor())))
+            .Options);
+        using var context2 = new UniverseContext(
+            Fixture.AddOptions(
+                Fixture.TestStore.AddProviderOptions(
+                    new DbContextOptionsBuilder<DbContext>().AddInterceptors(new TestQueryExpressionInterceptor())))
+            .Options);
+
+        var query1 = context1.Set<Singularity>().Where(e => e.Type == "Black Hole");
+        var result1 = async ? await query1.SingleAsync() : query1.Single();
+        Assert.Equal("Bing Bang", result1.Type);
+
+        var query2 = context2.Set<Singularity>().Where(e => e.Type == "Black Hole");
+        var result2 = async ? await query2.SingleAsync() : query2.Single();
+        Assert.Equal("Black Hole", result2.Type);
     }
 
     protected class QueryChangingExpressionInterceptor : TestQueryExpressionInterceptor
@@ -128,4 +139,6 @@ protected class TestQueryExpressionInterceptor : IQueryExpressionInterceptor
             return queryExpression;
         }
     }
+
+    public static readonly IEnumerable<object[]> IsAsyncData = [[false], [true]];
 }
