diff --git a/src/EFCore/Metadata/Conventions/RuntimeModelConvention.cs b/src/EFCore/Metadata/Conventions/RuntimeModelConvention.cs
index e1607e4dfd..8e6f1d89b2 100644
--- a/src/EFCore/Metadata/Conventions/RuntimeModelConvention.cs
+++ b/src/EFCore/Metadata/Conventions/RuntimeModelConvention.cs
@@ -54,6 +54,7 @@ public virtual IModel ProcessModelFinalized(IModel model)
         protected virtual RuntimeModel Create(IModel model)
         {
             var runtimeModel = new RuntimeModel();
+            runtimeModel.ModelId = model.ModelId;
             runtimeModel.SetSkipDetectChanges(((IRuntimeModel)model).SkipDetectChanges);
             ((IModel)runtimeModel).ModelDependencies = model.ModelDependencies!;
 
diff --git a/src/EFCore/Metadata/IReadOnlyModel.cs b/src/EFCore/Metadata/IReadOnlyModel.cs
index 4816a841cf..cf506f4b5b 100644
--- a/src/EFCore/Metadata/IReadOnlyModel.cs
+++ b/src/EFCore/Metadata/IReadOnlyModel.cs
@@ -198,6 +198,15 @@ private static int GetDerivedLevel(Type? derivedType, Dictionary<Type, int> deri
             return level;
         }
 
+        /// <summary>
+        ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+        ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+        ///     any release. You should only use it directly in your code with extreme caution and knowing that
+        ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+        /// </summary>
+        [EntityFrameworkInternal]
+        public Guid ModelId { get; }
+
         /// <summary>
         ///     <para>
         ///         Creates a human-readable representation of the given metadata.
diff --git a/src/EFCore/Metadata/Internal/Model.cs b/src/EFCore/Metadata/Internal/Model.cs
index b25074b663..74f493bfcb 100644
--- a/src/EFCore/Metadata/Internal/Model.cs
+++ b/src/EFCore/Metadata/Internal/Model.cs
@@ -471,6 +471,14 @@ public virtual IEnumerable<EntityType> FindEntityTypes(Type type)
                 : result;
         }
 
+        /// <summary>
+        ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+        ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+        ///     any release. You should only use it directly in your code with extreme caution and knowing that
+        ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+        /// </summary>
+        public virtual Guid ModelId { get; } = Guid.NewGuid();
+
         /// <summary>
         ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
         ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
diff --git a/src/EFCore/Metadata/RuntimeModel.cs b/src/EFCore/Metadata/RuntimeModel.cs
index f94b02d583..0d967cbded 100644
--- a/src/EFCore/Metadata/RuntimeModel.cs
+++ b/src/EFCore/Metadata/RuntimeModel.cs
@@ -135,6 +135,15 @@ private IEnumerable<RuntimeEntityType> FindEntityTypes(Type type)
                 : result;
         }
 
+        /// <summary>
+        ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+        ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+        ///     any release. You should only use it directly in your code with extreme caution and knowing that
+        ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+        /// </summary>
+        [EntityFrameworkInternal]
+        public virtual Guid ModelId { get; set; }
+
         /// <summary>
         ///     Adds configuration for a scalar type.
         /// </summary>
@@ -302,5 +311,9 @@ IEnumerable<ITypeMappingConfiguration> IModel.GetTypeMappingConfigurations()
             => _typeConfigurations.Count == 0
                 ? null
                 : _typeConfigurations.GetValueOrDefault(propertyType);
+
+        /// <inheritdoc />
+        Guid IReadOnlyModel.ModelId
+            => ModelId;
     }
 }
diff --git a/src/EFCore/ValueGeneration/ValueGeneratorCache.cs b/src/EFCore/ValueGeneration/ValueGeneratorCache.cs
index 6e9536afcf..a714feae56 100644
--- a/src/EFCore/ValueGeneration/ValueGeneratorCache.cs
+++ b/src/EFCore/ValueGeneration/ValueGeneratorCache.cs
@@ -29,6 +29,9 @@ namespace Microsoft.EntityFrameworkCore.ValueGeneration
     /// </remarks>
     public class ValueGeneratorCache : IValueGeneratorCache
     {
+        private static readonly bool _useOldBehavior31539 =
+            AppContext.TryGetSwitch("Microsoft.EntityFrameworkCore.Issue31539", out var enabled31539) && enabled31539;
+
         /// <summary>
         ///     Initializes a new instance of the <see cref="ValueGeneratorCache" /> class.
         /// </summary>
@@ -49,24 +52,48 @@ public ValueGeneratorCache(ValueGeneratorCacheDependencies dependencies)
 
         private readonly struct CacheKey : IEquatable<CacheKey>
         {
+            private readonly Guid _modelId;
+            private readonly string? _property;
+            private readonly string? _entityType;
+
             public CacheKey(IProperty property, IEntityType entityType)
             {
-                Property = property;
-                EntityType = entityType;
+                if (_useOldBehavior31539)
+                {
+                    _modelId = default;
+                    _property = null;
+                    _entityType = null;
+                    Property = property;
+                    EntityType = entityType;
+                }
+                else
+                {
+                    _modelId = entityType.Model.ModelId;
+                    _property = property.Name;
+                    _entityType = entityType.Name;
+                    Property = null;
+                    EntityType = null;
+                }
             }
 
-            public IProperty Property { get; }
+            public IProperty? Property { get; }
 
-            public IEntityType EntityType { get; }
+            public IEntityType? EntityType { get; }
 
             public bool Equals(CacheKey other)
-                => Property.Equals(other.Property) && EntityType.Equals(other.EntityType);
+                => _useOldBehavior31539
+                    ? Property!.Equals(other.Property) && EntityType!.Equals(other.EntityType)
+                    : (_property!.Equals(other._property, StringComparison.Ordinal)
+                        && _entityType!.Equals(other._entityType, StringComparison.Ordinal)
+                        && _modelId.Equals(other._modelId));
 
             public override bool Equals(object? obj)
                 => obj is CacheKey cacheKey && Equals(cacheKey);
 
             public override int GetHashCode()
-                => HashCode.Combine(Property, EntityType);
+                => _useOldBehavior31539
+                    ? HashCode.Combine(Property!, EntityType!)
+                    : HashCode.Combine(_property!, _entityType!, _modelId);
         }
 
         /// <summary>
@@ -88,7 +115,8 @@ public override int GetHashCode()
             Check.NotNull(property, nameof(property));
             Check.NotNull(factory, nameof(factory));
 
-            return _cache.GetOrAdd(new CacheKey(property, entityType), static (ck, f) => f(ck.Property, ck.EntityType), factory);
+            return _cache.GetOrAdd(
+                new CacheKey(property, entityType), static (ck, p) => p.factory(p.property, p.entityType), (factory, entityType, property));
         }
     }
 }
diff --git a/test/EFCore.Tests/ChangeTracking/Internal/KeyPropagatorTest.cs b/test/EFCore.Tests/ChangeTracking/Internal/KeyPropagatorTest.cs
index 95989c74ed..15fb1de0e8 100644
--- a/test/EFCore.Tests/ChangeTracking/Internal/KeyPropagatorTest.cs
+++ b/test/EFCore.Tests/ChangeTracking/Internal/KeyPropagatorTest.cs
@@ -169,18 +169,17 @@ public void Identifying_foreign_key_value_is_generated_if_principal_key_not_set(
         [InlineData(true, true)]
         public void Identifying_foreign_key_value_is_propagated_if_principal_key_is_generated(bool generateTemporary, bool async)
         {
-            var model = BuildModel(generateTemporary);
-
             var principal = new Product();
             var dependent = new ProductDetail { Product = principal };
 
-            var contextServices = CreateContextServices(model);
+            var contextServices = CreateContextServices(BuildModel(generateTemporary));
             var stateManager = contextServices.GetRequiredService<IStateManager>();
             var principalEntry = stateManager.GetOrCreateEntry(principal);
             principalEntry.SetEntityState(EntityState.Added);
             var dependentEntry = stateManager.GetOrCreateEntry(dependent);
-            var principalProperty = model.FindEntityType(typeof(Product)).FindProperty(nameof(Product.Id));
-            var dependentProperty = model.FindEntityType(typeof(ProductDetail)).FindProperty(nameof(ProductDetail.Id));
+            var runtimeModel = contextServices.GetRequiredService<IModel>();
+            var principalProperty = runtimeModel.FindEntityType(typeof(Product))!.FindProperty(nameof(Product.Id))!;
+            var dependentProperty = runtimeModel.FindEntityType(typeof(ProductDetail))!.FindProperty(nameof(ProductDetail.Id))!;
             var keyPropagator = contextServices.GetRequiredService<IKeyPropagator>();
 
             PropagateValue(keyPropagator, dependentEntry, dependentProperty, async);
