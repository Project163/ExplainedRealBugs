diff --git a/Directory.Packages.props b/Directory.Packages.props
index 5e1cc4bac1..086bb8e4c6 100644
--- a/Directory.Packages.props
+++ b/Directory.Packages.props
@@ -48,7 +48,7 @@
     <PackageVersion Include="Castle.Core" Version="5.2.1" />
     <PackageVersion Include="Humanizer.Core" Version="2.14.1" />
     <PackageVersion Include="Mono.TextTemplating" Version="3.0.0" />
-    <PackageVersion Include="NetTopologySuite" Version="2.5.0" />
+    <PackageVersion Include="NetTopologySuite" Version="2.6.0" />
     <PackageVersion Include="NetTopologySuite.IO.SpatiaLite" Version="2.0.0" />
     <PackageVersion Include="NetTopologySuite.IO.SqlServerBytes" Version="2.1.0" />
     <PackageVersion Include="Newtonsoft.Json" Version="13.0.3" />
diff --git a/src/EFCore.InMemory/Query/Internal/InMemoryExpressionTranslatingExpressionVisitor.cs b/src/EFCore.InMemory/Query/Internal/InMemoryExpressionTranslatingExpressionVisitor.cs
index 81803b4667..4c451233f7 100644
--- a/src/EFCore.InMemory/Query/Internal/InMemoryExpressionTranslatingExpressionVisitor.cs
+++ b/src/EFCore.InMemory/Query/Internal/InMemoryExpressionTranslatingExpressionVisitor.cs
@@ -925,6 +925,18 @@ protected override Expression VisitMethodCall(MethodCallExpression methodCallExp
             return Expression.Condition(objectNullCheck, Expression.Constant(null, result.Type), result);
         }
 
+        // Null-compensate any extension method where the 'this' argument is a reference type
+        // (in theory should do this for value types as well, but that's more complicated as the expression type needs to be changed etc.)
+        if (methodCallExpression is { Object: null, Method: { IsStatic: true } staticMethod }
+            && staticMethod.IsDefined(typeof(System.Runtime.CompilerServices.ExtensionAttribute), inherit: false)
+            && arguments is [{ Type.IsValueType: false } instance, ..])
+        {
+            return Expression.Condition(
+                Expression.Equal(instance, Expression.Constant(null, instance.Type)),
+                Expression.Default(methodCallExpression.Type),
+                Expression.Call(methodCallExpression.Method, arguments));
+        }
+
         return methodCallExpression.Update(@object, arguments);
     }
 
diff --git a/src/EFCore.SqlServer.NTS/Query/Internal/SqlServerGeometryCollectionMethodTranslator.cs b/src/EFCore.SqlServer.NTS/Query/Internal/SqlServerGeometryCollectionMethodTranslator.cs
index f17a864dc8..ea93b0a182 100644
--- a/src/EFCore.SqlServer.NTS/Query/Internal/SqlServerGeometryCollectionMethodTranslator.cs
+++ b/src/EFCore.SqlServer.NTS/Query/Internal/SqlServerGeometryCollectionMethodTranslator.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using Microsoft.EntityFrameworkCore.Query.SqlExpressions;
+using Microsoft.EntityFrameworkCore.SqlServer.Storage.Internal;
 using NetTopologySuite.Geometries;
 
 namespace Microsoft.EntityFrameworkCore.SqlServer.Query.Internal;
@@ -14,7 +15,6 @@ namespace Microsoft.EntityFrameworkCore.SqlServer.Query.Internal;
 /// </summary>
 public class SqlServerGeometryCollectionMethodTranslator : IMethodCallTranslator
 {
-    private static readonly MethodInfo Item = typeof(GeometryCollection).GetTypeInfo().GetRuntimeProperty("Item")!.GetMethod!;
     private readonly IRelationalTypeMappingSource _typeMappingSource;
     private readonly ISqlExpressionFactory _sqlExpressionFactory;
 
@@ -44,23 +44,21 @@ public class SqlServerGeometryCollectionMethodTranslator : IMethodCallTranslator
         IReadOnlyList<SqlExpression> arguments,
         IDiagnosticsLogger<DbLoggerCategory.Query> logger)
     {
-        if (Equals(method, Item)
-            && instance != null)
+        if (method.IsGenericMethod
+            && method.GetGenericMethodDefinition() == EnumerableMethods.ElementAt
+            && method.ReturnType == typeof(Geometry)
+            && arguments is [var collection, var index]
+            && _typeMappingSource.FindMapping(typeof(Geometry), collection.TypeMapping!.StoreType) is RelationalTypeMapping geometryTypeMapping)
         {
             return _sqlExpressionFactory.Function(
-                instance,
+                collection,
                 "STGeometryN",
-                new[]
-                {
-                    _sqlExpressionFactory.Add(
-                        arguments[0],
-                        _sqlExpressionFactory.Constant(1))
-                },
+                [_sqlExpressionFactory.Add(index, _sqlExpressionFactory.Constant(1))],
                 nullable: true,
                 instancePropagatesNullability: true,
                 argumentsPropagateNullability: Statics.FalseArrays[1],
                 method.ReturnType,
-                _typeMappingSource.FindMapping(typeof(Geometry), instance.TypeMapping!.StoreType));
+                geometryTypeMapping);
         }
 
         return null;
diff --git a/src/EFCore.Sqlite.NTS/Query/Internal/SqliteGeometryCollectionMethodTranslator.cs b/src/EFCore.Sqlite.NTS/Query/Internal/SqliteGeometryCollectionMethodTranslator.cs
index f9a74bf052..e152541bf9 100644
--- a/src/EFCore.Sqlite.NTS/Query/Internal/SqliteGeometryCollectionMethodTranslator.cs
+++ b/src/EFCore.Sqlite.NTS/Query/Internal/SqliteGeometryCollectionMethodTranslator.cs
@@ -14,7 +14,6 @@ namespace Microsoft.EntityFrameworkCore.Sqlite.Query.Internal;
 /// </summary>
 public class SqliteGeometryCollectionMethodTranslator : IMethodCallTranslator
 {
-    private static readonly MethodInfo Item = typeof(GeometryCollection).GetTypeInfo().GetRuntimeProperty("Item")!.GetMethod!;
     private readonly ISqlExpressionFactory _sqlExpressionFactory;
 
     /// <summary>
@@ -38,17 +37,17 @@ public SqliteGeometryCollectionMethodTranslator(ISqlExpressionFactory sqlExpress
         IReadOnlyList<SqlExpression> arguments,
         IDiagnosticsLogger<DbLoggerCategory.Query> logger)
     {
-        if (Equals(method, Item))
+        if (method.IsGenericMethod
+            && method.GetGenericMethodDefinition() == EnumerableMethods.ElementAt
+            && method.ReturnType == typeof(Geometry)
+            && arguments is [var collection, var index])
         {
             return _sqlExpressionFactory.Function(
                 "GeometryN",
-                new[]
-                {
-                    instance!,
-                    _sqlExpressionFactory.Add(
-                        arguments[0],
-                        _sqlExpressionFactory.Constant(1))
-                },
+                [
+                    collection,
+                    _sqlExpressionFactory.Add(index, _sqlExpressionFactory.Constant(1))
+                ],
                 nullable: true,
                 argumentsPropagateNullability: Statics.TrueArrays[2],
                 method.ReturnType);
diff --git a/test/EFCore.InMemory.FunctionalTests/Query/QueryFilterFuncletizationInMemoryTest.cs b/test/EFCore.InMemory.FunctionalTests/Query/QueryFilterFuncletizationInMemoryTest.cs
index ece8bbad05..90788abc3e 100644
--- a/test/EFCore.InMemory.FunctionalTests/Query/QueryFilterFuncletizationInMemoryTest.cs
+++ b/test/EFCore.InMemory.FunctionalTests/Query/QueryFilterFuncletizationInMemoryTest.cs
@@ -6,25 +6,6 @@ namespace Microsoft.EntityFrameworkCore.Query;
 public class QueryFilterFuncletizationInMemoryTest(QueryFilterFuncletizationInMemoryTest.QueryFilterFuncletizationInMemoryFixture fixture)
     : QueryFilterFuncletizationTestBase<QueryFilterFuncletizationInMemoryTest.QueryFilterFuncletizationInMemoryFixture>(fixture)
 {
-    public override void DbContext_list_is_parameterized()
-    {
-        using var context = CreateContext();
-        // Default value of TenantIds is null InExpression over null values throws
-        Assert.Throws<ArgumentNullException>(() => context.Set<ListFilter>().ToList());
-
-        context.TenantIds = [];
-        var query = context.Set<ListFilter>().ToList();
-        Assert.Empty(query);
-
-        context.TenantIds = [1];
-        query = context.Set<ListFilter>().ToList();
-        Assert.Single(query);
-
-        context.TenantIds = [2, 3];
-        query = context.Set<ListFilter>().ToList();
-        Assert.Equal(2, query.Count);
-    }
-
     public class QueryFilterFuncletizationInMemoryFixture : QueryFilterFuncletizationFixtureBase
     {
         protected override ITestStoreFactory TestStoreFactory
