diff --git a/src/EFCore.Relational/Extensions/RelationalPropertyExtensions.cs b/src/EFCore.Relational/Extensions/RelationalPropertyExtensions.cs
index 96c101ae42..db1bbdd1f8 100644
--- a/src/EFCore.Relational/Extensions/RelationalPropertyExtensions.cs
+++ b/src/EFCore.Relational/Extensions/RelationalPropertyExtensions.cs
@@ -1022,7 +1022,7 @@ public static void SetDefaultValue(this IMutableProperty property, object? value
             {
                 return Convert.ChangeType(value, property.ClrType, CultureInfo.InvariantCulture);
             }
-            catch (Exception)
+            catch
             {
                 throw new InvalidOperationException(
                     RelationalStrings.IncorrectDefaultValueType(
diff --git a/src/EFCore.Relational/Migrations/HistoryRepository.cs b/src/EFCore.Relational/Migrations/HistoryRepository.cs
index ed111047ec..e3d1a03e75 100644
--- a/src/EFCore.Relational/Migrations/HistoryRepository.cs
+++ b/src/EFCore.Relational/Migrations/HistoryRepository.cs
@@ -23,8 +23,6 @@ namespace Microsoft.EntityFrameworkCore.Migrations;
 ///         See <see href="https://aka.ms/efcore-docs-migrations">Database migrations</see> for more information and examples.
 ///     </para>
 /// </remarks>
-// TODO: Leverage query pipeline for GetAppliedMigrations
-// TODO: Leverage update pipeline for GetInsertScript & GetDeleteScript
 public abstract class HistoryRepository : IHistoryRepository
 {
     /// <summary>
@@ -122,15 +120,14 @@ protected virtual string ProductVersionColumnName
     /// </summary>
     /// <returns><see langword="true" /> if the table already exists, <see langword="false" /> otherwise.</returns>
     public virtual bool Exists()
-        => Dependencies.DatabaseCreator.Exists()
-            && InterpretExistsResult(
-                Dependencies.RawSqlCommandBuilder.Build(ExistsSql).ExecuteScalar(
-                    new RelationalCommandParameterObject(
-                        Dependencies.Connection,
-                        null,
-                        null,
-                        Dependencies.CurrentContext.Context,
-                        Dependencies.CommandLogger, CommandSource.Migrations)));
+        => InterpretExistsResult(
+            Dependencies.RawSqlCommandBuilder.Build(ExistsSql).ExecuteScalar(
+                new RelationalCommandParameterObject(
+                    Dependencies.Connection,
+                    null,
+                    null,
+                    Dependencies.CurrentContext.Context,
+                    Dependencies.CommandLogger, CommandSource.Migrations)));
 
     /// <summary>
     ///     Checks whether or not the history table exists.
@@ -142,16 +139,15 @@ public virtual bool Exists()
     /// </returns>
     /// <exception cref="OperationCanceledException">If the <see cref="CancellationToken" /> is canceled.</exception>
     public virtual async Task<bool> ExistsAsync(CancellationToken cancellationToken = default)
-        => await Dependencies.DatabaseCreator.ExistsAsync(cancellationToken).ConfigureAwait(false)
-            && InterpretExistsResult(
-                await Dependencies.RawSqlCommandBuilder.Build(ExistsSql).ExecuteScalarAsync(
-                    new RelationalCommandParameterObject(
-                        Dependencies.Connection,
-                        null,
-                        null,
-                        Dependencies.CurrentContext.Context,
-                        Dependencies.CommandLogger, CommandSource.Migrations),
-                    cancellationToken).ConfigureAwait(false));
+        => InterpretExistsResult(
+            await Dependencies.RawSqlCommandBuilder.Build(ExistsSql).ExecuteScalarAsync(
+                new RelationalCommandParameterObject(
+                    Dependencies.Connection,
+                    null,
+                    null,
+                    Dependencies.CurrentContext.Context,
+                    Dependencies.CommandLogger, CommandSource.Migrations),
+                cancellationToken).ConfigureAwait(false));
 
     /// <summary>
     ///     Interprets the result of executing <see cref="ExistsSql" />.
@@ -171,15 +167,49 @@ public virtual async Task<bool> ExistsAsync(CancellationToken cancellationToken
     /// </summary>
     /// <returns>The SQL script.</returns>
     public virtual string GetCreateScript()
+        => string.Concat(GetCreateCommands().Select(c => c.CommandText));
+
+    /// <summary>
+    ///     Creates the history table.
+    /// </summary>
+    public virtual void Create()
+        => Dependencies.MigrationCommandExecutor.ExecuteNonQuery(GetCreateCommands(), Dependencies.Connection);
+
+    /// <summary>
+    ///     Creates the history table.
+    /// </summary>
+    public virtual Task CreateAsync(CancellationToken cancellationToken = default)
+        => Dependencies.MigrationCommandExecutor.ExecuteNonQueryAsync(GetCreateCommands(), Dependencies.Connection, cancellationToken);
+
+    /// <summary>
+    ///     Returns the migration commands that will create the history table.
+    /// </summary>
+    /// <returns>The migration commands that will create the history table.</returns>
+    protected virtual IReadOnlyList<MigrationCommand> GetCreateCommands()
     {
         var model = EnsureModel();
 
         var operations = Dependencies.ModelDiffer.GetDifferences(null, model.GetRelationalModel());
         var commandList = Dependencies.MigrationsSqlGenerator.Generate(operations, model);
-
-        return string.Concat(commandList.Select(c => c.CommandText));
+        return commandList;
     }
 
+    /// <summary>
+    ///     Gets an exclusive lock on the database.
+    /// </summary>
+    /// <param name="timeout">The time to wait for the lock before an exception is thrown.</param>
+    /// <returns>An object that can be disposed to release the lock.</returns>
+    public abstract IDisposable GetDatabaseLock(TimeSpan timeout);
+
+    /// <summary>
+    ///     Gets an exclusive lock on the database.
+    /// </summary>
+    /// <param name="timeout">The time to wait for the lock before an exception is thrown.</param>
+    /// <param name="cancellationToken">A <see cref="CancellationToken" /> to observe while waiting for the task to complete.</param>
+    /// <returns>An object that can be disposed to release the lock.</returns>
+    /// <exception cref="OperationCanceledException">If the <see cref="CancellationToken" /> is canceled.</exception>
+    public abstract Task<IAsyncDisposable> GetDatabaseLockAsync(TimeSpan timeout, CancellationToken cancellationToken = default);
+
     /// <summary>
     ///     Configures the entity type mapped to the history table.
     /// </summary>
diff --git a/src/EFCore.Relational/Migrations/HistoryRepositoryDependencies.cs b/src/EFCore.Relational/Migrations/HistoryRepositoryDependencies.cs
index b3e8340059..b5f40bd8ba 100644
--- a/src/EFCore.Relational/Migrations/HistoryRepositoryDependencies.cs
+++ b/src/EFCore.Relational/Migrations/HistoryRepositoryDependencies.cs
@@ -52,6 +52,7 @@ public sealed record HistoryRepositoryDependencies
         IDbContextOptions options,
         IMigrationsModelDiffer modelDiffer,
         IMigrationsSqlGenerator migrationsSqlGenerator,
+        IMigrationCommandExecutor migrationCommandExecutor,
         ISqlGenerationHelper sqlGenerationHelper,
         IConventionSetBuilder conventionSetBuilder,
         ModelDependencies modelDependencies,
@@ -66,6 +67,7 @@ public sealed record HistoryRepositoryDependencies
         Options = options;
         ModelDiffer = modelDiffer;
         MigrationsSqlGenerator = migrationsSqlGenerator;
+        MigrationCommandExecutor = migrationCommandExecutor;
         SqlGenerationHelper = sqlGenerationHelper;
         ConventionSetBuilder = conventionSetBuilder;
         ModelDependencies = modelDependencies;
@@ -110,6 +112,11 @@ public sealed record HistoryRepositoryDependencies
     /// </summary>
     public ISqlGenerationHelper SqlGenerationHelper { get; init; }
 
+    /// <summary>
+    ///     The service for executing Migrations operations.
+    /// </summary>
+    public IMigrationCommandExecutor MigrationCommandExecutor { get; init; }
+
     /// <summary>
     ///     The core convention set to use when creating the model.
     /// </summary>
diff --git a/src/EFCore.Relational/Migrations/IHistoryRepository.cs b/src/EFCore.Relational/Migrations/IHistoryRepository.cs
index 70abc61b27..4d52db3804 100644
--- a/src/EFCore.Relational/Migrations/IHistoryRepository.cs
+++ b/src/EFCore.Relational/Migrations/IHistoryRepository.cs
@@ -24,13 +24,13 @@ namespace Microsoft.EntityFrameworkCore.Migrations;
 public interface IHistoryRepository
 {
     /// <summary>
-    ///     Checks whether or not the history table exists.
+    ///     Checks whether the history table exists.
     /// </summary>
     /// <returns><see langword="true" /> if the table already exists, <see langword="false" /> otherwise.</returns>
     bool Exists();
 
     /// <summary>
-    ///     Checks whether or not the history table exists.
+    ///     Checks whether the history table exists.
     /// </summary>
     /// <param name="cancellationToken">A <see cref="CancellationToken" /> to observe while waiting for the task to complete.</param>
     /// <returns>
@@ -40,6 +40,22 @@ public interface IHistoryRepository
     /// <exception cref="OperationCanceledException">If the <see cref="CancellationToken" /> is canceled.</exception>
     Task<bool> ExistsAsync(CancellationToken cancellationToken = default);
 
+    /// <summary>
+    ///     Creates the history table.
+    /// </summary>
+    void Create();
+
+    /// <summary>
+    ///     Creates the history table.
+    /// </summary>
+    /// <param name="cancellationToken">A <see cref="CancellationToken" /> to observe while waiting for the task to complete.</param>
+    /// <returns>
+    ///     A task that represents the asynchronous operation. The task result contains
+    ///     <see langword="true" /> if the table already exists, <see langword="false" /> otherwise.
+    /// </returns>
+    /// <exception cref="OperationCanceledException">If the <see cref="CancellationToken" /> is canceled.</exception>
+    Task CreateAsync(CancellationToken cancellationToken = default);
+
     /// <summary>
     ///     Queries the history table for all migrations that have been applied.
     /// </summary>
@@ -58,6 +74,22 @@ public interface IHistoryRepository
     Task<IReadOnlyList<HistoryRow>> GetAppliedMigrationsAsync(
         CancellationToken cancellationToken = default);
 
+    /// <summary>
+    ///     Gets an exclusive lock on the database.
+    /// </summary>
+    /// <param name="timeout">The time to wait for the lock before an exception is thrown.</param>
+    /// <returns>An object that can be disposed to release the lock.</returns>
+    IDisposable GetDatabaseLock(TimeSpan timeout);
+
+    /// <summary>
+    ///     Gets an exclusive lock on the database.
+    /// </summary>
+    /// <param name="timeout">The time to wait for the lock before an exception is thrown.</param>
+    /// <param name="cancellationToken">A <see cref="CancellationToken" /> to observe while waiting for the task to complete.</param>
+    /// <returns>An object that can be disposed to release the lock.</returns>
+    /// <exception cref="OperationCanceledException">If the <see cref="CancellationToken" /> is canceled.</exception>
+    Task<IAsyncDisposable> GetDatabaseLockAsync(TimeSpan timeout, CancellationToken cancellationToken = default);
+
     /// <summary>
     ///     Generates a SQL script that will create the history table.
     /// </summary>
diff --git a/src/EFCore.Relational/Migrations/Internal/MigrationsModelDiffer.cs b/src/EFCore.Relational/Migrations/Internal/MigrationsModelDiffer.cs
index 1eb56e1899..281859fbf3 100644
--- a/src/EFCore.Relational/Migrations/Internal/MigrationsModelDiffer.cs
+++ b/src/EFCore.Relational/Migrations/Internal/MigrationsModelDiffer.cs
@@ -2047,7 +2047,7 @@ private void AddSeedData(IEntityType entityType, Dictionary<ITable, IRowIdentity
                         {
                             value = propertyInfo.GetValue(seed, [property.Name]);
                         }
-                        catch (Exception)
+                        catch
                         {
                             return (null, false);
                         }
diff --git a/src/EFCore.Relational/Migrations/Internal/Migrator.cs b/src/EFCore.Relational/Migrations/Internal/Migrator.cs
index 67d61c6084..6263bec3a9 100644
--- a/src/EFCore.Relational/Migrations/Internal/Migrator.cs
+++ b/src/EFCore.Relational/Migrations/Internal/Migrator.cs
@@ -61,6 +61,14 @@ public class Migrator : IMigrator
         _activeProvider = databaseProvider.Name;
     }
 
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    protected virtual TimeSpan LockTimeout { get; } = TimeSpan.FromMinutes(30);
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -71,29 +79,32 @@ public virtual void Migrate(string? targetMigration = null)
     {
         _logger.MigrateUsingConnection(this, _connection);
 
-        if (!_historyRepository.Exists())
+        if (!_databaseCreator.Exists())
+        {
+            _databaseCreator.Create();
+        }
+
+        try
         {
-            if (!_databaseCreator.Exists())
+            _connection.Open();
+
+            using var _ = _historyRepository.GetDatabaseLock(LockTimeout);
+
+            if (!_historyRepository.Exists())
             {
-                _databaseCreator.Create();
+                _historyRepository.Create();
             }
 
-            var command = _rawSqlCommandBuilder.Build(
-                _historyRepository.GetCreateScript());
+            var commandLists = GetMigrationCommandLists(_historyRepository.GetAppliedMigrations(), targetMigration);
 
-            command.ExecuteNonQuery(
-                new RelationalCommandParameterObject(
-                    _connection,
-                    null,
-                    null,
-                    _currentContext.Context,
-                    _commandLogger, CommandSource.Migrations));
+            foreach (var commandList in commandLists)
+            {
+                _migrationCommandExecutor.ExecuteNonQuery(commandList(), _connection);
+            }
         }
-
-        var commandLists = GetMigrationCommandLists(_historyRepository.GetAppliedMigrations(), targetMigration);
-        foreach (var commandList in commandLists)
+        finally
         {
-            _migrationCommandExecutor.ExecuteNonQuery(commandList(), _connection);
+            _connection.Close();
         }
     }
 
@@ -109,35 +120,36 @@ public virtual void Migrate(string? targetMigration = null)
     {
         _logger.MigrateUsingConnection(this, _connection);
 
-        if (!await _historyRepository.ExistsAsync(cancellationToken).ConfigureAwait(false))
+        if (!await _databaseCreator.ExistsAsync(cancellationToken).ConfigureAwait(false))
         {
-            if (!await _databaseCreator.ExistsAsync(cancellationToken).ConfigureAwait(false))
+            await _databaseCreator.CreateAsync(cancellationToken).ConfigureAwait(false);
+        }
+
+        try
+        {
+            await _connection.OpenAsync(cancellationToken).ConfigureAwait(false);
+
+            var dbLock = await _historyRepository.GetDatabaseLockAsync(LockTimeout, cancellationToken).ConfigureAwait(false);
+            await using var _ = dbLock.ConfigureAwait(false);
+
+            if (!await _historyRepository.ExistsAsync(cancellationToken).ConfigureAwait(false))
             {
-                await _databaseCreator.CreateAsync(cancellationToken).ConfigureAwait(false);
+                await _historyRepository.CreateAsync(cancellationToken).ConfigureAwait(false);
             }
 
-            var command = _rawSqlCommandBuilder.Build(
-                _historyRepository.GetCreateScript());
-
-            await command.ExecuteNonQueryAsync(
-                    new RelationalCommandParameterObject(
-                        _connection,
-                        null,
-                        null,
-                        _currentContext.Context,
-                        _commandLogger, CommandSource.Migrations),
-                    cancellationToken)
-                .ConfigureAwait(false);
-        }
-
-        var commandLists = GetMigrationCommandLists(
-            await _historyRepository.GetAppliedMigrationsAsync(cancellationToken).ConfigureAwait(false),
-            targetMigration);
+            var commandLists = GetMigrationCommandLists(
+                await _historyRepository.GetAppliedMigrationsAsync(cancellationToken).ConfigureAwait(false),
+                targetMigration);
 
-        foreach (var commandList in commandLists)
+            foreach (var commandList in commandLists)
+            {
+                await _migrationCommandExecutor.ExecuteNonQueryAsync(commandList(), _connection, cancellationToken)
+                    .ConfigureAwait(false);
+            }
+        }
+        finally
         {
-            await _migrationCommandExecutor.ExecuteNonQueryAsync(commandList(), _connection, cancellationToken)
-                .ConfigureAwait(false);
+            _connection.Close();
         }
     }
 
@@ -303,8 +315,9 @@ await _migrationCommandExecutor.ExecuteNonQueryAsync(commandList(), _connection,
                 .Append(_sqlGenerationHelper.BatchTerminator);
         }
 
-        var transactionStarted = false;
-
+        var idempotencyEnd = idempotent
+            ? _historyRepository.GetEndIfScript()
+            : null;
         for (var i = 0; i < migrationsToRevert.Count; i++)
         {
             var migration = migrationsToRevert[i];
@@ -314,107 +327,82 @@ await _migrationCommandExecutor.ExecuteNonQueryAsync(commandList(), _connection,
 
             _logger.MigrationGeneratingDownScript(this, migration, fromMigration, toMigration, idempotent);
 
-            foreach (var command in GenerateDownSql(migration, previousMigration, options))
-            {
-                if (!noTransactions)
-                {
-                    if (!transactionStarted && !command.TransactionSuppressed)
-                    {
-                        builder
-                            .AppendLine(_sqlGenerationHelper.StartTransactionStatement)
-                            .Append(_sqlGenerationHelper.BatchTerminator);
-                        transactionStarted = true;
-                    }
-
-                    if (transactionStarted && command.TransactionSuppressed)
-                    {
-                        builder
-                            .AppendLine(_sqlGenerationHelper.CommitTransactionStatement)
-                            .Append(_sqlGenerationHelper.BatchTerminator);
-                        transactionStarted = false;
-                    }
-                }
+            var idempotencyCondition = idempotent
+                ? _historyRepository.GetBeginIfExistsScript(migration.GetId())
+                : null;
 
-                if (idempotent)
-                {
-                    builder.AppendLine(_historyRepository.GetBeginIfExistsScript(migration.GetId()));
-                    using (builder.Indent())
-                    {
-                        builder.AppendLines(command.CommandText);
-                    }
-
-                    builder.Append(_historyRepository.GetEndIfScript());
-                }
-                else
-                {
-                    builder.Append(command.CommandText);
-                }
-
-                builder.Append(_sqlGenerationHelper.BatchTerminator);
-            }
-
-            if (!noTransactions && transactionStarted)
-            {
-                builder
-                    .AppendLine(_sqlGenerationHelper.CommitTransactionStatement)
-                    .Append(_sqlGenerationHelper.BatchTerminator);
-                transactionStarted = false;
-            }
+            GenerateSqlScript(GenerateDownSql(migration, previousMigration, options), builder, _sqlGenerationHelper, noTransactions, idempotencyCondition, idempotencyEnd);
         }
 
         foreach (var migration in migrationsToApply)
         {
             _logger.MigrationGeneratingUpScript(this, migration, fromMigration, toMigration, idempotent);
 
-            foreach (var command in GenerateUpSql(migration, options))
+            var idempotencyCondition = idempotent
+                ? _historyRepository.GetBeginIfNotExistsScript(migration.GetId())
+                : null;
+
+            GenerateSqlScript(GenerateUpSql(migration, options), builder, _sqlGenerationHelper, noTransactions, idempotencyCondition, idempotencyEnd);
+        }
+
+        return builder.ToString();
+    }
+
+    private static void GenerateSqlScript(
+        IEnumerable<MigrationCommand> commands,
+        IndentedStringBuilder builder,
+        ISqlGenerationHelper sqlGenerationHelper,
+        bool noTransactions = false,
+        string? idempotencyCondition = null,
+        string? idempotencyEnd = null)
+    {
+        var transactionStarted = false;
+        foreach (var command in commands)
+        {
+            if (!noTransactions)
             {
-                if (!noTransactions)
+                if (!transactionStarted && !command.TransactionSuppressed)
                 {
-                    if (!transactionStarted && !command.TransactionSuppressed)
-                    {
-                        builder
-                            .AppendLine(_sqlGenerationHelper.StartTransactionStatement)
-                            .Append(_sqlGenerationHelper.BatchTerminator);
-                        transactionStarted = true;
-                    }
-
-                    if (transactionStarted && command.TransactionSuppressed)
-                    {
-                        builder
-                            .AppendLine(_sqlGenerationHelper.CommitTransactionStatement)
-                            .Append(_sqlGenerationHelper.BatchTerminator);
-                        transactionStarted = false;
-                    }
+                    builder
+                        .AppendLine(sqlGenerationHelper.StartTransactionStatement)
+                        .Append(sqlGenerationHelper.BatchTerminator);
+                    transactionStarted = true;
                 }
 
-                if (idempotent)
+                if (transactionStarted && command.TransactionSuppressed)
                 {
-                    builder.AppendLine(_historyRepository.GetBeginIfNotExistsScript(migration.GetId()));
-                    using (builder.Indent())
-                    {
-                        builder.AppendLines(command.CommandText);
-                    }
-
-                    builder.Append(_historyRepository.GetEndIfScript());
+                    builder
+                        .AppendLine(sqlGenerationHelper.CommitTransactionStatement)
+                        .Append(sqlGenerationHelper.BatchTerminator);
+                    transactionStarted = false;
                 }
-                else
+            }
+
+            if (idempotencyCondition != null
+                && idempotencyEnd != null)
+            {
+                builder.AppendLine(idempotencyCondition);
+                using (builder.Indent())
                 {
-                    builder.Append(command.CommandText);
+                    builder.AppendLines(command.CommandText);
                 }
 
-                builder.Append(_sqlGenerationHelper.BatchTerminator);
+                builder.Append(idempotencyEnd);
             }
-
-            if (!noTransactions && transactionStarted)
+            else
             {
-                builder
-                    .AppendLine(_sqlGenerationHelper.CommitTransactionStatement)
-                    .Append(_sqlGenerationHelper.BatchTerminator);
-                transactionStarted = false;
+                builder.Append(command.CommandText);
             }
+
+            builder.Append(sqlGenerationHelper.BatchTerminator);
         }
 
-        return builder.ToString();
+        if (!noTransactions && transactionStarted)
+        {
+            builder
+                .AppendLine(sqlGenerationHelper.CommitTransactionStatement)
+                .Append(sqlGenerationHelper.BatchTerminator);
+        }
     }
 
     /// <summary>
@@ -432,7 +420,7 @@ await _migrationCommandExecutor.ExecuteNonQueryAsync(commandList(), _connection,
 
         return _migrationsSqlGenerator
             .Generate(migration.UpOperations, FinalizeModel(migration.TargetModel), options)
-            .Concat(new[] { new MigrationCommand(insertCommand, _currentContext.Context, _commandLogger) })
+            .Concat([new MigrationCommand(insertCommand, _currentContext.Context, _commandLogger)])
             .ToList();
     }
 
@@ -453,7 +441,7 @@ await _migrationCommandExecutor.ExecuteNonQueryAsync(commandList(), _connection,
         return _migrationsSqlGenerator
             .Generate(
                 migration.DownOperations, previousMigration == null ? null : FinalizeModel(previousMigration.TargetModel), options)
-            .Concat(new[] { new MigrationCommand(deleteCommand, _currentContext.Context, _commandLogger) })
+            .Concat([new MigrationCommand(deleteCommand, _currentContext.Context, _commandLogger)])
             .ToList();
     }
 
diff --git a/src/EFCore.SqlServer/Migrations/Internal/SqlServerHistoryRepository.cs b/src/EFCore.SqlServer/Migrations/Internal/SqlServerHistoryRepository.cs
index 1169be0a89..cf365bcc2c 100644
--- a/src/EFCore.SqlServer/Migrations/Internal/SqlServerHistoryRepository.cs
+++ b/src/EFCore.SqlServer/Migrations/Internal/SqlServerHistoryRepository.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System.Text;
+using Microsoft.Data.SqlClient;
 
 namespace Microsoft.EntityFrameworkCore.SqlServer.Migrations.Internal;
 
@@ -53,6 +54,96 @@ protected override string ExistsSql
     protected override bool InterpretExistsResult(object? value)
         => value != DBNull.Value;
 
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public override IDisposable GetDatabaseLock(TimeSpan timeout)
+    {
+        var dbLock = CreateMigrationDatabaseLock();
+        int result;
+        try
+        {
+            result = (int)CreateGetLockCommand(timeout).ExecuteScalar(CreateRelationalCommandParameters())!;
+        }
+        catch
+        {
+            try
+            {
+                dbLock.Dispose();
+            }
+            catch
+            {
+            }
+
+            throw;
+        }
+
+        return result < 0
+            ? throw new TimeoutException()
+            : dbLock;
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public override async Task<IAsyncDisposable> GetDatabaseLockAsync(TimeSpan timeout, CancellationToken cancellationToken = default)
+    {
+        var dbLock = CreateMigrationDatabaseLock();
+        int result;
+        try
+        {
+            result = (int)(await CreateGetLockCommand(timeout).ExecuteScalarAsync(CreateRelationalCommandParameters(), cancellationToken)
+                .ConfigureAwait(false))!;
+        }
+        catch
+        {
+            try
+            {
+                await dbLock.DisposeAsync().ConfigureAwait(false);
+            }
+            catch
+            {
+            }
+
+            throw;
+        }
+
+        return result < 0
+            ? throw new TimeoutException()
+            : dbLock;
+    }
+
+    private IRelationalCommand CreateGetLockCommand(TimeSpan timeout)
+        => Dependencies.RawSqlCommandBuilder.Build("""
+DECLARE @result int;
+EXEC @result = sp_getapplock @Resource = '__EFMigrationsLock', @LockOwner = 'Session', @LockMode = 'Exclusive', @LockTimeout = @LockTimeout;
+SELECT @result
+""",
+            [new SqlParameter("@LockTimeout", timeout.TotalMilliseconds)]).RelationalCommand;
+
+    private SqlServerMigrationDatabaseLock CreateMigrationDatabaseLock()
+        => new(
+            Dependencies.RawSqlCommandBuilder.Build("""
+DECLARE @result int;
+EXEC @result = sp_releaseapplock @Resource = '__EFMigrationsLock', @LockOwner = 'Session';
+SELECT @result
+"""),
+            CreateRelationalCommandParameters());
+
+    private RelationalCommandParameterObject CreateRelationalCommandParameters()
+        => new(
+            Dependencies.Connection,
+            null,
+            null,
+            Dependencies.CurrentContext.Context,
+            Dependencies.CommandLogger, CommandSource.Migrations);
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
diff --git a/src/EFCore.SqlServer/Migrations/Internal/SqlServerMigrationDatabaseLock.cs b/src/EFCore.SqlServer/Migrations/Internal/SqlServerMigrationDatabaseLock.cs
new file mode 100644
index 0000000000..110dd267fc
--- /dev/null
+++ b/src/EFCore.SqlServer/Migrations/Internal/SqlServerMigrationDatabaseLock.cs
@@ -0,0 +1,42 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.EntityFrameworkCore.SqlServer.Migrations.Internal;
+
+/// <summary>
+///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+///     any release. You should only use it directly in your code with extreme caution and knowing that
+///     doing so can result in application failures when updating to a new Entity Framework Core release.
+/// </summary>
+/// <remarks>
+///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+///     any release. You should only use it directly in your code with extreme caution and knowing that
+///     doing so can result in application failures when updating to a new Entity Framework Core release.
+/// </remarks>
+public class SqlServerMigrationDatabaseLock(
+    IRelationalCommand relationalCommand,
+    RelationalCommandParameterObject relationalCommandParameters,
+    CancellationToken cancellationToken = default)
+    : IDisposable, IAsyncDisposable
+{
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public void Dispose()
+        => relationalCommand.ExecuteScalar(relationalCommandParameters);
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public async ValueTask DisposeAsync()
+        => await relationalCommand.ExecuteScalarAsync(relationalCommandParameters, cancellationToken).ConfigureAwait(false);
+}
diff --git a/src/EFCore.Sqlite.Core/Migrations/Internal/SqliteHistoryRepository.cs b/src/EFCore.Sqlite.Core/Migrations/Internal/SqliteHistoryRepository.cs
index 1d0a57fd31..477a43a65e 100644
--- a/src/EFCore.Sqlite.Core/Migrations/Internal/SqliteHistoryRepository.cs
+++ b/src/EFCore.Sqlite.Core/Migrations/Internal/SqliteHistoryRepository.cs
@@ -1,6 +1,7 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using System.Text;
 using Microsoft.EntityFrameworkCore.Sqlite.Internal;
 
 namespace Microsoft.EntityFrameworkCore.Sqlite.Migrations.Internal;
@@ -13,6 +14,8 @@ namespace Microsoft.EntityFrameworkCore.Sqlite.Migrations.Internal;
 /// </summary>
 public class SqliteHistoryRepository : HistoryRepository
 {
+    private static readonly TimeSpan _retryDelay = TimeSpan.FromSeconds(1);
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -30,16 +33,20 @@ public SqliteHistoryRepository(HistoryRepositoryDependencies dependencies)
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    protected override string ExistsSql
+    protected override string ExistsSql => CreateExistsSql(TableName);
+
+    /// <summary>
+    ///     The name of the table that will serve as a database-wide lock for migrations.
+    /// </summary>
+    protected virtual string LockTableName { get; } = "__EFMigrationsLock";
+
+    private string CreateExistsSql(string tableName)
     {
-        get
-        {
-            var stringTypeMapping = Dependencies.TypeMappingSource.GetMapping(typeof(string));
+        var stringTypeMapping = Dependencies.TypeMappingSource.GetMapping(typeof(string));
 
-            return "SELECT COUNT(*) FROM \"sqlite_master\" WHERE \"name\" = "
-                + stringTypeMapping.GenerateSqlLiteral(TableName)
-                + " AND \"type\" = 'table';";
-        }
+        return $"""
+SELECT COUNT(*) FROM "sqlite_master" WHERE "name" = {stringTypeMapping.GenerateSqlLiteral(tableName)} AND "type" = 'table';
+""";
     }
 
     /// <summary>
@@ -60,7 +67,6 @@ protected override bool InterpretExistsResult(object? value)
     public override string GetCreateIfNotExistsScript()
     {
         var script = GetCreateScript();
-
         return script.Insert(script.IndexOf("CREATE TABLE", StringComparison.Ordinal) + 12, " IF NOT EXISTS");
     }
 
@@ -90,4 +96,148 @@ public override string GetBeginIfExistsScript(string migrationId)
     /// </summary>
     public override string GetEndIfScript()
         => throw new NotSupportedException(SqliteStrings.MigrationScriptGenerationNotSupported);
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public override IDisposable GetDatabaseLock(TimeSpan timeout)
+    {
+        if (!InterpretExistsResult(Dependencies.RawSqlCommandBuilder.Build(CreateExistsSql(LockTableName))
+            .ExecuteScalar(CreateRelationalCommandParameters())))
+        {
+            CreateLockTableCommand().ExecuteNonQuery(CreateRelationalCommandParameters());
+        }
+
+        var retryDelay = _retryDelay;
+        var startTime = DateTimeOffset.UtcNow;
+        while (DateTimeOffset.UtcNow - startTime < timeout)
+        {
+            var dbLock = CreateMigrationDatabaseLock();
+            var insertCount = CreateInsertLockCommand(DateTimeOffset.UtcNow)
+                .ExecuteScalar(CreateRelationalCommandParameters());
+            if ((long)insertCount! == 1)
+            {
+                return dbLock;
+            }
+
+            using var reader = CreateGetLockCommand().ExecuteReader(CreateRelationalCommandParameters());
+            if (reader.Read())
+            {
+                var timestamp = reader.DbDataReader.GetFieldValue<DateTimeOffset>(1);
+                if (DateTimeOffset.UtcNow - timestamp > timeout)
+                {
+                    var id = reader.DbDataReader.GetFieldValue<int>(0);
+                    CreateDeleteLockCommand(id).ExecuteNonQuery(CreateRelationalCommandParameters());
+                }
+            }
+
+            Thread.Sleep(retryDelay);
+            if (retryDelay < TimeSpan.FromMinutes(1))
+            {
+                retryDelay = retryDelay.Add(retryDelay);
+            }
+        }
+
+        throw new TimeoutException();
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public override async Task<IAsyncDisposable> GetDatabaseLockAsync(TimeSpan timeout, CancellationToken cancellationToken = default)
+    {
+        if (!InterpretExistsResult(await Dependencies.RawSqlCommandBuilder.Build(CreateExistsSql(LockTableName))
+            .ExecuteScalarAsync(CreateRelationalCommandParameters(), cancellationToken).ConfigureAwait(false)))
+        {
+            await CreateLockTableCommand().ExecuteNonQueryAsync(CreateRelationalCommandParameters(), cancellationToken).ConfigureAwait(false);
+        }
+
+        var retryDelay = _retryDelay;
+        var startTime = DateTimeOffset.UtcNow;
+        while (DateTimeOffset.UtcNow - startTime < timeout)
+        {
+            var dbLock = CreateMigrationDatabaseLock();
+            var insertCount = await CreateInsertLockCommand(DateTimeOffset.UtcNow)
+                .ExecuteScalarAsync(CreateRelationalCommandParameters(), cancellationToken)
+                .ConfigureAwait(false);
+            if ((long)insertCount! == 1)
+            {
+                return dbLock;
+            }
+
+            using var reader = await CreateGetLockCommand().ExecuteReaderAsync(CreateRelationalCommandParameters(), cancellationToken)
+                .ConfigureAwait(false);
+            if (await reader.ReadAsync(cancellationToken).ConfigureAwait(false))
+            {
+                var timestamp = await reader.DbDataReader.GetFieldValueAsync<DateTimeOffset>(1).ConfigureAwait(false);
+                if (DateTimeOffset.UtcNow - timestamp > timeout)
+                {
+                    var id = await reader.DbDataReader.GetFieldValueAsync<int>(0).ConfigureAwait(false);
+                    await CreateDeleteLockCommand(id).ExecuteNonQueryAsync(CreateRelationalCommandParameters(), cancellationToken)
+                        .ConfigureAwait(false);
+                }
+            }
+
+            await Task.Delay(_retryDelay, cancellationToken).ConfigureAwait(true);
+            if (retryDelay < TimeSpan.FromMinutes(1))
+            {
+                retryDelay = retryDelay.Add(retryDelay);
+            }
+        }
+
+        throw new TimeoutException();
+    }
+
+    private IRelationalCommand CreateLockTableCommand()
+        => Dependencies.RawSqlCommandBuilder.Build($"""
+CREATE TABLE IF NOT EXISTS "{LockTableName}" (
+    "Id" INTEGER NOT NULL CONSTRAINT "PK_{LockTableName}" PRIMARY KEY,
+    "Timestamp" TEXT NOT NULL
+);
+""");
+
+    private IRelationalCommand CreateInsertLockCommand(DateTimeOffset timestamp)
+    {
+        var timestampLiteral = Dependencies.TypeMappingSource.GetMapping(typeof(DateTimeOffset)).GenerateSqlLiteral(timestamp);
+
+        return Dependencies.RawSqlCommandBuilder.Build($"""
+INSERT OR IGNORE INTO "{LockTableName}"("Id", "Timestamp") VALUES(1, {timestampLiteral});
+SELECT changes();
+""");
+    }
+
+    private IRelationalCommand CreateGetLockCommand()
+        => Dependencies.RawSqlCommandBuilder.Build($"""
+SELECT "Id", "Timestamp" FROM "{LockTableName}" LIMIT 1;
+""");
+
+    private IRelationalCommand CreateDeleteLockCommand(int? id = null)
+    {
+        var sql = $"""
+DELETE FROM "{LockTableName}"
+""";
+        if (id != null)
+        {
+            sql += $""" WHERE "Id" = {id}""";
+        }
+        sql += ";";
+        return Dependencies.RawSqlCommandBuilder.Build(sql);
+    }
+
+    private SqliteMigrationDatabaseLock CreateMigrationDatabaseLock()
+        => new(CreateDeleteLockCommand(), CreateRelationalCommandParameters());
+
+    private RelationalCommandParameterObject CreateRelationalCommandParameters()
+        => new(
+            Dependencies.Connection,
+            null,
+            null,
+            Dependencies.CurrentContext.Context,
+            Dependencies.CommandLogger, CommandSource.Migrations);
 }
diff --git a/src/EFCore.Sqlite.Core/Migrations/Internal/SqliteMigrationDatabaseLock.cs b/src/EFCore.Sqlite.Core/Migrations/Internal/SqliteMigrationDatabaseLock.cs
new file mode 100644
index 0000000000..997cbcd471
--- /dev/null
+++ b/src/EFCore.Sqlite.Core/Migrations/Internal/SqliteMigrationDatabaseLock.cs
@@ -0,0 +1,35 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.EntityFrameworkCore.Sqlite.Migrations.Internal;
+
+/// <summary>
+///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+///     any release. You should only use it directly in your code with extreme caution and knowing that
+///     doing so can result in application failures when updating to a new Entity Framework Core release.
+/// </summary>
+public class SqliteMigrationDatabaseLock(
+    IRelationalCommand relationalCommand,
+    RelationalCommandParameterObject relationalCommandParameters,
+    CancellationToken cancellationToken = default)
+    : IDisposable, IAsyncDisposable
+{
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public void Dispose()
+        => relationalCommand.ExecuteScalar(relationalCommandParameters);
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public async ValueTask DisposeAsync()
+        => await relationalCommand.ExecuteScalarAsync(relationalCommandParameters, cancellationToken).ConfigureAwait(false);
+}
diff --git a/src/EFCore/AutoTransactionBehavior.cs b/src/EFCore/AutoTransactionBehavior.cs
index 25d6e11db2..bd34420276 100644
--- a/src/EFCore/AutoTransactionBehavior.cs
+++ b/src/EFCore/AutoTransactionBehavior.cs
@@ -4,7 +4,7 @@
 namespace Microsoft.EntityFrameworkCore;
 
 /// <summary>
-///     Indicates whether or not a transaction will be created automatically by <see cref="DbContext.SaveChanges()" /> if a user transaction
+///     Indicates whether a transaction will be created automatically by <see cref="DbContext.SaveChanges()" /> if a user transaction
 ///     wasn't created via 'BeginTransaction' or provided via 'UseTransaction'.
 /// </summary>
 public enum AutoTransactionBehavior
diff --git a/src/EFCore/Diagnostics/CoreLoggerExtensions.cs b/src/EFCore/Diagnostics/CoreLoggerExtensions.cs
index a41f9621ec..cda0afbff2 100644
--- a/src/EFCore/Diagnostics/CoreLoggerExtensions.cs
+++ b/src/EFCore/Diagnostics/CoreLoggerExtensions.cs
@@ -2855,7 +2855,7 @@ private static string StateChangedSensitive(EventDefinitionBase definition, Even
     /// <param name="internalEntityEntry">The internal entity entry.</param>
     /// <param name="property">The property.</param>
     /// <param name="value">The value generated.</param>
-    /// <param name="temporary">Indicates whether or not the value is a temporary or permanent value.</param>
+    /// <param name="temporary">Indicates whether the value is a temporary or permanent value.</param>
     public static void ValueGenerated(
         this IDiagnosticsLogger<DbLoggerCategory.ChangeTracking> diagnostics,
         InternalEntityEntry internalEntityEntry,
diff --git a/src/EFCore/Diagnostics/ExecutionStrategyEventData.cs b/src/EFCore/Diagnostics/ExecutionStrategyEventData.cs
index 2557b05a78..d93f36a7af 100644
--- a/src/EFCore/Diagnostics/ExecutionStrategyEventData.cs
+++ b/src/EFCore/Diagnostics/ExecutionStrategyEventData.cs
@@ -24,7 +24,7 @@ public class ExecutionStrategyEventData : EventData
     /// </param>
     /// <param name="delay">The delay before retrying the operation.</param>
     /// <param name="async">
-    ///     Indicates whether or not the command was executed asynchronously.
+    ///     Indicates whether the command was executed asynchronously.
     /// </param>
     public ExecutionStrategyEventData(
         EventDefinitionBase eventDefinition,
@@ -50,7 +50,7 @@ public class ExecutionStrategyEventData : EventData
     public virtual TimeSpan Delay { get; }
 
     /// <summary>
-    ///     Indicates whether or not the operation is being executed asynchronously.
+    ///     Indicates whether the operation is being executed asynchronously.
     /// </summary>
     public virtual bool IsAsync { get; }
 }
diff --git a/src/EFCore/Diagnostics/IDbContextLogger.cs b/src/EFCore/Diagnostics/IDbContextLogger.cs
index 797242a4d3..04857fb4e8 100644
--- a/src/EFCore/Diagnostics/IDbContextLogger.cs
+++ b/src/EFCore/Diagnostics/IDbContextLogger.cs
@@ -36,7 +36,7 @@ public interface IDbContextLogger
     void Log(EventData eventData);
 
     /// <summary>
-    ///     Determines whether or not the given event should be logged.
+    ///     Determines whether the given event should be logged.
     /// </summary>
     /// <param name="eventId">The ID of the event.</param>
     /// <param name="logLevel">The level of the event.</param>
diff --git a/src/EFCore/Diagnostics/IDiagnosticsLogger.cs b/src/EFCore/Diagnostics/IDiagnosticsLogger.cs
index 7f969ce3af..ad2ef165e7 100644
--- a/src/EFCore/Diagnostics/IDiagnosticsLogger.cs
+++ b/src/EFCore/Diagnostics/IDiagnosticsLogger.cs
@@ -61,7 +61,7 @@ public interface IDiagnosticsLogger
     IInterceptors? Interceptors { get; }
 
     /// <summary>
-    ///     Checks whether or not the message should be sent to the <see cref="ILogger" />.
+    ///     Checks whether the message should be sent to the <see cref="ILogger" />.
     /// </summary>
     /// <param name="definition">The definition of the event to log.</param>
     /// <returns>
@@ -104,7 +104,7 @@ bool ShouldLog(EventDefinitionBase definition)
     }
 
     /// <summary>
-    ///     Determines whether or not an <see cref="EventData" /> instance is needed based on whether or
+    ///     Determines whether an <see cref="EventData" /> instance is needed based on whether or
     ///     not there is a <see cref="DiagnosticSource" /> or an <see cref="IDbContextLogger" /> enabled for
     ///     the given event.
     /// </summary>
@@ -136,7 +136,7 @@ bool ShouldLog(EventDefinitionBase definition)
     }
 
     /// <summary>
-    ///     Determines whether or not an <see cref="EventData" /> instance is needed based on whether or
+    ///     Determines whether an <see cref="EventData" /> instance is needed based on whether or
     ///     not there is a <see cref="DiagnosticSource" />, an <see cref="IDbContextLogger" />, or an <see cref="IInterceptor" /> enabled for
     ///     the given event.
     /// </summary>
diff --git a/src/EFCore/Diagnostics/ILoggingOptions.cs b/src/EFCore/Diagnostics/ILoggingOptions.cs
index 82b5881a2f..8eae16e380 100644
--- a/src/EFCore/Diagnostics/ILoggingOptions.cs
+++ b/src/EFCore/Diagnostics/ILoggingOptions.cs
@@ -44,6 +44,6 @@ public interface ILoggingOptions : ISingletonOptions
     ///     Returns <see langword="true" /> if a warning about string values for the given enum type has not yet been performed.
     /// </summary>
     /// <param name="enumType">The type to check.</param>
-    /// <returns>Whether or not a warning has been issued.</returns>
+    /// <returns>Whether a warning has been issued.</returns>
     bool ShouldWarnForStringEnumValueInJson(Type enumType);
 }
diff --git a/src/EFCore/Metadata/Internal/EntityType.cs b/src/EFCore/Metadata/Internal/EntityType.cs
index 70150fd083..02bfeb623d 100644
--- a/src/EFCore/Metadata/Internal/EntityType.cs
+++ b/src/EFCore/Metadata/Internal/EntityType.cs
@@ -2742,7 +2742,7 @@ public virtual IEnumerable<Trigger> GetDeclaredTriggers()
                                 {
                                     value = propertyInfo.GetValue(rawSeed, [propertyBase.Name]);
                                 }
-                                catch (Exception)
+                                catch
                                 {
                                     // Swallow if the property value is not set on the seed data
                                 }
diff --git a/src/EFCore/Metadata/Internal/InternalPropertyBuilder.cs b/src/EFCore/Metadata/Internal/InternalPropertyBuilder.cs
index 96fa8aae66..6f68c0d2d2 100644
--- a/src/EFCore/Metadata/Internal/InternalPropertyBuilder.cs
+++ b/src/EFCore/Metadata/Internal/InternalPropertyBuilder.cs
@@ -192,7 +192,7 @@ public virtual bool CanSetSentinel(object? sentinel, ConfigurationSource? config
             {
                 return Equals(Metadata.Sentinel, Convert.ChangeType(sentinel, Metadata.ClrType, CultureInfo.InvariantCulture));
             }
-            catch (Exception)
+            catch
             {
                 throw new InvalidOperationException(
                     CoreStrings.IncompatibleSentinelValue(
diff --git a/src/EFCore/Metadata/Internal/Property.cs b/src/EFCore/Metadata/Internal/Property.cs
index 55c742dd69..8908d63223 100644
--- a/src/EFCore/Metadata/Internal/Property.cs
+++ b/src/EFCore/Metadata/Internal/Property.cs
@@ -594,7 +594,7 @@ public virtual PropertySaveBehavior GetAfterSaveBehavior()
                 {
                     _sentinel = Convert.ChangeType(sentinel, ClrType, CultureInfo.InvariantCulture);
                 }
-                catch (Exception)
+                catch
                 {
                     throw new InvalidOperationException(
                         CoreStrings.IncompatibleSentinelValue(
diff --git a/src/EFCore/Storage/ExecutionStrategy.cs b/src/EFCore/Storage/ExecutionStrategy.cs
index 2d332ba7a8..3f6129b72d 100644
--- a/src/EFCore/Storage/ExecutionStrategy.cs
+++ b/src/EFCore/Storage/ExecutionStrategy.cs
@@ -255,8 +255,7 @@ public virtual bool RetriesOnFailure
 
                 OnRetry();
 
-                using var waitEvent = new ManualResetEventSlim(false);
-                waitEvent.WaitHandle.WaitOne(delay.Value);
+                Thread.Sleep(delay.Value);
             }
         }
     }
diff --git a/src/Microsoft.Data.Sqlite.Core/SqliteConnection.cs b/src/Microsoft.Data.Sqlite.Core/SqliteConnection.cs
index a59d762fce..a4a3193b30 100644
--- a/src/Microsoft.Data.Sqlite.Core/SqliteConnection.cs
+++ b/src/Microsoft.Data.Sqlite.Core/SqliteConnection.cs
@@ -66,7 +66,7 @@ static SqliteConnection()
                     storageFolderType = Type.GetType("Windows.Storage.StorageFolder, Windows, ContentType=WindowsRuntime")
                         ?? Type.GetType("Windows.Storage.StorageFolder, Microsoft.Windows.SDK.NET");
                 }
-                catch (Exception)
+                catch
                 {
                     // Ignore "Could not load assembly." or any type initialization error.
                 }
@@ -347,14 +347,8 @@ public override void Close()
                     // NB: Calls RemoveCommand()
                     command.Dispose();
                 }
-                else
-                {
-                    _commands.Remove(reference);
-                }
             }
 
-            Debug.Assert(_commands.Count == 0);
-
             _commands.Clear();
             _innerConnection!.Close();
             _innerConnection = null;
@@ -450,7 +444,9 @@ internal void RemoveCommand(SqliteCommand command)
         {
             for (var i = _commands.Count - 1; i >= 0; i--)
             {
-                if (_commands[i].TryGetTarget(out var item)
+                var reference = _commands[i];
+                if (reference != null
+                    && reference.TryGetTarget(out var item)
                     && item == command)
                 {
                     _commands.RemoveAt(i);
diff --git a/test/EFCore.Cosmos.FunctionalTests/F1CosmosFixture.cs b/test/EFCore.Cosmos.FunctionalTests/F1CosmosFixture.cs
index 9cf273f93b..bbd545b869 100644
--- a/test/EFCore.Cosmos.FunctionalTests/F1CosmosFixture.cs
+++ b/test/EFCore.Cosmos.FunctionalTests/F1CosmosFixture.cs
@@ -25,7 +25,7 @@ public override async Task ReseedAsync()
         {
             await context.Teams.SingleAsync(t => t.Id == Team.Ferrari);
         }
-        catch (Exception)
+        catch
         {
             // Recreating the containers without using CosmosClient causes cached metadata in CosmosClient to be out of sync
             // and causes the first query to fail. This is a workaround for that.
diff --git a/test/EFCore.Cosmos.FunctionalTests/TestUtilities/CosmosTestStore.cs b/test/EFCore.Cosmos.FunctionalTests/TestUtilities/CosmosTestStore.cs
index d49b0ed01f..458db5010a 100644
--- a/test/EFCore.Cosmos.FunctionalTests/TestUtilities/CosmosTestStore.cs
+++ b/test/EFCore.Cosmos.FunctionalTests/TestUtilities/CosmosTestStore.cs
@@ -304,13 +304,13 @@ public override async Task CleanAsync(DbContext context)
                 await SeedAsync(context).ConfigureAwait(false);
             }
         }
-        catch (Exception)
+        catch
         {
             try
             {
                 await EnsureDeletedAsync(context).ConfigureAwait(false);
             }
-            catch (Exception)
+            catch
             {
             }
 
diff --git a/test/EFCore.Design.Tests/Design/DesignTimeServicesTest.cs b/test/EFCore.Design.Tests/Design/DesignTimeServicesTest.cs
index f11e4073d6..94a072271c 100644
--- a/test/EFCore.Design.Tests/Design/DesignTimeServicesTest.cs
+++ b/test/EFCore.Design.Tests/Design/DesignTimeServicesTest.cs
@@ -192,6 +192,8 @@ public bool IsValidId(string value)
 
     public class ExtensionHistoryRepository : IHistoryRepository
     {
+        public void Create() => throw new NotImplementedException();
+        public Task CreateAsync(CancellationToken cancellationToken = default) => throw new NotImplementedException();
         public bool Exists()
             => throw new NotImplementedException();
 
@@ -216,6 +218,12 @@ public string GetCreateIfNotExistsScript()
         public string GetCreateScript()
             => throw new NotImplementedException();
 
+        public IDisposable GetDatabaseLock(TimeSpan timeout)
+            => throw new NotImplementedException();
+
+        public Task<IAsyncDisposable> GetDatabaseLockAsync(TimeSpan timeout, CancellationToken cancellationToken = default)
+            => throw new NotImplementedException();
+
         public string GetDeleteScript(string migrationId)
             => throw new NotImplementedException();
 
@@ -276,6 +284,18 @@ public string GetCreateIfNotExistsScript()
         public string GetCreateScript()
             => throw new NotImplementedException();
 
+        public void Create()
+            => throw new NotImplementedException();
+
+        public Task CreateAsync(CancellationToken cancellationToken = default)
+            => throw new NotImplementedException();
+
+        public IDisposable GetDatabaseLock(TimeSpan timeout)
+            => throw new NotImplementedException();
+
+        public Task<IAsyncDisposable> GetDatabaseLockAsync(TimeSpan timeout, CancellationToken cancellationToken = default)
+            => throw new NotImplementedException();
+
         public string GetDeleteScript(string migrationId)
             => throw new NotImplementedException();
 
diff --git a/test/EFCore.Design.Tests/Migrations/Design/MigrationScaffolderTest.cs b/test/EFCore.Design.Tests/Migrations/Design/MigrationScaffolderTest.cs
index 72f21d5c9a..99ae637bde 100644
--- a/test/EFCore.Design.Tests/Migrations/Design/MigrationScaffolderTest.cs
+++ b/test/EFCore.Design.Tests/Migrations/Design/MigrationScaffolderTest.cs
@@ -173,6 +173,18 @@ public string GetDeleteScript(string migrationId)
 
         public string GetInsertScript(HistoryRow row)
             => null;
+
+        public void Create()
+            => throw new NotImplementedException();
+
+        public Task CreateAsync(CancellationToken cancellationToken = default)
+            => throw new NotImplementedException();
+
+        public IDisposable GetDatabaseLock(TimeSpan timeout)
+            => throw new NotImplementedException();
+
+        public Task<IAsyncDisposable> GetDatabaseLockAsync(TimeSpan timeout, CancellationToken cancellationToken = default)
+            => throw new NotImplementedException();
     }
 
     private class MockProvider : IDatabaseProvider
diff --git a/test/EFCore.Relational.Specification.Tests/Migrations/MigrationsInfrastructureTestBase.cs b/test/EFCore.Relational.Specification.Tests/Migrations/MigrationsInfrastructureTestBase.cs
index c1ce90789e..a75f37bd01 100644
--- a/test/EFCore.Relational.Specification.Tests/Migrations/MigrationsInfrastructureTestBase.cs
+++ b/test/EFCore.Relational.Specification.Tests/Migrations/MigrationsInfrastructureTestBase.cs
@@ -3,6 +3,8 @@
 
 // ReSharper disable InconsistentNaming
 
+using Microsoft.EntityFrameworkCore.TestUtilities;
+
 namespace Microsoft.EntityFrameworkCore.Migrations;
 
 #nullable disable
@@ -22,6 +24,8 @@ protected MigrationsInfrastructureTestBase(TFixture fixture)
 
     protected string ActiveProvider { get; private set; }
 
+    public static IEnumerable<object[]> IsAsyncData = [[false], [true]];
+
     // Database deletion can happen as async file operation and SQLClient
     // doesn't account for this, so give some time for it to happen on slow C.I. machines
     protected virtual void GiveMeSomeTime(DbContext db)
@@ -178,6 +182,92 @@ public virtual async Task Can_apply_all_migrations_async()
             x => Assert.Equal("00000000000007_Migration7", x.MigrationId));
     }
 
+    [ConditionalFact]
+    public virtual void Can_apply_one_migration_in_parallel()
+    {
+        using var db = Fixture.CreateContext();
+        db.Database.EnsureDeleted();
+        GiveMeSomeTime(db);
+        db.GetService<IRelationalDatabaseCreator>().Create();
+
+        Parallel.For(0, Environment.ProcessorCount, i =>
+        {
+            using var context = Fixture.CreateContext();
+            var migrator = context.GetService<IMigrator>();
+            migrator.Migrate("Migration1");
+        });
+
+        var history = db.GetService<IHistoryRepository>();
+        Assert.Collection(
+            history.GetAppliedMigrations(),
+            x => Assert.Equal("00000000000001_Migration1", x.MigrationId));
+    }
+
+    [ConditionalFact]
+    public virtual async Task Can_apply_one_migration_in_parallel_async()
+    {
+        using var db = Fixture.CreateContext();
+        await db.Database.EnsureDeletedAsync();
+        await GiveMeSomeTimeAsync(db);
+        await db.GetService<IRelationalDatabaseCreator>().CreateAsync();
+
+        await Parallel.ForAsync(0, Environment.ProcessorCount, async (i, _) =>
+        {
+            using var context = Fixture.CreateContext();
+            var migrator = context.GetService<IMigrator>();
+            await migrator.MigrateAsync("Migration1");
+        });
+
+        var history = db.GetService<IHistoryRepository>();
+        Assert.Collection(
+            await history.GetAppliedMigrationsAsync(),
+            x => Assert.Equal("00000000000001_Migration1", x.MigrationId));
+    }
+
+    [ConditionalFact]
+    public virtual void Can_apply_second_migration_in_parallel()
+    {
+        using var db = Fixture.CreateContext();
+        db.Database.EnsureDeleted();
+        GiveMeSomeTime(db);
+        db.GetService<IMigrator>().Migrate("Migration1");
+
+        Parallel.For(0, Environment.ProcessorCount, i =>
+        {
+            using var context = Fixture.CreateContext();
+            var migrator = context.GetService<IMigrator>();
+            migrator.Migrate("Migration2");
+        });
+
+        var history = db.GetService<IHistoryRepository>();
+        Assert.Collection(
+            history.GetAppliedMigrations(),
+            x => Assert.Equal("00000000000001_Migration1", x.MigrationId),
+            x => Assert.Equal("00000000000002_Migration2", x.MigrationId));
+    }
+
+    [ConditionalFact]
+    public virtual async Task Can_apply_second_migration_in_parallel_async()
+    {
+        using var db = Fixture.CreateContext();
+        await db.Database.EnsureDeletedAsync();
+        await GiveMeSomeTimeAsync(db);
+        await db.GetService<IMigrator>().MigrateAsync("Migration1");
+
+        await Parallel.ForAsync(0, Environment.ProcessorCount, async (i, _) =>
+        {
+            using var context = Fixture.CreateContext();
+            var migrator = context.GetService<IMigrator>();
+            await migrator.MigrateAsync("Migration2");
+        });
+
+        var history = db.GetService<IHistoryRepository>();
+        Assert.Collection(
+            await history.GetAppliedMigrationsAsync(),
+            x => Assert.Equal("00000000000001_Migration1", x.MigrationId),
+            x => Assert.Equal("00000000000002_Migration2", x.MigrationId));
+    }
+
     [ConditionalFact]
     public virtual void Can_generate_no_migration_script()
     {
@@ -343,14 +433,20 @@ private void SetSql(string value)
         => Sql = value.Replace(ProductInfo.GetVersion(), "7.0.0-test");
 }
 
-public abstract class
-    MigrationsInfrastructureFixtureBase : SharedStoreFixtureBase<MigrationsInfrastructureFixtureBase.MigrationsContext>
+public abstract class MigrationsInfrastructureFixtureBase
+    : SharedStoreFixtureBase<MigrationsInfrastructureFixtureBase.MigrationsContext>
 {
     public static string ActiveProvider { get; set; }
 
     public new RelationalTestStore TestStore
         => (RelationalTestStore)base.TestStore;
 
+    protected override IServiceCollection AddServices(IServiceCollection serviceCollection)
+    {
+        TestStore.UseConnectionString = true;
+        return base.AddServices(serviceCollection);
+    }
+
     protected override string StoreName
         => "MigrationsTest";
 
diff --git a/test/EFCore.Relational.Specification.Tests/TestUtilities/RelationalTestStore.cs b/test/EFCore.Relational.Specification.Tests/TestUtilities/RelationalTestStore.cs
index 5440494942..84b476f631 100644
--- a/test/EFCore.Relational.Specification.Tests/TestUtilities/RelationalTestStore.cs
+++ b/test/EFCore.Relational.Specification.Tests/TestUtilities/RelationalTestStore.cs
@@ -9,6 +9,8 @@ public abstract class RelationalTestStore(string name, bool shared, DbConnection
 {
     public virtual string ConnectionString { get; } = connection.ConnectionString;
 
+    public virtual bool UseConnectionString { get; set; }
+
     public ConnectionState ConnectionState
         => Connection.State;
 
diff --git a/test/EFCore.Relational.Tests/Extensions/RelationalDatabaseFacadeExtensionsTest.cs b/test/EFCore.Relational.Tests/Extensions/RelationalDatabaseFacadeExtensionsTest.cs
index 1f6d0b97db..0357f279ab 100644
--- a/test/EFCore.Relational.Tests/Extensions/RelationalDatabaseFacadeExtensionsTest.cs
+++ b/test/EFCore.Relational.Tests/Extensions/RelationalDatabaseFacadeExtensionsTest.cs
@@ -355,6 +355,17 @@ public string GetBeginIfExistsScript(string migrationId)
 
         public string GetEndIfScript()
             => throw new NotImplementedException();
+        public void Create()
+            => throw new NotImplementedException();
+
+        public Task CreateAsync(CancellationToken cancellationToken = default)
+            => throw new NotImplementedException();
+
+        public IDisposable GetDatabaseLock(TimeSpan timeout)
+            => throw new NotImplementedException();
+
+        public Task<IAsyncDisposable> GetDatabaseLockAsync(TimeSpan timeout, CancellationToken cancellationToken = default)
+            => throw new NotImplementedException();
     }
 
     [ConditionalTheory]
diff --git a/test/EFCore.Specification.Tests/MusicStoreTestBase.cs b/test/EFCore.Specification.Tests/MusicStoreTestBase.cs
index 33bc6f460a..7844c568cc 100644
--- a/test/EFCore.Specification.Tests/MusicStoreTestBase.cs
+++ b/test/EFCore.Specification.Tests/MusicStoreTestBase.cs
@@ -644,7 +644,7 @@ public async Task<object> AddressAndPayment(MusicStoreContext context, string ca
 
                 return order.OrderId;
             }
-            catch (Exception)
+            catch
             {
                 return null;
             }
diff --git a/test/EFCore.Specification.Tests/TestUtilities/TestStore.cs b/test/EFCore.Specification.Tests/TestUtilities/TestStore.cs
index c8888f2fa6..6884b6ac5d 100644
--- a/test/EFCore.Specification.Tests/TestUtilities/TestStore.cs
+++ b/test/EFCore.Specification.Tests/TestUtilities/TestStore.cs
@@ -20,10 +20,7 @@ public abstract class TestStore(string name, bool shared) : IDisposable
         Func<DbContext, Task>? clean = null)
     {
         ServiceProvider = serviceProvider;
-        if (createContext == null)
-        {
-            createContext = CreateDefaultContext;
-        }
+        createContext ??= CreateDefaultContext;
 
         if (Shared)
         {
@@ -56,8 +53,8 @@ public abstract class TestStore(string name, bool shared) : IDisposable
             serviceProvider,
             () => createContext(this),
             // ReSharper disable twice RedundantCast
-            seed == null ? (Func<DbContext, Task>?)null : c => seed((TContext)c),
-            clean == null ? (Func<DbContext, Task>?)null : c => clean((TContext)c));
+            seed == null ? null : c => seed((TContext)c),
+            clean == null ? null : c => clean((TContext)c));
 
     protected virtual async Task InitializeAsync(Func<DbContext> createContext, Func<DbContext, Task>? seed, Func<DbContext, Task>? clean)
     {
diff --git a/test/EFCore.SqlServer.FunctionalTests/TestUtilities/SqlServerTestStore.cs b/test/EFCore.SqlServer.FunctionalTests/TestUtilities/SqlServerTestStore.cs
index 1e481d2622..6ad3e77667 100644
--- a/test/EFCore.SqlServer.FunctionalTests/TestUtilities/SqlServerTestStore.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/TestUtilities/SqlServerTestStore.cs
@@ -111,8 +111,9 @@ protected override async Task InitializeAsync(Func<DbContext> createContext, Fun
     }
 
     public override DbContextOptionsBuilder AddProviderOptions(DbContextOptionsBuilder builder)
-        => builder
-            .UseSqlServer(Connection, b => b.ApplyConfiguration())
+        => (UseConnectionString
+            ? builder.UseSqlServer(ConnectionString, b => b.ApplyConfiguration())
+            : builder.UseSqlServer(Connection, b => b.ApplyConfiguration()))
             .ConfigureWarnings(b => b.Ignore(SqlServerEventId.SavepointsDisabledBecauseOfMARS));
 
     private async Task<bool> CreateDatabase(Func<DbContext, Task>? clean)
diff --git a/test/EFCore.Sqlite.FunctionalTests/TestUtilities/SqliteTestStore.cs b/test/EFCore.Sqlite.FunctionalTests/TestUtilities/SqliteTestStore.cs
index 080d01758c..823452e857 100644
--- a/test/EFCore.Sqlite.FunctionalTests/TestUtilities/SqliteTestStore.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/TestUtilities/SqliteTestStore.cs
@@ -33,13 +33,21 @@ private SqliteTestStore(string name, bool seed = true, bool sharedCache = false,
     public virtual DbContextOptionsBuilder AddProviderOptions(
         DbContextOptionsBuilder builder,
         Action<SqliteDbContextOptionsBuilder>? configureSqlite)
-        => builder.UseSqlite(
-            Connection, b =>
-            {
-                b.CommandTimeout(CommandTimeout);
-                b.UseQuerySplittingBehavior(QuerySplittingBehavior.SingleQuery);
-                configureSqlite?.Invoke(b);
-            });
+        => UseConnectionString
+            ? builder.UseSqlite(
+                ConnectionString, b =>
+                {
+                    b.CommandTimeout(CommandTimeout);
+                    b.UseQuerySplittingBehavior(QuerySplittingBehavior.SingleQuery);
+                    configureSqlite?.Invoke(b);
+                })
+            : builder.UseSqlite(
+                Connection, b =>
+                {
+                    b.CommandTimeout(CommandTimeout);
+                    b.UseQuerySplittingBehavior(QuerySplittingBehavior.SingleQuery);
+                    configureSqlite?.Invoke(b);
+                });
 
     public override DbContextOptionsBuilder AddProviderOptions(DbContextOptionsBuilder builder)
         => AddProviderOptions(builder, configureSqlite: null);
diff --git a/test/EFCore.Tests/Infrastructure/EventIdTestBase.cs b/test/EFCore.Tests/Infrastructure/EventIdTestBase.cs
index 26e6383f73..89cd17466a 100644
--- a/test/EFCore.Tests/Infrastructure/EventIdTestBase.cs
+++ b/test/EFCore.Tests/Infrastructure/EventIdTestBase.cs
@@ -118,7 +118,7 @@ public abstract class EventIdTestBase
                         {
                             args[i] = Activator.CreateInstance(type);
                         }
-                        catch (Exception)
+                        catch
                         {
                             Assert.Fail(
                                 "Need to add fake test factory for type "
diff --git a/test/Microsoft.Data.Sqlite.Tests/SqliteTransactionTest.cs b/test/Microsoft.Data.Sqlite.Tests/SqliteTransactionTest.cs
index 7289a44b93..cdf7dbedbb 100644
--- a/test/Microsoft.Data.Sqlite.Tests/SqliteTransactionTest.cs
+++ b/test/Microsoft.Data.Sqlite.Tests/SqliteTransactionTest.cs
@@ -56,7 +56,7 @@ public class SqliteTransactionTest
 
             Assert.Fail();
         }
-        catch (Exception)
+        catch
         {
             // Expected to throw.
         }
