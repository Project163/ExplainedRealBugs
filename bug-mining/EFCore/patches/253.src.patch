diff --git a/src/EFCore.Relational/Query/Internal/QueryableJsonProjectionInfo.cs b/src/EFCore.Relational/Query/Internal/QueryableJsonProjectionInfo.cs
new file mode 100644
index 0000000000..12b168b43c
--- /dev/null
+++ b/src/EFCore.Relational/Query/Internal/QueryableJsonProjectionInfo.cs
@@ -0,0 +1,51 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.EntityFrameworkCore.Query.Internal;
+
+/// <summary>
+///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+///     any release. You should only use it directly in your code with extreme caution and knowing that
+///     doing so can result in application failures when updating to a new Entity Framework Core release.
+/// </summary>
+public readonly struct QueryableJsonProjectionInfo
+{
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public QueryableJsonProjectionInfo(
+        Dictionary<IProperty, int> propertyIndexMap,
+        List<(JsonProjectionInfo, INavigation)> childrenProjectionInfo)
+    {
+        PropertyIndexMap = propertyIndexMap;
+        ChildrenProjectionInfo = childrenProjectionInfo;
+    }
+
+    /// <summary>
+    ///     Map between entity properties and corresponding column indexes.
+    /// </summary>
+    /// <remarks>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </remarks>
+    public IDictionary<IProperty, int> PropertyIndexMap { get; }
+
+    /// <summary>
+    ///     Information needed to construct each child JSON entity.
+    ///     - JsonProjection info (same one we use for simple JSON projection),
+    ///     - navigation between parent and the child JSON entity.
+    /// </summary>
+    /// <remarks>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </remarks>
+    public IList<(JsonProjectionInfo JsonProjectionInfo, INavigation Navigation)> ChildrenProjectionInfo { get; }
+}
diff --git a/src/EFCore.Relational/Query/RelationalShapedQueryCompilingExpressionVisitor.ShaperProcessingExpressionVisitor.cs b/src/EFCore.Relational/Query/RelationalShapedQueryCompilingExpressionVisitor.ShaperProcessingExpressionVisitor.cs
index 8d250d96c1..29b4c1cab2 100644
--- a/src/EFCore.Relational/Query/RelationalShapedQueryCompilingExpressionVisitor.ShaperProcessingExpressionVisitor.cs
+++ b/src/EFCore.Relational/Query/RelationalShapedQueryCompilingExpressionVisitor.ShaperProcessingExpressionVisitor.cs
@@ -433,7 +433,11 @@ protected override Expression VisitBinary(BinaryExpression binaryExpression)
 
                     if (newExpression.Arguments[0] is ProjectionBindingExpression projectionBindingExpression)
                     {
-                        var propertyMap = (IDictionary<IProperty, int>)GetProjectionIndex(projectionBindingExpression);
+                        var projectionIndex = GetProjectionIndex(projectionBindingExpression);
+                        var propertyMap = projectionIndex is IDictionary<IProperty, int>
+                            ? (IDictionary<IProperty, int>)projectionIndex
+                            : ((QueryableJsonProjectionInfo)projectionIndex).PropertyIndexMap;
+
                         _materializationContextBindings[parameterExpression] = propertyMap;
                         _entityTypeIdentifyingExpressionInfo[parameterExpression] =
                             // If single entity type is being selected in hierarchy then we use the value directly else we store the offset
@@ -535,6 +539,50 @@ protected override Expression VisitExtension(Expression extensionExpression)
                                 visitedShaperResultParameter,
                                 shaper.Type);
                         }
+                        else if (GetProjectionIndex(projectionBindingExpression) is QueryableJsonProjectionInfo queryableJsonEntityProjectionInfo)
+                        {
+                            if (_isTracking)
+                            {
+                                throw new InvalidOperationException(
+                                    RelationalStrings.JsonEntityOrCollectionProjectedAtRootLevelInTrackingQuery(nameof(EntityFrameworkQueryableExtensions.AsNoTracking)));
+                            }
+
+                            // json entity converted to query root and projected
+                            var entityParameter = Parameter(shaper.Type);
+                            _variables.Add(entityParameter);
+                            var entityMaterializationExpression = (BlockExpression)_parentVisitor.InjectEntityMaterializers(shaper);
+
+                            var mappedProperties = queryableJsonEntityProjectionInfo.PropertyIndexMap.Keys.ToList();
+                            var rewrittenEntityMaterializationExpression = new QueryableJsonEntityMaterializerRewriter(mappedProperties)
+                                .Rewrite(entityMaterializationExpression);
+
+                            var visitedEntityMaterializationExpression = Visit(rewrittenEntityMaterializationExpression);
+                            _expressions.Add(Assign(entityParameter, visitedEntityMaterializationExpression));
+
+                            foreach (var childProjectionInfo in queryableJsonEntityProjectionInfo.ChildrenProjectionInfo)
+                            {
+                                var (jsonReaderDataVariable, keyValuesParameter) = JsonShapingPreProcess(
+                                    childProjectionInfo.JsonProjectionInfo,
+                                    childProjectionInfo.Navigation.TargetEntityType,
+                                    childProjectionInfo.Navigation.IsCollection);
+
+                                var shaperResult = CreateJsonShapers(
+                                    childProjectionInfo.Navigation.TargetEntityType,
+                                    nullable: true,
+                                    jsonReaderDataVariable,
+                                    keyValuesParameter,
+                                    parentEntityExpression: entityParameter,
+                                    navigation: childProjectionInfo.Navigation);
+
+                                var visitedShaperResult = Visit(shaperResult);
+
+                                _includeExpressions.Add(visitedShaperResult);
+                            }
+
+                            accessor = CompensateForCollectionMaterialization(
+                                entityParameter,
+                                shaper.Type);
+                        }
                         else
                         {
                             var entityParameter = Parameter(shaper.Type);
@@ -2141,6 +2189,62 @@ ParameterExpression ExtractAndCacheNonConstantJsonArrayElementAccessValue(int in
             }
         }
 
+        private sealed class QueryableJsonEntityMaterializerRewriter : ExpressionVisitor
+        {
+            private readonly List<IProperty> _mappedProperties;
+
+            public QueryableJsonEntityMaterializerRewriter(List<IProperty> mappedProperties)
+            {
+                _mappedProperties = mappedProperties;
+            }
+
+            public BlockExpression Rewrite(BlockExpression jsonEntityShaperMaterializer)
+                => (BlockExpression)VisitBlock(jsonEntityShaperMaterializer);
+
+            protected override Expression VisitBinary(BinaryExpression binaryExpression)
+            {
+                // here we try to pattern match part of the shaper code that checks if key values are null
+                // if they are all non-null then we generate the entity
+                // problem for JSON entities is that some of the keys are synthesized and should be omitted
+                // if the key is one of the mapped ones, we leave the expression as is, otherwise replace with Constant(true)
+                // i.e. removing it
+                if (binaryExpression is
+                    {
+                        NodeType: ExpressionType.NotEqual,
+                        Left: MethodCallExpression
+                        {
+                            Method: { IsGenericMethod: true } method,
+                            Arguments: [_, _, ConstantExpression { Value: IProperty property }]
+                        },
+                        Right: ConstantExpression { Value: null }
+                    }
+                    && method.GetGenericMethodDefinition() == Infrastructure.ExpressionExtensions.ValueBufferTryReadValueMethod)
+                {
+                    return _mappedProperties.Contains(property)
+                        ? binaryExpression
+                        : Constant(true);
+                }
+
+                return base.VisitBinary(binaryExpression);
+            }
+
+            protected override Expression VisitMethodCall(MethodCallExpression methodCallExpression)
+            {
+                if (methodCallExpression is
+                    {
+                        Method: { IsGenericMethod: true } method,
+                        Arguments: [_, _, ConstantExpression { Value: IProperty property }]
+                    }
+                    && method.GetGenericMethodDefinition() == Infrastructure.ExpressionExtensions.ValueBufferTryReadValueMethod
+                    && !_mappedProperties.Contains(property))
+                {
+                    return Default(methodCallExpression.Type);
+                }
+
+                return base.VisitMethodCall(methodCallExpression);
+            }
+        }
+
         private static LambdaExpression GenerateFixup(
             Type entityType,
             Type relatedEntityType,
diff --git a/src/EFCore.Relational/Query/SqlExpressions/SelectExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/SelectExpression.cs
index 856a485ec2..9ff0b64c9e 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/SelectExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/SelectExpression.cs
@@ -807,7 +807,9 @@ public void ApplyDistinct()
                         // For JSON entities, the identifier is the key that was generated when we convert from json to query root
                         // (OPENJSON, json_each, etc), but we can't use it for distinct, as it would warp the results.
                         // Instead, we will treat every non-key property as identifier.
-                        foreach (var property in entityType.GetDeclaredProperties().Where(p => !p.IsPrimaryKey()))
+
+                        // TODO: hack/workaround, see #31398
+                        foreach (var property in entityType.GetDeclaredProperties().Where(p => !p.IsPrimaryKey() && p.GetRelationalTypeMapping().ElementTypeMapping == null))
                         {
                             typeProjectionIdentifiers.Add(entityProjection.BindProperty(property));
                             typeProjectionValueComparers.Add(property.GetKeyValueComparer());
@@ -823,7 +825,9 @@ public void ApplyDistinct()
                         // We know that there are existing identifiers (see condition above); we know we must have a key since a keyless
                         // entity type would have wiped the identifiers when generating the join.
                         Check.DebugAssert(primaryKey != null, "primary key is null.");
-                        foreach (var property in primaryKey.Properties)
+
+                        // TODO: hack/workaround, see #31398
+                        foreach (var property in primaryKey.Properties.Where(x => x.GetRelationalTypeMapping().ElementTypeMapping == null))
                         {
                             typeProjectionIdentifiers.Add(entityProjection.BindProperty(property));
                             typeProjectionValueComparers.Add(property.GetKeyValueComparer());
@@ -1297,15 +1301,7 @@ static void UpdateLimit(SelectExpression selectExpression)
 
                     case JsonQueryExpression jsonQueryExpression:
                     {
-                        var jsonProjectionResult = AddJsonProjection(
-                            jsonQueryExpression,
-                            jsonScalarToAdd: new JsonScalarExpression(
-                                jsonQueryExpression.JsonColumn,
-                                jsonQueryExpression.Path,
-                                jsonQueryExpression.JsonColumn.Type,
-                                jsonQueryExpression.JsonColumn.TypeMapping!,
-                                jsonQueryExpression.IsNullable));
-
+                        var jsonProjectionResult = AddJsonProjection(jsonQueryExpression);
                         newClientProjections.Add(jsonProjectionResult);
                         clientProjectionIndexMap.Add(newClientProjections.Count - 1);
 
@@ -1765,6 +1761,33 @@ Expression CopyProjectionToOuter(SelectExpression innerSelectExpression, Express
                                 projectionIndexMap[jsonProjectionInfo.JsonColumnIndex],
                                 newKeyAccessInfo));
                     }
+                    else if (constantValue is QueryableJsonProjectionInfo queryableJsonProjectionInfo)
+                    {
+                        var newPropertyIndexMap = new Dictionary<IProperty, int>(queryableJsonProjectionInfo.PropertyIndexMap.Count);
+                        foreach (var (property, value) in queryableJsonProjectionInfo.PropertyIndexMap)
+                        {
+                            newPropertyIndexMap[property] = projectionIndexMap[value];
+                        }
+
+                        var newChildrenProjectionInfo = new List<(JsonProjectionInfo, INavigation)>();
+                        foreach (var childProjectionInfo in queryableJsonProjectionInfo.ChildrenProjectionInfo)
+                        {
+                            var newKeyAccessInfo = new List<(IProperty?, int?, int?)>();
+                            foreach (var (keyProperty, constantKeyValue, keyProjectionIndex) in childProjectionInfo.JsonProjectionInfo.KeyAccessInfo)
+                            {
+                                newKeyAccessInfo.Add((keyProperty, constantKeyValue, keyProjectionIndex != null ? projectionIndexMap[keyProjectionIndex.Value] : null));
+                            }
+
+                            newChildrenProjectionInfo.Add(
+                                (new JsonProjectionInfo(
+                                    projectionIndexMap[childProjectionInfo.JsonProjectionInfo.JsonColumnIndex],
+                                    newKeyAccessInfo),
+                                childProjectionInfo.Navigation));
+                        }
+
+                        remappedConstant = Constant(
+                            new QueryableJsonProjectionInfo(newPropertyIndexMap, newChildrenProjectionInfo));
+                    }
                     else
                     {
                         remappedConstant = Constant(projectionIndexMap[(int)constantValue]);
@@ -1792,14 +1815,7 @@ Expression CopyProjectionToOuter(SelectExpression innerSelectExpression, Express
                 result[projectionMember] = expression switch
                 {
                     StructuralTypeProjectionExpression projection => AddStructuralTypeProjection(projection),
-                    JsonQueryExpression jsonQueryExpression => AddJsonProjection(
-                        jsonQueryExpression,
-                        new JsonScalarExpression(
-                            jsonQueryExpression.JsonColumn,
-                            jsonQueryExpression.Path,
-                            jsonQueryExpression.JsonColumn.Type,
-                            jsonQueryExpression.JsonColumn.TypeMapping!,
-                            jsonQueryExpression.IsNullable)),
+                    JsonQueryExpression jsonQueryExpression => AddJsonProjection(jsonQueryExpression),
                     _ => Constant(AddToProjection((SqlExpression)expression, projectionMember.Last?.Name))
                 };
             }
@@ -1817,41 +1833,90 @@ ConstantExpression AddStructuralTypeProjection(StructuralTypeProjectionExpressio
                 throw new InvalidOperationException(RelationalStrings.CannotProjectNullableComplexType(complexType.DisplayName()));
             }
 
-            var projections = new Dictionary<IProperty, int>();
+            // JSON entity that had some query operations applied on it - it has been converted to a query root via OPENJSON/json_each
+            // so it requires different materialization path than regular entity
+            // e.g. we need to also add all the child navigations, JSON entity builds all the includes as part of it's own materializer
+            // rather than relying on IncludeExpressions in the shaper query
+            // also, we don't want to add projection map for synthesized keys, whereas regular entity needs to project every single property it has
+            if (projection is { StructuralType: IEntityType entityType }
+                && entityType.IsMappedToJson())
+            {
+                var propertyIndexMap = new Dictionary<IProperty, int>();
+                var ownerEntity = entityType;
 
-            ProcessType(projection);
+                do
+                {
+                    var ownership = ownerEntity.FindOwnership();
+                    if (ownership != null)
+                    {
+                        ownerEntity = ownership.PrincipalEntityType;
+                    }
+                } 
+                while (ownerEntity.IsMappedToJson());
+
+                var keyPropertyCount = ownerEntity.FindPrimaryKey()!.Properties.Count;
+                foreach (var property in entityType.FindPrimaryKey()!.Properties.Take(keyPropertyCount)
+                    .Concat(entityType.GetDeclaredProperties().Where(p => p.GetJsonPropertyName() is not null)))
+                {
+                    propertyIndexMap[property] = AddToProjection(projection.BindProperty(property), null);
+                }
+
+                var childrenProjectionInfo = new List<(JsonProjectionInfo, INavigation)>();
+                foreach (var ownedNavigation in entityType.GetNavigations().Where(
+                    n => n.TargetEntityType.IsMappedToJson() && n.ForeignKey.IsOwnership && n == n.ForeignKey.PrincipalToDependent))
+                {
+                    var jsonQueryExpression = (JsonQueryExpression)projection.BindNavigation(ownedNavigation)!.ValueBufferExpression;
+                    var jsonProjectionInfo = (JsonProjectionInfo)AddJsonProjection(jsonQueryExpression).Value!;
+                    childrenProjectionInfo.Add((jsonProjectionInfo, ownedNavigation));
+                }
 
-            void ProcessType(StructuralTypeProjectionExpression typeProjection)
+                return Constant(new QueryableJsonProjectionInfo(propertyIndexMap, childrenProjectionInfo));
+            }
+            else
             {
-                foreach (var property in GetAllPropertiesInHierarchy(typeProjection.StructuralType))
+                var projections = new Dictionary<IProperty, int>();
+
+                ProcessType(projection);
+
+                void ProcessType(StructuralTypeProjectionExpression typeProjection)
                 {
-                    if (typeProjection is { StructuralType: IEntityType entityType }
-                        && entityType.IsMappedToJson()
-                        && property.IsOrdinalKeyProperty())
+                    foreach (var property in GetAllPropertiesInHierarchy(typeProjection.StructuralType))
                     {
-                        continue;
+                        if (typeProjection is { StructuralType: IEntityType entityType }
+                            && entityType.IsMappedToJson()
+                            && property.IsOrdinalKeyProperty())
+                        {
+                            continue;
+                        }
+
+                        projections[property] = AddToProjection(typeProjection.BindProperty(property), alias: null);
                     }
 
-                    projections[property] = AddToProjection(typeProjection.BindProperty(property), alias: null);
+                    foreach (var complexProperty in GetAllComplexPropertiesInHierarchy(typeProjection.StructuralType))
+                    {
+                        ProcessType((StructuralTypeProjectionExpression)typeProjection.BindComplexProperty(complexProperty).ValueBufferExpression);
+                    }
                 }
 
-                foreach (var complexProperty in GetAllComplexPropertiesInHierarchy(typeProjection.StructuralType))
+                if (projection.DiscriminatorExpression is not null)
                 {
-                    ProcessType((StructuralTypeProjectionExpression)typeProjection.BindComplexProperty(complexProperty).ValueBufferExpression);
+                    AddToProjection(projection.DiscriminatorExpression, DiscriminatorColumnAlias);
                 }
-            }
 
-            if (projection.DiscriminatorExpression is not null)
-            {
-                AddToProjection(projection.DiscriminatorExpression, DiscriminatorColumnAlias);
+                return Constant(projections);
             }
-
-            return Constant(projections);
         }
 
-        ConstantExpression AddJsonProjection(JsonQueryExpression jsonQueryExpression, JsonScalarExpression jsonScalarToAdd)
+        ConstantExpression AddJsonProjection(JsonQueryExpression jsonQueryExpression)
         {
-            var sqlExpression = AssignUniqueAliases(jsonScalarToAdd);
+            var jsonScalarExpression = new JsonScalarExpression(
+                jsonQueryExpression.JsonColumn,
+                jsonQueryExpression.Path,
+                jsonQueryExpression.JsonColumn.Type,
+                jsonQueryExpression.JsonColumn.TypeMapping!,
+                jsonQueryExpression.IsNullable);
+
+            var sqlExpression = AssignUniqueAliases(jsonScalarExpression);
             _projection.Add(new ProjectionExpression(sqlExpression, ""));
             var jsonColumnIndex = _projection.Count - 1;
             var keyAccessInfo = new List<(IProperty?, int?, int?)>();
@@ -1862,7 +1927,7 @@ ConstantExpression AddJsonProjection(JsonQueryExpression jsonQueryExpression, Js
                 keyAccessInfo.Add((keyProperty, null, AddToProjection(keyColumn)));
             }
 
-            foreach (var elementAccessSegment in jsonScalarToAdd.Path.Where(x => x.ArrayIndex != null))
+            foreach (var elementAccessSegment in jsonScalarExpression.Path.Where(x => x.ArrayIndex != null))
             {
                 if (elementAccessSegment.ArrayIndex is SqlConstantExpression { Value: int intValue })
                 {
diff --git a/src/EFCore.SqlServer/Query/Internal/SqlServerJsonPostprocessor.cs b/src/EFCore.SqlServer/Query/Internal/SqlServerJsonPostprocessor.cs
index 4ec630254f..b7fdcb9111 100644
--- a/src/EFCore.SqlServer/Query/Internal/SqlServerJsonPostprocessor.cs
+++ b/src/EFCore.SqlServer/Query/Internal/SqlServerJsonPostprocessor.cs
@@ -236,8 +236,10 @@ static bool IsKeyColumn(SqlExpression sqlExpression, TableExpressionBase table)
                 columnExpression.Table, "value", columnExpression.Type, _nvarcharMaxTypeMapping, columnExpression.IsNullable);
 
             Check.DebugAssert(columnInfo.Path is not null, "Path shouldn't be null in OPENJSON WITH");
-            Check.DebugAssert(!columnInfo.AsJson, "AS JSON signifies an owned sub-entity being projected out of OPENJSON/WITH. "
-                + "Columns referring to that must be wrapped be Json{Scalar,Query}Expression and will have been already dealt with above");
+            //Check.DebugAssert(
+            //    !columnInfo.AsJson || columnInfo.TypeMapping.ElementTypeMapping is not null,
+            //    "AS JSON signifies an owned sub-entity or array of primitives being projected out of OPENJSON/WITH. "
+            //    + "Columns referring to sub-entities must be wrapped in Json{Scalar,Query}Expression and will have been already dealt with above");
 
             if (columnInfo.Path is [])
             {
diff --git a/src/EFCore.SqlServer/Query/Internal/SqlServerQueryableMethodTranslatingExpressionVisitor.cs b/src/EFCore.SqlServer/Query/Internal/SqlServerQueryableMethodTranslatingExpressionVisitor.cs
index 73ec9a2759..7e91065035 100644
--- a/src/EFCore.SqlServer/Query/Internal/SqlServerQueryableMethodTranslatingExpressionVisitor.cs
+++ b/src/EFCore.SqlServer/Query/Internal/SqlServerQueryableMethodTranslatingExpressionVisitor.cs
@@ -245,7 +245,8 @@ protected override ShapedQueryExpression TransformJsonQueryToTable(JsonQueryExpr
                 {
                     Name = jsonPropertyName,
                     TypeMapping = property.GetRelationalTypeMapping(),
-                    Path = new PathSegment[] { new(jsonPropertyName) }
+                    Path = new PathSegment[] { new(jsonPropertyName) },
+                    AsJson = property.GetRelationalTypeMapping().ElementTypeMapping is not null
                 });
             }
         }
diff --git a/test/EFCore.Cosmos.FunctionalTests/MaterializationInterceptionCosmosTest.cs b/test/EFCore.Cosmos.FunctionalTests/MaterializationInterceptionCosmosTest.cs
index b98e8456ee..9ef9d4e4be 100644
--- a/test/EFCore.Cosmos.FunctionalTests/MaterializationInterceptionCosmosTest.cs
+++ b/test/EFCore.Cosmos.FunctionalTests/MaterializationInterceptionCosmosTest.cs
@@ -11,6 +11,9 @@ public MaterializationInterceptionCosmosTest(MaterializationInterceptionCosmosFi
     {
     }
 
+    public override Task Intercept_query_materialization_with_owned_types_projecting_collection(bool async)
+        => Task.CompletedTask;
+
     public class CosmosLibraryContext : LibraryContext
     {
         public CosmosLibraryContext(DbContextOptions options)
diff --git a/test/EFCore.Relational.Specification.Tests/Query/JsonQueryTestBase.cs b/test/EFCore.Relational.Specification.Tests/Query/JsonQueryTestBase.cs
index 4e53cc0c64..8ff05b5441 100644
--- a/test/EFCore.Relational.Specification.Tests/Query/JsonQueryTestBase.cs
+++ b/test/EFCore.Relational.Specification.Tests/Query/JsonQueryTestBase.cs
@@ -1171,7 +1171,7 @@ public virtual Task Json_collection_in_projection_with_composition_where_and_ano
                     .Select(xx => new { xx.Names, xx.Numbers })
                     .ToList()));
 
-    [ConditionalTheory(Skip = "issue #31365")]
+    [ConditionalTheory]
     [MemberData(nameof(IsAsyncData))]
     public virtual Task Json_collection_filter_in_projection(bool async)
         => AssertQuery(
@@ -1179,9 +1179,56 @@ public virtual Task Json_collection_filter_in_projection(bool async)
             ss => ss.Set<JsonEntityBasic>()
                 .OrderBy(x => x.Id)
                 .Select(x => x.OwnedCollectionRoot.Where(xx => xx.Name != "Foo").ToList())
-                .AsNoTracking());
+                .AsNoTracking(),
+            assertOrder: true,
+            elementAsserter: (e, a) =>
+            {
+                AssertCollection(e, a, ordered: true, elementAsserter: (ee, aa) => AssertEqual(ee, aa));
+            });
+
+    [ConditionalTheory]
+    [MemberData(nameof(IsAsyncData))]
+    public virtual Task Json_nested_collection_filter_in_projection(bool async)
+        => AssertQuery(
+            async,
+            ss => ss.Set<JsonEntityBasic>()
+                .OrderBy(x => x.Id)
+                .Select(x => x.OwnedCollectionRoot
+                    .Select(xx => xx.OwnedCollectionBranch.Where(xxx => xxx.Date != new DateTime(2000, 1, 1)).ToList()))
+                .AsNoTracking(),
+            assertOrder: true,
+            elementAsserter: (e, a) => AssertCollection(e, a, ordered: true, elementAsserter: (ee, aa) => AssertCollection(ee, aa, ordered: true)));
 
-    [ConditionalTheory(Skip = "issue #31365")]
+    [ConditionalTheory]
+    [MemberData(nameof(IsAsyncData))]
+    public virtual Task Json_nested_collection_anonymous_projection_in_projection(bool async)
+        => AssertQuery(
+            async,
+            ss => ss.Set<JsonEntityBasic>()
+                .OrderBy(x => x.Id)
+                .Select(x => x.OwnedCollectionRoot
+                    .Select(xx => xx.OwnedCollectionBranch.Select(xxx => new
+                    {
+                        xxx.Date,
+                        xxx.Enum,
+                        xxx.Enums,
+                        xxx.Fraction,
+                        xxx.OwnedReferenceLeaf,
+                        xxx.OwnedCollectionLeaf
+                    }).ToList()))
+                .AsNoTracking(),
+            assertOrder: true,
+            elementAsserter: (e, a) => AssertCollection(e, a, ordered: true, elementAsserter: (ee, aa) => AssertCollection(ee, aa, ordered: true, elementAsserter: (eee, aaa) =>
+            {
+                AssertEqual(eee.Date, aaa.Date);
+                AssertEqual(eee.Enum, aaa.Enum);
+                AssertCollection(eee.Enums, aaa.Enums, ordered: true);
+                AssertEqual(eee.Fraction, aaa.Fraction);
+                AssertEqual(eee.OwnedReferenceLeaf, aaa.OwnedReferenceLeaf);
+                AssertCollection(eee.OwnedCollectionLeaf, aaa.OwnedCollectionLeaf, ordered: true);
+            })));
+
+    [ConditionalTheory]
     [MemberData(nameof(IsAsyncData))]
     public virtual Task Json_collection_skip_take_in_projection(bool async)
         => AssertQuery(
@@ -1189,7 +1236,9 @@ public virtual Task Json_collection_skip_take_in_projection(bool async)
             ss => ss.Set<JsonEntityBasic>()
                 .OrderBy(x => x.Id)
                 .Select(x => x.OwnedCollectionRoot.OrderBy(xx => xx.Name).Skip(1).Take(5).ToList())
-                .AsNoTracking());
+                .AsNoTracking(),
+            assertOrder: true,
+            elementAsserter: (e, a) => AssertCollection(e, a, ordered: true));
 
     [ConditionalTheory]
     [MemberData(nameof(IsAsyncData))]
@@ -1240,12 +1289,9 @@ public virtual Task Json_collection_skip_take_in_projection_with_json_reference_
                     .Select(xx => xx.OwnedReferenceBranch).ToList())
                 .AsNoTracking(),
             assertOrder: true,
-            elementAsserter: (e, a) =>
-            {
-                AssertCollection(e, a, ordered: true);
-            });
+            elementAsserter: (e, a) => AssertCollection(e, a, ordered: true));
 
-    [ConditionalTheory(Skip = "issue #31365")]
+    [ConditionalTheory]
     [MemberData(nameof(IsAsyncData))]
     public virtual Task Json_collection_distinct_in_projection(bool async)
         => AssertQuery(
@@ -1253,9 +1299,23 @@ public virtual Task Json_collection_distinct_in_projection(bool async)
             ss => ss.Set<JsonEntityBasic>()
                 .OrderBy(x => x.Id)
                 .Select(x => x.OwnedCollectionRoot.Distinct())
-                .AsNoTracking());
+                .AsNoTracking(),
+            assertOrder: true,
+            elementAsserter: (e, a) => AssertCollection(e, a, elementSorter: ee => (ee.Name, ee.Number)));
+
+    [ConditionalTheory(Skip = "issue #31397")]
+    [MemberData(nameof(IsAsyncData))]
+    public virtual Task Json_collection_anonymous_projection_distinct_in_projection(bool async)
+        => AssertQuery(
+            async,
+            ss => ss.Set<JsonEntityBasic>()
+                .OrderBy(x => x.Id)
+                .Select(x => x.OwnedCollectionRoot.Select(xx => xx.Name).Distinct().ToList())
+                .AsNoTracking(),
+                assertOrder: true,
+                elementAsserter: (e, a) => AssertCollection(e, a, elementSorter: ee => ee));
 
-    [ConditionalTheory(Skip = "issue #31365")]
+    [ConditionalTheory]
     [MemberData(nameof(IsAsyncData))]
     public virtual Task Json_collection_leaf_filter_in_projection(bool async)
         => AssertQuery(
@@ -1264,25 +1324,96 @@ public virtual Task Json_collection_leaf_filter_in_projection(bool async)
                 .OrderBy(x => x.Id)
                 .Select(x => x.OwnedReferenceRoot.OwnedReferenceBranch.OwnedCollectionLeaf
                     .Where(xx => xx.SomethingSomething  != "Baz").ToList())
-                .AsNoTracking());
+                .AsNoTracking(),
+            assertOrder: true,
+            elementAsserter: (e, a) => AssertCollection(e, a, ordered: true));
+
+    [ConditionalTheory]
+    [MemberData(nameof(IsAsyncData))]
+    public virtual Task Json_multiple_collection_projections(bool async)
+        => AssertQuery(
+            async,
+            ss => ss.Set<JsonEntityBasic>()
+                .OrderBy(x => x.Id)
+                .Select(x => new
+                {
+                    First = x.OwnedReferenceRoot.OwnedReferenceBranch.OwnedCollectionLeaf
+                        .Where(xx => xx.SomethingSomething != "Baz").ToList(),
+                    Second = x.OwnedCollectionRoot.Distinct().ToList(),
+                    Third = x.OwnedCollectionRoot
+                        .Select(xx => xx.OwnedCollectionBranch.Where(xxx => xxx.Date != new DateTime(2000, 1, 1)).ToList()),
+                    Fourth = x.EntityCollection.ToList()
+                })
+                .AsNoTracking(),
+                assertOrder: true,
+                elementAsserter: (e, a) =>
+                {
+                    AssertCollection(e.First, a.First, ordered: true);
+                    AssertCollection(e.Second, a.Second, elementSorter: ee => (ee.Name, ee.Number));
+                    AssertCollection(e.Third, a.Third, ordered: true, elementAsserter: (ee, aa) => AssertCollection(ee, aa, ordered: true));
+                    AssertCollection(e.Fourth, a.Fourth);
+                });
 
-    [ConditionalTheory(Skip = "issue #31365")]
+    [ConditionalTheory]
+    [MemberData(nameof(IsAsyncData))]
+    public virtual Task Json_branch_collection_distinct_and_other_collection(bool async)
+        => AssertQuery(
+            async,
+            ss => ss.Set<JsonEntityBasic>()
+                .OrderBy(x => x.Id)
+                .Select(x => new
+                {
+                    First = x.OwnedReferenceRoot.OwnedCollectionBranch.Distinct().ToList(),
+                    Second = x.EntityCollection.ToList()
+                })
+                .AsNoTracking(),
+                assertOrder: true,
+                elementAsserter: (e, a) =>
+                {
+                    AssertCollection(e.First, a.First, ordered: true);
+                    AssertCollection(e.Second, a.Second);
+                });
+
+
+    [ConditionalTheory]
+    [MemberData(nameof(IsAsyncData))]
+    public virtual Task Json_leaf_collection_distinct_and_other_collection(bool async)
+        => AssertQuery(
+            async,
+            ss => ss.Set<JsonEntityBasic>()
+                .OrderBy(x => x.Id)
+                .Select(x => new
+                {
+                    First = x.OwnedReferenceRoot.OwnedReferenceBranch.OwnedCollectionLeaf.Distinct().ToList(),
+                    Second = x.EntityCollection.ToList()
+                })
+                .AsNoTracking(),
+                assertOrder: true,
+                elementAsserter: (e, a) =>
+                {
+                    AssertCollection(e.First, a.First, ordered: true);
+                    AssertCollection(e.Second, a.Second);
+                });
+
+    [ConditionalTheory]
     [MemberData(nameof(IsAsyncData))]
     public virtual Task Json_collection_SelectMany(bool async)
         => AssertQuery(
             async,
             ss => ss.Set<JsonEntityBasic>()
                 .SelectMany(x => x.OwnedCollectionRoot)
-                .AsNoTracking());
+                .AsNoTracking(),
+            elementSorter: e => (e.Number, e.Name));
 
-    [ConditionalTheory(Skip = "issue #31365")]
+    [ConditionalTheory]
     [MemberData(nameof(IsAsyncData))]
     public virtual Task Json_nested_collection_SelectMany(bool async)
         => AssertQuery(
             async,
             ss => ss.Set<JsonEntityBasic>()
                 .SelectMany(x => x.OwnedReferenceRoot.OwnedCollectionBranch)
-                .AsNoTracking());
+                .AsNoTracking(),
+            elementSorter: e => (e.Enum, e.Date, e.NullableEnum, e.Fraction));
 
     [ConditionalTheory(Skip = "issue #31364")]
     [MemberData(nameof(IsAsyncData))]
diff --git a/test/EFCore.Specification.Tests/MaterializationInterceptionTestBase.cs b/test/EFCore.Specification.Tests/MaterializationInterceptionTestBase.cs
index 7d0cbef687..fd8520508a 100644
--- a/test/EFCore.Specification.Tests/MaterializationInterceptionTestBase.cs
+++ b/test/EFCore.Specification.Tests/MaterializationInterceptionTestBase.cs
@@ -261,6 +261,97 @@ public virtual async Task Intercept_query_materialization_with_owned_types(bool
         }
     }
 
+    [ConditionalTheory] // Issue #31365
+    [InlineData(false)]
+    [InlineData(true)]
+    public virtual async Task Intercept_query_materialization_with_owned_types_projecting_collection(bool async)
+    {
+        var creatingInstanceCounts = new Dictionary<Type, int>();
+        var createdInstanceCounts = new Dictionary<Type, int>();
+        var initializingInstanceCounts = new Dictionary<Type, int>();
+        var initializedInstanceCounts = new Dictionary<Type, int>();
+        LibraryContext? context = null;
+
+        var interceptors = new[]
+        {
+            new ValidatingMaterializationInterceptor(
+                (data, instance, method) =>
+                {
+                    Assert.Same(context, data.Context);
+                    Assert.Equal(QueryTrackingBehavior.NoTracking, data.QueryTrackingBehavior);
+
+                    int count;
+                    var clrType = data.EntityType.ClrType;
+                    switch (method)
+                    {
+                        case nameof(IMaterializationInterceptor.CreatingInstance):
+                            count = creatingInstanceCounts.GetOrAddNew(clrType);
+                            creatingInstanceCounts[clrType] = count + 1;
+                            Assert.Null(instance);
+                            break;
+                        case nameof(IMaterializationInterceptor.CreatedInstance):
+                            count = createdInstanceCounts.GetOrAddNew(clrType);
+                            createdInstanceCounts[clrType] = count + 1;
+                            Assert.Same(clrType, instance!.GetType());
+                            break;
+                        case nameof(IMaterializationInterceptor.InitializingInstance):
+                            count = initializingInstanceCounts.GetOrAddNew(clrType);
+                            initializingInstanceCounts[clrType] = count + 1;
+                            Assert.Same(clrType, instance!.GetType());
+                            break;
+                        case nameof(IMaterializationInterceptor.InitializedInstance):
+                            count = initializedInstanceCounts.GetOrAddNew(clrType);
+                            initializedInstanceCounts[clrType] = count + 1;
+                            Assert.Same(clrType, instance!.GetType());
+                            break;
+                    }
+                })
+        };
+
+        using (context = CreateContext(interceptors, inject: true))
+        {
+            context.Add(
+                new TestEntity30244
+                {
+                    Id = _id++,
+                    Name = "TestIssue",
+                    Settings = { new("Value1", "1"), new("Value2", "9") }
+                });
+
+            _ = async
+                ? await context.SaveChangesAsync()
+                : context.SaveChanges();
+
+            context.ChangeTracker.Clear();
+
+            var query = context.Set<TestEntity30244>()
+                    .AsNoTracking()
+                    .OrderBy(e => e.Id)
+                    .Select(x => x.Settings.Where(s => s.Key != "Foo").ToList());
+
+            var collection = async
+                ? await query.FirstOrDefaultAsync()
+                : query.FirstOrDefault();
+
+            Assert.NotNull(collection);
+            Assert.Equal("Value1", collection[0].Key);
+            Assert.Equal("1", collection[0].Value);
+            Assert.Contains(("Value2", "9"), collection.Select(x => (x.Key, x.Value)));
+
+            Assert.Equal(1, creatingInstanceCounts.Count);
+            Assert.Equal(2, creatingInstanceCounts[typeof(KeyValueSetting30244)]);
+
+            Assert.Equal(1, createdInstanceCounts.Count);
+            Assert.Equal(2, createdInstanceCounts[typeof(KeyValueSetting30244)]);
+
+            Assert.Equal(1, initializingInstanceCounts.Count);
+            Assert.Equal(2, initializingInstanceCounts[typeof(KeyValueSetting30244)]);
+
+            Assert.Equal(1, initializedInstanceCounts.Count);
+            Assert.Equal(2, initializedInstanceCounts[typeof(KeyValueSetting30244)]);
+        }
+    }
+
     [ConditionalTheory]
     [InlineData(false)]
     [InlineData(true)]
diff --git a/test/EFCore.SqlServer.FunctionalTests/Query/JsonQuerySqlServerTest.cs b/test/EFCore.SqlServer.FunctionalTests/Query/JsonQuerySqlServerTest.cs
index 68164d0fe1..cbdddc497a 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Query/JsonQuerySqlServerTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Query/JsonQuerySqlServerTest.cs
@@ -1012,10 +1012,10 @@ SELECT 1
     FROM OPENJSON([j].[OwnedReferenceRoot], '$.OwnedCollectionBranch') WITH (
         [Date] datetime2 '$.Date',
         [Enum] int '$.Enum',
-        [Enums] nvarchar(max) '$.Enums',
+        [Enums] nvarchar(max) '$.Enums' AS JSON,
         [Fraction] decimal(18,2) '$.Fraction',
         [NullableEnum] int '$.NullableEnum',
-        [NullableEnums] nvarchar(max) '$.NullableEnums',
+        [NullableEnums] nvarchar(max) '$.NullableEnums' AS JSON,
         [OwnedCollectionLeaf] nvarchar(max) '$.OwnedCollectionLeaf' AS JSON,
         [OwnedReferenceLeaf] nvarchar(max) '$.OwnedReferenceLeaf' AS JSON
     ) AS [o]
@@ -1097,10 +1097,10 @@ SELECT COUNT(*)
         FROM OPENJSON([j].[OwnedReferenceRoot], '$.OwnedCollectionBranch') WITH (
             [Date] datetime2 '$.Date',
             [Enum] int '$.Enum',
-            [Enums] nvarchar(max) '$.Enums',
+            [Enums] nvarchar(max) '$.Enums' AS JSON,
             [Fraction] decimal(18,2) '$.Fraction',
             [NullableEnum] int '$.NullableEnum',
-            [NullableEnums] nvarchar(max) '$.NullableEnums',
+            [NullableEnums] nvarchar(max) '$.NullableEnums' AS JSON,
             [OwnedCollectionLeaf] nvarchar(max) '$.OwnedCollectionLeaf' AS JSON,
             [OwnedReferenceLeaf] nvarchar(max) '$.OwnedReferenceLeaf' AS JSON
         ) AS [o]
@@ -1121,9 +1121,9 @@ public override async Task Json_collection_within_collection_Count(bool async)
     SELECT 1
     FROM OPENJSON([j].[OwnedCollectionRoot], '$') WITH (
         [Name] nvarchar(max) '$.Name',
-        [Names] nvarchar(max) '$.Names',
+        [Names] nvarchar(max) '$.Names' AS JSON,
         [Number] int '$.Number',
-        [Numbers] nvarchar(max) '$.Numbers',
+        [Numbers] nvarchar(max) '$.Numbers' AS JSON,
         [OwnedCollectionBranch] nvarchar(max) '$.OwnedCollectionBranch' AS JSON,
         [OwnedReferenceBranch] nvarchar(max) '$.OwnedReferenceBranch' AS JSON
     ) AS [o]
@@ -1132,10 +1132,10 @@ SELECT COUNT(*)
         FROM OPENJSON([o].[OwnedCollectionBranch], '$') WITH (
             [Date] datetime2 '$.Date',
             [Enum] int '$.Enum',
-            [Enums] nvarchar(max) '$.Enums',
+            [Enums] nvarchar(max) '$.Enums' AS JSON,
             [Fraction] decimal(18,2) '$.Fraction',
             [NullableEnum] int '$.NullableEnum',
-            [NullableEnums] nvarchar(max) '$.NullableEnums',
+            [NullableEnums] nvarchar(max) '$.NullableEnums' AS JSON,
             [OwnedCollectionLeaf] nvarchar(max) '$.OwnedCollectionLeaf' AS JSON,
             [OwnedReferenceLeaf] nvarchar(max) '$.OwnedReferenceLeaf' AS JSON
         ) AS [o0]) = 2)
@@ -1152,9 +1152,9 @@ public override async Task Json_collection_in_projection_with_composition_count(
     SELECT COUNT(*)
     FROM OPENJSON([j].[OwnedCollectionRoot], '$') WITH (
         [Name] nvarchar(max) '$.Name',
-        [Names] nvarchar(max) '$.Names',
+        [Names] nvarchar(max) '$.Names' AS JSON,
         [Number] int '$.Number',
-        [Numbers] nvarchar(max) '$.Numbers',
+        [Numbers] nvarchar(max) '$.Numbers' AS JSON,
         [OwnedCollectionBranch] nvarchar(max) '$.OwnedCollectionBranch' AS JSON,
         [OwnedReferenceBranch] nvarchar(max) '$.OwnedReferenceBranch' AS JSON
     ) AS [o])
@@ -1214,14 +1214,73 @@ public override async Task Json_collection_filter_in_projection(bool async)
     {
         await base.Json_collection_filter_in_projection(async);
 
-        AssertSql("");
+        AssertSql(
+"""
+SELECT [j].[Id], [t].[Id], [t].[Name], [t].[Names], [t].[Number], [t].[Numbers], [t].[c], [t].[c0], [t].[key]
+FROM [JsonEntitiesBasic] AS [j]
+OUTER APPLY (
+    SELECT [j].[Id], JSON_VALUE([o].[value], '$.Name') AS [Name], JSON_QUERY([o].[value], '$.Names') AS [Names], CAST(JSON_VALUE([o].[value], '$.Number') AS int) AS [Number], JSON_QUERY([o].[value], '$.Numbers') AS [Numbers], JSON_QUERY([o].[value], '$.OwnedCollectionBranch') AS [c], JSON_QUERY([o].[value], '$.OwnedReferenceBranch') AS [c0], [o].[key], CAST([o].[key] AS int) AS [c1]
+    FROM OPENJSON([j].[OwnedCollectionRoot], '$') AS [o]
+    WHERE JSON_VALUE([o].[value], '$.Name') <> N'Foo' OR JSON_VALUE([o].[value], '$.Name') IS NULL
+) AS [t]
+ORDER BY [j].[Id], [t].[c1]
+""");
+    }
+
+    public override async Task Json_nested_collection_filter_in_projection(bool async)
+    {
+        await base.Json_nested_collection_filter_in_projection(async);
+
+        AssertSql(
+"""
+SELECT [j].[Id], [t0].[key], [t0].[Id], [t0].[Date], [t0].[Enum], [t0].[Enums], [t0].[Fraction], [t0].[NullableEnum], [t0].[NullableEnums], [t0].[c], [t0].[c0], [t0].[key0]
+FROM [JsonEntitiesBasic] AS [j]
+OUTER APPLY (
+    SELECT [o].[key], [t].[Id], [t].[Date], [t].[Enum], [t].[Enums], [t].[Fraction], [t].[NullableEnum], [t].[NullableEnums], [t].[c], [t].[c0], [t].[key] AS [key0], CAST([o].[key] AS int) AS [c1], [t].[c1] AS [c10]
+    FROM OPENJSON([j].[OwnedCollectionRoot], '$') AS [o]
+    OUTER APPLY (
+        SELECT [j].[Id], CAST(JSON_VALUE([o0].[value], '$.Date') AS datetime2) AS [Date], CAST(JSON_VALUE([o0].[value], '$.Enum') AS int) AS [Enum], JSON_QUERY([o0].[value], '$.Enums') AS [Enums], CAST(JSON_VALUE([o0].[value], '$.Fraction') AS decimal(18,2)) AS [Fraction], CAST(JSON_VALUE([o0].[value], '$.NullableEnum') AS int) AS [NullableEnum], JSON_QUERY([o0].[value], '$.NullableEnums') AS [NullableEnums], JSON_QUERY([o0].[value], '$.OwnedCollectionLeaf') AS [c], JSON_QUERY([o0].[value], '$.OwnedReferenceLeaf') AS [c0], [o0].[key], CAST([o0].[key] AS int) AS [c1]
+        FROM OPENJSON(JSON_QUERY([o].[value], '$.OwnedCollectionBranch'), '$') AS [o0]
+        WHERE CAST(JSON_VALUE([o0].[value], '$.Date') AS datetime2) <> '2000-01-01T00:00:00.0000000' OR CAST(JSON_VALUE([o0].[value], '$.Date') AS datetime2) IS NULL
+    ) AS [t]
+) AS [t0]
+ORDER BY [j].[Id], [t0].[c1], [t0].[key], [t0].[c10]
+""");
+    }
+
+    public override async Task Json_nested_collection_anonymous_projection_in_projection(bool async)
+    {
+        await base.Json_nested_collection_anonymous_projection_in_projection(async);
+
+        AssertSql(
+"""
+SELECT [j].[Id], [t].[key], [t].[c], [t].[c0], [t].[c1], [t].[c2], [t].[c3], [t].[Id], [t].[c4], [t].[key0]
+FROM [JsonEntitiesBasic] AS [j]
+OUTER APPLY (
+    SELECT [o].[key], CAST(JSON_VALUE([o0].[value], '$.Date') AS datetime2) AS [c], CAST(JSON_VALUE([o0].[value], '$.Enum') AS int) AS [c0], JSON_QUERY([o0].[value], '$.Enums') AS [c1], CAST(JSON_VALUE([o0].[value], '$.Fraction') AS decimal(18,2)) AS [c2], JSON_QUERY([o0].[value], '$.OwnedReferenceLeaf') AS [c3], [j].[Id], JSON_QUERY([o0].[value], '$.OwnedCollectionLeaf') AS [c4], [o0].[key] AS [key0], CAST([o].[key] AS int) AS [c5], CAST([o0].[key] AS int) AS [c6]
+    FROM OPENJSON([j].[OwnedCollectionRoot], '$') AS [o]
+    OUTER APPLY OPENJSON(JSON_QUERY([o].[value], '$.OwnedCollectionBranch'), '$') AS [o0]
+) AS [t]
+ORDER BY [j].[Id], [t].[c5], [t].[key], [t].[c6]
+""");
     }
 
     public override async Task Json_collection_skip_take_in_projection(bool async)
     {
         await base.Json_collection_skip_take_in_projection(async);
 
-        AssertSql("");
+        AssertSql(
+"""
+SELECT [j].[Id], [t].[Id], [t].[Name], [t].[Names], [t].[Number], [t].[Numbers], [t].[c], [t].[c0], [t].[key]
+FROM [JsonEntitiesBasic] AS [j]
+OUTER APPLY (
+    SELECT [j].[Id], JSON_VALUE([o].[value], '$.Name') AS [Name], JSON_QUERY([o].[value], '$.Names') AS [Names], CAST(JSON_VALUE([o].[value], '$.Number') AS int) AS [Number], JSON_QUERY([o].[value], '$.Numbers') AS [Numbers], JSON_QUERY([o].[value], '$.OwnedCollectionBranch') AS [c], JSON_QUERY([o].[value], '$.OwnedReferenceBranch') AS [c0], [o].[key], JSON_VALUE([o].[value], '$.Name') AS [c1]
+    FROM OPENJSON([j].[OwnedCollectionRoot], '$') AS [o]
+    ORDER BY JSON_VALUE([o].[value], '$.Name')
+    OFFSET 1 ROWS FETCH NEXT 5 ROWS ONLY
+) AS [t]
+ORDER BY [j].[Id], [t].[c1]
+""");
     }
 
     public override async Task Json_collection_skip_take_in_projection_project_into_anonymous_type(bool async)
@@ -1264,6 +1323,29 @@ public override async Task Json_collection_distinct_in_projection(bool async)
     {
         await base.Json_collection_distinct_in_projection(async);
 
+        AssertSql(
+"""
+SELECT [j].[Id], [t].[Id], [t].[Name], [t].[Names], [t].[Number], [t].[Numbers], [t].[c], [t].[c0]
+FROM [JsonEntitiesBasic] AS [j]
+OUTER APPLY (
+    SELECT DISTINCT [j].[Id], [o].[Name], [o].[Names], [o].[Number], [o].[Numbers], [o].[OwnedCollectionBranch] AS [c], [o].[OwnedReferenceBranch] AS [c0]
+    FROM OPENJSON([j].[OwnedCollectionRoot], '$') WITH (
+        [Name] nvarchar(max) '$.Name',
+        [Names] nvarchar(max) '$.Names' AS JSON,
+        [Number] int '$.Number',
+        [Numbers] nvarchar(max) '$.Numbers' AS JSON,
+        [OwnedCollectionBranch] nvarchar(max) '$.OwnedCollectionBranch' AS JSON,
+        [OwnedReferenceBranch] nvarchar(max) '$.OwnedReferenceBranch' AS JSON
+    ) AS [o]
+) AS [t]
+ORDER BY [j].[Id], [t].[Name]
+""");
+    }
+
+    public override async Task Json_collection_anonymous_projection_distinct_in_projection(bool async)
+    {
+        await base.Json_collection_anonymous_projection_distinct_in_projection(async);
+
         AssertSql("");
     }
 
@@ -1271,21 +1353,138 @@ public override async Task Json_collection_leaf_filter_in_projection(bool async)
     {
         await base.Json_collection_leaf_filter_in_projection(async);
 
-        AssertSql("");
+        AssertSql(
+"""
+SELECT [j].[Id], [t].[Id], [t].[SomethingSomething], [t].[key]
+FROM [JsonEntitiesBasic] AS [j]
+OUTER APPLY (
+    SELECT [j].[Id], JSON_VALUE([o].[value], '$.SomethingSomething') AS [SomethingSomething], [o].[key], CAST([o].[key] AS int) AS [c]
+    FROM OPENJSON([j].[OwnedReferenceRoot], '$.OwnedReferenceBranch.OwnedCollectionLeaf') AS [o]
+    WHERE JSON_VALUE([o].[value], '$.SomethingSomething') <> N'Baz' OR JSON_VALUE([o].[value], '$.SomethingSomething') IS NULL
+) AS [t]
+ORDER BY [j].[Id], [t].[c]
+""");
+    }
+
+    public override async Task Json_multiple_collection_projections(bool async)
+    {
+        await base.Json_multiple_collection_projections(async);
+
+        AssertSql(
+"""
+SELECT [j].[Id], [t].[Id], [t].[SomethingSomething], [t].[key], [t0].[Id], [t0].[Name], [t0].[Names], [t0].[Number], [t0].[Numbers], [t0].[c], [t0].[c0], [t1].[key], [t1].[Id], [t1].[Date], [t1].[Enum], [t1].[Enums], [t1].[Fraction], [t1].[NullableEnum], [t1].[NullableEnums], [t1].[c], [t1].[c0], [t1].[key0], [j0].[Id], [j0].[Name], [j0].[ParentId]
+FROM [JsonEntitiesBasic] AS [j]
+OUTER APPLY (
+    SELECT [j].[Id], JSON_VALUE([o].[value], '$.SomethingSomething') AS [SomethingSomething], [o].[key], CAST([o].[key] AS int) AS [c]
+    FROM OPENJSON([j].[OwnedReferenceRoot], '$.OwnedReferenceBranch.OwnedCollectionLeaf') AS [o]
+    WHERE JSON_VALUE([o].[value], '$.SomethingSomething') <> N'Baz' OR JSON_VALUE([o].[value], '$.SomethingSomething') IS NULL
+) AS [t]
+OUTER APPLY (
+    SELECT DISTINCT [j].[Id], [o0].[Name], [o0].[Names], [o0].[Number], [o0].[Numbers], [o0].[OwnedCollectionBranch] AS [c], [o0].[OwnedReferenceBranch] AS [c0]
+    FROM OPENJSON([j].[OwnedCollectionRoot], '$') WITH (
+        [Name] nvarchar(max) '$.Name',
+        [Names] nvarchar(max) '$.Names' AS JSON,
+        [Number] int '$.Number',
+        [Numbers] nvarchar(max) '$.Numbers' AS JSON,
+        [OwnedCollectionBranch] nvarchar(max) '$.OwnedCollectionBranch' AS JSON,
+        [OwnedReferenceBranch] nvarchar(max) '$.OwnedReferenceBranch' AS JSON
+    ) AS [o0]
+) AS [t0]
+OUTER APPLY (
+    SELECT [o1].[key], [t2].[Id], [t2].[Date], [t2].[Enum], [t2].[Enums], [t2].[Fraction], [t2].[NullableEnum], [t2].[NullableEnums], [t2].[c], [t2].[c0], [t2].[key] AS [key0], CAST([o1].[key] AS int) AS [c1], [t2].[c1] AS [c10]
+    FROM OPENJSON([j].[OwnedCollectionRoot], '$') AS [o1]
+    OUTER APPLY (
+        SELECT [j].[Id], CAST(JSON_VALUE([o2].[value], '$.Date') AS datetime2) AS [Date], CAST(JSON_VALUE([o2].[value], '$.Enum') AS int) AS [Enum], JSON_QUERY([o2].[value], '$.Enums') AS [Enums], CAST(JSON_VALUE([o2].[value], '$.Fraction') AS decimal(18,2)) AS [Fraction], CAST(JSON_VALUE([o2].[value], '$.NullableEnum') AS int) AS [NullableEnum], JSON_QUERY([o2].[value], '$.NullableEnums') AS [NullableEnums], JSON_QUERY([o2].[value], '$.OwnedCollectionLeaf') AS [c], JSON_QUERY([o2].[value], '$.OwnedReferenceLeaf') AS [c0], [o2].[key], CAST([o2].[key] AS int) AS [c1]
+        FROM OPENJSON(JSON_QUERY([o1].[value], '$.OwnedCollectionBranch'), '$') AS [o2]
+        WHERE CAST(JSON_VALUE([o2].[value], '$.Date') AS datetime2) <> '2000-01-01T00:00:00.0000000' OR CAST(JSON_VALUE([o2].[value], '$.Date') AS datetime2) IS NULL
+    ) AS [t2]
+) AS [t1]
+LEFT JOIN [JsonEntitiesBasicForCollection] AS [j0] ON [j].[Id] = [j0].[ParentId]
+ORDER BY [j].[Id], [t].[c], [t].[key], [t0].[Name], [t0].[Number], [t1].[c1], [t1].[key], [t1].[c10], [t1].[key0]
+""");
+    }
+
+    public override async Task Json_branch_collection_distinct_and_other_collection(bool async)
+    {
+        await base.Json_branch_collection_distinct_and_other_collection(async);
+
+        AssertSql(
+"""
+SELECT [j].[Id], [t].[Id], [t].[Date], [t].[Enum], [t].[Enums], [t].[Fraction], [t].[NullableEnum], [t].[NullableEnums], [t].[c], [t].[c0], [j0].[Id], [j0].[Name], [j0].[ParentId]
+FROM [JsonEntitiesBasic] AS [j]
+OUTER APPLY (
+    SELECT DISTINCT [j].[Id], [o].[Date], [o].[Enum], [o].[Enums], [o].[Fraction], [o].[NullableEnum], [o].[NullableEnums], [o].[OwnedCollectionLeaf] AS [c], [o].[OwnedReferenceLeaf] AS [c0]
+    FROM OPENJSON([j].[OwnedReferenceRoot], '$.OwnedCollectionBranch') WITH (
+        [Date] datetime2 '$.Date',
+        [Enum] int '$.Enum',
+        [Enums] nvarchar(max) '$.Enums' AS JSON,
+        [Fraction] decimal(18,2) '$.Fraction',
+        [NullableEnum] int '$.NullableEnum',
+        [NullableEnums] nvarchar(max) '$.NullableEnums' AS JSON,
+        [OwnedCollectionLeaf] nvarchar(max) '$.OwnedCollectionLeaf' AS JSON,
+        [OwnedReferenceLeaf] nvarchar(max) '$.OwnedReferenceLeaf' AS JSON
+    ) AS [o]
+) AS [t]
+LEFT JOIN [JsonEntitiesBasicForCollection] AS [j0] ON [j].[Id] = [j0].[ParentId]
+ORDER BY [j].[Id], [t].[Date], [t].[Enum], [t].[Fraction], [t].[NullableEnum]
+""");
+    }
+
+    public override async Task Json_leaf_collection_distinct_and_other_collection(bool async)
+    {
+        await base.Json_leaf_collection_distinct_and_other_collection(async);
+
+        AssertSql(
+"""
+SELECT [j].[Id], [t].[Id], [t].[SomethingSomething], [j0].[Id], [j0].[Name], [j0].[ParentId]
+FROM [JsonEntitiesBasic] AS [j]
+OUTER APPLY (
+    SELECT DISTINCT [j].[Id], [o].[SomethingSomething]
+    FROM OPENJSON([j].[OwnedReferenceRoot], '$.OwnedReferenceBranch.OwnedCollectionLeaf') WITH ([SomethingSomething] nvarchar(max) '$.SomethingSomething') AS [o]
+) AS [t]
+LEFT JOIN [JsonEntitiesBasicForCollection] AS [j0] ON [j].[Id] = [j0].[ParentId]
+ORDER BY [j].[Id], [t].[SomethingSomething]
+""");
     }
 
     public override async Task Json_collection_SelectMany(bool async)
     {
         await base.Json_collection_SelectMany(async);
 
-        AssertSql("");
+        AssertSql(
+"""
+SELECT [j].[Id], [o].[Name], [o].[Names], [o].[Number], [o].[Numbers], [o].[OwnedCollectionBranch], [o].[OwnedReferenceBranch]
+FROM [JsonEntitiesBasic] AS [j]
+CROSS APPLY OPENJSON([j].[OwnedCollectionRoot], '$') WITH (
+    [Name] nvarchar(max) '$.Name',
+    [Names] nvarchar(max) '$.Names' AS JSON,
+    [Number] int '$.Number',
+    [Numbers] nvarchar(max) '$.Numbers' AS JSON,
+    [OwnedCollectionBranch] nvarchar(max) '$.OwnedCollectionBranch' AS JSON,
+    [OwnedReferenceBranch] nvarchar(max) '$.OwnedReferenceBranch' AS JSON
+) AS [o]
+""");
     }
 
     public override async Task Json_nested_collection_SelectMany(bool async)
     {
         await base.Json_nested_collection_SelectMany(async);
 
-        AssertSql("");
+        AssertSql(
+"""
+SELECT [j].[Id], [o].[Date], [o].[Enum], [o].[Enums], [o].[Fraction], [o].[NullableEnum], [o].[NullableEnums], [o].[OwnedCollectionLeaf], [o].[OwnedReferenceLeaf]
+FROM [JsonEntitiesBasic] AS [j]
+CROSS APPLY OPENJSON([j].[OwnedReferenceRoot], '$.OwnedCollectionBranch') WITH (
+    [Date] datetime2 '$.Date',
+    [Enum] int '$.Enum',
+    [Enums] nvarchar(max) '$.Enums' AS JSON,
+    [Fraction] decimal(18,2) '$.Fraction',
+    [NullableEnum] int '$.NullableEnum',
+    [NullableEnums] nvarchar(max) '$.NullableEnums' AS JSON,
+    [OwnedCollectionLeaf] nvarchar(max) '$.OwnedCollectionLeaf' AS JSON,
+    [OwnedReferenceLeaf] nvarchar(max) '$.OwnedReferenceLeaf' AS JSON
+) AS [o]
+""");
     }
 
     public override async Task Json_collection_of_primitives_SelectMany(bool async)
diff --git a/test/EFCore.Sqlite.FunctionalTests/MaterializationInterceptionSqliteTest.cs b/test/EFCore.Sqlite.FunctionalTests/MaterializationInterceptionSqliteTest.cs
index 46dca82910..f2627186dd 100644
--- a/test/EFCore.Sqlite.FunctionalTests/MaterializationInterceptionSqliteTest.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/MaterializationInterceptionSqliteTest.cs
@@ -3,6 +3,8 @@
 
 #nullable enable
 
+using Microsoft.EntityFrameworkCore.Sqlite.Internal;
+
 namespace Microsoft.EntityFrameworkCore;
 
 public class MaterializationInterceptionSqliteTest : MaterializationInterceptionTestBase<MaterializationInterceptionSqliteTest.SqliteLibraryContext>,
@@ -13,6 +15,13 @@ public MaterializationInterceptionSqliteTest(MaterializationInterceptionSqliteFi
     {
     }
 
+    public override async Task Intercept_query_materialization_with_owned_types_projecting_collection(bool async)
+        => Assert.Equal(
+            SqliteStrings.ApplyNotSupported,
+            (await Assert.ThrowsAsync<InvalidOperationException>(
+                () => base.Intercept_query_materialization_with_owned_types_projecting_collection(async)))
+            .Message);
+
     public class SqliteLibraryContext : LibraryContext
     {
         public SqliteLibraryContext(DbContextOptions options)
diff --git a/test/EFCore.Sqlite.FunctionalTests/Query/JsonQuerySqliteTest.cs b/test/EFCore.Sqlite.FunctionalTests/Query/JsonQuerySqliteTest.cs
index 272558e395..5f683ce48e 100644
--- a/test/EFCore.Sqlite.FunctionalTests/Query/JsonQuerySqliteTest.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/Query/JsonQuerySqliteTest.cs
@@ -298,6 +298,83 @@ public override async Task Json_collection_skip_take_in_projection_with_json_ref
                 () => base.Json_collection_skip_take_in_projection_with_json_reference_access_as_final_operation(async)))
             .Message);
 
+    public override async Task Json_collection_distinct_in_projection(bool async)
+        => Assert.Equal(
+            SqliteStrings.ApplyNotSupported,
+            (await Assert.ThrowsAsync<InvalidOperationException>(
+                () => base.Json_collection_distinct_in_projection(async)))
+            .Message);
+
+    public override async Task Json_collection_filter_in_projection(bool async)
+        => Assert.Equal(
+            SqliteStrings.ApplyNotSupported,
+            (await Assert.ThrowsAsync<InvalidOperationException>(
+                () => base.Json_collection_filter_in_projection(async)))
+            .Message);
+
+    public override async Task Json_collection_leaf_filter_in_projection(bool async)
+        => Assert.Equal(
+            SqliteStrings.ApplyNotSupported,
+            (await Assert.ThrowsAsync<InvalidOperationException>(
+                () => base.Json_collection_leaf_filter_in_projection(async)))
+            .Message);
+
+    public override async Task Json_branch_collection_distinct_and_other_collection(bool async)
+        => Assert.Equal(
+            SqliteStrings.ApplyNotSupported,
+            (await Assert.ThrowsAsync<InvalidOperationException>(
+                () => base.Json_branch_collection_distinct_and_other_collection(async)))
+            .Message);
+
+    public override async Task Json_leaf_collection_distinct_and_other_collection(bool async)
+        => Assert.Equal(
+            SqliteStrings.ApplyNotSupported,
+            (await Assert.ThrowsAsync<InvalidOperationException>(
+                () => base.Json_leaf_collection_distinct_and_other_collection(async)))
+            .Message);
+
+    public override async Task Json_multiple_collection_projections(bool async)
+        => Assert.Equal(
+            SqliteStrings.ApplyNotSupported,
+            (await Assert.ThrowsAsync<InvalidOperationException>(
+                () => base.Json_multiple_collection_projections(async)))
+            .Message);
+
+    public override async Task Json_collection_SelectMany(bool async)
+        => Assert.Equal(
+            SqliteStrings.ApplyNotSupported,
+            (await Assert.ThrowsAsync<InvalidOperationException>(
+                () => base.Json_collection_SelectMany(async)))
+            .Message);
+
+    public override async Task Json_collection_skip_take_in_projection(bool async)
+        => Assert.Equal(
+            SqliteStrings.ApplyNotSupported,
+            (await Assert.ThrowsAsync<InvalidOperationException>(
+                () => base.Json_collection_skip_take_in_projection(async)))
+            .Message);
+
+    public override async Task Json_nested_collection_anonymous_projection_in_projection(bool async)
+        => Assert.Equal(
+            SqliteStrings.ApplyNotSupported,
+            (await Assert.ThrowsAsync<InvalidOperationException>(
+                () => base.Json_nested_collection_anonymous_projection_in_projection(async)))
+            .Message);
+
+    public override async Task Json_nested_collection_filter_in_projection(bool async)
+        => Assert.Equal(
+            SqliteStrings.ApplyNotSupported,
+            (await Assert.ThrowsAsync<InvalidOperationException>(
+                () => base.Json_nested_collection_filter_in_projection(async)))
+            .Message);
+
+    public override async Task Json_nested_collection_SelectMany(bool async)
+        => Assert.Equal(
+            SqliteStrings.ApplyNotSupported,
+            (await Assert.ThrowsAsync<InvalidOperationException>(
+                () => base.Json_nested_collection_SelectMany(async)))
+            .Message);
+
     public override async Task Json_collection_index_in_projection_using_untranslatable_client_method(bool async)
     {
         var message = (await Assert.ThrowsAsync<InvalidOperationException>(
