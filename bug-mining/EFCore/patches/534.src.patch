diff --git a/src/EFCore.Relational/Diagnostics/RelationalEventId.cs b/src/EFCore.Relational/Diagnostics/RelationalEventId.cs
index cabde564e2..c05c73c46a 100644
--- a/src/EFCore.Relational/Diagnostics/RelationalEventId.cs
+++ b/src/EFCore.Relational/Diagnostics/RelationalEventId.cs
@@ -80,6 +80,7 @@ private enum Id
         PendingModelChangesWarning,
         NonTransactionalMigrationOperationWarning,
         AcquiringMigrationLock,
+        MigrationsUserTransactionWarning,
 
         // Query events
         QueryClientEvaluationWarning = CoreEventId.RelationalBaseId + 500,
@@ -764,6 +765,19 @@ private static EventId MakeMigrationsId(Id id)
     /// </remarks>
     public static readonly EventId AcquiringMigrationLock = MakeMigrationsId(Id.AcquiringMigrationLock);
 
+    /// <summary>
+    ///     A migration lock is being acquired.
+    /// </summary>
+    /// <remarks>
+    ///     <para>
+    ///         This event is in the <see cref="DbLoggerCategory.Migrations" /> category.
+    ///     </para>
+    ///     <para>
+    ///         This event uses the <see cref="EventData" /> payload when used with a <see cref="DiagnosticSource" />.
+    ///     </para>
+    /// </remarks>
+    public static readonly EventId MigrationsUserTransactionWarning = MakeMigrationsId(Id.MigrationsUserTransactionWarning);
+
     private static readonly string _queryPrefix = DbLoggerCategory.Query.Name + ".";
 
     private static EventId MakeQueryId(Id id)
diff --git a/src/EFCore.Relational/Diagnostics/RelationalLoggerExtensions.cs b/src/EFCore.Relational/Diagnostics/RelationalLoggerExtensions.cs
index a8afec569e..177b7e90bb 100644
--- a/src/EFCore.Relational/Diagnostics/RelationalLoggerExtensions.cs
+++ b/src/EFCore.Relational/Diagnostics/RelationalLoggerExtensions.cs
@@ -2425,6 +2425,36 @@ private static string AcquiringMigrationLock(EventDefinitionBase definition, Eve
         return d.GenerateMessage();
     }
 
+    /// <summary>
+    ///     Logs for the <see cref="RelationalEventId.MigrationsUserTransactionWarning" /> event.
+    /// </summary>
+    /// <param name="diagnostics">The diagnostics logger to use.</param>
+    public static void MigrationsUserTransactionWarning(
+        this IDiagnosticsLogger<DbLoggerCategory.Migrations> diagnostics)
+    {
+        var definition = RelationalResources.LogMigrationsUserTransaction(diagnostics);
+
+        if (diagnostics.ShouldLog(definition))
+        {
+            definition.Log(diagnostics);
+        }
+
+        if (diagnostics.NeedsEventData(definition, out var diagnosticSourceEnabled, out var simpleLogEnabled))
+        {
+            var eventData = new EventData(
+                definition,
+                MigrationsUserTransactionWarning);
+
+            diagnostics.DispatchEventData(definition, eventData, diagnosticSourceEnabled, simpleLogEnabled);
+        }
+    }
+
+    private static string MigrationsUserTransactionWarning(EventDefinitionBase definition, EventData payload)
+    {
+        var d = (EventDefinition)definition;
+        return d.GenerateMessage();
+    }
+
     /// <summary>
     ///     Logs for the <see cref="RelationalEventId.QueryPossibleUnintendedUseOfEqualsWarning" /> event.
     /// </summary>
diff --git a/src/EFCore.Relational/Diagnostics/RelationalLoggingDefinitions.cs b/src/EFCore.Relational/Diagnostics/RelationalLoggingDefinitions.cs
index 9b57a07998..762172c894 100644
--- a/src/EFCore.Relational/Diagnostics/RelationalLoggingDefinitions.cs
+++ b/src/EFCore.Relational/Diagnostics/RelationalLoggingDefinitions.cs
@@ -367,6 +367,15 @@ public abstract class RelationalLoggingDefinitions : LoggingDefinitions
     [EntityFrameworkInternal]
     public EventDefinitionBase? LogAcquiringMigrationLock;
 
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    [EntityFrameworkInternal]
+    public EventDefinitionBase? LogMigrationsUserTransactionWarning;
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
diff --git a/src/EFCore.Relational/Migrations/HistoryRepository.cs b/src/EFCore.Relational/Migrations/HistoryRepository.cs
index 78dc3b2401..bfb565786c 100644
--- a/src/EFCore.Relational/Migrations/HistoryRepository.cs
+++ b/src/EFCore.Relational/Migrations/HistoryRepository.cs
@@ -47,6 +47,14 @@ protected HistoryRepository(HistoryRepositoryDependencies dependencies)
         TableSchema = relationalOptions.MigrationsHistoryTableSchema;
     }
 
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public abstract LockReleaseBehavior LockReleaseBehavior { get; }
+
     /// <summary>
     ///     Relational provider-specific dependencies for this service.
     /// </summary>
@@ -120,14 +128,15 @@ protected virtual string ProductVersionColumnName
     /// </summary>
     /// <returns><see langword="true" /> if the table already exists, <see langword="false" /> otherwise.</returns>
     public virtual bool Exists()
-        => InterpretExistsResult(
-            Dependencies.RawSqlCommandBuilder.Build(ExistsSql).ExecuteScalar(
-                new RelationalCommandParameterObject(
-                    Dependencies.Connection,
-                    null,
-                    null,
-                    Dependencies.CurrentContext.Context,
-                    Dependencies.CommandLogger, CommandSource.Migrations)));
+        => Dependencies.DatabaseCreator.Exists()
+            && InterpretExistsResult(
+                Dependencies.RawSqlCommandBuilder.Build(ExistsSql).ExecuteScalar(
+                    new RelationalCommandParameterObject(
+                        Dependencies.Connection,
+                        null,
+                        null,
+                        Dependencies.CurrentContext.Context,
+                        Dependencies.CommandLogger, CommandSource.Migrations)));
 
     /// <summary>
     ///     Checks whether or not the history table exists.
@@ -139,15 +148,16 @@ public virtual bool Exists()
     /// </returns>
     /// <exception cref="OperationCanceledException">If the <see cref="CancellationToken" /> is canceled.</exception>
     public virtual async Task<bool> ExistsAsync(CancellationToken cancellationToken = default)
-        => InterpretExistsResult(
-            await Dependencies.RawSqlCommandBuilder.Build(ExistsSql).ExecuteScalarAsync(
-                new RelationalCommandParameterObject(
-                    Dependencies.Connection,
-                    null,
-                    null,
-                    Dependencies.CurrentContext.Context,
-                    Dependencies.CommandLogger, CommandSource.Migrations),
-                cancellationToken).ConfigureAwait(false));
+        => await Dependencies.DatabaseCreator.ExistsAsync(cancellationToken).ConfigureAwait(false)
+            && InterpretExistsResult(
+                await Dependencies.RawSqlCommandBuilder.Build(ExistsSql).ExecuteScalarAsync(
+                    new RelationalCommandParameterObject(
+                        Dependencies.Connection,
+                        null,
+                        null,
+                        Dependencies.CurrentContext.Context,
+                        Dependencies.CommandLogger, CommandSource.Migrations),
+                    cancellationToken).ConfigureAwait(false));
 
     /// <summary>
     ///     Interprets the result of executing <see cref="ExistsSql" />.
@@ -173,13 +183,15 @@ public virtual string GetCreateScript()
     ///     Creates the history table.
     /// </summary>
     public virtual void Create()
-        => Dependencies.MigrationCommandExecutor.ExecuteNonQuery(GetCreateCommands(), Dependencies.Connection);
+        => Dependencies.MigrationCommandExecutor.ExecuteNonQuery(
+            GetCreateCommands(), Dependencies.Connection, new MigrationExecutionState(), commitTransaction: true);
 
     /// <summary>
     ///     Creates the history table.
     /// </summary>
     public virtual Task CreateAsync(CancellationToken cancellationToken = default)
-        => Dependencies.MigrationCommandExecutor.ExecuteNonQueryAsync(GetCreateCommands(), Dependencies.Connection, cancellationToken);
+        => Dependencies.MigrationCommandExecutor.ExecuteNonQueryAsync(
+            GetCreateCommands(), Dependencies.Connection, new MigrationExecutionState(), commitTransaction: true, cancellationToken: cancellationToken);
 
     /// <summary>
     ///     Returns the migration commands that will create the history table.
@@ -194,19 +206,37 @@ protected virtual IReadOnlyList<MigrationCommand> GetCreateCommands()
         return commandList;
     }
 
+    bool IHistoryRepository.CreateIfNotExists()
+        => Dependencies.MigrationCommandExecutor.ExecuteNonQuery(
+            GetCreateIfNotExistsCommands(), Dependencies.Connection, new MigrationExecutionState(), commitTransaction: true)
+            != 0;
+
+    async Task<bool> IHistoryRepository.CreateIfNotExistsAsync(CancellationToken cancellationToken)
+        => (await Dependencies.MigrationCommandExecutor.ExecuteNonQueryAsync(
+            GetCreateIfNotExistsCommands(), Dependencies.Connection, new MigrationExecutionState(), commitTransaction: true, cancellationToken: cancellationToken).ConfigureAwait(false))
+            != 0;
+
+    private IReadOnlyList<MigrationCommand> GetCreateIfNotExistsCommands()
+        => Dependencies.MigrationsSqlGenerator.Generate([new SqlOperation
+        {
+            Sql = GetCreateIfNotExistsScript(),
+            SuppressTransaction = true
+        }]);
+
     /// <summary>
     ///     Gets an exclusive lock on the database.
     /// </summary>
     /// <returns>An object that can be disposed to release the lock.</returns>
-    public abstract IDisposable GetDatabaseLock();
+    public abstract IMigrationsDatabaseLock AcquireDatabaseLock();
 
     /// <summary>
     ///     Gets an exclusive lock on the database.
     /// </summary>
     /// <param name="cancellationToken">A <see cref="CancellationToken" /> to observe while waiting for the task to complete.</param>
+    /// 
     /// <returns>An object that can be disposed to release the lock.</returns>
     /// <exception cref="OperationCanceledException">If the <see cref="CancellationToken" /> is canceled.</exception>
-    public abstract Task<IAsyncDisposable> GetDatabaseLockAsync(CancellationToken cancellationToken = default);
+    public abstract Task<IMigrationsDatabaseLock> AcquireDatabaseLockAsync(CancellationToken cancellationToken = default);
 
     /// <summary>
     ///     Configures the entity type mapped to the history table.
diff --git a/src/EFCore.Relational/Migrations/HistoryRepositoryDependencies.cs b/src/EFCore.Relational/Migrations/HistoryRepositoryDependencies.cs
index b5f40bd8ba..a8bf28d3f2 100644
--- a/src/EFCore.Relational/Migrations/HistoryRepositoryDependencies.cs
+++ b/src/EFCore.Relational/Migrations/HistoryRepositoryDependencies.cs
@@ -59,7 +59,8 @@ public sealed record HistoryRepositoryDependencies
         IRelationalTypeMappingSource typeMappingSource,
         ICurrentDbContext currentContext,
         IModelRuntimeInitializer modelRuntimeInitializer,
-        IRelationalCommandDiagnosticsLogger commandLogger)
+        IRelationalCommandDiagnosticsLogger commandLogger,
+        IDiagnosticsLogger<DbLoggerCategory.Migrations> migrationsLogger)
     {
         DatabaseCreator = databaseCreator;
         RawSqlCommandBuilder = rawSqlCommandBuilder;
@@ -75,6 +76,7 @@ public sealed record HistoryRepositoryDependencies
         CurrentContext = currentContext;
         ModelRuntimeInitializer = modelRuntimeInitializer;
         CommandLogger = commandLogger;
+        MigrationsLogger = migrationsLogger;
     }
 
     /// <summary>
@@ -146,4 +148,9 @@ public sealed record HistoryRepositoryDependencies
     ///     The command logger
     /// </summary>
     public IRelationalCommandDiagnosticsLogger CommandLogger { get; init; }
+
+    /// <summary>
+    ///     The migrations logger
+    /// </summary>
+    public IDiagnosticsLogger<DbLoggerCategory.Migrations> MigrationsLogger { get; init; }
 }
diff --git a/src/EFCore.Relational/Migrations/IHistoryRepository.cs b/src/EFCore.Relational/Migrations/IHistoryRepository.cs
index 7bf3a46165..2189e6cea8 100644
--- a/src/EFCore.Relational/Migrations/IHistoryRepository.cs
+++ b/src/EFCore.Relational/Migrations/IHistoryRepository.cs
@@ -50,12 +50,44 @@ public interface IHistoryRepository
     /// </summary>
     /// <param name="cancellationToken">A <see cref="CancellationToken" /> to observe while waiting for the task to complete.</param>
     /// <returns>
-    ///     A task that represents the asynchronous operation. The task result contains
-    ///     <see langword="true" /> if the table already exists, <see langword="false" /> otherwise.
+    ///     A task that represents the asynchronous operation.
     /// </returns>
     /// <exception cref="OperationCanceledException">If the <see cref="CancellationToken" /> is canceled.</exception>
     Task CreateAsync(CancellationToken cancellationToken = default);
 
+    /// <summary>
+    ///     Creates the history table if it doesn't exist.
+    /// </summary>
+    /// <returns><see langword="true" /> if the table was created, <see langword="false" /> otherwise.</returns>
+    bool CreateIfNotExists()
+    {
+        if (!Exists())
+        {
+            Create();
+            return true;
+        }
+        return false;
+    }
+
+    /// <summary>
+    ///     Creates the history table.
+    /// </summary>
+    /// <param name="cancellationToken">A <see cref="CancellationToken" /> to observe while waiting for the task to complete.</param>
+    /// <returns>
+    ///     A task that represents the asynchronous operation. The task result contains
+    ///     <see langword="true" /> if the table was created, <see langword="false" /> otherwise.
+    /// </returns>
+    /// <exception cref="OperationCanceledException">If the <see cref="CancellationToken" /> is canceled.</exception>
+    async Task<bool> CreateIfNotExistsAsync(CancellationToken cancellationToken = default)
+    {
+        if (!await ExistsAsync(cancellationToken).ConfigureAwait(false))
+        {
+            await CreateAsync(cancellationToken).ConfigureAwait(false);
+            return true;
+        }
+        return false;
+    }
+
     /// <summary>
     ///     Queries the history table for all migrations that have been applied.
     /// </summary>
@@ -75,18 +107,23 @@ public interface IHistoryRepository
         CancellationToken cancellationToken = default);
 
     /// <summary>
-    ///     Gets an exclusive lock on the database.
+    ///     The condition under witch the lock is released implicitly.
+    /// </summary>
+    LockReleaseBehavior LockReleaseBehavior { get; }
+
+    /// <summary>
+    ///     Acquires an exclusive lock on the database.
     /// </summary>
     /// <returns>An object that can be disposed to release the lock.</returns>
-    IDisposable GetDatabaseLock();
+    IMigrationsDatabaseLock AcquireDatabaseLock();
 
     /// <summary>
-    ///     Gets an exclusive lock on the database.
+    ///     Acquires an exclusive lock on the database asynchronously.
     /// </summary>
     /// <param name="cancellationToken">A <see cref="CancellationToken" /> to observe while waiting for the task to complete.</param>
     /// <returns>An object that can be disposed to release the lock.</returns>
     /// <exception cref="OperationCanceledException">If the <see cref="CancellationToken" /> is canceled.</exception>
-    Task<IAsyncDisposable> GetDatabaseLockAsync(CancellationToken cancellationToken = default);
+    Task<IMigrationsDatabaseLock> AcquireDatabaseLockAsync(CancellationToken cancellationToken = default);
 
     /// <summary>
     ///     Generates a SQL script that will create the history table.
diff --git a/src/EFCore.Relational/Migrations/IMigrationCommandExecutor.cs b/src/EFCore.Relational/Migrations/IMigrationCommandExecutor.cs
index 7069ba9c04..039bbaa4f1 100644
--- a/src/EFCore.Relational/Migrations/IMigrationCommandExecutor.cs
+++ b/src/EFCore.Relational/Migrations/IMigrationCommandExecutor.cs
@@ -1,6 +1,8 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using System.Data;
+
 namespace Microsoft.EntityFrameworkCore.Migrations;
 
 /// <summary>
@@ -28,6 +30,24 @@ public interface IMigrationCommandExecutor
         IEnumerable<MigrationCommand> migrationCommands,
         IRelationalConnection connection);
 
+    /// <summary>
+    ///     Executes the given commands using the given database connection.
+    /// </summary>
+    /// <param name="migrationCommands">The commands to execute.</param>
+    /// <param name="connection">The connection to use.</param>
+    /// <param name="executionState">The state of the current migration execution.</param>
+    /// <param name="commitTransaction">
+    ///     Indicates whether the transaction started by this call should be commited.
+    ///     If <see langword="false" />, the transaction will be made available in <paramref name="executionState"/>.
+    /// </param>
+    /// <param name="isolationLevel">The isolation level for the transaction.</param>
+    int ExecuteNonQuery(
+        IReadOnlyList<MigrationCommand> migrationCommands,
+        IRelationalConnection connection,
+        MigrationExecutionState executionState,
+        bool commitTransaction,
+        IsolationLevel? isolationLevel = null);
+
     /// <summary>
     ///     Executes the given commands using the given database connection.
     /// </summary>
@@ -40,4 +60,26 @@ public interface IMigrationCommandExecutor
         IEnumerable<MigrationCommand> migrationCommands,
         IRelationalConnection connection,
         CancellationToken cancellationToken = default);
+
+    /// <summary>
+    ///     Executes the given commands using the given database connection.
+    /// </summary>
+    /// <param name="migrationCommands">The commands to execute.</param>
+    /// <param name="connection">The connection to use.</param>
+    /// <param name="executionState">The state of the current migration execution.</param>
+    /// <param name="commitTransaction">
+    ///     Indicates whether the transaction started by this call should be commited.
+    ///     If <see langword="false" />, the transaction will be made available in <paramref name="executionState"/>.
+    /// </param>
+    /// <param name="isolationLevel">The isolation level for the transaction.</param>
+    /// <param name="cancellationToken">A <see cref="CancellationToken" /> to observe while waiting for the task to complete.</param>
+    /// <returns>A task that represents the asynchronous operation.</returns>
+    /// <exception cref="OperationCanceledException">If the <see cref="CancellationToken" /> is canceled.</exception>
+    Task<int> ExecuteNonQueryAsync(
+        IReadOnlyList<MigrationCommand> migrationCommands,
+        IRelationalConnection connection,
+        MigrationExecutionState executionState,
+        bool commitTransaction,
+        IsolationLevel? isolationLevel = null,
+        CancellationToken cancellationToken = default);
 }
diff --git a/src/EFCore.Relational/Migrations/IMigrationsDatabaseLock.cs b/src/EFCore.Relational/Migrations/IMigrationsDatabaseLock.cs
new file mode 100644
index 0000000000..b08ea1b9fa
--- /dev/null
+++ b/src/EFCore.Relational/Migrations/IMigrationsDatabaseLock.cs
@@ -0,0 +1,62 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.EntityFrameworkCore.Migrations;
+
+/// <summary>
+///     Represents an exclusive lock on the database that is used to ensure that only one migration application can be run at a time.
+/// </summary>
+/// <remarks>
+///     Typically only database providers implement this.
+/// </remarks>
+public interface IMigrationsDatabaseLock : IDisposable, IAsyncDisposable
+{
+    /// <summary>
+    ///    The history repository.
+    /// </summary>
+    protected IHistoryRepository HistoryRepository { get; }
+
+    /// <summary>
+    ///     Acquires an exclusive lock on the database again if the current one was already released.
+    /// </summary>
+    /// <param name="connectionReopened">Indicates whether the connection was reopened.</param>
+    /// <param name="transactionRestarted">
+    ///     Indicates whether the transaction was restarted.
+    ///     <see langword="null"/> if there's no current transaction.
+    /// </param>
+    /// <returns>An object that can be disposed to release the lock.</returns>
+    IMigrationsDatabaseLock ReacquireIfNeeded(bool connectionReopened, bool? transactionRestarted)
+    {
+        if ((connectionReopened && HistoryRepository.LockReleaseBehavior == LockReleaseBehavior.Connection)
+                || (transactionRestarted is true && HistoryRepository.LockReleaseBehavior == LockReleaseBehavior.Transaction))
+        {
+            Dispose();
+            return HistoryRepository.AcquireDatabaseLock();
+        }
+
+        return this;
+    }
+
+    /// <summary>
+    ///     Acquires an exclusive lock on the database again, if the current one was already released.
+    /// </summary>
+    /// <param name="connectionReopened">Indicates whether the connection was reopened.</param>
+    /// <param name="transactionRestarted">
+    ///     Indicates whether the transaction was restarted.
+    ///     <see langword="null"/> if there's no current transaction.
+    /// </param>
+    /// <param name="cancellationToken">A <see cref="CancellationToken" /> to observe while waiting for the task to complete.</param>
+    /// <returns>An object that can be disposed to release the lock.</returns>
+    async Task<IMigrationsDatabaseLock> ReacquireIfNeededAsync(
+        bool connectionReopened, bool? transactionRestarted, CancellationToken cancellationToken = default)
+    {
+        if ((connectionReopened && HistoryRepository.LockReleaseBehavior == LockReleaseBehavior.Connection)
+                || (transactionRestarted is true && HistoryRepository.LockReleaseBehavior == LockReleaseBehavior.Transaction))
+        {
+            await DisposeAsync().ConfigureAwait(false);
+            return await HistoryRepository.AcquireDatabaseLockAsync(cancellationToken).ConfigureAwait(false);
+        }
+
+        return this;
+    }
+}
diff --git a/src/EFCore.Relational/Migrations/Internal/MigrationCommandExecutor.cs b/src/EFCore.Relational/Migrations/Internal/MigrationCommandExecutor.cs
index 4b2d78a85b..68c6ba4a88 100644
--- a/src/EFCore.Relational/Migrations/Internal/MigrationCommandExecutor.cs
+++ b/src/EFCore.Relational/Migrations/Internal/MigrationCommandExecutor.cs
@@ -28,74 +28,120 @@ public class MigrationCommandExecutor(IExecutionStrategy executionStrategy) : IM
     public virtual void ExecuteNonQuery(
         IEnumerable<MigrationCommand> migrationCommands,
         IRelationalConnection connection)
+        => ExecuteNonQuery(
+            migrationCommands.ToList(), connection, new MigrationExecutionState(), commitTransaction: true);
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual int ExecuteNonQuery(
+        IReadOnlyList<MigrationCommand> migrationCommands,
+        IRelationalConnection connection,
+        MigrationExecutionState executionState,
+        bool commitTransaction,
+        System.Data.IsolationLevel? isolationLevel = null)
     {
-        // TODO: Remove ToList, see #19710
-        var commands = migrationCommands.ToList();
-        var userTransaction = connection.CurrentTransaction;
-        if (userTransaction is not null
-            && (commands.Any(x => x.TransactionSuppressed) || executionStrategy.RetriesOnFailure))
+        var inUserTransaction = connection.CurrentTransaction is not null && executionState.Transaction == null;
+        if (inUserTransaction
+            && (migrationCommands.Any(x => x.TransactionSuppressed) || executionStrategy.RetriesOnFailure))
         {
             throw new NotSupportedException(RelationalStrings.TransactionSuppressedMigrationInUserTransaction);
         }
 
-        using (new TransactionScope(TransactionScopeOption.Suppress, TransactionScopeAsyncFlowOption.Enabled))
-        {
-            var parameters = new ExecuteParameters(commands, connection);
-            if (userTransaction is null)
-            {
-                executionStrategy.Execute(parameters, static (_, p) => Execute(p, beginTransaction: true), verifySucceeded: null);
-            }
-            else
-            {
-                Execute(parameters, beginTransaction: false);
-            }
-        }
+        using var transactionScope = new TransactionScope(TransactionScopeOption.Suppress, TransactionScopeAsyncFlowOption.Enabled);
+
+        return executionStrategy.Execute(
+            (migrationCommands, connection, inUserTransaction, executionState, commitTransaction, isolationLevel),
+            static (_, s) => Execute(
+                s.migrationCommands,
+                s.connection,
+                s.executionState,
+                beginTransaction: !s.inUserTransaction,
+                commitTransaction: !s.inUserTransaction && s.commitTransaction,
+                s.isolationLevel),
+            verifySucceeded: null);
     }
 
-    private static bool Execute(ExecuteParameters parameters, bool beginTransaction)
+    private static int Execute(
+        IReadOnlyList<MigrationCommand> migrationCommands,
+        IRelationalConnection connection,
+        MigrationExecutionState executionState,
+        bool beginTransaction,
+        bool commitTransaction,
+        System.Data.IsolationLevel? isolationLevel)
     {
-        var migrationCommands = parameters.MigrationCommands;
-        var connection = parameters.Connection;
-        IDbContextTransaction? transaction = null;
-        connection.Open();
+        var result = 0;
+        var connectionOpened = connection.Open();
+        Check.DebugAssert(!connectionOpened || executionState.Transaction == null,
+            "executionState.Transaction should be null");
+
         try
         {
-            for (var i = parameters.CurrentCommandIndex; i < migrationCommands.Count; i++)
+            for (var i = executionState.LastCommittedCommandIndex; i < migrationCommands.Count; i++)
             {
                 var command = migrationCommands[i];
-                if (transaction == null
+                if (executionState.Transaction == null
                     && !command.TransactionSuppressed
                     && beginTransaction)
                 {
-                    transaction = connection.BeginTransaction();
+                    executionState.Transaction = isolationLevel == null
+                        ? connection.BeginTransaction()
+                        : connection.BeginTransaction(isolationLevel.Value);
+                    if (executionState.DatabaseLock != null)
+                    {
+                        executionState.DatabaseLock = executionState.DatabaseLock.ReacquireIfNeeded(
+                            connectionOpened, transactionRestarted: true);
+                        connectionOpened = false;
+                    }
                 }
 
-                if (transaction != null
+                if (executionState.Transaction != null
                     && command.TransactionSuppressed)
                 {
-                    transaction.Commit();
-                    transaction.Dispose();
-                    transaction = null;
-                    parameters.CurrentCommandIndex = i;
+                    executionState.Transaction.Commit();
+                    executionState.Transaction.Dispose();
+                    executionState.Transaction = null;
+                    executionState.LastCommittedCommandIndex = i;
+                    executionState.AnyOperationPerformed = true;
+
+                    if (executionState.DatabaseLock != null)
+                    {
+                        executionState.DatabaseLock = executionState.DatabaseLock.ReacquireIfNeeded(
+                            connectionOpened, transactionRestarted: null);
+                        connectionOpened = false;
+                    }
                 }
 
-                command.ExecuteNonQuery(connection);
+                result = command.ExecuteNonQuery(connection);
 
-                if (transaction == null)
+                if (executionState.Transaction == null)
                 {
-                    parameters.CurrentCommandIndex = i + 1;
+                    executionState.LastCommittedCommandIndex = i + 1;
+                    executionState.AnyOperationPerformed = true;
                 }
             }
 
-            transaction?.Commit();
+            if (commitTransaction
+                && executionState.Transaction != null)
+            {
+                executionState.Transaction.Commit();
+                executionState.Transaction.Dispose();
+                executionState.Transaction = null;
+            }
         }
-        finally
+        catch
         {
-            transaction?.Dispose();
+            executionState.Transaction?.Dispose();
+            executionState.Transaction = null;
             connection.Close();
+            throw;
         }
 
-        return true;
+        connection.Close();
+        return result;
     }
 
     /// <summary>
@@ -104,95 +150,136 @@ private static bool Execute(ExecuteParameters parameters, bool beginTransaction)
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    public virtual async Task ExecuteNonQueryAsync(
+    public virtual Task ExecuteNonQueryAsync(
         IEnumerable<MigrationCommand> migrationCommands,
         IRelationalConnection connection,
         CancellationToken cancellationToken = default)
+        => ExecuteNonQueryAsync(
+            migrationCommands.ToList(), connection, new MigrationExecutionState(), commitTransaction: true, System.Data.IsolationLevel.Unspecified, cancellationToken);
+    
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual async Task<int> ExecuteNonQueryAsync(
+        IReadOnlyList<MigrationCommand> migrationCommands,
+        IRelationalConnection connection,
+        MigrationExecutionState executionState,
+        bool commitTransaction,
+        System.Data.IsolationLevel? isolationLevel = null,
+        CancellationToken cancellationToken = default)
     {
-        var commands = migrationCommands.ToList();
-        var userTransaction = connection.CurrentTransaction;
-        if (userTransaction is not null
-            && (commands.Any(x => x.TransactionSuppressed) || executionStrategy.RetriesOnFailure))
+        var inUserTransaction = connection.CurrentTransaction is not null && executionState.Transaction == null;
+        if (inUserTransaction
+            && (migrationCommands.Any(x => x.TransactionSuppressed) || executionStrategy.RetriesOnFailure))
         {
             throw new NotSupportedException(RelationalStrings.TransactionSuppressedMigrationInUserTransaction);
         }
 
         using var transactionScope = new TransactionScope(TransactionScopeOption.Suppress, TransactionScopeAsyncFlowOption.Enabled);
 
-        var parameters = new ExecuteParameters(commands, connection);
-        if (userTransaction is null)
-        {
-            await executionStrategy.ExecuteAsync(
-                parameters,
-                static (_, p, ct) => ExecuteAsync(p, beginTransaction: true, ct),
-                verifySucceeded: null,
-                cancellationToken).ConfigureAwait(false);
-        }
-        else
-        {
-            await ExecuteAsync(parameters, beginTransaction: false, cancellationToken).ConfigureAwait(false);
-        }
+        return await executionStrategy.ExecuteAsync(
+            (migrationCommands, connection, inUserTransaction, executionState, commitTransaction, isolationLevel),
+            static (_, s, ct) => ExecuteAsync(
+                s.migrationCommands,
+                s.connection,
+                s.executionState,
+                beginTransaction: !s.inUserTransaction,
+                commitTransaction: !s.inUserTransaction && s.commitTransaction,
+                s.isolationLevel,
+                ct),
+            verifySucceeded: null,
+            cancellationToken).ConfigureAwait(false);
     }
 
-    private static async Task<bool> ExecuteAsync(ExecuteParameters parameters, bool beginTransaction, CancellationToken cancellationToken)
+    private static async Task<int> ExecuteAsync(
+        IReadOnlyList<MigrationCommand> migrationCommands,
+        IRelationalConnection connection,
+        MigrationExecutionState executionState,
+        bool beginTransaction,
+        bool commitTransaction,
+        System.Data.IsolationLevel? isolationLevel,
+        CancellationToken cancellationToken)
     {
-        var migrationCommands = parameters.MigrationCommands;
-        var connection = parameters.Connection;
-        IDbContextTransaction? transaction = null;
-        await connection.OpenAsync(cancellationToken).ConfigureAwait(false);
+        var result = 0;
+        var connectionOpened = await connection.OpenAsync(cancellationToken).ConfigureAwait(false);
+        Check.DebugAssert(!connectionOpened || executionState.Transaction == null,
+            "executionState.Transaction should be null");
+
         try
         {
-            for (var i = parameters.CurrentCommandIndex; i < migrationCommands.Count; i++)
+            for (var i = executionState.LastCommittedCommandIndex; i < migrationCommands.Count; i++)
             {
+                var lockReacquired = false;
                 var command = migrationCommands[i];
-                if (transaction == null
+                if (executionState.Transaction == null
                     && !command.TransactionSuppressed
                     && beginTransaction)
                 {
-                    transaction = await connection.BeginTransactionAsync(cancellationToken)
+                    executionState.Transaction = await (isolationLevel == null
+                        ? connection.BeginTransactionAsync(cancellationToken)
+                        : connection.BeginTransactionAsync(isolationLevel.Value, cancellationToken))
                         .ConfigureAwait(false);
+
+                    if (executionState.DatabaseLock != null)
+                    {
+                        executionState.DatabaseLock = await executionState.DatabaseLock.ReacquireIfNeededAsync(
+                            connectionOpened, transactionRestarted: true, cancellationToken)
+                            .ConfigureAwait(false);
+                        lockReacquired = true;
+                    }
                 }
 
-                if (transaction != null
+                if (executionState.Transaction != null
                     && command.TransactionSuppressed)
                 {
-                    await transaction.CommitAsync(cancellationToken).ConfigureAwait(false);
-                    await transaction.DisposeAsync().ConfigureAwait(false);
-                    transaction = null;
-                    parameters.CurrentCommandIndex = i;
+                    await executionState.Transaction.CommitAsync(cancellationToken).ConfigureAwait(false);
+                    await executionState.Transaction.DisposeAsync().ConfigureAwait(false);
+                    executionState.Transaction = null;
+                    executionState.LastCommittedCommandIndex = i;
+                    executionState.AnyOperationPerformed = true;
+
+                    if (executionState.DatabaseLock != null
+                        && !lockReacquired)
+                    {
+                        executionState.DatabaseLock = await executionState.DatabaseLock.ReacquireIfNeededAsync(
+                            connectionOpened, transactionRestarted: null, cancellationToken)
+                            .ConfigureAwait(false);
+                    }
                 }
 
-                await command.ExecuteNonQueryAsync(connection, cancellationToken: cancellationToken)
+                result = await command.ExecuteNonQueryAsync(connection, cancellationToken: cancellationToken)
                     .ConfigureAwait(false);
 
-                if (transaction == null)
+                if (executionState.Transaction == null)
                 {
-                    parameters.CurrentCommandIndex = i + 1;
+                    executionState.LastCommittedCommandIndex = i + 1;
+                    executionState.AnyOperationPerformed = true;
                 }
             }
 
-            if (transaction != null)
+            if (commitTransaction
+                && executionState.Transaction != null)
             {
-                await transaction.CommitAsync(cancellationToken).ConfigureAwait(false);
+                await executionState.Transaction.CommitAsync(cancellationToken).ConfigureAwait(false);
+                await executionState.Transaction.DisposeAsync().ConfigureAwait(false);
+                executionState.Transaction = null;
             }
         }
-        finally
+        catch
         {
-            if (transaction != null)
+            if (executionState.Transaction != null)
             {
-                await transaction.DisposeAsync().ConfigureAwait(false);
+                await executionState.Transaction.DisposeAsync().ConfigureAwait(false);
+                executionState.Transaction = null;
             }
-
             await connection.CloseAsync().ConfigureAwait(false);
+            throw;
         }
 
-        return true;
-    }
-
-    private sealed class ExecuteParameters(List<MigrationCommand> migrationCommands, IRelationalConnection connection)
-    {
-        public int CurrentCommandIndex;
-        public List<MigrationCommand> MigrationCommands { get; } = migrationCommands;
-        public IRelationalConnection Connection { get; } = connection;
+        await connection.CloseAsync().ConfigureAwait(false);
+        return result;
     }
 }
diff --git a/src/EFCore.Relational/Migrations/Internal/Migrator.cs b/src/EFCore.Relational/Migrations/Internal/Migrator.cs
index c10cdd105c..a6644ef6fc 100644
--- a/src/EFCore.Relational/Migrations/Internal/Migrator.cs
+++ b/src/EFCore.Relational/Migrations/Internal/Migrator.cs
@@ -1,6 +1,7 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using System.Transactions;
 using Microsoft.EntityFrameworkCore.Diagnostics.Internal;
 
 namespace Microsoft.EntityFrameworkCore.Migrations.Internal;
@@ -29,6 +30,7 @@ public class Migrator : IMigrator
     private readonly IDesignTimeModel _designTimeModel;
     private readonly string _activeProvider;
     private readonly IDbContextOptions _contextOptions;
+    private readonly IExecutionStrategy _executionStrategy;
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
@@ -52,7 +54,8 @@ public class Migrator : IMigrator
         IDatabaseProvider databaseProvider,
         IMigrationsModelDiffer migrationsModelDiffer,
         IDesignTimeModel designTimeModel,
-        IDbContextOptions contextOptions)
+        IDbContextOptions contextOptions,
+        IExecutionStrategy executionStrategy)
     {
         _migrationsAssembly = migrationsAssembly;
         _historyRepository = historyRepository;
@@ -70,8 +73,17 @@ public class Migrator : IMigrator
         _designTimeModel = designTimeModel;
         _activeProvider = databaseProvider.Name;
         _contextOptions = contextOptions;
+        _executionStrategy = executionStrategy;
     }
 
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    protected virtual System.Data.IsolationLevel? MigrationTransactionIsolationLevel => null;
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -80,29 +92,90 @@ public class Migrator : IMigrator
     /// </summary>
     public virtual void Migrate(string? targetMigration)
     {
+        var useTransaction = _connection.CurrentTransaction is null;
+        if (!useTransaction
+            && _executionStrategy.RetriesOnFailure)
+        {
+            throw new NotSupportedException(RelationalStrings.TransactionSuppressedMigrationInUserTransaction);
+        }
+
         if (RelationalResources.LogPendingModelChanges(_logger).WarningBehavior != WarningBehavior.Ignore
             && HasPendingModelChanges())
         {
             _logger.PendingModelChangesWarning(_currentContext.Context.GetType());
         }
 
+        if (!useTransaction)
+        {
+            _logger.MigrationsUserTransactionWarning();
+        }
+
         _logger.MigrateUsingConnection(this, _connection);
 
+        using var transactionScope = new TransactionScope(TransactionScopeOption.Suppress, TransactionScopeAsyncFlowOption.Enabled);
+
         if (!_databaseCreator.Exists())
         {
             _databaseCreator.Create();
         }
 
+        _connection.Open();
         try
         {
-            _connection.Open();
+            var state = new MigrationExecutionState();
+            if (_historyRepository.LockReleaseBehavior != LockReleaseBehavior.Transaction
+                && useTransaction)
+            {
+                state.DatabaseLock = _historyRepository.AcquireDatabaseLock();
+            }
 
-            _logger.AcquiringMigrationLock();
-            using var _ = _historyRepository.GetDatabaseLock();
+            _executionStrategy.Execute(
+                this,
+                static (_, migrator) =>
+                {
+                    migrator._connection.Open();
+                    try
+                    {
+                        return migrator._historyRepository.CreateIfNotExists();
+                    }
+                    finally
+                    {
+                        migrator._connection.Close();
+                    }
+                },
+                verifySucceeded: null);
+
+            _executionStrategy.Execute(
+                (Migrator: this,
+                TargetMigration: targetMigration,
+                State: state,
+                UseTransaction: useTransaction),
+                static (c, s) => s.Migrator.MigrateImplementation(c, s.TargetMigration, s.State, s.UseTransaction),
+                static (_, s) => new ExecutionResult<bool>(
+                    successful: s.Migrator.VerifyMigrationSucceeded(s.TargetMigration, s.State),
+                    result: true));
+        }
+        finally
+        {
+            _connection.Close();
+        }
+    }
 
-            if (!_historyRepository.Exists())
+    private bool MigrateImplementation(
+        DbContext context, string? targetMigration, MigrationExecutionState state, bool useTransaction)
+    {
+        var connectionOpened = _connection.Open();
+        try
+        {
+            if (useTransaction)
             {
-                _historyRepository.Create();
+                state.Transaction = MigrationTransactionIsolationLevel == null
+                    ? _connection.BeginTransaction()
+                    : _connection.BeginTransaction(MigrationTransactionIsolationLevel.Value);
+
+                state.DatabaseLock = state.DatabaseLock == null
+                    ? _historyRepository.AcquireDatabaseLock()
+                    : state.DatabaseLock.ReacquireIfNeeded(connectionOpened, useTransaction);
             }
 
             PopulateMigrations(
@@ -113,7 +186,15 @@ public virtual void Migrate(string? targetMigration)
             var commandLists = GetMigrationCommandLists(migratorData);
             foreach (var commandList in commandLists)
             {
-                _migrationCommandExecutor.ExecuteNonQuery(commandList(), _connection);
+                var (id, getCommands) = commandList;
+                if (id != state.CurrentMigrationId)
+                {
+                    state.CurrentMigrationId = id;
+                    state.LastCommittedCommandIndex = 0;
+                }
+
+                _migrationCommandExecutor.ExecuteNonQuery(
+                    getCommands(), _connection, state, commitTransaction: false, MigrationTransactionIsolationLevel);
             }
 
             var coreOptionsExtension =
@@ -123,20 +204,22 @@ public virtual void Migrate(string? targetMigration)
             var seed = coreOptionsExtension.Seeder;
             if (seed != null)
             {
-                var context = _currentContext.Context;
-                var operationsPerformed = migratorData.AppliedMigrations.Count != 0
-                    || migratorData.RevertedMigrations.Count != 0;
-                using var transaction = context.Database.BeginTransaction();
-                seed(context, operationsPerformed);
-                transaction.Commit();
+                seed(context, state.AnyOperationPerformed);
             }
             else if (coreOptionsExtension.AsyncSeeder != null)
             {
                 throw new InvalidOperationException(CoreStrings.MissingSeeder);
             }
+
+            state.Transaction?.Commit();
+            return state.AnyOperationPerformed;
         }
         finally
         {
+            state.DatabaseLock?.Dispose();
+            state.DatabaseLock = null;
+            state.Transaction?.Dispose();
+            state.Transaction = null;
             _connection.Close();
         }
     }
@@ -151,30 +234,96 @@ public virtual void Migrate(string? targetMigration)
         string? targetMigration,
         CancellationToken cancellationToken = default)
     {
+        var useTransaction = _connection.CurrentTransaction is null;
+        if (!useTransaction
+            && _executionStrategy.RetriesOnFailure)
+        {
+            throw new NotSupportedException(RelationalStrings.TransactionSuppressedMigrationInUserTransaction);
+        }
+
         if (RelationalResources.LogPendingModelChanges(_logger).WarningBehavior != WarningBehavior.Ignore
             && HasPendingModelChanges())
         {
             _logger.PendingModelChangesWarning(_currentContext.Context.GetType());
         }
 
+        if (!useTransaction)
+        {
+            _logger.MigrationsUserTransactionWarning();
+        }
+
         _logger.MigrateUsingConnection(this, _connection);
 
+        using var transactionScope = new TransactionScope(TransactionScopeOption.Suppress, TransactionScopeAsyncFlowOption.Enabled);
+
         if (!await _databaseCreator.ExistsAsync(cancellationToken).ConfigureAwait(false))
         {
             await _databaseCreator.CreateAsync(cancellationToken).ConfigureAwait(false);
         }
 
+        await _connection.OpenAsync(cancellationToken).ConfigureAwait(false);
         try
         {
-            await _connection.OpenAsync(cancellationToken).ConfigureAwait(false);
+            var state = new MigrationExecutionState();
+            if (_historyRepository.LockReleaseBehavior != LockReleaseBehavior.Transaction
+                && useTransaction)
+            {
+                state.DatabaseLock = await _historyRepository.AcquireDatabaseLockAsync(cancellationToken).ConfigureAwait(false);
+            }
 
-            _logger.AcquiringMigrationLock();
-            var dbLock = await _historyRepository.GetDatabaseLockAsync(cancellationToken).ConfigureAwait(false);
-            await using var _ = dbLock.ConfigureAwait(false);
+            await _executionStrategy.ExecuteAsync(
+                this,
+                static async (_, migrator, ct) =>
+                {
+                    await migrator._connection.OpenAsync(ct).ConfigureAwait(false);
+                    try
+                    {
+                        return await migrator._historyRepository.CreateIfNotExistsAsync(ct).ConfigureAwait(false);
+                    }
+                    finally
+                    {
+                        await migrator._connection.CloseAsync().ConfigureAwait(false);
+                    }
+                },
+                verifySucceeded: null,
+                cancellationToken).ConfigureAwait(false);
+
+            await _executionStrategy.ExecuteAsync(
+                (Migrator: this,
+                TargetMigration: targetMigration,
+                State: state,
+                UseTransaction: useTransaction),
+                async static (c, s, ct) => await s.Migrator.MigrateImplementationAsync(
+                    c, s.TargetMigration, s.State, s.UseTransaction, ct).ConfigureAwait(false),
+                async static (_, s, ct) => new ExecutionResult<bool>(
+                    successful: await s.Migrator.VerifyMigrationSucceededAsync(s.TargetMigration, s.State, ct).ConfigureAwait(false),
+                    result: true),
+                cancellationToken)
+                .ConfigureAwait(false);
+        }
+        finally
+        {
+            await _connection.CloseAsync().ConfigureAwait(false);
+        }
+    }
 
-            if (!await _historyRepository.ExistsAsync(cancellationToken).ConfigureAwait(false))
+    private async Task<bool> MigrateImplementationAsync(
+        DbContext context, string? targetMigration, MigrationExecutionState state, bool useTransaction, CancellationToken cancellationToken = default)
+    {
+        var connectionOpened = await _connection.OpenAsync(cancellationToken).ConfigureAwait(false);
+        try
+        {
+            if (useTransaction)
             {
-                await _historyRepository.CreateAsync(cancellationToken).ConfigureAwait(false);
+                state.Transaction = await (MigrationTransactionIsolationLevel == null
+                    ? context.Database.BeginTransactionAsync(cancellationToken)
+                    : context.Database.BeginTransactionAsync(MigrationTransactionIsolationLevel.Value, cancellationToken))
+                        .ConfigureAwait(false);
+
+                state.DatabaseLock = state.DatabaseLock == null
+                    ? await _historyRepository.AcquireDatabaseLockAsync(cancellationToken).ConfigureAwait(false)
+                    : await state.DatabaseLock.ReacquireIfNeededAsync(connectionOpened, useTransaction, cancellationToken)
+                        .ConfigureAwait(false);
             }
 
             PopulateMigrations(
@@ -185,7 +334,15 @@ public virtual void Migrate(string? targetMigration)
             var commandLists = GetMigrationCommandLists(migratorData);
             foreach (var commandList in commandLists)
             {
-                await _migrationCommandExecutor.ExecuteNonQueryAsync(commandList(), _connection, cancellationToken)
+                var (id, getCommands) = commandList;
+                if (id != state.CurrentMigrationId)
+                {
+                    state.CurrentMigrationId = id;
+                    state.LastCommittedCommandIndex = 0;
+                }
+
+                await _migrationCommandExecutor.ExecuteNonQueryAsync(
+                    getCommands(), _connection, state, commitTransaction: false, MigrationTransactionIsolationLevel, cancellationToken)
                     .ConfigureAwait(false);
             }
 
@@ -196,26 +353,36 @@ await _migrationCommandExecutor.ExecuteNonQueryAsync(commandList(), _connection,
             var seedAsync = coreOptionsExtension.AsyncSeeder;
             if (seedAsync != null)
             {
-                var context = _currentContext.Context;
-                var operationsPerformed = migratorData.AppliedMigrations.Count != 0
-                    || migratorData.RevertedMigrations.Count != 0;
-                var transaction = await context.Database.BeginTransactionAsync(cancellationToken).ConfigureAwait(false);
-                await using var __ = transaction.ConfigureAwait(false);
-                await seedAsync(context, operationsPerformed, cancellationToken).ConfigureAwait(false);
-                await transaction.CommitAsync(cancellationToken).ConfigureAwait(false);
+                await seedAsync(context, state.AnyOperationPerformed, cancellationToken).ConfigureAwait(false);
             }
             else if (coreOptionsExtension.Seeder != null)
             {
                 throw new InvalidOperationException(CoreStrings.MissingSeeder);
             }
+
+            if (state.Transaction != null)
+            {
+                await state.Transaction.CommitAsync(cancellationToken).ConfigureAwait(false);
+            }
+            return state.AnyOperationPerformed;
         }
         finally
         {
-            _connection.Close();
+            if (state.DatabaseLock != null)
+            {
+                state.DatabaseLock.Dispose();
+                state.DatabaseLock = null;
+            }
+            if (state.Transaction != null)
+            {
+                await state.Transaction.DisposeAsync().ConfigureAwait(false);
+                state.Transaction = null;
+            }
+            await _connection.CloseAsync().ConfigureAwait(false);
         }
     }
 
-    private IEnumerable<Func<IReadOnlyList<MigrationCommand>>> GetMigrationCommandLists(MigratorData parameters)
+    private IEnumerable<(string, Func<IReadOnlyList<MigrationCommand>>)> GetMigrationCommandLists(MigratorData parameters)
     {
         var migrationsToApply = parameters.AppliedMigrations;
         var migrationsToRevert = parameters.RevertedMigrations;
@@ -226,7 +393,7 @@ private IEnumerable<Func<IReadOnlyList<MigrationCommand>>> GetMigrationCommandLi
             var migration = migrationsToRevert[i];
 
             var index = i;
-            yield return () =>
+            yield return (migration.GetId(), () =>
             {
                 _logger.MigrationReverting(this, migration);
 
@@ -242,12 +409,12 @@ private IEnumerable<Func<IReadOnlyList<MigrationCommand>>> GetMigrationCommandLi
                 }
 
                 return commands;
-            };
+            });
         }
 
         foreach (var migration in migrationsToApply)
         {
-            yield return () =>
+            yield return (migration.GetId(), () =>
             {
                 _logger.MigrationApplying(this, migration);
 
@@ -259,7 +426,7 @@ private IEnumerable<Func<IReadOnlyList<MigrationCommand>>> GetMigrationCommandLi
                 }
 
                 return commands;
-            };
+            });
         }
 
         if (migrationsToRevert.Count + migrationsToApply.Count == 0)
@@ -340,6 +507,26 @@ private IEnumerable<Func<IReadOnlyList<MigrationCommand>>> GetMigrationCommandLi
         parameters = new MigratorData(migrationsToApply, migrationsToRevert, actualTargetMigration);
     }
 
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    protected virtual bool VerifyMigrationSucceeded(
+        string? targetMigration, MigrationExecutionState state)
+        => false;
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    protected virtual Task<bool> VerifyMigrationSucceededAsync(
+        string? targetMigration, MigrationExecutionState state, CancellationToken cancellationToken)
+        => Task.FromResult(false);
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
diff --git a/src/EFCore.Relational/Migrations/LockReleaseBehavior.cs b/src/EFCore.Relational/Migrations/LockReleaseBehavior.cs
new file mode 100644
index 0000000000..bd1f96e995
--- /dev/null
+++ b/src/EFCore.Relational/Migrations/LockReleaseBehavior.cs
@@ -0,0 +1,25 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.EntityFrameworkCore.Migrations;
+
+/// <summary>
+///     Represents the conditions under which a lock is released implicitly.
+/// </summary>
+public enum LockReleaseBehavior
+{
+    /// <summary>
+    ///     The lock is released when the transaction is committed or rolled back.
+    /// </summary>
+    Transaction,
+
+    /// <summary>
+    ///     The lock is released when the connection is closed.
+    /// </summary>
+    Connection,
+
+    /// <summary>
+    ///     The lock can only be released explicitly.
+    /// </summary>
+    Explicit
+}
diff --git a/src/EFCore.Relational/Migrations/MigrationExecutionState.cs b/src/EFCore.Relational/Migrations/MigrationExecutionState.cs
new file mode 100644
index 0000000000..accd83e0cf
--- /dev/null
+++ b/src/EFCore.Relational/Migrations/MigrationExecutionState.cs
@@ -0,0 +1,35 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.EntityFrameworkCore.Migrations;
+
+/// <summary>
+///     Contains the state of the current migration execution.
+/// </summary>
+public sealed class MigrationExecutionState
+{
+    /// <summary>
+    ///     The index of the last command that was committed to the database.
+    /// </summary>
+    public int LastCommittedCommandIndex { get; set; }
+
+    /// <summary>
+    ///     The id the migration that is currently being applied.
+    /// </summary>
+    public string? CurrentMigrationId { get; set; }
+
+    /// <summary>
+    ///    Indicates whether any migration operation was performed.
+    /// </summary>
+    public bool AnyOperationPerformed { get; set; }
+
+    /// <summary>
+    ///     The database lock that is in use.
+    /// </summary>
+    public IMigrationsDatabaseLock? DatabaseLock { get; set; }
+
+    /// <summary>
+    ///     The transaction that is in use.
+    /// </summary>
+    public IDbContextTransaction? Transaction { get; set; }
+}
diff --git a/src/EFCore.Relational/Properties/RelationalStrings.Designer.cs b/src/EFCore.Relational/Properties/RelationalStrings.Designer.cs
index c235048025..731c62c4ec 100644
--- a/src/EFCore.Relational/Properties/RelationalStrings.Designer.cs
+++ b/src/EFCore.Relational/Properties/RelationalStrings.Designer.cs
@@ -2130,7 +2130,7 @@ public static string UnsupportedOperatorForSqlExpression(object? nodeType, objec
                 nodeType, expressionType);
 
         /// <summary>
-        ///     No relational type mapping can be found for property '{entity}.{property}' and the current provider doesn't specify a default store type for the properties of type '{clrType}'.
+        ///     No relational type mapping can be found for property '{entity}.{property}' and the current provider doesn't specify a default store type for the properties of type '{clrType}'. 
         /// </summary>
         public static string UnsupportedPropertyType(object? entity, object? property, object? clrType)
             => string.Format(
@@ -2256,7 +2256,7 @@ public static class RelationalResources
             = new ResourceManager("Microsoft.EntityFrameworkCore.Properties.RelationalStrings", typeof(RelationalResources).Assembly);
 
         /// <summary>
-        ///     Acquiring an exclusive lock for migration application. See https://aka.ms/efcore-docs-migrations for more information if this takes too long.
+        ///     Acquiring an exclusive lock for migration application. See https://aka.ms/efcore-docs-migrations-lock for more information if this takes too long.
         /// </summary>
         public static EventDefinition LogAcquiringMigrationLock(IDiagnosticsLogger logger)
         {
@@ -3424,6 +3424,31 @@ public static EventDefinition<string> LogMigrationAttributeMissingWarning(IDiagn
             return (EventDefinition<string>)definition;
         }
 
+        /// <summary>
+        ///     A transaction was started before applying migrations. This prevents a database lock to be acquired and hence the database will not be protected from concurrent migration applications. The transactions and execution strategy are already managed by EF as needed. Remove the external transaction.
+        /// </summary>
+        public static EventDefinition LogMigrationsUserTransaction(IDiagnosticsLogger logger)
+        {
+            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogMigrationsUserTransactionWarning;
+            if (definition == null)
+            {
+                definition = NonCapturingLazyInitializer.EnsureInitialized(
+                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogMigrationsUserTransactionWarning,
+                    logger,
+                    static logger => new EventDefinition(
+                        logger.Options,
+                        RelationalEventId.MigrationsUserTransactionWarning,
+                        LogLevel.Warning,
+                        "RelationalEventId.MigrationsUserTransactionWarning",
+                        level => LoggerMessage.Define(
+                            level,
+                            RelationalEventId.MigrationsUserTransactionWarning,
+                            _resourceManager.GetString("LogMigrationsUserTransaction")!)));
+            }
+
+            return (EventDefinition)definition;
+        }
+
         /// <summary>
         ///     Compiling a query which loads related collections for more than one collection navigation, either via 'Include' or through projection, but no 'QuerySplittingBehavior' has been configured. By default, Entity Framework will use 'QuerySplittingBehavior.SingleQuery', which can potentially result in slow query performance. See https://go.microsoft.com/fwlink/?linkid=2134277 for more information. To identify the query that's triggering this warning call 'ConfigureWarnings(w =&gt; w.Throw(RelationalEventId.MultipleCollectionIncludeWarning))'.
         /// </summary>
diff --git a/src/EFCore.Relational/Properties/RelationalStrings.resx b/src/EFCore.Relational/Properties/RelationalStrings.resx
index d6390b417f..104daf9daf 100644
--- a/src/EFCore.Relational/Properties/RelationalStrings.resx
+++ b/src/EFCore.Relational/Properties/RelationalStrings.resx
@@ -1,17 +1,17 @@
 <?xml version="1.0" encoding="utf-8"?>
 <root>
-  <!--
-    Microsoft ResX Schema
-
+  <!-- 
+    Microsoft ResX Schema 
+    
     Version 2.0
-
-    The primary goals of this format is to allow a simple XML format
-    that is mostly human readable. The generation and parsing of the
-    various data types are done through the TypeConverter classes
+    
+    The primary goals of this format is to allow a simple XML format 
+    that is mostly human readable. The generation and parsing of the 
+    various data types are done through the TypeConverter classes 
     associated with the data types.
-
+    
     Example:
-
+    
     ... ado.net/XML headers & schema ...
     <resheader name="resmimetype">text/microsoft-resx</resheader>
     <resheader name="version">2.0</resheader>
@@ -26,36 +26,36 @@
         <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
         <comment>This is a comment</comment>
     </data>
-
-    There are any number of "resheader" rows that contain simple
+                
+    There are any number of "resheader" rows that contain simple 
     name/value pairs.
-
-    Each data row contains a name, and value. The row also contains a
-    type or mimetype. Type corresponds to a .NET class that support
-    text/value conversion through the TypeConverter architecture.
-    Classes that don't support this are serialized and stored with the
+    
+    Each data row contains a name, and value. The row also contains a 
+    type or mimetype. Type corresponds to a .NET class that support 
+    text/value conversion through the TypeConverter architecture. 
+    Classes that don't support this are serialized and stored with the 
     mimetype set.
-
-    The mimetype is used for serialized objects, and tells the
-    ResXResourceReader how to depersist the object. This is currently not
+    
+    The mimetype is used for serialized objects, and tells the 
+    ResXResourceReader how to depersist the object. This is currently not 
     extensible. For a given mimetype the value must be set accordingly:
-
-    Note - application/x-microsoft.net.object.binary.base64 is the format
-    that the ResXResourceWriter will generate, however the reader can
+    
+    Note - application/x-microsoft.net.object.binary.base64 is the format 
+    that the ResXResourceWriter will generate, however the reader can 
     read any of the formats listed below.
-
+    
     mimetype: application/x-microsoft.net.object.binary.base64
-    value   : The object must be serialized with
+    value   : The object must be serialized with 
             : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
             : and then encoded with base64 encoding.
-
+    
     mimetype: application/x-microsoft.net.object.soap.base64
-    value   : The object must be serialized with
+    value   : The object must be serialized with 
             : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
             : and then encoded with base64 encoding.
 
     mimetype: application/x-microsoft.net.object.bytearray.base64
-    value   : The object must be serialized into a byte array
+    value   : The object must be serialized into a byte array 
             : using a System.ComponentModel.TypeConverter
             : and then encoded with base64 encoding.
     -->
@@ -786,6 +786,10 @@
     <value>A [Migration] attribute isn't specified on the '{class}' class.</value>
     <comment>Warning RelationalEventId.MigrationAttributeMissingWarning string</comment>
   </data>
+  <data name="LogMigrationsUserTransaction" xml:space="preserve">
+    <value>A transaction was started before applying migrations. This prevents a database lock to be acquired and hence the database will not be protected from concurrent migration applications. The transactions and execution strategy are already managed by EF as needed. Remove the external transaction.</value>
+    <comment>Warning RelationalEventId.MigrationsUserTransactionWarning</comment>
+  </data>
   <data name="LogMultipleCollectionIncludeWarning" xml:space="preserve">
     <value>Compiling a query which loads related collections for more than one collection navigation, either via 'Include' or through projection, but no 'QuerySplittingBehavior' has been configured. By default, Entity Framework will use 'QuerySplittingBehavior.SingleQuery', which can potentially result in slow query performance. See https://go.microsoft.com/fwlink/?linkid=2134277 for more information. To identify the query that's triggering this warning call 'ConfigureWarnings(w =&gt; w.Throw(RelationalEventId.MultipleCollectionIncludeWarning))'.</value>
     <comment>Warning RelationalEventId.MultipleCollectionIncludeWarning</comment>
diff --git a/src/EFCore.Relational/Storage/RelationalDatabaseCreator.cs b/src/EFCore.Relational/Storage/RelationalDatabaseCreator.cs
index ad6a2bcd7d..96f5ca0f76 100644
--- a/src/EFCore.Relational/Storage/RelationalDatabaseCreator.cs
+++ b/src/EFCore.Relational/Storage/RelationalDatabaseCreator.cs
@@ -116,7 +116,7 @@ public virtual Task DeleteAsync(CancellationToken cancellationToken = default)
     ///     to incrementally update the schema. It is assumed that none of the tables exist in the database.
     /// </summary>
     public virtual void CreateTables()
-        => Dependencies.MigrationCommandExecutor.ExecuteNonQuery(GetCreateTablesCommands(), Dependencies.Connection);
+        => Dependencies.MigrationCommandExecutor.ExecuteNonQuery(GetCreateTablesCommands(), Dependencies.Connection, new MigrationExecutionState(), commitTransaction: true);
 
     /// <summary>
     ///     Asynchronously creates all tables for the current model in the database. No attempt is made
@@ -129,7 +129,7 @@ public virtual void CreateTables()
     /// <exception cref="OperationCanceledException">If the <see cref="CancellationToken" /> is canceled.</exception>
     public virtual Task CreateTablesAsync(CancellationToken cancellationToken = default)
         => Dependencies.MigrationCommandExecutor.ExecuteNonQueryAsync(
-            GetCreateTablesCommands(), Dependencies.Connection, cancellationToken);
+            GetCreateTablesCommands(), Dependencies.Connection, new MigrationExecutionState(), commitTransaction: true, cancellationToken: cancellationToken);
 
     /// <summary>
     ///     Gets the commands that will create all tables from the model.
diff --git a/src/EFCore.SqlServer/Migrations/Internal/SqlServerHistoryRepository.cs b/src/EFCore.SqlServer/Migrations/Internal/SqlServerHistoryRepository.cs
index cc22d67fca..202c7a2c13 100644
--- a/src/EFCore.SqlServer/Migrations/Internal/SqlServerHistoryRepository.cs
+++ b/src/EFCore.SqlServer/Migrations/Internal/SqlServerHistoryRepository.cs
@@ -59,8 +59,18 @@ protected override bool InterpretExistsResult(object? value)
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    public override IDisposable GetDatabaseLock()
+    public override LockReleaseBehavior LockReleaseBehavior => LockReleaseBehavior.Connection;
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public override IMigrationsDatabaseLock AcquireDatabaseLock()
     {
+        Dependencies.MigrationsLogger.AcquiringMigrationLock();
+
         var dbLock = CreateMigrationDatabaseLock();
         int result;
         try
@@ -91,8 +101,10 @@ public override IDisposable GetDatabaseLock()
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    public override async Task<IAsyncDisposable> GetDatabaseLockAsync(CancellationToken cancellationToken = default)
+    public override async Task<IMigrationsDatabaseLock> AcquireDatabaseLockAsync(CancellationToken cancellationToken = default)
     {
+        Dependencies.MigrationsLogger.AcquiringMigrationLock();
+
         var dbLock = CreateMigrationDatabaseLock();
         int result;
         try
@@ -135,7 +147,8 @@ private SqlServerMigrationDatabaseLock CreateMigrationDatabaseLock()
 EXEC @result = sp_releaseapplock @Resource = '__EFMigrationsLock', @LockOwner = 'Session';
 SELECT @result
 """),
-            CreateRelationalCommandParameters());
+            CreateRelationalCommandParameters(),
+            this);
 
     private RelationalCommandParameterObject CreateRelationalCommandParameters()
         => new(
diff --git a/src/EFCore.SqlServer/Migrations/Internal/SqlServerMigrationDatabaseLock.cs b/src/EFCore.SqlServer/Migrations/Internal/SqlServerMigrationDatabaseLock.cs
index c102f6f970..b31ff90062 100644
--- a/src/EFCore.SqlServer/Migrations/Internal/SqlServerMigrationDatabaseLock.cs
+++ b/src/EFCore.SqlServer/Migrations/Internal/SqlServerMigrationDatabaseLock.cs
@@ -16,11 +16,20 @@ namespace Microsoft.EntityFrameworkCore.SqlServer.Migrations.Internal;
 ///     doing so can result in application failures when updating to a new Entity Framework Core release.
 /// </remarks>
 public class SqlServerMigrationDatabaseLock(
-    IRelationalCommand relationalCommand,
+    IRelationalCommand releaseLockCommand,
     RelationalCommandParameterObject relationalCommandParameters,
+    IHistoryRepository historyRepository,
     CancellationToken cancellationToken = default)
-    : IDisposable, IAsyncDisposable
+    : IMigrationsDatabaseLock
 {
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual IHistoryRepository HistoryRepository => historyRepository;
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -28,7 +37,7 @@ public class SqlServerMigrationDatabaseLock(
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
     public void Dispose()
-        => relationalCommand.ExecuteScalar(relationalCommandParameters);
+        => releaseLockCommand.ExecuteScalar(relationalCommandParameters);
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
@@ -37,5 +46,5 @@ public void Dispose()
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
     public async ValueTask DisposeAsync()
-        => await relationalCommand.ExecuteScalarAsync(relationalCommandParameters, cancellationToken).ConfigureAwait(false);
+        => await releaseLockCommand.ExecuteScalarAsync(relationalCommandParameters, cancellationToken).ConfigureAwait(false);
 }
diff --git a/src/EFCore.SqlServer/Storage/Internal/SqlServerDatabaseCreator.cs b/src/EFCore.SqlServer/Storage/Internal/SqlServerDatabaseCreator.cs
index 589440790a..e3f3fcdb83 100644
--- a/src/EFCore.SqlServer/Storage/Internal/SqlServerDatabaseCreator.cs
+++ b/src/EFCore.SqlServer/Storage/Internal/SqlServerDatabaseCreator.cs
@@ -14,26 +14,19 @@ namespace Microsoft.EntityFrameworkCore.SqlServer.Storage.Internal;
 ///     any release. You should only use it directly in your code with extreme caution and knowing that
 ///     doing so can result in application failures when updating to a new Entity Framework Core release.
 /// </summary>
-public class SqlServerDatabaseCreator : RelationalDatabaseCreator
+/// <remarks>
+///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+///     any release. You should only use it directly in your code with extreme caution and knowing that
+///     doing so can result in application failures when updating to a new Entity Framework Core release.
+/// </remarks>
+public class SqlServerDatabaseCreator(
+    RelationalDatabaseCreatorDependencies dependencies,
+    ISqlServerConnection connection,
+    IRawSqlCommandBuilder rawSqlCommandBuilder) : RelationalDatabaseCreator(dependencies)
 {
-    private readonly ISqlServerConnection _connection;
-    private readonly IRawSqlCommandBuilder _rawSqlCommandBuilder;
-
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public SqlServerDatabaseCreator(
-        RelationalDatabaseCreatorDependencies dependencies,
-        ISqlServerConnection connection,
-        IRawSqlCommandBuilder rawSqlCommandBuilder)
-        : base(dependencies)
-    {
-        _connection = connection;
-        _rawSqlCommandBuilder = rawSqlCommandBuilder;
-    }
+    private readonly ISqlServerConnection _connection = connection;
+    private readonly IRawSqlCommandBuilder _rawSqlCommandBuilder = rawSqlCommandBuilder;
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
@@ -62,7 +55,7 @@ public override void Create()
         using (var masterConnection = _connection.CreateMasterConnection())
         {
             Dependencies.MigrationCommandExecutor
-                .ExecuteNonQuery(CreateCreateOperations(), masterConnection);
+                .ExecuteNonQuery(CreateCreateOperations(), masterConnection, new MigrationExecutionState(), commitTransaction: true);
 
             ClearPool();
         }
@@ -82,7 +75,7 @@ public override async Task CreateAsync(CancellationToken cancellationToken = def
         await using (masterConnection.ConfigureAwait(false))
         {
             await Dependencies.MigrationCommandExecutor
-                .ExecuteNonQueryAsync(CreateCreateOperations(), masterConnection, cancellationToken)
+                .ExecuteNonQueryAsync(CreateCreateOperations(), masterConnection, new MigrationExecutionState(), commitTransaction: true, cancellationToken: cancellationToken)
                 .ConfigureAwait(false);
 
             ClearPool();
@@ -157,8 +150,7 @@ private IReadOnlyList<MigrationCommand> CreateCreateOperations()
     {
         var builder = new SqlConnectionStringBuilder(_connection.DbConnection.ConnectionString);
         return Dependencies.MigrationsSqlGenerator.Generate(
-            new[]
-            {
+            [
                 new SqlServerCreateDatabaseOperation
                 {
                     Name = builder.InitialCatalog,
@@ -166,7 +158,7 @@ private IReadOnlyList<MigrationCommand> CreateCreateOperations()
                     Collation = Dependencies.CurrentContext.Context.GetService<IDesignTimeModel>()
                         .Model.GetRelationalModel().Collation
                 }
-            });
+            ]);
     }
 
     /// <summary>
@@ -345,7 +337,7 @@ public override void Delete()
 
         using var masterConnection = _connection.CreateMasterConnection();
         Dependencies.MigrationCommandExecutor
-            .ExecuteNonQuery(CreateDropCommands(), masterConnection);
+            .ExecuteNonQuery(CreateDropCommands(), masterConnection, new MigrationExecutionState(), commitTransaction: true);
     }
 
     /// <summary>
@@ -361,7 +353,7 @@ public override async Task DeleteAsync(CancellationToken cancellationToken = def
         var masterConnection = _connection.CreateMasterConnection();
         await using var _ = masterConnection.ConfigureAwait(false);
         await Dependencies.MigrationCommandExecutor
-            .ExecuteNonQueryAsync(CreateDropCommands(), masterConnection, cancellationToken)
+            .ExecuteNonQueryAsync(CreateDropCommands(), masterConnection, new MigrationExecutionState(), commitTransaction: true, cancellationToken: cancellationToken)
             .ConfigureAwait(false);
     }
 
diff --git a/src/EFCore.Sqlite.Core/Migrations/Internal/SqliteHistoryRepository.cs b/src/EFCore.Sqlite.Core/Migrations/Internal/SqliteHistoryRepository.cs
index e346fd1e69..89d8fefc0c 100644
--- a/src/EFCore.Sqlite.Core/Migrations/Internal/SqliteHistoryRepository.cs
+++ b/src/EFCore.Sqlite.Core/Migrations/Internal/SqliteHistoryRepository.cs
@@ -103,11 +103,21 @@ public override string GetEndIfScript()
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    public override IDisposable GetDatabaseLock()
+    public override LockReleaseBehavior LockReleaseBehavior => LockReleaseBehavior.Explicit;
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public override IMigrationsDatabaseLock AcquireDatabaseLock()
     {
+        Dependencies.MigrationsLogger.AcquiringMigrationLock();
+
         if (!InterpretExistsResult(
-                Dependencies.RawSqlCommandBuilder.Build(CreateExistsSql(LockTableName))
-                    .ExecuteScalar(CreateRelationalCommandParameters())))
+            Dependencies.RawSqlCommandBuilder.Build(CreateExistsSql(LockTableName))
+                .ExecuteScalar(CreateRelationalCommandParameters())))
         {
             CreateLockTableCommand().ExecuteNonQuery(CreateRelationalCommandParameters());
         }
@@ -129,8 +139,6 @@ public override IDisposable GetDatabaseLock()
                 retryDelay = retryDelay.Add(retryDelay);
             }
         }
-
-        throw new TimeoutException();
     }
 
     /// <summary>
@@ -139,11 +147,14 @@ public override IDisposable GetDatabaseLock()
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    public override async Task<IAsyncDisposable> GetDatabaseLockAsync(CancellationToken cancellationToken = default)
+    public override async Task<IMigrationsDatabaseLock> AcquireDatabaseLockAsync(
+        CancellationToken cancellationToken = default)
     {
+        Dependencies.MigrationsLogger.AcquiringMigrationLock();
+
         if (!InterpretExistsResult(
-                await Dependencies.RawSqlCommandBuilder.Build(CreateExistsSql(LockTableName))
-                    .ExecuteScalarAsync(CreateRelationalCommandParameters(), cancellationToken).ConfigureAwait(false)))
+            await Dependencies.RawSqlCommandBuilder.Build(CreateExistsSql(LockTableName))
+                .ExecuteScalarAsync(CreateRelationalCommandParameters(), cancellationToken).ConfigureAwait(false)))
         {
             await CreateLockTableCommand().ExecuteNonQueryAsync(CreateRelationalCommandParameters(), cancellationToken)
                 .ConfigureAwait(false);
@@ -167,8 +178,6 @@ await CreateLockTableCommand().ExecuteNonQueryAsync(CreateRelationalCommandParam
                 retryDelay = retryDelay.Add(retryDelay);
             }
         }
-
-        throw new TimeoutException();
     }
 
     private IRelationalCommand CreateLockTableCommand()
@@ -206,7 +215,7 @@ private IRelationalCommand CreateDeleteLockCommand(int? id = null)
     }
 
     private SqliteMigrationDatabaseLock CreateMigrationDatabaseLock()
-        => new(CreateDeleteLockCommand(), CreateRelationalCommandParameters());
+        => new(CreateDeleteLockCommand(), CreateRelationalCommandParameters(), this);
 
     private RelationalCommandParameterObject CreateRelationalCommandParameters()
         => new(
diff --git a/src/EFCore.Sqlite.Core/Migrations/Internal/SqliteMigrationDatabaseLock.cs b/src/EFCore.Sqlite.Core/Migrations/Internal/SqliteMigrationDatabaseLock.cs
index 997cbcd471..668d2107ea 100644
--- a/src/EFCore.Sqlite.Core/Migrations/Internal/SqliteMigrationDatabaseLock.cs
+++ b/src/EFCore.Sqlite.Core/Migrations/Internal/SqliteMigrationDatabaseLock.cs
@@ -10,11 +10,20 @@ namespace Microsoft.EntityFrameworkCore.Sqlite.Migrations.Internal;
 ///     doing so can result in application failures when updating to a new Entity Framework Core release.
 /// </summary>
 public class SqliteMigrationDatabaseLock(
-    IRelationalCommand relationalCommand,
+    IRelationalCommand releaseLockCommand,
     RelationalCommandParameterObject relationalCommandParameters,
+    IHistoryRepository historyRepository,
     CancellationToken cancellationToken = default)
-    : IDisposable, IAsyncDisposable
+    : IMigrationsDatabaseLock
 {
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual IHistoryRepository HistoryRepository => historyRepository;
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -22,7 +31,7 @@ public class SqliteMigrationDatabaseLock(
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
     public void Dispose()
-        => relationalCommand.ExecuteScalar(relationalCommandParameters);
+        => releaseLockCommand.ExecuteScalar(relationalCommandParameters);
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
@@ -31,5 +40,5 @@ public void Dispose()
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
     public async ValueTask DisposeAsync()
-        => await relationalCommand.ExecuteScalarAsync(relationalCommandParameters, cancellationToken).ConfigureAwait(false);
+        => await releaseLockCommand.ExecuteScalarAsync(relationalCommandParameters, cancellationToken).ConfigureAwait(false);
 }
diff --git a/test/EFCore.Design.Tests/Design/DesignTimeServicesTest.cs b/test/EFCore.Design.Tests/Design/DesignTimeServicesTest.cs
index c2c58289d5..ee13f8d8c3 100644
--- a/test/EFCore.Design.Tests/Design/DesignTimeServicesTest.cs
+++ b/test/EFCore.Design.Tests/Design/DesignTimeServicesTest.cs
@@ -192,6 +192,8 @@ public bool IsValidId(string value)
 
     public class ExtensionHistoryRepository : IHistoryRepository
     {
+        public virtual LockReleaseBehavior LockReleaseBehavior => LockReleaseBehavior.Explicit;
+
         public void Create()
             => throw new NotImplementedException();
 
@@ -222,10 +224,10 @@ public string GetCreateIfNotExistsScript()
         public string GetCreateScript()
             => throw new NotImplementedException();
 
-        public IDisposable GetDatabaseLock()
+        public IMigrationsDatabaseLock AcquireDatabaseLock()
             => throw new NotImplementedException();
 
-        public Task<IAsyncDisposable> GetDatabaseLockAsync(CancellationToken cancellationToken = default)
+        public Task<IMigrationsDatabaseLock> AcquireDatabaseLockAsync(CancellationToken cancellationToken = default)
             => throw new NotImplementedException();
 
         public string GetDeleteScript(string migrationId)
@@ -264,6 +266,8 @@ public bool IsValidId(string value)
 
     public class ContextHistoryRepository : IHistoryRepository
     {
+        public virtual LockReleaseBehavior LockReleaseBehavior => LockReleaseBehavior.Explicit;
+
         public bool Exists()
             => throw new NotImplementedException();
 
@@ -294,10 +298,10 @@ public void Create()
         public Task CreateAsync(CancellationToken cancellationToken = default)
             => throw new NotImplementedException();
 
-        public IDisposable GetDatabaseLock()
+        public IMigrationsDatabaseLock AcquireDatabaseLock()
             => throw new NotImplementedException();
 
-        public Task<IAsyncDisposable> GetDatabaseLockAsync(CancellationToken cancellationToken = default)
+        public Task<IMigrationsDatabaseLock> AcquireDatabaseLockAsync(CancellationToken cancellationToken = default)
             => throw new NotImplementedException();
 
         public string GetDeleteScript(string migrationId)
diff --git a/test/EFCore.Design.Tests/Migrations/Design/MigrationScaffolderTest.cs b/test/EFCore.Design.Tests/Migrations/Design/MigrationScaffolderTest.cs
index 94fa478789..45f138e904 100644
--- a/test/EFCore.Design.Tests/Migrations/Design/MigrationScaffolderTest.cs
+++ b/test/EFCore.Design.Tests/Migrations/Design/MigrationScaffolderTest.cs
@@ -125,7 +125,8 @@ var migrationAssembly
                     services.GetRequiredService<IDatabaseProvider>(),
                     services.GetRequiredService<IMigrationsModelDiffer>(),
                     services.GetRequiredService<IDesignTimeModel>(),
-                    services.GetRequiredService<IDbContextOptions>())));
+                    services.GetRequiredService<IDbContextOptions>(),
+                    services.GetRequiredService<IExecutionStrategy>())));
     }
 
     // ReSharper disable once UnusedTypeParameter
@@ -143,6 +144,8 @@ protected override void BuildModel(ModelBuilder modelBuilder)
 
     private class MockHistoryRepository : IHistoryRepository
     {
+        public virtual LockReleaseBehavior LockReleaseBehavior => LockReleaseBehavior.Explicit;
+
         public string GetBeginIfExistsScript(string migrationId)
             => null;
 
@@ -182,10 +185,10 @@ public void Create()
         public Task CreateAsync(CancellationToken cancellationToken = default)
             => throw new NotImplementedException();
 
-        public IDisposable GetDatabaseLock()
+        public IMigrationsDatabaseLock AcquireDatabaseLock()
             => throw new NotImplementedException();
 
-        public Task<IAsyncDisposable> GetDatabaseLockAsync(CancellationToken cancellationToken = default)
+        public Task<IMigrationsDatabaseLock> AcquireDatabaseLockAsync(CancellationToken cancellationToken = default)
             => throw new NotImplementedException();
     }
 
diff --git a/test/EFCore.Relational.Tests/Extensions/RelationalDatabaseFacadeExtensionsTest.cs b/test/EFCore.Relational.Tests/Extensions/RelationalDatabaseFacadeExtensionsTest.cs
index 3e56284521..f2d2a935de 100644
--- a/test/EFCore.Relational.Tests/Extensions/RelationalDatabaseFacadeExtensionsTest.cs
+++ b/test/EFCore.Relational.Tests/Extensions/RelationalDatabaseFacadeExtensionsTest.cs
@@ -321,6 +321,8 @@ protected override void BuildModel(ModelBuilder modelBuilder)
 
     private class FakeHistoryRepository : IHistoryRepository
     {
+        public virtual LockReleaseBehavior LockReleaseBehavior => LockReleaseBehavior.Explicit;
+
         public List<HistoryRow> AppliedMigrations { get; set; }
 
         public IReadOnlyList<HistoryRow> GetAppliedMigrations()
@@ -362,10 +364,10 @@ public void Create()
         public Task CreateAsync(CancellationToken cancellationToken = default)
             => throw new NotImplementedException();
 
-        public IDisposable GetDatabaseLock()
+        public IMigrationsDatabaseLock AcquireDatabaseLock()
             => throw new NotImplementedException();
 
-        public Task<IAsyncDisposable> GetDatabaseLockAsync(CancellationToken cancellationToken = default)
+        public Task<IMigrationsDatabaseLock> AcquireDatabaseLockAsync(CancellationToken cancellationToken = default)
             => throw new NotImplementedException();
     }
 
diff --git a/test/EFCore.SqlServer.FunctionalTests/Migrations/MigrationsInfrastructureSqlServerTest.cs b/test/EFCore.SqlServer.FunctionalTests/Migrations/MigrationsInfrastructureSqlServerTest.cs
index 8aeb88a4e3..3d1c63e96e 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Migrations/MigrationsInfrastructureSqlServerTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Migrations/MigrationsInfrastructureSqlServerTest.cs
@@ -1017,13 +1017,16 @@ SELECT 1
 EXEC @result = sp_getapplock @Resource = '__EFMigrationsLock', @LockOwner = 'Session', @LockMode = 'Exclusive';
 SELECT @result
 
-SELECT OBJECT_ID(N'[__EFMigrationsHistory]');
+IF OBJECT_ID(N'[__EFMigrationsHistory]') IS NULL
+BEGIN
+    CREATE TABLE [__EFMigrationsHistory] (
+        [MigrationId] nvarchar(150) NOT NULL,
+        [ProductVersion] nvarchar(32) NOT NULL,
+        CONSTRAINT [PK___EFMigrationsHistory] PRIMARY KEY ([MigrationId])
+    );
+END;
 
-CREATE TABLE [__EFMigrationsHistory] (
-    [MigrationId] nvarchar(150) NOT NULL,
-    [ProductVersion] nvarchar(32) NOT NULL,
-    CONSTRAINT [PK___EFMigrationsHistory] PRIMARY KEY ([MigrationId])
-);
+SELECT 1
 
 SELECT OBJECT_ID(N'[__EFMigrationsHistory]');
 
@@ -1047,6 +1050,22 @@ SELECT @result
     THROW 65536, 'Test', 0;
 END
 
+DECLARE @result int;
+EXEC @result = sp_releaseapplock @Resource = '__EFMigrationsLock', @LockOwner = 'Session';
+SELECT @result
+
+DECLARE @result int;
+EXEC @result = sp_getapplock @Resource = '__EFMigrationsLock', @LockOwner = 'Session', @LockMode = 'Exclusive';
+SELECT @result
+
+SELECT 1
+
+SELECT OBJECT_ID(N'[__EFMigrationsHistory]');
+
+SELECT [MigrationId], [ProductVersion]
+FROM [__EFMigrationsHistory]
+ORDER BY [MigrationId];
+
 IF OBJECT_ID(N'Blogs', N'U') IS NULL
 BEGIN
     CREATE TABLE [Blogs] (
@@ -1110,13 +1129,16 @@ SELECT 1
 EXEC @result = sp_getapplock @Resource = '__EFMigrationsLock', @LockOwner = 'Session', @LockMode = 'Exclusive';
 SELECT @result
 
-SELECT OBJECT_ID(N'[__EFMigrationsHistory]');
+IF OBJECT_ID(N'[__EFMigrationsHistory]') IS NULL
+BEGIN
+    CREATE TABLE [__EFMigrationsHistory] (
+        [MigrationId] nvarchar(150) NOT NULL,
+        [ProductVersion] nvarchar(32) NOT NULL,
+        CONSTRAINT [PK___EFMigrationsHistory] PRIMARY KEY ([MigrationId])
+    );
+END;
 
-CREATE TABLE [__EFMigrationsHistory] (
-    [MigrationId] nvarchar(150) NOT NULL,
-    [ProductVersion] nvarchar(32) NOT NULL,
-    CONSTRAINT [PK___EFMigrationsHistory] PRIMARY KEY ([MigrationId])
-);
+SELECT 1
 
 SELECT OBJECT_ID(N'[__EFMigrationsHistory]');
 
@@ -1140,6 +1162,22 @@ SELECT @result
     THROW 65536, 'Test', 0;
 END
 
+DECLARE @result int;
+EXEC @result = sp_releaseapplock @Resource = '__EFMigrationsLock', @LockOwner = 'Session';
+SELECT @result
+
+DECLARE @result int;
+EXEC @result = sp_getapplock @Resource = '__EFMigrationsLock', @LockOwner = 'Session', @LockMode = 'Exclusive';
+SELECT @result
+
+SELECT 1
+
+SELECT OBJECT_ID(N'[__EFMigrationsHistory]');
+
+SELECT [MigrationId], [ProductVersion]
+FROM [__EFMigrationsHistory]
+ORDER BY [MigrationId];
+
 IF OBJECT_ID(N'Blogs', N'U') IS NULL
 BEGIN
     CREATE TABLE [Blogs] (
@@ -2078,7 +2116,8 @@ IF EXISTS(select * from sys.databases where name='TransactionSuppressed')
             public override MigrationsContext CreateContext()
             {
                 var options = AddOptions(TestStore.AddProviderOptions(new DbContextOptionsBuilder()))
-                    .UseSqlServer(TestStore.ConnectionString, b => b.ApplyConfiguration())
+                    .UseSqlServer(TestStore.ConnectionString, b => b
+                        .ApplyConfiguration())
                     .UseInternalServiceProvider(ServiceProvider)
                     .Options;
                 return new MigrationsContext(options);
diff --git a/test/EFCore.SqlServer.FunctionalTests/TestUtilities/TestSqlServerRetryingExecutionStrategy.cs b/test/EFCore.SqlServer.FunctionalTests/TestUtilities/TestSqlServerRetryingExecutionStrategy.cs
index ec517ff802..ac0eea2e54 100644
--- a/test/EFCore.SqlServer.FunctionalTests/TestUtilities/TestSqlServerRetryingExecutionStrategy.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/TestUtilities/TestSqlServerRetryingExecutionStrategy.cs
@@ -43,6 +43,13 @@ public TestSqlServerRetryingExecutionStrategy(ExecutionStrategyDependencies depe
     {
     }
 
+    public TestSqlServerRetryingExecutionStrategy(
+        ExecutionStrategyDependencies dependencies,
+        IEnumerable<int> errorNumbersToAdd)
+        : base(dependencies, DefaultMaxRetryCount, DefaultMaxDelay, _additionalErrorNumbers.Concat(errorNumbersToAdd))
+    {
+    }
+
     protected override bool ShouldRetryOn(Exception exception)
     {
         if (base.ShouldRetryOn(exception))
