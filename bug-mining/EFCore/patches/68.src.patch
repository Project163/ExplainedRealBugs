diff --git a/src/EFCore.Design/Extensions/ScaffoldingModelExtensions.cs b/src/EFCore.Design/Extensions/ScaffoldingModelExtensions.cs
index d0adcd4670..1fe38f6099 100644
--- a/src/EFCore.Design/Extensions/ScaffoldingModelExtensions.cs
+++ b/src/EFCore.Design/Extensions/ScaffoldingModelExtensions.cs
@@ -407,14 +407,14 @@ public static IEnumerable<AttributeCodeFragment> GetDataAnnotations(this ISkipNa
             toTableNestedCalls.Add(new MethodCallCodeFragment(nameof(TableBuilder.HasComment), comment));
         }
 
-        if (entityType.GetTriggers().Any())
+        if (entityType.GetDeclaredTriggers().Any())
         {
             toTableHandledByConventions = false;
             toTableHandledByDataAnnotations = false;
 
-            foreach (var trigger in entityType.GetTriggers())
+            foreach (var trigger in entityType.GetDeclaredTriggers())
             {
-                toTableNestedCalls.Add(new MethodCallCodeFragment(nameof(TableBuilder.HasTrigger), trigger.Name));
+                toTableNestedCalls.Add(new MethodCallCodeFragment(nameof(TableBuilder.HasTrigger), trigger.ModelName));
             }
         }
 
diff --git a/src/EFCore.Design/Migrations/Design/CSharpSnapshotGenerator.cs b/src/EFCore.Design/Migrations/Design/CSharpSnapshotGenerator.cs
index b12a83f223..d103595a45 100644
--- a/src/EFCore.Design/Migrations/Design/CSharpSnapshotGenerator.cs
+++ b/src/EFCore.Design/Migrations/Design/CSharpSnapshotGenerator.cs
@@ -1,8 +1,10 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using System;
 using System.Text;
 using Microsoft.EntityFrameworkCore.Internal;
+using Microsoft.EntityFrameworkCore.Metadata;
 using Microsoft.EntityFrameworkCore.Metadata.Internal;
 
 namespace Microsoft.EntityFrameworkCore.Migrations.Design;
@@ -847,20 +849,20 @@ protected virtual void GenerateKeyAnnotations(string keyBuilderName, IKey key, I
         annotations.TryGetAndRemove(RelationalAnnotationNames.TableName, out IAnnotation tableNameAnnotation);
         var table = StoreObjectIdentifier.Create(entityType, StoreObjectType.Table);
         var tableName = (string?)tableNameAnnotation?.Value ?? table?.Name;
-        var explicitName = tableNameAnnotation != null 
-            || entityType.BaseType == null 
+        var explicitName = tableNameAnnotation != null
+            || entityType.BaseType == null
             || entityType.BaseType.GetTableName() != tableName;
-        
+
         annotations.TryGetAndRemove(RelationalAnnotationNames.Schema, out IAnnotation schemaAnnotation);
         var schema = (string?)schemaAnnotation?.Value ?? table?.Schema;
-        
+
         annotations.TryGetAndRemove(RelationalAnnotationNames.IsTableExcludedFromMigrations, out IAnnotation isExcludedAnnotation);
         var isExcludedFromMigrations = (isExcludedAnnotation?.Value as bool?) == true;
-        
+
         annotations.TryGetAndRemove(RelationalAnnotationNames.Comment, out IAnnotation commentAnnotation);
         var comment = (string?)commentAnnotation?.Value;
-        
-        var hasTriggers = entityType.GetTriggers().Any(t => t.TableName == tableName! && t.TableSchema == schema);
+
+        var hasTriggers = entityType.GetDeclaredTriggers().Any(t => t.GetTableName() == tableName! && t.GetTableSchema() == schema);
         var hasOverrides = table != null
             && entityType.GetProperties().Select(p => p.FindOverrides(table.Value)).Any(o => o != null);
         var requiresTableBuilder = isExcludedFromMigrations
@@ -868,7 +870,7 @@ protected virtual void GenerateKeyAnnotations(string keyBuilderName, IKey key, I
             || hasTriggers
             || hasOverrides
             || entityType.GetCheckConstraints().Any();
-        
+
         if (!explicitName
             && !requiresTableBuilder)
         {
@@ -879,7 +881,7 @@ protected virtual void GenerateKeyAnnotations(string keyBuilderName, IKey key, I
             .AppendLine()
             .Append(entityTypeBuilderName)
             .Append(".ToTable(");
-        
+
         if (explicitName)
         {
             if (tableName == null
@@ -932,7 +934,7 @@ protected virtual void GenerateKeyAnnotations(string keyBuilderName, IKey key, I
                             .AppendLine()
                             .AppendLine("t.ExcludeFromMigrations();");
                     }
-                    
+
                     if (comment != null)
                     {
                         stringBuilder
@@ -1106,6 +1108,7 @@ private void GenerateViewMapping(string entityTypeBuilderName, IEntityType entit
         var annotations = Dependencies.AnnotationCodeGenerator
             .FilterIgnoredAnnotations(fragment.GetAnnotations())
             .ToDictionary(a => a.Name, a => a);
+
         if (annotations.Count > 0)
         {
             GenerateAnnotations(tableBuilderName, fragment, stringBuilder, annotations, inChainedCall: false);
@@ -1169,6 +1172,7 @@ private void GenerateViewMapping(string entityTypeBuilderName, IEntityType entit
         var annotations = Dependencies.AnnotationCodeGenerator
             .FilterIgnoredAnnotations(checkConstraint.GetAnnotations())
             .ToDictionary(a => a.Name, a => a);
+
         using (stringBuilder.Indent())
         {
             if (hasNonDefaultName)
@@ -1207,9 +1211,9 @@ private void GenerateViewMapping(string entityTypeBuilderName, IEntityType entit
         string? schema,
         IndentedStringBuilder stringBuilder)
     {
-        foreach (var trigger in entityType.GetTriggers())
+        foreach (var trigger in entityType.GetDeclaredTriggers())
         {
-            if (trigger.TableName != table || trigger.TableSchema != schema)
+            if (trigger.GetTableName() != table || trigger.GetTableSchema() != schema)
             {
                 continue;
             }
@@ -1237,15 +1241,6 @@ private void GenerateViewMapping(string entityTypeBuilderName, IEntityType entit
         // Note that GenerateAnnotations below does the corresponding decrement
         stringBuilder.IncrementIndent();
 
-        if (trigger.Name != trigger.GetDefaultName()!)
-        {
-            stringBuilder
-                .AppendLine()
-                .Append(".HasName(")
-                .Append(Code.Literal(trigger.Name))
-                .Append(")");
-        }
-
         GenerateTriggerAnnotations(triggerBuilderName, trigger, stringBuilder);
     }
 
@@ -1264,6 +1259,18 @@ private void GenerateViewMapping(string entityTypeBuilderName, IEntityType entit
             .FilterIgnoredAnnotations(trigger.GetAnnotations())
             .ToDictionary(a => a.Name, a => a);
 
+        if (annotations.TryGetAndRemove(RelationalAnnotationNames.Name, out IAnnotation nameAnnotation))
+        {
+            stringBuilder
+                .AppendLine()
+                .Append(".HasName(")
+                .Append(Code.Literal((string?)nameAnnotation.Value))
+                .Append(")");
+        }
+
+        annotations.Remove(RelationalAnnotationNames.TableName);
+        annotations.Remove(RelationalAnnotationNames.Schema);
+
         GenerateAnnotations(triggerBuilderName, trigger, stringBuilder, annotations, inChainedCall: true);
     }
 
@@ -1337,6 +1344,7 @@ private void GenerateViewMapping(string entityTypeBuilderName, IEntityType entit
         var annotations = Dependencies.AnnotationCodeGenerator
             .FilterIgnoredAnnotations(overrides.GetAnnotations())
             .ToDictionary(a => a.Name, a => a);
+
         GenerateAnnotations(propertyBuilderName, overrides, stringBuilder, annotations, inChainedCall: true);
     }
 
diff --git a/src/EFCore.Design/Scaffolding/Internal/CSharpRuntimeModelCodeGenerator.cs b/src/EFCore.Design/Scaffolding/Internal/CSharpRuntimeModelCodeGenerator.cs
index 7110d784db..8a25435941 100644
--- a/src/EFCore.Design/Scaffolding/Internal/CSharpRuntimeModelCodeGenerator.cs
+++ b/src/EFCore.Design/Scaffolding/Internal/CSharpRuntimeModelCodeGenerator.cs
@@ -547,6 +547,11 @@ private string GenerateEntityType(IEntityType entityType, string @namespace, str
                 Create(index, propertyVariables, parameters, nullable);
             }
 
+            foreach (var trigger in entityType.GetDeclaredTriggers())
+            {
+                Create(trigger, parameters);
+            }
+
             mainBuilder
                 .Append("return ")
                 .Append(entityTypeVariable)
@@ -1322,6 +1327,26 @@ private void Create(IEntityType entityType, CSharpRuntimeAnnotationCodeGenerator
             .AppendLine("}");
     }
 
+    private void Create(ITrigger trigger, CSharpRuntimeAnnotationCodeGeneratorParameters parameters)
+    {
+        var triggerVariable = _code.Identifier(trigger.ModelName, parameters.ScopeVariables, capitalize: false);
+
+        var mainBuilder = parameters.MainBuilder;
+        mainBuilder
+            .Append("var ").Append(triggerVariable).Append(" = ").Append(parameters.TargetName).AppendLine(".AddTrigger(")
+            .IncrementIndent()
+            .Append(_code.Literal(trigger.ModelName))
+            .AppendLine(");")
+            .DecrementIndent();
+
+        CreateAnnotations(
+            trigger,
+            _annotationCodeGenerator.Generate,
+            parameters with { TargetName = triggerVariable });
+
+        mainBuilder.AppendLine();
+    }
+
     private void CreateAnnotations(
         IEntityType entityType,
         IndentedStringBuilder mainBuilder,
diff --git a/src/EFCore.Design/Scaffolding/Internal/RelationalScaffoldingModelFactory.cs b/src/EFCore.Design/Scaffolding/Internal/RelationalScaffoldingModelFactory.cs
index 51edee9e68..63fc1fee6b 100644
--- a/src/EFCore.Design/Scaffolding/Internal/RelationalScaffoldingModelFactory.cs
+++ b/src/EFCore.Design/Scaffolding/Internal/RelationalScaffoldingModelFactory.cs
@@ -335,14 +335,9 @@ protected virtual ModelBuilder VisitTables(ModelBuilder modelBuilder, ICollectio
         VisitUniqueConstraints(builder, table.UniqueConstraints);
         VisitIndexes(builder, table.Indexes);
 
-        if (table.FindAnnotation(RelationalAnnotationNames.Triggers) is { Value: HashSet<string> triggers })
+        foreach (var triggerName in table.Triggers)
         {
-            foreach (var triggerName in triggers)
-            {
-                builder.ToTable(table.Name, table.Schema, tb => tb.HasTrigger(triggerName));
-            }
-
-            table.RemoveAnnotation(RelationalAnnotationNames.Triggers);
+            builder.ToTable(table.Name, table.Schema, tb => tb.HasTrigger(triggerName));
         }
 
         builder.Metadata.AddAnnotations(table.GetAnnotations());
diff --git a/src/EFCore.Relational/Design/AnnotationCodeGenerator.cs b/src/EFCore.Relational/Design/AnnotationCodeGenerator.cs
index 861376d947..98935d17ac 100644
--- a/src/EFCore.Relational/Design/AnnotationCodeGenerator.cs
+++ b/src/EFCore.Relational/Design/AnnotationCodeGenerator.cs
@@ -28,7 +28,6 @@ public class AnnotationCodeGenerator : IAnnotationCodeGenerator
     private static readonly ISet<string> IgnoredRelationalAnnotations = new HashSet<string>
     {
         RelationalAnnotationNames.CheckConstraints,
-        RelationalAnnotationNames.Triggers,
         RelationalAnnotationNames.Sequences,
         RelationalAnnotationNames.DbFunctions,
         RelationalAnnotationNames.DeleteStoredProcedure,
@@ -123,6 +122,18 @@ public virtual void RemoveAnnotationsHandledByConventions(IKey key, IDictionary<
         IDictionary<string, IAnnotation> annotations)
         => RemoveConventionalAnnotationsHelper(foreignKey, annotations, IsHandledByConvention);
 
+    /// <inheritdoc />
+    public virtual void RemoveAnnotationsHandledByConventions(
+        INavigation navigation,
+        IDictionary<string, IAnnotation> annotations)
+        => RemoveConventionalAnnotationsHelper(navigation, annotations, IsHandledByConvention);
+
+    /// <inheritdoc />
+    public virtual void RemoveAnnotationsHandledByConventions(
+        ISkipNavigation navigation,
+        IDictionary<string, IAnnotation> annotations)
+        => RemoveConventionalAnnotationsHelper(navigation, annotations, IsHandledByConvention);
+
     /// <inheritdoc />
     public virtual void RemoveAnnotationsHandledByConventions(IIndex index, IDictionary<string, IAnnotation> annotations)
         => RemoveConventionalAnnotationsHelper(index, annotations, IsHandledByConvention);
@@ -543,6 +554,32 @@ protected virtual bool IsHandledByConvention(IProperty property, IAnnotation ann
     protected virtual bool IsHandledByConvention(IForeignKey foreignKey, IAnnotation annotation)
         => false;
 
+    /// <summary>
+    ///     Checks if the given <paramref name="annotation" /> is handled by convention when
+    ///     applied to the given <paramref name="navigation" />.
+    /// </summary>
+    /// <remarks>
+    ///     The default implementation always returns <see langword="false" />.
+    /// </remarks>
+    /// <param name="navigation">The <see cref="INavigation" />.</param>
+    /// <param name="annotation">The <see cref="IAnnotation" />.</param>
+    /// <returns><see langword="false" />.</returns>
+    protected virtual bool IsHandledByConvention(INavigation navigation, IAnnotation annotation)
+        => false;
+
+    /// <summary>
+    ///     Checks if the given <paramref name="annotation" /> is handled by convention when
+    ///     applied to the given <paramref name="navigation" />.
+    /// </summary>
+    /// <remarks>
+    ///     The default implementation always returns <see langword="false" />.
+    /// </remarks>
+    /// <param name="navigation">The <see cref="ISkipNavigation" />.</param>
+    /// <param name="annotation">The <see cref="IAnnotation" />.</param>
+    /// <returns><see langword="false" />.</returns>
+    protected virtual bool IsHandledByConvention(ISkipNavigation navigation, IAnnotation annotation)
+        => false;
+
     /// <summary>
     ///     Checks if the given <paramref name="annotation" /> is handled by convention when
     ///     applied to the given <paramref name="index" />.
diff --git a/src/EFCore.Relational/Design/IAnnotationCodeGenerator.cs b/src/EFCore.Relational/Design/IAnnotationCodeGenerator.cs
index 9370ffa3ff..667b8b10cf 100644
--- a/src/EFCore.Relational/Design/IAnnotationCodeGenerator.cs
+++ b/src/EFCore.Relational/Design/IAnnotationCodeGenerator.cs
@@ -88,6 +88,26 @@ void RemoveAnnotationsHandledByConventions(IForeignKey foreignKey, IDictionary<s
     {
     }
 
+    /// <summary>
+    ///     Removes annotation whose configuration is already applied by convention, and do not need to be
+    ///     specified explicitly.
+    /// </summary>
+    /// <param name="navigation">The navigation to which the annotations are applied.</param>
+    /// <param name="annotations">The set of annotations from which to remove the conventional ones.</param>
+    void RemoveAnnotationsHandledByConventions(INavigation navigation, IDictionary<string, IAnnotation> annotations)
+    {
+    }
+
+    /// <summary>
+    ///     Removes annotation whose configuration is already applied by convention, and do not need to be
+    ///     specified explicitly.
+    /// </summary>
+    /// <param name="navigation">The navigation to which the annotations are applied.</param>
+    /// <param name="annotations">The set of annotations from which to remove the conventional ones.</param>
+    void RemoveAnnotationsHandledByConventions(ISkipNavigation navigation, IDictionary<string, IAnnotation> annotations)
+    {
+    }
+
     /// <summary>
     ///     Removes annotation whose configuration is already applied by convention, and do not need to be
     ///     specified explicitly.
@@ -139,8 +159,8 @@ void RemoveAnnotationsHandledByConventions(ISequence sequence, IDictionary<strin
     }
 
     /// <summary>
-    ///     For the given annotations which have corresponding fluent API calls, returns those fluent API calls
-    ///     and removes the annotations.
+    ///     Removes annotation whose configuration is already applied by convention, and do not need to be
+    ///     specified explicitly.
     /// </summary>
     /// <param name="annotatable">The annotatable to which the annotations are applied.</param>
     /// <param name="annotations">The set of annotations from which to generate fluent API calls.</param>
diff --git a/src/EFCore.Relational/Design/Internal/RelationalCSharpRuntimeAnnotationCodeGenerator.cs b/src/EFCore.Relational/Design/Internal/RelationalCSharpRuntimeAnnotationCodeGenerator.cs
index bef46d3450..0c2f8b3c52 100644
--- a/src/EFCore.Relational/Design/Internal/RelationalCSharpRuntimeAnnotationCodeGenerator.cs
+++ b/src/EFCore.Relational/Design/Internal/RelationalCSharpRuntimeAnnotationCodeGenerator.cs
@@ -1,6 +1,7 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using System;
 using System.Data;
 using Microsoft.EntityFrameworkCore.Metadata.Internal;
 
@@ -348,23 +349,6 @@ public override void Generate(IEntityType entityType, CSharpRuntimeAnnotationCod
                 GenerateSimpleAnnotation(RelationalAnnotationNames.MappingFragments, fragmentsVariable, parameters);
             }
 
-            if (annotations.TryGetAndRemove(
-                    RelationalAnnotationNames.Triggers,
-                    out SortedDictionary<string, ITrigger> triggers))
-            {
-                parameters.Namespaces.Add(typeof(SortedDictionary<,>).Namespace!);
-                var triggersVariable = Dependencies.CSharpHelper.Identifier("triggers", parameters.ScopeVariables, capitalize: false);
-                parameters.MainBuilder
-                    .Append("var ").Append(triggersVariable).AppendLine(" = new SortedDictionary<string, ITrigger>();").AppendLine();
-
-                foreach (var (_, trigger) in triggers)
-                {
-                    Create(trigger, triggersVariable, parameters);
-                }
-
-                GenerateSimpleAnnotation(RelationalAnnotationNames.Triggers, triggersVariable, parameters);
-            }
-
             if (annotations.TryGetAndRemove(
                     RelationalAnnotationNames.InsertStoredProcedure,
                     out StoredProcedure insertStoredProcedure))
@@ -444,46 +428,11 @@ public override void Generate(IEntityType entityType, CSharpRuntimeAnnotationCod
     public virtual void Generate(IEntityTypeMappingFragment fragment, CSharpRuntimeAnnotationCodeGeneratorParameters parameters)
         => GenerateSimpleAnnotations(parameters);
 
-    private void Create(ITrigger trigger, string triggersVariable, CSharpRuntimeAnnotationCodeGeneratorParameters parameters)
-    {
-        var code = Dependencies.CSharpHelper;
-        var triggerVariable = code.Identifier(trigger.ModelName, parameters.ScopeVariables, capitalize: false);
-        var mainBuilder = parameters.MainBuilder;
-        mainBuilder
-            .Append("var ").Append(triggerVariable).AppendLine(" = new RuntimeTrigger(").IncrementIndent()
-            .Append(parameters.TargetName).AppendLine(",")
-            .Append(code.Literal(trigger.ModelName)).AppendLine(",")
-            .Append(code.Literal(trigger.Name)).AppendLine(",")
-            .Append(code.Literal(trigger.TableName)).AppendLine(",")
-            .Append(code.Literal(trigger.TableSchema))
-            .AppendLine(");")
-            .DecrementIndent()
-            .AppendLine();
-
-        CreateAnnotations(
-            trigger,
-            Generate,
-            parameters with { TargetName = triggerVariable });
-
-        mainBuilder
-            .Append(triggersVariable).Append("[").Append(code.Literal(trigger.ModelName)).Append("] = ")
-            .Append(triggerVariable).AppendLine(";")
-            .AppendLine();
-    }
-
-    /// <summary>
-    ///     Generates code to create the given annotations.
-    /// </summary>
-    /// <param name="trigger">The trigger to which the annotations are applied.</param>
-    /// <param name="parameters">Additional parameters used during code generation.</param>
-    public virtual void Generate(ITrigger trigger, CSharpRuntimeAnnotationCodeGeneratorParameters parameters)
-        => GenerateSimpleAnnotations(parameters);
-
     private void Create(IStoredProcedure storedProcedure, string sprocVariable, CSharpRuntimeAnnotationCodeGeneratorParameters parameters)
     {
         AddNamespace(typeof(RuntimeStoredProcedure), parameters.Namespaces);
         AddNamespace(typeof(ParameterDirection), parameters.Namespaces);
-        
+
         var code = Dependencies.CSharpHelper;
         var mainBuilder = parameters.MainBuilder;
         mainBuilder
@@ -495,13 +444,13 @@ private void Create(IStoredProcedure storedProcedure, string sprocVariable, CSha
             .AppendLine(");")
             .DecrementIndent()
             .AppendLine();
-        
+
         parameters = parameters with { TargetName = sprocVariable };
         foreach (var parameter in storedProcedure.Parameters)
         {
             Create(parameter, parameters);
         }
-        
+
         foreach (var resultColumn in storedProcedure.ResultColumns)
         {
             Create(resultColumn, parameters);
@@ -536,7 +485,7 @@ private void Create(IStoredProcedureParameter parameter, CSharpRuntimeAnnotation
             .Append(code.Literal(parameter.PropertyName!)).Append(", ")
             .Append(code.Literal(parameter.ForOriginalValue))
             .AppendLine(");").DecrementIndent();
-        
+
         CreateAnnotations(
             parameter,
             Generate,
@@ -564,7 +513,7 @@ private void Create(IStoredProcedureResultColumn resultColumn, CSharpRuntimeAnno
             .Append(code.Literal(resultColumn.ForRowsAffected)).Append(", ")
             .Append(code.Literal(resultColumn.PropertyName!))
             .AppendLine(");").DecrementIndent();
-        
+
         CreateAnnotations(
             resultColumn,
             Generate,
diff --git a/src/EFCore.Relational/Extensions/RelationalEntityTypeBuilderExtensions.cs b/src/EFCore.Relational/Extensions/RelationalEntityTypeBuilderExtensions.cs
index 798e276199..4ceef8daa3 100644
--- a/src/EFCore.Relational/Extensions/RelationalEntityTypeBuilderExtensions.cs
+++ b/src/EFCore.Relational/Extensions/RelationalEntityTypeBuilderExtensions.cs
@@ -1096,57 +1096,6 @@ public static EntityTypeBuilder<TEntity> UseTptMappingStrategy<TEntity>(this Ent
             comment,
             fromDataAnnotation);
 
-    /// <summary>
-    ///     Configures a database trigger when targeting a relational database.
-    /// </summary>
-    /// <remarks>
-    ///     See <see href="https://aka.ms/efcore-docs-triggers">Database triggers</see> for more information and examples.
-    /// </remarks>
-    /// <param name="entityTypeBuilder">The entity type builder.</param>
-    /// <param name="modelName">The name of the trigger.</param>
-    /// <param name="tableName">The name of the table on which this trigger is defined.</param>
-    /// <param name="tableSchema">The schema of the table on which this trigger is defined.</param>
-    /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
-    /// <returns>The same builder instance if the check constraint was configured, <see langword="null" /> otherwise.</returns>
-    public static IConventionTriggerBuilder? HasTrigger(
-        this IConventionEntityTypeBuilder entityTypeBuilder,
-        string modelName,
-        string? tableName,
-        string? tableSchema,
-        bool fromDataAnnotation = false)
-        => InternalTriggerBuilder.HasTrigger(
-                entityTypeBuilder.Metadata,
-                modelName,
-                tableName,
-                tableSchema,
-                fromDataAnnotation ? ConfigurationSource.DataAnnotation : ConfigurationSource.Convention)
-            ?.Builder;
-
-    /// <summary>
-    ///     Returns a value indicating whether the trigger can be configured.
-    /// </summary>
-    /// <remarks>
-    ///     See <see href="https://aka.ms/efcore-docs-triggers">Database triggers</see> for more information and examples.
-    /// </remarks>
-    /// <param name="entityTypeBuilder">The builder for the entity type being configured.</param>
-    /// <param name="name">The name of the trigger.</param>
-    /// <param name="tableName">The name of the table on which this trigger is defined.</param>
-    /// <param name="tableSchema">The schema of the table on which this trigger is defined.</param>
-    /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
-    /// <returns><see langword="true" /> if the configuration can be applied.</returns>
-    public static bool CanHaveTrigger(
-        this IConventionEntityTypeBuilder entityTypeBuilder,
-        string name,
-        string? tableName,
-        string? tableSchema,
-        bool fromDataAnnotation = false)
-        => InternalTriggerBuilder.CanHaveTrigger(
-            entityTypeBuilder.Metadata,
-            name,
-            tableName,
-            tableSchema,
-            fromDataAnnotation ? ConfigurationSource.DataAnnotation : ConfigurationSource.Convention);
-
     /// <summary>
     ///     Configures the entity mapped to a JSON column, mapping it to the given JSON property,
     ///     rather than using the navigation name leading to it.
diff --git a/src/EFCore.Relational/Extensions/RelationalEntityTypeExtensions.cs b/src/EFCore.Relational/Extensions/RelationalEntityTypeExtensions.cs
index b2fcfff28a..6eb569df10 100644
--- a/src/EFCore.Relational/Extensions/RelationalEntityTypeExtensions.cs
+++ b/src/EFCore.Relational/Extensions/RelationalEntityTypeExtensions.cs
@@ -817,7 +817,7 @@ public static IEnumerable<IStoredProcedureMapping> GetDeleteStoredProcedureMappi
         => (IEnumerable<IStoredProcedureMapping>?)entityType.FindRuntimeAnnotationValue(
                 RelationalAnnotationNames.DeleteStoredProcedureMappings)
             ?? Enumerable.Empty<IStoredProcedureMapping>();
-    
+
     /// <summary>
     ///     Returns the update stored procedures to which the entity type is mapped.
     /// </summary>
@@ -1546,7 +1546,7 @@ public static void SetIsTableExcludedFromMigrations(this IMutableEntityType enti
         bool fromDataAnnotation = false)
         => entityType.GetOrCreateMappingFragment(storeObject, fromDataAnnotation).SetIsTableExcludedFromMigrations(
                 excluded, fromDataAnnotation);
-        
+
     /// <summary>
     ///     Gets the <see cref="ConfigurationSource" /> for <see cref="IsTableExcludedFromMigrations(IReadOnlyEntityType)" />.
     /// </summary>
@@ -1626,219 +1626,6 @@ public static void SetMappingStrategy(this IMutableEntityType entityType, string
 
     #endregion Mapping strategy
 
-    #region Trigger
-
-    /// <summary>
-    ///     Finds a trigger with the given name.
-    /// </summary>
-    /// <param name="entityType">The entity type to find the sequence on.</param>
-    /// <param name="name">The trigger name.</param>
-    /// <returns>The trigger or <see langword="null" /> if no trigger with the given name was found.</returns>
-    public static IReadOnlyTrigger? FindTrigger(this IReadOnlyEntityType entityType, string name)
-        => Trigger.FindTrigger(entityType, Check.NotEmpty(name, nameof(name)));
-
-    /// <summary>
-    ///     Finds a trigger with the given name.
-    /// </summary>
-    /// <param name="entityType">The entity type to find the sequence on.</param>
-    /// <param name="name">The trigger name.</param>
-    /// <returns>The trigger or <see langword="null" /> if no trigger with the given name was found.</returns>
-    public static IMutableTrigger? FindTrigger(this IMutableEntityType entityType, string name)
-        => (IMutableTrigger?)((IReadOnlyEntityType)entityType).FindTrigger(name);
-
-    /// <summary>
-    ///     Finds a trigger with the given name.
-    /// </summary>
-    /// <param name="entityType">The entity type to find the sequence on.</param>
-    /// <param name="name">The trigger name.</param>
-    /// <returns>The trigger or <see langword="null" /> if no trigger with the given name was found.</returns>
-    public static IConventionTrigger? FindTrigger(this IConventionEntityType entityType, string name)
-        => (IConventionTrigger?)((IReadOnlyEntityType)entityType).FindTrigger(name);
-
-    /// <summary>
-    ///     Finds a trigger with the given name.
-    /// </summary>
-    /// <param name="entityType">The entity type to find the sequence on.</param>
-    /// <param name="name">The trigger name.</param>
-    /// <returns>The trigger or <see langword="null" /> if no trigger with the given name was found.</returns>
-    public static ITrigger? FindTrigger(this IEntityType entityType, string name)
-        => (ITrigger?)((IReadOnlyEntityType)entityType).FindTrigger(name);
-
-    /// <summary>
-    ///     Creates a new trigger with the given name on entity type. Throws an exception if a trigger with the same name exists on the same
-    ///     entity type.
-    /// </summary>
-    /// <param name="entityType">The entity type to add the trigger to.</param>
-    /// <param name="name">The trigger name.</param>
-    /// <returns>The trigger.</returns>
-    public static IMutableTrigger AddTrigger(this IMutableEntityType entityType, string name)
-    {
-        Check.NotEmpty(name, nameof(name));
-
-        return new Trigger(entityType, name, tableName: null, tableSchema: null, ConfigurationSource.Explicit);
-    }
-
-    /// <summary>
-    ///     Creates a new trigger with the given name on entity type. Throws an exception if a trigger with the same name exists on the same
-    ///     entity type.
-    /// </summary>
-    /// <param name="entityType">The entity type to add the trigger to.</param>
-    /// <param name="name">The trigger name.</param>
-    /// <param name="tableName">The name of the table on which this trigger is defined.</param>
-    /// <param name="tableSchema">The schema of the table on which this trigger is defined.</param>
-    /// <returns>The trigger.</returns>
-    public static IMutableTrigger AddTrigger(this IMutableEntityType entityType, string name, string tableName, string? tableSchema = null)
-    {
-        Check.NotEmpty(name, nameof(name));
-
-        return new Trigger(entityType, name, tableName, tableSchema, ConfigurationSource.Explicit);
-    }
-
-    /// <summary>
-    ///     Creates a new trigger with the given name on entity type. Throws an exception if a trigger with the same name exists on the same
-    ///     entity type.
-    /// </summary>
-    /// <param name="entityType">The entityType to add the trigger to.</param>
-    /// <param name="name">The trigger name.</param>
-    /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
-    /// <returns>The trigger.</returns>
-    public static IConventionTrigger AddTrigger(
-        this IConventionEntityType entityType,
-        string name,
-        bool fromDataAnnotation = false)
-    {
-        Check.NotEmpty(name, nameof(name));
-
-        return new Trigger(
-            (IMutableEntityType)entityType, name, tableName: null, tableSchema: null,
-            fromDataAnnotation ? ConfigurationSource.DataAnnotation : ConfigurationSource.Convention);
-    }
-
-    /// <summary>
-    ///     Creates a new trigger with the given name on entity type. Throws an exception if a trigger with the same name exists on the same
-    ///     entity type.
-    /// </summary>
-    /// <param name="entityType">The entityType to add the trigger to.</param>
-    /// <param name="name">The trigger name.</param>
-    /// <param name="tableName">The name of the table on which this trigger is defined.</param>
-    /// <param name="tableSchema">The schema of the table on which this trigger is defined.</param>
-    /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
-    /// <returns>The trigger.</returns>
-    public static IConventionTrigger AddTrigger(
-        this IConventionEntityType entityType,
-        string name,
-        string tableName,
-        string? tableSchema,
-        bool fromDataAnnotation = false)
-    {
-        Check.NotEmpty(name, nameof(name));
-
-        return new Trigger(
-            (IMutableEntityType)entityType, name, tableName, tableSchema,
-            fromDataAnnotation ? ConfigurationSource.DataAnnotation : ConfigurationSource.Convention);
-    }
-
-    /// <summary>
-    ///     Removes the <see cref="IMutableTrigger" /> with the given name.
-    /// </summary>
-    /// <param name="entityType">The entityType to find the trigger in.</param>
-    /// <param name="name">The trigger name.</param>
-    /// <returns>
-    ///     The removed <see cref="IMutableTrigger" /> or <see langword="null" /> if no trigger with the given name was found.
-    /// </returns>
-    public static IMutableTrigger? RemoveTrigger(this IMutableEntityType entityType, string name)
-        => Trigger.RemoveTrigger(entityType, name);
-
-    /// <summary>
-    ///     Removes the <see cref="IConventionTrigger" /> with the given name.
-    /// </summary>
-    /// <param name="entityType">The entityType to find the trigger in.</param>
-    /// <param name="name">The trigger name.</param>
-    /// <returns>
-    ///     The removed <see cref="IMutableTrigger" /> or <see langword="null" /> if no trigger with the given name was found
-    ///     or the existing trigger was configured from a higher source.
-    /// </returns>
-    public static IConventionTrigger? RemoveTrigger(this IConventionEntityType entityType, string name)
-        => Trigger.RemoveTrigger((IMutableEntityType)entityType, name);
-
-    /// <summary>
-    ///     Returns all triggers on the entity type.
-    /// </summary>
-    /// <param name="entityType">The entity type to get the triggers on.</param>
-    public static IEnumerable<IReadOnlyTrigger> GetTriggers(this IReadOnlyEntityType entityType)
-        => Trigger.GetTriggers(entityType);
-
-    /// <summary>
-    ///     Returns all triggers on the entity type.
-    /// </summary>
-    /// <param name="entityType">The entity type to get the triggers on.</param>
-    public static IEnumerable<IMutableTrigger> GetTriggers(this IMutableEntityType entityType)
-        => Trigger.GetTriggers(entityType).Cast<IMutableTrigger>();
-
-    /// <summary>
-    ///     Returns all triggers on the entity type.
-    /// </summary>
-    /// <param name="entityType">The entity type to get the triggers on.</param>
-    public static IEnumerable<IConventionTrigger> GetTriggers(this IConventionEntityType entityType)
-        => Trigger.GetTriggers(entityType).Cast<IConventionTrigger>();
-
-    /// <summary>
-    ///     Returns all triggers on the entity type.
-    /// </summary>
-    /// <param name="entityType">The entity type to get the triggers on.</param>
-    public static IEnumerable<ITrigger> GetTriggers(this IEntityType entityType)
-        => Trigger.GetTriggers(entityType).Cast<ITrigger>();
-
-    /// <summary>
-    ///     Returns all triggers on the entity type.
-    /// </summary>
-    /// <param name="entityType">The entity type to get the triggers on.</param>
-    /// <remarks>
-    ///     This method does not return triggers declared on base types.
-    ///     It is useful when iterating over all entity types to avoid processing the same trigger more than once.
-    ///     Use <see cref="GetTriggers(IReadOnlyEntityType)" /> to also return triggers declared on base types.
-    /// </remarks>
-    public static IEnumerable<IReadOnlyTrigger> GetDeclaredTriggers(this IReadOnlyEntityType entityType)
-        => Trigger.GetDeclaredTriggers(entityType);
-
-    /// <summary>
-    ///     Returns all triggers on the entity type.
-    /// </summary>
-    /// <param name="entityType">The entity type to get the triggers on.</param>
-    /// <remarks>
-    ///     This method does not return triggers declared on base types.
-    ///     It is useful when iterating over all entity types to avoid processing the same trigger more than once.
-    ///     Use <see cref="GetTriggers(IMutableEntityType)" /> to also return triggers declared on base types.
-    /// </remarks>
-    public static IEnumerable<IMutableTrigger> GetDeclaredTriggers(this IMutableEntityType entityType)
-        => Trigger.GetDeclaredTriggers(entityType).Cast<IMutableTrigger>();
-
-    /// <summary>
-    ///     Returns all triggers on the entity type.
-    /// </summary>
-    /// <param name="entityType">The entity type to get the triggers on.</param>
-    /// <remarks>
-    ///     This method does not return triggers declared on base types.
-    ///     It is useful when iterating over all entity types to avoid processing the same trigger more than once.
-    ///     Use <see cref="GetTriggers(IConventionEntityType)" /> to also return triggers declared on base types.
-    /// </remarks>
-    public static IEnumerable<IConventionTrigger> GetDeclaredTriggers(this IConventionEntityType entityType)
-        => Trigger.GetDeclaredTriggers(entityType).Cast<IConventionTrigger>();
-
-    /// <summary>
-    ///     Returns all triggers on the entity type.
-    /// </summary>
-    /// <param name="entityType">The entity type to get the triggers on.</param>
-    /// <remarks>
-    ///     This method does not return triggers declared on base types.
-    ///     It is useful when iterating over all entity types to avoid processing the same trigger more than once.
-    ///     Use <see cref="GetTriggers(IEntityType)" /> to also return triggers declared on base types.
-    /// </remarks>
-    public static IEnumerable<ITrigger> GetDeclaredTriggers(this IEntityType entityType)
-        => Trigger.GetDeclaredTriggers(entityType).Cast<ITrigger>();
-
-    #endregion Trigger
-
     #region Json
 
     /// <summary>
diff --git a/src/EFCore.Relational/Extensions/RelationalIndexExtensions.cs b/src/EFCore.Relational/Extensions/RelationalIndexExtensions.cs
index e0fbff82b5..036729feee 100644
--- a/src/EFCore.Relational/Extensions/RelationalIndexExtensions.cs
+++ b/src/EFCore.Relational/Extensions/RelationalIndexExtensions.cs
@@ -67,7 +67,7 @@ public static class RelationalIndexExtensions
     /// <returns>The default name that would be used for this index.</returns>
     public static string? GetDefaultDatabaseName(this IReadOnlyIndex index, in StoreObjectIdentifier storeObject)
         => index.GetDefaultDatabaseName(storeObject, null);
-    
+
     /// <summary>
     ///     Sets the name of the index in the database.
     /// </summary>
diff --git a/src/EFCore.Relational/Extensions/RelationalPropertyBuilderExtensions.cs b/src/EFCore.Relational/Extensions/RelationalPropertyBuilderExtensions.cs
index b6187f7c04..64e37a330a 100644
--- a/src/EFCore.Relational/Extensions/RelationalPropertyBuilderExtensions.cs
+++ b/src/EFCore.Relational/Extensions/RelationalPropertyBuilderExtensions.cs
@@ -357,7 +357,7 @@ public static bool CanSetColumnOrder(this IConventionPropertyBuilder propertyBui
         bool? fixedLength,
         bool fromDataAnnotation = false)
         => propertyBuilder.CanSetAnnotation(RelationalAnnotationNames.IsFixedLength, fixedLength, fromDataAnnotation);
-    
+
     /// <summary>
     ///     Configures the default value expression for the column that the property maps to when targeting a
     ///     relational database.
diff --git a/src/EFCore.Relational/Extensions/RelationalTriggerBuilderExtensions.cs b/src/EFCore.Relational/Extensions/RelationalTriggerBuilderExtensions.cs
new file mode 100644
index 0000000000..61773f89a5
--- /dev/null
+++ b/src/EFCore.Relational/Extensions/RelationalTriggerBuilderExtensions.cs
@@ -0,0 +1,101 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+// ReSharper disable once CheckNamespace
+namespace Microsoft.EntityFrameworkCore;
+
+/// <summary>
+///     Relational database specific extension methods for <see cref="TriggerBuilder" />.
+/// </summary>
+/// <remarks>
+///     See <see href="https://aka.ms/efcore-docs-triggers">Database triggers</see> for more information and examples.
+/// </remarks>
+public static class RelationalTriggerBuilderExtensions
+{
+    /// <summary>
+    ///     Sets the database name of the trigger.
+    /// </summary>
+    /// <param name="triggerBuilder">The builder for the trigger being configured.</param>
+    /// <param name="name">The database name of the trigger.</param>
+    /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
+    /// <returns>The same builder instance if the configuration was applied, <see langword="null" /> otherwise.</returns>
+    public static IConventionTriggerBuilder? HasName(
+        this IConventionTriggerBuilder triggerBuilder, string? name, bool fromDataAnnotation = false)
+    {
+        if (!triggerBuilder.CanSetName(name, fromDataAnnotation))
+        {
+            return null;
+        }
+
+        triggerBuilder.Metadata.SetName(name, fromDataAnnotation);
+        return triggerBuilder;
+    }
+
+    /// <summary>
+    ///     Returns a value indicating whether the given name can be set for the trigger.
+    /// </summary>
+    /// <param name="triggerBuilder">The builder for the trigger being configured.</param>
+    /// <param name="name">The database name of the trigger.</param>
+    /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
+    /// <returns><see langword="true" /> if the database name can be set for the trigger.</returns>
+    public static bool CanSetName(this IConventionTriggerBuilder triggerBuilder, string? name, bool fromDataAnnotation = false)
+        => triggerBuilder.CanSetAnnotation(RelationalAnnotationNames.Name, name, fromDataAnnotation);
+
+    /// <summary>
+    ///     Sets name of the table on which this trigger is defined.
+    /// </summary>
+    /// <param name="triggerBuilder">The builder for the trigger being configured.</param>
+    /// <param name="name">The name of the table on which this trigger is defined.</param>
+    /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
+    /// <returns>The same builder instance if the configuration was applied, <see langword="null" /> otherwise.</returns>
+    public static IConventionTriggerBuilder? HasTableName(
+        this IConventionTriggerBuilder triggerBuilder, string? name, bool fromDataAnnotation = false)
+    {
+        if (!triggerBuilder.CanSetTableName(name, fromDataAnnotation))
+        {
+            return null;
+        }
+
+        triggerBuilder.Metadata.SetTableName(name, fromDataAnnotation);
+        return triggerBuilder;
+    }
+
+    /// <summary>
+    ///     Returns a value indicating whether the given table name can be set for the trigger.
+    /// </summary>
+    /// <param name="triggerBuilder">The builder for the trigger being configured.</param>
+    /// <param name="name">The name of the table on which this trigger is defined.</param>
+    /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
+    /// <returns><see langword="true" /> if the table name can be set for the trigger.</returns>
+    public static bool CanSetTableName(this IConventionTriggerBuilder triggerBuilder, string? name, bool fromDataAnnotation = false)
+        => triggerBuilder.CanSetAnnotation(RelationalAnnotationNames.TableName, name, fromDataAnnotation);
+
+    /// <summary>
+    ///     Sets the schema of the table on which this trigger is defined.
+    /// </summary>
+    /// <param name="triggerBuilder">The builder for the trigger being configured.</param>
+    /// <param name="schema">The schema of the table on which this trigger is defined.</param>
+    /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
+    /// <returns>The same builder instance if the configuration was applied, <see langword="null" /> otherwise.</returns>
+    public static IConventionTriggerBuilder? HasTableSchema(
+        this IConventionTriggerBuilder triggerBuilder, string? schema, bool fromDataAnnotation = false)
+    {
+        if (!triggerBuilder.CanSetTableSchema(schema, fromDataAnnotation))
+        {
+            return null;
+        }
+
+        triggerBuilder.Metadata.SetTableSchema(schema, fromDataAnnotation);
+        return triggerBuilder;
+    }
+
+    /// <summary>
+    ///     Returns a value indicating whether the given table schema can be set for the trigger.
+    /// </summary>
+    /// <param name="triggerBuilder">The builder for the trigger being configured.</param>
+    /// <param name="schema">The schema of the table on which this trigger is defined.</param>
+    /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
+    /// <returns><see langword="true" /> if the database name can be set for the trigger.</returns>
+    public static bool CanSetTableSchema(this IConventionTriggerBuilder triggerBuilder, string? schema, bool fromDataAnnotation = false)
+        => triggerBuilder.CanSetAnnotation(RelationalAnnotationNames.Schema, schema, fromDataAnnotation);
+}
diff --git a/src/EFCore.Relational/Extensions/RelationalTriggerExtensions.cs b/src/EFCore.Relational/Extensions/RelationalTriggerExtensions.cs
new file mode 100644
index 0000000000..eece3f04c7
--- /dev/null
+++ b/src/EFCore.Relational/Extensions/RelationalTriggerExtensions.cs
@@ -0,0 +1,186 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.EntityFrameworkCore.Metadata.Internal;
+
+// ReSharper disable once CheckNamespace
+namespace Microsoft.EntityFrameworkCore;
+
+/// <summary>
+///     Trigger extension methods for relational database metadata.
+/// </summary>
+/// <remarks>
+///     See <see href="https://aka.ms/efcore-docs-triggers">Database triggers</see> for more information and examples.
+/// </remarks>
+public static class RelationalTriggerExtensions
+{
+    /// <summary>
+    ///     Gets the name of the trigger in the database.
+    /// </summary>
+    /// <param name="trigger">The trigger.</param>
+    /// <returns>The name of the trigger in the database.</returns>
+    public static string? GetName(this IReadOnlyTrigger trigger)
+    {
+        if (trigger.EntityType.GetTableName() == null)
+        {
+            return null;
+        }
+
+        var annotation = trigger.FindAnnotation(RelationalAnnotationNames.Name);
+        return annotation != null ? (string?)annotation.Value : trigger.GetDefaultName();
+    }
+
+    /// <summary>
+    ///     Returns the default name that would be used for this trigger in the database.
+    /// </summary>
+    /// <param name="trigger">The trigger.</param>
+    /// <returns>The default name that would be used for this trigger in the database.</returns>
+    public static string? GetDefaultName(this IReadOnlyTrigger trigger)
+    {
+        var table = StoreObjectIdentifier.Create(trigger.EntityType, StoreObjectType.Table);
+        return !table.HasValue ? null : trigger.GetDefaultName(table.Value);
+    }
+
+    /// <summary>
+    ///     Gets the database name of the trigger.
+    /// </summary>
+    /// <param name="trigger">The trigger.</param>
+    /// <param name="storeObject">The identifier of the store object.</param>
+    /// <returns>The database name of the trigger for the given store object.</returns>
+    public static string? GetName(this IReadOnlyTrigger trigger, in StoreObjectIdentifier storeObject)
+    {
+        var triggerTable = trigger.GetTableName();
+        if (storeObject.StoreObjectType != StoreObjectType.Table
+            || (triggerTable != null
+                && (trigger.GetTableName() != storeObject.Name
+                    || trigger.GetTableSchema() != storeObject.Schema)))
+        {
+            return null;
+        }
+
+        var annotation = trigger.FindAnnotation(RelationalAnnotationNames.Name);
+        return annotation != null ? (string?)annotation.Value : trigger.GetDefaultName(storeObject);
+    }
+
+    /// <summary>
+    ///     Returns the default database name that would be used for this trigger.
+    /// </summary>
+    /// <param name="trigger">The trigger.</param>
+    /// <param name="storeObject">The identifier of the store object.</param>
+    /// <returns>The default name that would be used for this trigger.</returns>
+    public static string? GetDefaultName(this IReadOnlyTrigger trigger, in StoreObjectIdentifier storeObject)
+        => storeObject.StoreObjectType == StoreObjectType.Table
+            ? Uniquifier.Truncate(trigger.ModelName, trigger.EntityType.Model.GetMaxIdentifierLength())
+            : null;
+
+    /// <summary>
+    ///     Sets the name of the trigger in the database.
+    /// </summary>
+    /// <param name="trigger">The trigger.</param>
+    /// <param name="name">The name of the trigger in the database.</param>
+    public static void SetName(this IMutableTrigger trigger, string? name)
+        => trigger.SetOrRemoveAnnotation(
+            RelationalAnnotationNames.Name,
+            Check.NullButNotEmpty(name, nameof(name)));
+
+    /// <summary>
+    ///     Sets the name of the trigger in the database.
+    /// </summary>
+    /// <param name="trigger">The trigger.</param>
+    /// <param name="name">The name of the trigger in the database.</param>
+    /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
+    /// <returns>The configured value.</returns>
+    public static string? SetName(this IConventionTrigger trigger, string? name, bool fromDataAnnotation = false)
+        => (string?)trigger.SetOrRemoveAnnotation(
+            RelationalAnnotationNames.Name,
+            Check.NullButNotEmpty(name, nameof(name)),
+            fromDataAnnotation)?.Value;
+
+    /// <summary>
+    ///     Gets the configuration source for the database name.
+    /// </summary>
+    /// <param name="trigger">The trigger.</param>
+    /// <returns>The configuration source for the database name.</returns>
+    public static ConfigurationSource? GetNameConfigurationSource(this IConventionTrigger trigger)
+        => trigger.FindAnnotation(RelationalAnnotationNames.Name)?.GetConfigurationSource();
+
+    /// <summary>
+    ///     Gets the name of the table on which this trigger is defined.
+    /// </summary>
+    /// <param name="trigger">The trigger.</param>
+    /// <returns>The name of the table on which this trigger is defined.</returns>
+    public static string? GetTableName(this IReadOnlyTrigger trigger)
+        => (string?)trigger.FindAnnotation(RelationalAnnotationNames.TableName)?.Value
+            ?? trigger.EntityType.GetTableName()!;
+
+    /// <summary>
+    ///     Sets the name of the table on which this trigger is defined.
+    /// </summary>
+    /// <param name="trigger">The trigger.</param>
+    /// <param name="name">The name of the table on which this trigger is defined.</param>
+    public static void SetTableName(this IMutableTrigger trigger, string? name)
+        => trigger.SetOrRemoveAnnotation(
+            RelationalAnnotationNames.TableName,
+            Check.NullButNotEmpty(name, nameof(name)));
+
+    /// <summary>
+    ///     Sets the name of the table on which this trigger is defined.
+    /// </summary>
+    /// <param name="trigger">The trigger.</param>
+    /// <param name="name">The name of the table on which this trigger is defined.</param>
+    /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
+    /// <returns>The configured value.</returns>
+    public static string? SetTableName(this IConventionTrigger trigger, string? name, bool fromDataAnnotation = false)
+        => (string?)trigger.SetOrRemoveAnnotation(
+            RelationalAnnotationNames.TableName,
+            Check.NullButNotEmpty(name, nameof(name)),
+            fromDataAnnotation)?.Value;
+
+    /// <summary>
+    ///     Gets the configuration source for the table name.
+    /// </summary>
+    /// <param name="trigger">The trigger.</param>
+    /// <returns>The configuration source for the database name.</returns>
+    public static ConfigurationSource? GetTableNameConfigurationSource(this IConventionTrigger trigger)
+        => trigger.FindAnnotation(RelationalAnnotationNames.TableName)?.GetConfigurationSource();
+
+    /// <summary>
+    ///     Gets the schema of the table on which this trigger is defined.
+    /// </summary>
+    /// <param name="trigger">The trigger.</param>
+    /// <returns>The schema of the table on which this trigger is defined.</returns>
+    public static string? GetTableSchema(this IReadOnlyTrigger trigger)
+        => (string?)trigger.FindAnnotation(RelationalAnnotationNames.Schema)?.Value
+            ?? trigger.EntityType.GetSchema();
+
+    /// <summary>
+    ///     Sets the schema of the table on which this trigger is defined.
+    /// </summary>
+    /// <param name="trigger">The trigger.</param>
+    /// <param name="schema">The schema of the table on which this trigger is defined.</param>
+    public static void SetTableSchema(this IMutableTrigger trigger, string? schema)
+        => trigger.SetOrRemoveAnnotation(
+            RelationalAnnotationNames.Schema,
+            Check.NullButNotEmpty(schema, nameof(schema)));
+
+    /// <summary>
+    ///     Sets the schema of the table on which this trigger is defined.
+    /// </summary>
+    /// <param name="trigger">The trigger.</param>
+    /// <param name="schema">The schema of the table on which this trigger is defined.</param>
+    /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
+    /// <returns>The configured value.</returns>
+    public static string? SetTableSchema(this IConventionTrigger trigger, string? schema, bool fromDataAnnotation = false)
+        => (string?)trigger.SetOrRemoveAnnotation(
+            RelationalAnnotationNames.Schema,
+            Check.NullButNotEmpty(schema, nameof(schema)),
+            fromDataAnnotation)?.Value;
+
+    /// <summary>
+    ///     Gets the configuration source for the table schema.
+    /// </summary>
+    /// <param name="trigger">The trigger.</param>
+    /// <returns>The configuration source for the database name.</returns>
+    public static ConfigurationSource? GetTableSchemaConfigurationSource(this IConventionTrigger trigger)
+        => trigger.FindAnnotation(RelationalAnnotationNames.Schema)?.GetConfigurationSource();
+}
diff --git a/src/EFCore.Relational/Infrastructure/RelationalModelValidator.cs b/src/EFCore.Relational/Infrastructure/RelationalModelValidator.cs
index 00bd1fd1f3..3f0f46c65b 100644
--- a/src/EFCore.Relational/Infrastructure/RelationalModelValidator.cs
+++ b/src/EFCore.Relational/Infrastructure/RelationalModelValidator.cs
@@ -2306,7 +2306,7 @@ protected override bool IsRedundant(IForeignKey foreignKey)
     /// </summary>
     /// <param name="model">The model to validate.</param>
     /// <param name="logger">The logger to use.</param>
-    protected virtual void ValidateTriggers(
+    protected override void ValidateTriggers(
         IModel model,
         IDiagnosticsLogger<DbLoggerCategory.Model.Validation> logger)
     {
@@ -2317,21 +2317,15 @@ protected override bool IsRedundant(IForeignKey foreignKey)
 
             foreach (var trigger in entityType.GetDeclaredTriggers())
             {
-                if (tableName is null)
-                {
-                    throw new InvalidOperationException(
-                        RelationalStrings.TriggerOnUnmappedEntityType(trigger.ModelName, entityType.DisplayName()));
-                }
-
-                if ((trigger.TableName != tableName
-                    || trigger.TableSchema != tableSchema)
+                if ((trigger.GetTableName() != tableName
+                    || trigger.GetTableSchema() != tableSchema)
                     && entityType.GetMappingFragments(StoreObjectType.Table)
-                        .All(f => trigger.TableName != f.StoreObject.Name || trigger.TableSchema != f.StoreObject.Schema))
+                        .All(f => trigger.GetTableName() != f.StoreObject.Name || trigger.GetTableSchema() != f.StoreObject.Schema))
                 {
                     throw new InvalidOperationException(
                         RelationalStrings.TriggerWithMismatchedTable(
                             trigger.ModelName,
-                            (trigger.TableName, trigger.TableSchema).FormatTable(),
+                            (trigger.GetTableName()!, trigger.GetTableSchema()).FormatTable(),
                             entityType.DisplayName(),
                             entityType.GetSchemaQualifiedTableName())
                     );
diff --git a/src/EFCore.Relational/Metadata/Builders/IConventionTriggerBuilder.cs b/src/EFCore.Relational/Metadata/Builders/IConventionTriggerBuilder.cs
deleted file mode 100644
index e53400cc70..0000000000
--- a/src/EFCore.Relational/Metadata/Builders/IConventionTriggerBuilder.cs
+++ /dev/null
@@ -1,34 +0,0 @@
-// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-namespace Microsoft.EntityFrameworkCore.Metadata.Builders;
-
-/// <summary>
-///     Provides an API point for provider-specific extensions for configuring a <see cref="IConventionTrigger" />.
-/// </summary>
-/// <remarks>
-///     See <see href="https://aka.ms/efcore-docs-conventions">Model building conventions</see> for more information and examples.
-/// </remarks>
-public interface IConventionTriggerBuilder : IConventionAnnotatableBuilder
-{
-    /// <summary>
-    ///     The trigger being configured.
-    /// </summary>
-    new IConventionTrigger Metadata { get; }
-
-    /// <summary>
-    ///     Sets the database name of the trigger.
-    /// </summary>
-    /// <param name="name">The database name of the trigger.</param>
-    /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
-    /// <returns>The same builder instance if the configuration was applied, <see langword="null" /> otherwise.</returns>
-    IConventionTriggerBuilder? HasName(string? name, bool fromDataAnnotation = false);
-
-    /// <summary>
-    ///     Returns a value indicating whether the given name can be set for the trigger.
-    /// </summary>
-    /// <param name="name">The database name of the trigger.</param>
-    /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
-    /// <returns><see langword="true" /> if the database name can be set for the trigger.</returns>
-    bool CanSetName(string? name, bool fromDataAnnotation = false);
-}
diff --git a/src/EFCore.Relational/Metadata/Builders/OwnedNavigationSplitTableBuilder.cs b/src/EFCore.Relational/Metadata/Builders/OwnedNavigationSplitTableBuilder.cs
index 171b2d2b19..f907027177 100644
--- a/src/EFCore.Relational/Metadata/Builders/OwnedNavigationSplitTableBuilder.cs
+++ b/src/EFCore.Relational/Metadata/Builders/OwnedNavigationSplitTableBuilder.cs
@@ -78,13 +78,14 @@ public virtual OwnedNavigationSplitTableBuilder ExcludeFromMigrations(bool exclu
     /// <remarks>
     ///     See <see href="https://aka.ms/efcore-docs-triggers">Database triggers</see> for more information and examples.
     /// </remarks>
-    public virtual TriggerBuilder HasTrigger(string modelName)
-        => new((Trigger)InternalTriggerBuilder.HasTrigger(
-            (IConventionEntityType)MappingFragment.EntityType,
-            modelName,
-            Name,
-            Schema,
-            ConfigurationSource.Explicit)!);
+    public virtual TableTriggerBuilder HasTrigger(string modelName)
+    {
+        var trigger = EntityTypeBuilder.HasTrigger(modelName, OwnedNavigationBuilder.OwnedEntityType).Metadata;
+        trigger.SetTableName(Name);
+        trigger.SetTableSchema(Schema);
+
+        return new(trigger);
+    }
 
     /// <summary>
     ///     Maps the property to a column on the current table and returns an object that can be used
diff --git a/src/EFCore.Relational/Metadata/Builders/OwnedNavigationTableBuilder.cs b/src/EFCore.Relational/Metadata/Builders/OwnedNavigationTableBuilder.cs
index 84b5abeb0c..c05d721c70 100644
--- a/src/EFCore.Relational/Metadata/Builders/OwnedNavigationTableBuilder.cs
+++ b/src/EFCore.Relational/Metadata/Builders/OwnedNavigationTableBuilder.cs
@@ -74,13 +74,17 @@ public virtual OwnedNavigationTableBuilder ExcludeFromMigrations(bool excluded =
     /// <remarks>
     ///     See <see href="https://aka.ms/efcore-docs-triggers">Database triggers</see> for more information and examples.
     /// </remarks>
-    public virtual TriggerBuilder HasTrigger(string modelName)
-        => new((Trigger)InternalTriggerBuilder.HasTrigger(
-            (IConventionEntityType)Metadata,
-            modelName,
-            Name,
-            Schema,
-            ConfigurationSource.Explicit)!);
+    public virtual TableTriggerBuilder HasTrigger(string modelName)
+    {
+        var trigger = EntityTypeBuilder.HasTrigger(modelName, Metadata).Metadata;
+        if (Name != null)
+        {
+            trigger.SetTableName(Name);
+            trigger.SetTableSchema(Schema);
+        }
+
+        return new(trigger);
+    }
 
     /// <summary>
     ///     Configures a database check constraint when targeting a relational database.
@@ -97,7 +101,7 @@ public virtual TriggerBuilder HasTrigger(string modelName)
     {
         Check.NotEmpty(name, nameof(name));
         Check.NullButNotEmpty(sql, nameof(sql));
-        
+
         var checkConstraint = InternalCheckConstraintBuilder.HasCheckConstraint(
             (IConventionEntityType)Metadata,
             name,
@@ -106,7 +110,7 @@ public virtual TriggerBuilder HasTrigger(string modelName)
 
         return new((IMutableCheckConstraint)checkConstraint);
     }
-    
+
     /// <summary>
     ///     Configures a comment to be applied to the table
     /// </summary>
diff --git a/src/EFCore.Relational/Metadata/Builders/SplitTableBuilder.cs b/src/EFCore.Relational/Metadata/Builders/SplitTableBuilder.cs
index 6b366a8b07..e52a9ec5d7 100644
--- a/src/EFCore.Relational/Metadata/Builders/SplitTableBuilder.cs
+++ b/src/EFCore.Relational/Metadata/Builders/SplitTableBuilder.cs
@@ -78,13 +78,14 @@ public virtual SplitTableBuilder ExcludeFromMigrations(bool excluded = true)
     /// <remarks>
     ///     See <see href="https://aka.ms/efcore-docs-triggers">Database triggers</see> for more information and examples.
     /// </remarks>
-    public virtual TriggerBuilder HasTrigger(string modelName)
-        => new((Trigger)InternalTriggerBuilder.HasTrigger(
-            (IConventionEntityType)MappingFragment.EntityType,
-            modelName,
-            Name,
-            Schema,
-            ConfigurationSource.Explicit)!);
+    public virtual TableTriggerBuilder HasTrigger(string modelName)
+    {
+        var trigger = EntityTypeBuilder.HasTrigger(modelName, EntityTypeBuilder.Metadata).Metadata;
+        trigger.SetTableName(Name);
+        trigger.SetTableSchema(Schema);
+
+        return new(trigger);
+    }
 
     /// <summary>
     ///     Maps the property to a column on the current table and returns an object that can be used
diff --git a/src/EFCore.Relational/Metadata/Builders/TableBuilder.cs b/src/EFCore.Relational/Metadata/Builders/TableBuilder.cs
index 2c63d1de81..8143ebfff7 100644
--- a/src/EFCore.Relational/Metadata/Builders/TableBuilder.cs
+++ b/src/EFCore.Relational/Metadata/Builders/TableBuilder.cs
@@ -3,6 +3,7 @@
 
 using System.ComponentModel;
 using Microsoft.EntityFrameworkCore.Metadata.Internal;
+using Microsoft.Extensions.Configuration;
 
 namespace Microsoft.EntityFrameworkCore.Metadata.Builders;
 
@@ -74,14 +75,18 @@ public virtual TableBuilder ExcludeFromMigrations(bool excluded = true)
     /// <remarks>
     ///     See <see href="https://aka.ms/efcore-docs-triggers">Database triggers</see> for more information and examples.
     /// </remarks>
-    public virtual TriggerBuilder HasTrigger(string modelName)
-        => new((Trigger)InternalTriggerBuilder.HasTrigger(
-            (IConventionEntityType)Metadata,
-            modelName,
-            Name,
-            Schema,
-            ConfigurationSource.Explicit)!);
-    
+    public virtual TableTriggerBuilder HasTrigger(string modelName)
+    {
+        var trigger = EntityTypeBuilder.HasTrigger(modelName, Metadata).Metadata;
+        if (Name != null)
+        {
+            trigger.SetTableName(Name);
+            trigger.SetTableSchema(Schema);
+        }
+
+        return new(trigger);
+    }
+
     /// <summary>
     ///     Configures a database check constraint when targeting a relational database.
     /// </summary>
@@ -97,7 +102,7 @@ public virtual TriggerBuilder HasTrigger(string modelName)
     {
         Check.NotEmpty(name, nameof(name));
         Check.NullButNotEmpty(sql, nameof(sql));
-        
+
         var checkConstraint = InternalCheckConstraintBuilder.HasCheckConstraint(
             (IConventionEntityType)EntityTypeBuilder.Metadata,
             name,
@@ -106,7 +111,7 @@ public virtual TriggerBuilder HasTrigger(string modelName)
 
         return new((IMutableCheckConstraint)checkConstraint);
     }
-    
+
     /// <summary>
     ///     Configures a comment to be applied to the table
     /// </summary>
diff --git a/src/EFCore.Relational/Metadata/Builders/TableTriggerBuilder.cs b/src/EFCore.Relational/Metadata/Builders/TableTriggerBuilder.cs
new file mode 100644
index 0000000000..33c15b9c02
--- /dev/null
+++ b/src/EFCore.Relational/Metadata/Builders/TableTriggerBuilder.cs
@@ -0,0 +1,82 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.ComponentModel;
+using System.Xml.Linq;
+using Microsoft.EntityFrameworkCore.Metadata.Internal;
+
+namespace Microsoft.EntityFrameworkCore.Metadata.Builders;
+
+/// <summary>
+///     Provides an API point for provider-specific extensions for configuring a <see cref="ITrigger" />.
+/// </summary>
+/// <remarks>
+///     See <see href="https://aka.ms/efcore-docs-triggers">Database triggers</see> for more information and examples.
+/// </remarks>
+public class TableTriggerBuilder : TriggerBuilder
+{
+    /// <summary>
+    ///     Creates a new builder for the given trigger.
+    /// </summary>
+    /// <param name="trigger">The trigger to configure.</param>
+    public TableTriggerBuilder(IMutableTrigger trigger)
+        : base(trigger)
+    {
+    }
+
+    /// <summary>
+    ///     Sets the database name of the trigger.
+    /// </summary>
+    /// <remarks>
+    ///     See <see href="https://aka.ms/efcore-docs-triggers">Database triggers</see> for more information and examples.
+    /// </remarks>
+    /// <param name="name">The database name of the trigger.</param>
+    /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
+    public virtual TableTriggerBuilder HasName(string? name)
+    {
+        Metadata.SetName(name);
+
+        return this;
+    }
+
+    /// <summary>
+    ///     Adds or updates an annotation on the trigger. If an annotation with the key specified in <paramref name="annotation" />
+    ///     already exists, its value will be updated.
+    /// </summary>
+    /// <param name="annotation">The key of the annotation to be added or updated.</param>
+    /// <param name="value">The value to be stored in the annotation.</param>
+    /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
+    public new virtual TableTriggerBuilder HasAnnotation(string annotation, object? value)
+        => (TableTriggerBuilder)base.HasAnnotation(annotation, value);
+
+    #region Hidden System.Object members
+
+    /// <summary>
+    ///     Returns a string that represents the current object.
+    /// </summary>
+    /// <returns>A string that represents the current object.</returns>
+    [EditorBrowsable(EditorBrowsableState.Never)]
+    public override string? ToString()
+        => base.ToString();
+
+    /// <summary>
+    ///     Determines whether the specified object is equal to the current object.
+    /// </summary>
+    /// <param name="obj">The object to compare with the current object.</param>
+    /// <returns><see langword="true" /> if the specified object is equal to the current object; otherwise, <see langword="false" />.</returns>
+    [EditorBrowsable(EditorBrowsableState.Never)]
+    // ReSharper disable once BaseObjectEqualsIsObjectEquals
+    public override bool Equals(object? obj)
+        => base.Equals(obj);
+
+    /// <summary>
+    ///     Serves as the default hash function.
+    /// </summary>
+    /// <returns>A hash code for the current object.</returns>
+    [EditorBrowsable(EditorBrowsableState.Never)]
+    // ReSharper disable once BaseObjectGetHashCodeCallInGetHashCode
+    public override int GetHashCode()
+        => base.GetHashCode();
+
+    #endregion
+}
diff --git a/src/EFCore.Relational/Metadata/Conventions/Infrastructure/RelationalConventionSetBuilder.cs b/src/EFCore.Relational/Metadata/Conventions/Infrastructure/RelationalConventionSetBuilder.cs
index b89f188eff..4955cc7abd 100644
--- a/src/EFCore.Relational/Metadata/Conventions/Infrastructure/RelationalConventionSetBuilder.cs
+++ b/src/EFCore.Relational/Metadata/Conventions/Infrastructure/RelationalConventionSetBuilder.cs
@@ -69,7 +69,6 @@ public override ConventionSet CreateConventionSet()
         conventionSet.Add(new TableNameFromDbSetConvention(Dependencies, RelationalDependencies));
         conventionSet.Add(new PropertyOverridesConvention(Dependencies, RelationalDependencies));
         conventionSet.Add(new CheckConstraintConvention(Dependencies, RelationalDependencies));
-        conventionSet.Add(new TriggerConvention(Dependencies, RelationalDependencies));
         conventionSet.Add(new StoredProcedureConvention(Dependencies, RelationalDependencies));
         conventionSet.Add(new TableValuedDbFunctionConvention(Dependencies, RelationalDependencies));
         conventionSet.Add(new StoreGenerationConvention(Dependencies, RelationalDependencies));
diff --git a/src/EFCore.Relational/Metadata/Conventions/RelationalRuntimeModelConvention.cs b/src/EFCore.Relational/Metadata/Conventions/RelationalRuntimeModelConvention.cs
index de71291234..5fa76e3a91 100644
--- a/src/EFCore.Relational/Metadata/Conventions/RelationalRuntimeModelConvention.cs
+++ b/src/EFCore.Relational/Metadata/Conventions/RelationalRuntimeModelConvention.cs
@@ -136,7 +136,7 @@ public class RelationalRuntimeModelConvention : RuntimeModelConvention
             annotations.Remove(RelationalAnnotationNames.CheckConstraints);
             annotations.Remove(RelationalAnnotationNames.Comment);
             annotations.Remove(RelationalAnnotationNames.IsTableExcludedFromMigrations);
-                
+
             // These need to be set explicitly to prevent default values from being generated
             annotations[RelationalAnnotationNames.TableName] = entityType.GetTableName();
             annotations[RelationalAnnotationNames.Schema] = entityType.GetSchema();
@@ -162,56 +162,39 @@ public class RelationalRuntimeModelConvention : RuntimeModelConvention
                 annotations[RelationalAnnotationNames.MappingFragments] = runtimeEntityTypeMappingFragment;
             }
 
-            if (annotations.TryGetValue(RelationalAnnotationNames.Triggers, out var triggers))
-            {
-                var runtimeTriggers = new SortedDictionary<string, ITrigger>(StringComparer.Ordinal);
-                foreach (var (key, trigger) in (SortedDictionary<string, ITrigger>)triggers!)
-                {
-                    var runtimeTrigger = Create(trigger, runtimeEntityType);
-                    runtimeTriggers[key] = runtimeTrigger;
-
-                    CreateAnnotations(
-                        trigger, runtimeTrigger,
-                        static (convention, annotations, source, target, runtime)
-                            => convention.ProcessTriggerAnnotations(annotations, source, target, runtime));
-                }
-
-                annotations[RelationalAnnotationNames.Triggers] = runtimeTriggers;
-            }
-
             if (annotations.TryGetValue(RelationalAnnotationNames.InsertStoredProcedure, out var insertStoredProcedure))
             {
                 var runtimeSproc = Create((IStoredProcedure)insertStoredProcedure!, runtimeEntityType);
-                
+
                 CreateAnnotations(
                     (IStoredProcedure)insertStoredProcedure!, runtimeSproc,
                     static (convention, annotations, source, target, runtime)
                         => convention.ProcessStoredProcedureAnnotations(annotations, source, target, runtime));
-                
+
                 annotations[RelationalAnnotationNames.InsertStoredProcedure] = runtimeSproc;
             }
 
             if (annotations.TryGetValue(RelationalAnnotationNames.DeleteStoredProcedure, out var deleteStoredProcedure))
             {
                 var runtimeSproc = Create((IStoredProcedure)deleteStoredProcedure!, runtimeEntityType);
-                
+
                 CreateAnnotations(
                     (IStoredProcedure)deleteStoredProcedure!, runtimeSproc,
                     static (convention, annotations, source, target, runtime)
                         => convention.ProcessStoredProcedureAnnotations(annotations, source, target, runtime));
-                
+
                 annotations[RelationalAnnotationNames.DeleteStoredProcedure] = runtimeSproc;
             }
 
             if (annotations.TryGetValue(RelationalAnnotationNames.UpdateStoredProcedure, out var updateStoredProcedure))
             {
                 var runtimeSproc = Create((IStoredProcedure)updateStoredProcedure!, runtimeEntityType);
-                
+
                 CreateAnnotations(
                     (IStoredProcedure)updateStoredProcedure!, runtimeSproc,
                     static (convention, annotations, source, target, runtime)
                         => convention.ProcessStoredProcedureAnnotations(annotations, source, target, runtime));
-                
+
                 annotations[RelationalAnnotationNames.UpdateStoredProcedure] = runtimeSproc;
             }
         }
@@ -474,24 +457,6 @@ private static RuntimeSequence Create(ISequence sequence, RuntimeModel runtimeMo
         }
     }
 
-    private static RuntimeTrigger Create(ITrigger trigger, RuntimeEntityType runtimeEntityType)
-        => new(runtimeEntityType, trigger.ModelName, trigger.Name, trigger.TableName, trigger.TableSchema);
-
-    /// <summary>
-    ///     Updates the trigger annotations that will be set on the read-only object.
-    /// </summary>
-    /// <param name="annotations">The annotations to be processed.</param>
-    /// <param name="trigger">The source trigger.</param>
-    /// <param name="runtimeTrigger">The target trigger that will contain the annotations.</param>
-    /// <param name="runtime">Indicates whether the given annotations are runtime annotations.</param>
-    protected virtual void ProcessTriggerAnnotations(
-        Dictionary<string, object?> annotations,
-        ITrigger trigger,
-        RuntimeTrigger runtimeTrigger,
-        bool runtime)
-    {
-    }
-
     private RuntimeStoredProcedure Create(IStoredProcedure storedProcedure, RuntimeEntityType runtimeEntityType)
     {
         var runtimeStoredProcedure = new RuntimeStoredProcedure(
diff --git a/src/EFCore.Relational/Metadata/Conventions/TriggerConvention.cs b/src/EFCore.Relational/Metadata/Conventions/TriggerConvention.cs
deleted file mode 100644
index fd2ed5f937..0000000000
--- a/src/EFCore.Relational/Metadata/Conventions/TriggerConvention.cs
+++ /dev/null
@@ -1,162 +0,0 @@
-// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using Microsoft.EntityFrameworkCore.Metadata.Internal;
-
-namespace Microsoft.EntityFrameworkCore.Metadata.Conventions;
-
-/// <summary>
-///     A convention that ensures that the triggers on the derived types are compatible with the triggers on the base type.
-///     And also ensures that the declaring type is current.
-/// </summary>
-/// <remarks>
-///     See <see href="https://aka.ms/efcore-docs-conventions">Model building conventions</see> for more information and examples.
-/// </remarks>
-public class TriggerConvention : IEntityTypeBaseTypeChangedConvention, IEntityTypeAddedConvention
-{
-    /// <summary>
-    ///     Creates a new instance of <see cref="TriggerConvention" />.
-    /// </summary>
-    /// <param name="dependencies">Parameter object containing dependencies for this convention.</param>
-    /// <param name="relationalDependencies"> Parameter object containing relational dependencies for this convention.</param>
-    public TriggerConvention(
-        ProviderConventionSetBuilderDependencies dependencies,
-        RelationalConventionSetBuilderDependencies relationalDependencies)
-    {
-        Dependencies = dependencies;
-        RelationalDependencies = relationalDependencies;
-    }
-
-    /// <summary>
-    ///     Dependencies for this service.
-    /// </summary>
-    protected virtual ProviderConventionSetBuilderDependencies Dependencies { get; }
-
-    /// <summary>
-    ///     Relational provider-specific dependencies for this service.
-    /// </summary>
-    protected virtual RelationalConventionSetBuilderDependencies RelationalDependencies { get; }
-
-    /// <inheritdoc />
-    public virtual void ProcessEntityTypeAdded(
-        IConventionEntityTypeBuilder entityTypeBuilder,
-        IConventionContext<IConventionEntityTypeBuilder> context)
-    {
-        var entityType = entityTypeBuilder.Metadata;
-        if (!entityType.HasSharedClrType)
-        {
-            return;
-        }
-
-        List<IConventionTrigger>? triggersToReattach = null;
-        foreach (var trigger in entityType.GetDeclaredTriggers())
-        {
-            if (trigger.EntityType == entityType)
-            {
-                continue;
-            }
-
-            triggersToReattach ??= new();
-
-            triggersToReattach.Add(trigger);
-        }
-
-        if (triggersToReattach == null)
-        {
-            return;
-        }
-
-        foreach (var trigger in triggersToReattach)
-        {
-            var removedTrigger = entityType.RemoveTrigger(trigger.ModelName);
-            if (removedTrigger != null)
-            {
-                Trigger.Attach(entityType, removedTrigger);
-            }
-        }
-    }
-
-    /// <inheritdoc />
-    public virtual void ProcessEntityTypeBaseTypeChanged(
-        IConventionEntityTypeBuilder entityTypeBuilder,
-        IConventionEntityType? newBaseType,
-        IConventionEntityType? oldBaseType,
-        IConventionContext<IConventionEntityType> context)
-    {
-        var entityType = entityTypeBuilder.Metadata;
-        if (newBaseType != null)
-        {
-            var configurationSource = entityType.GetBaseTypeConfigurationSource();
-            var baseTriggers = newBaseType.GetTriggers().ToDictionary(c => c.ModelName);
-            List<IConventionTrigger>? triggersToBeDetached = null;
-            List<IConventionTrigger>? triggersToBeRemoved = null;
-            foreach (var trigger in entityType.GetDerivedTypesInclusive().SelectMany(et => et.GetDeclaredTriggers()))
-            {
-                if (baseTriggers.TryGetValue(trigger.ModelName, out var baseTrigger)
-                    && baseTrigger.GetConfigurationSource().Overrides(trigger.GetConfigurationSource())
-                    && !AreCompatible(trigger, baseTrigger))
-                {
-                    if (baseTrigger.GetConfigurationSource() == ConfigurationSource.Explicit
-                        && configurationSource == ConfigurationSource.Explicit
-                        && trigger.GetConfigurationSource() == ConfigurationSource.Explicit)
-                    {
-                        throw new InvalidOperationException(
-                            RelationalStrings.DuplicateTrigger(
-                                trigger.ModelName,
-                                trigger.EntityType.DisplayName(),
-                                baseTrigger.EntityType.DisplayName()));
-                    }
-
-                    triggersToBeRemoved ??= new List<IConventionTrigger>();
-
-                    triggersToBeRemoved.Add(trigger);
-                    continue;
-                }
-
-                if (baseTrigger != null)
-                {
-                    triggersToBeDetached ??= new List<IConventionTrigger>();
-
-                    triggersToBeDetached.Add(trigger);
-                }
-            }
-
-            if (triggersToBeRemoved != null)
-            {
-                foreach (var checkConstraintToBeRemoved in triggersToBeRemoved)
-                {
-                    checkConstraintToBeRemoved.EntityType.RemoveTrigger(checkConstraintToBeRemoved.ModelName);
-                }
-            }
-
-            if (triggersToBeDetached != null)
-            {
-                foreach (var triggerToBeDetached in triggersToBeDetached)
-                {
-                    var baseTrigger = baseTriggers[triggerToBeDetached.ModelName];
-                    Trigger.MergeInto(triggerToBeDetached, baseTrigger);
-
-                    triggerToBeDetached.EntityType.RemoveTrigger(triggerToBeDetached.ModelName);
-                }
-            }
-        }
-    }
-
-    private static bool AreCompatible(IConventionTrigger checkConstraint, IConventionTrigger baseTrigger)
-    {
-        var baseTable = StoreObjectIdentifier.Create(baseTrigger.EntityType, StoreObjectType.Table);
-        if (baseTable == null)
-        {
-            return true;
-        }
-
-        if (checkConstraint.GetName(baseTable.Value) != baseTrigger.GetName(baseTable.Value)
-            && checkConstraint.GetNameConfigurationSource() is ConfigurationSource nameConfigurationSource
-            && !nameConfigurationSource.OverridesStrictly(baseTrigger.GetNameConfigurationSource()))
-        {
-            return false;
-        }
-
-        return true;
-    }
-}
diff --git a/src/EFCore.Relational/Metadata/Internal/InternalStoredProcedureBuilder.cs b/src/EFCore.Relational/Metadata/Internal/InternalStoredProcedureBuilder.cs
index d97af283d0..a8265ca4bc 100644
--- a/src/EFCore.Relational/Metadata/Internal/InternalStoredProcedureBuilder.cs
+++ b/src/EFCore.Relational/Metadata/Internal/InternalStoredProcedureBuilder.cs
@@ -55,7 +55,7 @@ public InternalStoredProcedureBuilder(StoredProcedure storedProcedure, IConventi
 
         return sproc.Builder;
     }
-    
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -154,7 +154,7 @@ public virtual bool CanSetName(string? name, ConfigurationSource configurationSo
     public virtual bool CanSetSchema(string? schema, ConfigurationSource configurationSource)
         => configurationSource.Overrides(Metadata.GetSchemaConfigurationSource())
             || Metadata.Schema == schema;
-    
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -171,14 +171,14 @@ public virtual bool CanSetSchema(string? schema, ConfigurationSource configurati
             {
                 return null;
             }
-            
+
             parameter = Metadata.AddParameter(propertyName);
         }
 
         Metadata.UpdateConfigurationSource(configurationSource);
         return parameter.Builder;
     }
-    
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -200,7 +200,7 @@ public virtual bool CanSetSchema(string? schema, ConfigurationSource configurati
     public virtual bool CanHaveParameter(string propertyName, ConfigurationSource configurationSource)
         => Metadata.FindParameter(propertyName) != null
             || configurationSource.Overrides(Metadata.GetConfigurationSource());
-    
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -217,14 +217,14 @@ public virtual bool CanHaveParameter(string propertyName, ConfigurationSource co
             {
                 return null;
             }
-            
+
             parameter = Metadata.AddOriginalValueParameter(propertyName);
         }
 
         Metadata.UpdateConfigurationSource(configurationSource);
         return parameter.Builder;
     }
-    
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -246,7 +246,7 @@ public virtual bool CanHaveParameter(string propertyName, ConfigurationSource co
     public virtual bool CanHaveOriginalValueParameter(string propertyName, ConfigurationSource configurationSource)
         => Metadata.FindOriginalValueParameter(propertyName) != null
             || configurationSource.Overrides(Metadata.GetConfigurationSource());
-    
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -263,14 +263,14 @@ public virtual bool CanHaveOriginalValueParameter(string propertyName, Configura
             {
                 return null;
             }
-            
+
             parameter = Metadata.AddRowsAffectedParameter();
         }
 
         Metadata.UpdateConfigurationSource(configurationSource);
         return parameter.Builder;
     }
-    
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -315,7 +315,7 @@ public virtual bool CanHaveRowsAffectedParameter(ConfigurationSource configurati
         Metadata.UpdateConfigurationSource(configurationSource);
         return resultColumn.Builder;
     }
-    
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -361,7 +361,7 @@ public virtual bool CanHaveResultColumn(string propertyName, ConfigurationSource
         Metadata.UpdateConfigurationSource(configurationSource);
         return resultColumn.Builder;
     }
-    
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -382,7 +382,7 @@ public virtual bool CanHaveResultColumn(string propertyName, ConfigurationSource
     public virtual bool CanHaveRowsAffectedResultColumn(ConfigurationSource configurationSource)
         => Metadata.FindRowsAffectedResultColumn() != null
             || configurationSource.Overrides(Metadata.GetConfigurationSource());
-    
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -452,19 +452,19 @@ bool IConventionStoredProcedureBuilder.CanSetSchema(string? schema, bool fromDat
     bool IConventionStoredProcedureBuilder.CanHaveParameter(string propertyName, bool fromDataAnnotation)
         => CanHaveParameter(propertyName,
                 fromDataAnnotation ? ConfigurationSource.DataAnnotation : ConfigurationSource.Convention);
-    
+
     /// <inheritdoc />
     [DebuggerStepThrough]
     IConventionStoredProcedureParameterBuilder? IConventionStoredProcedureBuilder.HasOriginalValueParameter(
         string propertyName, bool fromDataAnnotation)
         => HasOriginalValueParameter(propertyName,
             fromDataAnnotation ? ConfigurationSource.DataAnnotation : ConfigurationSource.Convention);
-    
+
     /// <inheritdoc />
     [DebuggerStepThrough]
     bool IConventionStoredProcedureBuilder.CanHaveOriginalValueParameter(string propertyName, bool fromDataAnnotation)
         => CanHaveOriginalValueParameter(propertyName, fromDataAnnotation ? ConfigurationSource.DataAnnotation : ConfigurationSource.Convention);
-    
+
     /// <inheritdoc />
     [DebuggerStepThrough]
     IConventionStoredProcedureParameterBuilder? IConventionStoredProcedureBuilder.HasRowsAffectedParameter(bool fromDataAnnotation)
@@ -486,13 +486,13 @@ bool IConventionStoredProcedureBuilder.CanHaveRowsAffectedParameter(bool fromDat
     bool IConventionStoredProcedureBuilder.CanHaveResultColumn(string propertyName, bool fromDataAnnotation)
         => CanHaveResultColumn(propertyName,
             fromDataAnnotation ? ConfigurationSource.DataAnnotation : ConfigurationSource.Convention);
-    
+
     /// <inheritdoc />
     [DebuggerStepThrough]
     IConventionStoredProcedureResultColumnBuilder? IConventionStoredProcedureBuilder.HasRowsAffectedResultColumn(
         string propertyName, bool fromDataAnnotation)
         => HasRowsAffectedResultColumn(fromDataAnnotation ? ConfigurationSource.DataAnnotation : ConfigurationSource.Convention);
-    
+
     /// <inheritdoc />
     [DebuggerStepThrough]
     bool IConventionStoredProcedureBuilder.CanHaveRowsAffectedResultColumn(string propertyName, bool fromDataAnnotation)
diff --git a/src/EFCore.Relational/Metadata/Internal/InternalTriggerBuilder.cs b/src/EFCore.Relational/Metadata/Internal/InternalTriggerBuilder.cs
deleted file mode 100644
index 25518842e8..0000000000
--- a/src/EFCore.Relational/Metadata/Internal/InternalTriggerBuilder.cs
+++ /dev/null
@@ -1,190 +0,0 @@
-// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-namespace Microsoft.EntityFrameworkCore.Metadata.Internal;
-
-/// <summary>
-///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-///     any release. You should only use it directly in your code with extreme caution and knowing that
-///     doing so can result in application failures when updating to a new Entity Framework Core release.
-/// </summary>
-public class InternalTriggerBuilder : AnnotatableBuilder<Trigger, IConventionModelBuilder>, IConventionTriggerBuilder
-{
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public InternalTriggerBuilder(Trigger trigger, IConventionModelBuilder modelBuilder)
-        : base(trigger, modelBuilder)
-    {
-    }
-
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public virtual IConventionTriggerBuilder? HasName(string? name, ConfigurationSource configurationSource)
-    {
-        if (CanSetName(name, configurationSource))
-        {
-            Metadata.SetName(name, configurationSource);
-            return this;
-        }
-
-        return null;
-    }
-
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public virtual bool CanSetName(string? name, ConfigurationSource configurationSource)
-        => configurationSource.Overrides(Metadata.GetNameConfigurationSource())
-            || Metadata.Name == name;
-
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public static IConventionTrigger? HasTrigger(
-        IConventionEntityType entityType,
-        string modelName,
-        string? tableName,
-        string? tableSchema,
-        ConfigurationSource configurationSource)
-    {
-        List<IConventionTrigger>? triggersToBeDetached = null;
-        var trigger = entityType.FindTrigger(modelName);
-        if (trigger != null)
-        {
-            if ((tableName == null && tableSchema == null)
-                || (trigger.TableName == tableName && trigger.TableSchema == tableSchema))
-            {
-                ((Trigger)trigger).UpdateConfigurationSource(configurationSource);
-                return trigger;
-            }
-
-            if (!configurationSource.Overrides(trigger.GetConfigurationSource()))
-            {
-                return null;
-            }
-
-            entityType.RemoveTrigger(modelName);
-        }
-        else
-        {
-            foreach (var derivedType in entityType.GetDerivedTypes())
-            {
-                var derivedTrigger = (IConventionTrigger?)Trigger.FindDeclaredTrigger(derivedType, modelName);
-                if (derivedTrigger == null)
-                {
-                    continue;
-                }
-
-                if ((tableName != null || tableSchema != null)
-                    && (derivedTrigger.TableName != tableName || derivedTrigger.TableSchema != tableSchema)
-                    && !configurationSource.Overrides(derivedTrigger.GetConfigurationSource()))
-                {
-                    return null;
-                }
-
-                triggersToBeDetached ??= new List<IConventionTrigger>();
-
-                triggersToBeDetached.Add(derivedTrigger);
-            }
-        }
-
-        List<IConventionTrigger>? detachedTriggers = null;
-        if (triggersToBeDetached != null)
-        {
-            detachedTriggers = new List<IConventionTrigger>();
-            foreach (var triggerToBeDetached in triggersToBeDetached)
-            {
-                detachedTriggers.Add(
-                    triggerToBeDetached.EntityType.RemoveTrigger(triggerToBeDetached.ModelName)!);
-            }
-        }
-
-        trigger = new Trigger((IMutableEntityType)entityType, modelName, tableName, tableSchema, configurationSource);
-
-        if (detachedTriggers != null)
-        {
-            foreach (var detachedTrigger in detachedTriggers)
-            {
-                Trigger.MergeInto(detachedTrigger, trigger);
-            }
-        }
-
-        return trigger;
-    }
-
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public static bool CanHaveTrigger(
-        IConventionEntityType entityType,
-        string name,
-        string? tableName,
-        string? tableSchema,
-        ConfigurationSource configurationSource)
-    {
-        if (tableName == null
-            && tableSchema == null)
-        {
-            return true;
-        }
-
-        if (entityType.FindTrigger(name) is IConventionTrigger trigger)
-        {
-            return (trigger.TableName == tableName
-                    && trigger.TableSchema == tableSchema)
-                || configurationSource.Overrides(trigger.GetConfigurationSource());
-        }
-
-        foreach (var derivedType in entityType.GetDerivedTypes())
-        {
-            var derivedTrigger = (IConventionTrigger?)Trigger.FindDeclaredTrigger(derivedType, name);
-            if (derivedTrigger == null)
-            {
-                continue;
-            }
-
-            if ((derivedTrigger.TableName != tableName
-                || derivedTrigger.TableSchema != tableSchema)
-                && !configurationSource.Overrides(derivedTrigger.GetConfigurationSource()))
-            {
-                return false;
-            }
-        }
-
-        return true;
-    }
-
-    IConventionTrigger IConventionTriggerBuilder.Metadata
-    {
-        [DebuggerStepThrough]
-        get => Metadata;
-    }
-
-    /// <inheritdoc />
-    [DebuggerStepThrough]
-    IConventionTriggerBuilder? IConventionTriggerBuilder.HasName(string? name, bool fromDataAnnotation)
-        => HasName(name, fromDataAnnotation ? ConfigurationSource.DataAnnotation : ConfigurationSource.Convention);
-
-    /// <inheritdoc />
-    [DebuggerStepThrough]
-    bool IConventionTriggerBuilder.CanSetName(string? name, bool fromDataAnnotation)
-        => CanSetName(name, fromDataAnnotation ? ConfigurationSource.DataAnnotation : ConfigurationSource.Convention);
-}
diff --git a/src/EFCore.Relational/Metadata/Internal/RelationalModel.cs b/src/EFCore.Relational/Metadata/Internal/RelationalModel.cs
index 2937122bfc..d8a818fde0 100644
--- a/src/EFCore.Relational/Metadata/Internal/RelationalModel.cs
+++ b/src/EFCore.Relational/Metadata/Internal/RelationalModel.cs
@@ -989,7 +989,7 @@ private static StoreFunction GetOrCreateStoreFunction(IRuntimeDbFunction dbFunct
                     insertStoredProcedureMappings,
                     includesDerivedTypes,
                     relationalTypeMappingSource);
-                
+
                 if (tableMapping != null)
                 {
                     Check.DebugAssert(tableMapping.InsertStoredProcedureMapping == null,
@@ -1015,7 +1015,7 @@ private static StoreFunction GetOrCreateStoreFunction(IRuntimeDbFunction dbFunct
                     deleteStoredProcedureMappings,
                     includesDerivedTypes,
                     relationalTypeMappingSource);
-                
+
                 if (tableMapping != null)
                 {
                     Check.DebugAssert(tableMapping.DeleteStoredProcedureMapping == null,
@@ -1041,7 +1041,7 @@ private static StoreFunction GetOrCreateStoreFunction(IRuntimeDbFunction dbFunct
                     updateStoredProcedureMappings,
                     includesDerivedTypes,
                     relationalTypeMappingSource);
-                
+
                 if (tableMapping != null)
                 {
                     Check.DebugAssert(tableMapping.UpdateStoredProcedureMapping == null,
@@ -1061,7 +1061,7 @@ private static StoreFunction GetOrCreateStoreFunction(IRuntimeDbFunction dbFunct
 
             mappedType = mappedType.BaseType;
         }
-        
+
         if (insertStoredProcedureMappings?.Count > 0)
         {
             insertStoredProcedureMappings.Reverse();
@@ -1325,7 +1325,7 @@ private static StoreFunction GetOrCreateStoreFunction(IRuntimeDbFunction dbFunct
             {
                 storeParameter.IsNullable = false;
             }
-            
+
             ((IRuntimeStoredProcedureParameter)parameter).StoreParameter = storeParameter;
             return storeParameter;
         }
@@ -1500,7 +1500,7 @@ private static void PopulateTableConfiguration(Table table, bool designTime)
                 }
             }
 
-            // Triggers cannot be inherited
+            // Triggers are not inherited
             foreach (var trigger in entityType.GetDeclaredTriggers())
             {
                 var name = trigger.GetName(storeObject);
@@ -1509,8 +1509,8 @@ private static void PopulateTableConfiguration(Table table, bool designTime)
                     continue;
                 }
 
-                Check.DebugAssert(trigger.TableName == table.Name, "Mismatch in trigger table name");
-                Check.DebugAssert(trigger.TableSchema == table.Schema, "Mismatch in trigger table schema");
+                Check.DebugAssert(trigger.GetTableName() == table.Name, "Mismatch in trigger table name");
+                Check.DebugAssert(trigger.GetTableSchema() == table.Schema, "Mismatch in trigger table schema");
 
                 if (!table.Triggers.ContainsKey(name))
                 {
diff --git a/src/EFCore.Relational/Metadata/Internal/Trigger.cs b/src/EFCore.Relational/Metadata/Internal/Trigger.cs
deleted file mode 100644
index 1bce6addc7..0000000000
--- a/src/EFCore.Relational/Metadata/Internal/Trigger.cs
+++ /dev/null
@@ -1,479 +0,0 @@
-// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-namespace Microsoft.EntityFrameworkCore.Metadata.Internal;
-
-/// <summary>
-///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-///     any release. You should only use it directly in your code with extreme caution and knowing that
-///     doing so can result in application failures when updating to a new Entity Framework Core release.
-/// </summary>
-public class Trigger : ConventionAnnotatable, IMutableTrigger, IConventionTrigger, ITrigger
-{
-    private string? _name;
-    private string? _tableName;
-    private string? _tableSchema;
-    private InternalTriggerBuilder? _builder;
-
-    private ConfigurationSource _configurationSource;
-    private ConfigurationSource? _nameConfigurationSource;
-    private ConfigurationSource? _tableNameConfigurationSource;
-    private ConfigurationSource? _tableSchemaConfigurationSource;
-
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public Trigger(
-        IMutableEntityType entityType,
-        string modelName,
-        string? tableName,
-        string? tableSchema,
-        ConfigurationSource configurationSource)
-    {
-        EntityType = entityType;
-        ModelName = modelName;
-        _tableName = tableName;
-        _tableSchema = tableSchema;
-        _configurationSource = configurationSource;
-
-        var triggers = GetTriggersDictionary(entityType);
-        if (triggers == null)
-        {
-            triggers = new SortedDictionary<string, ITrigger>(StringComparer.Ordinal);
-            entityType.SetOrRemoveAnnotation(RelationalAnnotationNames.Triggers, triggers);
-        }
-
-        if (triggers.ContainsKey(modelName))
-        {
-            throw new InvalidOperationException(
-                RelationalStrings.DuplicateTrigger(
-                    modelName, entityType.DisplayName(), entityType.DisplayName()));
-        }
-
-        var baseTrigger = entityType.BaseType?.FindTrigger(modelName);
-        if (baseTrigger != null)
-        {
-            throw new InvalidOperationException(
-                RelationalStrings.DuplicateTrigger(
-                    modelName, entityType.DisplayName(), baseTrigger.EntityType.DisplayName()));
-        }
-
-        foreach (var derivedType in entityType.GetDerivedTypes())
-        {
-            var derivedTrigger = FindTrigger(derivedType, modelName);
-            if (derivedTrigger != null)
-            {
-                throw new InvalidOperationException(
-                    RelationalStrings.DuplicateTrigger(
-                        modelName, entityType.DisplayName(), derivedTrigger.EntityType.DisplayName()));
-            }
-        }
-
-        if (entityType.GetTableName() is null)
-        {
-            throw new InvalidOperationException(RelationalStrings.TriggerOnUnmappedEntityType(modelName, entityType.DisplayName()));
-        }
-
-        EnsureMutable();
-
-        triggers.Add(modelName, this);
-
-        _builder = new InternalTriggerBuilder(this, ((IConventionModel)entityType.Model).Builder);
-    }
-
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public static IEnumerable<IReadOnlyTrigger> GetDeclaredTriggers(IReadOnlyEntityType entityType)
-        => GetTriggersDictionary(entityType)?.Values ?? Enumerable.Empty<ITrigger>();
-
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public static IEnumerable<IReadOnlyTrigger> GetTriggers(IReadOnlyEntityType entityType)
-        => entityType.BaseType != null
-            ? GetTriggers(entityType.BaseType).Concat(GetDeclaredTriggers(entityType))
-            : GetDeclaredTriggers(entityType);
-
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public static IReadOnlyTrigger? FindTrigger(
-        IReadOnlyEntityType entityType,
-        string modelName)
-        => entityType.BaseType?.FindTrigger(modelName) ?? FindDeclaredTrigger(entityType, modelName);
-
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public static IReadOnlyTrigger? FindDeclaredTrigger(IReadOnlyEntityType entityType, string modelName)
-    {
-        var triggers = (SortedDictionary<string, ITrigger>?)entityType[RelationalAnnotationNames.Triggers];
-
-        return triggers is not null && triggers.TryGetValue(modelName, out var trigger)
-            ? trigger
-            : null;
-    }
-
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public static Trigger? RemoveTrigger(IMutableEntityType entityType, string modelName)
-    {
-        var triggers = (SortedDictionary<string, ITrigger>?)entityType[RelationalAnnotationNames.Triggers];
-        if (triggers == null
-            || !triggers.TryGetValue(modelName, out var trigger))
-        {
-            return null;
-        }
-
-        var mutableTrigger = (Trigger)trigger;
-        triggers.Remove(modelName);
-        mutableTrigger.SetRemovedFromModel();
-
-        return mutableTrigger;
-    }
-
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public static void Attach(IConventionEntityType entityType, IConventionTrigger detachedTrigger)
-    {
-        var newTrigger = new Trigger(
-            (IMutableEntityType)entityType,
-            detachedTrigger.ModelName,
-            detachedTrigger.TableName,
-            detachedTrigger.TableSchema,
-            detachedTrigger.GetConfigurationSource());
-
-        MergeInto(detachedTrigger, newTrigger);
-    }
-
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public static void MergeInto(IConventionTrigger detachedTrigger, IConventionTrigger existingTrigger)
-    {
-        var nameConfigurationSource = detachedTrigger.GetNameConfigurationSource();
-        if (nameConfigurationSource != null)
-        {
-            ((InternalTriggerBuilder)existingTrigger.Builder).HasName(
-                detachedTrigger.Name, nameConfigurationSource.Value);
-        }
-
-        ((InternalTriggerBuilder)existingTrigger.Builder).MergeAnnotationsFrom(
-            (Trigger)detachedTrigger);
-    }
-
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public virtual InternalTriggerBuilder Builder
-    {
-        [DebuggerStepThrough]
-        get => _builder ?? throw new InvalidOperationException(CoreStrings.ObjectRemovedFromModel);
-    }
-
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public virtual bool IsInModel
-        => _builder is not null;
-
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public virtual void SetRemovedFromModel()
-        => _builder = null;
-
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public virtual IReadOnlyEntityType EntityType { get; }
-
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public virtual string ModelName { get; }
-
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public virtual string? Name
-    {
-        get => EntityType.GetTableName() == null
-            ? null
-            : _name ?? ((IReadOnlyTrigger)this).GetDefaultName();
-        set => SetName(value, ConfigurationSource.Explicit);
-    }
-
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public virtual string? GetName(in StoreObjectIdentifier storeObject)
-        => storeObject.StoreObjectType == StoreObjectType.Table
-                && TableName == storeObject.Name
-                && TableSchema == storeObject.Schema
-            ? _name ?? ((IReadOnlyTrigger)this).GetDefaultName(storeObject)
-            : null;
-
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public virtual string? SetName(string? name, ConfigurationSource configurationSource)
-    {
-        EnsureMutable();
-
-        _name = name;
-
-        _nameConfigurationSource = configurationSource.Max(_nameConfigurationSource);
-
-        return name;
-    }
-
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public virtual ConfigurationSource? GetNameConfigurationSource()
-        => _nameConfigurationSource;
-
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public virtual string TableName
-    {
-        get => _tableName ?? EntityType.GetTableName()!;
-        set => SetTableName(value, ConfigurationSource.Explicit);
-    }
-
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public virtual string? SetTableName(string? tableName, ConfigurationSource configurationSource)
-    {
-        EnsureMutable();
-
-        _tableName = tableName;
-
-        _tableNameConfigurationSource = configurationSource.Max(_tableNameConfigurationSource);
-
-        return tableName;
-    }
-
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public virtual ConfigurationSource? GetTableNameConfigurationSource()
-        => _tableNameConfigurationSource;
-
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public virtual string? TableSchema
-    {
-        get => _tableSchema ?? EntityType.GetSchema();
-        set => SetTableSchema(value, ConfigurationSource.Explicit);
-    }
-
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public virtual string? SetTableSchema(string? tableSchema, ConfigurationSource configurationSource)
-    {
-        EnsureMutable();
-
-        _tableSchema = tableSchema;
-
-        _tableSchemaConfigurationSource = configurationSource.Max(_tableSchemaConfigurationSource);
-
-        return tableSchema;
-    }
-
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public virtual ConfigurationSource? GetTableSchemaConfigurationSource()
-        => _tableSchemaConfigurationSource;
-
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public virtual ConfigurationSource GetConfigurationSource()
-        => _configurationSource;
-
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public virtual void UpdateConfigurationSource(ConfigurationSource configurationSource)
-        => _configurationSource = _configurationSource.Max(configurationSource);
-
-    private static SortedDictionary<string, ITrigger>? GetTriggersDictionary(IReadOnlyEntityType entityType)
-        => (SortedDictionary<string, ITrigger>?)entityType[RelationalAnnotationNames.Triggers];
-
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public override string ToString()
-        => ((ITrigger)this).ToDebugString(MetadataDebugStringOptions.SingleLineDefault);
-
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    [EntityFrameworkInternal]
-    public virtual DebugView DebugView
-        => new(
-            () => ((ITrigger)this).ToDebugString(),
-            () => ((ITrigger)this).ToDebugString(MetadataDebugStringOptions.LongDefault));
-
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    IConventionEntityType IConventionTrigger.EntityType
-    {
-        [DebuggerStepThrough]
-        get => (IConventionEntityType)EntityType;
-    }
-
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    IMutableEntityType IMutableTrigger.EntityType
-    {
-        [DebuggerStepThrough]
-        get => (IMutableEntityType)EntityType;
-    }
-
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    IEntityType ITrigger.EntityType
-    {
-        [DebuggerStepThrough]
-        get => (IEntityType)EntityType;
-    }
-
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    string ITrigger.Name
-    {
-        [DebuggerStepThrough]
-        get => Name!;
-    }
-
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    IConventionTriggerBuilder IConventionTrigger.Builder
-    {
-        [DebuggerStepThrough]
-        get => Builder;
-    }
-
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    [DebuggerStepThrough]
-    string? IConventionTrigger.SetName(string? name, bool fromDataAnnotation)
-        => SetName(name, fromDataAnnotation ? ConfigurationSource.DataAnnotation : ConfigurationSource.Convention);
-}
diff --git a/src/EFCore.Relational/Metadata/RelationalAnnotationNames.cs b/src/EFCore.Relational/Metadata/RelationalAnnotationNames.cs
index abc44e5ebe..8a13a6d23a 100644
--- a/src/EFCore.Relational/Metadata/RelationalAnnotationNames.cs
+++ b/src/EFCore.Relational/Metadata/RelationalAnnotationNames.cs
@@ -86,7 +86,7 @@ public static class RelationalAnnotationNames
     ///     The name for mapped insert stored procedure annotations.
     /// </summary>
     public const string InsertStoredProcedure = Prefix + "InsertStoredProcedure";
-    
+
     /// <summary>
     ///     The name for mapped update stored procedure annotations.
     /// </summary>
@@ -144,11 +144,6 @@ public static class RelationalAnnotationNames
     /// </summary>
     public const string DbFunctions = Prefix + "DbFunctions";
 
-    /// <summary>
-    ///     The name for trigger annotation.
-    /// </summary>
-    public const string Triggers = Prefix + "Triggers";
-
     /// <summary>
     ///     The name for the annotation containing the maximum length for database identifiers.
     /// </summary>
@@ -303,7 +298,7 @@ public static class RelationalAnnotationNames
     ///     The name for the annotation that contains entity type mapping fragments.
     /// </summary>
     public const string MappingFragments = Prefix + "MappingFragments";
-    
+
     /// <summary>
     ///     The name for the annotation that contains table-specific facet overrides.
     /// </summary>
diff --git a/src/EFCore.Relational/Properties/RelationalStrings.Designer.cs b/src/EFCore.Relational/Properties/RelationalStrings.Designer.cs
index d53b5c3bc2..17c2c2e19e 100644
--- a/src/EFCore.Relational/Properties/RelationalStrings.Designer.cs
+++ b/src/EFCore.Relational/Properties/RelationalStrings.Designer.cs
@@ -589,14 +589,6 @@ public static string DuplicateSeedDataSensitive(object? entityType, object? keyV
                 GetString("DuplicateSeedDataSensitive", nameof(entityType), nameof(keyValue), nameof(table)),
                 entityType, keyValue, table);
 
-        /// <summary>
-        ///     The trigger '{trigger}' cannot be added to the entity type '{entityType}' because another trigger with the same name already exists on entity type '{conflictingEntityType}'.
-        /// </summary>
-        public static string DuplicateTrigger(object? trigger, object? entityType, object? conflictingEntityType)
-            => string.Format(
-                GetString("DuplicateTrigger", nameof(trigger), nameof(entityType), nameof(conflictingEntityType)),
-                trigger, entityType, conflictingEntityType);
-
         /// <summary>
         ///     Either {param1} or {param2} must be null.
         /// </summary>
@@ -1771,14 +1763,6 @@ public static string TransactionAssociatedWithDifferentConnection
         public static string TransactionSuppressedMigrationInUserTransaction
             => GetString("TransactionSuppressedMigrationInUserTransaction");
 
-        /// <summary>
-        ///     Trigger '{trigger}' cannot be defined on entity type '{entityType}' since that entity type isn't mapped to a database table. See https://aka.ms/efcore-docs-triggers for more information on triggers.
-        /// </summary>
-        public static string TriggerOnUnmappedEntityType(object? trigger, object? entityType)
-            => string.Format(
-                GetString("TriggerOnUnmappedEntityType", nameof(trigger), nameof(entityType)),
-                trigger, entityType);
-
         /// <summary>
         ///     Trigger '{trigger}' for table '{triggerTable}' is defined on entity type '{entityType}', which is mapped to table '{entityTable}'. See https://aka.ms/efcore-docs-triggers for more information on triggers.
         /// </summary>
diff --git a/src/EFCore.Relational/Properties/RelationalStrings.resx b/src/EFCore.Relational/Properties/RelationalStrings.resx
index 134d162b66..c79b398c97 100644
--- a/src/EFCore.Relational/Properties/RelationalStrings.resx
+++ b/src/EFCore.Relational/Properties/RelationalStrings.resx
@@ -334,9 +334,6 @@
   <data name="DuplicateSeedDataSensitive" xml:space="preserve">
     <value>A seed entity for entity type '{entityType}' has the same key value {keyValue} as another seed entity mapped to the same table '{table}'. Key values should be unique across seed entities.</value>
   </data>
-  <data name="DuplicateTrigger" xml:space="preserve">
-    <value>The trigger '{trigger}' cannot be added to the entity type '{entityType}' because another trigger with the same name already exists on entity type '{conflictingEntityType}'.</value>
-  </data>
   <data name="EitherOfTwoValuesMustBeNull" xml:space="preserve">
     <value>Either {param1} or {param2} must be null.</value>
   </data>
@@ -1083,9 +1080,6 @@
   <data name="TransactionSuppressedMigrationInUserTransaction" xml:space="preserve">
     <value>User transaction is not supported with a TransactionSuppressed migrations.</value>
   </data>
-  <data name="TriggerOnUnmappedEntityType" xml:space="preserve">
-    <value>Trigger '{trigger}' cannot be defined on entity type '{entityType}' since that entity type isn't mapped to a database table. See https://aka.ms/efcore-docs-triggers for more information on triggers.</value>
-  </data>
   <data name="TriggerWithMismatchedTable" xml:space="preserve">
     <value>Trigger '{trigger}' for table '{triggerTable}' is defined on entity type '{entityType}', which is mapped to table '{entityTable}'. See https://aka.ms/efcore-docs-triggers for more information on triggers.</value>
   </data>
diff --git a/src/EFCore.Relational/Scaffolding/Metadata/DatabaseTable.cs b/src/EFCore.Relational/Scaffolding/Metadata/DatabaseTable.cs
index 9a8fca3cbc..7c00b873ac 100644
--- a/src/EFCore.Relational/Scaffolding/Metadata/DatabaseTable.cs
+++ b/src/EFCore.Relational/Scaffolding/Metadata/DatabaseTable.cs
@@ -57,6 +57,11 @@ public class DatabaseTable : Annotatable
     /// </summary>
     public virtual IList<DatabaseForeignKey> ForeignKeys { get; } = new List<DatabaseForeignKey>();
 
+    /// <summary>
+    ///     The list of triggers defined on the table.
+    /// </summary>
+    public virtual HashSet<string> Triggers { get; } = new HashSet<string>();
+
     /// <inheritdoc />
     public override string ToString()
     {
diff --git a/src/EFCore.SqlServer/Scaffolding/Internal/SqlServerDatabaseModelFactory.cs b/src/EFCore.SqlServer/Scaffolding/Internal/SqlServerDatabaseModelFactory.cs
index 4ab10bd356..afffd6067b 100644
--- a/src/EFCore.SqlServer/Scaffolding/Internal/SqlServerDatabaseModelFactory.cs
+++ b/src/EFCore.SqlServer/Scaffolding/Internal/SqlServerDatabaseModelFactory.cs
@@ -1324,16 +1324,13 @@ private void GetTriggers(DbConnection connection, IReadOnlyList<DatabaseTable> t
 
             var table = tables.Single(t => t.Schema == tableSchema && t.Name == tableName);
 
-            var triggers = new HashSet<string>();
-            table[RelationalAnnotationNames.Triggers] = triggers;
-
             foreach (var triggerRecord in tableGroup)
             {
                 var triggerName = triggerRecord.GetFieldValue<string>("trigger_name");
 
                 // We don't actually scaffold anything beyond the fact that there's a trigger with a given name.
                 // This is to modify the SaveChanges logic to not use OUTPUT without INTO, which is incompatible with triggers.
-                triggers.Add(triggerName);
+                table.Triggers.Add(triggerName);
             }
         }
     }
diff --git a/src/EFCore/Design/Internal/CSharpRuntimeAnnotationCodeGenerator.cs b/src/EFCore/Design/Internal/CSharpRuntimeAnnotationCodeGenerator.cs
index 023bca97bb..7f97dffbe1 100644
--- a/src/EFCore/Design/Internal/CSharpRuntimeAnnotationCodeGenerator.cs
+++ b/src/EFCore/Design/Internal/CSharpRuntimeAnnotationCodeGenerator.cs
@@ -194,6 +194,24 @@ public virtual void Generate(IIndex index, CSharpRuntimeAnnotationCodeGeneratorP
         GenerateSimpleAnnotations(parameters);
     }
 
+    /// <inheritdoc />
+    public virtual void Generate(ITrigger trigger, CSharpRuntimeAnnotationCodeGeneratorParameters parameters)
+    {
+        if (!parameters.IsRuntime)
+        {
+            var annotations = parameters.Annotations;
+            foreach (var (key, _) in annotations)
+            {
+                if (CoreAnnotationNames.AllNames.Contains(key))
+                {
+                    annotations.Remove(key);
+                }
+            }
+        }
+
+        GenerateSimpleAnnotations(parameters);
+    }
+
     /// <inheritdoc />
     public virtual void Generate(ITypeMappingConfiguration typeConfiguration, CSharpRuntimeAnnotationCodeGeneratorParameters parameters)
     {
diff --git a/src/EFCore/Design/Internal/ICSharpRuntimeAnnotationCodeGenerator.cs b/src/EFCore/Design/Internal/ICSharpRuntimeAnnotationCodeGenerator.cs
index 0510c4f300..6d960da09f 100644
--- a/src/EFCore/Design/Internal/ICSharpRuntimeAnnotationCodeGenerator.cs
+++ b/src/EFCore/Design/Internal/ICSharpRuntimeAnnotationCodeGenerator.cs
@@ -76,6 +76,13 @@ public interface ICSharpRuntimeAnnotationCodeGenerator
     /// <param name="parameters">Additional parameters used during code generation.</param>
     void Generate(IIndex index, CSharpRuntimeAnnotationCodeGeneratorParameters parameters);
 
+    /// <summary>
+    ///     Generates code to create the given annotations.
+    /// </summary>
+    /// <param name="trigger">The trigger to which the annotations are applied.</param>
+    /// <param name="parameters">Additional parameters used during code generation.</param>
+    void Generate(ITrigger trigger, CSharpRuntimeAnnotationCodeGeneratorParameters parameters);
+
     /// <summary>
     ///     Generates code to create the given annotations.
     /// </summary>
diff --git a/src/EFCore/Diagnostics/CoreLoggerExtensions.cs b/src/EFCore/Diagnostics/CoreLoggerExtensions.cs
index 50de58a35d..c1bf623918 100644
--- a/src/EFCore/Diagnostics/CoreLoggerExtensions.cs
+++ b/src/EFCore/Diagnostics/CoreLoggerExtensions.cs
@@ -257,7 +257,7 @@ private static string OldModelVersion(EventDefinitionBase definition, EventData
                 definition,
                 out var interceptor, out var diagnosticSourceEnabled, out var simpleLogEnabled))
         {
-            var eventData = createEventData?.Invoke(context, exception, entries, definition) 
+            var eventData = createEventData?.Invoke(context, exception, entries, definition)
                 ?? CreateConcurrencyExceptionEventData(context, exception, entries, definition);
 
             diagnostics.DispatchEventData(definition, eventData, diagnosticSourceEnabled, simpleLogEnabled);
@@ -302,7 +302,7 @@ private static string OldModelVersion(EventDefinitionBase definition, EventData
                 definition,
                 out var interceptor, out var diagnosticSourceEnabled, out var simpleLogEnabled))
         {
-            var eventData = createEventData?.Invoke(context, exception, entries, definition) 
+            var eventData = createEventData?.Invoke(context, exception, entries, definition)
                 ?? CreateConcurrencyExceptionEventData(context, exception, entries, definition);
 
             diagnostics.DispatchEventData(definition, eventData, diagnosticSourceEnabled, simpleLogEnabled);
diff --git a/src/EFCore/Infrastructure/ModelValidator.cs b/src/EFCore/Infrastructure/ModelValidator.cs
index 4902eac65d..ee24105ede 100644
--- a/src/EFCore/Infrastructure/ModelValidator.cs
+++ b/src/EFCore/Infrastructure/ModelValidator.cs
@@ -60,6 +60,7 @@ public virtual void Validate(IModel model, IDiagnosticsLogger<DbLoggerCategory.M
         ValidateQueryFilters(model, logger);
         ValidateData(model, logger);
         ValidateTypeMappings(model, logger);
+        ValidateTriggers(model, logger);
         LogShadowProperties(model, logger);
     }
 
@@ -875,7 +876,7 @@ protected virtual bool IsRedundant(IForeignKey foreignKey)
                 {
                     _ = property.GetCurrentValueComparer(); // Will throw if there is no way to compare
                 }
-                
+
                 var providerComparer = property.GetProviderValueComparer();
                 if (providerComparer == null)
                 {
@@ -1078,6 +1079,17 @@ protected virtual void ValidateData(IModel model, IDiagnosticsLogger<DbLoggerCat
         }
     }
 
+    /// <summary>
+    ///     Validates triggers.
+    /// </summary>
+    /// <param name="model">The model to validate.</param>
+    /// <param name="logger">The logger to use.</param>
+    protected virtual void ValidateTriggers(
+        IModel model,
+        IDiagnosticsLogger<DbLoggerCategory.Model.Validation> logger)
+    {
+    }
+
     /// <summary>
     ///     Logs all shadow properties that were created because there was no matching CLR member.
     /// </summary>
diff --git a/src/EFCore/Metadata/Builders/EntityTypeBuilder.cs b/src/EFCore/Metadata/Builders/EntityTypeBuilder.cs
index 789827f6d8..6d534d5ee6 100644
--- a/src/EFCore/Metadata/Builders/EntityTypeBuilder.cs
+++ b/src/EFCore/Metadata/Builders/EntityTypeBuilder.cs
@@ -1090,6 +1090,15 @@ public virtual EntityTypeBuilder HasNoDiscriminator()
         return this;
     }
 
+    /// <summary>
+    ///     Configures a trigger for the the entity type.
+    /// </summary>
+    /// <param name="modelName">The name of the trigger.</param>
+    /// <param name="entityType">The entity type.</param>
+    /// <returns>A builder that can be used to configure the trigger.</returns>
+    public static TriggerBuilder HasTrigger(string modelName, IMutableEntityType entityType)
+        => new(((EntityType)entityType).Builder.HasTrigger(modelName, ConfigurationSource.Explicit)!.Metadata);
+
     #region Hidden System.Object members
 
     /// <summary>
diff --git a/src/EFCore/Metadata/Builders/IConventionEntityTypeBuilder.cs b/src/EFCore/Metadata/Builders/IConventionEntityTypeBuilder.cs
index 0e4107ecbe..043383cc38 100644
--- a/src/EFCore/Metadata/Builders/IConventionEntityTypeBuilder.cs
+++ b/src/EFCore/Metadata/Builders/IConventionEntityTypeBuilder.cs
@@ -1,6 +1,8 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using Microsoft.EntityFrameworkCore.Metadata.Internal;
+
 namespace Microsoft.EntityFrameworkCore.Metadata.Builders;
 
 /// <summary>
@@ -241,7 +243,7 @@ public interface IConventionEntityTypeBuilder : IConventionAnnotatableBuilder
     ///     <see langword="null" /> otherwise.
     /// </returns>
     IConventionKeyBuilder? PrimaryKey(IReadOnlyList<string>? propertyNames, bool fromDataAnnotation = false);
-    
+
     /// <summary>
     ///     Returns a value indicating whether the given properties can be set as the primary key for this entity type.
     /// </summary>
@@ -377,7 +379,7 @@ public interface IConventionEntityTypeBuilder : IConventionAnnotatableBuilder
         IReadOnlyList<IConventionProperty> properties,
         string name,
         bool fromDataAnnotation = false);
-    
+
     /// <summary>
     ///     Returns a value indicating whether and index on the given properties can be added to this entity type.
     /// </summary>
@@ -850,6 +852,32 @@ bool CanHaveSkipNavigation(MemberInfo navigation, bool fromDataAnnotation = fals
         bool? onDependent = null,
         bool fromDataAnnotation = false);
 
+    /// <summary>
+    ///     Configures a database trigger when targeting a relational database.
+    /// </summary>
+    /// <remarks>
+    ///     See <see href="https://aka.ms/efcore-docs-triggers">Database triggers</see> for more information and examples.
+    /// </remarks>
+    /// <param name="modelName">The name of the trigger.</param>
+    /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
+    /// <returns>The same builder instance if the check constraint was configured, <see langword="null" /> otherwise.</returns>
+    IConventionTriggerBuilder? HasTrigger(
+        string modelName,
+        bool fromDataAnnotation = false);
+
+    /// <summary>
+    ///     Returns a value indicating whether the trigger can be configured.
+    /// </summary>
+    /// <remarks>
+    ///     See <see href="https://aka.ms/efcore-docs-triggers">Database triggers</see> for more information and examples.
+    /// </remarks>
+    /// <param name="modelName">The name of the trigger.</param>
+    /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
+    /// <returns><see langword="true" /> if the configuration can be applied.</returns>
+    bool CanHaveTrigger(
+        string modelName,
+        bool fromDataAnnotation = false);
+
     /// <summary>
     ///     Specifies a LINQ predicate expression that will automatically be applied to any queries targeting
     ///     this entity type.
diff --git a/src/EFCore/Metadata/Builders/IConventionTriggerBuilder.cs b/src/EFCore/Metadata/Builders/IConventionTriggerBuilder.cs
new file mode 100644
index 0000000000..49d79bf56f
--- /dev/null
+++ b/src/EFCore/Metadata/Builders/IConventionTriggerBuilder.cs
@@ -0,0 +1,18 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.EntityFrameworkCore.Metadata.Builders;
+
+/// <summary>
+///     Provides an API point for provider-specific extensions for configuring a <see cref="IConventionTrigger" />.
+/// </summary>
+/// <remarks>
+///     See <see href="https://aka.ms/efcore-docs-conventions">Model building conventions</see> for more information and examples.
+/// </remarks>
+public interface IConventionTriggerBuilder : IConventionAnnotatableBuilder
+{
+    /// <summary>
+    ///     The trigger being configured.
+    /// </summary>
+    new IConventionTrigger Metadata { get; }
+}
diff --git a/src/EFCore.Relational/Metadata/Builders/TriggerBuilder.cs b/src/EFCore/Metadata/Builders/TriggerBuilder.cs
similarity index 78%
rename from src/EFCore.Relational/Metadata/Builders/TriggerBuilder.cs
rename to src/EFCore/Metadata/Builders/TriggerBuilder.cs
index de61d080c6..5d248a4ae7 100644
--- a/src/EFCore.Relational/Metadata/Builders/TriggerBuilder.cs
+++ b/src/EFCore/Metadata/Builders/TriggerBuilder.cs
@@ -9,9 +9,6 @@ namespace Microsoft.EntityFrameworkCore.Metadata.Builders;
 /// <summary>
 ///     Provides an API point for provider-specific extensions for configuring a <see cref="ITrigger" />.
 /// </summary>
-/// <remarks>
-///     See <see href="https://aka.ms/efcore-docs-triggers">Database triggers</see> for more information and examples.
-/// </remarks>
 public class TriggerBuilder : IInfrastructure<IConventionTriggerBuilder>
 {
     /// <summary>
@@ -19,7 +16,7 @@ public class TriggerBuilder : IInfrastructure<IConventionTriggerBuilder>
     /// </summary>
     /// <param name="trigger">The <see cref="IMutableTrigger" /> to configure.</param>
     public TriggerBuilder(IMutableTrigger trigger)
-        => Builder = ((Trigger)trigger).Builder;
+        => InternalBuilder = ((Trigger)trigger).Builder;
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
@@ -28,35 +25,25 @@ public TriggerBuilder(IMutableTrigger trigger)
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
     [EntityFrameworkInternal]
-    protected virtual InternalTriggerBuilder Builder { [DebuggerStepThrough] get; }
+    protected virtual InternalTriggerBuilder InternalBuilder { [DebuggerStepThrough] get; }
+
+    /// <summary>
+    ///     Gets the builder that can be used to configure this trigger.
+    /// </summary>
+    protected virtual IConventionTriggerBuilder Builder => InternalBuilder;
 
     /// <inheritdoc />
     IConventionTriggerBuilder IInfrastructure<IConventionTriggerBuilder>.Instance
     {
         [DebuggerStepThrough]
-        get => Builder;
+        get => InternalBuilder;
     }
 
     /// <summary>
     ///     The trigger being configured.
     /// </summary>
     public virtual IMutableTrigger Metadata
-        => Builder.Metadata;
-
-    /// <summary>
-    ///     Sets the database name of the trigger.
-    /// </summary>
-    /// <remarks>
-    ///     See <see href="https://aka.ms/efcore-docs-triggers">Database triggers</see> for more information and examples.
-    /// </remarks>
-    /// <param name="name">The database name of the trigger.</param>
-    /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
-    public virtual TriggerBuilder HasName(string name)
-    {
-        Builder.HasName(name, ConfigurationSource.Explicit);
-
-        return this;
-    }
+        => InternalBuilder.Metadata;
 
     /// <summary>
     ///     Adds or updates an annotation on the trigger. If an annotation with the key specified in <paramref name="annotation" />
@@ -69,7 +56,7 @@ public virtual TriggerBuilder HasAnnotation(string annotation, object? value)
     {
         Check.NotEmpty(annotation, nameof(annotation));
 
-        Builder.HasAnnotation(annotation, value, ConfigurationSource.Explicit);
+        InternalBuilder.HasAnnotation(annotation, value, ConfigurationSource.Explicit);
 
         return this;
     }
diff --git a/src/EFCore/Metadata/Conventions/RuntimeModelConvention.cs b/src/EFCore/Metadata/Conventions/RuntimeModelConvention.cs
index 5208834278..e8cc5b2c04 100644
--- a/src/EFCore/Metadata/Conventions/RuntimeModelConvention.cs
+++ b/src/EFCore/Metadata/Conventions/RuntimeModelConvention.cs
@@ -96,6 +96,14 @@ protected virtual RuntimeModel Create(IModel model)
                         convention.ProcessIndexAnnotations(annotations, source, target, runtime));
             }
 
+            foreach (var trigger in entityType.GetDeclaredTriggers())
+            {
+                var runtimeTrigger = Create(trigger, runtimeEntityType);
+                CreateAnnotations(
+                    trigger, runtimeTrigger, static (convention, annotations, source, target, runtime) =>
+                        convention.ProcessTriggerAnnotations(annotations, source, target, runtime));
+            }
+
             runtimeEntityType.ConstructorBinding = Create(entityType.ConstructorBinding, runtimeEntityType);
             runtimeEntityType.ServiceOnlyConstructorBinding =
                 Create(((IRuntimeEntityType)entityType).ServiceOnlyConstructorBinding, runtimeEntityType);
@@ -481,6 +489,34 @@ private RuntimeForeignKey Create(IForeignKey foreignKey, RuntimeEntityType runti
             foreignKey.IsOwnership);
     }
 
+    private static RuntimeTrigger Create(ITrigger trigger, RuntimeEntityType runtimeEntityType)
+        => runtimeEntityType.AddTrigger(trigger.ModelName);
+
+    /// <summary>
+    ///     Updates the trigger annotations that will be set on the read-only object.
+    /// </summary>
+    /// <param name="annotations">The annotations to be processed.</param>
+    /// <param name="trigger">The source trigger.</param>
+    /// <param name="runtimeTrigger">The target trigger that will contain the annotations.</param>
+    /// <param name="runtime">Indicates whether the given annotations are runtime annotations.</param>
+    protected virtual void ProcessTriggerAnnotations(
+        Dictionary<string, object?> annotations,
+        ITrigger trigger,
+        RuntimeTrigger runtimeTrigger,
+        bool runtime)
+    {
+        if (!runtime)
+        {
+            foreach (var (key, _) in annotations)
+            {
+                if (CoreAnnotationNames.AllNames.Contains(key))
+                {
+                    annotations.Remove(key);
+                }
+            }
+        }
+    }
+
     /// <summary>
     ///     Updates the foreign key annotations that will be set on the read-only object.
     /// </summary>
diff --git a/src/EFCore/Metadata/IConventionEntityType.cs b/src/EFCore/Metadata/IConventionEntityType.cs
index 4279dccbd3..d3cfec7c60 100644
--- a/src/EFCore/Metadata/IConventionEntityType.cs
+++ b/src/EFCore/Metadata/IConventionEntityType.cs
@@ -1026,4 +1026,37 @@ public interface IConventionEntityType : IReadOnlyEntityType, IConventionTypeBas
     /// <param name="property">The property to remove.</param>
     /// <returns>The removed property, or <see langword="null" /> if the property was not found.</returns>
     IConventionServiceProperty? RemoveServiceProperty(IReadOnlyServiceProperty property);
+
+    /// <summary>
+    ///     Finds a trigger with the given name.
+    /// </summary>
+    /// <param name="name">The trigger name.</param>
+    /// <returns>The trigger or <see langword="null" /> if no trigger with the given name was found.</returns>
+    new IConventionTrigger? FindDeclaredTrigger(string name);
+
+    /// <summary>
+    ///     Returns the declared triggers on the entity type.
+    /// </summary>
+    new IEnumerable<IConventionTrigger> GetDeclaredTriggers();
+
+    /// <summary>
+    ///     Creates a new trigger with the given name on entity type. Throws an exception if a trigger with the same name exists on the same
+    ///     entity type.
+    /// </summary>
+    /// <param name="name">The trigger name.</param>
+    /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
+    /// <returns>The trigger.</returns>
+    IConventionTrigger? AddTrigger(
+        string name,
+        bool fromDataAnnotation = false);
+
+    /// <summary>
+    ///     Removes the trigger with the given name.
+    /// </summary>
+    /// <param name="name">The trigger name.</param>
+    /// <returns>
+    ///     The removed trigger or <see langword="null" /> if no trigger with the given name was found
+    ///     or the existing trigger was configured from a higher source.
+    /// </returns>
+    IConventionTrigger? RemoveTrigger(string name);
 }
diff --git a/src/EFCore.Relational/Metadata/IConventionTrigger.cs b/src/EFCore/Metadata/IConventionTrigger.cs
similarity index 61%
rename from src/EFCore.Relational/Metadata/IConventionTrigger.cs
rename to src/EFCore/Metadata/IConventionTrigger.cs
index b0ced88561..2e64a37f8c 100644
--- a/src/EFCore.Relational/Metadata/IConventionTrigger.cs
+++ b/src/EFCore/Metadata/IConventionTrigger.cs
@@ -4,7 +4,7 @@
 namespace Microsoft.EntityFrameworkCore.Metadata;
 
 /// <summary>
-///     Represents a database sequence in the model.
+///     Represents a store trigger.
 /// </summary>
 /// <remarks>
 ///     See <see href="https://aka.ms/efcore-docs-triggers">Database triggers</see> for more information and examples.
@@ -27,18 +27,4 @@ public interface IConventionTrigger : IReadOnlyTrigger, IConventionAnnotatable
     /// </summary>
     /// <returns>The configuration source for this trigger.</returns>
     ConfigurationSource GetConfigurationSource();
-
-    /// <summary>
-    ///     Sets the name of the trigger in the database.
-    /// </summary>
-    /// <param name="name">The name of the trigger in the database.</param>
-    /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
-    /// <returns>The configured value.</returns>
-    string? SetName(string? name, bool fromDataAnnotation = false);
-
-    /// <summary>
-    ///     Gets the configuration source for the database name.
-    /// </summary>
-    /// <returns>The configuration source for the database name.</returns>
-    ConfigurationSource? GetNameConfigurationSource();
 }
diff --git a/src/EFCore/Metadata/IEntityType.cs b/src/EFCore/Metadata/IEntityType.cs
index bd8574d7e8..c912d966a0 100644
--- a/src/EFCore/Metadata/IEntityType.cs
+++ b/src/EFCore/Metadata/IEntityType.cs
@@ -564,4 +564,16 @@ public interface IEntityType : IReadOnlyEntityType, ITypeBase
     /// </remarks>
     /// <returns>The service properties defined on this entity type.</returns>
     new IEnumerable<IServiceProperty> GetServiceProperties();
+
+    /// <summary>
+    ///     Finds a trigger with the given name.
+    /// </summary>
+    /// <param name="name">The trigger name.</param>
+    /// <returns>The trigger or <see langword="null" /> if no trigger with the given name was found.</returns>
+    new ITrigger? FindDeclaredTrigger(string name);
+
+    /// <summary>
+    ///     Returns the declared triggers on the entity type.
+    /// </summary>
+    new IEnumerable<ITrigger> GetDeclaredTriggers();
 }
diff --git a/src/EFCore/Metadata/IMutableEntityType.cs b/src/EFCore/Metadata/IMutableEntityType.cs
index 35090e0b6d..5798de4c7b 100644
--- a/src/EFCore/Metadata/IMutableEntityType.cs
+++ b/src/EFCore/Metadata/IMutableEntityType.cs
@@ -891,4 +891,33 @@ IMutableProperty AddProperty(MemberInfo memberInfo)
     /// <param name="property">The property to remove.</param>
     /// <returns>The removed property, or <see langword="null" /> if the property was not found.</returns>
     IMutableServiceProperty? RemoveServiceProperty(IReadOnlyServiceProperty property);
+
+    /// <summary>
+    ///     Finds a trigger with the given name.
+    /// </summary>
+    /// <param name="name">The trigger name.</param>
+    /// <returns>The trigger or <see langword="null" /> if no trigger with the given name was found.</returns>
+    new IMutableTrigger? FindDeclaredTrigger(string name);
+
+    /// <summary>
+    ///     Returns the declared triggers on the entity type.
+    /// </summary>
+    new IEnumerable<IMutableTrigger> GetDeclaredTriggers();
+
+    /// <summary>
+    ///     Creates a new trigger with the given name on entity type. Throws an exception if a trigger with the same name exists on the same
+    ///     entity type.
+    /// </summary>
+    /// <param name="name">The trigger name.</param>
+    /// <returns>The trigger.</returns>
+    IMutableTrigger AddTrigger(string name);
+
+    /// <summary>
+    ///     Removes the trigger with the given name.
+    /// </summary>
+    /// <param name="name">The trigger name.</param>
+    /// <returns>
+    ///     The removed trigger or <see langword="null" /> if no trigger with the given name was found.
+    /// </returns>
+    IMutableTrigger? RemoveTrigger(string name);
 }
diff --git a/src/EFCore.Relational/Metadata/IMutableTrigger.cs b/src/EFCore/Metadata/IMutableTrigger.cs
similarity index 81%
rename from src/EFCore.Relational/Metadata/IMutableTrigger.cs
rename to src/EFCore/Metadata/IMutableTrigger.cs
index 037aec2bd8..542b95cd32 100644
--- a/src/EFCore.Relational/Metadata/IMutableTrigger.cs
+++ b/src/EFCore/Metadata/IMutableTrigger.cs
@@ -4,7 +4,7 @@
 namespace Microsoft.EntityFrameworkCore.Metadata;
 
 /// <summary>
-///     Represents a database trigger on a table.
+///     Represents a store trigger.
 /// </summary>
 /// <remarks>
 ///     <para>
@@ -20,9 +20,4 @@ public interface IMutableTrigger : IReadOnlyTrigger, IMutableAnnotatable
     ///     Gets the <see cref="IMutableEntityType" /> on which this trigger is defined.
     /// </summary>
     new IMutableEntityType EntityType { get; }
-
-    /// <summary>
-    ///     Gets or sets the name of the trigger in the database.
-    /// </summary>
-    new string? Name { get; set; }
 }
diff --git a/src/EFCore/Metadata/IReadOnlyEntityType.cs b/src/EFCore/Metadata/IReadOnlyEntityType.cs
index 43c89b6e3f..899d9dc827 100644
--- a/src/EFCore/Metadata/IReadOnlyEntityType.cs
+++ b/src/EFCore/Metadata/IReadOnlyEntityType.cs
@@ -79,7 +79,7 @@ bool GetIsDiscriminatorMappingComplete()
             ? null
             : (object?)GetDefaultDiscriminatorValue();
     }
-    
+
     /// <summary>
     ///     Returns the default discriminator value that would be used for this entity type.
     /// </summary>
@@ -750,6 +750,18 @@ IReadOnlyProperty GetProperty(string name)
     /// <returns>The service properties defined on this entity type.</returns>
     IEnumerable<IReadOnlyServiceProperty> GetServiceProperties();
 
+    /// <summary>
+    ///     Finds a trigger with the given name.
+    /// </summary>
+    /// <param name="name">The trigger name.</param>
+    /// <returns>The trigger or <see langword="null" /> if no trigger with the given name was found.</returns>
+    IReadOnlyTrigger? FindDeclaredTrigger(string name);
+
+    /// <summary>
+    ///     Returns the declared triggers on the entity type.
+    /// </summary>
+    IEnumerable<IReadOnlyTrigger> GetDeclaredTriggers();
+
     /// <summary>
     ///     <para>
     ///         Creates a human-readable representation of the given metadata.
diff --git a/src/EFCore.Relational/Metadata/IReadOnlyTrigger.cs b/src/EFCore/Metadata/IReadOnlyTrigger.cs
similarity index 52%
rename from src/EFCore.Relational/Metadata/IReadOnlyTrigger.cs
rename to src/EFCore/Metadata/IReadOnlyTrigger.cs
index a03fdff0e6..c7e0ad5153 100644
--- a/src/EFCore.Relational/Metadata/IReadOnlyTrigger.cs
+++ b/src/EFCore/Metadata/IReadOnlyTrigger.cs
@@ -6,7 +6,7 @@
 namespace Microsoft.EntityFrameworkCore.Metadata;
 
 /// <summary>
-///     Represents a database trigger on a table.
+///     Represents a store trigger.
 /// </summary>
 /// <remarks>
 ///     <para>
@@ -23,48 +23,6 @@ public interface IReadOnlyTrigger : IReadOnlyAnnotatable
     /// </summary>
     string ModelName { get; }
 
-    /// <summary>
-    ///     Gets the database name of the trigger.
-    /// </summary>
-    string? Name { get; }
-
-    /// <summary>
-    ///     Gets the name of the table on which this trigger is defined.
-    /// </summary>
-    string TableName { get; }
-
-    /// <summary>
-    ///     Gets the schema of the table on which this trigger is defined.
-    /// </summary>
-    string? TableSchema { get; }
-
-    /// <summary>
-    ///     Returns the default database name that would be used for this trigger.
-    /// </summary>
-    /// <returns>The default name that would be used for this trigger.</returns>
-    string? GetDefaultName()
-    {
-        var table = StoreObjectIdentifier.Create(EntityType, StoreObjectType.Table);
-        return !table.HasValue ? null : GetDefaultName(table.Value);
-    }
-
-    /// <summary>
-    ///     Gets the database name of the trigger.
-    /// </summary>
-    /// <param name="storeObject">The identifier of the store object.</param>
-    /// <returns>The database name of the trigger for the given store object.</returns>
-    string? GetName(in StoreObjectIdentifier storeObject);
-
-    /// <summary>
-    ///     Returns the default database name that would be used for this trigger.
-    /// </summary>
-    /// <param name="storeObject">The identifier of the store object.</param>
-    /// <returns>The default name that would be used for this trigger.</returns>
-    string? GetDefaultName(in StoreObjectIdentifier storeObject)
-        => storeObject.StoreObjectType == StoreObjectType.Table
-            ? Uniquifier.Truncate(ModelName, EntityType.Model.GetMaxIdentifierLength())
-            : null;
-
     /// <summary>
     ///     Gets the entity type on which this trigger is defined.
     /// </summary>
@@ -92,22 +50,6 @@ string ToDebugString(MetadataDebugStringOptions options = MetadataDebugStringOpt
             .Append("Trigger: ")
             .Append(ModelName);
 
-        if (Name != ModelName)
-        {
-            builder.Append('*');
-        }
-
-        builder.Append(" ");
-
-        if (TableSchema != null)
-        {
-            builder
-                .Append('.')
-                .Append(TableSchema);
-        }
-
-        builder.Append(TableName);
-
         if ((options & MetadataDebugStringOptions.SingleLine) == 0)
         {
             if ((options & MetadataDebugStringOptions.IncludeAnnotations) != 0)
diff --git a/src/EFCore.Relational/Metadata/ITrigger.cs b/src/EFCore/Metadata/ITrigger.cs
similarity index 82%
rename from src/EFCore.Relational/Metadata/ITrigger.cs
rename to src/EFCore/Metadata/ITrigger.cs
index ab5eee6ec5..4358168c56 100644
--- a/src/EFCore.Relational/Metadata/ITrigger.cs
+++ b/src/EFCore/Metadata/ITrigger.cs
@@ -4,7 +4,7 @@
 namespace Microsoft.EntityFrameworkCore.Metadata;
 
 /// <summary>
-///     Represents a database trigger on a table.
+///     Represents a store trigger.
 /// </summary>
 /// <remarks>
 ///     <para>
@@ -20,9 +20,4 @@ public interface ITrigger : IReadOnlyTrigger, IAnnotatable
     ///     Gets the entity type on which this trigger is defined.
     /// </summary>
     new IEntityType EntityType { get; }
-
-    /// <summary>
-    ///     Gets the database name of the trigger.
-    /// </summary>
-    new string Name { get; }
 }
diff --git a/src/EFCore/Metadata/Internal/EntityType.cs b/src/EFCore/Metadata/Internal/EntityType.cs
index 73db23e073..90b7170800 100644
--- a/src/EFCore/Metadata/Internal/EntityType.cs
+++ b/src/EFCore/Metadata/Internal/EntityType.cs
@@ -26,18 +26,21 @@ public class EntityType : TypeBase, IMutableEntityType, IConventionEntityType, I
     private readonly SortedDictionary<string, SkipNavigation> _skipNavigations
         = new(StringComparer.Ordinal);
 
+    private readonly SortedDictionary<string, ServiceProperty> _serviceProperties
+        = new(StringComparer.Ordinal);
+
+    private readonly SortedDictionary<string, Property> _properties;
+
     private readonly SortedDictionary<IReadOnlyList<IReadOnlyProperty>, Index> _unnamedIndexes
         = new(PropertyListComparer.Instance);
 
     private readonly SortedDictionary<string, Index> _namedIndexes
         = new(StringComparer.Ordinal);
 
-    private readonly SortedDictionary<string, Property> _properties;
-
     private readonly SortedDictionary<IReadOnlyList<IReadOnlyProperty>, Key> _keys
         = new(PropertyListComparer.Instance);
 
-    private readonly SortedDictionary<string, ServiceProperty> _serviceProperties
+    private readonly SortedDictionary<string, Trigger> _triggers
         = new(StringComparer.Ordinal);
 
     private List<object>? _data;
@@ -2957,6 +2960,86 @@ public virtual IEnumerable<ServiceProperty> GetDerivedServiceProperties()
 
     #endregion
 
+    #region Triggers
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual Trigger? AddTrigger(
+        string modelName,
+        ConfigurationSource configurationSource)
+    {
+        Check.NotEmpty(modelName, nameof(modelName));
+        Check.DebugAssert(IsInModel, "The entity type has been removed from the model");
+        EnsureMutable();
+
+        if (_triggers.ContainsKey(modelName))
+        {
+            throw new InvalidOperationException(
+                CoreStrings.DuplicateTrigger(
+                    modelName, DisplayName(), DisplayName()));
+        }
+
+        var trigger = new Trigger(modelName, this, configurationSource);
+
+        _triggers.Add(modelName, trigger);
+
+        return trigger;
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual Trigger? FindDeclaredTrigger(string modelName)
+    {
+        Check.NotEmpty(modelName, nameof(modelName));
+
+        return _triggers.TryGetValue(modelName, out var trigger)
+            ? trigger
+            : null;
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual IEnumerable<Trigger> GetDeclaredTriggers()
+        => _triggers.Values;
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual Trigger? RemoveTrigger(string modelName)
+    {
+        Check.NotEmpty(modelName, nameof(modelName));
+        Check.DebugAssert(IsInModel, "The entity type has been removed from the model");
+        EnsureMutable();
+
+        if (!_triggers.TryGetValue(modelName, out var trigger))
+        {
+            return null;
+        }
+
+        _triggers.Remove(modelName);
+
+        trigger.SetRemovedFromModel();
+
+        return trigger;
+    }
+
+    #endregion
+
     #region Ignore
 
     /// <summary>
@@ -5207,6 +5290,126 @@ IEnumerable<IServiceProperty> IEntityType.GetServiceProperties()
     IConventionServiceProperty? IConventionEntityType.RemoveServiceProperty(string name)
         => RemoveServiceProperty(name);
 
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    [DebuggerStepThrough]
+    IReadOnlyTrigger? IReadOnlyEntityType.FindDeclaredTrigger(string name)
+        => FindDeclaredTrigger(name);
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    [DebuggerStepThrough]
+    IConventionTrigger? IConventionEntityType.FindDeclaredTrigger(string name)
+        => FindDeclaredTrigger(name);
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    [DebuggerStepThrough]
+    IMutableTrigger? IMutableEntityType.FindDeclaredTrigger(string name)
+        => FindDeclaredTrigger(name);
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    [DebuggerStepThrough]
+    ITrigger? IEntityType.FindDeclaredTrigger(string name)
+        => FindDeclaredTrigger(name);
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    [DebuggerStepThrough]
+    IEnumerable<IReadOnlyTrigger> IReadOnlyEntityType.GetDeclaredTriggers()
+        => GetDeclaredTriggers();
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    [DebuggerStepThrough]
+    IEnumerable<IConventionTrigger> IConventionEntityType.GetDeclaredTriggers()
+        => GetDeclaredTriggers();
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    [DebuggerStepThrough]
+    IEnumerable<IMutableTrigger> IMutableEntityType.GetDeclaredTriggers()
+        => GetDeclaredTriggers();
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    [DebuggerStepThrough]
+    IEnumerable<ITrigger> IEntityType.GetDeclaredTriggers()
+        => GetDeclaredTriggers();
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    [DebuggerStepThrough]
+    IMutableTrigger IMutableEntityType.AddTrigger(string name)
+        => AddTrigger(name, ConfigurationSource.Explicit)!;
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    [DebuggerStepThrough]
+    IConventionTrigger? IConventionEntityType.AddTrigger(string name, bool fromDataAnnotation)
+        => AddTrigger(name, fromDataAnnotation ? ConfigurationSource.DataAnnotation : ConfigurationSource.Convention);
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    [DebuggerStepThrough]
+    IMutableTrigger? IMutableEntityType.RemoveTrigger(string name)
+        => RemoveTrigger(name);
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    [DebuggerStepThrough]
+    IConventionTrigger? IConventionEntityType.RemoveTrigger(string name)
+        => RemoveTrigger(name);
+
     #endregion
 
     private static IEnumerable<T> ToEnumerable<T>(T? element)
@@ -5301,6 +5504,11 @@ public virtual void Attach(InternalEntityTypeBuilder entityTypeBuilder)
                     EntityType.GetChangeTrackingStrategy(), EntityType._changeTrackingStrategyConfigurationSource.Value);
             }
 
+            foreach (var trigger in EntityType.GetDeclaredTriggers())
+            {
+                trigger.Builder.Attach(entityTypeBuilder);
+            }
+
             if (ServiceProperties != null)
             {
                 foreach (var detachedServiceProperty in ServiceProperties)
diff --git a/src/EFCore/Metadata/Internal/InternalEntityTypeBuilder.cs b/src/EFCore/Metadata/Internal/InternalEntityTypeBuilder.cs
index b5e4f15118..525edfba25 100644
--- a/src/EFCore/Metadata/Internal/InternalEntityTypeBuilder.cs
+++ b/src/EFCore/Metadata/Internal/InternalEntityTypeBuilder.cs
@@ -148,7 +148,7 @@ public InternalEntityTypeBuilder(EntityType metadata, InternalModelBuilder model
 
         return keyBuilder;
     }
-    
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -172,7 +172,7 @@ public InternalEntityTypeBuilder(EntityType metadata, InternalModelBuilder model
                 return false;
             }
         }
-        
+
         var previousPrimaryKey = Metadata.FindPrimaryKey();
         if (previousPrimaryKey != null
             && previousPrimaryKey.Properties.Select(p => p.Name).SequenceEqual(propertyNames))
@@ -1428,6 +1428,29 @@ private bool CanIgnore(string name, ConfigurationSource configurationSource, boo
         return true;
     }
 
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual InternalTriggerBuilder? HasTrigger(
+        string modelName,
+        ConfigurationSource configurationSource)
+    {
+        var entityType = Metadata;
+        var trigger = entityType.FindDeclaredTrigger(modelName);
+        if (trigger != null)
+        {
+            trigger.UpdateConfigurationSource(configurationSource);
+            return trigger.Builder;
+        }
+
+        trigger = entityType.AddTrigger(modelName, configurationSource);
+
+        return trigger?.Builder;
+    }
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -2489,7 +2512,7 @@ private static void RemovePropertyIfUnused(Property property, ConfigurationSourc
                 return false;
             }
         }
-        
+
         return true;
     }
 
@@ -4187,7 +4210,7 @@ private static bool Contains(IReadOnlyForeignKey? inheritedFk, IReadOnlyForeignK
         List<SkipNavigation>? navigationsToDetach = null;
         List<(InternalSkipNavigationBuilder Navigation, InternalSkipNavigationBuilder Inverse)>? detachedNavigations = null;
         InternalSkipNavigationBuilder builder;
-        
+
         var navigationName = navigationProperty.Name;
         if (navigationName != null)
         {
@@ -4922,7 +4945,7 @@ public virtual bool CanSetConstructorBinding(InstantiationBinding? constructorBi
         RemoveUnusedDiscriminatorProperty(discriminatorProperty, configurationSource);
 
         rootTypeBuilder.Metadata.SetDiscriminatorProperty(discriminatorProperty, configurationSource);
-        
+
         RemoveIncompatibleDiscriminatorValues(Metadata, discriminatorProperty, configurationSource);
 
         discriminatorPropertyBuilder.IsRequired(true, ConfigurationSource.Convention);
@@ -4981,7 +5004,7 @@ public virtual bool CanSetConstructorBinding(InstantiationBinding? constructorBi
         }
 
         Metadata.SetDiscriminatorProperty(null, configurationSource);
-        
+
         RemoveIncompatibleDiscriminatorValues(Metadata, null, configurationSource);
 
         if (configurationSource == ConfigurationSource.Explicit)
@@ -5315,7 +5338,7 @@ bool IConventionEntityTypeBuilder.CanSetPrimaryKey(IReadOnlyList<string> propert
         => CanSetPrimaryKey(
             propertyNames,
             fromDataAnnotation ? ConfigurationSource.DataAnnotation : ConfigurationSource.Convention);
-    
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -5428,7 +5451,7 @@ bool IConventionEntityTypeBuilder.CanRemoveKey(bool fromDataAnnotation)
             propertyNames,
             name,
             fromDataAnnotation ? ConfigurationSource.DataAnnotation : ConfigurationSource.Convention);
-    
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -5934,6 +5957,18 @@ bool IConventionEntityTypeBuilder.CanRemoveSkipNavigation(IConventionSkipNavigat
             (SkipNavigation)skipNavigation,
             fromDataAnnotation ? ConfigurationSource.DataAnnotation : ConfigurationSource.Convention);
 
+    /// <inheritdoc />
+    [DebuggerStepThrough]
+    IConventionTriggerBuilder? IConventionEntityTypeBuilder.HasTrigger(string modelName, bool fromDataAnnotation)
+        => HasTrigger(
+            modelName,
+            fromDataAnnotation ? ConfigurationSource.DataAnnotation : ConfigurationSource.Convention);
+
+    /// <inheritdoc />
+    [DebuggerStepThrough]
+    bool IConventionEntityTypeBuilder.CanHaveTrigger(string modelName, bool fromDataAnnotation)
+        => true;
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -6151,7 +6186,7 @@ bool IConventionEntityTypeBuilder.CanSetDiscriminator(MemberInfo memberInfo, boo
     [DebuggerStepThrough]
     bool IConventionEntityTypeBuilder.CanRemoveDiscriminator(bool fromDataAnnotation)
         => CanRemoveDiscriminator(fromDataAnnotation ? ConfigurationSource.DataAnnotation : ConfigurationSource.Convention);
-    
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
diff --git a/src/EFCore/Metadata/Internal/InternalTriggerBuilder.cs b/src/EFCore/Metadata/Internal/InternalTriggerBuilder.cs
new file mode 100644
index 0000000000..571803d998
--- /dev/null
+++ b/src/EFCore/Metadata/Internal/InternalTriggerBuilder.cs
@@ -0,0 +1,49 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.EntityFrameworkCore.Metadata.Internal;
+
+/// <summary>
+///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+///     any release. You should only use it directly in your code with extreme caution and knowing that
+///     doing so can result in application failures when updating to a new Entity Framework Core release.
+/// </summary>
+public class InternalTriggerBuilder : AnnotatableBuilder<Trigger, IConventionModelBuilder>, IConventionTriggerBuilder
+{
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public InternalTriggerBuilder(Trigger trigger, IConventionModelBuilder modelBuilder)
+        : base(trigger, modelBuilder)
+    {
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual InternalTriggerBuilder? Attach(InternalEntityTypeBuilder entityTypeBuilder)
+    {
+        var detachedTrigger = Metadata;
+        var newTriggerBuilder = entityTypeBuilder.HasTrigger(
+            detachedTrigger.ModelName,
+            detachedTrigger.GetConfigurationSource());
+
+        newTriggerBuilder?.MergeAnnotationsFrom(detachedTrigger);
+
+        return newTriggerBuilder;
+    }
+
+
+    IConventionTrigger IConventionTriggerBuilder.Metadata
+    {
+        [DebuggerStepThrough]
+        get => Metadata;
+    }
+}
diff --git a/src/EFCore/Metadata/Internal/Trigger.cs b/src/EFCore/Metadata/Internal/Trigger.cs
new file mode 100644
index 0000000000..45acd3ce6b
--- /dev/null
+++ b/src/EFCore/Metadata/Internal/Trigger.cs
@@ -0,0 +1,180 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.EntityFrameworkCore.Metadata.Internal;
+
+/// <summary>
+///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+///     any release. You should only use it directly in your code with extreme caution and knowing that
+///     doing so can result in application failures when updating to a new Entity Framework Core release.
+/// </summary>
+public class Trigger : ConventionAnnotatable, IMutableTrigger, IConventionTrigger, ITrigger
+{
+    private InternalTriggerBuilder? _builder;
+
+    private ConfigurationSource _configurationSource;
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public Trigger(
+        string modelName,
+        EntityType entityType,
+        ConfigurationSource configurationSource)
+    {
+        EntityType = entityType;
+        ModelName = modelName;
+        _configurationSource = configurationSource;
+
+        _builder = new InternalTriggerBuilder(this, ((IConventionModel)entityType.Model).Builder);
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual InternalTriggerBuilder Builder
+    {
+        [DebuggerStepThrough]
+        get => _builder ?? throw new InvalidOperationException(CoreStrings.ObjectRemovedFromModel);
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual bool IsInModel
+        => _builder is not null;
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual void SetRemovedFromModel()
+        => _builder = null;
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual EntityType EntityType { get; }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual string ModelName { get; }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual ConfigurationSource GetConfigurationSource()
+        => _configurationSource;
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual void UpdateConfigurationSource(ConfigurationSource configurationSource)
+        => _configurationSource = _configurationSource.Max(configurationSource);
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public override string ToString()
+        => ((ITrigger)this).ToDebugString(MetadataDebugStringOptions.SingleLineDefault);
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    [EntityFrameworkInternal]
+    public virtual DebugView DebugView
+        => new(
+            () => ((ITrigger)this).ToDebugString(),
+            () => ((ITrigger)this).ToDebugString(MetadataDebugStringOptions.LongDefault));
+    
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    IReadOnlyEntityType IReadOnlyTrigger.EntityType
+    {
+        [DebuggerStepThrough]
+        get => EntityType;
+    }
+    
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    IConventionEntityType IConventionTrigger.EntityType
+    {
+        [DebuggerStepThrough]
+        get => EntityType;
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    IMutableEntityType IMutableTrigger.EntityType
+    {
+        [DebuggerStepThrough]
+        get => EntityType;
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    IEntityType ITrigger.EntityType
+    {
+        [DebuggerStepThrough]
+        get => EntityType;
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    IConventionTriggerBuilder IConventionTrigger.Builder
+    {
+        [DebuggerStepThrough]
+        get => Builder;
+    }
+}
diff --git a/src/EFCore/Metadata/RuntimeEntityType.cs b/src/EFCore/Metadata/RuntimeEntityType.cs
index e584e27c3c..2cff9d5947 100644
--- a/src/EFCore/Metadata/RuntimeEntityType.cs
+++ b/src/EFCore/Metadata/RuntimeEntityType.cs
@@ -1,6 +1,9 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using System.Reflection;
+using System.Security.AccessControl;
+using System.Xml.Linq;
 using Microsoft.EntityFrameworkCore.ChangeTracking.Internal;
 using Microsoft.EntityFrameworkCore.Internal;
 using Microsoft.EntityFrameworkCore.Metadata.Internal;
@@ -23,18 +26,21 @@ public class RuntimeEntityType : AnnotatableBase, IRuntimeEntityType
     private readonly SortedDictionary<string, RuntimeSkipNavigation> _skipNavigations
         = new(StringComparer.Ordinal);
 
+    private readonly SortedDictionary<string, RuntimeServiceProperty> _serviceProperties
+        = new(StringComparer.Ordinal);
+
+    private readonly SortedDictionary<string, RuntimeProperty> _properties;
+
     private readonly SortedDictionary<IReadOnlyList<IReadOnlyProperty>, RuntimeIndex> _unnamedIndexes
         = new(PropertyListComparer.Instance);
 
     private readonly SortedDictionary<string, RuntimeIndex> _namedIndexes
         = new(StringComparer.Ordinal);
 
-    private readonly SortedDictionary<string, RuntimeProperty> _properties;
-
     private readonly SortedDictionary<IReadOnlyList<IReadOnlyProperty>, RuntimeKey> _keys
         = new(PropertyListComparer.Instance);
 
-    private readonly SortedDictionary<string, RuntimeServiceProperty> _serviceProperties
+    private readonly SortedDictionary<string, RuntimeTrigger> _triggers
         = new(StringComparer.Ordinal);
 
     private RuntimeKey? _primaryKey;
@@ -755,6 +761,43 @@ private IEnumerable<RuntimeServiceProperty> GetDerivedServiceProperties()
             ? Enumerable.Empty<RuntimeServiceProperty>()
             : GetDerivedTypes().SelectMany(et => et.GetDeclaredServiceProperties());
 
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual RuntimeTrigger AddTrigger(string modelName)
+    {
+        var trigger = new RuntimeTrigger(this, modelName);
+
+        _triggers.Add(modelName, trigger);
+
+        return trigger;
+    }
+
+    /// <summary>
+    ///     Finds a trigger with the given name.
+    /// </summary>
+    /// <param name="modelName">The trigger name.</param>
+    /// <returns>The trigger or <see langword="null" /> if no trigger with the given name was found.</returns>
+    public virtual RuntimeTrigger? FindDeclaredTrigger(string modelName)
+    {
+        Check.NotEmpty(modelName, nameof(modelName));
+
+        return _triggers.TryGetValue(modelName, out var trigger)
+            ? trigger
+            : null;
+    }
+
+    private IEnumerable<RuntimeTrigger> GetDeclaredTriggers()
+        => _triggers.Values;
+
+    private IEnumerable<RuntimeTrigger> GetTriggers()
+        => _baseType != null
+            ? _baseType.GetTriggers().Concat(GetDeclaredTriggers())
+            : GetDeclaredTriggers();
+
     /// <summary>
     ///     Gets or sets the <see cref="InstantiationBinding" /> for the preferred constructor.
     /// </summary>
@@ -1233,6 +1276,26 @@ IEnumerable<IReadOnlyProperty> IReadOnlyEntityType.GetProperties()
     IEnumerable<IProperty> IEntityType.GetProperties()
         => GetProperties();
 
+    /// <inheritdoc />
+    [DebuggerStepThrough]
+    IReadOnlyTrigger? IReadOnlyEntityType.FindDeclaredTrigger(string name)
+        => FindDeclaredTrigger(name);
+
+    /// <inheritdoc />
+    [DebuggerStepThrough]
+    ITrigger? IEntityType.FindDeclaredTrigger(string name)
+        => FindDeclaredTrigger(name);
+
+    /// <inheritdoc />
+    [DebuggerStepThrough]
+    IEnumerable<IReadOnlyTrigger> IReadOnlyEntityType.GetDeclaredTriggers()
+        => GetDeclaredTriggers();
+
+    /// <inheritdoc />
+    [DebuggerStepThrough]
+    IEnumerable<ITrigger> IEntityType.GetDeclaredTriggers()
+        => GetDeclaredTriggers();
+
     /// <inheritdoc />
     PropertyCounts IRuntimeEntityType.Counts
         => NonCapturingLazyInitializer.EnsureInitialized(ref _counts, this, static entityType => entityType.CalculateCounts());
diff --git a/src/EFCore.Relational/Metadata/RuntimeTrigger.cs b/src/EFCore/Metadata/RuntimeTrigger.cs
similarity index 63%
rename from src/EFCore.Relational/Metadata/RuntimeTrigger.cs
rename to src/EFCore/Metadata/RuntimeTrigger.cs
index 41397d4325..ac8ba0a7d1 100644
--- a/src/EFCore.Relational/Metadata/RuntimeTrigger.cs
+++ b/src/EFCore/Metadata/RuntimeTrigger.cs
@@ -6,9 +6,6 @@ namespace Microsoft.EntityFrameworkCore.Metadata;
 /// <summary>
 ///     Represents a database trigger on a table.
 /// </summary>
-/// <remarks>
-///     See <see href="https://aka.ms/efcore-docs-triggers">Database triggers</see> for more information and examples.
-/// </remarks>
 public class RuntimeTrigger : AnnotatableBase, ITrigger
 {
     /// <summary>
@@ -16,42 +13,16 @@ public class RuntimeTrigger : AnnotatableBase, ITrigger
     /// </summary>
     /// <param name="entityType">The entity type.</param>
     /// <param name="modelName">The name in the model.</param>
-    /// <param name="name">The name in the database.</param>
-    /// <param name="tableName">The name of the table.</param>
-    /// <param name="tableSchema">The schema of the table.</param>
     public RuntimeTrigger(
         RuntimeEntityType entityType,
-        string modelName,
-        string name,
-        string tableName,
-        string? tableSchema)
+        string modelName)
     {
         EntityType = entityType;
         ModelName = modelName;
-        Name = name;
-        TableName = tableName;
-        TableSchema = tableSchema;
     }
 
     /// <inheritdoc />
     public virtual string ModelName { get; }
-    
-    /// <inheritdoc />
-    public virtual string Name { get; }
-
-    /// <inheritdoc />
-    public virtual string? GetName(in StoreObjectIdentifier storeObject)
-        => storeObject.StoreObjectType == StoreObjectType.Table
-                && TableName == storeObject.Name
-                && TableSchema == storeObject.Schema
-            ? Name
-            : null;
-
-    /// <inheritdoc />
-    public virtual string TableName { get; }
-
-    /// <inheritdoc />
-    public virtual string? TableSchema { get; }
 
     /// <inheritdoc />
     public virtual IEntityType EntityType { get; }
diff --git a/src/EFCore/Properties/CoreStrings.Designer.cs b/src/EFCore/Properties/CoreStrings.Designer.cs
index be918c9c6e..27f767ea76 100644
--- a/src/EFCore/Properties/CoreStrings.Designer.cs
+++ b/src/EFCore/Properties/CoreStrings.Designer.cs
@@ -786,6 +786,14 @@ public static string DuplicatePropertyInKey(object? propertyList, object? proper
                 GetString("DuplicatePropertyInKey", nameof(propertyList), nameof(property)),
                 propertyList, property);
 
+        /// <summary>
+        ///     The trigger '{trigger}' cannot be added to the entity type '{entityType}' because another trigger with the same name already exists on entity type '{conflictingEntityType}'.
+        /// </summary>
+        public static string DuplicateTrigger(object? trigger, object? entityType, object? conflictingEntityType)
+            => string.Format(
+                GetString("DuplicateTrigger", nameof(trigger), nameof(entityType), nameof(conflictingEntityType)),
+                trigger, entityType, conflictingEntityType);
+
         /// <summary>
         ///     Cannot translate '{comparisonOperator}' on a subquery expression of entity type '{entityType}' because it has a composite primary key. See https://go.microsoft.com/fwlink/?linkid=2141942 for information on how to rewrite your query.
         /// </summary>
diff --git a/src/EFCore/Properties/CoreStrings.resx b/src/EFCore/Properties/CoreStrings.resx
index e0f892b9ee..0ed95bdb7c 100644
--- a/src/EFCore/Properties/CoreStrings.resx
+++ b/src/EFCore/Properties/CoreStrings.resx
@@ -408,6 +408,9 @@
   <data name="DuplicatePropertyInKey" xml:space="preserve">
     <value>The properties {propertyList} cannot be used for a key, because they contain a duplicate: '{property}'.</value>
   </data>
+  <data name="DuplicateTrigger" xml:space="preserve">
+    <value>The trigger '{trigger}' cannot be added to the entity type '{entityType}' because another trigger with the same name already exists on entity type '{conflictingEntityType}'.</value>
+  </data>
   <data name="EntityEqualityOnCompositeKeyEntitySubqueryNotSupported" xml:space="preserve">
     <value>Cannot translate '{comparisonOperator}' on a subquery expression of entity type '{entityType}' because it has a composite primary key. See https://go.microsoft.com/fwlink/?linkid=2141942 for information on how to rewrite your query.</value>
   </data>
@@ -836,7 +839,7 @@
   </data>
   <data name="LogOptimisticConcurrencyException" xml:space="preserve">
     <value>{error}</value>
-    <comment>Debug CoreEventId.OptimisticConcurrencyException Exception?</comment>
+    <comment>Debug CoreEventId.OptimisticConcurrencyException Exception</comment>
   </data>
   <data name="LogPossibleIncorrectRequiredNavigationWithQueryFilterInteraction" xml:space="preserve">
     <value>Entity '{principalEntityType}' has a global query filter defined and is the required end of a relationship with the entity '{declaringEntityType}'. This may lead to unexpected results when the required entity is filtered out. Either configure the navigation as optional, or define matching query filters for both entities in the navigation. See https://go.microsoft.com/fwlink/?linkid=2131316 for more information.</value>
diff --git a/test/EFCore.Cosmos.FunctionalTests/TestUtilities/CosmosTestStore.cs b/test/EFCore.Cosmos.FunctionalTests/TestUtilities/CosmosTestStore.cs
index 57cb328877..067d5c62ac 100644
--- a/test/EFCore.Cosmos.FunctionalTests/TestUtilities/CosmosTestStore.cs
+++ b/test/EFCore.Cosmos.FunctionalTests/TestUtilities/CosmosTestStore.cs
@@ -658,5 +658,17 @@ IEnumerable<IReadOnlyServiceProperty> IReadOnlyEntityType.GetServiceProperties()
 
         IEnumerable<IReadOnlySkipNavigation> IReadOnlyEntityType.GetSkipNavigations()
             => throw new NotImplementedException();
+
+        IReadOnlyTrigger IReadOnlyEntityType.FindDeclaredTrigger(string name)
+            => throw new NotImplementedException();
+
+        ITrigger IEntityType.FindDeclaredTrigger(string name)
+            => throw new NotImplementedException();
+
+        IEnumerable<IReadOnlyTrigger> IReadOnlyEntityType.GetDeclaredTriggers()
+            => throw new NotImplementedException();
+
+        IEnumerable<ITrigger> IEntityType.GetDeclaredTriggers()
+            => throw new NotImplementedException();
     }
 }
diff --git a/test/EFCore.Design.Tests/Migrations/Design/CSharpMigrationsGeneratorTest.cs b/test/EFCore.Design.Tests/Migrations/Design/CSharpMigrationsGeneratorTest.cs
index fbc87aa5b6..c01abc5d74 100644
--- a/test/EFCore.Design.Tests/Migrations/Design/CSharpMigrationsGeneratorTest.cs
+++ b/test/EFCore.Design.Tests/Migrations/Design/CSharpMigrationsGeneratorTest.cs
@@ -241,7 +241,6 @@ public void Test_new_annotations_handled_for_properties()
             RelationalAnnotationNames.TptMappingStrategy,
             RelationalAnnotationNames.RelationalModel,
             RelationalAnnotationNames.ModelDependencies,
-            RelationalAnnotationNames.Triggers,
             RelationalAnnotationNames.FieldValueGetter,
             RelationalAnnotationNames.ContainerColumnName,
             RelationalAnnotationNames.ContainerColumnTypeMapping,
diff --git a/test/EFCore.Design.Tests/Migrations/ModelSnapshotSqlServerTest.cs b/test/EFCore.Design.Tests/Migrations/ModelSnapshotSqlServerTest.cs
index bc0392316e..f82fd769ab 100644
--- a/test/EFCore.Design.Tests/Migrations/ModelSnapshotSqlServerTest.cs
+++ b/test/EFCore.Design.Tests/Migrations/ModelSnapshotSqlServerTest.cs
@@ -990,9 +990,9 @@ public virtual void Entity_splitting_is_stored_in_snapshot_with_tables()
                     splitTable.FindColumn("Shadow").PropertyMappings.Select(m => m.TableMapping.EntityType));
                 Assert.Equal("bar", fragment["foo"]);
 
-                var trigger = orderEntityType.GetTriggers().Single();
-                Assert.Equal(splitTable.Name, trigger.TableName);
-                Assert.Equal(splitTable.Schema, trigger.TableSchema);
+                var trigger = orderEntityType.GetDeclaredTriggers().Single();
+                Assert.Equal(splitTable.Name, trigger.GetTableName());
+                Assert.Equal(splitTable.Schema, trigger.GetTableSchema());
                 Assert.Equal("rab", trigger["oof"]);
 
                 var billingFragment = billingEntityType.GetMappingFragments().Single();
@@ -1402,8 +1402,8 @@ public virtual void Trigger_is_stored_in_snapshot()
                 });"),
             o =>
             {
-                var trigger = Assert.Single(o.GetEntityTypes().Single().GetTriggers());
-                Assert.Equal("SomeTrigger", trigger.Name);
+                var trigger = Assert.Single(o.GetEntityTypes().Single().GetDeclaredTriggers());
+                Assert.Equal("SomeTrigger", trigger.GetName());
             });
 
     [ConditionalFact]
@@ -1449,9 +1449,9 @@ public virtual void Triggers_and_ExcludeFromMigrations_are_stored_in_snapshot()
                 Assert.True(entityType.IsTableExcludedFromMigrations());
 
                 Assert.Collection(
-                    entityType.GetTriggers().OrderBy(t => t.Name),
-                    t => Assert.Equal("SomeTrigger1", t.Name),
-                    t => Assert.Equal("SomeTrigger2", t.Name));
+                    entityType.GetDeclaredTriggers(),
+                    t => Assert.Equal("SomeTrigger1", t.GetName()),
+                    t => Assert.Equal("SomeTrigger2", t.GetName()));
             });
 
     [ConditionalFact]
diff --git a/test/EFCore.Design.Tests/Scaffolding/Internal/CSharpDbContextGeneratorTest.cs b/test/EFCore.Design.Tests/Scaffolding/Internal/CSharpDbContextGeneratorTest.cs
index 8f96cf0631..a81e0b05cc 100644
--- a/test/EFCore.Design.Tests/Scaffolding/Internal/CSharpDbContextGeneratorTest.cs
+++ b/test/EFCore.Design.Tests/Scaffolding/Internal/CSharpDbContextGeneratorTest.cs
@@ -1237,11 +1237,11 @@ protected override void OnModelCreating(ModelBuilder modelBuilder)
                 model =>
                 {
                     var entityType = model.FindEntityType("TestNamespace.Employee")!;
-                    var triggers = entityType.GetTriggers();
+                    var triggers = entityType.GetDeclaredTriggers();
 
-                    Assert.Collection(triggers.OrderBy(t => t.Name),
-                        t => Assert.Equal("Trigger1", t.Name),
-                        t => Assert.Equal("Trigger2", t.Name));
+                    Assert.Collection(triggers,
+                        t => Assert.Equal("Trigger1", t.GetName()),
+                        t => Assert.Equal("Trigger2", t.GetName()));
                 });
 
         [ConditionalFact]
diff --git a/test/EFCore.Design.Tests/Scaffolding/Internal/CSharpRuntimeModelCodeGeneratorTest.cs b/test/EFCore.Design.Tests/Scaffolding/Internal/CSharpRuntimeModelCodeGeneratorTest.cs
index 1f92875a81..a3f20003b8 100644
--- a/test/EFCore.Design.Tests/Scaffolding/Internal/CSharpRuntimeModelCodeGeneratorTest.cs
+++ b/test/EFCore.Design.Tests/Scaffolding/Internal/CSharpRuntimeModelCodeGeneratorTest.cs
@@ -4150,7 +4150,6 @@ public partial class TriggersContextModel
                         "DataEntityType.cs",
                         @"// <auto-generated />
 using System;
-using System.Collections.Generic;
 using System.Reflection;
 using Microsoft.EntityFrameworkCore.Metadata;
 using Microsoft.EntityFrameworkCore.Scaffolding.Internal;
@@ -4188,32 +4187,17 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 new[] { id });
             runtimeEntityType.SetPrimaryKey(key);
 
+            var trigger1 = runtimeEntityType.AddTrigger(
+                ""Trigger1"");
+
+            var trigger2 = runtimeEntityType.AddTrigger(
+                ""Trigger2"");
+
             return runtimeEntityType;
         }
 
         public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
         {
-            var triggers = new SortedDictionary<string, ITrigger>();
-
-            var trigger1 = new RuntimeTrigger(
-                runtimeEntityType,
-                ""Trigger1"",
-                ""Trigger1"",
-                ""Data"",
-                null);
-
-            triggers[""Trigger1""] = trigger1;
-
-            var trigger2 = new RuntimeTrigger(
-                runtimeEntityType,
-                ""Trigger2"",
-                ""Trigger2"",
-                ""Data"",
-                null);
-
-            triggers[""Trigger2""] = trigger2;
-
-            runtimeEntityType.AddAnnotation(""Relational:Triggers"", triggers);
             runtimeEntityType.AddAnnotation(""Relational:FunctionName"", null);
             runtimeEntityType.AddAnnotation(""Relational:Schema"", null);
             runtimeEntityType.AddAnnotation(""Relational:SqlQuery"", null);
diff --git a/test/EFCore.Relational.Tests/Infrastructure/RelationalModelValidatorTest.cs b/test/EFCore.Relational.Tests/Infrastructure/RelationalModelValidatorTest.cs
index 59993486df..d9896dd76e 100644
--- a/test/EFCore.Relational.Tests/Infrastructure/RelationalModelValidatorTest.cs
+++ b/test/EFCore.Relational.Tests/Infrastructure/RelationalModelValidatorTest.cs
@@ -3262,20 +3262,6 @@ public virtual void Detects_duplicate_column_orders()
         VerifyWarning(definition.GenerateMessage("Animal", "'Id', 'Name'"), modelBuilder, LogLevel.Error);
     }
 
-    [ConditionalFact]
-    public virtual void Detects_triggers_on_unmapped_entity_types()
-    {
-        var modelBuilder = CreateConventionModelBuilder();
-        modelBuilder.Entity<Animal>(
-            x =>
-                {
-                    x.ToTable(tb => tb.HasTrigger("Animal_Trigger"));
-                    x.ToTable(name: null);
-                });
-
-        VerifyError(RelationalStrings.TriggerOnUnmappedEntityType("Animal_Trigger", "Animal"), modelBuilder);
-    }
-
     [ConditionalFact]
     public virtual void Throws_when_non_tph_entity_type_short_names_are_not_unique()
     {
diff --git a/test/EFCore.Relational.Tests/Metadata/RelationalBuilderExtensionsTest.cs b/test/EFCore.Relational.Tests/Metadata/RelationalBuilderExtensionsTest.cs
index 621af188cc..02159f6f53 100644
--- a/test/EFCore.Relational.Tests/Metadata/RelationalBuilderExtensionsTest.cs
+++ b/test/EFCore.Relational.Tests/Metadata/RelationalBuilderExtensionsTest.cs
@@ -658,12 +658,12 @@ public void Can_create_trigger()
             .Entity<Customer>()
             .ToTable(tb => tb.HasTrigger("Customer_Trigger"));
 
-        var trigger = entityType.FindTrigger("Customer_Trigger");
+        var trigger = entityType.FindDeclaredTrigger("Customer_Trigger");
 
         Assert.NotNull(trigger);
         Assert.Same(entityType, trigger.EntityType);
         Assert.Equal("Customer_Trigger", trigger.ModelName);
-        Assert.Equal("Customer_Trigger", trigger.Name);
+        Assert.Equal("Customer_Trigger", trigger.GetName());
     }
 
     [ConditionalFact]
@@ -680,12 +680,12 @@ public void Can_create_trigger_with_duplicate_name_replaces_existing()
             .Entity<Customer>()
             .ToTable(tb => tb.HasTrigger("Customer_Trigger").HasName("Table2"));
 
-        var trigger = entityType.FindTrigger("Customer_Trigger");
+        var trigger = entityType.FindDeclaredTrigger("Customer_Trigger");
 
         Assert.NotNull(trigger);
         Assert.Equal(entityType, trigger.EntityType);
         Assert.Equal("Customer_Trigger", trigger.ModelName);
-        Assert.Equal("Table2", trigger.Name);
+        Assert.Equal("Table2", trigger.GetName());
     }
 
     [ConditionalFact]
@@ -694,117 +694,24 @@ public void Can_access_trigger()
         var typeBuilder = CreateBuilder().Entity(typeof(Splot), ConfigurationSource.Convention);
         IReadOnlyEntityType entityType = typeBuilder.Metadata;
 
-        Assert.NotNull(typeBuilder.HasTrigger("Splew", "Table1", "dbo"));
-        Assert.Equal("Splew", entityType.GetTriggers().Single().ModelName);
-        Assert.Equal("Table1", entityType.GetTriggers().Single().TableName);
-
-        Assert.NotNull(typeBuilder.HasTrigger("Splew", "Table2", "dbo", fromDataAnnotation: true));
-        Assert.Equal("Splew", entityType.GetTriggers().Single().ModelName);
-        Assert.Equal("Table2", entityType.GetTriggers().Single().TableName);
-
-        Assert.Null(typeBuilder.HasTrigger("Splew", "Table1", "dbo"));
-        Assert.Equal("Splew", entityType.GetTriggers().Single().ModelName);
-        Assert.Equal("Table2", entityType.GetTriggers().Single().TableName);
-    }
-
-    [ConditionalFact]
-    public void Base_trigger_overrides_derived_one()
-    {
-        var modelBuilder = CreateBuilder();
-
-        var derivedBuilder = modelBuilder.Entity(typeof(Splow), ConfigurationSource.Convention);
-        IReadOnlyEntityType derivedEntityType = derivedBuilder.Metadata;
-
-        Assert.NotNull(
-            derivedBuilder.HasTrigger("Splew", "Table1", "dbo", fromDataAnnotation: true)
-                .HasName("Splow_Trigger", fromDataAnnotation: true));
-        Assert.Equal("Splew", derivedEntityType.GetTriggers().Single().ModelName);
-        Assert.Equal("Splow_Trigger", derivedEntityType.GetTriggers().Single().Name);
-        Assert.Equal("Table1", derivedEntityType.GetTriggers().Single().TableName);
-        Assert.Equal("dbo", derivedEntityType.GetTriggers().Single().TableSchema);
-
-        Assert.True(derivedBuilder.CanHaveTrigger("Splew", "Table1", "dbo"));
-        Assert.True(derivedBuilder.CanHaveTrigger("Splew", "Table2", "dbo", fromDataAnnotation: true));
-        Assert.True(derivedBuilder.CanHaveTrigger("Splew", "Table1", "dbo2", fromDataAnnotation: true));
-        Assert.False(derivedBuilder.CanHaveTrigger("Splew", "Table2", "dbo"));
-        Assert.False(derivedBuilder.CanHaveTrigger("Splew", "Table1", "dbo2"));
-        Assert.True(derivedBuilder.CanHaveTrigger("Splot", "Table2", "dbo2"));
-
-        var baseBuilder = modelBuilder.Entity(typeof(Splot), ConfigurationSource.DataAnnotation);
-        IReadOnlyEntityType baseEntityType = baseBuilder.Metadata;
-
-        Assert.True(baseBuilder.CanHaveTrigger("Splew", "Table1", "dbo"));
-        Assert.True(baseBuilder.CanHaveTrigger("Splew", "Table2", "dbo", fromDataAnnotation: true));
-        Assert.True(baseBuilder.CanHaveTrigger("Splew", "Table1", "dbo2", fromDataAnnotation: true));
-        Assert.False(baseBuilder.CanHaveTrigger("Splew", "Table2", "dbo"));
-        Assert.False(baseBuilder.CanHaveTrigger("Splew", "Table1", "dbo2"));
-        Assert.True(baseBuilder.CanHaveTrigger("Splot", "Table2", "dbo2"));
-
-        Assert.Null(baseBuilder.HasTrigger("Splew", "Table2", "dbo"));
-        Assert.Empty(baseEntityType.GetTriggers());
-        Assert.Equal("Table1", derivedEntityType.GetTriggers().Single().TableName);
-
-        Assert.NotNull(
-            baseBuilder.HasTrigger("Splew", "Table1", "dbo", fromDataAnnotation: true)
-                .HasName("Another_Splot_Trigger", fromDataAnnotation: true));
-        Assert.Equal("Splew", baseEntityType.GetTriggers().Single().ModelName);
-        Assert.Equal("Table1", baseEntityType.GetTriggers().Single().TableName);
-        Assert.Equal("Another_Splot_Trigger", baseEntityType.GetTriggers().Single().Name);
-
-        derivedBuilder.HasBaseType((EntityType)baseEntityType, ConfigurationSource.Convention);
-
-        Assert.Null(
-            baseBuilder.HasTrigger("Splew", "Table1", "dbo", fromDataAnnotation: true)
-                .HasName("Yet_Another_Splot_Trigger"));
-        Assert.Equal("Splew", baseEntityType.GetTriggers().Single().ModelName);
-        Assert.Equal("Table1", baseEntityType.GetTriggers().Single().TableName);
-        Assert.Equal("Another_Splot_Trigger", baseEntityType.GetTriggers().Single().Name);
-        Assert.Empty(derivedEntityType.GetDeclaredTriggers());
-        Assert.Same(baseEntityType.GetTriggers().Single(), derivedEntityType.GetTriggers().Single());
-    }
-
-    [ConditionalFact]
-    public void Base_trigger_overrides_derived_one_after_base_is_set()
-    {
-        var modelBuilder = CreateBuilder();
-
-        var derivedBuilder = modelBuilder.Entity(typeof(Splow), ConfigurationSource.Convention);
-        Assert.NotNull(derivedBuilder.HasBaseType((string)null, ConfigurationSource.DataAnnotation));
-        IReadOnlyEntityType derivedEntityType = derivedBuilder.Metadata;
-
-        Assert.NotNull(
-            derivedBuilder.HasTrigger("Splew", nameof(Splow), null, fromDataAnnotation: true)
-                .HasName("Splow_Trigger", fromDataAnnotation: true));
-        Assert.Equal("Splew", derivedEntityType.GetTriggers().Single().ModelName);
-        Assert.Equal(nameof(Splow), derivedEntityType.GetTriggers().Single().TableName);
-        Assert.Equal("Splow_Trigger", derivedEntityType.GetTriggers().Single().Name);
-        Assert.Equal("Splow_Trigger", derivedEntityType.GetTriggers().Single()
-            .GetName(StoreObjectIdentifier.Create(derivedEntityType, StoreObjectType.Table).Value));
-
-        var baseBuilder = modelBuilder.Entity(typeof(Splot), ConfigurationSource.Convention);
-        IReadOnlyEntityType baseEntityType = baseBuilder.Metadata;
-        Assert.Null(derivedEntityType.BaseType);
-
-        Assert.NotNull(
-            baseBuilder.HasTrigger("Splew", nameof(Splot), null, fromDataAnnotation: true)
-                .HasName("Splot_Trigger", fromDataAnnotation: true));
-        Assert.Equal("Splew", baseEntityType.GetTriggers().Single().ModelName);
-        Assert.Equal(nameof(Splot), baseEntityType.GetTriggers().Single().TableName);
-        Assert.Equal("Splot_Trigger", baseEntityType.GetTriggers().Single().Name);
-
-        Assert.NotNull(derivedBuilder.HasBaseType((EntityType)baseEntityType, ConfigurationSource.DataAnnotation));
-
-        Assert.Null(baseBuilder.HasTrigger("Splew", "Table1", "dbo"));
-        Assert.Null(
-            baseBuilder.HasTrigger("Splew", nameof(Splot), null, fromDataAnnotation: true)
-                .HasName("Splew_Trigger"));
-        Assert.Equal("Splew", baseEntityType.GetTriggers().Single().ModelName);
-        Assert.Equal(nameof(Splot), baseEntityType.GetTriggers().Single().TableName);
-        Assert.Equal("Splot_Trigger", baseEntityType.GetTriggers().Single().Name);
-        Assert.Equal("Splot_Trigger", baseEntityType.GetTriggers().Single()
-            .GetName(StoreObjectIdentifier.Create(baseEntityType, StoreObjectType.Table).Value));
-        Assert.Empty(derivedEntityType.GetDeclaredTriggers());
-        Assert.Same(baseEntityType.GetTriggers().Single(), derivedEntityType.GetTriggers().Single());
+        var trigger = typeBuilder.HasTrigger("Splew", ConfigurationSource.Convention);
+        Assert.NotNull(trigger.HasTableName("Table1"));
+        Assert.NotNull(trigger.HasTableSchema("dbo"));
+        Assert.Equal("Splew", entityType.GetDeclaredTriggers().Single().ModelName);
+        Assert.Equal("Table1", entityType.GetDeclaredTriggers().Single().GetTableName());
+        Assert.Equal("dbo", entityType.GetDeclaredTriggers().Single().GetTableSchema());
+
+        trigger = typeBuilder.HasTrigger("Splew", ConfigurationSource.DataAnnotation);
+        Assert.NotNull(trigger.HasTableName("Table2", fromDataAnnotation: true));
+        Assert.NotNull(trigger.HasTableSchema("dbo", fromDataAnnotation: true));
+        Assert.Equal("Splew", entityType.GetDeclaredTriggers().Single().ModelName);
+        Assert.Equal("Table2", entityType.GetDeclaredTriggers().Single().GetTableName());
+
+        trigger = typeBuilder.HasTrigger("Splew", ConfigurationSource.Convention);
+        Assert.Null(trigger.HasTableName("Table1"));
+        Assert.NotNull(trigger.HasTableSchema("dbo"));
+        Assert.Equal("Splew", entityType.GetDeclaredTriggers().Single().ModelName);
+        Assert.Equal("Table2", entityType.GetDeclaredTriggers().Single().GetTableName());
     }
 
     [ConditionalFact]
diff --git a/test/EFCore.Relational.Tests/Metadata/RelationalModelTest.cs b/test/EFCore.Relational.Tests/Metadata/RelationalModelTest.cs
index 4e4f15bf4e..4ef2391565 100644
--- a/test/EFCore.Relational.Tests/Metadata/RelationalModelTest.cs
+++ b/test/EFCore.Relational.Tests/Metadata/RelationalModelTest.cs
@@ -736,10 +736,10 @@ private static void AssertTables(IRelationalModel model, Mapping mapping)
                 Assert.False(customerTable.IsOptional(extraSpecialCustomerType));
             }
 
-            var orderTrigger = Assert.Single(orderType.GetTriggers());
-            Assert.Equal("Order_Trigger", orderTrigger.Name);
-            Assert.Equal("Order", orderTrigger.TableName);
-            Assert.Null(orderTrigger.TableSchema);
+            var orderTrigger = Assert.Single(orderType.GetDeclaredTriggers());
+            Assert.Equal("Order_Trigger", orderTrigger.GetName());
+            Assert.Equal("Order", orderTrigger.GetTableName());
+            Assert.Null(orderTrigger.GetTableSchema());
 
             var customerPk = specialCustomerType.FindPrimaryKey();
 
diff --git a/test/EFCore.Relational.Tests/Metadata/TriggerTest.cs b/test/EFCore.Relational.Tests/Metadata/TriggerTest.cs
index 093c34be64..9736a54a84 100644
--- a/test/EFCore.Relational.Tests/Metadata/TriggerTest.cs
+++ b/test/EFCore.Relational.Tests/Metadata/TriggerTest.cs
@@ -15,13 +15,13 @@ public void Can_create_trigger_for_default_table()
             .Entity<Customer>()
             .ToTable(tb => tb.HasTrigger("Customer_Trigger"));
 
-        var trigger = entityType.FindTrigger("Customer_Trigger");
+        var trigger = entityType.FindDeclaredTrigger("Customer_Trigger");
 
         Assert.NotNull(trigger);
         Assert.Same(entityType, trigger.EntityType);
-        Assert.Equal("Customer_Trigger", trigger.Name);
-        Assert.Equal("Customer", trigger.TableName);
-        Assert.Null(trigger.TableSchema);
+        Assert.Equal("Customer_Trigger", trigger.GetName());
+        Assert.Equal("Customer", trigger.GetTableName());
+        Assert.Null(trigger.GetTableSchema());
         Assert.Equal(ConfigurationSource.Explicit, ((IConventionTrigger)trigger).GetConfigurationSource());
     }
 
@@ -35,41 +35,28 @@ public void Can_create_trigger_for_specific_table()
             .Entity<Customer>()
             .ToTable("CustomerTable", "dbo", tb => tb.HasTrigger("Customer_Trigger"));
 
-        var trigger = entityType.FindTrigger("Customer_Trigger");
+        var trigger = entityType.FindDeclaredTrigger("Customer_Trigger");
 
         Assert.NotNull(trigger);
         Assert.Same(entityType, trigger.EntityType);
-        Assert.Equal("Customer_Trigger", trigger.Name);
-        Assert.Equal("CustomerTable", trigger.TableName);
-        Assert.Equal("dbo", trigger.TableSchema);
+        Assert.Equal("Customer_Trigger", trigger.GetName());
+        Assert.Equal("CustomerTable", trigger.GetTableName());
+        Assert.Equal("dbo", trigger.GetTableSchema());
         Assert.Equal(ConfigurationSource.Explicit, ((IConventionTrigger)trigger).GetConfigurationSource());
     }
 
-    [ConditionalFact]
-    public void Create_trigger_on_unmapped_entity_type_throws()
-    {
-        var modelBuilder = CreateConventionModelBuilder();
-
-        var exception = Assert.Throws<InvalidOperationException>(() => modelBuilder
-            .Entity<Customer>()
-            .ToTable((string)null)
-            .ToTable(tb => tb.HasTrigger("Customer_Trigger")));
-
-        Assert.Equal(RelationalStrings.TriggerOnUnmappedEntityType("Customer_Trigger", "Customer"), exception.Message);
-    }
-
     [ConditionalFact]
     public void AddTrigger_with_duplicate_names_throws_exception()
     {
         var entityTypeBuilder = CreateConventionModelBuilder().Entity<Customer>();
         var entityType = entityTypeBuilder.Metadata;
 
-        entityType.AddTrigger("SomeTrigger", "SomeTable", null);
+        entityType.AddTrigger("SomeTrigger").SetTableName("SomeTable");
 
         Assert.Equal(
-            RelationalStrings.DuplicateTrigger("SomeTrigger", entityType.DisplayName(), entityType.DisplayName()),
+            CoreStrings.DuplicateTrigger("SomeTrigger", entityType.DisplayName(), entityType.DisplayName()),
             Assert.Throws<InvalidOperationException>(
-                () => entityType.AddTrigger("SomeTrigger", "SomeTable")).Message);
+                () => entityType.AddTrigger("SomeTrigger")).Message);
     }
 
     [ConditionalFact]
@@ -78,9 +65,10 @@ public void RemoveTrigger_returns_trigger_when_trigger_exists()
         var entityTypeBuilder = CreateConventionModelBuilder().Entity<Customer>();
         var entityType = entityTypeBuilder.Metadata;
 
-        var constraint = entityType.AddTrigger("SomeTrigger", "SomeTable");
+        var trigger = entityType.AddTrigger("SomeTrigger");
+        trigger.SetTableName("SomeTable");
 
-        Assert.Same(constraint, entityType.RemoveTrigger("SomeTrigger"));
+        Assert.Same(trigger, entityType.RemoveTrigger("SomeTrigger"));
     }
 
     [ConditionalFact]
diff --git a/test/EFCore.Relational.Tests/ModelBuilding/RelationalModelBuilderTest.cs b/test/EFCore.Relational.Tests/ModelBuilding/RelationalModelBuilderTest.cs
index fccef69145..9a6528e110 100644
--- a/test/EFCore.Relational.Tests/ModelBuilding/RelationalModelBuilderTest.cs
+++ b/test/EFCore.Relational.Tests/ModelBuilding/RelationalModelBuilderTest.cs
@@ -2087,6 +2087,7 @@ public abstract class TestOwnedNavigationStoredProcedureBuilder<TOwnerEntity, TD
         public abstract TestOwnedNavigationStoredProcedureBuilder<TOwnerEntity, TDependentEntity>
             HasRowsAffectedReturnValue(bool rowsAffectedReturned = true);
 
+
         public abstract TestOwnedNavigationStoredProcedureBuilder<TOwnerEntity, TDependentEntity> HasAnnotation(
             string annotation,
             object? value);
@@ -2373,19 +2374,19 @@ public abstract class TestTriggerBuilder
         public abstract TestTriggerBuilder HasAnnotation(string annotation, object? value);
     }
 
-    public class NonGenericTestTriggerBuilder : TestTriggerBuilder, IInfrastructure<TriggerBuilder>
+    public class NonGenericTestTriggerBuilder : TestTriggerBuilder, IInfrastructure<TableTriggerBuilder>
     {
-        public NonGenericTestTriggerBuilder(TriggerBuilder triggerBuilder)
+        public NonGenericTestTriggerBuilder(TableTriggerBuilder triggerBuilder)
         {
             TriggerBuilder = triggerBuilder;
         }
 
-        private TriggerBuilder TriggerBuilder { get; }
+        private TableTriggerBuilder TriggerBuilder { get; }
 
-        TriggerBuilder IInfrastructure<TriggerBuilder>.Instance
+        TableTriggerBuilder IInfrastructure<TableTriggerBuilder>.Instance
             => TriggerBuilder;
 
-        protected virtual TestTriggerBuilder Wrap(TriggerBuilder checkConstraintBuilder)
+        protected virtual TestTriggerBuilder Wrap(TableTriggerBuilder checkConstraintBuilder)
             => new NonGenericTestTriggerBuilder(checkConstraintBuilder);
 
         public override TestTriggerBuilder HasName(string name)
diff --git a/test/EFCore.Relational.Tests/RelationalApiConsistencyTest.cs b/test/EFCore.Relational.Tests/RelationalApiConsistencyTest.cs
index 048c0cd81b..6932510c1d 100644
--- a/test/EFCore.Relational.Tests/RelationalApiConsistencyTest.cs
+++ b/test/EFCore.Relational.Tests/RelationalApiConsistencyTest.cs
@@ -97,13 +97,6 @@ public class RelationalApiConsistencyFixture : ApiConsistencyFixtureBase
                         typeof(IConventionCheckConstraintBuilder),
                         typeof(ICheckConstraint))
                 },
-                {
-                    typeof(IReadOnlyTrigger),
-                    (typeof(IMutableTrigger),
-                        typeof(IConventionTrigger),
-                        typeof(IConventionTriggerBuilder),
-                        typeof(ITrigger))
-                },
                 {
                     typeof(IReadOnlyEntityTypeMappingFragment),
                     (typeof(IMutableEntityTypeMappingFragment),
@@ -177,6 +170,7 @@ public class RelationalApiConsistencyFixture : ApiConsistencyFixtureBase
             typeof(SplitViewBuilder<>),
             typeof(OwnedNavigationSplitViewBuilder),
             typeof(OwnedNavigationSplitViewBuilder<,>),
+            typeof(TableTriggerBuilder),
             typeof(TableValuedFunctionBuilder),
             typeof(TableValuedFunctionBuilder<>),
             typeof(OwnedNavigationTableValuedFunctionBuilder),
diff --git a/test/EFCore.Specification.Tests/ApiConsistencyTestBase.cs b/test/EFCore.Specification.Tests/ApiConsistencyTestBase.cs
index 0eaa66b172..e411c14682 100644
--- a/test/EFCore.Specification.Tests/ApiConsistencyTestBase.cs
+++ b/test/EFCore.Specification.Tests/ApiConsistencyTestBase.cs
@@ -60,7 +60,7 @@ public void Generic_fluent_api_methods_should_return_generic_types()
             {
                 continue;
             }
-            
+
             if (type.IsGenericType
                 && type.BaseType != typeof(object)
                 && !type.BaseType.IsGenericType)
@@ -85,7 +85,7 @@ public void Generic_fluent_api_methods_should_return_generic_types()
                     }
                 }
             }
-            
+
             if (!type.IsGenericType
                 && type.BaseType == typeof(object))
             {
@@ -246,7 +246,7 @@ private string ValidateMetadata(KeyValuePair<Type, (Type, Type, Type, Type)> typ
             {
                 return $"{conventionType.Name} should derive from IConventionAnnotatable";
             }
-            
+
             if (!typeof(IAnnotatable).IsAssignableFrom(runtimeType))
             {
                 return $"{runtimeType.Name} should derive from IAnnotatable";
@@ -1141,6 +1141,12 @@ protected ApiConsistencyFixtureBase()
                         typeof(IConventionIndexBuilder),
                         typeof(IIndex))
                 },
+                {
+                    typeof(IReadOnlyTrigger), (typeof(IMutableTrigger),
+                        typeof(IConventionTrigger),
+                        typeof(IConventionTriggerBuilder),
+                        typeof(ITrigger))
+                },
                 {
                     typeof(IReadOnlyProperty), (typeof(IMutableProperty),
                         typeof(IConventionProperty),
@@ -1209,7 +1215,7 @@ public virtual
                             parameterGenerator(
                                 type.IsGenericType ? type.GenericTypeArguments : Array.Empty<Type>(),
                                 mi.IsGenericMethod ? mi.GetGenericArguments() : Array.Empty<Type>())));
-        
+
         protected virtual void Initialize()
         {
             foreach (var typeTuple in MetadataTypes.Values)
diff --git a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/SqlServerDatabaseModelFactoryTest.cs b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/SqlServerDatabaseModelFactoryTest.cs
index 8f07df62f1..b0d07cd1c9 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/SqlServerDatabaseModelFactoryTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/SqlServerDatabaseModelFactoryTest.cs
@@ -912,7 +912,7 @@ ON SomeTable
             dbModel =>
             {
                 var table = dbModel.Tables.Single();
-                var triggers = (HashSet<string>)table[RelationalAnnotationNames.Triggers]!;
+                var triggers = table.Triggers;
 
                 Assert.Collection(triggers.OrderBy(t => t),
                     t => Assert.Equal("Trigger1", t),
diff --git a/test/EFCore.Tests/ApiConsistencyTest.cs b/test/EFCore.Tests/ApiConsistencyTest.cs
index 5b4be02d41..2d6fd6a7fd 100644
--- a/test/EFCore.Tests/ApiConsistencyTest.cs
+++ b/test/EFCore.Tests/ApiConsistencyTest.cs
@@ -45,6 +45,7 @@ protected override void Initialize()
             typeof(EntityTypeBuilder<>),
             typeof(IndexBuilder),
             typeof(IndexBuilder<>),
+            typeof(TriggerBuilder),
             typeof(InvertibleRelationshipBuilderBase),
             typeof(KeyBuilder),
             typeof(KeyBuilder<>),
