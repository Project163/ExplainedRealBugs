diff --git a/src/EFCore/Metadata/Internal/EntityType.cs b/src/EFCore/Metadata/Internal/EntityType.cs
index 98ac9ab9f0..a3c9d8f002 100644
--- a/src/EFCore/Metadata/Internal/EntityType.cs
+++ b/src/EFCore/Metadata/Internal/EntityType.cs
@@ -2,7 +2,6 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System.Diagnostics.CodeAnalysis;
-using System.Runtime.CompilerServices;
 using Microsoft.EntityFrameworkCore.ChangeTracking.Internal;
 using Microsoft.EntityFrameworkCore.Internal;
 
diff --git a/src/EFCore/Metadata/Internal/InternalForeignKeyBuilder.cs b/src/EFCore/Metadata/Internal/InternalForeignKeyBuilder.cs
index 72ca557cc4..f666e0dc67 100644
--- a/src/EFCore/Metadata/Internal/InternalForeignKeyBuilder.cs
+++ b/src/EFCore/Metadata/Internal/InternalForeignKeyBuilder.cs
@@ -3677,7 +3677,11 @@ private static InternalForeignKeyBuilder MergeFacetsFrom(Navigation newNavigatio
             && (((navigationToPrincipal != null)
                     && (navigationToPrincipal.Value.Name == Metadata.PrincipalToDependent?.Name))
                 || ((navigationToDependent != null)
-                    && (navigationToDependent.Value.Name == Metadata.DependentToPrincipal?.Name)));
+                    && (navigationToDependent.Value.Name == Metadata.DependentToPrincipal?.Name))
+                || ((navigationToPrincipal == null)
+                    && (navigationToDependent == null)
+                    && principalEntityType == Metadata.DeclaringEntityType
+                    && dependentEntityType == Metadata.PrincipalEntityType));
 
         var someAspectsFitNonInverted = false;
         if (!sameHierarchyInvertedNavigations
diff --git a/src/EFCore/Metadata/Internal/Property.cs b/src/EFCore/Metadata/Internal/Property.cs
index c2614c05ee..a576e265be 100644
--- a/src/EFCore/Metadata/Internal/Property.cs
+++ b/src/EFCore/Metadata/Internal/Property.cs
@@ -4,6 +4,7 @@
 using System.Diagnostics.CodeAnalysis;
 using System.Globalization;
 using Microsoft.EntityFrameworkCore.ChangeTracking.Internal;
+using Microsoft.EntityFrameworkCore.Infrastructure;
 using Microsoft.EntityFrameworkCore.Internal;
 using Microsoft.EntityFrameworkCore.Storage.Json;
 
@@ -767,53 +768,10 @@ public virtual PropertySaveBehavior GetAfterSaveBehavior()
     public virtual ValueConverter? GetValueConverter()
     {
         var annotation = FindAnnotation(CoreAnnotationNames.ValueConverter);
-        if (annotation != null)
-        {
-            return (ValueConverter?)annotation.Value;
-        }
-
-        var property = this;
-        var i = 0;
-        for (; i < ForeignKey.LongestFkChainAllowedLength; i++)
-        {
-            Property? nextProperty = null;
-            foreach (var foreignKey in property.GetContainingForeignKeys())
-            {
-                for (var propertyIndex = 0; propertyIndex < foreignKey.Properties.Count; propertyIndex++)
-                {
-                    if (property == foreignKey.Properties[propertyIndex])
-                    {
-                        var principalProperty = foreignKey.PrincipalKey.Properties[propertyIndex];
-                        if (principalProperty == this
-                            || principalProperty == property)
-                        {
-                            break;
-                        }
-
-                        annotation = principalProperty.FindAnnotation(CoreAnnotationNames.ValueConverter);
-                        if (annotation != null)
-                        {
-                            return (ValueConverter?)annotation.Value;
-                        }
-
-                        nextProperty = principalProperty;
-                    }
-                }
-            }
-
-            if (nextProperty == null)
-            {
-                break;
-            }
-
-            property = nextProperty;
-        }
-
-        return i == ForeignKey.LongestFkChainAllowedLength
-            ? throw new InvalidOperationException(
-                CoreStrings.RelationshipCycle(
-                    DeclaringType.DisplayName(), Name, "ValueConverter"))
-            : null;
+        return annotation != null
+            ? (ValueConverter?)annotation.Value
+            : GetConversion(throwOnProviderClrTypeConflict: FindAnnotation(CoreAnnotationNames.ProviderClrType) == null)
+                .ValueConverter;
     }
 
     /// <summary>
@@ -859,53 +817,120 @@ public virtual PropertySaveBehavior GetAfterSaveBehavior()
     public virtual Type? GetProviderClrType()
     {
         var annotation = FindAnnotation(CoreAnnotationNames.ProviderClrType);
-        if (annotation != null)
-        {
-            return (Type?)annotation.Value;
-        }
+        return annotation != null
+            ? (Type?)annotation.Value
+            : GetConversion(throwOnValueConverterConflict: FindAnnotation(CoreAnnotationNames.ValueConverter) == null)
+                .ProviderClrType;
+    }
+
+    private (ValueConverter? ValueConverter, Type? ProviderClrType) GetConversion(
+        bool throwOnValueConverterConflict = true, bool throwOnProviderClrTypeConflict = true)
+    {
+        var queue = new Queue<(Property CurrentProperty, Property CycleBreakingPropert, int CyclePosition, int MaxCycleLength)>();
+        queue.Enqueue((this, this, 0, 2));
 
-        var property = this;
-        var i = 0;
-        for (; i < ForeignKey.LongestFkChainAllowedLength; i++)
+        ValueConverter? valueConverter = null;
+        Type? providerClrType = null;
+        while (queue.Count > 0)
         {
-            Property? nextProperty = null;
+            var (property, cycleBreakingProperty, cyclePosition, maxCycleLength) = queue.Dequeue();
+            if (cyclePosition >= ForeignKey.LongestFkChainAllowedLength)
+            {
+                throw new InvalidOperationException(
+                    CoreStrings.RelationshipCycle(DeclaringType.DisplayName(), Name, "ValueConverter"));
+            }
+
             foreach (var foreignKey in property.GetContainingForeignKeys())
             {
                 for (var propertyIndex = 0; propertyIndex < foreignKey.Properties.Count; propertyIndex++)
                 {
-                    if (property == foreignKey.Properties[propertyIndex])
+                    if (property != foreignKey.Properties[propertyIndex])
+                    {
+                        continue;
+                    }
+
+                    var principalProperty = foreignKey.PrincipalKey.Properties[propertyIndex];
+                    if (principalProperty == cycleBreakingProperty)
+                    {
+                        break;
+                    }
+
+                    var annotationFound = false;
+                    var valueConverterAnnotation = principalProperty.FindAnnotation(CoreAnnotationNames.ValueConverter);
+                    if (valueConverterAnnotation != null)
                     {
-                        var principalProperty = foreignKey.PrincipalKey.Properties[propertyIndex];
-                        if (principalProperty == this
-                            || principalProperty == property)
+                        var annotationValue = (ValueConverter?)valueConverterAnnotation.Value;
+                        if (annotationValue != null)
                         {
-                            break;
+                            if (valueConverter != null)
+                            {
+                                throw new InvalidOperationException(
+                                    CoreStrings.ConflictingRelationshipConversions(
+                                        DeclaringType.DisplayName(), Name,
+                                        valueConverter.GetType().ShortDisplayName(), annotationValue.GetType().ShortDisplayName()));
+                            }
+
+                            if (providerClrType != null
+                                && throwOnProviderClrTypeConflict)
+                            {
+                                throw new InvalidOperationException(
+                                    CoreStrings.ConflictingRelationshipConversions(
+                                        DeclaringType.DisplayName(), Name,
+                                        providerClrType.ShortDisplayName(), annotationValue.GetType().ShortDisplayName()));
+                            }
+
+                            valueConverter = annotationValue;
                         }
+                        annotationFound = true;
+                    }
 
-                        annotation = principalProperty.FindAnnotation(CoreAnnotationNames.ProviderClrType);
-                        if (annotation != null)
+                    var providerClrTypeAnnotation = principalProperty.FindAnnotation(CoreAnnotationNames.ProviderClrType);
+                    if (providerClrTypeAnnotation != null)
+                    {
+                        var annotationValue = (Type?)providerClrTypeAnnotation.Value;
+                        if (annotationValue != null)
                         {
-                            return (Type?)annotation.Value;
+                            if (providerClrType != null)
+                            {
+                                throw new InvalidOperationException(
+                                    CoreStrings.ConflictingRelationshipConversions(
+                                        DeclaringType.DisplayName(), Name,
+                                        providerClrType.ShortDisplayName(), annotationValue.ShortDisplayName()));
+                            }
+
+                            if (valueConverter != null
+                                && throwOnValueConverterConflict)
+                            {
+                                throw new InvalidOperationException(
+                                    CoreStrings.ConflictingRelationshipConversions(
+                                        DeclaringType.DisplayName(), Name,
+                                        valueConverter.GetType().ShortDisplayName(), annotationValue.ShortDisplayName()));
+                            }
+
+                            providerClrType = annotationValue;
                         }
+                        annotationFound = true;
+                    }
 
-                        nextProperty = principalProperty;
+                    if (!annotationFound)
+                    {
+                        if (cyclePosition == maxCycleLength - 1)
+                        {
+                            // We need to use different primes to ensure a different cycleBreakingProperty is selected
+                            // each time when traversing properties that participate in multiple relationship cycles
+                            queue.Enqueue((principalProperty, property, 0, HashHelpers.GetPrime(maxCycleLength << 1)));
+                        }
+                        else
+                        {
+                            queue.Enqueue((principalProperty, cycleBreakingProperty, cyclePosition + 1, maxCycleLength));
+                        }
                     }
+                    break;
                 }
             }
-
-            if (nextProperty == null)
-            {
-                break;
-            }
-
-            property = nextProperty;
         }
 
-        return i == ForeignKey.LongestFkChainAllowedLength
-            ? throw new InvalidOperationException(
-                CoreStrings.RelationshipCycle(
-                    DeclaringType.DisplayName(), Name, "ProviderClrType"))
-            : null;
+        return (valueConverter, providerClrType);
     }
 
     /// <summary>
@@ -1376,7 +1401,7 @@ public virtual bool IsForeignKey()
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
     public virtual IEnumerable<ForeignKey> GetContainingForeignKeys()
-        => ForeignKeys?.OrderBy(fk => fk.Properties, PropertyListComparer.Instance) ?? Enumerable.Empty<ForeignKey>();
+        => ForeignKeys?.OrderBy(fk => fk, ForeignKeyComparer.Instance) ?? Enumerable.Empty<ForeignKey>();
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
diff --git a/src/EFCore/Metadata/RuntimeEntityType.cs b/src/EFCore/Metadata/RuntimeEntityType.cs
index d8e42af0aa..72fe331433 100644
--- a/src/EFCore/Metadata/RuntimeEntityType.cs
+++ b/src/EFCore/Metadata/RuntimeEntityType.cs
@@ -212,7 +212,7 @@ private IEnumerable<RuntimeKey> GetKeys()
         {
             if (property.ForeignKeys == null)
             {
-                property.ForeignKeys = new List<RuntimeForeignKey> { foreignKey };
+                property.ForeignKeys = new SortedSet<RuntimeForeignKey>(ForeignKeyComparer.Instance) { foreignKey };
             }
             else
             {
diff --git a/src/EFCore/Metadata/RuntimeProperty.cs b/src/EFCore/Metadata/RuntimeProperty.cs
index 449816d4d0..1ec7020961 100644
--- a/src/EFCore/Metadata/RuntimeProperty.cs
+++ b/src/EFCore/Metadata/RuntimeProperty.cs
@@ -207,7 +207,7 @@ private IEnumerable<RuntimeKey> GetContainingKeys()
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
     [EntityFrameworkInternal]
-    public virtual List<RuntimeForeignKey>? ForeignKeys { get; set; }
+    public virtual ISet<RuntimeForeignKey>? ForeignKeys { get; set; }
 
     private IEnumerable<RuntimeForeignKey> GetContainingForeignKeys()
         => ForeignKeys ?? Enumerable.Empty<RuntimeForeignKey>();
diff --git a/src/EFCore/Properties/CoreStrings.Designer.cs b/src/EFCore/Properties/CoreStrings.Designer.cs
index 458ee21dd2..285f24ec93 100644
--- a/src/EFCore/Properties/CoreStrings.Designer.cs
+++ b/src/EFCore/Properties/CoreStrings.Designer.cs
@@ -5,6 +5,7 @@
 using System.Resources;
 using System.Threading;
 using Microsoft.EntityFrameworkCore.Diagnostics;
+using Microsoft.EntityFrameworkCore.Infrastructure;
 using Microsoft.EntityFrameworkCore.Internal;
 using Microsoft.Extensions.Logging;
 
@@ -622,6 +623,14 @@ public static string ConflictingPropertyOrNavigation(object? member, object? typ
                 GetString("ConflictingPropertyOrNavigation", nameof(member), nameof(type), nameof(conflictingType)),
                 member, type, conflictingType);
 
+        /// <summary>
+        ///     The property '{entityType}.{property}' participates in several relationship chains that have conflicting conversions: '{valueConversion}' and '{conflictingValueConversion}'.
+        /// </summary>
+        public static string ConflictingRelationshipConversions(object? entityType, object? property, object? valueConversion, object? conflictingValueConversion)
+        => string.Format(
+            GetString("ConflictingRelationshipConversions", nameof(entityType), nameof(property), nameof(valueConversion), nameof(conflictingValueConversion)),
+                entityType, property, valueConversion, conflictingValueConversion);
+
         /// <summary>
         ///     Cannot create a relationship between '{newPrincipalNavigationSpecification}' and '{newDependentNavigationSpecification}' because a relationship already exists between '{existingPrincipalNavigationSpecification}' and '{existingDependentNavigationSpecification}'. Navigations can only participate in a single relationship. If you want to override an existing relationship call 'Ignore' on the navigation '{newDependentNavigationSpecification}' first in 'OnModelCreating'.
         /// </summary>
diff --git a/src/EFCore/Properties/CoreStrings.resx b/src/EFCore/Properties/CoreStrings.resx
index 4fef33b794..b178505bd2 100644
--- a/src/EFCore/Properties/CoreStrings.resx
+++ b/src/EFCore/Properties/CoreStrings.resx
@@ -342,6 +342,9 @@
   <data name="ConflictingPropertyOrNavigation" xml:space="preserve">
     <value>The property or navigation '{member}' cannot be added to the '{type}' type because a property or navigation with the same name already exists on the '{conflictingType}' type.</value>
   </data>
+  <data name="ConflictingRelationshipConversions" xml:space="preserve">
+    <value>The property '{entityType}.{property}' participates in several relationship chains that have conflicting conversions: '{valueConversion}' and '{conflictingValueConversion}'.</value>
+  </data>
   <data name="ConflictingRelationshipNavigation" xml:space="preserve">
     <value>Cannot create a relationship between '{newPrincipalNavigationSpecification}' and '{newDependentNavigationSpecification}' because a relationship already exists between '{existingPrincipalNavigationSpecification}' and '{existingDependentNavigationSpecification}'. Navigations can only participate in a single relationship. If you want to override an existing relationship call 'Ignore' on the navigation '{newDependentNavigationSpecification}' first in 'OnModelCreating'.</value>
   </data>
diff --git a/test/EFCore.Relational.Tests/Infrastructure/RelationalModelValidatorTest.cs b/test/EFCore.Relational.Tests/Infrastructure/RelationalModelValidatorTest.cs
index db27f06f64..5b65e3e644 100644
--- a/test/EFCore.Relational.Tests/Infrastructure/RelationalModelValidatorTest.cs
+++ b/test/EFCore.Relational.Tests/Infrastructure/RelationalModelValidatorTest.cs
@@ -730,7 +730,7 @@ public virtual void Detects_shared_table_root_cycle()
         modelBuilder.Entity<A>().HasOne<B>().WithOne().HasForeignKey<B>(a => a.Id).HasPrincipalKey<A>(b => b.Id).IsRequired();
         modelBuilder.Entity<B>().ToTable("Table");
 
-        VerifyError(CoreStrings.RelationshipCycle("B", "AId", "ValueConverter"), modelBuilder);
+        VerifyError(CoreStrings.IdentifyingRelationshipCycle("A -> B"), modelBuilder);
     }
 
     [ConditionalFact]
diff --git a/test/EFCore.Specification.Tests/TestUtilities/ModelAsserter.cs b/test/EFCore.Specification.Tests/TestUtilities/ModelAsserter.cs
index 8852de4018..9dbeacec4b 100644
--- a/test/EFCore.Specification.Tests/TestUtilities/ModelAsserter.cs
+++ b/test/EFCore.Specification.Tests/TestUtilities/ModelAsserter.cs
@@ -665,6 +665,13 @@ protected ModelAsserter()
                     Assert.Equal(expected.DeclaringEntityType.Name, actual.DeclaringEntityType.Name);
                 }
             },
+            () =>
+            {
+                if (compareBackreferences)
+                {
+                    Assert.Equal(expected.GetReferencingForeignKeys().ToList(), actual.GetReferencingForeignKeys(), ForeignKeyComparer.Instance);
+                }
+            },
             () => Assert.Equal(expectedAnnotations, actualAnnotations, TestAnnotationComparer.Instance));
 
         return true;
diff --git a/test/EFCore.Tests/Infrastructure/ModelValidatorTest.cs b/test/EFCore.Tests/Infrastructure/ModelValidatorTest.cs
index 671d77d520..88d0ee7d70 100644
--- a/test/EFCore.Tests/Infrastructure/ModelValidatorTest.cs
+++ b/test/EFCore.Tests/Infrastructure/ModelValidatorTest.cs
@@ -593,28 +593,90 @@ public virtual void Detects_identifying_relationship_cycle()
         modelBuilder.Entity<A>().HasOne<C>().WithOne().HasForeignKey<C>(a => a.Id).HasPrincipalKey<A>(b => b.Id).IsRequired();
         modelBuilder.Entity<C>().HasOne<B>().WithOne().HasForeignKey<B>(a => a.Id).HasPrincipalKey<C>(b => b.Id).IsRequired();
 
-        VerifyError(CoreStrings.RelationshipCycle("B", "AId", "ValueConverter"), modelBuilder);
+        VerifyError(CoreStrings.IdentifyingRelationshipCycle("A -> B -> C"), modelBuilder);
     }
 
     [ConditionalFact]
-    public virtual void Detects_relationship_cycle_for_property_configuration()
+    public virtual void Passes_on_relationship_cycle_for_property_configuration()
     {
         var modelBuilder = base.CreateConventionModelBuilder();
 
         modelBuilder.Entity<C>().HasBaseType((string)null);
+        modelBuilder.Entity<D>().HasBaseType((string)null);
         modelBuilder.Entity<A>().HasOne<B>().WithOne().HasForeignKey<A>(a => a.Id).HasPrincipalKey<B>(b => b.Id).IsRequired();
-        modelBuilder.Entity<A>().HasOne<C>().WithOne().HasForeignKey<C>(a => a.Id).HasPrincipalKey<A>(b => b.Id).IsRequired();
-        modelBuilder.Entity<C>().HasOne<B>().WithOne().HasForeignKey<B>(a => a.Id).HasPrincipalKey<C>(b => b.Id).IsRequired();
+        modelBuilder.Entity<A>().HasOne<C>().WithOne().HasForeignKey<C>(c => c.Id).HasPrincipalKey<A>(a => a.Id).IsRequired();
+        modelBuilder.Entity<C>().HasOne<B>().WithOne().HasForeignKey<B>(b => b.Id).HasPrincipalKey<C>(c => c.Id).IsRequired();
+        modelBuilder.Entity<D>().HasOne<B>().WithOne().HasForeignKey<D>(d => d.Id).HasPrincipalKey<B>(b => b.Id).IsRequired();
+
+        var dId = modelBuilder.Model.FindEntityType(typeof(D)).FindProperty(nameof(D.Id));
+
+        Assert.Null(dId.GetValueConverter());
+        Assert.Null(dId.GetProviderClrType());
+    }
+
+    [ConditionalFact]
+    public virtual void Passes_on_multiple_relationship_cycles_for_property_configuration()
+    {
+        var modelBuilder = base.CreateConventionModelBuilder();
+
+        modelBuilder.Entity<C>().HasBaseType((string)null);
         modelBuilder.Entity<D>().HasBaseType((string)null);
-        modelBuilder.Entity<D>().HasOne<B>().WithOne().HasForeignKey<D>(a => a.Id).HasPrincipalKey<B>(b => b.Id).IsRequired();
+        modelBuilder.Entity<A>().HasOne<B>().WithOne().HasForeignKey<A>(a => a.Id).HasPrincipalKey<B>(b => b.Id).IsRequired();
+        modelBuilder.Entity<A>().HasOne<C>().WithOne().HasForeignKey<C>(c => c.Id).HasPrincipalKey<A>(a => a.Id).IsRequired();
+        modelBuilder.Entity<C>().HasOne<B>().WithOne().HasForeignKey<B>(b => b.Id).HasPrincipalKey<C>(c => c.Id).IsRequired();
+        modelBuilder.Entity<C>().HasOne<D>().WithOne().HasForeignKey<D>(d => d.Id).HasPrincipalKey<C>(c => c.Id).IsRequired();
+        modelBuilder.Entity<D>().HasOne<E>().WithOne().HasForeignKey<E>(e => e.Id).HasPrincipalKey<D>(d => d.Id).IsRequired();
+        modelBuilder.Entity<C>().HasOne<E>().WithOne().HasForeignKey<C>(c => c.Id).HasPrincipalKey<E>(e => e.Id).IsRequired();
+
+        var aId = modelBuilder.Model.FindEntityType(typeof(A)).FindProperty(nameof(A.Id));
+
+        Assert.Null(aId.GetValueConverter());
+        Assert.Null(aId.GetProviderClrType());
+    }
+
+    [ConditionalFact]
+    public virtual void Detects_conflicting_converter_and_provider_type_with_relationship_cycle()
+    {
+        var modelBuilder = base.CreateConventionModelBuilder();
+
+        modelBuilder.Entity<C>().HasBaseType((string)null);
+        modelBuilder.Entity<D>().HasBaseType((string)null);
+        modelBuilder.Entity<A>().Property(b => b.Id).HasConversion<string>();
+        modelBuilder.Entity<B>().Property(b => b.Id).HasConversion<CastingConverter<int, int>>();
+
+        modelBuilder.Entity<B>().HasOne<C>().WithOne().HasForeignKey<B>(b => b.Id).HasPrincipalKey<C>(c => c.Id).IsRequired();
+        modelBuilder.Entity<B>().HasOne<C>().WithOne().HasForeignKey<C>(c => c.Id).HasPrincipalKey<B>(b => b.Id).IsRequired();
+        modelBuilder.Entity<A>().HasOne<D>().WithOne().HasForeignKey<D>(d => d.Id).HasPrincipalKey<A>(a => a.Id).IsRequired();
+        modelBuilder.Entity<D>().HasOne<C>().WithOne().HasForeignKey<D>(d => d.Id).HasPrincipalKey<C>(c => c.Id).IsRequired();
 
         var dId = modelBuilder.Model.FindEntityType(typeof(D)).FindProperty(nameof(D.Id));
 
-        Assert.Equal(
-            CoreStrings.RelationshipCycle(nameof(D), nameof(D.Id), "ValueConverter"),
+        Assert.Equal(CoreStrings.ConflictingRelationshipConversions("D", "Id", "string", "CastingConverter<int, int>"),
             Assert.Throws<InvalidOperationException>(dId.GetValueConverter).Message);
-        Assert.Equal(
-            CoreStrings.RelationshipCycle(nameof(D), nameof(D.Id), "ProviderClrType"),
+        Assert.Equal(CoreStrings.ConflictingRelationshipConversions("D", "Id", "string", "CastingConverter<int, int>"),
+            Assert.Throws<InvalidOperationException>(dId.GetProviderClrType).Message);
+    }
+
+    [ConditionalFact]
+    public virtual void Detects_conflicting_provider_types_with_relationship_cycle()
+    {
+        var modelBuilder = base.CreateConventionModelBuilder();
+
+        modelBuilder.Entity<C>().HasBaseType((string)null);
+        modelBuilder.Entity<D>().HasBaseType((string)null);
+        modelBuilder.Entity<C>().Property(c => c.Id).HasConversion<long>();
+        modelBuilder.Entity<A>().Property(a => a.Id).HasConversion<string>();
+
+        modelBuilder.Entity<B>().HasOne<C>().WithOne().HasForeignKey<B>(b => b.Id).HasPrincipalKey<C>(c => c.Id).IsRequired();
+        modelBuilder.Entity<B>().HasOne<C>().WithOne().HasForeignKey<C>(c => c.Id).HasPrincipalKey<B>(b => b.Id).IsRequired();
+        modelBuilder.Entity<A>().HasOne<D>().WithOne().HasForeignKey<D>(d => d.Id).HasPrincipalKey<A>(a => a.Id).IsRequired();
+        modelBuilder.Entity<D>().HasOne<C>().WithOne().HasForeignKey<D>(d => d.Id).HasPrincipalKey<C>(c => c.Id).IsRequired();
+
+        var dId = modelBuilder.Model.FindEntityType(typeof(D)).FindProperty(nameof(D.Id));
+
+        Assert.Equal(CoreStrings.ConflictingRelationshipConversions("D", "Id", "string", "long"),
+            Assert.Throws<InvalidOperationException>(dId.GetValueConverter).Message);
+        Assert.Equal(CoreStrings.ConflictingRelationshipConversions("D", "Id", "string", "long"),
             Assert.Throws<InvalidOperationException>(dId.GetProviderClrType).Message);
     }
 
