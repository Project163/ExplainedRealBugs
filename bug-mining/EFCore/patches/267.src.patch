diff --git a/src/EFCore.Cosmos/Metadata/Conventions/CosmosDiscriminatorConvention.cs b/src/EFCore.Cosmos/Metadata/Conventions/CosmosDiscriminatorConvention.cs
index 19da8c86b2..83ce68b595 100644
--- a/src/EFCore.Cosmos/Metadata/Conventions/CosmosDiscriminatorConvention.cs
+++ b/src/EFCore.Cosmos/Metadata/Conventions/CosmosDiscriminatorConvention.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using Microsoft.EntityFrameworkCore.Cosmos.Metadata.Internal;
+using Microsoft.EntityFrameworkCore.Metadata.Internal;
 
 // ReSharper disable once CheckNamespace
 namespace Microsoft.EntityFrameworkCore.Metadata.Conventions;
@@ -29,21 +30,13 @@ public CosmosDiscriminatorConvention(ProviderConventionSetBuilderDependencies de
     {
     }
 
-    /// <summary>
-    ///     Called after an entity type is added to the model.
-    /// </summary>
-    /// <param name="entityTypeBuilder">The builder for the entity type.</param>
-    /// <param name="context">Additional information associated with convention execution.</param>
+    /// <inheritdoc/>
     public virtual void ProcessEntityTypeAdded(
         IConventionEntityTypeBuilder entityTypeBuilder,
         IConventionContext<IConventionEntityTypeBuilder> context)
         => ProcessEntityType(entityTypeBuilder);
 
-    /// <summary>
-    ///     Called after the ownership value for a foreign key is changed.
-    /// </summary>
-    /// <param name="relationshipBuilder">The builder for the foreign key.</param>
-    /// <param name="context">Additional information associated with convention execution.</param>
+    /// <inheritdoc/>
     public virtual void ProcessForeignKeyOwnershipChanged(
         IConventionForeignKeyBuilder relationshipBuilder,
         IConventionContext<bool?> context)
@@ -53,12 +46,7 @@ public CosmosDiscriminatorConvention(ProviderConventionSetBuilderDependencies de
         ProcessEntityType(entityType.Builder);
     }
 
-    /// <summary>
-    ///     Called after a foreign key is removed.
-    /// </summary>
-    /// <param name="entityTypeBuilder">The builder for the entity type.</param>
-    /// <param name="foreignKey">The removed foreign key.</param>
-    /// <param name="context">Additional information associated with convention execution.</param>
+    /// <inheritdoc/>
     public virtual void ProcessForeignKeyRemoved(
         IConventionEntityTypeBuilder entityTypeBuilder,
         IConventionForeignKey foreignKey,
@@ -71,14 +59,7 @@ public CosmosDiscriminatorConvention(ProviderConventionSetBuilderDependencies de
         }
     }
 
-    /// <summary>
-    ///     Called after an annotation is changed on an entity type.
-    /// </summary>
-    /// <param name="entityTypeBuilder">The builder for the entity type.</param>
-    /// <param name="name">The annotation name.</param>
-    /// <param name="annotation">The new annotation.</param>
-    /// <param name="oldAnnotation">The old annotation.</param>
-    /// <param name="context">Additional information associated with convention execution.</param>
+    /// <inheritdoc/>
     public virtual void ProcessEntityTypeAnnotationChanged(
         IConventionEntityTypeBuilder entityTypeBuilder,
         string name,
@@ -114,13 +95,20 @@ private static void ProcessEntityType(IConventionEntityTypeBuilder entityTypeBui
         }
     }
 
-    /// <summary>
-    ///     Called after the base type of an entity type changes.
-    /// </summary>
-    /// <param name="entityTypeBuilder">The builder for the entity type.</param>
-    /// <param name="newBaseType">The new base entity type.</param>
-    /// <param name="oldBaseType">The old base entity type.</param>
-    /// <param name="context">Additional information associated with convention execution.</param>
+    /// <inheritdoc/>
+    public override void ProcessDiscriminatorPropertySet(
+        IConventionEntityTypeBuilder entityTypeBuilder,
+        string? name,
+        IConventionContext<string> context)
+    {
+        var entityType = entityTypeBuilder.Metadata;
+        if (entityType.IsDocumentRoot())
+        {
+            base.ProcessDiscriminatorPropertySet(entityTypeBuilder, name, context);
+        }
+    }
+
+    /// <inheritdoc/>
     public override void ProcessEntityTypeBaseTypeChanged(
         IConventionEntityTypeBuilder entityTypeBuilder,
         IConventionEntityType? newBaseType,
@@ -132,41 +120,43 @@ private static void ProcessEntityType(IConventionEntityTypeBuilder entityTypeBui
             return;
         }
 
-        IConventionDiscriminatorBuilder? discriminator = null;
         var entityType = entityTypeBuilder.Metadata;
         if (newBaseType == null)
         {
             if (entityType.IsDocumentRoot())
             {
-                discriminator = entityTypeBuilder.HasDiscriminator(typeof(string));
+                entityTypeBuilder.HasDiscriminator(typeof(string));
             }
         }
         else
         {
             var rootType = newBaseType.GetRootType();
-            discriminator = rootType.IsInModel
-                ? rootType.Builder.HasDiscriminator(typeof(string))
-                : null;
+            if (!rootType.IsInModel
+                || !rootType.IsDocumentRoot())
+            {
+                return;
+            }
 
-            if (newBaseType.BaseType == null)
+            var discriminator = rootType.Builder.HasDiscriminator(typeof(string));
+            if (discriminator != null)
             {
-                discriminator?.HasValue(newBaseType, newBaseType.ShortName());
+                SetDefaultDiscriminatorValues(entityTypeBuilder.Metadata.GetDerivedTypesInclusive(), discriminator);
             }
         }
+    }
 
-        if (discriminator != null)
+    /// <inheritdoc/>
+    protected override void SetDefaultDiscriminatorValues(
+        IEnumerable<IConventionEntityType> entityTypes,
+        IConventionDiscriminatorBuilder discriminatorBuilder)
+    {
+        foreach (var entityType in entityTypes)
         {
-            discriminator.HasValue(entityTypeBuilder.Metadata, entityTypeBuilder.Metadata.ShortName());
-            SetDefaultDiscriminatorValues(entityType.GetDerivedTypes(), discriminator);
+            discriminatorBuilder.HasValue(entityType, entityType.ShortName());
         }
     }
 
-    /// <summary>
-    ///     Called after an entity type is removed from the model.
-    /// </summary>
-    /// <param name="modelBuilder">The builder for the model.</param>
-    /// <param name="entityType">The removed entity type.</param>
-    /// <param name="context">Additional information associated with convention execution.</param>
+    /// <inheritdoc/>
     public override void ProcessEntityTypeRemoved(
         IConventionModelBuilder modelBuilder,
         IConventionEntityType entityType,
diff --git a/src/EFCore.Design/Migrations/Design/CSharpSnapshotGenerator.cs b/src/EFCore.Design/Migrations/Design/CSharpSnapshotGenerator.cs
index 618a2f7e92..f05da43282 100644
--- a/src/EFCore.Design/Migrations/Design/CSharpSnapshotGenerator.cs
+++ b/src/EFCore.Design/Migrations/Design/CSharpSnapshotGenerator.cs
@@ -892,9 +892,10 @@ protected virtual void GenerateKeyAnnotations(string keyBuilderName, IKey key, I
                 .Append('.')
                 .Append("HasDiscriminator");
 
-            if (discriminatorPropertyAnnotation?.Value != null)
+            var discriminatorProperty = entityType.FindDiscriminatorProperty();
+            if (discriminatorPropertyAnnotation?.Value != null
+                && discriminatorProperty != null)
             {
-                var discriminatorProperty = entityType.FindProperty((string)discriminatorPropertyAnnotation.Value)!;
                 var propertyClrType = FindValueConverter(discriminatorProperty)?.ProviderClrType
                         .MakeNullable(discriminatorProperty.IsNullable)
                     ?? discriminatorProperty.ClrType;
@@ -902,7 +903,7 @@ protected virtual void GenerateKeyAnnotations(string keyBuilderName, IKey key, I
                     .Append('<')
                     .Append(Code.Reference(propertyClrType))
                     .Append(">(")
-                    .Append(Code.Literal((string)discriminatorPropertyAnnotation.Value))
+                    .Append(Code.Literal(discriminatorProperty.Name))
                     .Append(')');
             }
             else
@@ -926,7 +927,6 @@ protected virtual void GenerateKeyAnnotations(string keyBuilderName, IKey key, I
             if (discriminatorValueAnnotation?.Value != null)
             {
                 var value = discriminatorValueAnnotation.Value;
-                var discriminatorProperty = entityType.FindDiscriminatorProperty();
                 if (discriminatorProperty != null)
                 {
                     var valueConverter = FindValueConverter(discriminatorProperty);
diff --git a/src/EFCore/Metadata/Conventions/ConventionSet.cs b/src/EFCore/Metadata/Conventions/ConventionSet.cs
index 3b314b0430..0655edffd9 100644
--- a/src/EFCore/Metadata/Conventions/ConventionSet.cs
+++ b/src/EFCore/Metadata/Conventions/ConventionSet.cs
@@ -51,6 +51,11 @@ public class ConventionSet
     /// </summary>
     public virtual List<IEntityTypeMemberIgnoredConvention> EntityTypeMemberIgnoredConventions { get; } = new();
 
+    /// <summary>
+    ///     Conventions to run when a discriminator property is set.
+    /// </summary>
+    public virtual List<IDiscriminatorPropertySetConvention> DiscriminatorPropertySetConventions { get; } = new();
+
     /// <summary>
     ///     Conventions to run when the base entity type is changed.
     /// </summary>
@@ -340,6 +345,12 @@ public virtual void Replace<TImplementation>(TImplementation newConvention)
             EntityTypeMemberIgnoredConventions.Add(entityTypeMemberIgnoredConvention);
         }
 
+        if (newConvention is IDiscriminatorPropertySetConvention discriminatorPropertySetConvention
+            && !Replace(DiscriminatorPropertySetConventions, discriminatorPropertySetConvention, oldConvetionType))
+        {
+            DiscriminatorPropertySetConventions.Add(discriminatorPropertySetConvention);
+        }
+
         if (newConvention is IEntityTypeBaseTypeChangedConvention entityTypeBaseTypeChangedConvention
             && !Replace(EntityTypeBaseTypeChangedConventions, entityTypeBaseTypeChangedConvention, oldConvetionType))
         {
@@ -680,6 +691,11 @@ public virtual void Add(IConvention convention)
             EntityTypeMemberIgnoredConventions.Add(entityTypeMemberIgnoredConvention);
         }
 
+        if (convention is IDiscriminatorPropertySetConvention discriminatorPropertySetConvention)
+        {
+            DiscriminatorPropertySetConventions.Add(discriminatorPropertySetConvention);
+        }
+
         if (convention is IEntityTypeBaseTypeChangedConvention entityTypeBaseTypeChangedConvention)
         {
             EntityTypeBaseTypeChangedConventions.Add(entityTypeBaseTypeChangedConvention);
@@ -993,6 +1009,11 @@ public virtual void Remove(Type conventionType)
             Remove(EntityTypeMemberIgnoredConventions, conventionType);
         }
 
+        if (typeof(IDiscriminatorPropertySetConvention).IsAssignableFrom(conventionType))
+        {
+            Remove(DiscriminatorPropertySetConventions, conventionType);
+        }
+
         if (typeof(IEntityTypeBaseTypeChangedConvention).IsAssignableFrom(conventionType))
         {
             Remove(EntityTypeBaseTypeChangedConventions, conventionType);
diff --git a/src/EFCore/Metadata/Conventions/DiscriminatorConvention.cs b/src/EFCore/Metadata/Conventions/DiscriminatorConvention.cs
index 7d4cc93f46..0ec54cfe42 100644
--- a/src/EFCore/Metadata/Conventions/DiscriminatorConvention.cs
+++ b/src/EFCore/Metadata/Conventions/DiscriminatorConvention.cs
@@ -9,7 +9,10 @@ namespace Microsoft.EntityFrameworkCore.Metadata.Conventions;
 /// <remarks>
 ///     See <see href="https://aka.ms/efcore-docs-conventions">Model building conventions</see> for more information and examples.
 /// </remarks>
-public class DiscriminatorConvention : IEntityTypeBaseTypeChangedConvention, IEntityTypeRemovedConvention
+public class DiscriminatorConvention :
+    IEntityTypeBaseTypeChangedConvention,
+    IEntityTypeRemovedConvention,
+    IDiscriminatorPropertySetConvention
 {
     /// <summary>
     ///     Creates a new instance of <see cref="DiscriminatorConvention" />.
@@ -25,13 +28,7 @@ public DiscriminatorConvention(ProviderConventionSetBuilderDependencies dependen
     /// </summary>
     protected virtual ProviderConventionSetBuilderDependencies Dependencies { get; }
 
-    /// <summary>
-    ///     Called after the base type of an entity type changes.
-    /// </summary>
-    /// <param name="entityTypeBuilder">The builder for the entity type.</param>
-    /// <param name="newBaseType">The new base entity type.</param>
-    /// <param name="oldBaseType">The old base entity type.</param>
-    /// <param name="context">Additional information associated with convention execution.</param>
+    /// <inheritdoc/>
     public virtual void ProcessEntityTypeBaseTypeChanged(
         IConventionEntityTypeBuilder entityTypeBuilder,
         IConventionEntityType? newBaseType,
@@ -45,18 +42,15 @@ public DiscriminatorConvention(ProviderConventionSetBuilderDependencies dependen
         }
 
         var entityType = entityTypeBuilder.Metadata;
-        var derivedEntityTypes = entityType.GetDerivedTypes().ToList();
-
-        IConventionDiscriminatorBuilder? discriminator;
         if (newBaseType == null)
         {
-            if (derivedEntityTypes.Count == 0)
+            if (!entityType.GetDerivedTypes().Any())
             {
                 entityTypeBuilder.HasNoDiscriminator();
                 return;
             }
 
-            discriminator = entityTypeBuilder.HasDiscriminator(typeof(string));
+            entityTypeBuilder.HasDiscriminator(typeof(string));
         }
         else
         {
@@ -65,28 +59,41 @@ public DiscriminatorConvention(ProviderConventionSetBuilderDependencies dependen
                 return;
             }
 
-            var rootTypeBuilder = entityType.GetRootType().Builder;
-            discriminator = rootTypeBuilder.HasDiscriminator(typeof(string));
-
-            if (newBaseType.BaseType == null)
+            var rootType = entityType.GetRootType();
+            if (rootType.FindDiscriminatorProperty() == null)
             {
-                discriminator?.HasValue(newBaseType, newBaseType.GetDefaultDiscriminatorValue());
+                rootType.Builder.HasDiscriminator(typeof(string));
             }
+            else
+            {
+                var discriminator = entityTypeBuilder.HasDiscriminator(typeof(string));
+                if (discriminator != null)
+                {
+                    SetDefaultDiscriminatorValues(entityTypeBuilder.Metadata.GetDerivedTypesInclusive(), discriminator);
+                }
+            }
+        }
+    }
+
+    /// <inheritdoc/>
+    public virtual void ProcessDiscriminatorPropertySet(
+        IConventionEntityTypeBuilder entityTypeBuilder,
+        string? name,
+        IConventionContext<string> context)
+    {
+        if (name == null)
+        {
+            return;
         }
 
+        var discriminator = entityTypeBuilder.HasDiscriminator(typeof(string));
         if (discriminator != null)
         {
-            discriminator.HasValue(entityTypeBuilder.Metadata, entityTypeBuilder.Metadata.GetDefaultDiscriminatorValue());
-            SetDefaultDiscriminatorValues(derivedEntityTypes, discriminator);
+            SetDefaultDiscriminatorValues(entityTypeBuilder.Metadata.GetDerivedTypesInclusive(), discriminator);
         }
     }
 
-    /// <summary>
-    ///     Called after an entity type is removed from the model.
-    /// </summary>
-    /// <param name="modelBuilder">The builder for the model.</param>
-    /// <param name="entityType">The removed entity type.</param>
-    /// <param name="context">Additional information associated with convention execution.</param>
+    /// <inheritdoc/>
     public virtual void ProcessEntityTypeRemoved(
         IConventionModelBuilder modelBuilder,
         IConventionEntityType entityType,
diff --git a/src/EFCore/Metadata/Conventions/IDiscriminatorPropertySetConvention.cs b/src/EFCore/Metadata/Conventions/IDiscriminatorPropertySetConvention.cs
new file mode 100644
index 0000000000..85e3bf295d
--- /dev/null
+++ b/src/EFCore/Metadata/Conventions/IDiscriminatorPropertySetConvention.cs
@@ -0,0 +1,24 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.EntityFrameworkCore.Metadata.Conventions;
+
+/// <summary>
+///     Represents an operation that should be performed when a discriminator property is set for an entity type.
+/// </summary>
+/// <remarks>
+///     See <see href="https://aka.ms/efcore-docs-conventions">Model building conventions</see> for more information and examples.
+/// </remarks>
+public interface IDiscriminatorPropertySetConvention : IConvention
+{
+    /// <summary>
+    ///     Called after a discriminator property is set.
+    /// </summary>
+    /// <param name="entityTypeBuilder">The builder for the entity type.</param>
+    /// <param name="name">The name of the discriminator property.</param>
+    /// <param name="context">Additional information associated with convention execution.</param>
+    void ProcessDiscriminatorPropertySet(
+        IConventionEntityTypeBuilder entityTypeBuilder,
+        string? name,
+        IConventionContext<string?> context);
+}
diff --git a/src/EFCore/Metadata/Conventions/Internal/ConventionDispatcher.ConventionScope.cs b/src/EFCore/Metadata/Conventions/Internal/ConventionDispatcher.ConventionScope.cs
index 2cf04f3c32..36bed6b449 100644
--- a/src/EFCore/Metadata/Conventions/Internal/ConventionDispatcher.ConventionScope.cs
+++ b/src/EFCore/Metadata/Conventions/Internal/ConventionDispatcher.ConventionScope.cs
@@ -69,6 +69,10 @@ public int GetLeafCount()
             IConventionEntityTypeBuilder entityTypeBuilder,
             string name);
 
+        public abstract string? OnDiscriminatorPropertySet(
+            IConventionEntityTypeBuilder entityTypeBuilder,
+            string? name);
+
         public abstract IConventionKey? OnEntityTypePrimaryKeyChanged(
             IConventionEntityTypeBuilder entityTypeBuilder,
             IConventionKey? newPrimaryKey,
diff --git a/src/EFCore/Metadata/Conventions/Internal/ConventionDispatcher.DelayedConventionScope.cs b/src/EFCore/Metadata/Conventions/Internal/ConventionDispatcher.DelayedConventionScope.cs
index 24f640a95a..dd3ea512d8 100644
--- a/src/EFCore/Metadata/Conventions/Internal/ConventionDispatcher.DelayedConventionScope.cs
+++ b/src/EFCore/Metadata/Conventions/Internal/ConventionDispatcher.DelayedConventionScope.cs
@@ -79,6 +79,12 @@ public override string OnEntityTypeMemberIgnored(IConventionEntityTypeBuilder en
             return name;
         }
 
+        public override string? OnDiscriminatorPropertySet(IConventionEntityTypeBuilder entityTypeBuilder, string? name)
+        {
+            Add(new OnDiscriminatorPropertySetNode(entityTypeBuilder, name));
+            return name;
+        }
+
         public override IConventionEntityType? OnEntityTypeBaseTypeChanged(
             IConventionEntityTypeBuilder entityTypeBuilder,
             IConventionEntityType? newBaseType,
@@ -532,6 +538,21 @@ public override void Run(ConventionDispatcher dispatcher)
             => dispatcher._immediateConventionScope.OnEntityTypeMemberIgnored(EntityTypeBuilder, Name);
     }
 
+    private sealed class OnDiscriminatorPropertySetNode : ConventionNode
+    {
+        public OnDiscriminatorPropertySetNode(IConventionEntityTypeBuilder entityTypeBuilder, string? name)
+        {
+            EntityTypeBuilder = entityTypeBuilder;
+            Name = name;
+        }
+
+        public IConventionEntityTypeBuilder EntityTypeBuilder { get; }
+        public string? Name { get; }
+
+        public override void Run(ConventionDispatcher dispatcher)
+            => dispatcher._immediateConventionScope.OnDiscriminatorPropertySet(EntityTypeBuilder, Name);
+    }
+
     private sealed class OnEntityTypeBaseTypeChangedNode : ConventionNode
     {
         public OnEntityTypeBaseTypeChangedNode(
diff --git a/src/EFCore/Metadata/Conventions/Internal/ConventionDispatcher.ImmediateConventionScope.cs b/src/EFCore/Metadata/Conventions/Internal/ConventionDispatcher.ImmediateConventionScope.cs
index 700a841f15..d39329d5e1 100644
--- a/src/EFCore/Metadata/Conventions/Internal/ConventionDispatcher.ImmediateConventionScope.cs
+++ b/src/EFCore/Metadata/Conventions/Internal/ConventionDispatcher.ImmediateConventionScope.cs
@@ -1,6 +1,8 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using Microsoft.EntityFrameworkCore.Metadata.Internal;
+
 namespace Microsoft.EntityFrameworkCore.Metadata.Conventions.Internal;
 
 public partial class ConventionDispatcher
@@ -25,14 +27,13 @@ private sealed class ImmediateConventionScope : ConventionScope
         private readonly ConventionContext<IConventionKey> _keyConventionContext;
         private readonly ConventionContext<IConventionPropertyBuilder> _propertyBuilderConventionContext;
         private readonly ConventionContext<IConventionProperty> _propertyConventionContext;
-        private readonly ConventionContext<IConventionPropertyBuilder> _complexTypePropertyBuilderConventionContext;
-        private readonly ConventionContext<IConventionProperty> _complexTypePropertyConventionContext;
         private readonly ConventionContext<IConventionModelBuilder> _modelBuilderConventionContext;
         private readonly ConventionContext<IConventionTriggerBuilder> _triggerBuilderConventionContext;
         private readonly ConventionContext<IConventionTrigger> _triggerConventionContext;
         private readonly ConventionContext<IConventionAnnotation> _annotationConventionContext;
         private readonly ConventionContext<IReadOnlyList<IConventionProperty>> _propertyListConventionContext;
         private readonly ConventionContext<string> _stringConventionContext;
+        private readonly ConventionContext<string?> _nullableStringConventionContext;
         private readonly ConventionContext<FieldInfo> _fieldInfoConventionContext;
         private readonly ConventionContext<IElementType> _elementTypeConventionContext;
         private readonly ConventionContext<bool?> _boolConventionContext;
@@ -58,14 +59,13 @@ public ImmediateConventionScope(ConventionSet conventionSet, ConventionDispatche
             _keyConventionContext = new ConventionContext<IConventionKey>(dispatcher);
             _propertyBuilderConventionContext = new ConventionContext<IConventionPropertyBuilder>(dispatcher);
             _propertyConventionContext = new ConventionContext<IConventionProperty>(dispatcher);
-            _complexTypePropertyBuilderConventionContext = new ConventionContext<IConventionPropertyBuilder>(dispatcher);
-            _complexTypePropertyConventionContext = new ConventionContext<IConventionProperty>(dispatcher);
             _modelBuilderConventionContext = new ConventionContext<IConventionModelBuilder>(dispatcher);
             _triggerBuilderConventionContext = new ConventionContext<IConventionTriggerBuilder>(dispatcher);
             _triggerConventionContext = new ConventionContext<IConventionTrigger>(dispatcher);
             _annotationConventionContext = new ConventionContext<IConventionAnnotation>(dispatcher);
             _propertyListConventionContext = new ConventionContext<IReadOnlyList<IConventionProperty>>(dispatcher);
             _stringConventionContext = new ConventionContext<string>(dispatcher);
+            _nullableStringConventionContext = new ConventionContext<string?>(dispatcher);
             _fieldInfoConventionContext = new ConventionContext<FieldInfo>(dispatcher);
             _elementTypeConventionContext = new ConventionContext<IElementType>(dispatcher);
             _boolConventionContext = new ConventionContext<bool?>(dispatcher);
@@ -262,6 +262,39 @@ public IConventionModelBuilder OnModelInitialized(IConventionModelBuilder modelB
             return !entityTypeBuilder.Metadata.IsIgnored(name) ? null : name;
         }
 
+        public override string? OnDiscriminatorPropertySet(IConventionEntityTypeBuilder entityTypeBuilder, string? name)
+        {
+            if (!entityTypeBuilder.Metadata.IsInModel)
+            {
+                return null;
+            }
+
+#if DEBUG
+            var initialValue = entityTypeBuilder.Metadata.GetDiscriminatorPropertyName();
+#endif
+            using (_dispatcher.DelayConventions())
+            {
+                _stringConventionContext.ResetState(name);
+
+                foreach (var entityTypeConvention in _conventionSet.DiscriminatorPropertySetConventions)
+                {
+                    entityTypeConvention.ProcessDiscriminatorPropertySet(
+                        entityTypeBuilder, name, _nullableStringConventionContext);
+                    if (_stringConventionContext.ShouldStopProcessing())
+                    {
+                        return _stringConventionContext.Result;
+                    }
+#if DEBUG
+                    Check.DebugAssert(
+                        initialValue == entityTypeBuilder.Metadata.GetDiscriminatorPropertyName(),
+                        $"Convention {entityTypeConvention.GetType().Name} changed value without terminating");
+#endif
+                }
+            }
+
+            return entityTypeBuilder.Metadata.GetDiscriminatorPropertyName();
+        }
+
         public override IConventionEntityType? OnEntityTypeBaseTypeChanged(
             IConventionEntityTypeBuilder entityTypeBuilder,
             IConventionEntityType? newBaseType,
diff --git a/src/EFCore/Metadata/Conventions/Internal/ConventionDispatcher.cs b/src/EFCore/Metadata/Conventions/Internal/ConventionDispatcher.cs
index 1f4f806de3..8120df591d 100644
--- a/src/EFCore/Metadata/Conventions/Internal/ConventionDispatcher.cs
+++ b/src/EFCore/Metadata/Conventions/Internal/ConventionDispatcher.cs
@@ -123,6 +123,17 @@ public virtual IConventionModelBuilder OnModelFinalizing(IConventionModelBuilder
         string name)
         => _scope.OnEntityTypeMemberIgnored(entityTypeBuilder, name);
 
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual string? OnDiscriminatorPropertySet(
+        IConventionEntityTypeBuilder entityTypeBuilder,
+        string? name)
+        => _scope.OnDiscriminatorPropertySet(entityTypeBuilder, name);
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
diff --git a/src/EFCore/Metadata/Internal/EntityType.cs b/src/EFCore/Metadata/Internal/EntityType.cs
index 3fa7338b29..c85909243c 100644
--- a/src/EFCore/Metadata/Internal/EntityType.cs
+++ b/src/EFCore/Metadata/Internal/EntityType.cs
@@ -2937,10 +2937,16 @@ public virtual PropertyAccessMode GetNavigationAccessMode()
     /// </summary>
     public virtual Property? SetDiscriminatorProperty(Property? property, ConfigurationSource configurationSource)
     {
+        if ((string?)this[CoreAnnotationNames.DiscriminatorProperty] == property?.Name)
+        {
+            return property;
+        }
+
         CheckDiscriminatorProperty(property);
 
-        return ((string?)SetAnnotation(CoreAnnotationNames.DiscriminatorProperty, property?.Name, configurationSource)?.Value)
-            == property?.Name
+        SetAnnotation(CoreAnnotationNames.DiscriminatorProperty, property?.Name, configurationSource);
+
+        return Model.ConventionDispatcher.OnDiscriminatorPropertySet(Builder, property?.Name) == property?.Name
                 ? property
                 : (Property?)((IReadOnlyEntityType)this).FindDiscriminatorProperty();
     }
diff --git a/src/EFCore/Metadata/Internal/InternalEntityTypeBuilder.cs b/src/EFCore/Metadata/Internal/InternalEntityTypeBuilder.cs
index 4f40e66071..8eaf54203a 100644
--- a/src/EFCore/Metadata/Internal/InternalEntityTypeBuilder.cs
+++ b/src/EFCore/Metadata/Internal/InternalEntityTypeBuilder.cs
@@ -4392,13 +4392,17 @@ public virtual bool CanSetConstructorBinding(InstantiationBinding? constructorBi
     /// </summary>
     public virtual InternalEntityTypeBuilder? HasNoDiscriminator(ConfigurationSource configurationSource)
     {
-        if (Metadata[CoreAnnotationNames.DiscriminatorProperty] != null
-            && !configurationSource.Overrides(Metadata.GetDiscriminatorPropertyConfigurationSource()))
+        if (Metadata[CoreAnnotationNames.DiscriminatorProperty] == null)
+        {
+            return this;
+        }
+
+        if (!configurationSource.Overrides(Metadata.GetDiscriminatorPropertyConfigurationSource()))
         {
             return null;
         }
 
-        if (Metadata.BaseType == null)
+        if (((IReadOnlyEntityType)Metadata).FindDiscriminatorProperty()?.DeclaringType == Metadata)
         {
             RemoveUnusedDiscriminatorProperty(null, configurationSource);
         }
@@ -4457,7 +4461,7 @@ public virtual bool CanSetDiscriminator(string? name, Type? type, ConfigurationS
         => ((name == null && discriminatorType == null)
                 || ((name == null || discriminatorProperty?.Name == name)
                     && (discriminatorType == null || discriminatorProperty?.ClrType == discriminatorType))
-                || configurationSource.Overrides(Metadata.GetDiscriminatorPropertyConfigurationSource()))
+                || configurationSource.Overrides(Metadata.GetRootType().GetDiscriminatorPropertyConfigurationSource()))
             && (discriminatorProperty != null
                 || Metadata.GetRootType().Builder.CanAddDiscriminatorProperty(
                     discriminatorType ?? DefaultDiscriminatorType,
diff --git a/src/EFCore/Properties/CoreStrings.Designer.cs b/src/EFCore/Properties/CoreStrings.Designer.cs
index ec6c16e94f..9153d56546 100644
--- a/src/EFCore/Properties/CoreStrings.Designer.cs
+++ b/src/EFCore/Properties/CoreStrings.Designer.cs
@@ -247,8 +247,8 @@ public static string CannotBeNullable(object? property, object? entityType, obje
         /// </summary>
         public static string CannotBeNullableElement(object? entityType, object? property, object? elementType)
             => string.Format(
-                GetString("CannotBeNullableElement", "entityType", "property", "elementType"),
-                property, entityType);
+                GetString("CannotBeNullableElement", nameof(entityType), nameof(property), nameof(elementType)),
+                entityType, property, elementType);
 
         /// <summary>
         ///     The property '{1_entityType}.{0_property}' cannot be marked as nullable/optional because the property is a part of a key. Any property can be marked as non-nullable/required, but only properties of nullable types and which are not part of a key can be marked as nullable/optional.
@@ -845,7 +845,7 @@ public static string DiscriminatorPropertyNotFound(object? property, object? ent
                 property, entityType);
 
         /// <summary>
-        ///     The discriminator value '{value}' for the entity type '{entityType}' because it is not assignable to type '{discriminatorType}'.
+        ///     The discriminator value '{value}' for the entity type '{entityType}' cannot be set because it is not assignable to the discriminator property of type '{discriminatorType}'.
         /// </summary>
         public static string DiscriminatorValueIncompatible(object? value, object? entityType, object? discriminatorType)
             => string.Format(
@@ -2113,14 +2113,6 @@ public static string NotAnEFService(object? service)
                 GetString("NotAnEFService", nameof(service)),
                 service);
 
-        /// <summary>
-        ///     The property '{entityType}.{property}' cannot be mapped as a collection since it does not implement 'IEnumerable&lt;T&gt;'.
-        /// </summary>
-        public static string NotCollection(object? entityType, object? property)
-            => string.Format(
-                GetString("NotCollection", nameof(entityType), nameof(property)),
-                entityType, property);
-
         /// <summary>
         ///     The database provider attempted to register an implementation of the '{service}' service. This is a service defined by Entity Framework and as such must not be registered using the 'TryAddProviderSpecificServices' method.
         /// </summary>
@@ -2137,6 +2129,14 @@ public static string NotAssignableClrBaseType(object? entityType, object? baseEn
                 GetString("NotAssignableClrBaseType", nameof(entityType), nameof(baseEntityType), nameof(clrType), nameof(baseClrType)),
                 entityType, baseEntityType, clrType, baseClrType);
 
+        /// <summary>
+        ///     The property '{entityType}.{property}' cannot be mapped as a collection since it does not implement 'IEnumerable&lt;T&gt;'.
+        /// </summary>
+        public static string NotCollection(object? entityType, object? property)
+            => string.Format(
+                GetString("NotCollection", nameof(entityType), nameof(property)),
+                entityType, property);
+
         /// <summary>
         ///     The given 'IQueryable' does not support generation of query strings.
         /// </summary>
@@ -4866,31 +4866,6 @@ public static EventDefinition<string> LogServiceProviderDebugInfo(IDiagnosticsLo
             return (EventDefinition<int, int, string, string, string>)definition;
         }
 
-        /// <summary>
-        ///     A string value was read from JSON for enum '{enumType}'. Starting with EF Core 8, a breaking change was made to store enum values in JSON as numbers by default. See https://aka.ms/efcore-docs-jsonenums for details.
-        /// </summary>
-        public static EventDefinition<string> LogStringEnumValueInJson(IDiagnosticsLogger logger)
-        {
-            var definition = ((LoggingDefinitions)logger.Definitions).LogStringEnumValueInJson;
-            if (definition == null)
-            {
-                definition = NonCapturingLazyInitializer.EnsureInitialized(
-                    ref ((LoggingDefinitions)logger.Definitions).LogStringEnumValueInJson,
-                    logger,
-                    static logger => new EventDefinition<string>(
-                        logger.Options,
-                        CoreEventId.StringEnumValueInJson,
-                        LogLevel.Warning,
-                        "CoreEventId.StringEnumValueInJson",
-                        level => LoggerMessage.Define<string>(
-                            level,
-                            CoreEventId.StringEnumValueInJson,
-                            _resourceManager.GetString("LogStringEnumValueInJson")!)));
-            }
-
-            return (EventDefinition<string>)definition;
-        }
-
         /// <summary>
         ///     Context '{contextType}' started tracking '{entityType}' entity. Consider using 'DbContextOptionsBuilder.EnableSensitiveDataLogging' to see key values.
         /// </summary>
@@ -4991,6 +4966,31 @@ public static EventDefinition<string> LogStringEnumValueInJson(IDiagnosticsLogge
             return (EventDefinition<string, string, string, EntityState, EntityState>)definition;
         }
 
+        /// <summary>
+        ///     A string value was read from JSON for enum '{enumType}'. Starting with EF Core 8, a breaking change was made to store enum values in JSON as numbers by default. See https://aka.ms/efcore-docs-jsonenums for details.
+        /// </summary>
+        public static EventDefinition<string> LogStringEnumValueInJson(IDiagnosticsLogger logger)
+        {
+            var definition = ((LoggingDefinitions)logger.Definitions).LogStringEnumValueInJson;
+            if (definition == null)
+            {
+                definition = NonCapturingLazyInitializer.EnsureInitialized(
+                    ref ((LoggingDefinitions)logger.Definitions).LogStringEnumValueInJson,
+                    logger,
+                    static logger => new EventDefinition<string>(
+                        logger.Options,
+                        CoreEventId.StringEnumValueInJson,
+                        LogLevel.Warning,
+                        "CoreEventId.StringEnumValueInJson",
+                        level => LoggerMessage.Define<string>(
+                            level,
+                            CoreEventId.StringEnumValueInJson,
+                            _resourceManager.GetString("LogStringEnumValueInJson")!)));
+            }
+
+            return (EventDefinition<string>)definition;
+        }
+
         /// <summary>
         ///     '{contextType}' generated a temporary value for the property '{entityType}.{property}'. Consider using 'DbContextOptionsBuilder.EnableSensitiveDataLogging' to see key values.
         /// </summary>
diff --git a/src/EFCore/Properties/CoreStrings.resx b/src/EFCore/Properties/CoreStrings.resx
index e109eb49aa..72b5ed4053 100644
--- a/src/EFCore/Properties/CoreStrings.resx
+++ b/src/EFCore/Properties/CoreStrings.resx
@@ -1,17 +1,17 @@
 ï»¿<?xml version="1.0" encoding="utf-8"?>
 <root>
-  <!--
-    Microsoft ResX Schema
-
+  <!-- 
+    Microsoft ResX Schema 
+    
     Version 2.0
-
-    The primary goals of this format is to allow a simple XML format
-    that is mostly human readable. The generation and parsing of the
-    various data types are done through the TypeConverter classes
+    
+    The primary goals of this format is to allow a simple XML format 
+    that is mostly human readable. The generation and parsing of the 
+    various data types are done through the TypeConverter classes 
     associated with the data types.
-
+    
     Example:
-
+    
     ... ado.net/XML headers & schema ...
     <resheader name="resmimetype">text/microsoft-resx</resheader>
     <resheader name="version">2.0</resheader>
@@ -26,36 +26,36 @@
         <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
         <comment>This is a comment</comment>
     </data>
-
-    There are any number of "resheader" rows that contain simple
+                
+    There are any number of "resheader" rows that contain simple 
     name/value pairs.
-
-    Each data row contains a name, and value. The row also contains a
-    type or mimetype. Type corresponds to a .NET class that support
-    text/value conversion through the TypeConverter architecture.
-    Classes that don't support this are serialized and stored with the
+    
+    Each data row contains a name, and value. The row also contains a 
+    type or mimetype. Type corresponds to a .NET class that support 
+    text/value conversion through the TypeConverter architecture. 
+    Classes that don't support this are serialized and stored with the 
     mimetype set.
-
-    The mimetype is used for serialized objects, and tells the
-    ResXResourceReader how to depersist the object. This is currently not
+    
+    The mimetype is used for serialized objects, and tells the 
+    ResXResourceReader how to depersist the object. This is currently not 
     extensible. For a given mimetype the value must be set accordingly:
-
-    Note - application/x-microsoft.net.object.binary.base64 is the format
-    that the ResXResourceWriter will generate, however the reader can
+    
+    Note - application/x-microsoft.net.object.binary.base64 is the format 
+    that the ResXResourceWriter will generate, however the reader can 
     read any of the formats listed below.
-
+    
     mimetype: application/x-microsoft.net.object.binary.base64
-    value   : The object must be serialized with
+    value   : The object must be serialized with 
             : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
             : and then encoded with base64 encoding.
-
+    
     mimetype: application/x-microsoft.net.object.soap.base64
-    value   : The object must be serialized with
+    value   : The object must be serialized with 
             : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
             : and then encoded with base64 encoding.
 
     mimetype: application/x-microsoft.net.object.bytearray.base64
-    value   : The object must be serialized into a byte array
+    value   : The object must be serialized into a byte array 
             : using a System.ComponentModel.TypeConverter
             : and then encoded with base64 encoding.
     -->
@@ -430,7 +430,7 @@
     <value>Unable to set property '{property}' as a discriminator for entity type '{entityType}' because it is not a property of '{entityType}'.</value>
   </data>
   <data name="DiscriminatorValueIncompatible" xml:space="preserve">
-    <value>The discriminator value '{value}' for the entity type '{entityType}' because it is not assignable to type '{discriminatorType}'.</value>
+    <value>The discriminator value '{value}' for the entity type '{entityType}' cannot be set because it is not assignable to the discriminator property of type '{discriminatorType}'.</value>
   </data>
   <data name="DuplicateAnnotation" xml:space="preserve">
     <value>The annotation '{annotation}' cannot be added because an annotation with the same name already exists on the object {annotatable}</value>
@@ -1033,10 +1033,6 @@
     <value>{addedCount} entities were added and {removedCount} entities were removed from skip navigation '{entityType}.{property}' on entity with key '{keyValues}'.</value>
     <comment>Debug CoreEventId.SkipCollectionChangeDetected int int string string string</comment>
   </data>
-  <data name="LogStringEnumValueInJson" xml:space="preserve">
-    <value>A string value was read from JSON for enum '{enumType}'. Starting with EF Core 8, a breaking change was made to store enum values in JSON as numbers by default. See https://aka.ms/efcore-docs-jsonenums for details.</value>
-    <comment>Warning CoreEventId.StringEnumValueInJson</comment>
-  </data>
   <data name="LogStartedTracking" xml:space="preserve">
     <value>Context '{contextType}' started tracking '{entityType}' entity. Consider using 'DbContextOptionsBuilder.EnableSensitiveDataLogging' to see key values.</value>
     <comment>Debug CoreEventId.StartedTracking string string</comment>
@@ -1053,6 +1049,10 @@
     <value>The '{entityType}' entity with key '{keyValues}' tracked by '{contextType}' changed state from '{oldState}' to '{newState}'.</value>
     <comment>Debug CoreEventId.StateChanged string string string EntityState EntityState</comment>
   </data>
+  <data name="LogStringEnumValueInJson" xml:space="preserve">
+    <value>A string value was read from JSON for enum '{enumType}'. Starting with EF Core 8, a breaking change was made to store enum values in JSON as numbers by default. See https://aka.ms/efcore-docs-jsonenums for details.</value>
+    <comment>Warning CoreEventId.StringEnumValueInJson string</comment>
+  </data>
   <data name="LogTempValueGenerated" xml:space="preserve">
     <value>'{contextType}' generated a temporary value for the property '{entityType}.{property}'. Consider using 'DbContextOptionsBuilder.EnableSensitiveDataLogging' to see key values.</value>
     <comment>Debug CoreEventId.ValueGenerated string string string</comment>
@@ -1228,15 +1228,15 @@
   <data name="NotAnEFService" xml:space="preserve">
     <value>The database provider attempted to register an implementation of the '{service}' service. This is not a service defined by Entity Framework and as such must be registered as a provider-specific service using the 'TryAddProviderSpecificServices' method.</value>
   </data>
-  <data name="NotCollection" xml:space="preserve">
-    <value>The property '{entityType}.{property}' cannot be mapped as a collection since it does not implement 'IEnumerable&lt;T&gt;'.</value>
-  </data>
   <data name="NotAProviderService" xml:space="preserve">
     <value>The database provider attempted to register an implementation of the '{service}' service. This is a service defined by Entity Framework and as such must not be registered using the 'TryAddProviderSpecificServices' method.</value>
   </data>
   <data name="NotAssignableClrBaseType" xml:space="preserve">
     <value>The entity type '{entityType}' cannot inherit from '{baseEntityType}' because '{clrType}' is not a descendant of '{baseClrType}'.</value>
   </data>
+  <data name="NotCollection" xml:space="preserve">
+    <value>The property '{entityType}.{property}' cannot be mapped as a collection since it does not implement 'IEnumerable&lt;T&gt;'.</value>
+  </data>
   <data name="NotQueryingEnumerable" xml:space="preserve">
     <value>The given 'IQueryable' does not support generation of query strings.</value>
   </data>
diff --git a/test/EFCore.Tests/Metadata/Conventions/DiscriminatorConventionTest.cs b/test/EFCore.Tests/Metadata/Conventions/DiscriminatorConventionTest.cs
index f91dffa926..6674b12fbd 100644
--- a/test/EFCore.Tests/Metadata/Conventions/DiscriminatorConventionTest.cs
+++ b/test/EFCore.Tests/Metadata/Conventions/DiscriminatorConventionTest.cs
@@ -126,7 +126,7 @@ public void Does_nothing_if_explicit_discriminator_set_on_derived_type()
     {
         var entityTypeBuilder = CreateInternalEntityTypeBuilder<Entity>();
 
-        new EntityTypeBuilder(entityTypeBuilder.Metadata).HasDiscriminator("T", typeof(string));
+        new EntityTypeBuilder(entityTypeBuilder.Metadata).HasDiscriminator("T", typeof(int));
 
         var baseTypeBuilder = entityTypeBuilder.ModelBuilder.Entity(typeof(EntityBase), ConfigurationSource.Convention);
         entityTypeBuilder.HasBaseType(baseTypeBuilder.Metadata, ConfigurationSource.Convention);
diff --git a/test/EFCore.Tests/Metadata/Internal/EntityTypeTest.cs b/test/EFCore.Tests/Metadata/Internal/EntityTypeTest.cs
index d6cf05128c..08bacf8a83 100644
--- a/test/EFCore.Tests/Metadata/Internal/EntityTypeTest.cs
+++ b/test/EFCore.Tests/Metadata/Internal/EntityTypeTest.cs
@@ -23,6 +23,7 @@ public void Throws_when_model_is_readonly()
         var model = CreateModel();
 
         var entityTypeA = model.AddEntityType(typeof(A));
+        ((EntityType)entityTypeA).Builder.HasDiscriminator(ConfigurationSource.Explicit);
 
         model.FinalizeModel();
 
diff --git a/test/EFCore.Tests/ModelBuilding/InheritanceTestBase.cs b/test/EFCore.Tests/ModelBuilding/InheritanceTestBase.cs
index 8f4cf7e47d..5e5cd24dea 100644
--- a/test/EFCore.Tests/ModelBuilding/InheritanceTestBase.cs
+++ b/test/EFCore.Tests/ModelBuilding/InheritanceTestBase.cs
@@ -64,6 +64,19 @@ public virtual void Base_types_are_mapped_correctly_if_discovered_last()
             Assert.Same(derived, moreDerived.BaseType);
         }
 
+        [ConditionalFact]
+        public virtual void Can_specify_discriminator_without_derived_types()
+        {
+            var modelBuilder = CreateModelBuilder();
+
+            modelBuilder.Entity<Q>()
+                .HasDiscriminator<string>("Discriminator");
+
+            var model = modelBuilder.FinalizeModel();
+
+            Assert.Equal("Q", model.FindEntityType(typeof(Q)).GetDiscriminatorValue());
+        }
+
         [ConditionalFact]
         public virtual void Can_specify_discriminator_values_first()
         {
