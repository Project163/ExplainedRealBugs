diff --git a/All.sln.DotSettings b/All.sln.DotSettings
index edd36d48c7..8ed3bce737 100644
--- a/All.sln.DotSettings
+++ b/All.sln.DotSettings
@@ -335,6 +335,7 @@ The .NET Foundation licenses this file to you under the MIT license.&#xD;
 	<s:Boolean x:Key="/Default/UserDictionary/Words/=unignore/@EntryIndexedValue">True</s:Boolean>
 	<s:Boolean x:Key="/Default/UserDictionary/Words/=fixup/@EntryIndexedValue">True</s:Boolean>
 	<s:Boolean x:Key="/Default/UserDictionary/Words/=attacher/@EntryIndexedValue">True</s:Boolean>
+	<s:Boolean x:Key="/Default/UserDictionary/Words/=uninferrable/@EntryIndexedValue">True</s:Boolean>
 	<s:Boolean x:Key="/Default/UserDictionary/Words/=uniqueidentifier/@EntryIndexedValue">True</s:Boolean>
 	<s:Boolean x:Key="/Default/UserDictionary/Words/=Uniquification/@EntryIndexedValue">True</s:Boolean>
 	<s:Boolean x:Key="/Default/UserDictionary/Words/=Uniquified/@EntryIndexedValue">True</s:Boolean>
diff --git a/src/EFCore.Relational/Query/RelationalQueryableMethodTranslatingExpressionVisitor.cs b/src/EFCore.Relational/Query/RelationalQueryableMethodTranslatingExpressionVisitor.cs
index 9d656d89cb..c8abe3fc3d 100644
--- a/src/EFCore.Relational/Query/RelationalQueryableMethodTranslatingExpressionVisitor.cs
+++ b/src/EFCore.Relational/Query/RelationalQueryableMethodTranslatingExpressionVisitor.cs
@@ -2656,6 +2656,7 @@ protected override Expression VisitExtension(Expression node)
                     && _currentProjectionExpression is not null
                     && _inferredColumns.TryGetValue(
                         (_currentSelectExpression, _currentProjectionExpression.Alias), out var inferredTypeMapping)
+                    && inferredTypeMapping is not null
                     && WasMaybeOriginallyUntyped(columnExpression):
                 {
                     RegisterInferredTypeMapping(columnExpression, inferredTypeMapping);
@@ -2704,14 +2705,15 @@ SqlExpression UnwrapConvert(SqlExpression expression)
                     : expression;
         }
 
-        private void RegisterInferredTypeMapping(ColumnExpression columnExpression, RelationalTypeMapping? inferredTypeMapping)
+        private void RegisterInferredTypeMapping(ColumnExpression columnExpression, RelationalTypeMapping inferredTypeMapping)
         {
             var underlyingTable = columnExpression.Table is JoinExpressionBase joinExpression
                 ? joinExpression.Table
                 : columnExpression.Table;
 
             if (_inferredColumns.TryGetValue((underlyingTable, columnExpression.Name), out var knownTypeMapping)
-                && inferredTypeMapping != knownTypeMapping)
+                && knownTypeMapping is not null
+                && inferredTypeMapping.StoreType != knownTypeMapping.StoreType)
             {
                 // A different type mapping was already inferred for this column - we have a conflict.
                 // Null out the value for the inferred type mapping as an indication of the conflict. If it turns out that we need the
diff --git a/test/EFCore.SqlServer.FunctionalTests/Query/NonSharedPrimitiveCollectionsQuerySqlServerTest.cs b/test/EFCore.SqlServer.FunctionalTests/Query/NonSharedPrimitiveCollectionsQuerySqlServerTest.cs
index b22f075752..acd4773538 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Query/NonSharedPrimitiveCollectionsQuerySqlServerTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Query/NonSharedPrimitiveCollectionsQuerySqlServerTest.cs
@@ -313,6 +313,52 @@ public virtual async Task Same_parameter_with_different_type_mappings()
 """);
     }
 
+    [ConditionalFact]
+    public virtual async Task Same_collection_with_default_type_mapping_and_uninferrable_context()
+    {
+        var contextFactory = await InitializeAsync<TestContext>(
+            onModelCreating: mb => mb.Entity<TestEntity>(b => b.Property(typeof(DateTime), "DateTime")));
+
+        await using var context = contextFactory.CreateContext();
+
+        var dateTimes = new DateTime?[] { new DateTime(2020, 1, 1, 12, 30, 00), new DateTime(2020, 1, 2, 12, 30, 00), null };
+
+        _ = await context.Set<TestEntity>()
+            .Where(m => dateTimes.Any(d => d == EF.Property<DateTime>(m, "DateTime") && d != null))
+            .ToArrayAsync();
+
+        AssertSql(
+"""
+@__dateTimes_0='["2020-01-01T12:30:00","2020-01-02T12:30:00",null]' (Size = 4000)
+
+SELECT [t].[Id], [t].[DateTime], [t].[Ints]
+FROM [TestEntity] AS [t]
+WHERE EXISTS (
+    SELECT 1
+    FROM OPENJSON(@__dateTimes_0) WITH ([value] datetime2 '$') AS [d]
+    WHERE [d].[value] = [t].[DateTime] AND [d].[value] IS NOT NULL)
+""");
+    }
+
+    [ConditionalFact]
+    public virtual async Task Same_collection_with_non_default_type_mapping_and_uninferrable_context()
+    {
+        var contextFactory = await InitializeAsync<TestContext>(
+            onModelCreating: mb => mb.Entity<TestEntity>(
+                b => b.Property(typeof(DateTime), "DateTime").HasColumnType("datetime")));
+
+        await using var context = contextFactory.CreateContext();
+
+        var dateTimes = new DateTime?[] { new DateTime(2020, 1, 1, 12, 30, 00), new DateTime(2020, 1, 2, 12, 30, 00), null };
+
+        var exception = await Assert.ThrowsAsync<InvalidOperationException>(
+            () => context.Set<TestEntity>()
+                .Where(
+                    m => dateTimes.Any(d => d == EF.Property<DateTime>(m, "DateTime") && d != null))
+                .ToArrayAsync());
+        Assert.Equal(RelationalStrings.ConflictingTypeMappingsInferredForColumn("value"), exception.Message);
+    }
+
     [ConditionalFact]
     public virtual async Task Same_collection_with_conflicting_type_mappings_not_supported()
     {
