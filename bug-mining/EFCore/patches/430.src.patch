diff --git a/src/EFCore.Design/EFCore.Design.csproj b/src/EFCore.Design/EFCore.Design.csproj
index 5dd5be8a41..e4acbf7bd5 100644
--- a/src/EFCore.Design/EFCore.Design.csproj
+++ b/src/EFCore.Design/EFCore.Design.csproj
@@ -8,6 +8,7 @@
     <GenerateDocumentationFile>true</GenerateDocumentationFile>
     <DevelopmentDependency>true</DevelopmentDependency>
     <ImplicitUsings>true</ImplicitUsings>
+    <NoWarn>EF1003</NoWarn> <!-- Precompiled query is experimental -->
   </PropertyGroup>
 
   <ItemGroup>
diff --git a/src/EFCore.Relational/EFCore.Relational.csproj b/src/EFCore.Relational/EFCore.Relational.csproj
index 9725aabf41..77feb85648 100644
--- a/src/EFCore.Relational/EFCore.Relational.csproj
+++ b/src/EFCore.Relational/EFCore.Relational.csproj
@@ -8,6 +8,7 @@
     <RootNamespace>Microsoft.EntityFrameworkCore</RootNamespace>
     <GenerateDocumentationFile>true</GenerateDocumentationFile>
     <ImplicitUsings>true</ImplicitUsings>
+    <NoWarn>$(NoWarn);EF1003</NoWarn> <!-- Precomiled query is experimental -->
   </PropertyGroup>
 
   <ItemGroup>
diff --git a/src/EFCore.Relational/Metadata/IRelationalModel.cs b/src/EFCore.Relational/Metadata/IRelationalModel.cs
index 0900bddabd..2526098074 100644
--- a/src/EFCore.Relational/Metadata/IRelationalModel.cs
+++ b/src/EFCore.Relational/Metadata/IRelationalModel.cs
@@ -66,6 +66,13 @@ IEnumerable<ISequence> Sequences
     /// <returns>The table with a given name or <see langword="null" /> if no table with the given name is defined.</returns>
     ITable? FindTable(string name, string? schema);
 
+    /// <summary>
+    ///     Gets the default table with the given name. Returns <see langword="null" /> if no table with the given name is defined.
+    /// </summary>
+    /// <param name="name">The name of the table.</param>
+    /// <returns>The default table with a given name or <see langword="null" /> if no table with the given name is defined.</returns>
+    TableBase? FindDefaultTable(string name);
+
     /// <summary>
     ///     Gets the view with the given name. Returns <see langword="null" /> if no view with the given name is defined.
     /// </summary>
diff --git a/src/EFCore.Relational/Metadata/Internal/RelationalModel.cs b/src/EFCore.Relational/Metadata/Internal/RelationalModel.cs
index 4359aa432c..d39a5713d3 100644
--- a/src/EFCore.Relational/Metadata/Internal/RelationalModel.cs
+++ b/src/EFCore.Relational/Metadata/Internal/RelationalModel.cs
@@ -91,33 +91,28 @@ public override bool IsReadOnly
 
     /// <inheritdoc />
     public virtual ITable? FindTable(string name, string? schema)
-        => Tables.TryGetValue((name, schema), out var table)
-            ? table
-            : null;
+        => Tables.GetValueOrDefault((name, schema));
+
+    // TODO: Confirm that this makes sense
+    /// <inheritdoc />
+    public virtual TableBase? FindDefaultTable(string name)
+        => DefaultTables.GetValueOrDefault(name);
 
     /// <inheritdoc />
     public virtual IView? FindView(string name, string? schema)
-        => Views.TryGetValue((name, schema), out var view)
-            ? view
-            : null;
+        => Views.GetValueOrDefault((name, schema));
 
     /// <inheritdoc />
     public virtual ISqlQuery? FindQuery(string name)
-        => Queries.TryGetValue(name, out var query)
-            ? query
-            : null;
+        => Queries.GetValueOrDefault(name);
 
     /// <inheritdoc />
     public virtual IStoreFunction? FindFunction(string name, string? schema, IReadOnlyList<string> parameters)
-        => Functions.TryGetValue((name, schema, parameters), out var function)
-            ? function
-            : null;
+        => Functions.GetValueOrDefault((name, schema, parameters));
 
     /// <inheritdoc />
     public virtual IStoreStoredProcedure? FindStoredProcedure(string name, string? schema)
-        => StoredProcedures.TryGetValue((name, schema), out var storedProcedure)
-            ? storedProcedure
-            : null;
+        => StoredProcedures.GetValueOrDefault((name, schema));
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
diff --git a/src/EFCore.Relational/Query/IRelationalQuotableExpression.cs b/src/EFCore.Relational/Query/IRelationalQuotableExpression.cs
new file mode 100644
index 0000000000..f8e59c412c
--- /dev/null
+++ b/src/EFCore.Relational/Query/IRelationalQuotableExpression.cs
@@ -0,0 +1,20 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Diagnostics.CodeAnalysis;
+
+namespace Microsoft.EntityFrameworkCore.Query;
+
+/// <summary>
+///     Represents an expression that is quotable, that is, capable of returning an expression that, when evaluated, would construct an
+///     expression identical to this one. Used to generate code for precompiled queries, which reconstructs this expression.
+/// </summary>
+[Experimental("EF1003")]
+public interface IRelationalQuotableExpression
+{
+    /// <summary>
+    ///     Quotes the expression; that is, returns an expression that, when evaluated, would construct an expression identical to this
+    ///     one. Used to generate code for precompiled queries, which reconstructs this expression.
+    /// </summary>
+    Expression Quote();
+}
diff --git a/src/EFCore.Relational/Query/ISqlExpressionFactory.cs b/src/EFCore.Relational/Query/ISqlExpressionFactory.cs
index fabab2bb19..ecb12337e0 100644
--- a/src/EFCore.Relational/Query/ISqlExpressionFactory.cs
+++ b/src/EFCore.Relational/Query/ISqlExpressionFactory.cs
@@ -443,7 +443,7 @@ public interface ISqlExpressionFactory
     /// <param name="value">A value.</param>
     /// <param name="typeMapping">The <see cref="RelationalTypeMapping" /> associated with the expression.</param>
     /// <returns>An expression representing a constant in a SQL tree.</returns>
-    SqlConstantExpression Constant(object? value, RelationalTypeMapping? typeMapping = null);
+    SqlConstantExpression Constant(object value, RelationalTypeMapping? typeMapping = null);
 
     /// <summary>
     ///     Creates a new <see cref="SqlConstantExpression" /> which represents a constant in a SQL tree.
diff --git a/src/EFCore.Relational/Query/Internal/FromSqlParameterExpandingExpressionVisitor.cs b/src/EFCore.Relational/Query/Internal/FromSqlParameterExpandingExpressionVisitor.cs
index 182b1d54c5..bafd0d3dfe 100644
--- a/src/EFCore.Relational/Query/Internal/FromSqlParameterExpandingExpressionVisitor.cs
+++ b/src/EFCore.Relational/Query/Internal/FromSqlParameterExpandingExpressionVisitor.cs
@@ -180,7 +180,9 @@ object ProcessConstantValue(object? existingConstantValue)
             }
 
             return _sqlExpressionFactory.Constant(
-                existingConstantValue, _typeMappingSource.GetMappingForValue(existingConstantValue));
+                existingConstantValue,
+                existingConstantValue?.GetType() ?? typeof(object),
+                _typeMappingSource.GetMappingForValue(existingConstantValue));
         }
     }
 }
diff --git a/src/EFCore.Relational/Query/Internal/GetValueOrDefaultTranslator.cs b/src/EFCore.Relational/Query/Internal/GetValueOrDefaultTranslator.cs
index 15d039e1d9..48f311e2cb 100644
--- a/src/EFCore.Relational/Query/Internal/GetValueOrDefaultTranslator.cs
+++ b/src/EFCore.Relational/Query/Internal/GetValueOrDefaultTranslator.cs
@@ -45,7 +45,7 @@ public GetValueOrDefaultTranslator(ISqlExpressionFactory sqlExpressionFactory)
             return _sqlExpressionFactory.Coalesce(
                 instance,
                 arguments.Count == 0
-                    ? new SqlConstantExpression(method.ReturnType.GetDefaultValueConstant(), null)
+                    ? new SqlConstantExpression(method.ReturnType.GetDefaultValue(), method.ReturnType, typeMapping: null)
                     : arguments[0],
                 instance.TypeMapping);
         }
diff --git a/src/EFCore.Relational/Query/Internal/TpcTablesExpression.cs b/src/EFCore.Relational/Query/Internal/TpcTablesExpression.cs
index 3f37ba90e6..834a14e080 100644
--- a/src/EFCore.Relational/Query/Internal/TpcTablesExpression.cs
+++ b/src/EFCore.Relational/Query/Internal/TpcTablesExpression.cs
@@ -138,6 +138,10 @@ protected override TpcTablesExpression WithAnnotations(IReadOnlyDictionary<strin
     public override TpcTablesExpression WithAlias(string newAlias)
         => new(newAlias, EntityType, SelectExpressions, DiscriminatorColumn, DiscriminatorValues, Annotations);
 
+    /// <inheritdoc />
+    public override Expression Quote()
+        => throw new UnreachableException("TpcTablesExpression is a temporary tree representation and should never be quoted");
+
     /// <inheritdoc />
     public override TableExpressionBase Clone(string? alias, ExpressionVisitor cloningExpressionVisitor)
     {
diff --git a/src/EFCore.Relational/Query/PathSegment.cs b/src/EFCore.Relational/Query/PathSegment.cs
index a8237b7468..9e27268b40 100644
--- a/src/EFCore.Relational/Query/PathSegment.cs
+++ b/src/EFCore.Relational/Query/PathSegment.cs
@@ -14,8 +14,10 @@ namespace Microsoft.EntityFrameworkCore.Query;
 ///         not used in application code.
 ///     </para>
 /// </summary>
-public readonly struct PathSegment
+public readonly struct PathSegment : IRelationalQuotableExpression
 {
+    private static ConstructorInfo? _pathSegmentPropertyConstructor, _pathSegmentArrayIndexConstructor;
+
     /// <summary>
     ///     Creates a new <see cref="PathSegment" /> struct representing JSON property access.
     /// </summary>
@@ -46,6 +48,21 @@ public PathSegment(SqlExpression arrayIndex)
     /// </summary>
     public SqlExpression? ArrayIndex { get; }
 
+    /// <inheritdoc />
+    public Expression Quote()
+        => this switch
+        {
+            { PropertyName: string propertyName }
+                => Expression.New(
+                    _pathSegmentPropertyConstructor ??= typeof(PathSegment).GetConstructor([typeof(string)])!,
+                    Expression.Constant(propertyName)),
+            { ArrayIndex: SqlExpression arrayIndex }
+                => Expression.New(
+                    _pathSegmentArrayIndexConstructor ??= typeof(PathSegment).GetConstructor([typeof(SqlExpression)])!,
+                    arrayIndex.Quote()),
+            _ => throw new UnreachableException()
+        };
+
     /// <inheritdoc />
     public override string ToString()
         => PropertyName
diff --git a/src/EFCore.Relational/Query/RelationalExpressionQuotingUtilities.cs b/src/EFCore.Relational/Query/RelationalExpressionQuotingUtilities.cs
new file mode 100644
index 0000000000..699ad327ab
--- /dev/null
+++ b/src/EFCore.Relational/Query/RelationalExpressionQuotingUtilities.cs
@@ -0,0 +1,150 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Diagnostics.CodeAnalysis;
+using Microsoft.EntityFrameworkCore.Metadata.Internal;
+using Microsoft.EntityFrameworkCore.Query.SqlExpressions;
+using static System.Linq.Expressions.Expression;
+
+namespace Microsoft.EntityFrameworkCore.Query;
+
+/// <summary>
+///     Utilities used for implementing <see cref="IRelationalQuotableExpression" />.
+/// </summary>
+[Experimental("EF1003")]
+public static class RelationalExpressionQuotingUtilities
+{
+    private static readonly ParameterExpression RelationalModelParameter
+        = Parameter(typeof(RelationalModel), "relationalModel");
+    private static readonly ParameterExpression RelationalTypeMappingSourceParameter
+        = Parameter(typeof(RelationalTypeMappingSource), "relationalTypeMappingSource");
+
+    private static readonly MethodInfo RelationalModelFindTableMethod
+        = typeof(RelationalModel).GetMethod(nameof(RelationalModel.FindTable), [typeof(string), typeof(string)])!;
+
+    private static readonly MethodInfo RelationalModelFindDefaultTableMethod
+        = typeof(RelationalModel).GetMethod(nameof(RelationalModel.FindDefaultTable), [typeof(string)])!;
+
+    private static readonly MethodInfo RelationalModelFindViewMethod
+        = typeof(RelationalModel).GetMethod(nameof(RelationalModel.FindView), [typeof(string), typeof(string)])!;
+
+    private static readonly MethodInfo RelationalModelFindQueryMethod
+        = typeof(RelationalModel).GetMethod(nameof(RelationalModel.FindQuery), [typeof(string)])!;
+
+    private static readonly MethodInfo RelationalModelFindFunctionMethod
+        = typeof(RelationalModel).GetMethod(
+            nameof(RelationalModel.FindFunction), [typeof(string), typeof(string), typeof(IReadOnlyList<string>)])!;
+
+    private static ConstructorInfo? _annotationConstructor;
+    private static ConstructorInfo? _dictionaryConstructor;
+    private static MethodInfo? _dictionaryAddMethod;
+    private static MethodInfo? _hashSetAddMethod;
+
+    private static readonly MethodInfo RelationalTypeMappingSourceFindMappingMethod
+        = typeof(RelationalTypeMappingSource)
+            .GetMethod(
+                nameof(RelationalTypeMappingSource.FindMapping),
+                [
+                    typeof(Type), typeof(string), typeof(bool), typeof(bool), typeof(int), typeof(bool), typeof(bool), typeof(int),
+                    typeof(int)
+                ])!;
+
+    /// <summary>
+    ///     If <paramref name="expression" /> is <see langword="null" />, returns a <see cref="ConstantExpression" /> with a
+    ///     <see langword="null" /> value. Otherwise, calls <see cref="IRelationalQuotableExpression.Quote" /> and returns the result.
+    /// </summary>
+    public static Expression VisitOrNull<T>(T? expression) where T : IRelationalQuotableExpression
+        => expression is null ? Constant(null, typeof(T)) : expression.Quote();
+
+    /// <summary>
+    ///     Quotes a relational type mapping.
+    /// </summary>
+    public static Expression QuoteTypeMapping(RelationalTypeMapping? typeMapping)
+        => typeMapping is null
+            ? Constant(null, typeof(RelationalTypeMapping))
+            : Call(
+                RelationalTypeMappingSourceParameter,
+                RelationalTypeMappingSourceFindMappingMethod,
+                Constant(typeMapping.ClrType, typeof(Type)),
+                Constant(typeMapping.StoreType, typeof(string)),
+                Constant(false), // TODO: keyOrIndex not accessible
+                Constant(typeMapping.IsUnicode, typeof(bool?)),
+                Constant(typeMapping.Size, typeof(int?)),
+                Constant(false, typeof(bool?)), // TODO: rowversion not accessible
+                Constant(typeMapping.IsFixedLength, typeof(bool?)),
+                Constant(typeMapping.Precision, typeof(int?)),
+                Constant(typeMapping.Scale, typeof(int?)));
+
+    /// <summary>
+    ///     Quotes an <see cref="ITableBase" />.
+    /// </summary>
+    public static Expression QuoteTableBase(ITableBase tableBase)
+        => tableBase switch
+        {
+            ITable table
+                => Call(
+                    RelationalModelParameter,
+                    RelationalModelFindTableMethod,
+                    Constant(table.Name, typeof(string)),
+                    Constant(table.Schema, typeof(string))),
+
+            TableBase table
+                => Call(
+                    RelationalModelParameter,
+                    RelationalModelFindDefaultTableMethod,
+                    Constant(table.Name, typeof(string))),
+
+            IView view
+                => Call(
+                    RelationalModelParameter,
+                    RelationalModelFindViewMethod,
+                    Constant(view.Name, typeof(string)),
+                    Constant(view.Schema, typeof(string))),
+
+            ISqlQuery query
+                => Call(
+                    RelationalModelParameter,
+                    RelationalModelFindQueryMethod,
+                    Constant(query.Name, typeof(string))),
+
+            IStoreFunction function
+                => Call(
+                    RelationalModelParameter,
+                    RelationalModelFindFunctionMethod,
+                    Constant(function.Name, typeof(string)),
+                    Constant(function.Schema, typeof(string)),
+                    NewArrayInit(typeof(string), function.Parameters.Select(p => Constant(p.StoreType)))),
+
+            IStoreStoredProcedure => throw new UnreachableException(),
+
+            _ => throw new UnreachableException()
+        };
+
+    /// <summary>
+    ///     Quotes a set of string tags.
+    /// </summary>
+    public static Expression QuoteTags(ISet<string> tags)
+        => ListInit(
+            New(typeof(HashSet<string>)),
+            tags.Select(
+                t => ElementInit(
+                    _hashSetAddMethod ??= typeof(HashSet<string>).GetMethod(nameof(HashSet<string>.Add))!,
+                    Constant(t))));
+
+    /// <summary>
+    ///     Quotes the annotations on a <see cref="TableExpressionBase" />.
+    /// </summary>
+    public static Expression QuoteAnnotations(IReadOnlyDictionary<string, IAnnotation>? annotations)
+        => annotations is null or { Count: 0 }
+            ? Constant(null, typeof(IReadOnlyDictionary<string, IAnnotation>))
+            : ListInit(
+                New(_dictionaryConstructor ??= typeof(IDictionary<string, IAnnotation>).GetConstructor([])!),
+                annotations.Select(
+                    a => ElementInit(
+                        _dictionaryAddMethod ??= typeof(Dictionary<string, IAnnotation>).GetMethod("Add")!,
+                        Constant(a.Key),
+                        New(
+                            _annotationConstructor ??= typeof(Annotation).GetConstructor([typeof(string), typeof(object)])!,
+                            Constant(a.Key),
+                            Constant(a.Value)))));
+}
diff --git a/src/EFCore.Relational/Query/RelationalQueryableMethodTranslatingExpressionVisitor.CreateSelect.cs b/src/EFCore.Relational/Query/RelationalQueryableMethodTranslatingExpressionVisitor.CreateSelect.cs
index 07cc64e712..1bc5f19386 100644
--- a/src/EFCore.Relational/Query/RelationalQueryableMethodTranslatingExpressionVisitor.CreateSelect.cs
+++ b/src/EFCore.Relational/Query/RelationalQueryableMethodTranslatingExpressionVisitor.CreateSelect.cs
@@ -431,10 +431,13 @@ private void AddEntitySelectConditions(SelectExpression selectExpression, IEntit
             var concreteEntityTypes = entityType.GetConcreteDerivedTypesInclusive().ToList();
             var predicate = concreteEntityTypes.Count == 1
                 ? (SqlExpression)_sqlExpressionFactory.Equal(
-                    discriminatorColumn, _sqlExpressionFactory.Constant(concreteEntityTypes[0].GetDiscriminatorValue()))
+                    discriminatorColumn,
+                    _sqlExpressionFactory.Constant(concreteEntityTypes[0].GetDiscriminatorValue(), discriminatorColumn.Type))
                 : _sqlExpressionFactory.In(
                     discriminatorColumn,
-                    concreteEntityTypes.Select(et => _sqlExpressionFactory.Constant(et.GetDiscriminatorValue())).ToArray());
+                    concreteEntityTypes
+                        .Select(et => _sqlExpressionFactory.Constant(et.GetDiscriminatorValue(), discriminatorColumn.Type))
+                        .ToArray());
 
             selectExpression.ApplyPredicate(predicate);
 
diff --git a/src/EFCore.Relational/Query/RelationalQueryableMethodTranslatingExpressionVisitor.cs b/src/EFCore.Relational/Query/RelationalQueryableMethodTranslatingExpressionVisitor.cs
index 19bee3f349..ccbdb80cf5 100644
--- a/src/EFCore.Relational/Query/RelationalQueryableMethodTranslatingExpressionVisitor.cs
+++ b/src/EFCore.Relational/Query/RelationalQueryableMethodTranslatingExpressionVisitor.cs
@@ -2482,7 +2482,7 @@ protected virtual ValuesExpression ApplyTypeMappingsOnValuesExpression(ValuesExp
                 newRowValues[i] = new RowValueExpression(newValues);
             }
 
-            return new ValuesExpression(valuesExpression.Alias, newRowValues, newColumnNames, valuesExpression.GetAnnotations());
+            return new ValuesExpression(valuesExpression.Alias, newRowValues, newColumnNames);
         }
     }
 }
diff --git a/src/EFCore.Relational/Query/RelationalSqlTranslatingExpressionVisitor.cs b/src/EFCore.Relational/Query/RelationalSqlTranslatingExpressionVisitor.cs
index 9d854645ae..85db91718e 100644
--- a/src/EFCore.Relational/Query/RelationalSqlTranslatingExpressionVisitor.cs
+++ b/src/EFCore.Relational/Query/RelationalSqlTranslatingExpressionVisitor.cs
@@ -556,10 +556,10 @@ SqlExpression GeneratePredicateTpt(StructuralTypeProjectionExpression projection
                 return match
                     ? _sqlExpressionFactory.Equal(
                         discriminatorColumn,
-                        _sqlExpressionFactory.Constant(derivedType.GetDiscriminatorValue()))
+                        _sqlExpressionFactory.Constant(derivedType.GetDiscriminatorValue()!))
                     : _sqlExpressionFactory.NotEqual(
                         discriminatorColumn,
-                        _sqlExpressionFactory.Constant(derivedType.GetDiscriminatorValue()));
+                        _sqlExpressionFactory.Constant(derivedType.GetDiscriminatorValue()!));
             }
 
             return QueryCompilationContext.NotTranslatedExpression;
@@ -623,7 +623,7 @@ protected override Expression VisitConditional(ConditionalExpression conditional
 
     /// <inheritdoc />
     protected override Expression VisitConstant(ConstantExpression constantExpression)
-        => new SqlConstantExpression(constantExpression, null);
+        => new SqlConstantExpression(constantExpression.Value, constantExpression.Type, typeMapping: null);
 
     /// <inheritdoc />
     protected override Expression VisitExtension(Expression extensionExpression)
@@ -1150,10 +1150,12 @@ SqlExpression GeneratePredicateTpt(StructuralTypeProjectionExpression entityProj
                 return concreteEntityTypes.Count == 1
                     ? _sqlExpressionFactory.Equal(
                         discriminatorColumn,
-                        _sqlExpressionFactory.Constant(concreteEntityTypes[0].GetDiscriminatorValue()))
+                        _sqlExpressionFactory.Constant(concreteEntityTypes[0].GetDiscriminatorValue(), discriminatorColumn.Type))
                     : _sqlExpressionFactory.In(
                         discriminatorColumn,
-                        concreteEntityTypes.Select(et => _sqlExpressionFactory.Constant(et.GetDiscriminatorValue())).ToArray());
+                        concreteEntityTypes
+                            .Select(et => _sqlExpressionFactory.Constant(et.GetDiscriminatorValue(), discriminatorColumn.Type))
+                            .ToArray());
             }
 
             return _sqlExpressionFactory.Constant(true);
@@ -1326,7 +1328,7 @@ private SqlExpression BindProperty(StructuralTypeReferenceExpression typeReferen
                 if (allRequiredNonPkProperties.Count > 0)
                 {
                     condition = allRequiredNonPkProperties.Select(p => projection.BindProperty(p))
-                        .Select(c => (SqlExpression)_sqlExpressionFactory.NotEqual(c, _sqlExpressionFactory.Constant(null)))
+                        .Select(c => (SqlExpression)_sqlExpressionFactory.NotEqual(c, _sqlExpressionFactory.Constant(null, c.Type)))
                         .Aggregate((a, b) => _sqlExpressionFactory.AndAlso(a, b));
                 }
 
@@ -1336,7 +1338,7 @@ private SqlExpression BindProperty(StructuralTypeReferenceExpression typeReferen
                     // If all non principal shared properties are nullable then we need additional condition
                     var atLeastOneNonNullValueInNullableColumnsCondition = nonPrincipalSharedNonPkProperties
                         .Select(p => projection.BindProperty(p))
-                        .Select(c => (SqlExpression)_sqlExpressionFactory.NotEqual(c, _sqlExpressionFactory.Constant(null)))
+                        .Select(c => (SqlExpression)_sqlExpressionFactory.NotEqual(c, _sqlExpressionFactory.Constant(null, c.Type)))
                         .Aggregate((a, b) => _sqlExpressionFactory.OrElse(a, b));
 
                     condition = condition == null
@@ -1668,12 +1670,11 @@ private static bool TryEvaluateToConstant(Expression expression, [NotNullWhen(tr
         if (CanEvaluate(expression))
         {
             sqlConstantExpression = new SqlConstantExpression(
-                Expression.Constant(
-                    Expression.Lambda<Func<object>>(Expression.Convert(expression, typeof(object)))
-                        .Compile(preferInterpretation: true)
-                        .Invoke(),
-                    expression.Type),
-                null);
+                Expression.Lambda<Func<object>>(Expression.Convert(expression, typeof(object)))
+                    .Compile(preferInterpretation: true)
+                    .Invoke(),
+                expression.Type,
+                typeMapping: null);
             return true;
         }
 
diff --git a/src/EFCore.Relational/Query/SqlExpressionFactory.cs b/src/EFCore.Relational/Query/SqlExpressionFactory.cs
index 0dbfacce2d..df83d3a581 100644
--- a/src/EFCore.Relational/Query/SqlExpressionFactory.cs
+++ b/src/EFCore.Relational/Query/SqlExpressionFactory.cs
@@ -693,12 +693,12 @@ public virtual SqlFragmentExpression Fragment(string sql)
         => new(sql);
 
     /// <inheritdoc />
-    public virtual SqlConstantExpression Constant(object? value, RelationalTypeMapping? typeMapping = null)
-        => new(Expression.Constant(value), typeMapping);
+    public virtual SqlConstantExpression Constant(object value, RelationalTypeMapping? typeMapping = null)
+        => new(value, typeMapping);
 
     /// <inheritdoc />
     public virtual SqlConstantExpression Constant(object? value, Type type, RelationalTypeMapping? typeMapping = null)
-        => new(Expression.Constant(value, type), typeMapping);
+        => new(value, type, typeMapping);
 
     /// <inheritdoc />
     public virtual bool TryCreateLeast(
diff --git a/src/EFCore.Relational/Query/SqlExpressions/AtTimeZoneExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/AtTimeZoneExpression.cs
index f4b7529546..33cf6bef84 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/AtTimeZoneExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/AtTimeZoneExpression.cs
@@ -14,6 +14,8 @@ namespace Microsoft.EntityFrameworkCore.Query.SqlExpressions;
 /// </summary>
 public class AtTimeZoneExpression : SqlExpression
 {
+    private static ConstructorInfo? _quotingConstructor;
+
     /// <summary>
     ///     Creates a new instance of the <see cref="AtTimeZoneExpression" /> class.
     /// </summary>
@@ -63,6 +65,16 @@ public virtual AtTimeZoneExpression Update(SqlExpression operand, SqlExpression
             ? new AtTimeZoneExpression(operand, timeZone, Type, TypeMapping)
             : this;
 
+    /// <inheritdoc />
+    public override Expression Quote()
+        => New(
+            _quotingConstructor ??= typeof(AtTimeZoneExpression).GetConstructor(
+                [typeof(SqlExpression), typeof(SqlExpression), typeof(Type), typeof(RelationalTypeMapping)])!,
+            Operand.Quote(),
+            TimeZone.Quote(),
+            Constant(Type),
+            RelationalExpressionQuotingUtilities.QuoteTypeMapping(TypeMapping));
+
     /// <inheritdoc />
     protected override void Print(ExpressionPrinter expressionPrinter)
     {
diff --git a/src/EFCore.Relational/Query/SqlExpressions/CaseExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/CaseExpression.cs
index a5acf8d930..58e898aae9 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/CaseExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/CaseExpression.cs
@@ -16,6 +16,10 @@ public class CaseExpression : SqlExpression
 {
     private readonly List<CaseWhenClause> _whenClauses = [];
 
+    private static ConstructorInfo? _quotingConstructorWithOperand;
+    private static ConstructorInfo? _quotingConstructorWithoutOperand;
+    private static ConstructorInfo? _caseWhenClauseQuotingConstructor;
+
     /// <summary>
     ///     Creates a new instance of the <see cref="CaseExpression" /> class which represents a simple CASE expression.
     /// </summary>
@@ -114,6 +118,32 @@ protected override Expression VisitChildren(ExpressionVisitor visitor)
                 : new CaseExpression(operand, whenClauses, elseResult))
             : this;
 
+    /// <inheritdoc />
+    public override Expression Quote()
+    {
+        var whenClauses = NewArrayInit(
+            typeof(CaseWhenClause),
+            initializers: WhenClauses
+                .Select(c => New(
+                    _caseWhenClauseQuotingConstructor ??=
+                        typeof(CaseWhenClause).GetConstructor([typeof(SqlExpression), typeof(SqlExpression)])!,
+                    c.Test.Quote(),
+                    c.Result.Quote())));
+
+        return Operand is null
+            ? New(
+                _quotingConstructorWithoutOperand ??=
+                    typeof(CaseExpression).GetConstructor([typeof(IReadOnlyList<CaseWhenClause>), typeof(SqlExpression)])!,
+                whenClauses,
+                RelationalExpressionQuotingUtilities.VisitOrNull(ElseResult))
+            : New(
+                _quotingConstructorWithOperand ??= typeof(CaseExpression).GetConstructor(
+                    [typeof(SqlExpression), typeof(IReadOnlyList<CaseWhenClause>), typeof(SqlExpression)])!,
+                Operand.Quote(),
+                whenClauses,
+                RelationalExpressionQuotingUtilities.VisitOrNull(ElseResult));
+    }
+
     /// <inheritdoc />
     protected override void Print(ExpressionPrinter expressionPrinter)
     {
diff --git a/src/EFCore.Relational/Query/SqlExpressions/CollateExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/CollateExpression.cs
index 375493d173..578c4ab2bc 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/CollateExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/CollateExpression.cs
@@ -14,6 +14,8 @@ namespace Microsoft.EntityFrameworkCore.Query.SqlExpressions;
 /// </summary>
 public class CollateExpression : SqlExpression
 {
+    private static ConstructorInfo? _quotingConstructor;
+
     /// <summary>
     ///     Creates a new instance of the <see cref="CollateExpression" /> class.
     /// </summary>
@@ -51,6 +53,13 @@ public virtual CollateExpression Update(SqlExpression operand)
             ? new CollateExpression(operand, Collation)
             : this;
 
+    /// <inheritdoc />
+    public override Expression Quote()
+        => New(
+            _quotingConstructor ??= typeof(CollateExpression).GetConstructor([typeof(SqlExpression), typeof(string)])!,
+            Operand.Quote(),
+            Constant(Collation));
+
     /// <inheritdoc />
     protected override void Print(ExpressionPrinter expressionPrinter)
     {
diff --git a/src/EFCore.Relational/Query/SqlExpressions/ColumnExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/ColumnExpression.cs
index 06a79f6697..6e22fe372f 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/ColumnExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/ColumnExpression.cs
@@ -15,6 +15,8 @@ namespace Microsoft.EntityFrameworkCore.Query.SqlExpressions;
 [DebuggerDisplay("{TableAlias}.{Name}")]
 public class ColumnExpression : SqlExpression
 {
+    private static ConstructorInfo? _quotingConstructor;
+
     /// <summary>
     ///     Creates a new instance of the <see cref="ColumnExpression" /> class.
     /// </summary>
@@ -70,6 +72,17 @@ public virtual ColumnExpression MakeNullable()
     public virtual SqlExpression ApplyTypeMapping(RelationalTypeMapping? typeMapping)
         => new ColumnExpression(Name, TableAlias, Type, typeMapping, IsNullable);
 
+    /// <inheritdoc />
+    public override Expression Quote()
+        => New(
+            _quotingConstructor ??= typeof(ColumnExpression).GetConstructor(
+                [typeof(string), typeof(string), typeof(Type), typeof(RelationalTypeMapping), typeof(bool)])!,
+            Constant(Name),
+            Constant(TableAlias),
+            Constant(Type),
+            RelationalExpressionQuotingUtilities.QuoteTypeMapping(TypeMapping),
+            Constant(IsNullable));
+
     /// <inheritdoc />
     protected override void Print(ExpressionPrinter expressionPrinter)
         => expressionPrinter.Append(TableAlias).Append(".").Append(Name);
diff --git a/src/EFCore.Relational/Query/SqlExpressions/CrossApplyExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/CrossApplyExpression.cs
index 6b13a8fe4d..0eed1b4b1e 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/CrossApplyExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/CrossApplyExpression.cs
@@ -14,6 +14,8 @@ namespace Microsoft.EntityFrameworkCore.Query.SqlExpressions;
 /// </summary>
 public class CrossApplyExpression : JoinExpressionBase
 {
+    private static ConstructorInfo? _quotingConstructor;
+
     /// <summary>
     ///     Creates a new instance of the <see cref="CrossApplyExpression" /> class.
     /// </summary>
@@ -47,6 +49,15 @@ public override CrossApplyExpression Update(TableExpressionBase table)
     protected override CrossApplyExpression WithAnnotations(IReadOnlyDictionary<string, IAnnotation> annotations)
         => new(Table, annotations);
 
+    /// <inheritdoc />
+    public override Expression Quote()
+        => New(
+            _quotingConstructor ??=
+                typeof(CrossApplyExpression).GetConstructor(
+                    [typeof(TableExpressionBase), typeof(IReadOnlyDictionary<string, IAnnotation>)])!,
+            Table.Quote(),
+            RelationalExpressionQuotingUtilities.QuoteAnnotations(Annotations));
+
     /// <inheritdoc />
     protected override void Print(ExpressionPrinter expressionPrinter)
     {
diff --git a/src/EFCore.Relational/Query/SqlExpressions/CrossJoinExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/CrossJoinExpression.cs
index 9b5a58de12..f60bdaf438 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/CrossJoinExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/CrossJoinExpression.cs
@@ -14,6 +14,8 @@ namespace Microsoft.EntityFrameworkCore.Query.SqlExpressions;
 /// </summary>
 public class CrossJoinExpression : JoinExpressionBase
 {
+    private static ConstructorInfo? _quotingConstructor;
+
     /// <summary>
     ///     Creates a new instance of the <see cref="CrossJoinExpression" /> class.
     /// </summary>
@@ -47,6 +49,15 @@ public override CrossJoinExpression Update(TableExpressionBase table)
     protected override CrossJoinExpression WithAnnotations(IReadOnlyDictionary<string, IAnnotation> annotations)
         => new(Table, Annotations);
 
+    /// <inheritdoc />
+    public override Expression Quote()
+        => New(
+            _quotingConstructor ??=
+                typeof(CrossJoinExpression).GetConstructor(
+                    [typeof(TableExpressionBase), typeof(IReadOnlyDictionary<string, IAnnotation>)])!,
+            Table.Quote(),
+            RelationalExpressionQuotingUtilities.QuoteAnnotations(Annotations));
+
     /// <inheritdoc />
     protected override void Print(ExpressionPrinter expressionPrinter)
     {
diff --git a/src/EFCore.Relational/Query/SqlExpressions/DeleteExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/DeleteExpression.cs
index 80bb41ebbc..9a87151efe 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/DeleteExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/DeleteExpression.cs
@@ -11,8 +11,10 @@ namespace Microsoft.EntityFrameworkCore.Query.SqlExpressions;
 ///         This type is typically used by database providers (and other extensions). It is generally not used in application code.
 ///     </para>
 /// </summary>
-public sealed class DeleteExpression : Expression, IPrintableExpression
+public sealed class DeleteExpression : Expression, IRelationalQuotableExpression, IPrintableExpression
 {
+    private static ConstructorInfo? _quotingConstructor;
+
     /// <summary>
     ///     Creates a new instance of the <see cref="DeleteExpression" /> class.
     /// </summary>
@@ -80,6 +82,19 @@ public DeleteExpression Update(TableExpression table, SelectExpression selectExp
             ? this
             : new DeleteExpression(table, selectExpression, Tags);
 
+    /// <inheritdoc />
+    public Expression Quote()
+        => New(
+            _quotingConstructor ??= typeof(DeleteExpression).GetConstructor(
+            [
+                typeof(TableExpression),
+                typeof(SelectExpression),
+                typeof(ISet<string>)
+            ])!,
+            Table.Quote(),
+            SelectExpression.Quote(),
+            RelationalExpressionQuotingUtilities.QuoteTags(Tags));
+
     /// <inheritdoc />
     public void Print(ExpressionPrinter expressionPrinter)
     {
@@ -107,4 +122,5 @@ private bool Equals(DeleteExpression deleteExpression)
     /// <inheritdoc />
     public override int GetHashCode()
         => HashCode.Combine(Table, SelectExpression);
+
 }
diff --git a/src/EFCore.Relational/Query/SqlExpressions/DistinctExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/DistinctExpression.cs
index e59e28c04c..bdcca6199d 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/DistinctExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/DistinctExpression.cs
@@ -14,6 +14,8 @@ namespace Microsoft.EntityFrameworkCore.Query.SqlExpressions;
 /// </summary>
 public class DistinctExpression : SqlExpression
 {
+    private static ConstructorInfo? _quotingConstructor;
+
     /// <summary>
     ///     Creates a new instance of the <see cref="DistinctExpression" /> class.
     /// </summary>
@@ -54,6 +56,12 @@ public virtual DistinctExpression Update(SqlExpression operand)
             : this;
     }
 
+    /// <inheritdoc />
+    public override Expression Quote()
+        => New(
+            _quotingConstructor ??= typeof(DistinctExpression).GetConstructor([typeof(SqlExpression)])!,
+            Operand.Quote());
+
     /// <inheritdoc />
     protected override void Print(ExpressionPrinter expressionPrinter)
     {
diff --git a/src/EFCore.Relational/Query/SqlExpressions/ExceptExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/ExceptExpression.cs
index cb752a97bf..06388fcdcf 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/ExceptExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/ExceptExpression.cs
@@ -14,6 +14,8 @@ namespace Microsoft.EntityFrameworkCore.Query.SqlExpressions;
 /// </summary>
 public class ExceptExpression : SetOperationBase
 {
+    private static ConstructorInfo? _quotingConstructor;
+
     /// <summary>
     ///     Creates a new instance of the <see cref="ExceptExpression" /> class.
     /// </summary>
@@ -77,6 +79,23 @@ public override TableExpressionBase Clone(string? alias, ExpressionVisitor cloni
     public override ExceptExpression WithAlias(string newAlias)
         => new(newAlias, Source1, Source2, IsDistinct);
 
+    /// <inheritdoc />
+    public override Expression Quote()
+        => New(
+            _quotingConstructor ??= typeof(ExceptExpression).GetConstructor(
+            [
+                typeof(string),
+                typeof(SelectExpression),
+                typeof(SelectExpression),
+                typeof(bool),
+                typeof(IReadOnlyDictionary<string, IAnnotation>)
+            ])!,
+            Constant(Alias, typeof(string)),
+            Source1.Quote(),
+            Source2.Quote(),
+            Constant(IsDistinct),
+            RelationalExpressionQuotingUtilities.QuoteAnnotations(Annotations));
+
     /// <inheritdoc />
     protected override void Print(ExpressionPrinter expressionPrinter)
     {
diff --git a/src/EFCore.Relational/Query/SqlExpressions/ExistsExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/ExistsExpression.cs
index c3108c0aa8..a94b187b8e 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/ExistsExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/ExistsExpression.cs
@@ -14,6 +14,8 @@ namespace Microsoft.EntityFrameworkCore.Query.SqlExpressions;
 /// </summary>
 public class ExistsExpression : SqlExpression
 {
+    private static ConstructorInfo? _quotingConstructor;
+
     /// <summary>
     ///     Creates a new instance of the <see cref="ExistsExpression" /> class.
     /// </summary>
@@ -49,6 +51,14 @@ public virtual ExistsExpression Update(SelectExpression subquery)
             ? new ExistsExpression(subquery, TypeMapping)
             : this;
 
+    /// <inheritdoc />
+    public override Expression Quote()
+        => New(
+            _quotingConstructor ??=
+                typeof(ExistsExpression).GetConstructor([typeof(SelectExpression), typeof(bool), typeof(RelationalTypeMapping)])!,
+            Subquery.Quote(),
+            RelationalExpressionQuotingUtilities.QuoteTypeMapping(TypeMapping));
+
     /// <inheritdoc />
     protected override void Print(ExpressionPrinter expressionPrinter)
     {
diff --git a/src/EFCore.Relational/Query/SqlExpressions/FromSqlExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/FromSqlExpression.cs
index 97ac89511d..c71e7b9773 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/FromSqlExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/FromSqlExpression.cs
@@ -16,6 +16,9 @@ namespace Microsoft.EntityFrameworkCore.Query.SqlExpressions;
 /// </summary>
 public class FromSqlExpression : TableExpressionBase, ITableBasedExpression
 {
+    private static ConstructorInfo? _quotingConstructor;
+    private static MethodInfo? _constantExpressionFactoryMethod, _parameterExpressionFactoryMethod;
+
     /// <summary>
     ///     Creates a new instance of the <see cref="FromSqlExpression" /> class.
     /// </summary>
@@ -49,7 +52,14 @@ public FromSqlExpression(string alias, string sql, Expression arguments)
     {
     }
 
-    private FromSqlExpression(
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    [EntityFrameworkInternal]
+    public FromSqlExpression(
         string alias,
         ITableBase? tableBase,
         string sql,
@@ -102,6 +112,38 @@ protected override FromSqlExpression WithAnnotations(IReadOnlyDictionary<string,
     public override FromSqlExpression WithAlias(string newAlias)
         => new(newAlias, Table, Sql, Arguments, Annotations);
 
+    /// <inheritdoc />
+    public override Expression Quote()
+    {
+        _constantExpressionFactoryMethod ??= typeof(Expression).GetMethod(nameof(Constant), [typeof(object)])!;
+
+        return New(
+            _quotingConstructor ??= typeof(FromSqlExpression).GetConstructor(
+            [
+                typeof(string), typeof(ITableBase), typeof(string), typeof(Expression), typeof(IReadOnlyDictionary<string, IAnnotation>)
+            ])!,
+            Constant(Alias, typeof(string)),
+            Table is null ? Constant(null, typeof(ITableBase)) : RelationalExpressionQuotingUtilities.QuoteTableBase(Table),
+            Constant(Sql),
+            Arguments switch
+            {
+                ConstantExpression { Value: object[] arguments }
+                    => NewArrayInit(
+                        typeof(object),
+                        arguments.Select(a => (Expression)Call(_constantExpressionFactoryMethod, Constant(a))).ToArray()),
+
+                ParameterExpression parameter
+                    when parameter.Type == typeof(object[])
+                    => Call(
+                        _parameterExpressionFactoryMethod ??= typeof(Expression).GetMethod(nameof(Parameter), [typeof(Type), typeof(string)])!,
+                        Constant(typeof(object[])),
+                        Constant(parameter.Name, typeof(string))),
+
+                _ => throw new UnreachableException() // TODO: Confirm
+            },
+            RelationalExpressionQuotingUtilities.QuoteAnnotations(Annotations));
+    }
+
     /// <inheritdoc />
     protected override Expression VisitChildren(ExpressionVisitor visitor)
         => this;
diff --git a/src/EFCore.Relational/Query/SqlExpressions/InExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/InExpression.cs
index d8b4198bbc..a07f3bc7c7 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/InExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/InExpression.cs
@@ -14,6 +14,10 @@ namespace Microsoft.EntityFrameworkCore.Query.SqlExpressions;
 /// </summary>
 public class InExpression : SqlExpression
 {
+    private static ConstructorInfo? _quotingConstructorWithSubquery;
+    private static ConstructorInfo? _quotingConstructorWithValues;
+    private static ConstructorInfo? _quotingConstructorWithValuesParameter;
+
     /// <summary>
     ///     Creates a new instance of the <see cref="InExpression" /> class, representing a SQL <c>IN</c> expression with a subquery.
     /// </summary>
@@ -194,6 +198,34 @@ public virtual InExpression Update(SqlExpression item, SqlParameterExpression va
             : new InExpression(item, subquery, values, valuesParameter, TypeMapping);
     }
 
+    /// <inheritdoc />
+    public override Expression Quote()
+        => this switch
+        {
+            { Subquery: not null } => New(
+                _quotingConstructorWithSubquery ??= typeof(InExpression).GetConstructor(
+                    [typeof(SqlExpression), typeof(SelectExpression), typeof(RelationalTypeMapping)])!,
+                Item.Quote(),
+                Subquery.Quote(),
+                RelationalExpressionQuotingUtilities.QuoteTypeMapping(TypeMapping)),
+
+            { Values: not null } => New(
+                _quotingConstructorWithValues ??= typeof(InExpression).GetConstructor(
+                    [typeof(SqlExpression), typeof(IReadOnlyList<SqlExpression>), typeof(RelationalTypeMapping)])!,
+                Item.Quote(),
+                NewArrayInit(typeof(SqlExpression), initializers: Values.Select(v => v.Quote())),
+                RelationalExpressionQuotingUtilities.QuoteTypeMapping(TypeMapping)),
+
+            { ValuesParameter: not null } => New(
+                _quotingConstructorWithValuesParameter ??= typeof(InExpression).GetConstructor(
+                    [typeof(SqlExpression), typeof(SqlParameterExpression), typeof(RelationalTypeMapping)])!,
+                Item.Quote(),
+                ValuesParameter.Quote(),
+                RelationalExpressionQuotingUtilities.QuoteTypeMapping(TypeMapping)),
+
+            _ => throw new UnreachableException()
+        };
+
     /// <inheritdoc />
     protected override void Print(ExpressionPrinter expressionPrinter)
     {
diff --git a/src/EFCore.Relational/Query/SqlExpressions/InnerJoinExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/InnerJoinExpression.cs
index 5373bee4a0..d21c4a1f83 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/InnerJoinExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/InnerJoinExpression.cs
@@ -14,6 +14,8 @@ namespace Microsoft.EntityFrameworkCore.Query.SqlExpressions;
 /// </summary>
 public class InnerJoinExpression : PredicateJoinExpressionBase
 {
+    private static ConstructorInfo? _quotingConstructor;
+
     /// <summary>
     ///     Creates a new instance of the <see cref="InnerJoinExpression" /> class.
     /// </summary>
@@ -61,6 +63,16 @@ public override InnerJoinExpression Update(TableExpressionBase table)
     protected override InnerJoinExpression WithAnnotations(IReadOnlyDictionary<string, IAnnotation> annotations)
         => new(Table, JoinPredicate, IsPrunable, annotations);
 
+    /// <inheritdoc />
+    public override Expression Quote()
+        => New(
+            _quotingConstructor ??= typeof(InnerJoinExpression).GetConstructor(
+                [typeof(TableExpressionBase), typeof(SqlExpression), typeof(bool), typeof(IReadOnlyDictionary<string, IAnnotation>)])!,
+            Table.Quote(),
+            JoinPredicate.Quote(),
+            Constant(IsPrunable),
+            RelationalExpressionQuotingUtilities.QuoteAnnotations(Annotations));
+
     /// <inheritdoc />
     protected override void Print(ExpressionPrinter expressionPrinter)
     {
diff --git a/src/EFCore.Relational/Query/SqlExpressions/IntersectExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/IntersectExpression.cs
index 1ce1c89b91..2a3327e66a 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/IntersectExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/IntersectExpression.cs
@@ -14,6 +14,8 @@ namespace Microsoft.EntityFrameworkCore.Query.SqlExpressions;
 /// </summary>
 public class IntersectExpression : SetOperationBase
 {
+    private static ConstructorInfo? _quotingConstructor;
+
     /// <summary>
     ///     Creates a new instance of the <see cref="IntersectExpression" /> class.
     /// </summary>
@@ -77,6 +79,17 @@ public override TableExpressionBase Clone(string? alias, ExpressionVisitor cloni
     public override IntersectExpression WithAlias(string newAlias)
         => new(newAlias, Source1, Source2, IsDistinct);
 
+    /// <inheritdoc />
+    public override Expression Quote()
+        => New(
+            _quotingConstructor ??= typeof(IntersectExpression).GetConstructor(
+                [typeof(string), typeof(SelectExpression), typeof(SelectExpression), typeof(bool), typeof(IReadOnlyDictionary<string, IAnnotation>)])!,
+            Constant(Alias, typeof(string)),
+            Source1.Quote(),
+            Source2.Quote(),
+            Constant(IsDistinct),
+            RelationalExpressionQuotingUtilities.QuoteAnnotations(Annotations));
+
     /// <inheritdoc />
     protected override void Print(ExpressionPrinter expressionPrinter)
     {
diff --git a/src/EFCore.Relational/Query/SqlExpressions/JsonScalarExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/JsonScalarExpression.cs
index d44cc71b35..f3a7642fe8 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/JsonScalarExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/JsonScalarExpression.cs
@@ -14,6 +14,8 @@ namespace Microsoft.EntityFrameworkCore.Query.SqlExpressions;
 /// </summary>
 public class JsonScalarExpression : SqlExpression
 {
+    private static ConstructorInfo? _quotingConstructor;
+
     /// <summary>
     ///     Creates a new instance of the <see cref="JsonScalarExpression" /> class.
     /// </summary>
@@ -123,6 +125,17 @@ public virtual JsonScalarExpression Update(SqlExpression json)
             ? new JsonScalarExpression(json, Path, Type, TypeMapping!, IsNullable)
             : this;
 
+    /// <inheritdoc />
+    public override Expression Quote()
+        => New(
+            _quotingConstructor ??= typeof(JsonScalarExpression).GetConstructor(
+                [typeof(SqlExpression), typeof(IReadOnlyList<PathSegment>), typeof(Type), typeof(RelationalTypeMapping), typeof(bool)])!,
+            Json.Quote(),
+            NewArrayInit(typeof(PathSegment), initializers: Path.Select(s => s.Quote())),
+            Constant(Type),
+            RelationalExpressionQuotingUtilities.QuoteTypeMapping(TypeMapping),
+            Constant(IsNullable));
+
     /// <inheritdoc />
     protected override void Print(ExpressionPrinter expressionPrinter)
     {
diff --git a/src/EFCore.Relational/Query/SqlExpressions/LeftJoinExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/LeftJoinExpression.cs
index 1fc5dbef91..e359be4355 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/LeftJoinExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/LeftJoinExpression.cs
@@ -14,6 +14,8 @@ namespace Microsoft.EntityFrameworkCore.Query.SqlExpressions;
 /// </summary>
 public class LeftJoinExpression : PredicateJoinExpressionBase
 {
+    private static ConstructorInfo? _quotingConstructor;
+
     /// <summary>
     ///     Creates a new instance of the <see cref="LeftJoinExpression" /> class.
     /// </summary>
@@ -61,6 +63,15 @@ public override LeftJoinExpression Update(TableExpressionBase table)
     protected override LeftJoinExpression WithAnnotations(IReadOnlyDictionary<string, IAnnotation> annotations)
         => new(Table, JoinPredicate, IsPrunable, annotations);
 
+    /// <inheritdoc />
+    public override Expression Quote()
+        => New(
+            _quotingConstructor ??= typeof(LeftJoinExpression).GetConstructor([typeof(TableExpressionBase), typeof(SqlExpression), typeof(bool), typeof(IReadOnlyDictionary<string, IAnnotation>)])!,
+            Table.Quote(),
+            JoinPredicate.Quote(),
+            Constant(IsPrunable),
+            RelationalExpressionQuotingUtilities.QuoteAnnotations(Annotations));
+
     /// <inheritdoc />
     protected override void Print(ExpressionPrinter expressionPrinter)
     {
diff --git a/src/EFCore.Relational/Query/SqlExpressions/LikeExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/LikeExpression.cs
index ba07749ac4..977eda682f 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/LikeExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/LikeExpression.cs
@@ -14,6 +14,8 @@ namespace Microsoft.EntityFrameworkCore.Query.SqlExpressions;
 /// </summary>
 public class LikeExpression : SqlExpression
 {
+    private static ConstructorInfo? _quotingConstructor;
+
     /// <summary>
     ///     Creates a new instance of the <see cref="LikeExpression" /> class.
     /// </summary>
@@ -74,6 +76,16 @@ protected override Expression VisitChildren(ExpressionVisitor visitor)
             ? new LikeExpression(match, pattern, escapeChar, TypeMapping)
             : this;
 
+    /// <inheritdoc />
+    public override Expression Quote()
+        => New(
+            _quotingConstructor ??= typeof(LikeExpression).GetConstructor(
+                [typeof(SqlExpression), typeof(SqlExpression), typeof(SqlExpression), typeof(RelationalTypeMapping)])!,
+            Match.Quote(),
+            Pattern.Quote(),
+            RelationalExpressionQuotingUtilities.VisitOrNull(EscapeChar),
+            RelationalExpressionQuotingUtilities.QuoteTypeMapping(TypeMapping));
+
     /// <inheritdoc />
     protected override void Print(ExpressionPrinter expressionPrinter)
     {
diff --git a/src/EFCore.Relational/Query/SqlExpressions/OrderingExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/OrderingExpression.cs
index d0aaffb189..ad59d1151e 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/OrderingExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/OrderingExpression.cs
@@ -13,8 +13,10 @@ namespace Microsoft.EntityFrameworkCore.Query.SqlExpressions;
 ///     </para>
 /// </summary>
 [DebuggerDisplay("{Microsoft.EntityFrameworkCore.Query.ExpressionPrinter.Print(this), nq}")]
-public class OrderingExpression : Expression, IPrintableExpression
+public class OrderingExpression : Expression, IRelationalQuotableExpression, IPrintableExpression
 {
+    private static ConstructorInfo? _quotingConstructor;
+
     /// <summary>
     ///     Creates a new instance of the <see cref="OrderingExpression" /> class.
     /// </summary>
@@ -59,6 +61,14 @@ public virtual OrderingExpression Update(SqlExpression expression)
             ? new OrderingExpression(expression, IsAscending)
             : this;
 
+
+    /// <inheritdoc />
+    public Expression Quote()
+        => New(
+            _quotingConstructor ??= typeof(OrderingExpression).GetConstructor([typeof(SqlExpression), typeof(bool)])!,
+            Expression.Quote(),
+            Constant(IsAscending));
+
     /// <inheritdoc />
     void IPrintableExpression.Print(ExpressionPrinter expressionPrinter)
     {
diff --git a/src/EFCore.Relational/Query/SqlExpressions/OuterApplyExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/OuterApplyExpression.cs
index 6a64ce346d..91e319011f 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/OuterApplyExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/OuterApplyExpression.cs
@@ -14,6 +14,8 @@ namespace Microsoft.EntityFrameworkCore.Query.SqlExpressions;
 /// </summary>
 public class OuterApplyExpression : JoinExpressionBase
 {
+    private static ConstructorInfo? _quotingConstructor;
+
     /// <summary>
     ///     Creates a new instance of the <see cref="OuterApplyExpression" /> class.
     /// </summary>
@@ -47,6 +49,13 @@ public override OuterApplyExpression Update(TableExpressionBase table)
     protected override OuterApplyExpression WithAnnotations(IReadOnlyDictionary<string, IAnnotation> annotations)
         => new(Table, annotations);
 
+    /// <inheritdoc />
+    public override Expression Quote()
+        => New(
+            _quotingConstructor ??= typeof(OuterApplyExpression).GetConstructor([typeof(TableExpressionBase), typeof(IReadOnlyDictionary<string, IAnnotation>)])!,
+            Table.Quote(),
+            RelationalExpressionQuotingUtilities.QuoteAnnotations(Annotations));
+
     /// <inheritdoc />
     protected override void Print(ExpressionPrinter expressionPrinter)
     {
diff --git a/src/EFCore.Relational/Query/SqlExpressions/ProjectionExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/ProjectionExpression.cs
index 12af630fd3..28c1c6bc33 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/ProjectionExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/ProjectionExpression.cs
@@ -13,9 +13,18 @@ namespace Microsoft.EntityFrameworkCore.Query.SqlExpressions;
 ///     <see href="https://github.com/dotnet/efcore">github.com/dotnet/efcore</see>.
 /// </remarks>
 [DebuggerDisplay("{Microsoft.EntityFrameworkCore.Query.ExpressionPrinter.Print(this), nq}")]
-public sealed class ProjectionExpression : Expression, IPrintableExpression
+public sealed class ProjectionExpression : Expression, IRelationalQuotableExpression, IPrintableExpression
 {
-    internal ProjectionExpression(SqlExpression expression, string alias)
+    private static ConstructorInfo? _quotingConstructor;
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    [EntityFrameworkInternal]
+    public ProjectionExpression(SqlExpression expression, string alias)
     {
         Expression = expression;
         Alias = alias;
@@ -54,6 +63,13 @@ public ProjectionExpression Update(SqlExpression expression)
             ? new ProjectionExpression(expression, Alias)
             : this;
 
+    /// <inheritdoc />
+    public Expression Quote()
+        => New(
+            _quotingConstructor ??= typeof(ProjectionExpression).GetConstructor([typeof(SqlExpression), typeof(string)])!,
+            Expression.Quote(),
+            Constant(Alias));
+
     /// <inheritdoc />
     void IPrintableExpression.Print(ExpressionPrinter expressionPrinter)
     {
diff --git a/src/EFCore.Relational/Query/SqlExpressions/RowNumberExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/RowNumberExpression.cs
index 771382a5b9..228a0cde79 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/RowNumberExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/RowNumberExpression.cs
@@ -14,6 +14,8 @@ namespace Microsoft.EntityFrameworkCore.Query.SqlExpressions;
 /// </summary>
 public class RowNumberExpression : SqlExpression
 {
+    private static ConstructorInfo? _quotingConstructor;
+
     /// <summary>
     ///     Creates a new instance of the <see cref="RowNumberExpression" /> class.
     /// </summary>
@@ -81,6 +83,14 @@ protected override Expression VisitChildren(ExpressionVisitor visitor)
                 ? this
                 : new RowNumberExpression(partitions, orderings, TypeMapping);
 
+    /// <inheritdoc />
+    public override Expression Quote()
+        => New(
+            _quotingConstructor ??= typeof(RowNumberExpression).GetConstructor(
+                [typeof(IReadOnlyList<SqlExpression>), typeof(IReadOnlyList<OrderingExpression>), typeof(RelationalTypeMapping)])!,
+            NewArrayInit(typeof(SqlExpression), initializers: Orderings.Select(o => o.Quote())),
+            RelationalExpressionQuotingUtilities.QuoteTypeMapping(TypeMapping));
+
     /// <inheritdoc />
     protected override void Print(ExpressionPrinter expressionPrinter)
     {
diff --git a/src/EFCore.Relational/Query/SqlExpressions/RowValueExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/RowValueExpression.cs
index 3ae8b29dc1..9291d3e4c9 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/RowValueExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/RowValueExpression.cs
@@ -14,6 +14,8 @@ namespace Microsoft.EntityFrameworkCore.Query.SqlExpressions;
 /// </summary>
 public class RowValueExpression : SqlExpression
 {
+    private static ConstructorInfo? _quotingConstructor;
+
     /// <summary>
     ///     The values of this row.
     /// </summary>
@@ -47,6 +49,12 @@ public virtual RowValueExpression Update(IReadOnlyList<SqlExpression> values)
             ? this
             : new RowValueExpression(values);
 
+    /// <inheritdoc />
+    public override Expression Quote()
+        => New(
+            _quotingConstructor ??= typeof(RowValueExpression).GetConstructor([typeof(IReadOnlyList<SqlExpression>)])!,
+            NewArrayInit(typeof(SqlExpression), Values.Select(v => v.Quote())));
+
     /// <inheritdoc />
     protected override void Print(ExpressionPrinter expressionPrinter)
     {
diff --git a/src/EFCore.Relational/Query/SqlExpressions/ScalarSubqueryExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/ScalarSubqueryExpression.cs
index 334d8a682e..cf8cb38d6d 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/ScalarSubqueryExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/ScalarSubqueryExpression.cs
@@ -14,6 +14,8 @@ namespace Microsoft.EntityFrameworkCore.Query.SqlExpressions;
 /// </summary>
 public class ScalarSubqueryExpression : SqlExpression
 {
+    private static ConstructorInfo? _quotingConstructor;
+
     /// <summary>
     ///     Creates a new instance of the <see cref="ScalarSubqueryExpression" /> class.
     /// </summary>
@@ -70,6 +72,12 @@ public virtual ScalarSubqueryExpression Update(SelectExpression subquery)
             ? new ScalarSubqueryExpression(subquery)
             : this;
 
+    /// <inheritdoc />
+    public override Expression Quote()
+        => New(
+            _quotingConstructor ??= typeof(ScalarSubqueryExpression).GetConstructor([typeof(SelectExpression)])!,
+            Subquery.Quote());
+
     /// <inheritdoc />
     protected override void Print(ExpressionPrinter expressionPrinter)
     {
diff --git a/src/EFCore.Relational/Query/SqlExpressions/SelectExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/SelectExpression.cs
index a1c765dd9d..47db6c9f95 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/SelectExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/SelectExpression.cs
@@ -51,7 +51,16 @@ public sealed partial class SelectExpression : TableExpressionBase
     // Pushdown should null it out as if GroupBy was present was pushed down.
     private List<(ColumnExpression Column, ValueComparer Comparer)>? _preGroupByIdentifier;
 
-    private SelectExpression(
+    private static ConstructorInfo? _quotingConstructor;
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    [EntityFrameworkInternal]
+    public SelectExpression(
         string? alias,
         List<TableExpressionBase> tables,
         List<SqlExpression> groupBy,
@@ -678,7 +687,7 @@ static void UpdateLimit(SelectExpression selectExpression)
                     {
                         if (selectExpression.Limit is SqlConstantExpression { Value: 2 } limitConstantExpression)
                         {
-                            selectExpression.Limit = new SqlConstantExpression(Constant(1), limitConstantExpression.TypeMapping);
+                            selectExpression.Limit = new SqlConstantExpression(1, limitConstantExpression.TypeMapping);
                         }
                     }
                 }
@@ -2229,7 +2238,7 @@ static bool IsNullableProjection(ProjectionExpression projectionExpression)
     public void ApplyDefaultIfEmpty(ISqlExpressionFactory sqlExpressionFactory)
     {
         var nullSqlExpression = sqlExpressionFactory.ApplyDefaultTypeMapping(
-            new SqlConstantExpression(Constant(null, typeof(string)), null));
+            new SqlConstantExpression(null, typeof(string), null));
 
         var dummySelectExpression = CreateImmutable(
             _sqlAliasManager.GenerateTableAlias("empty"),
@@ -2823,7 +2832,7 @@ private enum JoinType
                                     limit = offset is SqlConstantExpression offsetConstant
                                         && limit is SqlConstantExpression limitConstant
                                             ? new SqlConstantExpression(
-                                                Constant((int)offsetConstant.Value! + (int)limitConstant.Value!),
+                                                (int)offsetConstant.Value! + (int)limitConstant.Value!,
                                                 limit.TypeMapping)
                                             : new SqlBinaryExpression(ExpressionType.Add, offset, limit, limit.Type, limit.TypeMapping);
                                 }
@@ -4201,6 +4210,39 @@ public override SelectExpression WithAlias(string newAlias)
         };
     }
 
+    /// <inheritdoc />
+    public override Expression Quote()
+        => New(
+            _quotingConstructor ??= typeof(SelectExpression).GetConstructor(
+            [
+                typeof(string), // alias
+                typeof(IReadOnlyList<TableExpressionBase>), // tables
+                typeof(SqlExpression), // predicate
+                typeof(IReadOnlyList<SqlExpression>), // groupby
+                typeof(SqlExpression), // having
+                typeof(IReadOnlyList<ProjectionExpression>), // projections
+                typeof(bool), // distinct
+                typeof(IReadOnlyList<OrderingExpression>), // orderings
+                typeof(SqlExpression), // limit
+                typeof(SqlExpression), // offset
+                typeof(IReadOnlySet<string>), // tags
+                typeof(IReadOnlyDictionary<string, IAnnotation>) // annotations
+            ])!,
+            Constant(Alias, typeof(string)),
+            NewArrayInit(
+                typeof(TableExpressionBase),
+                initializers: Tables.Select(t => t.Quote())),
+            RelationalExpressionQuotingUtilities.VisitOrNull(Predicate),
+            NewArrayInit(typeof(SqlExpression), initializers: GroupBy.Select(g => g.Quote())),
+            RelationalExpressionQuotingUtilities.VisitOrNull(Having),
+            NewArrayInit(typeof(ProjectionExpression), initializers: Projection.Select(p => p.Quote())),
+            Constant(IsDistinct),
+            NewArrayInit(typeof(OrderingExpression), initializers: Orderings.Select(o => o.Quote())),
+            RelationalExpressionQuotingUtilities.VisitOrNull(Limit),
+            RelationalExpressionQuotingUtilities.VisitOrNull(Offset),
+            RelationalExpressionQuotingUtilities.QuoteTags(Tags),
+            RelationalExpressionQuotingUtilities.QuoteAnnotations(Annotations));
+
     /// <inheritdoc />
     protected override void Print(ExpressionPrinter expressionPrinter)
     {
diff --git a/src/EFCore.Relational/Query/SqlExpressions/SqlBinaryExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/SqlBinaryExpression.cs
index b61fded1ed..d9fc939ff4 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/SqlBinaryExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/SqlBinaryExpression.cs
@@ -38,6 +38,8 @@ public class SqlBinaryExpression : SqlExpression
         //ExpressionType.LeftShift,
     };
 
+    private static ConstructorInfo? _quotingConstructor;
+
     internal static bool IsValidOperator(ExpressionType operatorType)
         => AllowedOperators.Contains(operatorType);
 
@@ -105,6 +107,17 @@ public virtual SqlBinaryExpression Update(SqlExpression left, SqlExpression righ
             ? new SqlBinaryExpression(OperatorType, left, right, Type, TypeMapping)
             : this;
 
+    /// <inheritdoc />
+    public override Expression Quote()
+        => New(
+            _quotingConstructor ??= typeof(SqlBinaryExpression).GetConstructor(
+                [typeof(ExpressionType), typeof(SqlExpression), typeof(SqlExpression), typeof(Type), typeof(RelationalTypeMapping)])!,
+            Constant(OperatorType),
+            Left.Quote(),
+            Right.Quote(),
+            Constant(Type),
+            RelationalExpressionQuotingUtilities.QuoteTypeMapping(TypeMapping));
+
     /// <inheritdoc />
     protected override void Print(ExpressionPrinter expressionPrinter)
     {
diff --git a/src/EFCore.Relational/Query/SqlExpressions/SqlConstantExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/SqlConstantExpression.cs
index bc7d4db06c..c386b7c98e 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/SqlConstantExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/SqlConstantExpression.cs
@@ -16,24 +16,43 @@ namespace Microsoft.EntityFrameworkCore.Query.SqlExpressions;
 /// </summary>
 public class SqlConstantExpression : SqlExpression
 {
-    private readonly ConstantExpression _constantExpression;
+    private static ConstructorInfo? _quotingConstructor;
+
+    /// <summary>
+    ///     Creates a new instance of the <see cref="SqlConstantExpression" /> class.
+    /// </summary>
+    /// <param name="value">An <see cref="Object" /> to set the <see cref="Value" /> property equal to.</param>
+    /// <param name="type">The <see cref="System.Type" /> of the expression.</param>
+    /// <param name="typeMapping">The <see cref="RelationalTypeMapping" /> associated with the expression.</param>
+    public SqlConstantExpression(object? value, Type type, RelationalTypeMapping? typeMapping)
+        : base(type.UnwrapNullableType(), typeMapping)
+        => Value = value;
+
+    /// <summary>
+    ///     Creates a new instance of the <see cref="SqlConstantExpression" /> class.
+    /// </summary>
+    /// <param name="value">An <see cref="Object" /> to set the <see cref="Value" /> property equal to.</param>
+    /// <param name="typeMapping">The <see cref="RelationalTypeMapping" /> associated with the expression.</param>
+    public SqlConstantExpression(object value, RelationalTypeMapping? typeMapping)
+        : this(value, value.GetType(), typeMapping)
+    {
+    }
 
     /// <summary>
     ///     Creates a new instance of the <see cref="SqlConstantExpression" /> class.
     /// </summary>
     /// <param name="constantExpression">A <see cref="ConstantExpression" />.</param>
     /// <param name="typeMapping">The <see cref="RelationalTypeMapping" /> associated with the expression.</param>
+    [Obsolete("Call the constructor accepting a value (and possibly a Type) instead")]
     public SqlConstantExpression(ConstantExpression constantExpression, RelationalTypeMapping? typeMapping)
         : base(constantExpression.Type.UnwrapNullableType(), typeMapping)
     {
-        _constantExpression = constantExpression;
     }
 
     /// <summary>
     ///     The constant value.
     /// </summary>
-    public virtual object? Value
-        => _constantExpression.Value;
+    public virtual object? Value { get; }
 
     /// <summary>
     ///     Applies supplied type mapping to this expression.
@@ -41,12 +60,24 @@ public SqlConstantExpression(ConstantExpression constantExpression, RelationalTy
     /// <param name="typeMapping">A relational type mapping to apply.</param>
     /// <returns>A new expression which has supplied type mapping.</returns>
     public virtual SqlExpression ApplyTypeMapping(RelationalTypeMapping? typeMapping)
-        => new SqlConstantExpression(_constantExpression, typeMapping);
+        => new SqlConstantExpression(Value, Type, typeMapping);
 
     /// <inheritdoc />
     protected override Expression VisitChildren(ExpressionVisitor visitor)
         => this;
 
+    /// <inheritdoc />
+    public override Expression Quote()
+        => New(
+            _quotingConstructor ??= typeof(SqlConstantExpression)
+                .GetConstructor([typeof(object), typeof(Type), typeof(RelationalTypeMapping)])!,
+            Type.IsValueType
+                ? Convert(
+                    Constant(Value, Type), typeof(object))
+                : Constant(Value, Type),
+            Constant(Type),
+            RelationalExpressionQuotingUtilities.QuoteTypeMapping(TypeMapping));
+
     /// <inheritdoc />
     protected override void Print(ExpressionPrinter expressionPrinter)
         => Print(Value, expressionPrinter);
diff --git a/src/EFCore.Relational/Query/SqlExpressions/SqlExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/SqlExpression.cs
index 670ec871fe..8c373550b9 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/SqlExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/SqlExpression.cs
@@ -13,7 +13,7 @@ namespace Microsoft.EntityFrameworkCore.Query.SqlExpressions;
 ///     </para>
 /// </summary>
 [DebuggerDisplay("{Microsoft.EntityFrameworkCore.Query.ExpressionPrinter.Print(this), nq}")]
-public abstract class SqlExpression : Expression, IPrintableExpression
+public abstract class SqlExpression : Expression, IRelationalQuotableExpression, IPrintableExpression
 {
     /// <summary>
     ///     Creates a new instance of the <see cref="SqlExpression" /> class.
@@ -44,6 +44,9 @@ protected override Expression VisitChildren(ExpressionVisitor visitor)
     public sealed override ExpressionType NodeType
         => ExpressionType.Extension;
 
+    /// <inheritdoc />
+    public abstract Expression Quote();
+
     /// <summary>
     ///     Creates a printable string representation of the given expression using <see cref="ExpressionPrinter" />.
     /// </summary>
diff --git a/src/EFCore.Relational/Query/SqlExpressions/SqlFragmentExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/SqlFragmentExpression.cs
index bc867cc8b9..b939517ac7 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/SqlFragmentExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/SqlFragmentExpression.cs
@@ -14,6 +14,8 @@ namespace Microsoft.EntityFrameworkCore.Query.SqlExpressions;
 /// </summary>
 public class SqlFragmentExpression : SqlExpression
 {
+    private static ConstructorInfo? _quotingConstructor;
+
     /// <summary>
     ///     Creates a new instance of the <see cref="SqlFragmentExpression" /> class.
     /// </summary>
@@ -33,6 +35,12 @@ public SqlFragmentExpression(string sql)
     protected override Expression VisitChildren(ExpressionVisitor visitor)
         => this;
 
+    /// <inheritdoc />
+    public override Expression Quote()
+        => New(
+            _quotingConstructor ??= typeof(SqlFragmentExpression).GetConstructor([typeof(string)])!,
+            Constant(Sql)); // TODO: The new type mapping once that's merged
+
     /// <inheritdoc />
     protected override void Print(ExpressionPrinter expressionPrinter)
         => expressionPrinter.Append(Sql);
diff --git a/src/EFCore.Relational/Query/SqlExpressions/SqlFunctionExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/SqlFunctionExpression.cs
index 0b4f646d44..29ef99a101 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/SqlFunctionExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/SqlFunctionExpression.cs
@@ -16,6 +16,8 @@ namespace Microsoft.EntityFrameworkCore.Query.SqlExpressions;
 /// </summary>
 public class SqlFunctionExpression : SqlExpression
 {
+    private static ConstructorInfo? _quotingConstructor;
+
     /// <summary>
     ///     Creates a new instance of the <see cref="SqlFunctionExpression" /> class which represents a built-in niladic function.
     /// </summary>
@@ -328,6 +330,31 @@ public virtual SqlFunctionExpression Update(SqlExpression? instance, IReadOnlyLi
                 TypeMapping)
             : this;
 
+    /// <inheritdoc />
+    public override Expression Quote()
+        => New(
+            _quotingConstructor ??= typeof(SqlFunctionExpression).GetConstructor(
+            [
+                typeof(SqlExpression), typeof(string), typeof(string), typeof(bool), typeof(IEnumerable<SqlExpression>),
+                typeof(bool), typeof(bool), typeof(IEnumerable<bool>), typeof(bool), typeof(Type), typeof(RelationalTypeMapping)
+            ])!,
+            RelationalExpressionQuotingUtilities.VisitOrNull(Instance),
+            Constant(Schema, typeof(string)),
+            Constant(Name),
+            Constant(IsNiladic),
+            Arguments is null
+                ? Constant(null, typeof(IEnumerable<SqlExpression>))
+                : NewArrayInit(typeof(SqlExpression), initializers: Arguments.Select(a => a.Quote())),
+            Constant(IsNullable),
+            Constant(InstancePropagatesNullability, typeof(bool?)),
+            ArgumentsPropagateNullability is null
+                ? Constant(null, typeof(IEnumerable<bool>))
+                : NewArrayInit(
+                    typeof(bool), initializers: ArgumentsPropagateNullability.Select(n => Constant(n))),
+            Constant(IsBuiltIn),
+            Constant(Type),
+            RelationalExpressionQuotingUtilities.QuoteTypeMapping(TypeMapping));
+
     /// <inheritdoc />
     protected override void Print(ExpressionPrinter expressionPrinter)
     {
diff --git a/src/EFCore.Relational/Query/SqlExpressions/SqlParameterExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/SqlParameterExpression.cs
index d53f50bbae..4046967176 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/SqlParameterExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/SqlParameterExpression.cs
@@ -8,6 +8,8 @@ namespace Microsoft.EntityFrameworkCore.Query.SqlExpressions;
 /// </summary>
 public sealed class SqlParameterExpression : SqlExpression
 {
+    private static ConstructorInfo? _quotingConstructor;
+
     /// <summary>
     ///     Creates a new instance of the <see cref="SqlParameterExpression" /> class.
     /// </summary>
@@ -48,6 +50,15 @@ public SqlExpression ApplyTypeMapping(RelationalTypeMapping? typeMapping)
     protected override Expression VisitChildren(ExpressionVisitor visitor)
         => this;
 
+    /// <inheritdoc />
+    public override Expression Quote()
+        => New(
+            _quotingConstructor ??= typeof(SqlParameterExpression).GetConstructor(
+                [typeof(string), typeof(Type), typeof(RelationalTypeMapping) ])!, // TODO: There's a dead IsNullable there...
+            Constant(Name, typeof(string)),
+            Constant(Type),
+            RelationalExpressionQuotingUtilities.QuoteTypeMapping(TypeMapping));
+
     /// <inheritdoc />
     protected override void Print(ExpressionPrinter expressionPrinter)
         => expressionPrinter.Append("@" + Name);
diff --git a/src/EFCore.Relational/Query/SqlExpressions/SqlUnaryExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/SqlUnaryExpression.cs
index 8b2b34f5d6..30950d8c91 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/SqlUnaryExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/SqlUnaryExpression.cs
@@ -14,6 +14,8 @@ namespace Microsoft.EntityFrameworkCore.Query.SqlExpressions;
 /// </summary>
 public class SqlUnaryExpression : SqlExpression
 {
+    private static ConstructorInfo? _quotingConstructor;
+
     private static readonly ISet<ExpressionType> AllowedOperators = new HashSet<ExpressionType>
     {
         ExpressionType.Equal,
@@ -76,6 +78,16 @@ public virtual SqlUnaryExpression Update(SqlExpression operand)
             ? new SqlUnaryExpression(OperatorType, operand, Type, TypeMapping)
             : this;
 
+    /// <inheritdoc />
+    public override Expression Quote()
+        => New(
+            _quotingConstructor ??= typeof(SqlUnaryExpression).GetConstructor(
+                [typeof(ExpressionType), typeof(SqlExpression), typeof(Type), typeof(RelationalTypeMapping)])!,
+            Constant(OperatorType),
+            Operand.Quote(),
+            Constant(Type),
+            RelationalExpressionQuotingUtilities.QuoteTypeMapping(TypeMapping));
+
     /// <inheritdoc />
     protected override void Print(ExpressionPrinter expressionPrinter)
     {
diff --git a/src/EFCore.Relational/Query/SqlExpressions/TableExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/TableExpression.cs
index 7db678bfa2..828af3f201 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/TableExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/TableExpression.cs
@@ -15,12 +15,24 @@ namespace Microsoft.EntityFrameworkCore.Query.SqlExpressions;
 /// </remarks>
 public sealed class TableExpression : TableExpressionBase, ITableBasedExpression
 {
-    internal TableExpression(string alias, ITableBase table)
+    private static ConstructorInfo? _quotingConstructor;
+
+    /// <summary>
+    ///     Creates a new instance of the <see cref="TableExpression" /> class.
+    /// </summary>
+    public TableExpression(string alias, ITableBase table)
         : this(alias, table, annotations: null)
     {
     }
 
-    private TableExpression(string alias, ITableBase table, IReadOnlyDictionary<string, IAnnotation>? annotations)
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    [EntityFrameworkInternal]
+    public TableExpression(string alias, ITableBase table, IReadOnlyDictionary<string, IAnnotation>? annotations)
         : base(alias, annotations)
     {
         Name = table.Name;
@@ -53,6 +65,15 @@ public override string Alias
     ITableBase ITableBasedExpression.Table
         => Table;
 
+    /// <inheritdoc />
+    public override Expression Quote()
+        => New(
+            _quotingConstructor ??= typeof(TableExpression)
+                .GetConstructor([typeof(string), typeof(ITableBase), typeof(IReadOnlyDictionary<string, IAnnotation>)])!,
+            Constant(Alias, typeof(string)),
+            RelationalExpressionQuotingUtilities.QuoteTableBase(Table),
+            RelationalExpressionQuotingUtilities.QuoteAnnotations(Annotations));
+
     /// <inheritdoc />
     protected override void Print(ExpressionPrinter expressionPrinter)
     {
diff --git a/src/EFCore.Relational/Query/SqlExpressions/TableExpressionBase.cs b/src/EFCore.Relational/Query/SqlExpressions/TableExpressionBase.cs
index fea3f911f9..f2ba6f9451 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/TableExpressionBase.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/TableExpressionBase.cs
@@ -15,7 +15,7 @@ namespace Microsoft.EntityFrameworkCore.Query.SqlExpressions;
 ///     </para>
 /// </summary>
 [DebuggerDisplay("{Microsoft.EntityFrameworkCore.Query.ExpressionPrinter.Print(this), nq}")]
-public abstract class TableExpressionBase : Expression, IPrintableExpression
+public abstract class TableExpressionBase : Expression, IRelationalQuotableExpression, IPrintableExpression
 {
     /// <summary>
     ///     An indexed collection of annotations associated with this table expression.
@@ -85,6 +85,9 @@ public sealed override ExpressionType NodeType
     /// <param name="newAlias">The alias to apply to the returned <see cref="TableExpressionBase" />.</param>
     public abstract TableExpressionBase WithAlias(string newAlias);
 
+    /// <inheritdoc />
+    public abstract Expression Quote();
+
     /// <summary>
     ///     Creates a printable string representation of the given expression using <see cref="ExpressionPrinter" />.
     /// </summary>
diff --git a/src/EFCore.Relational/Query/SqlExpressions/TableValuedFunctionExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/TableValuedFunctionExpression.cs
index 996be3e476..784e00ac2a 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/TableValuedFunctionExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/TableValuedFunctionExpression.cs
@@ -16,6 +16,8 @@ namespace Microsoft.EntityFrameworkCore.Query.SqlExpressions;
 /// </summary>
 public class TableValuedFunctionExpression : TableExpressionBase, ITableBasedExpression
 {
+    private static ConstructorInfo? _quotingConstructor1, _quotingConstructor2;
+
     /// <summary>
     ///     Creates a new instance of the <see cref="TableValuedFunctionExpression" /> class.
     /// </summary>
@@ -153,6 +155,22 @@ protected override TableValuedFunctionExpression WithAnnotations(IReadOnlyDictio
     public override TableValuedFunctionExpression WithAlias(string newAlias)
         => new(newAlias, Name, Schema, IsBuiltIn, Arguments, Annotations);
 
+    /// <inheritdoc />
+    public override Expression Quote()
+        => StoreFunction is null
+            ? New(
+                _quotingConstructor1 ??= typeof(TableValuedFunctionExpression).GetConstructor(
+                    [typeof(string), typeof(string), typeof(IReadOnlyList<SqlExpression>)])!,
+                Constant(Alias, typeof(string)),
+                Constant(Name, typeof(string)),
+                NewArrayInit(typeof(SqlExpression), Arguments.Select(v => v.Quote())))
+            : New(
+                _quotingConstructor2 ??= typeof(TableValuedFunctionExpression).GetConstructor(
+                    [typeof(string), typeof(IStoreFunction), typeof(IReadOnlyList<SqlExpression>)])!,
+                Constant(Alias, typeof(string)),
+                RelationalExpressionQuotingUtilities.QuoteTableBase(StoreFunction),
+                NewArrayInit(typeof(SqlExpression), Arguments.Select(v => v.Quote())));
+
     /// <inheritdoc />
     protected override void Print(ExpressionPrinter expressionPrinter)
     {
diff --git a/src/EFCore.Relational/Query/SqlExpressions/UnionExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/UnionExpression.cs
index 7e49663ca0..16db24710f 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/UnionExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/UnionExpression.cs
@@ -14,6 +14,8 @@ namespace Microsoft.EntityFrameworkCore.Query.SqlExpressions;
 /// </summary>
 public class UnionExpression : SetOperationBase
 {
+    private static ConstructorInfo? _quotingConstructor;
+
     /// <summary>
     ///     Creates a new instance of the <see cref="UnionExpression" /> class.
     /// </summary>
@@ -77,6 +79,17 @@ public override TableExpressionBase Clone(string? alias, ExpressionVisitor cloni
     public override UnionExpression WithAlias(string newAlias)
         => new(newAlias, Source1, Source2, IsDistinct);
 
+    /// <inheritdoc />
+    public override Expression Quote()
+        => New(
+            _quotingConstructor ??= typeof(UnionExpression).GetConstructor(
+                [typeof(string), typeof(SelectExpression), typeof(SelectExpression), typeof(bool), typeof(IReadOnlyDictionary<string, IAnnotation>)])!,
+            Constant(Alias, typeof(string)),
+            Source1.Quote(),
+            Source2.Quote(),
+            Constant(IsDistinct),
+            RelationalExpressionQuotingUtilities.QuoteAnnotations(Annotations));
+
     /// <inheritdoc />
     protected override void Print(ExpressionPrinter expressionPrinter)
     {
diff --git a/src/EFCore.Relational/Query/SqlExpressions/UpdateExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/UpdateExpression.cs
index 3a59decd32..598f8be6df 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/UpdateExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/UpdateExpression.cs
@@ -12,8 +12,11 @@ namespace Microsoft.EntityFrameworkCore.Query.SqlExpressions;
 ///         not used in application code.
 ///     </para>
 /// </summary>
-public sealed class UpdateExpression : Expression, IPrintableExpression
+public sealed class UpdateExpression : Expression, IRelationalQuotableExpression, IPrintableExpression
 {
+    private static ConstructorInfo? _quotingConstructor;
+    private static ConstructorInfo? _columnValueSetterQuotingConstructor;
+
     /// <summary>
     ///     Creates a new instance of the <see cref="UpdateExpression" /> class.
     /// </summary>
@@ -119,6 +122,26 @@ public UpdateExpression Update(SelectExpression selectExpression, IReadOnlyList<
             ? new UpdateExpression(Table, selectExpression, columnValueSetters, Tags)
             : this;
 
+    /// <inheritdoc />
+    public Expression Quote()
+        => New(
+            _quotingConstructor ??= typeof(UpdateExpression).GetConstructor(
+            [
+                typeof(TableExpression), typeof(SelectExpression), typeof(IReadOnlyList<ColumnValueSetter>), typeof(ISet<string>)
+            ])!,
+            Table.Quote(),
+            SelectExpression.Quote(),
+            NewArrayInit(
+                typeof(ColumnValueSetter),
+                ColumnValueSetters
+                    .Select(
+                        s => New(
+                            _columnValueSetterQuotingConstructor ??=
+                                typeof(ColumnValueSetter).GetConstructor([typeof(ColumnExpression), typeof(SqlExpression)])!,
+                            s.Column.Quote(),
+                            s.Value.Quote()))),
+            RelationalExpressionQuotingUtilities.QuoteTags(Tags));
+
     /// <inheritdoc />
     public void Print(ExpressionPrinter expressionPrinter)
     {
diff --git a/src/EFCore.Relational/Query/SqlExpressions/ValuesExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/ValuesExpression.cs
index 86d4433436..f8a03726bf 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/ValuesExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/ValuesExpression.cs
@@ -16,6 +16,8 @@ namespace Microsoft.EntityFrameworkCore.Query.SqlExpressions;
 /// </summary>
 public class ValuesExpression : TableExpressionBase
 {
+    private static ConstructorInfo? _quotingConstructor;
+
     /// <summary>
     ///     The row values for this table.
     /// </summary>
@@ -32,13 +34,11 @@ public class ValuesExpression : TableExpressionBase
     /// <param name="alias">A string alias for the table source.</param>
     /// <param name="rowValues">The row values for this table.</param>
     /// <param name="columnNames">The names of the columns contained in this table.</param>
-    /// <param name="annotations">A collection of annotations associated with this expression.</param>
     public ValuesExpression(
         string? alias,
         IReadOnlyList<RowValueExpression> rowValues,
-        IReadOnlyList<string> columnNames,
-        IEnumerable<IAnnotation>? annotations = null)
-        : base(alias, annotations)
+        IReadOnlyList<string> columnNames)
+        : base(alias, annotations: (IReadOnlyDictionary<string, IAnnotation>?)null)
     {
         Check.DebugAssert(
             rowValues.All(rv => rv.Values.Count == columnNames.Count),
@@ -48,7 +48,14 @@ public class ValuesExpression : TableExpressionBase
         ColumnNames = columnNames;
     }
 
-    private ValuesExpression(
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    [EntityFrameworkInternal]
+    public ValuesExpression(
         string? alias,
         IReadOnlyList<RowValueExpression> rowValues,
         IReadOnlyList<string> columnNames,
@@ -93,6 +100,21 @@ protected override ValuesExpression WithAnnotations(IReadOnlyDictionary<string,
     public override ValuesExpression WithAlias(string newAlias)
         => new(newAlias, RowValues, ColumnNames, Annotations);
 
+    /// <inheritdoc />
+    public override Expression Quote()
+        => New(
+            _quotingConstructor ??= typeof(ValuesExpression).GetConstructor(
+            [
+                typeof(string),
+                typeof(IReadOnlyList<RowValueExpression>),
+                typeof(IReadOnlyList<string>),
+                typeof(IReadOnlyDictionary<string, IAnnotation>)
+            ])!,
+            Constant(Alias, typeof(string)),
+            NewArrayInit(typeof(RowValueExpression), RowValues.Select(rv => rv.Quote())),
+            NewArrayInit(typeof(string), ColumnNames.Select(Constant)),
+            RelationalExpressionQuotingUtilities.QuoteAnnotations(Annotations));
+
     /// <inheritdoc />
     public override TableExpressionBase Clone(string? alias, ExpressionVisitor cloningExpressionVisitor)
     {
diff --git a/src/EFCore.Relational/Query/SqlNullabilityProcessor.cs b/src/EFCore.Relational/Query/SqlNullabilityProcessor.cs
index edf9de630d..2f8e60bb01 100644
--- a/src/EFCore.Relational/Query/SqlNullabilityProcessor.cs
+++ b/src/EFCore.Relational/Query/SqlNullabilityProcessor.cs
@@ -557,7 +557,7 @@ protected virtual SqlExpression VisitCase(CaseExpression caseExpression, bool al
         // - if there is no Else block, return null
         if (whenClauses.Count == 0)
         {
-            return elseResult ?? _sqlExpressionFactory.Constant(null, caseExpression.TypeMapping);
+            return elseResult ?? _sqlExpressionFactory.Constant(null, caseExpression.Type, caseExpression.TypeMapping);
         }
 
         // if there is only one When clause and it's test evaluates to 'true' AND there is no else block, simply return the result
@@ -925,7 +925,7 @@ protected virtual SqlExpression VisitIn(InExpression inExpression, bool allowOpt
                         continue;
                     }
 
-                    processedValues.Add(_sqlExpressionFactory.Constant(value, typeMapping));
+                    processedValues.Add(_sqlExpressionFactory.Constant(value, value?.GetType() ?? typeof(object), typeMapping));
                 }
             }
             else
@@ -1415,7 +1415,7 @@ SqlExpression AddNullConcatenationProtection(SqlExpression argument, RelationalT
         nullable = ParameterValues[sqlParameterExpression.Name] == null;
 
         return nullable
-            ? _sqlExpressionFactory.Constant(null, sqlParameterExpression.TypeMapping)
+            ? _sqlExpressionFactory.Constant(null, sqlParameterExpression.Type, sqlParameterExpression.TypeMapping)
             : sqlParameterExpression;
     }
 
diff --git a/src/EFCore.SqlServer/EFCore.SqlServer.csproj b/src/EFCore.SqlServer/EFCore.SqlServer.csproj
index 8fe46778fc..9e23cff53e 100644
--- a/src/EFCore.SqlServer/EFCore.SqlServer.csproj
+++ b/src/EFCore.SqlServer/EFCore.SqlServer.csproj
@@ -9,6 +9,7 @@
     <GenerateDocumentationFile>true</GenerateDocumentationFile>
     <PackageTags>$(PackageTags);SQL Server</PackageTags>
     <ImplicitUsings>true</ImplicitUsings>
+    <NoWarn>EF1003</NoWarn> <!-- Precompiled query is experimental -->
   </PropertyGroup>
 
   <ItemGroup>
diff --git a/src/EFCore.SqlServer/Query/Internal/SqlServerAggregateFunctionExpression.cs b/src/EFCore.SqlServer/Query/Internal/SqlServerAggregateFunctionExpression.cs
index 3bd412e60e..5522799e3c 100644
--- a/src/EFCore.SqlServer/Query/Internal/SqlServerAggregateFunctionExpression.cs
+++ b/src/EFCore.SqlServer/Query/Internal/SqlServerAggregateFunctionExpression.cs
@@ -13,6 +13,8 @@ namespace Microsoft.EntityFrameworkCore.SqlServer.Query.Internal;
 /// </summary>
 public class SqlServerAggregateFunctionExpression : SqlExpression
 {
+    private static ConstructorInfo? _quotingConstructor;
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -173,6 +175,35 @@ public virtual SqlServerAggregateFunctionExpression ApplyTypeMapping(RelationalT
                     Type,
                     TypeMapping);
 
+    // string name,
+    //     IReadOnlyList<SqlExpression> arguments,
+    // IReadOnlyList<OrderingExpression> orderings,
+    // bool nullable,
+    //     IEnumerable<bool> argumentsPropagateNullability,
+    // Type type,
+    //     RelationalTypeMapping? typeMapping)
+
+    /// <inheritdoc />
+    public override Expression Quote()
+        => New(
+            _quotingConstructor ??= typeof(SqlServerAggregateFunctionExpression).GetConstructor(
+            [
+                typeof(string), typeof(IReadOnlyList<SqlExpression>), typeof(IReadOnlyList<OrderingExpression>), typeof(bool),
+                typeof(IEnumerable<bool>), typeof(Type), typeof(RelationalTypeMapping)
+            ])!,
+            Constant(Name),
+            Arguments is null
+                ? Constant(null, typeof(IEnumerable<SqlExpression>))
+                : NewArrayInit(typeof(SqlExpression), initializers: Arguments.Select(a => a.Quote())),
+            NewArrayInit(typeof(OrderingExpression), Orderings.Select(o => o.Quote())),
+            Constant(IsNullable),
+            ArgumentsPropagateNullability is null
+                ? Constant(null, typeof(IEnumerable<bool>))
+                : NewArrayInit(
+                    typeof(bool), initializers: ArgumentsPropagateNullability.Select(n => Constant(n))),
+            Constant(Type),
+            RelationalExpressionQuotingUtilities.QuoteTypeMapping(TypeMapping));
+
     /// <inheritdoc />
     protected override void Print(ExpressionPrinter expressionPrinter)
     {
diff --git a/src/EFCore.SqlServer/Query/Internal/SqlServerObjectToStringTranslator.cs b/src/EFCore.SqlServer/Query/Internal/SqlServerObjectToStringTranslator.cs
index 10d9b5da5b..6d345fd4cc 100644
--- a/src/EFCore.SqlServer/Query/Internal/SqlServerObjectToStringTranslator.cs
+++ b/src/EFCore.SqlServer/Query/Internal/SqlServerObjectToStringTranslator.cs
@@ -88,7 +88,7 @@ public SqlServerObjectToStringTranslator(ISqlExpressionFactory sqlExpressionFact
                             _sqlExpressionFactory.Equal(instance, _sqlExpressionFactory.Constant(true)),
                             _sqlExpressionFactory.Constant(true.ToString()))
                     },
-                    _sqlExpressionFactory.Constant(null));
+                    _sqlExpressionFactory.Constant(null, typeof(string)));
             }
 
             return _sqlExpressionFactory.Case(
diff --git a/src/EFCore.SqlServer/Query/Internal/SqlServerOpenJsonExpression.cs b/src/EFCore.SqlServer/Query/Internal/SqlServerOpenJsonExpression.cs
index c1bb4bacf6..d38442ea81 100644
--- a/src/EFCore.SqlServer/Query/Internal/SqlServerOpenJsonExpression.cs
+++ b/src/EFCore.SqlServer/Query/Internal/SqlServerOpenJsonExpression.cs
@@ -22,6 +22,8 @@ namespace Microsoft.EntityFrameworkCore.SqlServer.Query.Internal;
 /// </remarks>
 public class SqlServerOpenJsonExpression : TableValuedFunctionExpression
 {
+    private static ConstructorInfo? _quotingConstructor, _columnInfoQuotingConstructor;
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -172,6 +174,40 @@ public override TableExpressionBase Clone(string? alias, ExpressionVisitor cloni
     public override SqlServerOpenJsonExpression WithAlias(string newAlias)
         => new(newAlias, JsonExpression, Path, ColumnInfos);
 
+    /// <inheritdoc />
+    public override Expression Quote()
+        => New(
+            _quotingConstructor ??= typeof(SqlServerOpenJsonExpression).GetConstructor(
+            [
+                typeof(string),
+                typeof(SqlExpression),
+                typeof(IReadOnlyList<PathSegment>),
+                typeof(IReadOnlyList<ColumnInfo>)
+            ])!,
+            Constant(Alias, typeof(string)),
+            JsonExpression.Quote(),
+            Path is null
+                ? Constant(null, typeof(IReadOnlyList<PathSegment>))
+                : NewArrayInit(typeof(PathSegment), Path.Select(s => s.Quote())),
+            ColumnInfos is null
+                ? Constant(null, typeof(IReadOnlyList<ColumnInfo>))
+                : NewArrayInit(
+                    typeof(ColumnInfo), ColumnInfos.Select(
+                        ci => New(
+                            _columnInfoQuotingConstructor ??= typeof(ColumnInfo).GetConstructor(
+                            [
+                                typeof(string),
+                                typeof(RelationalTypeMapping),
+                                typeof(IReadOnlyList<PathSegment>),
+                                typeof(bool)
+                            ])!,
+                            Constant(ci.Name),
+                            RelationalExpressionQuotingUtilities.QuoteTypeMapping(ci.TypeMapping),
+                            ci.Path is null
+                                ? Constant(null, typeof(IReadOnlyList<PathSegment>))
+                                : NewArrayInit(typeof(PathSegment), ci.Path.Select(s => s.Quote())),
+                            Constant(ci.AsJson)))));
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
diff --git a/src/EFCore.SqlServer/Query/Internal/SqlServerSqlTranslatingExpressionVisitor.cs b/src/EFCore.SqlServer/Query/Internal/SqlServerSqlTranslatingExpressionVisitor.cs
index 345a3910bf..c3cb7f851b 100644
--- a/src/EFCore.SqlServer/Query/Internal/SqlServerSqlTranslatingExpressionVisitor.cs
+++ b/src/EFCore.SqlServer/Query/Internal/SqlServerSqlTranslatingExpressionVisitor.cs
@@ -227,7 +227,9 @@ protected override Expression VisitMethodCall(MethodCallExpression methodCallExp
                     // simple LIKE
                     translation = patternConstant.Value switch
                     {
-                        null => _sqlExpressionFactory.Like(translatedInstance, _sqlExpressionFactory.Constant(null, stringTypeMapping)),
+                        null => _sqlExpressionFactory.Like(
+                            translatedInstance,
+                            _sqlExpressionFactory.Constant(null, typeof(string), stringTypeMapping)),
 
                         // In .NET, all strings start with/end with/contain the empty string, but SQL LIKE return false for empty patterns.
                         // Return % which always matches instead.
diff --git a/src/EFCore.Sqlite.Core/EFCore.Sqlite.Core.csproj b/src/EFCore.Sqlite.Core/EFCore.Sqlite.Core.csproj
index 6597351343..4b82a88a40 100644
--- a/src/EFCore.Sqlite.Core/EFCore.Sqlite.Core.csproj
+++ b/src/EFCore.Sqlite.Core/EFCore.Sqlite.Core.csproj
@@ -10,6 +10,7 @@
     <GenerateDocumentationFile>true</GenerateDocumentationFile>
     <PackageTags>$(PackageTags);SQLite</PackageTags>
     <ImplicitUsings>true</ImplicitUsings>
+    <NoWarn>EF1003</NoWarn> <!-- Precompiled query is experimental -->
   </PropertyGroup>
 
   <ItemGroup>
diff --git a/src/EFCore.Sqlite.Core/Query/Internal/SqliteObjectToStringTranslator.cs b/src/EFCore.Sqlite.Core/Query/Internal/SqliteObjectToStringTranslator.cs
index cf2e933130..2911c5b004 100644
--- a/src/EFCore.Sqlite.Core/Query/Internal/SqliteObjectToStringTranslator.cs
+++ b/src/EFCore.Sqlite.Core/Query/Internal/SqliteObjectToStringTranslator.cs
@@ -85,7 +85,7 @@ public SqliteObjectToStringTranslator(ISqlExpressionFactory sqlExpressionFactory
                             _sqlExpressionFactory.Equal(instance, _sqlExpressionFactory.Constant(true)),
                             _sqlExpressionFactory.Constant(true.ToString()))
                     },
-                    _sqlExpressionFactory.Constant(null));
+                    _sqlExpressionFactory.Constant(null, typeof(string)));
             }
 
             return _sqlExpressionFactory.Case(
diff --git a/src/EFCore.Sqlite.Core/Query/Internal/SqliteQuerySqlGenerator.cs b/src/EFCore.Sqlite.Core/Query/Internal/SqliteQuerySqlGenerator.cs
index 3868ed9ae4..f92325f70b 100644
--- a/src/EFCore.Sqlite.Core/Query/Internal/SqliteQuerySqlGenerator.cs
+++ b/src/EFCore.Sqlite.Core/Query/Internal/SqliteQuerySqlGenerator.cs
@@ -80,7 +80,7 @@ protected override void GenerateLimitOffset(SelectExpression selectExpression)
 
             Visit(
                 selectExpression.Limit
-                ?? new SqlConstantExpression(Expression.Constant(-1), selectExpression.Offset!.TypeMapping));
+                ?? new SqlConstantExpression(-1, selectExpression.Offset!.TypeMapping));
 
             if (selectExpression.Offset != null)
             {
diff --git a/src/EFCore.Sqlite.Core/Query/Internal/SqliteSqlTranslatingExpressionVisitor.cs b/src/EFCore.Sqlite.Core/Query/Internal/SqliteSqlTranslatingExpressionVisitor.cs
index 6c8b084f75..5698691db6 100644
--- a/src/EFCore.Sqlite.Core/Query/Internal/SqliteSqlTranslatingExpressionVisitor.cs
+++ b/src/EFCore.Sqlite.Core/Query/Internal/SqliteSqlTranslatingExpressionVisitor.cs
@@ -292,7 +292,9 @@ protected override Expression VisitMethodCall(MethodCallExpression methodCallExp
                     // simple LIKE
                     translation = patternConstant.Value switch
                     {
-                        null => _sqlExpressionFactory.Like(translatedInstance, _sqlExpressionFactory.Constant(null, stringTypeMapping)),
+                        null => _sqlExpressionFactory.Like(
+                            translatedInstance,
+                            _sqlExpressionFactory.Constant(null, typeof(string), stringTypeMapping)),
 
                         // In .NET, all strings start with/end with/contain the empty string, but SQL LIKE return false for empty patterns.
                         // Return % which always matches instead.
diff --git a/src/EFCore.Sqlite.Core/Query/SqlExpressions/Internal/GlobExpression.cs b/src/EFCore.Sqlite.Core/Query/SqlExpressions/Internal/GlobExpression.cs
index 1901cd67b4..7f852959e9 100644
--- a/src/EFCore.Sqlite.Core/Query/SqlExpressions/Internal/GlobExpression.cs
+++ b/src/EFCore.Sqlite.Core/Query/SqlExpressions/Internal/GlobExpression.cs
@@ -13,6 +13,8 @@ namespace Microsoft.EntityFrameworkCore.Sqlite.Query.SqlExpressions.Internal;
 /// </summary>
 public class GlobExpression : SqlExpression
 {
+    private static ConstructorInfo? _quotingConstructor;
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -76,6 +78,15 @@ public virtual GlobExpression Update(SqlExpression match, SqlExpression pattern)
             ? new GlobExpression(match, pattern, TypeMapping)
             : this;
 
+    /// <inheritdoc />
+    public override Expression Quote()
+        => New(
+            _quotingConstructor ??= typeof(GlobExpression).GetConstructor(
+                [typeof(SqlExpression), typeof(SqlExpression), typeof(RelationalTypeMapping)])!,
+            Match.Quote(),
+            Pattern.Quote(),
+            RelationalExpressionQuotingUtilities.QuoteTypeMapping(TypeMapping));
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
diff --git a/src/EFCore.Sqlite.Core/Query/SqlExpressions/Internal/JsonEachExpression.cs b/src/EFCore.Sqlite.Core/Query/SqlExpressions/Internal/JsonEachExpression.cs
index 741e85bdef..d2cfa45526 100644
--- a/src/EFCore.Sqlite.Core/Query/SqlExpressions/Internal/JsonEachExpression.cs
+++ b/src/EFCore.Sqlite.Core/Query/SqlExpressions/Internal/JsonEachExpression.cs
@@ -21,6 +21,8 @@ namespace Microsoft.EntityFrameworkCore.Sqlite.Query.SqlExpressions.Internal;
 /// </remarks>
 public class JsonEachExpression : TableValuedFunctionExpression
 {
+    private static ConstructorInfo? _quotingConstructor;
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -146,6 +148,21 @@ public override TableExpressionBase Clone(string? alias, ExpressionVisitor cloni
     public override JsonEachExpression WithAlias(string newAlias)
         => new(newAlias, JsonExpression, Path);
 
+    /// <inheritdoc />
+    public override Expression Quote()
+        => New(
+            _quotingConstructor ??= typeof(JsonEachExpression).GetConstructor(
+            [
+                typeof(string),
+                typeof(SqlExpression),
+                typeof(IReadOnlyList<PathSegment>)
+            ])!,
+            Constant(Alias, typeof(string)),
+            JsonExpression.Quote(),
+            Path is null
+                ? Constant(null, typeof(IReadOnlyList<PathSegment>))
+                : NewArrayInit(typeof(PathSegment), Path.Select(s => s.Quote())));
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
diff --git a/src/EFCore.Sqlite.Core/Query/SqlExpressions/Internal/RegexpExpression.cs b/src/EFCore.Sqlite.Core/Query/SqlExpressions/Internal/RegexpExpression.cs
index 101cced8c7..69aa51cb6c 100644
--- a/src/EFCore.Sqlite.Core/Query/SqlExpressions/Internal/RegexpExpression.cs
+++ b/src/EFCore.Sqlite.Core/Query/SqlExpressions/Internal/RegexpExpression.cs
@@ -13,6 +13,8 @@ namespace Microsoft.EntityFrameworkCore.Sqlite.Query.SqlExpressions.Internal;
 /// </summary>
 public class RegexpExpression : SqlExpression
 {
+    private static ConstructorInfo? _quotingConstructor;
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -76,6 +78,15 @@ public virtual RegexpExpression Update(SqlExpression match, SqlExpression patter
             ? new RegexpExpression(match, pattern, TypeMapping)
             : this;
 
+    /// <inheritdoc />
+    public override Expression Quote()
+        => New(
+            _quotingConstructor ??= typeof(RegexpExpression).GetConstructor(
+                [typeof(SqlExpression), typeof(SqlExpression), typeof(RelationalTypeMapping)])!,
+            Match.Quote(),
+            Pattern.Quote(),
+            RelationalExpressionQuotingUtilities.QuoteTypeMapping(TypeMapping));
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
diff --git a/test/EFCore.Relational.Specification.Tests/Query/UdfDbFunctionTestBase.cs b/test/EFCore.Relational.Specification.Tests/Query/UdfDbFunctionTestBase.cs
index 9f5874e89c..3c36b6b72a 100644
--- a/test/EFCore.Relational.Specification.Tests/Query/UdfDbFunctionTestBase.cs
+++ b/test/EFCore.Relational.Specification.Tests/Query/UdfDbFunctionTestBase.cs
@@ -292,9 +292,9 @@ protected override void OnModelCreating(ModelBuilder modelBuilder)
                         args.First(),
                         new[]
                         {
-                            new SqlConstantExpression(Expression.Constant(abc[0]), typeMapping: null),
-                            new SqlConstantExpression(Expression.Constant(abc[1]), typeMapping: null),
-                            new SqlConstantExpression(Expression.Constant(abc[2]), typeMapping: null)
+                            new SqlConstantExpression(abc[0], typeMapping: null),
+                            new SqlConstantExpression(abc[1], typeMapping: null),
+                            new SqlConstantExpression(abc[2], typeMapping: null)
                         }, // args.First().TypeMapping)
                         typeMapping: null));
 
@@ -306,15 +306,15 @@ protected override void OnModelCreating(ModelBuilder modelBuilder)
                             args.First(),
                             new[]
                             {
-                                new SqlConstantExpression(Expression.Constant(abc[0]), args.First().TypeMapping),
-                                new SqlConstantExpression(Expression.Constant(abc[1]), args.First().TypeMapping),
-                                new SqlConstantExpression(Expression.Constant(abc[2]), args.First().TypeMapping)
+                                new SqlConstantExpression(abc[0], args.First().TypeMapping),
+                                new SqlConstantExpression(abc[1], args.First().TypeMapping),
+                                new SqlConstantExpression(abc[2], args.First().TypeMapping)
                             },
                             typeMapping: null),
                         new[]
                         {
-                            new SqlConstantExpression(Expression.Constant(trueFalse[0]), typeMapping: null),
-                            new SqlConstantExpression(Expression.Constant(trueFalse[1]), typeMapping: null)
+                            new SqlConstantExpression(trueFalse[0], typeMapping: null),
+                            new SqlConstantExpression(trueFalse[1], typeMapping: null)
                         },
                         typeMapping: null));
 
diff --git a/test/EFCore.Relational.Tests/Infrastructure/RelationalEventIdTest.cs b/test/EFCore.Relational.Tests/Infrastructure/RelationalEventIdTest.cs
index b86ccd379e..2c5943573b 100644
--- a/test/EFCore.Relational.Tests/Infrastructure/RelationalEventIdTest.cs
+++ b/test/EFCore.Relational.Tests/Infrastructure/RelationalEventIdTest.cs
@@ -126,6 +126,9 @@ public FakeSqlExpression()
         {
         }
 
+        public override Expression Quote()
+            => throw new NotSupportedException();
+
         protected override void Print(ExpressionPrinter expressionPrinter)
             => expressionPrinter.Append("FakeSqlExpression");
     }
