diff --git a/src/EFCore.Relational/Query/RelationalQueryableMethodTranslatingExpressionVisitor.CreateSelect.cs b/src/EFCore.Relational/Query/RelationalQueryableMethodTranslatingExpressionVisitor.CreateSelect.cs
index 502b716f49..53cbe8b7bf 100644
--- a/src/EFCore.Relational/Query/RelationalQueryableMethodTranslatingExpressionVisitor.CreateSelect.cs
+++ b/src/EFCore.Relational/Query/RelationalQueryableMethodTranslatingExpressionVisitor.CreateSelect.cs
@@ -215,7 +215,8 @@ SelectExpression CreateRootSelectExpressionCore(IEntityType entityType)
                                     discriminatorColumnName));
                             discriminatorValues.Add(concreteEntityType.ShortName());
 
-                            subSelectExpressions.Add(SelectExpression.CreateImmutable(alias: null!, [tableExpression], projections));
+                            subSelectExpressions.Add(
+                                SelectExpression.CreateImmutable(alias: null!, [tableExpression], projections, _sqlAliasManager));
                         }
 
                         var tpcTableAlias = _sqlAliasManager.GenerateTableAlias("union");
diff --git a/src/EFCore.Relational/Query/SqlExpressions/SelectExpression.Helper.cs b/src/EFCore.Relational/Query/SqlExpressions/SelectExpression.Helper.cs
index 52fbb0b74b..94ab66a782 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/SelectExpression.Helper.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/SelectExpression.Helper.cs
@@ -379,7 +379,7 @@ private sealed class CloningExpressionVisitor(SqlAliasManager? sqlAliasManager,
         }
     }
 
-    private sealed class TpcTableExpressionRemovingExpressionVisitor : ExpressionVisitor
+    private sealed class TpcTableExpressionRemovingExpressionVisitor(SqlAliasManager sqlAliasManager) : ExpressionVisitor
     {
         protected override Expression VisitExtension(Expression expression)
         {
@@ -485,7 +485,7 @@ protected override Expression VisitExtension(Expression expression)
                                 CreateColumnExpression(projection, tpcTablesExpression.Alias), projection.Alias));
                     }
 
-                    result = CreateImmutable(alias: null!, tables: [unionExpression], projections);
+                    result = CreateImmutable(alias: null!, tables: [unionExpression], projections, sqlAliasManager);
                 }
 
                 if (identitySelect)
diff --git a/src/EFCore.Relational/Query/SqlExpressions/SelectExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/SelectExpression.cs
index 94021bf7a7..5a62c84fd2 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/SelectExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/SelectExpression.cs
@@ -73,7 +73,7 @@ public sealed partial class SelectExpression : TableExpressionBase
         SqlExpression? limit,
         ISet<string> tags,
         IReadOnlyDictionary<string, IAnnotation>? annotations,
-        SqlAliasManager? sqlAliasManager,
+        SqlAliasManager sqlAliasManager,
         bool isMutable)
         : base(alias, annotations)
     {
@@ -91,7 +91,7 @@ public sealed partial class SelectExpression : TableExpressionBase
         Tags = tags;
         IsMutable = isMutable;
 
-        _sqlAliasManager = sqlAliasManager!;
+        _sqlAliasManager = sqlAliasManager;
     }
 
     /// <summary>
@@ -112,11 +112,12 @@ public sealed partial class SelectExpression : TableExpressionBase
         IReadOnlyList<OrderingExpression> orderings,
         SqlExpression? offset,
         SqlExpression? limit,
+        SqlAliasManager sqlAliasManager,
         IReadOnlySet<string>? tags = null,
         IReadOnlyDictionary<string, IAnnotation>? annotations = null)
         : this(
             alias, tables.ToList(), predicate, groupBy.ToList(), having, projections.ToList(), distinct, orderings.ToList(),
-            offset, limit, tags?.ToHashSet() ?? [], annotations, sqlAliasManager: null, isMutable: false)
+            offset, limit, tags?.ToHashSet() ?? [], annotations, sqlAliasManager, isMutable: false)
     {
     }
 
@@ -177,11 +178,15 @@ public SelectExpression(SqlExpression projection, SqlAliasManager sqlAliasManage
     // Immutable selects no longer need to create tables, so no need for an alias manager (note that in the long term, SelectExpression
     // should have an alias manager at all, so this is temporary).
     [EntityFrameworkInternal]
-    public static SelectExpression CreateImmutable(string alias, List<TableExpressionBase> tables, List<ProjectionExpression> projection)
+    public static SelectExpression CreateImmutable(
+        string alias,
+        List<TableExpressionBase> tables,
+        List<ProjectionExpression> projection,
+        SqlAliasManager sqlAliasManager)
         => new(
             alias, tables, predicate: null, groupBy: [], having: null, projections: projection, distinct: false, orderings: [],
             offset: null, limit: null,
-            tags: new HashSet<string>(), sqlAliasManager: null, annotations: new Dictionary<string, IAnnotation>(),
+            tags: new HashSet<string>(), sqlAliasManager: sqlAliasManager, annotations: new Dictionary<string, IAnnotation>(),
             isMutable: false);
 
     /// <summary>
@@ -2353,7 +2358,8 @@ public void ApplyDefaultIfEmpty(ISqlExpressionFactory sqlExpressionFactory)
         var dummySelectExpression = CreateImmutable(
             _sqlAliasManager.GenerateTableAlias("empty"),
             tables: [],
-            [new ProjectionExpression(nullSqlExpression, "empty")]);
+            [new ProjectionExpression(nullSqlExpression, "empty")],
+            _sqlAliasManager);
 
         if (Orderings.Any()
             || Limit != null
@@ -3938,7 +3944,7 @@ private TableExpressionBase Clone(string? alias, ExpressionVisitor cloningExpres
     // TODO: Look into TPC handling and possibly clean this up, #32873
     [EntityFrameworkInternal]
     public SelectExpression RemoveTpcTableExpression()
-        => (SelectExpression)new TpcTableExpressionRemovingExpressionVisitor().Visit(this);
+        => (SelectExpression)new TpcTableExpressionRemovingExpressionVisitor(_sqlAliasManager).Visit(this);
 
     private Dictionary<ProjectionMember, int> ConvertProjectionMappingToClientProjections(
         Dictionary<ProjectionMember, Expression> projectionMapping,
@@ -4207,7 +4213,7 @@ protected override Expression VisitChildren(ExpressionVisitor visitor)
             {
                 var newSelectExpression = new SelectExpression(
                     Alias, newTables, predicate, newGroupBy, havingExpression, newProjections, IsDistinct, newOrderings, offset,
-                    limit, (IReadOnlySet<string>)Tags, Annotations)
+                    limit, _sqlAliasManager, (IReadOnlySet<string>)Tags, Annotations)
                 {
                     _clientProjections = _clientProjections, _projectionMapping = _projectionMapping
                 };
@@ -4323,7 +4329,7 @@ List<T> VisitList<T>(List<T> list, bool inPlace, out bool changed)
 
         var newSelectExpression = new SelectExpression(
             Alias, tables, predicate, groupBy, having, projections, IsDistinct, orderings, offset, limit,
-            (IReadOnlySet<string>)Tags, Annotations)
+            _sqlAliasManager, (IReadOnlySet<string>)Tags, Annotations)
         {
             _projectionMapping = projectionMapping, _clientProjections = _clientProjections.ToList()
         };
@@ -4366,6 +4372,7 @@ public override Expression Quote()
                 typeof(IReadOnlyList<OrderingExpression>), // orderings
                 typeof(SqlExpression), // offset
                 typeof(SqlExpression), // limit
+                typeof(SqlAliasManager), // SqlAliasManager
                 typeof(IReadOnlySet<string>), // tags
                 typeof(IReadOnlyDictionary<string, IAnnotation>) // annotations
             ])!,
@@ -4381,6 +4388,11 @@ public override Expression Quote()
             NewArrayInit(typeof(OrderingExpression), initializers: Orderings.Select(o => o.Quote())),
             RelationalExpressionQuotingUtilities.QuoteOrNull(Offset),
             RelationalExpressionQuotingUtilities.QuoteOrNull(Limit),
+            // TODO: SqlAliasManager is a required (non-nullable) parameter, but we'd need a complex liftable constant to make this work.
+            // The correct solution here is for SelectExpression to not need SqlAliasManager at all - actual query code that requires it
+            // should not live in SelectExpression, which should be a bare expression (#31049). In the meantime, setting null here means
+            // that precompiled queries which e.g. need to perform a pushdown in the 2nd part of the query pipeline fail (see #35507).
+            Constant(null, typeof(SqlAliasManager)),
             RelationalExpressionQuotingUtilities.QuoteTags(Tags),
             RelationalExpressionQuotingUtilities.QuoteAnnotations(Annotations));
 
diff --git a/src/EFCore.SqlServer/Query/Internal/SqlServerAggregateOverSubqueryPostprocessor.cs b/src/EFCore.SqlServer/Query/Internal/SqlServerAggregateOverSubqueryPostprocessor.cs
index 1322647c8e..5c36133960 100644
--- a/src/EFCore.SqlServer/Query/Internal/SqlServerAggregateOverSubqueryPostprocessor.cs
+++ b/src/EFCore.SqlServer/Query/Internal/SqlServerAggregateOverSubqueryPostprocessor.cs
@@ -147,7 +147,8 @@ protected override Expression VisitExtension(Expression node)
                             distinct: false,
                             orderings: Array.Empty<OrderingExpression>(),
                             offset: null,
-                            limit: null);
+                            limit: null,
+                            sqlAliasManager: sqlAliasManager);
 #pragma warning restore EF1001
                     }
 
diff --git a/test/EFCore.Cosmos.FunctionalTests/Query/NorthwindMiscellaneousQueryCosmosTest.cs b/test/EFCore.Cosmos.FunctionalTests/Query/NorthwindMiscellaneousQueryCosmosTest.cs
index e3d3a5ed16..49378dd26d 100644
--- a/test/EFCore.Cosmos.FunctionalTests/Query/NorthwindMiscellaneousQueryCosmosTest.cs
+++ b/test/EFCore.Cosmos.FunctionalTests/Query/NorthwindMiscellaneousQueryCosmosTest.cs
@@ -4984,6 +4984,14 @@ public override async Task Cast_to_object_over_parameter_directly_in_lambda(bool
         }
     }
 
+    public override async Task Late_subquery_pushdown(bool async)
+    {
+        // Uncorrelated subquery, not supported by Cosmos
+        await AssertTranslationFailed(() => base.Late_subquery_pushdown(async));
+
+        AssertSql();
+    }
+
     private void AssertSql(params string[] expected)
         => Fixture.TestSqlLoggerFactory.AssertBaseline(expected);
 
diff --git a/test/EFCore.Specification.Tests/Query/NorthwindMiscellaneousQueryTestBase.cs b/test/EFCore.Specification.Tests/Query/NorthwindMiscellaneousQueryTestBase.cs
index a9fb1c35e3..e530521327 100644
--- a/test/EFCore.Specification.Tests/Query/NorthwindMiscellaneousQueryTestBase.cs
+++ b/test/EFCore.Specification.Tests/Query/NorthwindMiscellaneousQueryTestBase.cs
@@ -5708,4 +5708,19 @@ public virtual Task Cast_to_object_over_parameter_directly_in_lambda(bool async)
             async,
             ss => ss.Set<Order>().OrderBy(o => (object)i).Select(o => o));
     }
+
+    [ConditionalTheory] // #35507
+    [MemberData(nameof(IsAsyncData))]
+    public virtual Task Late_subquery_pushdown(bool async)
+        => AssertQuery(
+            async,
+            ss => ss.Set<Order>()
+                .Select(o => o.CustomerID)
+                .Where(
+                    a => ss
+                        .Set<Order>()
+                        .Select(o => o.CustomerID)
+                        .Order()
+                        .Take(100)
+                        .Contains(a)));
 }
diff --git a/test/EFCore.SqlServer.FunctionalTests/Query/NorthwindMiscellaneousQuerySqlServerTest.cs b/test/EFCore.SqlServer.FunctionalTests/Query/NorthwindMiscellaneousQuerySqlServerTest.cs
index 3b69024591..fa69cfcad7 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Query/NorthwindMiscellaneousQuerySqlServerTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Query/NorthwindMiscellaneousQuerySqlServerTest.cs
@@ -7258,6 +7258,25 @@ public override async Task Cast_to_object_over_parameter_directly_in_lambda(bool
 """);
     }
 
+    public override async Task Late_subquery_pushdown(bool async)
+    {
+        await base.Late_subquery_pushdown(async);
+
+        AssertSql(
+            """
+SELECT [o].[CustomerID]
+FROM [Orders] AS [o]
+WHERE EXISTS (
+    SELECT 1
+    FROM (
+        SELECT TOP(100) [o0].[CustomerID]
+        FROM [Orders] AS [o0]
+        ORDER BY [o0].[CustomerID]
+    ) AS [o1]
+    WHERE [o1].[CustomerID] = [o].[CustomerID] OR ([o1].[CustomerID] IS NULL AND [o].[CustomerID] IS NULL))
+""");
+    }
+
     private void AssertSql(params string[] expected)
         => Fixture.TestSqlLoggerFactory.AssertBaseline(expected);
 
