diff --git a/src/EFCore.Relational/Properties/RelationalStrings.Designer.cs b/src/EFCore.Relational/Properties/RelationalStrings.Designer.cs
index 88f4c3c55f..b7ef50f00f 100644
--- a/src/EFCore.Relational/Properties/RelationalStrings.Designer.cs
+++ b/src/EFCore.Relational/Properties/RelationalStrings.Designer.cs
@@ -1407,12 +1407,6 @@ public static string ParameterNotObjectArray(object? parameter)
         public static string PendingAmbientTransaction
             => GetString("PendingAmbientTransaction");
 
-        /// <summary>
-        ///     The query projects an entity mapped to JSON and accesses a JSON collection element. Such queries require 'AsNoTracking' option, even when the parent entity is projected.
-        /// </summary>
-        public static string ProjectingJsonCollectionElementRequiresNoTracking
-            => GetString("ProjectingJsonCollectionElementRequiresNoTracking");
-
         /// <summary>
         ///     Unable to translate set operations when both sides don't assign values to the same properties in the nominal type. Please make sure that the same properties are included on both sides, and consider assigning default values if a property doesn't require a specific value.
         /// </summary>
diff --git a/src/EFCore.Relational/Properties/RelationalStrings.resx b/src/EFCore.Relational/Properties/RelationalStrings.resx
index 68f6c2b698..d10d59b928 100644
--- a/src/EFCore.Relational/Properties/RelationalStrings.resx
+++ b/src/EFCore.Relational/Properties/RelationalStrings.resx
@@ -950,9 +950,6 @@
   <data name="PendingAmbientTransaction" xml:space="preserve">
     <value>This connection was used with an ambient transaction. The original ambient transaction needs to be completed before this connection can be used outside of it.</value>
   </data>
-  <data name="ProjectingJsonCollectionElementRequiresNoTracking" xml:space="preserve">
-    <value>The query projects an entity mapped to JSON and accesses a JSON collection element. Such queries require 'AsNoTracking' option, even when the parent entity is projected.</value>
-  </data>
   <data name="ProjectionMappingCountMismatch" xml:space="preserve">
     <value>Unable to translate set operations when both sides don't assign values to the same properties in the nominal type. Please make sure that the same properties are included on both sides, and consider assigning default values if a property doesn't require a specific value.</value>
   </data>
diff --git a/src/EFCore.Relational/Query/Internal/JsonProjectionInfo.cs b/src/EFCore.Relational/Query/Internal/JsonProjectionInfo.cs
new file mode 100644
index 0000000000..ca5f0555fa
--- /dev/null
+++ b/src/EFCore.Relational/Query/Internal/JsonProjectionInfo.cs
@@ -0,0 +1,70 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.EntityFrameworkCore.Query.Internal;
+
+/// <summary>
+///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+///     any release. You should only use it directly in your code with extreme caution and knowing that
+///     doing so can result in application failures when updating to a new Entity Framework Core release.
+/// </summary>
+public readonly struct JsonProjectionInfo
+{
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public JsonProjectionInfo(
+        int jsonColumnIndex,
+        List<(IProperty?, int?, int?)> keyAccessInfo,
+        (string?, int?, int?)[] additionalPath)
+    {
+        JsonColumnIndex = jsonColumnIndex;
+        KeyAccessInfo = keyAccessInfo;
+        AdditionalPath = additionalPath;
+    }
+
+    /// <summary>
+    ///     Projection index for json column name.
+    /// </summary>
+    /// <remarks>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </remarks>
+    public int JsonColumnIndex { get; }
+
+    /// <summary>
+    ///     Information needed to construct key values for the initial JSON entity:
+    ///
+    ///     - for key properties of the owner entity we store IProperty under KeyProperty
+    ///       and projection index of the key in the KeyProjectionIndex, ConstantKeyValue is null,
+    ///     - for constant array element access we store the value directly in ConstantKeyValue
+    ///       KeyProperty and KeyProjectionIndex are null,
+    ///     - for non-constant array element access we store it's projection index in KeyProjectionIndex
+    ///       KeyProperty and ConstantKeyValue are null.
+    /// </summary>
+    /// <remarks>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </remarks>
+    public List<(IProperty? KeyProperty, int? ConstantKeyValue, int? KeyProjectionIndex)> KeyAccessInfo { get; }
+
+    /// <summary>
+    ///     List of additional path elements, only one of the values in the tuple is non-null
+    ///     this information is used to access the correct sub-element of a JsonElement that we materialized
+    /// </summary>
+    /// <remarks>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </remarks>
+    public (string? JsonPropertyName, int? ConstantArrayIndex, int? NonConstantArrayIndex)[] AdditionalPath { get; }
+}
diff --git a/src/EFCore.Relational/Query/RelationalShapedQueryCompilingExpressionVisitor.ShaperProcessingExpressionVisitor.cs b/src/EFCore.Relational/Query/RelationalShapedQueryCompilingExpressionVisitor.ShaperProcessingExpressionVisitor.cs
index 3bab5a7589..63c775e2a9 100644
--- a/src/EFCore.Relational/Query/RelationalShapedQueryCompilingExpressionVisitor.ShaperProcessingExpressionVisitor.cs
+++ b/src/EFCore.Relational/Query/RelationalShapedQueryCompilingExpressionVisitor.ShaperProcessingExpressionVisitor.cs
@@ -4,6 +4,7 @@
 using System.Diagnostics.CodeAnalysis;
 using System.Runtime.CompilerServices;
 using System.Text.Json;
+using System.Text.Json.Nodes;
 using Microsoft.EntityFrameworkCore.Internal;
 using Microsoft.EntityFrameworkCore.Query.Internal;
 using Microsoft.EntityFrameworkCore.Query.SqlExpressions;
@@ -14,14 +15,18 @@ public partial class RelationalShapedQueryCompilingExpressionVisitor
 {
     private sealed partial class ShaperProcessingExpressionVisitor : ExpressionVisitor
     {
-        // Reading database values
+        /// <summary>
+        ///     Reading database values 
+        /// </summary>
         private static readonly MethodInfo IsDbNullMethod =
             typeof(DbDataReader).GetRuntimeMethod(nameof(DbDataReader.IsDBNull), new[] { typeof(int) })!;
 
         public static readonly MethodInfo GetFieldValueMethod =
             typeof(DbDataReader).GetRuntimeMethod(nameof(DbDataReader.GetFieldValue), new[] { typeof(int) })!;
 
-        // Coordinating results
+        /// <summary>
+        ///     Coordinating results 
+        /// </summary>
         private static readonly MemberInfo ResultContextValuesMemberInfo
             = typeof(ResultContext).GetMember(nameof(ResultContext.Values))[0];
 
@@ -34,6 +39,9 @@ private sealed partial class ShaperProcessingExpressionVisitor : ExpressionVisit
         private static readonly MethodInfo JsonElementGetPropertyMethod
             = typeof(JsonElement).GetMethod(nameof(JsonElement.GetProperty), new[] { typeof(string) })!;
 
+        private static readonly MethodInfo JsonElementGetItemMethodInfo
+            = typeof(JsonElement).GetMethod("get_Item", new[] { typeof(int) })!;
+
         private static readonly PropertyInfo _objectArrayIndexerPropertyInfo
             = typeof(object[]).GetProperty("Item")!;
 
@@ -43,6 +51,9 @@ private sealed partial class ShaperProcessingExpressionVisitor : ExpressionVisit
         private static readonly PropertyInfo _nullableJsonElementValuePropertyInfo
             = typeof(JsonElement?).GetProperty(nameof(Nullable<JsonElement>.Value))!;
 
+        private static readonly MethodInfo _arrayCopyMethodInfo
+            = typeof(Array).GetMethod(nameof(Array.Copy), new[] { typeof(Array), typeof(Array), typeof(int) })!;
+
         private readonly RelationalShapedQueryCompilingExpressionVisitor _parentVisitor;
         private readonly ISet<string>? _tags;
         private readonly bool _isTracking;
@@ -53,49 +64,83 @@ private sealed partial class ShaperProcessingExpressionVisitor : ExpressionVisit
         private readonly ParameterExpression _resultCoordinatorParameter;
         private readonly ParameterExpression? _executionStrategyParameter;
 
-        // States scoped to SelectExpression
+        /// <summary>
+        ///     States scoped to SelectExpression 
+        /// </summary>
         private readonly SelectExpression _selectExpression;
         private readonly ParameterExpression _dataReaderParameter;
         private readonly ParameterExpression _resultContextParameter;
         private readonly ParameterExpression? _indexMapParameter;
         private readonly ReaderColumn?[]? _readerColumns;
 
-        // States to materialize only once
+        /// <summary>
+        ///     States to materialize only once 
+        /// </summary>
         private readonly Dictionary<Expression, Expression> _variableShaperMapping = new(ReferenceEqualityComparer.Instance);
 
-        // There are always entity variables to avoid materializing same entity twice
+        /// <summary>
+        ///     There are always entity variables to avoid materializing same entity twice 
+        /// </summary>
         private readonly List<ParameterExpression> _variables = new();
 
         private readonly List<Expression> _expressions = new();
 
-        // IncludeExpressions are added at the end in case they are using ValuesArray
+        /// <summary>
+        ///     IncludeExpressions are added later in case they are using ValuesArray 
+        /// </summary>
         private readonly List<Expression> _includeExpressions = new();
 
-        // If there is collection shaper then we need to construct ValuesArray to store values temporarily in ResultContext
+        /// <summary>
+        ///     Json entities are added after includes so that we can utilize tracking (includes will track all json entities) 
+        /// </summary>
+        private readonly List<Expression> _jsonEntityExpressions = new();
+
+        /// <summary>
+        ///     If there is collection shaper then we need to construct ValuesArray to store values temporarily in ResultContext 
+        /// </summary>
         private List<Expression>? _collectionPopulatingExpressions;
         private Expression? _valuesArrayExpression;
         private List<Expression>? _valuesArrayInitializers;
 
         private bool _containsCollectionMaterialization;
 
-        // Since identifiers for collection are not part of larger lambda they don't cannot use caching to materialize only once.
+        /// <summary>
+        ///     Since identifiers for collection are not part of larger lambda they don't cannot use caching to materialize only once. 
+        /// </summary>
         private bool _inline;
         private int _collectionId;
 
-        // States to convert code to data reader read
+        /// <summary>
+        ///     States to convert code to data reader read 
+        /// </summary>
         private readonly Dictionary<ParameterExpression, IDictionary<IProperty, int>> _materializationContextBindings = new();
         private readonly Dictionary<ParameterExpression, object> _entityTypeIdentifyingExpressionInfo = new();
         private readonly Dictionary<ProjectionBindingExpression, string> _singleEntityTypeDiscriminatorValues = new();
 
-        private readonly Dictionary<ParameterExpression, (ParameterExpression, ParameterExpression)> _jsonValueBufferParameterMapping =
-            new();
+        private readonly Dictionary<ParameterExpression, (ParameterExpression, ParameterExpression)>
+            _jsonValueBufferParameterMapping = new();
 
         private readonly Dictionary<ParameterExpression, (ParameterExpression, ParameterExpression)>
             _jsonMaterializationContextParameterMapping = new();
 
-        private readonly Dictionary<(int, string[]), ParameterExpression> _existingJsonElementMap
+        /// <summary>
+        ///     Cache for the JsonElement values we have generated - storing variables that the JsonElements are assigned to  
+        /// </summary>
+        private readonly Dictionary<(int JsonColumnIndex, (string? JsonPropertyName, int? ConstantArrayIndex, int? NonConstantArrayIndex)[] AdditionalPath), ParameterExpression> _existingJsonElementMap
             = new(new ExisitingJsonElementMapKeyComparer());
 
+        /// <summary>
+        ///     Cache for the key values we have generated - storing variables that the keys are assigned to 
+        /// </summary>
+        private readonly Dictionary<(int JsonColumnIndex, (int? ConstantArrayIndex, int? NonConstantArrayIndex)[] AdditionalPath), ParameterExpression> _existingKeyValuesMap
+            = new(new ExisitingJsonKeyValuesMapKeyComparer());
+
+        /// <summary>
+        ///     Map between index of the non-constant json array element access
+        ///     and the variable we store it's value that we extract from the reader
+        /// </summary>
+        private readonly Dictionary<int, ParameterExpression> _jsonArrayNonConstantElementAccessMap = new();
+
         public ShaperProcessingExpressionVisitor(
             RelationalShapedQueryCompilingExpressionVisitor parentVisitor,
             SelectExpression selectExpression,
@@ -247,6 +292,7 @@ private sealed partial class ShaperProcessingExpressionVisitor : ExpressionVisit
             {
                 var result = Visit(shaperExpression);
                 _expressions.AddRange(_includeExpressions);
+                _expressions.AddRange(_jsonEntityExpressions);
                 _expressions.Add(result);
                 result = Expression.Block(_variables, _expressions);
 
@@ -280,6 +326,7 @@ private sealed partial class ShaperProcessingExpressionVisitor : ExpressionVisit
 
                 _expressions.Add(valueArrayInitializationExpression);
                 _expressions.AddRange(_includeExpressions);
+                _expressions.AddRange(_jsonEntityExpressions);
 
                 if (_splitQuery)
                 {
@@ -416,19 +463,12 @@ protected override Expression VisitExtension(Expression extensionExpression)
                 {
                     if (!_variableShaperMapping.TryGetValue(entityShaperExpression.ValueBufferExpression, out var accessor))
                     {
-                        if (GetProjectionIndex(projectionBindingExpression) is ValueTuple<int, List<(IProperty, int)>, string[], int>
-                            jsonProjectionIndex)
+                        if (GetProjectionIndex(projectionBindingExpression) is JsonProjectionInfo jsonProjectionInfo)
                         {
-                            if (_isTracking && jsonProjectionIndex.Item4 > 0)
-                            {
-                                throw new InvalidOperationException(RelationalStrings.ProjectingJsonCollectionElementRequiresNoTracking);
-                            }
-
                             // json entity at the root
                             var (jsonElementParameter, keyValuesParameter) = JsonShapingPreProcess(
-                                jsonProjectionIndex,
-                                entityShaperExpression.EntityType,
-                                isCollection: false);
+                                jsonProjectionInfo,
+                                entityShaperExpression.EntityType);
 
                             var shaperResult = CreateJsonShapers(
                                 entityShaperExpression.EntityType,
@@ -442,7 +482,7 @@ protected override Expression VisitExtension(Expression extensionExpression)
                             var visitedShaperResult = Visit(shaperResult);
                             var visitedShaperResultParameter = Expression.Parameter(visitedShaperResult.Type);
                             _variables.Add(visitedShaperResultParameter);
-                            _expressions.Add(Expression.Assign(visitedShaperResultParameter, visitedShaperResult));
+                            _jsonEntityExpressions.Add(Expression.Assign(visitedShaperResultParameter, visitedShaperResult));
                             accessor = visitedShaperResultParameter;
                         }
                         else
@@ -515,18 +555,12 @@ protected override Expression VisitExtension(Expression extensionExpression)
                 case CollectionResultExpression collectionResultExpression
                     when collectionResultExpression.Navigation is INavigation navigation
                     && GetProjectionIndex(collectionResultExpression.ProjectionBindingExpression)
-                        is ValueTuple<int, List<(IProperty, int)>, string[], int> jsonProjectionIndex:
+                        is JsonProjectionInfo jsonProjectionInfo:
                 {
-                    if (_isTracking && jsonProjectionIndex.Item4 > 0)
-                    {
-                        throw new InvalidOperationException(RelationalStrings.ProjectingJsonCollectionElementRequiresNoTracking);
-                    }
-
                     // json entity collection at the root
                     var (jsonElementParameter, keyValuesParameter) = JsonShapingPreProcess(
-                        jsonProjectionIndex,
-                        navigation.TargetEntityType,
-                        isCollection: true);
+                        jsonProjectionInfo,
+                        navigation.TargetEntityType);
 
                     var shaperResult = CreateJsonShapers(
                         navigation.TargetEntityType,
@@ -791,13 +825,11 @@ protected override Expression VisitExtension(Expression extensionExpression)
 
                         // json include case
                         if (projectionBindingExpression != null
-                            && GetProjectionIndex(projectionBindingExpression) is ValueTuple<int, List<(IProperty, int)>, string[], int>
-                                jsonProjectionIndex)
+                            && GetProjectionIndex(projectionBindingExpression) is JsonProjectionInfo jsonProjectionInfo)
                         {
                             var (jsonElementParameter, keyValuesParameter) = JsonShapingPreProcess(
-                                jsonProjectionIndex,
-                                includeExpression.Navigation.TargetEntityType,
-                                includeExpression.Navigation.IsCollection);
+                                jsonProjectionInfo,
+                                includeExpression.Navigation.TargetEntityType);
 
                             var shaperResult = CreateJsonShapers(
                                 includeExpression.Navigation.TargetEntityType,
@@ -1246,107 +1278,241 @@ protected override Expression VisitMethodCall(MethodCallExpression methodCallExp
         }
 
         private (ParameterExpression, ParameterExpression) JsonShapingPreProcess(
-            ValueTuple<int, List<(IProperty, int)>, string[], int> projectionIndex,
-            IEntityType entityType,
-            bool isCollection)
+            JsonProjectionInfo jsonProjectionInfo,
+            IEntityType entityType)
         {
-            var jsonColumnProjectionIndex = projectionIndex.Item1;
-            var keyInfo = projectionIndex.Item2;
-            var additionalPath = projectionIndex.Item3;
-            var specifiedCollectionIndexesCount = projectionIndex.Item4;
-
-            var keyValuesParameter = Expression.Parameter(typeof(object[]));
-            var keyValues = new Expression[keyInfo.Count + specifiedCollectionIndexesCount];
+            if (_existingJsonElementMap.TryGetValue(
+                (jsonProjectionInfo.JsonColumnIndex, jsonProjectionInfo.AdditionalPath),
+                out var finalJsonElementVariable))
+            {
+                // if we already cached JsonElement then key values are guaranteed to have been cached also, as they go in tandem
+                var fullPathCacheKey = jsonProjectionInfo.AdditionalPath.Select(x => (x.ConstantArrayIndex, x.NonConstantArrayIndex)).ToArray();
+                var finalKeyValuesVariable = _existingKeyValuesMap[(jsonProjectionInfo.JsonColumnIndex, fullPathCacheKey)];
+
+                // if the JsonElement variable for the full path is present in the cache,
+                // it means we already went through this process before
+                // and have already generated all the steps leading to the result
+                // i.e. we can safely return from the pre process
+                return (finalJsonElementVariable, finalKeyValuesVariable);
+            }
 
-            for (var i = 0; i < keyInfo.Count; i++)
+            var currentJsonElementVariable = default(ParameterExpression);
+            var currentKeyValuesVariable = default(ParameterExpression);
+            var additionalKeyGeneratedCount = 0;
+
+            // go through each segment in the additional path and generate JsonElement and key values
+            // store them in variables and cache them, so we can re-use it later if needed
+            // JsonElement needs to be generated for every path segment, as they are always different
+            // key values only changes if we access element of the array (as opposed to JSON property access)
+            for (var index = 0; index <= jsonProjectionInfo.AdditionalPath.Length; index++)
             {
-                var projection = _selectExpression.Projection[keyInfo[i].Item2];
+                var jsonElementCacheKey = jsonProjectionInfo.AdditionalPath[..index];
+                var keyValuesCacheKey = jsonProjectionInfo.AdditionalPath[..index].Select(x => (x.ConstantArrayIndex, x.NonConstantArrayIndex)).ToArray();
 
-                keyValues[i] = Expression.Convert(
-                    CreateGetValueExpression(
+                if (_existingJsonElementMap.TryGetValue(
+                    (jsonProjectionInfo.JsonColumnIndex, jsonElementCacheKey),
+                    out var existingJsonElementVariable))
+                {
+                    currentJsonElementVariable = existingJsonElementVariable;
+                    currentKeyValuesVariable = _existingKeyValuesMap[(jsonProjectionInfo.JsonColumnIndex, keyValuesCacheKey)];
+
+                    continue;
+                }
+
+                if (index == 0)
+                {
+                    // create the JsonElement for the initial entity
+                    var jsonElementValueExpression = CreateGetValueExpression(
                         _dataReaderParameter,
-                        keyInfo[i].Item2,
-                        IsNullableProjection(projection),
-                        projection.Expression.TypeMapping!,
-                        keyInfo[i].Item1.ClrType,
-                        keyInfo[i].Item1),
-                    typeof(object));
-            }
+                        jsonProjectionInfo.JsonColumnIndex,
+                        nullable: true,
+                        entityType.GetContainerColumnTypeMapping()!,
+                        typeof(JsonElement?),
+                        property: null);
 
-            for (var i = 0; i < specifiedCollectionIndexesCount; i++)
-            {
-                keyValues[keyInfo.Count + i] = Expression.Convert(
-                    Expression.Constant(0), typeof(object));
-            }
+                    currentJsonElementVariable = Expression.Variable(
+                        typeof(JsonElement?));
 
-            var keyValuesInitialize = Expression.NewArrayInit(typeof(object), keyValues);
-            var keyValuesAssignment = Expression.Assign(keyValuesParameter, keyValuesInitialize);
+                    var jsonElementAssignment = Expression.Assign(
+                        currentJsonElementVariable,
+                        jsonElementValueExpression);
 
-            _variables.Add(keyValuesParameter);
-            _expressions.Add(keyValuesAssignment);
+                    _variables.Add(currentJsonElementVariable);
+                    _expressions.Add(jsonElementAssignment);
 
-            var jsonColumnTypeMapping = entityType.GetContainerColumnTypeMapping()!;
-            if (_existingJsonElementMap.TryGetValue((jsonColumnProjectionIndex, additionalPath), out var exisitingJsonElementVariable))
-            {
-                return (exisitingJsonElementVariable, keyValuesParameter);
-            }
+                    var keyValues = new Expression[jsonProjectionInfo.KeyAccessInfo.Count];
+                    for (var i = 0; i < jsonProjectionInfo.KeyAccessInfo.Count; i++)
+                    {
+                        if (jsonProjectionInfo.KeyAccessInfo[i].ConstantKeyValue is int constant)
+                        {
+                            // if key access was a constant (and we have the actual value) add it directly to key values array
+                            // adding 1 to the value as we start keys from 1 and the array starts at 0
+                            keyValues[i] = Expression.Convert(
+                                Expression.Constant(constant + 1),
+                                typeof(object));
+                        }
+                        else if (jsonProjectionInfo.KeyAccessInfo[i].KeyProperty is IProperty keyProperty)
+                        {
+                            // if key value has IProperty, it must be a PK of the owner
+                            var projection = _selectExpression.Projection[jsonProjectionInfo.KeyAccessInfo[i].KeyProjectionIndex!.Value];
+                            keyValues[i] = Expression.Convert(
+                                CreateGetValueExpression(
+                                    _dataReaderParameter,
+                                    jsonProjectionInfo.KeyAccessInfo[i].KeyProjectionIndex!.Value,
+                                    IsNullableProjection(projection),
+                                    projection.Expression.TypeMapping!,
+                                    keyProperty.ClrType,
+                                    keyProperty),
+                                typeof(object));
+                        }
+                        else
+                        {
+                            // otherwise it must be non-constant array access and we stored it's projection index
+                            // extract the value from the projection (or the cache if we used it before)
+                            var collectionElementAccessParameter = ExtractAndCacheNonConstantJsonArrayElementAccessValue(
+                                jsonProjectionInfo.KeyAccessInfo[i].KeyProjectionIndex!.Value);
+
+                            keyValues[i] = Expression.Convert(
+                                Expression.Add(collectionElementAccessParameter, Expression.Constant(1, typeof(int?))),
+                                typeof(object));
+                        }
+                    }
 
-            // TODO: this logic could/should be improved (later)
-            var currentJsonElementVariable = default(ParameterExpression);
-            var index = 0;
-            do
-            {
-                // try to find JsonElement variable for this json column and path if we encountered (and cached it) before
-                // otherwise either create new JsonElement from the data reader if we are at root level
-                // or build on top of previous variable withing the navigation chain (e.g. when we encountered the root before, but not this entire path)
-                if (!_existingJsonElementMap.TryGetValue(
-                        (jsonColumnProjectionIndex, additionalPath[..index]), out var exisitingJsonElementVariable2))
+                    // create key values for initial entity
+                    currentKeyValuesVariable = Expression.Parameter(typeof(object[]));
+                    var keyValuesAssignment = Expression.Assign(
+                        currentKeyValuesVariable,
+                        Expression.NewArrayInit(typeof(object), keyValues));
+
+                    _variables.Add(currentKeyValuesVariable);
+                    _expressions.Add(keyValuesAssignment);
+
+                    _existingJsonElementMap[(jsonProjectionInfo.JsonColumnIndex, jsonElementCacheKey)] = currentJsonElementVariable;
+                    _existingKeyValuesMap[(jsonProjectionInfo.JsonColumnIndex, keyValuesCacheKey)] = currentKeyValuesVariable;
+                }
+                else
                 {
-                    var jsonElementVariable = Expression.Variable(
-                        typeof(JsonElement?));
+                    // create JsonElement for the additional path segment
+                    var currentPath = jsonProjectionInfo.AdditionalPath[index - 1];
 
-                    var jsonElementValueExpression = index == 0
-                        ? CreateGetValueExpression(
-                            _dataReaderParameter,
-                            jsonColumnProjectionIndex,
-                            nullable: true,
-                            jsonColumnTypeMapping,
-                            typeof(JsonElement?),
-                            property: null)
-                        : Expression.Condition(
+                    Expression jsonElementAccessExpressionFragment;
+                    if (currentPath.JsonPropertyName is string stringPath)
+                    {
+                        jsonElementAccessExpressionFragment = Expression.Call(
                             Expression.MakeMemberAccess(
                                 currentJsonElementVariable!,
-                                _nullableJsonElementHasValuePropertyInfo),
-                            Expression.Convert(
-                                Expression.Call(
-                                    Expression.MakeMemberAccess(
-                                        currentJsonElementVariable!,
-                                        _nullableJsonElementValuePropertyInfo),
-                                    JsonElementGetPropertyMethod,
-                                    Expression.Constant(additionalPath[index - 1])),
-                                currentJsonElementVariable!.Type),
-                            Expression.Default(currentJsonElementVariable!.Type));
+                                _nullableJsonElementValuePropertyInfo),
+                            JsonElementGetPropertyMethod,
+                            Expression.Constant(stringPath));
+                    }
+                    else
+                    {
+                        var elementAccessExpression = currentPath.ConstantArrayIndex is int constantElementAccess
+                            ? (Expression)Expression.Constant(constantElementAccess)
+                            : Expression.Convert(
+                                ExtractAndCacheNonConstantJsonArrayElementAccessValue(currentPath.NonConstantArrayIndex!.Value),
+                                typeof(int));
+
+                        jsonElementAccessExpressionFragment = Expression.Call(
+                            Expression.MakeMemberAccess(
+                                currentJsonElementVariable!,
+                                _nullableJsonElementValuePropertyInfo),
+                            JsonElementGetItemMethodInfo,
+                            elementAccessExpression);
+
+                        additionalKeyGeneratedCount++;
+                        if (_existingKeyValuesMap.TryGetValue((jsonProjectionInfo.JsonColumnIndex, keyValuesCacheKey), out var existingKeyValuesVariable))
+                        {
+                            currentKeyValuesVariable = existingKeyValuesVariable;
+                        }
+                        else
+                        {
+                            // create new array of size 1 more than current array (as we will be adding the extra key value)
+                            // copy values from current array and set the last remaining value
+                            var previousKeyValuesVariable = currentKeyValuesVariable;
+                            currentKeyValuesVariable = Expression.Parameter(typeof(object[]));
+
+                            var currentKeyValuesCount = jsonProjectionInfo.KeyAccessInfo.Count
+                                + additionalKeyGeneratedCount;
+
+                            var currentKeyValuesArrayInitAssignment = Expression.Assign(
+                                currentKeyValuesVariable,
+                                Expression.NewArrayBounds(
+                                    typeof(object),
+                                    Expression.Constant(currentKeyValuesCount)));
+
+                            var keyValuesArrayCopyFromPrevious = Expression.Call(
+                                _arrayCopyMethodInfo,
+                                previousKeyValuesVariable!,
+                                currentKeyValuesVariable!,
+                                Expression.Constant(currentKeyValuesCount - 1));
+
+                            var missingKeyValueAssignment = Expression.Assign(
+                                Expression.MakeIndex(
+                                    currentKeyValuesVariable,
+                                    _objectArrayIndexerPropertyInfo,
+                                    new[] { Expression.Constant(currentKeyValuesCount - 1) }),
+                                Expression.Convert(
+                                    Expression.Add(elementAccessExpression, Expression.Constant(1)),
+                                    typeof(object)));
+
+                            _variables.Add(currentKeyValuesVariable);
+                            _expressions.Add(currentKeyValuesArrayInitAssignment);
+                            _expressions.Add(keyValuesArrayCopyFromPrevious);
+                            _expressions.Add(missingKeyValueAssignment);
+                        }
+                    }
+
+                    var jsonElementValueExpression = Expression.Condition(
+                        Expression.MakeMemberAccess(
+                            currentJsonElementVariable!,
+                            _nullableJsonElementHasValuePropertyInfo),
+                        Expression.Convert(
+                            jsonElementAccessExpressionFragment,
+                            currentJsonElementVariable!.Type),
+                        Expression.Default(currentJsonElementVariable!.Type));
+
+                    currentJsonElementVariable = Expression.Variable(
+                        typeof(JsonElement?));
 
                     var jsonElementAssignment = Expression.Assign(
-                        jsonElementVariable,
+                        currentJsonElementVariable,
                         jsonElementValueExpression);
 
-                    _variables.Add(jsonElementVariable);
+                    _variables.Add(currentJsonElementVariable);
                     _expressions.Add(jsonElementAssignment);
-                    _existingJsonElementMap[(jsonColumnProjectionIndex, additionalPath[..index])] = jsonElementVariable;
-
-                    currentJsonElementVariable = jsonElementVariable;
                 }
-                else
+            }
+
+            return (currentJsonElementVariable!, currentKeyValuesVariable!);
+
+            ParameterExpression ExtractAndCacheNonConstantJsonArrayElementAccessValue(int index)
+            {
+                if (!_jsonArrayNonConstantElementAccessMap.TryGetValue(index, out var arrayElementAccessParameter))
                 {
-                    currentJsonElementVariable = exisitingJsonElementVariable2;
+                    arrayElementAccessParameter = Expression.Parameter(typeof(int?));
+                    var projection = _selectExpression.Projection[index];
+
+                    var arrayElementAccessValue = CreateGetValueExpression(
+                        _dataReaderParameter,
+                        index,
+                        IsNullableProjection(projection),
+                        projection.Expression.TypeMapping!,
+                        type: typeof(int?),
+                        property: null);
+
+                    var arrayElementAccessAssignment = Expression.Assign(
+                        arrayElementAccessParameter,
+                        arrayElementAccessValue);
+
+                    _variables.Add(arrayElementAccessParameter);
+                    _expressions.Add(arrayElementAccessAssignment);
+
+                    _jsonArrayNonConstantElementAccessMap.Add(index, arrayElementAccessParameter);
                 }
 
-                index++;
+                return arrayElementAccessParameter;
             }
-            while (index <= additionalPath.Length);
-
-            return (currentJsonElementVariable!, keyValuesParameter);
         }
 
         private static LambdaExpression GenerateFixup(
@@ -1665,13 +1831,32 @@ public bool ContainsCollectionMaterialization(Expression expression)
             }
         }
 
-        private sealed class ExisitingJsonElementMapKeyComparer : IEqualityComparer<(int, string[])>
+        private sealed class ExisitingJsonElementMapKeyComparer
+            : IEqualityComparer<(int JsonColumnIndex, (string? JsonPropertyName, int? ConstantArrayIndex, int? NonConstantArrayIndex)[] AdditionalPath)>
         {
-            public bool Equals((int, string[]) x, (int, string[]) y)
-                => x.Item1 == y.Item1 && x.Item2.Length == y.Item2.Length && x.Item2.SequenceEqual(y.Item2);
+            public bool Equals(
+                (int JsonColumnIndex, (string? JsonPropertyName, int? ConstantArrayIndex, int? NonConstantArrayIndex)[] AdditionalPath) x,
+                (int JsonColumnIndex, (string? JsonPropertyName, int? ConstantArrayIndex, int? NonConstantArrayIndex)[] AdditionalPath) y)
+                => x.JsonColumnIndex == y.JsonColumnIndex
+                    && x.AdditionalPath.Length == y.AdditionalPath.Length
+                    && x.AdditionalPath.SequenceEqual(y.AdditionalPath);
+
+            public int GetHashCode([DisallowNull] (int JsonColumnIndex, (string? JsonPropertyName, int? ConstantArrayIndex, int? NonConstantArrayIndex)[] AdditionalPath) obj)
+                => HashCode.Combine(obj.JsonColumnIndex, obj.AdditionalPath?.Length);
+        }
 
-            public int GetHashCode([DisallowNull] (int, string[]) obj)
-                => HashCode.Combine(obj.Item1, obj.Item2?.Length);
+        private sealed class ExisitingJsonKeyValuesMapKeyComparer
+            : IEqualityComparer<(int JsonColumnIndex, (int? ConstantArrayIndex, int? NonConstantArrayIndex)[] AdditionalPath)>
+        {
+            public bool Equals(
+                (int JsonColumnIndex, (int? ConstantArrayIndex, int? NonConstantArrayIndex)[] AdditionalPath) x,
+                (int JsonColumnIndex, (int? ConstantArrayIndex, int? NonConstantArrayIndex)[] AdditionalPath) y)
+                => x.JsonColumnIndex == y.JsonColumnIndex
+                    && x.AdditionalPath.Length == y.AdditionalPath.Length
+                    && x.AdditionalPath.SequenceEqual(y.AdditionalPath);
+
+            public int GetHashCode([DisallowNull] (int JsonColumnIndex, (int? ConstantArrayIndex, int? NonConstantArrayIndex)[] AdditionalPath) obj)
+                => HashCode.Combine(obj.JsonColumnIndex, obj.AdditionalPath?.Length);
         }
     }
 }
diff --git a/src/EFCore.Relational/Query/SqlExpressions/SelectExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/SelectExpression.cs
index 8ebd14a03b..3f353357a6 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/SelectExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/SelectExpression.cs
@@ -1529,15 +1529,19 @@ Expression CopyProjectionToOuter(SelectExpression innerSelectExpression, Express
 
                         remappedConstant = Constant(newDictionary);
                     }
-                    else if (constantValue is ValueTuple<int, List<(IProperty, int)>, string[], int> tuple)
+                    else if (constantValue is JsonProjectionInfo jsonProjectionInfo)
                     {
-                        var newList = new List<(IProperty, int)>();
-                        foreach (var item in tuple.Item2)
+                        var newKeyAccessInfo = new List<(IProperty?, int?, int?)>();
+                        foreach (var (keyProperty, constantKeyValue, keyProjectionIndex) in jsonProjectionInfo.KeyAccessInfo)
                         {
-                            newList.Add((item.Item1, projectionIndexMap[item.Item2]));
+                            newKeyAccessInfo.Add((keyProperty, constantKeyValue, keyProjectionIndex != null ? projectionIndexMap[keyProjectionIndex.Value] : null));
                         }
 
-                        remappedConstant = Constant((projectionIndexMap[tuple.Item1], newList, tuple.Item3, tuple.Item4));
+                        remappedConstant = Constant(
+                            new JsonProjectionInfo(
+                                jsonProjectionInfo.JsonColumnIndex,
+                                newKeyAccessInfo,
+                                jsonProjectionInfo.AdditionalPath));
                     }
                     else
                     {
@@ -1639,30 +1643,54 @@ ConstantExpression AddEntityProjection(EntityProjectionExpression entityProjecti
 
         ConstantExpression AddJsonProjection(JsonQueryExpression jsonQueryExpression, JsonScalarExpression jsonScalarToAdd)
         {
-            var additionalPath = Array.Empty<string>();
-
-            // TODO: change this when implementing #29513
-            // deduplication doesn't happen currently if the additional path contains indexes
-            Debug.Assert(jsonQueryExpression.Path.Skip(jsonScalarToAdd.Path.Count).All(x => x.PropertyName != null));
-
-            additionalPath = jsonQueryExpression.Path
+            var additionalPath = jsonQueryExpression.Path
                 .Skip(jsonScalarToAdd.Path.Count)
-                .Select(x => x.PropertyName!)
                 .ToArray();
 
             var jsonColumnIndex = AddToProjection(jsonScalarToAdd);
 
-            var keyInfo = new List<(IProperty, int)>();
+            var keyAccessInfo = new List<(IProperty?, int?, int?)>();
             var keyProperties = GetMappedKeyProperties(jsonQueryExpression.EntityType.FindPrimaryKey()!);
             foreach (var keyProperty in keyProperties)
             {
                 var keyColumn = jsonQueryExpression.BindProperty(keyProperty);
-                keyInfo.Add((keyProperty, AddToProjection(keyColumn)));
+                keyAccessInfo.Add((keyProperty, null, AddToProjection(keyColumn)));
             }
 
-            var specifiedCollectionIndexesCount = jsonScalarToAdd.Path.Count(x => x.ArrayIndex != null);
+            foreach (var elementAccessSegment in jsonScalarToAdd.Path.Where(x => x.ArrayIndex != null))
+            {
+                if (elementAccessSegment.ArrayIndex is SqlConstantExpression { Value: int intValue })
+                {
+                    keyAccessInfo.Add((null, intValue, null));
+                }
+                else
+                {
+                    keyAccessInfo.Add((null, null, AddToProjection(elementAccessSegment.ArrayIndex!)));
+                }
+            }
 
-            return Constant((jsonColumnIndex, keyInfo, additionalPath, specifiedCollectionIndexesCount));
+            var additionalPathList = new List<(string?, int?, int?)>();
+            foreach (var additionalPathSegment in additionalPath)
+            {
+                if (additionalPathSegment.PropertyName is not null)
+                {
+                    additionalPathList.Add((additionalPathSegment.PropertyName, null, null));
+                }
+                else if (additionalPathSegment.ArrayIndex is SqlConstantExpression { Value: int intValue } sqlConstant)
+                {
+                    additionalPathList.Add((null, intValue, null));
+                }
+                else
+                {
+                    additionalPathList.Add((null, null, AddToProjection(additionalPathSegment.ArrayIndex!)));
+                }
+            }
+
+            return Constant(
+                new JsonProjectionInfo(
+                    jsonColumnIndex,
+                    keyAccessInfo,
+                    additionalPathList.ToArray()));
         }
 
         static IReadOnlyList<IProperty> GetMappedKeyProperties(IKey key)
@@ -1703,15 +1731,7 @@ static bool JsonEntityContainedIn(JsonScalarExpression sourceExpression, JsonQue
                 return false;
             }
 
-            if (!sourcePath.SequenceEqual(targetPath.Take(sourcePath.Count)))
-            {
-                return false;
-            }
-
-            // we can only perform deduplication if there additional path doesn't contain any collection indexes
-            // collection indexes can only be part of the source path
-            // see issue #29513
-            return targetPath.Skip(sourcePath.Count).All(x => x.ArrayIndex == null);
+            return sourcePath.SequenceEqual(targetPath.Take(sourcePath.Count));
         }
     }
 
diff --git a/src/EFCore/Query/ExpressionPrinter.cs b/src/EFCore/Query/ExpressionPrinter.cs
index 514c158bcb..da2ee33dfc 100644
--- a/src/EFCore/Query/ExpressionPrinter.cs
+++ b/src/EFCore/Query/ExpressionPrinter.cs
@@ -292,6 +292,7 @@ public virtual void VisitCollection<T>(IReadOnlyCollection<T> items, Action<Expr
                 break;
 
             case ExpressionType.NewArrayInit:
+            case ExpressionType.NewArrayBounds:
                 VisitNewArray((NewArrayExpression)expression);
                 break;
 
@@ -794,6 +795,15 @@ protected override Expression VisitNew(NewExpression newExpression)
     /// <inheritdoc />
     protected override Expression VisitNewArray(NewArrayExpression newArrayExpression)
     {
+        if (newArrayExpression.NodeType == ExpressionType.NewArrayBounds)
+        {
+            Append("new " + newArrayExpression.Type.GetElementType()!.ShortDisplayName() + "[");
+            VisitArguments(newArrayExpression.Expressions, s => Append(s));
+            Append("]");
+
+            return newArrayExpression;
+        }
+
         var isComplex = newArrayExpression.Expressions.Count > 1;
         var appendAction = isComplex ? s => AppendLine(s) : (Action<string>)(s => Append(s));
 
diff --git a/test/EFCore.Relational.Specification.Tests/Query/JsonQueryTestBase.cs b/test/EFCore.Relational.Specification.Tests/Query/JsonQueryTestBase.cs
index 16a09aa36b..185f59e08e 100644
--- a/test/EFCore.Relational.Specification.Tests/Query/JsonQueryTestBase.cs
+++ b/test/EFCore.Relational.Specification.Tests/Query/JsonQueryTestBase.cs
@@ -1025,7 +1025,6 @@ public virtual Task Json_projection_deduplication_with_collection_indexer_in_tar
     {
         var prm = 1;
 
-        // issue #29513
         return AssertQuery(
             async,
             ss => ss.Set<JsonEntityBasic>().Select(x => new
@@ -1048,65 +1047,186 @@ public virtual Task Json_projection_deduplication_with_collection_indexer_in_tar
     [ConditionalTheory]
     [MemberData(nameof(IsAsyncData))]
     public virtual Task Json_projection_deduplication_with_collection_in_original_and_collection_indexer_in_target(bool async)
-        // issue #29513
-        => AssertQuery(
+    {
+        var prm = 1;
+
+        return AssertQuery(
             async,
             ss => ss.Set<JsonEntityBasic>().Select(x => new
             {
+                DuplicateMix = x.OwnedReferenceRoot.OwnedCollectionBranch[0].OwnedCollectionLeaf[prm],
+                DuplicatePrm = x.OwnedReferenceRoot.OwnedCollectionBranch[prm],
                 x.Id,
                 Original = x.OwnedReferenceRoot.OwnedCollectionBranch,
-                Duplicate = x.OwnedReferenceRoot.OwnedCollectionBranch[1],
+                DuplicateConstant = x.OwnedReferenceRoot.OwnedCollectionBranch[0],
             }).AsNoTracking(),
             elementSorter: e => e.Id,
             elementAsserter: (e, a) =>
             {
                 AssertEqual(e.Id, a.Id);
                 AssertCollection(e.Original, a.Original, ordered: true);
-                AssertEqual(e.Duplicate, a.Duplicate);
+                AssertEqual(e.DuplicatePrm, a.DuplicatePrm);
+                AssertEqual(e.DuplicateConstant, a.DuplicateConstant);
+                AssertEqual(e.DuplicateMix, a.DuplicateMix);
             });
+    }
+
+    [ConditionalTheory]
+    [MemberData(nameof(IsAsyncData))]
+    public virtual Task Json_collection_element_access_in_projection_using_constant_when_owner_is_present(bool async)
+        => AssertQuery(
+            async,
+            ss => ss.Set<JsonEntityBasic>().Select(x => new
+            {
+                x,
+                CollectionElement = x.OwnedCollectionRoot[1]
+            }),
+            elementSorter: e => e.x.Id,
+            elementAsserter: (e, a) =>
+            {
+                AssertEqual(e.x, a.x);
+                AssertEqual(e.CollectionElement, a.CollectionElement);
+            },
+            entryCount: 40);
 
     [ConditionalTheory]
     [MemberData(nameof(IsAsyncData))]
-    public virtual async Task Json_collection_element_access_in_projection_requires_NoTracking_even_if_owner_is_present(bool async)
+    public virtual Task Json_collection_element_access_in_projection_using_parameter_when_owner_is_present(bool async)
     {
-        var exception = await Assert.ThrowsAsync<InvalidOperationException>(
-            () => AssertQuery(
-                async,
-                ss => ss.Set<JsonEntityBasic>().Select(x => new
-                {
-                    x,
-                    CollectionElement = x.OwnedCollectionRoot[1]
-                }),
-                elementSorter: e => e.x.Id,
-                elementAsserter: (e, a) =>
-                {
-                    AssertEqual(e.x, a.x);
-                    AssertEqual(e.CollectionElement, a.CollectionElement);
-                }));
+        var prm = 1;
 
-        Assert.Equal(RelationalStrings.ProjectingJsonCollectionElementRequiresNoTracking, exception.Message);
+        return AssertQuery(
+            async,
+            ss => ss.Set<JsonEntityBasic>().Select(x => new
+            {
+                x,
+                CollectionElement = x.OwnedCollectionRoot[prm]
+            }),
+            elementSorter: e => e.x.Id,
+            elementAsserter: (e, a) =>
+            {
+                AssertEqual(e.x, a.x);
+                AssertEqual(e.CollectionElement, a.CollectionElement);
+            },
+            entryCount: 40);
     }
 
     [ConditionalTheory]
     [MemberData(nameof(IsAsyncData))]
-    public virtual async Task Json_collection_element_access_in_projection_requires_NoTracking_even_if_owner_is_present2(bool async)
+    public virtual Task Json_collection_after_collection_element_access_in_projection_using_constant_when_owner_is_present(bool async)
+        => AssertQuery(
+            async,
+            ss => ss.Set<JsonEntityBasic>().Select(x => new
+            {
+                x,
+                Collection = x.OwnedCollectionRoot[1].OwnedCollectionBranch
+            }),
+            elementSorter: e => e.x.Id,
+            elementAsserter: (e, a) =>
+            {
+                AssertEqual(e.x, a.x);
+                AssertCollection(e.Collection, a.Collection, ordered: true);
+            },
+            entryCount: 40);
+
+    [ConditionalTheory]
+    [MemberData(nameof(IsAsyncData))]
+    public virtual Task Json_collection_after_collection_element_access_in_projection_using_parameter_when_owner_is_present(bool async)
     {
-        var message = (await Assert.ThrowsAsync<InvalidOperationException>(
-            () => AssertQuery(
-                async,
-                ss => ss.Set<JsonEntityBasic>().Select(x => new
-                {
-                    x,
-                    CollectionElement = x.OwnedCollectionRoot[1].OwnedReferenceBranch
-                }),
-                elementSorter: e => e.x.Id,
-                elementAsserter: (e, a) =>
-                {
-                    AssertEqual(e.x, a.x);
-                    AssertEqual(e.CollectionElement, a.CollectionElement);
-                }))).Message;
+        var prm = 1;
+
+        return AssertQuery(
+            async,
+            ss => ss.Set<JsonEntityBasic>().Select(x => new
+            {
+                x,
+                Collection = x.OwnedCollectionRoot[prm].OwnedCollectionBranch
+            }),
+            elementSorter: e => e.x.Id,
+            elementAsserter: (e, a) =>
+            {
+                AssertEqual(e.x, a.x);
+                AssertCollection(e.Collection, a.Collection, ordered: true);
+            },
+            entryCount: 40);
+    }
+
+    [ConditionalTheory]
+    [MemberData(nameof(IsAsyncData))]
+    public virtual Task Json_collection_element_access_in_projection_when_owner_is_present_misc1(bool async)
+    {
+        var prm = 1;
+
+        return AssertQuery(
+            async,
+            ss => ss.Set<JsonEntityBasic>().Select(x => new
+            {
+                x,
+                CollectionElement = x.OwnedCollectionRoot[1].OwnedCollectionBranch[prm],
+            }),
+            elementSorter: e => e.x.Id,
+            elementAsserter: (e, a) =>
+            {
+                AssertEqual(e.x, a.x);
+                AssertEqual(e.CollectionElement, a.CollectionElement);
+            },
+            entryCount: 40);
+    }
 
-        Assert.Equal(RelationalStrings.ProjectingJsonCollectionElementRequiresNoTracking, message);
+    [ConditionalTheory]
+    [MemberData(nameof(IsAsyncData))]
+    public virtual Task Json_collection_element_access_in_projection_when_owner_is_present_misc2(bool async)
+        => AssertQuery(
+            async,
+            ss => ss.Set<JsonEntityBasic>().Select(x => new
+            {
+                x,
+                CollectionElement = x.OwnedReferenceRoot.OwnedReferenceBranch.OwnedCollectionLeaf[1]
+            }),
+            elementSorter: e => e.x.Id,
+            elementAsserter: (e, a) =>
+            {
+                AssertEqual(e.x, a.x);
+                AssertEqual(e.CollectionElement, a.CollectionElement);
+            },
+            entryCount: 40);
+
+    [ConditionalTheory]
+    [MemberData(nameof(IsAsyncData))]
+    public virtual Task Json_collection_element_access_in_projection_when_owner_is_present_multiple(bool async)
+    {
+        var prm = 1;
+
+        return AssertQuery(
+            async,
+            ss => ss.Set<JsonEntityBasic>().Select(x => new
+            {
+                x,
+                CollectionElement1 = x.OwnedCollectionRoot[prm].OwnedCollectionBranch[1],
+                CollectionElement2 = x.OwnedCollectionRoot[1].OwnedCollectionBranch[1].OwnedReferenceLeaf,
+                CollectionElement3 = x.OwnedCollectionRoot[1].OwnedReferenceBranch,
+                CollectionElement4 = x.OwnedCollectionRoot[prm].OwnedReferenceBranch,
+                CollectionElement5 = x.OwnedCollectionRoot[prm].OwnedCollectionBranch[x.Id],
+                CollectionElement6 = x.OwnedCollectionRoot[x.Id].OwnedCollectionBranch[1].OwnedReferenceLeaf,
+                CollectionElement7 = x.OwnedCollectionRoot[1].OwnedReferenceBranch,
+                CollectionElement8 = x.OwnedCollectionRoot[x.Id].OwnedReferenceBranch,
+                CollectionElement9 = x.OwnedCollectionRoot[x.Id].OwnedCollectionBranch[x.Id],
+            }),
+            elementSorter: e => e.x.Id,
+            elementAsserter: (e, a) =>
+            {
+                AssertEqual(e.x, a.x);
+                AssertEqual(e.CollectionElement1, a.CollectionElement1);
+                AssertEqual(e.CollectionElement2, a.CollectionElement2);
+                AssertEqual(e.CollectionElement3, a.CollectionElement3);
+                AssertEqual(e.CollectionElement4, a.CollectionElement4);
+                AssertEqual(e.CollectionElement5, a.CollectionElement5);
+                AssertEqual(e.CollectionElement6, a.CollectionElement6);
+                AssertEqual(e.CollectionElement7, a.CollectionElement7);
+                AssertEqual(e.CollectionElement8, a.CollectionElement8);
+                AssertEqual(e.CollectionElement9, a.CollectionElement9);
+            },
+            entryCount: 40);
     }
 
     [ConditionalTheory]
diff --git a/test/EFCore.SqlServer.FunctionalTests/Query/JsonQuerySqlServerTest.cs b/test/EFCore.SqlServer.FunctionalTests/Query/JsonQuerySqlServerTest.cs
index 3b5cd9e219..069df8d118 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Query/JsonQuerySqlServerTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Query/JsonQuerySqlServerTest.cs
@@ -655,7 +655,7 @@ public override async Task Json_collection_element_access_in_projection_using_pa
 """
 @__prm_0='0'
 
-SELECT JSON_QUERY([j].[OwnedCollectionRoot],'$[' + CAST(@__prm_0 AS nvarchar(max)) + ']'), [j].[Id]
+SELECT JSON_QUERY([j].[OwnedCollectionRoot],'$[' + CAST(@__prm_0 AS nvarchar(max)) + ']'), [j].[Id], @__prm_0
 FROM [JsonEntitiesBasic] AS [j]
 """);
     }
@@ -718,7 +718,7 @@ public override async Task Json_collection_element_access_in_projection_nested(b
 """
 @__prm_0='1'
 
-SELECT JSON_QUERY([j].[OwnedCollectionRoot],'$[0].OwnedCollectionBranch[' + CAST(@__prm_0 AS nvarchar(max)) + ']'), [j].[Id]
+SELECT JSON_QUERY([j].[OwnedCollectionRoot],'$[0].OwnedCollectionBranch[' + CAST(@__prm_0 AS nvarchar(max)) + ']'), [j].[Id], @__prm_0
 FROM [JsonEntitiesBasic] AS [j]
 """);
     }
@@ -746,7 +746,7 @@ public override async Task Json_collection_element_access_in_projection_nested_p
 """
 @__prm_0='1'
 
-SELECT JSON_QUERY([j].[OwnedCollectionRoot],'$[0].OwnedCollectionBranch[' + CAST(@__prm_0 AS nvarchar(max)) + '].OwnedReferenceLeaf'), [j].[Id]
+SELECT JSON_QUERY([j].[OwnedCollectionRoot],'$[0].OwnedCollectionBranch[' + CAST(@__prm_0 AS nvarchar(max)) + '].OwnedReferenceLeaf'), [j].[Id], @__prm_0
 FROM [JsonEntitiesBasic] AS [j]
 """);
     }
@@ -760,7 +760,7 @@ public override async Task Json_collection_element_access_in_projection_nested_p
 """
 @__prm_0='1'
 
-SELECT JSON_QUERY([j].[OwnedCollectionRoot],'$[0].OwnedCollectionBranch[' + CAST(@__prm_0 AS nvarchar(max)) + '].OwnedCollectionLeaf'), [j].[Id]
+SELECT JSON_QUERY([j].[OwnedCollectionRoot],'$[0].OwnedCollectionBranch[' + CAST(@__prm_0 AS nvarchar(max)) + '].OwnedCollectionLeaf'), [j].[Id], @__prm_0
 FROM [JsonEntitiesBasic] AS [j]
 ORDER BY [j].[Id]
 """);
@@ -775,7 +775,7 @@ public override async Task Json_collection_element_access_in_projection_nested_p
 """
 @__prm_0='1'
 
-SELECT [j].[Id], JSON_QUERY([j].[OwnedCollectionRoot],'$[0].OwnedCollectionBranch[' + CAST(@__prm_0 AS nvarchar(max)) + '].OwnedCollectionLeaf')
+SELECT [j].[Id], JSON_QUERY([j].[OwnedCollectionRoot],'$[0].OwnedCollectionBranch[' + CAST(@__prm_0 AS nvarchar(max)) + '].OwnedCollectionLeaf'), @__prm_0
 FROM [JsonEntitiesBasic] AS [j]
 """);
     }
@@ -951,7 +951,7 @@ public override async Task Json_projection_deduplication_with_collection_indexer
 """
 @__prm_0='1'
 
-SELECT [j].[Id], JSON_QUERY([j].[OwnedReferenceRoot],'$.OwnedCollectionBranch[1]'), [j].[OwnedReferenceRoot], JSON_QUERY([j].[OwnedReferenceRoot],'$.OwnedReferenceBranch.OwnedCollectionLeaf[' + CAST(@__prm_0 AS nvarchar(max)) + ']')
+SELECT [j].[Id], [j].[OwnedReferenceRoot], @__prm_0
 FROM [JsonEntitiesBasic] AS [j]
 """);
     }
@@ -962,23 +962,96 @@ public override async Task Json_projection_deduplication_with_collection_in_orig
 
         AssertSql(
 """
-SELECT [j].[Id], JSON_QUERY([j].[OwnedReferenceRoot],'$.OwnedCollectionBranch'), JSON_QUERY([j].[OwnedReferenceRoot],'$.OwnedCollectionBranch[1]')
+@__prm_0='1'
+
+SELECT JSON_QUERY([j].[OwnedReferenceRoot],'$.OwnedCollectionBranch'), [j].[Id], @__prm_0
 FROM [JsonEntitiesBasic] AS [j]
 """);
     }
 
-    public override async Task Json_collection_element_access_in_projection_requires_NoTracking_even_if_owner_is_present(bool async)
+    public override async Task Json_collection_element_access_in_projection_using_constant_when_owner_is_present(bool async)
     {
-        await base.Json_collection_element_access_in_projection_requires_NoTracking_even_if_owner_is_present(async);
+        await base.Json_collection_element_access_in_projection_using_constant_when_owner_is_present(async);
 
-        AssertSql();
+        AssertSql(
+"""
+SELECT [j].[Id], [j].[EntityBasicId], [j].[Name], [j].[OwnedCollectionRoot], [j].[OwnedReferenceRoot]
+FROM [JsonEntitiesBasic] AS [j]
+""");
     }
 
-    public override async Task Json_collection_element_access_in_projection_requires_NoTracking_even_if_owner_is_present2(bool async)
+    public override async Task Json_collection_element_access_in_projection_using_parameter_when_owner_is_present(bool async)
     {
-        await base.Json_collection_element_access_in_projection_requires_NoTracking_even_if_owner_is_present2(async);
+        await base.Json_collection_element_access_in_projection_using_parameter_when_owner_is_present(async);
 
-        AssertSql();
+        AssertSql(
+"""
+@__prm_0='1'
+
+SELECT [j].[Id], [j].[EntityBasicId], [j].[Name], [j].[OwnedCollectionRoot], [j].[OwnedReferenceRoot], @__prm_0
+FROM [JsonEntitiesBasic] AS [j]
+""");
+    }
+
+    public override async Task Json_collection_after_collection_element_access_in_projection_using_constant_when_owner_is_present(bool async)
+    {
+        await base.Json_collection_after_collection_element_access_in_projection_using_constant_when_owner_is_present(async);
+
+        AssertSql(
+"""
+SELECT [j].[Id], [j].[EntityBasicId], [j].[Name], [j].[OwnedCollectionRoot], [j].[OwnedReferenceRoot]
+FROM [JsonEntitiesBasic] AS [j]
+""");
+    }
+
+    public override async Task Json_collection_after_collection_element_access_in_projection_using_parameter_when_owner_is_present(bool async)
+    {
+        await base.Json_collection_after_collection_element_access_in_projection_using_parameter_when_owner_is_present(async);
+
+        AssertSql(
+"""
+@__prm_0='1'
+
+SELECT [j].[Id], [j].[EntityBasicId], [j].[Name], [j].[OwnedCollectionRoot], [j].[OwnedReferenceRoot], @__prm_0
+FROM [JsonEntitiesBasic] AS [j]
+""");
+    }
+
+    public override async Task Json_collection_element_access_in_projection_when_owner_is_present_misc1(bool async)
+    {
+        await base.Json_collection_element_access_in_projection_when_owner_is_present_misc1(async);
+
+        AssertSql(
+"""
+@__prm_0='1'
+
+SELECT [j].[Id], [j].[EntityBasicId], [j].[Name], [j].[OwnedCollectionRoot], [j].[OwnedReferenceRoot], @__prm_0
+FROM [JsonEntitiesBasic] AS [j]
+""");
+    }
+
+    public override async Task Json_collection_element_access_in_projection_when_owner_is_present_misc2(bool async)
+    {
+        await base.Json_collection_element_access_in_projection_when_owner_is_present_misc2(async);
+
+        AssertSql(
+"""
+SELECT [j].[Id], [j].[EntityBasicId], [j].[Name], [j].[OwnedCollectionRoot], [j].[OwnedReferenceRoot]
+FROM [JsonEntitiesBasic] AS [j]
+""");
+    }
+
+    public override async Task Json_collection_element_access_in_projection_when_owner_is_present_multiple(bool async)
+    {
+        await base.Json_collection_element_access_in_projection_when_owner_is_present_multiple(async);
+
+        AssertSql(
+"""
+@__prm_0='1'
+
+SELECT [j].[Id], [j].[EntityBasicId], [j].[Name], [j].[OwnedCollectionRoot], [j].[OwnedReferenceRoot], @__prm_0
+FROM [JsonEntitiesBasic] AS [j]
+""");
     }
 
     public override async Task Json_scalar_required_null_semantics(bool async)
