diff --git a/src/EFCore/Metadata/Internal/InternalPropertyBuilder.cs b/src/EFCore/Metadata/Internal/InternalPropertyBuilder.cs
index e498f3c669..7c181c9f1a 100644
--- a/src/EFCore/Metadata/Internal/InternalPropertyBuilder.cs
+++ b/src/EFCore/Metadata/Internal/InternalPropertyBuilder.cs
@@ -1,6 +1,7 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using System;
 using System.Diagnostics.CodeAnalysis;
 using System.Globalization;
 using System.Reflection;
@@ -522,7 +523,10 @@ public virtual bool CanSetAfterSave(PropertySaveBehavior? behavior, Configuratio
     {
         if (CanSetConversion(converter, configurationSource))
         {
-            Metadata.SetElementType(null, configurationSource);
+            if (converter != null)
+            {
+                Metadata.SetElementType(null, configurationSource);
+            }
             Metadata.SetProviderClrType(null, configurationSource);
             Metadata.SetValueConverter(converter, configurationSource);
 
@@ -546,7 +550,8 @@ public virtual bool CanSetAfterSave(PropertySaveBehavior? behavior, Configuratio
                     && Metadata.CheckValueConverter(converter) == null)
                 || (Metadata[CoreAnnotationNames.ValueConverterType] == null
                     && (ValueConverter?)Metadata[CoreAnnotationNames.ValueConverter] == converter))
-            && configurationSource.Overrides(Metadata.GetProviderClrTypeConfigurationSource());
+            && configurationSource.Overrides(Metadata.GetProviderClrTypeConfigurationSource())
+            && (converter == null || CanSetElementType(null, configurationSource));
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
@@ -558,7 +563,10 @@ public virtual bool CanSetAfterSave(PropertySaveBehavior? behavior, Configuratio
     {
         if (CanSetConversion(providerClrType, configurationSource))
         {
-            Metadata.SetElementType(null, configurationSource);
+            if (providerClrType != null)
+            {
+                Metadata.SetElementType(null, configurationSource);
+            }
             Metadata.SetValueConverter((ValueConverter?)null, configurationSource);
             Metadata.SetProviderClrType(providerClrType, configurationSource);
 
@@ -577,7 +585,8 @@ public virtual bool CanSetAfterSave(PropertySaveBehavior? behavior, Configuratio
     public virtual bool CanSetConversion(Type? providerClrType, ConfigurationSource? configurationSource)
         => (configurationSource.Overrides(Metadata.GetProviderClrTypeConfigurationSource())
                 || Metadata.GetProviderClrType() == providerClrType)
-            && configurationSource.Overrides(Metadata.GetValueConverterConfigurationSource());
+            && configurationSource.Overrides(Metadata.GetValueConverterConfigurationSource())
+            && (providerClrType == null || CanSetElementType(null, configurationSource));
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
@@ -592,7 +601,10 @@ public virtual bool CanSetConversion(Type? providerClrType, ConfigurationSource?
     {
         if (CanSetConverter(converterType, configurationSource))
         {
-            Metadata.SetElementType(null, configurationSource);
+            if (converterType != null)
+            {
+                Metadata.SetElementType(null, configurationSource);
+            }
             Metadata.SetProviderClrType(null, configurationSource);
             Metadata.SetValueConverter(converterType, configurationSource);
 
@@ -612,9 +624,10 @@ public virtual bool CanSetConversion(Type? providerClrType, ConfigurationSource?
         [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicParameterlessConstructor)]
         Type? converterType,
         ConfigurationSource? configurationSource)
-        => configurationSource.Overrides(Metadata.GetValueConverterConfigurationSource())
+        => (configurationSource.Overrides(Metadata.GetValueConverterConfigurationSource())
             || (Metadata[CoreAnnotationNames.ValueConverter] == null
-                && (Type?)Metadata[CoreAnnotationNames.ValueConverterType] == converterType);
+                && (Type?)Metadata[CoreAnnotationNames.ValueConverterType] == converterType))
+            && (converterType == null || CanSetElementType(null, configurationSource));
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
@@ -809,7 +822,10 @@ public virtual bool CanSetProviderValueComparer(ValueComparer? comparer, Configu
         if (CanSetElementType(elementType, configurationSource))
         {
             Metadata.SetElementType(elementType, configurationSource);
-            Metadata.SetValueConverter((Type?)null, configurationSource);
+            if (elementType != null)
+            {
+                Metadata.SetValueConverter((Type?)null, configurationSource);
+            }
             return new InternalElementTypeBuilder(Metadata.GetElementType()!, ModelBuilder);
         }
 
@@ -823,8 +839,9 @@ public virtual bool CanSetProviderValueComparer(ValueComparer? comparer, Configu
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
     public virtual bool CanSetElementType(Type? elementType, ConfigurationSource? configurationSource)
-        => configurationSource.Overrides(Metadata.GetElementTypeConfigurationSource())
-            && (elementType != Metadata.GetElementType()?.ClrType);
+        => (configurationSource.Overrides(Metadata.GetElementTypeConfigurationSource())
+            && (elementType == null || CanSetConversion((Type?)null, configurationSource)))
+            || elementType == Metadata.GetElementType()?.ClrType;
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
diff --git a/test/EFCore.Relational.Specification.Tests/Query/AdHocJsonQueryTestBase.cs b/test/EFCore.Relational.Specification.Tests/Query/AdHocJsonQueryTestBase.cs
index f42e84581f..726df5a442 100644
--- a/test/EFCore.Relational.Specification.Tests/Query/AdHocJsonQueryTestBase.cs
+++ b/test/EFCore.Relational.Specification.Tests/Query/AdHocJsonQueryTestBase.cs
@@ -306,7 +306,7 @@ public virtual async Task Project_json_array_of_primitives_on_reference(bool asy
         }
     }
 
-    [ConditionalTheory]
+    [ConditionalTheory(Skip = "Issue #32611")]
     [MemberData(nameof(IsAsyncData))]
     public virtual async Task Project_json_array_of_primitives_on_collection(bool async)
     {
@@ -426,33 +426,10 @@ protected override void OnModelCreating(ModelBuilder modelBuilder)
         {
             modelBuilder.Entity<MyEntityArrayOfPrimitives>().Property(x => x.Id).ValueGeneratedNever();
             modelBuilder.Entity<MyEntityArrayOfPrimitives>().OwnsOne(
-                x => x.Reference, b =>
-                {
-                    b.ToJson();
-                    b.Property(x => x.IntArray).HasConversion(
-                        x => string.Join(" ", x),
-                        x => x.Split(" ", StringSplitOptions.None).Select(v => int.Parse(v)).ToArray(),
-                        new ValueComparer<int[]>(true));
-
-                    b.Property(x => x.ListOfString).HasConversion(
-                        x => string.Join(" ", x),
-                        x => x.Split(" ", StringSplitOptions.None).ToList(),
-                        new ValueComparer<List<string>>(true));
-                });
+                x => x.Reference, b => b.ToJson());
 
             modelBuilder.Entity<MyEntityArrayOfPrimitives>().OwnsMany(
-                x => x.Collection, b =>
-                {
-                    b.ToJson();
-                    b.Property(x => x.IntArray).HasConversion(
-                        x => string.Join(" ", x),
-                        x => x.Split(" ", StringSplitOptions.None).Select(v => int.Parse(v)).ToArray(),
-                        new ValueComparer<int[]>(true));
-                    b.Property(x => x.ListOfString).HasConversion(
-                        x => string.Join(" ", x),
-                        x => x.Split(" ", StringSplitOptions.None).ToList(),
-                        new ValueComparer<List<string>>(true));
-                });
+                x => x.Collection, b => b.ToJson());
         }
     }
 
diff --git a/test/EFCore.Specification.Tests/ModelBuilding/ModelBuilderTest.NonRelationship.cs b/test/EFCore.Specification.Tests/ModelBuilding/ModelBuilderTest.NonRelationship.cs
index c8d176ba14..a49472890e 100644
--- a/test/EFCore.Specification.Tests/ModelBuilding/ModelBuilderTest.NonRelationship.cs
+++ b/test/EFCore.Specification.Tests/ModelBuilding/ModelBuilderTest.NonRelationship.cs
@@ -3284,6 +3284,45 @@ public virtual void Element_types_can_have_unicode_set()
             Assert.False(entityType.FindProperty("Stranger")!.GetElementType()!.IsUnicode());
         }
 
+        [ConditionalFact]
+        public virtual void Conversion_on_base_property_prevents_primitive_collection()
+        {
+            var modelBuilder = CreateModelBuilder();
+            modelBuilder.Entity<DerivedCollectionQuarks>();
+            modelBuilder.Entity<CollectionQuarks>(b =>
+            {
+                b.Property(c => c.Down).HasConversion(gs => string.Join(',', gs!),
+                    s => new ObservableCollection<string>(s.Split(',', StringSplitOptions.RemoveEmptyEntries)));
+            });
+
+            var model = modelBuilder.FinalizeModel();
+
+            var property = model.FindEntityType(typeof(CollectionQuarks))!.FindProperty(nameof(CollectionQuarks.Down))!;
+            Assert.False(property.IsPrimitiveCollection);
+            Assert.NotNull(property.GetValueConverter());
+        }
+
+        [ConditionalFact]
+        public virtual void Conversion_on_base_property_prevents_primitive_collection_when_base_first()
+        {
+            var modelBuilder = CreateModelBuilder();
+            modelBuilder.Entity<CollectionQuarks>(b =>
+            {
+                b.Property(c => c.Down).HasConversion(gs => string.Join(',', gs!),
+                    s => new ObservableCollection<string>(s.Split(',', StringSplitOptions.RemoveEmptyEntries)));
+            });
+
+            var property = (IProperty)modelBuilder.Model.FindEntityType(typeof(CollectionQuarks))!.FindProperty(nameof(CollectionQuarks.Down))!;
+            Assert.False(property.IsPrimitiveCollection);
+
+            modelBuilder.Entity<DerivedCollectionQuarks>();
+
+            var model = modelBuilder.FinalizeModel();
+            property = model.FindEntityType(typeof(CollectionQuarks))!.FindProperty(nameof(CollectionQuarks.Down))!;
+            Assert.False(property.IsPrimitiveCollection);
+            Assert.NotNull(property.GetValueConverter());
+        }
+
         [ConditionalFact]
         public virtual void Element_types_can_have_provider_type_set()
         {
diff --git a/test/EFCore.Specification.Tests/ModelBuilding/ModelBuilderTest.OwnedTypes.cs b/test/EFCore.Specification.Tests/ModelBuilding/ModelBuilderTest.OwnedTypes.cs
index da2da4d44d..34653de94f 100644
--- a/test/EFCore.Specification.Tests/ModelBuilding/ModelBuilderTest.OwnedTypes.cs
+++ b/test/EFCore.Specification.Tests/ModelBuilding/ModelBuilderTest.OwnedTypes.cs
@@ -1659,6 +1659,7 @@ public virtual void Can_configure_owned_entity_and_property_of_same_type()
 
             var departmentIdProperty = departmentType.FindProperty(nameof(Department.Id));
             Assert.NotNull(departmentIdProperty);
+            Assert.NotNull(departmentIdProperty.GetValueConverter());
             Assert.NotNull(departmentNestedType);
             Assert.NotNull(officeNestedType);
 
diff --git a/test/EFCore.Specification.Tests/ModelBuilding/ModelBuilderTest.TestModel.cs b/test/EFCore.Specification.Tests/ModelBuilding/ModelBuilderTest.TestModel.cs
index ea89abada2..2a71e1c507 100644
--- a/test/EFCore.Specification.Tests/ModelBuilding/ModelBuilderTest.TestModel.cs
+++ b/test/EFCore.Specification.Tests/ModelBuilding/ModelBuilderTest.TestModel.cs
@@ -340,6 +340,10 @@ public ObservableCollection<int> Up
 #pragma warning restore 67
     }
 
+    protected class DerivedCollectionQuarks : CollectionQuarks
+    {
+    }
+
     protected class Hob
     {
         public string? Id1 { get; set; }
diff --git a/test/EFCore.Tests/Metadata/Conventions/ConventionDispatcherTest.cs b/test/EFCore.Tests/Metadata/Conventions/ConventionDispatcherTest.cs
index 0fdfaa2ae7..13e5cc0737 100644
--- a/test/EFCore.Tests/Metadata/Conventions/ConventionDispatcherTest.cs
+++ b/test/EFCore.Tests/Metadata/Conventions/ConventionDispatcherTest.cs
@@ -8,8 +8,6 @@ namespace Microsoft.EntityFrameworkCore.Metadata.Conventions;
 
 public class ConventionDispatcherTest
 {
-    // TODO: Use public API to add conventions, issue #214
-
     [ConditionalFact]
     public void Infinite_recursion_throws()
     {
@@ -3930,7 +3928,7 @@ public void OnPropertyElementTypeChanged_calls_conventions_in_order(bool useBuil
 
         if (useBuilder)
         {
-            Assert.Null(propertyBuilder.SetElementType(typeof(int), ConfigurationSource.Convention));
+            Assert.NotNull(propertyBuilder.SetElementType(typeof(int), ConfigurationSource.Convention));
             elementType = propertyBuilder.Metadata.GetElementType()!;
         }
         else
