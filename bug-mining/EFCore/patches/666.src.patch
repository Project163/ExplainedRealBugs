diff --git a/test/EFCore.Cosmos.FunctionalTests/TestUtilities/TestSqlLoggerFactory.cs b/test/EFCore.Cosmos.FunctionalTests/TestUtilities/TestSqlLoggerFactory.cs
index 81865e869d..9a89c3385a 100644
--- a/test/EFCore.Cosmos.FunctionalTests/TestUtilities/TestSqlLoggerFactory.cs
+++ b/test/EFCore.Cosmos.FunctionalTests/TestUtilities/TestSqlLoggerFactory.cs
@@ -123,6 +123,14 @@ void RewriteSourceWithNewBaseline(string fileName, int lineNumber)
             var fileInfo = _queryBaselineRewritingFileInfos.GetOrAdd(fileName, _ => new QueryBaselineRewritingFileInfo());
             lock (fileInfo.Lock)
             {
+                // Check if we've already processed this line - if so no need to do it again
+                if (fileInfo.ProcessedLines.Contains(lineNumber))
+                {
+                    return;
+                }
+
+                fileInfo.ProcessedLines.Add(lineNumber);
+
                 // First, adjust our lineNumber to take into account any baseline rewriting that already occurred in this file
                 var origLineNumber = lineNumber;
                 foreach (var displacement in fileInfo.LineDisplacements)
@@ -239,13 +247,13 @@ void RewriteSourceWithNewBaseline(string fileName, int lineNumber)
                         // Skip over the invocation on the read side, and write the new baseline invocation
                         var tempBuf = new char[Math.Max(1024, invocation.Span.Length)];
                         reader.ReadBlock(tempBuf, 0, invocation.Span.Length);
-                        var numNewlinesInOrigin = tempBuf.Count(c => c is '\n' or '\r');
+                        var numNewlinesInOrigin = tempBuf.Count(c => c is '\n');
 
                         indentBuilder.Append("    ");
                         var indent = indentBuilder.ToString();
                         var newBaseLine = $@"AssertSql(
 {string.Join("," + Environment.NewLine + indent + "//" + Environment.NewLine, SqlStatements.Select(sql => indent + "\"\"\"" + Environment.NewLine + sql + Environment.NewLine + "\"\"\""))})";
-                        var numNewlinesInRewritten = newBaseLine.Count(c => c is '\n' or '\r');
+                        var numNewlinesInRewritten = newBaseLine.Count(c => c is '\n');
 
                         writer.Write(newBaseLine);
 
@@ -338,6 +346,12 @@ private struct QueryBaselineRewritingFileInfo
 
         public object Lock { get; } = new();
 
+        /// <summary>
+        ///     Contains information on which lines in the file where we've already performed baseline rewriting; we use this to
+        ///     avoid processing the same line twice (e.g. when a test is a theory that's executed multiple times).
+        /// </summary>
+        public readonly HashSet<int> ProcessedLines = new();
+
         /// <summary>
         ///     Contains information on where previous baseline rewriting caused line numbers to shift; this is used in adjusting line
         ///     numbers for later errors. The keys are (pre-rewriting) line numbers, and the values are offsets that have been applied to
diff --git a/test/EFCore.Relational.Specification.Tests/TestUtilities/TestSqlLoggerFactory.cs b/test/EFCore.Relational.Specification.Tests/TestUtilities/TestSqlLoggerFactory.cs
index 57e3055ff9..f52fd022f4 100644
--- a/test/EFCore.Relational.Specification.Tests/TestUtilities/TestSqlLoggerFactory.cs
+++ b/test/EFCore.Relational.Specification.Tests/TestUtilities/TestSqlLoggerFactory.cs
@@ -137,6 +137,14 @@ void RewriteSourceWithNewBaseline(string fileName, int lineNumber)
             var fileInfo = _queryBaselineRewritingFileInfos.GetOrAdd(fileName, _ => new QueryBaselineRewritingFileInfo());
             lock (fileInfo.Lock)
             {
+                // Check if we've already processed this line - if so no need to do it again
+                if (fileInfo.ProcessedLines.Contains(lineNumber))
+                {
+                    return;
+                }
+
+                fileInfo.ProcessedLines.Add(lineNumber);
+
                 // First, adjust our lineNumber to take into account any baseline rewriting that already occurred in this file
                 var origLineNumber = lineNumber;
                 foreach (var displacement in fileInfo.LineDisplacements)
@@ -255,13 +263,13 @@ void RewriteSourceWithNewBaseline(string fileName, int lineNumber)
                         // Skip over the invocation on the read side, and write the new baseline invocation
                         var tempBuf = new char[Math.Max(1024, invocation.Span.Length)];
                         reader.ReadBlock(tempBuf, 0, invocation.Span.Length);
-                        var numNewlinesInOrigin = tempBuf.Count(c => c is '\n' or '\r');
+                        var numNewlinesInOrigin = tempBuf.Count(c => c is '\n');
 
                         indentBuilder.Append("    ");
                         var indent = indentBuilder.ToString();
                         var newBaseLine = $@"Assert{(forUpdate ? "ExecuteUpdate" : "")}Sql(
 {string.Join("," + Environment.NewLine + indent + "//" + Environment.NewLine, SqlStatements.Skip(offset).Take(count).Select(sql => indent + "\"\"\"" + Environment.NewLine + sql + Environment.NewLine + "\"\"\""))})";
-                        var numNewlinesInRewritten = newBaseLine.Count(c => c is '\n' or '\r');
+                        var numNewlinesInRewritten = newBaseLine.Count(c => c is '\n');
 
                         writer.Write(newBaseLine);
 
@@ -385,6 +393,12 @@ private struct QueryBaselineRewritingFileInfo
 
         public object Lock { get; } = new();
 
+        /// <summary>
+        ///     Contains information on which lines in the file where we've already performed baseline rewriting; we use this to
+        ///     avoid processing the same line twice (e.g. when a test is a theory that's executed multiple times).
+        /// </summary>
+        public readonly HashSet<int> ProcessedLines = new();
+
         /// <summary>
         ///     Contains information on where previous baseline rewriting caused line numbers to shift; this is used in adjusting line
         ///     numbers for later errors. The keys are (pre-rewriting) line numbers, and the values are offsets that have been applied to
