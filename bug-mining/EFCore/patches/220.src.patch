diff --git a/src/EFCore.Analyzers/AnalyzerReleases.Shipped.md b/src/EFCore.Analyzers/AnalyzerReleases.Shipped.md
index 433bac626f..9b4322118c 100644
--- a/src/EFCore.Analyzers/AnalyzerReleases.Shipped.md
+++ b/src/EFCore.Analyzers/AnalyzerReleases.Shipped.md
@@ -15,4 +15,11 @@ EF1001  | Usage    | Warning  | InternalUsageDiagnosticAnalyzer
 ### Removed Rules
 Rule ID | Category | Severity | Notes
 --------|----------|----------|--------------------
-EF1000  | Security | Disabled | RawSqlStringInjectionDiagnosticAnalyzer, [Documentation](https://docs.microsoft.com/ef/core/querying/raw-sql)
\ No newline at end of file
+EF1000  | Security | Disabled | RawSqlStringInjectionDiagnosticAnalyzer, [Documentation](https://docs.microsoft.com/ef/core/querying/raw-sql)
+
+## Release 8.0.0
+
+### New Rules
+Rule ID | Category | Severity | Notes
+--------|----------|----------|-------
+EF1002  | Security | Warning  | InterpolatedStringUsageInRawQueriesDiagnosticAnalyzer, [Documentation](https://learn.microsoft.com/en-us/ef/core/querying/sql-queries#passing-parameters)
\ No newline at end of file
diff --git a/src/EFCore.Analyzers/CompilationExtensions.cs b/src/EFCore.Analyzers/CompilationExtensions.cs
new file mode 100644
index 0000000000..de359940e9
--- /dev/null
+++ b/src/EFCore.Analyzers/CompilationExtensions.cs
@@ -0,0 +1,21 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.CodeAnalysis;
+
+namespace Microsoft.EntityFrameworkCore;
+
+internal static class CompilationExtensions
+{
+    public static INamedTypeSymbol? DbSetType(this Compilation compilation)
+        => compilation.GetTypeByMetadataName("Microsoft.EntityFrameworkCore.DbSet`1");
+
+    public static INamedTypeSymbol? DbContextType(this Compilation compilation)
+        => compilation.GetTypeByMetadataName("Microsoft.EntityFrameworkCore.DbContext");
+
+    public static INamedTypeSymbol? RelationalQueryableExtensionsType(this Compilation compilation)
+        => compilation.GetTypeByMetadataName("Microsoft.EntityFrameworkCore.RelationalQueryableExtensions");
+
+    public static INamedTypeSymbol? RelationalDatabaseFacadeExtensionsType(this Compilation compilation)
+        => compilation.GetTypeByMetadataName("Microsoft.EntityFrameworkCore.RelationalDatabaseFacadeExtensions");
+}
diff --git a/src/EFCore.Analyzers/EFCore.Analyzers.csproj b/src/EFCore.Analyzers/EFCore.Analyzers.csproj
index f11a5228fb..f905f61fc1 100644
--- a/src/EFCore.Analyzers/EFCore.Analyzers.csproj
+++ b/src/EFCore.Analyzers/EFCore.Analyzers.csproj
@@ -28,6 +28,7 @@
 
   <ItemGroup>
     <PackageReference Include="Microsoft.CodeAnalysis.CSharp" Version="$(MicrosoftCodeAnalysisVersion)" PrivateAssets="all" />
+    <PackageReference Include="Microsoft.CodeAnalysis.CSharp.Workspaces" Version="$(MicrosoftCodeAnalysisVersion)" PrivateAssets="all" />
     <PackageReference Update="NETStandard.Library" PrivateAssets="all" />
   </ItemGroup>
 
diff --git a/src/EFCore.Analyzers/InterpolatedStringUsageInRawQueriesCodeFixProvider.cs b/src/EFCore.Analyzers/InterpolatedStringUsageInRawQueriesCodeFixProvider.cs
new file mode 100644
index 0000000000..89b8e8f804
--- /dev/null
+++ b/src/EFCore.Analyzers/InterpolatedStringUsageInRawQueriesCodeFixProvider.cs
@@ -0,0 +1,88 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Immutable;
+using System.Composition;
+using Microsoft.CodeAnalysis;
+using Microsoft.CodeAnalysis.CodeActions;
+using Microsoft.CodeAnalysis.CodeFixes;
+using Microsoft.CodeAnalysis.CSharp;
+using Microsoft.CodeAnalysis.CSharp.Syntax;
+
+namespace Microsoft.EntityFrameworkCore;
+
+[ExportCodeFixProvider(LanguageNames.CSharp, Name = nameof(InterpolatedStringUsageInRawQueriesCodeFixProvider))]
+[Shared]
+public sealed class InterpolatedStringUsageInRawQueriesCodeFixProvider : CodeFixProvider
+{
+    public override ImmutableArray<string> FixableDiagnosticIds
+        => ImmutableArray.Create(InterpolatedStringUsageInRawQueriesDiagnosticAnalyzer.Id);
+
+    public override FixAllProvider GetFixAllProvider()
+        => WellKnownFixAllProviders.BatchFixer;
+
+    public override async Task RegisterCodeFixesAsync(CodeFixContext context)
+    {
+        var document = context.Document;
+        var span = context.Span;
+        var cancellationToken = context.CancellationToken;
+
+        // We report only 1 diagnostic per span, so this is ok
+        var diagnostic = context.Diagnostics.First();
+
+        var root = await document.GetSyntaxRootAsync(cancellationToken).ConfigureAwait(false);
+
+        if (root!.FindNode(diagnostic.Location.SourceSpan) is not SimpleNameSyntax simpleName)
+        {
+            Debug.Fail("Analyzer reported diagnostic not on a SimpleNameSyntax. This should never happen");
+            return;
+        }
+
+        var invocationSyntax = simpleName.FirstAncestorOrSelf<InvocationExpressionSyntax>();
+
+        if (invocationSyntax is null)
+        {
+            return;
+        }
+
+        var foundInterpolation = false;
+
+        // Not all reported by analyzer cases are fixable. If there is a mix of interpolated arguments and normal ones, e.g. `FromSqlRaw($"SELECT * FROM [Users] WHERE [Id] = {id}", id)`,
+        // then replacing `FromSqlRaw` to `FromSqlInterpolated` creates compiler error since there is no overload for this.
+        // We find such cases by walking through syntaxes of each argument and searching for first interpolated string. If there are arguments after it, we consider such case unfixable.
+        foreach (var argument in invocationSyntax.ArgumentList.Arguments)
+        {
+            if (argument.Expression is InterpolatedStringExpressionSyntax)
+            {
+                foundInterpolation = true;
+                continue;
+            }
+
+            if (!foundInterpolation)
+            {
+                continue;
+            }
+
+            return;
+        }
+
+        context.RegisterCodeFix(
+            CodeAction.Create(
+                AnalyzerStrings.InterpolatedStringUsageInRawQueriesCodeActionTitle,
+                _ => Task.FromResult(document.WithSyntaxRoot(root.ReplaceNode(simpleName, GetReplacementName(simpleName)))),
+                nameof(InterpolatedStringUsageInRawQueriesCodeFixProvider)),
+            diagnostic);
+    }
+
+    private static SimpleNameSyntax GetReplacementName(SimpleNameSyntax oldName)
+    {
+        var oldNameToken = oldName.Identifier;
+        var oldMethodName = oldNameToken.ValueText;
+
+        var replacementMethodName = InterpolatedStringUsageInRawQueriesDiagnosticAnalyzer.GetReplacementMethodName(oldMethodName);
+        Debug.Assert(replacementMethodName != oldMethodName, "At this point we must find correct replacement name");
+
+        var replacementToken = SyntaxFactory.Identifier(replacementMethodName).WithTriviaFrom(oldNameToken);
+        return oldName.WithIdentifier(replacementToken);
+    }
+}
diff --git a/src/EFCore.Analyzers/InterpolatedStringUsageInRawQueriesDiagnosticAnalyzer.cs b/src/EFCore.Analyzers/InterpolatedStringUsageInRawQueriesDiagnosticAnalyzer.cs
new file mode 100644
index 0000000000..964e28eb2a
--- /dev/null
+++ b/src/EFCore.Analyzers/InterpolatedStringUsageInRawQueriesDiagnosticAnalyzer.cs
@@ -0,0 +1,231 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Immutable;
+using Microsoft.CodeAnalysis;
+using Microsoft.CodeAnalysis.CSharp.Syntax;
+using Microsoft.CodeAnalysis.Diagnostics;
+using Microsoft.CodeAnalysis.Operations;
+
+namespace Microsoft.EntityFrameworkCore;
+
+[DiagnosticAnalyzer(LanguageNames.CSharp)]
+public sealed class InterpolatedStringUsageInRawQueriesDiagnosticAnalyzer : DiagnosticAnalyzer
+{
+    public const string Id = "EF1002";
+
+    private static readonly DiagnosticDescriptor Descriptor
+        // HACK: Work around dotnet/roslyn-analyzers#5890 by not using target-typed new
+        = new DiagnosticDescriptor(
+            Id,
+            title: AnalyzerStrings.InterpolatedStringUsageInRawQueriesAnalyzerTitle,
+            messageFormat: AnalyzerStrings.InterpolatedStringUsageInRawQueriesMessageFormat,
+            category: "Security",
+            defaultSeverity: DiagnosticSeverity.Warning,
+            isEnabledByDefault: true);
+
+    public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics
+        => ImmutableArray.Create(Descriptor);
+
+    public override void Initialize(AnalysisContext context)
+    {
+        context.EnableConcurrentExecution();
+        context.ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags.None);
+
+        context.RegisterOperationAction(AnalyzerInvocation, OperationKind.Invocation);
+    }
+
+    private void AnalyzerInvocation(OperationAnalysisContext context)
+    {
+        var invocation = (IInvocationOperation)context.Operation;
+        var targetMethod = invocation.TargetMethod;
+
+        var report = targetMethod.Name switch
+        {
+            "FromSqlRaw" => AnalyzeFromSqlRawInvocation(invocation),
+            "ExecuteSqlRaw" or "ExecuteSqlRawAsync" => AnalyzeExecuteSqlRawInvocation(invocation),
+            "SqlQueryRaw" => AnalyzeSqlQueryRawInvocation(invocation),
+            _ => false
+        };
+
+        if (report)
+        {
+            context.ReportDiagnostic(Diagnostic.Create(
+                Descriptor,
+                GetTargetLocation(invocation.Syntax),
+                targetMethod.Name,
+                GetReplacementMethodName(targetMethod.Name)));
+        }
+
+        static Location GetTargetLocation(SyntaxNode syntax)
+        {
+            if (syntax is not InvocationExpressionSyntax invocationExpression)
+            {
+                Debug.Fail("In theory should never happen");
+                return syntax.GetLocation();
+            }
+
+            var targetNode = invocationExpression.Expression;
+
+            while (targetNode is MemberAccessExpressionSyntax memberAccess)
+            {
+                targetNode = memberAccess.Name;
+            }
+
+            // Generic name case, e.g. `db.Database.SqlQueryRaw<int>(...)`.
+            // At this point `targetNode` is `SqlQueryRaw<int>`, but we need location of the actual identifier
+            if (targetNode is GenericNameSyntax genericName)
+            {
+                return genericName.Identifier.GetLocation();
+            }
+
+            // We should appear at name expression, representing method name token, e.g.:
+            // db.Users.[|FromSqlRaw|](...) or db.Database.[|ExecuteSqlRaw|](...)
+            return targetNode.GetLocation();
+        }
+    }
+
+    internal static string GetReplacementMethodName(string oldName) => oldName switch
+    {
+        "FromSqlRaw" => "FromSql",
+        "ExecuteSqlRaw" => "ExecuteSql",
+        "ExecuteSqlRawAsync" => "ExecuteSqlAsync",
+        "SqlQueryRaw" => "SqlQuery",
+        _ => oldName
+    };
+
+    private static bool AnalyzeFromSqlRawInvocation(IInvocationOperation invocation)
+    {
+        var targetMethod = invocation.TargetMethod;
+        Debug.Assert(targetMethod.Name == "FromSqlRaw");
+
+        var compilation = invocation.SemanticModel!.Compilation;
+        var correctFromSqlRaw = FromSqlRawMethod(compilation);
+
+        Debug.Assert(correctFromSqlRaw is not null, "Unable to find original `FromSqlRaw` method");
+
+        // Verify that the method is the one we analyze and its second argument, which corresponds to `string sql`, is an interpolated string
+        if (correctFromSqlRaw is null ||
+            !targetMethod.ConstructedFrom.Equals(correctFromSqlRaw, SymbolEqualityComparer.Default) ||
+            invocation.Arguments[1].Value is not IInterpolatedStringOperation interpolatedString)
+        {
+            return false;
+        }
+
+        // Report warning if interpolated string is not a constant and all its interpolations are not constants
+        return AnalyzeInterpolatedString(interpolatedString);
+    }
+
+    private static bool AnalyzeExecuteSqlRawInvocation(IInvocationOperation invocation)
+    {
+        var targetMethod = invocation.TargetMethod;
+        Debug.Assert(targetMethod.Name is "ExecuteSqlRaw" or "ExecuteSqlRawAsync");
+
+        var compilation = invocation.SemanticModel!.Compilation;
+
+        if (targetMethod.Name == "ExecuteSqlRaw")
+        {
+            var correctMethods = ExecuteSqlRawMethods(compilation);
+
+            Debug.Assert(correctMethods.Any(), "Unable to find any `ExecuteSqlRaw` methods");
+
+            if (!correctMethods.Contains(targetMethod.ConstructedFrom, SymbolEqualityComparer.Default))
+            {
+                return false;
+            }
+        }
+        else
+        {
+            var correctMethods = ExecuteSqlRawAsyncMethods(compilation);
+
+            Debug.Assert(correctMethods.Any(), "Unable to find any `ExecuteSqlRawAsync` methods");
+
+            if (!correctMethods.Contains(targetMethod.ConstructedFrom, SymbolEqualityComparer.Default))
+            {
+                return false;
+            }
+        }
+
+        // At this point assume that the method is correct since both `ExecuteSqlRaw` and `ExecuteSqlRawAsync` have multiple overloads.
+        // Checking for every possible one is too much work for almost no gain.
+        // So check whether the second argument, that corresponds to `string sql` parameter, is an interpolated string...
+        if (invocation.Arguments[1].Value is not IInterpolatedStringOperation interpolatedString)
+        {
+            return false;
+        }
+
+        // ...and report warning if interpolated string is not a constant and all its interpolations are not constants
+        return AnalyzeInterpolatedString(interpolatedString);
+    }
+
+    private static bool AnalyzeSqlQueryRawInvocation(IInvocationOperation invocation)
+    {
+        var targetMethod = invocation.TargetMethod;
+        Debug.Assert(targetMethod.Name == "SqlQueryRaw");
+
+        var compilation = invocation.SemanticModel!.Compilation;
+
+        var correctSqlQueryRaw = SqlQueryRawMethod(compilation);
+
+        Debug.Assert(correctSqlQueryRaw is not null, "Unable to find original `SqlQueryRaw` method");
+
+        // Verify that the method is the one we analyze and its second argument, which corresponds to `string sql`, is an interpolated string
+        if (correctSqlQueryRaw is null ||
+            !targetMethod.ConstructedFrom.Equals(correctSqlQueryRaw, SymbolEqualityComparer.Default) ||
+            invocation.Arguments[1].Value is not IInterpolatedStringOperation interpolatedString)
+        {
+            return false;
+        }
+
+        // Report warning if interpolated string is not a constant and all its interpolations are not constants
+        return AnalyzeInterpolatedString(interpolatedString);
+    }
+
+    private static bool AnalyzeInterpolatedString(IInterpolatedStringOperation interpolatedString)
+    {
+        if (interpolatedString.ConstantValue.HasValue)
+        {
+            return false;
+        }
+
+        foreach (var part in interpolatedString.Parts)
+        {
+            if (part is not IInterpolationOperation interpolation)
+            {
+                continue;
+            }
+
+            if (!interpolation.Expression.ConstantValue.HasValue)
+            {
+                // Found non-constant interpolation. Report it
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    private static IMethodSymbol? FromSqlRawMethod(Compilation compilation)
+    {
+        var type = compilation.RelationalQueryableExtensionsType();
+        return (IMethodSymbol?)type?.GetMembers("FromSqlRaw").FirstOrDefault(s => s is IMethodSymbol);
+    }
+
+    private static IEnumerable<IMethodSymbol> ExecuteSqlRawMethods(Compilation compilation)
+    {
+        var type = compilation.RelationalDatabaseFacadeExtensionsType();
+        return type?.GetMembers("ExecuteSqlRaw").Where(s => s is IMethodSymbol).Cast<IMethodSymbol>() ?? Array.Empty<IMethodSymbol>();
+    }
+
+    private static IEnumerable<IMethodSymbol> ExecuteSqlRawAsyncMethods(Compilation compilation)
+    {
+        var type = compilation.RelationalDatabaseFacadeExtensionsType();
+        return type?.GetMembers("ExecuteSqlRawAsync").Where(s => s is IMethodSymbol).Cast<IMethodSymbol>() ?? Array.Empty<IMethodSymbol>();
+    }
+
+    private static IMethodSymbol? SqlQueryRawMethod(Compilation compilation)
+    {
+        var type = compilation.RelationalDatabaseFacadeExtensionsType();
+        return (IMethodSymbol?)type?.GetMembers("SqlQueryRaw").FirstOrDefault(s => s is IMethodSymbol);
+    }
+}
diff --git a/src/EFCore.Analyzers/Properties/AnalyzerStrings.Designer.cs b/src/EFCore.Analyzers/Properties/AnalyzerStrings.Designer.cs
index e7e369733d..bcd1664c2a 100644
--- a/src/EFCore.Analyzers/Properties/AnalyzerStrings.Designer.cs
+++ b/src/EFCore.Analyzers/Properties/AnalyzerStrings.Designer.cs
@@ -10,8 +10,8 @@
 
 namespace Microsoft.EntityFrameworkCore {
     using System;
-    
-    
+
+
     /// <summary>
     ///   A strongly-typed resource class, for looking up localized strings, etc.
     /// </summary>
@@ -23,15 +23,15 @@ namespace Microsoft.EntityFrameworkCore {
     [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
     [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
     public class AnalyzerStrings {
-        
+
         private static global::System.Resources.ResourceManager resourceMan;
-        
+
         private static global::System.Globalization.CultureInfo resourceCulture;
-        
+
         [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
         internal AnalyzerStrings() {
         }
-        
+
         /// <summary>
         ///   Returns the cached ResourceManager instance used by this class.
         /// </summary>
@@ -45,7 +45,7 @@ public class AnalyzerStrings {
                 return resourceMan;
             }
         }
-        
+
         /// <summary>
         ///   Overrides the current thread's CurrentUICulture property for all
         ///   resource lookups using this strongly typed resource class.
@@ -59,7 +59,7 @@ public class AnalyzerStrings {
                 resourceCulture = value;
             }
         }
-        
+
         /// <summary>
         ///   Looks up a localized string similar to {0} is an internal API that supports the Entity Framework Core infrastructure and not subject to the same compatibility standards as public APIs. It may be changed or removed without notice in any release..
         /// </summary>
@@ -68,7 +68,7 @@ public class AnalyzerStrings {
                 return ResourceManager.GetString("InternalUsageMessageFormat", resourceCulture);
             }
         }
-        
+
         /// <summary>
         ///   Looks up a localized string similar to Internal EF Core API usage..
         /// </summary>
@@ -77,7 +77,34 @@ public class AnalyzerStrings {
                 return ResourceManager.GetString("InternalUsageTitle", resourceCulture);
             }
         }
-        
+
+        /// <summary>
+        ///   Looks up a localized string similar to Risk of vulnerability to SQL injection..
+        /// </summary>
+        public static string InterpolatedStringUsageInRawQueriesAnalyzerTitle {
+            get {
+                return ResourceManager.GetString("InterpolatedStringUsageInRawQueriesAnalyzerTitle", resourceCulture);
+            }
+        }
+
+        /// <summary>
+        ///   Looks up a localized string similar to Use method which protects against SQL injection..
+        /// </summary>
+        public static string InterpolatedStringUsageInRawQueriesCodeActionTitle {
+            get {
+                return ResourceManager.GetString("InterpolatedStringUsageInRawQueriesCodeActionTitle", resourceCulture);
+            }
+        }
+
+        /// <summary>
+        ///   Looks up a localized string similar to Method &apos;{0}&apos; inserts interpolated strings directly into the SQL, without any protection against SQL injection. Consider using &apos;{1}&apos; instead, which protects against SQL injection, or make sure that the value is sanitized and suppress the warning..
+        /// </summary>
+        public static string InterpolatedStringUsageInRawQueriesMessageFormat {
+            get {
+                return ResourceManager.GetString("InterpolatedStringUsageInRawQueriesMessageFormat", resourceCulture);
+            }
+        }
+
         /// <summary>
         ///   Looks up a localized string similar to DbSet properties on DbContext subclasses are automatically populated by the DbContext constructor..
         /// </summary>
diff --git a/src/EFCore.Analyzers/Properties/AnalyzerStrings.resx b/src/EFCore.Analyzers/Properties/AnalyzerStrings.resx
index b94f9ac8eb..2282189be5 100644
--- a/src/EFCore.Analyzers/Properties/AnalyzerStrings.resx
+++ b/src/EFCore.Analyzers/Properties/AnalyzerStrings.resx
@@ -27,4 +27,13 @@
   <data name="InternalUsageTitle" xml:space="preserve">
     <value>Internal EF Core API usage.</value>
   </data>
+  <data name="InterpolatedStringUsageInRawQueriesAnalyzerTitle" xml:space="preserve">
+    <value>Risk of vulnerability to SQL injection.</value>
+  </data>
+  <data name="InterpolatedStringUsageInRawQueriesCodeActionTitle" xml:space="preserve">
+    <value>Use method which protects against SQL injection</value>
+  </data>
+  <data name="InterpolatedStringUsageInRawQueriesMessageFormat" xml:space="preserve">
+    <value>Method '{0}' inserts interpolated strings directly into the SQL, without any protection against SQL injection. Consider using '{1}' instead, which protects against SQL injection, or make sure that the value is sanitized and suppress the warning.</value>
+  </data>
 </root>
\ No newline at end of file
diff --git a/src/EFCore.Analyzers/UninitializedDbSetDiagnosticSuppressor.cs b/src/EFCore.Analyzers/UninitializedDbSetDiagnosticSuppressor.cs
index c5cf7accf6..3cb3172cfb 100644
--- a/src/EFCore.Analyzers/UninitializedDbSetDiagnosticSuppressor.cs
+++ b/src/EFCore.Analyzers/UninitializedDbSetDiagnosticSuppressor.cs
@@ -57,8 +57,8 @@ public override void ReportSuppressions(SuppressionAnalysisContext context)
 
             if (dbSetTypeSymbol is null || dbContextTypeSymbol is null)
             {
-                dbSetTypeSymbol = context.Compilation.GetTypeByMetadataName("Microsoft.EntityFrameworkCore.DbSet`1");
-                dbContextTypeSymbol = context.Compilation.GetTypeByMetadataName("Microsoft.EntityFrameworkCore.DbContext");
+                dbSetTypeSymbol = context.Compilation.DbSetType();
+                dbContextTypeSymbol = context.Compilation.DbContextType();
 
                 if (dbSetTypeSymbol is null || dbContextTypeSymbol is null)
                 {
diff --git a/test/EFCore.Analyzers.Tests/EFCore.Analyzers.Tests.csproj b/test/EFCore.Analyzers.Tests/EFCore.Analyzers.Tests.csproj
index 6834ee6af4..4d00e9635e 100644
--- a/test/EFCore.Analyzers.Tests/EFCore.Analyzers.Tests.csproj
+++ b/test/EFCore.Analyzers.Tests/EFCore.Analyzers.Tests.csproj
@@ -47,6 +47,7 @@
     <PackageReference Include="xunit.assert" Version="$(XUnitVersion)" />
     <PackageReference Include="xunit.core" Version="$(XUnitVersion)" />
     <PackageReference Include="Microsoft.CodeAnalysis.CSharp.Analyzer.Testing.XUnit" Version="$(MicrosoftCodeAnalysisTestingVersion)" />
+    <PackageReference Include="Microsoft.CodeAnalysis.CSharp.CodeFix.Testing.XUnit" Version="$(MicrosoftCodeAnalysisTestingVersion)" />
   </ItemGroup>
 
 </Project>
diff --git a/test/EFCore.Analyzers.Tests/InterpolatedStringUsageInRawQueriesTests.cs b/test/EFCore.Analyzers.Tests/InterpolatedStringUsageInRawQueriesTests.cs
new file mode 100644
index 0000000000..9d6e844791
--- /dev/null
+++ b/test/EFCore.Analyzers.Tests/InterpolatedStringUsageInRawQueriesTests.cs
@@ -0,0 +1,828 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.EntityFrameworkCore;
+
+using VerifyCS = CSharpCodeFixVerifier<InterpolatedStringUsageInRawQueriesDiagnosticAnalyzer, InterpolatedStringUsageInRawQueriesCodeFixProvider>;
+
+public class InterpolatedStringUsageInRawQueriesTests
+{
+    private const string MyDbContext =
+"""
+using Microsoft.EntityFrameworkCore;
+using System.Collections.Generic;
+
+class User
+{
+    public int Id { get; set; }
+    public string FirstName { get; set; }
+    public string LastName { get; set; }
+}
+
+class MyDbContext : DbContext
+{
+    public DbSet<User> Users { get; init; }
+}
+""";
+
+    [Fact]
+    public Task FromSql_do_not_report()
+        => VerifyCS.VerifyAnalyzerAsync(MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db, int id)
+    {
+        db.Users.FromSql($"SELECT * FROM [Users] WHERE [Id] = {id};");
+    }
+}
+""");
+
+    [Fact]
+    public Task FromSqlInterpolated_do_not_report()
+        => VerifyCS.VerifyAnalyzerAsync(MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db, int id)
+    {
+        db.Users.FromSqlInterpolated($"SELECT * FROM [Users] WHERE [Id] = {id};");
+    }
+}
+""");
+
+    [Fact]
+    public Task ExecuteSql_do_not_report()
+        => VerifyCS.VerifyAnalyzerAsync(MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db, int id)
+    {
+        db.Database.ExecuteSql($"DELETE FROM FROM [Users] WHERE [Id] = {id};");
+    }
+}
+""");
+
+    [Fact]
+    public Task ExecuteSqlInterpolated_do_not_report()
+        => VerifyCS.VerifyAnalyzerAsync(MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db, int id)
+    {
+        db.Database.ExecuteSqlInterpolated($"DELETE FROM FROM [Users] WHERE [Id] = {id};");
+    }
+}
+""");
+
+    [Fact]
+    public Task ExecuteSqlAsync_do_not_report()
+        => VerifyCS.VerifyAnalyzerAsync(MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db, int id)
+    {
+        db.Database.ExecuteSqlAsync($"DELETE FROM FROM [Users] WHERE [Id] = {id};");
+    }
+}
+""");
+
+    [Fact]
+    public Task ExecuteSqlInterpolatedAsync_do_not_report()
+        => VerifyCS.VerifyAnalyzerAsync(MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db, int id)
+    {
+        db.Database.ExecuteSqlInterpolatedAsync($"DELETE FROM FROM [Users] WHERE [Id] = {id};");
+    }
+}
+""");
+
+    [Fact]
+    public Task SqlQuery_do_not_report()
+        => VerifyCS.VerifyAnalyzerAsync(MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db, int id)
+    {
+        db.Database.SqlQuery<int>($"SELECT [Age] FROM [Users] WHERE [Id] = {id};");
+    }
+}
+""");
+
+    #region FromSqlRaw
+
+    [Fact]
+    public Task FromSqlRaw_constant_string_do_not_report()
+        => VerifyCS.VerifyAnalyzerAsync(MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db)
+    {
+        db.Users.FromSqlRaw("SELECT * FROM [Users] WHERE [Id] = 1;");
+    }
+}
+""");
+
+    [Fact]
+    public Task FromSqlRaw_constant_string_with_parameters_do_not_report()
+        => VerifyCS.VerifyAnalyzerAsync(MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db, int id)
+    {
+        db.Users.FromSqlRaw("SELECT * FROM [Users] WHERE [Id] = {0};", id);
+    }
+}
+""");
+
+    [Fact]
+    public Task FromSqlRaw_interpolated_string_report()
+        => VerifyCS.VerifyCodeFixAsync(MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db, int id)
+    {
+        db.Users.[|FromSqlRaw|]($"SELECT * FROM [Users] WHERE [Id] = {id};");
+    }
+}
+""", MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db, int id)
+    {
+        db.Users.FromSql($"SELECT * FROM [Users] WHERE [Id] = {id};");
+    }
+}
+""");
+
+    [Fact]
+    public async Task FromSqlRaw_interpolated_string_with_other_parameters_report()
+    {
+        var source = MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db, int id)
+    {
+        db.Users.[|FromSqlRaw|]($"SELECT * FROM [Users] WHERE [Id] = {id};", id);
+    }
+}
+""";
+
+        await VerifyCS.VerifyCodeFixAsync(source, source);
+    }
+
+    [Fact]
+    public Task FromSqlRaw_constant_interpolated_string_do_not_report()
+        => VerifyCS.VerifyAnalyzerAsync(MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db)
+    {
+        const string id = "1";
+        db.Users.FromSqlRaw($"SELECT * FROM [Users] WHERE [Id] = {id};");
+    }
+}
+""");
+
+    [Fact]
+    public Task FromSqlRaw_pseudo_constant_interpolated_string_do_not_report()
+        => VerifyCS.VerifyAnalyzerAsync(MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db)
+    {
+        db.Users.FromSqlRaw($"SELECT [{nameof(MyDbContext)}] FROM [Users] WHERE [Id] = {1};");
+    }
+}
+""");
+
+    [Fact]
+    public Task FromSqlRaw_direct_extension_class_usage_interpolated_string_report()
+        => VerifyCS.VerifyCodeFixAsync(MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db, int id)
+    {
+        RelationalQueryableExtensions.[|FromSqlRaw|](db.Users, $"SELECT * FROM [Users] WHERE [Id] = {id};");
+    }
+}
+""", MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db, int id)
+    {
+        RelationalQueryableExtensions.FromSql(db.Users, $"SELECT * FROM [Users] WHERE [Id] = {id};");
+    }
+}
+""");
+
+    [Fact]
+    public Task FromSqlRaw_direct_extension_class_usage_constant_interpolated_string_do_not_report()
+        => VerifyCS.VerifyAnalyzerAsync(MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db)
+    {
+        const string id = "1";
+        RelationalQueryableExtensions.FromSqlRaw(db.Users, $"SELECT * FROM [Users] WHERE [Id] = {id};");
+    }
+}
+""");
+
+    [Fact]
+    public Task FromSqlRaw_direct_extension_class_usage_pseudo_constant_interpolated_string_do_not_report()
+        => VerifyCS.VerifyAnalyzerAsync(MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db)
+    {
+        RelationalQueryableExtensions.FromSqlRaw(db.Users, $"SELECT [{nameof(MyDbContext)}] FROM [Users] WHERE [Id] = {1};");
+    }
+}
+""");
+
+    [Fact]
+    public Task FromSqlRaw_FixAll()
+        => VerifyCS.VerifyCodeFixAsync(MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db, int id)
+    {
+        db.Users.[|FromSqlRaw|]($"SELECT * FROM [Users] WHERE [Id] = {id};");
+        db.Users.[|FromSqlRaw|]($"SELECT * FROM [Users] WHERE [Id] = {id};");
+    }
+}
+""", MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db, int id)
+    {
+        db.Users.FromSql($"SELECT * FROM [Users] WHERE [Id] = {id};");
+        db.Users.FromSql($"SELECT * FROM [Users] WHERE [Id] = {id};");
+    }
+}
+""");
+
+    #endregion
+
+    #region ExecuteSqlRaw
+
+    [Fact]
+    public Task ExecuteSqlRaw_constant_string_do_not_report()
+        => VerifyCS.VerifyAnalyzerAsync(MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db)
+    {
+        db.Database.ExecuteSqlRaw("DELETE FROM [Users] WHERE [Id] = 1;");
+    }
+}
+""");
+
+    [Fact]
+    public Task ExecuteSqlRaw_constant_string_with_parameters_do_not_report()
+        => VerifyCS.VerifyAnalyzerAsync(MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db, int id)
+    {
+        db.Database.ExecuteSqlRaw("DELETE FROM FROM [Users] WHERE [Id] = {0};", id);
+    }
+}
+""");
+
+    [Fact]
+    public Task ExecuteSqlRaw_interpolated_string_report()
+        => VerifyCS.VerifyCodeFixAsync(MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db, int id)
+    {
+        db.Database.[|ExecuteSqlRaw|]($"DELETE FROM FROM [Users] WHERE [Id] = {id};");
+    }
+}
+""", MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db, int id)
+    {
+        db.Database.ExecuteSql($"DELETE FROM FROM [Users] WHERE [Id] = {id};");
+    }
+}
+""");
+
+    [Fact]
+    public async Task ExecuteSqlRaw_interpolated_string_with_other_parameters_report()
+    {
+        var source = MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db, int id)
+    {
+        db.Database.[|ExecuteSqlRaw|]($"DELETE FROM FROM [Users] WHERE [Id] = {id};", id);
+    }
+}
+""";
+
+        await VerifyCS.VerifyCodeFixAsync(source, source);
+    }
+
+    [Fact]
+    public async Task ExecuteSqlRaw_interpolated_string_with_other_parameters_IEnumerable_report()
+    {
+        var source = MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db, int id)
+    {
+        db.Database.[|ExecuteSqlRaw|]($"DELETE FROM FROM [Users] WHERE [Id] = {id};", (IEnumerable<object>)null);
+    }
+}
+""";
+
+        await VerifyCS.VerifyCodeFixAsync(source, source);
+    }
+
+    [Fact]
+    public Task ExecuteSqlRaw_constant_interpolated_string_do_not_report()
+        => VerifyCS.VerifyAnalyzerAsync(MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db)
+    {
+        const string id = "1";
+        db.Database.ExecuteSqlRaw($"DELETE FROM FROM [Users] WHERE [Id] = {id};");
+    }
+}
+""");
+
+    [Fact]
+    public Task ExecuteSqlRaw_pseudo_constant_interpolated_string_do_not_report()
+        => VerifyCS.VerifyAnalyzerAsync(MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db)
+    {
+        db.Database.ExecuteSqlRaw($"DELETE FROM FROM [Users] WHERE [{nameof(MyDbContext)}] = {1};");
+    }
+}
+""");
+
+    [Fact]
+    public Task ExecuteSqlRaw_direct_extension_class_usage_interpolated_string_report()
+        => VerifyCS.VerifyCodeFixAsync(MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db, int id)
+    {
+        RelationalDatabaseFacadeExtensions.[|ExecuteSqlRaw|](db.Database, $"DELETE FROM FROM [Users] WHERE [Id] = {id};");
+    }
+}
+""", MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db, int id)
+    {
+        RelationalDatabaseFacadeExtensions.ExecuteSql(db.Database, $"DELETE FROM FROM [Users] WHERE [Id] = {id};");
+    }
+}
+""");
+
+    [Fact]
+    public Task ExecuteSqlRaw_direct_extension_class_usage_constant_interpolated_string_do_not_report()
+        => VerifyCS.VerifyAnalyzerAsync(MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db)
+    {
+        const string id = "1";
+        RelationalDatabaseFacadeExtensions.ExecuteSqlRaw(db.Database, $"DELETE FROM FROM [Users] WHERE [Id] = {id};");
+    }
+}
+""");
+
+    [Fact]
+    public Task ExecuteSqlRaw_direct_extension_class_usage_pseudo_constant_interpolated_string_do_not_report()
+        => VerifyCS.VerifyAnalyzerAsync(MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db)
+    {
+        RelationalDatabaseFacadeExtensions.ExecuteSqlRaw(db.Database, $"DELETE FROM FROM [{nameof(MyDbContext)}] WHERE [Id] = {1};");
+    }
+}
+""");
+
+    [Fact]
+    public Task ExecuteSqlRaw_FixAll()
+        => VerifyCS.VerifyCodeFixAsync(MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db, int id)
+    {
+        db.Database.[|ExecuteSqlRaw|]($"DELETE FROM FROM [Users] WHERE [Id] = {id};");
+        db.Database.[|ExecuteSqlRaw|]($"DELETE FROM FROM [Users] WHERE [Id] = {id};");
+    }
+}
+""", MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db, int id)
+    {
+        db.Database.ExecuteSql($"DELETE FROM FROM [Users] WHERE [Id] = {id};");
+        db.Database.ExecuteSql($"DELETE FROM FROM [Users] WHERE [Id] = {id};");
+    }
+}
+""");
+
+    #endregion
+
+    #region ExecuteSqlRawAsync
+
+    [Fact]
+    public Task ExecuteSqlRawAsync_constant_string_do_not_report()
+        => VerifyCS.VerifyAnalyzerAsync(MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db)
+    {
+        db.Database.ExecuteSqlRawAsync("DELETE FROM [Users] WHERE [Id] = 1;");
+    }
+}
+""");
+
+    [Fact]
+    public Task ExecuteSqlRawAsync_constant_string_with_parameters_do_not_report()
+        => VerifyCS.VerifyAnalyzerAsync(MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db, int id)
+    {
+        db.Database.ExecuteSqlRaw("DELETE FROM FROM [Users] WHERE [Id] = {0};", id);
+    }
+}
+""");
+
+    [Fact]
+    public Task ExecuteSqlRawAsync_interpolated_string_report()
+        => VerifyCS.VerifyCodeFixAsync(MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db, int id)
+    {
+        db.Database.[|ExecuteSqlRawAsync|]($"DELETE FROM FROM [Users] WHERE [Id] = {id};");
+    }
+}
+""", MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db, int id)
+    {
+        db.Database.ExecuteSqlAsync($"DELETE FROM FROM [Users] WHERE [Id] = {id};");
+    }
+}
+""");
+
+    [Fact]
+    public async Task ExecuteSqlRawAsync_interpolated_string_with_other_parameters_report()
+    {
+        var source = MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db, int id)
+    {
+        db.Database.[|ExecuteSqlRawAsync|]($"DELETE FROM FROM [Users] WHERE [Id] = {id};", id);
+    }
+}
+""";
+
+        await VerifyCS.VerifyCodeFixAsync(source, source);
+    }
+
+    [Fact]
+    public async Task ExecuteSqlRawAsync_interpolated_string_with_other_parameters_IEnumerable_report()
+    {
+        var source = MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db, int id)
+    {
+        db.Database.[|ExecuteSqlRawAsync|]($"DELETE FROM FROM [Users] WHERE [Id] = {id};", (IEnumerable<object>)null);
+    }
+}
+""";
+
+        await VerifyCS.VerifyCodeFixAsync(source, source);
+    }
+
+    [Fact]
+    public Task ExecuteSqlRawAsync_constant_interpolated_string_do_not_report()
+        => VerifyCS.VerifyAnalyzerAsync(MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db)
+    {
+        const string id = "1";
+        db.Database.ExecuteSqlRawAsync($"DELETE FROM FROM [Users] WHERE [Id] = {id};");
+    }
+}
+""");
+
+    [Fact]
+    public Task ExecuteSqlRawAsync_pseudo_constant_interpolated_string_do_not_report()
+        => VerifyCS.VerifyAnalyzerAsync(MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db)
+    {
+        const string id = "1";
+        db.Database.ExecuteSqlRawAsync($"DELETE FROM FROM [{nameof(MyDbContext)}] WHERE [Id] = {1};");
+    }
+}
+""");
+
+    [Fact]
+    public Task ExecuteSqlRawAsync_direct_extension_class_usage_interpolated_string_report()
+        => VerifyCS.VerifyCodeFixAsync(MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db, int id)
+    {
+        RelationalDatabaseFacadeExtensions.[|ExecuteSqlRawAsync|](db.Database, $"DELETE FROM FROM [Users] WHERE [Id] = {id};");
+    }
+}
+""", MyDbContext + """
+class C
+{
+    void M(MyDbContext db, int id)
+    {
+        RelationalDatabaseFacadeExtensions.ExecuteSqlAsync(db.Database, $"DELETE FROM FROM [Users] WHERE [Id] = {id};");
+    }
+}
+""");
+
+    [Fact]
+    public Task ExecuteSqlRawAsync_direct_extension_class_usage_constant_interpolated_string_do_not_report()
+        => VerifyCS.VerifyAnalyzerAsync(MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db)
+    {
+        const string id = "1";
+        RelationalDatabaseFacadeExtensions.ExecuteSqlRawAsync(db.Database, $"DELETE FROM FROM [Users] WHERE [Id] = {id};");
+    }
+}
+""");
+
+    [Fact]
+    public Task ExecuteSqlRawAsync_direct_extension_class_usage_pseudo_constant_interpolated_string_do_not_report()
+        => VerifyCS.VerifyAnalyzerAsync(MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db)
+    {
+        RelationalDatabaseFacadeExtensions.ExecuteSqlRawAsync(db.Database, $"DELETE FROM FROM [{nameof(MyDbContext)}] WHERE [Id] = {1};");
+    }
+}
+""");
+
+    [Fact]
+    public Task ExecuteSqlRawAsync_FixAll()
+        => VerifyCS.VerifyCodeFixAsync(MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db, int id)
+    {
+        db.Database.[|ExecuteSqlRawAsync|]($"DELETE FROM FROM [Users] WHERE [Id] = {id};");
+        db.Database.[|ExecuteSqlRawAsync|]($"DELETE FROM FROM [Users] WHERE [Id] = {id};");
+    }
+}
+""", MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db, int id)
+    {
+        db.Database.ExecuteSqlAsync($"DELETE FROM FROM [Users] WHERE [Id] = {id};");
+        db.Database.ExecuteSqlAsync($"DELETE FROM FROM [Users] WHERE [Id] = {id};");
+    }
+}
+""");
+
+    #endregion
+
+    #region SqlQueryRaw
+
+    [Fact]
+    public Task SqlQueryRaw_constant_string_do_not_report()
+        => VerifyCS.VerifyAnalyzerAsync(MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db)
+    {
+        db.Database.SqlQueryRaw<int>("SELECT [Age] FROM [Users] WHERE [Id] = 1;");
+    }
+}
+""");
+
+    [Fact]
+    public Task SqlQueryRaw_constant_string_with_parameters_do_not_report()
+        => VerifyCS.VerifyAnalyzerAsync(MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db, int id)
+    {
+        db.Database.SqlQueryRaw<int>("SELECT [Age] FROM [Users] WHERE [Id] = {0};", id);
+    }
+}
+""");
+
+    [Fact]
+    public Task SqlQueryRaw_interpolated_string_report()
+        => VerifyCS.VerifyCodeFixAsync(MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db, int id)
+    {
+        db.Database.[|SqlQueryRaw|]<int>($"SELECT [Age] FROM [Users] WHERE [Id] = {id};");
+    }
+}
+""", MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db, int id)
+    {
+        db.Database.SqlQuery<int>($"SELECT [Age] FROM [Users] WHERE [Id] = {id};");
+    }
+}
+""");
+
+    [Fact]
+    public async Task SqlQueryRaw_interpolated_string_with_other_parameters_report()
+    {
+        var source = MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db, int id)
+    {
+        db.Database.[|SqlQueryRaw|]<int>($"SELECT [Age] FROM [Users] WHERE [Id] = {id};", id);
+    }
+}
+""";
+
+        await VerifyCS.VerifyCodeFixAsync(source, source);
+    }
+
+    [Fact]
+    public Task SqlQueryRaw_constant_interpolated_string_do_not_report()
+        => VerifyCS.VerifyAnalyzerAsync(MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db)
+    {
+        const string id = "1";
+        db.Database.SqlQueryRaw<int>($"SELECT [Age] FROM [Users] WHERE [Id] = {id};");
+    }
+}
+""");
+
+    [Fact]
+    public Task SqlQueryRaw_pseudo_constant_interpolated_string_do_not_report()
+        => VerifyCS.VerifyAnalyzerAsync(MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db)
+    {
+        db.Database.SqlQueryRaw<int>($"SELECT [{nameof(MyDbContext)}] FROM [Users] WHERE [Id] = {1};");
+    }
+}
+""");
+
+    [Fact]
+    public Task SqlQueryRaw_direct_extension_class_usage_interpolated_string_report()
+        => VerifyCS.VerifyCodeFixAsync(MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db, int id)
+    {
+        RelationalDatabaseFacadeExtensions.[|SqlQueryRaw|]<int>(db.Database, $"SELECT [Age] FROM [Users] WHERE [Id] = {id};");
+    }
+}
+""", MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db, int id)
+    {
+        RelationalDatabaseFacadeExtensions.SqlQuery<int>(db.Database, $"SELECT [Age] FROM [Users] WHERE [Id] = {id};");
+    }
+}
+""");
+
+    [Fact]
+    public Task SqlQueryRaw_direct_extension_class_usage_constant_interpolated_string_do_not_report()
+        => VerifyCS.VerifyAnalyzerAsync(MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db)
+    {
+        const string id = "1";
+        RelationalDatabaseFacadeExtensions.SqlQueryRaw<int>(db.Database, $"SELECT [Age] FROM [Users] WHERE [Id] = {id};");
+    }
+}
+""");
+
+    [Fact]
+    public Task SqlQueryRaw_direct_extension_class_usage_pseudo_constant_interpolated_string_do_not_report()
+        => VerifyCS.VerifyAnalyzerAsync(MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db)
+    {
+        RelationalDatabaseFacadeExtensions.SqlQueryRaw<int>(db.Database, $"SELECT [{nameof(MyDbContext)}] FROM [Users] WHERE [Id] = {1};");
+    }
+}
+""");
+
+    [Fact]
+    public Task SqlQueryRaw_FixAll()
+        => VerifyCS.VerifyCodeFixAsync(MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db, int id)
+    {
+        db.Database.[|SqlQueryRaw|]<int>($"SELECT [Age] FROM [Users] WHERE [Id] = {id};");
+        db.Database.[|SqlQueryRaw|]<int>($"SELECT [Age] FROM [Users] WHERE [Id] = {id};");
+    }
+}
+""", MyDbContext +
+"""
+class C
+{
+    void M(MyDbContext db, int id)
+    {
+        db.Database.SqlQuery<int>($"SELECT [Age] FROM [Users] WHERE [Id] = {id};");
+        db.Database.SqlQuery<int>($"SELECT [Age] FROM [Users] WHERE [Id] = {id};");
+    }
+}
+""");
+
+    #endregion
+}
diff --git a/test/EFCore.Analyzers.Tests/Utilities/CSharpCodeFixVerifier.cs b/test/EFCore.Analyzers.Tests/Utilities/CSharpCodeFixVerifier.cs
new file mode 100644
index 0000000000..2f6d0b87a0
--- /dev/null
+++ b/test/EFCore.Analyzers.Tests/Utilities/CSharpCodeFixVerifier.cs
@@ -0,0 +1,56 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Immutable;
+using Microsoft.CodeAnalysis;
+using Microsoft.CodeAnalysis.CodeFixes;
+using Microsoft.CodeAnalysis.CSharp.Testing;
+using Microsoft.CodeAnalysis.Diagnostics;
+using Microsoft.CodeAnalysis.Testing;
+using Microsoft.CodeAnalysis.Testing.Model;
+using Microsoft.CodeAnalysis.Testing.Verifiers;
+
+namespace Microsoft.EntityFrameworkCore.Utilities;
+
+public static class CSharpCodeFixVerifier<TAnalyzer, TCodeFix>
+    where TAnalyzer : DiagnosticAnalyzer, new()
+    where TCodeFix : CodeFixProvider, new()
+{
+    public static DiagnosticResult Diagnostic(string diagnosticId)
+        => CSharpAnalyzerVerifier<TAnalyzer, XUnitVerifier>.Diagnostic(diagnosticId);
+
+    public static Task VerifyAnalyzerAsync(string source, params DiagnosticResult[] expected)
+    {
+        var test = new Test { TestCode = source };
+        test.ExpectedDiagnostics.AddRange(expected);
+        return test.RunAsync();
+    }
+
+    public static async Task VerifyCodeFixAsync(string source, string fixedSource)
+    {
+        var test = new Test
+        {
+            TestCode = source,
+            FixedCode = fixedSource
+        };
+
+        await test.RunAsync();
+    }
+
+    public class Test : CSharpCodeFixTest<TAnalyzer, TCodeFix, XUnitVerifier>
+    {
+        protected override async Task<Project> CreateProjectImplAsync(EvaluatedProjectState primaryProject, ImmutableArray<EvaluatedProjectState> additionalProjects, CancellationToken cancellationToken)
+        {
+            var metadataReferences
+                = Extensions.DependencyModel.DependencyContext.Load(GetType().Assembly)
+                    .CompileLibraries
+                    .SelectMany(c => c.ResolveReferencePaths())
+                    .Select(path => MetadataReference.CreateFromFile(path))
+                    .Cast<MetadataReference>()
+                    .ToList();
+
+            var project = await base.CreateProjectImplAsync(primaryProject, additionalProjects, cancellationToken).ConfigureAwait(false);
+            return project.WithMetadataReferences(metadataReferences);
+        }
+    }
+}
