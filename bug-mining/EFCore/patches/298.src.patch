diff --git a/src/EFCore.Relational/Query/RelationalShapedQueryCompilingExpressionVisitor.ShaperProcessingExpressionVisitor.cs b/src/EFCore.Relational/Query/RelationalShapedQueryCompilingExpressionVisitor.ShaperProcessingExpressionVisitor.cs
index 6ae1fcfc83..0ced6ea5a9 100644
--- a/src/EFCore.Relational/Query/RelationalShapedQueryCompilingExpressionVisitor.ShaperProcessingExpressionVisitor.cs
+++ b/src/EFCore.Relational/Query/RelationalShapedQueryCompilingExpressionVisitor.ShaperProcessingExpressionVisitor.cs
@@ -1204,10 +1204,13 @@ protected override Expression VisitMethodCall(MethodCallExpression methodCallExp
 
                     if (property!.IsPrimaryKey())
                     {
-                        return MakeIndex(
+                        var valueExpression = MakeIndex(
                             keyPropertyValuesParameter,
                             ObjectArrayIndexerPropertyInfo,
                             new[] { Constant(index) });
+                        return methodCallExpression.Type != valueExpression.Type
+                            ? Convert(valueExpression, methodCallExpression.Type)
+                            : valueExpression;
                     }
 
                     var jsonReaderManagerParameter = _jsonReaderDataToJsonReaderManagerParameterMapping[jsonReaderDataParameter];
@@ -1266,6 +1269,7 @@ protected override Expression VisitMethodCall(MethodCallExpression methodCallExp
             INavigation? navigation)
         {
             var jsonReaderDataShaperLambdaParameter = Parameter(typeof(JsonReaderData));
+            // TODO: Use ISnapshot instead #26544
             var keyValuesShaperLambdaParameter = Parameter(typeof(object[]));
             var shaperBlockVariables = new List<ParameterExpression>();
             var shaperBlockExpressions = new List<Expression>();
@@ -1554,7 +1558,7 @@ protected override Expression VisitSwitch(SwitchExpression switchExpression)
                         new ValueBufferTryReadValueMethodsFinder(_entityType).FindValueBufferTryReadValueMethods(body);
 
                     BlockExpression jsonEntityTypeInitializerBlock;
-                    //sometimes we have shadow value buffer and sometimes not, but type initializer always comes last
+                    //sometimes we have shadow snapshot and sometimes not, but type initializer always comes last
                     switch (body.Expressions[^1])
                     {
                         case UnaryExpression { Operand: BlockExpression innerBlock } jsonEntityTypeInitializerUnary
@@ -1665,7 +1669,7 @@ protected override Expression VisitSwitch(SwitchExpression switchExpression)
                     // we can't use simple ExpressionReplacingVisitor, because there could be multiple instances of MethodCallExpression for given property
                     // using dedicated mini-visitor that looks for MCEs with a given shape and compare the IProperty inside
                     // order is:
-                    // - shadow value buffer (if there was one)
+                    // - shadow snapshot (if there was one)
                     // - entity construction / property assignments
                     // - navigation fixups
                     // - entity instance variable that is returned as end result
@@ -1675,14 +1679,17 @@ protected override Expression VisitSwitch(SwitchExpression switchExpression)
                     if (body.Expressions[0] is BinaryExpression
                         {
                             NodeType: ExpressionType.Assign,
-                            Right: NewExpression
+                            Right: UnaryExpression
                             {
-                                Arguments: [NewArrayExpression]
+                                NodeType: ExpressionType.Convert,
+                                Operand: NewExpression
                             }
-                        } shadowValueBufferAssignment
-                        && shadowValueBufferAssignment.Type == typeof(ValueBuffer))
+                        } shadowSnapshotAssignment
+#pragma warning disable EF1001 // Internal EF Core API usage.
+                        && shadowSnapshotAssignment.Type == typeof(ISnapshot))
+#pragma warning restore EF1001 // Internal EF Core API usage.
                     {
-                        finalBlockExpressions.Add(propertyAssignmentReplacer.Visit(shadowValueBufferAssignment));
+                        finalBlockExpressions.Add(propertyAssignmentReplacer.Visit(shadowSnapshotAssignment));
                     }
 
                     foreach (var jsonEntityTypeInitializerBlockExpression in jsonEntityTypeInitializerBlock.Expressions.ToArray()[..^1])
@@ -1881,7 +1888,7 @@ protected override Expression VisitConditional(ConditionalExpression conditional
                     {
                         Assign(entityAlreadyTrackedVariable, Constant(false)),
 
-                        // shadowValueBuffer = ValueBuffer;
+                        // shadowSnapshot = Snapshot.Empty;
                         ifFalseBlock.Expressions[0],
 
                         // entityType = EntityType;
@@ -1904,12 +1911,12 @@ protected override Expression VisitConditional(ConditionalExpression conditional
                     var newInstanceAssignmentVariables = instanceAssignmentBody.Variables.ToList();
                     var newInstanceAssignmentExpressions = new List<Expression>();
 
-                    // we only need to generate shadowValueBuffer if the entity isn't already tracked
-                    // shadow value buffer can be generated early in the block (default)
+                    // we only need to generate shadowSnapshot if the entity isn't already tracked
+                    // shadow snapshot can be generated early in the block (default)
                     // or after we read all the values from JSON (case when the entity has some shadow properties)
-                    // so we loop through the existing expressions and add the condition to value buffer assignment when we find it
+                    // so we loop through the existing expressions and add the condition to snapshot assignment when we find it
                     // expressions processed here:
-                    // shadowValueBuffer = new ValueBuffer(...)
+                    // shadowSnapshot = new Snapshot(...)
                     // jsonManagerPrm = new Utf8JsonReaderManager(jsonReaderDataPrm);
                     // tokenType = jsonManagerPrm.TokenType;
                     // property_reading_loop(...)
@@ -1917,7 +1924,7 @@ protected override Expression VisitConditional(ConditionalExpression conditional
                     for (var i = 0; i < 5; i++)
                     {
                         newInstanceAssignmentExpressions.Add(
-                            instanceAssignmentBody.Expressions[i].Type == typeof(ValueBuffer)
+                            instanceAssignmentBody.Expressions[i].Type == typeof(ISnapshot)
                                 ? IfThen(
                                     Not(entityAlreadyTrackedVariable),
                                     instanceAssignmentBody.Expressions[i])
diff --git a/src/EFCore/ChangeTracking/IDependentKeyValueFactory`.cs b/src/EFCore/ChangeTracking/IDependentKeyValueFactory`.cs
index 1dc4295a22..3022ba1739 100644
--- a/src/EFCore/ChangeTracking/IDependentKeyValueFactory`.cs
+++ b/src/EFCore/ChangeTracking/IDependentKeyValueFactory`.cs
@@ -29,6 +29,7 @@ public interface IDependentKeyValueFactory<TKey> : IDependentKeyValueFactory
     /// <param name="key">The key instance.</param>
     /// <returns><see langword="true" /> if the key instance was created; <see langword="false" /> otherwise.</returns>
     [ContractAnnotation("=>true, key:notnull; =>false, key:null")]
+    [Obsolete]
     bool TryCreateFromBuffer(in ValueBuffer valueBuffer, [NotNullWhen(true)] out TKey? key);
 
     /// <summary>
diff --git a/src/EFCore/ChangeTracking/IPrincipalKeyValueFactory`.cs b/src/EFCore/ChangeTracking/IPrincipalKeyValueFactory`.cs
index 0d9e90429a..73093c4313 100644
--- a/src/EFCore/ChangeTracking/IPrincipalKeyValueFactory`.cs
+++ b/src/EFCore/ChangeTracking/IPrincipalKeyValueFactory`.cs
@@ -31,6 +31,7 @@ public interface IPrincipalKeyValueFactory<TKey> : IPrincipalKeyValueFactory
     /// </summary>
     /// <param name="valueBuffer">The buffer containing key values.</param>
     /// <returns>The key object, or null if any of the key values were null.</returns>
+    [Obsolete]
     object? CreateFromBuffer(ValueBuffer valueBuffer);
 
     /// <summary>
diff --git a/src/EFCore/ChangeTracking/Internal/CurrentValueComparerFactory.cs b/src/EFCore/ChangeTracking/Internal/CurrentValueComparerFactory.cs
index cf00bc77de..ab29fa3d62 100644
--- a/src/EFCore/ChangeTracking/Internal/CurrentValueComparerFactory.cs
+++ b/src/EFCore/ChangeTracking/Internal/CurrentValueComparerFactory.cs
@@ -19,73 +19,70 @@ public class CurrentValueComparerFactory
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    public virtual IComparer<IUpdateEntry> Create(IPropertyBase propertyBase)
+    public virtual IComparer<IUpdateEntry> Create(IProperty property)
     {
-        var modelType = propertyBase.ClrType;
+        var modelType = property.ClrType;
         var nonNullableModelType = modelType.UnwrapNullableType();
         if (IsGenericComparable(modelType, nonNullableModelType))
         {
             return (IComparer<IUpdateEntry>)Activator.CreateInstance(
                 typeof(EntryCurrentValueComparer<>).MakeGenericType(modelType),
-                propertyBase)!;
+                property)!;
         }
 
         if (typeof(IStructuralComparable).IsAssignableFrom(nonNullableModelType))
         {
-            return new StructuralEntryCurrentValueComparer(propertyBase);
+            return new StructuralEntryCurrentValueComparer(property);
         }
 
         if (typeof(IComparable).IsAssignableFrom(nonNullableModelType))
         {
-            return new EntryCurrentValueComparer(propertyBase);
+            return new EntryCurrentValueComparer(property);
         }
 
-        if (propertyBase is IProperty property)
+        var converter = property.GetTypeMapping().Converter;
+        if (converter != null)
         {
-            var converter = property.GetTypeMapping().Converter;
-            if (converter != null)
+            var providerType = converter.ProviderClrType;
+            var nonNullableProviderType = providerType.UnwrapNullableType();
+            if (IsGenericComparable(providerType, nonNullableProviderType))
             {
-                var providerType = converter.ProviderClrType;
-                var nonNullableProviderType = providerType.UnwrapNullableType();
-                if (IsGenericComparable(providerType, nonNullableProviderType))
-                {
-                    var elementType = property.GetElementType();
-                    var modelBaseType = elementType != null
-                        ? typeof(IEnumerable<>).MakeGenericType(elementType.ClrType)
-                        : modelType;
-                    var comparerType = modelType.IsClass
-                        ? typeof(NullableClassCurrentProviderValueComparer<,>).MakeGenericType(modelBaseType, providerType)
-                        : modelType == converter.ModelClrType
-                            ? typeof(CurrentProviderValueComparer<,>).MakeGenericType(modelBaseType, providerType)
-                            : typeof(NullableStructCurrentProviderValueComparer<,>).MakeGenericType(
-                                nonNullableModelType, providerType);
+                var elementType = property.GetElementType();
+                var modelBaseType = elementType != null
+                    ? typeof(IEnumerable<>).MakeGenericType(elementType.ClrType)
+                    : modelType;
+                var comparerType = modelType.IsClass
+                    ? typeof(NullableClassCurrentProviderValueComparer<,>).MakeGenericType(modelBaseType, providerType)
+                    : modelType == converter.ModelClrType
+                        ? typeof(CurrentProviderValueComparer<,>).MakeGenericType(modelBaseType, providerType)
+                        : typeof(NullableStructCurrentProviderValueComparer<,>).MakeGenericType(
+                            nonNullableModelType, providerType);
 
-                    return (IComparer<IUpdateEntry>)Activator.CreateInstance(comparerType, propertyBase, converter)!;
-                }
-
-                if (typeof(IStructuralComparable).IsAssignableFrom(nonNullableProviderType))
-                {
-                    return new StructuralEntryCurrentProviderValueComparer(propertyBase, converter);
-                }
+                return (IComparer<IUpdateEntry>)Activator.CreateInstance(comparerType, property, converter)!;
+            }
 
-                if (typeof(IComparable).IsAssignableFrom(nonNullableProviderType))
-                {
-                    return new EntryCurrentProviderValueComparer(propertyBase, converter);
-                }
+            if (typeof(IStructuralComparable).IsAssignableFrom(nonNullableProviderType))
+            {
+                return new StructuralEntryCurrentProviderValueComparer(property, converter);
+            }
 
-                throw new InvalidOperationException(
-                    CoreStrings.NonComparableKeyTypes(
-                        propertyBase.DeclaringType.DisplayName(),
-                        propertyBase.Name,
-                        modelType.ShortDisplayName(),
-                        providerType.ShortDisplayName()));
+            if (typeof(IComparable).IsAssignableFrom(nonNullableProviderType))
+            {
+                return new EntryCurrentProviderValueComparer(property, converter);
             }
+
+            throw new InvalidOperationException(
+                CoreStrings.NonComparableKeyTypes(
+                    property.DeclaringType.DisplayName(),
+                    property.Name,
+                    modelType.ShortDisplayName(),
+                    providerType.ShortDisplayName()));
         }
 
         throw new InvalidOperationException(
             CoreStrings.NonComparableKeyType(
-                propertyBase.DeclaringType.DisplayName(),
-                propertyBase.Name,
+                property.DeclaringType.DisplayName(),
+                property.Name,
                 modelType.ShortDisplayName()));
 
         static bool IsGenericComparable(Type type, Type nonNullableType)
diff --git a/src/EFCore/ChangeTracking/Internal/EmptyShadowValuesFactoryFactory.cs b/src/EFCore/ChangeTracking/Internal/EmptyShadowValuesFactoryFactory.cs
index b30f0f8ba2..1771645c96 100644
--- a/src/EFCore/ChangeTracking/Internal/EmptyShadowValuesFactoryFactory.cs
+++ b/src/EFCore/ChangeTracking/Internal/EmptyShadowValuesFactoryFactory.cs
@@ -13,6 +13,18 @@ namespace Microsoft.EntityFrameworkCore.ChangeTracking.Internal;
 /// </summary>
 public class EmptyShadowValuesFactoryFactory : SnapshotFactoryFactory
 {
+    private EmptyShadowValuesFactoryFactory()
+    {
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public static readonly EmptyShadowValuesFactoryFactory Instance = new();
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -55,7 +67,7 @@ protected override bool UseEntityVariable
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    protected override Expression CreateReadShadowValueExpression(ParameterExpression? parameter, IPropertyBase property)
+    protected override Expression CreateReadShadowValueExpression(Expression? parameter, IPropertyBase property)
         => Expression.Default(property.ClrType);
 
     /// <summary>
@@ -64,6 +76,6 @@ protected override Expression CreateReadShadowValueExpression(ParameterExpressio
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    protected override Expression CreateReadValueExpression(ParameterExpression? parameter, IPropertyBase property)
+    protected override Expression CreateReadValueExpression(Expression? parameter, IPropertyBase property)
         => Expression.Default(property.ClrType);
 }
diff --git a/src/EFCore/ChangeTracking/Internal/EntryCurrentProviderValueComparer.cs b/src/EFCore/ChangeTracking/Internal/EntryCurrentProviderValueComparer.cs
index a493a04edc..2d095cb7ca 100644
--- a/src/EFCore/ChangeTracking/Internal/EntryCurrentProviderValueComparer.cs
+++ b/src/EFCore/ChangeTracking/Internal/EntryCurrentProviderValueComparer.cs
@@ -20,7 +20,7 @@ public class EntryCurrentProviderValueComparer : EntryCurrentValueComparer
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
     public EntryCurrentProviderValueComparer(
-        IPropertyBase property,
+        IProperty property,
         ValueConverter converter)
         : base(property)
     {
diff --git a/src/EFCore/ChangeTracking/Internal/EntryCurrentValueComparer.cs b/src/EFCore/ChangeTracking/Internal/EntryCurrentValueComparer.cs
index fc3d909480..97ccd1d78c 100644
--- a/src/EFCore/ChangeTracking/Internal/EntryCurrentValueComparer.cs
+++ b/src/EFCore/ChangeTracking/Internal/EntryCurrentValueComparer.cs
@@ -13,7 +13,7 @@ namespace Microsoft.EntityFrameworkCore.ChangeTracking.Internal;
 /// </summary>
 public class EntryCurrentValueComparer : IComparer<IUpdateEntry>, IEqualityComparer<IUpdateEntry>
 {
-    private readonly IPropertyBase _property;
+    private readonly IProperty _property;
     private readonly IComparer _underlyingComparer;
 
     /// <summary>
@@ -22,7 +22,7 @@ public class EntryCurrentValueComparer : IComparer<IUpdateEntry>, IEqualityCompa
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    public EntryCurrentValueComparer(IPropertyBase property)
+    public EntryCurrentValueComparer(IProperty property)
         : this(property, Comparer.Default)
     {
     }
@@ -33,7 +33,7 @@ public EntryCurrentValueComparer(IPropertyBase property)
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    public EntryCurrentValueComparer(IPropertyBase property, IComparer underlyingComparer)
+    public EntryCurrentValueComparer(IProperty property, IComparer underlyingComparer)
     {
         _property = property;
         _underlyingComparer = underlyingComparer;
diff --git a/src/EFCore/ChangeTracking/Internal/IIdentityMap.cs b/src/EFCore/ChangeTracking/Internal/IIdentityMap.cs
index 16a6d372c2..8b4c536350 100644
--- a/src/EFCore/ChangeTracking/Internal/IIdentityMap.cs
+++ b/src/EFCore/ChangeTracking/Internal/IIdentityMap.cs
@@ -27,22 +27,6 @@ public interface IIdentityMap
     /// </summary>
     IEnumerable<InternalEntityEntry> All();
 
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    bool Contains(in ValueBuffer valueBuffer);
-
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    bool Contains(IForeignKey foreignKey, in ValueBuffer valueBuffer);
-
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
diff --git a/src/EFCore/ChangeTracking/Internal/ISnapshot.cs b/src/EFCore/ChangeTracking/Internal/ISnapshot.cs
index a13ac2a0a6..0936212ee6 100644
--- a/src/EFCore/ChangeTracking/Internal/ISnapshot.cs
+++ b/src/EFCore/ChangeTracking/Internal/ISnapshot.cs
@@ -26,4 +26,13 @@ public interface ISnapshot
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
     T GetValue<T>(int index);
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    bool IsEmpty
+        => false;
 }
diff --git a/src/EFCore/ChangeTracking/Internal/IStateManager.cs b/src/EFCore/ChangeTracking/Internal/IStateManager.cs
index 04c4b39b9d..03df891566 100644
--- a/src/EFCore/ChangeTracking/Internal/IStateManager.cs
+++ b/src/EFCore/ChangeTracking/Internal/IStateManager.cs
@@ -84,7 +84,7 @@ public interface IStateManager : IResettableService
     InternalEntityEntry StartTrackingFromQuery(
         IEntityType baseEntityType,
         object entity,
-        in ValueBuffer valueBuffer);
+        in ISnapshot snapshot);
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
diff --git a/src/EFCore/ChangeTracking/Internal/IdentityMap.cs b/src/EFCore/ChangeTracking/Internal/IdentityMap.cs
index 830a062ac7..1c4e6b8d1c 100644
--- a/src/EFCore/ChangeTracking/Internal/IdentityMap.cs
+++ b/src/EFCore/ChangeTracking/Internal/IdentityMap.cs
@@ -69,28 +69,6 @@ public class IdentityMap<TKey> : IIdentityMap<TKey>
     public virtual IEnumerable<InternalEntityEntry> All()
         => _identityMap.Values;
 
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public virtual bool Contains(in ValueBuffer valueBuffer)
-    {
-        var key = PrincipalKeyValueFactory.CreateFromBuffer(valueBuffer);
-        return key != null && _identityMap.ContainsKey((TKey)key);
-    }
-
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public virtual bool Contains(IForeignKey foreignKey, in ValueBuffer valueBuffer)
-        => foreignKey.GetDependentKeyValueFactory<TKey>().TryCreateFromBuffer(valueBuffer, out var key)
-            && _identityMap.ContainsKey(key);
-
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
diff --git a/src/EFCore/ChangeTracking/Internal/InternalEntityEntry.cs b/src/EFCore/ChangeTracking/Internal/InternalEntityEntry.cs
index 846a23acc3..040737495a 100644
--- a/src/EFCore/ChangeTracking/Internal/InternalEntityEntry.cs
+++ b/src/EFCore/ChangeTracking/Internal/InternalEntityEntry.cs
@@ -61,12 +61,48 @@ public sealed partial class InternalEntityEntry : IUpdateEntry
         IStateManager stateManager,
         IEntityType entityType,
         object entity,
-        in ValueBuffer valueBuffer)
+        in ISnapshot snapshot)
     {
         StateManager = stateManager;
         EntityType = (IRuntimeEntityType)entityType;
         Entity = entity;
-        _shadowValues = EntityType.ShadowValuesFactory(valueBuffer);
+        _shadowValues = snapshot;
+        _stateData = new StateData(EntityType.PropertyCount, EntityType.NavigationCount);
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public InternalEntityEntry(
+        IStateManager stateManager,
+        IEntityType entityType,
+        IDictionary<string, object?> values,
+        IEntityMaterializerSource entityMaterializerSource)
+    {
+        StateManager = stateManager;
+        EntityType = (IRuntimeEntityType)entityType;
+
+        var valuesArray = new object?[EntityType.PropertyCount];
+        var shadowPropertyValuesArray = EntityType.ShadowValuesFactory(values);
+        foreach (var property in entityType.GetFlattenedProperties())
+        {
+            var index = property.GetIndex();
+            if (index < 0)
+            {
+                continue;
+            }
+
+            valuesArray[index] = values.TryGetValue(property.Name, out var value)
+                ? value
+                : property.Sentinel;
+        }
+
+        Entity = entityType.GetOrCreateMaterializer(entityMaterializerSource)(
+            new MaterializationContext(new ValueBuffer(valuesArray), stateManager.Context));
+        _shadowValues = EntityType.ShadowValuesFactory(values);
         _stateData = new StateData(EntityType.PropertyCount, EntityType.NavigationCount);
     }
 
diff --git a/src/EFCore/ChangeTracking/Internal/OriginalValuesFactoryFactory.cs b/src/EFCore/ChangeTracking/Internal/OriginalValuesFactoryFactory.cs
index cb38d9f687..5f7c67314f 100644
--- a/src/EFCore/ChangeTracking/Internal/OriginalValuesFactoryFactory.cs
+++ b/src/EFCore/ChangeTracking/Internal/OriginalValuesFactoryFactory.cs
@@ -13,6 +13,18 @@ namespace Microsoft.EntityFrameworkCore.ChangeTracking.Internal;
 /// </summary>
 public class OriginalValuesFactoryFactory : SnapshotFactoryFactory<InternalEntityEntry>
 {
+    private OriginalValuesFactoryFactory()
+    {
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public static readonly OriginalValuesFactoryFactory Instance = new();
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
diff --git a/src/EFCore/ChangeTracking/Internal/RelationshipSnapshotFactoryFactory.cs b/src/EFCore/ChangeTracking/Internal/RelationshipSnapshotFactoryFactory.cs
index 548aceb526..4c7b7b5d8b 100644
--- a/src/EFCore/ChangeTracking/Internal/RelationshipSnapshotFactoryFactory.cs
+++ b/src/EFCore/ChangeTracking/Internal/RelationshipSnapshotFactoryFactory.cs
@@ -13,6 +13,18 @@ namespace Microsoft.EntityFrameworkCore.ChangeTracking.Internal;
 /// </summary>
 public class RelationshipSnapshotFactoryFactory : SnapshotFactoryFactory<InternalEntityEntry>
 {
+    private RelationshipSnapshotFactoryFactory()
+    {
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public static readonly RelationshipSnapshotFactoryFactory Instance = new();
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
diff --git a/src/EFCore/ChangeTracking/Internal/ShadowValuesFactoryFactory.cs b/src/EFCore/ChangeTracking/Internal/ShadowValuesFactoryFactory.cs
index 579768ad38..6b8e153dd8 100644
--- a/src/EFCore/ChangeTracking/Internal/ShadowValuesFactoryFactory.cs
+++ b/src/EFCore/ChangeTracking/Internal/ShadowValuesFactoryFactory.cs
@@ -11,8 +11,20 @@ namespace Microsoft.EntityFrameworkCore.ChangeTracking.Internal;
 ///     any release. You should only use it directly in your code with extreme caution and knowing that
 ///     doing so can result in application failures when updating to a new Entity Framework Core release.
 /// </summary>
-public class ShadowValuesFactoryFactory : SnapshotFactoryFactory<ValueBuffer>
+public class ShadowValuesFactoryFactory : SnapshotFactoryFactory<IDictionary<string, object?>>
 {
+    private ShadowValuesFactoryFactory()
+    {
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public static readonly ShadowValuesFactoryFactory Instance = new();
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -49,6 +61,12 @@ protected override int GetPropertyCount(IRuntimeEntityType entityType)
     protected override bool UseEntityVariable
         => false;
 
+    internal static readonly MethodInfo ContainsKeyMethod =
+        typeof(IDictionary<string, object?>).GetMethod(nameof(IDictionary<string, object?>.ContainsKey), new[] { typeof(string) })!;
+
+    private static readonly PropertyInfo DictionaryIndexer
+        = typeof(IDictionary<string, object?>).GetRuntimeProperties().Single(p => p.GetIndexParameters().Length > 0);
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -56,14 +74,33 @@ protected override bool UseEntityVariable
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
     protected override Expression CreateReadShadowValueExpression(
-        ParameterExpression? parameter,
+        Expression? parameter,
         IPropertyBase property)
-        => Expression.Convert(
-            Expression.Call(
+    {
+        if (parameter == null)
+        {
+            return Expression.Default(property.ClrType);
+        }
+
+        if (parameter is NewArrayExpression newArrayExpression)
+        {
+            var valueExpression = newArrayExpression.Expressions[property.GetShadowIndex()];
+            valueExpression = ((UnaryExpression)valueExpression).Operand; // Unwrap cast
+            return valueExpression.Type == property.ClrType
+                ? valueExpression
+                : Expression.Convert(
+                    valueExpression,
+                    property.ClrType);
+        }
+
+        return Expression.Condition(Expression.Call(parameter, ContainsKeyMethod, Expression.Constant(property.Name)),
+            Expression.Convert(Expression.MakeIndex(
                 parameter,
-                ValueBuffer.GetValueMethod,
-                Expression.Constant(property.GetShadowIndex())),
-            property.ClrType);
+                DictionaryIndexer,
+                new[] { Expression.Constant(property.Name) }),
+                property.ClrType),
+            Expression.Constant(property.Sentinel, property.ClrType));
+    }
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
@@ -72,7 +109,7 @@ protected override bool UseEntityVariable
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
     protected override Expression CreateReadValueExpression(
-        ParameterExpression? parameter,
+        Expression? parameter,
         IPropertyBase property)
         => CreateReadShadowValueExpression(parameter, property);
 }
diff --git a/src/EFCore/ChangeTracking/Internal/SidecarValuesFactoryFactory.cs b/src/EFCore/ChangeTracking/Internal/SidecarValuesFactoryFactory.cs
index c66736bdad..728fc48d83 100644
--- a/src/EFCore/ChangeTracking/Internal/SidecarValuesFactoryFactory.cs
+++ b/src/EFCore/ChangeTracking/Internal/SidecarValuesFactoryFactory.cs
@@ -13,6 +13,24 @@ namespace Microsoft.EntityFrameworkCore.ChangeTracking.Internal;
 /// </summary>
 public class SidecarValuesFactoryFactory : SnapshotFactoryFactory<InternalEntityEntry>
 {
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    protected SidecarValuesFactoryFactory()
+    {
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public static readonly SidecarValuesFactoryFactory Instance = new();
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
diff --git a/src/EFCore/ChangeTracking/Internal/SimpleFullyNullableDependentKeyValueFactory.cs b/src/EFCore/ChangeTracking/Internal/SimpleFullyNullableDependentKeyValueFactory.cs
index 7ac738c496..03bea96458 100644
--- a/src/EFCore/ChangeTracking/Internal/SimpleFullyNullableDependentKeyValueFactory.cs
+++ b/src/EFCore/ChangeTracking/Internal/SimpleFullyNullableDependentKeyValueFactory.cs
@@ -47,6 +47,7 @@ public class SimpleFullyNullableDependentKeyValueFactory<TKey> : DependentKeyVal
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
+    [Obsolete]
     public virtual bool TryCreateFromBuffer(in ValueBuffer valueBuffer, [NotNullWhen(true)] out TKey? key)
     {
         key = (TKey)_propertyAccessors.ValueBufferGetter!(valueBuffer);
diff --git a/src/EFCore/ChangeTracking/Internal/SimpleNonNullableDependentKeyValueFactory.cs b/src/EFCore/ChangeTracking/Internal/SimpleNonNullableDependentKeyValueFactory.cs
index 2c9162b6ab..dffbf8b6ef 100644
--- a/src/EFCore/ChangeTracking/Internal/SimpleNonNullableDependentKeyValueFactory.cs
+++ b/src/EFCore/ChangeTracking/Internal/SimpleNonNullableDependentKeyValueFactory.cs
@@ -47,6 +47,7 @@ public class SimpleNonNullableDependentKeyValueFactory<TKey> : DependentKeyValue
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
+    [Obsolete]
     public virtual bool TryCreateFromBuffer(in ValueBuffer valueBuffer, [NotNullWhen(true)] out TKey? key)
     {
         var value = _propertyAccessors.ValueBufferGetter!(valueBuffer);
diff --git a/src/EFCore/ChangeTracking/Internal/SimpleNullableDependentKeyValueFactory.cs b/src/EFCore/ChangeTracking/Internal/SimpleNullableDependentKeyValueFactory.cs
index 292804ef50..a71f44bd3a 100644
--- a/src/EFCore/ChangeTracking/Internal/SimpleNullableDependentKeyValueFactory.cs
+++ b/src/EFCore/ChangeTracking/Internal/SimpleNullableDependentKeyValueFactory.cs
@@ -46,6 +46,7 @@ public class SimpleNullableDependentKeyValueFactory<TKey> : DependentKeyValueFac
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
+    [Obsolete]
     public virtual bool TryCreateFromBuffer(in ValueBuffer valueBuffer, out TKey key)
     {
         var value = _propertyAccessors.ValueBufferGetter!(valueBuffer);
diff --git a/src/EFCore/ChangeTracking/Internal/SimpleNullablePrincipalDependentKeyValueFactory.cs b/src/EFCore/ChangeTracking/Internal/SimpleNullablePrincipalDependentKeyValueFactory.cs
index ee59ca03cf..822b015ecb 100644
--- a/src/EFCore/ChangeTracking/Internal/SimpleNullablePrincipalDependentKeyValueFactory.cs
+++ b/src/EFCore/ChangeTracking/Internal/SimpleNullablePrincipalDependentKeyValueFactory.cs
@@ -51,6 +51,7 @@ public class SimpleNullablePrincipalDependentKeyValueFactory<TKey, TNonNullableK
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
+    [Obsolete]
     public virtual bool TryCreateFromBuffer(in ValueBuffer valueBuffer, [NotNullWhen(true)] out TKey? key)
     {
         var value = _propertyAccessors.ValueBufferGetter!(valueBuffer);
diff --git a/src/EFCore/ChangeTracking/Internal/SimplePrincipalKeyValueFactory.cs b/src/EFCore/ChangeTracking/Internal/SimplePrincipalKeyValueFactory.cs
index 69e9f2a388..71778671a4 100644
--- a/src/EFCore/ChangeTracking/Internal/SimplePrincipalKeyValueFactory.cs
+++ b/src/EFCore/ChangeTracking/Internal/SimplePrincipalKeyValueFactory.cs
@@ -48,6 +48,7 @@ public SimplePrincipalKeyValueFactory(IKey key)
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
+    [Obsolete]
     public virtual object? CreateFromBuffer(ValueBuffer valueBuffer)
         => _propertyAccessors.ValueBufferGetter!(valueBuffer);
 
diff --git a/src/EFCore/ChangeTracking/Internal/Snapshot.cs b/src/EFCore/ChangeTracking/Internal/Snapshot.cs
index 1109f6ed86..2f5435dbec 100644
--- a/src/EFCore/ChangeTracking/Internal/Snapshot.cs
+++ b/src/EFCore/ChangeTracking/Internal/Snapshot.cs
@@ -33,6 +33,15 @@ private Snapshot()
     /// </summary>
     public static ISnapshot Empty = new Snapshot();
 
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public static readonly FieldInfo EmptyField
+        = typeof(Snapshot).GetField(nameof(Empty), BindingFlags.Public | BindingFlags.Static | BindingFlags.DeclaredOnly)!;
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -54,6 +63,16 @@ private Snapshot()
     public T GetValue<T>(int index)
         => throw new IndexOutOfRangeException();
 
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public static readonly MethodInfo GetValueMethod
+        = typeof(ISnapshot).GetMethod(nameof(GetValue), 1, BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly,
+            null, CallingConventions.Any, new[] { typeof(int) }, null)!;
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -97,6 +116,10 @@ public static Type CreateSnapshotType(Type[] types)
             30 => typeof(Snapshot<,,,,,,,,,,,,,,,,,,,,,,,,,,,,,>).MakeGenericType(types),
             _ => throw new IndexOutOfRangeException()
         };
+
+    /// <inheritdoc/>
+    bool ISnapshot.IsEmpty
+        => true;
 }
 
 /// <summary>
diff --git a/src/EFCore/ChangeTracking/Internal/SnapshotFactoryFactory.cs b/src/EFCore/ChangeTracking/Internal/SnapshotFactoryFactory.cs
index aba7539759..127deb2742 100644
--- a/src/EFCore/ChangeTracking/Internal/SnapshotFactoryFactory.cs
+++ b/src/EFCore/ChangeTracking/Internal/SnapshotFactoryFactory.cs
@@ -22,11 +22,7 @@ public abstract class SnapshotFactoryFactory
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
     public virtual Func<ISnapshot> CreateEmpty(IRuntimeEntityType entityType)
-        => GetPropertyCount(entityType) == 0
-            ? (() => Snapshot.Empty)
-            : Expression.Lambda<Func<ISnapshot>>(
-                    CreateConstructorExpression(entityType, null!))
-                .Compile();
+        => CreateEmptyExpression(entityType).Compile();
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
@@ -34,11 +30,24 @@ public virtual Func<ISnapshot> CreateEmpty(IRuntimeEntityType entityType)
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    protected virtual Expression CreateConstructorExpression(
+    public virtual Expression<Func<ISnapshot>> CreateEmptyExpression(IRuntimeEntityType entityType)
+        => Expression.Lambda<Func<ISnapshot>>(CreateConstructorExpression(entityType, null));
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual Expression CreateConstructorExpression(
         IRuntimeEntityType entityType,
-        ParameterExpression? parameter)
+        Expression? parameter)
     {
         var count = GetPropertyCount(entityType);
+        if (count == 0)
+        {
+            return Expression.MakeMemberAccess(null, Snapshot.EmptyField);
+        }
 
         var types = new Type[count];
         var propertyBases = new IPropertyBase?[count];
@@ -91,7 +100,7 @@ public virtual Func<ISnapshot> CreateEmpty(IRuntimeEntityType entityType)
     /// </summary>
     protected virtual Expression CreateSnapshotExpression(
         Type? entityType,
-        ParameterExpression? parameter,
+        Expression? parameter,
         Type[] types,
         IList<IPropertyBase?> propertyBases)
     {
@@ -180,36 +189,34 @@ public virtual Func<ISnapshot> CreateEmpty(IRuntimeEntityType entityType)
 
     private Expression CreateSnapshotValueExpression(Expression expression, IPropertyBase propertyBase)
     {
-        if (propertyBase is IProperty property)
+        if (propertyBase is not IProperty property
+            || GetValueComparer(property) is not ValueComparer comparer)
         {
-            var comparer = GetValueComparer(property);
+            return expression;
+        }
 
-            if (comparer != null)
-            {
-                if (expression.Type != comparer.Type)
-                {
-                    expression = Expression.Convert(expression, comparer.Type);
-                }
-
-                var snapshotExpression = ReplacingExpressionVisitor.Replace(
-                    comparer.SnapshotExpression.Parameters.Single(),
-                    expression,
-                    comparer.SnapshotExpression.Body);
-
-                if (snapshotExpression.Type != propertyBase.ClrType)
-                {
-                    snapshotExpression = Expression.Convert(snapshotExpression, propertyBase.ClrType);
-                }
-
-                expression = propertyBase.ClrType.IsNullableType()
-                    ? Expression.Condition(
-                        Expression.Equal(expression, Expression.Constant(null, propertyBase.ClrType)),
-                        Expression.Constant(null, propertyBase.ClrType),
-                        snapshotExpression)
-                    : snapshotExpression;
-            }
+        if (expression.Type != comparer.Type)
+        {
+            expression = Expression.Convert(expression, comparer.Type);
         }
 
+        var snapshotExpression = ReplacingExpressionVisitor.Replace(
+            comparer.SnapshotExpression.Parameters.Single(),
+            expression,
+            comparer.SnapshotExpression.Body);
+
+        if (snapshotExpression.Type != propertyBase.ClrType)
+        {
+            snapshotExpression = Expression.Convert(snapshotExpression, propertyBase.ClrType);
+        }
+
+        expression = propertyBase.ClrType.IsNullableType()
+            ? Expression.Condition(
+                Expression.Equal(expression, Expression.Constant(null, propertyBase.ClrType)),
+                Expression.Constant(null, propertyBase.ClrType),
+                snapshotExpression)
+            : snapshotExpression;
+
         return expression;
     }
 
@@ -228,7 +235,7 @@ private Expression CreateSnapshotValueExpression(Expression expression, IPropert
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
     protected virtual Expression CreateReadShadowValueExpression(
-        ParameterExpression? parameter,
+        Expression? parameter,
         IPropertyBase property)
         => Expression.Call(
             parameter,
@@ -242,7 +249,7 @@ private Expression CreateSnapshotValueExpression(Expression expression, IPropert
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
     protected virtual Expression CreateReadValueExpression(
-        ParameterExpression? parameter,
+        Expression? parameter,
         IPropertyBase property)
         => Expression.Call(
             parameter,
diff --git a/src/EFCore/ChangeTracking/Internal/SnapshotFactoryFactory`.cs b/src/EFCore/ChangeTracking/Internal/SnapshotFactoryFactory`.cs
index 08328f92b2..375e5b8fe7 100644
--- a/src/EFCore/ChangeTracking/Internal/SnapshotFactoryFactory`.cs
+++ b/src/EFCore/ChangeTracking/Internal/SnapshotFactoryFactory`.cs
@@ -20,17 +20,20 @@ public abstract class SnapshotFactoryFactory<TInput> : SnapshotFactoryFactory
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
     public virtual Func<TInput, ISnapshot> Create(IRuntimeEntityType entityType)
-    {
-        if (GetPropertyCount(entityType) == 0)
-        {
-            return _ => Snapshot.Empty;
-        }
+        => CreateExpression(entityType).Compile();
 
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual Expression<Func<TInput, ISnapshot>> CreateExpression(IRuntimeEntityType entityType)
+    {
         var parameter = Expression.Parameter(typeof(TInput), "source");
 
         return Expression.Lambda<Func<TInput, ISnapshot>>(
                 CreateConstructorExpression(entityType, parameter),
-                parameter)
-            .Compile();
+                parameter);
     }
 }
diff --git a/src/EFCore/ChangeTracking/Internal/StateManager.cs b/src/EFCore/ChangeTracking/Internal/StateManager.cs
index b072ae32de..62b76884c6 100644
--- a/src/EFCore/ChangeTracking/Internal/StateManager.cs
+++ b/src/EFCore/ChangeTracking/Internal/StateManager.cs
@@ -274,29 +274,7 @@ public virtual InternalEntityEntry GetOrCreateEntry(object entity, IEntityType?
     /// </summary>
     public virtual InternalEntityEntry CreateEntry(IDictionary<string, object?> values, IEntityType entityType)
     {
-        var i = 0;
-        var runtimeEntityType = (IRuntimeEntityType)entityType;
-        var valuesArray = new object?[runtimeEntityType.PropertyCount];
-        var shadowPropertyValuesArray = new object?[runtimeEntityType.ShadowPropertyCount];
-        foreach (var property in entityType.GetFlattenedProperties())
-        {
-            valuesArray[i++] = values.TryGetValue(property.Name, out var value)
-                ? value
-                : property.Sentinel;
-
-            if (property.IsShadowProperty())
-            {
-                shadowPropertyValuesArray[property.GetShadowIndex()] = values.TryGetValue(property.Name, out var shadowValue)
-                    ? shadowValue
-                    : property.Sentinel;
-            }
-        }
-
-        var valueBuffer = new ValueBuffer(valuesArray);
-        var entity = entityType.GetOrCreateMaterializer(EntityMaterializerSource)(new MaterializationContext(valueBuffer, Context));
-
-        var shadowPropertyValueBuffer = new ValueBuffer(shadowPropertyValuesArray);
-        var entry = new InternalEntityEntry(this, entityType, entity, shadowPropertyValueBuffer);
+        var entry = new InternalEntityEntry(this, entityType, values, EntityMaterializerSource);
 
         UpdateReferenceMaps(entry, EntityState.Detached, null);
 
@@ -331,7 +309,7 @@ public virtual InternalEntityEntry CreateEntry(IDictionary<string, object?> valu
     public virtual InternalEntityEntry StartTrackingFromQuery(
         IEntityType baseEntityType,
         object entity,
-        in ValueBuffer valueBuffer)
+        in ISnapshot snapshot)
     {
         var existingEntry = TryGetEntry(entity);
         if (existingEntry != null)
@@ -345,9 +323,9 @@ public virtual InternalEntityEntry CreateEntry(IDictionary<string, object?> valu
                 ? baseEntityType
                 : _model.FindRuntimeEntityType(clrType)!;
 
-        var newEntry = valueBuffer.IsEmpty
+        var newEntry = snapshot.IsEmpty
             ? new InternalEntityEntry(this, entityType, entity)
-            : new InternalEntityEntry(this, entityType, entity, valueBuffer);
+            : new InternalEntityEntry(this, entityType, entity, snapshot);
 
         foreach (var key in baseEntityType.GetKeys())
         {
diff --git a/src/EFCore/ChangeTracking/Internal/StoreGeneratedValuesFactoryFactory.cs b/src/EFCore/ChangeTracking/Internal/StoreGeneratedValuesFactoryFactory.cs
index 90ee70828b..884bfce0bb 100644
--- a/src/EFCore/ChangeTracking/Internal/StoreGeneratedValuesFactoryFactory.cs
+++ b/src/EFCore/ChangeTracking/Internal/StoreGeneratedValuesFactoryFactory.cs
@@ -11,6 +11,18 @@ namespace Microsoft.EntityFrameworkCore.ChangeTracking.Internal;
 /// </summary>
 public class StoreGeneratedValuesFactoryFactory : SidecarValuesFactoryFactory
 {
+    private StoreGeneratedValuesFactoryFactory()
+    {
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public static new readonly StoreGeneratedValuesFactoryFactory Instance = new();
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -26,7 +38,7 @@ protected override bool UseEntityVariable
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    protected override Expression CreateReadShadowValueExpression(ParameterExpression? parameter, IPropertyBase property)
+    protected override Expression CreateReadShadowValueExpression(Expression? parameter, IPropertyBase property)
         => Expression.Default(property.ClrType);
 
     /// <summary>
@@ -35,6 +47,6 @@ protected override Expression CreateReadShadowValueExpression(ParameterExpressio
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    protected override Expression CreateReadValueExpression(ParameterExpression? parameter, IPropertyBase property)
+    protected override Expression CreateReadValueExpression(Expression? parameter, IPropertyBase property)
         => Expression.Default(property.ClrType);
 }
diff --git a/src/EFCore/ChangeTracking/Internal/StructuralEntryCurrentProviderValueComparer.cs b/src/EFCore/ChangeTracking/Internal/StructuralEntryCurrentProviderValueComparer.cs
index f920932cc0..9a26cd70ac 100644
--- a/src/EFCore/ChangeTracking/Internal/StructuralEntryCurrentProviderValueComparer.cs
+++ b/src/EFCore/ChangeTracking/Internal/StructuralEntryCurrentProviderValueComparer.cs
@@ -20,7 +20,7 @@ public class StructuralEntryCurrentProviderValueComparer : StructuralEntryCurren
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
     public StructuralEntryCurrentProviderValueComparer(
-        IPropertyBase property,
+        IProperty property,
         ValueConverter converter)
         : base(property)
     {
diff --git a/src/EFCore/ChangeTracking/Internal/StructuralEntryCurrentValueComparer.cs b/src/EFCore/ChangeTracking/Internal/StructuralEntryCurrentValueComparer.cs
index 8611a04e02..0aed52dc2c 100644
--- a/src/EFCore/ChangeTracking/Internal/StructuralEntryCurrentValueComparer.cs
+++ b/src/EFCore/ChangeTracking/Internal/StructuralEntryCurrentValueComparer.cs
@@ -19,7 +19,7 @@ public class StructuralEntryCurrentValueComparer : EntryCurrentValueComparer
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    public StructuralEntryCurrentValueComparer(IPropertyBase property)
+    public StructuralEntryCurrentValueComparer(IProperty property)
         : base(property, StructuralComparisons.StructuralComparer)
     {
     }
diff --git a/src/EFCore/ChangeTracking/Internal/TemporaryValuesFactoryFactory.cs b/src/EFCore/ChangeTracking/Internal/TemporaryValuesFactoryFactory.cs
index e422ae610c..459a815fc2 100644
--- a/src/EFCore/ChangeTracking/Internal/TemporaryValuesFactoryFactory.cs
+++ b/src/EFCore/ChangeTracking/Internal/TemporaryValuesFactoryFactory.cs
@@ -13,6 +13,18 @@ namespace Microsoft.EntityFrameworkCore.ChangeTracking.Internal;
 /// </summary>
 public class TemporaryValuesFactoryFactory : SidecarValuesFactoryFactory
 {
+    private TemporaryValuesFactoryFactory()
+    {
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public static new readonly TemporaryValuesFactoryFactory Instance = new();
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -21,7 +33,7 @@ public class TemporaryValuesFactoryFactory : SidecarValuesFactoryFactory
     /// </summary>
     protected override Expression CreateSnapshotExpression(
         [DynamicallyAccessedMembers(IEntityType.DynamicallyAccessedMemberTypes)] Type? entityType,
-        ParameterExpression? parameter,
+        Expression? parameter,
         Type[] types,
         IList<IPropertyBase?> propertyBases)
     {
diff --git a/src/EFCore/Metadata/IProperty.cs b/src/EFCore/Metadata/IProperty.cs
index 82eb39d928..bac8020334 100644
--- a/src/EFCore/Metadata/IProperty.cs
+++ b/src/EFCore/Metadata/IProperty.cs
@@ -82,6 +82,12 @@ IEqualityComparer<TProperty> CreateKeyEqualityComparer<TProperty>()
     /// </returns>
     new IEnumerable<IKey> GetContainingKeys();
 
+    /// <summary>
+    ///     Gets a <see cref="IComparer{T}" /> for comparing values in tracked <see cref="IUpdateEntry" /> entries.
+    /// </summary>
+    /// <returns>The comparer.</returns>
+    IComparer<IUpdateEntry> GetCurrentValueComparer();
+
     /// <summary>
     ///     Gets the <see cref="ValueComparer" /> for this property.
     /// </summary>
diff --git a/src/EFCore/Metadata/IPropertyBase.cs b/src/EFCore/Metadata/IPropertyBase.cs
index 539bdc8e16..a180fa6026 100644
--- a/src/EFCore/Metadata/IPropertyBase.cs
+++ b/src/EFCore/Metadata/IPropertyBase.cs
@@ -32,12 +32,6 @@ public interface IPropertyBase : IReadOnlyPropertyBase, IAnnotatable
     /// <returns>The accessor.</returns>
     IClrPropertyGetter GetGetter();
 
-    /// <summary>
-    ///     Gets a <see cref="IComparer{T}" /> for comparing values in tracked <see cref="IUpdateEntry" /> entries.
-    /// </summary>
-    /// <returns>The comparer.</returns>
-    IComparer<IUpdateEntry> GetCurrentValueComparer();
-
     /// <summary>
     ///     Gets the <see cref="PropertyInfo" /> or <see cref="FieldInfo" /> that should be used to
     ///     get or set a value for the given property.
diff --git a/src/EFCore/Metadata/Internal/EntityType.cs b/src/EFCore/Metadata/Internal/EntityType.cs
index b4dda1a09c..99c31f332d 100644
--- a/src/EFCore/Metadata/Internal/EntityType.cs
+++ b/src/EFCore/Metadata/Internal/EntityType.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System.Diagnostics.CodeAnalysis;
+using System.Runtime.CompilerServices;
 using Microsoft.EntityFrameworkCore.ChangeTracking.Internal;
 using Microsoft.EntityFrameworkCore.Internal;
 
@@ -64,7 +65,7 @@ public class EntityType : TypeBase, IMutableEntityType, IConventionEntityType, I
     private Func<InternalEntityEntry, ISnapshot>? _originalValuesFactory;
     private Func<InternalEntityEntry, ISnapshot>? _temporaryValuesFactory;
     private Func<ISnapshot>? _storeGeneratedValuesFactory;
-    private Func<ValueBuffer, ISnapshot>? _shadowValuesFactory;
+    private Func<IDictionary<string, object?>, ISnapshot>? _shadowValuesFactory;
     private Func<ISnapshot>? _emptyShadowValuesFactory;
     private IProperty[]? _foreignKeyProperties;
     private IProperty[]? _valueGeneratingProperties;
@@ -2276,7 +2277,7 @@ public override IEnumerable<PropertyBase> GetSnapshottableMembers()
             static entityType =>
             {
                 entityType.EnsureReadOnly();
-                return new RelationshipSnapshotFactoryFactory().Create(entityType);
+                return RelationshipSnapshotFactoryFactory.Instance.Create(entityType);
             });
 
     /// <summary>
@@ -2291,7 +2292,7 @@ public override IEnumerable<PropertyBase> GetSnapshottableMembers()
             static entityType =>
             {
                 entityType.EnsureReadOnly();
-                return new OriginalValuesFactoryFactory().Create(entityType);
+                return OriginalValuesFactoryFactory.Instance.Create(entityType);
             });
 
     /// <summary>
@@ -2306,7 +2307,7 @@ public virtual Func<ISnapshot> StoreGeneratedValuesFactory
             static entityType =>
             {
                 entityType.EnsureReadOnly();
-                return new StoreGeneratedValuesFactoryFactory().CreateEmpty(entityType);
+                return StoreGeneratedValuesFactoryFactory.Instance.CreateEmpty(entityType);
             });
 
     /// <summary>
@@ -2321,7 +2322,7 @@ public virtual Func<ISnapshot> StoreGeneratedValuesFactory
             static entityType =>
             {
                 entityType.EnsureReadOnly();
-                return new TemporaryValuesFactoryFactory().Create(entityType);
+                return TemporaryValuesFactoryFactory.Instance.Create(entityType);
             });
 
     /// <summary>
@@ -2330,13 +2331,13 @@ public virtual Func<ISnapshot> StoreGeneratedValuesFactory
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    public virtual Func<ValueBuffer, ISnapshot> ShadowValuesFactory
+    public virtual Func<IDictionary<string, object?>, ISnapshot> ShadowValuesFactory
         => NonCapturingLazyInitializer.EnsureInitialized(
             ref _shadowValuesFactory, this,
             static entityType =>
             {
                 entityType.EnsureReadOnly();
-                return new ShadowValuesFactoryFactory().Create(entityType);
+                return ShadowValuesFactoryFactory.Instance.Create(entityType);
             });
 
     /// <summary>
@@ -2351,7 +2352,7 @@ public virtual Func<ISnapshot> EmptyShadowValuesFactory
             static entityType =>
             {
                 entityType.EnsureReadOnly();
-                return new EmptyShadowValuesFactoryFactory().CreateEmpty(entityType);
+                return EmptyShadowValuesFactoryFactory.Instance.CreateEmpty(entityType);
             });
 
     /// <summary>
diff --git a/src/EFCore/Metadata/Internal/IRuntimeEntityType.cs b/src/EFCore/Metadata/Internal/IRuntimeEntityType.cs
index 30c960c2df..e449e843df 100644
--- a/src/EFCore/Metadata/Internal/IRuntimeEntityType.cs
+++ b/src/EFCore/Metadata/Internal/IRuntimeEntityType.cs
@@ -129,7 +129,7 @@ int ComplexPropertyCount
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    Func<ValueBuffer, ISnapshot> ShadowValuesFactory { get; }
+    Func<IDictionary<string, object?>, ISnapshot> ShadowValuesFactory { get; }
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
diff --git a/src/EFCore/Metadata/Internal/Property.cs b/src/EFCore/Metadata/Internal/Property.cs
index 6cc5ee1dba..35b3cfe445 100644
--- a/src/EFCore/Metadata/Internal/Property.cs
+++ b/src/EFCore/Metadata/Internal/Property.cs
@@ -23,6 +23,7 @@ public class Property : PropertyBase, IMutableProperty, IConventionProperty, IPr
     private object? _sentinel;
     private ValueGenerated? _valueGenerated;
     private CoreTypeMapping? _typeMapping;
+    private IComparer<IUpdateEntry>? _currentValueComparer;
 
     private ConfigurationSource? _typeConfigurationSource;
     private ConfigurationSource? _isNullableConfigurationSource;
@@ -936,6 +937,20 @@ private Type GetEffectiveProviderClrType()
     public virtual ConfigurationSource? GetTypeMappingConfigurationSource()
         => _typeMappingConfigurationSource;
 
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual IComparer<IUpdateEntry> CurrentValueComparer
+        => NonCapturingLazyInitializer.EnsureInitialized(
+            ref _currentValueComparer, this, static property =>
+            {
+                property.EnsureReadOnly();
+                return new CurrentValueComparerFactory().Create(property);
+            });
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -1871,6 +1886,16 @@ void IMutableProperty.SetProviderClrType(Type? providerClrType)
             providerClrType,
             fromDataAnnotation ? ConfigurationSource.DataAnnotation : ConfigurationSource.Convention);
 
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    [DebuggerStepThrough]
+    IComparer<IUpdateEntry> IProperty.GetCurrentValueComparer()
+        => CurrentValueComparer;
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
diff --git a/src/EFCore/Metadata/Internal/PropertyAccessors.cs b/src/EFCore/Metadata/Internal/PropertyAccessors.cs
index 4767a15f67..4a40497da8 100644
--- a/src/EFCore/Metadata/Internal/PropertyAccessors.cs
+++ b/src/EFCore/Metadata/Internal/PropertyAccessors.cs
@@ -29,7 +29,9 @@ public sealed class PropertyAccessors
         PreStoreGeneratedCurrentValueGetter = preStoreGeneratedCurrentValueGetter;
         OriginalValueGetter = originalValueGetter;
         RelationshipSnapshotGetter = relationshipSnapshotGetter;
+#pragma warning disable CS0612 // Type or member is obsolete
         ValueBufferGetter = valueBufferGetter;
+#pragma warning restore CS0612 // Type or member is obsolete
     }
 
     /// <summary>
@@ -70,5 +72,6 @@ public sealed class PropertyAccessors
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
+    [Obsolete]
     public Func<ValueBuffer, object>? ValueBufferGetter { get; }
 }
diff --git a/src/EFCore/Metadata/Internal/PropertyBase.cs b/src/EFCore/Metadata/Internal/PropertyBase.cs
index ac81bb041f..c1a3321f53 100644
--- a/src/EFCore/Metadata/Internal/PropertyBase.cs
+++ b/src/EFCore/Metadata/Internal/PropertyBase.cs
@@ -25,7 +25,6 @@ public abstract class PropertyBase : ConventionAnnotatable, IMutablePropertyBase
     private IClrPropertySetter? _materializationSetter;
     private PropertyAccessors? _accessors;
     private PropertyIndexes? _indexes;
-    private IComparer<IUpdateEntry>? _currentValueComparer;
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
@@ -400,23 +399,6 @@ public virtual PropertyAccessors Accessors
                 return new PropertyAccessorsFactory().Create(property);
             });
 
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public virtual IComparer<IUpdateEntry> CurrentValueComparer
-        => NonCapturingLazyInitializer.EnsureInitialized(
-            ref _currentValueComparer, this, static property =>
-            {
-                property.EnsureReadOnly();
-                return new CurrentValueComparerFactory().Create(property);
-            });
-
-    private static readonly MethodInfo ContainsKeyMethod =
-        typeof(IDictionary<string, object>).GetMethod(nameof(IDictionary<string, object>.ContainsKey), new[] { typeof(string) })!;
-
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -438,7 +420,7 @@ public virtual IComparer<IUpdateEntry> CurrentValueComparer
             {
                 expression = Expression.Condition(
                     Expression.Call(
-                        instanceExpression, ContainsKeyMethod, new List<Expression> { Expression.Constant(property.Name) }),
+                        instanceExpression, ShadowValuesFactoryFactory.ContainsKeyMethod, new List<Expression> { Expression.Constant(property.Name) }),
                     expression,
                     expression.Type.GetDefaultValueConstant());
             }
@@ -571,16 +553,6 @@ void IMutablePropertyBase.SetPropertyAccessMode(PropertyAccessMode? propertyAcce
     IClrPropertyGetter IPropertyBase.GetGetter()
         => Getter;
 
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    [DebuggerStepThrough]
-    IComparer<IUpdateEntry> IPropertyBase.GetCurrentValueComparer()
-        => CurrentValueComparer;
-
     /// <summary>
     ///     Gets the sentinel value that indicates that this property is not set.
     /// </summary>
diff --git a/src/EFCore/Metadata/RuntimeEntityType.cs b/src/EFCore/Metadata/RuntimeEntityType.cs
index 79bbd12c4e..be62a254d7 100644
--- a/src/EFCore/Metadata/RuntimeEntityType.cs
+++ b/src/EFCore/Metadata/RuntimeEntityType.cs
@@ -56,7 +56,7 @@ public class RuntimeEntityType : RuntimeTypeBase, IRuntimeEntityType
     private Func<InternalEntityEntry, ISnapshot>? _originalValuesFactory;
     private Func<InternalEntityEntry, ISnapshot>? _temporaryValuesFactory;
     private Func<ISnapshot>? _storeGeneratedValuesFactory;
-    private Func<ValueBuffer, ISnapshot>? _shadowValuesFactory;
+    private Func<IDictionary<string, object?>, ISnapshot>? _shadowValuesFactory;
     private Func<ISnapshot>? _emptyShadowValuesFactory;
     private RuntimePropertyBase[]? _snapshottableProperties;
     private Func<MaterializationContext, object>? _materializer;
@@ -1245,27 +1245,19 @@ IEnumerable<IReadOnlyTrigger> IReadOnlyEntityType.GetDeclaredTriggers()
     IEnumerable<ITrigger> IEntityType.GetDeclaredTriggers()
         => GetDeclaredTriggers();
 
-    /// <inheritdoc />
-    Func<InternalEntityEntry, ISnapshot> IRuntimeEntityType.RelationshipSnapshotFactory
-        => NonCapturingLazyInitializer.EnsureInitialized(
-            ref _relationshipSnapshotFactory, this,
-            static entityType => RuntimeFeature.IsDynamicCodeSupported
-                ? new RelationshipSnapshotFactoryFactory().Create(entityType)
-                : throw new InvalidOperationException(CoreStrings.NativeAotNoCompiledModel));
-
     /// <inheritdoc />
     [DebuggerStepThrough]
     IEnumerable<IProperty> IEntityType.GetForeignKeyProperties()
         => NonCapturingLazyInitializer.EnsureInitialized(
             ref _foreignKeyProperties, this,
-            static entityType => { return entityType.GetProperties().Where(p => ((IReadOnlyProperty)p).IsForeignKey()).ToArray(); });
+            static entityType => entityType.GetProperties().Where(p => ((IReadOnlyProperty)p).IsForeignKey()).ToArray());
 
     /// <inheritdoc />
     [DebuggerStepThrough]
     IEnumerable<IProperty> IEntityType.GetValueGeneratingProperties()
         => NonCapturingLazyInitializer.EnsureInitialized(
             ref _valueGeneratingProperties, this,
-            static entityType => { return entityType.GetProperties().Where(p => p.RequiresValueGenerator()).ToArray(); });
+            static entityType => entityType.GetProperties().Where(p => p.RequiresValueGenerator()).ToArray());
 
     /// <inheritdoc />
     [DebuggerStepThrough]
@@ -1343,16 +1335,6 @@ public virtual void SetStoreGeneratedValuesFactory(Func<ISnapshot> factory)
     public virtual void SetTemporaryValuesFactory(Func<InternalEntityEntry, ISnapshot> factory)
         => _temporaryValuesFactory = factory;
 
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    [EntityFrameworkInternal]
-    public virtual void SetShadowValuesFactory(Func<ValueBuffer, ISnapshot> factory)
-        => _shadowValuesFactory = factory;
-
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -1363,73 +1345,51 @@ public virtual void SetShadowValuesFactory(Func<ValueBuffer, ISnapshot> factory)
     public virtual void SetEmptyShadowValuesFactory(Func<ISnapshot> factory)
         => _emptyShadowValuesFactory = factory;
 
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    [EntityFrameworkInternal]
-    public virtual Func<InternalEntityEntry, ISnapshot> OriginalValuesFactory
+    /// <inheritdoc />
+    Func<InternalEntityEntry, ISnapshot> IRuntimeEntityType.OriginalValuesFactory
         => NonCapturingLazyInitializer.EnsureInitialized(
             ref _originalValuesFactory, this,
-            static complexType => RuntimeFeature.IsDynamicCodeSupported
-                ? new OriginalValuesFactoryFactory().Create(complexType)
+            static entityType => RuntimeFeature.IsDynamicCodeSupported
+                ? OriginalValuesFactoryFactory.Instance.Create(entityType)
                 : throw new InvalidOperationException(CoreStrings.NativeAotNoCompiledModel));
 
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    [EntityFrameworkInternal]
-    public virtual Func<ISnapshot> StoreGeneratedValuesFactory
+    /// <inheritdoc />
+    Func<ISnapshot> IRuntimeEntityType.StoreGeneratedValuesFactory
         => NonCapturingLazyInitializer.EnsureInitialized(
             ref _storeGeneratedValuesFactory, this,
-            static complexType => RuntimeFeature.IsDynamicCodeSupported
-                ? new StoreGeneratedValuesFactoryFactory().CreateEmpty(complexType)
+            static entityType => RuntimeFeature.IsDynamicCodeSupported
+                ? StoreGeneratedValuesFactoryFactory.Instance.CreateEmpty(entityType)
                 : throw new InvalidOperationException(CoreStrings.NativeAotNoCompiledModel));
 
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    [EntityFrameworkInternal]
-    public virtual Func<InternalEntityEntry, ISnapshot> TemporaryValuesFactory
+    /// <inheritdoc />
+    Func<InternalEntityEntry, ISnapshot> IRuntimeEntityType.TemporaryValuesFactory
         => NonCapturingLazyInitializer.EnsureInitialized(
             ref _temporaryValuesFactory, this,
-            static complexType => RuntimeFeature.IsDynamicCodeSupported
-                ? new TemporaryValuesFactoryFactory().Create(complexType)
+            static entityType => RuntimeFeature.IsDynamicCodeSupported
+                ? TemporaryValuesFactoryFactory.Instance.Create(entityType)
                 : throw new InvalidOperationException(CoreStrings.NativeAotNoCompiledModel));
 
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    [EntityFrameworkInternal]
-    public virtual Func<ValueBuffer, ISnapshot> ShadowValuesFactory
+    /// <inheritdoc />
+    Func<IDictionary<string, object?>, ISnapshot> IRuntimeEntityType.ShadowValuesFactory
         => NonCapturingLazyInitializer.EnsureInitialized(
             ref _shadowValuesFactory, this,
-            static complexType => RuntimeFeature.IsDynamicCodeSupported
-                ? new ShadowValuesFactoryFactory().Create(complexType)
+            static entityType => RuntimeFeature.IsDynamicCodeSupported
+                ? ShadowValuesFactoryFactory.Instance.Create(entityType)
                 : throw new InvalidOperationException(CoreStrings.NativeAotNoCompiledModel));
 
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    [EntityFrameworkInternal]
-    public virtual Func<ISnapshot> EmptyShadowValuesFactory
+    /// <inheritdoc />
+    Func<ISnapshot> IRuntimeEntityType.EmptyShadowValuesFactory
         => NonCapturingLazyInitializer.EnsureInitialized(
             ref _emptyShadowValuesFactory, this,
-            static complexType => RuntimeFeature.IsDynamicCodeSupported
-                ? new EmptyShadowValuesFactoryFactory().CreateEmpty(complexType)
+            static entityType => RuntimeFeature.IsDynamicCodeSupported
+                ? EmptyShadowValuesFactoryFactory.Instance.CreateEmpty(entityType)
+                : throw new InvalidOperationException(CoreStrings.NativeAotNoCompiledModel));
+
+    /// <inheritdoc />
+    Func<InternalEntityEntry, ISnapshot> IRuntimeEntityType.RelationshipSnapshotFactory
+        => NonCapturingLazyInitializer.EnsureInitialized(
+            ref _relationshipSnapshotFactory, this,
+            static entityType => RuntimeFeature.IsDynamicCodeSupported
+                ? RelationshipSnapshotFactoryFactory.Instance.Create(entityType)
                 : throw new InvalidOperationException(CoreStrings.NativeAotNoCompiledModel));
 }
diff --git a/src/EFCore/Metadata/RuntimeProperty.cs b/src/EFCore/Metadata/RuntimeProperty.cs
index 0fd2201f7c..449816d4d0 100644
--- a/src/EFCore/Metadata/RuntimeProperty.cs
+++ b/src/EFCore/Metadata/RuntimeProperty.cs
@@ -28,9 +28,10 @@ public class RuntimeProperty : RuntimePropertyBase, IProperty
     private readonly ValueConverter? _valueConverter;
     private ValueComparer? _valueComparer;
     private ValueComparer? _keyValueComparer;
-    private readonly ValueComparer? _providerValueComparer;
+    private ValueComparer? _providerValueComparer;
     private readonly JsonValueReaderWriter? _jsonValueReaderWriter;
     private CoreTypeMapping? _typeMapping;
+    private IComparer<IUpdateEntry>? _currentValueComparer;
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
@@ -238,6 +239,13 @@ public virtual CoreTypeMapping TypeMapping
         set => _typeMapping = value;
     }
 
+    /// <inheritdoc />
+    [DebuggerStepThrough]
+    IComparer<IUpdateEntry> IProperty.GetCurrentValueComparer()
+        => NonCapturingLazyInitializer.EnsureInitialized(
+            ref _currentValueComparer, this, static property =>
+                new CurrentValueComparerFactory().Create(property));
+
     private ValueComparer GetValueComparer()
         => (GetValueComparer(null) ?? TypeMapping.Comparer)
             .ToNullableComparer(ClrType)!;
@@ -450,12 +458,12 @@ ValueComparer IProperty.GetKeyValueComparer()
     /// <inheritdoc />
     [DebuggerStepThrough]
     ValueComparer? IReadOnlyProperty.GetProviderValueComparer()
-        => _providerValueComparer ?? TypeMapping.ProviderValueComparer;
+        => _providerValueComparer ??= TypeMapping.ProviderValueComparer;
 
     /// <inheritdoc />
     [DebuggerStepThrough]
     ValueComparer IProperty.GetProviderValueComparer()
-        => _providerValueComparer ?? TypeMapping.ProviderValueComparer;
+        => _providerValueComparer ??= TypeMapping.ProviderValueComparer;
 
     /// <inheritdoc />
     [DebuggerStepThrough]
diff --git a/src/EFCore/Metadata/RuntimePropertyBase.cs b/src/EFCore/Metadata/RuntimePropertyBase.cs
index 89dc9c09cf..fb32230757 100644
--- a/src/EFCore/Metadata/RuntimePropertyBase.cs
+++ b/src/EFCore/Metadata/RuntimePropertyBase.cs
@@ -3,7 +3,6 @@
 
 using System.Diagnostics.CodeAnalysis;
 using System.Runtime.CompilerServices;
-using Microsoft.EntityFrameworkCore.ChangeTracking.Internal;
 using Microsoft.EntityFrameworkCore.Internal;
 using Microsoft.EntityFrameworkCore.Metadata.Internal;
 
@@ -27,7 +26,6 @@ public abstract class RuntimePropertyBase : AnnotatableBase, IRuntimePropertyBas
     private IClrPropertySetter? _materializationSetter;
     private PropertyAccessors? _accessors;
     private PropertyIndexes? _indexes;
-    private IComparer<IUpdateEntry>? _currentValueComparer;
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
@@ -176,11 +174,4 @@ IClrPropertySetter IRuntimePropertyBase.GetSetter()
     IClrPropertyGetter IPropertyBase.GetGetter()
         => NonCapturingLazyInitializer.EnsureInitialized(
             ref _getter, this, static property => new ClrPropertyGetterFactory().Create(property));
-
-    /// <inheritdoc />
-    [DebuggerStepThrough]
-    IComparer<IUpdateEntry> IPropertyBase.GetCurrentValueComparer()
-        => NonCapturingLazyInitializer.EnsureInitialized(
-            ref _currentValueComparer, this, static property =>
-                new CurrentValueComparerFactory().Create(property));
 }
diff --git a/src/EFCore/Query/QueryContext.cs b/src/EFCore/Query/QueryContext.cs
index 58a57ce456..9237d7ff65 100644
--- a/src/EFCore/Query/QueryContext.cs
+++ b/src/EFCore/Query/QueryContext.cs
@@ -142,7 +142,7 @@ public virtual void InitializeStateManager(bool standAlone = false)
     public virtual InternalEntityEntry StartTracking(
             IEntityType entityType,
             object entity,
-            ValueBuffer valueBuffer)
+            in ISnapshot snapshot)
         // InitializeStateManager will populate the field before calling here
-        => _stateManager!.StartTrackingFromQuery(entityType, entity, valueBuffer);
+        => _stateManager!.StartTrackingFromQuery(entityType, entity, snapshot);
 }
diff --git a/src/EFCore/Query/ShapedQueryCompilingExpressionVisitor.cs b/src/EFCore/Query/ShapedQueryCompilingExpressionVisitor.cs
index b3c3a01bff..af0b6288bd 100644
--- a/src/EFCore/Query/ShapedQueryCompilingExpressionVisitor.cs
+++ b/src/EFCore/Query/ShapedQueryCompilingExpressionVisitor.cs
@@ -271,9 +271,6 @@ private sealed class EntityMaterializerInjectingExpressionVisitor : ExpressionVi
         private static readonly ConstructorInfo MaterializationContextConstructor
             = typeof(MaterializationContext).GetConstructors().Single(ci => ci.GetParameters().Length == 2);
 
-        private static readonly ConstructorInfo ValueBufferConstructor
-            = typeof(ValueBuffer).GetTypeInfo().DeclaredConstructors.Single(ci => ci.GetParameters().Length == 1);
-
         private static readonly PropertyInfo DbContextMemberInfo
             = typeof(QueryContext).GetTypeInfo().GetProperty(nameof(QueryContext.Context))!;
 
@@ -289,7 +286,7 @@ private sealed class EntityMaterializerInjectingExpressionVisitor : ExpressionVi
 
         private static readonly MethodInfo StartTrackingMethodInfo
             = typeof(QueryContext).GetMethod(
-                nameof(QueryContext.StartTracking), new[] { typeof(IEntityType), typeof(object), typeof(ValueBuffer) })!;
+                nameof(QueryContext.StartTracking), new[] { typeof(IEntityType), typeof(object), typeof(ISnapshot).MakeByRefType() })!;
 
         private static readonly MethodInfo CreateNullKeyValueInNoTrackingQueryMethod
             = typeof(EntityMaterializerInjectingExpressionVisitor)
@@ -488,13 +485,13 @@ private Expression ProcessEntityShaper(StructuralTypeShaperExpression shaper)
             var variables = new List<ParameterExpression>();
 
             var shadowValuesVariable = Variable(
-                typeof(ValueBuffer),
-                "shadowValueBuffer" + _currentEntityIndex);
+                typeof(ISnapshot),
+                "shadowSnapshot" + _currentEntityIndex);
             variables.Add(shadowValuesVariable);
             expressions.Add(
                 Assign(
                     shadowValuesVariable,
-                    Constant(ValueBuffer.Empty)));
+                    Constant(Snapshot.Empty)));
 
             var returnType = typeBase.ClrType;
             var valueBufferExpression = Call(materializationContextVariable, MaterializationContext.GetValueBufferMethod);
@@ -584,27 +581,21 @@ private Expression ProcessEntityShaper(StructuralTypeShaperExpression shaper)
                 var valueBufferExpression = Call(
                     materializationContextVariable, MaterializationContext.GetValueBufferMethod);
 
-                IEnumerable<IPropertyBase> shadowProperties = runtimeEntityType.GetProperties();
-
-                if (runtimeEntityType is IEntityType concreteEntityType)
-                {
-                    shadowProperties = shadowProperties
-                        .Concat(concreteEntityType.GetNavigations())
-                        .Concat(concreteEntityType.GetSkipNavigations());
-                }
-
-                shadowProperties = shadowProperties.Where(n => n.IsShadowProperty()).OrderBy(e => e.GetShadowIndex());
+                var shadowProperties = ((IEnumerable<IPropertyBase>)runtimeEntityType.GetProperties())
+                    .Concat(runtimeEntityType.GetNavigations())
+                    .Concat(runtimeEntityType.GetSkipNavigations())
+                    .Where(n => n.IsShadowProperty())
+                    .OrderBy(e => e.GetShadowIndex());
 
                 blockExpressions.Add(
                     Assign(
                         shadowValuesVariable,
-                        New(
-                            ValueBufferConstructor,
+                        ShadowValuesFactoryFactory.Instance.CreateConstructorExpression(runtimeEntityType,
                             NewArrayInit(
                                 typeof(object),
-                                shadowProperties.Select(
-                                    p => valueBufferExpression.CreateValueBufferReadValueExpression(
-                                        typeof(object), p.GetIndex(), p))))));
+                                shadowProperties.Select(p =>
+                                    Convert(valueBufferExpression.CreateValueBufferReadValueExpression(
+                                        p.ClrType, p.GetIndex(), p), typeof(object)))))));
             }
 
             materializer = materializer.Type == returnType
diff --git a/src/EFCore/Query/StructuralTypeShaperExpression.cs b/src/EFCore/Query/StructuralTypeShaperExpression.cs
index 26b24a7989..21800633f8 100644
--- a/src/EFCore/Query/StructuralTypeShaperExpression.cs
+++ b/src/EFCore/Query/StructuralTypeShaperExpression.cs
@@ -216,7 +216,7 @@ protected override Expression VisitChildren(ExpressionVisitor visitor)
     /// <returns>This expression if the type was not changed, or a new expression with the updated type.</returns>
     public virtual StructuralTypeShaperExpression WithType(ITypeBase type)
         => type != StructuralType
-            ? new StructuralTypeShaperExpression(type, ValueBufferExpression, IsNullable)
+            ? new StructuralTypeShaperExpression(type, ValueBufferExpression, IsNullable, materializationCondition: null)
             : this;
 
     /// <summary>
@@ -227,7 +227,7 @@ public virtual StructuralTypeShaperExpression WithType(ITypeBase type)
     public virtual StructuralTypeShaperExpression MakeNullable(bool nullable = true)
         => IsNullable != nullable
             // Marking nullable requires re-computation of materialization condition
-            ? new StructuralTypeShaperExpression(StructuralType, ValueBufferExpression, nullable)
+            ? new StructuralTypeShaperExpression(StructuralType, ValueBufferExpression, nullable, materializationCondition: null)
             : this;
 
     /// <summary>
diff --git a/src/EFCore/Storage/ValueConversion/Internal/StringNumberConverter.cs b/src/EFCore/Storage/ValueConversion/Internal/StringNumberConverter.cs
index f648f55ff0..83dc64d410 100644
--- a/src/EFCore/Storage/ValueConversion/Internal/StringNumberConverter.cs
+++ b/src/EFCore/Storage/ValueConversion/Internal/StringNumberConverter.cs
@@ -108,7 +108,7 @@ public class StringNumberConverter<TModel, TProvider, TNumber> : ValueConverter<
         if (typeof(TNumber).IsNullableType())
         {
             expression = Expression.Condition(
-                Expression.Call(param, typeof(TNumber).GetMethod("get_HasValue")!),
+                Expression.MakeMemberAccess(param, typeof(TNumber).GetProperty("HasValue")!),
                 expression,
                 Expression.Constant(null, typeof(string)));
         }
diff --git a/test/EFCore.Specification.Tests/ComplexTypesTrackingTestBase.cs b/test/EFCore.Specification.Tests/ComplexTypesTrackingTestBase.cs
index ffc0e74493..3d91a2b883 100644
--- a/test/EFCore.Specification.Tests/ComplexTypesTrackingTestBase.cs
+++ b/test/EFCore.Specification.Tests/ComplexTypesTrackingTestBase.cs
@@ -999,9 +999,8 @@ protected void AssertPropertiesModified(EntityEntry entry, bool expected)
 
     protected static EntityEntry<TEntity> TrackFromQuery<TEntity>(DbContext context, TEntity pub)
         where TEntity : class
-        => new(
-            context.GetService<IStateManager>().StartTrackingFromQuery(
-                context.Model.FindEntityType(typeof(TEntity))!, pub, new ValueBuffer()));
+        => new(context.GetService<IStateManager>().StartTrackingFromQuery(
+            context.Model.FindEntityType(typeof(TEntity))!, pub, Snapshot.Empty));
 
     protected virtual void ExecuteWithStrategyInTransaction(
         Action<DbContext> testOperation,
diff --git a/test/EFCore.Tests/ChangeTracking/Internal/FixupTest.cs b/test/EFCore.Tests/ChangeTracking/Internal/FixupTest.cs
index eeb03f1ca2..88fa345bd8 100644
--- a/test/EFCore.Tests/ChangeTracking/Internal/FixupTest.cs
+++ b/test/EFCore.Tests/ChangeTracking/Internal/FixupTest.cs
@@ -2106,30 +2106,30 @@ public void Navigation_fixup_happens_when_entities_are_tracked_from_query()
 
         var stateManager = context.GetService<IStateManager>();
 
-        stateManager.StartTrackingFromQuery(categoryType, new Category(11), new ValueBuffer(new object[] { 11 }));
-        stateManager.StartTrackingFromQuery(categoryType, new Category(12), new ValueBuffer(new object[] { 12 }));
-        stateManager.StartTrackingFromQuery(categoryType, new Category(13), new ValueBuffer(new object[] { 13 }));
+        stateManager.StartTrackingFromQuery(categoryType, new Category(11), new Snapshot<int>(11));
+        stateManager.StartTrackingFromQuery(categoryType, new Category(12), new Snapshot<int>(12));
+        stateManager.StartTrackingFromQuery(categoryType, new Category(13), new Snapshot<int>(13));
 
-        stateManager.StartTrackingFromQuery(productType, new Product(21, 11), new ValueBuffer(new object[] { 21, 11 }));
+        stateManager.StartTrackingFromQuery(productType, new Product(21, 11), new Snapshot<int, int>(21, 11));
         AssertAllFixedUp(context);
-        stateManager.StartTrackingFromQuery(productType, new Product(22, 11), new ValueBuffer(new object[] { 22, 11 }));
+        stateManager.StartTrackingFromQuery(productType, new Product(22, 11), new Snapshot<int, int>(22, 11));
         AssertAllFixedUp(context);
-        stateManager.StartTrackingFromQuery(productType, new Product(23, 11), new ValueBuffer(new object[] { 23, 11 }));
+        stateManager.StartTrackingFromQuery(productType, new Product(23, 11), new Snapshot<int, int>(23, 11));
         AssertAllFixedUp(context);
-        stateManager.StartTrackingFromQuery(productType, new Product(24, 12), new ValueBuffer(new object[] { 24, 12 }));
+        stateManager.StartTrackingFromQuery(productType, new Product(24, 12), new Snapshot<int, int>(24, 12));
         AssertAllFixedUp(context);
-        stateManager.StartTrackingFromQuery(productType, new Product(25, 12), new ValueBuffer(new object[] { 25, 12 }));
+        stateManager.StartTrackingFromQuery(productType, new Product(25, 12), new Snapshot<int, int>(25, 12));
         AssertAllFixedUp(context);
 
-        stateManager.StartTrackingFromQuery(offerType, new SpecialOffer(31, 22), new ValueBuffer(new object[] { 31, 22 }));
+        stateManager.StartTrackingFromQuery(offerType, new SpecialOffer(31, 22), new Snapshot<int, int>(31, 22));
         AssertAllFixedUp(context);
-        stateManager.StartTrackingFromQuery(offerType, new SpecialOffer(32, 22), new ValueBuffer(new object[] { 32, 22 }));
+        stateManager.StartTrackingFromQuery(offerType, new SpecialOffer(32, 22), new Snapshot<int, int>(32, 22));
         AssertAllFixedUp(context);
-        stateManager.StartTrackingFromQuery(offerType, new SpecialOffer(33, 24), new ValueBuffer(new object[] { 33, 24 }));
+        stateManager.StartTrackingFromQuery(offerType, new SpecialOffer(33, 24), new Snapshot<int, int>(33, 24));
         AssertAllFixedUp(context);
-        stateManager.StartTrackingFromQuery(offerType, new SpecialOffer(34, 24), new ValueBuffer(new object[] { 34, 24 }));
+        stateManager.StartTrackingFromQuery(offerType, new SpecialOffer(34, 24), new Snapshot<int, int>(34, 24));
         AssertAllFixedUp(context);
-        stateManager.StartTrackingFromQuery(offerType, new SpecialOffer(35, 24), new ValueBuffer(new object[] { 35, 24 }));
+        stateManager.StartTrackingFromQuery(offerType, new SpecialOffer(35, 24), new Snapshot<int, int>(35, 24));
 
         AssertAllFixedUp(context);
 
diff --git a/test/EFCore.Tests/ChangeTracking/Internal/StateManagerTest.cs b/test/EFCore.Tests/ChangeTracking/Internal/StateManagerTest.cs
index c8116a31f9..cd7944103f 100644
--- a/test/EFCore.Tests/ChangeTracking/Internal/StateManagerTest.cs
+++ b/test/EFCore.Tests/ChangeTracking/Internal/StateManagerTest.cs
@@ -606,11 +606,11 @@ public void StartTracking_is_no_op_if_entity_is_already_tracked()
         var stateManager = CreateStateManager(model);
 
         var category = new Category { Id = 77, PrincipalId = 777 };
-        var valueBuffer = new ValueBuffer(new object[] { 77, "Bjork", 777 });
+        var snapshot = new Snapshot<int, string, int>(77, "Bjork", 777);
 
-        var entry = stateManager.StartTrackingFromQuery(categoryType, category, valueBuffer);
+        var entry = stateManager.StartTrackingFromQuery(categoryType, category, snapshot);
 
-        Assert.Same(entry, stateManager.StartTrackingFromQuery(categoryType, category, valueBuffer));
+        Assert.Same(entry, stateManager.StartTrackingFromQuery(categoryType, category, snapshot));
     }
 
     [ConditionalFact]
diff --git a/test/EFCore.Tests/Metadata/Internal/PropertyAccessorsFactoryTest.cs b/test/EFCore.Tests/Metadata/Internal/PropertyAccessorsFactoryTest.cs
index 425d62652d..086e8f06ec 100644
--- a/test/EFCore.Tests/Metadata/Internal/PropertyAccessorsFactoryTest.cs
+++ b/test/EFCore.Tests/Metadata/Internal/PropertyAccessorsFactoryTest.cs
@@ -9,6 +9,7 @@ namespace Microsoft.EntityFrameworkCore.Metadata.Internal;
 public class PropertyAccessorsFactoryTest
 {
     [ConditionalFact]
+    [Obsolete]
     public void Can_use_PropertyAccessorsFactory_on_indexed_property()
     {
         var modelBuilder = InMemoryTestHelpers.Instance.CreateConventionBuilder();
@@ -35,6 +36,7 @@ public void Can_use_PropertyAccessorsFactory_on_indexed_property()
     }
 
     [ConditionalFact]
+    [Obsolete]
     public void Can_use_PropertyAccessorsFactory_on_non_indexed_property()
     {
         var modelBuilder = InMemoryTestHelpers.Instance.CreateConventionBuilder();
diff --git a/test/EFCore.Tests/TestUtilities/FakeStateManager.cs b/test/EFCore.Tests/TestUtilities/FakeStateManager.cs
index a3319ee9c8..3887affd92 100644
--- a/test/EFCore.Tests/TestUtilities/FakeStateManager.cs
+++ b/test/EFCore.Tests/TestUtilities/FakeStateManager.cs
@@ -134,7 +134,7 @@ public InternalEntityEntry CreateEntry(IDictionary<string, object> values, IEnti
     public InternalEntityEntry StartTrackingFromQuery(
         IEntityType baseEntityType,
         object entity,
-        in ValueBuffer valueBuffer)
+        in ISnapshot snapshot)
         => throw new NotImplementedException();
 
     public InternalEntityEntry TryGetEntry(IKey key, IReadOnlyList<object> keyValues)
