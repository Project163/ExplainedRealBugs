diff --git a/src/EFCore.Design/Migrations/Design/CSharpSnapshotGenerator.cs b/src/EFCore.Design/Migrations/Design/CSharpSnapshotGenerator.cs
index 42c13f2477..a7163f2451 100644
--- a/src/EFCore.Design/Migrations/Design/CSharpSnapshotGenerator.cs
+++ b/src/EFCore.Design/Migrations/Design/CSharpSnapshotGenerator.cs
@@ -715,14 +715,22 @@ protected virtual void GenerateKeyAnnotations(string keyBuilderName, IKey key, I
                 }
 
                 var isExcludedAnnotation = annotations.Find(RelationalAnnotationNames.IsTableExcludedFromMigrations);
+                var isExcludedFromMigrations = (isExcludedAnnotation?.Value as bool?) == true;
+                if (isExcludedAnnotation is not null)
+                {
+                    annotations.Remove(isExcludedAnnotation.Name);
+                }
+
+                var hasTriggers = entityType.GetTriggers().Any();
+                var requiresTableBuilder = isExcludedFromMigrations || hasTriggers;
+
                 if (schema != null
                     || (schemaAnnotation != null && tableName != null))
                 {
                     stringBuilder
                         .Append(", ");
 
-                    if (schema == null
-                        && ((bool?)isExcludedAnnotation?.Value) != true)
+                    if (schema == null && !requiresTableBuilder)
                     {
                         stringBuilder.Append("(string)");
                     }
@@ -730,15 +738,32 @@ protected virtual void GenerateKeyAnnotations(string keyBuilderName, IKey key, I
                     stringBuilder.Append(Code.UnknownLiteral(schema));
                 }
 
-                if (isExcludedAnnotation != null)
+                if (requiresTableBuilder)
                 {
-                    if (((bool?)isExcludedAnnotation.Value) == true)
+                    if (isExcludedFromMigrations && !hasTriggers)
                     {
-                        stringBuilder
-                            .Append(", t => t.ExcludeFromMigrations()");
+                        stringBuilder.Append(", t => t.ExcludeFromMigrations()");
                     }
+                    else
+                    {
+                        stringBuilder
+                            .AppendLine(", t =>")
+                            .AppendLine("{");
 
-                    annotations.Remove(isExcludedAnnotation.Name);
+                        using (stringBuilder.Indent())
+                        {
+                            if (isExcludedFromMigrations)
+                            {
+                                stringBuilder
+                                    .AppendLine("t.ExcludeFromMigrations();")
+                                    .AppendLine();
+                            }
+
+                            GenerateTriggers("t", entityType, stringBuilder);
+                        }
+
+                        stringBuilder.Append("}");
+                    }
                 }
 
                 stringBuilder.AppendLine(");");
@@ -943,6 +968,64 @@ protected virtual void GenerateKeyAnnotations(string keyBuilderName, IKey key, I
         stringBuilder.AppendLine(");");
     }
 
+    /// <summary>
+    ///     Generates code for <see cref="ITrigger" /> objects.
+    /// </summary>
+    /// <param name="tableBuilderName">The name of the table builder variable.</param>
+    /// <param name="entityType">The entity type.</param>
+    /// <param name="stringBuilder">The builder code is added to.</param>
+    protected virtual void GenerateTriggers(
+        string tableBuilderName,
+        IEntityType entityType,
+        IndentedStringBuilder stringBuilder)
+    {
+        foreach (var trigger in entityType.GetTriggers())
+        {
+            GenerateTrigger(tableBuilderName, trigger, stringBuilder);
+        }
+    }
+
+    /// <summary>
+    ///     Generates code for an <see cref="ITrigger" />.
+    /// </summary>
+    /// <param name="tableBuilderName">The name of the table builder variable.</param>
+    /// <param name="trigger">The check constraint.</param>
+    /// <param name="stringBuilder">The builder code is added to.</param>
+    protected virtual void GenerateTrigger(
+        string tableBuilderName,
+        ITrigger trigger,
+        IndentedStringBuilder stringBuilder)
+    {
+        var triggerBuilderNameStringBuilder = new StringBuilder();
+        triggerBuilderNameStringBuilder
+            .Append(tableBuilderName)
+            .Append(".HasTrigger(")
+            .Append(Code.Literal(trigger.ModelName))
+            .Append(")");
+        var triggerBuilderName = triggerBuilderNameStringBuilder.ToString();
+
+        stringBuilder.Append(triggerBuilderName);
+
+        // Note that GenerateAnnotations below does the corresponding decrement
+        stringBuilder.IncrementIndent();
+
+        if (trigger.Name != null
+            && trigger.Name != (trigger.GetDefaultName() ?? trigger.ModelName))
+        {
+            stringBuilder
+                .AppendLine()
+                .Append(".HasName(")
+                .Append(Code.Literal(trigger.Name))
+                .Append(")");
+        }
+
+        var annotations = Dependencies.AnnotationCodeGenerator
+            .FilterIgnoredAnnotations(trigger.GetAnnotations())
+            .ToDictionary(a => a.Name, a => a);
+
+        GenerateAnnotations(triggerBuilderName, trigger, stringBuilder, annotations, inChainedCall: true);
+    }
+
     /// <summary>
     ///     Generates code for <see cref="IForeignKey" /> objects.
     /// </summary>
diff --git a/src/EFCore.Relational/Design/AnnotationCodeGenerator.cs b/src/EFCore.Relational/Design/AnnotationCodeGenerator.cs
index a091fb79db..7b23e8c26d 100644
--- a/src/EFCore.Relational/Design/AnnotationCodeGenerator.cs
+++ b/src/EFCore.Relational/Design/AnnotationCodeGenerator.cs
@@ -28,6 +28,7 @@ public class AnnotationCodeGenerator : IAnnotationCodeGenerator
     private static readonly ISet<string> IgnoredRelationalAnnotations = new HashSet<string>
     {
         RelationalAnnotationNames.CheckConstraints,
+        RelationalAnnotationNames.Triggers,
         RelationalAnnotationNames.Sequences,
         RelationalAnnotationNames.DbFunctions,
         RelationalAnnotationNames.RelationalOverrides
diff --git a/src/EFCore.Relational/Design/IAnnotationCodeGenerator.cs b/src/EFCore.Relational/Design/IAnnotationCodeGenerator.cs
index a301c9e484..9a0b5bc88d 100644
--- a/src/EFCore.Relational/Design/IAnnotationCodeGenerator.cs
+++ b/src/EFCore.Relational/Design/IAnnotationCodeGenerator.cs
@@ -223,6 +223,17 @@ void RemoveAnnotationsHandledByConventions(IAnnotatable annotatable, IDictionary
         IDictionary<string, IAnnotation> annotations)
         => Array.Empty<MethodCallCodeFragment>();
 
+    /// <summary>
+    ///     For the given annotations which have corresponding fluent API calls, returns those fluent API calls
+    ///     and removes the annotations.
+    /// </summary>
+    /// <param name="trigger">The trigger to which the annotations are applied.</param>
+    /// <param name="annotations">The set of annotations from which to generate fluent API calls.</param>
+    IReadOnlyList<MethodCallCodeFragment> GenerateFluentApiCalls(
+        ITrigger trigger,
+        IDictionary<string, IAnnotation> annotations)
+        => Array.Empty<MethodCallCodeFragment>();
+
     /// <summary>
     ///     For the given annotations which have corresponding fluent API calls, returns those fluent API calls
     ///     and removes the annotations.
@@ -240,6 +251,8 @@ IReadOnlyList<MethodCallCodeFragment> GenerateFluentApiCalls(IAnnotatable annota
             INavigation navigation => GenerateFluentApiCalls(navigation, annotations),
             ISkipNavigation skipNavigation => GenerateFluentApiCalls(skipNavigation, annotations),
             IIndex index => GenerateFluentApiCalls(index, annotations),
+            ITrigger trigger => GenerateFluentApiCalls(trigger, annotations),
+
             _ => throw new ArgumentException(RelationalStrings.UnhandledAnnotatableType(annotatable.GetType()))
         };
 
diff --git a/src/EFCore.Relational/Design/Internal/RelationalCSharpRuntimeAnnotationCodeGenerator.cs b/src/EFCore.Relational/Design/Internal/RelationalCSharpRuntimeAnnotationCodeGenerator.cs
index 26e55fb3a3..06401509b7 100644
--- a/src/EFCore.Relational/Design/Internal/RelationalCSharpRuntimeAnnotationCodeGenerator.cs
+++ b/src/EFCore.Relational/Design/Internal/RelationalCSharpRuntimeAnnotationCodeGenerator.cs
@@ -325,11 +325,63 @@ public override void Generate(IEntityType entityType, CSharpRuntimeAnnotationCod
             annotations[RelationalAnnotationNames.ViewSchema] = entityType.GetViewSchema();
             annotations[RelationalAnnotationNames.SqlQuery] = entityType.GetSqlQuery();
             annotations[RelationalAnnotationNames.FunctionName] = entityType.GetFunctionName();
+
+            if (annotations.TryGetAndRemove(
+                    RelationalAnnotationNames.Triggers,
+                    out SortedDictionary<string, ITrigger> triggers))
+            {
+                parameters.Namespaces.Add(typeof(SortedDictionary<,>).Namespace!);
+                var triggersVariable = Dependencies.CSharpHelper.Identifier("triggers", parameters.ScopeVariables, capitalize: false);
+                parameters.MainBuilder
+                    .Append("var ").Append(triggersVariable).AppendLine(" = new SortedDictionary<string, ITrigger>();").AppendLine();
+
+                foreach (var (_, trigger) in triggers)
+                {
+                    Create(trigger, triggersVariable, parameters);
+                }
+
+                GenerateSimpleAnnotation(RelationalAnnotationNames.Triggers, triggersVariable, parameters);
+            }
         }
 
         base.Generate(entityType, parameters);
     }
 
+    private void Create(ITrigger trigger, string triggersVariable, CSharpRuntimeAnnotationCodeGeneratorParameters parameters)
+    {
+        var code = Dependencies.CSharpHelper;
+        var triggerVariable = code.Identifier(trigger.ModelName, parameters.ScopeVariables, capitalize: false);
+        var mainBuilder = parameters.MainBuilder;
+        mainBuilder
+            .Append("var ").Append(triggerVariable).AppendLine(" = new RuntimeTrigger(").IncrementIndent()
+            .Append(parameters.TargetName).AppendLine(",")
+            .Append(code.Literal(trigger.ModelName)).AppendLine(",")
+            .Append(code.UnknownLiteral(trigger.Name)).AppendLine(",")
+            .Append(code.Literal(trigger.TableName)).AppendLine(",")
+            .Append(code.UnknownLiteral(trigger.TableSchema))
+            .AppendLine(");")
+            .DecrementIndent()
+            .AppendLine();
+
+        CreateAnnotations(
+            trigger,
+            Generate,
+            parameters with { TargetName = triggerVariable });
+
+        mainBuilder
+            .Append(triggersVariable).Append("[").Append(code.Literal(trigger.ModelName)).Append("] = ")
+            .Append(triggerVariable).AppendLine(";")
+            .AppendLine();
+    }
+
+    /// <summary>
+    ///     Generates code to create the given annotations.
+    /// </summary>
+    /// <param name="trigger">The trigger to which the annotations are applied.</param>
+    /// <param name="parameters">Additional parameters used during code generation.</param>
+    public virtual void Generate(ITrigger trigger, CSharpRuntimeAnnotationCodeGeneratorParameters parameters)
+        => GenerateSimpleAnnotations(parameters);
+
     /// <summary>
     ///     Generates code to create the given annotations.
     /// </summary>
diff --git a/src/EFCore.Relational/Extensions/RelationalEntityTypeBuilderExtensions.cs b/src/EFCore.Relational/Extensions/RelationalEntityTypeBuilderExtensions.cs
index dae7f560de..2bcca5e725 100644
--- a/src/EFCore.Relational/Extensions/RelationalEntityTypeBuilderExtensions.cs
+++ b/src/EFCore.Relational/Extensions/RelationalEntityTypeBuilderExtensions.cs
@@ -1846,4 +1846,55 @@ public static EntityTypeBuilder<TEntity> UseTptMappingStrategy<TEntity>(this Ent
             RelationalAnnotationNames.Comment,
             comment,
             fromDataAnnotation);
+
+    /// <summary>
+    ///     Configures a database trigger when targeting a relational database.
+    /// </summary>
+    /// <remarks>
+    ///     See <see href="https://aka.ms/efcore-docs-triggers">Database triggers</see> for more information and examples.
+    /// </remarks>
+    /// <param name="entityTypeBuilder">The entity type builder.</param>
+    /// <param name="name">The name of the trigger.</param>
+    /// <param name="tableName">The name of the table on which this trigger is defined.</param>
+    /// <param name="tableSchema">The schema of the table on which this trigger is defined.</param>
+    /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
+    /// <returns>The same builder instance if the check constraint was configured, <see langword="null" /> otherwise.</returns>
+    public static IConventionTriggerBuilder? HasTrigger(
+        this IConventionEntityTypeBuilder entityTypeBuilder,
+        string name,
+        string? tableName,
+        string? tableSchema,
+        bool fromDataAnnotation = false)
+        => InternalTriggerBuilder.HasTrigger(
+                entityTypeBuilder.Metadata,
+                name,
+                tableName,
+                tableSchema,
+                fromDataAnnotation ? ConfigurationSource.DataAnnotation : ConfigurationSource.Convention)
+            ?.Builder;
+
+    /// <summary>
+    ///     Returns a value indicating whether the trigger can be configured.
+    /// </summary>
+    /// <remarks>
+    ///     See <see href="https://aka.ms/efcore-docs-triggers">Database triggers</see> for more information and examples.
+    /// </remarks>
+    /// <param name="entityTypeBuilder">The builder for the entity type being configured.</param>
+    /// <param name="name">The name of the trigger.</param>
+    /// <param name="tableName">The name of the table on which this trigger is defined.</param>
+    /// <param name="tableSchema">The schema of the table on which this trigger is defined.</param>
+    /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
+    /// <returns><see langword="true" /> if the configuration can be applied.</returns>
+    public static bool CanHaveTrigger(
+        this IConventionEntityTypeBuilder entityTypeBuilder,
+        string name,
+        string? tableName,
+        string? tableSchema,
+        bool fromDataAnnotation = false)
+        => InternalTriggerBuilder.CanHaveTrigger(
+            entityTypeBuilder.Metadata,
+            name,
+            tableName,
+            tableSchema,
+            fromDataAnnotation ? ConfigurationSource.DataAnnotation : ConfigurationSource.Convention);
 }
diff --git a/src/EFCore.Relational/Extensions/RelationalEntityTypeExtensions.cs b/src/EFCore.Relational/Extensions/RelationalEntityTypeExtensions.cs
index 74fa562043..5e36879989 100644
--- a/src/EFCore.Relational/Extensions/RelationalEntityTypeExtensions.cs
+++ b/src/EFCore.Relational/Extensions/RelationalEntityTypeExtensions.cs
@@ -20,6 +20,8 @@ public static class RelationalEntityTypeExtensions
     /// </summary>
     public static readonly string DefaultQueryNameBase = "MappedSqlQuery";
 
+    #region Table mapping
+
     /// <summary>
     ///     Returns the name of the table to which the entity type is mapped
     ///     or <see langword="null" /> if not mapped to a table.
@@ -273,6 +275,10 @@ public static IEnumerable<ITableMapping> GetTableMappings(this IEntityType entit
                 RelationalAnnotationNames.TableMappings)
             ?? Enumerable.Empty<ITableMapping>();
 
+    #endregion Table mapping
+
+    #region View mapping
+
     /// <summary>
     ///     Returns the name of the view to which the entity type is mapped or <see langword="null" /> if not mapped to a view.
     /// </summary>
@@ -438,6 +444,10 @@ public static IEnumerable<IViewMapping> GetViewMappings(this IEntityType entityT
                 RelationalAnnotationNames.ViewMappings)
             ?? Enumerable.Empty<IViewMapping>();
 
+    #endregion View mapping
+
+    #region SQL query mapping
+
     /// <summary>
     ///     Gets the default SQL query name that would be used for this entity type when mapped using
     ///     <see cref="O:RelationalEntityTypeBuilderExtensions.ToSqlQuery" />.
@@ -503,6 +513,10 @@ public static IEnumerable<ISqlQueryMapping> GetSqlQueryMappings(this IEntityType
                 RelationalAnnotationNames.SqlQueryMappings)
             ?? Enumerable.Empty<ISqlQueryMapping>();
 
+    #endregion SQL query mapping
+
+    #region Function mapping
+
     /// <summary>
     ///     Returns the name of the function to which the entity type is mapped or <see langword="null" /> if not mapped to a function.
     /// </summary>
@@ -559,6 +573,10 @@ public static IEnumerable<IFunctionMapping> GetFunctionMappings(this IEntityType
                 RelationalAnnotationNames.FunctionMappings)
             ?? Enumerable.Empty<IFunctionMapping>();
 
+    #endregion Function mapping
+
+    #region Check constraint
+
     /// <summary>
     ///     Finds an <see cref="IReadOnlyCheckConstraint" /> with the given name.
     /// </summary>
@@ -760,6 +778,10 @@ public static IEnumerable<IConventionCheckConstraint> GetDeclaredCheckConstraint
     public static IEnumerable<ICheckConstraint> GetDeclaredCheckConstraints(this IEntityType entityType)
         => CheckConstraint.GetDeclaredCheckConstraints(entityType).Cast<ICheckConstraint>();
 
+    #endregion Check constraint
+
+    #region Comment
+
     /// <summary>
     ///     Returns the comment for the table this entity is mapped to.
     /// </summary>
@@ -804,6 +826,8 @@ public static void SetComment(this IMutableEntityType entityType, string? commen
         => entityType.FindAnnotation(RelationalAnnotationNames.Comment)
             ?.GetConfigurationSource();
 
+    #endregion Comment
+
     /// <summary>
     ///     Gets the foreign keys for the given entity type that point to other entity types
     ///     sharing the same table-like store object.
@@ -900,6 +924,8 @@ public static void SetComment(this IMutableEntityType entityType, string? commen
         // ReSharper disable once RedundantCast
         => ((IReadOnlyEntityType)entityType).FindRowInternalForeignKeys(storeObject).Cast<IForeignKey>();
 
+    #region IsTableExcludedFromMigrations
+
     /// <summary>
     ///     Gets a value indicating whether the associated table is ignored by Migrations.
     /// </summary>
@@ -987,6 +1013,10 @@ public static void SetIsTableExcludedFromMigrations(this IMutableEntityType enti
         return null;
     }
 
+    #endregion IsTableExcludedFromMigrations
+
+    #region Mapping strategy
+
     /// <summary>
     ///     Sets the mapping strategy for the derived types.
     /// </summary>
@@ -1019,4 +1049,218 @@ public static void SetMappingStrategy(this IMutableEntityType entityType, string
         this IConventionEntityType entityType)
         => entityType.FindAnnotation(RelationalAnnotationNames.MappingStrategy)
             ?.GetConfigurationSource();
+
+    #endregion Mapping strategy
+
+    #region Trigger
+
+    /// <summary>
+    ///     Finds a trigger with the given name.
+    /// </summary>
+    /// <param name="entityType">The entity type to find the sequence on.</param>
+    /// <param name="name">The trigger name.</param>
+    /// <returns>The trigger or <see langword="null" /> if no trigger with the given name was found.</returns>
+    public static IReadOnlyTrigger? FindTrigger(this IReadOnlyEntityType entityType, string name)
+        => Trigger.FindTrigger(entityType, Check.NotEmpty(name, nameof(name)));
+
+    /// <summary>
+    ///     Finds a trigger with the given name.
+    /// </summary>
+    /// <param name="entityType">The entity type to find the sequence on.</param>
+    /// <param name="name">The trigger name.</param>
+    /// <returns>The trigger or <see langword="null" /> if no trigger with the given name was found.</returns>
+    public static IMutableTrigger? FindTrigger(this IMutableEntityType entityType, string name)
+        => (IMutableTrigger?)((IReadOnlyEntityType)entityType).FindTrigger(name);
+
+    /// <summary>
+    ///     Finds a trigger with the given name.
+    /// </summary>
+    /// <param name="entityType">The entity type to find the sequence on.</param>
+    /// <param name="name">The trigger name.</param>
+    /// <returns>The trigger or <see langword="null" /> if no trigger with the given name was found.</returns>
+    public static IConventionTrigger? FindTrigger(this IConventionEntityType entityType, string name)
+        => (IConventionTrigger?)((IReadOnlyEntityType)entityType).FindTrigger(name);
+
+    /// <summary>
+    ///     Finds a trigger with the given name.
+    /// </summary>
+    /// <param name="entityType">The entity type to find the sequence on.</param>
+    /// <param name="name">The trigger name.</param>
+    /// <returns>The trigger or <see langword="null" /> if no trigger with the given name was found.</returns>
+    public static ITrigger? FindTrigger(this IEntityType entityType, string name)
+        => (ITrigger?)((IReadOnlyEntityType)entityType).FindTrigger(name);
+
+    /// <summary>
+    ///     Creates a new trigger with the given name on entity type. Throws an exception if a trigger with the same name exists on the same
+    ///     entity type.
+    /// </summary>
+    /// <param name="entityType">The entity type to add the trigger to.</param>
+    /// <param name="name">The trigger name.</param>
+    /// <returns>The trigger.</returns>
+    public static IMutableTrigger AddTrigger(this IMutableEntityType entityType, string name)
+    {
+        Check.NotEmpty(name, nameof(name));
+
+        return new Trigger(entityType, name, tableName: null, tableSchema: null, ConfigurationSource.Explicit);
+    }
+
+    /// <summary>
+    ///     Creates a new trigger with the given name on entity type. Throws an exception if a trigger with the same name exists on the same
+    ///     entity type.
+    /// </summary>
+    /// <param name="entityType">The entity type to add the trigger to.</param>
+    /// <param name="name">The trigger name.</param>
+    /// <param name="tableName">The name of the table on which this trigger is defined.</param>
+    /// <param name="tableSchema">The schema of the table on which this trigger is defined.</param>
+    /// <returns>The trigger.</returns>
+    public static IMutableTrigger AddTrigger(this IMutableEntityType entityType, string name, string tableName, string? tableSchema = null)
+    {
+        Check.NotEmpty(name, nameof(name));
+
+        return new Trigger(entityType, name, tableName, tableSchema, ConfigurationSource.Explicit);
+    }
+
+    /// <summary>
+    ///     Creates a new trigger with the given name on entity type. Throws an exception if a trigger with the same name exists on the same
+    ///     entity type.
+    /// </summary>
+    /// <param name="entityType">The entityType to add the trigger to.</param>
+    /// <param name="name">The trigger name.</param>
+    /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
+    /// <returns>The trigger.</returns>
+    public static IConventionTrigger AddTrigger(
+        this IConventionEntityType entityType,
+        string name,
+        bool fromDataAnnotation = false)
+    {
+        Check.NotEmpty(name, nameof(name));
+
+        return new Trigger(
+            (IMutableEntityType)entityType, name, tableName: null, tableSchema: null,
+            fromDataAnnotation ? ConfigurationSource.DataAnnotation : ConfigurationSource.Convention);
+    }
+
+    /// <summary>
+    ///     Creates a new trigger with the given name on entity type. Throws an exception if a trigger with the same name exists on the same
+    ///     entity type.
+    /// </summary>
+    /// <param name="entityType">The entityType to add the trigger to.</param>
+    /// <param name="name">The trigger name.</param>
+    /// <param name="tableName">The name of the table on which this trigger is defined.</param>
+    /// <param name="tableSchema">The schema of the table on which this trigger is defined.</param>
+    /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
+    /// <returns>The trigger.</returns>
+    public static IConventionTrigger AddTrigger(
+        this IConventionEntityType entityType,
+        string name,
+        string tableName,
+        string? tableSchema,
+        bool fromDataAnnotation = false)
+    {
+        Check.NotEmpty(name, nameof(name));
+
+        return new Trigger(
+            (IMutableEntityType)entityType, name, tableName, tableSchema,
+            fromDataAnnotation ? ConfigurationSource.DataAnnotation : ConfigurationSource.Convention);
+    }
+
+    /// <summary>
+    ///     Removes the <see cref="IMutableTrigger" /> with the given name.
+    /// </summary>
+    /// <param name="entityType">The entityType to find the trigger in.</param>
+    /// <param name="name">The trigger name.</param>
+    /// <returns>
+    ///     The removed <see cref="IMutableTrigger" /> or <see langword="null" /> if no trigger with the given name was found.
+    /// </returns>
+    public static IMutableTrigger? RemoveTrigger(this IMutableEntityType entityType, string name)
+        => Trigger.RemoveTrigger(entityType, name);
+
+    /// <summary>
+    ///     Removes the <see cref="IConventionTrigger" /> with the given name.
+    /// </summary>
+    /// <param name="entityType">The entityType to find the trigger in.</param>
+    /// <param name="name">The trigger name.</param>
+    /// <returns>
+    ///     The removed <see cref="IMutableTrigger" /> or <see langword="null" /> if no trigger with the given name was found.
+    /// </returns>
+    public static IConventionTrigger? RemoveTrigger(this IConventionEntityType entityType, string name)
+        => Trigger.RemoveTrigger((IMutableEntityType)entityType, name);
+
+    /// <summary>
+    ///     Returns all triggers on the entity type.
+    /// </summary>
+    /// <param name="entityType">The entity type to get the triggers on.</param>
+    public static IEnumerable<IReadOnlyTrigger> GetTriggers(this IReadOnlyEntityType entityType)
+        => Trigger.GetTriggers(entityType);
+
+    /// <summary>
+    ///     Returns all triggers on the entity type.
+    /// </summary>
+    /// <param name="entityType">The entity type to get the triggers on.</param>
+    public static IEnumerable<IMutableTrigger> GetTriggers(this IMutableEntityType entityType)
+        => Trigger.GetTriggers(entityType).Cast<IMutableTrigger>();
+
+    /// <summary>
+    ///     Returns all triggers on the entity type.
+    /// </summary>
+    /// <param name="entityType">The entity type to get the triggers on.</param>
+    public static IEnumerable<IConventionTrigger> GetTriggers(this IConventionEntityType entityType)
+        => Trigger.GetTriggers(entityType).Cast<IConventionTrigger>();
+
+    /// <summary>
+    ///     Returns all triggers on the entity type.
+    /// </summary>
+    /// <param name="entityType">The entity type to get the triggers on.</param>
+    public static IEnumerable<ITrigger> GetTriggers(this IEntityType entityType)
+        => Trigger.GetTriggers(entityType).Cast<ITrigger>();
+
+    /// <summary>
+    ///     Returns all triggers on the entity type.
+    /// </summary>
+    /// <param name="entityType">The entity type to get the triggers on.</param>
+    /// <remarks>
+    ///     This method does not return triggers declared on base types.
+    ///     It is useful when iterating over all entity types to avoid processing the same trigger more than once.
+    ///     Use <see cref="GetTriggers(IReadOnlyEntityType)" /> to also return triggers declared on base types.
+    /// </remarks>
+    public static IEnumerable<IReadOnlyTrigger> GetDeclaredTriggers(this IReadOnlyEntityType entityType)
+        => Trigger.GetDeclaredTriggers(entityType);
+
+    /// <summary>
+    ///     Returns all triggers on the entity type.
+    /// </summary>
+    /// <param name="entityType">The entity type to get the triggers on.</param>
+    /// <remarks>
+    ///     This method does not return triggers declared on base types.
+    ///     It is useful when iterating over all entity types to avoid processing the same trigger more than once.
+    ///     Use <see cref="GetTriggers(IMutableEntityType)" /> to also return triggers declared on base types.
+    /// </remarks>
+    public static IEnumerable<IMutableTrigger> GetDeclaredTriggers(this IMutableEntityType entityType)
+        => Trigger.GetDeclaredTriggers(entityType).Cast<IMutableTrigger>();
+
+    /// <summary>
+    ///     Returns all triggers on the entity type.
+    /// </summary>
+    /// <param name="entityType">The entity type to get the triggers on.</param>
+    /// <remarks>
+    ///     This method does not return triggers declared on base types.
+    ///     It is useful when iterating over all entity types to avoid processing the same trigger more than once.
+    ///     Use <see cref="GetTriggers(IConventionEntityType)" /> to also return triggers declared on base types.
+    /// </remarks>
+    public static IEnumerable<IConventionTrigger> GetDeclaredTriggers(this IConventionEntityType entityType)
+        => Trigger.GetDeclaredTriggers(entityType).Cast<IConventionTrigger>();
+
+    /// <summary>
+    ///     Returns all triggers on the entity type.
+    /// </summary>
+    /// <param name="entityType">The entity type to get the triggers on.</param>
+    /// <remarks>
+    ///     This method does not return triggers declared on base types.
+    ///     It is useful when iterating over all entity types to avoid processing the same trigger more than once.
+    ///     Use <see cref="GetTriggers(IEntityType)" /> to also return triggers declared on base types.
+    /// </remarks>
+    public static IEnumerable<ITrigger> GetDeclaredTriggers(this IEntityType entityType)
+        => Trigger.GetDeclaredTriggers(entityType).Cast<ITrigger>();
+
+    #endregion Trigger
 }
diff --git a/src/EFCore.Relational/Extensions/RelationalModelExtensions.cs b/src/EFCore.Relational/Extensions/RelationalModelExtensions.cs
index 2d53ff66db..d95a4b7a09 100644
--- a/src/EFCore.Relational/Extensions/RelationalModelExtensions.cs
+++ b/src/EFCore.Relational/Extensions/RelationalModelExtensions.cs
@@ -14,6 +14,8 @@ namespace Microsoft.EntityFrameworkCore;
 /// </remarks>
 public static class RelationalModelExtensions
 {
+    #region Default schema
+
     /// <summary>
     ///     Returns the default schema to use for the model, or <see langword="null" /> if none has been set.
     /// </summary>
@@ -58,6 +60,8 @@ public static void SetDefaultSchema(this IMutableModel model, string? value)
     public static ConfigurationSource? GetDefaultSchemaConfigurationSource(this IConventionModel model)
         => model.FindAnnotation(RelationalAnnotationNames.DefaultSchema)?.GetConfigurationSource();
 
+    #endregion Default schema
+
     /// <summary>
     ///     Returns the database model.
     /// </summary>
@@ -74,6 +78,8 @@ public static IRelationalModel GetRelationalModel(this IModel model)
         return databaseModel;
     }
 
+    #region Max identifier length
+
     /// <summary>
     ///     Returns the maximum length allowed for store identifiers.
     /// </summary>
@@ -112,6 +118,10 @@ public static void SetMaxIdentifierLength(this IMutableModel model, int? length)
     public static ConfigurationSource? GetMaxIdentifierLengthConfigurationSource(this IConventionModel model)
         => model.FindAnnotation(RelationalAnnotationNames.MaxIdentifierLength)?.GetConfigurationSource();
 
+    #endregion Max identifier length
+
+    #region Sequence
+
     /// <summary>
     ///     Finds a sequence with the given name.
     /// </summary>
@@ -269,6 +279,10 @@ public static IEnumerable<IConventionSequence> GetSequences(this IConventionMode
     public static IEnumerable<IReadOnlySequence> GetSequences(this IReadOnlyModel model)
         => Sequence.GetSequences(model);
 
+    #endregion Sequence
+
+    #region DbFunction
+
     /// <summary>
     ///     Finds a function that is mapped to the method represented by the given <see cref="MethodInfo" />.
     /// </summary>
@@ -467,6 +481,10 @@ public static IEnumerable<IConventionDbFunction> GetDbFunctions(this IConvention
     public static IEnumerable<IDbFunction> GetDbFunctions(this IModel model)
         => DbFunction.GetDbFunctions(model);
 
+    #endregion DbFunction
+
+    #region Collation
+
     /// <summary>
     ///     Returns the database collation.
     /// </summary>
@@ -509,4 +527,6 @@ public static void SetCollation(this IMutableModel model, string? value)
     /// <returns>The configuration source for the collation.</returns>
     public static ConfigurationSource? GetCollationConfigurationSource(this IConventionModel model)
         => model.FindAnnotation(RelationalAnnotationNames.Collation)?.GetConfigurationSource();
+
+    #endregion Collation
 }
diff --git a/src/EFCore.Relational/Infrastructure/RelationalModelValidator.cs b/src/EFCore.Relational/Infrastructure/RelationalModelValidator.cs
index fc68d71a41..b1066abdcf 100644
--- a/src/EFCore.Relational/Infrastructure/RelationalModelValidator.cs
+++ b/src/EFCore.Relational/Infrastructure/RelationalModelValidator.cs
@@ -1,6 +1,7 @@
 ï»¿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using Microsoft.EntityFrameworkCore.Internal;
 using Microsoft.EntityFrameworkCore.Metadata.Internal;
 
 namespace Microsoft.EntityFrameworkCore.Infrastructure;
@@ -56,6 +57,7 @@ public override void Validate(IModel model, IDiagnosticsLogger<DbLoggerCategory.
         ValidateDefaultValuesOnKeys(model, logger);
         ValidateBoolsWithDefaults(model, logger);
         ValidateIndexProperties(model, logger);
+        ValidateTriggers(model, logger);
     }
 
     /// <summary>
@@ -291,6 +293,7 @@ static bool IsNotNullAndFalse(object? value)
             ValidateSharedForeignKeysCompatibility(mappedTypes, table, logger);
             ValidateSharedIndexesCompatibility(mappedTypes, table, logger);
             ValidateSharedCheckConstraintCompatibility(mappedTypes, table, logger);
+            ValidateSharedTriggerCompatibility(mappedTypes, table, logger);
 
             // Validate optional dependents
             if (mappedTypes.Count == 1)
@@ -1191,7 +1194,7 @@ private static bool IsIdentifyingPrincipal(IEntityType dependentEntityType, IEnt
         => key.AreCompatible(duplicateKey, storeObject, shouldThrow: true);
 
     /// <summary>
-    ///     Validates the compatibility of check constraint in a given shared table.
+    ///     Validates the compatibility of check constraints in a given shared table.
     /// </summary>
     /// <param name="mappedTypes">The mapped entity types.</param>
     /// <param name="storeObject">The identifier of the store object.</param>
@@ -1223,8 +1226,8 @@ private static bool IsIdentifyingPrincipal(IEntityType dependentEntityType, IEnt
     /// <summary>
     ///     Validates the compatibility of two check constraints with the same name.
     /// </summary>
-    /// <param name="checkConstraint">An check constraints.</param>
-    /// <param name="duplicateCheckConstraint">Another check constraints.</param>
+    /// <param name="checkConstraint">A check constraint.</param>
+    /// <param name="duplicateCheckConstraint">Another check constraint.</param>
     /// <param name="indexName">The name of the check constraint.</param>
     /// <param name="storeObject">The identifier of the store object.</param>
     /// <param name="logger">The logger to use.</param>
@@ -1236,6 +1239,53 @@ private static bool IsIdentifyingPrincipal(IEntityType dependentEntityType, IEnt
         IDiagnosticsLogger<DbLoggerCategory.Model.Validation> logger)
         => CheckConstraint.AreCompatible(checkConstraint, duplicateCheckConstraint, storeObject, shouldThrow: true);
 
+    /// <summary>
+    ///     Validates the compatibility of triggers in a given shared table.
+    /// </summary>
+    /// <param name="mappedTypes">The mapped entity types.</param>
+    /// <param name="storeObject">The identifier of the store object.</param>
+    /// <param name="logger">The logger to use.</param>
+    protected virtual void ValidateSharedTriggerCompatibility(
+        IReadOnlyList<IEntityType> mappedTypes,
+        in StoreObjectIdentifier storeObject,
+        IDiagnosticsLogger<DbLoggerCategory.Model.Validation> logger)
+    {
+        var triggerMappings = new Dictionary<string, ITrigger>();
+        foreach (var trigger in mappedTypes.SelectMany(et => et.GetDeclaredTriggers()))
+        {
+            var triggerName = trigger.GetName(storeObject);
+            if (triggerName == null)
+            {
+                continue;
+            }
+
+            if (!triggerMappings.TryGetValue(triggerName, out var duplicateTrigger))
+            {
+                triggerMappings[triggerName] = trigger;
+                continue;
+            }
+
+            ValidateCompatible(trigger, duplicateTrigger, triggerName, storeObject, logger);
+        }
+    }
+
+    /// <summary>
+    ///     Validates the compatibility of two trigger with the same name.
+    /// </summary>
+    /// <param name="trigger">A trigger.</param>
+    /// <param name="duplicateTrigger">Another trigger.</param>
+    /// <param name="indexName">The name of the trigger.</param>
+    /// <param name="storeObject">The identifier of the store object.</param>
+    /// <param name="logger">The logger to use.</param>
+    protected virtual void ValidateCompatible(
+        ITrigger trigger,
+        ITrigger duplicateTrigger,
+        string indexName,
+        in StoreObjectIdentifier storeObject,
+        IDiagnosticsLogger<DbLoggerCategory.Model.Validation> logger)
+    {
+    }
+
     /// <summary>
     ///     Validates the mapping/configuration of inheritance in the model.
     /// </summary>
@@ -1478,8 +1528,7 @@ private static void ValidateTPHMapping(IEntityType rootEntityType, bool forTable
     }
 
     /// <summary>
-    ///     Validates that the properties of any one index are
-    ///     all mapped to columns on at least one common table.
+    ///     Validates that the properties of any one index are all mapped to columns on at least one common table.
     /// </summary>
     /// <param name="model">The model to validate.</param>
     /// <param name="logger">The logger to use.</param>
@@ -1581,6 +1630,43 @@ private static void ValidateTPHMapping(IEntityType rootEntityType, bool forTable
         }
     }
 
+    /// <summary>
+    ///     Validates that the triggers are unambiguously mapped to exactly one table.
+    /// </summary>
+    /// <param name="model">The model to validate.</param>
+    /// <param name="logger">The logger to use.</param>
+    protected virtual void ValidateTriggers(
+        IModel model,
+        IDiagnosticsLogger<DbLoggerCategory.Model.Validation> logger)
+    {
+        foreach (var entityType in model.GetEntityTypes())
+        {
+            var tableName = entityType.GetTableName();
+            var tableSchema = entityType.GetSchema();
+
+            foreach (var trigger in entityType.GetDeclaredTriggers())
+            {
+                if (tableName is null)
+                {
+                    throw new InvalidOperationException(
+                        RelationalStrings.TriggerOnUnmappedEntityType(trigger.ModelName, entityType.DisplayName()));
+                }
+
+                if ((trigger.TableName != tableName)
+                    || (trigger.TableSchema is not null && trigger.TableSchema != tableSchema))
+                {
+                    throw new InvalidOperationException(
+                        RelationalStrings.TriggerWithMismatchedTable(
+                            trigger.ModelName,
+                            (trigger.TableName!, trigger.TableSchema).FormatTable(),
+                            entityType.DisplayName(),
+                            entityType.GetSchemaQualifiedTableName())
+                    );
+                }
+            }
+        }
+    }
+
     /// <summary>
     ///     Throws an <see cref="InvalidOperationException" /> with a message containing provider-specific information, when
     ///     available, indicating possible reasons why the property cannot be mapped.
diff --git a/src/EFCore.Relational/Metadata/Builders/IConventionCheckConstraintBuilder.cs b/src/EFCore.Relational/Metadata/Builders/IConventionCheckConstraintBuilder.cs
index be8d2be4c0..a1240ea6dd 100644
--- a/src/EFCore.Relational/Metadata/Builders/IConventionCheckConstraintBuilder.cs
+++ b/src/EFCore.Relational/Metadata/Builders/IConventionCheckConstraintBuilder.cs
@@ -22,10 +22,7 @@ public interface IConventionCheckConstraintBuilder : IConventionAnnotatableBuild
     /// </summary>
     /// <param name="name">The database name of the check constraint.</param>
     /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
-    /// <returns>
-    ///     The same builder instance if the configuration was applied,
-    ///     <see langword="null" /> otherwise.
-    /// </returns>
+    /// <returns>The same builder instance if the configuration was applied, <see langword="null" /> otherwise.</returns>
     IConventionCheckConstraintBuilder? HasName(string? name, bool fromDataAnnotation = false);
 
     /// <summary>
diff --git a/src/EFCore.Relational/Metadata/Builders/IConventionTriggerBuilder.cs b/src/EFCore.Relational/Metadata/Builders/IConventionTriggerBuilder.cs
new file mode 100644
index 0000000000..e53400cc70
--- /dev/null
+++ b/src/EFCore.Relational/Metadata/Builders/IConventionTriggerBuilder.cs
@@ -0,0 +1,34 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.EntityFrameworkCore.Metadata.Builders;
+
+/// <summary>
+///     Provides an API point for provider-specific extensions for configuring a <see cref="IConventionTrigger" />.
+/// </summary>
+/// <remarks>
+///     See <see href="https://aka.ms/efcore-docs-conventions">Model building conventions</see> for more information and examples.
+/// </remarks>
+public interface IConventionTriggerBuilder : IConventionAnnotatableBuilder
+{
+    /// <summary>
+    ///     The trigger being configured.
+    /// </summary>
+    new IConventionTrigger Metadata { get; }
+
+    /// <summary>
+    ///     Sets the database name of the trigger.
+    /// </summary>
+    /// <param name="name">The database name of the trigger.</param>
+    /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
+    /// <returns>The same builder instance if the configuration was applied, <see langword="null" /> otherwise.</returns>
+    IConventionTriggerBuilder? HasName(string? name, bool fromDataAnnotation = false);
+
+    /// <summary>
+    ///     Returns a value indicating whether the given name can be set for the trigger.
+    /// </summary>
+    /// <param name="name">The database name of the trigger.</param>
+    /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
+    /// <returns><see langword="true" /> if the database name can be set for the trigger.</returns>
+    bool CanSetName(string? name, bool fromDataAnnotation = false);
+}
diff --git a/src/EFCore.Relational/Metadata/Builders/TableBuilder.cs b/src/EFCore.Relational/Metadata/Builders/TableBuilder.cs
index 8a74222b55..9dd2053f25 100644
--- a/src/EFCore.Relational/Metadata/Builders/TableBuilder.cs
+++ b/src/EFCore.Relational/Metadata/Builders/TableBuilder.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System.ComponentModel;
+using Microsoft.EntityFrameworkCore.Metadata.Internal;
 
 namespace Microsoft.EntityFrameworkCore.Metadata.Builders;
 
@@ -60,6 +61,22 @@ public virtual TableBuilder ExcludeFromMigrations(bool excluded = true)
         return this;
     }
 
+    /// <summary>
+    ///     Configures a database trigger on the table.
+    /// </summary>
+    /// <param name="name">The name of the trigger.</param>
+    /// <returns>A builder that can be used to configure the database trigger.</returns>
+    /// <remarks>
+    ///     See <see href="https://aka.ms/efcore-docs-triggers">Database triggers</see> for more information and examples.
+    /// </remarks>
+    public virtual TriggerBuilder HasTrigger(string name)
+        => new((Trigger)InternalTriggerBuilder.HasTrigger(
+            (IConventionEntityType)Metadata,
+            name,
+            Name,
+            Schema,
+            ConfigurationSource.Explicit)!);
+
     #region Hidden System.Object members
 
     /// <summary>
diff --git a/src/EFCore.Relational/Metadata/Builders/TriggerBuilder.cs b/src/EFCore.Relational/Metadata/Builders/TriggerBuilder.cs
new file mode 100644
index 0000000000..de61d080c6
--- /dev/null
+++ b/src/EFCore.Relational/Metadata/Builders/TriggerBuilder.cs
@@ -0,0 +1,107 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.ComponentModel;
+using Microsoft.EntityFrameworkCore.Metadata.Internal;
+
+namespace Microsoft.EntityFrameworkCore.Metadata.Builders;
+
+/// <summary>
+///     Provides an API point for provider-specific extensions for configuring a <see cref="ITrigger" />.
+/// </summary>
+/// <remarks>
+///     See <see href="https://aka.ms/efcore-docs-triggers">Database triggers</see> for more information and examples.
+/// </remarks>
+public class TriggerBuilder : IInfrastructure<IConventionTriggerBuilder>
+{
+    /// <summary>
+    ///     Creates a new builder for the given <see cref="ITrigger" />.
+    /// </summary>
+    /// <param name="trigger">The <see cref="IMutableTrigger" /> to configure.</param>
+    public TriggerBuilder(IMutableTrigger trigger)
+        => Builder = ((Trigger)trigger).Builder;
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    [EntityFrameworkInternal]
+    protected virtual InternalTriggerBuilder Builder { [DebuggerStepThrough] get; }
+
+    /// <inheritdoc />
+    IConventionTriggerBuilder IInfrastructure<IConventionTriggerBuilder>.Instance
+    {
+        [DebuggerStepThrough]
+        get => Builder;
+    }
+
+    /// <summary>
+    ///     The trigger being configured.
+    /// </summary>
+    public virtual IMutableTrigger Metadata
+        => Builder.Metadata;
+
+    /// <summary>
+    ///     Sets the database name of the trigger.
+    /// </summary>
+    /// <remarks>
+    ///     See <see href="https://aka.ms/efcore-docs-triggers">Database triggers</see> for more information and examples.
+    /// </remarks>
+    /// <param name="name">The database name of the trigger.</param>
+    /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
+    public virtual TriggerBuilder HasName(string name)
+    {
+        Builder.HasName(name, ConfigurationSource.Explicit);
+
+        return this;
+    }
+
+    /// <summary>
+    ///     Adds or updates an annotation on the trigger. If an annotation with the key specified in <paramref name="annotation" />
+    ///     already exists, its value will be updated.
+    /// </summary>
+    /// <param name="annotation">The key of the annotation to be added or updated.</param>
+    /// <param name="value">The value to be stored in the annotation.</param>
+    /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
+    public virtual TriggerBuilder HasAnnotation(string annotation, object? value)
+    {
+        Check.NotEmpty(annotation, nameof(annotation));
+
+        Builder.HasAnnotation(annotation, value, ConfigurationSource.Explicit);
+
+        return this;
+    }
+
+    #region Hidden System.Object members
+
+    /// <summary>
+    ///     Returns a string that represents the current object.
+    /// </summary>
+    /// <returns>A string that represents the current object.</returns>
+    [EditorBrowsable(EditorBrowsableState.Never)]
+    public override string? ToString()
+        => base.ToString();
+
+    /// <summary>
+    ///     Determines whether the specified object is equal to the current object.
+    /// </summary>
+    /// <param name="obj">The object to compare with the current object.</param>
+    /// <returns><see langword="true" /> if the specified object is equal to the current object; otherwise, <see langword="false" />.</returns>
+    [EditorBrowsable(EditorBrowsableState.Never)]
+    // ReSharper disable once BaseObjectEqualsIsObjectEquals
+    public override bool Equals(object? obj)
+        => base.Equals(obj);
+
+    /// <summary>
+    ///     Serves as the default hash function.
+    /// </summary>
+    /// <returns>A hash code for the current object.</returns>
+    [EditorBrowsable(EditorBrowsableState.Never)]
+    // ReSharper disable once BaseObjectGetHashCodeCallInGetHashCode
+    public override int GetHashCode()
+        => base.GetHashCode();
+
+    #endregion
+}
diff --git a/src/EFCore.Relational/Metadata/Conventions/CheckConstraintConvention.cs b/src/EFCore.Relational/Metadata/Conventions/CheckConstraintConvention.cs
index 37160c2c9c..6c05c901dc 100644
--- a/src/EFCore.Relational/Metadata/Conventions/CheckConstraintConvention.cs
+++ b/src/EFCore.Relational/Metadata/Conventions/CheckConstraintConvention.cs
@@ -6,8 +6,8 @@
 namespace Microsoft.EntityFrameworkCore.Metadata.Conventions;
 
 /// <summary>
-///     A convention that ensures that the check constraints on the derived types are compatible with
-///     the check constraints on the base type. And also ensures that the declaring type is current.
+///     A convention that ensures that the check constraints on the derived types are compatible with the check constraints on the base
+///     type. And also ensures that the declaring type is current.
 /// </summary>
 /// <remarks>
 ///     See <see href="https://aka.ms/efcore-docs-conventions">Model building conventions</see> for more information and examples.
diff --git a/src/EFCore.Relational/Metadata/Conventions/Infrastructure/RelationalConventionSetBuilder.cs b/src/EFCore.Relational/Metadata/Conventions/Infrastructure/RelationalConventionSetBuilder.cs
index 39b9570d35..3937f1281e 100644
--- a/src/EFCore.Relational/Metadata/Conventions/Infrastructure/RelationalConventionSetBuilder.cs
+++ b/src/EFCore.Relational/Metadata/Conventions/Infrastructure/RelationalConventionSetBuilder.cs
@@ -65,18 +65,21 @@ public override ConventionSet CreateConventionSet()
         conventionSet.PropertyAddedConventions.Add(relationalCommentAttributeConvention);
 
         var checkConstraintConvention = new CheckConstraintConvention(Dependencies, RelationalDependencies);
+        var triggerConvention = new TriggerConvention(Dependencies, RelationalDependencies);
         var tableNameFromDbSetConvention = new TableNameFromDbSetConvention(Dependencies, RelationalDependencies);
         conventionSet.EntityTypeAddedConventions.Add(new RelationalTableAttributeConvention(Dependencies, RelationalDependencies));
         conventionSet.EntityTypeAddedConventions.Add(
             new RelationalTableCommentAttributeConvention(Dependencies, RelationalDependencies));
         conventionSet.EntityTypeAddedConventions.Add(tableNameFromDbSetConvention);
         conventionSet.EntityTypeAddedConventions.Add(checkConstraintConvention);
+        conventionSet.EntityTypeAddedConventions.Add(triggerConvention);
 
         ValueGenerationConvention valueGenerationConvention =
             new RelationalValueGenerationConvention(Dependencies, RelationalDependencies);
         ReplaceConvention(conventionSet.EntityTypeBaseTypeChangedConventions, valueGenerationConvention);
         conventionSet.EntityTypeBaseTypeChangedConventions.Add(tableNameFromDbSetConvention);
         conventionSet.EntityTypeBaseTypeChangedConventions.Add(checkConstraintConvention);
+        conventionSet.EntityTypeBaseTypeChangedConventions.Add(triggerConvention);
 
         ReplaceConvention(conventionSet.ForeignKeyPropertiesChangedConventions, valueGenerationConvention);
 
diff --git a/src/EFCore.Relational/Metadata/Conventions/RelationalRuntimeModelConvention.cs b/src/EFCore.Relational/Metadata/Conventions/RelationalRuntimeModelConvention.cs
index 06f382ebf1..4fde4f9348 100644
--- a/src/EFCore.Relational/Metadata/Conventions/RelationalRuntimeModelConvention.cs
+++ b/src/EFCore.Relational/Metadata/Conventions/RelationalRuntimeModelConvention.cs
@@ -137,6 +137,23 @@ public class RelationalRuntimeModelConvention : RuntimeModelConvention
             annotations[RelationalAnnotationNames.ViewSchema] = entityType.GetViewSchema();
             annotations[RelationalAnnotationNames.SqlQuery] = entityType.GetSqlQuery();
             annotations[RelationalAnnotationNames.FunctionName] = entityType.GetFunctionName();
+
+            if (annotations.TryGetValue(RelationalAnnotationNames.Triggers, out var triggers))
+            {
+                var runtimeTriggers = new SortedDictionary<string, ITrigger>(StringComparer.Ordinal);
+                foreach (var (key, trigger) in (SortedDictionary<string, ITrigger>)triggers!)
+                {
+                    var runtimeTrigger = Create(trigger, runtimeEntityType);
+                    runtimeTriggers[key] = runtimeTrigger;
+
+                    CreateAnnotations(
+                        trigger, runtimeTrigger,
+                        static (convention, annotations, source, target, runtime)
+                            => convention.ProcessTriggerAnnotations(annotations, source, target, runtime));
+                }
+
+                annotations[RelationalAnnotationNames.Triggers] = runtimeTriggers;
+            }
         }
     }
 
@@ -367,4 +384,22 @@ private static RuntimeSequence Create(ISequence sequence, RuntimeModel runtimeMo
             annotations.Remove(RelationalAnnotationNames.ForeignKeyMappings);
         }
     }
+
+    private static RuntimeTrigger Create(ITrigger trigger, RuntimeEntityType runtimeEntityType)
+        => new(runtimeEntityType, trigger.ModelName, trigger.Name, trigger.TableName, trigger.TableSchema);
+
+    /// <summary>
+    ///     Updates the function annotations that will be set on the read-only object.
+    /// </summary>
+    /// <param name="annotations">The annotations to be processed.</param>
+    /// <param name="trigger">The source trigger.</param>
+    /// <param name="runtimeTrigger">The target trigger that will contain the annotations.</param>
+    /// <param name="runtime">Indicates whether the given annotations are runtime annotations.</param>
+    protected virtual void ProcessTriggerAnnotations(
+        Dictionary<string, object?> annotations,
+        ITrigger trigger,
+        RuntimeTrigger runtimeTrigger,
+        bool runtime)
+    {
+    }
 }
diff --git a/src/EFCore.Relational/Metadata/Conventions/SharedTableConvention.cs b/src/EFCore.Relational/Metadata/Conventions/SharedTableConvention.cs
index cbcb433d86..653887063b 100644
--- a/src/EFCore.Relational/Metadata/Conventions/SharedTableConvention.cs
+++ b/src/EFCore.Relational/Metadata/Conventions/SharedTableConvention.cs
@@ -51,6 +51,7 @@ public class SharedTableConvention : IModelFinalizingConvention
         var foreignKeys = new Dictionary<string, IConventionForeignKey>();
         var indexes = new Dictionary<string, IConventionIndex>();
         var checkConstraints = new Dictionary<(string, string?), IConventionCheckConstraint>();
+        var triggers = new Dictionary<string, IConventionTrigger>();
         foreach (var ((tableName, schema), conventionEntityTypes) in tables)
         {
             columns.Clear();
@@ -67,6 +68,11 @@ public class SharedTableConvention : IModelFinalizingConvention
                 checkConstraints.Clear();
             }
 
+            if (!TriggersUniqueAcrossTables)
+            {
+                triggers.Clear();
+            }
+
             var storeObject = StoreObjectIdentifier.Table(tableName, schema);
             foreach (var entityType in conventionEntityTypes)
             {
@@ -75,22 +81,29 @@ public class SharedTableConvention : IModelFinalizingConvention
                 TryUniquifyForeignKeyNames(entityType, foreignKeys, storeObject, maxLength);
                 TryUniquifyIndexNames(entityType, indexes, storeObject, maxLength);
                 TryUniquifyCheckConstraintNames(entityType, checkConstraints, storeObject, maxLength);
+                TryUniquifyTriggerNames(entityType, triggers, storeObject, maxLength);
             }
         }
     }
 
     /// <summary>
-    ///     Gets a value indicating whether the index names should be unique across tables.
+    ///     Gets a value indicating whether index names should be unique across tables.
     /// </summary>
     protected virtual bool IndexesUniqueAcrossTables
         => true;
 
     /// <summary>
-    ///     Gets a value indicating whether the index names should be unique across tables.
+    ///     Gets a value indicating whether check constraint names should be unique across tables.
     /// </summary>
     protected virtual bool CheckConstraintsUniqueAcrossTables
         => true;
 
+    /// <summary>
+    ///     Gets a value indicating whether trigger names should be unique across tables.
+    /// </summary>
+    protected virtual bool TriggersUniqueAcrossTables
+        => true;
+
     private static void TryUniquifyTableNames(
         IConventionModel model,
         Dictionary<(string Name, string? Schema), List<IConventionEntityType>> tables,
@@ -545,8 +558,7 @@ protected virtual bool CheckConstraintsUniqueAcrossTables
                 continue;
             }
 
-            var newOtherConstraintName = TryUniquify(
-                otherCheckConstraint, constraintName, storeObject.Schema, checkConstraints, maxLength);
+            var newOtherConstraintName = TryUniquify(otherCheckConstraint, constraintName, storeObject.Schema, checkConstraints, maxLength);
             if (newOtherConstraintName != null)
             {
                 checkConstraints[(constraintName, storeObject.Schema)] = checkConstraint;
@@ -584,4 +596,74 @@ protected virtual bool CheckConstraintsUniqueAcrossTables
 
         return null;
     }
+
+    private void TryUniquifyTriggerNames(
+        IConventionEntityType entityType,
+        Dictionary<string, IConventionTrigger> triggers,
+        in StoreObjectIdentifier storeObject,
+        int maxLength)
+    {
+        foreach (var trigger in entityType.GetDeclaredTriggers())
+        {
+            var triggerName = trigger.GetName(storeObject);
+            if (triggerName == null)
+            {
+                continue;
+            }
+
+            if (!triggers.TryGetValue(triggerName, out var otherTrigger))
+            {
+                triggers[triggerName] = trigger;
+                continue;
+            }
+
+            if (AreCompatible(trigger, otherTrigger, storeObject))
+            {
+                continue;
+            }
+
+            var newTriggerName = TryUniquify(trigger, triggerName, triggers, maxLength);
+            if (newTriggerName != null)
+            {
+                triggers[newTriggerName] = trigger;
+                continue;
+            }
+
+            var newOtherTrigger = TryUniquify(otherTrigger, triggerName, triggers, maxLength);
+            if (newOtherTrigger != null)
+            {
+                triggers[triggerName] = trigger;
+                triggers[newOtherTrigger] = otherTrigger;
+            }
+        }
+    }
+
+    /// <summary>
+    ///     Gets a value indicating whether two triggers with the same name are compatible.
+    /// </summary>
+    /// <param name="trigger">A trigger.</param>
+    /// <param name="duplicateTrigger">Another trigger.</param>
+    /// <param name="storeObject">The identifier of the store object.</param>
+    /// <returns><see langword="true" /> if compatible</returns>
+    protected virtual bool AreCompatible(
+        IReadOnlyTrigger trigger,
+        IReadOnlyTrigger duplicateTrigger,
+        in StoreObjectIdentifier storeObject)
+        => true;
+
+    private static string? TryUniquify<T>(
+        IConventionTrigger trigger,
+        string triggerName,
+        Dictionary<string, T> triggers,
+        int maxLength)
+    {
+        if (trigger.Builder.CanSetName(null))
+        {
+            triggerName = Uniquifier.Uniquify(triggerName, triggers, n => n, maxLength);
+            trigger.Builder.HasName(triggerName);
+            return triggerName;
+        }
+
+        return null;
+    }
 }
diff --git a/src/EFCore.Relational/Metadata/Conventions/TriggerConvention.cs b/src/EFCore.Relational/Metadata/Conventions/TriggerConvention.cs
new file mode 100644
index 0000000000..01cd41333e
--- /dev/null
+++ b/src/EFCore.Relational/Metadata/Conventions/TriggerConvention.cs
@@ -0,0 +1,162 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.EntityFrameworkCore.Metadata.Internal;
+
+namespace Microsoft.EntityFrameworkCore.Metadata.Conventions;
+
+/// <summary>
+///     A convention that ensures that the triggers on the derived types are compatible with the triggers on the base type.
+///     And also ensures that the declaring type is current.
+/// </summary>
+/// <remarks>
+///     See <see href="https://aka.ms/efcore-docs-conventions">Model building conventions</see> for more information and examples.
+/// </remarks>
+public class TriggerConvention : IEntityTypeBaseTypeChangedConvention, IEntityTypeAddedConvention
+{
+    /// <summary>
+    ///     Creates a new instance of <see cref="TriggerConvention" />.
+    /// </summary>
+    /// <param name="dependencies">Parameter object containing dependencies for this convention.</param>
+    /// <param name="relationalDependencies"> Parameter object containing relational dependencies for this convention.</param>
+    public TriggerConvention(
+        ProviderConventionSetBuilderDependencies dependencies,
+        RelationalConventionSetBuilderDependencies relationalDependencies)
+    {
+        Dependencies = dependencies;
+        RelationalDependencies = relationalDependencies;
+    }
+
+    /// <summary>
+    ///     Dependencies for this service.
+    /// </summary>
+    protected virtual ProviderConventionSetBuilderDependencies Dependencies { get; }
+
+    /// <summary>
+    ///     Relational provider-specific dependencies for this service.
+    /// </summary>
+    protected virtual RelationalConventionSetBuilderDependencies RelationalDependencies { get; }
+
+    /// <inheritdoc />
+    public virtual void ProcessEntityTypeAdded(
+        IConventionEntityTypeBuilder entityTypeBuilder,
+        IConventionContext<IConventionEntityTypeBuilder> context)
+    {
+        var entityType = entityTypeBuilder.Metadata;
+        if (!entityType.HasSharedClrType)
+        {
+            return;
+        }
+
+        List<IConventionTrigger>? triggersToReattach = null;
+        foreach (var trigger in entityType.GetTriggers())
+        {
+            if (trigger.EntityType == entityType)
+            {
+                continue;
+            }
+
+            triggersToReattach ??= new List<IConventionTrigger>();
+
+            triggersToReattach.Add(trigger);
+        }
+
+        if (triggersToReattach == null)
+        {
+            return;
+        }
+
+        foreach (var trigger in triggersToReattach)
+        {
+            var removedTrigger = entityType.RemoveTrigger(trigger.ModelName);
+            if (removedTrigger != null)
+            {
+                Trigger.MergeInto(entityType, removedTrigger);
+            }
+        }
+    }
+
+    /// <inheritdoc />
+    public virtual void ProcessEntityTypeBaseTypeChanged(
+        IConventionEntityTypeBuilder entityTypeBuilder,
+        IConventionEntityType? newBaseType,
+        IConventionEntityType? oldBaseType,
+        IConventionContext<IConventionEntityType> context)
+    {
+        var entityType = entityTypeBuilder.Metadata;
+        if (newBaseType != null)
+        {
+            var configurationSource = entityType.GetBaseTypeConfigurationSource();
+            var baseTriggers = newBaseType.GetTriggers().ToDictionary(c => c.ModelName);
+            List<IConventionTrigger>? triggersToBeDetached = null;
+            List<IConventionTrigger>? triggersToBeRemoved = null;
+            foreach (var trigger in entityType.GetDerivedTypesInclusive().SelectMany(et => et.GetDeclaredTriggers()))
+            {
+                if (baseTriggers.TryGetValue(trigger.ModelName, out var baseTrigger)
+                    && baseTrigger.GetConfigurationSource().Overrides(trigger.GetConfigurationSource())
+                    && !AreCompatible(trigger, baseTrigger))
+                {
+                    if (baseTrigger.GetConfigurationSource() == ConfigurationSource.Explicit
+                        && configurationSource == ConfigurationSource.Explicit
+                        && trigger.GetConfigurationSource() == ConfigurationSource.Explicit)
+                    {
+                        throw new InvalidOperationException(
+                            RelationalStrings.DuplicateTrigger(
+                                trigger.ModelName,
+                                trigger.EntityType.DisplayName(),
+                                baseTrigger.EntityType.DisplayName()));
+                    }
+
+                    triggersToBeRemoved ??= new List<IConventionTrigger>();
+
+                    triggersToBeRemoved.Add(trigger);
+                    continue;
+                }
+
+                if (baseTrigger != null)
+                {
+                    triggersToBeDetached ??= new List<IConventionTrigger>();
+
+                    triggersToBeDetached.Add(trigger);
+                }
+            }
+
+            if (triggersToBeRemoved != null)
+            {
+                foreach (var checkConstraintToBeRemoved in triggersToBeRemoved)
+                {
+                    checkConstraintToBeRemoved.EntityType.RemoveTrigger(checkConstraintToBeRemoved.ModelName);
+                }
+            }
+
+            if (triggersToBeDetached != null)
+            {
+                foreach (var triggerToBeDetached in triggersToBeDetached)
+                {
+                    var baseTrigger = baseTriggers[triggerToBeDetached.ModelName];
+                    Trigger.MergeInto(triggerToBeDetached, baseTrigger);
+
+                    triggerToBeDetached.EntityType.RemoveTrigger(triggerToBeDetached.ModelName);
+                }
+            }
+        }
+    }
+
+    private static bool AreCompatible(IConventionTrigger checkConstraint, IConventionTrigger baseTrigger)
+    {
+        var baseTable = StoreObjectIdentifier.Create(baseTrigger.EntityType, StoreObjectType.Table);
+        if (baseTable == null)
+        {
+            return true;
+        }
+
+        if (checkConstraint.GetName(baseTable.Value) != baseTrigger.GetName(baseTable.Value)
+            && checkConstraint.GetNameConfigurationSource() is ConfigurationSource nameConfigurationSource
+            && !nameConfigurationSource.OverridesStrictly(baseTrigger.GetNameConfigurationSource()))
+        {
+            return false;
+        }
+
+        return true;
+    }
+}
diff --git a/src/EFCore.Relational/Metadata/IConventionTrigger.cs b/src/EFCore.Relational/Metadata/IConventionTrigger.cs
new file mode 100644
index 0000000000..b0ced88561
--- /dev/null
+++ b/src/EFCore.Relational/Metadata/IConventionTrigger.cs
@@ -0,0 +1,44 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.EntityFrameworkCore.Metadata;
+
+/// <summary>
+///     Represents a database sequence in the model.
+/// </summary>
+/// <remarks>
+///     See <see href="https://aka.ms/efcore-docs-triggers">Database triggers</see> for more information and examples.
+/// </remarks>
+public interface IConventionTrigger : IReadOnlyTrigger, IConventionAnnotatable
+{
+    /// <summary>
+    ///     Gets the builder that can be used to configure this trigger.
+    /// </summary>
+    /// <exception cref="InvalidOperationException">If the trigger has been removed from the model.</exception>
+    new IConventionTriggerBuilder Builder { get; }
+
+    /// <summary>
+    ///     Gets the <see cref="IConventionEntityType" /> on which this trigger is defined.
+    /// </summary>
+    new IConventionEntityType EntityType { get; }
+
+    /// <summary>
+    ///     Gets the configuration source for this trigger.
+    /// </summary>
+    /// <returns>The configuration source for this trigger.</returns>
+    ConfigurationSource GetConfigurationSource();
+
+    /// <summary>
+    ///     Sets the name of the trigger in the database.
+    /// </summary>
+    /// <param name="name">The name of the trigger in the database.</param>
+    /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
+    /// <returns>The configured value.</returns>
+    string? SetName(string? name, bool fromDataAnnotation = false);
+
+    /// <summary>
+    ///     Gets the configuration source for the database name.
+    /// </summary>
+    /// <returns>The configuration source for the database name.</returns>
+    ConfigurationSource? GetNameConfigurationSource();
+}
diff --git a/src/EFCore.Relational/Metadata/IMutableTrigger.cs b/src/EFCore.Relational/Metadata/IMutableTrigger.cs
new file mode 100644
index 0000000000..037aec2bd8
--- /dev/null
+++ b/src/EFCore.Relational/Metadata/IMutableTrigger.cs
@@ -0,0 +1,28 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.EntityFrameworkCore.Metadata;
+
+/// <summary>
+///     Represents a database trigger on a table.
+/// </summary>
+/// <remarks>
+///     <para>
+///         Since triggers features vary across databases, this is mainly an extension point for providers to add their own annotations.
+///     </para>
+///     <para>
+///         See <see href="https://aka.ms/efcore-docs-triggers">Database triggers</see> for more information and examples.
+///     </para>
+/// </remarks>
+public interface IMutableTrigger : IReadOnlyTrigger, IMutableAnnotatable
+{
+    /// <summary>
+    ///     Gets the <see cref="IMutableEntityType" /> on which this trigger is defined.
+    /// </summary>
+    new IMutableEntityType EntityType { get; }
+
+    /// <summary>
+    ///     Gets or sets the name of the trigger in the database.
+    /// </summary>
+    new string? Name { get; set; }
+}
diff --git a/src/EFCore.Relational/Metadata/IReadOnlyTrigger.cs b/src/EFCore.Relational/Metadata/IReadOnlyTrigger.cs
new file mode 100644
index 0000000000..9b27689154
--- /dev/null
+++ b/src/EFCore.Relational/Metadata/IReadOnlyTrigger.cs
@@ -0,0 +1,70 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.EntityFrameworkCore.Metadata;
+
+/// <summary>
+///     Represents a database trigger on a table.
+/// </summary>
+/// <remarks>
+///     <para>
+///         Since triggers features vary across databases, this is mainly an extension point for providers to add their own annotations.
+///     </para>
+///     <para>
+///         See <see href="https://aka.ms/efcore-docs-triggers">Database triggers</see> for more information and examples.
+///     </para>
+/// </remarks>
+public interface IReadOnlyTrigger : IReadOnlyAnnotatable
+{
+    /// <summary>
+    ///     Gets the name of the trigger in the model.
+    /// </summary>
+    string ModelName { get; }
+
+    /// <summary>
+    ///     Gets the database name of the trigger.
+    /// </summary>
+    string? Name { get; }
+
+    /// <summary>
+    ///     Gets the name of the table on which this trigger is defined.
+    /// </summary>
+    string TableName { get; }
+
+    /// <summary>
+    ///     Gets the schema of the table on which this trigger is defined.
+    /// </summary>
+    string? TableSchema { get; }
+
+    /// <summary>
+    ///     Returns the default database name that would be used for this trigger.
+    /// </summary>
+    /// <returns>The default name that would be used for this trigger.</returns>
+    string? GetDefaultName()
+    {
+        var table = StoreObjectIdentifier.Create(EntityType, StoreObjectType.Table);
+        return !table.HasValue ? null : GetDefaultName(table.Value);
+    }
+
+    /// <summary>
+    ///     Gets the database name of the trigger.
+    /// </summary>
+    /// <param name="storeObject">The identifier of the store object.</param>
+    /// <returns>The database name of the trigger for the given store object.</returns>
+    string? GetName(in StoreObjectIdentifier storeObject);
+
+    /// <summary>
+    ///     Returns the default database name that would be used for this trigger.
+    /// </summary>
+    /// <param name="storeObject">The identifier of the store object.</param>
+    /// <returns>The default name that would be used for this trigger.</returns>
+    string? GetDefaultName(in StoreObjectIdentifier storeObject)
+        => storeObject.StoreObjectType == StoreObjectType.Table
+            ? Uniquifier.Truncate(ModelName, EntityType.Model.GetMaxIdentifierLength())
+            : null;
+
+    /// <summary>
+    ///     Gets the entity type on which this trigger is defined.
+    /// </summary>
+    IReadOnlyEntityType EntityType { get; }
+}
diff --git a/src/EFCore.Relational/Metadata/IRelationalAnnotationProvider.cs b/src/EFCore.Relational/Metadata/IRelationalAnnotationProvider.cs
index 29286682c2..6e8cdb7a00 100644
--- a/src/EFCore.Relational/Metadata/IRelationalAnnotationProvider.cs
+++ b/src/EFCore.Relational/Metadata/IRelationalAnnotationProvider.cs
@@ -131,4 +131,12 @@ public interface IRelationalAnnotationProvider
     /// <returns>The annotations.</returns>
     /// <param name="designTime">Whether the model should contain design-time configuration.</param>
     IEnumerable<IAnnotation> For(ICheckConstraint checkConstraint, bool designTime);
+
+    /// <summary>
+    ///     Gets provider-specific annotations for the given <see cref="ITrigger" />.
+    /// </summary>
+    /// <param name="trigger">The trigger.</param>
+    /// <returns>The annotations.</returns>
+    /// <param name="designTime">Whether the model should contain design-time configuration.</param>
+    IEnumerable<IAnnotation> For(ITrigger trigger, bool designTime);
 }
diff --git a/src/EFCore.Relational/Metadata/ITable.cs b/src/EFCore.Relational/Metadata/ITable.cs
index 21ba462211..cd8a0b342c 100644
--- a/src/EFCore.Relational/Metadata/ITable.cs
+++ b/src/EFCore.Relational/Metadata/ITable.cs
@@ -53,6 +53,11 @@ public interface ITable : ITableBase
     /// </summary>
     IEnumerable<ICheckConstraint> CheckConstraints { get; }
 
+    /// <summary>
+    ///     Gets the triggers for this table.
+    /// </summary>
+    IEnumerable<ITrigger> Triggers { get; }
+
     /// <summary>
     ///     Gets the comment for this table.
     /// </summary>
diff --git a/src/EFCore.Relational/Metadata/ITrigger.cs b/src/EFCore.Relational/Metadata/ITrigger.cs
new file mode 100644
index 0000000000..75434b0c9d
--- /dev/null
+++ b/src/EFCore.Relational/Metadata/ITrigger.cs
@@ -0,0 +1,58 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Text;
+
+namespace Microsoft.EntityFrameworkCore.Metadata;
+
+/// <summary>
+///     Represents a database trigger on a table.
+/// </summary>
+/// <remarks>
+///     <para>
+///         Since triggers features vary across databases, this is mainly an extension point for providers to add their own annotations.
+///     </para>
+///     <para>
+///         See <see href="https://aka.ms/efcore-docs-triggers">Database triggers</see> for more information and examples.
+///     </para>
+/// </remarks>
+public interface ITrigger : IReadOnlyTrigger, IAnnotatable
+{
+    /// <summary>
+    ///     Gets the entity type on which this trigger is defined.
+    /// </summary>
+    new IEntityType EntityType { get; }
+
+    /// <summary>
+    ///     <para>
+    ///         Creates a human-readable representation of the given metadata.
+    ///     </para>
+    ///     <para>
+    ///         Warning: Do not rely on the format of the returned string.
+    ///         It is designed for debugging only and may change arbitrarily between releases.
+    ///     </para>
+    /// </summary>
+    /// <param name="options">Options for generating the string.</param>
+    /// <param name="indent">The number of indent spaces to use before each new line.</param>
+    /// <returns>A human-readable representation.</returns>
+    string ToDebugString(MetadataDebugStringOptions options = MetadataDebugStringOptions.ShortDefault, int indent = 0)
+    {
+        var builder = new StringBuilder();
+        var indentString = new string(' ', indent);
+
+        builder
+            .Append(indentString)
+            .Append("Trigger: ")
+            .Append(ModelName);
+
+        if ((options & MetadataDebugStringOptions.SingleLine) == 0)
+        {
+            if ((options & MetadataDebugStringOptions.IncludeAnnotations) != 0)
+            {
+                builder.Append(AnnotationsToDebugString(indent: indent + 2));
+            }
+        }
+
+        return builder.ToString();
+    }
+}
diff --git a/src/EFCore.Relational/Metadata/Internal/CheckConstraint.cs b/src/EFCore.Relational/Metadata/Internal/CheckConstraint.cs
index 3d04662e53..e21dc834c6 100644
--- a/src/EFCore.Relational/Metadata/Internal/CheckConstraint.cs
+++ b/src/EFCore.Relational/Metadata/Internal/CheckConstraint.cs
@@ -288,7 +288,12 @@ public override bool IsReadOnly
         set => SetName(value, ConfigurationSource.Explicit);
     }
 
-    /// <inheritdoc />
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
     public virtual string? GetName(in StoreObjectIdentifier storeObject)
     {
         if (storeObject.StoreObjectType != StoreObjectType.Table)
diff --git a/src/EFCore.Relational/Metadata/Internal/InternalTriggerBuilder.cs b/src/EFCore.Relational/Metadata/Internal/InternalTriggerBuilder.cs
new file mode 100644
index 0000000000..247cffa8b2
--- /dev/null
+++ b/src/EFCore.Relational/Metadata/Internal/InternalTriggerBuilder.cs
@@ -0,0 +1,184 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.EntityFrameworkCore.Metadata.Internal;
+
+/// <summary>
+///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+///     any release. You should only use it directly in your code with extreme caution and knowing that
+///     doing so can result in application failures when updating to a new Entity Framework Core release.
+/// </summary>
+public class InternalTriggerBuilder : AnnotatableBuilder<Trigger, IConventionModelBuilder>, IConventionTriggerBuilder
+{
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public InternalTriggerBuilder(Trigger trigger, IConventionModelBuilder modelBuilder)
+        : base(trigger, modelBuilder)
+    {
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual IConventionTriggerBuilder? HasName(string? name, ConfigurationSource configurationSource)
+    {
+        if (CanSetName(name, configurationSource))
+        {
+            Metadata.SetName(name, configurationSource);
+            return this;
+        }
+
+        return null;
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual bool CanSetName(string? name, ConfigurationSource configurationSource)
+        => configurationSource.Overrides(Metadata.GetNameConfigurationSource())
+            || Metadata.Name == name;
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public static IConventionTrigger? HasTrigger(
+        IConventionEntityType entityType,
+        string name,
+        string? tableName,
+        string? tableSchema,
+        ConfigurationSource configurationSource)
+    {
+        List<IConventionTrigger>? triggersToBeDetached = null;
+        var trigger = entityType.FindTrigger(name);
+        if (trigger != null)
+        {
+            if (trigger.TableName == tableName && trigger.TableSchema == tableSchema)
+            {
+                ((Trigger)trigger).UpdateConfigurationSource(configurationSource);
+                return trigger;
+            }
+
+            if (!configurationSource.Overrides(trigger.GetConfigurationSource()))
+            {
+                return null;
+            }
+
+            entityType.RemoveTrigger(name);
+            trigger = null;
+        }
+        else
+        {
+            foreach (var derivedType in entityType.GetDerivedTypes())
+            {
+                var derivedTrigger =
+                    (IConventionTrigger?)Trigger.FindDeclaredTrigger(derivedType, name);
+                if (derivedTrigger == null)
+                {
+                    continue;
+                }
+
+                if ((derivedTrigger.TableName != tableName || derivedTrigger.TableSchema != tableSchema)
+                    && !configurationSource.Overrides(derivedTrigger.GetConfigurationSource()))
+                {
+                    return null;
+                }
+
+                triggersToBeDetached ??= new List<IConventionTrigger>();
+
+                triggersToBeDetached.Add(derivedTrigger);
+            }
+        }
+
+        List<IConventionTrigger>? detachedTriggers = null;
+        if (triggersToBeDetached != null)
+        {
+            detachedTriggers = new List<IConventionTrigger>();
+            foreach (var triggerToBeDetached in triggersToBeDetached)
+            {
+                detachedTriggers.Add(
+                    triggerToBeDetached.EntityType.RemoveTrigger(triggerToBeDetached.ModelName)!);
+            }
+        }
+
+        trigger = new Trigger((IMutableEntityType)entityType, name, tableName, tableSchema, configurationSource);
+
+        if (detachedTriggers != null)
+        {
+            foreach (var detachedTrigger in detachedTriggers)
+            {
+                Trigger.MergeInto(detachedTrigger, trigger);
+            }
+        }
+
+        return trigger;
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public static bool CanHaveTrigger(
+        IConventionEntityType entityType,
+        string name,
+        string? tableName,
+        string? tableSchema,
+        ConfigurationSource configurationSource)
+    {
+        if (entityType.FindTrigger(name) is IConventionTrigger trigger)
+        {
+            return (trigger.TableName == tableName
+                    && trigger.TableSchema == tableSchema)
+                || configurationSource.Overrides(trigger.GetConfigurationSource());
+        }
+
+        foreach (var derivedType in entityType.GetDerivedTypes())
+        {
+            var derivedTrigger = (IConventionTrigger?)Trigger.FindDeclaredTrigger(derivedType, name);
+            if (derivedTrigger == null)
+            {
+                continue;
+            }
+
+            if ((derivedTrigger.TableName != tableName
+                || derivedTrigger.TableSchema != tableSchema)
+                && !configurationSource.Overrides(derivedTrigger.GetConfigurationSource()))
+            {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    IConventionTrigger IConventionTriggerBuilder.Metadata
+    {
+        [DebuggerStepThrough]
+        get => Metadata;
+    }
+
+    /// <inheritdoc />
+    [DebuggerStepThrough]
+    IConventionTriggerBuilder? IConventionTriggerBuilder.HasName(string? name, bool fromDataAnnotation)
+        => HasName(name, fromDataAnnotation ? ConfigurationSource.DataAnnotation : ConfigurationSource.Convention);
+
+    /// <inheritdoc />
+    [DebuggerStepThrough]
+    bool IConventionTriggerBuilder.CanSetName(string? name, bool fromDataAnnotation)
+        => CanSetName(name, fromDataAnnotation ? ConfigurationSource.DataAnnotation : ConfigurationSource.Convention);
+}
diff --git a/src/EFCore.Relational/Metadata/Internal/RelationalModel.cs b/src/EFCore.Relational/Metadata/Internal/RelationalModel.cs
index a5210d6171..2a2e6c775e 100644
--- a/src/EFCore.Relational/Metadata/Internal/RelationalModel.cs
+++ b/src/EFCore.Relational/Metadata/Internal/RelationalModel.cs
@@ -151,7 +151,7 @@ public override bool IsReadOnly
         foreach (var table in databaseModel.Tables.Values)
         {
             PopulateRowInternalForeignKeys(table);
-            PopulateConstraints(table, designTime);
+            PopulateTableConfiguration(table, designTime);
 
             if (relationalAnnotationProvider != null)
             {
@@ -179,11 +179,15 @@ public override bool IsReadOnly
                 {
                     foreach (var checkConstraint in table.CheckConstraints.Values)
                     {
-                        checkConstraint.AddAnnotations(
-                            relationalAnnotationProvider.For(checkConstraint, designTime));
+                        checkConstraint.AddAnnotations(relationalAnnotationProvider.For(checkConstraint, designTime));
                     }
                 }
 
+                foreach (var trigger in table.Triggers.Values)
+                {
+                    ((AnnotatableBase)trigger).AddAnnotations(relationalAnnotationProvider.For(trigger, designTime));
+                }
+
                 table.AddAnnotations(relationalAnnotationProvider.For(table, designTime));
             }
         }
@@ -783,7 +787,7 @@ private static StoreFunction GetOrCreateStoreFunction(IRuntimeDbFunction dbFunct
         return storeFunction;
     }
 
-    private static void PopulateConstraints(Table table, bool designTime)
+    private static void PopulateTableConfiguration(Table table, bool designTime)
     {
         var storeObject = StoreObjectIdentifier.Table(table.Name, table.Schema);
         foreach (var entityTypeMapping in ((ITable)table).EntityTypeMappings)
@@ -1017,6 +1021,23 @@ private static void PopulateConstraints(Table table, bool designTime)
                     }
                 }
             }
+
+            foreach (var trigger in entityType.GetTriggers())
+            {
+                var name = trigger.GetName(storeObject);
+                if (name == null)
+                {
+                    continue;
+                }
+
+                Check.DebugAssert(trigger.TableName == table.Name, "Mismatch in trigger table name");
+                Check.DebugAssert(trigger.TableSchema is null || trigger.TableSchema == table.Schema, "Mismatch in trigger table schema");
+
+                if (!table.Triggers.ContainsKey(name))
+                {
+                    table.Triggers.Add(name, trigger);
+                }
+            }
         }
     }
 
diff --git a/src/EFCore.Relational/Metadata/Internal/Table.cs b/src/EFCore.Relational/Metadata/Internal/Table.cs
index 2ed34a918d..7dd967f32a 100644
--- a/src/EFCore.Relational/Metadata/Internal/Table.cs
+++ b/src/EFCore.Relational/Metadata/Internal/Table.cs
@@ -122,6 +122,15 @@ public Table(string name, string? schema, RelationalModel model)
     public virtual SortedDictionary<string, CheckConstraint> CheckConstraints { get; }
         = new();
 
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual SortedDictionary<string, ITrigger> Triggers { get; }
+        = new();
+
     /// <inheritdoc />
     public virtual bool IsExcludedFromMigrations
         => EntityTypeMappings.First().EntityType.IsTableExcludedFromMigrations();
@@ -191,7 +200,14 @@ IEnumerable<ICheckConstraint> ITable.CheckConstraints
             ? throw new InvalidOperationException(CoreStrings.RuntimeModelMissingData)
             : CheckConstraints.Values;
     }
-    
+
+    /// <inheritdoc />
+    IEnumerable<ITrigger> ITable.Triggers
+    {
+        [DebuggerStepThrough]
+        get => Triggers.Values;
+    }
+
     /// <inheritdoc />
     [DebuggerStepThrough]
     IColumn? ITable.FindColumn(string name)
diff --git a/src/EFCore.Relational/Metadata/Internal/Trigger.cs b/src/EFCore.Relational/Metadata/Internal/Trigger.cs
new file mode 100644
index 0000000000..58600cb3db
--- /dev/null
+++ b/src/EFCore.Relational/Metadata/Internal/Trigger.cs
@@ -0,0 +1,466 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.EntityFrameworkCore.Metadata.Internal;
+
+/// <summary>
+///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+///     any release. You should only use it directly in your code with extreme caution and knowing that
+///     doing so can result in application failures when updating to a new Entity Framework Core release.
+/// </summary>
+public class Trigger : ConventionAnnotatable, IMutableTrigger, IConventionTrigger, ITrigger
+{
+    private string? _name;
+    private string? _tableName;
+    private string? _tableSchema;
+    private InternalTriggerBuilder? _builder;
+
+    private ConfigurationSource _configurationSource;
+    private ConfigurationSource? _nameConfigurationSource;
+    private ConfigurationSource? _tableNameConfigurationSource;
+    private ConfigurationSource? _tableSchemaConfigurationSource;
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public Trigger(
+        IMutableEntityType entityType,
+        string name,
+        string? tableName,
+        string? tableSchema,
+        ConfigurationSource configurationSource)
+    {
+        EntityType = entityType;
+        ModelName = name;
+        _tableName = tableName;
+        _tableSchema = tableSchema;
+        _configurationSource = configurationSource;
+
+        var triggers = GetTriggersDictionary(entityType);
+        if (triggers == null)
+        {
+            triggers = new SortedDictionary<string, ITrigger>(StringComparer.Ordinal);
+            entityType.SetOrRemoveAnnotation(RelationalAnnotationNames.Triggers, triggers);
+        }
+
+        if (triggers.ContainsKey(name))
+        {
+            throw new InvalidOperationException(
+                RelationalStrings.DuplicateTrigger(
+                    name, entityType.DisplayName(), entityType.DisplayName()));
+        }
+
+        var baseTrigger = entityType.BaseType?.FindTrigger(name);
+        if (baseTrigger != null)
+        {
+            throw new InvalidOperationException(
+                RelationalStrings.DuplicateTrigger(
+                    name, entityType.DisplayName(), baseTrigger.EntityType.DisplayName()));
+        }
+
+        foreach (var derivedType in entityType.GetDerivedTypes())
+        {
+            var derivedTrigger = FindTrigger(derivedType, name);
+            if (derivedTrigger != null)
+            {
+                throw new InvalidOperationException(
+                    RelationalStrings.DuplicateTrigger(
+                        name, entityType.DisplayName(), derivedTrigger.EntityType.DisplayName()));
+            }
+        }
+
+        if (entityType.GetTableName() is null)
+        {
+            throw new InvalidOperationException(RelationalStrings.TriggerOnUnmappedEntityType(name, entityType.DisplayName()));
+        }
+
+        EnsureMutable();
+
+        triggers.Add(name, this);
+
+        _builder = new InternalTriggerBuilder(this, ((IConventionModel)entityType.Model).Builder);
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public static IEnumerable<IReadOnlyTrigger> GetDeclaredTriggers(IReadOnlyEntityType entityType)
+        => GetTriggersDictionary(entityType)?.Values ?? Enumerable.Empty<ITrigger>();
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public static IEnumerable<IReadOnlyTrigger> GetTriggers(IReadOnlyEntityType entityType)
+        => entityType.BaseType != null
+            ? GetTriggers(entityType.BaseType).Concat(GetDeclaredTriggers(entityType))
+            : GetDeclaredTriggers(entityType);
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public static IReadOnlyTrigger? FindTrigger(
+        IReadOnlyEntityType entityType,
+        string name)
+        => entityType.BaseType?.FindTrigger(name) ?? FindDeclaredTrigger(entityType, name);
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public static IReadOnlyTrigger? FindDeclaredTrigger(IReadOnlyEntityType entityType, string name)
+    {
+        var triggers = (SortedDictionary<string, ITrigger>?)entityType[RelationalAnnotationNames.Triggers];
+
+        return triggers is not null && triggers.TryGetValue(name, out var trigger)
+            ? trigger
+            : null;
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public static Trigger? RemoveTrigger(IMutableEntityType entityType, string name)
+    {
+        var triggers = (SortedDictionary<string, ITrigger>?)entityType[RelationalAnnotationNames.Triggers];
+        if (triggers == null
+            || !triggers.TryGetValue(name, out var trigger))
+        {
+            return null;
+        }
+
+        var mutableTrigger = (Trigger)trigger;
+        triggers.Remove(name);
+        mutableTrigger.SetRemovedFromModel();
+
+        return mutableTrigger;
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public static void MergeInto(IConventionEntityType entityType, IConventionTrigger detachedTrigger)
+    {
+        var newTrigger = new Trigger(
+            (IMutableEntityType)entityType,
+            detachedTrigger.ModelName,
+            detachedTrigger.TableName,
+            detachedTrigger.TableSchema,
+            detachedTrigger.GetConfigurationSource());
+
+        MergeInto(detachedTrigger, newTrigger);
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public static void MergeInto(IConventionTrigger detachedTrigger, IConventionTrigger existingTrigger)
+    {
+        var nameConfigurationSource = detachedTrigger.GetNameConfigurationSource();
+        if (nameConfigurationSource != null)
+        {
+            ((InternalTriggerBuilder)existingTrigger.Builder).HasName(
+                detachedTrigger.Name, nameConfigurationSource.Value);
+        }
+
+        ((InternalTriggerBuilder)existingTrigger.Builder).MergeAnnotationsFrom(
+            (Trigger)detachedTrigger);
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual InternalTriggerBuilder Builder
+    {
+        [DebuggerStepThrough]
+        get => _builder ?? throw new InvalidOperationException(CoreStrings.ObjectRemovedFromModel);
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual bool IsInModel
+        => _builder is not null;
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual void SetRemovedFromModel()
+        => _builder = null;
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual IReadOnlyEntityType EntityType { get; }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual string ModelName { get; }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual string? Name
+    {
+        get => EntityType.GetTableName() == null
+            ? null
+            : _name ?? ((IReadOnlyTrigger)this).GetDefaultName();
+        set => SetName(value, ConfigurationSource.Explicit);
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual string? GetName(in StoreObjectIdentifier storeObject)
+    {
+        if (storeObject.StoreObjectType != StoreObjectType.Table)
+        {
+            return null;
+        }
+
+        foreach (var containingType in EntityType.GetDerivedTypesInclusive())
+        {
+            if (StoreObjectIdentifier.Create(containingType, storeObject.StoreObjectType) == storeObject)
+            {
+                return _name ?? ((IReadOnlyTrigger)this).GetDefaultName(storeObject);
+            }
+        }
+
+        return null;
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual string? SetName(string? name, ConfigurationSource configurationSource)
+    {
+        EnsureMutable();
+
+        _name = name;
+
+        _nameConfigurationSource = configurationSource.Max(_nameConfigurationSource);
+
+        return name;
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual ConfigurationSource? GetNameConfigurationSource()
+        => _nameConfigurationSource;
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual string TableName
+    {
+        get => _tableName ?? EntityType.GetTableName()!;
+        set => SetTableName(value, ConfigurationSource.Explicit);
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual string? SetTableName(string? tableName, ConfigurationSource configurationSource)
+    {
+        EnsureMutable();
+
+        _tableName = tableName;
+
+        _tableNameConfigurationSource = configurationSource.Max(_tableNameConfigurationSource);
+
+        return tableName;
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual ConfigurationSource? GetTableNameConfigurationSource()
+        => _tableNameConfigurationSource;
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual string? TableSchema
+    {
+        get => _tableSchema;
+        set => SetTableSchema(value, ConfigurationSource.Explicit);
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual string? SetTableSchema(string? tableSchema, ConfigurationSource configurationSource)
+    {
+        EnsureMutable();
+
+        _tableSchema = tableSchema;
+
+        _tableSchemaConfigurationSource = configurationSource.Max(_tableSchemaConfigurationSource);
+
+        return tableSchema;
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual ConfigurationSource? GetTableSchemaConfigurationSource()
+        => _tableSchemaConfigurationSource;
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual ConfigurationSource GetConfigurationSource()
+        => _configurationSource;
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual void UpdateConfigurationSource(ConfigurationSource configurationSource)
+        => _configurationSource = _configurationSource.Max(configurationSource);
+
+    private static SortedDictionary<string, ITrigger>? GetTriggersDictionary(IReadOnlyEntityType entityType)
+        => (SortedDictionary<string, ITrigger>?)entityType[RelationalAnnotationNames.Triggers];
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public override string ToString()
+        => ((ITrigger)this).ToDebugString(MetadataDebugStringOptions.SingleLineDefault);
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    IConventionEntityType IConventionTrigger.EntityType
+    {
+        [DebuggerStepThrough]
+        get => (IConventionEntityType)EntityType;
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    IMutableEntityType IMutableTrigger.EntityType
+    {
+        [DebuggerStepThrough]
+        get => (IMutableEntityType)EntityType;
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    IEntityType ITrigger.EntityType
+    {
+        [DebuggerStepThrough]
+        get => (IEntityType)EntityType;
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    IConventionTriggerBuilder IConventionTrigger.Builder
+    {
+        [DebuggerStepThrough]
+        get => Builder;
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    [DebuggerStepThrough]
+    string? IConventionTrigger.SetName(string? name, bool fromDataAnnotation)
+        => SetName(name, fromDataAnnotation ? ConfigurationSource.DataAnnotation : ConfigurationSource.Convention);
+}
diff --git a/src/EFCore.Relational/Metadata/RelationalAnnotationNames.cs b/src/EFCore.Relational/Metadata/RelationalAnnotationNames.cs
index 2e40c17262..4885a3d648 100644
--- a/src/EFCore.Relational/Metadata/RelationalAnnotationNames.cs
+++ b/src/EFCore.Relational/Metadata/RelationalAnnotationNames.cs
@@ -129,6 +129,11 @@ public static class RelationalAnnotationNames
     /// </summary>
     public const string DbFunctions = Prefix + "DbFunctions";
 
+    /// <summary>
+    ///     The name for trigger annotation.
+    /// </summary>
+    public const string Triggers = Prefix + "Triggers";
+
     /// <summary>
     ///     The name for the annotation containing the maximum length for database identifiers.
     /// </summary>
diff --git a/src/EFCore.Relational/Metadata/RelationalAnnotationProvider.cs b/src/EFCore.Relational/Metadata/RelationalAnnotationProvider.cs
index e7276ac2f2..09c879111a 100644
--- a/src/EFCore.Relational/Metadata/RelationalAnnotationProvider.cs
+++ b/src/EFCore.Relational/Metadata/RelationalAnnotationProvider.cs
@@ -89,4 +89,8 @@ public virtual IEnumerable<IAnnotation> For(ISequence sequence, bool designTime)
     /// <inheritdoc />
     public virtual IEnumerable<IAnnotation> For(ICheckConstraint checkConstraint, bool designTime)
         => Enumerable.Empty<IAnnotation>();
+
+    /// <inheritdoc />
+    public virtual IEnumerable<IAnnotation> For(ITrigger trigger, bool designTime)
+        => Enumerable.Empty<IAnnotation>();
 }
diff --git a/src/EFCore.Relational/Metadata/RuntimeTrigger.cs b/src/EFCore.Relational/Metadata/RuntimeTrigger.cs
new file mode 100644
index 0000000000..ed95ba9e6e
--- /dev/null
+++ b/src/EFCore.Relational/Metadata/RuntimeTrigger.cs
@@ -0,0 +1,58 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.EntityFrameworkCore.Metadata;
+
+/// <summary>
+///     Represents a database trigger on a table.
+/// </summary>
+/// <remarks>
+///     See <see href="https://aka.ms/efcore-docs-triggers">Database triggers</see> for more information and examples.
+/// </remarks>
+public class RuntimeTrigger : AnnotatableBase, ITrigger
+{
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public RuntimeTrigger(
+        RuntimeEntityType entityType,
+        string modelName,
+        string? name,
+        string tableName,
+        string? tableSchema)
+    {
+        EntityType = entityType;
+        ModelName = modelName;
+        Name = name;
+        TableName = tableName;
+        TableSchema = tableSchema;
+    }
+
+    /// <inheritdoc />
+    public virtual string ModelName { get; }
+
+    /// <summary>
+    ///     Gets the database name of the trigger.
+    /// </summary>
+    public virtual string? Name { get; }
+
+    /// <inheritdoc />
+    public virtual string? GetName(in StoreObjectIdentifier storeObject)
+        => Name;
+
+    /// <inheritdoc />
+    public virtual string TableName { get; }
+
+    /// <inheritdoc />
+    public virtual string? TableSchema { get; }
+
+    /// <inheritdoc />
+    public virtual IEntityType EntityType { get; }
+
+    /// <inheritdoc />
+    IReadOnlyEntityType IReadOnlyTrigger.EntityType
+        => EntityType;
+}
diff --git a/src/EFCore.Relational/Properties/RelationalStrings.Designer.cs b/src/EFCore.Relational/Properties/RelationalStrings.Designer.cs
index 27aad4c18e..b3727c7438 100644
--- a/src/EFCore.Relational/Properties/RelationalStrings.Designer.cs
+++ b/src/EFCore.Relational/Properties/RelationalStrings.Designer.cs
@@ -549,6 +549,14 @@ public static string DuplicateKeyTableMismatch(object? keyProperties1, object? e
                 GetString("DuplicateKeyTableMismatch", nameof(keyProperties1), nameof(entityType1), nameof(keyProperties2), nameof(entityType2), nameof(keyName), nameof(table1), nameof(table2)),
                 keyProperties1, entityType1, keyProperties2, entityType2, keyName, table1, table2);
 
+        /// <summary>
+        ///     The trigger '{trigger}' cannot be added to the entity type '{entityType}' because another trigger with the same name already exists on entity type '{conflictingEntityType}'.
+        /// </summary>
+        public static string DuplicateTrigger(object? trigger, object? entityType, object? conflictingEntityType)
+            => string.Format(
+                GetString("DuplicateTrigger", nameof(trigger), nameof(entityType), nameof(conflictingEntityType)),
+                trigger, entityType, conflictingEntityType);
+
         /// <summary>
         ///     Either {param1} or {param2} must be null.
         /// </summary>
@@ -1175,6 +1183,22 @@ public static string TransactionAssociatedWithDifferentConnection
         public static string TransactionSuppressedMigrationInUserTransaction
             => GetString("TransactionSuppressedMigrationInUserTransaction");
 
+        /// <summary>
+        ///     Trigger '{trigger}' cannot be defined on entity type '{entityType}' since that entity type isn't mapped to a database table. See https://aka.ms/efcore-docs-triggers for more information on triggers.
+        /// </summary>
+        public static string TriggerOnUnmappedEntityType(object? trigger, object? entityType)
+            => string.Format(
+                GetString("TriggerOnUnmappedEntityType", nameof(trigger), nameof(entityType)),
+                trigger, entityType);
+
+        /// <summary>
+        ///     Trigger '{trigger}' with table '{triggerTable}' is defined on entity type '{entityType}', which is mapped to table '{entityTable}'. See https://aka.ms/efcore-docs-triggers for more information on triggers.
+        /// </summary>
+        public static string TriggerWithMismatchedTable(object? trigger, object? triggerTable, object? entityType, object? entityTable)
+            => string.Format(
+                GetString("TriggerWithMismatchedTable", nameof(trigger), nameof(triggerTable), nameof(entityType), nameof(entityTable)),
+                trigger, triggerTable, entityType, entityTable);
+
         /// <summary>
         ///     Unable to bind '{memberType}.{member}' to an entity projection of '{entityType}'.
         /// </summary>
diff --git a/src/EFCore.Relational/Properties/RelationalStrings.resx b/src/EFCore.Relational/Properties/RelationalStrings.resx
index 6a36f8c008..6e09693e95 100644
--- a/src/EFCore.Relational/Properties/RelationalStrings.resx
+++ b/src/EFCore.Relational/Properties/RelationalStrings.resx
@@ -319,6 +319,9 @@
   <data name="DuplicateKeyTableMismatch" xml:space="preserve">
     <value>The keys {keyProperties1} on '{entityType1}' and {keyProperties2} on '{entityType2}' are both mapped to '{keyName}', but on different tables ('{table1}' and '{table2}').</value>
   </data>
+  <data name="DuplicateTrigger" xml:space="preserve">
+    <value>The trigger '{trigger}' cannot be added to the entity type '{entityType}' because another trigger with the same name already exists on entity type '{conflictingEntityType}'.</value>
+  </data>
   <data name="EitherOfTwoValuesMustBeNull" xml:space="preserve">
     <value>Either {param1} or {param2} must be null.</value>
   </data>
@@ -815,6 +818,12 @@
   <data name="TransactionSuppressedMigrationInUserTransaction" xml:space="preserve">
     <value>User transaction is not supported with a TransactionSuppressed migrations.</value>
   </data>
+  <data name="TriggerOnUnmappedEntityType" xml:space="preserve">
+    <value>Trigger '{trigger}' cannot be defined on entity type '{entityType}' since that entity type isn't mapped to a database table. See https://aka.ms/efcore-docs-triggers for more information on triggers.</value>
+  </data>
+  <data name="TriggerWithMismatchedTable" xml:space="preserve">
+    <value>Trigger '{trigger}' for table '{triggerTable}' is defined on entity type '{entityType}', which is mapped to table '{entityTable}'. See https://aka.ms/efcore-docs-triggers for more information on triggers.</value>
+  </data>
   <data name="UnableToBindMemberToEntityProjection" xml:space="preserve">
     <value>Unable to bind '{memberType}.{member}' to an entity projection of '{entityType}'.</value>
   </data>
diff --git a/src/EFCore.Relational/Update/AffectedCountModificationCommandBatch.cs b/src/EFCore.Relational/Update/AffectedCountModificationCommandBatch.cs
index 14fb6e3bdc..88b0101dfb 100644
--- a/src/EFCore.Relational/Update/AffectedCountModificationCommandBatch.cs
+++ b/src/EFCore.Relational/Update/AffectedCountModificationCommandBatch.cs
@@ -158,45 +158,50 @@ protected override void Consume(RelationalDataReader reader)
     ///     Consumes the data reader created by <see cref="ReaderModificationCommandBatch.Execute" />,
     ///     propagating values back into the <see cref="ModificationCommand" />.
     /// </summary>
-    /// <param name="commandIndex">The ordinal of the command being consumed.</param>
+    /// <param name="startResultSetIndex">The ordinal of the first result set being consumed.</param>
     /// <param name="reader">The data reader.</param>
-    /// <returns>The ordinal of the next command that must be consumed.</returns>
-    protected virtual int ConsumeResultSetWithPropagation(int commandIndex, RelationalDataReader reader)
+    /// <returns>The ordinal of the next result set that must be consumed.</returns>
+    protected virtual int ConsumeResultSetWithPropagation(int startResultSetIndex, RelationalDataReader reader)
     {
+        var resultSetIndex = startResultSetIndex;
         var rowsAffected = 0;
         do
         {
-            var tableModification = ModificationCommands[commandIndex];
-            Check.DebugAssert(tableModification.RequiresResultPropagation, "RequiresResultPropagation is false");
-
             if (!reader.Read())
             {
                 var expectedRowsAffected = rowsAffected + 1;
-                while (++commandIndex < CommandResultSet.Count
-                       && CommandResultSet[commandIndex - 1] == ResultSetMapping.NotLastInResultSet)
+                while (++resultSetIndex < CommandResultSet.Count
+                       && CommandResultSet[resultSetIndex - 1] == ResultSetMapping.NotLastInResultSet)
                 {
                     expectedRowsAffected++;
                 }
 
-                ThrowAggregateUpdateConcurrencyException(commandIndex, expectedRowsAffected, rowsAffected);
+                ThrowAggregateUpdateConcurrencyException(resultSetIndex, expectedRowsAffected, rowsAffected);
             }
 
+            var tableModification = ModificationCommands[
+                ResultsPositionalMappingEnabled?.Length > resultSetIndex && ResultsPositionalMappingEnabled[resultSetIndex]
+                    ? startResultSetIndex + reader.DbDataReader.GetInt32(reader.DbDataReader.FieldCount - 1)
+                    : resultSetIndex];
+
+            Check.DebugAssert(tableModification.RequiresResultPropagation, "RequiresResultPropagation is false");
+
             var valueBufferFactory = CreateValueBufferFactory(tableModification.ColumnModifications);
 
             tableModification.PropagateResults(valueBufferFactory.Create(reader.DbDataReader));
             rowsAffected++;
         }
-        while (++commandIndex < CommandResultSet.Count
-               && CommandResultSet[commandIndex - 1] == ResultSetMapping.NotLastInResultSet);
+        while (++resultSetIndex < CommandResultSet.Count
+               && CommandResultSet[resultSetIndex - 1] == ResultSetMapping.NotLastInResultSet);
 
-        return commandIndex;
+        return resultSetIndex;
     }
 
     /// <summary>
     ///     Consumes the data reader created by <see cref="ReaderModificationCommandBatch.ExecuteAsync" />,
     ///     propagating values back into the <see cref="ModificationCommand" />.
     /// </summary>
-    /// <param name="commandIndex">The ordinal of the command being consumed.</param>
+    /// <param name="startResultSetIndex">The ordinal of the first result set being consumed.</param>
     /// <param name="reader">The data reader.</param>
     /// <param name="cancellationToken">A <see cref="CancellationToken" /> to observe while waiting for the task to complete.</param>
     /// <returns>
@@ -205,37 +210,42 @@ protected virtual int ConsumeResultSetWithPropagation(int commandIndex, Relation
     /// </returns>
     /// <exception cref="OperationCanceledException">If the <see cref="CancellationToken" /> is canceled.</exception>
     protected virtual async Task<int> ConsumeResultSetWithPropagationAsync(
-        int commandIndex,
+        int startResultSetIndex,
         RelationalDataReader reader,
         CancellationToken cancellationToken)
     {
+        var resultSetIndex = startResultSetIndex;
         var rowsAffected = 0;
         do
         {
-            var tableModification = ModificationCommands[commandIndex];
-            Check.DebugAssert(tableModification.RequiresResultPropagation, "RequiresResultPropagation is false");
-
             if (!await reader.ReadAsync(cancellationToken).ConfigureAwait(false))
             {
                 var expectedRowsAffected = rowsAffected + 1;
-                while (++commandIndex < CommandResultSet.Count
-                       && CommandResultSet[commandIndex - 1] == ResultSetMapping.NotLastInResultSet)
+                while (++resultSetIndex < CommandResultSet.Count
+                       && CommandResultSet[resultSetIndex - 1] == ResultSetMapping.NotLastInResultSet)
                 {
                     expectedRowsAffected++;
                 }
 
-                ThrowAggregateUpdateConcurrencyException(commandIndex, expectedRowsAffected, rowsAffected);
+                ThrowAggregateUpdateConcurrencyException(resultSetIndex, expectedRowsAffected, rowsAffected);
             }
 
+            var tableModification = ModificationCommands[
+                ResultsPositionalMappingEnabled?.Length > resultSetIndex && ResultsPositionalMappingEnabled[resultSetIndex]
+                    ? startResultSetIndex + reader.DbDataReader.GetInt32(reader.DbDataReader.FieldCount - 1)
+                    : resultSetIndex];
+
+            Check.DebugAssert(tableModification.RequiresResultPropagation, "RequiresResultPropagation is false");
+
             var valueBufferFactory = CreateValueBufferFactory(tableModification.ColumnModifications);
 
             tableModification.PropagateResults(valueBufferFactory.Create(reader.DbDataReader));
             rowsAffected++;
         }
-        while (++commandIndex < CommandResultSet.Count
-               && CommandResultSet[commandIndex - 1] == ResultSetMapping.NotLastInResultSet);
+        while (++resultSetIndex < CommandResultSet.Count
+               && CommandResultSet[resultSetIndex - 1] == ResultSetMapping.NotLastInResultSet);
 
-        return commandIndex;
+        return resultSetIndex;
     }
 
     /// <summary>
diff --git a/src/EFCore.Relational/Update/Internal/CommandBatchPreparer.cs b/src/EFCore.Relational/Update/Internal/CommandBatchPreparer.cs
index 9bd866d77d..7c5457b00f 100644
--- a/src/EFCore.Relational/Update/Internal/CommandBatchPreparer.cs
+++ b/src/EFCore.Relational/Update/Internal/CommandBatchPreparer.cs
@@ -27,7 +27,7 @@ public CommandBatchPreparer(CommandBatchPreparerDependencies dependencies)
     {
         _minBatchSize =
             dependencies.Options.Extensions.OfType<RelationalOptionsExtension>().FirstOrDefault()?.MinBatchSize
-            ?? 4;
+            ?? 1;
         Dependencies = dependencies;
 
         if (dependencies.LoggingOptions.IsSensitiveDataLoggingEnabled)
diff --git a/src/EFCore.Relational/Update/ReaderModificationCommandBatch.cs b/src/EFCore.Relational/Update/ReaderModificationCommandBatch.cs
index 1a35f6aa66..7ada76329f 100644
--- a/src/EFCore.Relational/Update/ReaderModificationCommandBatch.cs
+++ b/src/EFCore.Relational/Update/ReaderModificationCommandBatch.cs
@@ -1,6 +1,7 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using System.Collections;
 using System.Text;
 
 namespace Microsoft.EntityFrameworkCore.Update;
@@ -66,6 +67,13 @@ public override IReadOnlyList<IReadOnlyModificationCommand> ModificationCommands
     /// </summary>
     protected virtual IList<ResultSetMapping> CommandResultSet { get; } = new List<ResultSetMapping>();
 
+    /// <summary>
+    ///     When rows with database-generated values are returned in non-deterministic ordering, it is necessary to project out a synthetic
+    ///     position value, in order to look up the correct <see cref="ModificationCommand" /> and propagate the values. When this array
+    ///     isn't <see langword="null" />, it determines whether the current result row contains such a position value.
+    /// </summary>
+    protected virtual BitArray? ResultsPositionalMappingEnabled { get; set; }
+
     /// <summary>
     ///     Adds the given insert/update/delete <see cref="ModificationCommands" /> to the batch.
     /// </summary>
diff --git a/src/EFCore.Relational/Update/UpdateSqlGenerator.cs b/src/EFCore.Relational/Update/UpdateSqlGenerator.cs
index f176858895..5ba908b303 100644
--- a/src/EFCore.Relational/Update/UpdateSqlGenerator.cs
+++ b/src/EFCore.Relational/Update/UpdateSqlGenerator.cs
@@ -68,20 +68,11 @@ protected virtual ISqlGenerationHelper SqlGenerationHelper
         var writeOperations = operations.Where(o => o.IsWrite).ToList();
         var readOperations = operations.Where(o => o.IsRead).ToList();
 
-        AppendInsertCommand(commandStringBuilder, name, schema, writeOperations);
-
-        if (readOperations.Count > 0)
-        {
-            var keyOperations = operations.Where(o => o.IsKey).ToList();
-
-            requiresTransaction = true;
-
-            return AppendSelectAffectedCommand(commandStringBuilder, name, schema, readOperations, keyOperations, commandPosition);
-        }
+        AppendInsertCommand(commandStringBuilder, name, schema, writeOperations, readOperations);
 
         requiresTransaction = false;
 
-        return ResultSetMapping.NoResultSet;
+        return readOperations.Count > 0 ? ResultSetMapping.LastInResultSet : ResultSetMapping.NoResultSet;
     }
 
     /// <summary>
@@ -153,16 +144,19 @@ protected virtual ISqlGenerationHelper SqlGenerationHelper
     /// <param name="commandStringBuilder">The builder to which the SQL should be appended.</param>
     /// <param name="name">The name of the table.</param>
     /// <param name="schema">The table schema, or <see langword="null" /> to use the default schema.</param>
-    /// <param name="writeOperations">The operations for each column.</param>
+    /// <param name="writeOperations">The operations with the values to insert for each column.</param>
+    /// <param name="readOperations">The operations for column values to be read back.</param>
     protected virtual void AppendInsertCommand(
         StringBuilder commandStringBuilder,
         string name,
         string? schema,
-        IReadOnlyList<IColumnModification> writeOperations)
+        IReadOnlyList<IColumnModification> writeOperations,
+        IReadOnlyList<IColumnModification> readOperations)
     {
         AppendInsertCommandHeader(commandStringBuilder, name, schema, writeOperations);
         AppendValuesHeader(commandStringBuilder, writeOperations);
         AppendValues(commandStringBuilder, name, schema, writeOperations);
+        AppendReturningClause(commandStringBuilder, readOperations);
         commandStringBuilder.AppendLine(SqlGenerationHelper.StatementTerminator);
     }
 
@@ -412,6 +406,27 @@ protected virtual ISqlGenerationHelper SqlGenerationHelper
         }
     }
 
+    /// <summary>
+    ///     Appends a clause used to return generated values from an INSERT or UPDATE statement.
+    /// </summary>
+    /// <param name="commandStringBuilder">The builder to which the SQL should be appended.</param>
+    /// <param name="operations">The operations for column values to be read back.</param>
+    protected virtual void AppendReturningClause(
+        StringBuilder commandStringBuilder,
+        IReadOnlyList<IColumnModification> operations)
+    {
+        if (operations.Count > 0)
+        {
+            commandStringBuilder
+                .AppendLine()
+                .Append("RETURNING ")
+                .AppendJoin(
+                    operations,
+                    SqlGenerationHelper,
+                    (sb, o, helper) => helper.DelimitIdentifier(sb, o.ColumnName));
+        }
+    }
+
     /// <summary>
     ///     Appends a <c>WHERE</c> clause.
     /// </summary>
diff --git a/src/EFCore.SqlServer/Properties/SqlServerStrings.Designer.cs b/src/EFCore.SqlServer/Properties/SqlServerStrings.Designer.cs
index cd412d4d00..9efc6efc08 100644
--- a/src/EFCore.SqlServer/Properties/SqlServerStrings.Designer.cs
+++ b/src/EFCore.SqlServer/Properties/SqlServerStrings.Designer.cs
@@ -211,6 +211,18 @@ public static string NonKeyValueGeneration(object? property, object? entityType)
         public static string NoSavepointRelease
             => GetString("NoSavepointRelease");
 
+        /// <summary>
+        ///     Could not save changes because the target table has computed column with a function that performs data access. Please configure your entity type accordingly, see https://aka.ms/efcore-docs-sqlserver-save-changes-and-computed-columns for more information.
+        /// </summary>
+        public static string SaveChangesFailedBecauseOfComputedColumnWithFunction
+            => GetString("SaveChangesFailedBecauseOfComputedColumnWithFunction");
+
+        /// <summary>
+        ///     Could not save changes because the target table has database triggers. Please configure your entity type accordingly, see https://aka.ms/efcore-docs-sqlserver-save-changes-and-triggers for more information.
+        /// </summary>
+        public static string SaveChangesFailedBecauseOfTriggers
+            => GetString("SaveChangesFailedBecauseOfTriggers");
+
         /// <summary>
         ///     SQL Server sequences cannot be used to generate values for the property '{property}' on entity type '{entityType}' because the property type is '{propertyType}'. Sequences can only be used with integer properties.
         /// </summary>
diff --git a/src/EFCore.SqlServer/Properties/SqlServerStrings.resx b/src/EFCore.SqlServer/Properties/SqlServerStrings.resx
index 6c2891b274..79abd10b74 100644
--- a/src/EFCore.SqlServer/Properties/SqlServerStrings.resx
+++ b/src/EFCore.SqlServer/Properties/SqlServerStrings.resx
@@ -284,6 +284,12 @@
   <data name="NoSavepointRelease" xml:space="preserve">
     <value>SQL Server does not support releasing a savepoint.</value>
   </data>
+  <data name="SaveChangesFailedBecauseOfComputedColumnWithFunction" xml:space="preserve">
+    <value>Could not save changes because the target table has computed column with a function that performs data access. Please configure your entity type accordingly, see https://aka.ms/efcore-docs-sqlserver-save-changes-and-computed-columns for more information.</value>
+  </data>
+  <data name="SaveChangesFailedBecauseOfTriggers" xml:space="preserve">
+    <value>Could not save changes because the target table has database triggers. Please configure your entity type accordingly, see https://aka.ms/efcore-docs-sqlserver-save-changes-and-triggers for more information.</value>
+  </data>
   <data name="SequenceBadType" xml:space="preserve">
     <value>SQL Server sequences cannot be used to generate values for the property '{property}' on entity type '{entityType}' because the property type is '{propertyType}'. Sequences can only be used with integer properties.</value>
   </data>
diff --git a/src/EFCore.SqlServer/Update/Internal/ISqlServerUpdateSqlGenerator.cs b/src/EFCore.SqlServer/Update/Internal/ISqlServerUpdateSqlGenerator.cs
index c7f92fb002..583aebebdf 100644
--- a/src/EFCore.SqlServer/Update/Internal/ISqlServerUpdateSqlGenerator.cs
+++ b/src/EFCore.SqlServer/Update/Internal/ISqlServerUpdateSqlGenerator.cs
@@ -28,6 +28,7 @@ public interface ISqlServerUpdateSqlGenerator : IUpdateSqlGenerator
         StringBuilder commandStringBuilder,
         IReadOnlyList<IReadOnlyModificationCommand> modificationCommands,
         int commandPosition,
+        out bool resultsContainPositionMapping,
         out bool requiresTransaction);
 
     /// <summary>
@@ -40,5 +41,5 @@ public interface ISqlServerUpdateSqlGenerator : IUpdateSqlGenerator
         StringBuilder commandStringBuilder,
         IReadOnlyList<IReadOnlyModificationCommand> modificationCommands,
         int commandPosition)
-        => AppendBulkInsertOperation(commandStringBuilder, modificationCommands, commandPosition, out _);
+        => AppendBulkInsertOperation(commandStringBuilder, modificationCommands, commandPosition, out _, out _);
 }
diff --git a/src/EFCore.SqlServer/Update/Internal/SqlServerModificationCommandBatch.cs b/src/EFCore.SqlServer/Update/Internal/SqlServerModificationCommandBatch.cs
index 18e4ee6d50..2d2429f88c 100644
--- a/src/EFCore.SqlServer/Update/Internal/SqlServerModificationCommandBatch.cs
+++ b/src/EFCore.SqlServer/Update/Internal/SqlServerModificationCommandBatch.cs
@@ -1,7 +1,10 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using System.Collections;
 using System.Text;
+using Microsoft.Data.SqlClient;
+using Microsoft.EntityFrameworkCore.SqlServer.Internal;
 
 namespace Microsoft.EntityFrameworkCore.SqlServer.Update.Internal;
 
@@ -153,10 +156,28 @@ private void AppendBulkInsertCommandText(int lastIndex)
         var wasCachedCommandTextEmpty = IsCachedCommandTextEmpty;
 
         var resultSetMapping = UpdateSqlGenerator.AppendBulkInsertOperation(
-            CachedCommandText, _bulkInsertCommands, lastIndex - _bulkInsertCommands.Count, out var requiresTransaction);
+            CachedCommandText, _bulkInsertCommands, lastIndex - _bulkInsertCommands.Count, out var resultsContainPositionMapping,
+            out var requiresTransaction);
 
         SetRequiresTransaction(!wasCachedCommandTextEmpty || requiresTransaction);
 
+        if (resultsContainPositionMapping)
+        {
+            if (ResultsPositionalMappingEnabled is null)
+            {
+                ResultsPositionalMappingEnabled = new BitArray(CommandResultSet.Count);
+            }
+            else
+            {
+                ResultsPositionalMappingEnabled.Length = CommandResultSet.Count;
+            }
+
+            for (var i = lastIndex - _bulkInsertCommands.Count; i < lastIndex; i++)
+            {
+                ResultsPositionalMappingEnabled![i] = true;
+            }
+        }
+
         for (var i = lastIndex - _bulkInsertCommands.Count; i < lastIndex; i++)
         {
             CommandResultSet[i] = resultSetMapping;
@@ -230,4 +251,76 @@ protected override void UpdateCachedCommandText(int commandPosition)
                 secondCommand.ColumnModifications.Where(o => o.IsWrite).Select(o => o.ColumnName))
             && firstCommand.ColumnModifications.Where(o => o.IsRead).Select(o => o.ColumnName).SequenceEqual(
                 secondCommand.ColumnModifications.Where(o => o.IsRead).Select(o => o.ColumnName));
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public override void Execute(IRelationalConnection connection)
+    {
+        try
+        {
+            base.Execute(connection);
+        }
+        catch (DbUpdateException e) when (e.InnerException is SqlException { Number: 334 } )
+        {
+            // SQL Server error: The target table '%.*ls' of the DML statement cannot have any enabled triggers if the statement contains an
+            // OUTPUT clause without INTO clause.
+            // This occurs when the user hasn't declared in metadata that a table has triggers, but triggers do exist in the database.
+            // Throw a specialized exception to point the user in the right direction.
+            throw new DbUpdateException(
+                SqlServerStrings.SaveChangesFailedBecauseOfTriggers,
+                e.InnerException,
+                e.Entries);
+        }
+        catch (DbUpdateException e) when (e.InnerException is SqlException { Number: 4186 } )
+        {
+            // SQL Server error: Column '%ls.%.*ls' cannot be referenced in the OUTPUT clause because the column definition contains a
+            // subquery or references a function that performs user or system data access [...]
+            // See https://docs.microsoft.com/sql/relational-databases/errors-events/mssqlserver-4186-database-engine-error
+            throw new DbUpdateException(
+                SqlServerStrings.SaveChangesFailedBecauseOfComputedColumnWithFunction,
+                e.InnerException,
+                e.Entries);
+        }
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public override async Task ExecuteAsync(
+        IRelationalConnection connection,
+        CancellationToken cancellationToken = default)
+    {
+        try
+        {
+            await base.ExecuteAsync(connection, cancellationToken).ConfigureAwait(false);
+        }
+        catch (DbUpdateException e) when (e.InnerException is SqlException { Number: 334 } )
+        {
+            // SQL Server error: The target table '%.*ls' of the DML statement cannot have any enabled triggers if the statement contains an
+            // OUTPUT clause without INTO clause.
+            // This occurs when the user hasn't declared in metadata that a table has triggers, but triggers do exist in the database.
+            // Throw a specialized exception to point the user in the right direction.
+            throw new DbUpdateException(
+                SqlServerStrings.SaveChangesFailedBecauseOfTriggers,
+                e.InnerException,
+                e.Entries);
+        }
+        catch (DbUpdateException e) when (e.InnerException is SqlException { Number: 4186 } )
+        {
+            // SQL Server error: Column '%ls.%.*ls' cannot be referenced in the OUTPUT clause because the column definition contains a
+            // subquery or references a function that performs user or system data access [...]
+            // See https://docs.microsoft.com/sql/relational-databases/errors-events/mssqlserver-4186-database-engine-error
+            throw new DbUpdateException(
+                SqlServerStrings.SaveChangesFailedBecauseOfComputedColumnWithFunction,
+                e.InnerException,
+                e.Entries);
+        }
+    }
 }
diff --git a/src/EFCore.SqlServer/Update/Internal/SqlServerUpdateSqlGenerator.cs b/src/EFCore.SqlServer/Update/Internal/SqlServerUpdateSqlGenerator.cs
index 1d18cee739..7d08eb1283 100644
--- a/src/EFCore.SqlServer/Update/Internal/SqlServerUpdateSqlGenerator.cs
+++ b/src/EFCore.SqlServer/Update/Internal/SqlServerUpdateSqlGenerator.cs
@@ -26,6 +26,74 @@ public class SqlServerUpdateSqlGenerator : UpdateSqlGenerator, ISqlServerUpdateS
     {
     }
 
+    /// <summary>
+    ///     The minimum number of insertions which are executed using MERGE ... OUTPUT INTO. Below this threshold, multiple batched INSERT
+    ///     statements are more efficient.
+    /// </summary>
+    protected virtual int MergeIntoMinimumThreshold => 4;
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public override ResultSetMapping AppendInsertOperation(
+        StringBuilder commandStringBuilder,
+        IReadOnlyModificationCommand command,
+        int commandPosition,
+        out bool requiresTransaction)
+    {
+        // If no database-generated columns need to be read back, just do a simple INSERT (default behavior).
+        // If there are generated columns but there are no triggers defined on the table, we can do a simple INSERT ... OUTPUT
+        // (without INTO), which is also the default behavior, doesn't require a transaction and is the most efficient.
+        if (command.ColumnModifications.All(o => !o.IsRead)
+            || !command.Entries[0].EntityType.Model.GetRelationalModel().FindTable(command.TableName, command.Schema)!.Triggers.Any())
+        {
+            return base.AppendInsertOperation(commandStringBuilder, command, commandPosition, out requiresTransaction);
+        }
+
+        // SQL Server doesn't allow INSERT ... OUTPUT on tables with triggers.
+        // If the only generated column is an IDENTITY, do INSERT+SELECT which is relatively fast.
+        // Otherwise fall back to INSERT ... OUTPUT INTO @inserted; SELECT ... FROM @inserted.
+        var table = StoreObjectIdentifier.Table(command.TableName, command.Schema);
+
+        return command.ColumnModifications.All(
+            o =>
+                !o.IsKey
+                || !o.IsRead
+                || o.Property?.GetValueGenerationStrategy(table) == SqlServerValueGenerationStrategy.IdentityColumn)
+            ? AppendInsertAndSelectOperations(commandStringBuilder, command, commandPosition, out requiresTransaction)
+            : AppendInsertSingleRowWithOutputInto(
+                commandStringBuilder,
+                command,
+                command.ColumnModifications.Where(o => o.IsKey).ToList(),
+                command.ColumnModifications.Where(o => o.IsRead).ToList(),
+                commandPosition,
+                out requiresTransaction);
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    protected override void AppendInsertCommand(
+        StringBuilder commandStringBuilder,
+        string name,
+        string? schema,
+        IReadOnlyList<IColumnModification> writeOperations,
+        IReadOnlyList<IColumnModification> readOperations)
+    {
+        // In SQL Server the OUTPUT clause is placed differently (before the VALUES instead of at the end)
+        AppendInsertCommandHeader(commandStringBuilder, name, schema, writeOperations);
+        AppendOutputClause(commandStringBuilder, readOperations);
+        AppendValuesHeader(commandStringBuilder, writeOperations);
+        AppendValues(commandStringBuilder, name, schema, writeOperations);
+        commandStringBuilder.AppendLine(SqlGenerationHelper.StatementTerminator);
+    }
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -36,33 +104,24 @@ public class SqlServerUpdateSqlGenerator : UpdateSqlGenerator, ISqlServerUpdateS
         StringBuilder commandStringBuilder,
         IReadOnlyList<IReadOnlyModificationCommand> modificationCommands,
         int commandPosition,
+        out bool resultsContainPositionMapping,
         out bool requiresTransaction)
     {
-        var table = StoreObjectIdentifier.Table(modificationCommands[0].TableName, modificationCommands[0].Schema);
+        resultsContainPositionMapping = false;
+
+        var firstCommand = modificationCommands[0];
+
         if (modificationCommands.Count == 1)
         {
-            return modificationCommands[0].ColumnModifications.All(
-                o =>
-                    !o.IsKey
-                    || !o.IsRead
-                    || o.Property?.GetValueGenerationStrategy(table) == SqlServerValueGenerationStrategy.IdentityColumn)
-                // Do a regular INSERT+SELECT for IDENTITY, but not if there are any non-IDENTITY generated columns
-                ? AppendInsertOperation(commandStringBuilder, modificationCommands[0], commandPosition, out requiresTransaction)
-                // If we have a non-identity generated column, do INSERT ... OUTPUT INTO @inserted; SELECT ... FROM @inserted
-                : AppendInsertOperationWithServerKeys(
-                    commandStringBuilder,
-                    modificationCommands[0],
-                    modificationCommands[0].ColumnModifications.Where(o => o.IsKey).ToList(),
-                    modificationCommands[0].ColumnModifications.Where(o => o.IsRead).ToList(),
-                    commandPosition,
-                    out requiresTransaction);
+            return AppendInsertOperation(commandStringBuilder, firstCommand, commandPosition, out requiresTransaction);
         }
 
-        var readOperations = modificationCommands[0].ColumnModifications.Where(o => o.IsRead).ToList();
-        var writeOperations = modificationCommands[0].ColumnModifications.Where(o => o.IsWrite).ToList();
-        var keyOperations = modificationCommands[0].ColumnModifications.Where(o => o.IsKey).ToList();
+        var table = StoreObjectIdentifier.Table(firstCommand.TableName, modificationCommands[0].Schema);
+
+        var readOperations = firstCommand.ColumnModifications.Where(o => o.IsRead).ToList();
+        var writeOperations = firstCommand.ColumnModifications.Where(o => o.IsWrite).ToList();
+        var keyOperations = firstCommand.ColumnModifications.Where(o => o.IsKey).ToList();
 
-        var defaultValuesOnly = writeOperations.Count == 0;
         var writableOperations = modificationCommands[0].ColumnModifications
             .Where(o =>
                 o.Property?.GetValueGenerationStrategy(table) != SqlServerValueGenerationStrategy.IdentityColumn
@@ -70,43 +129,48 @@ public class SqlServerUpdateSqlGenerator : UpdateSqlGenerator, ISqlServerUpdateS
                 && o.Property?.GetColumnType() is not "rowversion" and not "timestamp")
             .ToList();
 
-        if (defaultValuesOnly)
+        if (writeOperations.Count == 0)
         {
-            if (writableOperations.Count == 0
-                || readOperations.Count == 0)
+            // We have no values to write; MERGE and multi-row INSERT cannot be used without writing at least a single column.
+            // But as long as there's at least one writable column (non-identity/computed), we can use it to send DEFAULT in a multi-row
+            // INSERT.
+            if (writableOperations.Count > 0)
             {
-                requiresTransaction = modificationCommands.Count > 1;
-                foreach (var modification in modificationCommands)
+                if (writableOperations.Count > 1)
                 {
-                    AppendInsertOperation(commandStringBuilder, modification, commandPosition, out var localRequiresTransaction);
-                    requiresTransaction = requiresTransaction || localRequiresTransaction;
+                    writableOperations.RemoveRange(1, writableOperations.Count - 1);
                 }
 
                 return readOperations.Count == 0
-                    ? ResultSetMapping.NoResultSet
-                    : ResultSetMapping.LastInResultSet;
+                    ? AppendInsertMultipleDefaultRows(
+                        commandStringBuilder, modificationCommands, writableOperations, out requiresTransaction)
+                    : AppendInsertMultipleDefaultRowsWithOutputInto(
+                        commandStringBuilder, modificationCommands, commandPosition, writableOperations, keyOperations, readOperations,
+                        out requiresTransaction);
             }
 
-            if (writableOperations.Count > 1)
+            // There are no writeable columns, fall back to sending multiple single-row INSERTs (there is no way to insert multiple
+            // all-default rows in a single INSERT).
+            requiresTransaction = modificationCommands.Count > 1;
+            foreach (var modification in modificationCommands)
             {
-                writableOperations.RemoveRange(1, writableOperations.Count - 1);
+                AppendInsertOperation(commandStringBuilder, modification, commandPosition++, out var localRequiresTransaction);
+                requiresTransaction = requiresTransaction || localRequiresTransaction;
             }
+
+            return readOperations.Count == 0
+                ? ResultSetMapping.NoResultSet
+                : ResultSetMapping.LastInResultSet;
         }
 
         if (readOperations.Count == 0)
         {
-            return AppendBulkInsertWithoutServerValues(
+            // We have no values to read, just use a plain old multi-row INSERT.
+            return AppendInsertMultipleRows(
                 commandStringBuilder, modificationCommands, writeOperations, out requiresTransaction);
         }
 
-        if (defaultValuesOnly)
-        {
-            return AppendBulkInsertWithServerValuesOnly(
-                commandStringBuilder, modificationCommands, commandPosition, writableOperations, keyOperations, readOperations,
-                out requiresTransaction);
-        }
-
-        if (modificationCommands[0].Entries.SelectMany(e => e.EntityType.GetAllBaseTypesInclusive())
+        if (firstCommand.Entries.SelectMany(e => e.EntityType.GetAllBaseTypesInclusive())
             .Any(e => e.IsMemoryOptimized()))
         {
             requiresTransaction = modificationCommands.Count > 1;
@@ -123,7 +187,7 @@ public class SqlServerUpdateSqlGenerator : UpdateSqlGenerator, ISqlServerUpdateS
             {
                 foreach (var modification in modificationCommands)
                 {
-                    AppendInsertOperationWithServerKeys(
+                    AppendInsertSingleRowWithOutputInto(
                         commandStringBuilder, modification, keyOperations, readOperations, commandPosition++,
                         out var localRequiresTransaction);
                     requiresTransaction = requiresTransaction || localRequiresTransaction;
@@ -133,12 +197,75 @@ public class SqlServerUpdateSqlGenerator : UpdateSqlGenerator, ISqlServerUpdateS
             return ResultSetMapping.LastInResultSet;
         }
 
-        return AppendBulkInsertWithServerValues(
+        // We default to using MERGE ... OUTPUT (without INTO), projecting back a synthetic _Position column to know the order back
+        // at the client and propagate database-generated values correctly. However, if any triggers are defined, OUTPUT without INTO
+        // doesn't work.
+        if (!firstCommand.Entries[0].EntityType.Model.GetRelationalModel().FindTable(firstCommand.TableName, firstCommand.Schema)!
+                .Triggers.Any())
+        {
+            // MERGE ... OUTPUT returns rows whose ordering isn't guaranteed. So this technique projects back a position int with each row,
+            // to allow mapping the rows back for value propagation.
+            resultsContainPositionMapping = true;
+
+            return AppendMergeWithOutput(
+                commandStringBuilder, modificationCommands, writeOperations, readOperations, out requiresTransaction);
+        }
+
+        // We have a trigger, so can't use a simple OUTPUT clause.
+        // If we have an IDENTITY column, then multiple batched SELECT+INSERTs are faster up to a certain threshold (4), and then
+        // MERGE ... OUTPUT INTO is faster.
+        if (modificationCommands.Count < MergeIntoMinimumThreshold
+            && firstCommand.ColumnModifications.All(
+                o =>
+                    !o.IsKey
+                    || !o.IsRead
+                    || o.Property?.GetValueGenerationStrategy(table) == SqlServerValueGenerationStrategy.IdentityColumn))
+        {
+            requiresTransaction = true;
+
+            foreach (var command in modificationCommands)
+            {
+                AppendInsertAndSelectOperations(commandStringBuilder, command, commandPosition++, out _);
+            }
+
+            return ResultSetMapping.LastInResultSet;
+        }
+
+        return AppendMergeWithOutputInto(
             commandStringBuilder, modificationCommands, commandPosition, writeOperations, keyOperations, readOperations,
             out requiresTransaction);
     }
 
-    private ResultSetMapping AppendBulkInsertWithoutServerValues(
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    protected virtual ResultSetMapping AppendInsertAndSelectOperations(
+        StringBuilder commandStringBuilder,
+        IReadOnlyModificationCommand command,
+        int commandPosition,
+        out bool requiresTransaction)
+    {
+        var name = command.TableName;
+        var schema = command.Schema;
+        var operations = command.ColumnModifications;
+
+        var writeOperations = operations.Where(o => o.IsWrite).ToList();
+        var readOperations = operations.Where(o => o.IsRead).ToList();
+        var keyOperations = operations.Where(o => o.IsKey).ToList();
+
+        Check.DebugAssert(readOperations.Count > 0, "AppendInsertAndSelectOperations called without any read operations");
+
+        requiresTransaction = true;
+
+        AppendInsertCommand(commandStringBuilder, name, schema, writeOperations, readOperations: Array.Empty<IColumnModification>());
+
+        return AppendSelectAffectedCommand(commandStringBuilder, name, schema, readOperations, keyOperations, commandPosition);
+    }
+
+    private ResultSetMapping AppendInsertMultipleRows(
         StringBuilder commandStringBuilder,
         IReadOnlyList<IReadOnlyModificationCommand> modificationCommands,
         List<IColumnModification> writeOperations,
@@ -155,8 +282,7 @@ public class SqlServerUpdateSqlGenerator : UpdateSqlGenerator, ISqlServerUpdateS
         for (var i = 1; i < modificationCommands.Count; i++)
         {
             commandStringBuilder.AppendLine(",");
-            AppendValues(
-                commandStringBuilder, name, schema, modificationCommands[i].ColumnModifications.Where(o => o.IsWrite).ToList());
+            AppendValues(commandStringBuilder, name, schema, modificationCommands[i].ColumnModifications.Where(o => o.IsWrite).ToList());
         }
 
         commandStringBuilder.AppendLine(SqlGenerationHelper.StatementTerminator);
@@ -172,7 +298,36 @@ public class SqlServerUpdateSqlGenerator : UpdateSqlGenerator, ISqlServerUpdateS
     private const string PositionColumnDeclaration = "[" + PositionColumnName + "] [int]";
     private const string FullPositionColumnName = ToInsertTableAlias + "." + PositionColumnName;
 
-    private ResultSetMapping AppendBulkInsertWithServerValues(
+    private ResultSetMapping AppendMergeWithOutput(
+        StringBuilder commandStringBuilder,
+        IReadOnlyList<IReadOnlyModificationCommand> modificationCommands,
+        List<IColumnModification> writeOperations,
+        List<IColumnModification> readOperations,
+        out bool requiresTransaction)
+    {
+        var name = modificationCommands[0].TableName;
+        var schema = modificationCommands[0].Schema;
+
+        AppendMergeCommandHeader(
+            commandStringBuilder,
+            name,
+            schema,
+            ToInsertTableAlias,
+            modificationCommands,
+            writeOperations,
+            PositionColumnName);
+        AppendOutputClause(
+            commandStringBuilder,
+            readOperations,
+            FullPositionColumnName);
+        commandStringBuilder.AppendLine(SqlGenerationHelper.StatementTerminator);
+
+        requiresTransaction = false;
+
+        return ResultSetMapping.NotLastInResultSet;
+    }
+
+    private ResultSetMapping AppendMergeWithOutputInto(
         StringBuilder commandStringBuilder,
         IReadOnlyList<IReadOnlyModificationCommand> modificationCommands,
         int commandPosition,
@@ -199,7 +354,7 @@ public class SqlServerUpdateSqlGenerator : UpdateSqlGenerator, ISqlServerUpdateS
             modificationCommands,
             writeOperations,
             PositionColumnName);
-        AppendOutputClause(
+        AppendOutputIntoClause(
             commandStringBuilder,
             keyOperations,
             InsertedTableBaseName,
@@ -216,7 +371,34 @@ public class SqlServerUpdateSqlGenerator : UpdateSqlGenerator, ISqlServerUpdateS
         return ResultSetMapping.NotLastInResultSet;
     }
 
-    private ResultSetMapping AppendBulkInsertWithServerValuesOnly(
+    private ResultSetMapping AppendInsertMultipleDefaultRows(
+        StringBuilder commandStringBuilder,
+        IReadOnlyList<IReadOnlyModificationCommand> modificationCommands,
+        List<IColumnModification> writeableOperations,
+        out bool requiresTransaction)
+    {
+        Check.DebugAssert(writeableOperations.Count > 0, $"writeableOperations.Count is {writeableOperations.Count}");
+
+        var name = modificationCommands[0].TableName;
+        var schema = modificationCommands[0].Schema;
+
+        AppendInsertCommandHeader(commandStringBuilder, name, schema, writeableOperations);
+        AppendValuesHeader(commandStringBuilder, writeableOperations);
+        AppendValues(commandStringBuilder, name, schema, writeableOperations);
+        for (var i = 1; i < modificationCommands.Count; i++)
+        {
+            commandStringBuilder.AppendLine(",");
+            AppendValues(commandStringBuilder, name, schema, writeableOperations);
+        }
+
+        commandStringBuilder.AppendLine(SqlGenerationHelper.StatementTerminator);
+
+        requiresTransaction = false;
+
+        return ResultSetMapping.NoResultSet;
+    }
+
+    private ResultSetMapping AppendInsertMultipleDefaultRowsWithOutputInto(
         StringBuilder commandStringBuilder,
         IReadOnlyList<IReadOnlyModificationCommand> modificationCommands,
         int commandPosition,
@@ -230,7 +412,7 @@ public class SqlServerUpdateSqlGenerator : UpdateSqlGenerator, ISqlServerUpdateS
         var name = modificationCommands[0].TableName;
         var schema = modificationCommands[0].Schema;
         AppendInsertCommandHeader(commandStringBuilder, name, schema, writableOperations);
-        AppendOutputClause(commandStringBuilder, keyOperations, InsertedTableBaseName, commandPosition);
+        AppendOutputIntoClause(commandStringBuilder, keyOperations, InsertedTableBaseName, commandPosition);
         AppendValuesHeader(commandStringBuilder, writableOperations);
         AppendValues(commandStringBuilder, name, schema, writableOperations);
         for (var i = 1; i < modificationCommands.Count; i++)
@@ -291,9 +473,7 @@ public class SqlServerUpdateSqlGenerator : UpdateSqlGenerator, ISqlServerUpdateS
         commandStringBuilder
             .Append(')')
             .AppendLine(" ON 1=0")
-            .AppendLine("WHEN NOT MATCHED THEN");
-
-        commandStringBuilder
+            .AppendLine("WHEN NOT MATCHED THEN")
             .Append("INSERT ")
             .Append('(')
             .AppendJoin(
@@ -390,37 +570,66 @@ private static string GetTypeNameForCopy(IProperty property)
                 : typeName;
     }
 
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    protected override void AppendReturningClause(
+        StringBuilder commandStringBuilder,
+        IReadOnlyList<IColumnModification> operations)
+        => AppendOutputClause(commandStringBuilder, operations);
+
     // ReSharper disable once ParameterTypeCanBeEnumerable.Local
     private void AppendOutputClause(
         StringBuilder commandStringBuilder,
         IReadOnlyList<IColumnModification> operations,
-        string tableName,
-        int tableIndex,
         string? additionalColumns = null)
     {
-        commandStringBuilder
-            .AppendLine()
-            .Append("OUTPUT ")
-            .AppendJoin(
-                operations,
-                SqlGenerationHelper,
-                (sb, o, helper) =>
-                {
-                    sb.Append("INSERTED.");
-                    helper.DelimitIdentifier(sb, o.ColumnName);
-                });
-
-        if (additionalColumns != null)
+        if (operations.Count > 0 || additionalColumns is not null)
         {
             commandStringBuilder
-                .Append(", ").Append(additionalColumns);
+                .AppendLine()
+                .Append("OUTPUT ")
+                .AppendJoin(
+                    operations,
+                    SqlGenerationHelper,
+                    (sb, o, helper) =>
+                    {
+                        sb.Append("INSERTED.");
+                        helper.DelimitIdentifier(sb, o.ColumnName);
+                    });
+
+            if (additionalColumns != null)
+            {
+                if (operations.Count > 0)
+                {
+                    commandStringBuilder.Append(", ");
+                }
+
+                commandStringBuilder.Append(additionalColumns);
+            }
         }
+    }
 
-        commandStringBuilder.AppendLine()
-            .Append("INTO ").Append(tableName).Append(tableIndex);
+    private void AppendOutputIntoClause(
+        StringBuilder commandStringBuilder,
+        IReadOnlyList<IColumnModification> operations,
+        string tableName,
+        int tableIndex,
+        string? additionalColumns = null)
+    {
+        if (operations.Count > 0 || additionalColumns is not null)
+        {
+            AppendOutputClause(commandStringBuilder, operations, additionalColumns);
+
+            commandStringBuilder.AppendLine()
+                .Append("INTO ").Append(tableName).Append(tableIndex);
+        }
     }
 
-    private ResultSetMapping AppendInsertOperationWithServerKeys(
+    private ResultSetMapping AppendInsertSingleRowWithOutputInto(
         StringBuilder commandStringBuilder,
         IReadOnlyModificationCommand command,
         IReadOnlyList<IColumnModification> keyOperations,
@@ -437,7 +646,7 @@ private static string GetTypeNameForCopy(IProperty property)
         AppendDeclareTable(commandStringBuilder, InsertedTableBaseName, commandPosition, keyOperations);
 
         AppendInsertCommandHeader(commandStringBuilder, name, schema, writeOperations);
-        AppendOutputClause(commandStringBuilder, keyOperations, InsertedTableBaseName, commandPosition);
+        AppendOutputIntoClause(commandStringBuilder, keyOperations, InsertedTableBaseName, commandPosition);
         AppendValuesHeader(commandStringBuilder, writeOperations);
         AppendValues(commandStringBuilder, name, schema, writeOperations);
         commandStringBuilder.Append(SqlGenerationHelper.StatementTerminator);
diff --git a/test/EFCore.Design.Tests/Migrations/Design/CSharpMigrationsGeneratorTest.cs b/test/EFCore.Design.Tests/Migrations/Design/CSharpMigrationsGeneratorTest.cs
index adc6154513..fe4fd6f5b0 100644
--- a/test/EFCore.Design.Tests/Migrations/Design/CSharpMigrationsGeneratorTest.cs
+++ b/test/EFCore.Design.Tests/Migrations/Design/CSharpMigrationsGeneratorTest.cs
@@ -79,7 +79,8 @@ public void Test_new_annotations_handled_for_entity_types()
             RelationalAnnotationNames.TphMappingStrategy,
             RelationalAnnotationNames.TptMappingStrategy,
             RelationalAnnotationNames.RelationalModel,
-            RelationalAnnotationNames.ModelDependencies
+            RelationalAnnotationNames.ModelDependencies,
+            RelationalAnnotationNames.Triggers // Appears on entity but requires provider-specific support
         };
 
         // Add a line here if the code generator is supposed to handle this annotation
@@ -207,7 +208,8 @@ public void Test_new_annotations_handled_for_properties()
             RelationalAnnotationNames.TphMappingStrategy,
             RelationalAnnotationNames.TptMappingStrategy,
             RelationalAnnotationNames.RelationalModel,
-            RelationalAnnotationNames.ModelDependencies
+            RelationalAnnotationNames.ModelDependencies,
+            RelationalAnnotationNames.Triggers
         };
 
         var columnMapping = $@"{_nl}.{nameof(RelationalPropertyBuilderExtensions.HasColumnType)}(""default_int_mapping"")";
diff --git a/test/EFCore.Design.Tests/Migrations/ModelSnapshotSqlServerTest.cs b/test/EFCore.Design.Tests/Migrations/ModelSnapshotSqlServerTest.cs
index 285844ce4c..9489f11709 100644
--- a/test/EFCore.Design.Tests/Migrations/ModelSnapshotSqlServerTest.cs
+++ b/test/EFCore.Design.Tests/Migrations/ModelSnapshotSqlServerTest.cs
@@ -824,6 +824,87 @@ public virtual void CheckConstraint_is_only_stored_in_snapshot_once_for_TPH()
                 Assert.Equal("CK_BaseEntity_AlternateId", constraint.Name);
             });
 
+    [ConditionalFact]
+    public virtual void Trigger_is_stored_in_snapshot()
+        => Test(
+            builder =>
+            {
+                builder.Entity<EntityWithOneProperty>()
+                    .ToTable(tb => tb.HasTrigger("SomeTrigger").Metadata["foo"] = "bar");
+                builder.Ignore<EntityWithTwoProperties>();
+            },
+            AddBoilerPlate(
+                GetHeading()
+                + @"
+            modelBuilder.Entity(""Microsoft.EntityFrameworkCore.Migrations.ModelSnapshotSqlServerTest+EntityWithOneProperty"", b =>
+                {
+                    b.Property<int>(""Id"")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType(""int"");
+
+                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>(""Id""), 1L, 1);
+
+                    b.HasKey(""Id"");
+
+                    b.ToTable(""EntityWithOneProperty"", t =>
+                    {
+                        t.HasTrigger(""SomeTrigger"")
+                            .HasAnnotation(""foo"", ""bar"");
+                    });
+                });"),
+            o =>
+            {
+                var trigger = Assert.Single(o.GetEntityTypes().Single().GetTriggers());
+                Assert.Equal("SomeTrigger", trigger.Name);
+            });
+
+    [ConditionalFact]
+    public virtual void Triggers_and_ExcludeFromMigrations_are_stored_in_snapshot()
+        => Test(
+            builder =>
+            {
+                builder.Entity<EntityWithOneProperty>()
+                    .ToTable(tb =>
+                    {
+                        tb.HasTrigger("SomeTrigger1");
+                        tb.HasTrigger("SomeTrigger2");
+                        tb.ExcludeFromMigrations();
+                    });
+                builder.Ignore<EntityWithTwoProperties>();
+            },
+            AddBoilerPlate(
+                GetHeading()
+                + @"
+            modelBuilder.Entity(""Microsoft.EntityFrameworkCore.Migrations.ModelSnapshotSqlServerTest+EntityWithOneProperty"", b =>
+                {
+                    b.Property<int>(""Id"")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType(""int"");
+
+                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>(""Id""), 1L, 1);
+
+                    b.HasKey(""Id"");
+
+                    b.ToTable(""EntityWithOneProperty"", t =>
+                    {
+                        t.ExcludeFromMigrations();
+
+                        t.HasTrigger(""SomeTrigger1"");
+                        t.HasTrigger(""SomeTrigger2"");
+                    });
+                });"),
+            o =>
+            {
+                var entityType = Assert.Single(o.GetEntityTypes());
+
+                Assert.True(entityType.IsTableExcludedFromMigrations());
+
+                Assert.Collection(
+                    entityType.GetTriggers().OrderBy(t => t.Name),
+                    t => Assert.Equal("SomeTrigger1", t.Name),
+                    t => Assert.Equal("SomeTrigger2", t.Name));
+            });
+
     [ConditionalFact]
     public virtual void ProductVersion_is_stored_in_snapshot()
     {
diff --git a/test/EFCore.Design.Tests/Scaffolding/Internal/CSharpRuntimeModelCodeGeneratorTest.cs b/test/EFCore.Design.Tests/Scaffolding/Internal/CSharpRuntimeModelCodeGeneratorTest.cs
index 166946c8d5..03cdc62567 100644
--- a/test/EFCore.Design.Tests/Scaffolding/Internal/CSharpRuntimeModelCodeGeneratorTest.cs
+++ b/test/EFCore.Design.Tests/Scaffolding/Internal/CSharpRuntimeModelCodeGeneratorTest.cs
@@ -3495,6 +3495,187 @@ protected override void OnModelCreating(ModelBuilder modelBuilder)
             }
         }
 
+        [ConditionalFact]
+        public void Triggers()
+            => Test(
+                new TriggersContext(),
+                new CompiledModelCodeGenerationOptions(),
+                code => Assert.Collection(
+                    code,
+                    c => AssertFileContents(
+                        "TriggersContextModel.cs",
+                        @"// <auto-generated />
+using Microsoft.EntityFrameworkCore.Infrastructure;
+using Microsoft.EntityFrameworkCore.Metadata;
+using Microsoft.EntityFrameworkCore.Scaffolding.Internal;
+
+#pragma warning disable 219, 612, 618
+#nullable disable
+
+namespace TestNamespace
+{
+    [DbContext(typeof(CSharpRuntimeModelCodeGeneratorTest.TriggersContext))]
+    public partial class TriggersContextModel : RuntimeModel
+    {
+        static TriggersContextModel()
+        {
+            var model = new TriggersContextModel();
+            model.Initialize();
+            model.Customize();
+            _instance = model;
+        }
+
+        private static TriggersContextModel _instance;
+        public static IModel Instance => _instance;
+
+        partial void Initialize();
+
+        partial void Customize();
+    }
+}
+",
+                        c),
+                    c => AssertFileContents(
+                        "TriggersContextModelBuilder.cs",
+                        @"// <auto-generated />
+using System;
+using Microsoft.EntityFrameworkCore.Infrastructure;
+using Microsoft.EntityFrameworkCore.Metadata;
+
+#pragma warning disable 219, 612, 618
+#nullable disable
+
+namespace TestNamespace
+{
+    public partial class TriggersContextModel
+    {
+        partial void Initialize()
+        {
+            var data = DataEntityType.Create(this);
+
+            DataEntityType.CreateAnnotations(data);
+
+            AddAnnotation(""Relational:MaxIdentifierLength"", 128);
+            AddAnnotation(""SqlServer:ValueGenerationStrategy"", SqlServerValueGenerationStrategy.IdentityColumn);
+        }
+    }
+}
+",
+                        c),
+                    c => AssertFileContents(
+                        "DataEntityType.cs",
+                        @"// <auto-generated />
+using System;
+using System.Collections.Generic;
+using System.Reflection;
+using Microsoft.EntityFrameworkCore.Metadata;
+using Microsoft.EntityFrameworkCore.Scaffolding.Internal;
+
+#pragma warning disable 219, 612, 618
+#nullable disable
+
+namespace TestNamespace
+{
+    internal partial class DataEntityType
+    {
+        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
+        {
+            var runtimeEntityType = model.AddEntityType(
+                ""Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+Data"",
+                typeof(CSharpRuntimeModelCodeGeneratorTest.Data),
+                baseEntityType);
+
+            var id = runtimeEntityType.AddProperty(
+                ""Id"",
+                typeof(int),
+                valueGenerated: ValueGenerated.OnAdd,
+                afterSaveBehavior: PropertySaveBehavior.Throw);
+            id.AddAnnotation(""SqlServer:ValueGenerationStrategy"", SqlServerValueGenerationStrategy.IdentityColumn);
+
+            var blob = runtimeEntityType.AddProperty(
+                ""Blob"",
+                typeof(byte[]),
+                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.Data).GetProperty(""Blob"", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
+                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.Data).GetField(""<Blob>k__BackingField"", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
+                nullable: true);
+            blob.AddAnnotation(""SqlServer:ValueGenerationStrategy"", SqlServerValueGenerationStrategy.None);
+
+            var key = runtimeEntityType.AddKey(
+                new[] { id });
+            runtimeEntityType.SetPrimaryKey(key);
+
+            return runtimeEntityType;
+        }
+
+        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
+        {
+            var triggers = new SortedDictionary<string, ITrigger>();
+
+            var trigger1 = new RuntimeTrigger(
+                runtimeEntityType,
+                ""Trigger1"",
+                ""Trigger1"",
+                ""Data"",
+                null);
+
+            triggers[""Trigger1""] = trigger1;
+
+            var trigger2 = new RuntimeTrigger(
+                runtimeEntityType,
+                ""Trigger2"",
+                ""Trigger2"",
+                ""Data"",
+                null);
+
+            triggers[""Trigger2""] = trigger2;
+
+            runtimeEntityType.AddAnnotation(""Relational:Triggers"", triggers);
+            runtimeEntityType.AddAnnotation(""Relational:FunctionName"", null);
+            runtimeEntityType.AddAnnotation(""Relational:Schema"", null);
+            runtimeEntityType.AddAnnotation(""Relational:SqlQuery"", null);
+            runtimeEntityType.AddAnnotation(""Relational:TableName"", ""Data"");
+            runtimeEntityType.AddAnnotation(""Relational:ViewName"", null);
+            runtimeEntityType.AddAnnotation(""Relational:ViewSchema"", null);
+
+            Customize(runtimeEntityType);
+        }
+
+        static partial void Customize(RuntimeEntityType runtimeEntityType);
+    }
+}
+",
+                        c)),
+                model =>
+                {
+                    var dataEntity = model.GetEntityTypes().Single();
+
+                    Assert.Equal(
+                        CoreStrings.RuntimeModelMissingData,
+                        Assert.Throws<InvalidOperationException>(() => dataEntity.GetCheckConstraints()).Message);
+                });
+
+        public class TriggersContext : SqlServerContextBase
+        {
+            protected override void OnModelCreating(ModelBuilder modelBuilder)
+            {
+                base.OnModelCreating(modelBuilder);
+
+                modelBuilder.Entity<Data>(
+                    eb =>
+                    {
+                        eb.Property<int>("Id");
+                        eb.HasKey("Id");
+
+                        eb.ToTable(
+                            tb =>
+                                {
+                                    tb.HasTrigger("Trigger1");
+                                    tb.HasTrigger("Trigger2");
+                                });
+                    });
+            }
+        }
+
         [ConditionalFact]
         public void Sqlite()
             => Test(
diff --git a/test/EFCore.Relational.Specification.Tests/TransactionTestBase.cs b/test/EFCore.Relational.Specification.Tests/TransactionTestBase.cs
index 2d2beb2d73..5d9d4da8fa 100644
--- a/test/EFCore.Relational.Specification.Tests/TransactionTestBase.cs
+++ b/test/EFCore.Relational.Specification.Tests/TransactionTestBase.cs
@@ -40,7 +40,7 @@ public virtual async Task SaveChanges_can_be_used_with_no_transaction(bool async
             context.Add(
                 new TransactionCustomer { Id = -77, Name = "Bobble" });
 
-            context.Entry(context.Set<TransactionCustomer>().OrderBy(c => c.Id).Last()).State = EntityState.Added;
+            context.Entry(context.Set<TransactionOrder>().OrderBy(c => c.Id).Last()).State = EntityState.Added;
 
             if (async)
             {
@@ -1290,7 +1290,7 @@ public virtual async Task SaveChanges_can_be_used_with_no_savepoint(bool async)
             }
 
             context.Add(new TransactionCustomer { Id = -78, Name = "Hobble" });
-            context.Add(new TransactionCustomer { Id = 1, Name = "Gobble" }); // Cause SaveChanges failure
+            context.Add(new TransactionOrder { Id = 100 }); // Cause SaveChanges failure
 
             if (async)
             {
diff --git a/test/EFCore.Relational.Specification.Tests/Update/StoreValueGenerationFixtureBase.cs b/test/EFCore.Relational.Specification.Tests/Update/StoreValueGenerationFixtureBase.cs
index b0b2715963..b35fea5b9a 100644
--- a/test/EFCore.Relational.Specification.Tests/Update/StoreValueGenerationFixtureBase.cs
+++ b/test/EFCore.Relational.Specification.Tests/Update/StoreValueGenerationFixtureBase.cs
@@ -13,6 +13,8 @@ public abstract class StoreValueGenerationFixtureBase : SharedStoreFixtureBase<S
 
     protected override void OnModelCreating(ModelBuilder modelBuilder, DbContext context)
     {
+        var sqlGenerationHelper = context.GetService<ISqlGenerationHelper>();
+
         foreach (var name in new[]
                  {
                      nameof(StoreValueGenerationContext.WithNoDatabaseGenerated),
@@ -28,15 +30,13 @@ protected override void OnModelCreating(ModelBuilder modelBuilder, DbContext con
         foreach (var name in new[]
                  {
                      nameof(StoreValueGenerationContext.WithSomeDatabaseGenerated),
-                     nameof(StoreValueGenerationContext.WithSomeDatabaseGenerated2),
-                     nameof(StoreValueGenerationContext.WithAllDatabaseGenerated),
-                     nameof(StoreValueGenerationContext.WithAllDatabaseGenerated2)
+                     nameof(StoreValueGenerationContext.WithSomeDatabaseGenerated2)
                  })
         {
             modelBuilder
                 .SharedTypeEntity<StoreValueGenerationData>(name)
                 .Property(w => w.Data1)
-                .HasComputedColumnSql("80");
+                .HasComputedColumnSql(sqlGenerationHelper.DelimitIdentifier(nameof(StoreValueGenerationData.Data2)) + " + 1");
         }
 
         foreach (var name in new[]
@@ -45,6 +45,11 @@ protected override void OnModelCreating(ModelBuilder modelBuilder, DbContext con
                      nameof(StoreValueGenerationContext.WithAllDatabaseGenerated2)
                  })
         {
+            modelBuilder
+                .SharedTypeEntity<StoreValueGenerationData>(name)
+                .Property(w => w.Data1)
+                .HasComputedColumnSql("80");
+
             modelBuilder
                 .SharedTypeEntity<StoreValueGenerationData>(name)
                 .Property(w => w.Data2)
diff --git a/test/EFCore.Relational.Specification.Tests/Update/StoreValueGenerationTestBase.cs b/test/EFCore.Relational.Specification.Tests/Update/StoreValueGenerationTestBase.cs
index 5b89e789ac..007f32d838 100644
--- a/test/EFCore.Relational.Specification.Tests/Update/StoreValueGenerationTestBase.cs
+++ b/test/EFCore.Relational.Specification.Tests/Update/StoreValueGenerationTestBase.cs
@@ -336,13 +336,13 @@ public virtual Task Delete_Delete_with_different_entity_types(bool async)
             return true;
         }
 
-        // Deletes don't ever need to bring back database-generated values
-        if (firstOperationType == EntityState.Deleted)
+        // Deletes don't ever need to bring back database-generated values, and inserts use the RETURNING clause - no transaction needed
+        if (firstOperationType is EntityState.Deleted or EntityState.Added)
         {
             return false;
         }
 
-        // By default, assume that fetching back database-generated values requires a transaction
+        // Fetching back database-generated values from an update requires a transaction
         return generatedValues != GeneratedValues.None;
     }
 
diff --git a/test/EFCore.Relational.Specification.Tests/Update/UpdateSqlGeneratorTestBase.cs b/test/EFCore.Relational.Specification.Tests/Update/UpdateSqlGeneratorTestBase.cs
index 14977de972..8243c42190 100644
--- a/test/EFCore.Relational.Specification.Tests/Update/UpdateSqlGeneratorTestBase.cs
+++ b/test/EFCore.Relational.Specification.Tests/Update/UpdateSqlGeneratorTestBase.cs
@@ -74,65 +74,17 @@ public virtual void AppendDeleteOperation_creates_full_delete_command_text_with_
     }
 
     [ConditionalFact]
-    public virtual void AppendInsertOperation_appends_insert_and_select_and_where_if_store_generated_columns_exist()
+    public virtual void AppendInsertOperation_insert_if_store_generated_columns_exist()
     {
         var stringBuilder = new StringBuilder();
         var command = CreateInsertCommand();
 
         CreateSqlGenerator().AppendInsertOperation(stringBuilder, command, 0);
 
-        AppendInsertOperation_appends_insert_and_select_and_where_if_store_generated_columns_exist_verification(stringBuilder);
+        AppendInsertOperation_insert_if_store_generated_columns_exist_verification(stringBuilder);
     }
 
-    protected virtual void AppendInsertOperation_appends_insert_and_select_and_where_if_store_generated_columns_exist_verification(
-        StringBuilder stringBuilder)
-        => Assert.Equal(
-            "INSERT INTO "
-            + SchemaPrefix
-            + OpenDelimiter
-            + "Ducks"
-            + CloseDelimiter
-            + " ("
-            + OpenDelimiter
-            + "Name"
-            + CloseDelimiter
-            + ", "
-            + OpenDelimiter
-            + "Quacks"
-            + CloseDelimiter
-            + ", "
-            + OpenDelimiter
-            + "ConcurrencyToken"
-            + CloseDelimiter
-            + ")"
-            + Environment.NewLine
-            + "VALUES (@p0, @p1, @p2);"
-            + Environment.NewLine
-            + "SELECT "
-            + OpenDelimiter
-            + "Id"
-            + CloseDelimiter
-            + ", "
-            + OpenDelimiter
-            + "Computed"
-            + CloseDelimiter
-            + ""
-            + Environment.NewLine
-            + "FROM "
-            + SchemaPrefix
-            + OpenDelimiter
-            + "Ducks"
-            + CloseDelimiter
-            + ""
-            + Environment.NewLine
-            + "WHERE "
-            + RowsAffected
-            + " = 1 AND "
-            + GetIdentityWhereCondition("Id")
-            + ";"
-            + Environment.NewLine
-            + Environment.NewLine,
-            stringBuilder.ToString());
+    protected abstract void AppendInsertOperation_insert_if_store_generated_columns_exist_verification(StringBuilder stringBuilder);
 
     [ConditionalFact]
     public virtual void
@@ -173,217 +125,56 @@ public virtual void
     }
 
     [ConditionalFact]
-    public virtual void AppendInsertOperation_appends_insert_and_select_store_generated_columns_but_no_identity()
+    public virtual void AppendInsertOperation_for_store_generated_columns_but_no_identity()
     {
         var stringBuilder = new StringBuilder();
         var command = CreateInsertCommand(false);
 
         CreateSqlGenerator().AppendInsertOperation(stringBuilder, command, 0);
 
-        AppendInsertOperation_appends_insert_and_select_store_generated_columns_but_no_identity_verification(stringBuilder);
+        AppendInsertOperation_for_store_generated_columns_but_no_identity_verification(stringBuilder);
     }
 
-    protected virtual void AppendInsertOperation_appends_insert_and_select_store_generated_columns_but_no_identity_verification(
-        StringBuilder stringBuilder)
-        => Assert.Equal(
-            "INSERT INTO "
-            + SchemaPrefix
-            + OpenDelimiter
-            + "Ducks"
-            + CloseDelimiter
-            + " ("
-            + OpenDelimiter
-            + "Id"
-            + CloseDelimiter
-            + ", "
-            + OpenDelimiter
-            + "Name"
-            + CloseDelimiter
-            + ", "
-            + OpenDelimiter
-            + "Quacks"
-            + CloseDelimiter
-            + ", "
-            + OpenDelimiter
-            + "ConcurrencyToken"
-            + CloseDelimiter
-            + ")"
-            + Environment.NewLine
-            + "VALUES (@p0, @p1, @p2, @p3);"
-            + Environment.NewLine
-            + "SELECT "
-            + OpenDelimiter
-            + "Computed"
-            + CloseDelimiter
-            + ""
-            + Environment.NewLine
-            + "FROM "
-            + SchemaPrefix
-            + OpenDelimiter
-            + "Ducks"
-            + CloseDelimiter
-            + ""
-            + Environment.NewLine
-            + "WHERE "
-            + RowsAffected
-            + " = 1 AND "
-            + OpenDelimiter
-            + "Id"
-            + CloseDelimiter
-            + " = @p0;"
-            + Environment.NewLine
-            + Environment.NewLine,
-            stringBuilder.ToString());
+    protected abstract void AppendInsertOperation_for_store_generated_columns_but_no_identity_verification(StringBuilder stringBuilder);
 
     [ConditionalFact]
-    public virtual void AppendInsertOperation_appends_insert_and_select_for_only_identity()
+    public virtual void AppendInsertOperation_for_only_identity()
     {
         var stringBuilder = new StringBuilder();
         var command = CreateInsertCommand(true, false);
 
         CreateSqlGenerator().AppendInsertOperation(stringBuilder, command, 0);
 
-        AppendInsertOperation_appends_insert_and_select_for_only_identity_verification(stringBuilder);
+        AppendInsertOperation_for_only_identity_verification(stringBuilder);
     }
 
-    protected virtual void AppendInsertOperation_appends_insert_and_select_for_only_identity_verification(StringBuilder stringBuilder)
-        => Assert.Equal(
-            "INSERT INTO "
-            + SchemaPrefix
-            + OpenDelimiter
-            + "Ducks"
-            + CloseDelimiter
-            + " ("
-            + OpenDelimiter
-            + "Name"
-            + CloseDelimiter
-            + ", "
-            + OpenDelimiter
-            + "Quacks"
-            + CloseDelimiter
-            + ", "
-            + OpenDelimiter
-            + "ConcurrencyToken"
-            + CloseDelimiter
-            + ")"
-            + Environment.NewLine
-            + "VALUES (@p0, @p1, @p2);"
-            + Environment.NewLine
-            + "SELECT "
-            + OpenDelimiter
-            + "Id"
-            + CloseDelimiter
-            + ""
-            + Environment.NewLine
-            + "FROM "
-            + SchemaPrefix
-            + OpenDelimiter
-            + "Ducks"
-            + CloseDelimiter
-            + ""
-            + Environment.NewLine
-            + "WHERE "
-            + RowsAffected
-            + " = 1 AND "
-            + GetIdentityWhereCondition("Id")
-            + ";"
-            + Environment.NewLine
-            + Environment.NewLine,
-            stringBuilder.ToString());
+    protected abstract void AppendInsertOperation_for_only_identity_verification(StringBuilder stringBuilder);
 
     [ConditionalFact]
-    public virtual void AppendInsertOperation_appends_insert_and_select_for_all_store_generated_columns()
+    public virtual void AppendInsertOperation_for_all_store_generated_columns()
     {
         var stringBuilder = new StringBuilder();
         var command = CreateInsertCommand(true, true, true);
 
         CreateSqlGenerator().AppendInsertOperation(stringBuilder, command, 0);
 
-        AppendInsertOperation_appends_insert_and_select_for_all_store_generated_columns_verification(stringBuilder);
+        AppendInsertOperation_for_all_store_generated_columns_verification(stringBuilder);
     }
 
-    protected virtual void AppendInsertOperation_appends_insert_and_select_for_all_store_generated_columns_verification(
-        StringBuilder stringBuilder)
-        => Assert.Equal(
-            "INSERT INTO "
-            + SchemaPrefix
-            + OpenDelimiter
-            + "Ducks"
-            + CloseDelimiter
-            + ""
-            + Environment.NewLine
-            + "DEFAULT VALUES;"
-            + Environment.NewLine
-            + "SELECT "
-            + OpenDelimiter
-            + "Id"
-            + CloseDelimiter
-            + ", "
-            + OpenDelimiter
-            + "Computed"
-            + CloseDelimiter
-            + ""
-            + Environment.NewLine
-            + "FROM "
-            + SchemaPrefix
-            + OpenDelimiter
-            + "Ducks"
-            + CloseDelimiter
-            + ""
-            + Environment.NewLine
-            + "WHERE "
-            + RowsAffected
-            + " = 1 AND "
-            + GetIdentityWhereCondition("Id")
-            + ";"
-            + Environment.NewLine
-            + Environment.NewLine,
-            stringBuilder.ToString());
+    protected abstract void AppendInsertOperation_for_all_store_generated_columns_verification(StringBuilder stringBuilder);
 
     [ConditionalFact]
-    public virtual void AppendInsertOperation_appends_insert_and_select_for_only_single_identity_columns()
+    public virtual void AppendInsertOperation_for_only_single_identity_columns()
     {
         var stringBuilder = new StringBuilder();
-        var command = CreateInsertCommand(true, false, true);
+        var command = CreateInsertCommand(identityKey: true, isComputed: false, defaultsOnly: true);
 
         CreateSqlGenerator().AppendInsertOperation(stringBuilder, command, 0);
 
-        AppendInsertOperation_appends_insert_and_select_for_only_single_identity_columns_verification(stringBuilder);
+        AppendInsertOperation_for_only_single_identity_columns_verification(stringBuilder);
     }
 
-    protected virtual void AppendInsertOperation_appends_insert_and_select_for_only_single_identity_columns_verification(
-        StringBuilder stringBuilder)
-        => Assert.Equal(
-            "INSERT INTO "
-            + SchemaPrefix
-            + OpenDelimiter
-            + "Ducks"
-            + CloseDelimiter
-            + ""
-            + Environment.NewLine
-            + "DEFAULT VALUES;"
-            + Environment.NewLine
-            + "SELECT "
-            + OpenDelimiter
-            + "Id"
-            + CloseDelimiter
-            + ""
-            + Environment.NewLine
-            + "FROM "
-            + SchemaPrefix
-            + OpenDelimiter
-            + "Ducks"
-            + CloseDelimiter
-            + ""
-            + Environment.NewLine
-            + "WHERE "
-            + RowsAffected
-            + " = 1 AND "
-            + GetIdentityWhereCondition("Id")
-            + ";"
-            + Environment.NewLine
-            + Environment.NewLine,
-            stringBuilder.ToString());
+    protected abstract void AppendInsertOperation_for_only_single_identity_columns_verification(StringBuilder stringBuilder);
 
     [ConditionalFact]
     public virtual void AppendUpdateOperation_appends_update_and_select_if_store_generated_columns_exist()
@@ -652,6 +443,7 @@ protected IModificationCommand CreateInsertCommand(bool identityKey = true, bool
         var model = GetDuckModel();
         var stateManager = TestHelpers.CreateContextServices(model).GetRequiredService<IStateManager>();
         var entry = stateManager.GetOrCreateEntry(new Duck());
+        entry.SetEntityState(EntityState.Added);
         var generator = new ParameterNameGenerator();
 
         var duckType = model.FindEntityType(typeof(Duck));
@@ -685,7 +477,7 @@ protected IModificationCommand CreateInsertCommand(bool identityKey = true, bool
             columnModifications = columnModifications.Where(c => !c.IsWrite).ToArray();
         }
 
-        return CreateModificationCommand("Ducks", Schema, columnModifications, false);
+        return CreateModificationCommand("Ducks", Schema, entry, columnModifications, false);
     }
 
     protected IModificationCommand CreateUpdateCommand(bool isComputed = true, bool concurrencyToken = true)
@@ -693,6 +485,7 @@ protected IModificationCommand CreateUpdateCommand(bool isComputed = true, bool
         var model = GetDuckModel();
         var stateManager = TestHelpers.CreateContextServices(model).GetRequiredService<IStateManager>();
         var entry = stateManager.GetOrCreateEntry(new Duck());
+        entry.SetEntityState(EntityState.Modified);
         var generator = new ParameterNameGenerator();
 
         var duckType = model.FindEntityType(typeof(Duck));
@@ -721,7 +514,7 @@ protected IModificationCommand CreateUpdateCommand(bool isComputed = true, bool
                 concurrencyProperty.GetTableColumnMappings().Single().TypeMapping, false, true, false, concurrencyToken, true)
         };
 
-        return CreateModificationCommand("Ducks", Schema, columnModifications, false);
+        return CreateModificationCommand("Ducks", Schema, entry, columnModifications, false);
     }
 
     protected IModificationCommand CreateDeleteCommand(bool concurrencyToken = true)
@@ -729,6 +522,7 @@ protected IModificationCommand CreateDeleteCommand(bool concurrencyToken = true)
         var model = GetDuckModel();
         var stateManager = TestHelpers.CreateContextServices(model).GetRequiredService<IStateManager>();
         var entry = stateManager.GetOrCreateEntry(new Duck());
+        entry.SetEntityState(EntityState.Deleted);
         var generator = new ParameterNameGenerator();
 
         var duckType = model.FindEntityType(typeof(Duck));
@@ -745,7 +539,7 @@ protected IModificationCommand CreateDeleteCommand(bool concurrencyToken = true)
                 concurrencyProperty.GetTableColumnMappings().Single().TypeMapping, false, false, false, concurrencyToken, true)
         };
 
-        return CreateModificationCommand("Ducks", Schema, columnModifications, false);
+        return CreateModificationCommand("Ducks", Schema, entry, columnModifications, false);
     }
 
     protected abstract TestHelpers TestHelpers { get; }
@@ -769,6 +563,7 @@ protected class Duck
     private IModificationCommand CreateModificationCommand(
         string name,
         string schema,
+        InternalEntityEntry entry,
         IReadOnlyList<ColumnModificationParameters> columnModifications,
         bool sensitiveLoggingEnabled)
     {
@@ -777,6 +572,8 @@ protected class Duck
         var modificationCommand = CreateMutableModificationCommandFactory().CreateModificationCommand(
             modificationCommandParameters);
 
+        modificationCommand.AddEntry(entry, mainEntry: true);
+
         foreach (var columnModification in columnModifications)
         {
             modificationCommand.AddColumnModification(columnModification);
diff --git a/test/EFCore.Relational.Tests/Infrastructure/RelationalModelValidatorTest.cs b/test/EFCore.Relational.Tests/Infrastructure/RelationalModelValidatorTest.cs
index 9ce26453f6..1666ad475c 100644
--- a/test/EFCore.Relational.Tests/Infrastructure/RelationalModelValidatorTest.cs
+++ b/test/EFCore.Relational.Tests/Infrastructure/RelationalModelValidatorTest.cs
@@ -2446,6 +2446,20 @@ public virtual void Detects_duplicate_column_orders()
         VerifyWarning(definition.GenerateMessage("Animal", "'Id', 'Name'"), modelBuilder, LogLevel.Error);
     }
 
+    [ConditionalFact]
+    public virtual void Detects_triggers_on_unmapped_entity_types()
+    {
+        var modelBuilder = CreateConventionalModelBuilder();
+        modelBuilder.Entity<Animal>(
+            x =>
+                {
+                    x.ToTable(tb => tb.HasTrigger("Animal_Trigger"));
+                    x.ToTable(name: null);
+                });
+
+        VerifyError(RelationalStrings.TriggerOnUnmappedEntityType("Animal_Trigger", "Animal"), modelBuilder);
+    }
+
     protected override void SetBaseType(IMutableEntityType entityType, IMutableEntityType baseEntityType)
     {
         base.SetBaseType(entityType, baseEntityType);
diff --git a/test/EFCore.Relational.Tests/Metadata/RelationalBuilderExtensionsTest.cs b/test/EFCore.Relational.Tests/Metadata/RelationalBuilderExtensionsTest.cs
index 1959792ec7..5a5878377a 100644
--- a/test/EFCore.Relational.Tests/Metadata/RelationalBuilderExtensionsTest.cs
+++ b/test/EFCore.Relational.Tests/Metadata/RelationalBuilderExtensionsTest.cs
@@ -651,6 +651,160 @@ public void Base_check_constraint_overrides_derived_one_after_base_is_set()
         Assert.Same(baseEntityType.GetCheckConstraints().Single(), derivedEntityType.GetCheckConstraints().Single());
     }
 
+    [ConditionalFact]
+    public void Can_create_trigger()
+    {
+        var modelBuilder = CreateConventionModelBuilder();
+        var entityType = modelBuilder.Entity<Customer>().Metadata;
+
+        modelBuilder
+            .Entity<Customer>()
+            .ToTable(tb => tb.HasTrigger("Customer_Trigger"));
+
+        var trigger = entityType.FindTrigger("Customer_Trigger");
+
+        Assert.NotNull(trigger);
+        Assert.Same(entityType, trigger.EntityType);
+        Assert.Equal("Customer_Trigger", trigger.ModelName);
+        Assert.Equal("Customer_Trigger", trigger.Name);
+    }
+
+    [ConditionalFact]
+    public void Can_create_trigger_with_duplicate_name_replaces_existing()
+    {
+        var modelBuilder = CreateConventionModelBuilder();
+        var entityType = modelBuilder.Entity<Customer>().Metadata;
+
+        modelBuilder
+            .Entity<Customer>()
+            .ToTable(tb => tb.HasTrigger("Customer_Trigger").HasName("Table1"));
+
+        modelBuilder
+            .Entity<Customer>()
+            .ToTable(tb => tb.HasTrigger("Customer_Trigger").HasName("Table2"));
+
+        var trigger = entityType.FindTrigger("Customer_Trigger");
+
+        Assert.NotNull(trigger);
+        Assert.Equal(entityType, trigger.EntityType);
+        Assert.Equal("Customer_Trigger", trigger.ModelName);
+        Assert.Equal("Table2", trigger.Name);
+    }
+
+    [ConditionalFact]
+    public void Can_access_trigger()
+    {
+        var typeBuilder = CreateBuilder().Entity(typeof(Splot), ConfigurationSource.Convention);
+        IReadOnlyEntityType entityType = typeBuilder.Metadata;
+
+        Assert.NotNull(typeBuilder.HasTrigger("Splew", "Table1", "dbo"));
+        Assert.Equal("Splew", entityType.GetTriggers().Single().ModelName);
+        Assert.Equal("Table1", entityType.GetTriggers().Single().TableName);
+
+        Assert.NotNull(typeBuilder.HasTrigger("Splew", "Table2", "dbo", fromDataAnnotation: true));
+        Assert.Equal("Splew", entityType.GetTriggers().Single().ModelName);
+        Assert.Equal("Table2", entityType.GetTriggers().Single().TableName);
+
+        Assert.Null(typeBuilder.HasTrigger("Splew", "Table1", "dbo"));
+        Assert.Equal("Splew", entityType.GetTriggers().Single().ModelName);
+        Assert.Equal("Table2", entityType.GetTriggers().Single().TableName);
+    }
+
+    [ConditionalFact]
+    public void Base_trigger_overrides_derived_one()
+    {
+        var modelBuilder = CreateBuilder();
+
+        var derivedBuilder = modelBuilder.Entity(typeof(Splow), ConfigurationSource.Convention);
+        IReadOnlyEntityType derivedEntityType = derivedBuilder.Metadata;
+
+        Assert.NotNull(
+            derivedBuilder.HasTrigger("Splew", "Table1", "dbo", fromDataAnnotation: true)
+                .HasName("Splow_Trigger", fromDataAnnotation: true));
+        Assert.Equal("Splew", derivedEntityType.GetTriggers().Single().ModelName);
+        Assert.Equal("Splow_Trigger", derivedEntityType.GetTriggers().Single().Name);
+        Assert.Equal("Table1", derivedEntityType.GetTriggers().Single().TableName);
+        Assert.Equal("dbo", derivedEntityType.GetTriggers().Single().TableSchema);
+
+        Assert.True(derivedBuilder.CanHaveTrigger("Splew", "Table1", "dbo"));
+        Assert.True(derivedBuilder.CanHaveTrigger("Splew", "Table2", "dbo", fromDataAnnotation: true));
+        Assert.True(derivedBuilder.CanHaveTrigger("Splew", "Table1", "dbo2", fromDataAnnotation: true));
+        Assert.False(derivedBuilder.CanHaveTrigger("Splew", "Table2", "dbo"));
+        Assert.False(derivedBuilder.CanHaveTrigger("Splew", "Table1", "dbo2"));
+        Assert.True(derivedBuilder.CanHaveTrigger("Splot", "Table2", "dbo2"));
+
+        var baseBuilder = modelBuilder.Entity(typeof(Splot), ConfigurationSource.DataAnnotation);
+        IReadOnlyEntityType baseEntityType = baseBuilder.Metadata;
+
+        Assert.True(baseBuilder.CanHaveTrigger("Splew", "Table1", "dbo"));
+        Assert.True(baseBuilder.CanHaveTrigger("Splew", "Table2", "dbo", fromDataAnnotation: true));
+        Assert.True(baseBuilder.CanHaveTrigger("Splew", "Table1", "dbo2", fromDataAnnotation: true));
+        Assert.False(baseBuilder.CanHaveTrigger("Splew", "Table2", "dbo"));
+        Assert.False(baseBuilder.CanHaveTrigger("Splew", "Table1", "dbo2"));
+        Assert.True(baseBuilder.CanHaveTrigger("Splot", "Table2", "dbo2"));
+
+        Assert.Null(baseBuilder.HasTrigger("Splew", "Table2", "dbo"));
+        Assert.Empty(baseEntityType.GetTriggers());
+        Assert.Equal("Table1", derivedEntityType.GetTriggers().Single().TableName);
+
+        Assert.NotNull(
+            baseBuilder.HasTrigger("Splew", "Table1", "dbo", fromDataAnnotation: true)
+                .HasName("Another_Splot_Trigger", fromDataAnnotation: true));
+        Assert.Equal("Splew", baseEntityType.GetTriggers().Single().ModelName);
+        Assert.Equal("Table1", baseEntityType.GetTriggers().Single().TableName);
+        Assert.Equal("Another_Splot_Trigger", baseEntityType.GetTriggers().Single().Name);
+
+        derivedBuilder.HasBaseType((EntityType)baseEntityType, ConfigurationSource.Convention);
+
+        Assert.Null(
+            baseBuilder.HasTrigger("Splew", "Table1", "dbo", fromDataAnnotation: true)
+                .HasName("Yet_Another_Splot_Trigger"));
+        Assert.Equal("Splew", baseEntityType.GetTriggers().Single().ModelName);
+        Assert.Equal("Table1", baseEntityType.GetTriggers().Single().TableName);
+        Assert.Equal("Another_Splot_Trigger", baseEntityType.GetTriggers().Single().Name);
+        Assert.Empty(derivedEntityType.GetDeclaredTriggers());
+        Assert.Same(baseEntityType.GetTriggers().Single(), derivedEntityType.GetTriggers().Single());
+    }
+
+    [ConditionalFact]
+    public void Base_trigger_overrides_derived_one_after_base_is_set()
+    {
+        var modelBuilder = CreateBuilder();
+
+        var derivedBuilder = modelBuilder.Entity(typeof(Splow), ConfigurationSource.Convention);
+        Assert.NotNull(derivedBuilder.HasBaseType((string)null, ConfigurationSource.DataAnnotation));
+        IReadOnlyEntityType derivedEntityType = derivedBuilder.Metadata;
+
+        Assert.NotNull(
+            derivedBuilder.HasTrigger("Splew", "Table1", "dbo", fromDataAnnotation: true)
+                .HasName("Splow_Trigger", fromDataAnnotation: true));
+        Assert.Equal("Splew", derivedEntityType.GetTriggers().Single().ModelName);
+        Assert.Equal("Table1", derivedEntityType.GetTriggers().Single().TableName);
+        Assert.Equal("Splow_Trigger", derivedEntityType.GetTriggers().Single().Name);
+
+        var baseBuilder = modelBuilder.Entity(typeof(Splot), ConfigurationSource.Convention);
+        IReadOnlyEntityType baseEntityType = baseBuilder.Metadata;
+        Assert.Null(derivedEntityType.BaseType);
+
+        Assert.NotNull(
+            baseBuilder.HasTrigger("Splew", "Table1", "dbo", fromDataAnnotation: true)
+                .HasName("Splot_Trigger", fromDataAnnotation: true));
+        Assert.Equal("Splew", baseEntityType.GetTriggers().Single().ModelName);
+        Assert.Equal("Table1", baseEntityType.GetTriggers().Single().TableName);
+        Assert.Equal("Splot_Trigger", baseEntityType.GetTriggers().Single().Name);
+
+        Assert.NotNull(derivedBuilder.HasBaseType((EntityType)baseEntityType, ConfigurationSource.DataAnnotation));
+
+        Assert.Null(
+            baseBuilder.HasTrigger("Splew", "Table1", "dbo", fromDataAnnotation: true)
+                .HasName("Splew_Trigger"));
+        Assert.Equal("Splew", baseEntityType.GetTriggers().Single().ModelName);
+        Assert.Equal("Table1", baseEntityType.GetTriggers().Single().TableName);
+        Assert.Equal("Splot_Trigger", baseEntityType.GetTriggers().Single().Name);
+        Assert.Empty(derivedEntityType.GetDeclaredTriggers());
+        Assert.Same(baseEntityType.GetTriggers().Single(), derivedEntityType.GetTriggers().Single());
+    }
+
     [ConditionalFact]
     public void Can_set_discriminator_value_using_property_expression()
     {
diff --git a/test/EFCore.Relational.Tests/Metadata/RelationalModelTest.cs b/test/EFCore.Relational.Tests/Metadata/RelationalModelTest.cs
index 3d95323f8c..c657323d7a 100644
--- a/test/EFCore.Relational.Tests/Metadata/RelationalModelTest.cs
+++ b/test/EFCore.Relational.Tests/Metadata/RelationalModelTest.cs
@@ -639,6 +639,11 @@ private static void AssertTables(IRelationalModel model, Mapping mapping)
                 Assert.False(customerTable.IsOptional(extraSpecialCustomerType));
             }
 
+            var orderTrigger = Assert.Single(orderType.GetTriggers());
+            Assert.Equal("Order_Trigger", orderTrigger.Name);
+            Assert.Equal("Order", orderTrigger.TableName);
+            Assert.Null(orderTrigger.TableSchema);
+
             var customerPk = specialCustomerType.FindPrimaryKey();
 
             if (mapping == Mapping.TPT)
@@ -1030,6 +1035,11 @@ private IRelationalModel CreateTestModel(bool mapToTables = false, bool mapToVie
                     {
                         ob.ToTable("Order");
                     }
+
+                    if (mapToTables || !mapToViews)
+                    {
+                        ob.ToTable(o => o.HasTrigger("Order_Trigger"));
+                    }
                 });
 
             modelBuilder.Entity<DateDetails>(
diff --git a/test/EFCore.Relational.Tests/Metadata/TriggerTest.cs b/test/EFCore.Relational.Tests/Metadata/TriggerTest.cs
new file mode 100644
index 0000000000..d4c5c3dc7c
--- /dev/null
+++ b/test/EFCore.Relational.Tests/Metadata/TriggerTest.cs
@@ -0,0 +1,102 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.EntityFrameworkCore.Metadata;
+
+public class TriggerTest
+{
+    [ConditionalFact]
+    public void Can_create_trigger_for_default_table()
+    {
+        var modelBuilder = CreateConventionModelBuilder();
+        var entityType = modelBuilder.Entity<Customer>().Metadata;
+
+        modelBuilder
+            .Entity<Customer>()
+            .ToTable(tb => tb.HasTrigger("Customer_Trigger"));
+
+        var trigger = entityType.FindTrigger("Customer_Trigger");
+
+        Assert.NotNull(trigger);
+        Assert.Same(entityType, trigger.EntityType);
+        Assert.Equal("Customer_Trigger", trigger.Name);
+        Assert.Equal("Customer", trigger.TableName);
+        Assert.Null(trigger.TableSchema);
+        Assert.Equal(ConfigurationSource.Explicit, ((IConventionTrigger)trigger).GetConfigurationSource());
+    }
+
+    [ConditionalFact]
+    public void Can_create_trigger_for_specific_table()
+    {
+        var modelBuilder = CreateConventionModelBuilder();
+        var entityType = modelBuilder.Entity<Customer>().Metadata;
+
+        modelBuilder
+            .Entity<Customer>()
+            .ToTable("CustomerTable", "dbo", tb => tb.HasTrigger("Customer_Trigger"));
+
+        var trigger = entityType.FindTrigger("Customer_Trigger");
+
+        Assert.NotNull(trigger);
+        Assert.Same(entityType, trigger.EntityType);
+        Assert.Equal("Customer_Trigger", trigger.Name);
+        Assert.Equal("CustomerTable", trigger.TableName);
+        Assert.Equal("dbo", trigger.TableSchema);
+        Assert.Equal(ConfigurationSource.Explicit, ((IConventionTrigger)trigger).GetConfigurationSource());
+    }
+
+    [ConditionalFact]
+    public void Create_trigger_on_unmapped_entity_type_throws()
+    {
+        var modelBuilder = CreateConventionModelBuilder();
+
+        var exception = Assert.Throws<InvalidOperationException>(() => modelBuilder
+            .Entity<Customer>()
+            .ToTable(null, tb => tb.HasTrigger("Customer_Trigger")));
+
+        Assert.Equal(RelationalStrings.TriggerOnUnmappedEntityType("Customer_Trigger", "Customer"), exception.Message);
+    }
+
+    [ConditionalFact]
+    public void AddTrigger_with_duplicate_names_throws_exception()
+    {
+        var entityTypeBuilder = CreateConventionModelBuilder().Entity<Customer>();
+        var entityType = entityTypeBuilder.Metadata;
+
+        entityType.AddTrigger("SomeTrigger", "SomeTable", null);
+
+        Assert.Equal(
+            RelationalStrings.DuplicateTrigger("SomeTrigger", entityType.DisplayName(), entityType.DisplayName()),
+            Assert.Throws<InvalidOperationException>(
+                () => entityType.AddTrigger("SomeTrigger", "SomeTable")).Message);
+    }
+
+    [ConditionalFact]
+    public void RemoveTrigger_returns_trigger_when_trigger_exists()
+    {
+        var entityTypeBuilder = CreateConventionModelBuilder().Entity<Customer>();
+        var entityType = entityTypeBuilder.Metadata;
+
+        var constraint = entityType.AddTrigger("SomeTrigger", "SomeTable");
+
+        Assert.Same(constraint, entityType.RemoveTrigger("SomeTrigger"));
+    }
+
+    [ConditionalFact]
+    public void RemoveTrigger_returns_null_when_trigger_is_missing()
+    {
+        var entityTypeBuilder = CreateConventionModelBuilder().Entity<Customer>();
+        var entityType = entityTypeBuilder.Metadata;
+
+        Assert.Null(entityType.RemoveTrigger("SomeTrigger"));
+    }
+
+    protected virtual ModelBuilder CreateConventionModelBuilder()
+        => RelationalTestHelpers.Instance.CreateConventionBuilder();
+
+    private class Customer
+    {
+        public int Id { get; set; }
+        public string Name { get; set; }
+    }
+}
diff --git a/test/EFCore.Relational.Tests/RelationalApiConsistencyTest.cs b/test/EFCore.Relational.Tests/RelationalApiConsistencyTest.cs
index 2e8d706a70..2116ad5afe 100644
--- a/test/EFCore.Relational.Tests/RelationalApiConsistencyTest.cs
+++ b/test/EFCore.Relational.Tests/RelationalApiConsistencyTest.cs
@@ -59,8 +59,14 @@ public class RelationalApiConsistencyFixture : ApiConsistencyFixtureBase
                 {
                     typeof(IReadOnlyCheckConstraint), (typeof(IMutableCheckConstraint),
                         typeof(IConventionCheckConstraint),
-                        null,
+                        typeof(IConventionCheckConstraintBuilder),
                         typeof(ICheckConstraint))
+                },
+                {
+                    typeof(IReadOnlyTrigger), (typeof(IMutableTrigger),
+                        typeof(IConventionTrigger),
+                        typeof(IConventionTriggerBuilder),
+                        typeof(ITrigger))
                 }
             };
 
@@ -81,7 +87,8 @@ public class RelationalApiConsistencyFixture : ApiConsistencyFixtureBase
             typeof(IViewColumnMapping),
             typeof(ITableIndex),
             typeof(IForeignKeyConstraint),
-            typeof(IUniqueConstraint)
+            typeof(IUniqueConstraint),
+            typeof(ITrigger)
         };
 
         public override HashSet<Type> FluentApiTypes { get; } = new()
diff --git a/test/EFCore.Relational.Tests/Update/UpdateSqlGeneratorTest.cs b/test/EFCore.Relational.Tests/Update/UpdateSqlGeneratorTest.cs
index 1cb1689789..825deece69 100644
--- a/test/EFCore.Relational.Tests/Update/UpdateSqlGeneratorTest.cs
+++ b/test/EFCore.Relational.Tests/Update/UpdateSqlGeneratorTest.cs
@@ -16,6 +16,48 @@ protected override IUpdateSqlGenerator CreateSqlGenerator()
                     TestServiceFactory.Instance.Create<TypeMappingSourceDependencies>(),
                     TestServiceFactory.Instance.Create<RelationalTypeMappingSourceDependencies>())));
 
+    protected override void AppendInsertOperation_insert_if_store_generated_columns_exist_verification(StringBuilder stringBuilder)
+        => AssertBaseline(
+            @"INSERT INTO ""dbo"".""Ducks"" (""Name"", ""Quacks"", ""ConcurrencyToken"")
+VALUES (@p0, @p1, @p2)
+RETURNING ""Id"", ""Computed"";
+",
+            stringBuilder.ToString());
+
+    protected override void AppendInsertOperation_for_store_generated_columns_but_no_identity_verification(
+        StringBuilder stringBuilder)
+        => AssertBaseline(
+            @"INSERT INTO ""dbo"".""Ducks"" (""Id"", ""Name"", ""Quacks"", ""ConcurrencyToken"")
+VALUES (@p0, @p1, @p2, @p3)
+RETURNING ""Computed"";
+",
+            stringBuilder.ToString());
+
+    protected override void AppendInsertOperation_for_only_identity_verification(StringBuilder stringBuilder)
+        => AssertBaseline(
+            @"INSERT INTO ""dbo"".""Ducks"" (""Name"", ""Quacks"", ""ConcurrencyToken"")
+VALUES (@p0, @p1, @p2)
+RETURNING ""Id"";
+",
+            stringBuilder.ToString());
+
+    protected override void AppendInsertOperation_for_all_store_generated_columns_verification(StringBuilder stringBuilder)
+        => AssertBaseline(
+            @"INSERT INTO ""dbo"".""Ducks""
+DEFAULT VALUES
+RETURNING ""Id"", ""Computed"";
+",
+            stringBuilder.ToString());
+
+    protected override void AppendInsertOperation_for_only_single_identity_columns_verification(
+        StringBuilder stringBuilder)
+        => AssertBaseline(
+            @"INSERT INTO ""dbo"".""Ducks""
+DEFAULT VALUES
+RETURNING ""Id"";
+",
+            stringBuilder.ToString());
+
     protected override TestHelpers TestHelpers
         => RelationalTestHelpers.Instance;
 
@@ -24,4 +66,7 @@ protected override string RowsAffected
 
     protected override string Identity
         => "provider_specific_identity()";
+
+    private void AssertBaseline(string expected, string actual)
+        => Assert.Equal(expected, actual, ignoreLineEndingDifferences: true);
 }
diff --git a/test/EFCore.SqlServer.FunctionalTests/DataAnnotationSqlServerTest.cs b/test/EFCore.SqlServer.FunctionalTests/DataAnnotationSqlServerTest.cs
index b2c5db89b7..77547e4d67 100644
--- a/test/EFCore.SqlServer.FunctionalTests/DataAnnotationSqlServerTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/DataAnnotationSqlServerTest.cs
@@ -195,12 +195,11 @@ public override void DatabaseGeneratedAttribute_autogenerates_values_when_set_to
 @p5='Third Name' (Size = 4000)
 @p6='0' (Nullable = true)
 
+SET IMPLICIT_TRANSACTIONS OFF;
 SET NOCOUNT ON;
 INSERT INTO [Sample] ([MaxLengthProperty], [Name], [RowVersion], [AdditionalDetails_Name], [AdditionalDetails_Value], [Details_Name], [Details_Value])
-VALUES (@p0, @p1, @p2, @p3, @p4, @p5, @p6);
-SELECT [Unique_No]
-FROM [Sample]
-WHERE @@ROWCOUNT = 1 AND [Unique_No] = scope_identity();");
+OUTPUT INSERTED.[Unique_No]
+VALUES (@p0, @p1, @p2, @p3, @p4, @p5, @p6);");
     }
 
     public override void MaxLengthAttribute_throws_while_inserting_value_longer_than_max_length()
@@ -216,12 +215,11 @@ public override void MaxLengthAttribute_throws_while_inserting_value_longer_than
 @p5='Third Name' (Size = 4000)
 @p6='0' (Nullable = true)
 
+SET IMPLICIT_TRANSACTIONS OFF;
 SET NOCOUNT ON;
 INSERT INTO [Sample] ([MaxLengthProperty], [Name], [RowVersion], [AdditionalDetails_Name], [AdditionalDetails_Value], [Details_Name], [Details_Value])
-VALUES (@p0, @p1, @p2, @p3, @p4, @p5, @p6);
-SELECT [Unique_No]
-FROM [Sample]
-WHERE @@ROWCOUNT = 1 AND [Unique_No] = scope_identity();",
+OUTPUT INSERTED.[Unique_No]
+VALUES (@p0, @p1, @p2, @p3, @p4, @p5, @p6);",
             //
             @"@p0='VeryVeryVeryVeryVeryVeryLongString' (Size = 4000)
 @p1='ValidString' (Nullable = false) (Size = 4000)
@@ -231,12 +229,11 @@ public override void MaxLengthAttribute_throws_while_inserting_value_longer_than
 @p5='Third Name' (Size = 4000)
 @p6='0' (Nullable = true)
 
+SET IMPLICIT_TRANSACTIONS OFF;
 SET NOCOUNT ON;
 INSERT INTO [Sample] ([MaxLengthProperty], [Name], [RowVersion], [AdditionalDetails_Name], [AdditionalDetails_Value], [Details_Name], [Details_Value])
-VALUES (@p0, @p1, @p2, @p3, @p4, @p5, @p6);
-SELECT [Unique_No]
-FROM [Sample]
-WHERE @@ROWCOUNT = 1 AND [Unique_No] = scope_identity();");
+OUTPUT INSERTED.[Unique_No]
+VALUES (@p0, @p1, @p2, @p3, @p4, @p5, @p6);");
     }
 
     public override void StringLengthAttribute_throws_while_inserting_value_longer_than_max_length()
@@ -246,21 +243,19 @@ public override void StringLengthAttribute_throws_while_inserting_value_longer_t
         AssertSql(
             @"@p0='ValidString' (Size = 16)
 
+SET IMPLICIT_TRANSACTIONS OFF;
 SET NOCOUNT ON;
 INSERT INTO [Two] ([Data])
-VALUES (@p0);
-SELECT [Id], [Timestamp]
-FROM [Two]
-WHERE @@ROWCOUNT = 1 AND [Id] = scope_identity();",
+OUTPUT INSERTED.[Id], INSERTED.[Timestamp]
+VALUES (@p0);",
             //
             @"@p0='ValidButLongString' (Size = 4000)
 
+SET IMPLICIT_TRANSACTIONS OFF;
 SET NOCOUNT ON;
 INSERT INTO [Two] ([Data])
-VALUES (@p0);
-SELECT [Id], [Timestamp]
-FROM [Two]
-WHERE @@ROWCOUNT = 1 AND [Id] = scope_identity();");
+OUTPUT INSERTED.[Id], INSERTED.[Timestamp]
+VALUES (@p0);");
     }
 
     public override void TimestampAttribute_throws_if_value_in_database_changed()
diff --git a/test/EFCore.SqlServer.FunctionalTests/Query/QueryBugsTest.cs b/test/EFCore.SqlServer.FunctionalTests/Query/QueryBugsTest.cs
index e1c16adb00..115f13931a 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Query/QueryBugsTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Query/QueryBugsTest.cs
@@ -3985,12 +3985,11 @@ public virtual async Task Multilevel_owned_entities_determine_correct_nullabilit
             AssertSql(
                 @"@p0='BaseEntity13079' (Nullable = false) (Size = 4000)
 
+SET IMPLICIT_TRANSACTIONS OFF;
 SET NOCOUNT ON;
 INSERT INTO [BaseEntities] ([Discriminator])
-VALUES (@p0);
-SELECT [Id]
-FROM [BaseEntities]
-WHERE @@ROWCOUNT = 1 AND [Id] = scope_identity();");
+OUTPUT INSERTED.[Id]
+VALUES (@p0);");
         }
     }
 
@@ -9134,8 +9133,8 @@ public virtual async Task Batch_insert_with_sqlvariant_different_types_12482()
 @p2='String Value' (Size = 12) (DbType = Object)
 @p3='2020-01-01T00:00:00.0000000' (Nullable = true) (DbType = Object)
 
+SET IMPLICIT_TRANSACTIONS OFF;
 SET NOCOUNT ON;
-DECLARE @inserted0 TABLE ([Id] int, [_Position] [int]);
 MERGE [BaseEntities] USING (
 VALUES (@p0, 0),
 (@p1, 1),
@@ -9144,11 +9143,7 @@ public virtual async Task Batch_insert_with_sqlvariant_different_types_12482()
 WHEN NOT MATCHED THEN
 INSERT ([Value])
 VALUES (i.[Value])
-OUTPUT INSERTED.[Id], i._Position
-INTO @inserted0;
-
-SELECT [i].[Id] FROM @inserted0 i
-ORDER BY [i].[_Position];");
+OUTPUT INSERTED.[Id], i._Position;");
         }
     }
 
diff --git a/test/EFCore.SqlServer.FunctionalTests/SqlServerEndToEndTest.cs b/test/EFCore.SqlServer.FunctionalTests/SqlServerEndToEndTest.cs
index 7bc0200958..b41d24206a 100644
--- a/test/EFCore.SqlServer.FunctionalTests/SqlServerEndToEndTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/SqlServerEndToEndTest.cs
@@ -707,13 +707,13 @@ public async Task Can_save_changes()
             Assert.Equal(EntityState.Unchanged, db.Entry(toAdd).State);
             Assert.DoesNotContain(toDelete, db.ChangeTracker.Entries().Select(e => e.Entity));
 
-            Assert.Equal(5, Fixture.TestSqlLoggerFactory.SqlStatements.Count);
+            Assert.Equal(4, Fixture.TestSqlLoggerFactory.SqlStatements.Count);
             Assert.Contains("SELECT", Fixture.TestSqlLoggerFactory.SqlStatements[0]);
             Assert.Contains("SELECT", Fixture.TestSqlLoggerFactory.SqlStatements[1]);
             Assert.Contains("@p0='" + deletedId, Fixture.TestSqlLoggerFactory.SqlStatements[2]);
             Assert.Contains("DELETE", Fixture.TestSqlLoggerFactory.SqlStatements[2]);
-            Assert.Contains("UPDATE", Fixture.TestSqlLoggerFactory.SqlStatements[3]);
-            Assert.Contains("INSERT", Fixture.TestSqlLoggerFactory.SqlStatements[4]);
+            Assert.Contains("UPDATE", Fixture.TestSqlLoggerFactory.SqlStatements[2]);
+            Assert.Contains("INSERT", Fixture.TestSqlLoggerFactory.SqlStatements[3]);
 
             var rows = await testDatabase.ExecuteScalarAsync<int>(
                 $"SELECT Count(*) FROM [dbo].[Blog] WHERE Id = {updatedId} AND Name = 'Blog is Updated'");
diff --git a/test/EFCore.SqlServer.FunctionalTests/SqlServerQueryTriggersTest.cs b/test/EFCore.SqlServer.FunctionalTests/SqlServerQueryTriggersTest.cs
index cff6e3c07b..24ed01dee0 100644
--- a/test/EFCore.SqlServer.FunctionalTests/SqlServerQueryTriggersTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/SqlServerQueryTriggersTest.cs
@@ -97,7 +97,7 @@ protected override void OnModelCreating(ModelBuilder modelBuilder)
                     eb.Property(e => e.StoreUpdated)
                         .HasDefaultValue(0)
                         .ValueGeneratedOnAddOrUpdate();
-                    eb.ToTable("UpdatedProducts");
+                    eb.ToTable("UpdatedProducts", tb => tb.HasTrigger("TRG_InsertUpdateProduct"));
                 });
     }
 
diff --git a/test/EFCore.SqlServer.FunctionalTests/SqlServerTriggersTest.cs b/test/EFCore.SqlServer.FunctionalTests/SqlServerTriggersTest.cs
index 6243605c77..344e5b10b1 100644
--- a/test/EFCore.SqlServer.FunctionalTests/SqlServerTriggersTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/SqlServerTriggersTest.cs
@@ -109,6 +109,12 @@ protected override void OnModelCreating(ModelBuilder modelBuilder)
             modelBuilder.Entity<Product>(
                 eb =>
                 {
+                    eb.ToTable(tb =>
+                    {
+                        tb.HasTrigger("TRG_InsertProduct");
+                        tb.HasTrigger("TRG_UpdateProduct");
+                        tb.HasTrigger("TRG_DeleteProduct");
+                    });
                     eb.Property(e => e.Version)
                         .ValueGeneratedOnAddOrUpdate()
                         .IsConcurrencyToken();
diff --git a/test/EFCore.SqlServer.FunctionalTests/SqlServerValueGenerationScenariosTest.cs b/test/EFCore.SqlServer.FunctionalTests/SqlServerValueGenerationScenariosTest.cs
index b37b7ada9c..ea50ad74e9 100644
--- a/test/EFCore.SqlServer.FunctionalTests/SqlServerValueGenerationScenariosTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/SqlServerValueGenerationScenariosTest.cs
@@ -1,6 +1,8 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using Microsoft.Data.SqlClient;
+using Microsoft.EntityFrameworkCore.SqlServer.Internal;
 using Microsoft.EntityFrameworkCore.ValueGeneration.Internal;
 using NetTopologySuite;
 using NetTopologySuite.Geometries;
@@ -792,6 +794,21 @@ protected override void OnModelCreating(ModelBuilder modelBuilder)
         }
     }
 
+    public class BlogContextComputedColumnWithTriggerMetadata : BlogContextComputedColumn
+    {
+        public BlogContextComputedColumnWithTriggerMetadata(string databaseName)
+            : base(databaseName)
+        {
+        }
+
+        protected override void OnModelCreating(ModelBuilder modelBuilder)
+        {
+            base.OnModelCreating(modelBuilder);
+
+            modelBuilder.Entity<FullNameBlog>().ToTable(tb => tb.HasTrigger("SomeTrigger"));
+        }
+    }
+
     // #6044
     [ConditionalFact]
     public void Insert_and_update_with_computed_column_with_function()
@@ -855,7 +872,7 @@ protected override void OnModelCreating(ModelBuilder modelBuilder)
     public void Insert_and_update_with_computed_column_with_querying_function()
     {
         using var testStore = SqlServerTestStore.CreateInitialized(DatabaseName);
-        using (var context = new BlogContextComputedColumn(testStore.Name))
+        using (var context = new BlogContextComputedColumnWithTriggerMetadata(testStore.Name))
         {
             context.GetService<IRelationalDatabaseCreator>().CreateTables();
 
@@ -875,7 +892,7 @@ RETURN @FullName
 
         try
         {
-            using (var context = new BlogContextComputedColumn(testStore.Name))
+            using (var context = new BlogContextComputedColumnWithTriggerMetadata(testStore.Name))
             {
                 var blog = context.Add(
                     new FullNameBlog { FirstName = "One", LastName = "Unicorn" }).Entity;
@@ -885,7 +902,7 @@ RETURN @FullName
                 Assert.Equal("OneUnicorn", blog.FullName);
             }
 
-            using (var context = new BlogContextComputedColumn(testStore.Name))
+            using (var context = new BlogContextComputedColumnWithTriggerMetadata(testStore.Name))
             {
                 var blog = context.FullNameBlogs.Single();
 
@@ -898,7 +915,7 @@ RETURN @FullName
                 Assert.Equal("OnePegasus", blog.FullName);
             }
 
-            using (var context = new BlogContextComputedColumn(testStore.Name))
+            using (var context = new BlogContextComputedColumnWithTriggerMetadata(testStore.Name))
             {
                 var blog1 = context.Add(
                     new FullNameBlog { FirstName = "Hank", LastName = "Unicorn" }).Entity;
@@ -913,12 +930,103 @@ RETURN @FullName
         }
         finally
         {
-            using var context = new BlogContextComputedColumn(testStore.Name);
+            using var context = new BlogContextComputedColumnWithTriggerMetadata(testStore.Name);
+            context.Database.ExecuteSqlRaw("ALTER TABLE dbo.FullNameBlogs DROP COLUMN FullName;");
+            context.Database.ExecuteSqlRaw("DROP FUNCTION [dbo].[GetFullName];");
+        }
+    }
+
+    [ConditionalTheory]
+    [MemberData(nameof(IsAsyncData))]
+    public async Task Insert_with_computed_column_with_function_without_metadata_configuration(bool async)
+    {
+        using var testStore = SqlServerTestStore.CreateInitialized(DatabaseName);
+        using (var context = new BlogContextComputedColumn(testStore.Name))
+        {
+            context.GetService<IRelationalDatabaseCreator>().CreateTables();
+
+            context.Database.ExecuteSqlRaw("ALTER TABLE dbo.FullNameBlogs DROP COLUMN FullName;");
+
+            context.Database.ExecuteSqlRaw(
+                @"CREATE FUNCTION [dbo].[GetFullName](@Id int)
+RETURNS nvarchar(max) WITH SCHEMABINDING AS
+BEGIN
+    DECLARE @FullName nvarchar(max);
+    SELECT @FullName = [FirstName] + [LastName] FROM [dbo].[FullNameBlogs] WHERE [Id] = @Id;
+    RETURN @FullName
+END");
+
+            context.Database.ExecuteSqlRaw("ALTER TABLE dbo.FullNameBlogs ADD FullName AS [dbo].[GetFullName]([Id]); ");
+        }
+
+        try
+        {
+            using (var context = new BlogContextComputedColumn(testStore.Name))
+            {
+                context.Add(new FullNameBlog());
+
+                var exception = async
+                    ? await Assert.ThrowsAsync<DbUpdateException>(() => context.SaveChangesAsync())
+                    : Assert.Throws<DbUpdateException>(() => context.SaveChanges());
+
+                Assert.Equal(SqlServerStrings.SaveChangesFailedBecauseOfComputedColumnWithFunction, exception.Message);
+
+                var sqlException = Assert.IsType<SqlException>(exception.InnerException);
+                Assert.Equal(4186, sqlException.Number);
+            }
+        }
+        finally
+        {
+            using var context = new BlogContextComputedColumnWithTriggerMetadata(testStore.Name);
             context.Database.ExecuteSqlRaw("ALTER TABLE dbo.FullNameBlogs DROP COLUMN FullName;");
             context.Database.ExecuteSqlRaw("DROP FUNCTION [dbo].[GetFullName];");
         }
     }
 
+    [ConditionalTheory]
+    [MemberData(nameof(IsAsyncData))]
+    public async Task Insert_with_trigger_without_metadata_configuration(bool async)
+    {
+        // Execute an insert against a table which has a trigger, but which haven't identified as such in our metadata.
+        // This causes a specialized exception to be thrown, directing users to the relevant docs.
+        using var testStore = SqlServerTestStore.CreateInitialized(DatabaseName);
+        using (var context = new BlogContextComputedColumn(testStore.Name))
+        {
+            context.GetService<IRelationalDatabaseCreator>().CreateTables();
+
+            context.Database.ExecuteSqlRaw(
+                @"CREATE OR ALTER TRIGGER [FullNameBlogs_Trigger]
+ON [FullNameBlogs]
+FOR INSERT, UPDATE, DELETE AS
+BEGIN
+	IF @@ROWCOUNT = 0
+		return
+END");
+        }
+
+        try
+        {
+            using (var context = new BlogContextComputedColumn(testStore.Name))
+            {
+                context.Add(new FullNameBlog());
+
+                var exception = async
+                    ? await Assert.ThrowsAsync<DbUpdateException>(() => context.SaveChangesAsync())
+                    : Assert.Throws<DbUpdateException>(() => context.SaveChanges());
+
+                Assert.Equal(SqlServerStrings.SaveChangesFailedBecauseOfTriggers, exception.Message);
+
+                var sqlException = Assert.IsType<SqlException>(exception.InnerException);
+                Assert.Equal(334, sqlException.Number);
+            }
+        }
+        finally
+        {
+            using var context = new BlogContextComputedColumn(testStore.Name);
+            context.Database.ExecuteSqlRaw("DROP TRIGGER [FullNameBlogs_Trigger]");
+        }
+    }
+
     [ConditionalFact]
     public void Insert_with_client_generated_GUID_key()
     {
@@ -1404,4 +1512,6 @@ protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
                     SqlServerTestStore.CreateConnectionString(_databaseName),
                     b => b.UseNetTopologySuite().ApplyConfiguration());
     }
+
+    public static IEnumerable<object[]> IsAsyncData = new[] { new object[] { false }, new object[] { true } };
 }
diff --git a/test/EFCore.SqlServer.FunctionalTests/Update/SqlServerUpdateSqlGeneratorTest.cs b/test/EFCore.SqlServer.FunctionalTests/Update/SqlServerUpdateSqlGeneratorTest.cs
index 6f426db087..2d18a03898 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Update/SqlServerUpdateSqlGeneratorTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Update/SqlServerUpdateSqlGeneratorTest.cs
@@ -31,75 +31,50 @@ public void AppendBatchHeader_should_append_SET_NOCOUNT_ON()
         Assert.Equal("SET NOCOUNT ON;" + Environment.NewLine, sb.ToString());
     }
 
-    protected override void AppendInsertOperation_appends_insert_and_select_store_generated_columns_but_no_identity_verification(
+    protected override void AppendInsertOperation_for_store_generated_columns_but_no_identity_verification(
         StringBuilder stringBuilder)
-        => Assert.Equal(
-            "INSERT INTO [dbo].[Ducks] ([Id], [Name], [Quacks], [ConcurrencyToken])"
-            + Environment.NewLine
-            + "VALUES (@p0, @p1, @p2, @p3);"
-            + Environment.NewLine
-            + "SELECT [Computed]"
-            + Environment.NewLine
-            + "FROM [dbo].[Ducks]"
-            + Environment.NewLine
-            + "WHERE @@ROWCOUNT = 1 AND [Id] = @p0;"
-            + Environment.NewLine
-            + Environment.NewLine,
+        => AssertBaseline(
+            @"INSERT INTO [dbo].[Ducks] ([Id], [Name], [Quacks], [ConcurrencyToken])
+OUTPUT INSERTED.[Computed]
+VALUES (@p0, @p1, @p2, @p3);
+",
             stringBuilder.ToString());
 
-    protected override void AppendInsertOperation_appends_insert_and_select_and_where_if_store_generated_columns_exist_verification(
-        StringBuilder stringBuilder)
-        => Assert.Equal(
-            "INSERT INTO [dbo].[Ducks] ([Name], [Quacks], [ConcurrencyToken])"
-            + Environment.NewLine
-            + "VALUES (@p0, @p1, @p2);"
-            + Environment.NewLine
-            + "SELECT [Id], [Computed]"
-            + Environment.NewLine
-            + "FROM [dbo].[Ducks]"
-            + Environment.NewLine
-            + "WHERE @@ROWCOUNT = 1 AND [Id] = scope_identity();"
-            + Environment.NewLine
-            + Environment.NewLine,
+    protected override void AppendInsertOperation_insert_if_store_generated_columns_exist_verification(StringBuilder stringBuilder)
+        => AssertBaseline(
+            @"INSERT INTO [dbo].[Ducks] ([Name], [Quacks], [ConcurrencyToken])
+OUTPUT INSERTED.[Id], INSERTED.[Computed]
+VALUES (@p0, @p1, @p2);
+",
             stringBuilder.ToString());
 
-    protected override void AppendInsertOperation_appends_insert_and_select_for_only_single_identity_columns_verification(
+    protected override void AppendInsertOperation_for_only_single_identity_columns_verification(
         StringBuilder stringBuilder)
         => AssertBaseline(
             @"INSERT INTO [dbo].[Ducks]
+OUTPUT INSERTED.[Id]
 DEFAULT VALUES;
-SELECT [Id]
-FROM [dbo].[Ducks]
-WHERE @@ROWCOUNT = 1 AND [Id] = scope_identity();
-
 ",
             stringBuilder.ToString());
 
-    protected override void AppendInsertOperation_appends_insert_and_select_for_only_identity_verification(StringBuilder stringBuilder)
+    protected override void AppendInsertOperation_for_only_identity_verification(StringBuilder stringBuilder)
         => AssertBaseline(
             @"INSERT INTO [dbo].[Ducks] ([Name], [Quacks], [ConcurrencyToken])
+OUTPUT INSERTED.[Id]
 VALUES (@p0, @p1, @p2);
-SELECT [Id]
-FROM [dbo].[Ducks]
-WHERE @@ROWCOUNT = 1 AND [Id] = scope_identity();
-
 ",
             stringBuilder.ToString());
 
-    protected override void AppendInsertOperation_appends_insert_and_select_for_all_store_generated_columns_verification(
-        StringBuilder stringBuilder)
+    protected override void AppendInsertOperation_for_all_store_generated_columns_verification(StringBuilder stringBuilder)
         => AssertBaseline(
             @"INSERT INTO [dbo].[Ducks]
+OUTPUT INSERTED.[Id], INSERTED.[Computed]
 DEFAULT VALUES;
-SELECT [Id], [Computed]
-FROM [dbo].[Ducks]
-WHERE @@ROWCOUNT = 1 AND [Id] = scope_identity();
-
 ",
             stringBuilder.ToString());
 
     [ConditionalFact]
-    public void AppendBulkInsertOperation_appends_insert_if_store_generated_columns_exist()
+    public void AppendBulkInsertOperation_appends_merge_if_store_generated_columns_exist()
     {
         var stringBuilder = new StringBuilder();
         var command = CreateInsertCommand();
@@ -108,20 +83,13 @@ public void AppendBulkInsertOperation_appends_insert_if_store_generated_columns_
         var grouping = sqlGenerator.AppendBulkInsertOperation(stringBuilder, new[] { command, command }, 0);
 
         AssertBaseline(
-            @"DECLARE @inserted0 TABLE ([Id] int, [_Position] [int]);
-MERGE [dbo].[Ducks] USING (
+            @"MERGE [dbo].[Ducks] USING (
 VALUES (@p0, @p1, @p2, 0),
 (@p0, @p1, @p2, 1)) AS i ([Name], [Quacks], [ConcurrencyToken], _Position) ON 1=0
 WHEN NOT MATCHED THEN
 INSERT ([Name], [Quacks], [ConcurrencyToken])
 VALUES (i.[Name], i.[Quacks], i.[ConcurrencyToken])
-OUTPUT INSERTED.[Id], i._Position
-INTO @inserted0;
-
-SELECT [t].[Id], [t].[Computed] FROM [dbo].[Ducks] t
-INNER JOIN @inserted0 i ON ([t].[Id] = [i].[Id])
-ORDER BY [i].[_Position];
-
+OUTPUT INSERTED.[Id], INSERTED.[Computed], i._Position;
 ",
             stringBuilder.ToString());
         Assert.Equal(ResultSetMapping.NotLastInResultSet, grouping);
@@ -178,12 +146,11 @@ public void AppendBulkInsertOperation_appends_insert_if_no_store_generated_colum
         var sqlGenerator = (ISqlServerUpdateSqlGenerator)CreateSqlGenerator();
         var grouping = sqlGenerator.AppendBulkInsertOperation(stringBuilder, new[] { command, command }, 0);
 
-        var expectedText = @"INSERT INTO [dbo].[Ducks]
-DEFAULT VALUES;
+        var expectedText = @"INSERT INTO [dbo].[Ducks] ([Computed])
+VALUES (DEFAULT),
+(DEFAULT);
 ";
-        AssertBaseline(
-            expectedText + expectedText,
-            stringBuilder.ToString());
+        AssertBaseline(expectedText, stringBuilder.ToString());
         Assert.Equal(ResultSetMapping.NoResultSet, grouping);
     }
 
diff --git a/test/EFCore.SqlServer.FunctionalTests/Update/StoreValueGenerationIdentitySqlServerTest.cs b/test/EFCore.SqlServer.FunctionalTests/Update/StoreValueGenerationIdentitySqlServerTest.cs
index 7bb46716dd..ec27e33ef3 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Update/StoreValueGenerationIdentitySqlServerTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Update/StoreValueGenerationIdentitySqlServerTest.cs
@@ -1,6 +1,8 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using Microsoft.EntityFrameworkCore.TestModels.StoreValueGenerationModel;
+
 namespace Microsoft.EntityFrameworkCore.Update;
 
 #nullable enable
@@ -17,12 +19,31 @@ public class StoreValueGenerationIdentitySqlServerTest : StoreValueGenerationTes
         // Fixture.TestSqlLoggerFactory.SetTestOutputHelper(testOutputHelper);
     }
 
-    protected override int ShouldExecuteInNumberOfCommands(
+    protected override bool ShouldCreateImplicitTransaction(
         EntityState firstOperationType,
         EntityState? secondOperationType,
         GeneratedValues generatedValues,
-        bool withDatabaseGenerated)
-        => secondOperationType is null ? 1 : 2;
+        bool withSameEntityType)
+    {
+        // Updates with generated values currently use SELECT to retrieve them, and so require transactions
+        if (firstOperationType == EntityState.Modified && generatedValues != GeneratedValues.None)
+        {
+            return true;
+        }
+
+        // For multiple operations, we specifically optimize multiple insertions of the same entity type with a single command (e.g. MERGE)
+        // (as long as there are writable columns)
+        if (firstOperationType is EntityState.Added
+            && secondOperationType is EntityState.Added
+            && withSameEntityType
+            && generatedValues != GeneratedValues.All)
+        {
+            return false;
+        }
+
+        // Other single operations should never be in a transaction (always executed in a single SQL command)
+        return secondOperationType is not null;
+    }
 
     #region Single operation
 
@@ -33,12 +54,11 @@ public override async Task Add_with_generated_values(bool async)
         AssertSql(
             @"@p0='1000'
 
+SET IMPLICIT_TRANSACTIONS OFF;
 SET NOCOUNT ON;
 INSERT INTO [WithSomeDatabaseGenerated] ([Data2])
-VALUES (@p0);
-SELECT [Id], [Data1]
-FROM [WithSomeDatabaseGenerated]
-WHERE @@ROWCOUNT = 1 AND [Id] = scope_identity();");
+OUTPUT INSERTED.[Id], INSERTED.[Data1]
+VALUES (@p0);");
     }
 
     public override async Task Add_with_no_generated_values(bool async)
@@ -61,12 +81,11 @@ public override async Task Add_with_all_generated_values(bool async)
         await base.Add_with_all_generated_values(async);
 
         AssertSql(
-            @"SET NOCOUNT ON;
+            @"SET IMPLICIT_TRANSACTIONS OFF;
+SET NOCOUNT ON;
 INSERT INTO [WithAllDatabaseGenerated]
-DEFAULT VALUES;
-SELECT [Id], [Data1], [Data2]
-FROM [WithAllDatabaseGenerated]
-WHERE @@ROWCOUNT = 1 AND [Id] = scope_identity();");
+OUTPUT INSERTED.[Id], INSERTED.[Data1], INSERTED.[Data2]
+DEFAULT VALUES;");
     }
 
     public override async Task Modify_with_generated_values(bool async)
@@ -125,22 +144,17 @@ public override async Task Add_Add_with_same_entity_type_and_generated_values(bo
 
         AssertSql(
             @"@p0='1000'
+@p1='1001'
 
+SET IMPLICIT_TRANSACTIONS OFF;
 SET NOCOUNT ON;
-INSERT INTO [WithSomeDatabaseGenerated] ([Data2])
-VALUES (@p0);
-SELECT [Id], [Data1]
-FROM [WithSomeDatabaseGenerated]
-WHERE @@ROWCOUNT = 1 AND [Id] = scope_identity();",
-            //
-            @"@p0='1001'
-
-SET NOCOUNT ON;
-INSERT INTO [WithSomeDatabaseGenerated] ([Data2])
-VALUES (@p0);
-SELECT [Id], [Data1]
-FROM [WithSomeDatabaseGenerated]
-WHERE @@ROWCOUNT = 1 AND [Id] = scope_identity();");
+MERGE [WithSomeDatabaseGenerated] USING (
+VALUES (@p0, 0),
+(@p1, 1)) AS i ([Data2], _Position) ON 1=0
+WHEN NOT MATCHED THEN
+INSERT ([Data2])
+VALUES (i.[Data2])
+OUTPUT INSERTED.[Id], INSERTED.[Data1], i._Position;");
     }
 
     public override async Task Add_Add_with_same_entity_type_and_no_generated_values(bool async)
@@ -151,20 +165,15 @@ public override async Task Add_Add_with_same_entity_type_and_no_generated_values
             @"@p0='100'
 @p1='1000'
 @p2='1000'
+@p3='101'
+@p4='1001'
+@p5='1001'
 
 SET IMPLICIT_TRANSACTIONS OFF;
 SET NOCOUNT ON;
 INSERT INTO [WithNoDatabaseGenerated] ([Id], [Data1], [Data2])
-VALUES (@p0, @p1, @p2);",
-            //
-            @"@p0='101'
-@p1='1001'
-@p2='1001'
-
-SET IMPLICIT_TRANSACTIONS OFF;
-SET NOCOUNT ON;
-INSERT INTO [WithNoDatabaseGenerated] ([Id], [Data1], [Data2])
-VALUES (@p0, @p1, @p2);");
+VALUES (@p0, @p1, @p2),
+(@p3, @p4, @p5);");
     }
 
     public override async Task Add_Add_with_same_entity_type_and_all_generated_values(bool async)
@@ -174,17 +183,11 @@ public override async Task Add_Add_with_same_entity_type_and_all_generated_value
         AssertSql(
             @"SET NOCOUNT ON;
 INSERT INTO [WithAllDatabaseGenerated]
+OUTPUT INSERTED.[Id], INSERTED.[Data1], INSERTED.[Data2]
 DEFAULT VALUES;
-SELECT [Id], [Data1], [Data2]
-FROM [WithAllDatabaseGenerated]
-WHERE @@ROWCOUNT = 1 AND [Id] = scope_identity();",
-            //
-            @"SET NOCOUNT ON;
 INSERT INTO [WithAllDatabaseGenerated]
-DEFAULT VALUES;
-SELECT [Id], [Data1], [Data2]
-FROM [WithAllDatabaseGenerated]
-WHERE @@ROWCOUNT = 1 AND [Id] = scope_identity();");
+OUTPUT INSERTED.[Id], INSERTED.[Data1], INSERTED.[Data2]
+DEFAULT VALUES;");
     }
 
     public override async Task Modify_Modify_with_same_entity_type_and_generated_values(bool async)
@@ -194,23 +197,21 @@ public override async Task Modify_Modify_with_same_entity_type_and_generated_val
         AssertSql(
             @"@p1='1'
 @p0='1000'
+@p3='2'
+@p2='1001'
 
 SET NOCOUNT ON;
 UPDATE [WithSomeDatabaseGenerated] SET [Data2] = @p0
 WHERE [Id] = @p1;
 SELECT [Data1]
 FROM [WithSomeDatabaseGenerated]
-WHERE @@ROWCOUNT = 1 AND [Id] = @p1;",
-            //
-            @"@p1='2'
-@p0='1001'
+WHERE @@ROWCOUNT = 1 AND [Id] = @p1;
 
-SET NOCOUNT ON;
-UPDATE [WithSomeDatabaseGenerated] SET [Data2] = @p0
-WHERE [Id] = @p1;
+UPDATE [WithSomeDatabaseGenerated] SET [Data2] = @p2
+WHERE [Id] = @p3;
 SELECT [Data1]
 FROM [WithSomeDatabaseGenerated]
-WHERE @@ROWCOUNT = 1 AND [Id] = @p1;");
+WHERE @@ROWCOUNT = 1 AND [Id] = @p3;");
     }
 
     public override async Task Modify_Modify_with_same_entity_type_and_no_generated_values(bool async)
@@ -221,21 +222,17 @@ public override async Task Modify_Modify_with_same_entity_type_and_no_generated_
             @"@p2='1'
 @p0='1000'
 @p1='1000'
+@p5='2'
+@p3='1001'
+@p4='1001'
 
-SET IMPLICIT_TRANSACTIONS OFF;
 SET NOCOUNT ON;
 UPDATE [WithNoDatabaseGenerated] SET [Data1] = @p0, [Data2] = @p1
 WHERE [Id] = @p2;
-SELECT @@ROWCOUNT;",
-            //
-            @"@p2='2'
-@p0='1001'
-@p1='1001'
+SELECT @@ROWCOUNT;
 
-SET IMPLICIT_TRANSACTIONS OFF;
-SET NOCOUNT ON;
-UPDATE [WithNoDatabaseGenerated] SET [Data1] = @p0, [Data2] = @p1
-WHERE [Id] = @p2;
+UPDATE [WithNoDatabaseGenerated] SET [Data1] = @p3, [Data2] = @p4
+WHERE [Id] = @p5;
 SELECT @@ROWCOUNT;");
     }
 
@@ -245,19 +242,15 @@ public override async Task Delete_Delete_with_same_entity_type(bool async)
 
         AssertSql(
             @"@p0='1'
+@p1='2'
 
-SET IMPLICIT_TRANSACTIONS OFF;
 SET NOCOUNT ON;
 DELETE FROM [WithSomeDatabaseGenerated]
 WHERE [Id] = @p0;
-SELECT @@ROWCOUNT;",
-            //
-            @"@p0='2'
+SELECT @@ROWCOUNT;
 
-SET IMPLICIT_TRANSACTIONS OFF;
-SET NOCOUNT ON;
 DELETE FROM [WithSomeDatabaseGenerated]
-WHERE [Id] = @p0;
+WHERE [Id] = @p1;
 SELECT @@ROWCOUNT;");
     }
 
@@ -271,22 +264,15 @@ public override async Task Add_Add_with_different_entity_types_and_generated_val
 
         AssertSql(
             @"@p0='1000'
+@p1='1001'
 
 SET NOCOUNT ON;
 INSERT INTO [WithSomeDatabaseGenerated] ([Data2])
+OUTPUT INSERTED.[Id], INSERTED.[Data1]
 VALUES (@p0);
-SELECT [Id], [Data1]
-FROM [WithSomeDatabaseGenerated]
-WHERE @@ROWCOUNT = 1 AND [Id] = scope_identity();",
-            //
-            @"@p0='1001'
-
-SET NOCOUNT ON;
 INSERT INTO [WithSomeDatabaseGenerated2] ([Data2])
-VALUES (@p0);
-SELECT [Id], [Data1]
-FROM [WithSomeDatabaseGenerated2]
-WHERE @@ROWCOUNT = 1 AND [Id] = scope_identity();");
+OUTPUT INSERTED.[Id], INSERTED.[Data1]
+VALUES (@p1);");
     }
 
     public override async Task Add_Add_with_different_entity_types_and_no_generated_values(bool async)
@@ -297,20 +283,15 @@ public override async Task Add_Add_with_different_entity_types_and_no_generated_
             @"@p0='100'
 @p1='1000'
 @p2='1000'
+@p3='101'
+@p4='1001'
+@p5='1001'
 
-SET IMPLICIT_TRANSACTIONS OFF;
 SET NOCOUNT ON;
 INSERT INTO [WithNoDatabaseGenerated] ([Id], [Data1], [Data2])
-VALUES (@p0, @p1, @p2);",
-            //
-            @"@p0='101'
-@p1='1001'
-@p2='1001'
-
-SET IMPLICIT_TRANSACTIONS OFF;
-SET NOCOUNT ON;
+VALUES (@p0, @p1, @p2);
 INSERT INTO [WithNoDatabaseGenerated2] ([Id], [Data1], [Data2])
-VALUES (@p0, @p1, @p2);");
+VALUES (@p3, @p4, @p5);");
     }
 
     public override async Task Add_Add_with_different_entity_types_and_all_generated_values(bool async)
@@ -320,17 +301,11 @@ public override async Task Add_Add_with_different_entity_types_and_all_generated
         AssertSql(
             @"SET NOCOUNT ON;
 INSERT INTO [WithAllDatabaseGenerated]
+OUTPUT INSERTED.[Id], INSERTED.[Data1], INSERTED.[Data2]
 DEFAULT VALUES;
-SELECT [Id], [Data1], [Data2]
-FROM [WithAllDatabaseGenerated]
-WHERE @@ROWCOUNT = 1 AND [Id] = scope_identity();",
-            //
-            @"SET NOCOUNT ON;
 INSERT INTO [WithAllDatabaseGenerated2]
-DEFAULT VALUES;
-SELECT [Id], [Data1], [Data2]
-FROM [WithAllDatabaseGenerated2]
-WHERE @@ROWCOUNT = 1 AND [Id] = scope_identity();");
+OUTPUT INSERTED.[Id], INSERTED.[Data1], INSERTED.[Data2]
+DEFAULT VALUES;");
     }
 
     public override async Task Modify_Modify_with_different_entity_types_and_generated_values(bool async)
@@ -340,23 +315,21 @@ public override async Task Modify_Modify_with_different_entity_types_and_generat
         AssertSql(
             @"@p1='1'
 @p0='1000'
+@p3='2'
+@p2='1001'
 
 SET NOCOUNT ON;
 UPDATE [WithSomeDatabaseGenerated] SET [Data2] = @p0
 WHERE [Id] = @p1;
 SELECT [Data1]
 FROM [WithSomeDatabaseGenerated]
-WHERE @@ROWCOUNT = 1 AND [Id] = @p1;",
-            //
-            @"@p1='2'
-@p0='1001'
+WHERE @@ROWCOUNT = 1 AND [Id] = @p1;
 
-SET NOCOUNT ON;
-UPDATE [WithSomeDatabaseGenerated2] SET [Data2] = @p0
-WHERE [Id] = @p1;
+UPDATE [WithSomeDatabaseGenerated2] SET [Data2] = @p2
+WHERE [Id] = @p3;
 SELECT [Data1]
 FROM [WithSomeDatabaseGenerated2]
-WHERE @@ROWCOUNT = 1 AND [Id] = @p1;");
+WHERE @@ROWCOUNT = 1 AND [Id] = @p3;");
     }
 
     public override async Task Modify_Modify_with_different_entity_types_and_no_generated_values(bool async)
@@ -366,21 +339,17 @@ public override async Task Modify_Modify_with_different_entity_types_and_no_gene
     @"@p2='1'
 @p0='1000'
 @p1='1000'
+@p5='2'
+@p3='1001'
+@p4='1001'
 
-SET IMPLICIT_TRANSACTIONS OFF;
 SET NOCOUNT ON;
 UPDATE [WithNoDatabaseGenerated] SET [Data1] = @p0, [Data2] = @p1
 WHERE [Id] = @p2;
-SELECT @@ROWCOUNT;",
-    //
-    @"@p2='2'
-@p0='1001'
-@p1='1001'
+SELECT @@ROWCOUNT;
 
-SET IMPLICIT_TRANSACTIONS OFF;
-SET NOCOUNT ON;
-UPDATE [WithNoDatabaseGenerated2] SET [Data1] = @p0, [Data2] = @p1
-WHERE [Id] = @p2;
+UPDATE [WithNoDatabaseGenerated2] SET [Data1] = @p3, [Data2] = @p4
+WHERE [Id] = @p5;
 SELECT @@ROWCOUNT;");
     }
 
@@ -390,19 +359,15 @@ public override async Task Delete_Delete_with_different_entity_types(bool async)
 
         AssertSql(
             @"@p0='1'
+@p1='2'
 
-SET IMPLICIT_TRANSACTIONS OFF;
 SET NOCOUNT ON;
 DELETE FROM [WithSomeDatabaseGenerated]
 WHERE [Id] = @p0;
-SELECT @@ROWCOUNT;",
-            //
-            @"@p0='2'
+SELECT @@ROWCOUNT;
 
-SET IMPLICIT_TRANSACTIONS OFF;
-SET NOCOUNT ON;
 DELETE FROM [WithSomeDatabaseGenerated2]
-WHERE [Id] = @p0;
+WHERE [Id] = @p1;
 SELECT @@ROWCOUNT;");
     }
 
diff --git a/test/EFCore.SqlServer.FunctionalTests/Update/StoreValueGenerationIdentityTriggerSqlServerTest.cs b/test/EFCore.SqlServer.FunctionalTests/Update/StoreValueGenerationIdentityTriggerSqlServerTest.cs
new file mode 100644
index 0000000000..2f2fb166ba
--- /dev/null
+++ b/test/EFCore.SqlServer.FunctionalTests/Update/StoreValueGenerationIdentityTriggerSqlServerTest.cs
@@ -0,0 +1,483 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.EntityFrameworkCore.Update;
+
+#nullable enable
+
+public class StoreValueGenerationIdentityTriggerSqlServerTest : StoreValueGenerationTriggerSqlServerTestBase<
+    StoreValueGenerationIdentityTriggerSqlServerTest.StoreValueGenerationIdentityWithTriggerSqlServerFixture>
+{
+    public StoreValueGenerationIdentityTriggerSqlServerTest(
+        StoreValueGenerationIdentityWithTriggerSqlServerFixture fixture,
+        ITestOutputHelper testOutputHelper)
+        : base(fixture)
+    {
+        Fixture.TestSqlLoggerFactory.Clear();
+        // Fixture.TestSqlLoggerFactory.SetTestOutputHelper(testOutputHelper);
+    }
+
+    protected override bool ShouldCreateImplicitTransaction(
+        EntityState firstOperationType,
+        EntityState? secondOperationType,
+        GeneratedValues generatedValues,
+        bool withSameEntityType)
+    {
+        // We have triggers, so any insert/update retrieving a database-generated value must be enclosed in a transaction
+        // (we use INSERT+SELECT or INSERT ... OUTPUT INTO+SELECT)
+        if (generatedValues is GeneratedValues.Some or GeneratedValues.All
+            && firstOperationType is EntityState.Added or EntityState.Modified)
+        {
+            return true;
+        }
+
+        if (secondOperationType is null)
+        {
+            return false;
+        }
+
+        // For multiple operations, we specifically optimize multiple insertions of the same entity type with a single MERGE.
+        return !(firstOperationType is EntityState.Added && secondOperationType is EntityState.Added && withSameEntityType);
+    }
+
+    #region Single operation
+
+    public override async Task Add_with_generated_values(bool async)
+    {
+        await base.Add_with_generated_values(async);
+
+        AssertSql(
+            @"@p0='1000'
+
+SET NOCOUNT ON;
+INSERT INTO [WithSomeDatabaseGenerated] ([Data2])
+VALUES (@p0);
+SELECT [Id], [Data1]
+FROM [WithSomeDatabaseGenerated]
+WHERE @@ROWCOUNT = 1 AND [Id] = scope_identity();");
+    }
+
+    public override async Task Add_with_no_generated_values(bool async)
+    {
+        await base.Add_with_no_generated_values(async);
+
+        AssertSql(
+            @"@p0='100'
+@p1='1000'
+@p2='1000'
+
+SET IMPLICIT_TRANSACTIONS OFF;
+SET NOCOUNT ON;
+INSERT INTO [WithNoDatabaseGenerated] ([Id], [Data1], [Data2])
+VALUES (@p0, @p1, @p2);");
+    }
+
+    public override async Task Add_with_all_generated_values(bool async)
+    {
+        await base.Add_with_all_generated_values(async);
+
+        AssertSql(
+            @"SET NOCOUNT ON;
+INSERT INTO [WithAllDatabaseGenerated]
+DEFAULT VALUES;
+SELECT [Id], [Data1], [Data2]
+FROM [WithAllDatabaseGenerated]
+WHERE @@ROWCOUNT = 1 AND [Id] = scope_identity();");
+    }
+
+    public override async Task Modify_with_generated_values(bool async)
+    {
+        await base.Modify_with_generated_values(async);
+
+        AssertSql(
+            @"@p1='1'
+@p0='1000'
+
+SET NOCOUNT ON;
+UPDATE [WithSomeDatabaseGenerated] SET [Data2] = @p0
+WHERE [Id] = @p1;
+SELECT [Data1]
+FROM [WithSomeDatabaseGenerated]
+WHERE @@ROWCOUNT = 1 AND [Id] = @p1;");
+    }
+
+    public override async Task Modify_with_no_generated_values(bool async)
+    {
+        await base.Modify_with_no_generated_values(async);
+
+        AssertSql(
+            @"@p2='1'
+@p0='1000'
+@p1='1000'
+
+SET IMPLICIT_TRANSACTIONS OFF;
+SET NOCOUNT ON;
+UPDATE [WithNoDatabaseGenerated] SET [Data1] = @p0, [Data2] = @p1
+WHERE [Id] = @p2;
+SELECT @@ROWCOUNT;");
+    }
+
+    public override async Task Delete(bool async)
+    {
+        await base.Delete(async);
+
+        AssertSql(
+            @"@p0='1'
+
+SET IMPLICIT_TRANSACTIONS OFF;
+SET NOCOUNT ON;
+DELETE FROM [WithSomeDatabaseGenerated]
+WHERE [Id] = @p0;
+SELECT @@ROWCOUNT;");
+    }
+
+    #endregion Single operation
+
+    #region Two operations with same entity type
+
+    public override async Task Add_Add_with_same_entity_type_and_generated_values(bool async)
+    {
+        await base.Add_Add_with_same_entity_type_and_generated_values(async);
+
+        AssertSql(
+            @"@p0='1000'
+@p1='1001'
+
+SET NOCOUNT ON;
+INSERT INTO [WithSomeDatabaseGenerated] ([Data2])
+VALUES (@p0);
+SELECT [Id], [Data1]
+FROM [WithSomeDatabaseGenerated]
+WHERE @@ROWCOUNT = 1 AND [Id] = scope_identity();
+
+INSERT INTO [WithSomeDatabaseGenerated] ([Data2])
+VALUES (@p1);
+SELECT [Id], [Data1]
+FROM [WithSomeDatabaseGenerated]
+WHERE @@ROWCOUNT = 1 AND [Id] = scope_identity();");
+    }
+
+    public override async Task Add_Add_with_same_entity_type_and_no_generated_values(bool async)
+    {
+        await base.Add_Add_with_same_entity_type_and_no_generated_values(async);
+
+        AssertSql(
+            @"@p0='100'
+@p1='1000'
+@p2='1000'
+@p3='101'
+@p4='1001'
+@p5='1001'
+
+SET IMPLICIT_TRANSACTIONS OFF;
+SET NOCOUNT ON;
+INSERT INTO [WithNoDatabaseGenerated] ([Id], [Data1], [Data2])
+VALUES (@p0, @p1, @p2),
+(@p3, @p4, @p5);");
+    }
+
+    public override async Task Add_Add_with_same_entity_type_and_all_generated_values(bool async)
+    {
+        await base.Add_Add_with_same_entity_type_and_all_generated_values(async);
+
+        AssertSql(
+            @"SET NOCOUNT ON;
+INSERT INTO [WithAllDatabaseGenerated]
+DEFAULT VALUES;
+SELECT [Id], [Data1], [Data2]
+FROM [WithAllDatabaseGenerated]
+WHERE @@ROWCOUNT = 1 AND [Id] = scope_identity();
+
+INSERT INTO [WithAllDatabaseGenerated]
+DEFAULT VALUES;
+SELECT [Id], [Data1], [Data2]
+FROM [WithAllDatabaseGenerated]
+WHERE @@ROWCOUNT = 1 AND [Id] = scope_identity();");
+    }
+
+    public override async Task Modify_Modify_with_same_entity_type_and_generated_values(bool async)
+    {
+        await base.Modify_Modify_with_same_entity_type_and_generated_values(async);
+
+        AssertSql(
+            @"@p1='1'
+@p0='1000'
+@p3='2'
+@p2='1001'
+
+SET NOCOUNT ON;
+UPDATE [WithSomeDatabaseGenerated] SET [Data2] = @p0
+WHERE [Id] = @p1;
+SELECT [Data1]
+FROM [WithSomeDatabaseGenerated]
+WHERE @@ROWCOUNT = 1 AND [Id] = @p1;
+
+UPDATE [WithSomeDatabaseGenerated] SET [Data2] = @p2
+WHERE [Id] = @p3;
+SELECT [Data1]
+FROM [WithSomeDatabaseGenerated]
+WHERE @@ROWCOUNT = 1 AND [Id] = @p3;");
+    }
+
+    public override async Task Modify_Modify_with_same_entity_type_and_no_generated_values(bool async)
+    {
+        await base.Modify_Modify_with_same_entity_type_and_no_generated_values(async);
+
+        AssertSql(
+            @"@p2='1'
+@p0='1000'
+@p1='1000'
+@p5='2'
+@p3='1001'
+@p4='1001'
+
+SET NOCOUNT ON;
+UPDATE [WithNoDatabaseGenerated] SET [Data1] = @p0, [Data2] = @p1
+WHERE [Id] = @p2;
+SELECT @@ROWCOUNT;
+
+UPDATE [WithNoDatabaseGenerated] SET [Data1] = @p3, [Data2] = @p4
+WHERE [Id] = @p5;
+SELECT @@ROWCOUNT;");
+    }
+
+    public override async Task Delete_Delete_with_same_entity_type(bool async)
+    {
+        await base.Delete_Delete_with_same_entity_type(async);
+
+        AssertSql(
+            @"@p0='1'
+@p1='2'
+
+SET NOCOUNT ON;
+DELETE FROM [WithSomeDatabaseGenerated]
+WHERE [Id] = @p0;
+SELECT @@ROWCOUNT;
+
+DELETE FROM [WithSomeDatabaseGenerated]
+WHERE [Id] = @p1;
+SELECT @@ROWCOUNT;");
+    }
+
+    #endregion Two operations with same entity type
+
+    #region Two operations with different entity types
+
+    public override async Task Add_Add_with_different_entity_types_and_generated_values(bool async)
+    {
+        await base.Add_Add_with_different_entity_types_and_generated_values(async);
+
+        AssertSql(
+            @"@p0='1000'
+@p1='1001'
+
+SET NOCOUNT ON;
+INSERT INTO [WithSomeDatabaseGenerated] ([Data2])
+VALUES (@p0);
+SELECT [Id], [Data1]
+FROM [WithSomeDatabaseGenerated]
+WHERE @@ROWCOUNT = 1 AND [Id] = scope_identity();
+
+INSERT INTO [WithSomeDatabaseGenerated2] ([Data2])
+VALUES (@p1);
+SELECT [Id], [Data1]
+FROM [WithSomeDatabaseGenerated2]
+WHERE @@ROWCOUNT = 1 AND [Id] = scope_identity();");
+    }
+
+    public override async Task Add_Add_with_different_entity_types_and_no_generated_values(bool async)
+    {
+        await base.Add_Add_with_different_entity_types_and_no_generated_values(async);
+
+        AssertSql(
+            @"@p0='100'
+@p1='1000'
+@p2='1000'
+@p3='101'
+@p4='1001'
+@p5='1001'
+
+SET NOCOUNT ON;
+INSERT INTO [WithNoDatabaseGenerated] ([Id], [Data1], [Data2])
+VALUES (@p0, @p1, @p2);
+INSERT INTO [WithNoDatabaseGenerated2] ([Id], [Data1], [Data2])
+VALUES (@p3, @p4, @p5);");
+    }
+
+    public override async Task Add_Add_with_different_entity_types_and_all_generated_values(bool async)
+    {
+        await base.Add_Add_with_different_entity_types_and_all_generated_values(async);
+
+        AssertSql(
+            @"SET NOCOUNT ON;
+INSERT INTO [WithAllDatabaseGenerated]
+DEFAULT VALUES;
+SELECT [Id], [Data1], [Data2]
+FROM [WithAllDatabaseGenerated]
+WHERE @@ROWCOUNT = 1 AND [Id] = scope_identity();
+
+INSERT INTO [WithAllDatabaseGenerated2]
+DEFAULT VALUES;
+SELECT [Id], [Data1], [Data2]
+FROM [WithAllDatabaseGenerated2]
+WHERE @@ROWCOUNT = 1 AND [Id] = scope_identity();");
+    }
+
+
+    public override async Task Modify_Modify_with_different_entity_types_and_generated_values(bool async)
+    {
+        await base.Modify_Modify_with_different_entity_types_and_generated_values(async);
+
+        AssertSql(
+            @"@p1='1'
+@p0='1000'
+@p3='2'
+@p2='1001'
+
+SET NOCOUNT ON;
+UPDATE [WithSomeDatabaseGenerated] SET [Data2] = @p0
+WHERE [Id] = @p1;
+SELECT [Data1]
+FROM [WithSomeDatabaseGenerated]
+WHERE @@ROWCOUNT = 1 AND [Id] = @p1;
+
+UPDATE [WithSomeDatabaseGenerated2] SET [Data2] = @p2
+WHERE [Id] = @p3;
+SELECT [Data1]
+FROM [WithSomeDatabaseGenerated2]
+WHERE @@ROWCOUNT = 1 AND [Id] = @p3;");
+    }
+
+    public override async Task Modify_Modify_with_different_entity_types_and_no_generated_values(bool async)
+    {
+        await base.Modify_Modify_with_different_entity_types_and_no_generated_values(async);
+
+        AssertSql(
+            @"@p2='1'
+@p0='1000'
+@p1='1000'
+@p5='2'
+@p3='1001'
+@p4='1001'
+
+SET NOCOUNT ON;
+UPDATE [WithNoDatabaseGenerated] SET [Data1] = @p0, [Data2] = @p1
+WHERE [Id] = @p2;
+SELECT @@ROWCOUNT;
+
+UPDATE [WithNoDatabaseGenerated2] SET [Data1] = @p3, [Data2] = @p4
+WHERE [Id] = @p5;
+SELECT @@ROWCOUNT;");
+    }
+
+    public override async Task Delete_Delete_with_different_entity_types(bool async)
+    {
+        await base.Delete_Delete_with_different_entity_types(async);
+
+        AssertSql(
+            @"@p0='1'
+@p1='2'
+
+SET NOCOUNT ON;
+DELETE FROM [WithSomeDatabaseGenerated]
+WHERE [Id] = @p0;
+SELECT @@ROWCOUNT;
+
+DELETE FROM [WithSomeDatabaseGenerated2]
+WHERE [Id] = @p1;
+SELECT @@ROWCOUNT;");
+    }
+
+    #endregion Two operations with different entity types
+
+    public override async Task Three_Add_use_batched_inserts(bool async)
+    {
+        await base.Three_Add_use_batched_inserts(async);
+
+        AssertSql(
+            @"@p0='0'
+@p1='0'
+@p2='0'
+
+SET NOCOUNT ON;
+INSERT INTO [WithSomeDatabaseGenerated] ([Data2])
+VALUES (@p0);
+SELECT [Id], [Data1]
+FROM [WithSomeDatabaseGenerated]
+WHERE @@ROWCOUNT = 1 AND [Id] = scope_identity();
+
+INSERT INTO [WithSomeDatabaseGenerated] ([Data2])
+VALUES (@p1);
+SELECT [Id], [Data1]
+FROM [WithSomeDatabaseGenerated]
+WHERE @@ROWCOUNT = 1 AND [Id] = scope_identity();
+
+INSERT INTO [WithSomeDatabaseGenerated] ([Data2])
+VALUES (@p2);
+SELECT [Id], [Data1]
+FROM [WithSomeDatabaseGenerated]
+WHERE @@ROWCOUNT = 1 AND [Id] = scope_identity();");
+    }
+
+    protected override async Task Test(
+        EntityState firstOperationType,
+        EntityState? secondOperationType,
+        GeneratedValues generatedValues,
+        bool async,
+        bool withSameEntityType = true)
+    {
+        await base.Test(firstOperationType, secondOperationType, generatedValues, async, withSameEntityType);
+
+        if (!ShouldCreateImplicitTransaction(firstOperationType, secondOperationType, generatedValues, withSameEntityType))
+        {
+            Assert.Contains("SET IMPLICIT_TRANSACTIONS OFF", Fixture.TestSqlLoggerFactory.SqlStatements[0]);
+        }
+    }
+
+    public class StoreValueGenerationIdentityWithTriggerSqlServerFixture : StoreValueGenerationTriggerSqlServerFixture
+    {
+        private string? _identityResetCommand;
+
+        protected override string StoreName { get; } = "StoreValueGenerationIdentityWithTriggerTest";
+
+        protected override ITestStoreFactory TestStoreFactory
+            => SqlServerTestStoreFactory.Instance;
+
+        public override void Reseed()
+        {
+            using var context = CreateContext();
+            Clean(context);
+            Seed(context);
+        }
+
+        protected override void Clean(DbContext context)
+        {
+            base.Clean(context);
+
+            // Reset the IDENTITY values since we assert on them
+            context.Database.ExecuteSqlRaw(GetIdentityResetCommand());
+        }
+
+        private string GetIdentityResetCommand()
+        {
+            if (_identityResetCommand is not null)
+            {
+                return _identityResetCommand;
+            }
+
+            var context = CreateContext();
+            var builder = new StringBuilder();
+
+            var tablesWithIdentity = context.Model.GetEntityTypes()
+                .Where(e => e.GetProperties().Any(p => p.GetValueGenerationStrategy() == SqlServerValueGenerationStrategy.IdentityColumn))
+                .Select(e => e.GetTableName());
+
+            foreach (var table in tablesWithIdentity)
+            {
+                builder.AppendLine($"DBCC CHECKIDENT ('{table}', RESEED, 0);");
+            }
+
+            return _identityResetCommand = builder.ToString();
+        }
+    }
+}
diff --git a/test/EFCore.SqlServer.FunctionalTests/Update/StoreValueGenerationSequenceSqlServerTest.cs b/test/EFCore.SqlServer.FunctionalTests/Update/StoreValueGenerationSequenceSqlServerTest.cs
index eb65ef829d..f56a6747fc 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Update/StoreValueGenerationSequenceSqlServerTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Update/StoreValueGenerationSequenceSqlServerTest.cs
@@ -19,12 +19,31 @@ public class StoreValueGenerationSequenceSqlServerTest : StoreValueGenerationTes
         // Fixture.TestSqlLoggerFactory.SetTestOutputHelper(testOutputHelper);
     }
 
-    protected override int ShouldExecuteInNumberOfCommands(
+    protected override bool ShouldCreateImplicitTransaction(
         EntityState firstOperationType,
         EntityState? secondOperationType,
         GeneratedValues generatedValues,
-        bool withDatabaseGenerated)
-        => secondOperationType is null ? 1 : 2;
+        bool withSameEntityType)
+    {
+        // Updates with generated values currently use SELECT to retrieve them, and so require transactions
+        if (firstOperationType == EntityState.Modified && generatedValues != GeneratedValues.None)
+        {
+            return true;
+        }
+
+        // For multiple operations, we specifically optimize multiple insertions of the same entity type with a single command (e.g. MERGE)
+        // (as long as there are writable columns)
+        if (firstOperationType is EntityState.Added
+            && secondOperationType is EntityState.Added
+            && withSameEntityType
+            && generatedValues != GeneratedValues.All)
+        {
+            return false;
+        }
+
+        // Other single operations should never be in a transaction (always executed in a single SQL command)
+        return secondOperationType is not null;
+    }
 
     #region Single operation
 
@@ -35,14 +54,11 @@ public override async Task Add_with_generated_values(bool async)
         AssertSql(
             @"@p0='1000'
 
+SET IMPLICIT_TRANSACTIONS OFF;
 SET NOCOUNT ON;
-DECLARE @inserted0 TABLE ([Id] int);
 INSERT INTO [WithSomeDatabaseGenerated] ([Data2])
-OUTPUT INSERTED.[Id]
-INTO @inserted0
-VALUES (@p0);
-SELECT [t].[Id], [t].[Data1] FROM [WithSomeDatabaseGenerated] t
-INNER JOIN @inserted0 i ON ([t].[Id] = [i].[Id]);");
+OUTPUT INSERTED.[Id], INSERTED.[Data1]
+VALUES (@p0);");
     }
 
     public override async Task Add_with_no_generated_values(bool async)
@@ -65,14 +81,11 @@ public override async Task Add_with_all_generated_values(bool async)
         await base.Add_with_all_generated_values(async);
 
         AssertSql(
-            @"SET NOCOUNT ON;
-DECLARE @inserted0 TABLE ([Id] int);
+            @"SET IMPLICIT_TRANSACTIONS OFF;
+SET NOCOUNT ON;
 INSERT INTO [WithAllDatabaseGenerated]
-OUTPUT INSERTED.[Id]
-INTO @inserted0
-DEFAULT VALUES;
-SELECT [t].[Id], [t].[Data1], [t].[Data2] FROM [WithAllDatabaseGenerated] t
-INNER JOIN @inserted0 i ON ([t].[Id] = [i].[Id]);");
+OUTPUT INSERTED.[Id], INSERTED.[Data1], INSERTED.[Data2]
+DEFAULT VALUES;");
     }
 
     public override async Task Modify_with_generated_values(bool async)
@@ -131,26 +144,17 @@ public override async Task Add_Add_with_same_entity_type_and_generated_values(bo
 
         AssertSql(
             @"@p0='1000'
+@p1='1001'
 
+SET IMPLICIT_TRANSACTIONS OFF;
 SET NOCOUNT ON;
-DECLARE @inserted0 TABLE ([Id] int);
-INSERT INTO [WithSomeDatabaseGenerated] ([Data2])
-OUTPUT INSERTED.[Id]
-INTO @inserted0
-VALUES (@p0);
-SELECT [t].[Id], [t].[Data1] FROM [WithSomeDatabaseGenerated] t
-INNER JOIN @inserted0 i ON ([t].[Id] = [i].[Id]);",
-            //
-            @"@p0='1001'
-
-SET NOCOUNT ON;
-DECLARE @inserted0 TABLE ([Id] int);
-INSERT INTO [WithSomeDatabaseGenerated] ([Data2])
-OUTPUT INSERTED.[Id]
-INTO @inserted0
-VALUES (@p0);
-SELECT [t].[Id], [t].[Data1] FROM [WithSomeDatabaseGenerated] t
-INNER JOIN @inserted0 i ON ([t].[Id] = [i].[Id]);");
+MERGE [WithSomeDatabaseGenerated] USING (
+VALUES (@p0, 0),
+(@p1, 1)) AS i ([Data2], _Position) ON 1=0
+WHEN NOT MATCHED THEN
+INSERT ([Data2])
+VALUES (i.[Data2])
+OUTPUT INSERTED.[Id], INSERTED.[Data1], i._Position;");
     }
 
     public override async Task Add_Add_with_same_entity_type_and_no_generated_values(bool async)
@@ -161,20 +165,15 @@ public override async Task Add_Add_with_same_entity_type_and_no_generated_values
             @"@p0='100'
 @p1='1000'
 @p2='1000'
+@p3='101'
+@p4='1001'
+@p5='1001'
 
 SET IMPLICIT_TRANSACTIONS OFF;
 SET NOCOUNT ON;
 INSERT INTO [WithNoDatabaseGenerated] ([Id], [Data1], [Data2])
-VALUES (@p0, @p1, @p2);",
-            //
-            @"@p0='101'
-@p1='1001'
-@p2='1001'
-
-SET IMPLICIT_TRANSACTIONS OFF;
-SET NOCOUNT ON;
-INSERT INTO [WithNoDatabaseGenerated] ([Id], [Data1], [Data2])
-VALUES (@p0, @p1, @p2);");
+VALUES (@p0, @p1, @p2),
+(@p3, @p4, @p5);");
     }
 
     public override async Task Add_Add_with_same_entity_type_and_all_generated_values(bool async)
@@ -184,19 +183,11 @@ public override async Task Add_Add_with_same_entity_type_and_all_generated_value
         AssertSql(
             @"SET NOCOUNT ON;
 DECLARE @inserted0 TABLE ([Id] int);
-INSERT INTO [WithAllDatabaseGenerated]
-OUTPUT INSERTED.[Id]
-INTO @inserted0
-DEFAULT VALUES;
-SELECT [t].[Id], [t].[Data1], [t].[Data2] FROM [WithAllDatabaseGenerated] t
-INNER JOIN @inserted0 i ON ([t].[Id] = [i].[Id]);",
-            //
-            @"SET NOCOUNT ON;
-DECLARE @inserted0 TABLE ([Id] int);
-INSERT INTO [WithAllDatabaseGenerated]
+INSERT INTO [WithAllDatabaseGenerated] ([Id])
 OUTPUT INSERTED.[Id]
 INTO @inserted0
-DEFAULT VALUES;
+VALUES (DEFAULT),
+(DEFAULT);
 SELECT [t].[Id], [t].[Data1], [t].[Data2] FROM [WithAllDatabaseGenerated] t
 INNER JOIN @inserted0 i ON ([t].[Id] = [i].[Id]);");
     }
@@ -208,23 +199,21 @@ public override async Task Modify_Modify_with_same_entity_type_and_generated_val
         AssertSql(
             @"@p1='5'
 @p0='1000'
+@p3='6'
+@p2='1001'
 
 SET NOCOUNT ON;
 UPDATE [WithSomeDatabaseGenerated] SET [Data2] = @p0
 WHERE [Id] = @p1;
 SELECT [Data1]
 FROM [WithSomeDatabaseGenerated]
-WHERE @@ROWCOUNT = 1 AND [Id] = @p1;",
-            //
-            @"@p1='6'
-@p0='1001'
+WHERE @@ROWCOUNT = 1 AND [Id] = @p1;
 
-SET NOCOUNT ON;
-UPDATE [WithSomeDatabaseGenerated] SET [Data2] = @p0
-WHERE [Id] = @p1;
+UPDATE [WithSomeDatabaseGenerated] SET [Data2] = @p2
+WHERE [Id] = @p3;
 SELECT [Data1]
 FROM [WithSomeDatabaseGenerated]
-WHERE @@ROWCOUNT = 1 AND [Id] = @p1;");
+WHERE @@ROWCOUNT = 1 AND [Id] = @p3;");
     }
 
     public override async Task Modify_Modify_with_same_entity_type_and_no_generated_values(bool async)
@@ -235,21 +224,17 @@ public override async Task Modify_Modify_with_same_entity_type_and_no_generated_
             @"@p2='1'
 @p0='1000'
 @p1='1000'
+@p5='2'
+@p3='1001'
+@p4='1001'
 
-SET IMPLICIT_TRANSACTIONS OFF;
 SET NOCOUNT ON;
 UPDATE [WithNoDatabaseGenerated] SET [Data1] = @p0, [Data2] = @p1
 WHERE [Id] = @p2;
-SELECT @@ROWCOUNT;",
-            //
-            @"@p2='2'
-@p0='1001'
-@p1='1001'
+SELECT @@ROWCOUNT;
 
-SET IMPLICIT_TRANSACTIONS OFF;
-SET NOCOUNT ON;
-UPDATE [WithNoDatabaseGenerated] SET [Data1] = @p0, [Data2] = @p1
-WHERE [Id] = @p2;
+UPDATE [WithNoDatabaseGenerated] SET [Data1] = @p3, [Data2] = @p4
+WHERE [Id] = @p5;
 SELECT @@ROWCOUNT;");
     }
 
@@ -259,19 +244,15 @@ public override async Task Delete_Delete_with_same_entity_type(bool async)
 
         AssertSql(
             @"@p0='5'
+@p1='6'
 
-SET IMPLICIT_TRANSACTIONS OFF;
 SET NOCOUNT ON;
 DELETE FROM [WithSomeDatabaseGenerated]
 WHERE [Id] = @p0;
-SELECT @@ROWCOUNT;",
-            //
-            @"@p0='6'
+SELECT @@ROWCOUNT;
 
-SET IMPLICIT_TRANSACTIONS OFF;
-SET NOCOUNT ON;
 DELETE FROM [WithSomeDatabaseGenerated]
-WHERE [Id] = @p0;
+WHERE [Id] = @p1;
 SELECT @@ROWCOUNT;");
     }
 
@@ -285,26 +266,15 @@ public override async Task Add_Add_with_different_entity_types_and_generated_val
 
         AssertSql(
             @"@p0='1000'
+@p1='1001'
 
 SET NOCOUNT ON;
-DECLARE @inserted0 TABLE ([Id] int);
 INSERT INTO [WithSomeDatabaseGenerated] ([Data2])
-OUTPUT INSERTED.[Id]
-INTO @inserted0
+OUTPUT INSERTED.[Id], INSERTED.[Data1]
 VALUES (@p0);
-SELECT [t].[Id], [t].[Data1] FROM [WithSomeDatabaseGenerated] t
-INNER JOIN @inserted0 i ON ([t].[Id] = [i].[Id]);",
-            //
-            @"@p0='1001'
-
-SET NOCOUNT ON;
-DECLARE @inserted0 TABLE ([Id] int);
 INSERT INTO [WithSomeDatabaseGenerated2] ([Data2])
-OUTPUT INSERTED.[Id]
-INTO @inserted0
-VALUES (@p0);
-SELECT [t].[Id], [t].[Data1] FROM [WithSomeDatabaseGenerated2] t
-INNER JOIN @inserted0 i ON ([t].[Id] = [i].[Id]);");
+OUTPUT INSERTED.[Id], INSERTED.[Data1]
+VALUES (@p1);");
     }
 
     public override async Task Add_Add_with_different_entity_types_and_no_generated_values(bool async)
@@ -315,20 +285,15 @@ public override async Task Add_Add_with_different_entity_types_and_no_generated_
             @"@p0='100'
 @p1='1000'
 @p2='1000'
+@p3='101'
+@p4='1001'
+@p5='1001'
 
-SET IMPLICIT_TRANSACTIONS OFF;
 SET NOCOUNT ON;
 INSERT INTO [WithNoDatabaseGenerated] ([Id], [Data1], [Data2])
-VALUES (@p0, @p1, @p2);",
-            //
-            @"@p0='101'
-@p1='1001'
-@p2='1001'
-
-SET IMPLICIT_TRANSACTIONS OFF;
-SET NOCOUNT ON;
+VALUES (@p0, @p1, @p2);
 INSERT INTO [WithNoDatabaseGenerated2] ([Id], [Data1], [Data2])
-VALUES (@p0, @p1, @p2);");
+VALUES (@p3, @p4, @p5);");
     }
 
     public override async Task Add_Add_with_different_entity_types_and_all_generated_values(bool async)
@@ -337,22 +302,12 @@ public override async Task Add_Add_with_different_entity_types_and_all_generated
 
         AssertSql(
             @"SET NOCOUNT ON;
-DECLARE @inserted0 TABLE ([Id] int);
 INSERT INTO [WithAllDatabaseGenerated]
-OUTPUT INSERTED.[Id]
-INTO @inserted0
+OUTPUT INSERTED.[Id], INSERTED.[Data1], INSERTED.[Data2]
 DEFAULT VALUES;
-SELECT [t].[Id], [t].[Data1], [t].[Data2] FROM [WithAllDatabaseGenerated] t
-INNER JOIN @inserted0 i ON ([t].[Id] = [i].[Id]);",
-            //
-            @"SET NOCOUNT ON;
-DECLARE @inserted0 TABLE ([Id] int);
 INSERT INTO [WithAllDatabaseGenerated2]
-OUTPUT INSERTED.[Id]
-INTO @inserted0
-DEFAULT VALUES;
-SELECT [t].[Id], [t].[Data1], [t].[Data2] FROM [WithAllDatabaseGenerated2] t
-INNER JOIN @inserted0 i ON ([t].[Id] = [i].[Id]);");
+OUTPUT INSERTED.[Id], INSERTED.[Data1], INSERTED.[Data2]
+DEFAULT VALUES;");
     }
 
     public override async Task Modify_Modify_with_different_entity_types_and_generated_values(bool async)
@@ -362,23 +317,21 @@ public override async Task Modify_Modify_with_different_entity_types_and_generat
         AssertSql(
             @"@p1='5'
 @p0='1000'
+@p3='8'
+@p2='1001'
 
 SET NOCOUNT ON;
 UPDATE [WithSomeDatabaseGenerated] SET [Data2] = @p0
 WHERE [Id] = @p1;
 SELECT [Data1]
 FROM [WithSomeDatabaseGenerated]
-WHERE @@ROWCOUNT = 1 AND [Id] = @p1;",
-            //
-            @"@p1='8'
-@p0='1001'
+WHERE @@ROWCOUNT = 1 AND [Id] = @p1;
 
-SET NOCOUNT ON;
-UPDATE [WithSomeDatabaseGenerated2] SET [Data2] = @p0
-WHERE [Id] = @p1;
+UPDATE [WithSomeDatabaseGenerated2] SET [Data2] = @p2
+WHERE [Id] = @p3;
 SELECT [Data1]
 FROM [WithSomeDatabaseGenerated2]
-WHERE @@ROWCOUNT = 1 AND [Id] = @p1;");
+WHERE @@ROWCOUNT = 1 AND [Id] = @p3;");
     }
 
     public override async Task Modify_Modify_with_different_entity_types_and_no_generated_values(bool async)
@@ -388,21 +341,17 @@ public override async Task Modify_Modify_with_different_entity_types_and_no_gene
     @"@p2='1'
 @p0='1000'
 @p1='1000'
+@p5='2'
+@p3='1001'
+@p4='1001'
 
-SET IMPLICIT_TRANSACTIONS OFF;
 SET NOCOUNT ON;
 UPDATE [WithNoDatabaseGenerated] SET [Data1] = @p0, [Data2] = @p1
 WHERE [Id] = @p2;
-SELECT @@ROWCOUNT;",
-    //
-    @"@p2='2'
-@p0='1001'
-@p1='1001'
+SELECT @@ROWCOUNT;
 
-SET IMPLICIT_TRANSACTIONS OFF;
-SET NOCOUNT ON;
-UPDATE [WithNoDatabaseGenerated2] SET [Data1] = @p0, [Data2] = @p1
-WHERE [Id] = @p2;
+UPDATE [WithNoDatabaseGenerated2] SET [Data1] = @p3, [Data2] = @p4
+WHERE [Id] = @p5;
 SELECT @@ROWCOUNT;");
     }
 
@@ -412,19 +361,15 @@ public override async Task Delete_Delete_with_different_entity_types(bool async)
 
         AssertSql(
             @"@p0='5'
+@p1='8'
 
-SET IMPLICIT_TRANSACTIONS OFF;
 SET NOCOUNT ON;
 DELETE FROM [WithSomeDatabaseGenerated]
 WHERE [Id] = @p0;
-SELECT @@ROWCOUNT;",
-            //
-            @"@p0='8'
+SELECT @@ROWCOUNT;
 
-SET IMPLICIT_TRANSACTIONS OFF;
-SET NOCOUNT ON;
 DELETE FROM [WithSomeDatabaseGenerated2]
-WHERE [Id] = @p0;
+WHERE [Id] = @p1;
 SELECT @@ROWCOUNT;");
     }
 
diff --git a/test/EFCore.SqlServer.FunctionalTests/Update/StoreValueGenerationSequenceTriggerSqlServerTest.cs b/test/EFCore.SqlServer.FunctionalTests/Update/StoreValueGenerationSequenceTriggerSqlServerTest.cs
new file mode 100644
index 0000000000..8c1d5e85ce
--- /dev/null
+++ b/test/EFCore.SqlServer.FunctionalTests/Update/StoreValueGenerationSequenceTriggerSqlServerTest.cs
@@ -0,0 +1,491 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.Data.SqlClient;
+using Microsoft.EntityFrameworkCore.SqlServer.Internal;
+using Microsoft.EntityFrameworkCore.TestModels.StoreValueGenerationModel;
+
+namespace Microsoft.EntityFrameworkCore.Update;
+
+#nullable enable
+
+public class StoreValueGenerationSequenceTriggerSqlServerTest : StoreValueGenerationTriggerSqlServerTestBase<
+    StoreValueGenerationSequenceTriggerSqlServerTest.StoreValueGenerationSequenceWithTriggerSqlServerFixture>
+{
+    public StoreValueGenerationSequenceTriggerSqlServerTest(
+        StoreValueGenerationSequenceWithTriggerSqlServerFixture fixture,
+        ITestOutputHelper testOutputHelper)
+        : base(fixture)
+    {
+        Fixture.TestSqlLoggerFactory.Clear();
+        // Fixture.TestSqlLoggerFactory.SetTestOutputHelper(testOutputHelper);
+    }
+
+    protected override bool ShouldCreateImplicitTransaction(
+        EntityState firstOperationType,
+        EntityState? secondOperationType,
+        GeneratedValues generatedValues,
+        bool withSameEntityType)
+    {
+        // We have triggers, so any insert/update retrieving a database-generated value must be enclosed in a transaction
+        // (we use INSERT+SELECT or INSERT ... OUTPUT INTO+SELECT)
+        if (generatedValues is GeneratedValues.Some or GeneratedValues.All
+            && firstOperationType is EntityState.Added or EntityState.Modified)
+        {
+            return true;
+        }
+
+        if (secondOperationType is null)
+        {
+            return false;
+        }
+
+        // For multiple operations, we specifically optimize multiple insertions of the same entity type with a single MERGE.
+        return !(firstOperationType is EntityState.Added && secondOperationType is EntityState.Added && withSameEntityType);
+    }
+
+    #region Single operation
+
+    public override async Task Add_with_generated_values(bool async)
+    {
+        await base.Add_with_generated_values(async);
+
+        AssertSql(
+            @"@p0='1000'
+
+SET NOCOUNT ON;
+DECLARE @inserted0 TABLE ([Id] int);
+INSERT INTO [WithSomeDatabaseGenerated] ([Data2])
+OUTPUT INSERTED.[Id]
+INTO @inserted0
+VALUES (@p0);
+SELECT [t].[Id], [t].[Data1] FROM [WithSomeDatabaseGenerated] t
+INNER JOIN @inserted0 i ON ([t].[Id] = [i].[Id]);");
+    }
+
+    public override async Task Add_with_no_generated_values(bool async)
+    {
+        await base.Add_with_no_generated_values(async);
+
+        AssertSql(
+            @"@p0='100'
+@p1='1000'
+@p2='1000'
+
+SET IMPLICIT_TRANSACTIONS OFF;
+SET NOCOUNT ON;
+INSERT INTO [WithNoDatabaseGenerated] ([Id], [Data1], [Data2])
+VALUES (@p0, @p1, @p2);");
+    }
+
+    public override async Task Add_with_all_generated_values(bool async)
+    {
+        await base.Add_with_all_generated_values(async);
+
+        AssertSql(
+            @"SET NOCOUNT ON;
+DECLARE @inserted0 TABLE ([Id] int);
+INSERT INTO [WithAllDatabaseGenerated]
+OUTPUT INSERTED.[Id]
+INTO @inserted0
+DEFAULT VALUES;
+SELECT [t].[Id], [t].[Data1], [t].[Data2] FROM [WithAllDatabaseGenerated] t
+INNER JOIN @inserted0 i ON ([t].[Id] = [i].[Id]);");
+    }
+
+    public override async Task Modify_with_generated_values(bool async)
+    {
+        await base.Modify_with_generated_values(async);
+
+        AssertSql(
+            @"@p1='5'
+@p0='1000'
+
+SET NOCOUNT ON;
+UPDATE [WithSomeDatabaseGenerated] SET [Data2] = @p0
+WHERE [Id] = @p1;
+SELECT [Data1]
+FROM [WithSomeDatabaseGenerated]
+WHERE @@ROWCOUNT = 1 AND [Id] = @p1;");
+    }
+
+    public override async Task Modify_with_no_generated_values(bool async)
+    {
+        await base.Modify_with_no_generated_values(async);
+
+        AssertSql(
+            @"@p2='1'
+@p0='1000'
+@p1='1000'
+
+SET IMPLICIT_TRANSACTIONS OFF;
+SET NOCOUNT ON;
+UPDATE [WithNoDatabaseGenerated] SET [Data1] = @p0, [Data2] = @p1
+WHERE [Id] = @p2;
+SELECT @@ROWCOUNT;");
+    }
+
+    public override async Task Delete(bool async)
+    {
+        await base.Delete(async);
+
+        AssertSql(
+            @"@p0='5'
+
+SET IMPLICIT_TRANSACTIONS OFF;
+SET NOCOUNT ON;
+DELETE FROM [WithSomeDatabaseGenerated]
+WHERE [Id] = @p0;
+SELECT @@ROWCOUNT;");
+    }
+
+    #endregion Single operation
+
+    #region Two operations with same entity type
+
+    public override async Task Add_Add_with_same_entity_type_and_generated_values(bool async)
+    {
+        await base.Add_Add_with_same_entity_type_and_generated_values(async);
+
+        AssertSql(
+            @"@p0='1000'
+@p1='1001'
+
+SET NOCOUNT ON;
+DECLARE @inserted0 TABLE ([Id] int, [_Position] [int]);
+MERGE [WithSomeDatabaseGenerated] USING (
+VALUES (@p0, 0),
+(@p1, 1)) AS i ([Data2], _Position) ON 1=0
+WHEN NOT MATCHED THEN
+INSERT ([Data2])
+VALUES (i.[Data2])
+OUTPUT INSERTED.[Id], i._Position
+INTO @inserted0;
+
+SELECT [t].[Id], [t].[Data1] FROM [WithSomeDatabaseGenerated] t
+INNER JOIN @inserted0 i ON ([t].[Id] = [i].[Id])
+ORDER BY [i].[_Position];");
+    }
+
+    public override async Task Add_Add_with_same_entity_type_and_no_generated_values(bool async)
+    {
+        await base.Add_Add_with_same_entity_type_and_no_generated_values(async);
+
+        AssertSql(
+            @"@p0='100'
+@p1='1000'
+@p2='1000'
+@p3='101'
+@p4='1001'
+@p5='1001'
+
+SET IMPLICIT_TRANSACTIONS OFF;
+SET NOCOUNT ON;
+INSERT INTO [WithNoDatabaseGenerated] ([Id], [Data1], [Data2])
+VALUES (@p0, @p1, @p2),
+(@p3, @p4, @p5);");
+    }
+
+    public override async Task Add_Add_with_same_entity_type_and_all_generated_values(bool async)
+    {
+        await base.Add_Add_with_same_entity_type_and_all_generated_values(async);
+
+        AssertSql(
+            @"SET NOCOUNT ON;
+DECLARE @inserted0 TABLE ([Id] int);
+INSERT INTO [WithAllDatabaseGenerated] ([Id])
+OUTPUT INSERTED.[Id]
+INTO @inserted0
+VALUES (DEFAULT),
+(DEFAULT);
+SELECT [t].[Id], [t].[Data1], [t].[Data2] FROM [WithAllDatabaseGenerated] t
+INNER JOIN @inserted0 i ON ([t].[Id] = [i].[Id]);");
+    }
+
+    public override async Task Modify_Modify_with_same_entity_type_and_generated_values(bool async)
+    {
+        await base.Modify_Modify_with_same_entity_type_and_generated_values(async);
+
+        AssertSql(
+            @"@p1='5'
+@p0='1000'
+@p3='6'
+@p2='1001'
+
+SET NOCOUNT ON;
+UPDATE [WithSomeDatabaseGenerated] SET [Data2] = @p0
+WHERE [Id] = @p1;
+SELECT [Data1]
+FROM [WithSomeDatabaseGenerated]
+WHERE @@ROWCOUNT = 1 AND [Id] = @p1;
+
+UPDATE [WithSomeDatabaseGenerated] SET [Data2] = @p2
+WHERE [Id] = @p3;
+SELECT [Data1]
+FROM [WithSomeDatabaseGenerated]
+WHERE @@ROWCOUNT = 1 AND [Id] = @p3;");
+    }
+
+    public override async Task Modify_Modify_with_same_entity_type_and_no_generated_values(bool async)
+    {
+        await base.Modify_Modify_with_same_entity_type_and_no_generated_values(async);
+
+        AssertSql(
+            @"@p2='1'
+@p0='1000'
+@p1='1000'
+@p5='2'
+@p3='1001'
+@p4='1001'
+
+SET NOCOUNT ON;
+UPDATE [WithNoDatabaseGenerated] SET [Data1] = @p0, [Data2] = @p1
+WHERE [Id] = @p2;
+SELECT @@ROWCOUNT;
+
+UPDATE [WithNoDatabaseGenerated] SET [Data1] = @p3, [Data2] = @p4
+WHERE [Id] = @p5;
+SELECT @@ROWCOUNT;");
+    }
+
+    public override async Task Delete_Delete_with_same_entity_type(bool async)
+    {
+        await base.Delete_Delete_with_same_entity_type(async);
+
+        AssertSql(
+            @"@p0='5'
+@p1='6'
+
+SET NOCOUNT ON;
+DELETE FROM [WithSomeDatabaseGenerated]
+WHERE [Id] = @p0;
+SELECT @@ROWCOUNT;
+
+DELETE FROM [WithSomeDatabaseGenerated]
+WHERE [Id] = @p1;
+SELECT @@ROWCOUNT;");
+    }
+
+    #endregion Two operations with same entity type
+
+    #region Two operations with different entity types
+
+    public override async Task Add_Add_with_different_entity_types_and_generated_values(bool async)
+    {
+        await base.Add_Add_with_different_entity_types_and_generated_values(async);
+
+        AssertSql(
+            @"@p0='1000'
+@p1='1001'
+
+SET NOCOUNT ON;
+DECLARE @inserted0 TABLE ([Id] int);
+INSERT INTO [WithSomeDatabaseGenerated] ([Data2])
+OUTPUT INSERTED.[Id]
+INTO @inserted0
+VALUES (@p0);
+SELECT [t].[Id], [t].[Data1] FROM [WithSomeDatabaseGenerated] t
+INNER JOIN @inserted0 i ON ([t].[Id] = [i].[Id]);
+
+DECLARE @inserted1 TABLE ([Id] int);
+INSERT INTO [WithSomeDatabaseGenerated2] ([Data2])
+OUTPUT INSERTED.[Id]
+INTO @inserted1
+VALUES (@p1);
+SELECT [t].[Id], [t].[Data1] FROM [WithSomeDatabaseGenerated2] t
+INNER JOIN @inserted1 i ON ([t].[Id] = [i].[Id]);");
+    }
+
+    public override async Task Add_Add_with_different_entity_types_and_no_generated_values(bool async)
+    {
+        await base.Add_Add_with_different_entity_types_and_no_generated_values(async);
+
+        AssertSql(
+            @"@p0='100'
+@p1='1000'
+@p2='1000'
+@p3='101'
+@p4='1001'
+@p5='1001'
+
+SET NOCOUNT ON;
+INSERT INTO [WithNoDatabaseGenerated] ([Id], [Data1], [Data2])
+VALUES (@p0, @p1, @p2);
+INSERT INTO [WithNoDatabaseGenerated2] ([Id], [Data1], [Data2])
+VALUES (@p3, @p4, @p5);");
+    }
+
+    public override async Task Add_Add_with_different_entity_types_and_all_generated_values(bool async)
+    {
+        await base.Add_Add_with_different_entity_types_and_all_generated_values(async);
+
+        AssertSql(
+            @"SET NOCOUNT ON;
+DECLARE @inserted0 TABLE ([Id] int);
+INSERT INTO [WithAllDatabaseGenerated]
+OUTPUT INSERTED.[Id]
+INTO @inserted0
+DEFAULT VALUES;
+SELECT [t].[Id], [t].[Data1], [t].[Data2] FROM [WithAllDatabaseGenerated] t
+INNER JOIN @inserted0 i ON ([t].[Id] = [i].[Id]);
+
+DECLARE @inserted1 TABLE ([Id] int);
+INSERT INTO [WithAllDatabaseGenerated2]
+OUTPUT INSERTED.[Id]
+INTO @inserted1
+DEFAULT VALUES;
+SELECT [t].[Id], [t].[Data1], [t].[Data2] FROM [WithAllDatabaseGenerated2] t
+INNER JOIN @inserted1 i ON ([t].[Id] = [i].[Id]);");
+    }
+
+    public override async Task Modify_Modify_with_different_entity_types_and_generated_values(bool async)
+    {
+        await base.Modify_Modify_with_different_entity_types_and_generated_values(async);
+
+        AssertSql(
+            @"@p1='5'
+@p0='1000'
+@p3='8'
+@p2='1001'
+
+SET NOCOUNT ON;
+UPDATE [WithSomeDatabaseGenerated] SET [Data2] = @p0
+WHERE [Id] = @p1;
+SELECT [Data1]
+FROM [WithSomeDatabaseGenerated]
+WHERE @@ROWCOUNT = 1 AND [Id] = @p1;
+
+UPDATE [WithSomeDatabaseGenerated2] SET [Data2] = @p2
+WHERE [Id] = @p3;
+SELECT [Data1]
+FROM [WithSomeDatabaseGenerated2]
+WHERE @@ROWCOUNT = 1 AND [Id] = @p3;");
+    }
+
+    public override async Task Modify_Modify_with_different_entity_types_and_no_generated_values(bool async)
+    {
+        await base.Modify_Modify_with_different_entity_types_and_no_generated_values(async);
+
+        AssertSql(
+            @"@p2='1'
+@p0='1000'
+@p1='1000'
+@p5='2'
+@p3='1001'
+@p4='1001'
+
+SET NOCOUNT ON;
+UPDATE [WithNoDatabaseGenerated] SET [Data1] = @p0, [Data2] = @p1
+WHERE [Id] = @p2;
+SELECT @@ROWCOUNT;
+
+UPDATE [WithNoDatabaseGenerated2] SET [Data1] = @p3, [Data2] = @p4
+WHERE [Id] = @p5;
+SELECT @@ROWCOUNT;");
+    }
+
+    public override async Task Delete_Delete_with_different_entity_types(bool async)
+    {
+        await base.Delete_Delete_with_different_entity_types(async);
+
+        AssertSql(
+            @"@p0='5'
+@p1='8'
+
+SET NOCOUNT ON;
+DELETE FROM [WithSomeDatabaseGenerated]
+WHERE [Id] = @p0;
+SELECT @@ROWCOUNT;
+
+DELETE FROM [WithSomeDatabaseGenerated2]
+WHERE [Id] = @p1;
+SELECT @@ROWCOUNT;");
+    }
+
+    #endregion Two operations with different entity types
+
+    public override async Task Three_Add_use_batched_inserts(bool async)
+    {
+        await base.Three_Add_use_batched_inserts(async);
+
+        AssertSql(
+            @"@p0='0'
+@p1='0'
+@p2='0'
+
+SET NOCOUNT ON;
+DECLARE @inserted0 TABLE ([Id] int, [_Position] [int]);
+MERGE [WithSomeDatabaseGenerated] USING (
+VALUES (@p0, 0),
+(@p1, 1),
+(@p2, 2)) AS i ([Data2], _Position) ON 1=0
+WHEN NOT MATCHED THEN
+INSERT ([Data2])
+VALUES (i.[Data2])
+OUTPUT INSERTED.[Id], i._Position
+INTO @inserted0;
+
+SELECT [t].[Id], [t].[Data1] FROM [WithSomeDatabaseGenerated] t
+INNER JOIN @inserted0 i ON ([t].[Id] = [i].[Id])
+ORDER BY [i].[_Position];");
+    }
+
+    protected override async Task Test(
+        EntityState firstOperationType,
+        EntityState? secondOperationType,
+        GeneratedValues generatedValues,
+        bool async,
+        bool withSameEntityType = true)
+    {
+        await base.Test(firstOperationType, secondOperationType, generatedValues, async, withSameEntityType);
+
+        if (!ShouldCreateImplicitTransaction(firstOperationType, secondOperationType, generatedValues, withSameEntityType))
+        {
+            Assert.Contains("SET IMPLICIT_TRANSACTIONS OFF", Fixture.TestSqlLoggerFactory.SqlStatements[0]);
+        }
+    }
+
+    public class StoreValueGenerationSequenceWithTriggerSqlServerFixture : StoreValueGenerationTriggerSqlServerFixture
+    {
+        protected override string StoreName { get; } = "StoreValueGenerationSequenceWithTriggerTest";
+
+        protected override ITestStoreFactory TestStoreFactory
+            => SqlServerTestStoreFactory.Instance;
+
+        protected override void OnModelCreating(ModelBuilder modelBuilder, DbContext context)
+        {
+            base.OnModelCreating(modelBuilder, context);
+
+            modelBuilder.HasSequence<int>("Ids");
+
+            foreach (var name in new[]
+                     {
+                         nameof(StoreValueGenerationContext.WithSomeDatabaseGenerated),
+                         nameof(StoreValueGenerationContext.WithSomeDatabaseGenerated2),
+                         nameof(StoreValueGenerationContext.WithAllDatabaseGenerated),
+                         nameof(StoreValueGenerationContext.WithAllDatabaseGenerated2)
+                     })
+            {
+                modelBuilder
+                    .SharedTypeEntity<StoreValueGenerationData>(name)
+                    .Property(w => w.Id)
+                    .HasDefaultValueSql("NEXT VALUE FOR [Ids]");
+            }
+        }
+
+        public override void Reseed()
+        {
+            using var context = CreateContext();
+            Clean(context);
+            Seed(context);
+        }
+
+        protected override void Clean(DbContext context)
+        {
+            base.Clean(context);
+
+            // Reset the sequence values since we assert on them
+            context.Database.ExecuteSqlRaw("ALTER SEQUENCE [Ids] RESTART WITH 1");
+        }
+    }
+}
diff --git a/test/EFCore.SqlServer.FunctionalTests/Update/StoreValueGenerationTriggerSqlServerFixture.cs b/test/EFCore.SqlServer.FunctionalTests/Update/StoreValueGenerationTriggerSqlServerFixture.cs
new file mode 100644
index 0000000000..7a24f9483e
--- /dev/null
+++ b/test/EFCore.SqlServer.FunctionalTests/Update/StoreValueGenerationTriggerSqlServerFixture.cs
@@ -0,0 +1,38 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.EntityFrameworkCore.TestModels.StoreValueGenerationModel;
+
+namespace Microsoft.EntityFrameworkCore.Update;
+
+public abstract class StoreValueGenerationTriggerSqlServerFixture : StoreValueGenerationFixtureBase
+{
+    protected override void Seed(StoreValueGenerationContext context)
+    {
+        base.Seed(context);
+
+        // Add triggers to all tables
+        foreach (var table in context.Model.GetEntityTypes().Select(e => e.GetTableName()))
+        {
+            context.Database.ExecuteSqlRaw(
+                $@"
+CREATE OR ALTER TRIGGER [{table}_Trigger]
+ON [{table}]
+FOR INSERT, UPDATE, DELETE AS
+BEGIN
+	IF @@ROWCOUNT = 0
+		return
+END");
+        }
+    }
+
+    protected override void OnModelCreating(ModelBuilder modelBuilder, DbContext context)
+    {
+        base.OnModelCreating(modelBuilder, context);
+
+        foreach (var entity in modelBuilder.Model.GetEntityTypes())
+        {
+            modelBuilder.Entity(entity.Name).ToTable(b => b.HasTrigger(entity.GetTableName() + "_Trigger"));
+        }
+    }
+}
diff --git a/test/EFCore.SqlServer.FunctionalTests/Update/StoreValueGenerationTriggerSqlServerTestBase.cs b/test/EFCore.SqlServer.FunctionalTests/Update/StoreValueGenerationTriggerSqlServerTestBase.cs
new file mode 100644
index 0000000000..76c888ed1d
--- /dev/null
+++ b/test/EFCore.SqlServer.FunctionalTests/Update/StoreValueGenerationTriggerSqlServerTestBase.cs
@@ -0,0 +1,110 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.EntityFrameworkCore.TestModels.StoreValueGenerationModel;
+
+namespace Microsoft.EntityFrameworkCore.Update;
+
+public abstract class StoreValueGenerationTriggerSqlServerTestBase<TFixture> : StoreValueGenerationTestBase<TFixture>
+    where TFixture : StoreValueGenerationTriggerSqlServerFixture
+{
+    protected StoreValueGenerationTriggerSqlServerTestBase(TFixture fixture)
+        : base(fixture)
+    {
+    }
+
+    [ConditionalTheory]
+    [MemberData(nameof(IsAsyncData))]
+    public virtual async Task Three_Add_use_batched_inserts(bool async)
+    {
+        await using var context = CreateContext();
+
+        var instances = new StoreValueGenerationData[] { new(), new(), new() };
+        context.WithSomeDatabaseGenerated.AddRange(instances[0], instances[1], instances[2]);
+
+        Fixture.ListLoggerFactory.Clear();
+
+        if (async)
+        {
+            await context.SaveChangesAsync();
+        }
+        else
+        {
+            context.SaveChanges();
+        }
+
+        Assert.Contains(Fixture.ListLoggerFactory.Log, l => l.Id == RelationalEventId.TransactionStarted);
+        Assert.Contains(Fixture.ListLoggerFactory.Log, l => l.Id == RelationalEventId.TransactionCommitted);
+
+        Assert.Equal(1, Fixture.ListLoggerFactory.Log.Count(l => l.Id == RelationalEventId.CommandExecuted));
+
+        context.ChangeTracker.Clear();
+
+        using (Fixture.TestSqlLoggerFactory.SuspendRecordingEvents())
+        {
+            foreach (var instance in instances)
+            {
+                Assert.Equal(await context.WithSomeDatabaseGenerated.FindAsync(instance.Id), instance);
+            }
+        }
+    }
+
+    [ConditionalTheory]
+    [MemberData(nameof(IsAsyncData))]
+    public virtual async Task Four_Add_use_merge_output_into(bool async)
+    {
+        await using var context = CreateContext();
+
+        var instances = new StoreValueGenerationData[] { new(), new(), new(), new() };
+        context.WithSomeDatabaseGenerated.AddRange(instances[0], instances[1], instances[2], instances[3]);
+
+        Fixture.ListLoggerFactory.Clear();
+
+        if (async)
+        {
+            await context.SaveChangesAsync();
+        }
+        else
+        {
+            context.SaveChanges();
+        }
+
+        Assert.Contains(Fixture.ListLoggerFactory.Log, l => l.Id == RelationalEventId.TransactionStarted);
+        Assert.Contains(Fixture.ListLoggerFactory.Log, l => l.Id == RelationalEventId.TransactionCommitted);
+
+        Assert.Equal(1, Fixture.ListLoggerFactory.Log.Count(l => l.Id == RelationalEventId.CommandExecuted));
+
+        context.ChangeTracker.Clear();
+
+        using (Fixture.TestSqlLoggerFactory.SuspendRecordingEvents())
+        {
+            foreach (var instance in instances)
+            {
+                Assert.Equal(await context.WithSomeDatabaseGenerated.FindAsync(instance.Id), instance);
+            }
+        }
+
+        AssertSql(
+            @"@p0='0'
+@p1='0'
+@p2='0'
+@p3='0'
+
+SET NOCOUNT ON;
+DECLARE @inserted0 TABLE ([Id] int, [_Position] [int]);
+MERGE [WithSomeDatabaseGenerated] USING (
+VALUES (@p0, 0),
+(@p1, 1),
+(@p2, 2),
+(@p3, 3)) AS i ([Data2], _Position) ON 1=0
+WHEN NOT MATCHED THEN
+INSERT ([Data2])
+VALUES (i.[Data2])
+OUTPUT INSERTED.[Id], i._Position
+INTO @inserted0;
+
+SELECT [t].[Id], [t].[Data1] FROM [WithSomeDatabaseGenerated] t
+INNER JOIN @inserted0 i ON ([t].[Id] = [i].[Id])
+ORDER BY [i].[_Position];");
+    }
+}
diff --git a/test/EFCore.SqlServer.FunctionalTests/UpdatesSqlServerTest.cs b/test/EFCore.SqlServer.FunctionalTests/UpdatesSqlServerTest.cs
index ac06c24272..1d2c6b2b92 100644
--- a/test/EFCore.SqlServer.FunctionalTests/UpdatesSqlServerTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/UpdatesSqlServerTest.cs
@@ -43,23 +43,16 @@ public virtual void Save_with_shared_foreign_key()
             @"@p0='77'
 @p1=NULL (Size = 4000)
 @p2='777'
+@p3=NULL (Size = 8000) (DbType = Binary)
+@p4='ProductWithBytes' (Nullable = false) (Size = 4000)
+@p5=NULL (Size = 4000)
 
-SET IMPLICIT_TRANSACTIONS OFF;
 SET NOCOUNT ON;
 INSERT INTO [Categories] ([Id], [Name], [PrincipalId])
-VALUES (@p0, @p1, @p2);",
-            //
-            @"@p0=NULL (Size = 8000) (DbType = Binary)
-@p1='ProductWithBytes' (Nullable = false) (Size = 4000)
-@p2=NULL (Size = 4000)
-
-SET NOCOUNT ON;
-DECLARE @inserted0 TABLE ([Id] uniqueidentifier);
+VALUES (@p0, @p1, @p2);
 INSERT INTO [ProductBase] ([Bytes], [Discriminator], [ProductWithBytes_Name])
 OUTPUT INSERTED.[Id]
-INTO @inserted0
-VALUES (@p0, @p1, @p2);
-SELECT [i].[Id] FROM @inserted0 i;");
+VALUES (@p3, @p4, @p5);");
     }
 
     [ConditionalFact]
@@ -68,60 +61,50 @@ public override void Can_add_and_remove_self_refs()
         base.Can_add_and_remove_self_refs();
 
         AssertContainsSql(
-            @"@p0='1' (Size = 4000)
+                @"@p0='1' (Size = 4000)
 @p1=NULL (DbType = Int32)
 
+SET IMPLICIT_TRANSACTIONS OFF;
 SET NOCOUNT ON;
 INSERT INTO [Person] ([Name], [ParentId])
-VALUES (@p0, @p1);
-SELECT [PersonId]
-FROM [Person]
-WHERE @@ROWCOUNT = 1 AND [PersonId] = scope_identity();",
-            //
-            @"@p0='2' (Size = 4000)
-@p1='1' (Nullable = true)
-
-SET NOCOUNT ON;
-INSERT INTO [Person] ([Name], [ParentId])
-VALUES (@p0, @p1);
-SELECT [PersonId]
-FROM [Person]
-WHERE @@ROWCOUNT = 1 AND [PersonId] = scope_identity();",
-            //
-            @"@p0='3' (Size = 4000)
-@p1='1' (Nullable = true)
-
-SET NOCOUNT ON;
-INSERT INTO [Person] ([Name], [ParentId])
-VALUES (@p0, @p1);
-SELECT [PersonId]
-FROM [Person]
-WHERE @@ROWCOUNT = 1 AND [PersonId] = scope_identity();",
-            //
-            @"@p2='4' (Size = 4000)
-@p3='2' (Nullable = true)
-@p4='5' (Size = 4000)
-@p5='2' (Nullable = true)
-@p6='6' (Size = 4000)
-@p7='3' (Nullable = true)
-@p8='7' (Size = 4000)
-@p9='3' (Nullable = true)
+OUTPUT INSERTED.[PersonId]
+VALUES (@p0, @p1);",
+                //
+                @"@p2='2' (Size = 4000)
+@p3='1' (Nullable = true)
+@p4='3' (Size = 4000)
+@p5='1' (Nullable = true)
 
+SET IMPLICIT_TRANSACTIONS OFF;
 SET NOCOUNT ON;
-DECLARE @inserted0 TABLE ([PersonId] int, [_Position] [int]);
 MERGE [Person] USING (
 VALUES (@p2, @p3, 0),
-(@p4, @p5, 1),
-(@p6, @p7, 2),
-(@p8, @p9, 3)) AS i ([Name], [ParentId], _Position) ON 1=0
+(@p4, @p5, 1)) AS i ([Name], [ParentId], _Position) ON 1=0
 WHEN NOT MATCHED THEN
 INSERT ([Name], [ParentId])
 VALUES (i.[Name], i.[ParentId])
-OUTPUT INSERTED.[PersonId], i._Position
-INTO @inserted0;
+OUTPUT INSERTED.[PersonId], i._Position;",
+                //
+                @"@p6='4' (Size = 4000)
+@p7='2' (Nullable = true)
+@p8='5' (Size = 4000)
+@p9='2' (Nullable = true)
+@p10='6' (Size = 4000)
+@p11='3' (Nullable = true)
+@p12='7' (Size = 4000)
+@p13='3' (Nullable = true)
 
-SELECT [i].[PersonId] FROM @inserted0 i
-ORDER BY [i].[_Position];");
+SET IMPLICIT_TRANSACTIONS OFF;
+SET NOCOUNT ON;
+MERGE [Person] USING (
+VALUES (@p6, @p7, 0),
+(@p8, @p9, 1),
+(@p10, @p11, 2),
+(@p12, @p13, 3)) AS i ([Name], [ParentId], _Position) ON 1=0
+WHEN NOT MATCHED THEN
+INSERT ([Name], [ParentId])
+VALUES (i.[Name], i.[ParentId])
+OUTPUT INSERTED.[PersonId], i._Position;");
     }
 
     public override void Save_replaced_principal()
diff --git a/test/EFCore.Sqlite.FunctionalTests/DataAnnotationSqliteTest.cs b/test/EFCore.Sqlite.FunctionalTests/DataAnnotationSqliteTest.cs
index bfa4f379fc..c032c7b032 100644
--- a/test/EFCore.Sqlite.FunctionalTests/DataAnnotationSqliteTest.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/DataAnnotationSqliteTest.cs
@@ -133,10 +133,8 @@ public override void DatabaseGeneratedAttribute_autogenerates_values_when_set_to
 @p6='0' (Nullable = true)
 
 INSERT INTO ""Sample"" (""MaxLengthProperty"", ""Name"", ""RowVersion"", ""AdditionalDetails_Name"", ""AdditionalDetails_Value"", ""Details_Name"", ""Details_Value"")
-VALUES (@p0, @p1, @p2, @p3, @p4, @p5, @p6);
-SELECT ""Unique_No""
-FROM ""Sample""
-WHERE changes() = 1 AND ""rowid"" = last_insert_rowid();");
+VALUES (@p0, @p1, @p2, @p3, @p4, @p5, @p6)
+RETURNING ""Unique_No"";");
     }
 
     // Sqlite does not support length
diff --git a/test/EFCore.Sqlite.FunctionalTests/Update/SqliteUpdateSqlGeneratorTest.cs b/test/EFCore.Sqlite.FunctionalTests/Update/SqliteUpdateSqlGeneratorTest.cs
index f4cb3dd24b..94da6a946f 100644
--- a/test/EFCore.Sqlite.FunctionalTests/Update/SqliteUpdateSqlGeneratorTest.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/Update/SqliteUpdateSqlGeneratorTest.cs
@@ -40,4 +40,49 @@ public override void GenerateNextSequenceValueOperation_returns_statement_with_s
             () => base.GenerateNextSequenceValueOperation_returns_statement_with_sanitized_sequence());
         Assert.Equal(SqliteStrings.SequencesNotSupported, ex.Message);
     }
+
+    protected override void AppendInsertOperation_insert_if_store_generated_columns_exist_verification(StringBuilder stringBuilder)
+        => AssertBaseline(
+            @"INSERT INTO ""Ducks"" (""Name"", ""Quacks"", ""ConcurrencyToken"")
+VALUES (@p0, @p1, @p2)
+RETURNING ""Id"", ""Computed"";
+",
+            stringBuilder.ToString());
+
+    protected override void AppendInsertOperation_for_store_generated_columns_but_no_identity_verification(
+        StringBuilder stringBuilder)
+        => AssertBaseline(
+            @"INSERT INTO ""Ducks"" (""Id"", ""Name"", ""Quacks"", ""ConcurrencyToken"")
+VALUES (@p0, @p1, @p2, @p3)
+RETURNING ""Computed"";
+",
+            stringBuilder.ToString());
+
+    protected override void AppendInsertOperation_for_only_identity_verification(StringBuilder stringBuilder)
+        => AssertBaseline(
+            @"INSERT INTO ""Ducks"" (""Name"", ""Quacks"", ""ConcurrencyToken"")
+VALUES (@p0, @p1, @p2)
+RETURNING ""Id"";
+",
+            stringBuilder.ToString());
+
+    protected override void AppendInsertOperation_for_all_store_generated_columns_verification(StringBuilder stringBuilder)
+        => AssertBaseline(
+            @"INSERT INTO ""Ducks""
+DEFAULT VALUES
+RETURNING ""Id"", ""Computed"";
+",
+            stringBuilder.ToString());
+
+    protected override void AppendInsertOperation_for_only_single_identity_columns_verification(
+        StringBuilder stringBuilder)
+        => AssertBaseline(
+            @"INSERT INTO ""Ducks""
+DEFAULT VALUES
+RETURNING ""Id"";
+",
+            stringBuilder.ToString());
+
+    private void AssertBaseline(string expected, string actual)
+        => Assert.Equal(expected, actual, ignoreLineEndingDifferences: true);
 }
diff --git a/test/EFCore.Sqlite.FunctionalTests/Update/StoreValueGenerationSqliteTest.cs b/test/EFCore.Sqlite.FunctionalTests/Update/StoreValueGenerationSqliteTest.cs
index 0904be07d5..3aa88b271a 100644
--- a/test/EFCore.Sqlite.FunctionalTests/Update/StoreValueGenerationSqliteTest.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/Update/StoreValueGenerationSqliteTest.cs
@@ -12,7 +12,7 @@ public StoreValueGenerationSqliteTest(StoreValueGenerationSqliteFixture fixture,
         : base(fixture)
     {
         fixture.TestSqlLoggerFactory.Clear();
-        fixture.TestSqlLoggerFactory.SetTestOutputHelper(testOutputHelper);
+        // fixture.TestSqlLoggerFactory.SetTestOutputHelper(testOutputHelper);
     }
 
     protected override int ShouldExecuteInNumberOfCommands(
@@ -32,10 +32,8 @@ public override async Task Add_with_generated_values(bool async)
             @"@p0='1000'
 
 INSERT INTO ""WithSomeDatabaseGenerated"" (""Data2"")
-VALUES (@p0);
-SELECT ""Id"", ""Data1""
-FROM ""WithSomeDatabaseGenerated""
-WHERE changes() = 1 AND ""rowid"" = last_insert_rowid();");
+VALUES (@p0)
+RETURNING ""Id"", ""Data1"";");
     }
 
     public override async Task Add_with_no_generated_values(bool async)
@@ -57,10 +55,8 @@ public override async Task Add_with_all_generated_values(bool async)
 
         AssertSql(
             @"INSERT INTO ""WithAllDatabaseGenerated""
-DEFAULT VALUES;
-SELECT ""Id"", ""Data1"", ""Data2""
-FROM ""WithAllDatabaseGenerated""
-WHERE changes() = 1 AND ""rowid"" = last_insert_rowid();");
+DEFAULT VALUES
+RETURNING ""Id"", ""Data1"", ""Data2"";");
     }
 
     public override async Task Modify_with_generated_values(bool async)
@@ -116,18 +112,14 @@ public override async Task Add_Add_with_same_entity_type_and_generated_values(bo
             @"@p0='1000'
 
 INSERT INTO ""WithSomeDatabaseGenerated"" (""Data2"")
-VALUES (@p0);
-SELECT ""Id"", ""Data1""
-FROM ""WithSomeDatabaseGenerated""
-WHERE changes() = 1 AND ""rowid"" = last_insert_rowid();",
+VALUES (@p0)
+RETURNING ""Id"", ""Data1"";",
             //
             @"@p0='1001'
 
 INSERT INTO ""WithSomeDatabaseGenerated"" (""Data2"")
-VALUES (@p0);
-SELECT ""Id"", ""Data1""
-FROM ""WithSomeDatabaseGenerated""
-WHERE changes() = 1 AND ""rowid"" = last_insert_rowid();");
+VALUES (@p0)
+RETURNING ""Id"", ""Data1"";");
     }
 
     public override async Task Add_Add_with_same_entity_type_and_no_generated_values(bool async)
@@ -156,16 +148,12 @@ public override async Task Add_Add_with_same_entity_type_and_all_generated_value
 
         AssertSql(
             @"INSERT INTO ""WithAllDatabaseGenerated""
-DEFAULT VALUES;
-SELECT ""Id"", ""Data1"", ""Data2""
-FROM ""WithAllDatabaseGenerated""
-WHERE changes() = 1 AND ""rowid"" = last_insert_rowid();",
+DEFAULT VALUES
+RETURNING ""Id"", ""Data1"", ""Data2"";",
             //
             @"INSERT INTO ""WithAllDatabaseGenerated""
-DEFAULT VALUES;
-SELECT ""Id"", ""Data1"", ""Data2""
-FROM ""WithAllDatabaseGenerated""
-WHERE changes() = 1 AND ""rowid"" = last_insert_rowid();");
+DEFAULT VALUES
+RETURNING ""Id"", ""Data1"", ""Data2"";");
     }
 
     public override async Task Modify_Modify_with_same_entity_type_and_generated_values(bool async)
@@ -244,18 +232,14 @@ public override async Task Add_Add_with_different_entity_types_and_generated_val
             @"@p0='1000'
 
 INSERT INTO ""WithSomeDatabaseGenerated"" (""Data2"")
-VALUES (@p0);
-SELECT ""Id"", ""Data1""
-FROM ""WithSomeDatabaseGenerated""
-WHERE changes() = 1 AND ""rowid"" = last_insert_rowid();",
+VALUES (@p0)
+RETURNING ""Id"", ""Data1"";",
             //
             @"@p0='1001'
 
 INSERT INTO ""WithSomeDatabaseGenerated2"" (""Data2"")
-VALUES (@p0);
-SELECT ""Id"", ""Data1""
-FROM ""WithSomeDatabaseGenerated2""
-WHERE changes() = 1 AND ""rowid"" = last_insert_rowid();");
+VALUES (@p0)
+RETURNING ""Id"", ""Data1"";");
     }
 
     public override async Task Add_Add_with_different_entity_types_and_no_generated_values(bool async)
@@ -284,16 +268,12 @@ public override async Task Add_Add_with_different_entity_types_and_all_generated
 
         AssertSql(
             @"INSERT INTO ""WithAllDatabaseGenerated""
-DEFAULT VALUES;
-SELECT ""Id"", ""Data1"", ""Data2""
-FROM ""WithAllDatabaseGenerated""
-WHERE changes() = 1 AND ""rowid"" = last_insert_rowid();",
+DEFAULT VALUES
+RETURNING ""Id"", ""Data1"", ""Data2"";",
             //
             @"INSERT INTO ""WithAllDatabaseGenerated2""
-DEFAULT VALUES;
-SELECT ""Id"", ""Data1"", ""Data2""
-FROM ""WithAllDatabaseGenerated2""
-WHERE changes() = 1 AND ""rowid"" = last_insert_rowid();");
+DEFAULT VALUES
+RETURNING ""Id"", ""Data1"", ""Data2"";");
     }
 
     public override async Task Modify_Modify_with_different_entity_types_and_generated_values(bool async)
