diff --git a/src/EFCore.Relational/Query/SqlExpressions/SelectExpression.Helper.cs b/src/EFCore.Relational/Query/SqlExpressions/SelectExpression.Helper.cs
index 3ebcb7d2ac..5d58972f0d 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/SelectExpression.Helper.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/SelectExpression.Helper.cs
@@ -408,7 +408,7 @@ public ClientProjectionRemappingExpressionVisitor(List<object> clientProjectionI
     // improved); for those cases SqlAliasManager is passed in and ensures unique table aliases across the entire query.
     // But for split query, we clone in order to create a completely separate query, in which case we don't want unique aliases - and so
     // SqlAliasManager isn't passed in.
-    private sealed class CloningExpressionVisitor(SqlAliasManager? sqlAliasManager) : ExpressionVisitor
+    private sealed class CloningExpressionVisitor(SqlAliasManager? sqlAliasManager, bool cloneClientProjections = true) : ExpressionVisitor
     {
         private readonly Dictionary<string, string> _tableAliasMap = new();
 
@@ -417,16 +417,21 @@ private sealed class CloningExpressionVisitor(SqlAliasManager? sqlAliasManager)
         {
             switch (expression)
             {
+                case ShapedQueryExpression shapedQuery:
+                    return shapedQuery.UpdateQueryExpression(Visit(shapedQuery.QueryExpression));
+
                 case TableExpressionBase table:
                 {
-                    if (sqlAliasManager is null || table.Alias is null)
+                    var newTableAlias = table.Alias;
+                    if (sqlAliasManager is not null && table.Alias is not null)
                     {
-                        return table.Clone(table.Alias, this);
+                        newTableAlias = sqlAliasManager.GenerateTableAlias(table.Alias);
+                        _tableAliasMap[table.Alias] = newTableAlias;
                     }
 
-                    var newTableAlias = sqlAliasManager.GenerateTableAlias(table.Alias);
-                    _tableAliasMap[table.Alias] = newTableAlias;
-                    return table.Clone(newTableAlias, this);
+                    return table is SelectExpression select
+                        ? select.Clone(newTableAlias, this, cloneClientProjections)
+                        : table.Clone(newTableAlias, this);
                 }
 
                 case ColumnExpression column when _tableAliasMap.TryGetValue(column.TableAlias, out var newTableAlias):
diff --git a/src/EFCore.Relational/Query/SqlExpressions/SelectExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/SelectExpression.cs
index 431da91d87..3471a414fd 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/SelectExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/SelectExpression.cs
@@ -1082,11 +1082,15 @@ void ProcessTypeProjection(StructuralTypeProjectionExpression projection)
                 && (containsSingleResult || containsCollection))
             {
                 // SingleResult can lift collection from inner
+
+                // Specifically for here, we want to avoid cloning the client projection; if we do, when applying the projection on the
+                // cloned inner query we go into an endless recursion.
+
                 // Note that we create a CloningExpressionVisitor without a SQL alias manager - this means that aliases won't get uniquified
                 // as expressions are being cloned. Since we're cloning here to get a completely separate (split) query, that makes sense
                 // as we don't want aliases to be unique across different queries (but in other contexts, when the cloned fragment gets
                 // integrated back into the same query (e.g. GroupBy) we do want to uniquify aliases).
-                cloningExpressionVisitor = new CloningExpressionVisitor(sqlAliasManager: null);
+                cloningExpressionVisitor = new CloningExpressionVisitor(sqlAliasManager: null, cloneClientProjections: false);
             }
 
             var earlierClientProjectionCount = _clientProjections.Count;
@@ -4282,6 +4286,9 @@ public SelectExpression Clone()
 
     /// <inheritdoc />
     public override TableExpressionBase Clone(string? alias, ExpressionVisitor cloningExpressionVisitor)
+        => Clone(alias, cloningExpressionVisitor, cloneClientProjections: true);
+
+    private TableExpressionBase Clone(string? alias, ExpressionVisitor cloningExpressionVisitor, bool cloneClientProjections)
     {
         var newTables = _tables.Select(cloningExpressionVisitor.Visit).ToList<TableExpressionBase>();
         var tpcTablesMap = _tables.Select(TableExpressionExtensions.UnwrapJoin).Zip(newTables.Select(TableExpressionExtensions.UnwrapJoin))
@@ -4294,6 +4301,10 @@ public override TableExpressionBase Clone(string? alias, ExpressionVisitor cloni
             newProjectionMappings[projectionMember] = cloningExpressionVisitor.Visit(value);
         }
 
+        var newClientProjections = cloneClientProjections
+            ? _clientProjections.Select(p => cloningExpressionVisitor.Visit(p)).ToList()
+            : [];
+
         var newProjections = _projection.Select(cloningExpressionVisitor.Visit).ToList<ProjectionExpression>();
 
         var predicate = (SqlExpression?)cloningExpressionVisitor.Visit(Predicate);
@@ -4315,6 +4326,7 @@ public override TableExpressionBase Clone(string? alias, ExpressionVisitor cloni
             IsDistinct = IsDistinct,
             Tags = Tags,
             _projectionMapping = newProjectionMappings,
+            _clientProjections = newClientProjections,
             IsMutable = IsMutable
         };
 
diff --git a/test/EFCore.Relational.Specification.Tests/BulkUpdates/NonSharedModelBulkUpdatesTestBase.cs b/test/EFCore.Relational.Specification.Tests/BulkUpdates/NonSharedModelBulkUpdatesTestBase.cs
index f4b7723e9d..5b4bbbc57c 100644
--- a/test/EFCore.Relational.Specification.Tests/BulkUpdates/NonSharedModelBulkUpdatesTestBase.cs
+++ b/test/EFCore.Relational.Specification.Tests/BulkUpdates/NonSharedModelBulkUpdatesTestBase.cs
@@ -18,6 +18,18 @@ public virtual async Task Delete_aggregate_root_when_eager_loaded_owned_collecti
             context => context.Set<Owner>(), rowsAffectedCount: 0);
     }
 
+    // Composing the OrderBy().Skip() operators causes the query to not be natively translatable as a simple DELETE (in most databases),
+    // causing a subquery pushdown (WHERE Id IN (...)).
+    [ConditionalTheory]
+    [MemberData(nameof(IsAsyncData))]
+    public virtual async Task Delete_with_owned_collection_and_non_natively_translatable_query(bool async)
+    {
+        var contextFactory = await InitializeAsync<Context28671>(onModelCreating: mb => mb.Entity<Owner>().Ignore(e => e.OwnedReference));
+        await AssertDelete(
+            async, contextFactory.CreateContext,
+            context => context.Set<Owner>().OrderBy(o => o.Title).Skip(1), rowsAffectedCount: 0);
+    }
+
     [ConditionalTheory]
     [MemberData(nameof(IsAsyncData))]
     public virtual async Task Delete_aggregate_root_when_table_sharing_with_owned(bool async)
diff --git a/test/EFCore.SqlServer.FunctionalTests/BulkUpdates/NonSharedModelBulkUpdatesSqlServerTest.cs b/test/EFCore.SqlServer.FunctionalTests/BulkUpdates/NonSharedModelBulkUpdatesSqlServerTest.cs
index d399fc5bf0..4c76619239 100644
--- a/test/EFCore.SqlServer.FunctionalTests/BulkUpdates/NonSharedModelBulkUpdatesSqlServerTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/BulkUpdates/NonSharedModelBulkUpdatesSqlServerTest.cs
@@ -23,6 +23,25 @@ public override async Task Delete_aggregate_root_when_eager_loaded_owned_collect
 """);
     }
 
+    public override async Task Delete_with_owned_collection_and_non_natively_translatable_query(bool async)
+    {
+        await base.Delete_with_owned_collection_and_non_natively_translatable_query(async);
+
+        AssertSql(
+            """
+@__p_0='1'
+
+DELETE FROM [o]
+FROM [Owner] AS [o]
+WHERE [o].[Id] IN (
+    SELECT [o0].[Id]
+    FROM [Owner] AS [o0]
+    ORDER BY [o0].[Title]
+    OFFSET @__p_0 ROWS
+)
+""");
+    }
+
     public override async Task Delete_aggregate_root_when_table_sharing_with_owned(bool async)
     {
         await base.Delete_aggregate_root_when_table_sharing_with_owned(async);
diff --git a/test/EFCore.Sqlite.FunctionalTests/BulkUpdates/NonSharedModelBulkUpdatesSqliteTest.cs b/test/EFCore.Sqlite.FunctionalTests/BulkUpdates/NonSharedModelBulkUpdatesSqliteTest.cs
index 8925722d99..0cc68af9e3 100644
--- a/test/EFCore.Sqlite.FunctionalTests/BulkUpdates/NonSharedModelBulkUpdatesSqliteTest.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/BulkUpdates/NonSharedModelBulkUpdatesSqliteTest.cs
@@ -22,6 +22,24 @@ public override async Task Delete_aggregate_root_when_eager_loaded_owned_collect
 """);
     }
 
+    public override async Task Delete_with_owned_collection_and_non_natively_translatable_query(bool async)
+    {
+        await base.Delete_with_owned_collection_and_non_natively_translatable_query(async);
+
+        AssertSql(
+            """
+@__p_0='1'
+
+DELETE FROM "Owner" AS "o"
+WHERE "o"."Id" IN (
+    SELECT "o0"."Id"
+    FROM "Owner" AS "o0"
+    ORDER BY "o0"."Title"
+    LIMIT -1 OFFSET @__p_0
+)
+""");
+    }
+
     public override async Task Delete_aggregate_root_when_table_sharing_with_owned(bool async)
     {
         await base.Delete_aggregate_root_when_table_sharing_with_owned(async);
@@ -111,8 +129,20 @@ public override async Task Update_non_main_table_in_entity_with_entity_splitting
 """);
     }
 
-    public override Task Delete_entity_with_auto_include(bool async)
-        => Assert.ThrowsAsync<ArgumentOutOfRangeException>(() => base.Delete_entity_with_auto_include(async));
+    public override async Task Delete_entity_with_auto_include(bool async)
+    {
+        await base.Delete_entity_with_auto_include(async);
+
+        AssertSql(
+            """
+DELETE FROM "Context30572_Principal" AS "c"
+WHERE "c"."Id" IN (
+    SELECT "c0"."Id"
+    FROM "Context30572_Principal" AS "c0"
+    LEFT JOIN "Context30572_Dependent" AS "c1" ON "c0"."DependentId" = "c1"."Id"
+)
+""");
+    }
 
     public override async Task Delete_predicate_based_on_optional_navigation(bool async)
     {
