diff --git a/src/EFCore.Cosmos/Diagnostics/CosmosEventId.cs b/src/EFCore.Cosmos/Diagnostics/CosmosEventId.cs
index a3efd7adad..c4fe1338bd 100644
--- a/src/EFCore.Cosmos/Diagnostics/CosmosEventId.cs
+++ b/src/EFCore.Cosmos/Diagnostics/CosmosEventId.cs
@@ -25,6 +25,7 @@ public static class CosmosEventId
     private enum Id
     {
         // Database events
+        [Obsolete("Synchronous I/O has been fully removed and now always throws.")]
         SyncNotSupported = CoreEventId.ProviderBaseId,
 
         // Command events
@@ -44,19 +45,6 @@ private enum Id
         NoPartitionKeyDefined = CoreEventId.ProviderBaseId + 600,
     }
 
-    private static readonly string DatabasePrefix = DbLoggerCategory.Database.Name + ".";
-
-    /// <summary>
-    ///     Azure Cosmos DB does not support synchronous I/O. Make sure to use and correctly await only async
-    ///     methods when using Entity Framework Core to access Azure Cosmos DB.
-    ///     See https://aka.ms/ef-cosmos-nosync for more information.
-    /// </summary>
-    /// <remarks>
-    ///     This event is in the <see cref="DbLoggerCategory.Database" /> category.
-    /// </remarks>
-    public static readonly EventId SyncNotSupported
-        = new((int)Id.SyncNotSupported, DatabasePrefix + Id.SyncNotSupported);
-
     private static readonly string CommandPrefix = DbLoggerCategory.Database.Command.Name + ".";
 
     /// <summary>
diff --git a/src/EFCore.Cosmos/Diagnostics/Internal/CosmosLoggerExtensions.cs b/src/EFCore.Cosmos/Diagnostics/Internal/CosmosLoggerExtensions.cs
index 2f6dac58c9..bb53832df2 100644
--- a/src/EFCore.Cosmos/Diagnostics/Internal/CosmosLoggerExtensions.cs
+++ b/src/EFCore.Cosmos/Diagnostics/Internal/CosmosLoggerExtensions.cs
@@ -19,32 +19,6 @@ namespace Microsoft.EntityFrameworkCore.Cosmos.Diagnostics.Internal;
 /// </summary>
 public static class CosmosLoggerExtensions
 {
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public static void SyncNotSupported(
-        this IDiagnosticsLogger<DbLoggerCategory.Database> diagnostics)
-    {
-        var definition = CosmosResources.LogSyncNotSupported(diagnostics);
-
-        if (diagnostics.ShouldLog(definition))
-        {
-            definition.Log(diagnostics);
-        }
-
-        if (diagnostics.NeedsEventData(definition, out var diagnosticSourceEnabled, out var simpleLogEnabled))
-        {
-            var eventData = new EventData(
-                definition,
-                (d, p) => ((EventDefinition)d).GenerateMessage());
-
-            diagnostics.DispatchEventData(definition, eventData, diagnosticSourceEnabled, simpleLogEnabled);
-        }
-    }
-
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
diff --git a/src/EFCore.Cosmos/Diagnostics/Internal/CosmosLoggingDefinitions.cs b/src/EFCore.Cosmos/Diagnostics/Internal/CosmosLoggingDefinitions.cs
index b7cbf35729..5b5177e87f 100644
--- a/src/EFCore.Cosmos/Diagnostics/Internal/CosmosLoggingDefinitions.cs
+++ b/src/EFCore.Cosmos/Diagnostics/Internal/CosmosLoggingDefinitions.cs
@@ -75,14 +75,6 @@ public class CosmosLoggingDefinitions : LoggingDefinitions
     /// </summary>
     public EventDefinitionBase? LogExecutedDeleteItem;
 
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public EventDefinitionBase? LogSyncNotSupported;
-
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
diff --git a/src/EFCore.Cosmos/Extensions/CosmosDbContextOptionsExtensions.cs b/src/EFCore.Cosmos/Extensions/CosmosDbContextOptionsExtensions.cs
index 54b40a779f..448a002dc0 100644
--- a/src/EFCore.Cosmos/Extensions/CosmosDbContextOptionsExtensions.cs
+++ b/src/EFCore.Cosmos/Extensions/CosmosDbContextOptionsExtensions.cs
@@ -52,8 +52,6 @@ public static class CosmosDbContextOptionsExtensions
         Check.NotNull(optionsBuilder);
         Check.NotNull(cosmosOptionsAction);
 
-        ConfigureWarnings(optionsBuilder);
-
         cosmosOptionsAction.Invoke(new CosmosDbContextOptionsBuilder(optionsBuilder));
 
         return optionsBuilder;
@@ -120,8 +118,6 @@ public static class CosmosDbContextOptionsExtensions
             .WithAccountKey(accountKey)
             .WithDatabaseName(databaseName);
 
-        ConfigureWarnings(optionsBuilder);
-
         ((IDbContextOptionsBuilderInfrastructure)optionsBuilder).AddOrUpdateExtension(extension);
 
         cosmosOptionsAction?.Invoke(new CosmosDbContextOptionsBuilder(optionsBuilder));
@@ -190,8 +186,6 @@ public static class CosmosDbContextOptionsExtensions
             .WithTokenCredential(tokenCredential)
             .WithDatabaseName(databaseName);
 
-        ConfigureWarnings(optionsBuilder);
-
         ((IDbContextOptionsBuilderInfrastructure)optionsBuilder).AddOrUpdateExtension(extension);
 
         cosmosOptionsAction?.Invoke(new CosmosDbContextOptionsBuilder(optionsBuilder));
@@ -253,8 +247,6 @@ public static class CosmosDbContextOptionsExtensions
             .WithConnectionString(connectionString)
             .WithDatabaseName(databaseName);
 
-        ConfigureWarnings(optionsBuilder);
-
         ((IDbContextOptionsBuilderInfrastructure)optionsBuilder).AddOrUpdateExtension(extension);
 
         cosmosOptionsAction?.Invoke(new CosmosDbContextOptionsBuilder(optionsBuilder));
@@ -268,10 +260,6 @@ var coreOptionsExtension
             = optionsBuilder.Options.FindExtension<CoreOptionsExtension>()
             ?? new CoreOptionsExtension();
 
-        coreOptionsExtension = coreOptionsExtension.WithWarningsConfiguration(
-            coreOptionsExtension.WarningsConfiguration.TryWithExplicit(
-                CosmosEventId.SyncNotSupported, WarningBehavior.Throw));
-
         ((IDbContextOptionsBuilderInfrastructure)optionsBuilder).AddOrUpdateExtension(coreOptionsExtension);
     }
 }
diff --git a/src/EFCore.Cosmos/Properties/CosmosStrings.Designer.cs b/src/EFCore.Cosmos/Properties/CosmosStrings.Designer.cs
index f52af8503f..6b42a75fb1 100644
--- a/src/EFCore.Cosmos/Properties/CosmosStrings.Designer.cs
+++ b/src/EFCore.Cosmos/Properties/CosmosStrings.Designer.cs
@@ -497,6 +497,12 @@ public static string SaveChangesAutoTransactionBehaviorAlwaysTriggerAtomicity
         public static string SingleFirstOrDefaultNotSupportedOnNonNullableQueries
             => GetString("SingleFirstOrDefaultNotSupportedOnNonNullableQueries");
 
+        /// <summary>
+        ///     Azure Cosmos DB does not support synchronous I/O. Make sure to use and correctly await only async methods when using Entity Framework Core to access Azure Cosmos DB.
+        /// </summary>
+        public static string SyncNotSupported
+            => GetString("SyncNotSupported");
+
         /// <summary>
         ///     The provisioned throughput was configured to '{throughput1}' on '{entityType1}', but on '{entityType2}' it was configured to '{throughput2}'. All entity types mapped to the same container '{container}' must be configured with the same provisioned throughput.
         /// </summary>
@@ -891,30 +897,5 @@ public static EventDefinition<string> LogNoPartitionKeyDefined(IDiagnosticsLogge
 
             return (EventDefinition<string, string>)definition;
         }
-
-        /// <summary>
-        ///     Azure Cosmos DB does not support synchronous I/O. Make sure to use and correctly await only async methods when using Entity Framework Core to access Azure Cosmos DB. See https://aka.ms/ef-cosmos-nosync for more information.
-        /// </summary>
-        public static EventDefinition LogSyncNotSupported(IDiagnosticsLogger logger)
-        {
-            var definition = ((Diagnostics.Internal.CosmosLoggingDefinitions)logger.Definitions).LogSyncNotSupported;
-            if (definition == null)
-            {
-                definition = NonCapturingLazyInitializer.EnsureInitialized(
-                    ref ((Diagnostics.Internal.CosmosLoggingDefinitions)logger.Definitions).LogSyncNotSupported,
-                    logger,
-                    static logger => new EventDefinition(
-                        logger.Options,
-                        CosmosEventId.SyncNotSupported,
-                        LogLevel.Error,
-                        "CosmosEventId.SyncNotSupported",
-                        level => LoggerMessage.Define(
-                            level,
-                            CosmosEventId.SyncNotSupported,
-                            _resourceManager.GetString("LogSyncNotSupported")!)));
-            }
-
-            return (EventDefinition)definition;
-        }
     }
 }
diff --git a/src/EFCore.Cosmos/Properties/CosmosStrings.resx b/src/EFCore.Cosmos/Properties/CosmosStrings.resx
index fd4e48bbad..bb443f30aa 100644
--- a/src/EFCore.Cosmos/Properties/CosmosStrings.resx
+++ b/src/EFCore.Cosmos/Properties/CosmosStrings.resx
@@ -250,10 +250,6 @@
     <value>The key property '{entityType}.{property}' is not configured to generate values and has the CLR default or sentinel value while saving a new entity to the database. The Azure Cosmos DB database provider for EF Core does not generate key values by default. This means key values must be explicitly set before saving new entities. See https://aka.ms/ef-cosmos-keys for more information.</value>
     <comment>Warning CosmosEventId.PrimaryKeyValueNotSet string string</comment>
   </data>
-  <data name="LogSyncNotSupported" xml:space="preserve">
-    <value>Azure Cosmos DB does not support synchronous I/O. Make sure to use and correctly await only async methods when using Entity Framework Core to access Azure Cosmos DB. See https://aka.ms/ef-cosmos-nosync for more information.</value>
-    <comment>Error CosmosEventId.SyncNotSupported</comment>
-  </data>
   <data name="MissingOrderingInSelectExpression" xml:space="preserve">
     <value>'Reverse' could not be translated to the server because there is no ordering on the server side.</value>
   </data>
@@ -353,6 +349,9 @@
   <data name="SingleFirstOrDefaultNotSupportedOnNonNullableQueries" xml:space="preserve">
     <value>SingleOrDefault and FirstOrDefault cannot be used Cosmos SQL does not allow Offset without Limit. Consider specifying a 'Take' operation on the query.</value>
   </data>
+  <data name="SyncNotSupported" xml:space="preserve">
+    <value>Azure Cosmos DB does not support synchronous I/O. Make sure to use and correctly await only async methods when using Entity Framework Core to access Azure Cosmos DB.</value>
+  </data>
   <data name="ThroughputMismatch" xml:space="preserve">
     <value>The provisioned throughput was configured to '{throughput1}' on '{entityType1}', but on '{entityType2}' it was configured to '{throughput2}'. All entity types mapped to the same container '{container}' must be configured with the same provisioned throughput.</value>
   </data>
diff --git a/src/EFCore.Cosmos/Query/Internal/CosmosShapedQueryCompilingExpressionVisitor.QueryingEnumerable.cs b/src/EFCore.Cosmos/Query/Internal/CosmosShapedQueryCompilingExpressionVisitor.QueryingEnumerable.cs
index ced9ff5422..58c976b5ac 100644
--- a/src/EFCore.Cosmos/Query/Internal/CosmosShapedQueryCompilingExpressionVisitor.QueryingEnumerable.cs
+++ b/src/EFCore.Cosmos/Query/Internal/CosmosShapedQueryCompilingExpressionVisitor.QueryingEnumerable.cs
@@ -5,6 +5,7 @@
 
 using System.Collections;
 using System.Text;
+using Microsoft.EntityFrameworkCore.Cosmos.Internal;
 using Microsoft.EntityFrameworkCore.Cosmos.Storage.Internal;
 using Newtonsoft.Json.Linq;
 
@@ -64,7 +65,7 @@ public IAsyncEnumerator<T> GetAsyncEnumerator(CancellationToken cancellationToke
             => new AsyncEnumerator(this, cancellationToken);
 
         public IEnumerator<T> GetEnumerator()
-            => new Enumerator(this);
+            => throw new InvalidOperationException(CosmosStrings.SyncNotSupported);
 
         IEnumerator IEnumerable.GetEnumerator()
             => GetEnumerator();
@@ -99,95 +100,6 @@ public string ToQueryString()
             return builder.Append(sqlQuery.Query).ToString();
         }
 
-        private sealed class Enumerator : IEnumerator<T>
-        {
-            private readonly QueryingEnumerable<T> _queryingEnumerable;
-            private readonly CosmosQueryContext _cosmosQueryContext;
-            private readonly Func<CosmosQueryContext, JToken, T> _shaper;
-            private readonly Type _contextType;
-            private readonly string _cosmosContainer;
-            private readonly PartitionKey _cosmosPartitionKey;
-            private readonly IDiagnosticsLogger<DbLoggerCategory.Query> _queryLogger;
-            private readonly bool _standAloneStateManager;
-            private readonly IConcurrencyDetector _concurrencyDetector;
-            private readonly IExceptionDetector _exceptionDetector;
-
-            private IEnumerator<JToken> _enumerator;
-
-            public Enumerator(QueryingEnumerable<T> queryingEnumerable)
-            {
-                _queryingEnumerable = queryingEnumerable;
-                _cosmosQueryContext = queryingEnumerable._cosmosQueryContext;
-                _shaper = queryingEnumerable._shaper;
-                _contextType = queryingEnumerable._contextType;
-                _cosmosContainer = queryingEnumerable._cosmosContainer;
-                _cosmosPartitionKey = queryingEnumerable._cosmosPartitionKey;
-                _queryLogger = queryingEnumerable._queryLogger;
-                _standAloneStateManager = queryingEnumerable._standAloneStateManager;
-                _exceptionDetector = _cosmosQueryContext.ExceptionDetector;
-
-                _concurrencyDetector = queryingEnumerable._threadSafetyChecksEnabled
-                    ? _cosmosQueryContext.ConcurrencyDetector
-                    : null;
-            }
-
-            public T Current { get; private set; }
-
-            object IEnumerator.Current
-                => Current;
-
-            public bool MoveNext()
-            {
-                try
-                {
-                    using var _ = _concurrencyDetector?.EnterCriticalSection();
-
-                    if (_enumerator == null)
-                    {
-                        var sqlQuery = _queryingEnumerable.GenerateQuery();
-
-                        EntityFrameworkMetricsData.ReportQueryExecuting();
-
-                        _enumerator = _cosmosQueryContext.CosmosClient
-                            .ExecuteSqlQuery(_cosmosContainer, _cosmosPartitionKey, sqlQuery)
-                            .GetEnumerator();
-                        _cosmosQueryContext.InitializeStateManager(_standAloneStateManager);
-                    }
-
-                    var hasNext = _enumerator.MoveNext();
-
-                    Current
-                        = hasNext
-                            ? _shaper(_cosmosQueryContext, _enumerator.Current)
-                            : default;
-
-                    return hasNext;
-                }
-                catch (Exception exception)
-                {
-                    if (_exceptionDetector.IsCancellation(exception))
-                    {
-                        _queryLogger.QueryCanceled(_contextType);
-                    }
-                    else
-                    {
-                        _queryLogger.QueryIterationFailed(_contextType, exception);
-                    }
-
-                    throw;
-                }
-            }
-
-            public void Dispose()
-            {
-                _enumerator?.Dispose();
-                _enumerator = null;
-            }
-
-            public void Reset()
-                => throw new NotSupportedException(CoreStrings.EnumerableResetNotSupported);
-        }
-
         private sealed class AsyncEnumerator : IAsyncEnumerator<T>
         {
             private readonly QueryingEnumerable<T> _queryingEnumerable;
diff --git a/src/EFCore.Cosmos/Query/Internal/CosmosShapedQueryCompilingExpressionVisitor.ReadItemQueryingEnumerable.cs b/src/EFCore.Cosmos/Query/Internal/CosmosShapedQueryCompilingExpressionVisitor.ReadItemQueryingEnumerable.cs
index 6884390298..eae16897ff 100644
--- a/src/EFCore.Cosmos/Query/Internal/CosmosShapedQueryCompilingExpressionVisitor.ReadItemQueryingEnumerable.cs
+++ b/src/EFCore.Cosmos/Query/Internal/CosmosShapedQueryCompilingExpressionVisitor.ReadItemQueryingEnumerable.cs
@@ -57,10 +57,10 @@ private sealed class ReadItemQueryingEnumerable<T> : IEnumerable<T>, IAsyncEnume
         }
 
         public IAsyncEnumerator<T> GetAsyncEnumerator(CancellationToken cancellationToken = default)
-            => new Enumerator(this, cancellationToken);
+            => new AsyncEnumerator(this, cancellationToken);
 
         public IEnumerator<T> GetEnumerator()
-            => new Enumerator(this);
+            => throw new InvalidOperationException(CosmosStrings.SyncNotSupported);
 
         IEnumerator IEnumerable.GetEnumerator()
             => GetEnumerator();
@@ -100,7 +100,7 @@ private bool TryGetResourceId(out string resourceId)
             return true;
         }
 
-        private sealed class Enumerator : IEnumerator<T>, IAsyncEnumerator<T>
+        private sealed class AsyncEnumerator : IAsyncEnumerator<T>
         {
             private readonly CosmosQueryContext _cosmosQueryContext;
             private readonly string _cosmosContainer;
@@ -117,7 +117,7 @@ private sealed class Enumerator : IEnumerator<T>, IAsyncEnumerator<T>
             private JObject _item;
             private bool _hasExecuted;
 
-            public Enumerator(ReadItemQueryingEnumerable<T> readItemEnumerable, CancellationToken cancellationToken = default)
+            public AsyncEnumerator(ReadItemQueryingEnumerable<T> readItemEnumerable, CancellationToken cancellationToken = default)
             {
                 _cosmosQueryContext = readItemEnumerable._cosmosQueryContext;
                 _cosmosContainer = readItemEnumerable._cosmosContainer;
@@ -135,51 +135,8 @@ public Enumerator(ReadItemQueryingEnumerable<T> readItemEnumerable, Cancellation
                     : null;
             }
 
-            object IEnumerator.Current
-                => Current;
-
             public T Current { get; private set; }
 
-            public bool MoveNext()
-            {
-                try
-                {
-                    using var _ = _concurrencyDetector?.EnterCriticalSection();
-
-                    if (_hasExecuted)
-                    {
-                        return false;
-                    }
-
-                    if (!_readItemEnumerable.TryGetResourceId(out var resourceId))
-                    {
-                        throw new InvalidOperationException(CosmosStrings.ResourceIdMissing);
-                    }
-
-                    EntityFrameworkMetricsData.ReportQueryExecuting();
-
-                    _item = _cosmosQueryContext.CosmosClient.ExecuteReadItem(
-                        _cosmosContainer,
-                        _cosmosPartitionKey,
-                        resourceId);
-
-                    return ShapeResult();
-                }
-                catch (Exception exception)
-                {
-                    if (_exceptionDetector.IsCancellation(exception))
-                    {
-                        _queryLogger.QueryCanceled(_contextType);
-                    }
-                    else
-                    {
-                        _queryLogger.QueryIterationFailed(_contextType, exception);
-                    }
-
-                    throw;
-                }
-            }
-
             public async ValueTask<bool> MoveNextAsync()
             {
                 try
@@ -222,15 +179,10 @@ public async ValueTask<bool> MoveNextAsync()
                 }
             }
 
-            public void Dispose()
+            public ValueTask DisposeAsync()
             {
                 _item = null;
                 _hasExecuted = false;
-            }
-
-            public ValueTask DisposeAsync()
-            {
-                Dispose();
 
                 return default;
             }
diff --git a/src/EFCore.Cosmos/Storage/Internal/CosmosClientWrapper.cs b/src/EFCore.Cosmos/Storage/Internal/CosmosClientWrapper.cs
index 3f1b6f6264..ed2ab2804b 100644
--- a/src/EFCore.Cosmos/Storage/Internal/CosmosClientWrapper.cs
+++ b/src/EFCore.Cosmos/Storage/Internal/CosmosClientWrapper.cs
@@ -131,24 +131,6 @@ private static bool TryDeserializeNextToken(JsonTextReader jsonReader, out JToke
         }
     }
 
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public virtual bool CreateDatabaseIfNotExists(ThroughputProperties? throughput)
-    {
-        _databaseLogger.SyncNotSupported();
-
-        return _executionStrategy.Execute((throughput, this), CreateDatabaseIfNotExistsOnce, null);
-    }
-
-    private static bool CreateDatabaseIfNotExistsOnce(
-        DbContext? context,
-        (ThroughputProperties? Throughput, CosmosClientWrapper Wrapper) parameters)
-        => CreateDatabaseIfNotExistsOnceAsync(context, parameters).GetAwaiter().GetResult();
-
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -174,24 +156,6 @@ public virtual bool CreateDatabaseIfNotExists(ThroughputProperties? throughput)
         return response.StatusCode == HttpStatusCode.Created;
     }
 
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public virtual bool DeleteDatabase()
-    {
-        _databaseLogger.SyncNotSupported();
-
-        return _executionStrategy.Execute(this, DeleteDatabaseOnce, null);
-    }
-
-    private static bool DeleteDatabaseOnce(
-        DbContext? context,
-        CosmosClientWrapper wrapper)
-        => DeleteDatabaseOnceAsync(context, wrapper).GetAwaiter().GetResult();
-
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -219,24 +183,6 @@ public virtual bool DeleteDatabase()
         return response.StatusCode == HttpStatusCode.NoContent;
     }
 
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public virtual bool CreateContainerIfNotExists(ContainerProperties properties)
-    {
-        _databaseLogger.SyncNotSupported();
-
-        return _executionStrategy.Execute((properties, this), CreateContainerIfNotExistsOnce, null);
-    }
-
-    private static bool CreateContainerIfNotExistsOnce(
-        DbContext context,
-        (ContainerProperties Parameters, CosmosClientWrapper Wrapper) parametersTuple)
-        => CreateContainerIfNotExistsOnceAsync(context, parametersTuple).GetAwaiter().GetResult();
-
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -379,27 +325,6 @@ private static string GetPathFromRoot(IReadOnlyEntityType entityType)
         return "";
     }
 
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public virtual bool CreateItem(
-        string containerId,
-        JToken document,
-        IUpdateEntry entry)
-    {
-        _databaseLogger.SyncNotSupported();
-
-        return _executionStrategy.Execute((containerId, document, entry, this), CreateItemOnce, null);
-    }
-
-    private static bool CreateItemOnce(
-        DbContext context,
-        (string ContainerId, JToken Document, IUpdateEntry Entry, CosmosClientWrapper Wrapper) parameters)
-        => CreateItemOnceAsync(context, parameters).GetAwaiter().GetResult();
-
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -461,28 +386,6 @@ private static string GetPathFromRoot(IReadOnlyEntityType entityType)
         return response.StatusCode == HttpStatusCode.Created;
     }
 
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public virtual bool ReplaceItem(
-        string collectionId,
-        string documentId,
-        JObject document,
-        IUpdateEntry entry)
-    {
-        _databaseLogger.SyncNotSupported();
-
-        return _executionStrategy.Execute((collectionId, documentId, document, entry, this), ReplaceItemOnce, null);
-    }
-
-    private static bool ReplaceItemOnce(
-        DbContext context,
-        (string ContainerId, string ItemId, JObject Document, IUpdateEntry Entry, CosmosClientWrapper Wrapper) parameters)
-        => ReplaceItemOnceAsync(context, parameters).GetAwaiter().GetResult();
-
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -547,27 +450,6 @@ private static string GetPathFromRoot(IReadOnlyEntityType entityType)
         return response.StatusCode == HttpStatusCode.OK;
     }
 
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public virtual bool DeleteItem(
-        string containerId,
-        string documentId,
-        IUpdateEntry entry)
-    {
-        _databaseLogger.SyncNotSupported();
-
-        return _executionStrategy.Execute((containerId, documentId, entry, this), DeleteItemOnce, null);
-    }
-
-    private static bool DeleteItemOnce(
-        DbContext context,
-        (string ContainerId, string DocumentId, IUpdateEntry Entry, CosmosClientWrapper Wrapper) parameters)
-        => DeleteItemOnceAsync(context, parameters).GetAwaiter().GetResult();
-
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -604,23 +486,6 @@ public virtual ICosmosTransactionalBatchWrapper CreateTransactionalBatch(string
         return new CosmosTransactionalBatchWrapper(batch, containerId, partitionKeyValue, checkSize, _enableContentResponseOnWrite);
     }
 
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public virtual CosmosTransactionalBatchResult ExecuteTransactionalBatch(ICosmosTransactionalBatchWrapper batch)
-    {
-        _databaseLogger.SyncNotSupported();
-
-        return _executionStrategy.Execute((batch, this), ExecuteBatchOnce, null);
-    }
-
-    private static CosmosTransactionalBatchResult ExecuteBatchOnce(DbContext _,
-        (ICosmosTransactionalBatchWrapper Batch, CosmosClientWrapper Wrapper) parameters)
-        => ExecuteBatchOnceAsync(_, parameters).GetAwaiter().GetResult();
-
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -628,9 +493,9 @@ public virtual CosmosTransactionalBatchResult ExecuteTransactionalBatch(ICosmosT
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
     public virtual Task<CosmosTransactionalBatchResult> ExecuteTransactionalBatchAsync(ICosmosTransactionalBatchWrapper batch, CancellationToken cancellationToken = default)
-        => _executionStrategy.ExecuteAsync((batch, this), ExecuteBatchOnceAsync, null, cancellationToken);
+        => _executionStrategy.ExecuteAsync((batch, this), ExecuteTransactionalBatchOnceAsync, null, cancellationToken);
 
-    private static async Task<CosmosTransactionalBatchResult> ExecuteBatchOnceAsync(DbContext _,
+    private static async Task<CosmosTransactionalBatchResult> ExecuteTransactionalBatchOnceAsync(DbContext _,
         (ICosmosTransactionalBatchWrapper Batch, CosmosClientWrapper Wrapper) parameters,
         CancellationToken cancellationToken = default)
     {
@@ -794,24 +659,6 @@ private static void ProcessResponse(IUpdateEntry entry, string eTag, Stream? con
         }
     }
 
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public virtual IEnumerable<JToken> ExecuteSqlQuery(
-        string containerId,
-        PartitionKey partitionKeyValue,
-        CosmosSqlQuery query)
-    {
-        _databaseLogger.SyncNotSupported();
-
-        _commandLogger.ExecutingSqlQuery(containerId, partitionKeyValue, query);
-
-        return new DocumentEnumerable(this, containerId, partitionKeyValue, query);
-    }
-
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -828,34 +675,6 @@ private static void ProcessResponse(IUpdateEntry entry, string eTag, Stream? con
         return new DocumentAsyncEnumerable(this, containerId, partitionKeyValue, query);
     }
 
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public virtual JObject? ExecuteReadItem(
-        string containerId,
-        PartitionKey partitionKeyValue,
-        string resourceId)
-    {
-        _databaseLogger.SyncNotSupported();
-
-        _commandLogger.ExecutingReadItem(containerId, partitionKeyValue, resourceId);
-
-        var response = _executionStrategy.Execute((containerId, partitionKeyValue, resourceId, this), CreateSingleItemQuery, null);
-
-        _commandLogger.ExecutedReadItem(
-            response.Diagnostics.GetClientElapsedTime(),
-            response.Headers.RequestCharge,
-            response.Headers.ActivityId,
-            resourceId,
-            containerId,
-            partitionKeyValue);
-
-        return JObjectFromReadItemResponseMessage(response);
-    }
-
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -888,11 +707,6 @@ private static void ProcessResponse(IUpdateEntry entry, string eTag, Stream? con
         return JObjectFromReadItemResponseMessage(response);
     }
 
-    private static ResponseMessage CreateSingleItemQuery(
-        DbContext? context,
-        (string ContainerId, PartitionKey PartitionKeyValue, string ResourceId, CosmosClientWrapper Wrapper) parameters)
-        => CreateSingleItemQueryAsync(context, parameters).GetAwaiter().GetResult();
-
     private static Task<ResponseMessage> CreateSingleItemQueryAsync(
         DbContext? _,
         (string ContainerId, PartitionKey PartitionKeyValue, string ResourceId, CosmosClientWrapper Wrapper) parameters,
@@ -969,113 +783,6 @@ private static JsonTextReader CreateJsonReader(TextReader reader)
         return jsonReader;
     }
 
-    private sealed class DocumentEnumerable(
-        CosmosClientWrapper cosmosClient,
-        string containerId,
-        PartitionKey partitionKeyValue,
-        CosmosSqlQuery cosmosSqlQuery)
-        : IEnumerable<JToken>
-    {
-        private readonly CosmosClientWrapper _cosmosClient = cosmosClient;
-        private readonly string _containerId = containerId;
-        private readonly PartitionKey _partitionKeyValue = partitionKeyValue;
-        private readonly CosmosSqlQuery _cosmosSqlQuery = cosmosSqlQuery;
-
-        public IEnumerator<JToken> GetEnumerator()
-            => new Enumerator(this);
-
-        IEnumerator IEnumerable.GetEnumerator()
-            => GetEnumerator();
-
-        private sealed class Enumerator(DocumentEnumerable documentEnumerable) : IEnumerator<JToken>
-        {
-            private readonly CosmosClientWrapper _cosmosClientWrapper = documentEnumerable._cosmosClient;
-            private readonly string _containerId = documentEnumerable._containerId;
-            private readonly PartitionKey _partitionKeyValue = documentEnumerable._partitionKeyValue;
-            private readonly CosmosSqlQuery _cosmosSqlQuery = documentEnumerable._cosmosSqlQuery;
-
-            private JToken? _current;
-            private ResponseMessage? _responseMessage;
-            private IEnumerator<JToken>? _responseMessageEnumerator;
-
-            private FeedIterator? _query;
-
-            public JToken Current
-                => _current ?? throw new InvalidOperationException();
-
-            object IEnumerator.Current
-                => Current;
-
-            [MethodImpl(MethodImplOptions.AggressiveInlining)]
-            public bool MoveNext()
-            {
-                if (_responseMessageEnumerator == null)
-                {
-                    if (_query is null)
-                    {
-                        var queryRequestOptions = new QueryRequestOptions();
-                        if (_partitionKeyValue != PartitionKey.None)
-                        {
-                            queryRequestOptions.PartitionKey = _partitionKeyValue;
-                        }
-
-                        _query = _cosmosClientWrapper.CreateQuery(
-                            _containerId, _cosmosSqlQuery, continuationToken: null, queryRequestOptions);
-                    }
-
-                    if (!_query.HasMoreResults)
-                    {
-                        _current = null;
-                        return false;
-                    }
-
-                    _responseMessage = _cosmosClientWrapper._executionStrategy.Execute(
-                        (_query, _cosmosClientWrapper),
-                        static (_, state) => state._query.ReadNextAsync().GetAwaiter().GetResult(),
-                        null);
-
-                    _cosmosClientWrapper._commandLogger.ExecutedReadNext(
-                        _responseMessage.Diagnostics.GetClientElapsedTime(),
-                        _responseMessage.Headers.RequestCharge,
-                        _responseMessage.Headers.ActivityId,
-                        _containerId,
-                        _partitionKeyValue,
-                        _cosmosSqlQuery);
-
-                    _responseMessage.EnsureSuccessStatusCode();
-
-                    _responseMessageEnumerator = new ResponseMessageEnumerable(_responseMessage).GetEnumerator();
-                }
-
-                if (_responseMessageEnumerator.MoveNext())
-                {
-                    _current = _responseMessageEnumerator.Current;
-                    return true;
-                }
-
-                ResetRead();
-
-                return MoveNext();
-            }
-
-            private void ResetRead()
-            {
-                _responseMessageEnumerator?.Dispose();
-                _responseMessageEnumerator = null;
-                _responseMessage?.Dispose();
-            }
-
-            public void Dispose()
-            {
-                ResetRead();
-                _query?.Dispose();
-            }
-
-            public void Reset()
-                => throw new NotSupportedException(CoreStrings.EnumerableResetNotSupported);
-        }
-    }
-
     private sealed class DocumentAsyncEnumerable(
         CosmosClientWrapper cosmosClient,
         string containerId,
diff --git a/src/EFCore.Cosmos/Storage/Internal/CosmosDatabaseCreator.cs b/src/EFCore.Cosmos/Storage/Internal/CosmosDatabaseCreator.cs
index 0e38528d30..0c93c65b14 100644
--- a/src/EFCore.Cosmos/Storage/Internal/CosmosDatabaseCreator.cs
+++ b/src/EFCore.Cosmos/Storage/Internal/CosmosDatabaseCreator.cs
@@ -43,32 +43,6 @@ public class CosmosDatabaseCreator : IDatabaseCreator
         _contextOptions = contextOptions;
     }
 
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public virtual bool EnsureCreated()
-    {
-        var model = _designTimeModel.Model;
-        var created = _cosmosClient.CreateDatabaseIfNotExists(model.GetThroughput());
-
-        foreach (var container in GetContainersToCreate(model))
-        {
-            created |= _cosmosClient.CreateContainerIfNotExists(container);
-        }
-
-        if (created)
-        {
-            InsertData();
-        }
-
-        SeedData(created);
-
-        return created;
-    }
-
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -184,19 +158,6 @@ private static IEnumerable<ContainerProperties> GetContainersToCreate(IModel mod
         }
     }
 
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public virtual void InsertData()
-    {
-        var updateAdapter = AddModelData();
-
-        _database.SaveChanges(updateAdapter.GetEntriesToSave());
-    }
-
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -232,18 +193,17 @@ private IUpdateAdapter AddModelData()
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    public virtual void SeedData(bool created)
+    public virtual async Task SeedDataAsync(bool created, CancellationToken cancellationToken = default)
     {
         var coreOptionsExtension =
             _contextOptions.FindExtension<CoreOptionsExtension>()
             ?? new CoreOptionsExtension();
 
-        var seed = coreOptionsExtension.Seeder;
-        if (seed != null)
+        if (coreOptionsExtension.AsyncSeeder is not null)
         {
-            seed(_currentContext.Context, created);
+            await coreOptionsExtension.AsyncSeeder(_currentContext.Context, created, cancellationToken).ConfigureAwait(false);
         }
-        else if (coreOptionsExtension.AsyncSeeder != null)
+        else if (coreOptionsExtension.Seeder != null)
         {
             throw new InvalidOperationException(CoreStrings.MissingSeeder);
         }
@@ -255,31 +215,47 @@ public virtual void SeedData(bool created)
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    public virtual async Task SeedDataAsync(bool created, CancellationToken cancellationToken = default)
-    {
-        var coreOptionsExtension =
-            _contextOptions.FindExtension<CoreOptionsExtension>()
-            ?? new CoreOptionsExtension();
+    public virtual Task<bool> EnsureDeletedAsync(CancellationToken cancellationToken = default)
+        => _cosmosClient.DeleteDatabaseAsync(cancellationToken);
 
-        var seedAsync = coreOptionsExtension.AsyncSeeder;
-        if (seedAsync != null)
-        {
-            await seedAsync(_currentContext.Context, created, cancellationToken).ConfigureAwait(false);
-        }
-        else if (coreOptionsExtension.Seeder != null)
-        {
-            throw new InvalidOperationException(CoreStrings.MissingSeeder);
-        }
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual Task<bool> CanConnectAsync(CancellationToken cancellationToken = default)
+        => throw new NotSupportedException(CosmosStrings.CanConnectNotSupported);
+
+    /// <summary>
+    ///     Returns the store names of the properties that is used to store the partition keys.
+    /// </summary>
+    /// <remarks>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </remarks>
+    /// <param name="entityType">The entity type to get the partition key property names for.</param>
+    /// <returns>The names of the partition key property.</returns>
+    private static IReadOnlyList<string> GetPartitionKeyStoreNames(IEntityType entityType)
+    {
+        var properties = entityType.GetPartitionKeyProperties();
+        return properties.Any()
+            ? properties.Select(p => p.GetJsonPropertyName()).ToList()
+            : [CosmosClientWrapper.DefaultPartitionKey];
     }
 
+    #region Unsupported sync methods
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    public virtual bool EnsureDeleted()
-        => _cosmosClient.DeleteDatabase();
+    public virtual bool EnsureCreated()
+        => throw new InvalidOperationException(CosmosStrings.SyncNotSupported);
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
@@ -287,8 +263,8 @@ public virtual bool EnsureDeleted()
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    public virtual Task<bool> EnsureDeletedAsync(CancellationToken cancellationToken = default)
-        => _cosmosClient.DeleteDatabaseAsync(cancellationToken);
+    public virtual bool EnsureDeleted()
+        => throw new InvalidOperationException(CosmosStrings.SyncNotSupported);
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
@@ -297,7 +273,7 @@ public virtual Task<bool> EnsureDeletedAsync(CancellationToken cancellationToken
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
     public virtual bool CanConnect()
-        => throw new NotSupportedException(CosmosStrings.CanConnectNotSupported);
+        => throw new InvalidOperationException(CosmosStrings.SyncNotSupported);
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
@@ -305,25 +281,19 @@ public virtual bool CanConnect()
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    public virtual Task<bool> CanConnectAsync(CancellationToken cancellationToken = default)
-        => throw new NotSupportedException(CosmosStrings.CanConnectNotSupported);
+    public virtual void SeedData(bool created)
+        => throw new InvalidOperationException(CosmosStrings.SyncNotSupported);
 
     /// <summary>
-    ///     Returns the store names of the properties that is used to store the partition keys.
-    /// </summary>
-    /// <remarks>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </remarks>
-    /// <param name="entityType">The entity type to get the partition key property names for.</param>
-    /// <returns>The names of the partition key property.</returns>
-    private static IReadOnlyList<string> GetPartitionKeyStoreNames(IEntityType entityType)
+    /// </summary>
+    [Obsolete("Azure Cosmos DB does not support synchronous I/O, use InsertDataAsync.", error: true)]
+    public virtual void InsertData()
     {
-        var properties = entityType.GetPartitionKeyProperties();
-        return properties.Any()
-            ? properties.Select(p => p.GetJsonPropertyName()).ToList()
-            : [CosmosClientWrapper.DefaultPartitionKey];
     }
+
+    #endregion
 }
diff --git a/src/EFCore.Cosmos/Storage/Internal/CosmosDatabaseWrapper.cs b/src/EFCore.Cosmos/Storage/Internal/CosmosDatabaseWrapper.cs
index a8608b8e48..6fd56faea7 100644
--- a/src/EFCore.Cosmos/Storage/Internal/CosmosDatabaseWrapper.cs
+++ b/src/EFCore.Cosmos/Storage/Internal/CosmosDatabaseWrapper.cs
@@ -50,72 +50,6 @@ public class CosmosDatabaseWrapper : Database
         }
     }
 
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public override int SaveChanges(IList<IUpdateEntry> entries)
-    {
-        if (entries.Count == 0)
-        {
-            return 0;
-        }
-
-        var rowsAffected = 0;
-        var groups = CreateSaveGroups(entries);
-
-        foreach (var write in groups.SingleUpdateEntries)
-        {
-            if (Save(write))
-            {
-                rowsAffected++;
-            }
-        }
-
-        foreach (var batch in groups.BatchableUpdateEntries)
-        {
-            if (batch.UpdateEntries.Count == 1 && _currentDbContext.Context.Database.AutoTransactionBehavior != AutoTransactionBehavior.Always)
-            {
-                if (Save(batch.UpdateEntries[0]))
-                {
-                    rowsAffected++;
-                }
-
-                continue;
-            }
-
-            foreach (var transaction in CreateTransactions(batch))
-            {
-                try
-                {
-                    var response = _cosmosClient.ExecuteTransactionalBatch(transaction);
-                    if (!response.IsSuccess)
-                    {
-                        var exception = WrapUpdateException(response.Exception, response.ErroredEntries);
-                        if (exception is not DbUpdateConcurrencyException
-                            || !Dependencies.Logger.OptimisticConcurrencyException(
-                                    transaction.Entries.First().Entry.Context, transaction.Entries.Select(x => x.Entry).ToArray(), (DbUpdateConcurrencyException)exception, null)
-                                .IsSuppressed)
-                        {
-                            throw exception;
-                        }
-                    }
-                }
-                catch (Exception ex) when (ex is not DbUpdateException and not OperationCanceledException)
-                {
-                    var exception = WrapUpdateException(ex, transaction.Entries.Select(x => x.Entry).ToArray());
-                    throw exception;
-                }
-
-                rowsAffected += transaction.Entries.Count;
-            }
-        }
-
-        return rowsAffected;
-    }
-
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -276,7 +210,7 @@ private SaveGroups CreateSaveGroups(IList<IUpdateEntry> entries)
                 SingleUpdateEntries = []
             };
         }
-        
+
         var batches = CreateBatches(entriesWithoutTriggers);
 
         return new SaveGroups
@@ -407,7 +341,7 @@ private List<(Grouping Key, List<CosmosUpdateEntry> UpdateEntries)> CreateBatche
                                 Dependencies.Logger.PrimaryKeyValueNotSet(primaryKey.Properties[0]);
                             }
                         }
-                        catch(InvalidOperationException ex)
+                        catch (InvalidOperationException ex)
                         {
                             throw WrapUpdateException(ex, [entry]);
                         }
@@ -512,39 +446,6 @@ private bool AddToTransaction(ICosmosTransactionalBatchWrapper transaction, Cosm
         };
     }
 
-    private bool Save(CosmosUpdateEntry updateEntry)
-    {
-        try
-        {
-            return updateEntry.Operation switch
-            {
-                CosmosCudOperation.Create => _cosmosClient.CreateItem(
-                                    updateEntry.CollectionId, updateEntry.Document!, updateEntry.Entry),
-                CosmosCudOperation.Update => _cosmosClient.ReplaceItem(
-                                    updateEntry.CollectionId,
-                                    updateEntry.DocumentSource.GetId(updateEntry.Entry.SharedIdentityEntry ?? updateEntry.Entry),
-                                    updateEntry.Document!,
-                                    updateEntry.Entry),
-                CosmosCudOperation.Delete => _cosmosClient.DeleteItem(updateEntry.CollectionId, updateEntry.DocumentSource.GetId(updateEntry.Entry), updateEntry.Entry),
-                _ => throw new UnreachableException(),
-            };
-        }
-        catch (Exception ex) when (ex is not DbUpdateException and not UnreachableException and not OperationCanceledException)
-        {
-            var errorEntries = new[] { updateEntry.Entry };
-            var exception = WrapUpdateException(ex, errorEntries);
-
-            if (exception is not DbUpdateConcurrencyException
-                || !Dependencies.Logger.OptimisticConcurrencyException(
-                        updateEntry.Entry.Context, errorEntries, (DbUpdateConcurrencyException)exception, null).IsSuppressed)
-            {
-                throw exception;
-            }
-
-            return false;
-        }
-    }
-
     private async Task<bool> SaveAsync(CosmosUpdateEntry updateEntry, CancellationToken cancellationToken)
     {
         try
@@ -651,7 +552,7 @@ private DbUpdateException WrapUpdateException(Exception exception, IReadOnlyList
     private sealed class SaveGroups
     {
         public required IEnumerable<CosmosUpdateEntry> SingleUpdateEntries { get; init; }
-        
+
         public required IEnumerable<(Grouping Key, List<CosmosUpdateEntry> UpdateEntries)> BatchableUpdateEntries { get; init; }
     }
 
@@ -665,4 +566,13 @@ private sealed class CosmosUpdateEntry
     }
 
     private sealed record Grouping(string ContainerId, PartitionKey PartitionKeyValue);
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public override int SaveChanges(IList<IUpdateEntry> entries)
+        => throw new InvalidOperationException(CosmosStrings.SyncNotSupported);
 }
diff --git a/src/EFCore.Cosmos/Storage/Internal/ICosmosClientWrapper.cs b/src/EFCore.Cosmos/Storage/Internal/ICosmosClientWrapper.cs
index 3c3d545ec9..2775250ef7 100644
--- a/src/EFCore.Cosmos/Storage/Internal/ICosmosClientWrapper.cs
+++ b/src/EFCore.Cosmos/Storage/Internal/ICosmosClientWrapper.cs
@@ -13,14 +13,6 @@ namespace Microsoft.EntityFrameworkCore.Cosmos.Storage.Internal;
 /// </summary>
 public interface ICosmosClientWrapper
 {
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    bool CreateDatabaseIfNotExists(ThroughputProperties? throughput);
-
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -29,14 +21,6 @@ public interface ICosmosClientWrapper
     /// </summary>
     Task<bool> CreateDatabaseIfNotExistsAsync(ThroughputProperties? throughput, CancellationToken cancellationToken = default);
 
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    bool CreateContainerIfNotExists(ContainerProperties properties);
-
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -45,14 +29,6 @@ public interface ICosmosClientWrapper
     /// </summary>
     Task<bool> CreateContainerIfNotExistsAsync(ContainerProperties properties, CancellationToken cancellationToken = default);
 
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    bool DeleteDatabase();
-
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -61,37 +37,6 @@ public interface ICosmosClientWrapper
     /// </summary>
     Task<bool> DeleteDatabaseAsync(CancellationToken cancellationToken = default);
 
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    bool CreateItem(string containerId, JToken document, IUpdateEntry entry);
-
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    bool ReplaceItem(
-        string collectionId,
-        string documentId,
-        JObject document,
-        IUpdateEntry entry);
-
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    bool DeleteItem(
-        string containerId,
-        string documentId,
-        IUpdateEntry entry);
-
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -141,17 +86,6 @@ public interface ICosmosClientWrapper
         string? continuationToken = null,
         QueryRequestOptions? queryRequestOptions = null);
 
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    JObject? ExecuteReadItem(
-        string containerId,
-        PartitionKey partitionKeyValue,
-        string resourceId);
-
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -164,17 +98,6 @@ public interface ICosmosClientWrapper
         string resourceId,
         CancellationToken cancellationToken = default);
 
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    IEnumerable<JToken> ExecuteSqlQuery(
-        string containerId,
-        PartitionKey partitionKeyValue,
-        CosmosSqlQuery query);
-
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -217,12 +140,4 @@ public interface ICosmosClientWrapper
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
     Task<CosmosTransactionalBatchResult> ExecuteTransactionalBatchAsync(ICosmosTransactionalBatchWrapper batch, CancellationToken cancellationToken = default);
-
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    CosmosTransactionalBatchResult ExecuteTransactionalBatch(ICosmosTransactionalBatchWrapper batch);
 }
diff --git a/test/EFCore.Cosmos.FunctionalTests/ConcurrencyDetectorEnabledCosmosTest.cs b/test/EFCore.Cosmos.FunctionalTests/ConcurrencyDetectorEnabledCosmosTest.cs
index d60d12e7e6..93660ba35d 100644
--- a/test/EFCore.Cosmos.FunctionalTests/ConcurrencyDetectorEnabledCosmosTest.cs
+++ b/test/EFCore.Cosmos.FunctionalTests/ConcurrencyDetectorEnabledCosmosTest.cs
@@ -9,10 +9,64 @@ public class ConcurrencyDetectorEnabledCosmosTest(ConcurrencyDetectorEnabledCosm
     : ConcurrencyDetectorEnabledTestBase<
         ConcurrencyDetectorEnabledCosmosTest.ConcurrencyDetectorCosmosFixture>(fixture)
 {
+    public override async Task Find(bool async)
+    {
+        // Always throws for sync.
+        if (async)
+        {
+            await base.Find(async);
+        }
+    }
+
+    public override async Task Count(bool async)
+    {
+        // Always throws for sync.
+        if (async)
+        {
+            await base.Count(async);
+        }
+    }
+
+    public override async Task First(bool async)
+    {
+        // Always throws for sync.
+        if (async)
+        {
+            await base.First(async);
+        }
+    }
+
+    public override async Task Last(bool async)
+    {
+        // Always throws for sync.
+        if (async)
+        {
+            await base.Last(async);
+        }
+    }
+
+    public override async Task Single(bool async)
+    {
+        // Always throws for sync.
+        if (async)
+        {
+            await base.Single(async);
+        }
+    }
+
     [ConditionalTheory(Skip = "Issue #17246")]
     public override Task Any(bool async)
         => base.Any(async);
 
+    public override async Task ToList(bool async)
+    {
+        // Always throws for sync.
+        if (async)
+        {
+            await base.ToList(async);
+        }
+    }
+
     public class ConcurrencyDetectorCosmosFixture : ConcurrencyDetectorFixtureBase
     {
         protected override ITestStoreFactory TestStoreFactory
diff --git a/test/EFCore.Cosmos.FunctionalTests/CosmosTriggersTest.cs b/test/EFCore.Cosmos.FunctionalTests/CosmosTriggersTest.cs
index 8d123cc673..43d82f252f 100644
--- a/test/EFCore.Cosmos.FunctionalTests/CosmosTriggersTest.cs
+++ b/test/EFCore.Cosmos.FunctionalTests/CosmosTriggersTest.cs
@@ -18,9 +18,7 @@ protected override ITestStoreFactory TestStoreFactory
     [ConditionalFact]
     public async Task Triggers_are_executed_on_SaveChanges()
     {
-        var contextFactory = await InitializeAsync<TriggersContext>(
-            shouldLogCategory: _ => true,
-            onConfiguring: o => o.ConfigureWarnings(w => w.Log(CosmosEventId.SyncNotSupported)));
+        var contextFactory = await InitializeAsync<TriggersContext>(shouldLogCategory: _ => true);
 
         using (var context = contextFactory.CreateContext())
         {
@@ -91,7 +89,7 @@ private async Task CreateTriggersInCosmosAsync(TriggersContext context)
     var context = getContext();
     var request = context.getRequest();
     var doc = request.getBody();
-    
+
     // Log the trigger execution using the same partition key as the document being created
     var logEntry = {
         id: 'log_' + Math.random().toString().replace('.', ''),
@@ -102,7 +100,7 @@ private async Task CreateTriggersInCosmosAsync(TriggersContext context)
         ExecutedAt: new Date().toISOString(),
         PartitionKey: doc.PartitionKey // Use the same partition key as the document
     };
-    
+
     // Create a separate document to track trigger execution
     var collection = context.getCollection();
     var accepted = collection.createDocument(collection.getSelfLink(), logEntry);
@@ -128,7 +126,7 @@ private async Task CreateTriggersInCosmosAsync(TriggersContext context)
             Body = @"
 function postDeleteTrigger() {
     var context = getContext();
-    
+
     // For delete operations, we can't access the deleted document
     // So we'll just create a log entry with a timestamp-based ID
     var logEntry = {
@@ -140,7 +138,7 @@ private async Task CreateTriggersInCosmosAsync(TriggersContext context)
         ExecutedAt: new Date().toISOString(),
         PartitionKey: 'Products' // Use the same partition key as Product documents
     };
-    
+
     // Create a separate document to track trigger execution
     var collection = context.getCollection();
     var accepted = collection.createDocument(collection.getSelfLink(), logEntry);
@@ -168,7 +166,7 @@ private async Task CreateTriggersInCosmosAsync(TriggersContext context)
     var context = getContext();
     var request = context.getRequest();
     var doc = request.getBody();
-    
+
     // Log the trigger execution using the same partition key as the document being updated
     var logEntry = {
         id: 'log_' + Math.random().toString().replace('.', ''),
@@ -179,7 +177,7 @@ private async Task CreateTriggersInCosmosAsync(TriggersContext context)
         ExecutedAt: new Date().toISOString(),
         PartitionKey: doc.PartitionKey // Use the same partition key as the document
     };
-    
+
     // Create a separate document to track trigger execution
     var collection = context.getCollection();
     var accepted = collection.createDocument(collection.getSelfLink(), logEntry);
diff --git a/test/EFCore.Cosmos.FunctionalTests/EndToEndCosmosTest.cs b/test/EFCore.Cosmos.FunctionalTests/EndToEndCosmosTest.cs
index 00feda6375..2fda062226 100644
--- a/test/EFCore.Cosmos.FunctionalTests/EndToEndCosmosTest.cs
+++ b/test/EFCore.Cosmos.FunctionalTests/EndToEndCosmosTest.cs
@@ -20,118 +20,7 @@ public async Task Can_add_update_delete_end_to_end(bool transactionalBatch)
         var contextFactory = await InitializeAsync<DbContext>(
             b => b.Entity<Customer>(),
             shouldLogCategory: _ => true,
-            onConfiguring: o => o.ConfigureWarnings(w => w.Log(CosmosEventId.SyncNotSupported, CosmosEventId.NoPartitionKeyDefined)));
-
-        var customer = new Customer { Id = 42, Name = "Theon" };
-
-        using (var context = CreateContext(contextFactory, transactionalBatch))
-        {
-            ListLoggerFactory.Clear();
-
-            context.Add(customer);
-
-            context.SaveChanges();
-
-            if (transactionalBatch)
-            {
-                var logEntry = ListLoggerFactory.Log.Single(e => e.Id == CosmosEventId.ExecutedTransactionalBatch);
-                Assert.Equal(LogLevel.Information, logEntry.Level);
-                Assert.Contains("TransactionalBatch", logEntry.Message);
-            }
-            else
-            {
-                var logEntry = ListLoggerFactory.Log.Single(e => e.Id == CosmosEventId.ExecutedCreateItem);
-                Assert.Equal(LogLevel.Information, logEntry.Level);
-                Assert.Contains("CreateItem", logEntry.Message);
-            }
-
-            Assert.Equal(1, ListLoggerFactory.Log.Count(l => l.Id == CosmosEventId.SyncNotSupported));
-        }
-
-        using (var context = CreateContext(contextFactory, transactionalBatch))
-        {
-            ListLoggerFactory.Clear();
-            var customerFromStore = context.Set<Customer>().Single();
-
-            var logEntry = ListLoggerFactory.Log.Single(e => e.Id == CosmosEventId.ExecutedReadNext);
-            Assert.Equal(LogLevel.Information, logEntry.Level);
-            Assert.Contains("ReadNext", logEntry.Message);
-            Assert.Single(ListLoggerFactory.Log, l => l.Id == CosmosEventId.SyncNotSupported);
-            ListLoggerFactory.Clear();
-
-            Assert.Equal(42, customerFromStore.Id);
-            Assert.Equal("Theon", customerFromStore.Name);
-
-            customerFromStore.Name = "Theon Greyjoy";
-
-            context.SaveChanges();
-
-            if (transactionalBatch)
-            {
-                logEntry = ListLoggerFactory.Log.Single(e => e.Id == CosmosEventId.ExecutedTransactionalBatch);
-                Assert.Equal(LogLevel.Information, logEntry.Level);
-                Assert.Contains("TransactionalBatch", logEntry.Message);
-            }
-            else
-            {
-                logEntry = ListLoggerFactory.Log.Single(e => e.Id == CosmosEventId.ExecutedReplaceItem);
-                Assert.Equal(LogLevel.Information, logEntry.Level);
-                Assert.Contains("ReplaceItem", logEntry.Message);
-            }
-
-            Assert.Single(ListLoggerFactory.Log, l => l.Id == CosmosEventId.SyncNotSupported);
-        }
-
-        using (var context = CreateContext(contextFactory, transactionalBatch))
-        {
-            ListLoggerFactory.Clear();
-            var customerFromStore = context.Find<Customer>(42);
-
-            var logEntry = ListLoggerFactory.Log.Single(e => e.Id == CosmosEventId.ExecutedReadItem);
-            Assert.Equal(LogLevel.Information, logEntry.Level);
-            Assert.Contains("ReadItem", logEntry.Message);
-            Assert.Single(ListLoggerFactory.Log, l => l.Id == CosmosEventId.SyncNotSupported);
-            ListLoggerFactory.Clear();
-
-            Assert.Equal(42, customerFromStore.Id);
-            Assert.Equal("Theon Greyjoy", customerFromStore.Name);
-
-            context.Remove(customerFromStore);
-
-            context.SaveChanges();
-
-            if (transactionalBatch)
-            {
-                logEntry = ListLoggerFactory.Log.Single(e => e.Id == CosmosEventId.ExecutedTransactionalBatch);
-                Assert.Equal(LogLevel.Information, logEntry.Level);
-                Assert.Contains("TransactionalBatch", logEntry.Message);
-            }
-            else
-            {
-                logEntry = ListLoggerFactory.Log.Single(e => e.Id == CosmosEventId.ExecutedDeleteItem);
-                Assert.Equal(LogLevel.Information, logEntry.Level);
-                Assert.Contains("DeleteItem", logEntry.Message);
-            }
-
-            Assert.Single(ListLoggerFactory.Log, l => l.Id == CosmosEventId.SyncNotSupported);
-        }
-
-        using (var context = CreateContext(contextFactory, transactionalBatch))
-        {
-            ListLoggerFactory.Clear();
-            Assert.Empty(context.Set<Customer>().ToList());
-
-            Assert.Single(ListLoggerFactory.Log, l => l.Id == CosmosEventId.SyncNotSupported);
-        }
-    }
-
-    [ConditionalTheory, InlineData(false), InlineData(true)]
-    public async Task Can_add_update_delete_end_to_end_async(bool transactionalBatch)
-    {
-        var contextFactory = await InitializeAsync<DbContext>(
-            b => b.Entity<Customer>(),
-            shouldLogCategory: _ => true,
-            onConfiguring: o => o.ConfigureWarnings(w => w.Log(CosmosEventId.SyncNotSupported, CosmosEventId.NoPartitionKeyDefined)));
+            onConfiguring: o => o.ConfigureWarnings(w => w.Log(CosmosEventId.NoPartitionKeyDefined)));
 
         var customer = new Customer { Id = 42, Name = "Theon" };
 
@@ -153,8 +42,6 @@ public async Task Can_add_update_delete_end_to_end_async(bool transactionalBatch
                 Assert.Equal(LogLevel.Information, logEntry.Level);
                 Assert.Contains("CreateItem", logEntry.Message);
             }
-
-            Assert.DoesNotContain(ListLoggerFactory.Log, l => l.Id == CosmosEventId.SyncNotSupported);
         }
 
         using (var context = CreateContext(contextFactory, transactionalBatch))
@@ -164,7 +51,6 @@ public async Task Can_add_update_delete_end_to_end_async(bool transactionalBatch
             var logEntry = ListLoggerFactory.Log.Single(e => e.Id == CosmosEventId.ExecutedReadNext);
             Assert.Equal(LogLevel.Information, logEntry.Level);
             Assert.Contains("ReadNext", logEntry.Message);
-            Assert.DoesNotContain(ListLoggerFactory.Log, l => l.Id == CosmosEventId.SyncNotSupported);
             ListLoggerFactory.Clear();
 
             Assert.Equal(42, customerFromStore.Id);
@@ -186,7 +72,6 @@ public async Task Can_add_update_delete_end_to_end_async(bool transactionalBatch
                 Assert.Equal(LogLevel.Information, logEntry.Level);
                 Assert.Contains("ReplaceItem", logEntry.Message);
             }
-            Assert.DoesNotContain(ListLoggerFactory.Log, l => l.Id == CosmosEventId.SyncNotSupported);
         }
 
         using (var context = CreateContext(contextFactory, transactionalBatch))
@@ -196,7 +81,6 @@ public async Task Can_add_update_delete_end_to_end_async(bool transactionalBatch
             var logEntry = ListLoggerFactory.Log.Single(e => e.Id == CosmosEventId.ExecutedReadItem);
             Assert.Equal(LogLevel.Information, logEntry.Level);
             Assert.Contains("ReadItem", logEntry.Message);
-            Assert.DoesNotContain(ListLoggerFactory.Log, l => l.Id == CosmosEventId.SyncNotSupported);
             ListLoggerFactory.Clear();
 
             Assert.Equal(42, customerFromStore.Id);
@@ -218,23 +102,21 @@ public async Task Can_add_update_delete_end_to_end_async(bool transactionalBatch
                 Assert.Equal(LogLevel.Information, logEntry.Level);
                 Assert.Contains("DeleteItem", logEntry.Message);
             }
-            Assert.DoesNotContain(ListLoggerFactory.Log, l => l.Id == CosmosEventId.SyncNotSupported);
         }
 
         using (var context = CreateContext(contextFactory, transactionalBatch))
         {
             Assert.Empty(await context.Set<Customer>().ToListAsync());
-            Assert.DoesNotContain(ListLoggerFactory.Log, l => l.Id == CosmosEventId.SyncNotSupported);
         }
     }
 
     [ConditionalTheory, InlineData(false), InlineData(true)]
-    public async Task Can_add_update_delete_detached_entity_end_to_end_async(bool transactionalBatch)
+    public async Task Can_add_update_delete_detached_entity_end_to_end(bool transactionalBatch)
     {
         var contextFactory = await InitializeAsync<DbContext>(
             b => b.Entity<Customer>(),
             shouldLogCategory: _ => true,
-            onConfiguring: o => o.ConfigureWarnings(w => w.Log(CosmosEventId.SyncNotSupported, CosmosEventId.NoPartitionKeyDefined)));
+            onConfiguring: o => o.ConfigureWarnings(w => w.Log(CosmosEventId.NoPartitionKeyDefined)));
 
         var customer = new Customer { Id = 42, Name = "Theon" };
         string storeId = null;
@@ -247,8 +129,6 @@ public async Task Can_add_update_delete_detached_entity_end_to_end_async(bool tr
             await context.AddAsync(customer);
 
             storeId = entry.Property<string>(CosmosJsonIdConvention.DefaultIdPropertyName).CurrentValue;
-
-            Assert.DoesNotContain(ListLoggerFactory.Log, l => l.Id == CosmosEventId.SyncNotSupported);
         }
 
         Assert.Equal("42", storeId);
@@ -259,8 +139,6 @@ public async Task Can_add_update_delete_detached_entity_end_to_end_async(bool tr
 
             Assert.Equal(42, customerFromStore.Id);
             Assert.Equal("Theon", customerFromStore.Name);
-
-            Assert.DoesNotContain(ListLoggerFactory.Log, l => l.Id == CosmosEventId.SyncNotSupported);
         }
 
         using (var context = CreateContext(contextFactory, transactionalBatch))
@@ -274,8 +152,6 @@ public async Task Can_add_update_delete_detached_entity_end_to_end_async(bool tr
             entry.State = EntityState.Modified;
 
             await context.SaveChangesAsync();
-
-            Assert.DoesNotContain(ListLoggerFactory.Log, l => l.Id == CosmosEventId.SyncNotSupported);
         }
 
         using (var context = CreateContext(contextFactory, transactionalBatch))
@@ -284,8 +160,6 @@ public async Task Can_add_update_delete_detached_entity_end_to_end_async(bool tr
 
             Assert.Equal(42, customerFromStore.Id);
             Assert.Equal("Theon Greyjoy", customerFromStore.Name);
-
-            Assert.DoesNotContain(ListLoggerFactory.Log, l => l.Id == CosmosEventId.SyncNotSupported);
         }
 
         using (var context = CreateContext(contextFactory, transactionalBatch))
@@ -295,24 +169,21 @@ public async Task Can_add_update_delete_detached_entity_end_to_end_async(bool tr
             entry.State = EntityState.Deleted;
 
             await context.SaveChangesAsync();
-
-            Assert.DoesNotContain(ListLoggerFactory.Log, l => l.Id == CosmosEventId.SyncNotSupported);
         }
 
         using (var context = CreateContext(contextFactory, transactionalBatch))
         {
             Assert.Empty(await context.Set<Customer>().ToListAsync());
-            Assert.DoesNotContain(ListLoggerFactory.Log, l => l.Id == CosmosEventId.SyncNotSupported);
         }
     }
 
     [ConditionalTheory, InlineData(false), InlineData(true)]
-    public async Task Can_add_update_untracked_properties_async(bool transactionalBatch)
+    public async Task Can_add_update_untracked_properties(bool transactionalBatch)
     {
         var contextFactory = await InitializeAsync<DbContext>(
             b => b.Entity<Customer>(),
             shouldLogCategory: _ => true,
-            onConfiguring: o => o.ConfigureWarnings(w => w.Log(CosmosEventId.SyncNotSupported, CosmosEventId.NoPartitionKeyDefined)));
+            onConfiguring: o => o.ConfigureWarnings(w => w.Log(CosmosEventId.NoPartitionKeyDefined)));
 
         var customer = new Customer { Id = 42, Name = "Theon" };
 
@@ -330,7 +201,6 @@ public async Task Can_add_update_untracked_properties_async(bool transactionalBa
 
             await context.SaveChangesAsync();
 
-            Assert.DoesNotContain(ListLoggerFactory.Log, l => l.Id == CosmosEventId.SyncNotSupported);
         }
 
         using (var context = CreateContext(contextFactory, transactionalBatch))
@@ -351,8 +221,6 @@ public async Task Can_add_update_untracked_properties_async(bool transactionalBa
             document["key2"] = "value2";
             entry.State = EntityState.Modified;
             await context.SaveChangesAsync();
-
-            Assert.DoesNotContain(ListLoggerFactory.Log, l => l.Id == CosmosEventId.SyncNotSupported);
         }
 
         using (var context = CreateContext(contextFactory, transactionalBatch))
@@ -371,8 +239,6 @@ public async Task Can_add_update_untracked_properties_async(bool transactionalBa
             customerFromStore.Name = "Theon Greyjoy";
 
             await context.SaveChangesAsync();
-
-            Assert.DoesNotContain(ListLoggerFactory.Log, l => l.Id == CosmosEventId.SyncNotSupported);
         }
 
         using (var context = CreateContext(contextFactory, transactionalBatch))
@@ -389,19 +255,16 @@ public async Task Can_add_update_untracked_properties_async(bool transactionalBa
             context.Remove(customerFromStore);
 
             await context.SaveChangesAsync();
-
-            Assert.DoesNotContain(ListLoggerFactory.Log, l => l.Id == CosmosEventId.SyncNotSupported);
         }
 
         using (var context = CreateContext(contextFactory, transactionalBatch))
         {
             Assert.Empty(await context.Set<Customer>().ToListAsync());
-            Assert.DoesNotContain(ListLoggerFactory.Log, l => l.Id == CosmosEventId.SyncNotSupported);
         }
     }
 
     [ConditionalTheory, InlineData(false), InlineData(true)]
-    public async Task Can_add_update_delete_end_to_end_with_Guid_async(bool transactionalBatch)
+    public async Task Can_add_update_delete_end_to_end_with_Guid(bool transactionalBatch)
     {
         var contextFactory = await InitializeAsync<DbContext>(
             b => b.Entity<CustomerGuid>(b =>
@@ -410,8 +273,7 @@ public async Task Can_add_update_delete_end_to_end_with_Guid_async(bool transact
                 b.Property(c => c.PartitionKey).HasConversion<string>().ToJsonProperty("pk");
                 b.HasPartitionKey(c => c.PartitionKey);
             }),
-            shouldLogCategory: _ => true,
-            onConfiguring: o => o.ConfigureWarnings(w => w.Log(CosmosEventId.SyncNotSupported)));
+            shouldLogCategory: _ => true);
 
         var customer = new CustomerGuid
         {
@@ -425,8 +287,6 @@ public async Task Can_add_update_delete_end_to_end_with_Guid_async(bool transact
             await context.AddAsync(customer);
 
             await context.SaveChangesAsync();
-
-            Assert.DoesNotContain(ListLoggerFactory.Log, l => l.Id == CosmosEventId.SyncNotSupported);
         }
 
         using (var context = CreateContext(contextFactory, transactionalBatch))
@@ -439,8 +299,6 @@ public async Task Can_add_update_delete_end_to_end_with_Guid_async(bool transact
             customerFromStore.Name = "Theon Greyjoy";
 
             await context.SaveChangesAsync();
-
-            Assert.DoesNotContain(ListLoggerFactory.Log, l => l.Id == CosmosEventId.SyncNotSupported);
         }
 
         using (var context = CreateContext(contextFactory, transactionalBatch))
@@ -453,19 +311,16 @@ public async Task Can_add_update_delete_end_to_end_with_Guid_async(bool transact
             context.Remove(customerFromStore);
 
             await context.SaveChangesAsync();
-
-            Assert.DoesNotContain(ListLoggerFactory.Log, l => l.Id == CosmosEventId.SyncNotSupported);
         }
 
         using (var context = CreateContext(contextFactory, transactionalBatch))
         {
             Assert.Empty(await context.Set<CustomerGuid>().ToListAsync());
-            Assert.DoesNotContain(ListLoggerFactory.Log, l => l.Id == CosmosEventId.SyncNotSupported);
         }
     }
 
     [ConditionalTheory, InlineData(false), InlineData(true)]
-    public async Task Can_add_update_delete_end_to_end_with_DateTime_async(bool transactionalBatch)
+    public async Task Can_add_update_delete_end_to_end_with_DateTime(bool transactionalBatch)
     {
         var contextFactory = await InitializeAsync<DbContext>(
             b => b.Entity<CustomerDateTime>(b =>
@@ -475,8 +330,7 @@ public async Task Can_add_update_delete_end_to_end_with_DateTime_async(bool tran
                 b.HasPartitionKey(c => c.PartitionKey);
                 b.HasKey(c => new { c.Id, c.Name });
             }),
-            shouldLogCategory: _ => true,
-            onConfiguring: o => o.ConfigureWarnings(w => w.Log(CosmosEventId.SyncNotSupported)));
+            shouldLogCategory: _ => true);
 
         var customer = new CustomerDateTime
         {
@@ -492,8 +346,6 @@ public async Task Can_add_update_delete_end_to_end_with_DateTime_async(bool tran
             Assert.Equal("0001-01-01T00:00:00.0000000|Theon^2F^5C^23^5C^5C^3F", entry.CurrentValues["__id"]);
 
             await context.SaveChangesAsync();
-
-            Assert.DoesNotContain(ListLoggerFactory.Log, l => l.Id == CosmosEventId.SyncNotSupported);
         }
 
         using (var context = CreateContext(contextFactory, transactionalBatch))
@@ -506,8 +358,6 @@ public async Task Can_add_update_delete_end_to_end_with_DateTime_async(bool tran
             customerFromStore.Value = 23;
 
             await context.SaveChangesAsync();
-
-            Assert.DoesNotContain(ListLoggerFactory.Log, l => l.Id == CosmosEventId.SyncNotSupported);
         }
 
         using (var context = CreateContext(contextFactory, transactionalBatch))
@@ -520,14 +370,11 @@ public async Task Can_add_update_delete_end_to_end_with_DateTime_async(bool tran
             context.Remove(customerFromStore);
 
             await context.SaveChangesAsync();
-
-            Assert.DoesNotContain(ListLoggerFactory.Log, l => l.Id == CosmosEventId.SyncNotSupported);
         }
 
         using (var context = CreateContext(contextFactory, transactionalBatch))
         {
             Assert.Empty(await context.Set<CustomerDateTime>().ToListAsync());
-            Assert.DoesNotContain(ListLoggerFactory.Log, l => l.Id == CosmosEventId.SyncNotSupported);
         }
     }
 
@@ -570,12 +417,12 @@ private class CustomerNoPartitionKey
     }
 
     [ConditionalTheory, InlineData(false), InlineData(true)]
-    public async Task Can_add_update_delete_with_dateTime_string_end_to_end_async(bool transactionalBatch)
+    public async Task Can_add_update_delete_with_dateTime_string_end_to_end(bool transactionalBatch)
     {
         var contextFactory = await InitializeAsync<DbContext>(
             b => b.Entity<Customer>(),
             shouldLogCategory: _ => true,
-            onConfiguring: o => o.ConfigureWarnings(w => w.Log(CosmosEventId.SyncNotSupported, CosmosEventId.NoPartitionKeyDefined)));
+            onConfiguring: o => o.ConfigureWarnings(w => w.Log(CosmosEventId.NoPartitionKeyDefined)));
 
         var customer = new Customer { Id = 42, Name = "2021-08-23T06:23:40+00:00" };
 
@@ -584,8 +431,6 @@ public async Task Can_add_update_delete_with_dateTime_string_end_to_end_async(bo
             await context.AddAsync(customer);
 
             await context.SaveChangesAsync();
-
-            Assert.DoesNotContain(ListLoggerFactory.Log, l => l.Id == CosmosEventId.SyncNotSupported);
         }
 
         using (var context = CreateContext(contextFactory, transactionalBatch))
@@ -603,8 +448,6 @@ public async Task Can_add_update_delete_with_dateTime_string_end_to_end_async(bo
             customerFromStore.Name = "2021-08-23T06:23:40+02:00";
 
             await context.SaveChangesAsync();
-
-            Assert.DoesNotContain(ListLoggerFactory.Log, l => l.Id == CosmosEventId.SyncNotSupported);
         }
 
         using (var context = CreateContext(contextFactory, transactionalBatch))
@@ -617,14 +460,11 @@ public async Task Can_add_update_delete_with_dateTime_string_end_to_end_async(bo
             context.Remove(customerFromStore);
 
             await context.SaveChangesAsync();
-
-            Assert.DoesNotContain(ListLoggerFactory.Log, l => l.Id == CosmosEventId.SyncNotSupported);
         }
 
         using (var context = CreateContext(contextFactory, transactionalBatch))
         {
             Assert.Empty(await context.Set<Customer>().ToListAsync());
-            Assert.DoesNotContain(ListLoggerFactory.Log, l => l.Id == CosmosEventId.SyncNotSupported);
         }
     }
 
@@ -634,7 +474,7 @@ public async Task Entities_with_null_PK_can_be_added_with_normal_use_of_DbContex
         var contextFactory = await InitializeAsync<IdentifierShadowValuePresenceTestContext>(
             usePooling: false,
             shouldLogCategory: _ => true,
-            onConfiguring: o => o.ConfigureWarnings(w => w.Log(CosmosEventId.SyncNotSupported, CosmosEventId.NoPartitionKeyDefined)));
+            onConfiguring: o => o.ConfigureWarnings(w => w.Log(CosmosEventId.NoPartitionKeyDefined)));
 
         var context = CreateContext(contextFactory, transactionalBatch);
         var item = new GItem();
@@ -658,7 +498,7 @@ public async Task Entities_can_be_tracked_with_normal_use_of_DbContext_methods_a
         var contextFactory = await InitializeAsync<IdentifierShadowValuePresenceTestContext>(
             usePooling: false,
             shouldLogCategory: _ => true,
-            onConfiguring: o => o.ConfigureWarnings(w => w.Log(CosmosEventId.SyncNotSupported, CosmosEventId.NoPartitionKeyDefined)));
+            onConfiguring: o => o.ConfigureWarnings(w => w.Log(CosmosEventId.NoPartitionKeyDefined)));
 
         using var context = CreateContext(contextFactory, transactionalBatch);
 
@@ -933,7 +773,7 @@ public async Task Can_add_update_delete_with_nested_collections(bool transaction
         var contextFactory = await InitializeAsync<CollectionCustomerContext<TCollection>>(
             shouldLogCategory: _ => true,
             onModelCreating: onModelBuilder,
-            onConfiguring: o => o.ConfigureWarnings(w => w.Log(CosmosEventId.SyncNotSupported, CosmosEventId.NoPartitionKeyDefined)));
+            onConfiguring: o => o.ConfigureWarnings(w => w.Log(CosmosEventId.NoPartitionKeyDefined)));
 
         var customer = new CustomerWithCollection<TCollection>
         {
@@ -1000,11 +840,9 @@ protected override void OnModelCreating(ModelBuilder modelBuilder)
     }
 
     [ConditionalFact]
-    public async Task Can_read_with_find_with_resource_id_async()
+    public async Task Can_read_with_find_with_resource_id()
     {
-        var contextFactory = await InitializeAsync<PartitionKeyContextWithResourceId>(
-            shouldLogCategory: _ => true,
-            onConfiguring: o => o.ConfigureWarnings(w => w.Log(CosmosEventId.SyncNotSupported)));
+        var contextFactory = await InitializeAsync<PartitionKeyContextWithResourceId>(shouldLogCategory: _ => true);
 
         const int pk1 = 1;
         const int pk2 = 2;
@@ -1068,26 +906,23 @@ await using (var context = contextFactory.CreateContext())
     [ConditionalTheory, InlineData(false), InlineData(true)]
     public async Task Find_with_empty_resource_id_throws(bool transactionalBatch)
     {
-        var contextFactory = await InitializeAsync<PartitionKeyContextWithResourceId>(
-            shouldLogCategory: _ => true,
-            onConfiguring: o => o.ConfigureWarnings(w => w.Log(CosmosEventId.SyncNotSupported)));
+        var contextFactory = await InitializeAsync<PartitionKeyContextWithResourceId>(shouldLogCategory: _ => true);
 
         using (var context = CreateContext(contextFactory, transactionalBatch))
         {
-            context.Database.EnsureCreated();
+            await context.Database.EnsureCreatedAsync();
 
-            Assert.Equal(
-                CosmosStrings.InvalidResourceId,
-                Assert.Throws<InvalidOperationException>(() => context.Set<CustomerWithResourceId>().Find(1, 3.15m, "")).Message);
+            var exception = await Assert.ThrowsAsync<InvalidOperationException>(async () => await context.Set<CustomerWithResourceId>().FindAsync(1, 3.15m, ""));
+
+            Assert.Equal(CosmosStrings.InvalidResourceId, exception.Message);
         }
     }
 
     [ConditionalFact]
-    public async Task Can_read_with_find_with_partition_key_and_value_generator_async()
+    public async Task Can_read_with_find_with_partition_key_and_value_generator()
     {
         var contextFactory = await InitializeAsync<PartitionKeyContextCustomValueGenerator>(
             shouldLogCategory: _ => true,
-            onConfiguring: o => o.ConfigureWarnings(w => w.Log(CosmosEventId.SyncNotSupported)),
             addServices: s => s.AddSingleton<IJsonIdDefinitionFactory, CustomJsonIdDefinitionFactory>());
 
         const int pk1 = 1;
@@ -1151,9 +986,7 @@ await using (var context = contextFactory.CreateContext())
     [ConditionalFact]
     public async Task Can_read_with_find_with_partition_key_without_value_generator()
     {
-        var contextFactory = await InitializeAsync<PartitionKeyContextNoValueGenerator>(
-            shouldLogCategory: _ => true,
-            onConfiguring: o => o.ConfigureWarnings(w => w.Log(CosmosEventId.SyncNotSupported)));
+        var contextFactory = await InitializeAsync<PartitionKeyContextNoValueGenerator>(shouldLogCategory: _ => true);
 
         const int pk1 = 1;
 
@@ -1172,13 +1005,13 @@ public async Task Can_read_with_find_with_partition_key_without_value_generator(
             customerEntry.Property(CosmosJsonIdConvention.DefaultIdPropertyName).CurrentValue = "42";
             customerEntry.State = EntityState.Added;
 
-            context.SaveChanges();
+            await context.SaveChangesAsync();
         }
 
         using (var context = contextFactory.CreateContext())
         {
-            var customerFromStore = context.Set<Customer>()
-                .Find(pk1, "One", true, 42);
+            var customerFromStore = await context.Set<Customer>()
+                .FindAsync(pk1, "One", true, 42);
 
             Assert.Equal(42, customerFromStore.Id);
             Assert.Equal("Theon", customerFromStore.Name);
@@ -1193,14 +1026,14 @@ public async Task Can_read_with_find_with_partition_key_without_value_generator(
 
             customerFromStore.Name = "Theon Greyjoy";
 
-            context.SaveChanges();
+            await context.SaveChangesAsync();
         }
 
         using (var context = contextFactory.CreateContext())
         {
-            var customerFromStore = context.Set<Customer>()
+            var customerFromStore = await context.Set<Customer>()
                 .WithPartitionKey(pk1, "One", true)
-                .Single();
+                .SingleAsync();
 
             Assert.Equal(42, customerFromStore.Id);
             Assert.Equal("Theon Greyjoy", customerFromStore.Name);
@@ -1215,7 +1048,7 @@ public async Task Can_read_with_find_with_partition_key_not_part_of_primary_key(
     {
         var contextFactory = await InitializeAsync<PartitionKeyContextNonPrimaryKey>(
             shouldLogCategory: _ => true,
-            onConfiguring: o => o.ConfigureWarnings(w => w.Log(CosmosEventId.SyncNotSupported, CosmosEventId.NoPartitionKeyDefined)));
+            onConfiguring: o => o.ConfigureWarnings(w => w.Log(CosmosEventId.NoPartitionKeyDefined)));
 
         var customer = new Customer
         {
@@ -1237,7 +1070,7 @@ public async Task Can_read_with_find_with_partition_key_not_part_of_primary_key(
 
         using (var context = contextFactory.CreateContext())
         {
-            var customerFromStore = context.Set<Customer>().Find(42);
+            var customerFromStore = await context.Set<Customer>().FindAsync(42);
 
             Assert.Equal(42, customerFromStore.Id);
             Assert.Equal("Theon", customerFromStore.Name);
@@ -1250,7 +1083,7 @@ public async Task Can_read_with_find_without_partition_key()
     {
         var contextFactory = await InitializeAsync<PartitionKeyContextEntityWithNoPartitionKey>(
             shouldLogCategory: _ => true,
-            onConfiguring: o => o.ConfigureWarnings(w => w.Log(CosmosEventId.SyncNotSupported, CosmosEventId.NoPartitionKeyDefined)));
+            onConfiguring: o => o.ConfigureWarnings(w => w.Log(CosmosEventId.NoPartitionKeyDefined)));
 
         var customer = new CustomerNoPartitionKey { Id = 42, Name = "Theon" };
 
@@ -1263,7 +1096,7 @@ await using (var context = contextFactory.CreateContext())
 
         await using (var context = contextFactory.CreateContext())
         {
-            var customerFromStore = context.Set<CustomerNoPartitionKey>().Find(42);
+            var customerFromStore = await context.Set<CustomerNoPartitionKey>().FindAsync(42);
 
             Assert.Equal(42, customerFromStore.Id);
             Assert.Equal("Theon", customerFromStore.Name);
@@ -1274,9 +1107,7 @@ await using (var context = contextFactory.CreateContext())
     [ConditionalFact]
     public async Task Can_read_with_find_with_PK_partition_key()
     {
-        var contextFactory = await InitializeAsync<PartitionKeyContextPrimaryKey>(
-            shouldLogCategory: _ => true,
-            onConfiguring: o => o.ConfigureWarnings(w => w.Log(CosmosEventId.SyncNotSupported)));
+        var contextFactory = await InitializeAsync<PartitionKeyContextPrimaryKey>(shouldLogCategory: _ => true);
 
         var customer = new CustomerGuid { Id = Guid.NewGuid(), Name = "Theon" };
 
@@ -1289,7 +1120,7 @@ await using (var context = contextFactory.CreateContext())
 
         await using (var context = contextFactory.CreateContext())
         {
-            var customerFromStore = context.Set<CustomerGuid>().Find(customer.Id);
+            var customerFromStore = await context.Set<CustomerGuid>().FindAsync(customer.Id);
 
             Assert.Equal(customer.Id, customerFromStore.Id);
             Assert.Equal("Theon", customerFromStore.Name);
@@ -1300,9 +1131,7 @@ await using (var context = contextFactory.CreateContext())
     [ConditionalFact]
     public async Task Can_read_with_find_with_PK_resource_id()
     {
-        var contextFactory = await InitializeAsync<PartitionKeyContextWithPrimaryKeyResourceId>(
-            shouldLogCategory: _ => true,
-            onConfiguring: o => o.ConfigureWarnings(w => w.Log(CosmosEventId.SyncNotSupported)));
+        var contextFactory = await InitializeAsync<PartitionKeyContextWithPrimaryKeyResourceId>(shouldLogCategory: _ => true);
 
         var customer = new CustomerWithResourceId { id = "42", Name = "Theon" };
 
@@ -1315,7 +1144,7 @@ await using (var context = contextFactory.CreateContext())
 
         await using (var context = contextFactory.CreateContext())
         {
-            var customerFromStore = context.Set<CustomerWithResourceId>().Find("42");
+            var customerFromStore = await context.Set<CustomerWithResourceId>().FindAsync("42");
 
             Assert.Equal("42", customerFromStore.id);
             Assert.Equal("Theon", customerFromStore.Name);
@@ -1454,7 +1283,7 @@ public async Task Can_use_detached_entities_without_discriminators(bool transact
     {
         var contextFactory = await InitializeAsync<NoDiscriminatorCustomerContext>(
             shouldLogCategory: _ => true,
-            onConfiguring: o => o.ConfigureWarnings(w => w.Log(CosmosEventId.SyncNotSupported, CosmosEventId.NoPartitionKeyDefined)));
+            onConfiguring: o => o.ConfigureWarnings(w => w.Log(CosmosEventId.NoPartitionKeyDefined)));
 
         var customer = new Customer { Id = 42, Name = "Theon" };
 
@@ -1476,7 +1305,7 @@ public async Task Can_use_detached_entities_without_discriminators(bool transact
 
         using (var context = CreateContext(contextFactory, transactionalBatch))
         {
-            var customerFromStore = context.Set<Customer>().AsNoTracking().Single();
+            var customerFromStore = await context.Set<Customer>().AsNoTracking().SingleAsync();
 
             Assert.Equal(42, customerFromStore.Id);
             Assert.Equal("Theon Greyjoy", customerFromStore.Name);
@@ -1503,7 +1332,7 @@ public async Task Can_update_unmapped_properties(bool transactionalBatch)
     {
         var contextFactory = await InitializeAsync<ExtraCustomerContext>(
             shouldLogCategory: _ => true,
-            onConfiguring: o => o.ConfigureWarnings(w => w.Log(CosmosEventId.SyncNotSupported, CosmosEventId.NoPartitionKeyDefined)));
+            onConfiguring: o => o.ConfigureWarnings(w => w.Log(CosmosEventId.NoPartitionKeyDefined)));
 
         var customer = new Customer { Id = 42, Name = "Theon" };
 
@@ -1512,24 +1341,24 @@ public async Task Can_update_unmapped_properties(bool transactionalBatch)
             var entry = context.Add(customer);
             entry.Property<string>("EMail").CurrentValue = "theon.g@winterfell.com";
 
-            context.SaveChanges();
+            await context.SaveChangesAsync();
         }
 
         using (var context = CreateContext(contextFactory, transactionalBatch))
         {
-            var customerFromStore = context.Set<Customer>().Single();
+            var customerFromStore = await context.Set<Customer>().SingleAsync();
 
             Assert.Equal(42, customerFromStore.Id);
             Assert.Equal("Theon", customerFromStore.Name);
 
             customerFromStore.Name = "Theon Greyjoy";
 
-            context.SaveChanges();
+            await context.SaveChangesAsync();
         }
 
         using (var context = CreateContext(contextFactory, transactionalBatch))
         {
-            var customerFromStore = context.Set<Customer>().Single();
+            var customerFromStore = await context.Set<Customer>().SingleAsync();
 
             Assert.Equal(42, customerFromStore.Id);
             Assert.Equal("Theon Greyjoy", customerFromStore.Name);
@@ -1542,12 +1371,12 @@ public async Task Can_update_unmapped_properties(bool transactionalBatch)
 
             context.Remove(customerFromStore);
 
-            context.SaveChanges();
+            await context.SaveChangesAsync();
         }
 
         using (var context = CreateContext(contextFactory, transactionalBatch))
         {
-            Assert.Empty(context.Set<Customer>().ToList());
+            Assert.Empty(await context.Set<Customer>().ToListAsync());
         }
     }
 
@@ -1562,7 +1391,7 @@ public async Task Can_use_non_persisted_properties(bool transactionalBatch)
     {
         var contextFactory = await InitializeAsync<UnmappedCustomerContext>(
             shouldLogCategory: _ => true,
-            onConfiguring: o => o.ConfigureWarnings(w => w.Log(CosmosEventId.SyncNotSupported, CosmosEventId.NoPartitionKeyDefined)));
+            onConfiguring: o => o.ConfigureWarnings(w => w.Log(CosmosEventId.NoPartitionKeyDefined)));
 
         var customer = new Customer { Id = 42, Name = "Theon" };
 
@@ -1666,9 +1495,7 @@ public DbSet<Customer> Customers
     [ConditionalFact]
     public async Task Using_a_conflicting_incompatible_id_throws()
     {
-        var contextFactory = await InitializeAsync<PartitionKeyContextPrimaryKey>(
-            shouldLogCategory: _ => true,
-            onConfiguring: o => o.ConfigureWarnings(w => w.Log(CosmosEventId.SyncNotSupported)));
+        var contextFactory = await InitializeAsync<PartitionKeyContextPrimaryKey>(shouldLogCategory: _ => true);
 
         using var context = contextFactory.CreateContext();
 
@@ -1698,7 +1525,7 @@ public async Task Can_add_update_delete_end_to_end_with_conflicting_id(bool tran
     {
         var contextFactory = await InitializeAsync<ConflictingIdContext>(
             shouldLogCategory: _ => true,
-            onConfiguring: o => o.ConfigureWarnings(w => w.Log(CosmosEventId.SyncNotSupported, CosmosEventId.NoPartitionKeyDefined)));
+            onConfiguring: o => o.ConfigureWarnings(w => w.Log(CosmosEventId.NoPartitionKeyDefined)));
 
         var entity = new ConflictingId { id = "42", Name = "Theon" };
 
@@ -1711,7 +1538,7 @@ public async Task Can_add_update_delete_end_to_end_with_conflicting_id(bool tran
 
         using (var context = CreateContext(contextFactory, transactionalBatch))
         {
-            var entityFromStore = context.Set<ConflictingId>().Single();
+            var entityFromStore = await context.Set<ConflictingId>().SingleAsync();
 
             Assert.Equal("42", entityFromStore.id);
             Assert.Equal("Theon", entityFromStore.Name);
@@ -1728,7 +1555,7 @@ public async Task Can_add_update_delete_end_to_end_with_conflicting_id(bool tran
 
         using (var context = CreateContext(contextFactory, transactionalBatch))
         {
-            var entityFromStore = context.Set<ConflictingId>().Single();
+            var entityFromStore = await context.Set<ConflictingId>().SingleAsync();
 
             Assert.Equal("42", entityFromStore.id);
             Assert.Equal("Theon Greyjoy", entityFromStore.Name);
@@ -1743,7 +1570,7 @@ public async Task Can_add_update_delete_end_to_end_with_conflicting_id(bool tran
 
         using (var context = CreateContext(contextFactory, transactionalBatch))
         {
-            Assert.Empty(context.Set<ConflictingId>().ToList());
+            Assert.Empty(await context.Set<ConflictingId>().ToListAsync());
         }
     }
 
@@ -1777,7 +1604,7 @@ public async Task Can_have_non_string_property_named_Discriminator(bool useDiscr
                     b.Entity<NonStringDiscriminator>();
                 }
             },
-            onConfiguring: o => o.ConfigureWarnings(w => w.Log(CosmosEventId.SyncNotSupported, CosmosEventId.NoPartitionKeyDefined)));
+            onConfiguring: o => o.ConfigureWarnings(w => w.Log(CosmosEventId.NoPartitionKeyDefined)));
 
         using var context = contextFactory.CreateContext();
 
@@ -1894,7 +1721,7 @@ protected override ITestStoreFactory TestStoreFactory
             shouldLogCategory: _ => true,
             onConfiguring: options =>
             {
-                options.ConfigureWarnings(w => w.Log(CosmosEventId.SyncNotSupported)).EnableSensitiveDataLogging(sensitiveLogEnabled);
+                options.EnableSensitiveDataLogging(sensitiveLogEnabled);
                 onConfiguring?.Invoke(options);
             }
         );
diff --git a/test/EFCore.Cosmos.FunctionalTests/Query/NorthwindMiscellaneousQueryCosmosTest.cs b/test/EFCore.Cosmos.FunctionalTests/Query/NorthwindMiscellaneousQueryCosmosTest.cs
index 68f4977149..9f732656d5 100644
--- a/test/EFCore.Cosmos.FunctionalTests/Query/NorthwindMiscellaneousQueryCosmosTest.cs
+++ b/test/EFCore.Cosmos.FunctionalTests/Query/NorthwindMiscellaneousQueryCosmosTest.cs
@@ -533,20 +533,28 @@ public override async Task OrderBy_any(bool async)
 
     public override async Task Skip(bool async)
     {
-        Assert.Equal(
-            CosmosStrings.OffsetRequiresLimit,
-            (await Assert.ThrowsAsync<InvalidOperationException>(() => base.Skip(async))).Message);
+        // Always throws for sync.
+        if (async)
+        {
+            Assert.Equal(
+                CosmosStrings.OffsetRequiresLimit,
+                (await Assert.ThrowsAsync<InvalidOperationException>(() => base.Skip(async))).Message);
 
-        AssertSql();
+            AssertSql();
+        }
     }
 
     public override async Task Skip_no_orderby(bool async)
     {
-        Assert.Equal(
-            CosmosStrings.OffsetRequiresLimit,
-            (await Assert.ThrowsAsync<InvalidOperationException>(() => base.Skip_no_orderby(async))).Message);
+        // Always throws for sync.
+        if (async)
+        {
+            Assert.Equal(
+                CosmosStrings.OffsetRequiresLimit,
+                (await Assert.ThrowsAsync<InvalidOperationException>(() => base.Skip_no_orderby(async))).Message);
 
-        AssertSql();
+            AssertSql();
+        }
     }
 
     public override Task Skip_Take(bool async)
@@ -1911,16 +1919,23 @@ public override Task Environment_newline_is_funcletized(bool async)
                 await base.Environment_newline_is_funcletized(a);
 
                 var sql = Fixture.TestSqlLoggerFactory.SqlStatements[0];
-                Assert.StartsWith("@NewLine='", sql);
-                Assert.EndsWith(
-                    """
-'
+                var newlineString = Environment.NewLine switch
+                {
+                    "\n" => """\n""",
+                    "\r\n" => """\r\n""",
+                    _ => throw new UnreachableException()
+                };
+
+                Assert.Equal(
+                    $"""
+@NewLine='{newlineString}'
 
 SELECT VALUE c
 FROM root c
 WHERE CONTAINS(c["id"], @NewLine)
 """,
-                    sql);
+                    sql,
+                    ignoreLineEndingDifferences: true);
             });
 
     public override async Task String_concat_with_navigation1(bool async)
@@ -3414,11 +3429,15 @@ public override Task Select_Property_when_shadow_unconstrained_generic_method(bo
 
     public override async Task Skip_orderby_const(bool async)
     {
-        Assert.Equal(
-            CosmosStrings.OffsetRequiresLimit,
-            (await Assert.ThrowsAsync<InvalidOperationException>(() => base.Skip_orderby_const(async))).Message);
+        // Always throws for sync.
+        if (async)
+       {
+            Assert.Equal(
+                CosmosStrings.OffsetRequiresLimit,
+                (await Assert.ThrowsAsync<InvalidOperationException>(() => base.Skip_orderby_const(async))).Message);
 
-        AssertSql();
+            AssertSql();
+        }
     }
 
     public override Task Where_Property_when_shadow_unconstrained_generic_method(bool async)
diff --git a/test/EFCore.Cosmos.FunctionalTests/Query/NorthwindSelectQueryCosmosTest.cs b/test/EFCore.Cosmos.FunctionalTests/Query/NorthwindSelectQueryCosmosTest.cs
index 4f807ac3b1..57cdc29860 100644
--- a/test/EFCore.Cosmos.FunctionalTests/Query/NorthwindSelectQueryCosmosTest.cs
+++ b/test/EFCore.Cosmos.FunctionalTests/Query/NorthwindSelectQueryCosmosTest.cs
@@ -676,11 +676,15 @@ SELECT VALUE ((c["CustomerID"] = null) ? true : (c["OrderID"] < 100))
 
     public override async Task Projection_in_a_subquery_should_be_liftable(bool async)
     {
-        Assert.Equal(
-            CosmosStrings.OffsetRequiresLimit,
-            (await Assert.ThrowsAsync<InvalidOperationException>(() => base.Projection_in_a_subquery_should_be_liftable(async))).Message);
+        // Always throws for sync.
+        if (async)
+        {
+            Assert.Equal(
+                CosmosStrings.OffsetRequiresLimit,
+                (await Assert.ThrowsAsync<InvalidOperationException>(() => base.Projection_in_a_subquery_should_be_liftable(async))).Message);
 
-        AssertSql();
+            AssertSql();
+        }
     }
 
     public override Task Projection_containing_DateTime_subtraction(bool async)
@@ -1441,18 +1445,26 @@ SELECT VALUE ((c["id"] || " ") || c["City"])
 
     public override async Task Projection_skip_projection_doesnt_project_intermittent_column(bool async)
     {
-        var message = (await Assert.ThrowsAsync<InvalidOperationException>(()
-            => base.Projection_skip_projection_doesnt_project_intermittent_column(async))).Message;
+        // Always throws for sync.
+        if (async)
+        {
+            var message = (await Assert.ThrowsAsync<InvalidOperationException>(()
+                => base.Projection_skip_projection_doesnt_project_intermittent_column(async))).Message;
 
-        Assert.Equal(CosmosStrings.OffsetRequiresLimit, message);
+            Assert.Equal(CosmosStrings.OffsetRequiresLimit, message);
+        }
     }
 
     public override async Task Projection_Distinct_projection_preserves_columns_used_for_distinct_in_subquery(bool async)
     {
-        // Cosmos client evaluation. Issue #17246.
-        await AssertTranslationFailed(() => base.Projection_Distinct_projection_preserves_columns_used_for_distinct_in_subquery(async));
+        // Always throws for sync.
+        if (async)
+        {
+            // Cosmos client evaluation. Issue #17246.
+            await AssertTranslationFailed(() => base.Projection_Distinct_projection_preserves_columns_used_for_distinct_in_subquery(async));
 
-        AssertSql();
+            AssertSql();
+        }
     }
 
     public override async Task Projecting_count_of_navigation_which_is_generic_collection(bool async)
diff --git a/test/EFCore.Cosmos.FunctionalTests/Query/OwnedQueryCosmosTest.cs b/test/EFCore.Cosmos.FunctionalTests/Query/OwnedQueryCosmosTest.cs
index ba6392d3d9..aef51eb64a 100644
--- a/test/EFCore.Cosmos.FunctionalTests/Query/OwnedQueryCosmosTest.cs
+++ b/test/EFCore.Cosmos.FunctionalTests/Query/OwnedQueryCosmosTest.cs
@@ -424,17 +424,25 @@ public override Task No_ignored_include_warning_when_implicit_load(bool async)
 
     public override async Task Client_method_skip_loads_owned_navigations(bool async)
     {
-        var exception = await Assert.ThrowsAsync<InvalidOperationException>(() => base.Client_method_skip_loads_owned_navigations(async));
+        // Always throws for sync.
+        if (async)
+        {
+            var exception = await Assert.ThrowsAsync<InvalidOperationException>(() => base.Client_method_skip_loads_owned_navigations(async));
 
-        Assert.Equal(CosmosStrings.OffsetRequiresLimit, exception.Message);
+            Assert.Equal(CosmosStrings.OffsetRequiresLimit, exception.Message);
+        }
     }
 
     public override async Task Client_method_skip_loads_owned_navigations_variation_2(bool async)
     {
-        var exception =
-            await Assert.ThrowsAsync<InvalidOperationException>(() => base.Client_method_skip_loads_owned_navigations_variation_2(async));
+        // Always throws for sync.
+        if (async)
+        {
+            var exception =
+                await Assert.ThrowsAsync<InvalidOperationException>(() => base.Client_method_skip_loads_owned_navigations_variation_2(async));
 
-        Assert.Equal(CosmosStrings.OffsetRequiresLimit, exception.Message);
+            Assert.Equal(CosmosStrings.OffsetRequiresLimit, exception.Message);
+        }
     }
 
     public override Task Where_owned_collection_navigation_ToList_Count(bool async)
diff --git a/test/EFCore.Cosmos.FunctionalTests/Query/PrimitiveCollectionsQueryCosmosTest.cs b/test/EFCore.Cosmos.FunctionalTests/Query/PrimitiveCollectionsQueryCosmosTest.cs
index be05683173..63fa617720 100644
--- a/test/EFCore.Cosmos.FunctionalTests/Query/PrimitiveCollectionsQueryCosmosTest.cs
+++ b/test/EFCore.Cosmos.FunctionalTests/Query/PrimitiveCollectionsQueryCosmosTest.cs
@@ -1598,7 +1598,7 @@ public override async Task Parameter_collection_in_subquery_Union_column_collect
         var exception = await Assert.ThrowsAsync<InvalidOperationException>(
             base.Parameter_collection_in_subquery_Union_column_collection_as_compiled_query);
 
-        Assert.Equal(SyncNotSupportedMessage, exception.Message);
+        Assert.Equal(CosmosStrings.SyncNotSupported, exception.Message);
 
         AssertSql();
     }
@@ -1643,7 +1643,7 @@ public override async Task Parameter_collection_in_subquery_Count_as_compiled_qu
         var exception = await Assert.ThrowsAsync<InvalidOperationException>(
             base.Parameter_collection_in_subquery_Count_as_compiled_query);
 
-        Assert.Equal(SyncNotSupportedMessage, exception.Message);
+        Assert.Equal(CosmosStrings.SyncNotSupported, exception.Message);
 
         AssertSql();
     }
@@ -1657,7 +1657,7 @@ public override async Task Parameter_collection_in_subquery_Union_another_parame
         var exception = await Assert.ThrowsAsync<InvalidOperationException>(
             base.Parameter_collection_in_subquery_Union_another_parameter_collection_as_compiled_query);
 
-        Assert.Equal(SyncNotSupportedMessage, exception.Message);
+        Assert.Equal(CosmosStrings.SyncNotSupported, exception.Message);
 
         AssertSql();
     }
@@ -2053,10 +2053,4 @@ protected override void OnModelCreating(ModelBuilder modelBuilder, DbContext con
 
     private void AssertSql(params string[] expected)
         => Fixture.TestSqlLoggerFactory.AssertBaseline(expected);
-
-    private static readonly string SyncNotSupportedMessage
-        = CoreStrings.WarningAsErrorTemplate(
-            CosmosEventId.SyncNotSupported.ToString(),
-            CosmosResources.LogSyncNotSupported(new TestLogger<CosmosLoggingDefinitions>()).GenerateMessage(),
-            "CosmosEventId.SyncNotSupported");
 }
diff --git a/test/EFCore.Cosmos.FunctionalTests/TestUtilities/CosmosTestHelpers.cs b/test/EFCore.Cosmos.FunctionalTests/TestUtilities/CosmosTestHelpers.cs
index 56be8eb634..2fe44663c4 100644
--- a/test/EFCore.Cosmos.FunctionalTests/TestUtilities/CosmosTestHelpers.cs
+++ b/test/EFCore.Cosmos.FunctionalTests/TestUtilities/CosmosTestHelpers.cs
@@ -32,12 +32,6 @@ public override DbContextOptionsBuilder UseProviderOptions(DbContextOptionsBuild
                 TestEnvironment.AuthToken,
                 "UnitTests");
 
-    private static readonly string SyncMessage
-        = CoreStrings.WarningAsErrorTemplate(
-            CosmosEventId.SyncNotSupported.ToString(),
-            CosmosResources.LogSyncNotSupported(new TestLogger<CosmosLoggingDefinitions>()).GenerateMessage(),
-            "CosmosEventId.SyncNotSupported");
-
     public override LoggingDefinitions LoggingDefinitions { get; } = new CosmosLoggingDefinitions();
 
     public async Task NoSyncTest(bool async, Func<bool, Task> testCode)
@@ -49,7 +43,7 @@ public async Task NoSyncTest(bool async, Func<bool, Task> testCode)
         }
         catch (InvalidOperationException e)
         {
-            if (e.Message != SyncMessage)
+            if (e.Message != CosmosStrings.SyncNotSupported)
             {
                 throw;
             }
@@ -58,7 +52,7 @@ public async Task NoSyncTest(bool async, Func<bool, Task> testCode)
         }
         catch (DbUpdateException e)
         {
-            if (e.InnerException?.Message != SyncMessage)
+            if (e.InnerException?.Message != CosmosStrings.SyncNotSupported)
             {
                 throw;
             }
@@ -76,14 +70,14 @@ public void NoSyncTest(Action testCode)
         }
         catch (InvalidOperationException e)
         {
-            if (e.Message != SyncMessage)
+            if (e.Message != CosmosStrings.SyncNotSupported)
             {
                 throw;
             }
         }
         catch (DbUpdateException e)
         {
-            if (e.InnerException?.Message != SyncMessage)
+            if (e.InnerException?.Message != CosmosStrings.SyncNotSupported)
             {
                 throw;
             }
diff --git a/test/EFCore.Cosmos.FunctionalTests/TestUtilities/CosmosTestStore.cs b/test/EFCore.Cosmos.FunctionalTests/TestUtilities/CosmosTestStore.cs
index 346ba8887d..6107763f18 100644
--- a/test/EFCore.Cosmos.FunctionalTests/TestUtilities/CosmosTestStore.cs
+++ b/test/EFCore.Cosmos.FunctionalTests/TestUtilities/CosmosTestStore.cs
@@ -339,7 +339,7 @@ public override async Task CleanAsync(DbContext context)
         {
             if (!created)
             {
-                await DeleteContainers(context).ConfigureAwait(false);
+                await DeleteContainersAsync(context).ConfigureAwait(false);
             }
 
             if (!TestEnvironment.UseTokenCredential)
@@ -508,7 +508,7 @@ private static IReadOnlyList<string> GetPartitionKeyStoreNames(IEntityType entit
             : [CosmosClientWrapper.DefaultPartitionKey];
     }
 
-    private async Task DeleteContainers(DbContext context)
+    private async Task DeleteContainersAsync(DbContext context)
     {
         if (!TestEnvironment.UseTokenCredential)
         {
