diff --git a/src/EFCore/Query/Internal/QueryOptimizingExpressionVisitor.cs b/src/EFCore/Query/Internal/QueryOptimizingExpressionVisitor.cs
index cb74f2a053..21da182917 100644
--- a/src/EFCore/Query/Internal/QueryOptimizingExpressionVisitor.cs
+++ b/src/EFCore/Query/Internal/QueryOptimizingExpressionVisitor.cs
@@ -375,46 +375,57 @@ private static Expression MatchExpressionType(Expression expression, Type typeTo
         // Simplify (a != null ? new { Member = b, ... } : null).Member
         // to a != null ? b : null
         // Later null check removal will simplify it further
-        if (expression is MemberExpression
-            {
-                Expression: ConditionalExpression
-                {
-                    Test: BinaryExpression { NodeType: ExpressionType.Equal or ExpressionType.NotEqual } binaryTest
-                } conditionalExpression
-            } visitedMemberExpression
-            // Exclude HasValue/Value over Nullable<> as they return non-null type and we don't have equivalent for it for null part
-            && !(conditionalExpression.Type.IsNullableValueType()
-                && visitedMemberExpression.Member.Name is nameof(Nullable<int>.HasValue) or nameof(Nullable<int>.Value)))
+        if (expression is MemberExpression { Expression: Expression inner } visitedMemberExpression)
         {
-            var isLeftNullConstant = IsNullConstant(binaryTest.Left);
-            var isRightNullConstant = IsNullConstant(binaryTest.Right);
-
-            if (isLeftNullConstant != isRightNullConstant
-                && ((binaryTest.NodeType == ExpressionType.Equal
-                        && IsNullConstant(conditionalExpression.IfTrue))
-                    || (binaryTest.NodeType == ExpressionType.NotEqual
-                        && IsNullConstant(conditionalExpression.IfFalse))))
+            var (conditional, convert) = inner switch
+            {
+                ConditionalExpression c => (c, null),
+                UnaryExpression { NodeType: ExpressionType.Convert or ExpressionType.ConvertChecked, Operand: ConditionalExpression cond } conv => (cond, conv),
+                _ => (null, null)
+            };
+
+            if (conditional is { Test: BinaryExpression { NodeType: ExpressionType.Equal or ExpressionType.NotEqual } binaryTest } conditionalExpression
+                && !(conditionalExpression.Type.IsNullableValueType()
+                    && visitedMemberExpression.Member.Name is nameof(Nullable<int>.HasValue) or nameof(Nullable<int>.Value)))
             {
-                var nonNullExpression = binaryTest.NodeType == ExpressionType.Equal
-                    ? conditionalExpression.IfFalse
-                    : conditionalExpression.IfTrue;
-
-                // Use ReplacingExpressionVisitor rather than creating MemberExpression
-                // So that member access chain on NewExpression/MemberInitExpression condenses
-                nonNullExpression = ReplacingExpressionVisitor.Replace(
-                    visitedMemberExpression.Expression, nonNullExpression, visitedMemberExpression);
-                nonNullExpression = TryOptimizeMemberAccessOverConditional(nonNullExpression) ?? nonNullExpression;
-                if (!nonNullExpression.Type.IsNullableType())
+                var isLeftNullConstant = IsNullConstant(binaryTest.Left);
+                var isRightNullConstant = IsNullConstant(binaryTest.Right);
+
+                if (isLeftNullConstant != isRightNullConstant
+                    && ((binaryTest.NodeType == ExpressionType.Equal
+                            && IsNullConstant(conditionalExpression.IfTrue))
+                        || (binaryTest.NodeType == ExpressionType.NotEqual
+                            && IsNullConstant(conditionalExpression.IfFalse))))
                 {
-                    nonNullExpression = Expression.Convert(nonNullExpression, nonNullExpression.Type.MakeNullable());
+                    var nonNullExpression = binaryTest.NodeType == ExpressionType.Equal
+                        ? conditionalExpression.IfFalse
+                        : conditionalExpression.IfTrue;
+
+                    // if we removed convert around ConditionalExpression
+                    // we need to re-apply it before we apply the MemberExpression
+                    if (convert is not null)
+                    {
+                        nonNullExpression = convert.Update(nonNullExpression);
+                    }
+
+                    // Use ReplacingExpressionVisitor rather than creating MemberExpression
+                    // So that member access chain on NewExpression/MemberInitExpression condenses
+                    nonNullExpression = ReplacingExpressionVisitor.Replace(
+                        visitedMemberExpression.Expression, nonNullExpression, visitedMemberExpression);
+
+                    nonNullExpression = TryOptimizeMemberAccessOverConditional(nonNullExpression) ?? nonNullExpression;
+                    if (!nonNullExpression.Type.IsNullableType())
+                    {
+                        nonNullExpression = Expression.Convert(nonNullExpression, nonNullExpression.Type.MakeNullable());
+                    }
+
+                    var nullExpression = Expression.Constant(null, nonNullExpression.Type);
+
+                    return Expression.Condition(
+                        conditionalExpression.Test,
+                        binaryTest.NodeType == ExpressionType.Equal ? nullExpression : nonNullExpression,
+                        binaryTest.NodeType == ExpressionType.Equal ? nonNullExpression : nullExpression);
                 }
-
-                var nullExpression = Expression.Constant(null, nonNullExpression.Type);
-
-                return Expression.Condition(
-                    conditionalExpression.Test,
-                    binaryTest.NodeType == ExpressionType.Equal ? nullExpression : nonNullExpression,
-                    binaryTest.NodeType == ExpressionType.Equal ? nonNullExpression : nullExpression);
             }
         }
 
diff --git a/test/EFCore.Specification.Tests/Query/SimpleQueryTestBase.cs b/test/EFCore.Specification.Tests/Query/SimpleQueryTestBase.cs
index 05bac0d55f..886e228951 100644
--- a/test/EFCore.Specification.Tests/Query/SimpleQueryTestBase.cs
+++ b/test/EFCore.Specification.Tests/Query/SimpleQueryTestBase.cs
@@ -10,6 +10,8 @@ public abstract class SimpleQueryTestBase : NonSharedModelTestBase
     protected override string StoreName
         => "SimpleQueryTests";
 
+    #region 24368
+
     [ConditionalTheory]
     [MemberData(nameof(IsAsyncData))]
     public virtual async Task Multiple_nested_reference_navigations(bool async)
@@ -138,6 +140,10 @@ protected class Staff
         public Staff SecondaryManager { get; set; }
     }
 
+    #endregion
+
+    #region 21770
+
     [ConditionalTheory]
     [MemberData(nameof(IsAsyncData))]
     public virtual async Task Comparing_enum_casted_to_byte_with_int_parameter(bool async)
@@ -268,6 +274,10 @@ protected class Food
         public byte? Taste { get; set; }
     }
 
+    #endregion
+
+    #region 24657
+
     [ConditionalTheory]
     [MemberData(nameof(IsAsyncData))]
     public virtual async Task Bool_discriminator_column_works(bool async)
@@ -339,6 +349,10 @@ public PhotoBlog()
         public int NumberOfPhotos { get; set; }
     }
 
+    #endregion
+
+    #region 26433
+
     [ConditionalTheory]
     [MemberData(nameof(IsAsyncData))]
     public virtual async Task Count_member_over_IReadOnlyCollection_works(bool async)
@@ -405,6 +419,10 @@ protected class Book26433
         public Author26433 Author { get; set; }
     }
 
+    #endregion
+
+    #region 26428
+
 #nullable enable
 
     [ConditionalTheory]
@@ -490,6 +508,10 @@ protected class Location
 
 #nullable disable
 
+    #endregion
+
+    #region 26593
+
     [ConditionalTheory]
     [MemberData(nameof(IsAsyncData))]
     public virtual async Task Unwrap_convert_node_over_projection_when_translating_contains_over_subquery(bool async)
@@ -610,6 +632,10 @@ protected class Membership
         public int GroupId { get; set; }
     }
 
+    #endregion
+
+    #region 26587
+
     [ConditionalTheory]
     [MemberData(nameof(IsAsyncData))]
     public virtual async Task GroupBy_aggregate_on_right_side_of_join(bool async)
@@ -656,6 +682,10 @@ protected class OrderItem
         public DateTime? CancellationDate { get; set; }
     }
 
+    #endregion
+
+    #region 26472
+
     [ConditionalTheory]
     [MemberData(nameof(IsAsyncData))]
     public virtual async Task Enum_with_value_converter_matching_take_value(bool async)
@@ -716,6 +746,10 @@ protected enum OrderItemType
         MyType2 = 2
     }
 
+    #endregion
+
+    #region 27083
+
     [ConditionalTheory]
     [MemberData(nameof(IsAsyncData))]
     public virtual async Task GroupBy_Aggregate_over_navigations_repeated(bool async)
@@ -874,6 +908,10 @@ protected class TimeSheet
         public Order Order { get; set; }
     }
 
+    #endregion
+
+    #region 27094
+
     [ConditionalTheory]
     [MemberData(nameof(IsAsyncData))]
     public virtual async Task Aggregate_over_subquery_in_group_by_projection_2(bool async)
@@ -936,6 +974,10 @@ protected class Table
         public int? Value { get; set; }
     }
 
+    #endregion
+
+    #region 27163
+
     [ConditionalTheory]
     [MemberData(nameof(IsAsyncData))]
     public virtual async Task Group_by_multiple_aggregate_joining_different_tables(bool async)
@@ -1041,6 +1083,10 @@ public class ChildFilter2
         public string Value2 { get; set; }
     }
 
+    #endregion
+
+    #region 26744
+
     [ConditionalTheory]
     [MemberData(nameof(IsAsyncData))]
     public virtual async Task Subquery_first_member_compared_to_null(bool async)
@@ -1131,6 +1177,10 @@ protected class Child26744
         public Parent26744 Parent { get; set; }
     }
 
+    #endregion
+
+    #region 27343
+
     [ConditionalTheory]
     [MemberData(nameof(IsAsyncData))]
     public virtual async Task Flattened_GroupJoin_on_interface_generic(bool async)
@@ -1186,6 +1236,10 @@ protected class Child27343
         public Parent27343 Parent { get; set; }
     }
 
+    #endregion
+
+    #region 28196
+
     [ConditionalTheory]
     [MemberData(nameof(IsAsyncData))]
     public virtual Task Hierarchy_query_with_abstract_type_sibling(bool async)
@@ -1256,6 +1310,10 @@ public void Seed()
         }
     }
 
+    #endregion
+
+    #region 28039
+
     [ConditionalTheory]
     [MemberData(nameof(IsAsyncData))]
     public virtual async Task Pushdown_does_not_add_grouping_key_to_projection_when_distinct_is_applied(bool async)
@@ -1344,4 +1402,133 @@ protected class Dog : Pet
     {
         public string FavoriteToy { get; set; }
     }
+
+    #endregion
+
+    #region 31961
+
+    [ConditionalTheory]
+    [MemberData(nameof(IsAsyncData))]
+    public virtual async Task Filter_on_nested_DTO_with_interface_gets_simplified_correctly(bool async)
+    {
+        var contextFactory = await InitializeAsync<Context31961>();
+        using var context = contextFactory.CreateContext();
+
+        var query = await context.Customers
+            .Select(m => new CustomerDto31961()
+            {
+                Id = m.Id,
+                CompanyId = m.CompanyId,
+                Company = m.Company != null ? new CompanyDto31961()
+                {
+                    Id = m.Company.Id,
+                    CompanyName = m.Company.CompanyName,
+                    CountryId = m.Company.CountryId,
+                    Country = new CountryDto31961()
+                    {
+                        Id = m.Company.Country.Id,
+                        CountryName = m.Company.Country.CountryName,
+                    },
+                } : null,
+            })
+        .Where(m => m.Company.Country.CountryName == "COUNTRY")
+        .ToListAsync();
+    }
+
+    protected class Context31961 : DbContext
+    {
+        public Context31961(DbContextOptions options)
+            : base(options)
+        {
+        }
+
+        public DbSet<Customer31961> Customers { get; set; }
+
+        public DbSet<Company31961> Companies { get; set; }
+
+        public DbSet<Country31961> Countries { get; set; }
+    }
+
+    public class Customer31961
+    {
+        public string Id { get; set; } = string.Empty;
+
+        public string CompanyId { get; set; }
+
+        public Company31961 Company { get; set; }
+    }
+
+    public class Country31961
+    {
+        public string Id { get; set; } = string.Empty;
+
+        public string CountryName { get; set; } = string.Empty;
+    }
+
+    public class Company31961
+    {
+        public string Id { get; set; } = string.Empty;
+
+        public string CompanyName { get; set; } = string.Empty;
+
+        public string CountryId { get; set; }
+
+        public Country31961 Country { get; set; }
+    }
+
+    public interface ICustomerDto31961
+    {
+        string Id { get; set; }
+
+        string CompanyId { get; set; }
+
+        ICompanyDto31961 Company { get; set; }
+    }
+
+    public interface ICountryDto31961
+    {
+        string Id { get; set; }
+
+        string CountryName { get; set; }
+    }
+
+    public interface ICompanyDto31961
+    {
+        string Id { get; set; }
+
+        string CompanyName { get; set; }
+
+        string CountryId { get; set; }
+
+        ICountryDto31961 Country { get; set; }
+    }
+
+    public class CustomerDto31961 : ICustomerDto31961
+    {
+        public string Id { get; set; } = string.Empty;
+
+        public string CompanyId { get; set; }
+
+        public ICompanyDto31961 Company { get; set; }
+    }
+
+    public class CountryDto31961 : ICountryDto31961
+    {
+        public string Id { get; set; } = string.Empty;
+
+        public string CountryName { get; set; } = string.Empty;
+    }
+
+    public class CompanyDto31961 : ICompanyDto31961
+    {
+        public string Id { get; set; } = string.Empty;
+
+        public string CompanyName { get; set; } = string.Empty;
+
+        public string CountryId { get; set; }
+
+        public ICountryDto31961 Country { get; set; }
+    }
+
+    #endregion
 }
diff --git a/test/EFCore.SqlServer.FunctionalTests/Query/SimpleQuerySqlServerTest.cs b/test/EFCore.SqlServer.FunctionalTests/Query/SimpleQuerySqlServerTest.cs
index 17e0bb1b74..12c8459442 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Query/SimpleQuerySqlServerTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Query/SimpleQuerySqlServerTest.cs
@@ -12,6 +12,66 @@ public class SimpleQuerySqlServerTest : SimpleQueryRelationalTestBase
     protected override ITestStoreFactory TestStoreFactory
         => SqlServerTestStoreFactory.Instance;
 
+
+    #region 27427
+
+    [ConditionalTheory]
+    [MemberData(nameof(IsAsyncData))]
+    public virtual async Task Muliple_occurrences_of_FromSql_in_group_by_aggregate(bool async)
+    {
+        var contextFactory = await InitializeAsync<Context27427>();
+        using var context = contextFactory.CreateContext();
+        var query = context.DemoEntities
+            .FromSqlRaw("SELECT * FROM DemoEntities WHERE Id = {0}", new SqlParameter { Value = 1 })
+            .Select(e => e.Id);
+
+        var query2 = context.DemoEntities
+            .Where(e => query.Contains(e.Id))
+            .GroupBy(e => e.Id)
+            .Select(g => new { g.Key, Aggregate = g.Count() });
+
+        if (async)
+        {
+            await query2.ToListAsync();
+        }
+        else
+        {
+            query2.ToList();
+        }
+
+        AssertSql(
+            """
+p0='1'
+
+SELECT [d].[Id] AS [Key], COUNT(*) AS [Aggregate]
+FROM [DemoEntities] AS [d]
+WHERE [d].[Id] IN (
+    SELECT [m].[Id]
+    FROM (
+        SELECT * FROM DemoEntities WHERE Id = @p0
+    ) AS [m]
+)
+GROUP BY [d].[Id]
+""");
+    }
+
+    protected class Context27427 : DbContext
+    {
+        public Context27427(DbContextOptions options)
+            : base(options)
+        {
+        }
+
+        public DbSet<DemoEntity> DemoEntities { get; set; }
+    }
+
+    protected class DemoEntity
+    {
+        public int Id { get; set; }
+    }
+
+    #endregion
+
     #region 30478
 
     [ConditionalTheory]
@@ -749,58 +809,23 @@ UNION ALL
 """);
     }
 
-    [ConditionalTheory]
-    [MemberData(nameof(IsAsyncData))]
-    public virtual async Task Muliple_occurrences_of_FromSql_in_group_by_aggregate(bool async)
+    public override async Task Filter_on_nested_DTO_with_interface_gets_simplified_correctly(bool async)
     {
-        var contextFactory = await InitializeAsync<Context27427>();
-        using var context = contextFactory.CreateContext();
-        var query = context.DemoEntities
-            .FromSqlRaw("SELECT * FROM DemoEntities WHERE Id = {0}", new SqlParameter { Value = 1 })
-            .Select(e => e.Id);
-
-        var query2 = context.DemoEntities
-            .Where(e => query.Contains(e.Id))
-            .GroupBy(e => e.Id)
-            .Select(g => new { g.Key, Aggregate = g.Count() });
-
-        if (async)
-        {
-            await query2.ToListAsync();
-        }
-        else
-        {
-            query2.ToList();
-        }
+        await base.Filter_on_nested_DTO_with_interface_gets_simplified_correctly(async);
 
         AssertSql(
-            """
-p0='1'
-
-SELECT [d].[Id] AS [Key], COUNT(*) AS [Aggregate]
-FROM [DemoEntities] AS [d]
-WHERE [d].[Id] IN (
-    SELECT [m].[Id]
-    FROM (
-        SELECT * FROM DemoEntities WHERE Id = @p0
-    ) AS [m]
-)
-GROUP BY [d].[Id]
+"""
+SELECT [c].[Id], [c].[CompanyId], CASE
+    WHEN [c0].[Id] IS NOT NULL THEN CAST(1 AS bit)
+    ELSE CAST(0 AS bit)
+END, [c0].[Id], [c0].[CompanyName], [c0].[CountryId], [c1].[Id], [c1].[CountryName]
+FROM [Customers] AS [c]
+LEFT JOIN [Companies] AS [c0] ON [c].[CompanyId] = [c0].[Id]
+LEFT JOIN [Countries] AS [c1] ON [c0].[CountryId] = [c1].[Id]
+WHERE CASE
+    WHEN [c0].[Id] IS NOT NULL THEN [c1].[CountryName]
+    ELSE NULL
+END = N'COUNTRY'
 """);
     }
-
-    protected class Context27427 : DbContext
-    {
-        public Context27427(DbContextOptions options)
-            : base(options)
-        {
-        }
-
-        public DbSet<DemoEntity> DemoEntities { get; set; }
-    }
-
-    protected class DemoEntity
-    {
-        public int Id { get; set; }
-    }
 }
