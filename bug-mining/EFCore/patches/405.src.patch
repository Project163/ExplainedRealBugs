diff --git a/src/EFCore.InMemory/ValueGeneration/Internal/InMemoryValueGeneratorSelector.cs b/src/EFCore.InMemory/ValueGeneration/Internal/InMemoryValueGeneratorSelector.cs
index d2147ac2bb..77483e1ba3 100644
--- a/src/EFCore.InMemory/ValueGeneration/Internal/InMemoryValueGeneratorSelector.cs
+++ b/src/EFCore.InMemory/ValueGeneration/Internal/InMemoryValueGeneratorSelector.cs
@@ -35,12 +35,17 @@ public class InMemoryValueGeneratorSelector : ValueGeneratorSelector
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    public override ValueGenerator Select(IProperty property, ITypeBase typeBase)
-        => property.GetValueGeneratorFactory() == null
-            && property.ClrType.IsInteger()
-            && property.ClrType.UnwrapNullableType() != typeof(char)
-                ? GetOrCreate(property)
-                : base.Select(property, typeBase);
+    [Obsolete("Use TrySelect and throw if needed when the generator is not found.")]
+    public override ValueGenerator? Select(IProperty property, ITypeBase typeBase)
+    {
+        if (TrySelect(property, typeBase, out var valueGenerator))
+        {
+            return valueGenerator;
+        }
+
+        throw new NotSupportedException(
+            CoreStrings.NoValueGenerator(property.Name, property.DeclaringType.DisplayName(), property.ClrType.ShortDisplayName()));
+    }
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
@@ -48,18 +53,12 @@ public override ValueGenerator Select(IProperty property, ITypeBase typeBase)
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    private ValueGenerator GetOrCreate(IProperty property)
-    {
-        var type = property.ClrType.UnwrapNullableType().UnwrapEnumType();
-        if (FindGenerator(property, type, out var valueGenerator))
-        {
-            return valueGenerator!;
-        }
-
-        throw new ArgumentException(
-            CoreStrings.InvalidValueGeneratorFactoryProperty(
-                "InMemoryIntegerValueGeneratorFactory", property.Name, property.DeclaringType.DisplayName()));
-    }
+    public override bool TrySelect(IProperty property, ITypeBase typeBase, out ValueGenerator? valueGenerator)
+        => property.GetValueGeneratorFactory() == null
+            && property.ClrType.IsInteger()
+            && property.ClrType.UnwrapNullableType() != typeof(char)
+                ? FindGenerator(property, property.ClrType.UnwrapNullableType().UnwrapEnumType(), out valueGenerator)
+                : base.TrySelect(property, typeBase, out valueGenerator);
 
     private bool FindGenerator(IProperty property, Type type, out ValueGenerator? valueGenerator)
     {
diff --git a/src/EFCore.SqlServer/ValueGeneration/Internal/SqlServerValueGeneratorSelector.cs b/src/EFCore.SqlServer/ValueGeneration/Internal/SqlServerValueGeneratorSelector.cs
index 05acf3560c..e6dac7ad70 100644
--- a/src/EFCore.SqlServer/ValueGeneration/Internal/SqlServerValueGeneratorSelector.cs
+++ b/src/EFCore.SqlServer/ValueGeneration/Internal/SqlServerValueGeneratorSelector.cs
@@ -53,17 +53,35 @@ public new virtual ISqlServerValueGeneratorCache Cache
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    public override ValueGenerator Select(IProperty property, ITypeBase typeBase)
+    [Obsolete("Use TrySelect and throw if needed when the generator is not found.")]
+    public override ValueGenerator? Select(IProperty property, ITypeBase typeBase)
+    {
+        if (TrySelect(property, typeBase, out var valueGenerator))
+        {
+            return valueGenerator;
+        }
+
+        throw new NotSupportedException(
+            CoreStrings.NoValueGenerator(property.Name, property.DeclaringType.DisplayName(), property.ClrType.ShortDisplayName()));
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public override bool TrySelect(IProperty property, ITypeBase typeBase, out ValueGenerator? valueGenerator)
     {
         if (property.GetValueGeneratorFactory() != null
             || property.GetValueGenerationStrategy() != SqlServerValueGenerationStrategy.SequenceHiLo)
         {
-            return base.Select(property, typeBase);
+            return base.TrySelect(property, typeBase, out valueGenerator);
         }
 
         var propertyType = property.ClrType.UnwrapNullableType().UnwrapEnumType();
 
-        var generator = _sequenceFactory.TryCreate(
+        valueGenerator = _sequenceFactory.TryCreate(
             property,
             propertyType,
             Cache.GetOrAddSequenceState(property, _connection),
@@ -71,16 +89,16 @@ public override ValueGenerator Select(IProperty property, ITypeBase typeBase)
             _rawSqlCommandBuilder,
             _commandLogger);
 
-        if (generator != null)
+        if (valueGenerator != null)
         {
-            return generator;
+            return true;
         }
 
         var converter = property.GetTypeMapping().Converter;
         if (converter != null
             && converter.ProviderClrType != propertyType)
         {
-            generator = _sequenceFactory.TryCreate(
+            valueGenerator = _sequenceFactory.TryCreate(
                 property,
                 converter.ProviderClrType,
                 Cache.GetOrAddSequenceState(property, _connection),
@@ -88,15 +106,14 @@ public override ValueGenerator Select(IProperty property, ITypeBase typeBase)
                 _rawSqlCommandBuilder,
                 _commandLogger);
 
-            if (generator != null)
+            if (valueGenerator != null)
             {
-                return generator.WithConverter(converter);
+                valueGenerator = valueGenerator.WithConverter(converter);
+                return true;
             }
         }
 
-        throw new ArgumentException(
-            CoreStrings.InvalidValueGeneratorFactoryProperty(
-                nameof(SqlServerSequenceValueGeneratorFactory), property.Name, property.DeclaringType.DisplayName()));
+        return false;
     }
 
     /// <summary>
diff --git a/src/EFCore/ChangeTracking/Internal/KeyPropagator.cs b/src/EFCore/ChangeTracking/Internal/KeyPropagator.cs
index ce5e05b991..15b9c89231 100644
--- a/src/EFCore/ChangeTracking/Internal/KeyPropagator.cs
+++ b/src/EFCore/ChangeTracking/Internal/KeyPropagator.cs
@@ -167,7 +167,20 @@ private static void SetValue(InternalEntityEntry entry, IProperty property, Valu
     }
 
     private ValueGenerator? TryGetValueGenerator(IProperty? generationProperty, ITypeBase? typeBase)
-        => generationProperty != null
-            ? _valueGeneratorSelector.Select(generationProperty, typeBase!)
-            : null;
+    {
+        if (generationProperty == null)
+        {
+            return null;
+        }
+
+        if (!_valueGeneratorSelector.TrySelect(generationProperty, typeBase!, out var valueGenerator))
+        {
+            throw new NotSupportedException(
+                CoreStrings.NoValueGenerator(
+                    generationProperty.Name, generationProperty.DeclaringType.DisplayName(),
+                    generationProperty.ClrType.ShortDisplayName()));
+        }
+
+        return valueGenerator!;
+    }
 }
diff --git a/src/EFCore/ChangeTracking/Internal/ValueGenerationManager.cs b/src/EFCore/ChangeTracking/Internal/ValueGenerationManager.cs
index 4df08a5dc6..14350e3ab3 100644
--- a/src/EFCore/ChangeTracking/Internal/ValueGenerationManager.cs
+++ b/src/EFCore/ChangeTracking/Internal/ValueGenerationManager.cs
@@ -92,37 +92,26 @@ public virtual bool Generate(InternalEntityEntry entry, bool includePrimaryKey =
         var entityEntry = new EntityEntry(entry);
         var hasStableValues = false;
         var hasNonStableValues = false;
+        IProperty? propertyWithNoGenerator = null;
 
         //TODO: Handle complex properties
         foreach (var property in entry.EntityType.GetValueGeneratingProperties())
         {
-            var valueGenerator = GetValueGenerator(property);
-            if (valueGenerator.GeneratesStableValues)
-            {
-                hasStableValues = true;
-            }
-            else
-            {
-                hasNonStableValues = true;
-            }
-
-            if (entry.HasExplicitValue(property)
-                || (!includePrimaryKey
-                    && property.IsPrimaryKey()))
+            if (!TryFindValueGenerator(
+                    entry, includePrimaryKey, property,
+                    ref hasStableValues, ref hasNonStableValues, ref propertyWithNoGenerator,
+                    out var valueGenerator))
             {
                 continue;
             }
 
-            var generatedValue = valueGenerator.Next(entityEntry);
-            var temporary = valueGenerator.GeneratesTemporaryValues;
-
-            Log(entry, property, generatedValue, temporary);
-
-            SetGeneratedValue(entry, property, generatedValue, temporary);
+            var generatedValue = valueGenerator!.Next(entityEntry);
 
-            MarkKeyUnknown(entry, includePrimaryKey, property, valueGenerator);
+            FinishGenerate(entry, includePrimaryKey, valueGenerator, property, generatedValue);
         }
 
+        CheckPropertyWithNoGenerator(propertyWithNoGenerator);
+
         return hasStableValues && !hasNonStableValues;
     }
 
@@ -152,10 +141,63 @@ private void Log(InternalEntityEntry entry, IProperty property, object? generate
         var entityEntry = new EntityEntry(entry);
         var hasStableValues = false;
         var hasNonStableValues = false;
+        IProperty? propertyWithNoGenerator = null;
+
+        //TODO: Handle complex properties
         foreach (var property in entry.EntityType.GetValueGeneratingProperties())
         {
-            var valueGenerator = GetValueGenerator(property);
-            if (valueGenerator.GeneratesStableValues)
+            if (!TryFindValueGenerator(
+                    entry, includePrimaryKey, property,
+                    ref hasStableValues, ref hasNonStableValues, ref propertyWithNoGenerator,
+                    out var valueGenerator))
+            {
+                continue;
+            }
+
+            var generatedValue = await valueGenerator!.NextAsync(entityEntry, cancellationToken).ConfigureAwait(false);
+
+            FinishGenerate(entry, includePrimaryKey, valueGenerator, property, generatedValue);
+        }
+
+        CheckPropertyWithNoGenerator(propertyWithNoGenerator);
+
+        return hasStableValues && !hasNonStableValues;
+    }
+
+    private void FinishGenerate(
+        InternalEntityEntry entry,
+        bool includePrimaryKey,
+        ValueGenerator valueGenerator,
+        IProperty property,
+        object? generatedValue)
+    {
+        var temporary = valueGenerator.GeneratesTemporaryValues;
+        Log(entry, property, generatedValue, temporary);
+        SetGeneratedValue(entry, property, generatedValue, temporary);
+        MarkKeyUnknown(entry, includePrimaryKey, property, valueGenerator);
+    }
+
+    private static void CheckPropertyWithNoGenerator(IProperty? property)
+    {
+        if (property != null)
+        {
+            throw new NotSupportedException(
+                CoreStrings.NoValueGenerator(property.Name, property.DeclaringType.DisplayName(), property.ClrType.ShortDisplayName()));
+        }
+    }
+
+    private bool TryFindValueGenerator(
+        InternalEntityEntry entry,
+        bool includePrimaryKey,
+        IProperty property,
+        ref bool hasStableValues,
+        ref bool hasNonStableValues,
+        ref IProperty? propertyWithNoGenerator,
+        out ValueGenerator? valueGenerator)
+    {
+        if (_valueGeneratorSelector.TrySelect(property, property.DeclaringType, out valueGenerator))
+        {
+            if (valueGenerator!.GeneratesStableValues)
             {
                 hasStableValues = true;
             }
@@ -163,33 +205,27 @@ private void Log(InternalEntityEntry entry, IProperty property, object? generate
             {
                 hasNonStableValues = true;
             }
+        }
 
-            if (entry.HasExplicitValue(property)
-                || (!includePrimaryKey
-                    && property.IsPrimaryKey()))
+        if (valueGenerator == null)
+        {
+            if (property.GetContainingKeys().Any(k => k.Properties.Count == 1))
             {
-                continue;
+                propertyWithNoGenerator ??= property;
             }
+            return false;
+        }
 
-            var generatedValue = await valueGenerator.NextAsync(entityEntry, cancellationToken).ConfigureAwait(false);
-            var temporary = valueGenerator.GeneratesTemporaryValues;
-
-            Log(entry, property, generatedValue, temporary);
-
-            SetGeneratedValue(
-                entry,
-                property,
-                generatedValue,
-                temporary);
-
-            MarkKeyUnknown(entry, includePrimaryKey, property, valueGenerator);
+        if (entry.HasExplicitValue(property)
+            || (!includePrimaryKey
+                && property.IsPrimaryKey()))
+        {
+            return false;
         }
 
-        return hasStableValues && !hasNonStableValues;
-    }
 
-    private ValueGenerator GetValueGenerator(IProperty property)
-        => _valueGeneratorSelector.Select(property, property.DeclaringType);
+        return true;
+    }
 
     private static void SetGeneratedValue(InternalEntityEntry entry, IProperty property, object? generatedValue, bool isTemporary)
     {
diff --git a/src/EFCore/ValueGeneration/IValueGeneratorCache.cs b/src/EFCore/ValueGeneration/IValueGeneratorCache.cs
index be89869d95..0a7f760707 100644
--- a/src/EFCore/ValueGeneration/IValueGeneratorCache.cs
+++ b/src/EFCore/ValueGeneration/IValueGeneratorCache.cs
@@ -36,8 +36,8 @@ public interface IValueGeneratorCache
     /// </param>
     /// <param name="factory">Factory to create a new value generator if one is not present in the cache.</param>
     /// <returns>The existing or newly created value generator.</returns>
-    ValueGenerator GetOrAdd(
+    ValueGenerator? GetOrAdd(
         IProperty property,
         ITypeBase typeBase,
-        Func<IProperty, ITypeBase, ValueGenerator> factory);
+        Func<IProperty, ITypeBase, ValueGenerator?> factory);
 }
diff --git a/src/EFCore/ValueGeneration/IValueGeneratorSelector.cs b/src/EFCore/ValueGeneration/IValueGeneratorSelector.cs
index f2d9b276f7..d802440063 100644
--- a/src/EFCore/ValueGeneration/IValueGeneratorSelector.cs
+++ b/src/EFCore/ValueGeneration/IValueGeneratorSelector.cs
@@ -35,5 +35,18 @@ public interface IValueGeneratorSelector
     ///     this type may be different from the declaring type for <paramref name="property" />
     /// </param>
     /// <returns>The value generator to be used.</returns>
-    ValueGenerator Select(IProperty property, ITypeBase typeBase);
+    [Obsolete("Use TrySelect and throw if needed when the generator is not found.")]
+    ValueGenerator? Select(IProperty property, ITypeBase typeBase);
+
+    /// <summary>
+    ///     Selects the appropriate value generator for a given property, if available.
+    /// </summary>
+    /// <param name="property">The property to get the value generator for.</param>
+    /// <param name="typeBase">
+    ///     The entity type that the value generator will be used for. When called on inherited properties on derived entity types,
+    ///     this entity type may be different from the declared entity type on <paramref name="property" />
+    /// </param>
+    /// <param name="valueGenerator">The value generator, or <see langword="null"/> if none is available.</param>
+    /// <returns><see langword="true"/> if a value generator was selected; <see langword="false"/> if none was available.</returns>
+    bool TrySelect(IProperty property, ITypeBase typeBase, out ValueGenerator? valueGenerator);
 }
diff --git a/src/EFCore/ValueGeneration/ValueGeneratorCache.cs b/src/EFCore/ValueGeneration/ValueGeneratorCache.cs
index 147d52df8c..0a2655125a 100644
--- a/src/EFCore/ValueGeneration/ValueGeneratorCache.cs
+++ b/src/EFCore/ValueGeneration/ValueGeneratorCache.cs
@@ -41,7 +41,7 @@ public ValueGeneratorCache(ValueGeneratorCacheDependencies dependencies)
     /// </summary>
     protected virtual ValueGeneratorCacheDependencies Dependencies { get; }
 
-    private readonly ConcurrentDictionary<CacheKey, ValueGenerator> _cache = new();
+    private readonly ConcurrentDictionary<CacheKey, ValueGenerator?> _cache = new();
 
     private readonly struct CacheKey : IEquatable<CacheKey>
     {
@@ -79,10 +79,10 @@ public override int GetHashCode()
     /// </param>
     /// <param name="factory">Factory to create a new value generator if one is not present in the cache.</param>
     /// <returns>The existing or newly created value generator.</returns>
-    public virtual ValueGenerator GetOrAdd(
+    public virtual ValueGenerator? GetOrAdd(
         IProperty property,
         ITypeBase typeBase,
-        Func<IProperty, ITypeBase, ValueGenerator> factory)
+        Func<IProperty, ITypeBase, ValueGenerator?> factory)
         => _cache.GetOrAdd(
                 new CacheKey(property, typeBase), static (ck, p) => p.factory(p.property, p.typeBase), (factory, typeBase, property));
 }
diff --git a/src/EFCore/ValueGeneration/ValueGeneratorSelector.cs b/src/EFCore/ValueGeneration/ValueGeneratorSelector.cs
index 207d3672ad..f6cc78cd8f 100644
--- a/src/EFCore/ValueGeneration/ValueGeneratorSelector.cs
+++ b/src/EFCore/ValueGeneration/ValueGeneratorSelector.cs
@@ -46,17 +46,23 @@ public ValueGeneratorSelector(ValueGeneratorSelectorDependencies dependencies)
     /// </summary>
     protected virtual ValueGeneratorSelectorDependencies Dependencies { get; }
 
-    /// <summary>
-    ///     Selects the appropriate value generator for a given property.
-    /// </summary>
-    /// <param name="property">The property to get the value generator for.</param>
-    /// <param name="typeBase">
-    ///     The entity type that the value generator will be used for. When called on inherited properties on derived entity types,
-    ///     this entity type may be different from the declared entity type on <paramref name="property" />
-    /// </param>
-    /// <returns>The value generator to be used.</returns>
-    public virtual ValueGenerator Select(IProperty property, ITypeBase typeBase)
-        => Cache.GetOrAdd(property, typeBase, (p, t) => CreateFromFactory(p, t) ?? Create(p, t));
+    /// <inheritdoc />
+    [Obsolete("Use TrySelect and throw if needed when the generator is not found.")]
+    public virtual ValueGenerator? Select(IProperty property, ITypeBase typeBase)
+        => Cache.GetOrAdd(
+            property, typeBase, (p, t) => Find(p, t)
+                ?? throw new NotSupportedException(
+                    CoreStrings.NoValueGenerator(p.Name, p.DeclaringType.DisplayName(), p.ClrType.ShortDisplayName())));
+
+    /// <inheritdoc />
+    public virtual bool TrySelect(IProperty property, ITypeBase typeBase, out ValueGenerator? valueGenerator)
+    {
+        valueGenerator = Cache.GetOrAdd(property, typeBase, (p, t) => Find(p, t));
+        return valueGenerator != null;
+    }
+
+    private ValueGenerator? Find(IProperty p, ITypeBase t)
+        => CreateFromFactory(p, t) ?? (TryCreate(p, t, out var valueGenerator) ? valueGenerator : null);
 
     private static ValueGenerator? CreateFromFactory(IProperty property, ITypeBase structuralType)
     {
@@ -85,28 +91,51 @@ public virtual ValueGenerator Select(IProperty property, ITypeBase typeBase)
     ///     this entity type may be different from the declared entity type on <paramref name="property" />
     /// </param>
     /// <returns>The newly created value generator.</returns>
+    [Obsolete("Use TryCreate and throw if needed when the generator is not found.")]
     public virtual ValueGenerator Create(IProperty property, ITypeBase typeBase)
+    {
+        if (!TryCreate(property, typeBase, out var valueGenerator))
+        {
+            throw new NotSupportedException(
+                CoreStrings.NoValueGenerator(
+                    property.Name, property.DeclaringType.DisplayName(), property.DeclaringType.ClrType.ShortDisplayName()));
+        }
+
+        return valueGenerator!;
+    }
+
+    /// <summary>
+    ///     Creates a new value generator for the given property.
+    /// </summary>
+    /// <param name="property">The property to get the value generator for.</param>
+    /// <param name="typeBase">
+    ///     The entity type that the value generator will be used for. When called on inherited properties on derived entity types,
+    ///     this entity type may be different from the declared entity type on <paramref name="property" />
+    /// </param>
+    /// <param name="valueGenerator">The newly created value generator, or <see langword="null"/> if none is available.</param>
+    /// <returns><see langword="true"/> if a generator was created.</returns>
+    public virtual bool TryCreate(IProperty property, ITypeBase typeBase, out ValueGenerator? valueGenerator)
     {
         var propertyType = property.ClrType.UnwrapNullableType().UnwrapEnumType();
-        var generator = FindForType(property, typeBase, propertyType);
-        if (generator != null)
+        valueGenerator = FindForType(property, typeBase, propertyType);
+        if (valueGenerator != null)
         {
-            return generator;
+            return true;
         }
 
         var converter = property.GetTypeMapping().Converter;
         if (converter != null
             && converter.ProviderClrType != propertyType)
         {
-            generator = FindForType(property, typeBase, converter.ProviderClrType);
-            if (generator != null)
+            valueGenerator = FindForType(property, typeBase, converter.ProviderClrType);
+            if (valueGenerator != null)
             {
-                return generator.WithConverter(converter);
+                valueGenerator = valueGenerator.WithConverter(converter);
+                return true;
             }
         }
 
-        throw new NotSupportedException(
-            CoreStrings.NoValueGenerator(property.Name, property.DeclaringType.DisplayName(), propertyType.ShortDisplayName()));
+        return false;
     }
 
     /// <summary>
diff --git a/test/EFCore.InMemory.FunctionalTests/CustomValueGeneratorTest.cs b/test/EFCore.InMemory.FunctionalTests/CustomValueGeneratorTest.cs
index 1cced5f8b4..f246654058 100644
--- a/test/EFCore.InMemory.FunctionalTests/CustomValueGeneratorTest.cs
+++ b/test/EFCore.InMemory.FunctionalTests/CustomValueGeneratorTest.cs
@@ -198,8 +198,11 @@ private class CustomInMemoryValueGeneratorSelector(
     {
         private readonly ValueGeneratorFactory _factory = new CustomValueGeneratorFactory();
 
-        public override ValueGenerator Create(IProperty property, ITypeBase typeBase)
-            => _factory.Create(property, typeBase);
+        public override bool TryCreate(IProperty property, ITypeBase typeBase, out ValueGenerator valueGenerator)
+        {
+            valueGenerator = _factory.Create(property, typeBase);
+            return true;
+        }
     }
 
     private class CustomGuidValueGenerator : ValueGenerator<Guid>
diff --git a/test/EFCore.InMemory.FunctionalTests/GraphUpdates/GraphUpdatesInMemoryTestBase.cs b/test/EFCore.InMemory.FunctionalTests/GraphUpdates/GraphUpdatesInMemoryTestBase.cs
index de9a3b5080..2baf251bc6 100644
--- a/test/EFCore.InMemory.FunctionalTests/GraphUpdates/GraphUpdatesInMemoryTestBase.cs
+++ b/test/EFCore.InMemory.FunctionalTests/GraphUpdates/GraphUpdatesInMemoryTestBase.cs
@@ -11,6 +11,26 @@ protected GraphUpdatesInMemoryTestBase(TFixture fixture)
     {
     }
 
+    // In-memory database does not have database default values
+    public override Task Can_insert_when_bool_PK_in_composite_key_has_sentinel_value(bool async, bool initialValue)
+        => Task.CompletedTask;
+
+    // In-memory database does not have database default values
+    public override Task Can_insert_when_int_PK_in_composite_key_has_sentinel_value(bool async, int initialValue)
+        => Task.CompletedTask;
+
+    // In-memory database does not have database default values
+    public override Task Can_insert_when_nullable_bool_PK_in_composite_key_has_sentinel_value(bool async, bool? initialValue)
+        => Task.CompletedTask;
+
+    // In-memory database does not have database default values
+    public override Task Throws_for_single_property_bool_key_with_default_value_generation(bool async, bool initialValue)
+        => Task.CompletedTask;
+
+    // In-memory database does not have database default values
+    public override Task Throws_for_single_property_nullable_bool_key_with_default_value_generation(bool async, bool? initialValue)
+        => Task.CompletedTask;
+
     // In-memory database does not have database default values
     public override Task Can_insert_when_composite_FK_has_default_value_for_one_part(bool async)
         => Task.CompletedTask;
diff --git a/test/EFCore.InMemory.Tests/ValueGeneration/InMemoryValueGeneratorSelectorTest.cs b/test/EFCore.InMemory.Tests/ValueGeneration/InMemoryValueGeneratorSelectorTest.cs
index 1892770c39..c0987d6155 100644
--- a/test/EFCore.InMemory.Tests/ValueGeneration/InMemoryValueGeneratorSelectorTest.cs
+++ b/test/EFCore.InMemory.Tests/ValueGeneration/InMemoryValueGeneratorSelectorTest.cs
@@ -17,6 +17,7 @@ public void Returns_built_in_generators_for_types_setup_for_value_generation()
 
         var selector = InMemoryTestHelpers.Instance.CreateContextServices(model).GetRequiredService<IValueGeneratorSelector>();
 
+#pragma warning disable CS0618 // Type or member is obsolete
         Assert.IsType<CustomValueGenerator>(selector.Select(entityType.FindProperty("Custom"), entityType));
         Assert.IsType<InMemoryIntegerValueGenerator<int>>(selector.Select(entityType.FindProperty("Id"), entityType));
         Assert.IsType<InMemoryIntegerValueGenerator<long>>(selector.Select(entityType.FindProperty("Long"), entityType));
@@ -37,39 +38,84 @@ public void Returns_built_in_generators_for_types_setup_for_value_generation()
         Assert.IsType<StringValueGenerator>(selector.Select(entityType.FindProperty("String"), entityType));
         Assert.IsType<GuidValueGenerator>(selector.Select(entityType.FindProperty("Guid"), entityType));
         Assert.IsType<BinaryValueGenerator>(selector.Select(entityType.FindProperty("Binary"), entityType));
+#pragma warning restore CS0618 // Type or member is obsolete
     }
 
     [ConditionalFact]
-    public void Can_create_factories_for_all_integer_types()
+    public void Returns_built_in_generators_for_types_setup_for_value_generation_using_Try_method()
     {
         var model = BuildModel();
-        var entityType = model.FindEntityType(typeof(AnEntity));
+        var entityType = model.FindEntityType(typeof(AnEntity))!;
+
+        var selector = InMemoryTestHelpers.Instance.CreateContextServices(model).GetRequiredService<IValueGeneratorSelector>();
+
+        Assert.IsType<CustomValueGenerator>(selector.TrySelect(entityType.FindProperty("Custom")!, entityType, out var generator) ? generator : null);
+        Assert.IsType<InMemoryIntegerValueGenerator<int>>(selector.TrySelect(entityType.FindProperty("Id")!, entityType, out generator) ? generator : null);
+        Assert.IsType<InMemoryIntegerValueGenerator<long>>(selector.TrySelect(entityType.FindProperty("Long")!, entityType, out  generator) ? generator : null);
+        Assert.IsType<InMemoryIntegerValueGenerator<short>>(selector.TrySelect(entityType.FindProperty("Short")!, entityType, out generator) ? generator : null);
+        Assert.IsType<InMemoryIntegerValueGenerator<byte>>(selector.TrySelect(entityType.FindProperty("Byte")!, entityType, out generator) ? generator : null);
+        Assert.IsType<InMemoryIntegerValueGenerator<int>>(selector.TrySelect(entityType.FindProperty("NullableInt")!, entityType, out generator) ? generator : null);
+        Assert.IsType<InMemoryIntegerValueGenerator<long>>(selector.TrySelect(entityType.FindProperty("NullableLong")!, entityType, out generator) ? generator : null);
+        Assert.IsType<InMemoryIntegerValueGenerator<short>>(selector.TrySelect(entityType.FindProperty("NullableShort")!, entityType, out generator) ? generator : null);
+        Assert.IsType<InMemoryIntegerValueGenerator<byte>>(selector.TrySelect(entityType.FindProperty("NullableByte")!, entityType, out generator) ? generator : null);
+        Assert.IsType<InMemoryIntegerValueGenerator<uint>>(selector.TrySelect(entityType.FindProperty("UInt")!, entityType, out generator) ? generator : null);
+        Assert.IsType<InMemoryIntegerValueGenerator<ulong>>(selector.TrySelect(entityType.FindProperty("ULong")!, entityType, out generator) ? generator : null);
+        Assert.IsType<InMemoryIntegerValueGenerator<ushort>>(selector.TrySelect(entityType.FindProperty("UShort")!, entityType, out generator) ? generator : null);
+        Assert.IsType<InMemoryIntegerValueGenerator<sbyte>>(selector.TrySelect(entityType.FindProperty("SByte")!, entityType, out generator) ? generator : null);
+        Assert.IsType<InMemoryIntegerValueGenerator<uint>>(selector.TrySelect(entityType.FindProperty("NullableUInt")!, entityType, out generator) ? generator : null);
+        Assert.IsType<InMemoryIntegerValueGenerator<ulong>>(selector.TrySelect(entityType.FindProperty("NullableULong")!, entityType, out generator) ? generator : null);
+        Assert.IsType<InMemoryIntegerValueGenerator<ushort>>(selector.TrySelect(entityType.FindProperty("NullableUShort")!, entityType, out generator) ? generator : null);
+        Assert.IsType<InMemoryIntegerValueGenerator<sbyte>>(selector.TrySelect(entityType.FindProperty("NullableSByte")!, entityType, out generator) ? generator : null);
+        Assert.IsType<StringValueGenerator>(selector.TrySelect(entityType.FindProperty("String")!, entityType, out generator) ? generator : null);
+        Assert.IsType<GuidValueGenerator>(selector.TrySelect(entityType.FindProperty("Guid")!, entityType, out generator) ? generator : null);
+        Assert.IsType<BinaryValueGenerator>(selector.TrySelect(entityType.FindProperty("Binary")!, entityType, out generator) ? generator : null);
+    }
 
-        Assert.Equal(1, CreateAndUseFactory(entityType.FindProperty("Id")));
-        Assert.Equal(1L, CreateAndUseFactory(entityType.FindProperty("Long")));
-        Assert.Equal((short)1, CreateAndUseFactory(entityType.FindProperty("Short")));
-        Assert.Equal((byte)1, CreateAndUseFactory(entityType.FindProperty("Byte")));
-        Assert.Equal((int?)1, CreateAndUseFactory(entityType.FindProperty("NullableInt")));
-        Assert.Equal((long?)1, CreateAndUseFactory(entityType.FindProperty("NullableLong")));
-        Assert.Equal((short?)1, CreateAndUseFactory(entityType.FindProperty("NullableShort")));
-        Assert.Equal((byte?)1, CreateAndUseFactory(entityType.FindProperty("NullableByte")));
-        Assert.Equal((uint)1, CreateAndUseFactory(entityType.FindProperty("UInt")));
-        Assert.Equal((ulong)1, CreateAndUseFactory(entityType.FindProperty("ULong")));
-        Assert.Equal((ushort)1, CreateAndUseFactory(entityType.FindProperty("UShort")));
-        Assert.Equal((sbyte)1, CreateAndUseFactory(entityType.FindProperty("SByte")));
-        Assert.Equal((uint?)1, CreateAndUseFactory(entityType.FindProperty("NullableUInt")));
-        Assert.Equal((ulong?)1, CreateAndUseFactory(entityType.FindProperty("NullableULong")));
-        Assert.Equal((ushort?)1, CreateAndUseFactory(entityType.FindProperty("NullableUShort")));
-        Assert.Equal((sbyte?)1, CreateAndUseFactory(entityType.FindProperty("NullableSByte")));
+    [ConditionalTheory]
+    [InlineData(true)]
+    [InlineData(false)]
+    public void Can_create_factories_for_all_integer_types(bool useTry)
+    {
+        var model = BuildModel();
+        var entityType = model.FindEntityType(typeof(AnEntity))!;
+
+        Assert.Equal(1, CreateAndUseFactory(entityType.FindProperty("Id"), useTry));
+        Assert.Equal(1L, CreateAndUseFactory(entityType.FindProperty("Long"), useTry));
+        Assert.Equal((short)1, CreateAndUseFactory(entityType.FindProperty("Short"), useTry));
+        Assert.Equal((byte)1, CreateAndUseFactory(entityType.FindProperty("Byte"), useTry));
+        Assert.Equal((int?)1, CreateAndUseFactory(entityType.FindProperty("NullableInt"), useTry));
+        Assert.Equal((long?)1, CreateAndUseFactory(entityType.FindProperty("NullableLong"), useTry));
+        Assert.Equal((short?)1, CreateAndUseFactory(entityType.FindProperty("NullableShort"), useTry));
+        Assert.Equal((byte?)1, CreateAndUseFactory(entityType.FindProperty("NullableByte"), useTry));
+        Assert.Equal((uint)1, CreateAndUseFactory(entityType.FindProperty("UInt"), useTry));
+        Assert.Equal((ulong)1, CreateAndUseFactory(entityType.FindProperty("ULong"), useTry));
+        Assert.Equal((ushort)1, CreateAndUseFactory(entityType.FindProperty("UShort"), useTry));
+        Assert.Equal((sbyte)1, CreateAndUseFactory(entityType.FindProperty("SByte"), useTry));
+        Assert.Equal((uint?)1, CreateAndUseFactory(entityType.FindProperty("NullableUInt"), useTry));
+        Assert.Equal((ulong?)1, CreateAndUseFactory(entityType.FindProperty("NullableULong"), useTry));
+        Assert.Equal((ushort?)1, CreateAndUseFactory(entityType.FindProperty("NullableUShort"), useTry));
+        Assert.Equal((sbyte?)1, CreateAndUseFactory(entityType.FindProperty("NullableSByte"), useTry));
     }
 
-    private static object CreateAndUseFactory(IProperty property)
+    private static object CreateAndUseFactory(IProperty property, bool useTry = true)
     {
         var model = BuildModel();
 
         var selector = InMemoryTestHelpers.Instance.CreateContextServices(model).GetRequiredService<IValueGeneratorSelector>();
 
-        return selector.Select(property, property.DeclaringType).Next(null);
+        ValueGenerator generator;
+        if (useTry)
+        {
+            selector.TrySelect(property, property.DeclaringType, out generator);
+        }
+        else
+        {
+#pragma warning disable CS0618 // Type or member is obsolete
+            generator = selector.Select(property, property.DeclaringType);
+#pragma warning restore CS0618 // Type or member is obsolete
+        }
+
+        return generator!.Next(null!);
     }
 
     [ConditionalFact]
@@ -82,7 +128,21 @@ public void Throws_for_unsupported_combinations()
 
         Assert.Equal(
             CoreStrings.NoValueGenerator("Float", "AnEntity", "float"),
+#pragma warning disable CS0618 // Type or member is obsolete
             Assert.Throws<NotSupportedException>(() => selector.Select(entityType.FindProperty("Float"), entityType)).Message);
+#pragma warning restore CS0618 // Type or member is obsolete
+    }
+
+    [ConditionalFact]
+    public void Returns_null_for_unsupported_combinations()
+    {
+        var model = BuildModel();
+        var entityType = model.FindEntityType(typeof(AnEntity))!;
+
+        var selector = InMemoryTestHelpers.Instance.CreateContextServices(model).GetRequiredService<IValueGeneratorSelector>();
+
+        Assert.False(selector.TrySelect(entityType.FindProperty("Float")!, entityType, out var valueGenerator));
+        Assert.Null(valueGenerator);
     }
 
     private static IModel BuildModel(bool generateValues = true)
diff --git a/test/EFCore.Specification.Tests/GraphUpdates/GraphUpdatesTestBase.cs b/test/EFCore.Specification.Tests/GraphUpdates/GraphUpdatesTestBase.cs
index 2a4005c52e..4f50ce12ca 100644
--- a/test/EFCore.Specification.Tests/GraphUpdates/GraphUpdatesTestBase.cs
+++ b/test/EFCore.Specification.Tests/GraphUpdates/GraphUpdatesTestBase.cs
@@ -614,6 +614,41 @@ protected override void OnModelCreating(ModelBuilder modelBuilder, DbContext con
                     b.HasOne(x => x.Brother).WithOne().HasForeignKey<SneakyUncle32084>(x => x.BrotherId);
                     b.Property(e => e.Id).HasValueGenerator<StableGuidGenerator>();
                 });
+
+            modelBuilder.Entity<CompositeKeyWith<int>>(
+                b =>
+                {
+                    b.HasKey(e => new { e.TargetId, e.SourceId, e.PrimaryGroup });
+                    b.Property(e => e.PrimaryGroup).ValueGeneratedOnAdd();
+                });
+
+            modelBuilder.Entity<CompositeKeyWith<bool>>(
+                b =>
+                {
+                    b.HasKey(e => new { e.TargetId, e.SourceId, e.PrimaryGroup });
+                    b.Property(e => e.PrimaryGroup).ValueGeneratedOnAdd();
+                });
+
+            modelBuilder.Entity<CompositeKeyWith<bool?>>(
+                b =>
+                {
+                    b.HasKey(e => new { e.TargetId, e.SourceId, e.PrimaryGroup });
+                    b.Property(e => e.PrimaryGroup).ValueGeneratedOnAdd();
+                });
+
+            modelBuilder.Entity<BoolOnlyKey<bool>>(
+                b =>
+                {
+                    b.HasKey(e => e.PrimaryGroup);
+                    b.Property(e => e.PrimaryGroup).ValueGeneratedOnAdd();
+                });
+
+            modelBuilder.Entity<BoolOnlyKey<bool?>>(
+                b =>
+                {
+                    b.HasKey(e => e.PrimaryGroup);
+                    b.Property(e => e.PrimaryGroup).ValueGeneratedOnAdd();
+                });
         }
 
         private class StableGuidGenerator : ValueGenerator<Guid>
@@ -4480,6 +4515,44 @@ public StableParent32084 Brother
         }
     }
 
+    protected class CompositeKeyWith<T> : NotifyingEntity
+        where T : new()
+    {
+        private Guid _targetId;
+        private Guid _sourceId;
+        private T _primaryGroup;
+
+        public Guid TargetId
+        {
+            get => _targetId;
+            set => SetWithNotify(value, ref _targetId);
+        }
+
+        public Guid SourceId
+        {
+            get => _sourceId;
+            set => SetWithNotify(value, ref _sourceId);
+        }
+
+        public T PrimaryGroup
+        {
+            get => _primaryGroup;
+            set => SetWithNotify(value, ref _primaryGroup);
+        }
+    }
+
+    protected class BoolOnlyKey<T> : NotifyingEntity
+        where T : new()
+    {
+        private T _primaryGroup;
+
+        public T PrimaryGroup
+        {
+            get => _primaryGroup;
+            set => SetWithNotify(value, ref _primaryGroup);
+        }
+    }
+
     protected class NotifyingEntity : INotifyPropertyChanging, INotifyPropertyChanged
     {
         protected void SetWithNotify<T>(T value, ref T field, [CallerMemberName] string propertyName = "")
diff --git a/test/EFCore.Specification.Tests/GraphUpdates/GraphUpdatesTestBaseMiscellaneous.cs b/test/EFCore.Specification.Tests/GraphUpdates/GraphUpdatesTestBaseMiscellaneous.cs
index 7f8450d619..5c821da894 100644
--- a/test/EFCore.Specification.Tests/GraphUpdates/GraphUpdatesTestBaseMiscellaneous.cs
+++ b/test/EFCore.Specification.Tests/GraphUpdates/GraphUpdatesTestBaseMiscellaneous.cs
@@ -103,6 +103,101 @@ public virtual async Task Can_insert_when_FK_has_sentinel_value(bool async)
                 Assert.Equal(cruiser.IdUserState, cruiser.UserState.AccessStateWithSentinelId);
             });
 
+    [ConditionalTheory]
+    [InlineData(false, false)]
+    [InlineData(true, false)]
+    [InlineData(false, true)]
+    [InlineData(true, true)]
+    public virtual Task Can_insert_when_bool_PK_in_composite_key_has_sentinel_value(bool async, bool initialValue)
+        => Can_insert_when_PK_property_in_composite_key_has_sentinel_value(async, initialValue);
+
+    [ConditionalTheory]
+    [InlineData(false, 0)]
+    [InlineData(true, 0)]
+    [InlineData(false, 1)]
+    [InlineData(true, 1)]
+    [InlineData(false, 2)]
+    [InlineData(true, 2)]
+    public virtual Task Can_insert_when_int_PK_in_composite_key_has_sentinel_value(bool async, int initialValue)
+        => Can_insert_when_PK_property_in_composite_key_has_sentinel_value(async, initialValue);
+
+    [ConditionalTheory]
+    [InlineData(false, false)]
+    [InlineData(true, false)]
+    [InlineData(false, true)]
+    [InlineData(true, true)]
+    public virtual Task Can_insert_when_nullable_bool_PK_in_composite_key_has_sentinel_value(bool async, bool? initialValue)
+        => Can_insert_when_PK_property_in_composite_key_has_sentinel_value(async, initialValue);
+
+    protected async Task Can_insert_when_PK_property_in_composite_key_has_sentinel_value<T>(bool async, T initialValue)
+        where T : new()
+    {
+        var inserted = new CompositeKeyWith<T>()
+        {
+            SourceId = Guid.NewGuid(),
+            TargetId = Guid.NewGuid(),
+            PrimaryGroup = initialValue
+        };
+
+        await ExecuteWithStrategyInTransactionAsync(
+            async context =>
+            {
+                if (async)
+                {
+                    await context.AddAsync(inserted);
+                    await context.SaveChangesAsync();
+                }
+                else
+                {
+                    context.Add(inserted);
+                    context.SaveChanges();
+                }
+            },
+            async context =>
+            {
+                var queryable = context.Set<CompositeKeyWith<T>>();
+                var loaded = async ? (await queryable.SingleAsync()) : queryable.Single();
+                Assert.Equal(inserted.SourceId, loaded.SourceId);
+                Assert.Equal(inserted.TargetId, loaded.TargetId);
+                Assert.Equal(initialValue, loaded.PrimaryGroup);
+            });
+    }
+
+    [ConditionalTheory]
+    [InlineData(false, false)]
+    [InlineData(true, false)]
+    [InlineData(false, true)]
+    [InlineData(true, true)]
+    public virtual Task Throws_for_single_property_bool_key_with_default_value_generation(bool async, bool initialValue)
+        => Throws_for_single_property_key_with_default_value_generation(async, initialValue);
+
+    [ConditionalTheory]
+    [InlineData(false, false)]
+    [InlineData(true, false)]
+    [InlineData(false, true)]
+    [InlineData(true, true)]
+    public virtual Task Throws_for_single_property_nullable_bool_key_with_default_value_generation(bool async, bool? initialValue)
+        => Throws_for_single_property_key_with_default_value_generation(async, initialValue);
+
+    protected async Task Throws_for_single_property_key_with_default_value_generation<T>(bool async, T initialValue)
+        where T : new()
+    {
+        var inserted = new BoolOnlyKey<T>()
+        {
+            PrimaryGroup = initialValue
+        };
+
+        await ExecuteWithStrategyInTransactionAsync(
+            async context =>
+            {
+                Assert.Equal(
+                    CoreStrings.NoValueGenerator("PrimaryGroup", typeof(BoolOnlyKey<T>).ShortDisplayName(), typeof(T).ShortDisplayName()),
+                    (async
+                        ? (await Assert.ThrowsAsync<NotSupportedException>(async () => await context.AddAsync(inserted)))
+                        : Assert.Throws<NotSupportedException>(() => context.Add(inserted))).Message);
+            });
+    }
+
     [ConditionalTheory] // Issue #23043
     [InlineData(false)]
     [InlineData(true)]
diff --git a/test/EFCore.SqlServer.FunctionalTests/GraphUpdates/GraphUpdatesSqlServerOwnedTest.cs b/test/EFCore.SqlServer.FunctionalTests/GraphUpdates/GraphUpdatesSqlServerOwnedTest.cs
index 15856a214a..b0d1ff5fa8 100644
--- a/test/EFCore.SqlServer.FunctionalTests/GraphUpdates/GraphUpdatesSqlServerOwnedTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/GraphUpdates/GraphUpdatesSqlServerOwnedTest.cs
@@ -78,6 +78,26 @@ public override void Required_one_to_one_with_AK_relationships_are_one_to_one(Ca
     {
     }
 
+    // No owned types
+    public override Task Can_insert_when_bool_PK_in_composite_key_has_sentinel_value(bool async, bool initialValue)
+        => Task.CompletedTask;
+
+    // No owned types
+    public override Task Can_insert_when_int_PK_in_composite_key_has_sentinel_value(bool async, int initialValue)
+        => Task.CompletedTask;
+
+    // No owned types
+    public override Task Can_insert_when_nullable_bool_PK_in_composite_key_has_sentinel_value(bool async, bool? initialValue)
+        => Task.CompletedTask;
+
+    // No owned types
+    public override Task Throws_for_single_property_bool_key_with_default_value_generation(bool async, bool initialValue)
+        => Task.CompletedTask;
+
+    // No owned types
+    public override Task Throws_for_single_property_nullable_bool_key_with_default_value_generation(bool async, bool? initialValue)
+        => Task.CompletedTask;
+
     protected override void UseTransaction(DatabaseFacade facade, IDbContextTransaction transaction)
         => facade.UseTransaction(transaction.GetDbTransaction());
 
diff --git a/test/EFCore.SqlServer.FunctionalTests/GraphUpdates/GraphUpdatesSqlServerTestBase.cs b/test/EFCore.SqlServer.FunctionalTests/GraphUpdates/GraphUpdatesSqlServerTestBase.cs
index 6719be3b0d..604751ed6b 100644
--- a/test/EFCore.SqlServer.FunctionalTests/GraphUpdates/GraphUpdatesSqlServerTestBase.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/GraphUpdates/GraphUpdatesSqlServerTestBase.cs
@@ -196,6 +196,24 @@ protected override void OnModelCreating(ModelBuilder modelBuilder, DbContext con
                         .HasForeignKey<StringKeyAndIndexChild>(e => e.ParentId)
                         .HasPrincipalKey<StringKeyAndIndexParent>(e => e.AlternateId);
                 });
+
+            modelBuilder.Entity<CompositeKeyWith<int>>(
+                b =>
+                {
+                    b.Property(e => e.PrimaryGroup).HasDefaultValue(1).HasSentinel(1);
+                });
+
+            modelBuilder.Entity<CompositeKeyWith<bool>>(
+                b =>
+                {
+                    b.Property(e => e.PrimaryGroup).HasDefaultValue(true);
+                });
+
+            modelBuilder.Entity<CompositeKeyWith<bool?>>(
+                b =>
+                {
+                    b.Property(e => e.PrimaryGroup).HasDefaultValue(true);
+                });
         }
     }
 }
diff --git a/test/EFCore.SqlServer.Tests/ValueGeneration/SqlServerValueGeneratorSelectorTest.cs b/test/EFCore.SqlServer.Tests/ValueGeneration/SqlServerValueGeneratorSelectorTest.cs
index 0edf9d855e..bc0f8b2744 100644
--- a/test/EFCore.SqlServer.Tests/ValueGeneration/SqlServerValueGeneratorSelectorTest.cs
+++ b/test/EFCore.SqlServer.Tests/ValueGeneration/SqlServerValueGeneratorSelectorTest.cs
@@ -10,25 +10,27 @@ namespace Microsoft.EntityFrameworkCore.ValueGeneration;
 
 public class SqlServerValueGeneratorSelectorTest
 {
-    [ConditionalFact]
-    public void Returns_built_in_generators_for_types_setup_for_value_generation()
+    [ConditionalTheory]
+    [InlineData(true)]
+    [InlineData(false)]
+    public void Returns_built_in_generators_for_types_setup_for_value_generation(bool useTry)
     {
-        AssertGenerator<TemporaryIntValueGenerator>("Id");
-        AssertGenerator<CustomValueGenerator>("Custom");
-        AssertGenerator<TemporaryLongValueGenerator>("Long");
-        AssertGenerator<TemporaryShortValueGenerator>("Short");
-        AssertGenerator<TemporaryByteValueGenerator>("Byte");
-        AssertGenerator<TemporaryIntValueGenerator>("NullableInt");
-        AssertGenerator<TemporaryLongValueGenerator>("NullableLong");
-        AssertGenerator<TemporaryShortValueGenerator>("NullableShort");
-        AssertGenerator<TemporaryByteValueGenerator>("NullableByte");
-        AssertGenerator<TemporaryDecimalValueGenerator>("Decimal");
-        AssertGenerator<StringValueGenerator>("String");
-        AssertGenerator<SequentialGuidValueGenerator>("Guid");
-        AssertGenerator<BinaryValueGenerator>("Binary");
+        AssertGenerator<TemporaryIntValueGenerator>("Id", useTry: useTry);
+        AssertGenerator<CustomValueGenerator>("Custom", useTry: useTry);
+        AssertGenerator<TemporaryLongValueGenerator>("Long", useTry: useTry);
+        AssertGenerator<TemporaryShortValueGenerator>("Short", useTry: useTry);
+        AssertGenerator<TemporaryByteValueGenerator>("Byte", useTry: useTry);
+        AssertGenerator<TemporaryIntValueGenerator>("NullableInt", useTry: useTry);
+        AssertGenerator<TemporaryLongValueGenerator>("NullableLong", useTry: useTry);
+        AssertGenerator<TemporaryShortValueGenerator>("NullableShort", useTry: useTry);
+        AssertGenerator<TemporaryByteValueGenerator>("NullableByte", useTry: useTry);
+        AssertGenerator<TemporaryDecimalValueGenerator>("Decimal", useTry: useTry);
+        AssertGenerator<StringValueGenerator>("String", useTry: useTry);
+        AssertGenerator<SequentialGuidValueGenerator>("Guid", useTry: useTry);
+        AssertGenerator<BinaryValueGenerator>("Binary", useTry: useTry);
     }
 
-    private void AssertGenerator<TExpected>(string propertyName, bool useHiLo = false, bool useKeySequence = false)
+    private void AssertGenerator<TExpected>(string propertyName, bool useHiLo = false, bool useKeySequence = false, bool useTry = true)
     {
         var builder = SqlServerTestHelpers.Instance.CreateConventionBuilder();
         builder.Entity<AnEntity>(
@@ -51,15 +53,37 @@ private void AssertGenerator<TExpected>(string propertyName, bool useHiLo = fals
         }
 
         var model = builder.FinalizeModel();
-        var entityType = model.FindEntityType(typeof(AnEntity));
+        var entityType = model.FindEntityType(typeof(AnEntity))!;
 
         var selector = SqlServerTestHelpers.Instance.CreateContextServices(model).GetRequiredService<IValueGeneratorSelector>();
 
-        Assert.IsType<TExpected>(selector.Select(entityType.FindProperty(propertyName), entityType));
+        var property = entityType.FindProperty(propertyName)!;
+        var generator = CreateValueGenerator(selector, property, useTry);
+
+        Assert.IsType<TExpected>(generator);
     }
 
-    [ConditionalFact]
-    public void Returns_temp_guid_generator_when_default_sql_set()
+    private static ValueGenerator CreateValueGenerator(IValueGeneratorSelector selector, IProperty property, bool useTry)
+    {
+        ValueGenerator generator;
+        if (useTry)
+        {
+            selector.TrySelect(property, property.DeclaringType, out generator);
+        }
+        else
+        {
+#pragma warning disable CS0618 // Type or member is obsolete
+            generator = selector.Select(property, property.DeclaringType);
+#pragma warning restore CS0618 // Type or member is obsolete
+        }
+
+        return generator;
+    }
+
+    [ConditionalTheory]
+    [InlineData(true)]
+    [InlineData(false)]
+    public void Returns_temp_guid_generator_when_default_sql_set(bool useTry)
     {
         var builder = SqlServerTestHelpers.Instance.CreateConventionBuilder();
         builder.Entity<AnEntity>(
@@ -69,15 +93,19 @@ public void Returns_temp_guid_generator_when_default_sql_set()
                 b.HasKey(e => e.Guid);
             });
         var model = builder.FinalizeModel();
-        var entityType = model.FindEntityType(typeof(AnEntity));
+        var entityType = model.FindEntityType(typeof(AnEntity))!;
 
         var selector = SqlServerTestHelpers.Instance.CreateContextServices(model).GetRequiredService<IValueGeneratorSelector>();
 
-        Assert.IsType<TemporaryGuidValueGenerator>(selector.Select(entityType.FindProperty("Guid"), entityType));
+        var property = entityType.FindProperty("Guid")!;
+        var generator = CreateValueGenerator(selector, property, useTry);
+        Assert.IsType<TemporaryGuidValueGenerator>(generator);
     }
 
-    [ConditionalFact]
-    public void Returns_temp_string_generator_when_default_sql_set()
+    [ConditionalTheory]
+    [InlineData(true)]
+    [InlineData(false)]
+    public void Returns_temp_string_generator_when_default_sql_set(bool useTry)
     {
         var builder = SqlServerTestHelpers.Instance.CreateConventionBuilder();
         builder.Entity<AnEntity>(
@@ -87,17 +115,21 @@ public void Returns_temp_string_generator_when_default_sql_set()
                 b.HasKey(e => e.String);
             });
         var model = builder.FinalizeModel();
-        var entityType = model.FindEntityType(typeof(AnEntity));
+        var entityType = model.FindEntityType(typeof(AnEntity))!;
 
         var selector = SqlServerTestHelpers.Instance.CreateContextServices(model).GetRequiredService<IValueGeneratorSelector>();
 
-        var generator = selector.Select(entityType.FindProperty("String"), entityType);
+        var property = entityType.FindProperty("String")!;
+        var generator = CreateValueGenerator(selector, property, useTry);
+
         Assert.IsType<TemporaryStringValueGenerator>(generator);
         Assert.True(generator.GeneratesTemporaryValues);
     }
 
-    [ConditionalFact]
-    public void Returns_temp_binary_generator_when_default_sql_set()
+    [ConditionalTheory]
+    [InlineData(true)]
+    [InlineData(false)]
+    public void Returns_temp_binary_generator_when_default_sql_set(bool useTry)
     {
         var builder = SqlServerTestHelpers.Instance.CreateConventionBuilder();
         builder.Entity<AnEntity>(
@@ -107,49 +139,55 @@ public void Returns_temp_binary_generator_when_default_sql_set()
                 b.Property(e => e.Binary).HasDefaultValueSql("Foo").ValueGeneratedOnAdd();
             });
         var model = builder.FinalizeModel();
-        var entityType = model.FindEntityType(typeof(AnEntity));
+        var entityType = model.FindEntityType(typeof(AnEntity))!;
 
         var selector = SqlServerTestHelpers.Instance.CreateContextServices(model).GetRequiredService<IValueGeneratorSelector>();
 
-        var generator = selector.Select(entityType.FindProperty("Binary"), entityType);
+        var property = entityType.FindProperty("Binary")!;
+        var generator = CreateValueGenerator(selector, property, useTry);
+
         Assert.IsType<TemporaryBinaryValueGenerator>(generator);
         Assert.True(generator.GeneratesTemporaryValues);
     }
 
-    [ConditionalFact]
-    public void Returns_sequence_value_generators_when_configured_for_model()
+    [ConditionalTheory]
+    [InlineData(true)]
+    [InlineData(false)]
+    public void Returns_sequence_value_generators_when_configured_for_model(bool useTry)
     {
-        AssertGenerator<SqlServerSequenceHiLoValueGenerator<int>>("Id", useHiLo: true);
-        AssertGenerator<CustomValueGenerator>("Custom", useHiLo: true);
-        AssertGenerator<SqlServerSequenceHiLoValueGenerator<long>>("Long", useHiLo: true);
-        AssertGenerator<SqlServerSequenceHiLoValueGenerator<short>>("Short", useHiLo: true);
-        AssertGenerator<SqlServerSequenceHiLoValueGenerator<byte>>("Byte", useHiLo: true);
-        AssertGenerator<SqlServerSequenceHiLoValueGenerator<int>>("NullableInt", useHiLo: true);
-        AssertGenerator<SqlServerSequenceHiLoValueGenerator<long>>("NullableLong", useHiLo: true);
-        AssertGenerator<SqlServerSequenceHiLoValueGenerator<short>>("NullableShort", useHiLo: true);
-        AssertGenerator<SqlServerSequenceHiLoValueGenerator<byte>>("NullableByte", useHiLo: true);
-        AssertGenerator<SqlServerSequenceHiLoValueGenerator<decimal>>("Decimal", useHiLo: true);
-        AssertGenerator<StringValueGenerator>("String", useHiLo: true);
-        AssertGenerator<SequentialGuidValueGenerator>("Guid", useHiLo: true);
-        AssertGenerator<BinaryValueGenerator>("Binary", useHiLo: true);
+        AssertGenerator<SqlServerSequenceHiLoValueGenerator<int>>("Id", useHiLo: true, useTry: useTry);
+        AssertGenerator<CustomValueGenerator>("Custom", useHiLo: true, useTry: useTry);
+        AssertGenerator<SqlServerSequenceHiLoValueGenerator<long>>("Long", useHiLo: true, useTry: useTry);
+        AssertGenerator<SqlServerSequenceHiLoValueGenerator<short>>("Short", useHiLo: true, useTry: useTry);
+        AssertGenerator<SqlServerSequenceHiLoValueGenerator<byte>>("Byte", useHiLo: true, useTry: useTry);
+        AssertGenerator<SqlServerSequenceHiLoValueGenerator<int>>("NullableInt", useHiLo: true, useTry: useTry);
+        AssertGenerator<SqlServerSequenceHiLoValueGenerator<long>>("NullableLong", useHiLo: true, useTry: useTry);
+        AssertGenerator<SqlServerSequenceHiLoValueGenerator<short>>("NullableShort", useHiLo: true, useTry: useTry);
+        AssertGenerator<SqlServerSequenceHiLoValueGenerator<byte>>("NullableByte", useHiLo: true, useTry: useTry);
+        AssertGenerator<SqlServerSequenceHiLoValueGenerator<decimal>>("Decimal", useHiLo: true, useTry: useTry);
+        AssertGenerator<StringValueGenerator>("String", useHiLo: true, useTry: useTry);
+        AssertGenerator<SequentialGuidValueGenerator>("Guid", useHiLo: true, useTry: useTry);
+        AssertGenerator<BinaryValueGenerator>("Binary", useHiLo: true, useTry: useTry);
     }
 
-    [ConditionalFact]
-    public void Returns_built_in_generators_for_types_setup_for_value_generation_even_with_key_sequences()
+    [ConditionalTheory]
+    [InlineData(true)]
+    [InlineData(false)]
+    public void Returns_built_in_generators_for_types_setup_for_value_generation_even_with_key_sequences(bool useTry)
     {
-        AssertGenerator<TemporaryIntValueGenerator>("Id", useKeySequence: true);
-        AssertGenerator<CustomValueGenerator>("Custom", useKeySequence: true);
-        AssertGenerator<TemporaryLongValueGenerator>("Long", useKeySequence: true);
-        AssertGenerator<TemporaryShortValueGenerator>("Short", useKeySequence: true);
-        AssertGenerator<TemporaryByteValueGenerator>("Byte", useKeySequence: true);
-        AssertGenerator<TemporaryIntValueGenerator>("NullableInt", useKeySequence: true);
-        AssertGenerator<TemporaryLongValueGenerator>("NullableLong", useKeySequence: true);
-        AssertGenerator<TemporaryShortValueGenerator>("NullableShort", useKeySequence: true);
-        AssertGenerator<TemporaryByteValueGenerator>("NullableByte", useKeySequence: true);
-        AssertGenerator<TemporaryDecimalValueGenerator>("Decimal", useKeySequence: true);
-        AssertGenerator<StringValueGenerator>("String", useKeySequence: true);
-        AssertGenerator<SequentialGuidValueGenerator>("Guid", useKeySequence: true);
-        AssertGenerator<BinaryValueGenerator>("Binary", useKeySequence: true);
+        AssertGenerator<TemporaryIntValueGenerator>("Id", useKeySequence: true, useTry: useTry);
+        AssertGenerator<CustomValueGenerator>("Custom", useKeySequence: true, useTry: useTry);
+        AssertGenerator<TemporaryLongValueGenerator>("Long", useKeySequence: true, useTry: useTry);
+        AssertGenerator<TemporaryShortValueGenerator>("Short", useKeySequence: true, useTry: useTry);
+        AssertGenerator<TemporaryByteValueGenerator>("Byte", useKeySequence: true, useTry: useTry);
+        AssertGenerator<TemporaryIntValueGenerator>("NullableInt", useKeySequence: true, useTry: useTry);
+        AssertGenerator<TemporaryLongValueGenerator>("NullableLong", useKeySequence: true, useTry: useTry);
+        AssertGenerator<TemporaryShortValueGenerator>("NullableShort", useKeySequence: true, useTry: useTry);
+        AssertGenerator<TemporaryByteValueGenerator>("NullableByte", useKeySequence: true, useTry: useTry);
+        AssertGenerator<TemporaryDecimalValueGenerator>("Decimal", useKeySequence: true, useTry: useTry);
+        AssertGenerator<StringValueGenerator>("String", useKeySequence: true, useTry: useTry);
+        AssertGenerator<SequentialGuidValueGenerator>("Guid", useKeySequence: true, useTry: useTry);
+        AssertGenerator<BinaryValueGenerator>("Binary", useKeySequence: true, useTry: useTry);
     }
 
     [ConditionalFact]
@@ -165,15 +203,38 @@ public void Throws_for_unsupported_combinations()
         var model = builder.FinalizeModel();
         var entityType = model.FindEntityType(typeof(AnEntity));
 
-        var selector = InMemoryTestHelpers.Instance.CreateContextServices(model).GetRequiredService<IValueGeneratorSelector>();
+        var selector = SqlServerTestHelpers.Instance.CreateContextServices(model).GetRequiredService<IValueGeneratorSelector>();
 
         Assert.Equal(
             CoreStrings.NoValueGenerator("Random", "AnEntity", "Something"),
+#pragma warning disable CS0618 // Type or member is obsolete
             Assert.Throws<NotSupportedException>(() => selector.Select(entityType.FindProperty("Random"), entityType)).Message);
+#pragma warning restore CS0618 // Type or member is obsolete
     }
 
     [ConditionalFact]
-    public void Returns_generator_configured_on_model_when_property_is_identity()
+    public void Returns_null_for_unsupported_combinations()
+    {
+        var builder = InMemoryTestHelpers.Instance.CreateConventionBuilder();
+        builder.Entity<AnEntity>(
+            b =>
+            {
+                b.Property(e => e.Random).ValueGeneratedOnAdd();
+                b.HasKey(e => e.Random);
+            });
+        var model = builder.FinalizeModel();
+        var entityType = model.FindEntityType(typeof(AnEntity))!;
+
+        var selector = SqlServerTestHelpers.Instance.CreateContextServices(model).GetRequiredService<IValueGeneratorSelector>();
+
+        Assert.False(selector.TrySelect(entityType.FindProperty("Random")!, entityType, out var valueGenerator));
+        Assert.Null(valueGenerator);
+    }
+
+    [ConditionalTheory]
+    [InlineData(true)]
+    [InlineData(false)]
+    public void Returns_generator_configured_on_model_when_property_is_identity(bool useTry)
     {
         var builder = SqlServerTestHelpers.Instance.CreateConventionBuilder();
 
@@ -184,11 +245,14 @@ public void Returns_generator_configured_on_model_when_property_is_identity()
             .HasSequence<int>(SqlServerModelExtensions.DefaultHiLoSequenceName);
 
         var model = builder.UseHiLo().FinalizeModel();
-        var entityType = model.FindEntityType(typeof(AnEntity));
+        var entityType = model.FindEntityType(typeof(AnEntity))!;
 
         var selector = SqlServerTestHelpers.Instance.CreateContextServices(model).GetRequiredService<IValueGeneratorSelector>();
 
-        Assert.IsType<SqlServerSequenceHiLoValueGenerator<int>>(selector.Select(entityType.FindProperty("Id"), entityType));
+        var property = entityType.FindProperty("Id")!;
+        var generator = CreateValueGenerator(selector, property, useTry);
+
+        Assert.IsType<SqlServerSequenceHiLoValueGenerator<int>>(generator);
     }
 
     private class AnEntity
diff --git a/test/EFCore.Sqlite.FunctionalTests/GraphUpdates/GraphUpdatesSqliteTestBase.cs b/test/EFCore.Sqlite.FunctionalTests/GraphUpdates/GraphUpdatesSqliteTestBase.cs
index 7f693f97ad..e33b778d1c 100644
--- a/test/EFCore.Sqlite.FunctionalTests/GraphUpdates/GraphUpdatesSqliteTestBase.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/GraphUpdates/GraphUpdatesSqliteTestBase.cs
@@ -122,6 +122,24 @@ protected override void OnModelCreating(ModelBuilder modelBuilder, DbContext con
 
             modelBuilder.Entity<SomethingOfCategoryA>().Property<int>("CategoryId").HasDefaultValue(1);
             modelBuilder.Entity<SomethingOfCategoryB>().Property(e => e.CategoryId).HasDefaultValue(2);
+
+            modelBuilder.Entity<CompositeKeyWith<int>>(
+                b =>
+                {
+                    b.Property(e => e.PrimaryGroup).HasDefaultValue(1).HasSentinel(1);
+                });
+
+            modelBuilder.Entity<CompositeKeyWith<bool>>(
+                b =>
+                {
+                    b.Property(e => e.PrimaryGroup).HasDefaultValue(true);
+                });
+
+            modelBuilder.Entity<CompositeKeyWith<bool?>>(
+                b =>
+                {
+                    b.Property(e => e.PrimaryGroup).HasDefaultValue(true);
+                });
         }
     }
 }
diff --git a/test/EFCore.Tests/ChangeTracking/ChangeTrackerTest.cs b/test/EFCore.Tests/ChangeTracking/ChangeTrackerTest.cs
index 2d1bb02b97..7c27647183 100644
--- a/test/EFCore.Tests/ChangeTracking/ChangeTrackerTest.cs
+++ b/test/EFCore.Tests/ChangeTracking/ChangeTrackerTest.cs
@@ -941,7 +941,7 @@ private static void ResetValueGenerator(DbContext context, IProperty property, b
         var generator = (ResettableValueGenerator)cache.GetOrAdd(
             property,
             property.DeclaringType,
-            (p, e) => new ResettableValueGenerator());
+            (p, e) => new ResettableValueGenerator())!;
 
         generator.Reset(generateTemporaryValues);
     }
diff --git a/test/EFCore.Tests/ValueGeneration/ValueGeneratorSelectorTest.cs b/test/EFCore.Tests/ValueGeneration/ValueGeneratorSelectorTest.cs
index c38c93d11f..6f14e9207a 100644
--- a/test/EFCore.Tests/ValueGeneration/ValueGeneratorSelectorTest.cs
+++ b/test/EFCore.Tests/ValueGeneration/ValueGeneratorSelectorTest.cs
@@ -9,54 +9,110 @@ public class ValueGeneratorSelectorTest
     public void Returns_built_in_generators_for_types_setup_for_value_generation()
     {
         var model = BuildModel();
-        var entityType = model.FindEntityType(typeof(AnEntity));
+        var entityType = model.FindEntityType(typeof(AnEntity))!;
+
+        var selector = new ValueGeneratorSelector(
+            new ValueGeneratorSelectorDependencies(new ValueGeneratorCache(new ValueGeneratorCacheDependencies())));
+
+#pragma warning disable CS0618 // Type or member is obsolete
+        Assert.IsType<CustomValueGenerator>(selector.Select(entityType.FindProperty("Custom")!, entityType));
+
+        Assert.Throws<NotSupportedException>(() => selector.Select(entityType.FindProperty("Id")!, entityType));
+        Assert.Throws<NotSupportedException>(() => selector.Select(entityType.FindProperty("Long")!, entityType));
+        Assert.Throws<NotSupportedException>(() => selector.Select(entityType.FindProperty("Short")!, entityType));
+        Assert.Throws<NotSupportedException>(() => selector.Select(entityType.FindProperty("Byte")!, entityType));
+
+        Assert.Throws<NotSupportedException>(() => selector.Select(entityType.FindProperty("NullableInt")!, entityType));
+        Assert.Throws<NotSupportedException>(() => selector.Select(entityType.FindProperty("NullableLong")!, entityType));
+        Assert.Throws<NotSupportedException>(() => selector.Select(entityType.FindProperty("NullableShort")!, entityType));
+        Assert.Throws<NotSupportedException>(() => selector.Select(entityType.FindProperty("NullableByte")!, entityType));
+
+        Assert.Throws<NotSupportedException>(() => selector.Select(entityType.FindProperty("UInt")!, entityType));
+        Assert.Throws<NotSupportedException>(() => selector.Select(entityType.FindProperty("ULong")!, entityType));
+        Assert.Throws<NotSupportedException>(() => selector.Select(entityType.FindProperty("UShort")!, entityType));
+        Assert.Throws<NotSupportedException>(() => selector.Select(entityType.FindProperty("SByte")!, entityType));
+
+        Assert.Throws<NotSupportedException>(() => selector.Select(entityType.FindProperty("NullableUInt")!, entityType));
+        Assert.Throws<NotSupportedException>(() => selector.Select(entityType.FindProperty("NullableULong")!, entityType));
+        Assert.Throws<NotSupportedException>(() => selector.Select(entityType.FindProperty("NullableUShort")!, entityType));
+        Assert.Throws<NotSupportedException>(() => selector.Select(entityType.FindProperty("NullableSByte")!, entityType));
+
+        Assert.Throws<NotSupportedException>(() => selector.Select(entityType.FindProperty("Decimal")!, entityType));
+        Assert.Throws<NotSupportedException>(() => selector.Select(entityType.FindProperty("NullableDecimal")!, entityType));
+
+        Assert.Throws<NotSupportedException>(() => selector.Select(entityType.FindProperty("Float")!, entityType));
+        Assert.Throws<NotSupportedException>(() => selector.Select(entityType.FindProperty("NullableFloat")!, entityType));
+
+        Assert.Throws<NotSupportedException>(() => selector.Select(entityType.FindProperty("Double")!, entityType));
+        Assert.Throws<NotSupportedException>(() => selector.Select(entityType.FindProperty("NullableDouble")!, entityType));
+
+        Assert.Throws<NotSupportedException>(() => selector.Select(entityType.FindProperty("DateTime")!, entityType));
+        Assert.Throws<NotSupportedException>(() => selector.Select(entityType.FindProperty("NullableDateTime")!, entityType));
+
+        Assert.Throws<NotSupportedException>(() => selector.Select(entityType.FindProperty("DateTimeOffset")!, entityType));
+        Assert.Throws<NotSupportedException>(() => selector.Select(entityType.FindProperty("NullableDateTimeOffset")!, entityType));
+
+        Assert.IsType<StringValueGenerator>(selector.Select(entityType.FindProperty("String")!, entityType));
+
+        Assert.IsType<GuidValueGenerator>(selector.Select(entityType.FindProperty("Guid")!, entityType));
+        Assert.IsType<GuidValueGenerator>(selector.Select(entityType.FindProperty("NullableGuid")!, entityType));
+
+        Assert.IsType<BinaryValueGenerator>(selector.Select(entityType.FindProperty("Binary")!, entityType));
+#pragma warning restore CS0618 // Type or member is obsolete
+    }
+
+    [ConditionalFact]
+    public void Returns_built_in_generators_for_types_setup_for_value_generation_using_Try_method()
+    {
+        var model = BuildModel();
+        var entityType = model.FindEntityType(typeof(AnEntity))!;
 
         var selector = new ValueGeneratorSelector(
             new ValueGeneratorSelectorDependencies(new ValueGeneratorCache(new ValueGeneratorCacheDependencies())));
 
-        Assert.IsType<CustomValueGenerator>(selector.Select(entityType.FindProperty("Custom"), entityType));
+        Assert.IsType<CustomValueGenerator>(selector.TrySelect(entityType.FindProperty("Custom")!, entityType, out var generator) ? generator : null);
 
-        Assert.Throws<NotSupportedException>(() => selector.Select(entityType.FindProperty("Id"), entityType));
-        Assert.Throws<NotSupportedException>(() => selector.Select(entityType.FindProperty("Long"), entityType));
-        Assert.Throws<NotSupportedException>(() => selector.Select(entityType.FindProperty("Short"), entityType));
-        Assert.Throws<NotSupportedException>(() => selector.Select(entityType.FindProperty("Byte"), entityType));
+        Assert.Null(selector.TrySelect(entityType.FindProperty("Id")!, entityType, out generator) ? generator : null);
+        Assert.Null(selector.TrySelect(entityType.FindProperty("Long")!, entityType, out generator) ? generator : null);
+        Assert.Null(selector.TrySelect(entityType.FindProperty("Short")!, entityType, out generator) ? generator : null);
+        Assert.Null(selector.TrySelect(entityType.FindProperty("Byte")!, entityType, out generator) ? generator : null);
 
-        Assert.Throws<NotSupportedException>(() => selector.Select(entityType.FindProperty("NullableInt"), entityType));
-        Assert.Throws<NotSupportedException>(() => selector.Select(entityType.FindProperty("NullableLong"), entityType));
-        Assert.Throws<NotSupportedException>(() => selector.Select(entityType.FindProperty("NullableShort"), entityType));
-        Assert.Throws<NotSupportedException>(() => selector.Select(entityType.FindProperty("NullableByte"), entityType));
+        Assert.Null(selector.TrySelect(entityType.FindProperty("NullableInt")!, entityType, out generator) ? generator : null);
+        Assert.Null(selector.TrySelect(entityType.FindProperty("NullableLong")!, entityType, out generator) ? generator : null);
+        Assert.Null(selector.TrySelect(entityType.FindProperty("NullableShort")!, entityType, out generator) ? generator : null);
+        Assert.Null(selector.TrySelect(entityType.FindProperty("NullableByte")!, entityType, out generator) ? generator : null);
 
-        Assert.Throws<NotSupportedException>(() => selector.Select(entityType.FindProperty("UInt"), entityType));
-        Assert.Throws<NotSupportedException>(() => selector.Select(entityType.FindProperty("ULong"), entityType));
-        Assert.Throws<NotSupportedException>(() => selector.Select(entityType.FindProperty("UShort"), entityType));
-        Assert.Throws<NotSupportedException>(() => selector.Select(entityType.FindProperty("SByte"), entityType));
+        Assert.Null(selector.TrySelect(entityType.FindProperty("UInt")!, entityType, out generator) ? generator : null);
+        Assert.Null(selector.TrySelect(entityType.FindProperty("ULong")!, entityType, out generator) ? generator : null);
+        Assert.Null(selector.TrySelect(entityType.FindProperty("UShort")!, entityType, out generator) ? generator : null);
+        Assert.Null(selector.TrySelect(entityType.FindProperty("SByte")!, entityType, out generator) ? generator : null);
 
-        Assert.Throws<NotSupportedException>(() => selector.Select(entityType.FindProperty("NullableUInt"), entityType));
-        Assert.Throws<NotSupportedException>(() => selector.Select(entityType.FindProperty("NullableULong"), entityType));
-        Assert.Throws<NotSupportedException>(() => selector.Select(entityType.FindProperty("NullableUShort"), entityType));
-        Assert.Throws<NotSupportedException>(() => selector.Select(entityType.FindProperty("NullableSByte"), entityType));
+        Assert.Null(selector.TrySelect(entityType.FindProperty("NullableUInt")!, entityType, out generator) ? generator : null);
+        Assert.Null(selector.TrySelect(entityType.FindProperty("NullableULong")!, entityType, out generator) ? generator : null);
+        Assert.Null(selector.TrySelect(entityType.FindProperty("NullableUShort")!, entityType, out generator) ? generator : null);
+        Assert.Null(selector.TrySelect(entityType.FindProperty("NullableSByte")!, entityType, out generator) ? generator : null);
 
-        Assert.Throws<NotSupportedException>(() => selector.Select(entityType.FindProperty("Decimal"), entityType));
-        Assert.Throws<NotSupportedException>(() => selector.Select(entityType.FindProperty("NullableDecimal"), entityType));
+        Assert.Null(selector.TrySelect(entityType.FindProperty("Decimal")!, entityType, out generator) ? generator : null);
+        Assert.Null(selector.TrySelect(entityType.FindProperty("NullableDecimal")!, entityType, out generator) ? generator : null);
 
-        Assert.Throws<NotSupportedException>(() => selector.Select(entityType.FindProperty("Float"), entityType));
-        Assert.Throws<NotSupportedException>(() => selector.Select(entityType.FindProperty("NullableFloat"), entityType));
+        Assert.Null(selector.TrySelect(entityType.FindProperty("Float")!, entityType, out generator) ? generator : null);
+        Assert.Null(selector.TrySelect(entityType.FindProperty("NullableFloat")!, entityType, out generator) ? generator : null);
 
-        Assert.Throws<NotSupportedException>(() => selector.Select(entityType.FindProperty("Double"), entityType));
-        Assert.Throws<NotSupportedException>(() => selector.Select(entityType.FindProperty("NullableDouble"), entityType));
+        Assert.Null(selector.TrySelect(entityType.FindProperty("Double")!, entityType, out generator) ? generator : null);
+        Assert.Null(selector.TrySelect(entityType.FindProperty("NullableDouble")!, entityType, out generator) ? generator : null);
 
-        Assert.Throws<NotSupportedException>(() => selector.Select(entityType.FindProperty("DateTime"), entityType));
-        Assert.Throws<NotSupportedException>(() => selector.Select(entityType.FindProperty("NullableDateTime"), entityType));
+        Assert.Null(selector.TrySelect(entityType.FindProperty("DateTime")!, entityType, out generator) ? generator : null);
+        Assert.Null(selector.TrySelect(entityType.FindProperty("NullableDateTime")!, entityType, out generator) ? generator : null);
 
-        Assert.Throws<NotSupportedException>(() => selector.Select(entityType.FindProperty("DateTimeOffset"), entityType));
-        Assert.Throws<NotSupportedException>(() => selector.Select(entityType.FindProperty("NullableDateTimeOffset"), entityType));
+        Assert.Null(selector.TrySelect(entityType.FindProperty("DateTimeOffset")!, entityType, out generator) ? generator : null);
+        Assert.Null(selector.TrySelect(entityType.FindProperty("NullableDateTimeOffset")!, entityType, out generator) ? generator : null);
 
-        Assert.IsType<StringValueGenerator>(selector.Select(entityType.FindProperty("String"), entityType));
+        Assert.IsType<StringValueGenerator>(selector.TrySelect(entityType.FindProperty("String")!, entityType, out generator) ? generator : null);
 
-        Assert.IsType<GuidValueGenerator>(selector.Select(entityType.FindProperty("Guid"), entityType));
-        Assert.IsType<GuidValueGenerator>(selector.Select(entityType.FindProperty("NullableGuid"), entityType));
+        Assert.IsType<GuidValueGenerator>(selector.TrySelect(entityType.FindProperty("Guid")!, entityType, out generator) ? generator : null);
+        Assert.IsType<GuidValueGenerator>(selector.TrySelect(entityType.FindProperty("NullableGuid")!, entityType, out generator) ? generator : null);
 
-        Assert.IsType<BinaryValueGenerator>(selector.Select(entityType.FindProperty("Binary"), entityType));
+        Assert.IsType<BinaryValueGenerator>(selector.TrySelect(entityType.FindProperty("Binary")!, entityType, out generator) ? generator : null);
     }
 
     [ConditionalFact]
@@ -71,7 +127,23 @@ public void Throws_for_unsupported_combinations()
 
         Assert.Equal(
             CoreStrings.NoValueGenerator("Random", "AnEntity", "char"),
+#pragma warning disable CS0618 // Type or member is obsolete
             Assert.Throws<NotSupportedException>(() => selector.Select(entityType.FindProperty("Random"), entityType)).Message);
+#pragma warning restore CS0618 // Type or member is obsolete
+    }
+
+    [ConditionalFact]
+    public void Returns_null_for_unsupported_combinations_with_Try_method()
+    {
+        var model = BuildModel();
+        var entityType = model.FindEntityType(typeof(AnEntity))!;
+
+        var contextServices = InMemoryTestHelpers.Instance.CreateContextServices(model);
+
+        var selector = contextServices.GetRequiredService<IValueGeneratorSelector>();
+
+        Assert.False(selector.TrySelect(entityType.FindProperty("Random")!, entityType, out var valueGenerator));
+        Assert.Null(valueGenerator);
     }
 
     private static IModel BuildModel(bool generateValues = true)
@@ -132,4 +204,25 @@ public override int Next(EntityEntry entry)
         public override bool GeneratesTemporaryValues
             => false;
     }
+
+    private static object CreateAndUseFactory(IProperty property, bool useTry = true)
+    {
+        var model = BuildModel();
+
+        var selector = InMemoryTestHelpers.Instance.CreateContextServices(model).GetRequiredService<IValueGeneratorSelector>();
+
+        ValueGenerator generator;
+        if (useTry)
+        {
+            selector.TrySelect(property, property.DeclaringType, out generator);
+        }
+        else
+        {
+#pragma warning disable CS0618 // Type or member is obsolete
+            generator = selector.Select(property, property.DeclaringType);
+#pragma warning restore CS0618 // Type or member is obsolete
+        }
+
+        return generator!.Next(null!);
+    }
 }
