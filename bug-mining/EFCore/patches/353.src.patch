diff --git a/src/EFCore/Metadata/Internal/InternalPropertyBuilder.cs b/src/EFCore/Metadata/Internal/InternalPropertyBuilder.cs
index bf4bb1ef13..63443cb2be 100644
--- a/src/EFCore/Metadata/Internal/InternalPropertyBuilder.cs
+++ b/src/EFCore/Metadata/Internal/InternalPropertyBuilder.cs
@@ -14,6 +14,9 @@ namespace Microsoft.EntityFrameworkCore.Metadata.Internal;
 public class InternalPropertyBuilder
     : InternalPropertyBaseBuilder<IConventionPropertyBuilder, Property>, IConventionPropertyBuilder
 {
+    internal static readonly bool UseOldBehavior32430 =
+    AppContext.TryGetSwitch("Microsoft.EntityFrameworkCore.Issue32430", out var enabled32430) && enabled32430;
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -496,7 +499,10 @@ public virtual bool CanSetAfterSave(PropertySaveBehavior? behavior, Configuratio
     {
         if (CanSetConversion(converter, configurationSource))
         {
-            Metadata.SetElementType(null, configurationSource);
+            if (converter != null || UseOldBehavior32430)
+            {
+                Metadata.SetElementType(null, configurationSource);
+            }
             Metadata.SetProviderClrType(null, configurationSource);
             Metadata.SetValueConverter(converter, configurationSource);
 
@@ -520,7 +526,8 @@ public virtual bool CanSetAfterSave(PropertySaveBehavior? behavior, Configuratio
                     && Metadata.CheckValueConverter(converter) == null)
                 || (Metadata[CoreAnnotationNames.ValueConverterType] == null
                     && (ValueConverter?)Metadata[CoreAnnotationNames.ValueConverter] == converter))
-            && configurationSource.Overrides(Metadata.GetProviderClrTypeConfigurationSource());
+            && configurationSource.Overrides(Metadata.GetProviderClrTypeConfigurationSource())
+            && (converter == null || CanSetElementType(null, configurationSource) || UseOldBehavior32430);
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
@@ -532,7 +539,10 @@ public virtual bool CanSetAfterSave(PropertySaveBehavior? behavior, Configuratio
     {
         if (CanSetConversion(providerClrType, configurationSource))
         {
-            Metadata.SetElementType(null, configurationSource);
+            if (providerClrType != null || UseOldBehavior32430)
+            {
+                Metadata.SetElementType(null, configurationSource);
+            }
             Metadata.SetValueConverter((ValueConverter?)null, configurationSource);
             Metadata.SetProviderClrType(providerClrType, configurationSource);
 
@@ -551,7 +561,8 @@ public virtual bool CanSetAfterSave(PropertySaveBehavior? behavior, Configuratio
     public virtual bool CanSetConversion(Type? providerClrType, ConfigurationSource? configurationSource)
         => (configurationSource.Overrides(Metadata.GetProviderClrTypeConfigurationSource())
                 || Metadata.GetProviderClrType() == providerClrType)
-            && configurationSource.Overrides(Metadata.GetValueConverterConfigurationSource());
+            && configurationSource.Overrides(Metadata.GetValueConverterConfigurationSource())
+            && (providerClrType == null || CanSetElementType(null, configurationSource) || UseOldBehavior32430);
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
@@ -566,7 +577,10 @@ public virtual bool CanSetConversion(Type? providerClrType, ConfigurationSource?
     {
         if (CanSetConverter(converterType, configurationSource))
         {
-            Metadata.SetElementType(null, configurationSource);
+            if (converterType != null || UseOldBehavior32430)
+            {
+                Metadata.SetElementType(null, configurationSource);
+            }
             Metadata.SetProviderClrType(null, configurationSource);
             Metadata.SetValueConverter(converterType, configurationSource);
 
@@ -586,9 +600,10 @@ public virtual bool CanSetConversion(Type? providerClrType, ConfigurationSource?
         [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicParameterlessConstructor)]
         Type? converterType,
         ConfigurationSource? configurationSource)
-        => configurationSource.Overrides(Metadata.GetValueConverterConfigurationSource())
+        => (configurationSource.Overrides(Metadata.GetValueConverterConfigurationSource())
             || (Metadata[CoreAnnotationNames.ValueConverter] == null
-                && (Type?)Metadata[CoreAnnotationNames.ValueConverterType] == converterType);
+                && (Type?)Metadata[CoreAnnotationNames.ValueConverterType] == converterType))
+            && (converterType == null || CanSetElementType(null, configurationSource) || UseOldBehavior32430);
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
@@ -783,7 +798,10 @@ public virtual bool CanSetProviderValueComparer(ValueComparer? comparer, Configu
         if (CanSetElementType(elementType, configurationSource))
         {
             Metadata.SetElementType(elementType, configurationSource);
-            Metadata.SetValueConverter((Type?)null, configurationSource);
+            if (elementType != null || UseOldBehavior32430)
+            {
+                Metadata.SetValueConverter((Type?)null, configurationSource);
+            }
             return new InternalElementTypeBuilder(Metadata.GetElementType()!, ModelBuilder);
         }
 
@@ -797,8 +815,9 @@ public virtual bool CanSetProviderValueComparer(ValueComparer? comparer, Configu
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
     public virtual bool CanSetElementType(Type? elementType, ConfigurationSource? configurationSource)
-        => configurationSource.Overrides(Metadata.GetElementTypeConfigurationSource())
-            && (elementType != Metadata.GetElementType()?.ClrType);
+        => (configurationSource.Overrides(Metadata.GetElementTypeConfigurationSource())
+            && (elementType == null || CanSetConversion((Type?)null, configurationSource) || UseOldBehavior32430))
+            || elementType == Metadata.GetElementType()?.ClrType;
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
diff --git a/test/EFCore.Relational.Specification.Tests/Query/JsonQueryAdHocTestBase.cs b/test/EFCore.Relational.Specification.Tests/Query/JsonQueryAdHocTestBase.cs
index c5c3dadfed..d3a61239eb 100644
--- a/test/EFCore.Relational.Specification.Tests/Query/JsonQueryAdHocTestBase.cs
+++ b/test/EFCore.Relational.Specification.Tests/Query/JsonQueryAdHocTestBase.cs
@@ -306,7 +306,7 @@ public virtual async Task Project_json_array_of_primitives_on_reference(bool asy
         }
     }
 
-    [ConditionalTheory]
+    [ConditionalTheory(Skip = "Issue #32611")]
     [MemberData(nameof(IsAsyncData))]
     public virtual async Task Project_json_array_of_primitives_on_collection(bool async)
     {
@@ -426,33 +426,10 @@ protected override void OnModelCreating(ModelBuilder modelBuilder)
         {
             modelBuilder.Entity<MyEntityArrayOfPrimitives>().Property(x => x.Id).ValueGeneratedNever();
             modelBuilder.Entity<MyEntityArrayOfPrimitives>().OwnsOne(
-                x => x.Reference, b =>
-                {
-                    b.ToJson();
-                    b.Property(x => x.IntArray).HasConversion(
-                        x => string.Join(" ", x),
-                        x => x.Split(" ", StringSplitOptions.None).Select(v => int.Parse(v)).ToArray(),
-                        new ValueComparer<int[]>(true));
-
-                    b.Property(x => x.ListOfString).HasConversion(
-                        x => string.Join(" ", x),
-                        x => x.Split(" ", StringSplitOptions.None).ToList(),
-                        new ValueComparer<List<string>>(true));
-                });
+                x => x.Reference, b => b.ToJson());
 
             modelBuilder.Entity<MyEntityArrayOfPrimitives>().OwnsMany(
-                x => x.Collection, b =>
-                {
-                    b.ToJson();
-                    b.Property(x => x.IntArray).HasConversion(
-                        x => string.Join(" ", x),
-                        x => x.Split(" ", StringSplitOptions.None).Select(v => int.Parse(v)).ToArray(),
-                        new ValueComparer<int[]>(true));
-                    b.Property(x => x.ListOfString).HasConversion(
-                        x => string.Join(" ", x),
-                        x => x.Split(" ", StringSplitOptions.None).ToList(),
-                        new ValueComparer<List<string>>(true));
-                });
+                x => x.Collection, b => b.ToJson());
         }
     }
 
diff --git a/test/EFCore.Tests/Metadata/Conventions/ConventionDispatcherTest.cs b/test/EFCore.Tests/Metadata/Conventions/ConventionDispatcherTest.cs
index 67f1fe3a87..8d12e6c54b 100644
--- a/test/EFCore.Tests/Metadata/Conventions/ConventionDispatcherTest.cs
+++ b/test/EFCore.Tests/Metadata/Conventions/ConventionDispatcherTest.cs
@@ -8,8 +8,6 @@ namespace Microsoft.EntityFrameworkCore.Metadata.Conventions;
 
 public class ConventionDispatcherTest
 {
-    // TODO: Use public API to add conventions, issue #214
-
     [ConditionalFact]
     public void Infinite_recursion_throws()
     {
@@ -3710,7 +3708,7 @@ public void OnPropertyElementTypeChanged_calls_conventions_in_order(bool useBuil
 
         if (useBuilder)
         {
-            Assert.Null(propertyBuilder.SetElementType(typeof(int), ConfigurationSource.Convention));
+            Assert.NotNull(propertyBuilder.SetElementType(typeof(int), ConfigurationSource.Convention));
             elementType = propertyBuilder.Metadata.GetElementType()!;
         }
         else
diff --git a/test/EFCore.Tests/ModelBuilding/NonRelationshipTestBase.cs b/test/EFCore.Tests/ModelBuilding/NonRelationshipTestBase.cs
index c021017411..21f67ef86f 100644
--- a/test/EFCore.Tests/ModelBuilding/NonRelationshipTestBase.cs
+++ b/test/EFCore.Tests/ModelBuilding/NonRelationshipTestBase.cs
@@ -3255,6 +3255,45 @@ public virtual void Element_types_can_have_unicode_set()
             Assert.False(entityType.FindProperty("Stranger")!.GetElementType()!.IsUnicode());
         }
 
+        [ConditionalFact]
+        public virtual void Conversion_on_base_property_prevents_primitive_collection()
+        {
+            var modelBuilder = CreateModelBuilder();
+            modelBuilder.Entity<DerivedCollectionQuarks>();
+            modelBuilder.Entity<CollectionQuarks>(b =>
+            {
+                b.Property(c => c.Down).HasConversion(gs => string.Join(',', gs!),
+                    s => new ObservableCollection<string>(s.Split(',', StringSplitOptions.RemoveEmptyEntries)));
+            });
+
+            var model = modelBuilder.FinalizeModel();
+
+            var property = model.FindEntityType(typeof(CollectionQuarks))!.FindProperty(nameof(CollectionQuarks.Down))!;
+            Assert.False(property.IsPrimitiveCollection);
+            Assert.NotNull(property.GetValueConverter());
+        }
+
+        [ConditionalFact]
+        public virtual void Conversion_on_base_property_prevents_primitive_collection_when_base_first()
+        {
+            var modelBuilder = CreateModelBuilder();
+            modelBuilder.Entity<CollectionQuarks>(b =>
+            {
+                b.Property(c => c.Down).HasConversion(gs => string.Join(',', gs!),
+                    s => new ObservableCollection<string>(s.Split(',', StringSplitOptions.RemoveEmptyEntries)));
+            });
+
+            var property = (IProperty)modelBuilder.Model.FindEntityType(typeof(CollectionQuarks))!.FindProperty(nameof(CollectionQuarks.Down))!;
+            Assert.False(property.IsPrimitiveCollection);
+
+            modelBuilder.Entity<DerivedCollectionQuarks>();
+
+            var model = modelBuilder.FinalizeModel();
+            property = model.FindEntityType(typeof(CollectionQuarks))!.FindProperty(nameof(CollectionQuarks.Down))!;
+            Assert.False(property.IsPrimitiveCollection);
+            Assert.NotNull(property.GetValueConverter());
+        }
+
         [ConditionalFact]
         public virtual void Element_types_can_have_provider_type_set()
         {
diff --git a/test/EFCore.Tests/ModelBuilding/OwnedTypesTestBase.cs b/test/EFCore.Tests/ModelBuilding/OwnedTypesTestBase.cs
index 7accdd4322..c4816b16b6 100644
--- a/test/EFCore.Tests/ModelBuilding/OwnedTypesTestBase.cs
+++ b/test/EFCore.Tests/ModelBuilding/OwnedTypesTestBase.cs
@@ -1652,6 +1652,7 @@ public virtual void Can_configure_owned_entity_and_property_of_same_type()
 
             var departmentIdProperty = departmentType.FindProperty(nameof(Department.Id));
             Assert.NotNull(departmentIdProperty);
+            Assert.NotNull(departmentIdProperty.GetValueConverter());
             Assert.NotNull(departmentNestedType);
             Assert.NotNull(officeNestedType);
 
diff --git a/test/EFCore.Tests/ModelBuilding/TestModel.cs b/test/EFCore.Tests/ModelBuilding/TestModel.cs
index 22b8c92b56..215ec576aa 100644
--- a/test/EFCore.Tests/ModelBuilding/TestModel.cs
+++ b/test/EFCore.Tests/ModelBuilding/TestModel.cs
@@ -340,6 +340,10 @@ public ObservableCollection<int> Up
 #pragma warning restore 67
     }
 
+    protected class DerivedCollectionQuarks : CollectionQuarks
+    {
+    }
+
     protected class Hob
     {
         public string? Id1 { get; set; }
