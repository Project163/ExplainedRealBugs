diff --git a/src/EFCore.Cosmos/Extensions/CosmosDbFunctionsExtensions.cs b/src/EFCore.Cosmos/Extensions/CosmosDbFunctionsExtensions.cs
index 1eb299ee90..88be60b654 100644
--- a/src/EFCore.Cosmos/Extensions/CosmosDbFunctionsExtensions.cs
+++ b/src/EFCore.Cosmos/Extensions/CosmosDbFunctionsExtensions.cs
@@ -1,7 +1,7 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-namespace Microsoft.EntityFrameworkCore.Cosmos.Extensions;
+namespace Microsoft.EntityFrameworkCore;
 
 /// <summary>
 ///     Provides CLR methods that get translated to database functions when used in LINQ to Entities queries.
@@ -99,17 +99,7 @@ public static double FullTextScore(this DbFunctions _, string property, params s
     public static double Rrf(this DbFunctions _, params double[] scores)
         => throw new InvalidOperationException(CoreStrings.FunctionOnClient(nameof(Rrf)));
 
-    /// <summary>
-    ///     Returns the distance between two vectors, using the distance function and data type defined using
-    ///     <see
-    ///         cref="CosmosPropertyBuilderExtensions.IsVectorProperty(Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder,Microsoft.Azure.Cosmos.DistanceFunction,int)" />
-    ///     .
-    /// </summary>
-    /// <param name="_">The <see cref="DbFunctions" /> instance.</param>
-    /// <param name="vector1">The first vector.</param>
-    /// <param name="vector2">The second vector.</param>
-    public static double VectorDistance(this DbFunctions _, ReadOnlyMemory<byte> vector1, ReadOnlyMemory<byte> vector2)
-        => throw new InvalidOperationException(CoreStrings.FunctionOnClient(nameof(VectorDistance)));
+    #region VectorDistance
 
     /// <summary>
     ///     Returns the distance between two vectors, given a distance function (aka similarity measure).
@@ -118,15 +108,17 @@ public static double VectorDistance(this DbFunctions _, ReadOnlyMemory<byte> vec
     /// <param name="vector1">The first vector.</param>
     /// <param name="vector2">The second vector.</param>
     /// <param name="useBruteForce">
-    ///     A <see langword="bool" /> specifying how the computed value is used in an ORDER BY
-    ///     expression. If <see langword="true" />, then brute force is used, otherwise any index defined on the vector
-    ///     property is leveraged.
+    ///     An optional boolean specifying how the computed value is used in an <c>ORDER BY</c> expression.
+    ///     If <see langword="true"/>, then brute force is used. A value of <see langword="false" /> uses any index defined on the vector
+    ///     property, if it exists. Default value is <see langword="false" />.
     /// </param>
+    /// <param name="options">An optional object used to specify options for the vector distance calculation.</param>
     public static double VectorDistance(
         this DbFunctions _,
-        ReadOnlyMemory<byte> vector1,
-        ReadOnlyMemory<byte> vector2,
-        [NotParameterized] bool useBruteForce)
+        ReadOnlyMemory<float> vector1,
+        ReadOnlyMemory<float> vector2,
+        [NotParameterized] bool? useBruteForce = null,
+        [NotParameterized] VectorDistanceOptions? options = null)
         => throw new InvalidOperationException(CoreStrings.FunctionOnClient(nameof(VectorDistance)));
 
     /// <summary>
@@ -135,30 +127,18 @@ public static double VectorDistance(this DbFunctions _, ReadOnlyMemory<byte> vec
     /// <param name="_">The <see cref="DbFunctions" /> instance.</param>
     /// <param name="vector1">The first vector.</param>
     /// <param name="vector2">The second vector.</param>
-    /// <param name="distanceFunction">The distance function to use.</param>
     /// <param name="useBruteForce">
-    ///     A <see langword="bool" /> specifying how the computed value is used in an ORDER BY
-    ///     expression. If <see langword="true" />, then brute force is used, otherwise any index defined on the vector
-    ///     property is leveraged.
+    ///     An optional boolean specifying how the computed value is used in an <c>ORDER BY</c> expression.
+    ///     If <see langword="true"/>, then brute force is used. A value of <see langword="false" /> uses any index defined on the vector
+    ///     property, if it exists. Default value is <see langword="false" />.
     /// </param>
+    /// <param name="options">An optional object used to specify options for the vector distance calculation.</param>
     public static double VectorDistance(
         this DbFunctions _,
         ReadOnlyMemory<byte> vector1,
         ReadOnlyMemory<byte> vector2,
-        [NotParameterized] bool useBruteForce,
-        [NotParameterized] DistanceFunction distanceFunction)
-        => throw new InvalidOperationException(CoreStrings.FunctionOnClient(nameof(VectorDistance)));
-
-    /// <summary>
-    ///     Returns the distance between two vectors, using the distance function and data type defined using
-    ///     <see
-    ///         cref="CosmosPropertyBuilderExtensions.IsVectorProperty(Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder,Microsoft.Azure.Cosmos.DistanceFunction,int)" />
-    ///     .
-    /// </summary>
-    /// <param name="_">The <see cref="DbFunctions" /> instance.</param>
-    /// <param name="vector1">The first vector.</param>
-    /// <param name="vector2">The second vector.</param>
-    public static double VectorDistance(this DbFunctions _, ReadOnlyMemory<sbyte> vector1, ReadOnlyMemory<sbyte> vector2)
+        [NotParameterized] bool? useBruteForce = null,
+        [NotParameterized] VectorDistanceOptions? options = null)
         => throw new InvalidOperationException(CoreStrings.FunctionOnClient(nameof(VectorDistance)));
 
     /// <summary>
@@ -168,84 +148,18 @@ public static double VectorDistance(this DbFunctions _, ReadOnlyMemory<sbyte> ve
     /// <param name="vector1">The first vector.</param>
     /// <param name="vector2">The second vector.</param>
     /// <param name="useBruteForce">
-    ///     A <see langword="bool" /> specifying how the computed value is used in an ORDER BY
-    ///     expression. If <see langword="true" />, then brute force is used, otherwise any index defined on the vector
-    ///     property is leveraged.
+    ///     An optional boolean specifying how the computed value is used in an <c>ORDER BY</c> expression.
+    ///     If <see langword="true"/>, then brute force is used. A value of <see langword="false" /> uses any index defined on the vector
+    ///     property, if it exists. Default value is <see langword="false" />.
     /// </param>
+    /// <param name="options">An optional object used to specify options for the vector distance calculation.</param>
     public static double VectorDistance(
         this DbFunctions _,
         ReadOnlyMemory<sbyte> vector1,
         ReadOnlyMemory<sbyte> vector2,
-        [NotParameterized] bool useBruteForce)
+        [NotParameterized] bool? useBruteForce = null,
+        [NotParameterized] VectorDistanceOptions? options = null)
         => throw new InvalidOperationException(CoreStrings.FunctionOnClient(nameof(VectorDistance)));
 
-    /// <summary>
-    ///     Returns the distance between two vectors, given a distance function (aka similarity measure).
-    /// </summary>
-    /// <param name="_">The <see cref="DbFunctions" /> instance.</param>
-    /// <param name="vector1">The first vector.</param>
-    /// <param name="vector2">The second vector.</param>
-    /// <param name="distanceFunction">The distance function to use.</param>
-    /// <param name="useBruteForce">
-    ///     A <see langword="bool" /> specifying how the computed value is used in an ORDER BY
-    ///     expression. If <see langword="true" />, then brute force is used, otherwise any index defined on the vector
-    ///     property is leveraged.
-    /// </param>
-    public static double VectorDistance(
-        this DbFunctions _,
-        ReadOnlyMemory<sbyte> vector1,
-        ReadOnlyMemory<sbyte> vector2,
-        [NotParameterized] bool useBruteForce,
-        [NotParameterized] DistanceFunction distanceFunction)
-        => throw new InvalidOperationException(CoreStrings.FunctionOnClient(nameof(VectorDistance)));
-
-    /// <summary>
-    ///     Returns the distance between two vectors, using the distance function and data type defined using
-    ///     <see
-    ///         cref="CosmosPropertyBuilderExtensions.IsVectorProperty(Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder,Microsoft.Azure.Cosmos.DistanceFunction,int)" />
-    ///     .
-    /// </summary>
-    /// <param name="_">The <see cref="DbFunctions" /> instance.</param>
-    /// <param name="vector1">The first vector.</param>
-    /// <param name="vector2">The second vector.</param>
-    public static double VectorDistance(this DbFunctions _, ReadOnlyMemory<float> vector1, ReadOnlyMemory<float> vector2)
-        => throw new InvalidOperationException(CoreStrings.FunctionOnClient(nameof(VectorDistance)));
-
-    /// <summary>
-    ///     Returns the distance between two vectors, given a distance function (aka similarity measure).
-    /// </summary>
-    /// <param name="_">The <see cref="DbFunctions" /> instance.</param>
-    /// <param name="vector1">The first vector.</param>
-    /// <param name="vector2">The second vector.</param>
-    /// <param name="useBruteForce">
-    ///     A <see langword="bool" /> specifying how the computed value is used in an ORDER BY
-    ///     expression. If <see langword="true" />, then brute force is used, otherwise any index defined on the vector
-    ///     property is leveraged.
-    /// </param>
-    public static double VectorDistance(
-        this DbFunctions _,
-        ReadOnlyMemory<float> vector1,
-        ReadOnlyMemory<float> vector2,
-        [NotParameterized] bool useBruteForce)
-        => throw new InvalidOperationException(CoreStrings.FunctionOnClient(nameof(VectorDistance)));
-
-    /// <summary>
-    ///     Returns the distance between two vectors, given a distance function (aka similarity measure).
-    /// </summary>
-    /// <param name="_">The <see cref="DbFunctions" /> instance.</param>
-    /// <param name="vector1">The first vector.</param>
-    /// <param name="vector2">The second vector.</param>
-    /// <param name="distanceFunction">The distance function to use.</param>
-    /// <param name="useBruteForce">
-    ///     A <see langword="bool" /> specifying how the computed value is used in an ORDER BY
-    ///     expression. If <see langword="true" />, then brute force is used, otherwise any index defined on the vector
-    ///     property is leveraged.
-    /// </param>
-    public static double VectorDistance(
-        this DbFunctions _,
-        ReadOnlyMemory<float> vector1,
-        ReadOnlyMemory<float> vector2,
-        [NotParameterized] bool useBruteForce,
-        [NotParameterized] DistanceFunction distanceFunction)
-        => throw new InvalidOperationException(CoreStrings.FunctionOnClient(nameof(VectorDistance)));
+    #endregion VectorDistance
 }
diff --git a/src/EFCore.Cosmos/Query/Internal/CosmosSqlTranslatingExpressionVisitor.cs b/src/EFCore.Cosmos/Query/Internal/CosmosSqlTranslatingExpressionVisitor.cs
index 241addf033..18583a1d26 100644
--- a/src/EFCore.Cosmos/Query/Internal/CosmosSqlTranslatingExpressionVisitor.cs
+++ b/src/EFCore.Cosmos/Query/Internal/CosmosSqlTranslatingExpressionVisitor.cs
@@ -1221,6 +1221,7 @@ private static bool CanEvaluate(Expression expression)
         => expression switch
         {
             ConstantExpression => true,
+            UnaryExpression e => CanEvaluate(e.Operand),
             NewExpression e => e.Arguments.All(CanEvaluate),
             NewArrayExpression e => e.Expressions.All(CanEvaluate),
             MemberInitExpression e => CanEvaluate(e.NewExpression)
diff --git a/src/EFCore.Cosmos/Query/Internal/Expressions/SelectExpression.cs b/src/EFCore.Cosmos/Query/Internal/Expressions/SelectExpression.cs
index 3820506189..6b11c765be 100644
--- a/src/EFCore.Cosmos/Query/Internal/Expressions/SelectExpression.cs
+++ b/src/EFCore.Cosmos/Query/Internal/Expressions/SelectExpression.cs
@@ -1,7 +1,6 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using Microsoft.EntityFrameworkCore.Cosmos.Extensions;
 using Microsoft.EntityFrameworkCore.Cosmos.Internal;
 using Microsoft.EntityFrameworkCore.Internal;
 
diff --git a/src/EFCore.Cosmos/Query/Internal/Translators/CosmosFullTextSearchTranslator.cs b/src/EFCore.Cosmos/Query/Internal/Translators/CosmosFullTextSearchTranslator.cs
index 0aecf93ac1..b1edf94d67 100644
--- a/src/EFCore.Cosmos/Query/Internal/Translators/CosmosFullTextSearchTranslator.cs
+++ b/src/EFCore.Cosmos/Query/Internal/Translators/CosmosFullTextSearchTranslator.cs
@@ -1,8 +1,6 @@
 ï»¿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using Microsoft.EntityFrameworkCore.Cosmos.Extensions;
-
 namespace Microsoft.EntityFrameworkCore.Cosmos.Query.Internal;
 
 /// <summary>
diff --git a/src/EFCore.Cosmos/Query/Internal/Translators/CosmosTypeCheckingTranslator.cs b/src/EFCore.Cosmos/Query/Internal/Translators/CosmosTypeCheckingTranslator.cs
index 84fabb881f..f53efbee3d 100644
--- a/src/EFCore.Cosmos/Query/Internal/Translators/CosmosTypeCheckingTranslator.cs
+++ b/src/EFCore.Cosmos/Query/Internal/Translators/CosmosTypeCheckingTranslator.cs
@@ -1,8 +1,6 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using Microsoft.EntityFrameworkCore.Cosmos.Extensions;
-
 // ReSharper disable once CheckNamespace
 namespace Microsoft.EntityFrameworkCore.Cosmos.Query.Internal;
 
diff --git a/src/EFCore.Cosmos/Query/Internal/Translators/CosmosVectorSearchTranslator.cs b/src/EFCore.Cosmos/Query/Internal/Translators/CosmosVectorSearchTranslator.cs
index d22d18d052..47fd91fd15 100644
--- a/src/EFCore.Cosmos/Query/Internal/Translators/CosmosVectorSearchTranslator.cs
+++ b/src/EFCore.Cosmos/Query/Internal/Translators/CosmosVectorSearchTranslator.cs
@@ -1,9 +1,8 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using Microsoft.EntityFrameworkCore.Cosmos.Extensions;
+using System.Text;
 using Microsoft.EntityFrameworkCore.Cosmos.Internal;
-using Microsoft.EntityFrameworkCore.Cosmos.Metadata.Internal;
 using Microsoft.EntityFrameworkCore.Cosmos.Storage.Internal;
 
 // ReSharper disable once CheckNamespace
@@ -36,51 +35,119 @@ public class CosmosVectorSearchTranslator(ISqlExpressionFactory sqlExpressionFac
             return null;
         }
 
-        var vectorMapping = arguments[1].TypeMapping as CosmosVectorTypeMapping
-            ?? arguments[2].TypeMapping as CosmosVectorTypeMapping
+        if (arguments is not [_, var vector1, var vector2, var useBruteForceExpression, var optionsExpression])
+        {
+            throw new UnreachableException();
+        }
+
+        if (useBruteForceExpression is not SqlConstantExpression { Value: var useBruteForceValue })
+        {
+            throw new InvalidOperationException(
+                CoreStrings.ArgumentNotConstant("useBruteForce", nameof(CosmosDbFunctionsExtensions.VectorDistance)));
+        }
+
+        if (optionsExpression is not SqlConstantExpression { Value: var optionsValue })
+        {
+            throw new InvalidOperationException(
+                CoreStrings.ArgumentNotConstant("options", nameof(CosmosDbFunctionsExtensions.VectorDistance)));
+        }
+
+        var options = (VectorDistanceOptions?)optionsValue;
+
+        var vectorMapping = vector1.TypeMapping as CosmosVectorTypeMapping
+            ?? vector2.TypeMapping as CosmosVectorTypeMapping
             ?? throw new InvalidOperationException(CosmosStrings.VectorSearchRequiresVector);
 
-        Check.DebugAssert(arguments.Count is 3 or 4 or 5, "Did you add a parameter?");
 
-        SqlConstantExpression bruteForce;
-        if (arguments.Count >= 4)
+        var vectorType = vectorMapping.VectorType;
+
+        List<Expression> newArguments = new()
         {
-            if (arguments[3] is not SqlConstantExpression { Value: bool })
-            {
-                throw new InvalidOperationException(
-                    CoreStrings.ArgumentNotConstant("useBruteForce", nameof(CosmosDbFunctionsExtensions.VectorDistance)));
-            }
+            sqlExpressionFactory.ApplyTypeMapping(vector1, vectorMapping),
+            sqlExpressionFactory.ApplyTypeMapping(vector2, vectorMapping),
+        };
 
-            bruteForce = (SqlConstantExpression)arguments[3];
-        }
-        else
+        if (useBruteForceValue is not null)
         {
-            bruteForce = (SqlConstantExpression)sqlExpressionFactory.Constant(false);
+            newArguments.Add(useBruteForceExpression);
         }
 
-        var vectorType = vectorMapping.VectorType;
-        if (arguments.Count == 5)
+        if (options is not null)
         {
-            if (arguments[4] is not SqlConstantExpression { Value: DistanceFunction distanceFunction })
+            // If the options are provided but not useBruteForce, we need to explicitly specify the default for the
+            // latter (false)
+            if (useBruteForceValue is null)
             {
-                throw new InvalidOperationException(
-                    CoreStrings.ArgumentNotConstant("distanceFunction", nameof(CosmosDbFunctionsExtensions.VectorDistance)));
+                newArguments.Add(sqlExpressionFactory.ApplyDefaultTypeMapping(new SqlConstantExpression(false, typeMapping: null)));
             }
 
-            vectorType = vectorType with { DistanceFunction = distanceFunction };
-        }
+            var optionsBuilder = new StringBuilder("{ ");
+
+            var requireComma = false;
+
+            if (options.DistanceFunction is DistanceFunction distanceFunction)
+            {
+                optionsBuilder
+                    .Append("'distanceFunction': '")
+                    .Append(distanceFunction.ToString().ToLower())
+                    .Append('\'');
 
-        var dataType = CosmosVectorType.CreateDefaultVectorDataType(vectorMapping.ClrType);
+                vectorType = vectorType with { DistanceFunction = distanceFunction };
+
+                requireComma = true;
+            }
+
+            if (options.DataType is not null)
+            {
+                if (requireComma)
+                {
+                    optionsBuilder.Append(", ");
+                }
+
+                optionsBuilder
+                    .Append("'dataType': '")
+                    .Append(options.DataType.ToLower())
+                    .Append('\'');
+
+                requireComma = true;
+            }
+
+            if (options.SearchListSizeMultiplier is not null)
+            {
+                if (requireComma)
+                {
+                    optionsBuilder.Append(", ");
+                }
+
+                optionsBuilder
+                    .Append("'searchListSizeMultiplier': ")
+                    .Append(options.SearchListSizeMultiplier.Value);
+
+                requireComma = true;
+            }
+
+            if (options.QuantizedVectorListMultiplier is not null)
+            {
+                if (requireComma)
+                {
+                    optionsBuilder.Append(", ");
+                }
+
+                optionsBuilder
+                    .Append("'quantizedVectorListMultiplier': ")
+                    .Append(options.QuantizedVectorListMultiplier.Value);
+            }
+
+            optionsBuilder.Append(" }");
+
+            var optionsString = optionsBuilder.ToString();
+
+            newArguments.Add(new FragmentExpression(optionsString));
+        }
 
         return sqlExpressionFactory.Function(
             "VectorDistance",
-            [
-                sqlExpressionFactory.ApplyTypeMapping(arguments[1], vectorMapping),
-                sqlExpressionFactory.ApplyTypeMapping(arguments[2], vectorMapping),
-                bruteForce,
-                new FragmentExpression(
-                    $"{{'distanceFunction':'{vectorType.DistanceFunction.ToString().ToLower()}', 'dataType':'{dataType.ToString().ToLower()}'}}")
-            ],
+            newArguments,
             typeof(double),
             typeMappingSource.FindMapping(typeof(double))!);
     }
diff --git a/src/EFCore.Cosmos/Query/VectorDistanceOptions.cs b/src/EFCore.Cosmos/Query/VectorDistanceOptions.cs
new file mode 100644
index 0000000000..60baf1d0a2
--- /dev/null
+++ b/src/EFCore.Cosmos/Query/VectorDistanceOptions.cs
@@ -0,0 +1,33 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+// ReSharper disable once CheckNamespace
+namespace Microsoft.EntityFrameworkCore;
+
+/// <summary>
+///     Options to be passed to <see cref="CosmosDbFunctionsExtensions.VectorDistance(DbFunctions, ReadOnlyMemory{float}, ReadOnlyMemory{float}, bool?, VectorDistanceOptions)" />
+/// </summary>
+public sealed class VectorDistanceOptions
+{
+    /// <summary>
+    ///     The metric used to compute distance/similarity.
+    /// </summary>
+    public DistanceFunction? DistanceFunction { get; set; }
+
+    /// <summary>
+    ///     The data type of the vectors. <c>float32</c>, <c>int8</c>, <c>uint8</c> values. Default value is <c>float32</c>.
+    /// </summary>
+    public string? DataType { get; set; }
+
+    /// <summary>
+    ///     An integer specifying the size of the search list when conducting a vector search on the DiskANN index.
+    ///     Increasing this may improve accuracy at the expense of RU cost and latency. Min=1, Default=10, Max=100.
+    /// </summary>
+    public int? SearchListSizeMultiplier { get; set; }
+
+    /// <summary>
+    ///     An integer specifying the size of the search list when conducting a vector search on the quantizedFlat index.
+    ///     Increasing this may improve accuracy at the expense of RU cost and latency. Min=1, Default=5, Max=100.
+    /// </summary>
+    public int? QuantizedVectorListMultiplier { get; set; }
+}
diff --git a/src/EFCore.Relational/Query/RelationalSqlTranslatingExpressionVisitor.cs b/src/EFCore.Relational/Query/RelationalSqlTranslatingExpressionVisitor.cs
index 57e1d26508..6b44c7c678 100644
--- a/src/EFCore.Relational/Query/RelationalSqlTranslatingExpressionVisitor.cs
+++ b/src/EFCore.Relational/Query/RelationalSqlTranslatingExpressionVisitor.cs
@@ -1680,6 +1680,7 @@ private static bool CanEvaluate(Expression expression)
         => expression switch
         {
             ConstantExpression => true,
+            UnaryExpression e => CanEvaluate(e.Operand),
             NewExpression e => e.Arguments.All(CanEvaluate),
             NewArrayExpression e => e.Expressions.All(CanEvaluate),
             MemberInitExpression e => CanEvaluate(e.NewExpression)
diff --git a/test/EFCore.Cosmos.FunctionalTests/FullTextSearchCosmosTest.cs b/test/EFCore.Cosmos.FunctionalTests/FullTextSearchCosmosTest.cs
index 878b22f747..e8cd3d854f 100644
--- a/test/EFCore.Cosmos.FunctionalTests/FullTextSearchCosmosTest.cs
+++ b/test/EFCore.Cosmos.FunctionalTests/FullTextSearchCosmosTest.cs
@@ -2,7 +2,6 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using Microsoft.Azure.Cosmos;
-using Microsoft.EntityFrameworkCore.Cosmos.Extensions;
 using Microsoft.EntityFrameworkCore.Cosmos.Internal;
 
 namespace Microsoft.EntityFrameworkCore;
diff --git a/test/EFCore.Cosmos.FunctionalTests/HybridSearchCosmosTest.cs b/test/EFCore.Cosmos.FunctionalTests/HybridSearchCosmosTest.cs
index a813c7ca81..8ecec2fd08 100644
--- a/test/EFCore.Cosmos.FunctionalTests/HybridSearchCosmosTest.cs
+++ b/test/EFCore.Cosmos.FunctionalTests/HybridSearchCosmosTest.cs
@@ -2,7 +2,6 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using Microsoft.Azure.Cosmos;
-using Microsoft.EntityFrameworkCore.Cosmos.Extensions;
 
 namespace Microsoft.EntityFrameworkCore;
 
diff --git a/test/EFCore.Cosmos.FunctionalTests/Query/PrimitiveCollectionsQueryCosmosTest.cs b/test/EFCore.Cosmos.FunctionalTests/Query/PrimitiveCollectionsQueryCosmosTest.cs
index b57c27b9de..5cc00ae89a 100644
--- a/test/EFCore.Cosmos.FunctionalTests/Query/PrimitiveCollectionsQueryCosmosTest.cs
+++ b/test/EFCore.Cosmos.FunctionalTests/Query/PrimitiveCollectionsQueryCosmosTest.cs
@@ -4,7 +4,6 @@
 using System.Net;
 using Microsoft.Azure.Cosmos;
 using Microsoft.EntityFrameworkCore.Cosmos.Diagnostics.Internal;
-using Microsoft.EntityFrameworkCore.Cosmos.Extensions;
 using Microsoft.EntityFrameworkCore.Cosmos.Internal;
 using Xunit.Sdk;
 
diff --git a/test/EFCore.Cosmos.FunctionalTests/VectorSearchCosmosTest.cs b/test/EFCore.Cosmos.FunctionalTests/Query/Translations/VectorSearchTranslationsCosmosTest.cs
similarity index 79%
rename from test/EFCore.Cosmos.FunctionalTests/VectorSearchCosmosTest.cs
rename to test/EFCore.Cosmos.FunctionalTests/Query/Translations/VectorSearchTranslationsCosmosTest.cs
index e361439e47..ac59cca6cd 100644
--- a/test/EFCore.Cosmos.FunctionalTests/VectorSearchCosmosTest.cs
+++ b/test/EFCore.Cosmos.FunctionalTests/Query/Translations/VectorSearchTranslationsCosmosTest.cs
@@ -2,14 +2,13 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using Microsoft.Azure.Cosmos;
-using Microsoft.EntityFrameworkCore.Cosmos.Extensions;
 using Microsoft.EntityFrameworkCore.Cosmos.Internal;
 
-namespace Microsoft.EntityFrameworkCore;
+namespace Microsoft.EntityFrameworkCore.Query.Translations;
 
-public class VectorSearchCosmosTest : IClassFixture<VectorSearchCosmosTest.VectorSearchFixture>
+public class VectorSearchTranslationsCosmosTest : IClassFixture<VectorSearchTranslationsCosmosTest.VectorSearchFixture>
 {
-    public VectorSearchCosmosTest(VectorSearchFixture fixture, ITestOutputHelper testOutputHelper)
+    public VectorSearchTranslationsCosmosTest(VectorSearchFixture fixture, ITestOutputHelper testOutputHelper)
     {
         Fixture = fixture;
         _testOutputHelper = testOutputHelper;
@@ -21,37 +20,37 @@ public VectorSearchCosmosTest(VectorSearchFixture fixture, ITestOutputHelper tes
     private readonly ITestOutputHelper _testOutputHelper;
 
     [ConditionalFact]
-    public virtual async Task Query_for_vector_distance_sbytes()
+    public virtual async Task OrderBy_VectorDistance_singles_memory()
     {
         await using var context = CreateContext();
-        var inputVector = new ReadOnlyMemory<sbyte>([2, -1, 4, 3, 5, -2, 5, -7, 3, 1]);
+        var inputVector = new[] { 0.33f, -0.52f, 0.45f, -0.67f, 0.89f, -0.34f, 0.86f, -0.78f };
 
         var booksFromStore = await context
             .Set<Book>()
-            .Select(e => EF.Functions.VectorDistance(e.SBytes, inputVector))
+            .OrderBy(e => EF.Functions.VectorDistance(e.SinglesArray, inputVector))
             .ToListAsync();
 
         Assert.Equal(3, booksFromStore.Count);
-        Assert.All(booksFromStore, s => Assert.NotEqual(0.0, s));
-
         AssertSql(
             """
-@inputVector='[2,-1,4,3,5,-2,5,-7,3,1]'
+@p='[0.33,-0.52,0.45,-0.67,0.89,-0.34,0.86,-0.78]'
 
-SELECT VALUE VectorDistance(c["SBytes"], @inputVector, false, {'distanceFunction':'dotproduct', 'dataType':'int8'})
+SELECT VALUE c
 FROM root c
+ORDER BY VectorDistance(c["SinglesArray"], @p)
 """);
     }
 
     [ConditionalFact]
-    public virtual async Task Query_for_vector_distance_bytes()
+    public virtual async Task OrderBy_VectorDistance_singles_array()
     {
         await using var context = CreateContext();
-        var inputVector = new ReadOnlyMemory<byte>([2, 1, 4, 3, 5, 2, 5, 7, 3, 1]);
+        var inputVector = new[] { 0.33f, -0.52f, 0.45f, -0.67f, 0.89f, -0.34f, 0.86f, -0.78f, 0.86f, -0.78f };
 
         var booksFromStore = await context
             .Set<Book>()
-            .Select(e => EF.Functions.VectorDistance(e.Bytes, inputVector))
+            .Select(
+                e => EF.Functions.VectorDistance(e.SinglesArray, inputVector, useBruteForce: false, new() { DistanceFunction = DistanceFunction.DotProduct }))
             .ToListAsync();
 
         Assert.Equal(3, booksFromStore.Count);
@@ -59,193 +58,193 @@ public virtual async Task Query_for_vector_distance_bytes()
 
         AssertSql(
             """
-@inputVector='[2,1,4,3,5,2,5,7,3,1]'
+@p='[0.33,-0.52,0.45,-0.67,0.89,-0.34,0.86,-0.78,0.86,-0.78]'
 
-SELECT VALUE VectorDistance(c["Bytes"], @inputVector, false, {'distanceFunction':'cosine', 'dataType':'uint8'})
+SELECT VALUE VectorDistance(c["SinglesArray"], @p, false, { 'distanceFunction': 'dotproduct' })
 FROM root c
 """);
     }
 
     [ConditionalFact]
-    public virtual async Task Query_for_vector_distance_singles()
+    public virtual async Task OrderBy_VectorDistance_bytes_memory()
     {
         await using var context = CreateContext();
-        var inputVector = new ReadOnlyMemory<float>([0.33f, -0.52f, 0.45f, -0.67f, 0.89f, -0.34f, 0.86f, -0.78f, 0.86f, -0.78f]);
+        var inputVector = new byte[] { 2, 1, 4, 6, 5, 2, 5, 7, 3, 1 };
 
         var booksFromStore = await context
             .Set<Book>()
-            .Select(
-                e => EF.Functions.VectorDistance(e.OwnedReference.NestedOwned.NestedSingles, inputVector, false, DistanceFunction.DotProduct))
+            .OrderBy(e => EF.Functions.VectorDistance(e.Bytes, inputVector))
             .ToListAsync();
 
         Assert.Equal(3, booksFromStore.Count);
-        Assert.All(booksFromStore, s => Assert.NotEqual(0.0, s));
-
         AssertSql(
-"""
-@inputVector='[0.33,-0.52,0.45,-0.67,0.89,-0.34,0.86,-0.78,0.86,-0.78]'
+            """
+@p='[2,1,4,6,5,2,5,7,3,1]'
 
-SELECT VALUE VectorDistance(c["OwnedReference"]["NestedOwned"]["NestedSingles"], @inputVector, false, {'distanceFunction':'dotproduct', 'dataType':'float32'})
+SELECT VALUE c
 FROM root c
+ORDER BY VectorDistance(c["Bytes"], @p)
 """);
     }
 
     [ConditionalFact]
-    public virtual async Task Query_for_vector_distance_bytes_array()
+    public virtual async Task OrderBy_VectorDistance_bytes_array()
     {
         await using var context = CreateContext();
-        var inputVector = new byte[] { 2, 1, 4, 3, 5, 2, 5, 7, 3, 1 };
+        var inputVector = new byte[] { 2, 1, 4, 6, 5, 2, 5, 7, 3, 1 };
 
         var booksFromStore = await context
             .Set<Book>()
-            .Select(e => EF.Functions.VectorDistance(e.BytesArray, inputVector))
+            .OrderBy(e => EF.Functions.VectorDistance(e.BytesArray, inputVector))
             .ToListAsync();
 
         Assert.Equal(3, booksFromStore.Count);
-        Assert.All(booksFromStore, s => Assert.NotEqual(0.0, s));
-
         AssertSql(
             """
-@p='[2,1,4,3,5,2,5,7,3,1]'
+@p='[2,1,4,6,5,2,5,7,3,1]'
 
-SELECT VALUE VectorDistance(c["BytesArray"], @p, false, {'distanceFunction':'cosine', 'dataType':'uint8'})
+SELECT VALUE c
 FROM root c
+ORDER BY VectorDistance(c["BytesArray"], @p)
 """);
     }
 
     [ConditionalFact]
-    public virtual async Task Query_for_vector_distance_singles_array()
+    public virtual async Task OrderBy_VectorDistance_sbyte()
     {
         await using var context = CreateContext();
-        var inputVector = new[] { 0.33f, -0.52f, 0.45f, -0.67f, 0.89f, -0.34f, 0.86f, -0.78f, 0.86f, -0.78f };
+        var inputVector = new sbyte[] { 2, 1, 4, 6, 5, 2, 5, 7, 3, 1 };
 
         var booksFromStore = await context
             .Set<Book>()
-            .Select(
-                e => EF.Functions.VectorDistance(e.SinglesArray, inputVector, false, DistanceFunction.DotProduct))
+            .OrderBy(e => EF.Functions.VectorDistance(e.SBytes, inputVector))
             .ToListAsync();
 
         Assert.Equal(3, booksFromStore.Count);
-        Assert.All(booksFromStore, s => Assert.NotEqual(0.0, s));
 
         AssertSql(
             """
-@p='[0.33,-0.52,0.45,-0.67,0.89,-0.34,0.86,-0.78,0.86,-0.78]'
+@p='[2,1,4,6,5,2,5,7,3,1]'
 
-SELECT VALUE VectorDistance(c["SinglesArray"], @p, false, {'distanceFunction':'dotproduct', 'dataType':'float32'})
+SELECT VALUE c
 FROM root c
+ORDER BY VectorDistance(c["SBytes"], @p)
 """);
     }
 
+    #region Brute force and options
+
     [ConditionalFact]
-    public virtual async Task Vector_distance_sbytes_in_OrderBy()
+    public virtual async Task VectorDistance_with_brute_force_true()
     {
         await using var context = CreateContext();
-        var inputVector = new sbyte[] { 2, 1, 4, 6, 5, 2, 5, 7, 3, 1 };
+        var inputVector = new[] { 0.33f, -0.52f, 0.45f, -0.67f, 0.89f, -0.34f, 0.86f, -0.78f };
 
         var booksFromStore = await context
             .Set<Book>()
-            .OrderBy(e => EF.Functions.VectorDistance(e.SBytes, inputVector, false, DistanceFunction.DotProduct))
+            .OrderBy(e => EF.Functions.VectorDistance(e.SinglesArray, inputVector, useBruteForce: true))
             .ToListAsync();
 
         Assert.Equal(3, booksFromStore.Count);
-
         AssertSql(
             """
-@p='[2,1,4,6,5,2,5,7,3,1]'
+@p='[0.33,-0.52,0.45,-0.67,0.89,-0.34,0.86,-0.78]'
 
 SELECT VALUE c
 FROM root c
-ORDER BY VectorDistance(c["SBytes"], @p, false, {'distanceFunction':'dotproduct', 'dataType':'int8'})
+ORDER BY VectorDistance(c["SinglesArray"], @p, true)
 """);
     }
 
     [ConditionalFact]
-    public virtual async Task Vector_distance_bytes_in_OrderBy()
+    public virtual async Task VectorDistance_with_brute_force_and_distance_function()
     {
         await using var context = CreateContext();
-        var inputVector = new byte[] { 2, 1, 4, 6, 5, 2, 5, 7, 3, 1 };
+        var inputVector = new[] { 0.33f, -0.52f, 0.45f, -0.67f, 0.89f, -0.34f, 0.86f, -0.78f };
 
         var booksFromStore = await context
             .Set<Book>()
-            .OrderBy(e => EF.Functions.VectorDistance(e.Bytes, inputVector))
+            .OrderBy(e => EF.Functions.VectorDistance(e.SinglesArray, inputVector, useBruteForce: true, new() { DistanceFunction = DistanceFunction.DotProduct }))
             .ToListAsync();
 
         Assert.Equal(3, booksFromStore.Count);
         AssertSql(
             """
-@p='[2,1,4,6,5,2,5,7,3,1]'
+@p='[0.33,-0.52,0.45,-0.67,0.89,-0.34,0.86,-0.78]'
 
 SELECT VALUE c
 FROM root c
-ORDER BY VectorDistance(c["Bytes"], @p, false, {'distanceFunction':'cosine', 'dataType':'uint8'})
+ORDER BY VectorDistance(c["SinglesArray"], @p, true, { 'distanceFunction': 'dotproduct' })
 """);
     }
 
     [ConditionalFact]
-    public virtual async Task Vector_distance_singles_in_OrderBy()
+    public virtual async Task VectorDistance_with_distance_function_and_brute_force_null()
     {
         await using var context = CreateContext();
         var inputVector = new[] { 0.33f, -0.52f, 0.45f, -0.67f, 0.89f, -0.34f, 0.86f, -0.78f };
 
         var booksFromStore = await context
             .Set<Book>()
-            .OrderBy(e => EF.Functions.VectorDistance(e.OwnedReference.NestedOwned.NestedSingles, inputVector))
+            .OrderBy(e => EF.Functions.VectorDistance(e.SinglesArray, inputVector, useBruteForce: null, new() { DistanceFunction = DistanceFunction.DotProduct }))
             .ToListAsync();
 
         Assert.Equal(3, booksFromStore.Count);
-
         AssertSql(
-"""
+            """
 @p='[0.33,-0.52,0.45,-0.67,0.89,-0.34,0.86,-0.78]'
 
 SELECT VALUE c
 FROM root c
-ORDER BY VectorDistance(c["OwnedReference"]["NestedOwned"]["NestedSingles"], @p, false, {'distanceFunction':'cosine', 'dataType':'float32'})
+ORDER BY VectorDistance(c["SinglesArray"], @p, false, { 'distanceFunction': 'dotproduct' })
 """);
     }
 
     [ConditionalFact]
-    public virtual async Task Vector_distance_bytes_array_in_OrderBy()
+    public virtual async Task VectorDistance_with_data_type_and_distance_function()
     {
         await using var context = CreateContext();
-        var inputVector = new byte[] { 2, 1, 4, 6, 5, 2, 5, 7, 3, 1 };
+        var inputVector = new[] { 0.33f, -0.52f, 0.45f, -0.67f, 0.89f, -0.34f, 0.86f, -0.78f };
 
         var booksFromStore = await context
             .Set<Book>()
-            .OrderBy(e => EF.Functions.VectorDistance(e.BytesArray, inputVector))
+            .OrderBy(e => EF.Functions.VectorDistance(e.SinglesArray, inputVector, useBruteForce: false, new() { DataType = "float32", DistanceFunction = DistanceFunction.DotProduct }))
             .ToListAsync();
 
         Assert.Equal(3, booksFromStore.Count);
         AssertSql(
             """
-@p='[2,1,4,6,5,2,5,7,3,1]'
+@p='[0.33,-0.52,0.45,-0.67,0.89,-0.34,0.86,-0.78]'
 
 SELECT VALUE c
 FROM root c
-ORDER BY VectorDistance(c["BytesArray"], @p, false, {'distanceFunction':'cosine', 'dataType':'uint8'})
+ORDER BY VectorDistance(c["SinglesArray"], @p, false, { 'distanceFunction': 'dotproduct', 'dataType': 'float32' })
 """);
     }
 
+    #endregion Brute force and options
+
     [ConditionalFact]
-    public virtual async Task Vector_distance_singles_array_in_OrderBy()
+    public virtual async Task Select_VectorDistance()
     {
         await using var context = CreateContext();
-        var inputVector = new[] { 0.33f, -0.52f, 0.45f, -0.67f, 0.89f, -0.34f, 0.86f, -0.78f };
+        var inputVector = new ReadOnlyMemory<float>([0.33f, -0.52f, 0.45f, -0.67f, 0.89f, -0.34f, 0.86f, -0.78f, 0.86f, -0.78f]);
 
         var booksFromStore = await context
             .Set<Book>()
-            .OrderBy(e => EF.Functions.VectorDistance(e.SinglesArray, inputVector))
+            .Select(
+                e => EF.Functions.VectorDistance(e.OwnedReference.NestedOwned.NestedSingles, inputVector))
             .ToListAsync();
 
         Assert.Equal(3, booksFromStore.Count);
+        Assert.All(booksFromStore, s => Assert.NotEqual(0.0, s));
+
         AssertSql(
-            """
-@p='[0.33,-0.52,0.45,-0.67,0.89,-0.34,0.86,-0.78]'
+"""
+@inputVector='[0.33,-0.52,0.45,-0.67,0.89,-0.34,0.86,-0.78,0.86,-0.78]'
 
-SELECT VALUE c
+SELECT VALUE VectorDistance(c["OwnedReference"]["NestedOwned"]["NestedSingles"], @inputVector)
 FROM root c
-ORDER BY VectorDistance(c["SinglesArray"], @p, false, {'distanceFunction':'cosine', 'dataType':'float32'})
 """);
     }
 
@@ -272,7 +271,7 @@ public virtual async Task RRF_with_two_Vector_distance_functions_in_OrderBy()
 
 SELECT VALUE c
 FROM root c
-ORDER BY RANK RRF(VectorDistance(c["BytesArray"], @p, false, {'distanceFunction':'cosine', 'dataType':'uint8'}), VectorDistance(c["SinglesArray"], @p0, false, {'distanceFunction':'cosine', 'dataType':'float32'}))
+ORDER BY RANK RRF(VectorDistance(c["BytesArray"], @p), VectorDistance(c["SinglesArray"], @p0))
 """);
     }
 
@@ -323,14 +322,12 @@ public virtual async Task VectorDistance_throws_when_used_with_non_const_args()
                     .OrderBy(e => EF.Functions.VectorDistance(e.OwnedReference.NestedOwned.NestedSingles, inputVector, e.IsPublished))
                     .ToListAsync())).Message);
 
-        Assert.Equal(
-            CoreStrings.ArgumentNotConstant("distanceFunction", nameof(CosmosDbFunctionsExtensions.VectorDistance)),
-            (await Assert.ThrowsAsync<InvalidOperationException>(
-                async () => await context
-                    .Set<Book>()
-                    .OrderBy(
-                        e => EF.Functions.VectorDistance(e.OwnedReference.NestedOwned.NestedSingles, inputVector, false, e.DistanceFunction))
-                    .ToListAsync())).Message);
+        await Assert.ThrowsAsync<InvalidOperationException>(
+            async () => await context
+                .Set<Book>()
+                .OrderBy(
+                    e => EF.Functions.VectorDistance(e.OwnedReference.NestedOwned.NestedSingles, inputVector, useBruteForce: false, new() { DistanceFunction = e.DistanceFunction }))
+                .ToListAsync());
     }
 
     private class Book
