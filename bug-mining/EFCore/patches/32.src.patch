diff --git a/src/EFCore.Design/Scaffolding/Internal/CSharpRuntimeModelCodeGenerator.cs b/src/EFCore.Design/Scaffolding/Internal/CSharpRuntimeModelCodeGenerator.cs
index 557407a0b6..7110d784db 100644
--- a/src/EFCore.Design/Scaffolding/Internal/CSharpRuntimeModelCodeGenerator.cs
+++ b/src/EFCore.Design/Scaffolding/Internal/CSharpRuntimeModelCodeGenerator.cs
@@ -678,6 +678,15 @@ private void Create(IEntityType entityType, CSharpRuntimeAnnotationCodeGenerator
                     property.DeclaringEntityType.ShortName(), property.Name, nameof(PropertyBuilder.HasConversion)));
         }
 
+        var providerValueComparerType = (Type?)property[CoreAnnotationNames.ProviderValueComparerType];
+        if (providerValueComparerType == null
+            && property[CoreAnnotationNames.ProviderValueComparer] != null)
+        {
+            throw new InvalidOperationException(
+                DesignStrings.CompiledModelValueComparer(
+                    property.DeclaringEntityType.ShortName(), property.Name, nameof(PropertyBuilder.HasConversion)));
+        }
+
         var valueConverterType = (Type?)property[CoreAnnotationNames.ValueConverterType];
         if (valueConverterType == null
             && property.GetValueConverter() != null)
@@ -809,6 +818,16 @@ private void Create(IEntityType entityType, CSharpRuntimeAnnotationCodeGenerator
                 .Append("()");
         }
 
+        if (providerValueComparerType != null)
+        {
+            AddNamespace(providerValueComparerType, parameters.Namespaces);
+
+            mainBuilder.AppendLine(",")
+                .Append("providerValueComparer: new ")
+                .Append(_code.Reference(providerValueComparerType))
+                .Append("()");
+        }
+
         mainBuilder
             .AppendLine(");")
             .DecrementIndent();
diff --git a/src/EFCore.Relational/Infrastructure/RelationalModelValidator.cs b/src/EFCore.Relational/Infrastructure/RelationalModelValidator.cs
index a284accdf5..8711ffdbf8 100644
--- a/src/EFCore.Relational/Infrastructure/RelationalModelValidator.cs
+++ b/src/EFCore.Relational/Infrastructure/RelationalModelValidator.cs
@@ -1318,7 +1318,7 @@ private static bool IsIdentifyingPrincipal(IEntityType dependentEntityType, IEnt
             var mappingStrategy = (string?)entityType[RelationalAnnotationNames.MappingStrategy];
             if (mappingStrategy != null)
             {
-                ValidateMappingStrategy(mappingStrategy, entityType);
+                ValidateMappingStrategy(entityType, mappingStrategy);
                 var storeObject = entityType.GetSchemaQualifiedTableName()
                     ?? entityType.GetSchemaQualifiedViewName()
                     ?? entityType.GetFunctionName();
@@ -1389,9 +1389,9 @@ private static bool IsIdentifyingPrincipal(IEntityType dependentEntityType, IEnt
     /// <summary>
     ///     Validates that the given mapping strategy is supported
     /// </summary>
-    /// <param name="mappingStrategy">The mapping strategy.</param>
     /// <param name="entityType">The entity type.</param>
-    protected virtual void ValidateMappingStrategy(string? mappingStrategy, IEntityType entityType)
+    /// <param name="mappingStrategy">The mapping strategy.</param>
+    protected virtual void ValidateMappingStrategy(IEntityType entityType, string? mappingStrategy)
     {
         switch (mappingStrategy)
         {
diff --git a/src/EFCore.Relational/Metadata/IColumn.cs b/src/EFCore.Relational/Metadata/IColumn.cs
index 4620f09db9..99685f72dc 100644
--- a/src/EFCore.Relational/Metadata/IColumn.cs
+++ b/src/EFCore.Relational/Metadata/IColumn.cs
@@ -147,6 +147,14 @@ public virtual bool TryGetDefaultValue(out object? defaultValue)
         => PropertyMappings.First().Property
             .GetCollation(StoreObjectIdentifier.Table(Table.Name, Table.Schema));
 
+    /// <summary>
+    ///     Gets the <see cref="ValueComparer" /> for this column.
+    /// </summary>
+    /// <returns>The comparer.</returns>
+    public virtual ValueComparer ProviderValueComparer
+        => PropertyMappings.First().Property
+            .GetProviderValueComparer();
+
     /// <summary>
     ///     Returns the property mapping for the given entity type.
     /// </summary>
diff --git a/src/EFCore.Relational/Migrations/Internal/MigrationsModelDiffer.cs b/src/EFCore.Relational/Migrations/Internal/MigrationsModelDiffer.cs
index cf9a4c33d1..941add0b3a 100644
--- a/src/EFCore.Relational/Migrations/Internal/MigrationsModelDiffer.cs
+++ b/src/EFCore.Relational/Migrations/Internal/MigrationsModelDiffer.cs
@@ -2062,7 +2062,7 @@ private void AddSeedData(IEntityType entityType, Dictionary<ITable, IRowIdentity
 
                     var sourceValue = sourceColumnModification.OriginalValue;
                     var targetValue = targetColumnModification.Value;
-                    var comparer = targetMapping.TypeMapping.ProviderValueComparer;
+                    var comparer = targetColumn.ProviderValueComparer;
                     if (sourceColumn.ProviderClrType == targetColumn.ProviderClrType
                         && comparer.Equals(sourceValue, targetValue))
                     {
diff --git a/src/EFCore.Relational/Storage/RelationalGeometryTypeMapping.cs b/src/EFCore.Relational/Storage/RelationalGeometryTypeMapping.cs
index 8bd9dd44c5..f145f044a2 100644
--- a/src/EFCore.Relational/Storage/RelationalGeometryTypeMapping.cs
+++ b/src/EFCore.Relational/Storage/RelationalGeometryTypeMapping.cs
@@ -27,7 +27,6 @@ public abstract class RelationalGeometryTypeMapping<TGeometry, TProvider> : Rela
         : base(CreateRelationalTypeMappingParameters(storeType))
     {
         SpatialConverter = converter;
-        SetProviderValueComparer();
     }
 
     /// <summary>
@@ -38,25 +37,19 @@ public abstract class RelationalGeometryTypeMapping<TGeometry, TProvider> : Rela
     protected RelationalGeometryTypeMapping(
         RelationalTypeMappingParameters parameters,
         ValueConverter<TGeometry, TProvider>? converter)
-        : base(parameters)
+        : base(parameters.WithCoreParameters(parameters.CoreParameters with
+            {
+                ProviderValueComparer = parameters.CoreParameters.ProviderValueComparer
+                    ?? CreateProviderValueComparer(parameters.CoreParameters.Converter?.ProviderClrType ?? parameters.CoreParameters.ClrType)
+            }))
     {
         SpatialConverter = converter;
-        SetProviderValueComparer();
     }
 
-    private void SetProviderValueComparer()
-    {
-        var providerType = Converter?.ProviderClrType ?? ClrType;
-        if (providerType.IsAssignableTo(typeof(TGeometry)))
-        {
-            ProviderValueComparer = (ValueComparer)Activator.CreateInstance(typeof(GeometryValueComparer<>).MakeGenericType(providerType))!;
-        }
-    }
-
-    /// <summary>
-    ///     The underlying Geometry converter.
-    /// </summary>
-    protected virtual ValueConverter<TGeometry, TProvider>? SpatialConverter { get; }
+    private static ValueComparer? CreateProviderValueComparer(Type providerType)
+        => providerType.IsAssignableTo(typeof(TGeometry))
+            ? (ValueComparer)Activator.CreateInstance(typeof(GeometryValueComparer<>).MakeGenericType(providerType))!
+            : null;
 
     private static RelationalTypeMappingParameters CreateRelationalTypeMappingParameters(string storeType)
     {
@@ -67,10 +60,16 @@ private static RelationalTypeMappingParameters CreateRelationalTypeMappingParame
                 typeof(TGeometry),
                 null,
                 comparer,
-                comparer),
+                comparer,
+                CreateProviderValueComparer(typeof(TGeometry))),
             storeType);
     }
 
+    /// <summary>
+    ///     The underlying Geometry converter.
+    /// </summary>
+    protected virtual ValueConverter<TGeometry, TProvider>? SpatialConverter { get; }
+
     /// <summary>
     ///     Creates a <see cref="DbParameter" /> with the appropriate type information configured.
     /// </summary>
diff --git a/src/EFCore.Relational/Storage/RelationalTypeMapping.cs b/src/EFCore.Relational/Storage/RelationalTypeMapping.cs
index aa41dff067..d223502f13 100644
--- a/src/EFCore.Relational/Storage/RelationalTypeMapping.cs
+++ b/src/EFCore.Relational/Storage/RelationalTypeMapping.cs
@@ -109,6 +109,24 @@ public abstract class RelationalTypeMapping : CoreTypeMapping
         /// </summary>
         public StoreTypePostfix StoreTypePostfix { get; }
 
+        /// <summary>
+        ///     Creates a new <see cref="RelationalTypeMappingParameters" /> parameter object with the given
+        ///     core parameters.
+        /// </summary>
+        /// <param name="coreParameters">Parameters for the <see cref="CoreTypeMapping" /> base class.</param>
+        /// <returns>The new parameter object.</returns>
+        public RelationalTypeMappingParameters WithCoreParameters(in CoreTypeMappingParameters coreParameters)
+            => new(
+                coreParameters,
+                StoreType,
+                StoreTypePostfix,
+                DbType,
+                Unicode,
+                Size,
+                FixedLength,
+                Precision,
+                Scale);
+
         /// <summary>
         ///     Creates a new <see cref="RelationalTypeMappingParameters" /> parameter object with the given
         ///     mapping info.
@@ -261,8 +279,6 @@ protected override RelationalTypeMapping Clone(RelationalTypeMappingParameters p
             => this;
     }
 
-    private ValueComparer? _providerValueComparer;
-
     /// <summary>
     ///     Initializes a new instance of the <see cref="RelationalTypeMapping" /> class.
     /// </summary>
@@ -380,19 +396,6 @@ public virtual bool IsFixedLength
     protected virtual string SqlLiteralFormatString
         => "{0}";
 
-    /// <summary>
-    ///     A <see cref="ValueComparer" /> for the provider CLR type values.
-    /// </summary>
-    public virtual ValueComparer ProviderValueComparer
-    {
-        get => NonCapturingLazyInitializer.EnsureInitialized(
-                   ref _providerValueComparer,
-                   this,
-                   static c => ValueComparer.CreateDefault(c.Converter?.ProviderClrType ?? c.ClrType, favorStructuralComparisons: true));
-        
-        protected set => _providerValueComparer = value;
-    }
-
     /// <summary>
     ///     Creates a copy of this mapping.
     /// </summary>
diff --git a/src/EFCore.Relational/Update/Internal/CommandBatchPreparer.cs b/src/EFCore.Relational/Update/Internal/CommandBatchPreparer.cs
index f062ee0e32..05e355093b 100644
--- a/src/EFCore.Relational/Update/Internal/CommandBatchPreparer.cs
+++ b/src/EFCore.Relational/Update/Internal/CommandBatchPreparer.cs
@@ -612,7 +612,7 @@ private static bool IsModified(IReadOnlyList<IColumn> columns, IReadOnlyModifica
             var column = columns[columnIndex];
             object? originalValue = null;
             object? currentValue = null;
-            RelationalTypeMapping? typeMapping = null;
+            ValueComparer? providerValueComparer = null;
             for (var entryIndex = 0; entryIndex < command.Entries.Count; entryIndex++)
             {
                 var entry = command.Entries[entryIndex];
@@ -641,12 +641,12 @@ private static bool IsModified(IReadOnlyList<IColumn> columns, IReadOnlyModifica
                             break;
                     }
 
-                    typeMapping = columnMapping!.TypeMapping;
+                    providerValueComparer = property.GetProviderValueComparer();
                 }
             }
 
-            if (typeMapping != null
-                && !typeMapping.ProviderValueComparer.Equals(originalValue, currentValue))
+            if (providerValueComparer != null
+                && !providerValueComparer.Equals(originalValue, currentValue))
             {
                 return true;
             }
diff --git a/src/EFCore.Relational/Update/Internal/CompositeRowValueFactory.cs b/src/EFCore.Relational/Update/Internal/CompositeRowValueFactory.cs
index 348495ac8a..c4ab62efb5 100644
--- a/src/EFCore.Relational/Update/Internal/CompositeRowValueFactory.cs
+++ b/src/EFCore.Relational/Update/Internal/CompositeRowValueFactory.cs
@@ -150,7 +150,7 @@ public virtual bool TryCreateDependentKeyValue(IReadOnlyModificationCommand comm
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
     protected static IEqualityComparer<object?[]> CreateEqualityComparer(IReadOnlyList<IColumn> columns)
-        => new CompositeCustomComparer(columns.Select(c => c.PropertyMappings.First().TypeMapping.ProviderValueComparer).ToList());
+        => new CompositeCustomComparer(columns.Select(c => c.ProviderValueComparer).ToList());
 
     private sealed class CompositeCustomComparer : IEqualityComparer<object?[]>
     {
diff --git a/src/EFCore.Relational/Update/Internal/RowForeignKeyValueFactory.cs b/src/EFCore.Relational/Update/Internal/RowForeignKeyValueFactory.cs
index fdec90c5e4..866b070f03 100644
--- a/src/EFCore.Relational/Update/Internal/RowForeignKeyValueFactory.cs
+++ b/src/EFCore.Relational/Update/Internal/RowForeignKeyValueFactory.cs
@@ -96,8 +96,7 @@ public virtual object CreatePrincipalValueIndex(IReadOnlyModificationCommand com
     /// </summary>
     protected virtual IEqualityComparer<TKey> CreateKeyEqualityComparer(IColumn column)
 #pragma warning disable EF1001 // Internal EF Core API usage.
-        => NullableComparerAdapter<TKey>.Wrap(
-            column.PropertyMappings.First().TypeMapping.ProviderValueComparer);
+        => NullableComparerAdapter<TKey>.Wrap(column.ProviderValueComparer);
 #pragma warning restore EF1001 // Internal EF Core API usage.
 
     /// <summary>
diff --git a/src/EFCore.Relational/Update/Internal/SimpleRowIndexValueFactory.cs b/src/EFCore.Relational/Update/Internal/SimpleRowIndexValueFactory.cs
index 8e9d852121..b208536a03 100644
--- a/src/EFCore.Relational/Update/Internal/SimpleRowIndexValueFactory.cs
+++ b/src/EFCore.Relational/Update/Internal/SimpleRowIndexValueFactory.cs
@@ -31,7 +31,7 @@ public SimpleRowIndexValueFactory(ITableIndex index)
         _column = index.Columns.Single();
         _columnAccessors = ((Column)_column).Accessors;
 #pragma warning disable EF1001 // Internal EF Core API usage.
-        EqualityComparer = NullableComparerAdapter<TKey>.Wrap(_column.PropertyMappings.First().TypeMapping.ProviderValueComparer);
+        EqualityComparer = NullableComparerAdapter<TKey>.Wrap(_column.ProviderValueComparer);
 #pragma warning restore EF1001 // Internal EF Core API usage.
     }
 
diff --git a/src/EFCore.Relational/Update/Internal/SimpleRowKeyValueFactory.cs b/src/EFCore.Relational/Update/Internal/SimpleRowKeyValueFactory.cs
index 7ab03fb083..bbff7df81a 100644
--- a/src/EFCore.Relational/Update/Internal/SimpleRowKeyValueFactory.cs
+++ b/src/EFCore.Relational/Update/Internal/SimpleRowKeyValueFactory.cs
@@ -31,7 +31,7 @@ public SimpleRowKeyValueFactory(IUniqueConstraint constraint)
         _constraint = constraint;
         _column = constraint.Columns.Single();
         _columnAccessors = ((Column)_column).Accessors;
-        EqualityComparer = new NoNullsCustomEqualityComparer(_column.PropertyMappings.First().TypeMapping.ProviderValueComparer);
+        EqualityComparer = new NoNullsCustomEqualityComparer(_column.ProviderValueComparer);
     }
 
     /// <summary>
@@ -139,14 +139,6 @@ private sealed class NoNullsCustomEqualityComparer : IEqualityComparer<TKey>
 
         public NoNullsCustomEqualityComparer(ValueComparer comparer)
         {
-            if (comparer.Type != typeof(TKey)
-                && comparer.Type == typeof(TKey).UnwrapNullableType())
-            {
-#pragma warning disable EF1001 // Internal EF Core API usage.
-                comparer = comparer.ToNonNullNullableComparer();
-#pragma warning restore EF1001 // Internal EF Core API usage.
-            }
-
             _equals = (Func<TKey?, TKey?, bool>)comparer.EqualsExpression.Compile();
             _hashCode = (Func<TKey, int>)comparer.HashCodeExpression.Compile();
         }
diff --git a/src/EFCore.Relational/Update/ModificationCommand.cs b/src/EFCore.Relational/Update/ModificationCommand.cs
index 6a472a267e..5c1ca6bbb2 100644
--- a/src/EFCore.Relational/Update/ModificationCommand.cs
+++ b/src/EFCore.Relational/Update/ModificationCommand.cs
@@ -490,7 +490,7 @@ public void RecordValue(IColumnMapping mapping, IUpdateEntry entry)
                     break;
                 case EntityState.Added:
                     _currentValue = entry.GetCurrentProviderValue(property);
-                    _write = !mapping.TypeMapping.ProviderValueComparer.Equals(_originalValue, _currentValue);
+                    _write = !mapping.Column.ProviderValueComparer.Equals(_originalValue, _currentValue);
 
                     break;
                 case EntityState.Deleted:
@@ -513,7 +513,7 @@ public bool TryPropagate(IColumnMapping mapping, IUpdateEntry entry)
                 && (entry.EntityState == EntityState.Unchanged
                     || (entry.EntityState == EntityState.Modified && !entry.IsModified(property))
                     || (entry.EntityState == EntityState.Added
-                        && mapping.TypeMapping.ProviderValueComparer.Equals(_originalValue, entry.GetCurrentValue(property)))))
+                        && mapping.Column.ProviderValueComparer.Equals(_originalValue, entry.GetCurrentValue(property)))))
             {
                 if (property.GetAfterSaveBehavior() == PropertySaveBehavior.Save
                     || entry.EntityState == EntityState.Added)
diff --git a/src/EFCore/ChangeTracking/Internal/SimplePrincipalKeyValueFactory.cs b/src/EFCore/ChangeTracking/Internal/SimplePrincipalKeyValueFactory.cs
index c890413d70..74851ea964 100644
--- a/src/EFCore/ChangeTracking/Internal/SimplePrincipalKeyValueFactory.cs
+++ b/src/EFCore/ChangeTracking/Internal/SimplePrincipalKeyValueFactory.cs
@@ -122,12 +122,6 @@ private sealed class NoNullsCustomEqualityComparer : IEqualityComparer<TKey>
 
         public NoNullsCustomEqualityComparer(ValueComparer comparer)
         {
-            if (comparer.Type != typeof(TKey)
-                && comparer.Type == typeof(TKey).UnwrapNullableType())
-            {
-                comparer = comparer.ToNonNullNullableComparer();
-            }
-
             _equals = (Func<TKey?, TKey?, bool>)comparer.EqualsExpression.Compile();
             _hashCode = (Func<TKey, int>)comparer.HashCodeExpression.Compile();
         }
diff --git a/src/EFCore/ChangeTracking/Internal/ValueComparerExtensions.cs b/src/EFCore/ChangeTracking/Internal/ValueComparerExtensions.cs
deleted file mode 100644
index 5b31626f24..0000000000
--- a/src/EFCore/ChangeTracking/Internal/ValueComparerExtensions.cs
+++ /dev/null
@@ -1,62 +0,0 @@
-// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-namespace Microsoft.EntityFrameworkCore.ChangeTracking.Internal;
-
-/// <summary>
-///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-///     any release. You should only use it directly in your code with extreme caution and knowing that
-///     doing so can result in application failures when updating to a new Entity Framework Core release.
-/// </summary>
-public static class ValueComparerExtensions
-{
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public static ValueComparer ToNonNullNullableComparer(this ValueComparer comparer)
-    {
-        var type = comparer.EqualsExpression.Parameters[0].Type;
-        var nullableType = type.MakeNullable();
-
-        var newEqualsParam1 = Expression.Parameter(nullableType, "v1");
-        var newEqualsParam2 = Expression.Parameter(nullableType, "v2");
-        var newHashCodeParam = Expression.Parameter(nullableType, "v");
-        var newSnapshotParam = Expression.Parameter(nullableType, "v");
-
-        return (ValueComparer)Activator.CreateInstance(
-            typeof(NonNullNullableValueComparer<>).MakeGenericType(nullableType),
-            Expression.Lambda(
-                comparer.ExtractEqualsBody(
-                    Expression.Convert(newEqualsParam1, type),
-                    Expression.Convert(newEqualsParam2, type)),
-                newEqualsParam1, newEqualsParam2),
-            Expression.Lambda(
-                comparer.ExtractHashCodeBody(
-                    Expression.Convert(newHashCodeParam, type)),
-                newHashCodeParam),
-            Expression.Lambda(
-                Expression.Convert(
-                    comparer.ExtractSnapshotBody(
-                        Expression.Convert(newSnapshotParam, type)),
-                    nullableType),
-                newSnapshotParam))!;
-    }
-
-    private sealed class NonNullNullableValueComparer<T> : ValueComparer<T>
-    {
-        public NonNullNullableValueComparer(
-            LambdaExpression equalsExpression,
-            LambdaExpression hashCodeExpression,
-            LambdaExpression snapshotExpression)
-            : base(
-                (Expression<Func<T?, T?, bool>>)equalsExpression,
-                (Expression<Func<T, int>>)hashCodeExpression,
-                (Expression<Func<T, T>>)snapshotExpression)
-        {
-        }
-    }
-}
diff --git a/src/EFCore/Infrastructure/ModelValidator.cs b/src/EFCore/Infrastructure/ModelValidator.cs
index cdc344f2ff..d53e42b96d 100644
--- a/src/EFCore/Infrastructure/ModelValidator.cs
+++ b/src/EFCore/Infrastructure/ModelValidator.cs
@@ -868,6 +868,24 @@ static bool ContainedInForeignKeyForAllConcreteTypes(IEntityType entityType, IPr
                 {
                     _ = property.GetCurrentValueComparer(); // Will throw if there is no way to compare
                 }
+                
+                var providerComparer = property.GetProviderValueComparer();
+                if (providerComparer == null)
+                {
+                    continue;
+                }
+
+                var typeMapping = property.GetTypeMapping();
+                var actualProviderClrType = (typeMapping.Converter?.ProviderClrType ?? typeMapping.ClrType).UnwrapNullableType();
+
+                if (providerComparer.Type.UnwrapNullableType() != actualProviderClrType)
+                {
+                    throw new InvalidOperationException(CoreStrings.ComparerPropertyMismatch(
+                        providerComparer.Type.ShortDisplayName(),
+                        property.DeclaringEntityType.DisplayName(),
+                        property.Name,
+                        actualProviderClrType.ShortDisplayName()));
+                }
             }
         }
     }
diff --git a/src/EFCore/Metadata/Builders/IConventionPropertyBuilder.cs b/src/EFCore/Metadata/Builders/IConventionPropertyBuilder.cs
index cfa24fb1b5..beeb081763 100644
--- a/src/EFCore/Metadata/Builders/IConventionPropertyBuilder.cs
+++ b/src/EFCore/Metadata/Builders/IConventionPropertyBuilder.cs
@@ -487,4 +487,52 @@ public interface IConventionPropertyBuilder : IConventionPropertyBaseBuilder
     ///     <see langword="true" /> if the given <see cref="ValueComparer" /> can be configured for this property.
     /// </returns>
     bool CanSetValueComparer(Type? comparerType, bool fromDataAnnotation = false);
+
+    /// <summary>
+    ///     Configures the <see cref="ValueComparer" /> to use for the provider values for this property.
+    /// </summary>
+    /// <param name="comparer">The comparer, or <see langword="null" /> to remove any previously set comparer.</param>
+    /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
+    /// <returns>
+    ///     The same builder instance if the configuration was applied, <see langword="null" /> otherwise.
+    /// </returns>
+    IConventionPropertyBuilder? HasProviderValueComparer(ValueComparer? comparer, bool fromDataAnnotation = false);
+
+    /// <summary>
+    ///     Returns a value indicating whether the given <see cref="ValueComparer" />
+    ///     can be configured for this property from the current configuration source.
+    /// </summary>
+    /// <param name="comparer">The comparer, or <see langword="null" /> to remove any previously set comparer.</param>
+    /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
+    /// <returns>
+    ///     <see langword="true" /> if the given <see cref="ValueComparer" /> can be configured for this property.
+    /// </returns>
+    bool CanSetProviderValueComparer(ValueComparer? comparer, bool fromDataAnnotation = false);
+
+    /// <summary>
+    ///     Configures the <see cref="ValueComparer" /> to use for the provider values for this property.
+    /// </summary>
+    /// <param name="comparerType">
+    ///     A type that derives from <see cref="ValueComparer" />,
+    ///     or <see langword="null" /> to remove any previously set comparer.
+    /// </param>
+    /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
+    /// <returns>
+    ///     The same builder instance if the configuration was applied, <see langword="null" /> otherwise.
+    /// </returns>
+    IConventionPropertyBuilder? HasProviderValueComparer(Type? comparerType, bool fromDataAnnotation = false);
+
+    /// <summary>
+    ///     Returns a value indicating whether the given <see cref="ValueComparer" />
+    ///     can be configured for this property from the current configuration source.
+    /// </summary>
+    /// <param name="comparerType">
+    ///     A type that derives from <see cref="ValueComparer" />,
+    ///     or <see langword="null" /> to remove any previously set comparer.
+    /// </param>
+    /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
+    /// <returns>
+    ///     <see langword="true" /> if the given <see cref="ValueComparer" /> can be configured for this property.
+    /// </returns>
+    bool CanSetProviderValueComparer(Type? comparerType, bool fromDataAnnotation = false);
 }
diff --git a/src/EFCore/Metadata/Builders/PropertiesConfigurationBuilder.cs b/src/EFCore/Metadata/Builders/PropertiesConfigurationBuilder.cs
index 1bd3688658..072223dec5 100644
--- a/src/EFCore/Metadata/Builders/PropertiesConfigurationBuilder.cs
+++ b/src/EFCore/Metadata/Builders/PropertiesConfigurationBuilder.cs
@@ -112,7 +112,7 @@ public virtual PropertiesConfigurationBuilder AreUnicode(bool unicode = true)
     ///     Configures the property so that the property value is converted before
     ///     writing to the database and converted back when reading from the database.
     /// </summary>
-    /// <typeparam name="TConversion">The type to convert to and from or a type that derives from <see cref="ValueConverter" />.</typeparam>
+    /// <typeparam name="TConversion">The type to convert to and from or a type that inherits from <see cref="ValueConverter" />.</typeparam>
     /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
     public virtual PropertiesConfigurationBuilder HaveConversion<TConversion>()
         => HaveConversion(typeof(TConversion));
@@ -121,7 +121,7 @@ public virtual PropertiesConfigurationBuilder HaveConversion<TConversion>()
     ///     Configures the property so that the property value is converted before
     ///     writing to the database and converted back when reading from the database.
     /// </summary>
-    /// <param name="conversionType">The type to convert to and from or a type that derives from <see cref="ValueConverter" />.</param>
+    /// <param name="conversionType">The type to convert to and from or a type that inherits from <see cref="ValueConverter" />.</param>
     /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
     public virtual PropertiesConfigurationBuilder HaveConversion(Type conversionType)
     {
@@ -143,8 +143,8 @@ public virtual PropertiesConfigurationBuilder HaveConversion(Type conversionType
     ///     Configures the property so that the property value is converted before
     ///     writing to the database and converted back when reading from the database.
     /// </summary>
-    /// <typeparam name="TConversion">The type to convert to and from or a type that derives from <see cref="ValueConverter" />.</typeparam>
-    /// <typeparam name="TComparer">A type that derives from <see cref="ValueComparer" />.</typeparam>
+    /// <typeparam name="TConversion">The type to convert to and from or a type that inherits from <see cref="ValueConverter" />.</typeparam>
+    /// <typeparam name="TComparer">A type that inherits from <see cref="ValueComparer" />.</typeparam>
     /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
     public virtual PropertiesConfigurationBuilder HaveConversion<TConversion, TComparer>()
         where TComparer : ValueComparer
@@ -154,10 +154,33 @@ public virtual PropertiesConfigurationBuilder HaveConversion(Type conversionType
     ///     Configures the property so that the property value is converted before
     ///     writing to the database and converted back when reading from the database.
     /// </summary>
-    /// <param name="conversionType">The type to convert to and from or a type that derives from <see cref="ValueConverter" />.</param>
-    /// <param name="comparerType">A type that derives from <see cref="ValueComparer" />.</param>
+    /// <typeparam name="TConversion">The type to convert to and from or a type that inherits from <see cref="ValueConverter" />.</typeparam>
+    /// <typeparam name="TComparer">A type that inherits from <see cref="ValueComparer" />.</typeparam>
+    /// <typeparam name="TProviderComparer">A type that inherits from <see cref="ValueComparer" /> to use for the provider values.</typeparam>
+    /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
+    public virtual PropertiesConfigurationBuilder HaveConversion<TConversion, TComparer, TProviderComparer>()
+        where TComparer : ValueComparer
+        => HaveConversion(typeof(TConversion), typeof(TComparer), typeof(TProviderComparer));
+
+    /// <summary>
+    ///     Configures the property so that the property value is converted before
+    ///     writing to the database and converted back when reading from the database.
+    /// </summary>
+    /// <param name="conversionType">The type to convert to and from or a type that inherits from <see cref="ValueConverter" />.</param>
+    /// <param name="comparerType">A type that inherits from <see cref="ValueComparer" />.</param>
     /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
     public virtual PropertiesConfigurationBuilder HaveConversion(Type conversionType, Type? comparerType)
+        => HaveConversion(conversionType, comparerType, null);
+
+    /// <summary>
+    ///     Configures the property so that the property value is converted before
+    ///     writing to the database and converted back when reading from the database.
+    /// </summary>
+    /// <param name="conversionType">The type to convert to and from or a type that inherits from <see cref="ValueConverter" />.</param>
+    /// <param name="comparerType">A type that inherits from <see cref="ValueComparer" />.</param>
+    /// <param name="providerComparerType">A type that inherits from <see cref="ValueComparer" /> to use for the provider values.</param>
+    /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
+    public virtual PropertiesConfigurationBuilder HaveConversion(Type conversionType, Type? comparerType, Type? providerComparerType)
     {
         Check.NotNull(conversionType, nameof(conversionType));
 
@@ -172,6 +195,8 @@ public virtual PropertiesConfigurationBuilder HaveConversion(Type conversionType
 
         Configuration.SetValueComparer(comparerType);
 
+        Configuration.SetProviderValueComparer(providerComparerType);
+
         return this;
     }
 
diff --git a/src/EFCore/Metadata/Builders/PropertiesConfigurationBuilder`.cs b/src/EFCore/Metadata/Builders/PropertiesConfigurationBuilder`.cs
index 78fc52f3fd..fc7c0fb7d6 100644
--- a/src/EFCore/Metadata/Builders/PropertiesConfigurationBuilder`.cs
+++ b/src/EFCore/Metadata/Builders/PropertiesConfigurationBuilder`.cs
@@ -78,7 +78,7 @@ public new virtual PropertiesConfigurationBuilder<TProperty> AreUnicode(bool uni
     ///     Configures the property so that the property value is converted before
     ///     writing to the database and converted back when reading from the database.
     /// </summary>
-    /// <typeparam name="TConversion">The type to convert to and from or a type that derives from <see cref="ValueConverter" />.</typeparam>
+    /// <typeparam name="TConversion">The type to convert to and from or a type that inherits from <see cref="ValueConverter" />.</typeparam>
     /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
     public new virtual PropertiesConfigurationBuilder<TProperty> HaveConversion<TConversion>()
         => (PropertiesConfigurationBuilder<TProperty>)base.HaveConversion<TConversion>();
@@ -87,7 +87,7 @@ public new virtual PropertiesConfigurationBuilder<TProperty> HaveConversion<TCon
     ///     Configures the property so that the property value is converted before
     ///     writing to the database and converted back when reading from the database.
     /// </summary>
-    /// <param name="conversionType">The type to convert to and from or a type that derives from <see cref="ValueConverter" />.</param>
+    /// <param name="conversionType">The type to convert to and from or a type that inherits from <see cref="ValueConverter" />.</param>
     /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
     public new virtual PropertiesConfigurationBuilder<TProperty> HaveConversion(Type conversionType)
         => (PropertiesConfigurationBuilder<TProperty>)base.HaveConversion(conversionType);
@@ -96,8 +96,8 @@ public new virtual PropertiesConfigurationBuilder<TProperty> HaveConversion(Type
     ///     Configures the property so that the property value is converted before
     ///     writing to the database and converted back when reading from the database.
     /// </summary>
-    /// <typeparam name="TConversion">The type to convert to and from or a type that derives from <see cref="ValueConverter" />.</typeparam>
-    /// <typeparam name="TComparer">A type that derives from <see cref="ValueComparer" />.</typeparam>
+    /// <typeparam name="TConversion">The type to convert to and from or a type that inherits from <see cref="ValueConverter" />.</typeparam>
+    /// <typeparam name="TComparer">A type that inherits from <see cref="ValueComparer" />.</typeparam>
     /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
     public new virtual PropertiesConfigurationBuilder<TProperty> HaveConversion<TConversion, TComparer>()
         where TComparer : ValueComparer
@@ -107,8 +107,8 @@ public new virtual PropertiesConfigurationBuilder<TProperty> HaveConversion(Type
     ///     Configures the property so that the property value is converted before
     ///     writing to the database and converted back when reading from the database.
     /// </summary>
-    /// <param name="conversionType">The type to convert to and from or a type that derives from <see cref="ValueConverter" />.</param>
-    /// <param name="comparerType">A type that derives from <see cref="ValueComparer" />.</param>
+    /// <param name="conversionType">The type to convert to and from or a type that inherits from <see cref="ValueConverter" />.</param>
+    /// <param name="comparerType">A type that inherits from <see cref="ValueComparer" />.</param>
     /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
     public new virtual PropertiesConfigurationBuilder<TProperty> HaveConversion(Type conversionType, Type? comparerType)
         => (PropertiesConfigurationBuilder<TProperty>)base.HaveConversion(conversionType, comparerType);
diff --git a/src/EFCore/Metadata/Builders/PropertyBuilder.cs b/src/EFCore/Metadata/Builders/PropertyBuilder.cs
index 7e8e216339..a3ec58aba2 100644
--- a/src/EFCore/Metadata/Builders/PropertyBuilder.cs
+++ b/src/EFCore/Metadata/Builders/PropertyBuilder.cs
@@ -439,7 +439,7 @@ public virtual PropertyBuilder UsePropertyAccessMode(PropertyAccessMode property
     ///     Configures the property so that the property value is converted before
     ///     writing to the database and converted back when reading from the database.
     /// </summary>
-    /// <typeparam name="TConversion">The type to convert to and from or a type that derives from <see cref="ValueConverter" />.</typeparam>
+    /// <typeparam name="TConversion">The type to convert to and from or a type that inherits from <see cref="ValueConverter" />.</typeparam>
     /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
     public virtual PropertyBuilder HasConversion<TConversion>()
         => HasConversion(typeof(TConversion));
@@ -448,7 +448,7 @@ public virtual PropertyBuilder HasConversion<TConversion>()
     ///     Configures the property so that the property value is converted before
     ///     writing to the database and converted back when reading from the database.
     /// </summary>
-    /// <param name="conversionType">The type to convert to and from or a type that derives from <see cref="ValueConverter" />.</param>
+    /// <param name="conversionType">The type to convert to and from or a type that inherits from <see cref="ValueConverter" />.</param>
     /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
     public virtual PropertyBuilder HasConversion(Type? conversionType)
     {
@@ -471,18 +471,14 @@ public virtual PropertyBuilder HasConversion(Type? conversionType)
     /// <param name="converter">The converter to use.</param>
     /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
     public virtual PropertyBuilder HasConversion(ValueConverter? converter)
-    {
-        Builder.HasConversion(converter, ConfigurationSource.Explicit);
-
-        return this;
-    }
+        => HasConversion(converter, null, null);
 
     /// <summary>
     ///     Configures the property so that the property value is converted before
     ///     writing to the database and converted back when reading from the database.
     /// </summary>
     /// <param name="valueComparer">The comparer to use for values before conversion.</param>
-    /// <typeparam name="TConversion">The type to convert to and from or a type that derives from <see cref="ValueConverter" />.</typeparam>
+    /// <typeparam name="TConversion">The type to convert to and from or a type that inherits from <see cref="ValueConverter" />.</typeparam>
     /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
     public virtual PropertyBuilder HasConversion<TConversion>(ValueComparer? valueComparer)
         => HasConversion(typeof(TConversion), valueComparer);
@@ -491,10 +487,32 @@ public virtual PropertyBuilder HasConversion<TConversion>(ValueComparer? valueCo
     ///     Configures the property so that the property value is converted before
     ///     writing to the database and converted back when reading from the database.
     /// </summary>
-    /// <param name="conversionType">The type to convert to and from or a type that derives from <see cref="ValueConverter" />.</param>
+    /// <param name="valueComparer">The comparer to use for values before conversion.</param>
+    /// <param name="providerComparer">The comparer to use for the provider values.</param>
+    /// <typeparam name="TConversion">The type to convert to and from or a type that inherits from <see cref="ValueConverter" />.</typeparam>
+    /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
+    public virtual PropertyBuilder HasConversion<TConversion>(ValueComparer? valueComparer, ValueComparer? providerComparer)
+        => HasConversion(typeof(TConversion), valueComparer, providerComparer);
+
+    /// <summary>
+    ///     Configures the property so that the property value is converted before
+    ///     writing to the database and converted back when reading from the database.
+    /// </summary>
+    /// <param name="conversionType">The type to convert to and from or a type that inherits from <see cref="ValueConverter" />.</param>
     /// <param name="valueComparer">The comparer to use for values before conversion.</param>
     /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
     public virtual PropertyBuilder HasConversion(Type conversionType, ValueComparer? valueComparer)
+        => HasConversion(conversionType, valueComparer, null);
+
+    /// <summary>
+    ///     Configures the property so that the property value is converted before
+    ///     writing to the database and converted back when reading from the database.
+    /// </summary>
+    /// <param name="conversionType">The type to convert to and from or a type that inherits from <see cref="ValueConverter" />.</param>
+    /// <param name="valueComparer">The comparer to use for values before conversion.</param>
+    /// <param name="providerComparer">The comparer to use for the provider values.</param>
+    /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
+    public virtual PropertyBuilder HasConversion(Type conversionType, ValueComparer? valueComparer, ValueComparer? providerComparer)
     {
         Check.NotNull(conversionType, nameof(conversionType));
 
@@ -508,6 +526,7 @@ public virtual PropertyBuilder HasConversion(Type conversionType, ValueComparer?
         }
 
         Builder.HasValueComparer(valueComparer, ConfigurationSource.Explicit);
+        Builder.HasProviderValueComparer(providerComparer, ConfigurationSource.Explicit);
 
         return this;
     }
@@ -520,9 +539,21 @@ public virtual PropertyBuilder HasConversion(Type conversionType, ValueComparer?
     /// <param name="valueComparer">The comparer to use for values before conversion.</param>
     /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
     public virtual PropertyBuilder HasConversion(ValueConverter? converter, ValueComparer? valueComparer)
+        => HasConversion(converter, valueComparer, null);
+
+    /// <summary>
+    ///     Configures the property so that the property value is converted to and from the database
+    ///     using the given <see cref="ValueConverter" />.
+    /// </summary>
+    /// <param name="converter">The converter to use.</param>
+    /// <param name="valueComparer">The comparer to use for values before conversion.</param>
+    /// <param name="providerComparer">The comparer to use for the provider values.</param>
+    /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
+    public virtual PropertyBuilder HasConversion(ValueConverter? converter, ValueComparer? valueComparer, ValueComparer? providerComparer)
     {
         Builder.HasConversion(converter, ConfigurationSource.Explicit);
         Builder.HasValueComparer(valueComparer, ConfigurationSource.Explicit);
+        Builder.HasProviderValueComparer(providerComparer, ConfigurationSource.Explicit);
 
         return this;
     }
@@ -531,8 +562,8 @@ public virtual PropertyBuilder HasConversion(ValueConverter? converter, ValueCom
     ///     Configures the property so that the property value is converted before
     ///     writing to the database and converted back when reading from the database.
     /// </summary>
-    /// <typeparam name="TConversion">The type to convert to and from or a type that derives from <see cref="ValueConverter" />.</typeparam>
-    /// <typeparam name="TComparer">A type that derives from <see cref="ValueComparer" />.</typeparam>
+    /// <typeparam name="TConversion">The type to convert to and from or a type that inherits from <see cref="ValueConverter" />.</typeparam>
+    /// <typeparam name="TComparer">A type that inherits from <see cref="ValueComparer" />.</typeparam>
     /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
     public virtual PropertyBuilder HasConversion<TConversion, TComparer>()
         where TComparer : ValueComparer
@@ -542,10 +573,34 @@ public virtual PropertyBuilder HasConversion(ValueConverter? converter, ValueCom
     ///     Configures the property so that the property value is converted before
     ///     writing to the database and converted back when reading from the database.
     /// </summary>
-    /// <param name="conversionType">The type to convert to and from or a type that derives from <see cref="ValueConverter" />.</param>
-    /// <param name="comparerType">A type that derives from <see cref="ValueComparer" />.</param>
+    /// <typeparam name="TConversion">The type to convert to and from or a type that inherits from <see cref="ValueConverter" />.</typeparam>
+    /// <typeparam name="TComparer">A type that inherits from <see cref="ValueComparer" />.</typeparam>
+    /// <typeparam name="TProviderComparer">A type that inherits from <see cref="ValueComparer" /> to use for the provider values.</typeparam>
+    /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
+    public virtual PropertyBuilder HasConversion<TConversion, TComparer, TProviderComparer>()
+        where TComparer : ValueComparer
+        where TProviderComparer : ValueComparer
+        => HasConversion(typeof(TConversion), typeof(TComparer), typeof(TProviderComparer));
+
+    /// <summary>
+    ///     Configures the property so that the property value is converted before
+    ///     writing to the database and converted back when reading from the database.
+    /// </summary>
+    /// <param name="conversionType">The type to convert to and from or a type that inherits from <see cref="ValueConverter" />.</param>
+    /// <param name="comparerType">A type that inherits from <see cref="ValueComparer" />.</param>
     /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
     public virtual PropertyBuilder HasConversion(Type conversionType, Type? comparerType)
+        => HasConversion(conversionType, comparerType, null);
+
+    /// <summary>
+    ///     Configures the property so that the property value is converted before
+    ///     writing to the database and converted back when reading from the database.
+    /// </summary>
+    /// <param name="conversionType">The type to convert to and from or a type that inherits from <see cref="ValueConverter" />.</param>
+    /// <param name="comparerType">A type that inherits from <see cref="ValueComparer" />.</param>
+    /// <param name="providerComparerType">A type that inherits from <see cref="ValueComparer" /> to use for the provider values.</param>
+    /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
+    public virtual PropertyBuilder HasConversion(Type conversionType, Type? comparerType, Type? providerComparerType)
     {
         Check.NotNull(conversionType, nameof(conversionType));
 
@@ -559,6 +614,7 @@ public virtual PropertyBuilder HasConversion(Type conversionType, Type? comparer
         }
 
         Builder.HasValueComparer(comparerType, ConfigurationSource.Explicit);
+        Builder.HasProviderValueComparer(providerComparerType, ConfigurationSource.Explicit);
 
         return this;
     }
diff --git a/src/EFCore/Metadata/Builders/PropertyBuilder`.cs b/src/EFCore/Metadata/Builders/PropertyBuilder`.cs
index 01fff1bf5f..44485ab074 100644
--- a/src/EFCore/Metadata/Builders/PropertyBuilder`.cs
+++ b/src/EFCore/Metadata/Builders/PropertyBuilder`.cs
@@ -337,7 +337,7 @@ public new virtual PropertyBuilder<TProperty> UsePropertyAccessMode(PropertyAcce
     ///     Configures the property so that the property value is converted before
     ///     writing to the database and converted back when reading from the database.
     /// </summary>
-    /// <typeparam name="TConversion">The type to convert to and from or a type that derives from <see cref="ValueConverter" />.</typeparam>
+    /// <typeparam name="TConversion">The type to convert to and from or a type that inherits from <see cref="ValueConverter" />.</typeparam>
     /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
     public new virtual PropertyBuilder<TProperty> HasConversion<TConversion>()
         => (PropertyBuilder<TProperty>)base.HasConversion<TConversion>();
@@ -346,7 +346,7 @@ public new virtual PropertyBuilder<TProperty> HasConversion<TConversion>()
     ///     Configures the property so that the property value is converted before
     ///     writing to the database and converted back when reading from the database.
     /// </summary>
-    /// <param name="providerClrType">The type to convert to and from or a type that derives from <see cref="ValueConverter" />.</param>
+    /// <param name="providerClrType">The type to convert to and from or a type that inherits from <see cref="ValueConverter" />.</param>
     /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
     public new virtual PropertyBuilder<TProperty> HasConversion(Type? providerClrType)
         => (PropertyBuilder<TProperty>)base.HasConversion(providerClrType);
@@ -390,7 +390,7 @@ public new virtual PropertyBuilder<TProperty> HasConversion(ValueConverter? conv
     ///     Configures the property so that the property value is converted before
     ///     writing to the database and converted back when reading from the database.
     /// </summary>
-    /// <typeparam name="TConversion">The type to convert to and from or a type that derives from <see cref="ValueConverter" />.</typeparam>
+    /// <typeparam name="TConversion">The type to convert to and from or a type that inherits from <see cref="ValueConverter" />.</typeparam>
     /// <param name="valueComparer">The comparer to use for values before conversion.</param>
     /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
     public new virtual PropertyBuilder<TProperty> HasConversion<TConversion>(ValueComparer? valueComparer)
@@ -400,7 +400,18 @@ public new virtual PropertyBuilder<TProperty> HasConversion<TConversion>(ValueCo
     ///     Configures the property so that the property value is converted before
     ///     writing to the database and converted back when reading from the database.
     /// </summary>
-    /// <param name="conversionType">The type to convert to and from or a type that derives from <see cref="ValueConverter" />.</param>
+    /// <typeparam name="TConversion">The type to convert to and from or a type that inherits from <see cref="ValueConverter" />.</typeparam>
+    /// <param name="valueComparer">The comparer to use for values before conversion.</param>
+    /// <param name="providerComparer">The comparer to use for the provider values.</param>
+    /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
+    public new virtual PropertyBuilder<TProperty> HasConversion<TConversion>(ValueComparer? valueComparer, ValueComparer? providerComparer)
+        => (PropertyBuilder<TProperty>)base.HasConversion<TConversion>(valueComparer, providerComparer);
+
+    /// <summary>
+    ///     Configures the property so that the property value is converted before
+    ///     writing to the database and converted back when reading from the database.
+    /// </summary>
+    /// <param name="conversionType">The type to convert to and from or a type that inherits from <see cref="ValueConverter" />.</param>
     /// <param name="valueComparer">The comparer to use for values before conversion.</param>
     /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
     public new virtual PropertyBuilder<TProperty> HasConversion(
@@ -408,6 +419,20 @@ public new virtual PropertyBuilder<TProperty> HasConversion<TConversion>(ValueCo
         ValueComparer? valueComparer)
         => (PropertyBuilder<TProperty>)base.HasConversion(conversionType, valueComparer);
 
+    /// <summary>
+    ///     Configures the property so that the property value is converted before
+    ///     writing to the database and converted back when reading from the database.
+    /// </summary>
+    /// <param name="conversionType">The type to convert to and from or a type that inherits from <see cref="ValueConverter" />.</param>
+    /// <param name="valueComparer">The comparer to use for values before conversion.</param>
+    /// <param name="providerComparer">The comparer to use for the provider values.</param>
+    /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
+    public new virtual PropertyBuilder<TProperty> HasConversion(
+        Type conversionType,
+        ValueComparer? valueComparer,
+        ValueComparer? providerComparer)
+        => (PropertyBuilder<TProperty>)base.HasConversion(conversionType, valueComparer, providerComparer);
+
     /// <summary>
     ///     Configures the property so that the property value is converted to and from the database
     ///     using the given conversion expressions.
@@ -427,6 +452,28 @@ public new virtual PropertyBuilder<TProperty> HasConversion<TConversion>(ValueCo
                 Check.NotNull(convertFromProviderExpression, nameof(convertFromProviderExpression))),
             valueComparer);
 
+    /// <summary>
+    ///     Configures the property so that the property value is converted to and from the database
+    ///     using the given conversion expressions.
+    /// </summary>
+    /// <typeparam name="TProvider">The store type generated by the conversions.</typeparam>
+    /// <param name="convertToProviderExpression">An expression to convert objects when writing data to the store.</param>
+    /// <param name="convertFromProviderExpression">An expression to convert objects when reading data from the store.</param>
+    /// <param name="valueComparer">The comparer to use for values before conversion.</param>
+    /// <param name="providerComparer">The comparer to use for the provider values.</param>
+    /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
+    public virtual PropertyBuilder<TProperty> HasConversion<TProvider>(
+        Expression<Func<TProperty, TProvider>> convertToProviderExpression,
+        Expression<Func<TProvider, TProperty>> convertFromProviderExpression,
+        ValueComparer? valueComparer,
+        ValueComparer? providerComparer)
+        => HasConversion(
+            new ValueConverter<TProperty, TProvider>(
+                Check.NotNull(convertToProviderExpression, nameof(convertToProviderExpression)),
+                Check.NotNull(convertFromProviderExpression, nameof(convertFromProviderExpression))),
+            valueComparer,
+            providerComparer);
+
     /// <summary>
     ///     Configures the property so that the property value is converted to and from the database
     ///     using the given <see cref="ValueConverter{TModel,TProvider}" />.
@@ -440,6 +487,21 @@ public new virtual PropertyBuilder<TProperty> HasConversion<TConversion>(ValueCo
         ValueComparer? valueComparer)
         => HasConversion((ValueConverter?)converter, valueComparer);
 
+    /// <summary>
+    ///     Configures the property so that the property value is converted to and from the database
+    ///     using the given <see cref="ValueConverter{TModel,TProvider}" />.
+    /// </summary>
+    /// <typeparam name="TProvider">The store type generated by the converter.</typeparam>
+    /// <param name="converter">The converter to use.</param>
+    /// <param name="valueComparer">The comparer to use for values before conversion.</param>
+    /// <param name="providerComparer">The comparer to use for the provider values.</param>
+    /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
+    public virtual PropertyBuilder<TProperty> HasConversion<TProvider>(
+        ValueConverter<TProperty, TProvider>? converter,
+        ValueComparer? valueComparer,
+        ValueComparer? providerComparer)
+        => HasConversion((ValueConverter?)converter, valueComparer, providerComparer);
+
     /// <summary>
     ///     Configures the property so that the property value is converted to and from the database
     ///     using the given <see cref="ValueConverter" />.
@@ -452,12 +514,26 @@ public new virtual PropertyBuilder<TProperty> HasConversion<TConversion>(ValueCo
         ValueComparer? valueComparer)
         => (PropertyBuilder<TProperty>)base.HasConversion(converter, valueComparer);
 
+    /// <summary>
+    ///     Configures the property so that the property value is converted to and from the database
+    ///     using the given <see cref="ValueConverter" />.
+    /// </summary>
+    /// <param name="converter">The converter to use.</param>
+    /// <param name="valueComparer">The comparer to use for values before conversion.</param>
+    /// <param name="providerComparer">The comparer to use for the provider values.</param>
+    /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
+    public new virtual PropertyBuilder<TProperty> HasConversion(
+        ValueConverter? converter,
+        ValueComparer? valueComparer,
+        ValueComparer? providerComparer)
+        => (PropertyBuilder<TProperty>)base.HasConversion(converter, valueComparer, providerComparer);
+
     /// <summary>
     ///     Configures the property so that the property value is converted before
     ///     writing to the database and converted back when reading from the database.
     /// </summary>
-    /// <typeparam name="TConversion">The type to convert to and from or a type that derives from <see cref="ValueConverter" />.</typeparam>
-    /// <typeparam name="TComparer">A type that derives from <see cref="ValueComparer" />.</typeparam>
+    /// <typeparam name="TConversion">The type to convert to and from or a type that inherits from <see cref="ValueConverter" />.</typeparam>
+    /// <typeparam name="TComparer">A type that inherits from <see cref="ValueComparer" />.</typeparam>
     /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
     public new virtual PropertyBuilder<TProperty> HasConversion<TConversion, TComparer>()
         where TComparer : ValueComparer
@@ -467,9 +543,33 @@ public new virtual PropertyBuilder<TProperty> HasConversion<TConversion>(ValueCo
     ///     Configures the property so that the property value is converted before
     ///     writing to the database and converted back when reading from the database.
     /// </summary>
-    /// <param name="conversionType">The type to convert to and from or a type that derives from <see cref="ValueConverter" />.</param>
-    /// <param name="comparerType">A type that derives from <see cref="ValueComparer" />.</param>
+    /// <typeparam name="TConversion">The type to convert to and from or a type that inherits from <see cref="ValueConverter" />.</typeparam>
+    /// <typeparam name="TComparer">A type that inherits from <see cref="ValueComparer" />.</typeparam>
+    /// <typeparam name="TProviderComparer">A type that inherits from <see cref="ValueComparer" /> to use for the provider values.</typeparam>
+    /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
+    public new virtual PropertyBuilder<TProperty> HasConversion<TConversion, TComparer, TProviderComparer>()
+        where TComparer : ValueComparer
+        where TProviderComparer : ValueComparer
+        => (PropertyBuilder<TProperty>)base.HasConversion<TConversion, TComparer, TProviderComparer>();
+
+    /// <summary>
+    ///     Configures the property so that the property value is converted before
+    ///     writing to the database and converted back when reading from the database.
+    /// </summary>
+    /// <param name="conversionType">The type to convert to and from or a type that inherits from <see cref="ValueConverter" />.</param>
+    /// <param name="comparerType">A type that inherits from <see cref="ValueComparer" />.</param>
     /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
     public new virtual PropertyBuilder<TProperty> HasConversion(Type conversionType, Type? comparerType)
         => (PropertyBuilder<TProperty>)base.HasConversion(conversionType, comparerType);
+
+    /// <summary>
+    ///     Configures the property so that the property value is converted before
+    ///     writing to the database and converted back when reading from the database.
+    /// </summary>
+    /// <param name="conversionType">The type to convert to and from or a type that inherits from <see cref="ValueConverter" />.</param>
+    /// <param name="comparerType">A type that inherits from <see cref="ValueComparer" />.</param>
+    /// <param name="providerComparerType">A type that inherits from <see cref="ValueComparer" /> to use for the provider values.</param>
+    /// <returns>The same builder instance so that multiple configuration calls can be chained.</returns>
+    public new virtual PropertyBuilder<TProperty> HasConversion(Type conversionType, Type? comparerType, Type? providerComparerType)
+        => (PropertyBuilder<TProperty>)base.HasConversion(conversionType, comparerType, providerComparerType);
 }
diff --git a/src/EFCore/Metadata/Conventions/RuntimeModelConvention.cs b/src/EFCore/Metadata/Conventions/RuntimeModelConvention.cs
index 93fdd6ccf8..4755df168f 100644
--- a/src/EFCore/Metadata/Conventions/RuntimeModelConvention.cs
+++ b/src/EFCore/Metadata/Conventions/RuntimeModelConvention.cs
@@ -348,6 +348,7 @@ private static RuntimeProperty Create(IProperty property, RuntimeEntityType runt
             property.GetValueConverter(),
             property.GetValueComparer(),
             property.GetKeyValueComparer(),
+            property.GetProviderValueComparer(),
             property.GetTypeMapping());
 
     /// <summary>
diff --git a/src/EFCore/Metadata/IConventionEntityType.cs b/src/EFCore/Metadata/IConventionEntityType.cs
index db0d4e0e7a..60258e7278 100644
--- a/src/EFCore/Metadata/IConventionEntityType.cs
+++ b/src/EFCore/Metadata/IConventionEntityType.cs
@@ -910,7 +910,7 @@ public interface IConventionEntityType : IReadOnlyEntityType, IConventionTypeBas
     ///     <see cref="FindNavigation(string)" /> to find a navigation property.
     /// </remarks>
     /// <param name="name">The property name.</param>
-    /// <returns>The property, or <see langword="null" /> if none is found.</returns>
+    /// <returns>The property.</returns>
     new IConventionProperty GetProperty(string name)
         => (IConventionProperty)((IReadOnlyEntityType)this).GetProperty(name);
 
diff --git a/src/EFCore/Metadata/IConventionProperty.cs b/src/EFCore/Metadata/IConventionProperty.cs
index 4e701938ef..90e00d0c2b 100644
--- a/src/EFCore/Metadata/IConventionProperty.cs
+++ b/src/EFCore/Metadata/IConventionProperty.cs
@@ -338,7 +338,7 @@ bool IsImplicitlyCreated()
     ///     Sets the custom <see cref="ValueConverter" /> for this property.
     /// </summary>
     /// <param name="converterType">
-    ///     A type that derives from <see cref="ValueConverter" />, or <see langword="null" /> to remove any previously set converter.
+    ///     A type that inherits from <see cref="ValueConverter" />, or <see langword="null" /> to remove any previously set converter.
     /// </param>
     /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
     /// <returns>The configured value.</returns>
@@ -376,7 +376,7 @@ bool IsImplicitlyCreated()
     ///     Sets the custom <see cref="ValueComparer" /> for this property.
     /// </summary>
     /// <param name="comparerType">
-    ///     A type that derives from <see cref="ValueComparer" />, or <see langword="null" /> to remove any previously set comparer.
+    ///     A type that inherits from <see cref="ValueComparer" />, or <see langword="null" /> to remove any previously set comparer.
     /// </param>
     /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
     /// <returns>The configured value.</returns>
@@ -387,4 +387,28 @@ bool IsImplicitlyCreated()
     /// </summary>
     /// <returns>The configuration source for <see cref="IReadOnlyProperty.GetValueComparer" />.</returns>
     ConfigurationSource? GetValueComparerConfigurationSource();
+
+    /// <summary>
+    ///     Sets the custom <see cref="ValueComparer" /> to use for the provider values for this property.
+    /// </summary>
+    /// <param name="comparer">The comparer, or <see langword="null" /> to remove any previously set comparer.</param>
+    /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
+    /// <returns>The configured value.</returns>
+    ValueComparer? SetProviderValueComparer(ValueComparer? comparer, bool fromDataAnnotation = false);
+
+    /// <summary>
+    ///     Sets the custom <see cref="ValueComparer" /> to use for the provider values for this property.
+    /// </summary>
+    /// <param name="comparerType">
+    ///     A type that inherits from <see cref="ValueComparer" />, or <see langword="null" /> to remove any previously set comparer.
+    /// </param>
+    /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
+    /// <returns>The configured value.</returns>
+    Type? SetProviderValueComparer(Type? comparerType, bool fromDataAnnotation = false);
+
+    /// <summary>
+    ///     Returns the configuration source for <see cref="IReadOnlyProperty.GetProviderValueComparer" />.
+    /// </summary>
+    /// <returns>The configuration source for <see cref="IReadOnlyProperty.GetProviderValueComparer" />.</returns>
+    ConfigurationSource? GetProviderValueComparerConfigurationSource();
 }
diff --git a/src/EFCore/Metadata/IEntityType.cs b/src/EFCore/Metadata/IEntityType.cs
index 65f21399a5..23a38ca8a8 100644
--- a/src/EFCore/Metadata/IEntityType.cs
+++ b/src/EFCore/Metadata/IEntityType.cs
@@ -458,7 +458,7 @@ public interface IEntityType : IReadOnlyEntityType, ITypeBase
     ///     <see cref="FindNavigation(string)" /> to find a navigation property.
     /// </remarks>
     /// <param name="name">The property name.</param>
-    /// <returns>The property, or <see langword="null" /> if none is found.</returns>
+    /// <returns>The property.</returns>
     new IProperty GetProperty(string name)
         => (IProperty)((IReadOnlyEntityType)this).GetProperty(name);
 
diff --git a/src/EFCore/Metadata/IMutableEntityType.cs b/src/EFCore/Metadata/IMutableEntityType.cs
index 8a0a614cb2..3b1b160c5f 100644
--- a/src/EFCore/Metadata/IMutableEntityType.cs
+++ b/src/EFCore/Metadata/IMutableEntityType.cs
@@ -731,7 +731,7 @@ IMutableIndex AddIndex(IMutableProperty property, string name)
     ///     <see cref="FindNavigation(string)" /> to find a navigation property.
     /// </remarks>
     /// <param name="name">The property name.</param>
-    /// <returns>The property, or <see langword="null" /> if none is found.</returns>
+    /// <returns>The property.</returns>
     new IMutableProperty GetProperty(string name)
         => (IMutableProperty)((IReadOnlyEntityType)this).GetProperty(name);
 
diff --git a/src/EFCore/Metadata/IMutableProperty.cs b/src/EFCore/Metadata/IMutableProperty.cs
index 6377e2dfc9..a253dcf74c 100644
--- a/src/EFCore/Metadata/IMutableProperty.cs
+++ b/src/EFCore/Metadata/IMutableProperty.cs
@@ -235,4 +235,18 @@ public interface IMutableProperty : IReadOnlyProperty, IMutablePropertyBase
     ///     A type that derives from <see cref="ValueComparer" />, or <see langword="null" /> to remove any previously set comparer.
     /// </param>
     void SetValueComparer(Type? comparerType);
+
+    /// <summary>
+    ///     Sets the custom <see cref="ValueComparer" /> to use for the provider values for this property.
+    /// </summary>
+    /// <param name="comparer">The comparer, or <see langword="null" /> to remove any previously set comparer.</param>
+    void SetProviderValueComparer(ValueComparer? comparer);
+
+    /// <summary>
+    ///     Sets the custom <see cref="ValueComparer" /> to use for the provider values for this property.
+    /// </summary>
+    /// <param name="comparerType">
+    ///     A type that derives from <see cref="ValueComparer" />, or <see langword="null" /> to remove any previously set comparer.
+    /// </param>
+    void SetProviderValueComparer(Type? comparerType);
 }
diff --git a/src/EFCore/Metadata/IProperty.cs b/src/EFCore/Metadata/IProperty.cs
index 47aa28b804..6e6edd84b1 100644
--- a/src/EFCore/Metadata/IProperty.cs
+++ b/src/EFCore/Metadata/IProperty.cs
@@ -84,13 +84,17 @@ IEqualityComparer<TProperty> CreateKeyEqualityComparer<TProperty>()
     ///     Gets the <see cref="ValueComparer" /> for this property.
     /// </summary>
     /// <returns>The comparer.</returns>
-    [DebuggerStepThrough]
     new ValueComparer GetValueComparer();
 
     /// <summary>
     ///     Gets the <see cref="ValueComparer" /> to use with keys for this property.
     /// </summary>
     /// <returns>The comparer.</returns>
-    [DebuggerStepThrough]
     new ValueComparer GetKeyValueComparer();
+
+    /// <summary>
+    ///     Gets the <see cref="ValueComparer" /> to use for the provider values for this property.
+    /// </summary>
+    /// <returns>The comparer.</returns>
+    new ValueComparer GetProviderValueComparer();
 }
diff --git a/src/EFCore/Metadata/IReadOnlyEntityType.cs b/src/EFCore/Metadata/IReadOnlyEntityType.cs
index 607b09a60d..f3e53bfee9 100644
--- a/src/EFCore/Metadata/IReadOnlyEntityType.cs
+++ b/src/EFCore/Metadata/IReadOnlyEntityType.cs
@@ -638,7 +638,7 @@ bool IsInOwnershipPath(IReadOnlyEntityType targetType)
     ///     <see cref="FindNavigation(string)" /> to find a navigation property.
     /// </remarks>
     /// <param name="name">The property name.</param>
-    /// <returns>The property, or <see langword="null" /> if none is found.</returns>
+    /// <returns>The property.</returns>
     IReadOnlyProperty GetProperty(string name)
     {
         Check.NotEmpty(name, nameof(name));
diff --git a/src/EFCore/Metadata/IReadOnlyProperty.cs b/src/EFCore/Metadata/IReadOnlyProperty.cs
index 2ea51499b8..5aa4c42f8f 100644
--- a/src/EFCore/Metadata/IReadOnlyProperty.cs
+++ b/src/EFCore/Metadata/IReadOnlyProperty.cs
@@ -155,6 +155,12 @@ CoreTypeMapping GetTypeMapping()
     /// <returns>The comparer, or <see langword="null" /> if none has been set.</returns>
     ValueComparer? GetKeyValueComparer();
 
+    /// <summary>
+    ///     Gets the <see cref="ValueComparer" /> to use for the provider values for this property.
+    /// </summary>
+    /// <returns>The comparer, or <see langword="null" /> if none has been set.</returns>
+    ValueComparer? GetProviderValueComparer();
+
     /// <summary>
     ///     Finds the first principal property that the given property is constrained by
     ///     if the given property is part of a foreign key.
diff --git a/src/EFCore/Metadata/Internal/CoreAnnotationNames.cs b/src/EFCore/Metadata/Internal/CoreAnnotationNames.cs
index ff82e0e45f..1bf90857a0 100644
--- a/src/EFCore/Metadata/Internal/CoreAnnotationNames.cs
+++ b/src/EFCore/Metadata/Internal/CoreAnnotationNames.cs
@@ -139,6 +139,22 @@ public static class CoreAnnotationNames
     /// </summary>
     public const string ValueComparerType = "ValueComparerType";
 
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public const string ProviderValueComparer = "ProviderValueComparer";
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public const string ProviderValueComparerType = "ProviderValueComparerType";
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -300,6 +316,8 @@ public static class CoreAnnotationNames
         ValueConverterType,
         ValueComparer,
         ValueComparerType,
+        ProviderValueComparer,
+        ProviderValueComparerType,
         AfterSaveBehavior,
         BeforeSaveBehavior,
         QueryFilter,
diff --git a/src/EFCore/Metadata/Internal/InternalPropertyBuilder.cs b/src/EFCore/Metadata/Internal/InternalPropertyBuilder.cs
index 755e20eda8..017b116a1b 100644
--- a/src/EFCore/Metadata/Internal/InternalPropertyBuilder.cs
+++ b/src/EFCore/Metadata/Internal/InternalPropertyBuilder.cs
@@ -647,10 +647,56 @@ public virtual bool CanSetValueComparer(Type? comparerType, ConfigurationSource?
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    public virtual InternalPropertyBuilder? HasKeyValueComparer(
+    public virtual InternalPropertyBuilder? HasProviderValueComparer(
         ValueComparer? comparer,
         ConfigurationSource configurationSource)
-        => HasValueComparer(comparer, configurationSource);
+    {
+        if (CanSetProviderValueComparer(comparer, configurationSource))
+        {
+            Metadata.SetProviderValueComparer(comparer, configurationSource);
+
+            return this;
+        }
+
+        return null;
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual bool CanSetProviderValueComparer(ValueComparer? comparer, ConfigurationSource? configurationSource)
+    {
+        if (configurationSource.Overrides(Metadata.GetProviderValueComparerConfigurationSource()))
+        {
+            return true;
+        }
+
+        return Metadata[CoreAnnotationNames.ProviderValueComparerType] == null
+            && Metadata[CoreAnnotationNames.ProviderValueComparer] == comparer;
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual InternalPropertyBuilder? HasProviderValueComparer(
+        Type? comparerType,
+        ConfigurationSource configurationSource)
+    {
+        if (CanSetProviderValueComparer(comparerType, configurationSource))
+        {
+            Metadata.SetProviderValueComparer(comparerType, configurationSource);
+
+            return this;
+        }
+
+        return null;
+    }
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
@@ -658,8 +704,10 @@ public virtual bool CanSetValueComparer(Type? comparerType, ConfigurationSource?
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    public virtual bool CanSetKeyValueComparer(ValueComparer? comparer, ConfigurationSource? configurationSource)
-        => CanSetValueComparer(comparer, configurationSource);
+    public virtual bool CanSetProviderValueComparer(Type? comparerType, ConfigurationSource? configurationSource)
+        => configurationSource.Overrides(Metadata.GetProviderValueComparerConfigurationSource())
+            || (Metadata[CoreAnnotationNames.ProviderValueComparer] == null
+                && (Type?)Metadata[CoreAnnotationNames.ProviderValueComparerType] == comparerType);
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
@@ -1198,4 +1246,40 @@ bool IConventionPropertyBuilder.CanSetValueComparer(ValueComparer? comparer, boo
     /// </summary>
     bool IConventionPropertyBuilder.CanSetValueComparer(Type? comparerType, bool fromDataAnnotation)
         => CanSetValueComparer(comparerType, fromDataAnnotation ? ConfigurationSource.DataAnnotation : ConfigurationSource.Convention);
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    IConventionPropertyBuilder? IConventionPropertyBuilder.HasProviderValueComparer(ValueComparer? comparer, bool fromDataAnnotation)
+        => HasProviderValueComparer(comparer, fromDataAnnotation ? ConfigurationSource.DataAnnotation : ConfigurationSource.Convention);
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    bool IConventionPropertyBuilder.CanSetProviderValueComparer(ValueComparer? comparer, bool fromDataAnnotation)
+        => CanSetProviderValueComparer(comparer, fromDataAnnotation ? ConfigurationSource.DataAnnotation : ConfigurationSource.Convention);
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    IConventionPropertyBuilder? IConventionPropertyBuilder.HasProviderValueComparer(Type? comparerType, bool fromDataAnnotation)
+        => HasProviderValueComparer(comparerType, fromDataAnnotation ? ConfigurationSource.DataAnnotation : ConfigurationSource.Convention);
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    bool IConventionPropertyBuilder.CanSetProviderValueComparer(Type? comparerType, bool fromDataAnnotation)
+        => CanSetProviderValueComparer(comparerType, fromDataAnnotation ? ConfigurationSource.DataAnnotation : ConfigurationSource.Convention);
 }
diff --git a/src/EFCore/Metadata/Internal/Property.cs b/src/EFCore/Metadata/Internal/Property.cs
index 28396b2d38..3679a32197 100644
--- a/src/EFCore/Metadata/Internal/Property.cs
+++ b/src/EFCore/Metadata/Internal/Property.cs
@@ -710,6 +710,10 @@ public virtual PropertySaveBehavior GetAfterSaveBehavior()
     public virtual ConfigurationSource? GetProviderClrTypeConfigurationSource()
         => FindAnnotation(CoreAnnotationNames.ProviderClrType)?.GetConfigurationSource();
 
+    private Type GetEffectiveProviderClrType()
+        => TypeMapping?.Converter?.ProviderClrType
+            ?? ClrType.UnwrapNullableType();
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -814,6 +818,42 @@ public virtual PropertySaveBehavior GetAfterSaveBehavior()
         => ToNullableComparer(GetValueComparer(null)
             ?? TypeMapping?.Comparer);
 
+    private ValueComparer? GetValueComparer(HashSet<IProperty>? checkedProperties)
+    {
+        var comparer = (ValueComparer?)this[CoreAnnotationNames.ValueComparer];
+        if (comparer != null)
+        {
+            return comparer;
+        }
+
+        var principal = (Property?)FindFirstDifferentPrincipal();
+        if (principal == null)
+        {
+            return null;
+        }
+
+        if (checkedProperties == null)
+        {
+            checkedProperties = new HashSet<IProperty>();
+        }
+        else if (checkedProperties.Contains(this))
+        {
+            return null;
+        }
+
+        checkedProperties.Add(this);
+        return principal.GetValueComparer(checkedProperties);
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual ConfigurationSource? GetValueComparerConfigurationSource()
+        => FindAnnotation(CoreAnnotationNames.ValueComparer)?.GetConfigurationSource();
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -824,6 +864,99 @@ public virtual PropertySaveBehavior GetAfterSaveBehavior()
         => ToNullableComparer(GetValueComparer(null)
             ?? TypeMapping?.KeyComparer);
 
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual ValueComparer? SetProviderValueComparer(ValueComparer? comparer, ConfigurationSource configurationSource)
+    {
+        RemoveAnnotation(CoreAnnotationNames.ProviderValueComparerType);
+        return (ValueComparer?)SetOrRemoveAnnotation(CoreAnnotationNames.ProviderValueComparer, comparer, configurationSource)?.Value;
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual Type? SetProviderValueComparer(Type? comparerType, ConfigurationSource configurationSource)
+    {
+        ValueComparer? comparer = null;
+        if (comparerType != null)
+        {
+            if (!typeof(ValueComparer).IsAssignableFrom(comparerType))
+            {
+                throw new InvalidOperationException(
+                    CoreStrings.BadValueComparerType(comparerType.ShortDisplayName(), typeof(ValueComparer).ShortDisplayName()));
+            }
+
+            try
+            {
+                comparer = (ValueComparer?)Activator.CreateInstance(comparerType);
+            }
+            catch (Exception e)
+            {
+                throw new InvalidOperationException(
+                    CoreStrings.CannotCreateValueComparer(
+                        comparerType.ShortDisplayName(), nameof(PropertyBuilder.HasConversion)), e);
+            }
+        }
+
+        SetProviderValueComparer(comparer, configurationSource);
+        return (Type?)SetOrRemoveAnnotation(CoreAnnotationNames.ProviderValueComparerType, comparerType, configurationSource)?.Value;
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual ValueComparer? GetProviderValueComparer()
+        => GetProviderValueComparer(null) ?? (GetEffectiveProviderClrType() == ClrType
+                ? GetKeyValueComparer()
+                : TypeMapping?.ProviderValueComparer);
+
+    private ValueComparer? GetProviderValueComparer(HashSet<IProperty>? checkedProperties)
+    {
+        var comparer = (ValueComparer?)this[CoreAnnotationNames.ProviderValueComparer];
+        if (comparer != null)
+        {
+            return comparer;
+        }
+
+        var principal = (Property?)FindFirstDifferentPrincipal();
+        if (principal == null
+            || principal.GetEffectiveProviderClrType() != GetEffectiveProviderClrType())
+        {
+            return null;
+        }
+
+        if (checkedProperties == null)
+        {
+            checkedProperties = new HashSet<IProperty>();
+        }
+        else if (checkedProperties.Contains(this))
+        {
+            return null;
+        }
+
+        checkedProperties.Add(this);
+        return principal.GetProviderValueComparer(checkedProperties);
+    }
+    
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual ConfigurationSource? GetProviderValueComparerConfigurationSource()
+        => FindAnnotation(CoreAnnotationNames.ProviderValueComparer)?.GetConfigurationSource();
+
     private ValueComparer? ToNullableComparer(ValueComparer? valueComparer)
     {
         if (valueComparer == null
@@ -877,50 +1010,14 @@ public virtual PropertySaveBehavior GetAfterSaveBehavior()
                     Expression.Default(ClrType)),
                 newSnapshotParam))!;
     }
-
-    private ValueComparer? GetValueComparer(HashSet<IProperty>? checkedProperties)
-    {
-        var comparer = (ValueComparer?)this[CoreAnnotationNames.ValueComparer];
-        if (comparer != null)
-        {
-            return comparer;
-        }
-
-        var principal = ((Property?)FindFirstDifferentPrincipal());
-        if (principal == null)
-        {
-            return null;
-        }
-
-        if (checkedProperties == null)
-        {
-            checkedProperties = new HashSet<IProperty>();
-        }
-        else if (checkedProperties.Contains(this))
-        {
-            return null;
-        }
-
-        checkedProperties.Add(this);
-        return principal.GetValueComparer(checkedProperties);
-    }
-
+    
     private IProperty? FindFirstDifferentPrincipal()
     {
         var principal = ((IProperty)this).FindFirstPrincipal();
 
         return principal != this ? principal : null;
     }
-
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public virtual ConfigurationSource? GetValueComparerConfigurationSource()
-        => FindAnnotation(CoreAnnotationNames.ValueComparer)?.GetConfigurationSource();
-
+    
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -1655,4 +1752,58 @@ ValueComparer IProperty.GetValueComparer()
     /// </summary>
     ValueComparer IProperty.GetKeyValueComparer()
         => GetKeyValueComparer()!;
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    [DebuggerStepThrough]
+    void IMutableProperty.SetProviderValueComparer(ValueComparer? comparer)
+        => SetProviderValueComparer(comparer, ConfigurationSource.Explicit);
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    [DebuggerStepThrough]
+    ValueComparer? IConventionProperty.SetProviderValueComparer(ValueComparer? comparer, bool fromDataAnnotation)
+        => SetProviderValueComparer(
+            comparer,
+            fromDataAnnotation ? ConfigurationSource.DataAnnotation : ConfigurationSource.Convention);
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    [DebuggerStepThrough]
+    void IMutableProperty.SetProviderValueComparer(Type? comparerType)
+        => SetProviderValueComparer(comparerType, ConfigurationSource.Explicit);
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    [DebuggerStepThrough]
+    Type? IConventionProperty.SetProviderValueComparer(Type? comparerType, bool fromDataAnnotation)
+        => SetProviderValueComparer(
+            comparerType,
+            fromDataAnnotation ? ConfigurationSource.DataAnnotation : ConfigurationSource.Convention);
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    [DebuggerStepThrough]
+    ValueComparer IProperty.GetProviderValueComparer()
+        => GetProviderValueComparer()!;
 }
diff --git a/src/EFCore/Metadata/Internal/PropertyConfiguration.cs b/src/EFCore/Metadata/Internal/PropertyConfiguration.cs
index 7abe702985..106bd65591 100644
--- a/src/EFCore/Metadata/Internal/PropertyConfiguration.cs
+++ b/src/EFCore/Metadata/Internal/PropertyConfiguration.cs
@@ -77,6 +77,13 @@ public virtual void Apply(IMutableProperty property)
                         property.SetValueComparer((Type?)annotation.Value);
                     }
 
+                    break;
+                case CoreAnnotationNames.ProviderValueComparerType:
+                    if (ClrType.UnwrapNullableType() == property.ClrType.UnwrapNullableType())
+                    {
+                        property.SetProviderValueComparer((Type?)annotation.Value);
+                    }
+
                     break;
                 default:
                     if (!CoreAnnotationNames.AllNames.Contains(annotation.Name))
@@ -259,4 +266,24 @@ public virtual void SetValueComparer(Type? comparerType)
 
         this[CoreAnnotationNames.ValueComparerType] = comparerType;
     }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual void SetProviderValueComparer(Type? comparerType)
+    {
+        if (comparerType != null)
+        {
+            if (!typeof(ValueComparer).IsAssignableFrom(comparerType))
+            {
+                throw new InvalidOperationException(
+                    CoreStrings.BadValueComparerType(comparerType.ShortDisplayName(), typeof(ValueComparer).ShortDisplayName()));
+            }
+        }
+
+        this[CoreAnnotationNames.ProviderValueComparerType] = comparerType;
+    }
 }
diff --git a/src/EFCore/Metadata/RuntimeEntityType.cs b/src/EFCore/Metadata/RuntimeEntityType.cs
index 021fdad507..ada954cb6b 100644
--- a/src/EFCore/Metadata/RuntimeEntityType.cs
+++ b/src/EFCore/Metadata/RuntimeEntityType.cs
@@ -583,6 +583,7 @@ private IEnumerable<RuntimeIndex> GetIndexes()
     /// <param name="valueConverter">The custom <see cref="ValueConverter" /> set for this property.</param>
     /// <param name="valueComparer">The <see cref="ValueComparer" /> for this property.</param>
     /// <param name="keyValueComparer">The <see cref="ValueComparer" /> to use with keys for this property.</param>
+    /// <param name="providerValueComparer">The <see cref="ValueComparer" /> to use for the provider values for this property.</param>
     /// <param name="typeMapping">The <see cref="CoreTypeMapping" /> for this property.</param>
     /// <returns>The newly created property.</returns>
     public virtual RuntimeProperty AddProperty(
@@ -605,6 +606,7 @@ private IEnumerable<RuntimeIndex> GetIndexes()
         ValueConverter? valueConverter = null,
         ValueComparer? valueComparer = null,
         ValueComparer? keyValueComparer = null,
+        ValueComparer? providerValueComparer = null,
         CoreTypeMapping? typeMapping = null)
     {
         var property = new RuntimeProperty(
@@ -628,6 +630,7 @@ private IEnumerable<RuntimeIndex> GetIndexes()
             valueConverter,
             valueComparer,
             keyValueComparer,
+            providerValueComparer,
             typeMapping);
 
         _properties.Add(property.Name, property);
diff --git a/src/EFCore/Metadata/RuntimeProperty.cs b/src/EFCore/Metadata/RuntimeProperty.cs
index 9bcc9281e3..94ffdcd29e 100644
--- a/src/EFCore/Metadata/RuntimeProperty.cs
+++ b/src/EFCore/Metadata/RuntimeProperty.cs
@@ -23,6 +23,7 @@ public class RuntimeProperty : RuntimePropertyBase, IProperty
     private readonly ValueConverter? _valueConverter;
     private readonly ValueComparer? _valueComparer;
     private readonly ValueComparer? _keyValueComparer;
+    private readonly ValueComparer? _providerValueComparer;
     private CoreTypeMapping? _typeMapping;
 
     /// <summary>
@@ -53,6 +54,7 @@ public class RuntimeProperty : RuntimePropertyBase, IProperty
         ValueConverter? valueConverter,
         ValueComparer? valueComparer,
         ValueComparer? keyValueComparer,
+        ValueComparer? providerValueComparer,
         CoreTypeMapping? typeMapping)
         : base(name, propertyInfo, fieldInfo, propertyAccessMode)
     {
@@ -94,6 +96,7 @@ public class RuntimeProperty : RuntimePropertyBase, IProperty
         _typeMapping = typeMapping;
         _valueComparer = valueComparer;
         _keyValueComparer = keyValueComparer ?? valueComparer;
+        _providerValueComparer = providerValueComparer;
     }
 
     /// <summary>
@@ -288,6 +291,16 @@ ValueComparer IProperty.GetValueComparer()
     ValueComparer IProperty.GetKeyValueComparer()
         => _keyValueComparer ?? TypeMapping.KeyComparer;
 
+    /// <inheritdoc />
+    [DebuggerStepThrough]
+    ValueComparer? IReadOnlyProperty.GetProviderValueComparer()
+        => _providerValueComparer ?? TypeMapping.ProviderValueComparer;
+
+    /// <inheritdoc />
+    [DebuggerStepThrough]
+    ValueComparer IProperty.GetProviderValueComparer()
+        => _providerValueComparer ?? TypeMapping.ProviderValueComparer;
+
     /// <inheritdoc />
     [DebuggerStepThrough]
     bool IReadOnlyProperty.IsForeignKey()
diff --git a/src/EFCore/Storage/CoreTypeMapping.cs b/src/EFCore/Storage/CoreTypeMapping.cs
index 0e9b99ac0c..d80348b498 100644
--- a/src/EFCore/Storage/CoreTypeMapping.cs
+++ b/src/EFCore/Storage/CoreTypeMapping.cs
@@ -23,7 +23,7 @@ public abstract class CoreTypeMapping
     /// <summary>
     ///     Parameter object for use in the <see cref="CoreTypeMapping" /> hierarchy.
     /// </summary>
-    protected readonly struct CoreTypeMappingParameters
+    protected readonly record struct CoreTypeMappingParameters
     {
         /// <summary>
         ///     Creates a new <see cref="CoreTypeMappingParameters" /> parameter object.
@@ -32,40 +32,48 @@ public abstract class CoreTypeMapping
         /// <param name="converter">Converts types to and from the store whenever this mapping is used.</param>
         /// <param name="comparer">Supports custom value snapshotting and comparisons.</param>
         /// <param name="keyComparer">Supports custom comparisons between keys--e.g. PK to FK comparison.</param>
+        /// <param name="providerValueComparer">Supports custom comparisons between converted provider values.</param>
         /// <param name="valueGeneratorFactory">An optional factory for creating a specific <see cref="ValueGenerator" />.</param>
         public CoreTypeMappingParameters(
             Type clrType,
             ValueConverter? converter = null,
             ValueComparer? comparer = null,
             ValueComparer? keyComparer = null,
+            ValueComparer? providerValueComparer = null,
             Func<IProperty, IEntityType, ValueGenerator>? valueGeneratorFactory = null)
         {
             ClrType = clrType;
             Converter = converter;
             Comparer = comparer;
             KeyComparer = keyComparer;
+            ProviderValueComparer = providerValueComparer;
             ValueGeneratorFactory = valueGeneratorFactory;
         }
 
         /// <summary>
         ///     The mapping CLR type.
         /// </summary>
-        public Type ClrType { get; }
+        public Type ClrType { get; init; }
 
         /// <summary>
         ///     The mapping converter.
         /// </summary>
-        public ValueConverter? Converter { get; }
+        public ValueConverter? Converter { get; init; }
 
         /// <summary>
         ///     The mapping comparer.
         /// </summary>
-        public ValueComparer? Comparer { get; }
+        public ValueComparer? Comparer { get; init; }
 
         /// <summary>
         ///     The mapping key comparer.
         /// </summary>
-        public ValueComparer? KeyComparer { get; }
+        public ValueComparer? KeyComparer { get; init; }
+
+        /// <summary>
+        ///     The provider comparer.
+        /// </summary>
+        public ValueComparer? ProviderValueComparer { get; init; }
 
         /// <summary>
         ///     An optional factory for creating a specific <see cref="ValueGenerator" /> to use with
@@ -85,11 +93,13 @@ public CoreTypeMappingParameters WithComposedConverter(ValueConverter? converter
                 converter == null ? Converter : converter.ComposeWith(Converter),
                 Comparer,
                 KeyComparer,
+                ProviderValueComparer,
                 ValueGeneratorFactory);
     }
 
     private ValueComparer? _comparer;
     private ValueComparer? _keyComparer;
+    private ValueComparer? _providerValueComparer;
 
     /// <summary>
     ///     Initializes a new instance of the <see cref="CoreTypeMapping" /> class.
@@ -106,10 +116,9 @@ protected CoreTypeMapping(CoreTypeMappingParameters parameters)
 
         Check.DebugAssert(
             parameters.Comparer == null
-            || parameters.ClrType == null
             || converter != null
-            || parameters.Comparer.Type == parameters.ClrType,
-            $"Expected {parameters.ClrType}, got {parameters.Comparer?.Type}");
+            || parameters.Comparer.Type == clrType,
+            $"Expected {clrType}, got {parameters.Comparer?.Type}");
         if (parameters.Comparer?.Type == clrType)
         {
             _comparer = parameters.Comparer;
@@ -117,7 +126,6 @@ protected CoreTypeMapping(CoreTypeMappingParameters parameters)
 
         Check.DebugAssert(
             parameters.KeyComparer == null
-            || parameters.ClrType == null
             || converter != null
             || parameters.KeyComparer.Type == parameters.ClrType,
             $"Expected {parameters.ClrType}, got {parameters.KeyComparer?.Type}");
@@ -126,6 +134,15 @@ protected CoreTypeMapping(CoreTypeMappingParameters parameters)
             _keyComparer = parameters.KeyComparer;
         }
 
+        Check.DebugAssert(
+            parameters.ProviderValueComparer == null
+            || parameters.ProviderValueComparer.Type == (converter?.ProviderClrType ?? clrType),
+            $"Expected {converter?.ProviderClrType ?? clrType}, got {parameters.ProviderValueComparer?.Type}");
+        if (parameters.ProviderValueComparer?.Type == (converter?.ProviderClrType ?? clrType))
+        {
+            _providerValueComparer = parameters.ProviderValueComparer;
+        }
+
         ValueGeneratorFactory = parameters.ValueGeneratorFactory
             ?? converter?.MappingHints?.ValueGeneratorFactory;
     }
@@ -174,6 +191,17 @@ public virtual ValueComparer KeyComparer
             this,
             static c => ValueComparer.CreateDefault(c.ClrType, favorStructuralComparisons: true));
 
+    /// <summary>
+    ///     A <see cref="ValueComparer" /> for the provider CLR type values.
+    /// </summary>
+    public virtual ValueComparer ProviderValueComparer
+        => NonCapturingLazyInitializer.EnsureInitialized(
+            ref _providerValueComparer,
+            this,
+            static c => (c.Converter?.ProviderClrType ?? c.ClrType) == c.ClrType
+                    ? c.KeyComparer
+                    : ValueComparer.CreateDefault(c.Converter?.ProviderClrType ?? c.ClrType, favorStructuralComparisons: true));
+
     /// <summary>
     ///     Returns a new copy of this type mapping with the given <see cref="ValueConverter" />
     ///     added.
diff --git a/test/EFCore.Cosmos.Tests/ModelBuilding/CosmosModelBuilderGenericTest.cs b/test/EFCore.Cosmos.Tests/ModelBuilding/CosmosModelBuilderGenericTest.cs
index c96217b571..c486739e8c 100644
--- a/test/EFCore.Cosmos.Tests/ModelBuilding/CosmosModelBuilderGenericTest.cs
+++ b/test/EFCore.Cosmos.Tests/ModelBuilding/CosmosModelBuilderGenericTest.cs
@@ -48,7 +48,7 @@ public override void Properties_can_have_provider_type_set_for_type()
                     b.Property(e => e.Down);
                     b.Property<int>("Charm");
                     b.Property<string>("Strange");
-                    b.Property<string>("__id").HasConversion((Type)null);
+                    b.Property<string>("__id").HasConversion(null);
                 });
 
             var model = modelBuilder.FinalizeModel();
diff --git a/test/EFCore.Design.Tests/Scaffolding/Internal/CSharpRuntimeModelCodeGeneratorTest.cs b/test/EFCore.Design.Tests/Scaffolding/Internal/CSharpRuntimeModelCodeGeneratorTest.cs
index 03cdc62567..89b102108f 100644
--- a/test/EFCore.Design.Tests/Scaffolding/Internal/CSharpRuntimeModelCodeGeneratorTest.cs
+++ b/test/EFCore.Design.Tests/Scaffolding/Internal/CSharpRuntimeModelCodeGeneratorTest.cs
@@ -349,6 +349,29 @@ public override int GetHashCode(object instance)
             public override object Snapshot(object instance)
                 => throw new NotImplementedException();
         }
+        
+        [ConditionalFact]
+        public void Throws_for_provider_value_comparer()
+            => Test(
+                new ProviderValueComparerContext(),
+                new CompiledModelCodeGenerationOptions(),
+                expectedExceptionMessage: DesignStrings.CompiledModelValueComparer(
+                    "MyEntity", "Id", nameof(PropertyBuilder.HasConversion)));
+
+        public class ProviderValueComparerContext : ContextBase
+        {
+            protected override void OnModelCreating(ModelBuilder modelBuilder)
+            {
+                base.OnModelCreating(modelBuilder);
+
+                modelBuilder.Entity(
+                    "MyEntity", e =>
+                    {
+                        e.Property<int>("Id").HasConversion(typeof(int), null, new FakeValueComparer());
+                        e.HasKey("Id");
+                    });
+            }
+        }
 
         [ConditionalFact]
         public void Throws_for_custom_type_mapping()
@@ -367,7 +390,7 @@ protected override void OnModelCreating(ModelBuilder modelBuilder)
                 modelBuilder.Entity(
                     "MyEntity", e =>
                     {
-                        e.Property<int>("Id").Metadata.SetTypeMapping(new InMemoryTypeMapping(typeof(int[])));
+                        e.Property<int>("Id").Metadata.SetTypeMapping(new InMemoryTypeMapping(typeof(int)));
                         e.HasKey("Id");
                     });
             }
@@ -1083,7 +1106,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType? ba
                 valueGenerated: ValueGenerated.OnAdd,
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 valueConverter: new CastingConverter<Point, Point>(),
-                valueComparer: new CSharpRuntimeModelCodeGeneratorTest.CustomValueComparer<Point>());
+                valueComparer: new CSharpRuntimeModelCodeGeneratorTest.CustomValueComparer<Point>(),
+                providerValueComparer: new CSharpRuntimeModelCodeGeneratorTest.CustomValueComparer<Point>());
             alternateId.AddAnnotation(""Relational:ColumnType"", ""geometry"");
             alternateId.AddAnnotation(""Relational:DefaultValue"", (NetTopologySuite.Geometries.Point)new NetTopologySuite.IO.WKTReader().Read(""SRID=0;POINT Z(0 0 0)""));
             alternateId.AddAnnotation(""SqlServer:ValueGenerationStrategy"", SqlServerValueGenerationStrategy.None);
@@ -1674,6 +1698,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
                     Assert.IsType<CastingConverter<Point, Point>>(principalAlternateId.GetValueConverter());
                     Assert.IsType<CustomValueComparer<Point>>(principalAlternateId.GetValueComparer());
                     Assert.IsType<CustomValueComparer<Point>>(principalAlternateId.GetKeyValueComparer());
+                    Assert.IsType<CustomValueComparer<Point>>(principalAlternateId.GetProviderValueComparer());
                     Assert.Equal(SqlServerValueGenerationStrategy.None, principalAlternateId.GetValueGenerationStrategy());
                     Assert.Equal(PropertyAccessMode.FieldDuringConstruction, principalAlternateId.GetPropertyAccessMode());
                     Assert.Null(principalAlternateId[CoreAnnotationNames.PropertyAccessMode]);
@@ -2049,7 +2074,7 @@ protected override void OnModelCreating(ModelBuilder modelBuilder)
                             .HasColumnType("geometry")
                             .HasDefaultValue(
                                 NtsGeometryServices.Instance.CreateGeometryFactory(srid: 0).CreatePoint(new CoordinateZM(0, 0, 0, 0)))
-                            .HasConversion<CastingConverter<Point, Point>, CustomValueComparer<Point>>();
+                            .HasConversion<CastingConverter<Point, Point>, CustomValueComparer<Point>, CustomValueComparer<Point>>();
 
                         eb.HasIndex(e => e.AlternateId, "AlternateIndex")
                             .IsUnique()
diff --git a/test/EFCore.Relational.Tests/Migrations/Internal/MigrationsModelDifferTest.cs b/test/EFCore.Relational.Tests/Migrations/Internal/MigrationsModelDifferTest.cs
index d111d6e98e..d7b88032f3 100644
--- a/test/EFCore.Relational.Tests/Migrations/Internal/MigrationsModelDifferTest.cs
+++ b/test/EFCore.Relational.Tests/Migrations/Internal/MigrationsModelDifferTest.cs
@@ -9842,6 +9842,44 @@ public void SeedData_binary_change()
                         v => Assert.Equal(new byte[] { 2, 1 }, v));
                 }));
 
+    [ConditionalFact]
+    public void SeedData_binary_change_custom_comparer()
+        => Execute(
+            source => source.Entity(
+                "EntityWithTwoProperties",
+                x =>
+                {
+                    x.Property<int>("Id");
+                    x.Property<byte[]>("Value1").HasConversion(typeof(byte[]), null, new RightmostValueComparer());
+                }),
+            source => source.Entity(
+                "EntityWithTwoProperties",
+                x =>
+                {
+                    x.HasData(
+                        new { Id = 42, Value1 = new byte[] { 0, 1 } });
+                }),
+            target => target.Entity(
+                "EntityWithTwoProperties",
+                x =>
+                {
+                    x.HasData(
+                        new { Id = 42, Value1 = new byte[] { 1 } });
+                }),
+            upOps => Assert.Empty(upOps),
+            downOps => Assert.Empty(downOps));
+
+    private class RightmostValueComparer : ValueComparer<byte[]>
+    {
+        public RightmostValueComparer()
+            : base(false)
+        {
+        }
+
+        public override bool Equals(byte[] left, byte[] right)
+            => object.Equals(left[^1], right[^1]);
+    }
+
     [ConditionalFact]
     public void SeedData_binary_no_change()
         => Execute(
diff --git a/test/EFCore.Relational.Tests/Storage/RelationalTypeMappingTest.cs b/test/EFCore.Relational.Tests/Storage/RelationalTypeMappingTest.cs
index 6f8d327a52..dd1888c36a 100644
--- a/test/EFCore.Relational.Tests/Storage/RelationalTypeMappingTest.cs
+++ b/test/EFCore.Relational.Tests/Storage/RelationalTypeMappingTest.cs
@@ -8,27 +8,39 @@ namespace Microsoft.EntityFrameworkCore.Storage;
 
 public abstract class RelationalTypeMappingTest
 {
-    protected class FakeValueConverter : ValueConverter<object, object>
+    protected class FakeValueConverter<TModel, TProvider> : ValueConverter<TModel, TProvider>
     {
         public FakeValueConverter()
-            : base(_ => _, _ => _)
+            : base(_ => (TProvider)(object)_, _ => (TModel)(object)_)
         {
         }
 
-        public override Type ModelClrType { get; } = typeof(object);
-        public override Type ProviderClrType { get; } = typeof(object);
+        public override Type ModelClrType { get; } = typeof(TModel);
+        public override Type ProviderClrType { get; } = typeof(TProvider);
     }
 
-    protected class FakeValueComparer : ValueComparer<object>
+    protected class FakeValueComparer<T> : ValueComparer<T>
     {
         public FakeValueComparer()
             : base(false)
         {
         }
 
-        public override Type Type { get; } = typeof(object);
+        public override Type Type { get; } = typeof(T);
     }
 
+    public static ValueConverter CreateConverter(Type modelType)
+        => (ValueConverter)Activator.CreateInstance(
+                typeof(FakeValueConverter<,>).MakeGenericType(modelType, typeof(object)));
+
+    public static ValueConverter CreateConverter(Type modelType, Type providerType)
+        => (ValueConverter)Activator.CreateInstance(
+                typeof(FakeValueConverter<,>).MakeGenericType(modelType, providerType));
+
+    public static ValueComparer CreateComparer(Type type)
+        => (ValueComparer)Activator.CreateInstance(
+                typeof(FakeValueComparer<>).MakeGenericType(type));
+
     [ConditionalTheory]
     [InlineData(typeof(BoolTypeMapping), typeof(bool))]
     [InlineData(typeof(ByteTypeMapping), typeof(byte))]
@@ -68,10 +80,10 @@ public virtual void Create_and_clone_with_converter(Type mappingType, Type type)
         Assert.Same(mapping.Converter, clone.Converter);
         Assert.Same(mapping.Comparer, clone.Comparer);
         Assert.Same(mapping.KeyComparer, clone.KeyComparer);
-        Assert.Same(typeof(object), clone.ClrType);
+        Assert.Same(type, clone.ClrType);
         Assert.Equal(StoreTypePostfix.PrecisionAndScale, clone.StoreTypePostfix);
 
-        var newConverter = new FakeValueConverter();
+        var newConverter = CreateConverter(typeof(object), type);
         clone = (RelationalTypeMapping)mapping.Clone(newConverter);
 
         Assert.NotSame(mapping, clone);
@@ -80,8 +92,9 @@ public virtual void Create_and_clone_with_converter(Type mappingType, Type type)
         Assert.Equal(DbType.VarNumeric, clone.DbType);
         Assert.Null(clone.Size);
         Assert.NotSame(mapping.Converter, clone.Converter);
-        Assert.Same(mapping.Comparer, clone.Comparer);
-        Assert.Same(mapping.KeyComparer, clone.KeyComparer);
+        Assert.NotSame(mapping.Comparer, clone.Comparer);
+        Assert.NotSame(mapping.KeyComparer, clone.KeyComparer);
+        Assert.Same(mapping.ProviderValueComparer, clone.ProviderValueComparer);
         Assert.Same(typeof(object), clone.ClrType);
         Assert.Equal(StoreTypePostfix.PrecisionAndScale, clone.StoreTypePostfix);
     }
@@ -123,12 +136,13 @@ public virtual void Create_and_clone_sized_mappings_with_converter()
         Assert.Same(mapping.Converter, clone.Converter);
         Assert.Same(mapping.Comparer, clone.Comparer);
         Assert.Same(mapping.KeyComparer, clone.KeyComparer);
-        Assert.Same(typeof(object), clone.ClrType);
+        Assert.Same(mapping.ProviderValueComparer, clone.ProviderValueComparer);
+        Assert.Same(type, clone.ClrType);
         Assert.True(mapping.IsFixedLength);
         Assert.True(clone.IsFixedLength);
         Assert.Equal(StoreTypePostfix.Size, clone.StoreTypePostfix);
 
-        var newConverter = new FakeValueConverter();
+        var newConverter = CreateConverter(typeof(object), type);
         clone = (RelationalTypeMapping)mapping.Clone(newConverter);
 
         Assert.NotSame(mapping, clone);
@@ -139,8 +153,9 @@ public virtual void Create_and_clone_sized_mappings_with_converter()
         Assert.Equal(33, mapping.Size);
         Assert.Equal(33, clone.Size);
         Assert.NotSame(mapping.Converter, clone.Converter);
-        Assert.Same(mapping.Comparer, clone.Comparer);
-        Assert.Same(mapping.KeyComparer, clone.KeyComparer);
+        Assert.NotSame(mapping.Comparer, clone.Comparer);
+        Assert.NotSame(mapping.KeyComparer, clone.KeyComparer);
+        Assert.Same(mapping.ProviderValueComparer, clone.ProviderValueComparer);
         Assert.Same(typeof(object), clone.ClrType);
         Assert.True(mapping.IsFixedLength);
         Assert.True(clone.IsFixedLength);
@@ -187,12 +202,13 @@ public virtual void Create_and_clone_unicode_sized_mappings_with_converter()
         Assert.Same(mapping.Converter, clone.Converter);
         Assert.Same(mapping.Comparer, clone.Comparer);
         Assert.Same(mapping.KeyComparer, clone.KeyComparer);
-        Assert.Same(typeof(object), clone.ClrType);
+        Assert.Same(mapping.ProviderValueComparer, clone.ProviderValueComparer);
+        Assert.Same(type, clone.ClrType);
         Assert.True(mapping.IsFixedLength);
         Assert.True(clone.IsFixedLength);
         Assert.Equal(StoreTypePostfix.Size, clone.StoreTypePostfix);
 
-        var newConverter = new FakeValueConverter();
+        var newConverter = CreateConverter(typeof(object), type);
         clone = (RelationalTypeMapping)mapping.Clone(newConverter);
 
         Assert.NotSame(mapping, clone);
@@ -205,8 +221,9 @@ public virtual void Create_and_clone_unicode_sized_mappings_with_converter()
         Assert.False(mapping.IsUnicode);
         Assert.False(clone.IsUnicode);
         Assert.NotSame(mapping.Converter, clone.Converter);
-        Assert.Same(mapping.Comparer, clone.Comparer);
-        Assert.Same(mapping.KeyComparer, clone.KeyComparer);
+        Assert.NotSame(mapping.Comparer, clone.Comparer);
+        Assert.NotSame(mapping.KeyComparer, clone.KeyComparer);
+        Assert.Same(mapping.ProviderValueComparer, clone.ProviderValueComparer);
         Assert.Same(typeof(object), clone.ClrType);
         Assert.True(mapping.IsFixedLength);
         Assert.True(clone.IsFixedLength);
@@ -234,9 +251,10 @@ public FakeTypeMapping()
             => new RelationalTypeMappingParameters(
                 new CoreTypeMappingParameters(
                     type,
-                    new FakeValueConverter(),
-                    new FakeValueComparer(),
-                    new FakeValueComparer()),
+                    CreateConverter(type),
+                    CreateComparer(type),
+                    CreateComparer(type),
+                    CreateComparer(typeof(object))),
                 "<original>",
                 storeTypePostfix,
                 System.Data.DbType.VarNumeric,
diff --git a/test/EFCore.Specification.Tests/CustomConvertersTestBase.cs b/test/EFCore.Specification.Tests/CustomConvertersTestBase.cs
index cd639c580e..870a0086f1 100644
--- a/test/EFCore.Specification.Tests/CustomConvertersTestBase.cs
+++ b/test/EFCore.Specification.Tests/CustomConvertersTestBase.cs
@@ -254,7 +254,7 @@ public Fuel(double volume)
         public double Volume { get; }
     }
 
-    [ConditionalFact(Skip = "Issue #27738")]
+    [ConditionalFact]
     public virtual void Can_insert_and_read_back_with_case_insensitive_string_key()
     {
         using (var context = CreateContext())
diff --git a/test/EFCore.SqlServer.FunctionalTests/CustomConvertersSqlServerTest.cs b/test/EFCore.SqlServer.FunctionalTests/CustomConvertersSqlServerTest.cs
index fe0cd97d6b..4493b30ed0 100644
--- a/test/EFCore.SqlServer.FunctionalTests/CustomConvertersSqlServerTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/CustomConvertersSqlServerTest.cs
@@ -1,8 +1,6 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-
-
 // ReSharper disable InconsistentNaming
 namespace Microsoft.EntityFrameworkCore;
 
diff --git a/test/EFCore.SqlServer.Tests/Storage/SqlServerTypeMappingTest.cs b/test/EFCore.SqlServer.Tests/Storage/SqlServerTypeMappingTest.cs
index 44f0af461f..8995c2a5a9 100644
--- a/test/EFCore.SqlServer.Tests/Storage/SqlServerTypeMappingTest.cs
+++ b/test/EFCore.SqlServer.Tests/Storage/SqlServerTypeMappingTest.cs
@@ -111,9 +111,9 @@ public virtual void Create_and_clone_UDT_mapping_with_converter()
             literalGenerator,
             StoreTypePostfix.None,
             "udtType",
-            new FakeValueConverter(),
-            new FakeValueComparer(),
-            new FakeValueComparer(),
+            CreateConverter(typeof(object)),
+            CreateComparer(typeof(object)),
+            CreateComparer(typeof(object)),
             DbType.VarNumeric,
             false,
             33,
@@ -141,7 +141,7 @@ public virtual void Create_and_clone_UDT_mapping_with_converter()
         Assert.True(clone.IsFixedLength);
         Assert.Same(literalGenerator, clone.LiteralGenerator);
 
-        var newConverter = new FakeValueConverter();
+        var newConverter = CreateConverter(typeof(object));
         clone = (SqlServerUdtTypeMapping)mapping.Clone(newConverter);
 
         Assert.NotSame(mapping, clone);
diff --git a/test/EFCore.Tests/Metadata/Internal/ClrPropertyGetterFactoryTest.cs b/test/EFCore.Tests/Metadata/Internal/ClrPropertyGetterFactoryTest.cs
index 6d90df406f..85830b7be1 100644
--- a/test/EFCore.Tests/Metadata/Internal/ClrPropertyGetterFactoryTest.cs
+++ b/test/EFCore.Tests/Metadata/Internal/ClrPropertyGetterFactoryTest.cs
@@ -75,6 +75,9 @@ public ValueComparer GetValueComparer()
         public ValueComparer GetKeyValueComparer()
             => throw new NotImplementedException();
 
+        public ValueComparer GetProviderValueComparer()
+            => throw new NotImplementedException();
+
         public bool IsForeignKey()
             => throw new NotImplementedException();
 
diff --git a/test/EFCore.Tests/Metadata/Internal/ClrPropertySetterFactoryTest.cs b/test/EFCore.Tests/Metadata/Internal/ClrPropertySetterFactoryTest.cs
index 582ed68105..28597c008f 100644
--- a/test/EFCore.Tests/Metadata/Internal/ClrPropertySetterFactoryTest.cs
+++ b/test/EFCore.Tests/Metadata/Internal/ClrPropertySetterFactoryTest.cs
@@ -92,6 +92,9 @@ public ValueComparer GetValueComparer()
         public ValueComparer GetKeyValueComparer()
             => throw new NotImplementedException();
 
+        public ValueComparer GetProviderValueComparer()
+            => throw new NotImplementedException();
+
         public bool IsForeignKey()
             => throw new NotImplementedException();
 
diff --git a/test/EFCore.Tests/Metadata/Internal/InternalPropertyBuilderTest.cs b/test/EFCore.Tests/Metadata/Internal/InternalPropertyBuilderTest.cs
index a1f1f31cc7..c626791aba 100644
--- a/test/EFCore.Tests/Metadata/Internal/InternalPropertyBuilderTest.cs
+++ b/test/EFCore.Tests/Metadata/Internal/InternalPropertyBuilderTest.cs
@@ -395,6 +395,32 @@ public CustomValueComparer()
         }
     }
 
+    [ConditionalFact]
+    public void Can_only_override_lower_or_equal_source_ProviderValueComparer()
+    {
+        var builder = CreateInternalPropertyBuilder();
+        var metadata = builder.Metadata;
+
+        Assert.NotNull(builder.HasProviderValueComparer(new CustomValueComparer<string>(), ConfigurationSource.DataAnnotation));
+        Assert.NotNull(builder.HasProviderValueComparer(new ValueComparer<string>(false), ConfigurationSource.DataAnnotation));
+
+        Assert.IsType<ValueComparer<string>>(metadata.GetProviderValueComparer());
+
+        Assert.Null(builder.HasProviderValueComparer(new CustomValueComparer<string>(), ConfigurationSource.Convention));
+        Assert.IsType<ValueComparer<string>>(metadata.GetProviderValueComparer());
+
+        Assert.Null(builder.HasProviderValueComparer(typeof(CustomValueComparer<string>), ConfigurationSource.Convention));
+        Assert.IsType<ValueComparer<string>>(metadata.GetProviderValueComparer());
+
+        Assert.NotNull(builder.HasProviderValueComparer(typeof(CustomValueComparer<string>), ConfigurationSource.DataAnnotation));
+        Assert.IsType<CustomValueComparer<string>>(metadata.GetProviderValueComparer());
+
+        Assert.NotNull(builder.HasProviderValueComparer((ValueComparer)null, ConfigurationSource.DataAnnotation));
+        Assert.Null(metadata.GetProviderValueComparer());
+        Assert.Null(metadata[CoreAnnotationNames.ProviderValueComparer]);
+        Assert.Null(metadata[CoreAnnotationNames.ProviderValueComparerType]);
+    }
+
     [ConditionalFact]
     public void Can_only_override_lower_or_equal_source_IsUnicode()
     {
diff --git a/test/EFCore.Tests/ModelBuilding/ModelBuilderGenericRelationshipTypeTest.cs b/test/EFCore.Tests/ModelBuilding/ModelBuilderGenericRelationshipTypeTest.cs
index 5950a49036..8f2f402a12 100644
--- a/test/EFCore.Tests/ModelBuilding/ModelBuilderGenericRelationshipTypeTest.cs
+++ b/test/EFCore.Tests/ModelBuilding/ModelBuilderGenericRelationshipTypeTest.cs
@@ -14,6 +14,14 @@ public class GenericOneToOneType : OneToOneTestBase
             Action<ModelConfigurationBuilder>? configure)
             => new GenericTypeTestModelBuilder(testHelpers, configure);
     }
+    
+    public class GenericNonRelationshipTest : NonRelationshipTestBase
+    {
+        protected override TestModelBuilder CreateTestModelBuilder(
+            TestHelpers testHelpers,
+            Action<ModelConfigurationBuilder>? configure)
+            => new GenericTypeTestModelBuilder(testHelpers, configure);
+    }
 
     private class GenericTypeTestModelBuilder : TestModelBuilder
     {
@@ -66,6 +74,9 @@ public GenericTypeTestEntityTypeBuilder(EntityTypeBuilder<TEntity> entityTypeBui
         protected override TestEntityTypeBuilder<TEntity> Wrap(EntityTypeBuilder<TEntity> entityTypeBuilder)
             => new GenericTypeTestEntityTypeBuilder<TEntity>(entityTypeBuilder);
 
+        protected override TestPropertyBuilder<TProperty> Wrap<TProperty>(PropertyBuilder<TProperty> propertyBuilder)
+            => new GenericTypeTestPropertyBuilder<TProperty>(propertyBuilder);
+
         public override TestOwnedNavigationBuilder<TEntity, TRelatedEntity> OwnsOne<TRelatedEntity>(
             Expression<Func<TEntity, TRelatedEntity?>> navigationExpression)
             where TRelatedEntity : class
@@ -75,10 +86,9 @@ protected override TestEntityTypeBuilder<TEntity> Wrap(EntityTypeBuilder<TEntity
             Expression<Func<TEntity, TRelatedEntity?>> navigationExpression,
             Action<TestOwnedNavigationBuilder<TEntity, TRelatedEntity>> buildAction)
             where TRelatedEntity : class
-            => Wrap(
-                EntityTypeBuilder.OwnsOne(
-                    navigationExpression,
-                    r => buildAction(new GenericTypeTestOwnedNavigationBuilder<TEntity, TRelatedEntity>(r))));
+            => Wrap(EntityTypeBuilder.OwnsOne(
+                        navigationExpression,
+                        r => buildAction(new GenericTypeTestOwnedNavigationBuilder<TEntity, TRelatedEntity>(r))));
 
         public override TestReferenceNavigationBuilder<TEntity, TRelatedEntity> HasOne<TRelatedEntity>(
             Expression<Func<TEntity, TRelatedEntity?>>? navigationExpression = null)
@@ -92,8 +102,33 @@ protected override TestEntityTypeBuilder<TEntity> Wrap(EntityTypeBuilder<TEntity
             => new GenericTypeTestCollectionNavigationBuilder<TEntity, TRelatedEntity>(EntityTypeBuilder.HasMany(navigationExpression));
     }
 
-    private class GenericTypeTestReferenceNavigationBuilder<TEntity, TRelatedEntity> : GenericTestReferenceNavigationBuilder<TEntity,
-        TRelatedEntity>
+    private class GenericTypeTestPropertyBuilder<TProperty> : GenericTestPropertyBuilder<TProperty>
+    {
+        public GenericTypeTestPropertyBuilder(PropertyBuilder<TProperty> propertyBuilder)
+            : base(propertyBuilder)
+        {
+        }
+
+        protected override TestPropertyBuilder<TProperty> Wrap(PropertyBuilder<TProperty> propertyBuilder)
+            => new GenericTypeTestPropertyBuilder<TProperty>(propertyBuilder);
+
+        public override TestPropertyBuilder<TProperty> HasConversion<TProvider>()
+            => Wrap(PropertyBuilder.HasConversion(typeof(TProvider)));
+
+        public override TestPropertyBuilder<TProperty> HasConversion<TProvider>(ValueComparer? valueComparer)
+            => Wrap(PropertyBuilder.HasConversion(typeof(TProvider), valueComparer));
+
+        public override TestPropertyBuilder<TProperty> HasConversion<TProvider>(ValueComparer? valueComparer, ValueComparer? providerComparerType)
+            => Wrap(PropertyBuilder.HasConversion(typeof(TProvider), valueComparer, providerComparerType));
+        
+        public override TestPropertyBuilder<TProperty> HasConversion<TConverter, TComparer>()
+            => Wrap(PropertyBuilder.HasConversion(typeof(TConverter), typeof(TComparer)));
+
+        public override TestPropertyBuilder<TProperty> HasConversion<TConverter, TComparer, TProviderComparer>()
+            => Wrap(PropertyBuilder.HasConversion(typeof(TConverter), typeof(TComparer), typeof(TProviderComparer)));
+    }
+
+    private class GenericTypeTestReferenceNavigationBuilder<TEntity, TRelatedEntity> : GenericTestReferenceNavigationBuilder<TEntity, TRelatedEntity>
         where TEntity : class
         where TRelatedEntity : class
     {
diff --git a/test/EFCore.Tests/ModelBuilding/ModelBuilderGenericTest.cs b/test/EFCore.Tests/ModelBuilding/ModelBuilderGenericTest.cs
index c7a2e0af06..4ec6e41d27 100644
--- a/test/EFCore.Tests/ModelBuilding/ModelBuilderGenericTest.cs
+++ b/test/EFCore.Tests/ModelBuilding/ModelBuilderGenericTest.cs
@@ -169,6 +169,9 @@ public override IMutableEntityType Metadata
 
         protected virtual TestEntityTypeBuilder<TEntity> Wrap(EntityTypeBuilder<TEntity> entityTypeBuilder)
             => new GenericTestEntityTypeBuilder<TEntity>(entityTypeBuilder);
+        
+        protected virtual TestPropertyBuilder<TProperty> Wrap<TProperty>(PropertyBuilder<TProperty> propertyBuilder)
+            => new GenericTestPropertyBuilder<TProperty>(propertyBuilder);
 
         public override TestEntityTypeBuilder<TEntity> HasAnnotation(string annotation, object? value)
             => Wrap(EntityTypeBuilder.HasAnnotation(annotation, value));
@@ -196,13 +199,13 @@ public override TestEntityTypeBuilder<TEntity> HasNoKey()
 
         public override TestPropertyBuilder<TProperty> Property<TProperty>(Expression<Func<TEntity, TProperty>> propertyExpression)
             where TProperty : default
-            => new GenericTestPropertyBuilder<TProperty>(EntityTypeBuilder.Property(propertyExpression));
+            => Wrap(EntityTypeBuilder.Property(propertyExpression));
 
         public override TestPropertyBuilder<TProperty> Property<TProperty>(string propertyName)
-            => new GenericTestPropertyBuilder<TProperty>(EntityTypeBuilder.Property<TProperty>(propertyName));
+            => Wrap(EntityTypeBuilder.Property<TProperty>(propertyName));
 
         public override TestPropertyBuilder<TProperty> IndexerProperty<TProperty>(string propertyName)
-            => new GenericTestPropertyBuilder<TProperty>(EntityTypeBuilder.IndexerProperty<TProperty>(propertyName));
+            => Wrap(EntityTypeBuilder.IndexerProperty<TProperty>(propertyName));
 
         public override TestNavigationBuilder Navigation<TNavigation>(
             Expression<Func<TEntity, TNavigation?>> navigationExpression)
@@ -451,94 +454,130 @@ public GenericTestPropertyBuilder(PropertyBuilder<TProperty> propertyBuilder)
             PropertyBuilder = propertyBuilder;
         }
 
-        private PropertyBuilder<TProperty> PropertyBuilder { get; }
+        protected PropertyBuilder<TProperty> PropertyBuilder { get; }
 
         public override IMutableProperty Metadata
             => PropertyBuilder.Metadata;
 
+        protected virtual TestPropertyBuilder<TProperty> Wrap(PropertyBuilder<TProperty> propertyBuilder)
+            => new GenericTestPropertyBuilder<TProperty>(propertyBuilder);
+
         public override TestPropertyBuilder<TProperty> HasAnnotation(string annotation, object? value)
-            => new GenericTestPropertyBuilder<TProperty>(PropertyBuilder.HasAnnotation(annotation, value));
+            => Wrap(PropertyBuilder.HasAnnotation(annotation, value));
 
         public override TestPropertyBuilder<TProperty> IsRequired(bool isRequired = true)
-            => new GenericTestPropertyBuilder<TProperty>(PropertyBuilder.IsRequired(isRequired));
+            => Wrap(PropertyBuilder.IsRequired(isRequired));
 
         public override TestPropertyBuilder<TProperty> HasMaxLength(int maxLength)
-            => new GenericTestPropertyBuilder<TProperty>(PropertyBuilder.HasMaxLength(maxLength));
+            => Wrap(PropertyBuilder.HasMaxLength(maxLength));
 
         public override TestPropertyBuilder<TProperty> HasPrecision(int precision, int scale)
-            => new GenericTestPropertyBuilder<TProperty>(PropertyBuilder.HasPrecision(precision, scale));
+            => Wrap(PropertyBuilder.HasPrecision(precision, scale));
 
         public override TestPropertyBuilder<TProperty> IsUnicode(bool unicode = true)
-            => new GenericTestPropertyBuilder<TProperty>(PropertyBuilder.IsUnicode(unicode));
+            => Wrap(PropertyBuilder.IsUnicode(unicode));
 
         public override TestPropertyBuilder<TProperty> IsRowVersion()
-            => new GenericTestPropertyBuilder<TProperty>(PropertyBuilder.IsRowVersion());
+            => Wrap(PropertyBuilder.IsRowVersion());
 
         public override TestPropertyBuilder<TProperty> IsConcurrencyToken(bool isConcurrencyToken = true)
-            => new GenericTestPropertyBuilder<TProperty>(PropertyBuilder.IsConcurrencyToken(isConcurrencyToken));
+            => Wrap(PropertyBuilder.IsConcurrencyToken(isConcurrencyToken));
 
         public override TestPropertyBuilder<TProperty> ValueGeneratedNever()
-            => new GenericTestPropertyBuilder<TProperty>(PropertyBuilder.ValueGeneratedNever());
+            => Wrap(PropertyBuilder.ValueGeneratedNever());
 
         public override TestPropertyBuilder<TProperty> ValueGeneratedOnAdd()
-            => new GenericTestPropertyBuilder<TProperty>(PropertyBuilder.ValueGeneratedOnAdd());
+            => Wrap(PropertyBuilder.ValueGeneratedOnAdd());
 
         public override TestPropertyBuilder<TProperty> ValueGeneratedOnAddOrUpdate()
-            => new GenericTestPropertyBuilder<TProperty>(PropertyBuilder.ValueGeneratedOnAddOrUpdate());
+            => Wrap(PropertyBuilder.ValueGeneratedOnAddOrUpdate());
 
         public override TestPropertyBuilder<TProperty> ValueGeneratedOnUpdate()
-            => new GenericTestPropertyBuilder<TProperty>(PropertyBuilder.ValueGeneratedOnUpdate());
+            => Wrap(PropertyBuilder.ValueGeneratedOnUpdate());
 
         public override TestPropertyBuilder<TProperty> HasValueGenerator<TGenerator>()
-            => new GenericTestPropertyBuilder<TProperty>(PropertyBuilder.HasValueGenerator<TGenerator>());
+            => Wrap(PropertyBuilder.HasValueGenerator<TGenerator>());
 
         public override TestPropertyBuilder<TProperty> HasValueGenerator(Type valueGeneratorType)
-            => new GenericTestPropertyBuilder<TProperty>(PropertyBuilder.HasValueGenerator(valueGeneratorType));
+            => Wrap(PropertyBuilder.HasValueGenerator(valueGeneratorType));
 
         public override TestPropertyBuilder<TProperty> HasValueGenerator(
             Func<IReadOnlyProperty, IReadOnlyEntityType, ValueGenerator> factory)
-            => new GenericTestPropertyBuilder<TProperty>(PropertyBuilder.HasValueGenerator(factory));
+            => Wrap(PropertyBuilder.HasValueGenerator(factory));
 
         public override TestPropertyBuilder<TProperty> HasValueGeneratorFactory<TFactory>()
-            => new GenericTestPropertyBuilder<TProperty>(PropertyBuilder.HasValueGeneratorFactory<TFactory>());
+            => Wrap(PropertyBuilder.HasValueGeneratorFactory<TFactory>());
 
         public override TestPropertyBuilder<TProperty> HasValueGeneratorFactory(Type valueGeneratorFactoryType)
-            => new GenericTestPropertyBuilder<TProperty>(PropertyBuilder.HasValueGeneratorFactory(valueGeneratorFactoryType));
+            => Wrap(PropertyBuilder.HasValueGeneratorFactory(valueGeneratorFactoryType));
 
         public override TestPropertyBuilder<TProperty> HasField(string fieldName)
-            => new GenericTestPropertyBuilder<TProperty>(PropertyBuilder.HasField(fieldName));
+            => Wrap(PropertyBuilder.HasField(fieldName));
 
         public override TestPropertyBuilder<TProperty> UsePropertyAccessMode(PropertyAccessMode propertyAccessMode)
-            => new GenericTestPropertyBuilder<TProperty>(PropertyBuilder.UsePropertyAccessMode(propertyAccessMode));
+            => Wrap(PropertyBuilder.UsePropertyAccessMode(propertyAccessMode));
 
         public override TestPropertyBuilder<TProperty> HasConversion<TProvider>()
-            => new GenericTestPropertyBuilder<TProperty>(PropertyBuilder.HasConversion<TProvider>());
+            => Wrap(PropertyBuilder.HasConversion<TProvider>());
+
+        public override TestPropertyBuilder<TProperty> HasConversion<TProvider>(ValueComparer? valueComparer)
+            => Wrap(PropertyBuilder.HasConversion<TProvider>(valueComparer));
 
-        public override TestPropertyBuilder<TProperty> HasConversion(Type? providerClrType)
-            => new GenericTestPropertyBuilder<TProperty>(PropertyBuilder.HasConversion(providerClrType));
+        public override TestPropertyBuilder<TProperty> HasConversion<TProvider>(ValueComparer? valueComparer, ValueComparer? providerComparerType)
+            => Wrap(PropertyBuilder.HasConversion<TProvider>(valueComparer, providerComparerType));
 
         public override TestPropertyBuilder<TProperty> HasConversion<TProvider>(
             Expression<Func<TProperty, TProvider>> convertToProviderExpression,
             Expression<Func<TProvider, TProperty>> convertFromProviderExpression)
-            => new GenericTestPropertyBuilder<TProperty>(
-                PropertyBuilder.HasConversion(
-                    convertToProviderExpression,
-                    convertFromProviderExpression));
+            => Wrap(PropertyBuilder.HasConversion(
+                        convertToProviderExpression,
+                        convertFromProviderExpression));
+
+        public override TestPropertyBuilder<TProperty> HasConversion<TProvider>(
+            Expression<Func<TProperty, TProvider>> convertToProviderExpression,
+            Expression<Func<TProvider, TProperty>> convertFromProviderExpression,
+            ValueComparer? valueComparer)
+            => Wrap(PropertyBuilder.HasConversion(
+                        convertToProviderExpression,
+                        convertFromProviderExpression,
+                        valueComparer));
+
+        public override TestPropertyBuilder<TProperty> HasConversion<TProvider>(
+            Expression<Func<TProperty, TProvider>> convertToProviderExpression,
+            Expression<Func<TProvider, TProperty>> convertFromProviderExpression,
+            ValueComparer? valueComparer,
+            ValueComparer? providerComparerType)
+            => Wrap(PropertyBuilder.HasConversion(
+                        convertToProviderExpression,
+                        convertFromProviderExpression,
+                        valueComparer,
+                        providerComparerType));
 
         public override TestPropertyBuilder<TProperty> HasConversion<TProvider>(ValueConverter<TProperty, TProvider> converter)
-            => new GenericTestPropertyBuilder<TProperty>(PropertyBuilder.HasConversion(converter));
+            => Wrap(PropertyBuilder.HasConversion(converter));
+
+        public override TestPropertyBuilder<TProperty> HasConversion<TProvider>(ValueConverter<TProperty, TProvider> converter,
+            ValueComparer? valueComparer)
+            => Wrap(PropertyBuilder.HasConversion(converter, valueComparer));
+
+        public override TestPropertyBuilder<TProperty> HasConversion<TProvider>(ValueConverter<TProperty, TProvider> converter,
+            ValueComparer? valueComparer, ValueComparer? providerComparerType)
+            => Wrap(PropertyBuilder.HasConversion(converter, valueComparer, providerComparerType));
 
         public override TestPropertyBuilder<TProperty> HasConversion(ValueConverter? converter)
-            => new GenericTestPropertyBuilder<TProperty>(PropertyBuilder.HasConversion(converter));
+            => Wrap(PropertyBuilder.HasConversion(converter));
 
         public override TestPropertyBuilder<TProperty> HasConversion(ValueConverter? converter, ValueComparer? valueComparer)
-            => new GenericTestPropertyBuilder<TProperty>(PropertyBuilder.HasConversion(converter, valueComparer));
+            => Wrap(PropertyBuilder.HasConversion(converter, valueComparer));
 
-        public override TestPropertyBuilder<TProperty> HasConversion<TConverter, TComparer>()
-            => new GenericTestPropertyBuilder<TProperty>(PropertyBuilder.HasConversion<TConverter, TComparer>());
+        public override TestPropertyBuilder<TProperty> HasConversion(ValueConverter? converter, ValueComparer? valueComparer, ValueComparer? providerComparerType)
+            => Wrap(PropertyBuilder.HasConversion(converter, valueComparer, providerComparerType));
 
-        public override TestPropertyBuilder<TProperty> HasConversion(Type converterType, Type? comparerType)
-            => new GenericTestPropertyBuilder<TProperty>(PropertyBuilder.HasConversion(converterType, comparerType));
+        public override TestPropertyBuilder<TProperty> HasConversion<TConverter, TComparer>()
+            => Wrap(PropertyBuilder.HasConversion<TConverter, TComparer>());
+        
+        public override TestPropertyBuilder<TProperty> HasConversion<TConverter, TComparer, TProviderComparer>()
+            => Wrap(PropertyBuilder.HasConversion<TConverter, TComparer, TProviderComparer>());
 
         PropertyBuilder<TProperty> IInfrastructure<PropertyBuilder<TProperty>>.Instance
             => PropertyBuilder;
@@ -1026,6 +1065,9 @@ public override IMutableEntityType OwnedEntityType
             where TNewDependentEntity : class
             => new(ownershipBuilder);
 
+        protected virtual TestPropertyBuilder<TProperty> Wrap<TProperty>(PropertyBuilder<TProperty> propertyBuilder)
+            => new GenericTestPropertyBuilder<TProperty>(propertyBuilder);
+
         public override TestOwnedNavigationBuilder<TEntity, TDependentEntity> HasAnnotation(
             string annotation,
             object? value)
@@ -1038,14 +1080,14 @@ public override TestKeyBuilder<TDependentEntity> HasKey(params string[] property
             => new GenericTestKeyBuilder<TDependentEntity>(OwnedNavigationBuilder.HasKey(propertyNames));
 
         public override TestPropertyBuilder<TProperty> Property<TProperty>(string propertyName)
-            => new GenericTestPropertyBuilder<TProperty>(OwnedNavigationBuilder.Property<TProperty>(propertyName));
+            => Wrap(OwnedNavigationBuilder.Property<TProperty>(propertyName));
 
         public override TestPropertyBuilder<TProperty> IndexerProperty<TProperty>(string propertyName)
-            => new GenericTestPropertyBuilder<TProperty>(OwnedNavigationBuilder.IndexerProperty<TProperty>(propertyName));
+            => Wrap(OwnedNavigationBuilder.IndexerProperty<TProperty>(propertyName));
 
         public override TestPropertyBuilder<TProperty> Property<TProperty>(
             Expression<Func<TDependentEntity, TProperty>> propertyExpression)
-            => new GenericTestPropertyBuilder<TProperty>(OwnedNavigationBuilder.Property(propertyExpression));
+            => Wrap(OwnedNavigationBuilder.Property(propertyExpression));
 
         public override TestNavigationBuilder Navigation<TNavigation>(
             Expression<Func<TDependentEntity, TNavigation?>> navigationExpression)
@@ -1151,8 +1193,7 @@ public override DataBuilder<TDependentEntity> HasData(IEnumerable<TDependentEnti
         public override DataBuilder<TDependentEntity> HasData(IEnumerable<object> data)
             => OwnedNavigationBuilder.HasData(data);
 
-        OwnedNavigationBuilder<TEntity, TDependentEntity> IInfrastructure<OwnedNavigationBuilder<TEntity, TDependentEntity>>.
-            Instance
+        OwnedNavigationBuilder<TEntity, TDependentEntity> IInfrastructure<OwnedNavigationBuilder<TEntity, TDependentEntity>>.Instance
             => OwnedNavigationBuilder;
     }
 }
diff --git a/test/EFCore.Tests/ModelBuilding/ModelBuilderNonGenericTest.cs b/test/EFCore.Tests/ModelBuilding/ModelBuilderNonGenericTest.cs
index 6904a9b007..4aee1e9fb3 100644
--- a/test/EFCore.Tests/ModelBuilding/ModelBuilderNonGenericTest.cs
+++ b/test/EFCore.Tests/ModelBuilding/ModelBuilderNonGenericTest.cs
@@ -210,6 +210,9 @@ public override IMutableEntityType Metadata
         protected virtual NonGenericTestEntityTypeBuilder<TEntity> Wrap(EntityTypeBuilder entityTypeBuilder)
             => new(entityTypeBuilder);
 
+        protected virtual TestPropertyBuilder<TProperty> Wrap<TProperty>(PropertyBuilder propertyBuilder)
+            => new NonGenericTestPropertyBuilder<TProperty>(propertyBuilder);
+
         public override TestEntityTypeBuilder<TEntity> HasAnnotation(string annotation, object? value)
             => Wrap(EntityTypeBuilder.HasAnnotation(annotation, value));
 
@@ -240,15 +243,14 @@ public override TestEntityTypeBuilder<TEntity> HasNoKey()
         public override TestPropertyBuilder<TProperty> Property<TProperty>(Expression<Func<TEntity, TProperty>> propertyExpression)
         {
             var memberInfo = propertyExpression.GetMemberAccess();
-            return new NonGenericTestPropertyBuilder<TProperty>(
-                EntityTypeBuilder.Property(memberInfo.GetMemberType(), memberInfo.GetSimpleMemberName()));
+            return Wrap<TProperty>(EntityTypeBuilder.Property(memberInfo.GetMemberType(), memberInfo.GetSimpleMemberName()));
         }
 
         public override TestPropertyBuilder<TProperty> Property<TProperty>(string propertyName)
-            => new NonGenericTestPropertyBuilder<TProperty>(EntityTypeBuilder.Property<TProperty>(propertyName));
+            => Wrap<TProperty>(EntityTypeBuilder.Property<TProperty>(propertyName));
 
         public override TestPropertyBuilder<TProperty> IndexerProperty<TProperty>(string propertyName)
-            => new NonGenericTestPropertyBuilder<TProperty>(EntityTypeBuilder.IndexerProperty<TProperty>(propertyName));
+            => Wrap<TProperty>(EntityTypeBuilder.IndexerProperty<TProperty>(propertyName));
 
         public override TestNavigationBuilder Navigation<TNavigation>(Expression<Func<TEntity, TNavigation?>> navigationExpression)
             where TNavigation : class
@@ -537,88 +539,123 @@ public NonGenericTestPropertyBuilder(PropertyBuilder propertyBuilder)
         public override IMutableProperty Metadata
             => PropertyBuilder.Metadata;
 
+        protected virtual TestPropertyBuilder<TProperty> Wrap(PropertyBuilder propertyBuilder)
+            => new NonGenericTestPropertyBuilder<TProperty>(propertyBuilder);
+
         public override TestPropertyBuilder<TProperty> HasAnnotation(string annotation, object? value)
-            => new NonGenericTestPropertyBuilder<TProperty>(PropertyBuilder.HasAnnotation(annotation, value));
+            => Wrap(PropertyBuilder.HasAnnotation(annotation, value));
 
         public override TestPropertyBuilder<TProperty> IsRequired(bool isRequired = true)
-            => new NonGenericTestPropertyBuilder<TProperty>(PropertyBuilder.IsRequired(isRequired));
+            => Wrap(PropertyBuilder.IsRequired(isRequired));
 
         public override TestPropertyBuilder<TProperty> HasMaxLength(int maxLength)
-            => new NonGenericTestPropertyBuilder<TProperty>(PropertyBuilder.HasMaxLength(maxLength));
+            => Wrap(PropertyBuilder.HasMaxLength(maxLength));
 
         public override TestPropertyBuilder<TProperty> HasPrecision(int precision, int scale)
-            => new NonGenericTestPropertyBuilder<TProperty>(PropertyBuilder.HasPrecision(precision, scale));
+            => Wrap(PropertyBuilder.HasPrecision(precision, scale));
 
         public override TestPropertyBuilder<TProperty> IsUnicode(bool unicode = true)
-            => new NonGenericTestPropertyBuilder<TProperty>(PropertyBuilder.IsUnicode(unicode));
+            => Wrap(PropertyBuilder.IsUnicode(unicode));
 
         public override TestPropertyBuilder<TProperty> IsRowVersion()
-            => new NonGenericTestPropertyBuilder<TProperty>(PropertyBuilder.IsRowVersion());
+            => Wrap(PropertyBuilder.IsRowVersion());
 
         public override TestPropertyBuilder<TProperty> IsConcurrencyToken(bool isConcurrencyToken = true)
-            => new NonGenericTestPropertyBuilder<TProperty>(PropertyBuilder.IsConcurrencyToken(isConcurrencyToken));
+            => Wrap(PropertyBuilder.IsConcurrencyToken(isConcurrencyToken));
 
         public override TestPropertyBuilder<TProperty> ValueGeneratedNever()
-            => new NonGenericTestPropertyBuilder<TProperty>(PropertyBuilder.ValueGeneratedNever());
+            => Wrap(PropertyBuilder.ValueGeneratedNever());
 
         public override TestPropertyBuilder<TProperty> ValueGeneratedOnAdd()
-            => new NonGenericTestPropertyBuilder<TProperty>(PropertyBuilder.ValueGeneratedOnAdd());
+            => Wrap(PropertyBuilder.ValueGeneratedOnAdd());
 
         public override TestPropertyBuilder<TProperty> ValueGeneratedOnAddOrUpdate()
-            => new NonGenericTestPropertyBuilder<TProperty>(PropertyBuilder.ValueGeneratedOnAddOrUpdate());
+            => Wrap(PropertyBuilder.ValueGeneratedOnAddOrUpdate());
 
         public override TestPropertyBuilder<TProperty> ValueGeneratedOnUpdate()
-            => new NonGenericTestPropertyBuilder<TProperty>(PropertyBuilder.ValueGeneratedOnUpdate());
+            => Wrap(PropertyBuilder.ValueGeneratedOnUpdate());
 
         public override TestPropertyBuilder<TProperty> HasValueGenerator<TGenerator>()
-            => new NonGenericTestPropertyBuilder<TProperty>(PropertyBuilder.HasValueGenerator<TGenerator>());
+            => Wrap(PropertyBuilder.HasValueGenerator<TGenerator>());
 
         public override TestPropertyBuilder<TProperty> HasValueGenerator(Type valueGeneratorType)
-            => new NonGenericTestPropertyBuilder<TProperty>(PropertyBuilder.HasValueGenerator(valueGeneratorType));
+            => Wrap(PropertyBuilder.HasValueGenerator(valueGeneratorType));
 
         public override TestPropertyBuilder<TProperty> HasValueGenerator(
             Func<IReadOnlyProperty, IReadOnlyEntityType, ValueGenerator> factory)
-            => new NonGenericTestPropertyBuilder<TProperty>(PropertyBuilder.HasValueGenerator(factory));
+            => Wrap(PropertyBuilder.HasValueGenerator(factory));
 
         public override TestPropertyBuilder<TProperty> HasValueGeneratorFactory<TFactory>()
-            => new NonGenericTestPropertyBuilder<TProperty>(PropertyBuilder.HasValueGeneratorFactory<TFactory>());
+            => Wrap(PropertyBuilder.HasValueGeneratorFactory<TFactory>());
 
         public override TestPropertyBuilder<TProperty> HasValueGeneratorFactory(Type valueGeneratorFactoryType)
-            => new NonGenericTestPropertyBuilder<TProperty>(PropertyBuilder.HasValueGeneratorFactory(valueGeneratorFactoryType));
+            => Wrap(PropertyBuilder.HasValueGeneratorFactory(valueGeneratorFactoryType));
 
         public override TestPropertyBuilder<TProperty> HasField(string fieldName)
-            => new NonGenericTestPropertyBuilder<TProperty>(PropertyBuilder.HasField(fieldName));
+            => Wrap(PropertyBuilder.HasField(fieldName));
 
         public override TestPropertyBuilder<TProperty> UsePropertyAccessMode(PropertyAccessMode propertyAccessMode)
-            => new NonGenericTestPropertyBuilder<TProperty>(PropertyBuilder.UsePropertyAccessMode(propertyAccessMode));
+            => Wrap(PropertyBuilder.UsePropertyAccessMode(propertyAccessMode));
 
         public override TestPropertyBuilder<TProperty> HasConversion<TProvider>()
-            => new NonGenericTestPropertyBuilder<TProperty>(PropertyBuilder.HasConversion<TProvider>());
+            => Wrap(PropertyBuilder.HasConversion<TProvider>());
 
-        public override TestPropertyBuilder<TProperty> HasConversion(Type? providerClrType)
-            => new NonGenericTestPropertyBuilder<TProperty>(PropertyBuilder.HasConversion(providerClrType));
+        public override TestPropertyBuilder<TProperty> HasConversion<TProvider>(ValueComparer? valueComparer)
+            => Wrap(PropertyBuilder.HasConversion<TProvider>(valueComparer));
+
+        public override TestPropertyBuilder<TProperty> HasConversion<TProvider>(ValueComparer? valueComparer, ValueComparer? providerComparerType)
+            => Wrap(PropertyBuilder.HasConversion<TProvider>(valueComparer, providerComparerType));
 
         public override TestPropertyBuilder<TProperty> HasConversion<TProvider>(
             Expression<Func<TProperty, TProvider>> convertToProviderExpression,
             Expression<Func<TProvider, TProperty>> convertFromProviderExpression)
-            => new NonGenericTestPropertyBuilder<TProperty>(
-                PropertyBuilder.HasConversion(
-                    new ValueConverter<TProperty, TProvider>(convertToProviderExpression, convertFromProviderExpression)));
+            => Wrap(PropertyBuilder.HasConversion(
+                        new ValueConverter<TProperty, TProvider>(convertToProviderExpression, convertFromProviderExpression)));
+
+        public override TestPropertyBuilder<TProperty> HasConversion<TProvider>(
+            Expression<Func<TProperty, TProvider>> convertToProviderExpression,
+            Expression<Func<TProvider, TProperty>> convertFromProviderExpression,
+            ValueComparer? valueComparer)
+            => Wrap(PropertyBuilder.HasConversion(
+                        new ValueConverter<TProperty, TProvider>(convertToProviderExpression, convertFromProviderExpression),
+                        valueComparer));
+
+        public override TestPropertyBuilder<TProperty> HasConversion<TProvider>(
+            Expression<Func<TProperty, TProvider>> convertToProviderExpression,
+            Expression<Func<TProvider, TProperty>> convertFromProviderExpression,
+            ValueComparer? valueComparer,
+            ValueComparer? providerComparerType)
+            => Wrap(PropertyBuilder.HasConversion(
+                        new ValueConverter<TProperty, TProvider>(convertToProviderExpression, convertFromProviderExpression),
+                        valueComparer,
+                        providerComparerType));
 
         public override TestPropertyBuilder<TProperty> HasConversion<TStore>(ValueConverter<TProperty, TStore> converter)
-            => new NonGenericTestPropertyBuilder<TProperty>(PropertyBuilder.HasConversion(converter));
+            => Wrap(PropertyBuilder.HasConversion(converter));
+        
+        public override TestPropertyBuilder<TProperty> HasConversion<TStore>(ValueConverter<TProperty, TStore> converter, ValueComparer? valueComparer)
+            => Wrap(PropertyBuilder.HasConversion(converter, valueComparer));
+        
+        public override TestPropertyBuilder<TProperty> HasConversion<TStore>(
+            ValueConverter<TProperty, TStore> converter,
+            ValueComparer? valueComparer,
+            ValueComparer? providerComparerType)
+            => Wrap(PropertyBuilder.HasConversion(converter, valueComparer, providerComparerType));
 
         public override TestPropertyBuilder<TProperty> HasConversion(ValueConverter? converter)
-            => new NonGenericTestPropertyBuilder<TProperty>(PropertyBuilder.HasConversion(converter));
+            => Wrap(PropertyBuilder.HasConversion(converter));
 
         public override TestPropertyBuilder<TProperty> HasConversion(ValueConverter? converter, ValueComparer? valueComparer)
-            => new NonGenericTestPropertyBuilder<TProperty>(PropertyBuilder.HasConversion(converter, valueComparer));
+            => Wrap(PropertyBuilder.HasConversion(converter, valueComparer));
+
+        public override TestPropertyBuilder<TProperty> HasConversion(ValueConverter? converter, ValueComparer? valueComparer, ValueComparer? providerComparerType)
+            => Wrap(PropertyBuilder.HasConversion(converter, valueComparer, providerComparerType));
 
         public override TestPropertyBuilder<TProperty> HasConversion<TConverter, TComparer>()
-            => new NonGenericTestPropertyBuilder<TProperty>(PropertyBuilder.HasConversion<TConverter, TComparer>());
+            => Wrap(PropertyBuilder.HasConversion<TConverter, TComparer>());
 
-        public override TestPropertyBuilder<TProperty> HasConversion(Type converterType, Type? comparerType)
-            => new NonGenericTestPropertyBuilder<TProperty>(PropertyBuilder.HasConversion(converterType, comparerType));
+        public override TestPropertyBuilder<TProperty> HasConversion<TConverter, TComparer, TProviderComparer>()
+            => Wrap(PropertyBuilder.HasConversion<TConverter, TComparer, TProviderComparer>());
 
         PropertyBuilder IInfrastructure<PropertyBuilder>.Instance
             => PropertyBuilder;
diff --git a/test/EFCore.Tests/ModelBuilding/ModelBuilderTestBase.cs b/test/EFCore.Tests/ModelBuilding/ModelBuilderTestBase.cs
index 368b3aaa84..0a49457809 100644
--- a/test/EFCore.Tests/ModelBuilding/ModelBuilderTestBase.cs
+++ b/test/EFCore.Tests/ModelBuilding/ModelBuilderTestBase.cs
@@ -398,21 +398,41 @@ public abstract class TestPropertyBuilder<TProperty>
         public abstract TestPropertyBuilder<TProperty> UsePropertyAccessMode(PropertyAccessMode propertyAccessMode);
 
         public abstract TestPropertyBuilder<TProperty> HasConversion<TProvider>();
-        public abstract TestPropertyBuilder<TProperty> HasConversion(Type providerClrType);
+        public abstract TestPropertyBuilder<TProperty> HasConversion<TProvider>(ValueComparer? valueComparer);
+        public abstract TestPropertyBuilder<TProperty> HasConversion<TProvider>(ValueComparer? valueComparer, ValueComparer? providerComparerType);
 
         public abstract TestPropertyBuilder<TProperty> HasConversion<TProvider>(
             Expression<Func<TProperty, TProvider>> convertToProviderExpression,
             Expression<Func<TProvider, TProperty>> convertFromProviderExpression);
 
+        public abstract TestPropertyBuilder<TProperty> HasConversion<TProvider>(
+            Expression<Func<TProperty, TProvider>> convertToProviderExpression,
+            Expression<Func<TProvider, TProperty>> convertFromProviderExpression,
+            ValueComparer? valueComparer);
+
+        public abstract TestPropertyBuilder<TProperty> HasConversion<TProvider>(
+            Expression<Func<TProperty, TProvider>> convertToProviderExpression,
+            Expression<Func<TProvider, TProperty>> convertFromProviderExpression,
+            ValueComparer? valueComparer,
+            ValueComparer? providerComparerType);
+
         public abstract TestPropertyBuilder<TProperty> HasConversion<TProvider>(ValueConverter<TProperty, TProvider> converter);
+        public abstract TestPropertyBuilder<TProperty> HasConversion<TProvider>(ValueConverter<TProperty, TProvider> converter, ValueComparer? valueComparer);
+        public abstract TestPropertyBuilder<TProperty> HasConversion<TProvider>(
+            ValueConverter<TProperty, TProvider> converter,
+            ValueComparer? valueComparer,
+            ValueComparer? providerComparerType);
+        
         public abstract TestPropertyBuilder<TProperty> HasConversion(ValueConverter? converter);
         public abstract TestPropertyBuilder<TProperty> HasConversion(ValueConverter? converter, ValueComparer? valueComparer);
+        public abstract TestPropertyBuilder<TProperty> HasConversion(ValueConverter? converter, ValueComparer? valueComparer, ValueComparer? providerComparerType);
 
         public abstract TestPropertyBuilder<TProperty> HasConversion<TConverter, TComparer>()
-            where TConverter : ValueConverter
             where TComparer : ValueComparer;
-
-        public abstract TestPropertyBuilder<TProperty> HasConversion(Type converterType, Type? comparerType);
+        
+        public abstract TestPropertyBuilder<TProperty> HasConversion<TConverter, TComparer, TProviderComparer>()
+            where TComparer : ValueComparer
+            where TProviderComparer : ValueComparer;
     }
 
     public abstract class TestNavigationBuilder
diff --git a/test/EFCore.Tests/ModelBuilding/NonRelationshipTestBase.cs b/test/EFCore.Tests/ModelBuilding/NonRelationshipTestBase.cs
index a7603a2a5c..af7bf6582e 100644
--- a/test/EFCore.Tests/ModelBuilding/NonRelationshipTestBase.cs
+++ b/test/EFCore.Tests/ModelBuilding/NonRelationshipTestBase.cs
@@ -750,9 +750,10 @@ public virtual void Properties_can_have_provider_type_set()
                 {
                     b.Property(e => e.Up);
                     b.Property(e => e.Down).HasConversion<byte[]>();
-                    b.Property<int>("Charm").HasConversion(typeof(long), typeof(CustomValueComparer<int>));
-                    b.Property<string>("Strange").HasConversion<byte[]>();
-                    b.Property<string>("Strange").HasConversion((Type)null);
+                    b.Property<int>("Charm").HasConversion<long, CustomValueComparer<int>>();
+                    b.Property<string>("Strange").HasConversion<byte[]>(new CustomValueComparer<string>(), new CustomValueComparer<byte[]>());
+                    b.Property<string>("Strange").HasConversion(null);
+                    b.Property<string>("Top").HasConversion<string>(new CustomValueComparer<string>());
                 });
 
             var model = modelBuilder.FinalizeModel();
@@ -765,14 +766,22 @@ public virtual void Properties_can_have_provider_type_set()
             var down = entityType.FindProperty("Down");
             Assert.Same(typeof(byte[]), down.GetProviderClrType());
             Assert.IsType<ValueComparer.DefaultValueComparer<string>>(down.GetValueComparer());
+            Assert.IsType<ValueComparer<byte[]>>(down.GetProviderValueComparer());
 
             var charm = entityType.FindProperty("Charm");
             Assert.Same(typeof(long), charm.GetProviderClrType());
             Assert.IsType<CustomValueComparer<int>>(charm.GetValueComparer());
+            Assert.IsType<ValueComparer.DefaultValueComparer<long>>(charm.GetProviderValueComparer());
 
             var strange = entityType.FindProperty("Strange");
             Assert.Null(strange.GetProviderClrType());
             Assert.IsType<ValueComparer.DefaultValueComparer<string>>(strange.GetValueComparer());
+            Assert.IsType<ValueComparer.DefaultValueComparer<string>>(strange.GetProviderValueComparer());
+
+            var top = entityType.FindProperty("Top");
+            Assert.Same(typeof(string), top.GetProviderClrType());
+            Assert.IsType<CustomValueComparer<string>>(top.GetValueComparer());
+            Assert.IsType<CustomValueComparer<string>>(top.GetProviderValueComparer());
         }
 
         [ConditionalFact]
@@ -799,7 +808,7 @@ public virtual void Properties_can_have_provider_type_set_for_type()
         }
 
         [ConditionalFact]
-        public virtual void Properties_can_have_value_converter_set_non_generic()
+        public virtual void Properties_can_have_non_generic_value_converter_set()
         {
             var modelBuilder = CreateModelBuilder();
 
@@ -811,51 +820,67 @@ public virtual void Properties_can_have_value_converter_set_non_generic()
                 {
                     b.Property(e => e.Up);
                     b.Property(e => e.Down).HasConversion(stringConverter);
-                    b.Property<int>("Charm").HasConversion(intConverter);
+                    b.Property<int>("Charm").HasConversion(intConverter, null, new CustomValueComparer<long>());
                     b.Property<string>("Strange").HasConversion(stringConverter);
-                    b.Property<string>("Strange").HasConversion((ValueConverter)null);
+                    b.Property<string>("Strange").HasConversion(null);
                 });
 
             var model = modelBuilder.FinalizeModel();
             var entityType = (IReadOnlyEntityType)model.FindEntityType(typeof(Quarks));
 
             Assert.Null(entityType.FindProperty("Up").GetValueConverter());
-            Assert.Same(stringConverter, entityType.FindProperty("Down").GetValueConverter());
-            Assert.Same(intConverter, entityType.FindProperty("Charm").GetValueConverter());
+            
+            var down = entityType.FindProperty("Down");
+            Assert.Same(stringConverter, down.GetValueConverter());
+            Assert.IsType<ValueComparer.DefaultValueComparer<string>>(down.GetValueComparer());
+            Assert.IsType<ValueComparer<byte[]>>(down.GetProviderValueComparer());
+            
+            var charm = entityType.FindProperty("Charm");
+            Assert.Same(intConverter, charm.GetValueConverter());
+            Assert.IsType<ValueComparer.DefaultValueComparer<int>>(charm.GetValueComparer());
+            Assert.IsType<CustomValueComparer<long>>(charm.GetProviderValueComparer());
+
             Assert.Null(entityType.FindProperty("Strange").GetValueConverter());
         }
 
         [ConditionalFact]
-        public virtual void Properties_can_have_value_converter_type_set()
+        public virtual void Properties_can_have_custom_type_value_converter_type_set()
         {
             var modelBuilder = CreateModelBuilder();
 
             modelBuilder.Entity<Quarks>(
                 b =>
                 {
-                    b.Property(e => e.Up);
-                    b.Property(e => e.Down).HasConversion(typeof(UTF8StringToBytesConverter));
+                    b.Property(e => e.Up).HasConversion<int, CustomValueComparer<int>>();
+                    b.Property(e => e.Down).HasConversion<UTF8StringToBytesConverter, CustomValueComparer<string>, CustomValueComparer<byte[]>>();
                     b.Property<int>("Charm").HasConversion<CastingConverter<int, long>, CustomValueComparer<int>>();
-                    b.Property<string>("Strange").HasConversion(
-                        typeof(UTF8StringToBytesConverter), typeof(CustomValueComparer<string>));
-                    b.Property<string>("Strange").HasConversion((ValueConverter)null, null);
+                    b.Property<string>("Strange").HasConversion<UTF8StringToBytesConverter, CustomValueComparer<string>>();
+                    b.Property<string>("Strange").HasConversion(null, null);
                 });
 
             var model = modelBuilder.FinalizeModel();
             var entityType = (IReadOnlyEntityType)model.FindEntityType(typeof(Quarks));
 
-            Assert.Null(entityType.FindProperty("Up").GetValueConverter());
+            var up = entityType.FindProperty("Up");
+            Assert.Equal(typeof(int), up.GetProviderClrType());
+            Assert.Null(up.GetValueConverter());
+            Assert.IsType<CustomValueComparer<int>>(up.GetValueComparer());
+            Assert.IsType<CustomValueComparer<int>>(up.GetProviderValueComparer());
 
             var down = entityType.FindProperty("Down");
             Assert.IsType<UTF8StringToBytesConverter>(down.GetValueConverter());
-            Assert.IsType<ValueComparer.DefaultValueComparer<string>>(down.GetValueComparer());
+            Assert.IsType<CustomValueComparer<string>>(down.GetValueComparer());
+            Assert.IsType<CustomValueComparer<byte[]>>(down.GetProviderValueComparer());
 
             var charm = entityType.FindProperty("Charm");
             Assert.IsType<CastingConverter<int, long>>(charm.GetValueConverter());
             Assert.IsType<CustomValueComparer<int>>(charm.GetValueComparer());
+            Assert.IsType<ValueComparer.DefaultValueComparer<long>>(charm.GetProviderValueComparer());
 
-            Assert.Null(entityType.FindProperty("Strange").GetValueConverter());
-            Assert.IsAssignableFrom<ValueComparer.DefaultValueComparer<string>>(entityType.FindProperty("Strange").GetValueComparer());
+            var strange = entityType.FindProperty("Strange");
+            Assert.Null(strange.GetValueConverter());
+            Assert.IsType<ValueComparer.DefaultValueComparer<string>>(strange.GetValueComparer());
+            Assert.IsType<ValueComparer.DefaultValueComparer<string>>(strange.GetProviderValueComparer());
         }
 
         private class UTF8StringToBytesConverter : StringToBytesConverter
@@ -883,16 +908,76 @@ public virtual void Properties_can_have_value_converter_set_inline()
                 b =>
                 {
                     b.Property(e => e.Up);
-                    b.Property(e => e.Down).HasConversion(v => v.ToCharArray(), v => new string(v));
-                    b.Property<int>("Charm").HasConversion(v => (long)v, v => (int)v);
+                    b.Property(e => e.Down).HasConversion(v => int.Parse(v), v => v.ToString());
+                    b.Property<int>("Charm").HasConversion(v => (long)v, v => (int)v, new CustomValueComparer<int>());
+                    b.Property<float>("Strange").HasConversion(v => (double)v, v => (float)v, new CustomValueComparer<float>(), new CustomValueComparer<double>());
                 });
 
-            var model = (IReadOnlyModel)modelBuilder.Model;
+            var model = modelBuilder.FinalizeModel();
             var entityType = model.FindEntityType(typeof(Quarks));
+            
+            var up = entityType.FindProperty("Up");
+            Assert.Null(up.GetProviderClrType());
+            Assert.Null(up.GetValueConverter());
+            Assert.IsType<ValueComparer.DefaultValueComparer<int>>(up.GetValueComparer());
+            Assert.IsType<ValueComparer.DefaultValueComparer<int>>(up.GetProviderValueComparer());
 
-            Assert.Null(entityType.FindProperty("Up").GetValueConverter());
-            Assert.NotNull(entityType.FindProperty("Down").GetValueConverter());
-            Assert.NotNull(entityType.FindProperty("Charm").GetValueConverter());
+            var down = entityType.FindProperty("Down");
+            Assert.IsType<ValueConverter<string, int>>(down.GetValueConverter());
+            Assert.IsType<ValueComparer.DefaultValueComparer<string>>(down.GetValueComparer());
+            Assert.IsType<ValueComparer.DefaultValueComparer<int>>(down.GetProviderValueComparer());
+
+            var charm = entityType.FindProperty("Charm");
+            Assert.IsType<ValueConverter<int, long>>(charm.GetValueConverter());
+            Assert.IsType<CustomValueComparer<int>>(charm.GetValueComparer());
+            Assert.IsType<ValueComparer.DefaultValueComparer<long>>(charm.GetProviderValueComparer());
+
+            var strange = entityType.FindProperty("Strange");
+            Assert.IsType<ValueConverter<float, double>>(strange.GetValueConverter());
+            Assert.IsType<CustomValueComparer<float>>(strange.GetValueComparer());
+            Assert.IsType<CustomValueComparer<double>>(strange.GetProviderValueComparer());
+        }
+        
+        [ConditionalFact]
+        public virtual void Properties_can_have_value_converter_set()
+        {
+            var modelBuilder = CreateModelBuilder();
+
+            modelBuilder.Entity<Quarks>(
+                b =>
+                {
+                    b.Property(e => e.Up);
+                    b.Property(e => e.Down).HasConversion(
+                        new ValueConverter<string, int>(v => int.Parse(v), v => v.ToString()));
+                    b.Property<int>("Charm").HasConversion(
+                        new ValueConverter<int, long>(v => v, v => (int)v), new CustomValueComparer<int>());
+                    b.Property<float>("Strange").HasConversion(
+                        new ValueConverter<float, double>(v => (double)v, v => (float)v), new CustomValueComparer<float>(), new CustomValueComparer<double>());
+                });
+
+            var model = modelBuilder.FinalizeModel();
+            var entityType = model.FindEntityType(typeof(Quarks));
+
+            var up = entityType.FindProperty("Up");
+            Assert.Null(up.GetProviderClrType());
+            Assert.Null(up.GetValueConverter());
+            Assert.IsType<ValueComparer.DefaultValueComparer<int>>(up.GetValueComparer());
+            Assert.IsType<ValueComparer.DefaultValueComparer<int>>(up.GetProviderValueComparer());
+
+            var down = entityType.FindProperty("Down");
+            Assert.IsType<ValueConverter<string, int>>(down.GetValueConverter());
+            Assert.IsType<ValueComparer.DefaultValueComparer<string>>(down.GetValueComparer());
+            Assert.IsType<ValueComparer.DefaultValueComparer<int>>(down.GetProviderValueComparer());
+
+            var charm = entityType.FindProperty("Charm");
+            Assert.IsType<ValueConverter<int, long>>(charm.GetValueConverter());
+            Assert.IsType<CustomValueComparer<int>>(charm.GetValueComparer());
+            Assert.IsType<ValueComparer.DefaultValueComparer<long>>(charm.GetProviderValueComparer());
+
+            var strange = entityType.FindProperty("Strange");
+            Assert.IsType<ValueConverter<float, double>>(strange.GetValueConverter());
+            Assert.IsType<CustomValueComparer<float>>(strange.GetValueComparer());
+            Assert.IsType<CustomValueComparer<double>>(strange.GetProviderValueComparer());
         }
 
         [ConditionalFact]
@@ -1001,7 +1086,7 @@ public virtual void Value_converter_configured_on_nullable_type_overrides_non_nu
                 c =>
                 {
                     c.Properties<int?>().HaveConversion<NumberToStringConverter<int?>, CustomValueComparer<int?>>();
-                    c.Properties<int>().HaveConversion<NumberToStringConverter<int>, CustomValueComparer<int>>();
+                    c.Properties<int>().HaveConversion<NumberToStringConverter<int>, CustomValueComparer<int>, CustomValueComparer<string>>();
                 });
 
             modelBuilder.Entity<Quarks>(
@@ -1016,10 +1101,12 @@ public virtual void Value_converter_configured_on_nullable_type_overrides_non_nu
             var id = entityType.FindProperty("Id");
             Assert.IsType<NumberToStringConverter<int>>(id.GetValueConverter());
             Assert.IsType<CustomValueComparer<int>>(id.GetValueComparer());
+            Assert.IsType<CustomValueComparer<string>>(id.GetProviderValueComparer());
 
             var wierd = entityType.FindProperty("Wierd");
             Assert.IsType<NumberToStringConverter<int?>>(wierd.GetValueConverter());
             Assert.IsType<CustomValueComparer<int?>>(wierd.GetValueComparer());
+            Assert.IsType<CustomValueComparer<string>>(wierd.GetProviderValueComparer());
         }
 
         [ConditionalFact]
diff --git a/test/EFCore.Tests/Storage/ValueComparerTest.cs b/test/EFCore.Tests/Storage/ValueComparerTest.cs
index dce88aabbd..4547169c4a 100644
--- a/test/EFCore.Tests/Storage/ValueComparerTest.cs
+++ b/test/EFCore.Tests/Storage/ValueComparerTest.cs
@@ -7,15 +7,6 @@ namespace Microsoft.EntityFrameworkCore.Storage;
 
 public class ValueComparerTest
 {
-    private class SomeDbContext : DbContext
-    {
-        protected internal override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
-            => optionsBuilder.UseInMemoryDatabase(Guid.NewGuid().ToString());
-
-        protected internal override void OnModelCreating(ModelBuilder modelBuilder)
-            => modelBuilder.Entity<Foo>().Property(e => e.Bar).HasConversion<string>(new FakeValueComparer());
-    }
-
     protected class FakeValueComparer : ValueComparer<double>
     {
         public FakeValueComparer()
@@ -33,12 +24,40 @@ private class Foo
     [ConditionalFact]
     public void Throws_for_comparer_with_wrong_type()
     {
-        using var context = new SomeDbContext();
+        using var context = new InvalidDbContext();
 
         Assert.Equal(
             CoreStrings.ComparerPropertyMismatch("double", nameof(Foo), nameof(Foo.Bar), "int"),
             Assert.Throws<InvalidOperationException>(() => context.Model).Message);
     }
+    
+    private class InvalidDbContext : DbContext
+    {
+        protected internal override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
+            => optionsBuilder.UseInMemoryDatabase(Guid.NewGuid().ToString());
+
+        protected internal override void OnModelCreating(ModelBuilder modelBuilder)
+            => modelBuilder.Entity<Foo>().Property(e => e.Bar).HasConversion<string>(new FakeValueComparer());
+    }
+
+    [ConditionalFact]
+    public void Throws_for_provider_comparer_with_wrong_type()
+    {
+        using var context = new InvalidProviderDbContext();
+
+        Assert.Equal(
+            CoreStrings.ComparerPropertyMismatch("double", nameof(Foo), nameof(Foo.Bar), "string"),
+            Assert.Throws<InvalidOperationException>(() => context.Model).Message);
+    }
+
+    private class InvalidProviderDbContext : DbContext
+    {
+        protected internal override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
+            => optionsBuilder.UseInMemoryDatabase(Guid.NewGuid().ToString());
+
+        protected internal override void OnModelCreating(ModelBuilder modelBuilder)
+            => modelBuilder.Entity<Foo>().Property(e => e.Bar).HasConversion<string>((ValueComparer)null, new FakeValueComparer());
+    }
 
     [ConditionalTheory]
     [InlineData(typeof(byte), (byte)1, (byte)2, 1)]
@@ -68,7 +87,7 @@ private static ValueComparer CompareTest(Type type, object value1, object value2
         var comparer = (ValueComparer)Activator.CreateInstance(typeof(ValueComparer<>).MakeGenericType(type), new object[] { false });
         if (toNullable)
         {
-            comparer = comparer.ToNonNullNullableComparer();
+            comparer = ToNonNullNullableComparer(comparer);
         }
 
         Assert.True(comparer.Equals(value1, value1));
@@ -84,7 +103,7 @@ private static ValueComparer CompareTest(Type type, object value1, object value2
         var keyComparer = (ValueComparer)Activator.CreateInstance(typeof(ValueComparer<>).MakeGenericType(type), new object[] { true });
         if (toNullable)
         {
-            keyComparer = keyComparer.ToNonNullNullableComparer();
+            keyComparer = ToNonNullNullableComparer(keyComparer);
         }
 
         Assert.True(keyComparer.Equals(value1, value1));
@@ -98,6 +117,49 @@ private static ValueComparer CompareTest(Type type, object value1, object value2
         return comparer;
     }
 
+    public static ValueComparer ToNonNullNullableComparer(ValueComparer comparer)
+    {
+        var type = comparer.EqualsExpression.Parameters[0].Type;
+        var nullableType = type.MakeNullable();
+
+        var newEqualsParam1 = Expression.Parameter(nullableType, "v1");
+        var newEqualsParam2 = Expression.Parameter(nullableType, "v2");
+        var newHashCodeParam = Expression.Parameter(nullableType, "v");
+        var newSnapshotParam = Expression.Parameter(nullableType, "v");
+
+        return (ValueComparer)Activator.CreateInstance(
+            typeof(NonNullNullableValueComparer<>).MakeGenericType(nullableType),
+            Expression.Lambda(
+                comparer.ExtractEqualsBody(
+                    Expression.Convert(newEqualsParam1, type),
+                    Expression.Convert(newEqualsParam2, type)),
+                newEqualsParam1, newEqualsParam2),
+            Expression.Lambda(
+                comparer.ExtractHashCodeBody(
+                    Expression.Convert(newHashCodeParam, type)),
+                newHashCodeParam),
+            Expression.Lambda(
+                Expression.Convert(
+                    comparer.ExtractSnapshotBody(
+                        Expression.Convert(newSnapshotParam, type)),
+                    nullableType),
+                newSnapshotParam))!;
+    }
+
+    private sealed class NonNullNullableValueComparer<T> : ValueComparer<T>
+    {
+        public NonNullNullableValueComparer(
+            LambdaExpression equalsExpression,
+            LambdaExpression hashCodeExpression,
+            LambdaExpression snapshotExpression)
+            : base(
+                (Expression<Func<T, T, bool>>)equalsExpression,
+                (Expression<Func<T, int>>)hashCodeExpression,
+                (Expression<Func<T, T>>)snapshotExpression)
+        {
+        }
+    }
+
     private enum JustAnEnum : ushort
     {
         A,
