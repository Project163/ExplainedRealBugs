diff --git a/src/EFCore.Relational/Update/AffectedCountModificationCommandBatch.cs b/src/EFCore.Relational/Update/AffectedCountModificationCommandBatch.cs
index 88b0101dfb..beae811319 100644
--- a/src/EFCore.Relational/Update/AffectedCountModificationCommandBatch.cs
+++ b/src/EFCore.Relational/Update/AffectedCountModificationCommandBatch.cs
@@ -5,8 +5,7 @@ namespace Microsoft.EntityFrameworkCore.Update;
 
 /// <summary>
 ///     <para>
-///         A <see cref="ReaderModificationCommandBatch" /> for providers which append an SQL query to find out
-///         how many rows were affected (see <see cref="UpdateSqlGenerator.AppendSelectAffectedCountCommand" />).
+///         A <see cref="ReaderModificationCommandBatch" /> for providers which return values to find out how many rows were affected.
 ///     </para>
 ///     <para>
 ///         This type is typically used by database providers; it is generally not used in application code.
diff --git a/src/EFCore.Relational/Update/UpdateSqlGenerator.cs b/src/EFCore.Relational/Update/UpdateSqlGenerator.cs
index 5ba908b303..0d18aff8a3 100644
--- a/src/EFCore.Relational/Update/UpdateSqlGenerator.cs
+++ b/src/EFCore.Relational/Update/UpdateSqlGenerator.cs
@@ -97,20 +97,13 @@ protected virtual ISqlGenerationHelper SqlGenerationHelper
         var conditionOperations = operations.Where(o => o.IsCondition).ToList();
         var readOperations = operations.Where(o => o.IsRead).ToList();
 
-        AppendUpdateCommand(commandStringBuilder, name, schema, writeOperations, conditionOperations);
-
-        if (readOperations.Count > 0)
-        {
-            var keyOperations = operations.Where(o => o.IsKey).ToList();
-
-            requiresTransaction = true;
-
-            return AppendSelectAffectedCommand(commandStringBuilder, name, schema, readOperations, keyOperations, commandPosition);
-        }
-
         requiresTransaction = false;
 
-        return AppendSelectAffectedCountCommand(commandStringBuilder, name, schema, commandPosition);
+        AppendUpdateCommand(
+            commandStringBuilder, name, schema, writeOperations, readOperations, conditionOperations,
+            additionalReadValues: readOperations.Count == 0 ? "1" : null);
+
+        return ResultSetMapping.LastInResultSet;
     }
 
     /// <summary>
@@ -131,11 +124,12 @@ protected virtual ISqlGenerationHelper SqlGenerationHelper
         var schema = command.Schema;
         var conditionOperations = command.ColumnModifications.Where(o => o.IsCondition).ToList();
 
-        AppendDeleteCommand(commandStringBuilder, name, schema, conditionOperations);
-
         requiresTransaction = false;
 
-        return AppendSelectAffectedCountCommand(commandStringBuilder, name, schema, commandPosition);
+        AppendDeleteCommand(
+            commandStringBuilder, name, schema, Array.Empty<IColumnModification>(), conditionOperations, additionalReadValues: "1");
+
+        return ResultSetMapping.LastInResultSet;
     }
 
     /// <summary>
@@ -167,16 +161,21 @@ protected virtual ISqlGenerationHelper SqlGenerationHelper
     /// <param name="name">The name of the table.</param>
     /// <param name="schema">The table schema, or <see langword="null" /> to use the default schema.</param>
     /// <param name="writeOperations">The operations for each column.</param>
+    /// <param name="readOperations">The operations for column values to be read back.</param>
     /// <param name="conditionOperations">The operations used to generate the <c>WHERE</c> clause for the update.</param>
+    /// <param name="additionalReadValues">Additional values to be read back.</param>
     protected virtual void AppendUpdateCommand(
         StringBuilder commandStringBuilder,
         string name,
         string? schema,
         IReadOnlyList<IColumnModification> writeOperations,
-        IReadOnlyList<IColumnModification> conditionOperations)
+        IReadOnlyList<IColumnModification> readOperations,
+        IReadOnlyList<IColumnModification> conditionOperations,
+        string? additionalReadValues = null)
     {
         AppendUpdateCommandHeader(commandStringBuilder, name, schema, writeOperations);
         AppendWhereClause(commandStringBuilder, conditionOperations);
+        AppendReturningClause(commandStringBuilder, readOperations, additionalReadValues);
         commandStringBuilder.AppendLine(SqlGenerationHelper.StatementTerminator);
     }
 
@@ -186,33 +185,23 @@ protected virtual ISqlGenerationHelper SqlGenerationHelper
     /// <param name="commandStringBuilder">The builder to which the SQL should be appended.</param>
     /// <param name="name">The name of the table.</param>
     /// <param name="schema">The table schema, or <see langword="null" /> to use the default schema.</param>
+    /// <param name="readOperations">The operations for column values to be read back.</param>
     /// <param name="conditionOperations">The operations used to generate the <c>WHERE</c> clause for the delete.</param>
+    /// <param name="additionalReadValues">Additional values to be read back.</param>
     protected virtual void AppendDeleteCommand(
         StringBuilder commandStringBuilder,
         string name,
         string? schema,
-        IReadOnlyList<IColumnModification> conditionOperations)
+        IReadOnlyList<IColumnModification> readOperations,
+        IReadOnlyList<IColumnModification> conditionOperations,
+        string? additionalReadValues = null)
     {
         AppendDeleteCommandHeader(commandStringBuilder, name, schema);
         AppendWhereClause(commandStringBuilder, conditionOperations);
+        AppendReturningClause(commandStringBuilder, readOperations, additionalReadValues);
         commandStringBuilder.AppendLine(SqlGenerationHelper.StatementTerminator);
     }
 
-    /// <summary>
-    ///     Appends a SQL command for selecting the number of rows affected.
-    /// </summary>
-    /// <param name="commandStringBuilder">The builder to which the SQL should be appended.</param>
-    /// <param name="name">The name of the table.</param>
-    /// <param name="schema">The table schema, or <see langword="null" /> to use the default schema.</param>
-    /// <param name="commandPosition">The ordinal of the command for which rows affected it being returned.</param>
-    /// <returns>The <see cref="ResultSetMapping" /> for this command.</returns>
-    protected virtual ResultSetMapping AppendSelectAffectedCountCommand(
-        StringBuilder commandStringBuilder,
-        string name,
-        string? schema,
-        int commandPosition)
-        => ResultSetMapping.NoResultSet;
-
     /// <summary>
     ///     Appends a SQL command for selecting affected data.
     /// </summary>
@@ -411,11 +400,13 @@ protected virtual ISqlGenerationHelper SqlGenerationHelper
     /// </summary>
     /// <param name="commandStringBuilder">The builder to which the SQL should be appended.</param>
     /// <param name="operations">The operations for column values to be read back.</param>
+    /// <param name="additionalValues">Additional values to be read back.</param>
     protected virtual void AppendReturningClause(
         StringBuilder commandStringBuilder,
-        IReadOnlyList<IColumnModification> operations)
+        IReadOnlyList<IColumnModification> operations,
+        string? additionalValues = null)
     {
-        if (operations.Count > 0)
+        if (operations.Count > 0 || additionalValues is not null)
         {
             commandStringBuilder
                 .AppendLine()
@@ -424,6 +415,16 @@ protected virtual ISqlGenerationHelper SqlGenerationHelper
                     operations,
                     SqlGenerationHelper,
                     (sb, o, helper) => helper.DelimitIdentifier(sb, o.ColumnName));
+
+            if (additionalValues is not null)
+            {
+                if (operations.Count > 0)
+                {
+                    commandStringBuilder.Append(", ");
+                }
+
+                commandStringBuilder.Append(additionalValues);
+            }
         }
     }
 
diff --git a/src/EFCore.SqlServer/Update/Internal/SqlServerUpdateSqlGenerator.cs b/src/EFCore.SqlServer/Update/Internal/SqlServerUpdateSqlGenerator.cs
index 7d08eb1283..c633fc85db 100644
--- a/src/EFCore.SqlServer/Update/Internal/SqlServerUpdateSqlGenerator.cs
+++ b/src/EFCore.SqlServer/Update/Internal/SqlServerUpdateSqlGenerator.cs
@@ -47,8 +47,7 @@ public class SqlServerUpdateSqlGenerator : UpdateSqlGenerator, ISqlServerUpdateS
         // If no database-generated columns need to be read back, just do a simple INSERT (default behavior).
         // If there are generated columns but there are no triggers defined on the table, we can do a simple INSERT ... OUTPUT
         // (without INTO), which is also the default behavior, doesn't require a transaction and is the most efficient.
-        if (command.ColumnModifications.All(o => !o.IsRead)
-            || !command.Entries[0].EntityType.Model.GetRelationalModel().FindTable(command.TableName, command.Schema)!.Triggers.Any())
+        if (command.ColumnModifications.All(o => !o.IsRead) || !HasAnyTriggers(command))
         {
             return base.AppendInsertOperation(commandStringBuilder, command, commandPosition, out requiresTransaction);
         }
@@ -94,6 +93,124 @@ public class SqlServerUpdateSqlGenerator : UpdateSqlGenerator, ISqlServerUpdateS
         commandStringBuilder.AppendLine(SqlGenerationHelper.StatementTerminator);
     }
 
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public override ResultSetMapping AppendUpdateOperation(
+        StringBuilder commandStringBuilder,
+        IReadOnlyModificationCommand command,
+        int commandPosition,
+        out bool requiresTransaction)
+    {
+        // We normally do a simple UPDATE with an OUTPUT clause (either for the generated columns, or for "1" for concurrency checking).
+        // However, if there are triggers defined, OUTPUT (without INTO) is not supported, so we do UPDATE+SELECT.
+        if (!HasAnyTriggers(command))
+        {
+            return base.AppendUpdateOperation(commandStringBuilder, command, commandPosition, out requiresTransaction);
+        }
+
+        var name = command.TableName;
+        var schema = command.Schema;
+        var operations = command.ColumnModifications;
+
+        var writeOperations = operations.Where(o => o.IsWrite).ToList();
+        var conditionOperations = operations.Where(o => o.IsCondition).ToList();
+        var readOperations = operations.Where(o => o.IsRead).ToList();
+
+        AppendUpdateCommand(commandStringBuilder, name, schema, writeOperations, Array.Empty<IColumnModification>(), conditionOperations);
+
+        if (readOperations.Count > 0)
+        {
+            var keyOperations = operations.Where(o => o.IsKey).ToList();
+
+            requiresTransaction = true;
+
+            return AppendSelectAffectedCommand(commandStringBuilder, name, schema, readOperations, keyOperations, commandPosition);
+        }
+
+        requiresTransaction = false;
+
+        return AppendSelectAffectedCountCommand(commandStringBuilder, name, schema, commandPosition);
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    protected override void AppendUpdateCommand(
+        StringBuilder commandStringBuilder,
+        string name,
+        string? schema,
+        IReadOnlyList<IColumnModification> writeOperations,
+        IReadOnlyList<IColumnModification> readOperations,
+        IReadOnlyList<IColumnModification> conditionOperations,
+        string? additionalReadValues = null)
+    {
+        // In SQL Server the OUTPUT clause is placed differently (before the WHERE instead of at the end)
+        AppendUpdateCommandHeader(commandStringBuilder, name, schema, writeOperations);
+        AppendOutputClause(commandStringBuilder, readOperations, additionalReadValues);
+        AppendWhereClause(commandStringBuilder, conditionOperations);
+        commandStringBuilder.AppendLine(SqlGenerationHelper.StatementTerminator);
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public override ResultSetMapping AppendDeleteOperation(
+        StringBuilder commandStringBuilder,
+        IReadOnlyModificationCommand command,
+        int commandPosition,
+        out bool requiresTransaction)
+    {
+        // We normally do a simple DELETE, with an OUTPUT clause emitting "1" for concurrency checking.
+        // However, if there are triggers defined, OUTPUT (without INTO) is not supported, so we do UPDATE+SELECT.
+        if (!HasAnyTriggers(command))
+        {
+            return base.AppendDeleteOperation(commandStringBuilder, command, commandPosition, out requiresTransaction);
+        }
+
+        var name = command.TableName;
+        var schema = command.Schema;
+        var operations = command.ColumnModifications;
+
+        var conditionOperations = operations.Where(o => o.IsCondition).ToList();
+
+        requiresTransaction = false;
+
+        AppendDeleteCommand(commandStringBuilder, name, schema, Array.Empty<IColumnModification>(), conditionOperations);
+
+        return AppendSelectAffectedCountCommand(commandStringBuilder, name, schema, commandPosition);
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    protected override void AppendDeleteCommand(
+        StringBuilder commandStringBuilder,
+        string name,
+        string? schema,
+        IReadOnlyList<IColumnModification> readOperations,
+        IReadOnlyList<IColumnModification> conditionOperations,
+        string? additionalReadValues = null)
+    {
+        // In SQL Server the OUTPUT clause is placed differently (before the WHERE instead of at the end)
+        AppendDeleteCommandHeader(commandStringBuilder, name, schema);
+        AppendOutputClause(commandStringBuilder, readOperations, additionalReadValues);
+        AppendWhereClause(commandStringBuilder, conditionOperations);
+        commandStringBuilder.AppendLine(SqlGenerationHelper.StatementTerminator);
+    }
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -200,8 +317,7 @@ public class SqlServerUpdateSqlGenerator : UpdateSqlGenerator, ISqlServerUpdateS
         // We default to using MERGE ... OUTPUT (without INTO), projecting back a synthetic _Position column to know the order back
         // at the client and propagate database-generated values correctly. However, if any triggers are defined, OUTPUT without INTO
         // doesn't work.
-        if (!firstCommand.Entries[0].EntityType.Model.GetRelationalModel().FindTable(firstCommand.TableName, firstCommand.Schema)!
-                .Triggers.Any())
+        if (!HasAnyTriggers(firstCommand))
         {
             // MERGE ... OUTPUT returns rows whose ordering isn't guaranteed. So this technique projects back a position int with each row,
             // to allow mapping the rows back for value propagation.
@@ -578,16 +694,17 @@ private static string GetTypeNameForCopy(IProperty property)
     /// </summary>
     protected override void AppendReturningClause(
         StringBuilder commandStringBuilder,
-        IReadOnlyList<IColumnModification> operations)
-        => AppendOutputClause(commandStringBuilder, operations);
+        IReadOnlyList<IColumnModification> operations,
+        string? additionalValues = null)
+        => AppendOutputClause(commandStringBuilder, operations, additionalValues);
 
     // ReSharper disable once ParameterTypeCanBeEnumerable.Local
     private void AppendOutputClause(
         StringBuilder commandStringBuilder,
         IReadOnlyList<IColumnModification> operations,
-        string? additionalColumns = null)
+        string? additionalReadValues = null)
     {
-        if (operations.Count > 0 || additionalColumns is not null)
+        if (operations.Count > 0 || additionalReadValues is not null)
         {
             commandStringBuilder
                 .AppendLine()
@@ -601,14 +718,14 @@ private static string GetTypeNameForCopy(IProperty property)
                         helper.DelimitIdentifier(sb, o.ColumnName);
                     });
 
-            if (additionalColumns != null)
+            if (additionalReadValues is not null)
             {
                 if (operations.Count > 0)
                 {
                     commandStringBuilder.Append(", ");
                 }
 
-                commandStringBuilder.Append(additionalColumns);
+                commandStringBuilder.Append(additionalReadValues);
             }
         }
     }
@@ -728,7 +845,7 @@ private static string GetTypeNameForCopy(IProperty property)
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    protected override ResultSetMapping AppendSelectAffectedCountCommand(
+    protected virtual ResultSetMapping AppendSelectAffectedCountCommand(
         StringBuilder commandStringBuilder,
         string name,
         string? schema,
@@ -790,4 +907,10 @@ protected override void AppendRowsAffectedWhereCondition(StringBuilder commandSt
         => commandStringBuilder
             .Append("@@ROWCOUNT = ")
             .Append(expectedRowsAffected.ToString(CultureInfo.InvariantCulture));
+
+    private static bool HasAnyTriggers(IReadOnlyModificationCommand command)
+        // Data seeding doesn't provide any entries, so we we don't know if the table has triggers; assume it does to generate SQL
+        // that works everywhere.
+        => command.Entries.Count == 0
+            || command.Entries[0].EntityType.Model.GetRelationalModel().FindTable(command.TableName, command.Schema)!.Triggers.Any();
 }
diff --git a/src/EFCore.Sqlite.Core/Update/Internal/SqliteUpdateSqlGenerator.cs b/src/EFCore.Sqlite.Core/Update/Internal/SqliteUpdateSqlGenerator.cs
index e92eb82e08..5ea20d8b67 100644
--- a/src/EFCore.Sqlite.Core/Update/Internal/SqliteUpdateSqlGenerator.cs
+++ b/src/EFCore.Sqlite.Core/Update/Internal/SqliteUpdateSqlGenerator.cs
@@ -38,26 +38,6 @@ protected override void AppendIdentityWhereCondition(StringBuilder commandString
             .Append("last_insert_rowid()");
     }
 
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    protected override ResultSetMapping AppendSelectAffectedCountCommand(
-        StringBuilder commandStringBuilder,
-        string name,
-        string? schema,
-        int commandPosition)
-    {
-        commandStringBuilder
-            .Append("SELECT changes()")
-            .AppendLine(SqlGenerationHelper.StatementTerminator)
-            .AppendLine();
-
-        return ResultSetMapping.LastInResultSet;
-    }
-
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
diff --git a/test/EFCore.Relational.Specification.Tests/Update/StoreValueGenerationTestBase.cs b/test/EFCore.Relational.Specification.Tests/Update/StoreValueGenerationTestBase.cs
index 007f32d838..f790bf1219 100644
--- a/test/EFCore.Relational.Specification.Tests/Update/StoreValueGenerationTestBase.cs
+++ b/test/EFCore.Relational.Specification.Tests/Update/StoreValueGenerationTestBase.cs
@@ -329,22 +329,7 @@ public virtual Task Delete_Delete_with_different_entity_types(bool async)
         EntityState? secondOperationType,
         GeneratedValues generatedValues,
         bool withSameEntityType)
-    {
-        // By default, two changes require a transaction
-        if (secondOperationType is not null)
-        {
-            return true;
-        }
-
-        // Deletes don't ever need to bring back database-generated values, and inserts use the RETURNING clause - no transaction needed
-        if (firstOperationType is EntityState.Deleted or EntityState.Added)
-        {
-            return false;
-        }
-
-        // Fetching back database-generated values from an update requires a transaction
-        return generatedValues != GeneratedValues.None;
-    }
+        => secondOperationType is not null;
 
     /// <summary>
     ///     Providers can override this to specify how many commands (batches) are used to execute the update.
diff --git a/test/EFCore.Relational.Specification.Tests/Update/UpdateSqlGeneratorTestBase.cs b/test/EFCore.Relational.Specification.Tests/Update/UpdateSqlGeneratorTestBase.cs
index 8243c42190..d0544ef623 100644
--- a/test/EFCore.Relational.Specification.Tests/Update/UpdateSqlGeneratorTestBase.cs
+++ b/test/EFCore.Relational.Specification.Tests/Update/UpdateSqlGeneratorTestBase.cs
@@ -17,28 +17,11 @@ public virtual void AppendDeleteOperation_creates_full_delete_command_text()
 
         CreateSqlGenerator().AppendDeleteOperation(stringBuilder, command, 0);
 
-        Assert.Equal(
-            "DELETE FROM "
-            + SchemaPrefix
-            + OpenDelimiter
-            + "Ducks"
-            + CloseDelimiter
-            + ""
-            + Environment.NewLine
-            + "WHERE "
-            + OpenDelimiter
-            + "Id"
-            + CloseDelimiter
-            + " = @p0;"
-            + Environment.NewLine
-            + "SELECT "
-            + RowsAffected
-            + ";"
-            + Environment.NewLine
-            + Environment.NewLine,
-            stringBuilder.ToString());
+        AppendDeleteOperation_creates_full_delete_command_text_verification(stringBuilder);
     }
 
+    protected abstract void AppendDeleteOperation_creates_full_delete_command_text_verification(StringBuilder stringBuilder);
+
     [ConditionalFact]
     public virtual void AppendDeleteOperation_creates_full_delete_command_text_with_concurrency_check()
     {
@@ -47,32 +30,12 @@ public virtual void AppendDeleteOperation_creates_full_delete_command_text_with_
 
         CreateSqlGenerator().AppendDeleteOperation(stringBuilder, command, 0);
 
-        Assert.Equal(
-            "DELETE FROM "
-            + SchemaPrefix
-            + OpenDelimiter
-            + "Ducks"
-            + CloseDelimiter
-            + ""
-            + Environment.NewLine
-            + "WHERE "
-            + OpenDelimiter
-            + "Id"
-            + CloseDelimiter
-            + " = @p0 AND "
-            + OpenDelimiter
-            + "ConcurrencyToken"
-            + CloseDelimiter
-            + " IS NULL;"
-            + Environment.NewLine
-            + "SELECT "
-            + RowsAffected
-            + ";"
-            + Environment.NewLine
-            + Environment.NewLine,
-            stringBuilder.ToString());
+        AppendDeleteOperation_creates_full_delete_command_text_with_concurrency_check_verification(stringBuilder);
     }
 
+    protected abstract void AppendDeleteOperation_creates_full_delete_command_text_with_concurrency_check_verification(
+        StringBuilder stringBuilder);
+
     [ConditionalFact]
     public virtual void AppendInsertOperation_insert_if_store_generated_columns_exist()
     {
@@ -177,114 +140,31 @@ public virtual void AppendInsertOperation_for_only_single_identity_columns()
     protected abstract void AppendInsertOperation_for_only_single_identity_columns_verification(StringBuilder stringBuilder);
 
     [ConditionalFact]
-    public virtual void AppendUpdateOperation_appends_update_and_select_if_store_generated_columns_exist()
+    public virtual void AppendUpdateOperation_if_store_generated_columns_exist()
     {
         var stringBuilder = new StringBuilder();
         var command = CreateUpdateCommand();
 
         CreateSqlGenerator().AppendUpdateOperation(stringBuilder, command, 0);
 
-        AppendUpdateOperation_appends_update_and_select_if_store_generated_columns_exist_verification(stringBuilder);
+        AppendUpdateOperation_if_store_generated_columns_exist_verification(stringBuilder);
     }
 
-    protected virtual void AppendUpdateOperation_appends_update_and_select_if_store_generated_columns_exist_verification(
-        StringBuilder stringBuilder)
-        => Assert.Equal(
-            "UPDATE "
-            + SchemaPrefix
-            + OpenDelimiter
-            + "Ducks"
-            + CloseDelimiter
-            + " SET "
-            + OpenDelimiter
-            + "Name"
-            + CloseDelimiter
-            + " = @p0, "
-            + OpenDelimiter
-            + "Quacks"
-            + CloseDelimiter
-            + " = @p1, "
-            + OpenDelimiter
-            + "ConcurrencyToken"
-            + CloseDelimiter
-            + " = @p2"
-            + Environment.NewLine
-            + "WHERE "
-            + OpenDelimiter
-            + "Id"
-            + CloseDelimiter
-            + " = @p3 AND "
-            + OpenDelimiter
-            + "ConcurrencyToken"
-            + CloseDelimiter
-            + " IS NULL;"
-            + Environment.NewLine
-            + "SELECT "
-            + OpenDelimiter
-            + "Computed"
-            + CloseDelimiter
-            + ""
-            + Environment.NewLine
-            + "FROM "
-            + SchemaPrefix
-            + OpenDelimiter
-            + "Ducks"
-            + CloseDelimiter
-            + ""
-            + Environment.NewLine
-            + "WHERE "
-            + RowsAffected
-            + " = 1 AND "
-            + OpenDelimiter
-            + "Id"
-            + CloseDelimiter
-            + " = @p3;"
-            + Environment.NewLine
-            + Environment.NewLine,
-            stringBuilder.ToString());
+    protected abstract void AppendUpdateOperation_if_store_generated_columns_exist_verification(StringBuilder stringBuilder);
 
     [ConditionalFact]
-    public virtual void AppendUpdateOperation_appends_update_and_select_rowcount_if_store_generated_columns_dont_exist()
+    public virtual void AppendUpdateOperation_if_store_generated_columns_dont_exist()
     {
         var stringBuilder = new StringBuilder();
         var command = CreateUpdateCommand(false, false);
 
         CreateSqlGenerator().AppendUpdateOperation(stringBuilder, command, 0);
 
-        Assert.Equal(
-            "UPDATE "
-            + SchemaPrefix
-            + OpenDelimiter
-            + "Ducks"
-            + CloseDelimiter
-            + " SET "
-            + OpenDelimiter
-            + "Name"
-            + CloseDelimiter
-            + " = @p0, "
-            + OpenDelimiter
-            + "Quacks"
-            + CloseDelimiter
-            + " = @p1, "
-            + OpenDelimiter
-            + "ConcurrencyToken"
-            + CloseDelimiter
-            + " = @p2"
-            + Environment.NewLine
-            + "WHERE "
-            + OpenDelimiter
-            + "Id"
-            + CloseDelimiter
-            + " = @p3;"
-            + Environment.NewLine
-            + "SELECT "
-            + RowsAffected
-            + ";"
-            + Environment.NewLine
-            + Environment.NewLine,
-            stringBuilder.ToString());
+        AppendUpdateOperation_if_store_generated_columns_dont_exist_verification(stringBuilder);
     }
 
+    protected abstract void AppendUpdateOperation_if_store_generated_columns_dont_exist_verification(StringBuilder stringBuilder);
+
     [ConditionalFact]
     public virtual void AppendUpdateOperation_appends_where_for_concurrency_token()
     {
@@ -293,105 +173,23 @@ public virtual void AppendUpdateOperation_appends_where_for_concurrency_token()
 
         CreateSqlGenerator().AppendUpdateOperation(stringBuilder, command, 0);
 
-        Assert.Equal(
-            "UPDATE "
-            + SchemaPrefix
-            + OpenDelimiter
-            + "Ducks"
-            + CloseDelimiter
-            + " SET "
-            + OpenDelimiter
-            + "Name"
-            + CloseDelimiter
-            + " = @p0, "
-            + OpenDelimiter
-            + "Quacks"
-            + CloseDelimiter
-            + " = @p1, "
-            + OpenDelimiter
-            + "ConcurrencyToken"
-            + CloseDelimiter
-            + " = @p2"
-            + Environment.NewLine
-            + "WHERE "
-            + OpenDelimiter
-            + "Id"
-            + CloseDelimiter
-            + " = @p3 AND "
-            + OpenDelimiter
-            + "ConcurrencyToken"
-            + CloseDelimiter
-            + " IS NULL;"
-            + Environment.NewLine
-            + "SELECT "
-            + RowsAffected
-            + ";"
-            + Environment.NewLine
-            + Environment.NewLine,
-            stringBuilder.ToString());
+        AppendUpdateOperation_appends_where_for_concurrency_token_verification(stringBuilder);
     }
 
+    protected abstract void AppendUpdateOperation_appends_where_for_concurrency_token_verification(StringBuilder stringBuilder);
+
     [ConditionalFact]
-    public virtual void AppendUpdateOperation_appends_select_for_computed_property()
+    public virtual void AppendUpdateOperation_for_computed_property()
     {
         var stringBuilder = new StringBuilder();
         var command = CreateUpdateCommand(true, false);
 
         CreateSqlGenerator().AppendUpdateOperation(stringBuilder, command, 0);
 
-        AppendUpdateOperation_appends_select_for_computed_property_verification(stringBuilder);
+        AppendUpdateOperation_for_computed_property_verification(stringBuilder);
     }
 
-    protected virtual void AppendUpdateOperation_appends_select_for_computed_property_verification(StringBuilder stringBuilder)
-        => Assert.Equal(
-            "UPDATE "
-            + SchemaPrefix
-            + OpenDelimiter
-            + "Ducks"
-            + CloseDelimiter
-            + " SET "
-            + OpenDelimiter
-            + "Name"
-            + CloseDelimiter
-            + " = @p0, "
-            + OpenDelimiter
-            + "Quacks"
-            + CloseDelimiter
-            + " = @p1, "
-            + OpenDelimiter
-            + "ConcurrencyToken"
-            + CloseDelimiter
-            + " = @p2"
-            + Environment.NewLine
-            + "WHERE "
-            + OpenDelimiter
-            + "Id"
-            + CloseDelimiter
-            + " = @p3;"
-            + Environment.NewLine
-            + "SELECT "
-            + OpenDelimiter
-            + "Computed"
-            + CloseDelimiter
-            + ""
-            + Environment.NewLine
-            + "FROM "
-            + SchemaPrefix
-            + OpenDelimiter
-            + "Ducks"
-            + CloseDelimiter
-            + ""
-            + Environment.NewLine
-            + "WHERE "
-            + RowsAffected
-            + " = 1 AND "
-            + OpenDelimiter
-            + "Id"
-            + CloseDelimiter
-            + " = @p3;"
-            + Environment.NewLine
-            + Environment.NewLine,
-            stringBuilder.ToString());
+    protected abstract void AppendUpdateOperation_for_computed_property_verification(StringBuilder stringBuilder);
 
     [ConditionalFact]
     public virtual void GenerateNextSequenceValueOperation_returns_statement_with_sanitized_sequence()
diff --git a/test/EFCore.Relational.Tests/TestUtilities/FakeProvider/FakeSqlGenerator.cs b/test/EFCore.Relational.Tests/TestUtilities/FakeProvider/FakeSqlGenerator.cs
index 3a45ae9629..84e737066f 100644
--- a/test/EFCore.Relational.Tests/TestUtilities/FakeProvider/FakeSqlGenerator.cs
+++ b/test/EFCore.Relational.Tests/TestUtilities/FakeProvider/FakeSqlGenerator.cs
@@ -57,18 +57,6 @@ protected override void AppendIdentityWhereCondition(StringBuilder commandString
             .Append(" = ")
             .Append("provider_specific_identity()");
 
-    protected override ResultSetMapping AppendSelectAffectedCountCommand(
-        StringBuilder commandStringBuilder,
-        string name,
-        string schema,
-        int commandPosition)
-    {
-        commandStringBuilder
-            .Append("SELECT provider_specific_rowcount();").Append(Environment.NewLine).Append(Environment.NewLine);
-
-        return ResultSetMapping.LastInResultSet;
-    }
-
     protected override void AppendRowsAffectedWhereCondition(StringBuilder commandStringBuilder, int expectedRowsAffected)
         => commandStringBuilder
             .Append("provider_specific_rowcount() = ").Append(expectedRowsAffected);
diff --git a/test/EFCore.Relational.Tests/Update/UpdateSqlGeneratorTest.cs b/test/EFCore.Relational.Tests/Update/UpdateSqlGeneratorTest.cs
index 825deece69..34c232b073 100644
--- a/test/EFCore.Relational.Tests/Update/UpdateSqlGeneratorTest.cs
+++ b/test/EFCore.Relational.Tests/Update/UpdateSqlGeneratorTest.cs
@@ -16,6 +16,22 @@ protected override IUpdateSqlGenerator CreateSqlGenerator()
                     TestServiceFactory.Instance.Create<TypeMappingSourceDependencies>(),
                     TestServiceFactory.Instance.Create<RelationalTypeMappingSourceDependencies>())));
 
+    protected override void AppendDeleteOperation_creates_full_delete_command_text_verification(StringBuilder stringBuilder)
+        => AssertBaseline(
+            @"DELETE FROM ""dbo"".""Ducks""
+WHERE ""Id"" = @p0
+RETURNING 1;
+",
+            stringBuilder.ToString());
+
+    protected override void AppendDeleteOperation_creates_full_delete_command_text_with_concurrency_check_verification(StringBuilder stringBuilder)
+        => AssertBaseline(
+            @"DELETE FROM ""dbo"".""Ducks""
+WHERE ""Id"" = @p0 AND ""ConcurrencyToken"" IS NULL
+RETURNING 1;
+",
+            stringBuilder.ToString());
+
     protected override void AppendInsertOperation_insert_if_store_generated_columns_exist_verification(StringBuilder stringBuilder)
         => AssertBaseline(
             @"INSERT INTO ""dbo"".""Ducks"" (""Name"", ""Quacks"", ""ConcurrencyToken"")
@@ -55,6 +71,38 @@ DEFAULT VALUES
             @"INSERT INTO ""dbo"".""Ducks""
 DEFAULT VALUES
 RETURNING ""Id"";
+",
+            stringBuilder.ToString());
+
+    protected override void AppendUpdateOperation_if_store_generated_columns_exist_verification(StringBuilder stringBuilder)
+        => AssertBaseline(
+            @"UPDATE ""dbo"".""Ducks"" SET ""Name"" = @p0, ""Quacks"" = @p1, ""ConcurrencyToken"" = @p2
+WHERE ""Id"" = @p3 AND ""ConcurrencyToken"" IS NULL
+RETURNING ""Computed"";
+",
+            stringBuilder.ToString());
+
+    protected override void AppendUpdateOperation_if_store_generated_columns_dont_exist_verification(StringBuilder stringBuilder)
+        => AssertBaseline(
+            @"UPDATE ""dbo"".""Ducks"" SET ""Name"" = @p0, ""Quacks"" = @p1, ""ConcurrencyToken"" = @p2
+WHERE ""Id"" = @p3
+RETURNING 1;
+",
+            stringBuilder.ToString());
+
+    protected override void AppendUpdateOperation_appends_where_for_concurrency_token_verification(StringBuilder stringBuilder)
+        => AssertBaseline(
+            @"UPDATE ""dbo"".""Ducks"" SET ""Name"" = @p0, ""Quacks"" = @p1, ""ConcurrencyToken"" = @p2
+WHERE ""Id"" = @p3 AND ""ConcurrencyToken"" IS NULL
+RETURNING 1;
+",
+            stringBuilder.ToString());
+
+    protected override void AppendUpdateOperation_for_computed_property_verification(StringBuilder stringBuilder)
+        => AssertBaseline(
+            @"UPDATE ""dbo"".""Ducks"" SET ""Name"" = @p0, ""Quacks"" = @p1, ""ConcurrencyToken"" = @p2
+WHERE ""Id"" = @p3
+RETURNING ""Computed"";
 ",
             stringBuilder.ToString());
 
diff --git a/test/EFCore.SqlServer.FunctionalTests/DataAnnotationSqlServerTest.cs b/test/EFCore.SqlServer.FunctionalTests/DataAnnotationSqlServerTest.cs
index 77547e4d67..f8cab2a2ac 100644
--- a/test/EFCore.SqlServer.FunctionalTests/DataAnnotationSqlServerTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/DataAnnotationSqlServerTest.cs
@@ -167,8 +167,8 @@ public override void ConcurrencyCheckAttribute_throws_if_value_in_database_chang
 SET IMPLICIT_TRANSACTIONS OFF;
 SET NOCOUNT ON;
 UPDATE [Sample] SET [Name] = @p0, [RowVersion] = @p1
-WHERE [Unique_No] = @p2 AND [RowVersion] = @p3;
-SELECT @@ROWCOUNT;",
+OUTPUT 1
+WHERE [Unique_No] = @p2 AND [RowVersion] = @p3;",
             //
             @"@p2='1'
 @p0='ChangedData' (Nullable = false) (Size = 4000)
@@ -178,8 +178,8 @@ public override void ConcurrencyCheckAttribute_throws_if_value_in_database_chang
 SET IMPLICIT_TRANSACTIONS OFF;
 SET NOCOUNT ON;
 UPDATE [Sample] SET [Name] = @p0, [RowVersion] = @p1
-WHERE [Unique_No] = @p2 AND [RowVersion] = @p3;
-SELECT @@ROWCOUNT;");
+OUTPUT 1
+WHERE [Unique_No] = @p2 AND [RowVersion] = @p3;");
     }
 
     public override void DatabaseGeneratedAttribute_autogenerates_values_when_set_to_identity()
diff --git a/test/EFCore.SqlServer.FunctionalTests/OptimisticConcurrencySqlServerTest.cs b/test/EFCore.SqlServer.FunctionalTests/OptimisticConcurrencySqlServerTest.cs
index 469a2b2120..21b4c363f2 100644
--- a/test/EFCore.SqlServer.FunctionalTests/OptimisticConcurrencySqlServerTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/OptimisticConcurrencySqlServerTest.cs
@@ -169,8 +169,8 @@ public override void Property_entry_original_value_is_set()
 SET IMPLICIT_TRANSACTIONS OFF;
 SET NOCOUNT ON;
 UPDATE [Engines] SET [Name] = @p0
-WHERE [Id] = @p1 AND [EngineSupplierId] = @p2 AND [Name] = @p3 AND [StorageLocation_Latitude] = @p4 AND [StorageLocation_Longitude] = @p5;
-SELECT @@ROWCOUNT;");
+OUTPUT 1
+WHERE [Id] = @p1 AND [EngineSupplierId] = @p2 AND [Name] = @p3 AND [StorageLocation_Latitude] = @p4 AND [StorageLocation_Longitude] = @p5;");
     }
 
     private void AssertSql(params string[] expected)
diff --git a/test/EFCore.SqlServer.FunctionalTests/Query/IncompleteMappingInheritanceQuerySqlServerTest.cs b/test/EFCore.SqlServer.FunctionalTests/Query/IncompleteMappingInheritanceQuerySqlServerTest.cs
index 85a40748b6..98a6c6c600 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Query/IncompleteMappingInheritanceQuerySqlServerTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Query/IncompleteMappingInheritanceQuerySqlServerTest.cs
@@ -404,8 +404,8 @@ public override void Can_insert_update_delete()
 SET IMPLICIT_TRANSACTIONS OFF;
 SET NOCOUNT ON;
 UPDATE [Animals] SET [EagleId] = @p0
-WHERE [Species] = @p1;
-SELECT @@ROWCOUNT;",
+OUTPUT 1
+WHERE [Species] = @p1;",
             //
             @"SELECT TOP(2) [a].[Species], [a].[CountryId], [a].[Discriminator], [a].[Name], [a].[EagleId], [a].[IsFlightless], [a].[FoundOn]
 FROM [Animals] AS [a]
@@ -416,8 +416,8 @@ public override void Can_insert_update_delete()
 SET IMPLICIT_TRANSACTIONS OFF;
 SET NOCOUNT ON;
 DELETE FROM [Animals]
-WHERE [Species] = @p0;
-SELECT @@ROWCOUNT;",
+OUTPUT 1
+WHERE [Species] = @p0;",
             //
             @"SELECT COUNT(*)
 FROM [Animals] AS [a]
diff --git a/test/EFCore.SqlServer.FunctionalTests/Query/InheritanceQuerySqlServerTest.cs b/test/EFCore.SqlServer.FunctionalTests/Query/InheritanceQuerySqlServerTest.cs
index 3f58c6ef53..cf4ed45898 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Query/InheritanceQuerySqlServerTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Query/InheritanceQuerySqlServerTest.cs
@@ -378,8 +378,8 @@ public override void Can_insert_update_delete()
 SET IMPLICIT_TRANSACTIONS OFF;
 SET NOCOUNT ON;
 UPDATE [Animals] SET [EagleId] = @p0
-WHERE [Species] = @p1;
-SELECT @@ROWCOUNT;",
+OUTPUT 1
+WHERE [Species] = @p1;",
             //
             @"SELECT TOP(2) [a].[Species], [a].[CountryId], [a].[Discriminator], [a].[Name], [a].[EagleId], [a].[IsFlightless], [a].[FoundOn]
 FROM [Animals] AS [a]
@@ -390,8 +390,8 @@ public override void Can_insert_update_delete()
 SET IMPLICIT_TRANSACTIONS OFF;
 SET NOCOUNT ON;
 DELETE FROM [Animals]
-WHERE [Species] = @p0;
-SELECT @@ROWCOUNT;",
+OUTPUT 1
+WHERE [Species] = @p0;",
             //
             @"SELECT COUNT(*)
 FROM [Animals] AS [a]
diff --git a/test/EFCore.SqlServer.FunctionalTests/Query/TPTInheritanceQuerySqlServerTest.cs b/test/EFCore.SqlServer.FunctionalTests/Query/TPTInheritanceQuerySqlServerTest.cs
index 6c45fc1809..a31d28b8f5 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Query/TPTInheritanceQuerySqlServerTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Query/TPTInheritanceQuerySqlServerTest.cs
@@ -136,8 +136,8 @@ public override void Can_insert_update_delete()
 SET IMPLICIT_TRANSACTIONS OFF;
 SET NOCOUNT ON;
 UPDATE [Birds] SET [EagleId] = @p0
-WHERE [Species] = @p1;
-SELECT @@ROWCOUNT;",
+OUTPUT 1
+WHERE [Species] = @p1;",
             //
             @"SELECT TOP(2) [a].[Species], [a].[CountryId], [a].[Name], [b].[EagleId], [b].[IsFlightless], [k].[FoundOn]
 FROM [Animals] AS [a]
@@ -150,24 +150,24 @@ public override void Can_insert_update_delete()
 SET IMPLICIT_TRANSACTIONS OFF;
 SET NOCOUNT ON;
 DELETE FROM [Kiwi]
-WHERE [Species] = @p0;
-SELECT @@ROWCOUNT;",
+OUTPUT 1
+WHERE [Species] = @p0;",
             //
             @"@p1='Apteryx owenii' (Nullable = false) (Size = 100)
 
 SET IMPLICIT_TRANSACTIONS OFF;
 SET NOCOUNT ON;
 DELETE FROM [Birds]
-WHERE [Species] = @p1;
-SELECT @@ROWCOUNT;",
+OUTPUT 1
+WHERE [Species] = @p1;",
             //
             @"@p2='Apteryx owenii' (Nullable = false) (Size = 100)
 
 SET IMPLICIT_TRANSACTIONS OFF;
 SET NOCOUNT ON;
 DELETE FROM [Animals]
-WHERE [Species] = @p2;
-SELECT @@ROWCOUNT;",
+OUTPUT 1
+WHERE [Species] = @p2;",
             //
             @"SELECT COUNT(*)
 FROM [Animals] AS [a]
diff --git a/test/EFCore.SqlServer.FunctionalTests/TPTTableSplittingSqlServerTest.cs b/test/EFCore.SqlServer.FunctionalTests/TPTTableSplittingSqlServerTest.cs
index 4f9bbb9011..518ec2d7f5 100644
--- a/test/EFCore.SqlServer.FunctionalTests/TPTTableSplittingSqlServerTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/TPTTableSplittingSqlServerTest.cs
@@ -190,8 +190,8 @@ public override async Task Can_change_dependent_instance_non_derived()
 SET IMPLICIT_TRANSACTIONS OFF;
 SET NOCOUNT ON;
 UPDATE [Vehicles] SET [Operator_Name] = @p0
-WHERE [Name] = @p1;
-SELECT @@ROWCOUNT;",
+OUTPUT 1
+WHERE [Name] = @p1;",
             //
             @"@p2='Trek Pro Fit Madone 6 Series' (Nullable = false) (Size = 450)
 @p3='Repair' (Size = 4000)
@@ -233,8 +233,8 @@ public override async Task Can_change_principal_instance_non_derived()
 SET IMPLICIT_TRANSACTIONS OFF;
 SET NOCOUNT ON;
 UPDATE [Vehicles] SET [SeatingCapacity] = @p0
-WHERE [Name] = @p1;
-SELECT @@ROWCOUNT;",
+OUTPUT 1
+WHERE [Name] = @p1;",
             //
             @"SELECT TOP(2) [v].[Name], [v].[SeatingCapacity], [c].[AttachedVehicleName], CASE
     WHEN [c].[Name] IS NOT NULL THEN N'CompositeVehicle'
diff --git a/test/EFCore.SqlServer.FunctionalTests/TableSplittingSqlServerTest.cs b/test/EFCore.SqlServer.FunctionalTests/TableSplittingSqlServerTest.cs
index 4fa4ba6108..30f4308c71 100644
--- a/test/EFCore.SqlServer.FunctionalTests/TableSplittingSqlServerTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/TableSplittingSqlServerTest.cs
@@ -213,8 +213,8 @@ public override async Task Can_change_dependent_instance_non_derived()
 SET IMPLICIT_TRANSACTIONS OFF;
 SET NOCOUNT ON;
 UPDATE [Vehicles] SET [Operator_Discriminator] = @p0, [LicenseType] = @p1, [Operator_Name] = @p2
-WHERE [Name] = @p3;
-SELECT @@ROWCOUNT;",
+OUTPUT 1
+WHERE [Name] = @p3;",
             //
             @"SELECT TOP(2) [v].[Name], [v].[Discriminator], [v].[SeatingCapacity], [v].[AttachedVehicleName], [t].[Name], [t].[Operator_Discriminator], [t].[Operator_Name], [t].[LicenseType]
 FROM [Vehicles] AS [v]
@@ -237,8 +237,8 @@ public override async Task Can_change_principal_instance_non_derived()
 SET IMPLICIT_TRANSACTIONS OFF;
 SET NOCOUNT ON;
 UPDATE [Vehicles] SET [SeatingCapacity] = @p0
-WHERE [Name] = @p1;
-SELECT @@ROWCOUNT;",
+OUTPUT 1
+WHERE [Name] = @p1;",
             //
             @"SELECT TOP(2) [v].[Name], [v].[Discriminator], [v].[SeatingCapacity], [v].[AttachedVehicleName], [t].[Name], [t].[Operator_Discriminator], [t].[Operator_Name], [t].[LicenseType]
 FROM [Vehicles] AS [v]
diff --git a/test/EFCore.SqlServer.FunctionalTests/Update/SqlServerUpdateSqlGeneratorTest.cs b/test/EFCore.SqlServer.FunctionalTests/Update/SqlServerUpdateSqlGeneratorTest.cs
index 2d18a03898..b57726caab 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Update/SqlServerUpdateSqlGeneratorTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Update/SqlServerUpdateSqlGeneratorTest.cs
@@ -154,6 +154,56 @@ public void AppendBulkInsertOperation_appends_insert_if_no_store_generated_colum
         Assert.Equal(ResultSetMapping.NoResultSet, grouping);
     }
 
+    protected override void AppendUpdateOperation_for_computed_property_verification(StringBuilder stringBuilder)
+        => AssertBaseline(
+            @"UPDATE [dbo].[Ducks] SET [Name] = @p0, [Quacks] = @p1, [ConcurrencyToken] = @p2
+OUTPUT INSERTED.[Computed]
+WHERE [Id] = @p3;
+",
+            stringBuilder.ToString());
+
+    protected override void AppendUpdateOperation_if_store_generated_columns_exist_verification(
+        StringBuilder stringBuilder)
+        => AssertBaseline(
+            @"UPDATE [dbo].[Ducks] SET [Name] = @p0, [Quacks] = @p1, [ConcurrencyToken] = @p2
+OUTPUT INSERTED.[Computed]
+WHERE [Id] = @p3 AND [ConcurrencyToken] IS NULL;
+",
+            stringBuilder.ToString());
+
+    protected override void AppendUpdateOperation_if_store_generated_columns_dont_exist_verification(
+        StringBuilder stringBuilder)
+        => AssertBaseline(
+            @"UPDATE [dbo].[Ducks] SET [Name] = @p0, [Quacks] = @p1, [ConcurrencyToken] = @p2
+OUTPUT 1
+WHERE [Id] = @p3;
+",
+            stringBuilder.ToString());
+
+    protected override void AppendUpdateOperation_appends_where_for_concurrency_token_verification(StringBuilder stringBuilder)
+        => AssertBaseline(
+            @"UPDATE [dbo].[Ducks] SET [Name] = @p0, [Quacks] = @p1, [ConcurrencyToken] = @p2
+OUTPUT 1
+WHERE [Id] = @p3 AND [ConcurrencyToken] IS NULL;
+",
+            stringBuilder.ToString());
+
+    protected override void AppendDeleteOperation_creates_full_delete_command_text_verification(StringBuilder stringBuilder)
+        => AssertBaseline(
+            @"DELETE FROM [dbo].[Ducks]
+OUTPUT 1
+WHERE [Id] = @p0;
+",
+            stringBuilder.ToString());
+
+    protected override void AppendDeleteOperation_creates_full_delete_command_text_with_concurrency_check_verification(StringBuilder stringBuilder)
+        => AssertBaseline(
+            @"DELETE FROM [dbo].[Ducks]
+OUTPUT 1
+WHERE [Id] = @p0 AND [ConcurrencyToken] IS NULL;
+",
+            stringBuilder.ToString());
+
     protected override string RowsAffected
         => "@@ROWCOUNT";
 
diff --git a/test/EFCore.SqlServer.FunctionalTests/Update/StoreValueGenerationIdentitySqlServerTest.cs b/test/EFCore.SqlServer.FunctionalTests/Update/StoreValueGenerationIdentitySqlServerTest.cs
index ec27e33ef3..b68da2be60 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Update/StoreValueGenerationIdentitySqlServerTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Update/StoreValueGenerationIdentitySqlServerTest.cs
@@ -1,8 +1,6 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using Microsoft.EntityFrameworkCore.TestModels.StoreValueGenerationModel;
-
 namespace Microsoft.EntityFrameworkCore.Update;
 
 #nullable enable
@@ -25,12 +23,6 @@ public class StoreValueGenerationIdentitySqlServerTest : StoreValueGenerationTes
         GeneratedValues generatedValues,
         bool withSameEntityType)
     {
-        // Updates with generated values currently use SELECT to retrieve them, and so require transactions
-        if (firstOperationType == EntityState.Modified && generatedValues != GeneratedValues.None)
-        {
-            return true;
-        }
-
         // For multiple operations, we specifically optimize multiple insertions of the same entity type with a single command (e.g. MERGE)
         // (as long as there are writable columns)
         if (firstOperationType is EntityState.Added
@@ -96,12 +88,11 @@ public override async Task Modify_with_generated_values(bool async)
             @"@p1='1'
 @p0='1000'
 
+SET IMPLICIT_TRANSACTIONS OFF;
 SET NOCOUNT ON;
 UPDATE [WithSomeDatabaseGenerated] SET [Data2] = @p0
-WHERE [Id] = @p1;
-SELECT [Data1]
-FROM [WithSomeDatabaseGenerated]
-WHERE @@ROWCOUNT = 1 AND [Id] = @p1;");
+OUTPUT INSERTED.[Data1]
+WHERE [Id] = @p1;");
     }
 
     public override async Task Modify_with_no_generated_values(bool async)
@@ -116,8 +107,8 @@ public override async Task Modify_with_no_generated_values(bool async)
 SET IMPLICIT_TRANSACTIONS OFF;
 SET NOCOUNT ON;
 UPDATE [WithNoDatabaseGenerated] SET [Data1] = @p0, [Data2] = @p1
-WHERE [Id] = @p2;
-SELECT @@ROWCOUNT;");
+OUTPUT 1
+WHERE [Id] = @p2;");
     }
 
     public override async Task Delete(bool async)
@@ -130,8 +121,8 @@ public override async Task Delete(bool async)
 SET IMPLICIT_TRANSACTIONS OFF;
 SET NOCOUNT ON;
 DELETE FROM [WithSomeDatabaseGenerated]
-WHERE [Id] = @p0;
-SELECT @@ROWCOUNT;");
+OUTPUT 1
+WHERE [Id] = @p0;");
     }
 
     #endregion Single operation
@@ -202,16 +193,11 @@ public override async Task Modify_Modify_with_same_entity_type_and_generated_val
 
 SET NOCOUNT ON;
 UPDATE [WithSomeDatabaseGenerated] SET [Data2] = @p0
+OUTPUT INSERTED.[Data1]
 WHERE [Id] = @p1;
-SELECT [Data1]
-FROM [WithSomeDatabaseGenerated]
-WHERE @@ROWCOUNT = 1 AND [Id] = @p1;
-
 UPDATE [WithSomeDatabaseGenerated] SET [Data2] = @p2
-WHERE [Id] = @p3;
-SELECT [Data1]
-FROM [WithSomeDatabaseGenerated]
-WHERE @@ROWCOUNT = 1 AND [Id] = @p3;");
+OUTPUT INSERTED.[Data1]
+WHERE [Id] = @p3;");
     }
 
     public override async Task Modify_Modify_with_same_entity_type_and_no_generated_values(bool async)
@@ -228,12 +214,11 @@ public override async Task Modify_Modify_with_same_entity_type_and_no_generated_
 
 SET NOCOUNT ON;
 UPDATE [WithNoDatabaseGenerated] SET [Data1] = @p0, [Data2] = @p1
+OUTPUT 1
 WHERE [Id] = @p2;
-SELECT @@ROWCOUNT;
-
 UPDATE [WithNoDatabaseGenerated] SET [Data1] = @p3, [Data2] = @p4
-WHERE [Id] = @p5;
-SELECT @@ROWCOUNT;");
+OUTPUT 1
+WHERE [Id] = @p5;");
     }
 
     public override async Task Delete_Delete_with_same_entity_type(bool async)
@@ -246,12 +231,11 @@ public override async Task Delete_Delete_with_same_entity_type(bool async)
 
 SET NOCOUNT ON;
 DELETE FROM [WithSomeDatabaseGenerated]
+OUTPUT 1
 WHERE [Id] = @p0;
-SELECT @@ROWCOUNT;
-
 DELETE FROM [WithSomeDatabaseGenerated]
-WHERE [Id] = @p1;
-SELECT @@ROWCOUNT;");
+OUTPUT 1
+WHERE [Id] = @p1;");
     }
 
     #endregion Two operations with same entity type
@@ -320,23 +304,19 @@ public override async Task Modify_Modify_with_different_entity_types_and_generat
 
 SET NOCOUNT ON;
 UPDATE [WithSomeDatabaseGenerated] SET [Data2] = @p0
+OUTPUT INSERTED.[Data1]
 WHERE [Id] = @p1;
-SELECT [Data1]
-FROM [WithSomeDatabaseGenerated]
-WHERE @@ROWCOUNT = 1 AND [Id] = @p1;
-
 UPDATE [WithSomeDatabaseGenerated2] SET [Data2] = @p2
-WHERE [Id] = @p3;
-SELECT [Data1]
-FROM [WithSomeDatabaseGenerated2]
-WHERE @@ROWCOUNT = 1 AND [Id] = @p3;");
+OUTPUT INSERTED.[Data1]
+WHERE [Id] = @p3;");
     }
 
     public override async Task Modify_Modify_with_different_entity_types_and_no_generated_values(bool async)
     {
         await base.Modify_Modify_with_different_entity_types_and_no_generated_values(async);
-AssertSql(
-    @"@p2='1'
+
+        AssertSql(
+            @"@p2='1'
 @p0='1000'
 @p1='1000'
 @p5='2'
@@ -345,12 +325,11 @@ public override async Task Modify_Modify_with_different_entity_types_and_no_gene
 
 SET NOCOUNT ON;
 UPDATE [WithNoDatabaseGenerated] SET [Data1] = @p0, [Data2] = @p1
+OUTPUT 1
 WHERE [Id] = @p2;
-SELECT @@ROWCOUNT;
-
 UPDATE [WithNoDatabaseGenerated2] SET [Data1] = @p3, [Data2] = @p4
-WHERE [Id] = @p5;
-SELECT @@ROWCOUNT;");
+OUTPUT 1
+WHERE [Id] = @p5;");
     }
 
     public override async Task Delete_Delete_with_different_entity_types(bool async)
@@ -363,12 +342,11 @@ public override async Task Delete_Delete_with_different_entity_types(bool async)
 
 SET NOCOUNT ON;
 DELETE FROM [WithSomeDatabaseGenerated]
+OUTPUT 1
 WHERE [Id] = @p0;
-SELECT @@ROWCOUNT;
-
 DELETE FROM [WithSomeDatabaseGenerated2]
-WHERE [Id] = @p1;
-SELECT @@ROWCOUNT;");
+OUTPUT 1
+WHERE [Id] = @p1;");
     }
 
     #endregion Two operations with different entity types
diff --git a/test/EFCore.SqlServer.FunctionalTests/Update/StoreValueGenerationIdentityTriggerSqlServerTest.cs b/test/EFCore.SqlServer.FunctionalTests/Update/StoreValueGenerationIdentityTriggerSqlServerTest.cs
index 2f2fb166ba..2dffa61a26 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Update/StoreValueGenerationIdentityTriggerSqlServerTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Update/StoreValueGenerationIdentityTriggerSqlServerTest.cs
@@ -24,7 +24,7 @@ public class StoreValueGenerationIdentityTriggerSqlServerTest : StoreValueGenera
         bool withSameEntityType)
     {
         // We have triggers, so any insert/update retrieving a database-generated value must be enclosed in a transaction
-        // (we use INSERT+SELECT or INSERT ... OUTPUT INTO+SELECT)
+        // (e.g. we use INSERT/UPDATE+SELECT or INSERT ... OUTPUT INTO+SELECT)
         if (generatedValues is GeneratedValues.Some or GeneratedValues.All
             && firstOperationType is EntityState.Added or EntityState.Modified)
         {
diff --git a/test/EFCore.SqlServer.FunctionalTests/Update/StoreValueGenerationSequenceSqlServerTest.cs b/test/EFCore.SqlServer.FunctionalTests/Update/StoreValueGenerationSequenceSqlServerTest.cs
index f56a6747fc..b32fade183 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Update/StoreValueGenerationSequenceSqlServerTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Update/StoreValueGenerationSequenceSqlServerTest.cs
@@ -25,12 +25,6 @@ public class StoreValueGenerationSequenceSqlServerTest : StoreValueGenerationTes
         GeneratedValues generatedValues,
         bool withSameEntityType)
     {
-        // Updates with generated values currently use SELECT to retrieve them, and so require transactions
-        if (firstOperationType == EntityState.Modified && generatedValues != GeneratedValues.None)
-        {
-            return true;
-        }
-
         // For multiple operations, we specifically optimize multiple insertions of the same entity type with a single command (e.g. MERGE)
         // (as long as there are writable columns)
         if (firstOperationType is EntityState.Added
@@ -96,12 +90,11 @@ public override async Task Modify_with_generated_values(bool async)
             @"@p1='5'
 @p0='1000'
 
+SET IMPLICIT_TRANSACTIONS OFF;
 SET NOCOUNT ON;
 UPDATE [WithSomeDatabaseGenerated] SET [Data2] = @p0
-WHERE [Id] = @p1;
-SELECT [Data1]
-FROM [WithSomeDatabaseGenerated]
-WHERE @@ROWCOUNT = 1 AND [Id] = @p1;");
+OUTPUT INSERTED.[Data1]
+WHERE [Id] = @p1;");
     }
 
     public override async Task Modify_with_no_generated_values(bool async)
@@ -116,8 +109,8 @@ public override async Task Modify_with_no_generated_values(bool async)
 SET IMPLICIT_TRANSACTIONS OFF;
 SET NOCOUNT ON;
 UPDATE [WithNoDatabaseGenerated] SET [Data1] = @p0, [Data2] = @p1
-WHERE [Id] = @p2;
-SELECT @@ROWCOUNT;");
+OUTPUT 1
+WHERE [Id] = @p2;");
     }
 
     public override async Task Delete(bool async)
@@ -130,8 +123,8 @@ public override async Task Delete(bool async)
 SET IMPLICIT_TRANSACTIONS OFF;
 SET NOCOUNT ON;
 DELETE FROM [WithSomeDatabaseGenerated]
-WHERE [Id] = @p0;
-SELECT @@ROWCOUNT;");
+OUTPUT 1
+WHERE [Id] = @p0;");
     }
 
     #endregion Single operation
@@ -204,16 +197,11 @@ public override async Task Modify_Modify_with_same_entity_type_and_generated_val
 
 SET NOCOUNT ON;
 UPDATE [WithSomeDatabaseGenerated] SET [Data2] = @p0
+OUTPUT INSERTED.[Data1]
 WHERE [Id] = @p1;
-SELECT [Data1]
-FROM [WithSomeDatabaseGenerated]
-WHERE @@ROWCOUNT = 1 AND [Id] = @p1;
-
 UPDATE [WithSomeDatabaseGenerated] SET [Data2] = @p2
-WHERE [Id] = @p3;
-SELECT [Data1]
-FROM [WithSomeDatabaseGenerated]
-WHERE @@ROWCOUNT = 1 AND [Id] = @p3;");
+OUTPUT INSERTED.[Data1]
+WHERE [Id] = @p3;");
     }
 
     public override async Task Modify_Modify_with_same_entity_type_and_no_generated_values(bool async)
@@ -230,12 +218,11 @@ public override async Task Modify_Modify_with_same_entity_type_and_no_generated_
 
 SET NOCOUNT ON;
 UPDATE [WithNoDatabaseGenerated] SET [Data1] = @p0, [Data2] = @p1
+OUTPUT 1
 WHERE [Id] = @p2;
-SELECT @@ROWCOUNT;
-
 UPDATE [WithNoDatabaseGenerated] SET [Data1] = @p3, [Data2] = @p4
-WHERE [Id] = @p5;
-SELECT @@ROWCOUNT;");
+OUTPUT 1
+WHERE [Id] = @p5;");
     }
 
     public override async Task Delete_Delete_with_same_entity_type(bool async)
@@ -248,12 +235,11 @@ public override async Task Delete_Delete_with_same_entity_type(bool async)
 
 SET NOCOUNT ON;
 DELETE FROM [WithSomeDatabaseGenerated]
+OUTPUT 1
 WHERE [Id] = @p0;
-SELECT @@ROWCOUNT;
-
 DELETE FROM [WithSomeDatabaseGenerated]
-WHERE [Id] = @p1;
-SELECT @@ROWCOUNT;");
+OUTPUT 1
+WHERE [Id] = @p1;");
     }
 
     #endregion Two operations with same entity type
@@ -322,16 +308,11 @@ public override async Task Modify_Modify_with_different_entity_types_and_generat
 
 SET NOCOUNT ON;
 UPDATE [WithSomeDatabaseGenerated] SET [Data2] = @p0
+OUTPUT INSERTED.[Data1]
 WHERE [Id] = @p1;
-SELECT [Data1]
-FROM [WithSomeDatabaseGenerated]
-WHERE @@ROWCOUNT = 1 AND [Id] = @p1;
-
 UPDATE [WithSomeDatabaseGenerated2] SET [Data2] = @p2
-WHERE [Id] = @p3;
-SELECT [Data1]
-FROM [WithSomeDatabaseGenerated2]
-WHERE @@ROWCOUNT = 1 AND [Id] = @p3;");
+OUTPUT INSERTED.[Data1]
+WHERE [Id] = @p3;");
     }
 
     public override async Task Modify_Modify_with_different_entity_types_and_no_generated_values(bool async)
@@ -347,12 +328,11 @@ public override async Task Modify_Modify_with_different_entity_types_and_no_gene
 
 SET NOCOUNT ON;
 UPDATE [WithNoDatabaseGenerated] SET [Data1] = @p0, [Data2] = @p1
+OUTPUT 1
 WHERE [Id] = @p2;
-SELECT @@ROWCOUNT;
-
 UPDATE [WithNoDatabaseGenerated2] SET [Data1] = @p3, [Data2] = @p4
-WHERE [Id] = @p5;
-SELECT @@ROWCOUNT;");
+OUTPUT 1
+WHERE [Id] = @p5;");
     }
 
     public override async Task Delete_Delete_with_different_entity_types(bool async)
@@ -365,12 +345,11 @@ public override async Task Delete_Delete_with_different_entity_types(bool async)
 
 SET NOCOUNT ON;
 DELETE FROM [WithSomeDatabaseGenerated]
+OUTPUT 1
 WHERE [Id] = @p0;
-SELECT @@ROWCOUNT;
-
 DELETE FROM [WithSomeDatabaseGenerated2]
-WHERE [Id] = @p1;
-SELECT @@ROWCOUNT;");
+OUTPUT 1
+WHERE [Id] = @p1;");
     }
 
     #endregion Two operations with different entity types
diff --git a/test/EFCore.SqlServer.FunctionalTests/Update/StoreValueGenerationSequenceTriggerSqlServerTest.cs b/test/EFCore.SqlServer.FunctionalTests/Update/StoreValueGenerationSequenceTriggerSqlServerTest.cs
index 8c1d5e85ce..055a0351ca 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Update/StoreValueGenerationSequenceTriggerSqlServerTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Update/StoreValueGenerationSequenceTriggerSqlServerTest.cs
@@ -28,7 +28,7 @@ public class StoreValueGenerationSequenceTriggerSqlServerTest : StoreValueGenera
         bool withSameEntityType)
     {
         // We have triggers, so any insert/update retrieving a database-generated value must be enclosed in a transaction
-        // (we use INSERT+SELECT or INSERT ... OUTPUT INTO+SELECT)
+        // (e.g. we use INSERT/UPDATE+SELECT or INSERT ... OUTPUT INTO+SELECT)
         if (generatedValues is GeneratedValues.Some or GeneratedValues.All
             && firstOperationType is EntityState.Added or EntityState.Modified)
         {
diff --git a/test/EFCore.SqlServer.FunctionalTests/UpdatesSqlServerTest.cs b/test/EFCore.SqlServer.FunctionalTests/UpdatesSqlServerTest.cs
index 1d2c6b2b92..5e33fb7b29 100644
--- a/test/EFCore.SqlServer.FunctionalTests/UpdatesSqlServerTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/UpdatesSqlServerTest.cs
@@ -111,15 +111,33 @@ public override void Save_replaced_principal()
     {
         base.Save_replaced_principal();
 
-        AssertContainsSql(
+        AssertSql(
+            @"SELECT TOP(2) [c].[Id], [c].[Name], [c].[PrincipalId]
+FROM [Categories] AS [c]",
+            //
+            @"@__category_PrincipalId_0='778' (Nullable = true)
+
+SELECT [p].[Id], [p].[Discriminator], [p].[DependentId], [p].[Name], [p].[Price]
+FROM [ProductBase] AS [p]
+WHERE [p].[Discriminator] = N'Product' AND [p].[DependentId] = @__category_PrincipalId_0",
+            //
             @"@p1='78'
 @p0='New Category' (Size = 4000)
 
 SET IMPLICIT_TRANSACTIONS OFF;
 SET NOCOUNT ON;
 UPDATE [Categories] SET [Name] = @p0
-WHERE [Id] = @p1;
-SELECT @@ROWCOUNT;");
+OUTPUT 1
+WHERE [Id] = @p1;",
+            //
+            @"SELECT TOP(2) [c].[Id], [c].[Name], [c].[PrincipalId]
+FROM [Categories] AS [c]",
+            //
+            @"@__category_PrincipalId_0='778' (Nullable = true)
+
+SELECT [p].[Id], [p].[Discriminator], [p].[DependentId], [p].[Name], [p].[Price]
+FROM [ProductBase] AS [p]
+WHERE [p].[Discriminator] = N'Product' AND [p].[DependentId] = @__category_PrincipalId_0");
     }
 
     public override void Identifiers_are_generated_correctly()
diff --git a/test/EFCore.Sqlite.FunctionalTests/DataAnnotationSqliteTest.cs b/test/EFCore.Sqlite.FunctionalTests/DataAnnotationSqliteTest.cs
index c032c7b032..d92736fdf7 100644
--- a/test/EFCore.Sqlite.FunctionalTests/DataAnnotationSqliteTest.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/DataAnnotationSqliteTest.cs
@@ -106,8 +106,8 @@ public override void ConcurrencyCheckAttribute_throws_if_value_in_database_chang
 @p3='00000001-0000-0000-0000-000000000001'
 
 UPDATE ""Sample"" SET ""Name"" = @p0, ""RowVersion"" = @p1
-WHERE ""Unique_No"" = @p2 AND ""RowVersion"" = @p3;
-SELECT changes();",
+WHERE ""Unique_No"" = @p2 AND ""RowVersion"" = @p3
+RETURNING 1;",
             //
             @"@p2='1'
 @p0='ChangedData' (Nullable = false) (Size = 11)
@@ -115,8 +115,8 @@ public override void ConcurrencyCheckAttribute_throws_if_value_in_database_chang
 @p3='00000001-0000-0000-0000-000000000001'
 
 UPDATE ""Sample"" SET ""Name"" = @p0, ""RowVersion"" = @p1
-WHERE ""Unique_No"" = @p2 AND ""RowVersion"" = @p3;
-SELECT changes();");
+WHERE ""Unique_No"" = @p2 AND ""RowVersion"" = @p3
+RETURNING 1;");
     }
 
     public override void DatabaseGeneratedAttribute_autogenerates_values_when_set_to_identity()
diff --git a/test/EFCore.Sqlite.FunctionalTests/Migrations/SqliteMigrationsSqlGeneratorTest.cs b/test/EFCore.Sqlite.FunctionalTests/Migrations/SqliteMigrationsSqlGeneratorTest.cs
index 3857debf8b..921372b163 100644
--- a/test/EFCore.Sqlite.FunctionalTests/Migrations/SqliteMigrationsSqlGeneratorTest.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/Migrations/SqliteMigrationsSqlGeneratorTest.cs
@@ -428,25 +428,20 @@ public override void DeleteDataOperation_all_args()
 
         AssertSql(
             @"DELETE FROM ""People""
-WHERE ""First Name"" = 'Hodor';
-SELECT changes();
-
+WHERE ""First Name"" = 'Hodor'
+RETURNING 1;
 DELETE FROM ""People""
-WHERE ""First Name"" = 'Daenerys';
-SELECT changes();
-
+WHERE ""First Name"" = 'Daenerys'
+RETURNING 1;
 DELETE FROM ""People""
-WHERE ""First Name"" = 'John';
-SELECT changes();
-
+WHERE ""First Name"" = 'John'
+RETURNING 1;
 DELETE FROM ""People""
-WHERE ""First Name"" = 'Arya';
-SELECT changes();
-
+WHERE ""First Name"" = 'Arya'
+RETURNING 1;
 DELETE FROM ""People""
-WHERE ""First Name"" = 'Harry';
-SELECT changes();
-
+WHERE ""First Name"" = 'Harry'
+RETURNING 1;
 ");
     }
 
@@ -456,25 +451,20 @@ public override void DeleteDataOperation_all_args_composite()
 
         AssertSql(
             @"DELETE FROM ""People""
-WHERE ""First Name"" = 'Hodor' AND ""Last Name"" IS NULL;
-SELECT changes();
-
+WHERE ""First Name"" = 'Hodor' AND ""Last Name"" IS NULL
+RETURNING 1;
 DELETE FROM ""People""
-WHERE ""First Name"" = 'Daenerys' AND ""Last Name"" = 'Targaryen';
-SELECT changes();
-
+WHERE ""First Name"" = 'Daenerys' AND ""Last Name"" = 'Targaryen'
+RETURNING 1;
 DELETE FROM ""People""
-WHERE ""First Name"" = 'John' AND ""Last Name"" = 'Snow';
-SELECT changes();
-
+WHERE ""First Name"" = 'John' AND ""Last Name"" = 'Snow'
+RETURNING 1;
 DELETE FROM ""People""
-WHERE ""First Name"" = 'Arya' AND ""Last Name"" = 'Stark';
-SELECT changes();
-
+WHERE ""First Name"" = 'Arya' AND ""Last Name"" = 'Stark'
+RETURNING 1;
 DELETE FROM ""People""
-WHERE ""First Name"" = 'Harry' AND ""Last Name"" = 'Strickland';
-SELECT changes();
-
+WHERE ""First Name"" = 'Harry' AND ""Last Name"" = 'Strickland'
+RETURNING 1;
 ");
     }
 
@@ -484,9 +474,8 @@ public override void DeleteDataOperation_required_args()
 
         AssertSql(
             @"DELETE FROM ""People""
-WHERE ""Last Name"" = 'Snow';
-SELECT changes();
-
+WHERE ""Last Name"" = 'Snow'
+RETURNING 1;
 ");
     }
 
@@ -496,9 +485,8 @@ public override void DeleteDataOperation_required_args_composite()
 
         AssertSql(
             @"DELETE FROM ""People""
-WHERE ""First Name"" = 'John' AND ""Last Name"" = 'Snow';
-SELECT changes();
-
+WHERE ""First Name"" = 'John' AND ""Last Name"" = 'Snow'
+RETURNING 1;
 ");
     }
 
@@ -508,13 +496,11 @@ public override void UpdateDataOperation_all_args()
 
         AssertSql(
             @"UPDATE ""People"" SET ""Birthplace"" = 'Winterfell', ""House Allegiance"" = 'Stark', ""Culture"" = 'Northmen'
-WHERE ""First Name"" = 'Hodor';
-SELECT changes();
-
+WHERE ""First Name"" = 'Hodor'
+RETURNING 1;
 UPDATE ""People"" SET ""Birthplace"" = 'Dragonstone', ""House Allegiance"" = 'Targaryen', ""Culture"" = 'Valyrian'
-WHERE ""First Name"" = 'Daenerys';
-SELECT changes();
-
+WHERE ""First Name"" = 'Daenerys'
+RETURNING 1;
 ");
     }
 
@@ -524,13 +510,11 @@ public override void UpdateDataOperation_all_args_composite()
 
         AssertSql(
             @"UPDATE ""People"" SET ""House Allegiance"" = 'Stark'
-WHERE ""First Name"" = 'Hodor' AND ""Last Name"" IS NULL;
-SELECT changes();
-
+WHERE ""First Name"" = 'Hodor' AND ""Last Name"" IS NULL
+RETURNING 1;
 UPDATE ""People"" SET ""House Allegiance"" = 'Targaryen'
-WHERE ""First Name"" = 'Daenerys' AND ""Last Name"" = 'Targaryen';
-SELECT changes();
-
+WHERE ""First Name"" = 'Daenerys' AND ""Last Name"" = 'Targaryen'
+RETURNING 1;
 ");
     }
 
@@ -540,13 +524,11 @@ public override void UpdateDataOperation_all_args_composite_multi()
 
         AssertSql(
             @"UPDATE ""People"" SET ""Birthplace"" = 'Winterfell', ""House Allegiance"" = 'Stark', ""Culture"" = 'Northmen'
-WHERE ""First Name"" = 'Hodor' AND ""Last Name"" IS NULL;
-SELECT changes();
-
+WHERE ""First Name"" = 'Hodor' AND ""Last Name"" IS NULL
+RETURNING 1;
 UPDATE ""People"" SET ""Birthplace"" = 'Dragonstone', ""House Allegiance"" = 'Targaryen', ""Culture"" = 'Valyrian'
-WHERE ""First Name"" = 'Daenerys' AND ""Last Name"" = 'Targaryen';
-SELECT changes();
-
+WHERE ""First Name"" = 'Daenerys' AND ""Last Name"" = 'Targaryen'
+RETURNING 1;
 ");
     }
 
@@ -556,9 +538,8 @@ public override void UpdateDataOperation_all_args_multi()
 
         AssertSql(
             @"UPDATE ""People"" SET ""Birthplace"" = 'Dragonstone', ""House Allegiance"" = 'Targaryen', ""Culture"" = 'Valyrian'
-WHERE ""First Name"" = 'Daenerys';
-SELECT changes();
-
+WHERE ""First Name"" = 'Daenerys'
+RETURNING 1;
 ");
     }
 
@@ -568,9 +549,8 @@ public override void UpdateDataOperation_required_args()
 
         AssertSql(
             @"UPDATE ""People"" SET ""House Allegiance"" = 'Targaryen'
-WHERE ""First Name"" = 'Daenerys';
-SELECT changes();
-
+WHERE ""First Name"" = 'Daenerys'
+RETURNING 1;
 ");
     }
 
@@ -580,9 +560,8 @@ public override void UpdateDataOperation_required_args_composite()
 
         AssertSql(
             @"UPDATE ""People"" SET ""House Allegiance"" = 'Targaryen'
-WHERE ""First Name"" = 'Daenerys' AND ""Last Name"" = 'Targaryen';
-SELECT changes();
-
+WHERE ""First Name"" = 'Daenerys' AND ""Last Name"" = 'Targaryen'
+RETURNING 1;
 ");
     }
 
@@ -592,9 +571,8 @@ public override void UpdateDataOperation_required_args_composite_multi()
 
         AssertSql(
             @"UPDATE ""People"" SET ""Birthplace"" = 'Dragonstone', ""House Allegiance"" = 'Targaryen', ""Culture"" = 'Valyrian'
-WHERE ""First Name"" = 'Daenerys' AND ""Last Name"" = 'Targaryen';
-SELECT changes();
-
+WHERE ""First Name"" = 'Daenerys' AND ""Last Name"" = 'Targaryen'
+RETURNING 1;
 ");
     }
 
@@ -604,9 +582,8 @@ public override void UpdateDataOperation_required_args_multi()
 
         AssertSql(
             @"UPDATE ""People"" SET ""Birthplace"" = 'Dragonstone', ""House Allegiance"" = 'Targaryen', ""Culture"" = 'Valyrian'
-WHERE ""First Name"" = 'Daenerys';
-SELECT changes();
-
+WHERE ""First Name"" = 'Daenerys'
+RETURNING 1;
 ");
     }
 
@@ -616,13 +593,11 @@ public override void UpdateDataOperation_required_args_multiple_rows()
 
         AssertSql(
             @"UPDATE ""People"" SET ""House Allegiance"" = 'Stark'
-WHERE ""First Name"" = 'Hodor';
-SELECT changes();
-
+WHERE ""First Name"" = 'Hodor'
+RETURNING 1;
 UPDATE ""People"" SET ""House Allegiance"" = 'Targaryen'
-WHERE ""First Name"" = 'Daenerys';
-SELECT changes();
-
+WHERE ""First Name"" = 'Daenerys'
+RETURNING 1;
 ");
     }
 
diff --git a/test/EFCore.Sqlite.FunctionalTests/OptimisticConcurrencySqliteTest.cs b/test/EFCore.Sqlite.FunctionalTests/OptimisticConcurrencySqliteTest.cs
index ca7c5154b7..801464aff8 100644
--- a/test/EFCore.Sqlite.FunctionalTests/OptimisticConcurrencySqliteTest.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/OptimisticConcurrencySqliteTest.cs
@@ -46,8 +46,8 @@ public override void Property_entry_original_value_is_set()
 @p5='-122.128101' (Nullable = true)
 
 UPDATE ""Engines"" SET ""Name"" = @p0
-WHERE ""Id"" = @p1 AND ""EngineSupplierId"" = @p2 AND ""Name"" = @p3 AND ""StorageLocation_Latitude"" = @p4 AND ""StorageLocation_Longitude"" = @p5;
-SELECT changes();");
+WHERE ""Id"" = @p1 AND ""EngineSupplierId"" = @p2 AND ""Name"" = @p3 AND ""StorageLocation_Latitude"" = @p4 AND ""StorageLocation_Longitude"" = @p5
+RETURNING 1;");
     }
 
     [ConditionalFact(Skip = "Optimistic Offline Lock #2195")]
diff --git a/test/EFCore.Sqlite.FunctionalTests/Update/SqliteUpdateSqlGeneratorTest.cs b/test/EFCore.Sqlite.FunctionalTests/Update/SqliteUpdateSqlGeneratorTest.cs
index 94da6a946f..c49b170915 100644
--- a/test/EFCore.Sqlite.FunctionalTests/Update/SqliteUpdateSqlGeneratorTest.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/Update/SqliteUpdateSqlGeneratorTest.cs
@@ -80,6 +80,56 @@ DEFAULT VALUES
             @"INSERT INTO ""Ducks""
 DEFAULT VALUES
 RETURNING ""Id"";
+",
+            stringBuilder.ToString());
+
+    protected override void AppendUpdateOperation_for_computed_property_verification(StringBuilder stringBuilder)
+        => AssertBaseline(
+            @"UPDATE ""Ducks"" SET ""Name"" = @p0, ""Quacks"" = @p1, ""ConcurrencyToken"" = @p2
+WHERE ""Id"" = @p3
+RETURNING ""Computed"";
+",
+            stringBuilder.ToString());
+
+    protected override void AppendUpdateOperation_if_store_generated_columns_exist_verification(
+        StringBuilder stringBuilder)
+        => AssertBaseline(
+            @"UPDATE ""Ducks"" SET ""Name"" = @p0, ""Quacks"" = @p1, ""ConcurrencyToken"" = @p2
+WHERE ""Id"" = @p3 AND ""ConcurrencyToken"" IS NULL
+RETURNING ""Computed"";
+",
+            stringBuilder.ToString());
+
+    protected override void AppendUpdateOperation_if_store_generated_columns_dont_exist_verification(
+        StringBuilder stringBuilder)
+        => AssertBaseline(
+            @"UPDATE ""Ducks"" SET ""Name"" = @p0, ""Quacks"" = @p1, ""ConcurrencyToken"" = @p2
+WHERE ""Id"" = @p3
+RETURNING 1;
+",
+            stringBuilder.ToString());
+
+    protected override void AppendUpdateOperation_appends_where_for_concurrency_token_verification(StringBuilder stringBuilder)
+        => AssertBaseline(
+            @"UPDATE ""Ducks"" SET ""Name"" = @p0, ""Quacks"" = @p1, ""ConcurrencyToken"" = @p2
+WHERE ""Id"" = @p3 AND ""ConcurrencyToken"" IS NULL
+RETURNING 1;
+",
+            stringBuilder.ToString());
+
+    protected override void AppendDeleteOperation_creates_full_delete_command_text_verification(StringBuilder stringBuilder)
+        => AssertBaseline(
+            @"DELETE FROM ""Ducks""
+WHERE ""Id"" = @p0
+RETURNING 1;
+",
+            stringBuilder.ToString());
+
+    protected override void AppendDeleteOperation_creates_full_delete_command_text_with_concurrency_check_verification(StringBuilder stringBuilder)
+        => AssertBaseline(
+            @"DELETE FROM ""Ducks""
+WHERE ""Id"" = @p0 AND ""ConcurrencyToken"" IS NULL
+RETURNING 1;
 ",
             stringBuilder.ToString());
 
diff --git a/test/EFCore.Sqlite.FunctionalTests/Update/StoreValueGenerationSqliteTest.cs b/test/EFCore.Sqlite.FunctionalTests/Update/StoreValueGenerationSqliteTest.cs
index 3aa88b271a..c4ece3530f 100644
--- a/test/EFCore.Sqlite.FunctionalTests/Update/StoreValueGenerationSqliteTest.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/Update/StoreValueGenerationSqliteTest.cs
@@ -68,10 +68,8 @@ public override async Task Modify_with_generated_values(bool async)
 @p0='1000'
 
 UPDATE ""WithSomeDatabaseGenerated"" SET ""Data2"" = @p0
-WHERE ""Id"" = @p1;
-SELECT ""Data1""
-FROM ""WithSomeDatabaseGenerated""
-WHERE changes() = 1 AND ""Id"" = @p1;");
+WHERE ""Id"" = @p1
+RETURNING ""Data1"";");
     }
 
     public override async Task Modify_with_no_generated_values(bool async)
@@ -84,8 +82,8 @@ public override async Task Modify_with_no_generated_values(bool async)
 @p1='1000'
 
 UPDATE ""WithNoDatabaseGenerated"" SET ""Data1"" = @p0, ""Data2"" = @p1
-WHERE ""Id"" = @p2;
-SELECT changes();");
+WHERE ""Id"" = @p2
+RETURNING 1;");
     }
 
     public override async Task Delete(bool async)
@@ -96,8 +94,8 @@ public override async Task Delete(bool async)
             @"@p0='1'
 
 DELETE FROM ""WithSomeDatabaseGenerated""
-WHERE ""Id"" = @p0;
-SELECT changes();");
+WHERE ""Id"" = @p0
+RETURNING 1;");
     }
 
     #endregion Single operation
@@ -165,19 +163,15 @@ public override async Task Modify_Modify_with_same_entity_type_and_generated_val
 @p0='1000'
 
 UPDATE ""WithSomeDatabaseGenerated"" SET ""Data2"" = @p0
-WHERE ""Id"" = @p1;
-SELECT ""Data1""
-FROM ""WithSomeDatabaseGenerated""
-WHERE changes() = 1 AND ""Id"" = @p1;",
+WHERE ""Id"" = @p1
+RETURNING ""Data1"";",
             //
             @"@p1='2'
 @p0='1001'
 
 UPDATE ""WithSomeDatabaseGenerated"" SET ""Data2"" = @p0
-WHERE ""Id"" = @p1;
-SELECT ""Data1""
-FROM ""WithSomeDatabaseGenerated""
-WHERE changes() = 1 AND ""Id"" = @p1;");
+WHERE ""Id"" = @p1
+RETURNING ""Data1"";");
     }
 
     public override async Task Modify_Modify_with_same_entity_type_and_no_generated_values(bool async)
@@ -190,16 +184,16 @@ public override async Task Modify_Modify_with_same_entity_type_and_no_generated_
 @p1='1000'
 
 UPDATE ""WithNoDatabaseGenerated"" SET ""Data1"" = @p0, ""Data2"" = @p1
-WHERE ""Id"" = @p2;
-SELECT changes();",
+WHERE ""Id"" = @p2
+RETURNING 1;",
             //
             @"@p2='2'
 @p0='1001'
 @p1='1001'
 
 UPDATE ""WithNoDatabaseGenerated"" SET ""Data1"" = @p0, ""Data2"" = @p1
-WHERE ""Id"" = @p2;
-SELECT changes();");
+WHERE ""Id"" = @p2
+RETURNING 1;");
     }
 
     public override async Task Delete_Delete_with_same_entity_type(bool async)
@@ -210,14 +204,14 @@ public override async Task Delete_Delete_with_same_entity_type(bool async)
             @"@p0='1'
 
 DELETE FROM ""WithSomeDatabaseGenerated""
-WHERE ""Id"" = @p0;
-SELECT changes();",
+WHERE ""Id"" = @p0
+RETURNING 1;",
             //
             @"@p0='2'
 
 DELETE FROM ""WithSomeDatabaseGenerated""
-WHERE ""Id"" = @p0;
-SELECT changes();");
+WHERE ""Id"" = @p0
+RETURNING 1;");
     }
 
     #endregion Two operations with same entity type
@@ -285,19 +279,15 @@ public override async Task Modify_Modify_with_different_entity_types_and_generat
 @p0='1000'
 
 UPDATE ""WithSomeDatabaseGenerated"" SET ""Data2"" = @p0
-WHERE ""Id"" = @p1;
-SELECT ""Data1""
-FROM ""WithSomeDatabaseGenerated""
-WHERE changes() = 1 AND ""Id"" = @p1;",
+WHERE ""Id"" = @p1
+RETURNING ""Data1"";",
             //
             @"@p1='2'
 @p0='1001'
 
 UPDATE ""WithSomeDatabaseGenerated2"" SET ""Data2"" = @p0
-WHERE ""Id"" = @p1;
-SELECT ""Data1""
-FROM ""WithSomeDatabaseGenerated2""
-WHERE changes() = 1 AND ""Id"" = @p1;");
+WHERE ""Id"" = @p1
+RETURNING ""Data1"";");
     }
 
     public override async Task Modify_Modify_with_different_entity_types_and_no_generated_values(bool async)
@@ -310,16 +300,16 @@ public override async Task Modify_Modify_with_different_entity_types_and_no_gene
 @p1='1000'
 
 UPDATE ""WithNoDatabaseGenerated"" SET ""Data1"" = @p0, ""Data2"" = @p1
-WHERE ""Id"" = @p2;
-SELECT changes();",
+WHERE ""Id"" = @p2
+RETURNING 1;",
             //
             @"@p2='2'
 @p0='1001'
 @p1='1001'
 
 UPDATE ""WithNoDatabaseGenerated2"" SET ""Data1"" = @p0, ""Data2"" = @p1
-WHERE ""Id"" = @p2;
-SELECT changes();");
+WHERE ""Id"" = @p2
+RETURNING 1;");
     }
 
     public override async Task Delete_Delete_with_different_entity_types(bool async)
@@ -330,14 +320,14 @@ public override async Task Delete_Delete_with_different_entity_types(bool async)
             @"@p0='1'
 
 DELETE FROM ""WithSomeDatabaseGenerated""
-WHERE ""Id"" = @p0;
-SELECT changes();",
+WHERE ""Id"" = @p0
+RETURNING 1;",
             //
             @"@p0='2'
 
 DELETE FROM ""WithSomeDatabaseGenerated2""
-WHERE ""Id"" = @p0;
-SELECT changes();");
+WHERE ""Id"" = @p0
+RETURNING 1;");
     }
 
     #endregion Two operations with different entity types
