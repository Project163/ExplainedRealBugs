diff --git a/src/EFCore.Relational/Query/RelationalShapedQueryCompilingExpressionVisitor.ShaperProcessingExpressionVisitor.cs b/src/EFCore.Relational/Query/RelationalShapedQueryCompilingExpressionVisitor.ShaperProcessingExpressionVisitor.cs
index f10e922ba6..8b5ff6bd2e 100644
--- a/src/EFCore.Relational/Query/RelationalShapedQueryCompilingExpressionVisitor.ShaperProcessingExpressionVisitor.cs
+++ b/src/EFCore.Relational/Query/RelationalShapedQueryCompilingExpressionVisitor.ShaperProcessingExpressionVisitor.cs
@@ -3049,7 +3049,7 @@ private sealed class JsonCorrectOrderOfEntitiesForChangeTrackerValidator(SelectE
         {
             private bool _insideCollection;
             private bool _insideInclude;
-
+            private SelectExpression _selectExpression = selectExpression;
             private readonly
                 List<(IEntityType JsonEntityType, List<(IProperty? KeyProperty, int? ConstantKeyValue, int? KeyProjectionIndex)>
                     KeyAccessInfo)> _projectedKeyAccessInfos = [];
@@ -3206,8 +3206,11 @@ protected override Expression VisitExtension(Expression extensionExpression)
                 {
                     var insideCollection = _insideCollection;
                     _insideCollection = true;
+                    var oldSelectExpression = _selectExpression;
+                    _selectExpression = splitCollectionShaperExpression.SelectExpression;
                     Visit(splitCollectionShaperExpression.InnerShaper);
                     _insideCollection = insideCollection;
+                    _selectExpression = oldSelectExpression;
 
                     return splitCollectionShaperExpression;
                 }
@@ -3225,7 +3228,7 @@ protected override Expression VisitExtension(Expression extensionExpression)
                         ValueBufferExpression: ProjectionBindingExpression entityProjectionBindingExpression
                     } entityShaperExpression)
                 {
-                    var entityProjection = selectExpression.GetProjection(entityProjectionBindingExpression).GetConstantValue<object>();
+                    var entityProjection = _selectExpression.GetProjection(entityProjectionBindingExpression).GetConstantValue<object>();
 
                     switch (entityProjection)
                     {
@@ -3264,7 +3267,7 @@ protected override Expression VisitExtension(Expression extensionExpression)
                     } collectionResultExpression)
                 {
                     var collectionProjection =
-                        selectExpression.GetProjection(collectionProjectionBindingExpression).GetConstantValue<object>();
+                        _selectExpression.GetProjection(collectionProjectionBindingExpression).GetConstantValue<object>();
 
                     switch (collectionProjection)
                     {
diff --git a/test/EFCore.Relational.Specification.Tests/Query/AdHocQuerySplittingQueryTestBase.cs b/test/EFCore.Relational.Specification.Tests/Query/AdHocQuerySplittingQueryTestBase.cs
index 2b3471ebcb..94e3b92137 100644
--- a/test/EFCore.Relational.Specification.Tests/Query/AdHocQuerySplittingQueryTestBase.cs
+++ b/test/EFCore.Relational.Specification.Tests/Query/AdHocQuerySplittingQueryTestBase.cs
@@ -360,4 +360,104 @@ public Test(int value)
     }
 
     #endregion
+
+    #region 34728
+
+    [ConditionalTheory]
+    [InlineData(true)]
+    [InlineData(false)]
+    public virtual async Task NoTrackingWithIdentityResolution_split_query_basic(bool async)
+    {
+        var contextFactory = await InitializeAsync<Context34728>(
+            onConfiguring: o => SetQuerySplittingBehavior(o, QuerySplittingBehavior.SplitQuery));
+
+        using var context = contextFactory.CreateContext();
+        var query = context.Set<Context34728.Blog>()
+            .AsNoTrackingWithIdentityResolution()
+            .Select(
+                blog => new
+                {
+                    blog.Id,
+                    Posts = blog.Posts.Select(
+                        blogPost => new 
+                        {
+                            blogPost.Id,
+                            blogPost.Author
+                        }).ToList()
+                });
+
+        var test = async
+            ? await query.ToListAsync()
+            : query.ToList();
+    }
+
+    [ConditionalTheory]
+    [InlineData(true)]
+    [InlineData(false)]
+    public virtual async Task NoTrackingWithIdentityResolution_split_query_complex(bool async)
+    {
+        var contextFactory = await InitializeAsync<Context34728>(
+            onConfiguring: o => SetQuerySplittingBehavior(o, QuerySplittingBehavior.SplitQuery));
+
+        using var context = contextFactory.CreateContext();
+        var query = context.Set<Context34728.Blog>()
+            .AsNoTrackingWithIdentityResolution()
+            .Select(
+                blog => new
+                {
+                    blog.Id,
+                    Posts = blog.Posts.Select(
+                        blogPost => new
+                        {
+                            blogPost.Id,
+                            blogPost.Author
+                        }).ToList(),
+                    Posts2 = blog.Posts.Select(x => new
+                    {
+                        x.Id,
+                        Tags = x.Tags.Select(xx => new
+                        {
+                            xx.Id,
+                            xx.Name,
+                            xx.Name.Length
+                        }).ToList()
+                    }).ToList()
+                });
+
+        var test = async
+            ? await query.ToListAsync()
+            : query.ToList();
+    }
+
+    protected class Context34728(DbContextOptions options) : DbContext(options)
+    {
+        public DbSet<Blog> Tests { get; set; }
+
+        public sealed class Blog
+        {
+            public long Id { get; set; }
+            public string Name { get; set; }
+            public ISet<BlogPost> Posts { get; set; } = new HashSet<BlogPost>();
+        }
+
+        public sealed class BlogPost
+        {
+            public long Id { get; set; }
+            public WebAccount Author { get; set; }
+            public List<Tag> Tags { get; set; }
+        }
+
+        public sealed class WebAccount
+        {
+            public long Id { get; set; }
+        }
+
+        public sealed class Tag
+        {
+            public int Id { get; set; }
+            public string Name { get; set; }
+        }
+    }
+
+    #endregion
 }
