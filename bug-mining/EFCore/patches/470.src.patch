diff --git a/src/EFCore.Sqlite.Core/Extensions/SqliteDbFunctionsExtensions.cs b/src/EFCore.Sqlite.Core/Extensions/SqliteDbFunctionsExtensions.cs
index 60e81b8626..4d5882d47d 100644
--- a/src/EFCore.Sqlite.Core/Extensions/SqliteDbFunctionsExtensions.cs
+++ b/src/EFCore.Sqlite.Core/Extensions/SqliteDbFunctionsExtensions.cs
@@ -52,8 +52,8 @@ public static string Hex(this DbFunctions _, byte[] bytes)
     /// </remarks>
     /// <param name="_">The <see cref="DbFunctions" /> instance.</param>
     /// <param name="value">The hexadecimal string.</param>
-    /// <returns>Decoded hexadecimal string as binary value.</returns>
-    public static byte[] Unhex(this DbFunctions _, string value)
+    /// <returns>Decoded hexadecimal string as binary value or <see langword="null" /> if <paramref name="value" /> is not an hexadecimal string.</returns>
+    public static byte[]? Unhex(this DbFunctions _, string value)
         => throw new InvalidOperationException(CoreStrings.FunctionOnClient(nameof(Unhex)));
 
     /// <summary>
@@ -66,8 +66,11 @@ public static byte[] Unhex(this DbFunctions _, string value)
     /// <param name="_">The <see cref="DbFunctions" /> instance.</param>
     /// <param name="value">The hexadecimal string.</param>
     /// <param name="ignoreChars">Characters that are ignored in <paramref name="value" />.</param>
-    /// <returns>Decoded hexadecimal string as binary value.</returns>
-    public static byte[] Unhex(this DbFunctions _, string value, string ignoreChars)
+    /// <returns>
+    ///     Decoded hexadecimal string as binary value or <see langword="null" /> if ignoring the characters from
+    ///     <paramref name="ignoreChars" /> in <paramref name="value" /> does not result in an hexadecimal string.
+    /// </returns>
+    public static byte[]? Unhex(this DbFunctions _, string value, string ignoreChars)
         => throw new InvalidOperationException(CoreStrings.FunctionOnClient(nameof(Unhex)));
 
     /// <summary>
diff --git a/src/EFCore.Sqlite.Core/Query/Internal/SqliteQueryableMethodTranslatingExpressionVisitor.cs b/src/EFCore.Sqlite.Core/Query/Internal/SqliteQueryableMethodTranslatingExpressionVisitor.cs
index 4e90f088db..22f588956e 100644
--- a/src/EFCore.Sqlite.Core/Query/Internal/SqliteQueryableMethodTranslatingExpressionVisitor.cs
+++ b/src/EFCore.Sqlite.Core/Query/Internal/SqliteQueryableMethodTranslatingExpressionVisitor.cs
@@ -567,8 +567,21 @@ private static Type GetProviderType(SqlExpression expression)
         bool isNullable)
         => typeMapping switch
         {
+            // In general unhex returns NULL whenever the decoding fails.
+            // In this case, we assume that the decoding cannot fail, because we
+            // rely on the user to correctly model the database schema and
+            // contents. Under this assumption, `expression` can only be a valid
+            // hex string or NULL, hence unhex simply propagates the nullability
+            // from its argument.
+
             ByteArrayTypeMapping
-                => sqlExpressionFactory.Function("unhex", new[] { expression }, isNullable, new[] { true }, typeof(byte[]), typeMapping),
+                => sqlExpressionFactory.Function(
+                    "unhex",
+                    new[] { expression },
+                    nullable: true,
+                    argumentsPropagateNullability: new[] { true },
+                    typeof(byte[]),
+                    typeMapping),
 
             _ => expression
         };
diff --git a/src/EFCore.Sqlite.Core/Query/Internal/Translators/SqliteHexMethodTranslator.cs b/src/EFCore.Sqlite.Core/Query/Internal/Translators/SqliteHexMethodTranslator.cs
index fd66b54f80..019a57ce1e 100644
--- a/src/EFCore.Sqlite.Core/Query/Internal/Translators/SqliteHexMethodTranslator.cs
+++ b/src/EFCore.Sqlite.Core/Query/Internal/Translators/SqliteHexMethodTranslator.cs
@@ -61,11 +61,13 @@ public SqliteHexMethodTranslator(ISqlExpressionFactory sqlExpressionFactory)
         if (method.Equals(UnhexMethodInfo)
             || method.Equals(UnhexWithIgnoreCharsMethodInfo))
         {
+            // unhex returns NULL whenever the decoding fails, hence mark as
+            // nullable and use an all-false argumentsPropagateNullability
             return _sqlExpressionFactory.Function(
                 "unhex",
                 arguments.Skip(1),
                 nullable: true,
-                arguments.Skip(1).Select(_ => true).ToArray(),
+                argumentsPropagateNullability: arguments.Skip(1).Select(_ => false).ToArray(),
                 typeof(byte[]));
         }
 
diff --git a/test/EFCore.Sqlite.FunctionalTests/BuiltInDataTypesSqliteTest.cs b/test/EFCore.Sqlite.FunctionalTests/BuiltInDataTypesSqliteTest.cs
index e4b265921c..5ab5fd842f 100644
--- a/test/EFCore.Sqlite.FunctionalTests/BuiltInDataTypesSqliteTest.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/BuiltInDataTypesSqliteTest.cs
@@ -1,6 +1,7 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using System.Text.RegularExpressions;
 using Microsoft.EntityFrameworkCore.Sqlite.Internal;
 
 // ReSharper disable InconsistentNaming
@@ -1586,6 +1587,30 @@ SELECT unhex(COALESCE(hex("o"."Bytes"), '') || '!?', '!?')
         Assert.Equal(expectedResults, results);
     }
 
+    [ConditionalFact]
+    public virtual void Can_filter_using_unhex_function()
+    {
+        using var context = CreateContext();
+
+        var results = context.Set<ObjectBackedDataTypes>()
+            .Select(e => e.String)
+            .Where(e => EF.Functions.Unhex(e) == null).ToList();
+
+        AssertSql(
+            """
+SELECT "o"."String"
+FROM "ObjectBackedDataTypes" AS "o"
+WHERE unhex("o"."String") IS NULL
+""");
+
+        var regex = new Regex("^[0-9a-fA-F]*$");
+        var expectedResults = context.Set<ObjectBackedDataTypes>().AsEnumerable()
+            .Select(e => e.String)
+            .Where(e => !regex.IsMatch(e)).ToList();
+
+        Assert.Equal(expectedResults, results);
+    }
+
     [ConditionalFact]
     public virtual void Can_query_using_substr_function()
     {
