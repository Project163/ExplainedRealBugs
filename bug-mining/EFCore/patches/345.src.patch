diff --git a/src/EFCore/Metadata/Builders/CollectionCollectionBuilder.cs b/src/EFCore/Metadata/Builders/CollectionCollectionBuilder.cs
index 8b6f569c16..d552774a44 100644
--- a/src/EFCore/Metadata/Builders/CollectionCollectionBuilder.cs
+++ b/src/EFCore/Metadata/Builders/CollectionCollectionBuilder.cs
@@ -407,6 +407,7 @@ protected virtual InternalModelBuilder ModelBuilder
 
         var existingJoinEntityType = (EntityType?)(LeftNavigation.JoinEntityType ?? RightNavigation.JoinEntityType);
         EntityType? newJoinEntityType = null;
+        EntityType.Snapshot? entityTypeSnapshot = null;
         if (existingJoinEntityType != null)
         {
             if ((joinEntityType == null || existingJoinEntityType.ClrType == joinEntityType)
@@ -416,7 +417,13 @@ protected virtual InternalModelBuilder ModelBuilder
             }
             else
             {
-                ModelBuilder.RemoveImplicitJoinEntity(existingJoinEntityType);
+                ModelBuilder.RemoveImplicitJoinEntity(existingJoinEntityType, configurationSource: ConfigurationSource.DataAnnotation);
+
+                entityTypeSnapshot = InternalEntityTypeBuilder.DetachAllMembers(existingJoinEntityType);
+                if (entityTypeSnapshot != null)
+                {
+                    ModelBuilder.HasNoEntityType(existingJoinEntityType, ConfigurationSource.Explicit);
+                }
             }
         }
 
@@ -440,15 +447,36 @@ protected virtual InternalModelBuilder ModelBuilder
             }
         }
 
-        var rightForeignKey = configureRight != null
-            ? configureRight(newJoinEntityType)
-            : GetOrCreateSkipNavigationForeignKey((SkipNavigation)RightNavigation, newJoinEntityType);
-        var leftForeignKey = configureLeft != null
-            ? configureLeft(newJoinEntityType)
-            : GetOrCreateSkipNavigationForeignKey((SkipNavigation)LeftNavigation, newJoinEntityType);
+        if (entityTypeSnapshot != null)
+        {
+            entityTypeSnapshot.Attach(newJoinEntityType.Builder);
+        }
 
+        IMutableForeignKey? rightForeignKey;
+        if (configureRight != null)
+        {
+            newJoinEntityType.SetAnnotation(CoreAnnotationNames.SkipNavigationBeingConfigured, RightNavigation);
+            rightForeignKey = configureRight(newJoinEntityType);
+            newJoinEntityType.RemoveAnnotation(CoreAnnotationNames.SkipNavigationBeingConfigured);
+        }
+        else
+        {
+            rightForeignKey = GetOrCreateSkipNavigationForeignKey((SkipNavigation)RightNavigation, newJoinEntityType);
+        }
         ((SkipNavigation)RightNavigation).Builder
             .HasForeignKey((ForeignKey)rightForeignKey, ConfigurationSource.Explicit);
+
+        IMutableForeignKey? leftForeignKey;
+        if (configureLeft != null)
+        {
+            newJoinEntityType.SetAnnotation(CoreAnnotationNames.SkipNavigationBeingConfigured, LeftNavigation);
+            leftForeignKey = configureLeft(newJoinEntityType);
+            newJoinEntityType.RemoveAnnotation(CoreAnnotationNames.SkipNavigationBeingConfigured);
+        }
+        else
+        {
+            leftForeignKey = GetOrCreateSkipNavigationForeignKey((SkipNavigation)LeftNavigation, newJoinEntityType);
+        }
         ((SkipNavigation)LeftNavigation).Builder
             .HasForeignKey((ForeignKey)leftForeignKey, ConfigurationSource.Explicit);
 
diff --git a/src/EFCore/Metadata/Builders/EntityTypeBuilder.cs b/src/EFCore/Metadata/Builders/EntityTypeBuilder.cs
index d502f695f9..42f81db7f4 100644
--- a/src/EFCore/Metadata/Builders/EntityTypeBuilder.cs
+++ b/src/EFCore/Metadata/Builders/EntityTypeBuilder.cs
@@ -1055,8 +1055,7 @@ private OwnedNavigationBuilder OwnsManyBuilder(in TypeIdentity ownedType, string
         Check.NullButNotEmpty(navigationName, nameof(navigationName));
 
         var relatedEntityType = FindRelatedEntityType(relatedTypeName, navigationName);
-        var foreignKey = HasOneBuilder(
-            MemberIdentity.Create(navigationName), relatedEntityType);
+        var foreignKey = HasOneBuilder(MemberIdentity.Create(navigationName), relatedEntityType);
 
         return new ReferenceNavigationBuilder(
             Builder.Metadata,
@@ -1098,8 +1097,7 @@ private OwnedNavigationBuilder OwnsManyBuilder(in TypeIdentity ownedType, string
         Check.NullButNotEmpty(navigationName, nameof(navigationName));
 
         var relatedEntityType = FindRelatedEntityType(relatedType, navigationName);
-        var foreignKey = HasOneBuilder(
-            MemberIdentity.Create(navigationName), relatedEntityType);
+        var foreignKey = HasOneBuilder(MemberIdentity.Create(navigationName), relatedEntityType);
 
         return new ReferenceNavigationBuilder(
             Builder.Metadata,
@@ -1145,6 +1143,17 @@ public virtual ReferenceNavigationBuilder HasOne(string? navigationName)
         MemberIdentity navigationId,
         EntityType relatedEntityType)
     {
+        if (Metadata[CoreAnnotationNames.SkipNavigationBeingConfigured] is SkipNavigation skipNavigation
+            && skipNavigation.DeclaringEntityType == relatedEntityType
+            && skipNavigation.ForeignKey?.DeclaringEntityType == Builder.Metadata)
+        {
+            return navigationId.MemberInfo != null
+                ? skipNavigation.ForeignKey.Builder.HasNavigation(navigationId.MemberInfo, pointsToPrincipal: true, ConfigurationSource.Explicit)
+                    !.Metadata
+                : skipNavigation.ForeignKey.Builder.HasNavigation(navigationId.Name, pointsToPrincipal: true, ConfigurationSource.Explicit)
+                    !.Metadata;
+        }
+
         ForeignKey foreignKey;
         if (navigationId.MemberInfo != null)
         {
diff --git a/src/EFCore/Metadata/Builders/EntityTypeBuilder`.cs b/src/EFCore/Metadata/Builders/EntityTypeBuilder`.cs
index b9644c1234..3cee16b13e 100644
--- a/src/EFCore/Metadata/Builders/EntityTypeBuilder`.cs
+++ b/src/EFCore/Metadata/Builders/EntityTypeBuilder`.cs
@@ -1336,8 +1336,7 @@ public virtual EntityTypeBuilder<TEntity> OwnsMany
         where TRelatedEntity : class
     {
         var relatedEntityType = FindRelatedEntityType(typeof(TRelatedEntity), navigationName);
-        var foreignKey = HasOneBuilder(
-            MemberIdentity.Create(navigationName), relatedEntityType);
+        var foreignKey = HasOneBuilder(MemberIdentity.Create(navigationName), relatedEntityType);
 
         return new ReferenceNavigationBuilder<TEntity, TRelatedEntity>(
             Builder.Metadata,
@@ -1381,8 +1380,7 @@ public virtual EntityTypeBuilder<TEntity> OwnsMany
     {
         var navigationMember = navigationExpression?.GetMemberAccess();
         var relatedEntityType = FindRelatedEntityType(typeof(TRelatedEntity), navigationMember?.GetSimpleMemberName());
-        var foreignKey = HasOneBuilder(
-            MemberIdentity.Create(navigationMember), relatedEntityType);
+        var foreignKey = HasOneBuilder(MemberIdentity.Create(navigationMember), relatedEntityType);
 
         return new ReferenceNavigationBuilder<TEntity, TRelatedEntity>(
             Builder.Metadata,
diff --git a/src/EFCore/Metadata/Builders/OwnedNavigationBuilder.cs b/src/EFCore/Metadata/Builders/OwnedNavigationBuilder.cs
index fbd8c0d166..3707a4be3e 100644
--- a/src/EFCore/Metadata/Builders/OwnedNavigationBuilder.cs
+++ b/src/EFCore/Metadata/Builders/OwnedNavigationBuilder.cs
@@ -861,14 +861,13 @@ private OwnedNavigationBuilder OwnsManyBuilder(in TypeIdentity ownedType, string
         Check.NullButNotEmpty(navigationName, nameof(navigationName));
 
         var relatedEntityType = FindRelatedEntityType(relatedTypeName, navigationName);
+        var foreignKey = HasOneBuilder(MemberIdentity.Create(navigationName), relatedEntityType);
 
         return new ReferenceNavigationBuilder(
             DependentEntityType,
             relatedEntityType,
             navigationName,
-            DependentEntityType.Builder.HasRelationship(
-                relatedEntityType, navigationName, ConfigurationSource.Explicit,
-                targetIsPrincipal: DependentEntityType == relatedEntityType ? true : null)!.Metadata);
+            foreignKey);
     }
 
     /// <summary>
@@ -936,14 +935,41 @@ public virtual ReferenceNavigationBuilder HasOne(string navigationName)
         Check.NullButNotEmpty(navigationName, nameof(navigationName));
 
         var relatedEntityType = FindRelatedEntityType(relatedType, navigationName);
+        var foreignKey = HasOneBuilder(MemberIdentity.Create(navigationName), relatedEntityType);
 
         return new ReferenceNavigationBuilder(
             DependentEntityType,
             relatedEntityType,
             navigationName,
-            DependentEntityType.Builder.HasRelationship(
-                relatedEntityType, navigationName, ConfigurationSource.Explicit,
-                targetIsPrincipal: DependentEntityType == relatedEntityType ? true : null)!.Metadata);
+            foreignKey);
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    [EntityFrameworkInternal]
+    protected virtual ForeignKey HasOneBuilder(
+        MemberIdentity navigationId,
+        EntityType relatedEntityType)
+    {
+        ForeignKey foreignKey;
+        if (navigationId.MemberInfo != null)
+        {
+            foreignKey = DependentEntityType.Builder.HasRelationship(
+                relatedEntityType, navigationId.MemberInfo, ConfigurationSource.Explicit,
+                targetIsPrincipal: DependentEntityType == relatedEntityType ? true : null)!.Metadata;
+        }
+        else
+        {
+            foreignKey = DependentEntityType.Builder.HasRelationship(
+                relatedEntityType, navigationId.Name, ConfigurationSource.Explicit,
+                targetIsPrincipal: DependentEntityType == relatedEntityType ? true : null)!.Metadata;
+        }
+
+        return foreignKey;
     }
 
     /// <summary>
diff --git a/src/EFCore/Metadata/Builders/OwnedNavigationBuilder`.cs b/src/EFCore/Metadata/Builders/OwnedNavigationBuilder`.cs
index c68773f981..fb30a60352 100644
--- a/src/EFCore/Metadata/Builders/OwnedNavigationBuilder`.cs
+++ b/src/EFCore/Metadata/Builders/OwnedNavigationBuilder`.cs
@@ -1104,14 +1104,13 @@ public new virtual IndexBuilder<TDependentEntity> HasIndex(params string[] prope
         where TNewRelatedEntity : class
     {
         var relatedEntityType = FindRelatedEntityType(typeof(TNewRelatedEntity), navigationName);
+        var foreignKey = HasOneBuilder(MemberIdentity.Create(navigationName), relatedEntityType);
 
         return new ReferenceNavigationBuilder<TDependentEntity, TNewRelatedEntity>(
             DependentEntityType,
             relatedEntityType,
             navigationName,
-            DependentEntityType.Builder.HasRelationship(
-                relatedEntityType, navigationName, ConfigurationSource.Explicit,
-                targetIsPrincipal: DependentEntityType == relatedEntityType ? true : null)!.Metadata);
+            foreignKey);
     }
 
     /// <summary>
@@ -1147,16 +1146,15 @@ public new virtual IndexBuilder<TDependentEntity> HasIndex(params string[] prope
             Expression<Func<TDependentEntity, TNewRelatedEntity?>>? navigationExpression = null)
         where TNewRelatedEntity : class
     {
-        var navigation = navigationExpression?.GetMemberAccess();
-        var relatedEntityType = FindRelatedEntityType(typeof(TNewRelatedEntity), navigation?.GetSimpleMemberName());
+        var navigationMember = navigationExpression?.GetMemberAccess();
+        var relatedEntityType = FindRelatedEntityType(typeof(TNewRelatedEntity), navigationMember?.GetSimpleMemberName());
+        var foreignKey = HasOneBuilder(MemberIdentity.Create(navigationMember), relatedEntityType);
 
         return new ReferenceNavigationBuilder<TDependentEntity, TNewRelatedEntity>(
             DependentEntityType,
             relatedEntityType,
-            navigation,
-            DependentEntityType.Builder.HasRelationship(
-                relatedEntityType, navigation, ConfigurationSource.Explicit,
-                targetIsPrincipal: DependentEntityType == relatedEntityType ? true : null)!.Metadata);
+            navigationMember,
+            foreignKey);
     }
 
     /// <summary>
diff --git a/src/EFCore/Metadata/Conventions/KeyDiscoveryConvention.cs b/src/EFCore/Metadata/Conventions/KeyDiscoveryConvention.cs
index 26c67fe323..14729e821a 100644
--- a/src/EFCore/Metadata/Conventions/KeyDiscoveryConvention.cs
+++ b/src/EFCore/Metadata/Conventions/KeyDiscoveryConvention.cs
@@ -279,7 +279,8 @@ protected virtual void TryConfigurePrimaryKey(IConventionEntityTypeBuilder entit
         IConventionContext<IReadOnlyList<IConventionProperty>> context)
     {
         var foreignKey = relationshipBuilder.Metadata;
-        if (foreignKey.IsOwnership
+        if ((foreignKey.IsOwnership
+            || foreignKey.GetReferencingSkipNavigations().Any(n => n.IsCollection))
             && !foreignKey.Properties.SequenceEqual(oldDependentProperties)
             && relationshipBuilder.Metadata.IsInModel)
         {
diff --git a/src/EFCore/Metadata/Internal/CoreAnnotationNames.cs b/src/EFCore/Metadata/Internal/CoreAnnotationNames.cs
index 17559381dc..54d3468337 100644
--- a/src/EFCore/Metadata/Internal/CoreAnnotationNames.cs
+++ b/src/EFCore/Metadata/Internal/CoreAnnotationNames.cs
@@ -348,6 +348,14 @@ public static class CoreAnnotationNames
     /// </summary>
     public const string ElementType = "ElementType";
 
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public const string SkipNavigationBeingConfigured = "SkipNavigationBeingConfigured";
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -399,6 +407,7 @@ public static class CoreAnnotationNames
         FullChangeTrackingNotificationsRequired,
         AdHocModel,
         JsonValueReaderWriterType,
-        ElementType
+        ElementType,
+        SkipNavigationBeingConfigured
     };
 }
diff --git a/src/EFCore/Metadata/Internal/InternalModelBuilder.cs b/src/EFCore/Metadata/Internal/InternalModelBuilder.cs
index 2313d82414..430d649c63 100644
--- a/src/EFCore/Metadata/Internal/InternalModelBuilder.cs
+++ b/src/EFCore/Metadata/Internal/InternalModelBuilder.cs
@@ -385,16 +385,13 @@ public override InternalModelBuilder ModelBuilder
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    public virtual InternalModelBuilder? RemoveImplicitJoinEntity(EntityType joinEntityType)
-    {
-        Check.NotNull(joinEntityType, nameof(joinEntityType));
-
-        return !joinEntityType.IsInModel
+    public virtual InternalModelBuilder? RemoveImplicitJoinEntity(
+        EntityType joinEntityType, ConfigurationSource configurationSource = ConfigurationSource.Convention)
+        => !Check.NotNull(joinEntityType, nameof(joinEntityType)).IsInModel
             ? this
             : !joinEntityType.IsImplicitlyCreatedJoinEntityType
                 ? null
-                : HasNoEntityType(joinEntityType, ConfigurationSource.Convention);
-    }
+                : HasNoEntityType(joinEntityType, configurationSource);
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
diff --git a/src/EFCore/Metadata/Internal/InternalSkipNavigationBuilder.cs b/src/EFCore/Metadata/Internal/InternalSkipNavigationBuilder.cs
index a59efb9799..a5bef15398 100644
--- a/src/EFCore/Metadata/Internal/InternalSkipNavigationBuilder.cs
+++ b/src/EFCore/Metadata/Internal/InternalSkipNavigationBuilder.cs
@@ -68,7 +68,7 @@ protected override InternalSkipNavigationBuilder This
             && oldForeignKey != foreignKey
             && oldForeignKey.ReferencingSkipNavigations?.Any() != true)
         {
-            oldForeignKey.DeclaringEntityType.Builder.HasNoRelationship(oldForeignKey, ConfigurationSource.Convention);
+            oldForeignKey.DeclaringEntityType.Builder.HasNoRelationship(oldForeignKey, ConfigurationSource.Explicit);
         }
 
         return this;
diff --git a/test/EFCore.Cosmos.FunctionalTests/ModelBuilding/CosmosModelBuilderGenericTest.cs b/test/EFCore.Cosmos.FunctionalTests/ModelBuilding/CosmosModelBuilderGenericTest.cs
index a527ee2af5..533575f1ed 100644
--- a/test/EFCore.Cosmos.FunctionalTests/ModelBuilding/CosmosModelBuilderGenericTest.cs
+++ b/test/EFCore.Cosmos.FunctionalTests/ModelBuilding/CosmosModelBuilderGenericTest.cs
@@ -920,6 +920,14 @@ public virtual void Can_use_shared_type_as_join_entity_with_partition_keys()
                     mb.HasPartitionKey("PartitionId");
                 });
 
+            modelBuilder.Entity<ManyToManyNavPrincipal>()
+                .HasMany(e => e.Dependents)
+                .WithMany(e => e.ManyToManyPrincipals)
+                .UsingEntity<Dictionary<string, object>>(
+                    "JoinType",
+                    e => e.HasOne<NavDependent>().WithMany().HasAnnotation("Right", "Foo"),
+                    e => e.HasOne<ManyToManyNavPrincipal>().WithMany().HasAnnotation("Left", "Bar"));
+
             modelBuilder.Entity<ManyToManyNavPrincipal>()
                 .HasMany(e => e.Dependents)
                 .WithMany(e => e.ManyToManyPrincipals)
@@ -927,16 +935,15 @@ public virtual void Can_use_shared_type_as_join_entity_with_partition_keys()
                     "JoinType",
                     e => e.HasOne<NavDependent>().WithMany().HasForeignKey("DependentId", "PartitionId"),
                     e => e.HasOne<ManyToManyNavPrincipal>().WithMany().HasForeignKey("PrincipalId", "PartitionId"),
-                    e =>
-                    {
-                        e.HasPartitionKey("PartitionId");
-                    });
+                    e => e.HasPartitionKey("PartitionId"));
 
             var model = modelBuilder.FinalizeModel();
 
             var joinType = model.FindEntityType("JoinType")!;
             Assert.NotNull(joinType);
-            Assert.Equal(2, joinType.GetForeignKeys().Count());
+            Assert.Collection(joinType.GetForeignKeys(),
+                fk => Assert.Equal("Foo", fk["Right"]),
+                fk => Assert.Equal("Bar", fk["Left"]));
             Assert.Equal(3, joinType.FindPrimaryKey()!.Properties.Count);
             Assert.Equal(6, joinType.GetProperties().Count());
             Assert.Equal("DbContext", joinType.GetContainer());
diff --git a/test/EFCore.Cosmos.FunctionalTests/TestUtilities/CosmosModelAsserter.cs b/test/EFCore.Cosmos.FunctionalTests/TestUtilities/CosmosModelAsserter.cs
index 1b73d9b1e1..39ebe9ee0e 100644
--- a/test/EFCore.Cosmos.FunctionalTests/TestUtilities/CosmosModelAsserter.cs
+++ b/test/EFCore.Cosmos.FunctionalTests/TestUtilities/CosmosModelAsserter.cs
@@ -19,8 +19,8 @@ protected CosmosModelAsserter()
         bool assertOrder = false,
         bool compareAnnotations = false)
     {
-        expectedProperties = expectedProperties.Where(p => p.Name != "__jObject" && p.Name != "__id");
-        actualProperties = actualProperties.Where(p => p.Name != "__jObject" && p.Name != "__id");
+        expectedProperties = expectedProperties.Where(p => p.Name != "__jObject" && p.Name != "__id" && p.Name != "Discriminator");
+        actualProperties = actualProperties.Where(p => p.Name != "__jObject" && p.Name != "__id" && p.Name != "Discriminator");
 
         base.AssertEqual(expectedProperties, actualProperties, assertOrder, compareAnnotations);
     }
diff --git a/test/EFCore.Relational.Specification.Tests/ModelBuilding/RelationalModelBuilderTest.cs b/test/EFCore.Relational.Specification.Tests/ModelBuilding/RelationalModelBuilderTest.cs
index ade65a48d1..5136547374 100644
--- a/test/EFCore.Relational.Specification.Tests/ModelBuilding/RelationalModelBuilderTest.cs
+++ b/test/EFCore.Relational.Specification.Tests/ModelBuilding/RelationalModelBuilderTest.cs
@@ -3,6 +3,8 @@
 
 #nullable enable
 
+using System.ComponentModel.DataAnnotations;
+using System.ComponentModel.DataAnnotations.Schema;
 using System.Data;
 
 // ReSharper disable InconsistentNaming
@@ -708,7 +710,7 @@ public virtual void Can_use_table_splitting()
 
     public abstract class RelationalOneToManyTestBase : OneToManyTestBase
     {
-        public RelationalOneToManyTestBase(RelationalModelBuilderFixture fixture)
+        protected RelationalOneToManyTestBase(RelationalModelBuilderFixture fixture)
             : base(fixture)
         {
         }
@@ -716,7 +718,7 @@ public RelationalOneToManyTestBase(RelationalModelBuilderFixture fixture)
 
     public abstract class RelationalManyToOneTestBase : ManyToOneTestBase
     {
-        public RelationalManyToOneTestBase(RelationalModelBuilderFixture fixture)
+        protected RelationalManyToOneTestBase(RelationalModelBuilderFixture fixture)
             : base(fixture)
         {
         }
@@ -724,7 +726,7 @@ public RelationalManyToOneTestBase(RelationalModelBuilderFixture fixture)
 
     public abstract class RelationalOneToOneTestBase : OneToOneTestBase
     {
-        public RelationalOneToOneTestBase(RelationalModelBuilderFixture fixture)
+        protected RelationalOneToOneTestBase(RelationalModelBuilderFixture fixture)
             : base(fixture)
         {
         }
@@ -732,15 +734,149 @@ public RelationalOneToOneTestBase(RelationalModelBuilderFixture fixture)
 
     public abstract class RelationalManyToManyTestBase : ManyToManyTestBase
     {
-        public RelationalManyToManyTestBase(RelationalModelBuilderFixture fixture)
+        protected RelationalManyToManyTestBase(RelationalModelBuilderFixture fixture)
             : base(fixture)
         {
         }
+
+        [ConditionalFact] // Issue #27990
+        public virtual void Can_use_ForeignKeyAttribute_with_InversePropertyAttribute()
+        {
+            var modelBuilder = CreateModelBuilder();
+                    
+            modelBuilder.Entity<MotorArt>(
+                entity =>
+                {
+                    entity.HasMany(d => d.MotorBauArt)
+                        .WithMany(p => p.MotorArt)
+                        .UsingEntity<Dictionary<string, object>>("MotorArtXMotorBauart");
+                });
+
+            var model = modelBuilder.FinalizeModel();
+
+            Assert.Collection(model.GetEntityTypes(),
+                e =>
+                {
+                    Assert.Equal("FuelTypeMotorArt", e.ShortName());
+                    Assert.Collection(e.GetProperties(), p => Assert.Equal("FuelTypeId", p.Name), p => Assert.Equal("MotorArtId", p.Name));
+                    Assert.Collection(e.GetKeys(), k =>Assert.Collection(k.Properties,
+                        p => Assert.Equal("FuelTypeId", p.Name),
+                        p => Assert.Equal("MotorArtId", p.Name)));
+                    Assert.Collection(e.GetForeignKeys(), k =>
+                    {
+                        Assert.Equal("FuelType", k.PrincipalEntityType.ShortName());
+                        Assert.Collection(k.Properties, p => Assert.Equal("FuelTypeId", p.Name));
+                        Assert.Collection(k.PrincipalKey.Properties, p => Assert.Equal("FuelTypeId", p.Name));
+                    }, k =>
+                    {
+                        Assert.Equal("MotorArt", k.PrincipalEntityType.ShortName());
+                        Assert.Collection(k.Properties, p => Assert.Equal("MotorArtId", p.Name));
+                        Assert.Collection(k.PrincipalKey.Properties, p => Assert.Equal("MotorArtId", p.Name));
+                    });
+                    Assert.Empty(e.GetNavigations());
+                    Assert.Empty(e.GetSkipNavigations());
+                },
+                e =>
+                {
+                    Assert.Equal("FuelType", e.ShortName());
+                    Assert.Collection(e.GetKeys(), k =>Assert.Collection(k.Properties, p => Assert.Equal("FuelTypeId", p.Name)));
+                    Assert.Collection(e.GetProperties(), p => Assert.Equal("FuelTypeId", p.Name), p => Assert.Equal("Bezeichnung", p.Name));
+                    Assert.Empty(e.GetForeignKeys());
+                    Assert.Empty(e.GetNavigations());
+                    Assert.Collection(e.GetSkipNavigations(), n => Assert.Equal("MotorArt", n.Name));
+                },
+                e =>
+                {
+                    Assert.Equal("MotorArt", e.ShortName());
+                    Assert.Collection(e.GetKeys(), k =>Assert.Collection(k.Properties, p => Assert.Equal("MotorArtId", p.Name)));
+                    Assert.Collection(e.GetProperties(), p => Assert.Equal("MotorArtId", p.Name));
+                    Assert.Empty(e.GetForeignKeys());
+                    Assert.Empty(e.GetNavigations());
+                    Assert.Collection(e.GetSkipNavigations(),
+                        n => Assert.Equal("FuelType", n.Name),
+                        n => Assert.Equal("MotorBauArt", n.Name));
+                },
+                e =>
+                {
+                    Assert.Equal("MotorBauart", e.ShortName());
+                    Assert.Collection(e.GetKeys(), k =>Assert.Collection(k.Properties, p => Assert.Equal("MotorBauartId", p.Name)));
+                    Assert.Collection(e.GetProperties(), p => Assert.Equal("MotorBauartId", p.Name));
+                    Assert.Empty(e.GetForeignKeys());
+                    Assert.Empty(e.GetNavigations());
+                    Assert.Collection(e.GetSkipNavigations(), n => Assert.Equal("MotorArt", n.Name));
+                },
+                e =>
+                {
+                    Assert.Equal("MotorArtXMotorBauart", e.ShortName());
+                    Assert.Collection(e.GetProperties(),
+                        p => Assert.Equal("MotorArtId", p.Name),
+                        p => Assert.Equal("MotorBauArtId", p.Name));
+                    Assert.Collection(e.GetKeys(), k =>Assert.Collection(k.Properties,
+                        p => Assert.Equal("MotorArtId", p.Name),
+                        p => Assert.Equal("MotorBauArtId", p.Name)));
+                    Assert.Collection(e.GetForeignKeys(), k =>
+                    {
+                        Assert.Equal("MotorArt", k.PrincipalEntityType.ShortName());
+                        Assert.Collection(k.Properties, p => Assert.Equal("MotorArtId", p.Name));
+                        Assert.Collection(k.PrincipalKey.Properties, p => Assert.Equal("MotorArtId", p.Name));
+                    }, k =>
+                    {
+                        Assert.Equal("MotorBauart", k.PrincipalEntityType.ShortName());
+                        Assert.Collection(k.Properties, p => Assert.Equal("MotorBauArtId", p.Name));
+                        Assert.Collection(k.PrincipalKey.Properties, p => Assert.Equal("MotorBauartId", p.Name));
+                    });
+                    Assert.Empty(e.GetNavigations());
+                    Assert.Empty(e.GetSkipNavigations());
+                });
+        }
+
+        [Table("FuelType", Schema = "dbo")]
+        [Index("Bezeichnung", Name = "Key_Fueltype", IsUnique = true)]
+        protected class FuelType
+        {
+            [Key]
+            public int FuelTypeId { get; set; }
+
+            [StringLength(255)]
+            public string Bezeichnung { get; set; } = null!;
+
+            [ForeignKey("FuelTypeId")]
+            [InverseProperty("FuelType")]
+            public virtual ICollection<MotorArt> MotorArt { get; set; } = new HashSet<MotorArt>();
+        }
+
+        [Table("MotorArt", Schema = "Bib")]
+        protected class MotorArt
+        {
+            [Key]
+            public int MotorArtId { get; set; }
+
+            [StringLength(255)]
+            [ForeignKey("MotorArtId")]
+            [InverseProperty("MotorArt")]
+            public virtual ICollection<FuelType> FuelType { get; set; } = new HashSet<FuelType>();
+
+            [ForeignKey("MotorArtId")]
+            [InverseProperty("MotorArt")]
+            public virtual ICollection<MotorBauart> MotorBauArt { get; set; } = new HashSet<MotorBauart>();
+        }
+
+        [Table("MotorBauart", Schema = "Bib")]
+        protected class MotorBauart
+        {
+            [Key]
+            public int MotorBauartId { get; set; }
+
+            [ForeignKey("MotorBauArtId")]
+            [InverseProperty("MotorBauArt")]
+            public virtual ICollection<MotorArt> MotorArt { get; set; } = new HashSet<MotorArt>();
+        }
+
     }
 
     public abstract class RelationalOwnedTypesTestBase : OwnedTypesTestBase
     {
-        public RelationalOwnedTypesTestBase(RelationalModelBuilderFixture fixture)
+        protected RelationalOwnedTypesTestBase(RelationalModelBuilderFixture fixture)
             : base(fixture)
         {
         }
diff --git a/test/EFCore.Specification.Tests/ModelBuilding/ModelBuilderTest.ManyToMany.cs b/test/EFCore.Specification.Tests/ModelBuilding/ModelBuilderTest.ManyToMany.cs
index 4a4a29c246..7e2e190ec8 100644
--- a/test/EFCore.Specification.Tests/ModelBuilding/ModelBuilderTest.ManyToMany.cs
+++ b/test/EFCore.Specification.Tests/ModelBuilding/ModelBuilderTest.ManyToMany.cs
@@ -13,7 +13,7 @@ public abstract partial class ModelBuilderTest
 {
     public abstract class ManyToManyTestBase : ModelBuilderTestBase
     {
-        public ManyToManyTestBase(ModelBuilderFixtureBase fixture)
+        protected ManyToManyTestBase(ModelBuilderFixtureBase fixture)
             : base(fixture)
         {
         }
@@ -718,6 +718,150 @@ protected class CategoryWithAttribute
             public virtual ICollection<ProductWithAttribute>? Products { get; set; }
         }
 
+        [ConditionalFact] // Issue #27990
+        public virtual void ForeignKeyAttribute_does_not_force_convention_join_table_inclusion_matching_key_names()
+        {
+            var modelBuilder = CreateModelBuilder();
+
+            modelBuilder.Entity<MotorArtMatching>(
+                entity =>
+                {
+                    entity.HasMany(d => d.MotorBauArtMatching)
+                        .WithMany(p => p.MotorArtMatching)
+                        .UsingEntity<Dictionary<string, object>>("MotorArtXMotorBauartMatching");
+                });
+
+            var model = modelBuilder.FinalizeModel();
+
+            Assert.Equal(3, model.GetEntityTypes().Count());
+
+            Assert.Collection(model.GetEntityTypes(),
+                e =>
+                {
+                    Assert.Equal("MotorArtMatching", e.ShortName());
+                    AssertEqual(new[] { e.FindProperty("MotorArtMatchingId")! }, e.GetProperties());
+                    Assert.Empty(e.GetForeignKeys());
+                    Assert.Empty(e.GetNavigations());
+                    Assert.Collection(e.GetSkipNavigations(), n => Assert.Equal("MotorBauArtMatching", n.Name));
+                },
+                e =>
+                {
+                    Assert.Equal("MotorBauartMatching", e.ShortName());
+                    AssertEqual(new[] { e.FindProperty("MotorBauartMatchingId")! }, e.GetProperties());
+                    Assert.Empty(e.GetForeignKeys());
+                    Assert.Empty(e.GetNavigations());
+                    Assert.Collection(e.GetSkipNavigations(), n => Assert.Equal("MotorArtMatching", n.Name));
+                },
+                e =>
+                {
+                    Assert.Equal("MotorArtXMotorBauartMatching", e.ShortName());
+                    Assert.Collection(e.GetForeignKeys(),
+                        k =>
+                        {
+                            Assert.Equal("MotorArtMatching", k.PrincipalEntityType.ShortName());
+                            Assert.Collection(k.Properties, p => Assert.Equal("MotorArtMatchingId", p.Name));
+                            Assert.Collection(k.PrincipalKey.Properties, p => Assert.Equal("MotorArtMatchingId", p.Name));
+                        },
+                        k =>
+                        {
+                            Assert.Equal("MotorBauartMatching", k.PrincipalEntityType.ShortName());
+                            Assert.Collection(k.Properties, p => Assert.Equal("MotorBauartMatchingId", p.Name));
+                            Assert.Collection(k.PrincipalKey.Properties, p => Assert.Equal("MotorBauartMatchingId", p.Name));
+                        });
+                    AssertEqual(e.GetForeignKeys().SelectMany(fk => fk.Properties), e.GetProperties());
+                    Assert.Empty(e.GetNavigations());
+                    Assert.Empty(e.GetSkipNavigations());
+                });
+        }
+
+        protected class MotorArtMatching
+        {
+            public int MotorArtMatchingId { get; set; }
+
+            [ForeignKey("MotorArtMatchingId")]
+            public virtual ICollection<MotorBauartMatching> MotorBauArtMatching { get; set; } = null!;
+        }
+
+        protected class MotorBauartMatching
+        {
+            public int MotorBauartMatchingId { get; set; }
+
+            [ForeignKey("MotorBauartMatchingId")]
+            public virtual ICollection<MotorArtMatching> MotorArtMatching { get; set; } = null!;
+        }
+
+        [ConditionalFact] // Issue #27990
+        public virtual void ForeignKeyAttribute_does_not_force_convention_join_table_inclusion_mismatching_key_names()
+        {
+            var modelBuilder = CreateModelBuilder();
+
+            modelBuilder.Entity<MotorArtMismatching>(
+                entity =>
+                {
+                    entity.HasMany(d => d.MotorBauArtMismatching)
+                        .WithMany(p => p.MotorArtMismatching)
+                        .UsingEntity<Dictionary<string, object>>("MotorArtXMotorBauartMismatching");
+                });
+
+            var model = modelBuilder.FinalizeModel();
+
+            Assert.Equal(3, model.GetEntityTypes().Count());
+
+            Assert.Collection(model.GetEntityTypes(),
+                e =>
+                {
+                    Assert.Equal("MotorArtMismatching", e.ShortName());
+                    AssertEqual(new[] { e.FindProperty("MotorArtMismatchingId")! }, e.GetProperties());
+                    Assert.Empty(e.GetForeignKeys());
+                    Assert.Empty(e.GetNavigations());
+                    Assert.Collection(e.GetSkipNavigations(), n => Assert.Equal("MotorBauArtMismatching", n.Name));
+                },
+                e =>
+                {
+                    Assert.Equal("MotorBauartMismatching", e.ShortName());
+                    AssertEqual(new[] { e.FindProperty("MotorBauartMismatchingId")! }, e.GetProperties());
+                    Assert.Empty(e.GetForeignKeys());
+                    Assert.Empty(e.GetNavigations());
+                    Assert.Collection(e.GetSkipNavigations(), n => Assert.Equal("MotorArtMismatching", n.Name));
+                },
+                e =>
+                {
+                    Assert.Equal("MotorArtXMotorBauartMismatching", e.ShortName());
+                    Assert.Collection(e.GetForeignKeys(),
+                        k =>
+                        {
+                            Assert.Equal("MotorArtMismatching", k.PrincipalEntityType.ShortName());
+                            Assert.Collection(k.Properties, p => Assert.Equal("MotorArtMismatchingKey", p.Name));
+                            Assert.Collection(k.PrincipalKey.Properties, p => Assert.Equal("MotorArtMismatchingId", p.Name));
+                        },
+                        k =>
+                        {
+                            Assert.Equal("MotorBauartMismatching", k.PrincipalEntityType.ShortName());
+                            Assert.Collection(k.Properties, p => Assert.Equal("MotorBauArtMismatchingKey", p.Name));
+                            Assert.Collection(k.PrincipalKey.Properties, p => Assert.Equal("MotorBauartMismatchingId", p.Name));
+                        });
+                    AssertEqual(e.GetForeignKeys().SelectMany(fk => fk.Properties), e.GetProperties());
+                    Assert.Empty(e.GetNavigations());
+                    Assert.Empty(e.GetSkipNavigations());
+                });
+        }
+
+        protected class MotorArtMismatching
+        {
+            public int MotorArtMismatchingId { get; set; }
+
+            [ForeignKey("MotorArtMismatchingKey")]
+            public virtual ICollection<MotorBauartMismatching> MotorBauArtMismatching { get; set; } = null!;
+        }
+
+        protected class MotorBauartMismatching
+        {
+            public int MotorBauartMismatchingId { get; set; }
+
+            [ForeignKey("MotorBauArtMismatchingKey")]
+            public virtual ICollection<MotorArtMismatching> MotorArtMismatching { get; set; } = null!;
+        }
+
         [ConditionalFact]
         public virtual void Navigation_properties_can_set_access_mode()
         {
@@ -1042,6 +1186,13 @@ public virtual void Can_use_implicit_shared_type_with_default_name_and_implicit_
 
             modelBuilder.Ignore<OneToManyNavPrincipal>();
             modelBuilder.Ignore<OneToOneNavPrincipal>();
+            modelBuilder.Ignore<OneToManyPrincipalWithField>();
+            modelBuilder.Ignore<OneToOnePrincipalWithField>();
+
+            modelBuilder.Entity<ManyToManyNavPrincipal>()
+                .HasMany(e => e.Dependents)
+                .WithMany(e => e.ManyToManyPrincipals)
+                .UsingEntity<Dictionary<string, object>>("ManyToManyNavPrincipalNavDependentOld", j => j.HasAnnotation("Foo", "Bar"));
 
             modelBuilder.Entity<ManyToManyNavPrincipal>()
                 .HasMany(e => e.Dependents)
@@ -1054,11 +1205,9 @@ public virtual void Can_use_implicit_shared_type_with_default_name_and_implicit_
                 .UsingEntity(e => e.IndexerProperty<int>("Payload"));
 
             modelBuilder.Entity<ManyToManyPrincipalWithField>().HasKey(d => d.Id);
-            modelBuilder.Entity<OneToManyPrincipalWithField>().HasKey(d => d.Id);
-            modelBuilder.Entity<OneToOnePrincipalWithField>().HasKey(d => d.Id);
             modelBuilder.Entity<DependentWithField>().HasKey(d => d.DependentWithFieldId);
 
-            var model = modelBuilder.Model;
+            IReadOnlyModel model = modelBuilder.Model;
 
             var shared1 = model.FindEntityType(typeof(ManyToManyNavPrincipal))!
                 .FindSkipNavigation(nameof(ManyToManyNavPrincipal.Dependents))!.JoinEntityType!;
@@ -1073,6 +1222,7 @@ public virtual void Can_use_implicit_shared_type_with_default_name_and_implicit_
             Assert.True(shared1.HasSharedClrType);
             Assert.Equal(typeof(Dictionary<string, object>), shared1.ClrType);
             Assert.Equal("ManyToManyNavPrincipalNavDependent", shared1.Name);
+            Assert.Equal("Bar", shared1["Foo"]);
 
             var shared2 = model.FindEntityType(typeof(ManyToManyPrincipalWithField))!
                 .FindSkipNavigation(nameof(ManyToManyPrincipalWithField.Dependents))!.JoinEntityType!;
@@ -1093,7 +1243,10 @@ public virtual void Can_use_implicit_shared_type_with_default_name_and_implicit_
                 CoreStrings.ClashingSharedType(typeof(Dictionary<string, object>).ShortDisplayName()),
                 Assert.Throws<InvalidOperationException>(modelBuilder.Entity<Dictionary<string, object>>).Message);
 
-            AssertEqual(modelBuilder.Model, modelBuilder.FinalizeModel());
+            model = modelBuilder.FinalizeModel();
+            AssertEqual(modelBuilder.Model, model);
+
+            Assert.Equal(6, model.GetEntityTypes().Count());
         }
 
         [ConditionalFact]
